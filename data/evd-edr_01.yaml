- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">1</samp> <samp class="SANS_Dogma_OT_Bold_B_11">EDR-CHITECTURE</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">1</samp> <samp class="SANS_Dogma_OT_Bold_B_11">EDR架构</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: Virtually every adversary, whether they’re a malicious actor or part of a commercial
    red team, will sometimes run into defensive products that compromise their operations.
    Of these defensive products, endpoint detection and response (EDR) presents the
    largest risk to the post-exploitation phase of an attack. Generally speaking,
    *EDRs* are applications installed on a target’s workstations or servers that are
    designed to collect data about the security of the environment, called *telemetry*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个对手，无论是恶意行为者还是商业红队的一部分，有时都会遇到妨碍其操作的防御产品。在这些防御产品中，端点检测与响应（EDR）对攻击的后期利用阶段构成了最大的风险。一般来说，*EDR*是安装在目标工作站或服务器上的应用程序，旨在收集有关环境安全的数据，这些数据被称为*遥测*。
- en: In this chapter, we discuss the components of EDRs, their methods of detecting
    malicious activity on a system, and their typical designs. We also provide an
    overview of the difficulties that EDRs can cause attackers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了EDR的组成部分、它们检测系统中恶意活动的方法以及它们的典型设计。我们还提供了EDR可能给攻击者带来的困难的概述。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Components of an EDR</samp>
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">EDR的组成部分</samp>
- en: Later chapters will explore the nuts and bolts of many EDR sensor components,
    how they work, and how attackers might evade them. First, though, we’ll consider
    the EDR as a whole and define some terms that you’ll see frequently throughout
    the book.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 后续章节将探讨许多EDR传感器组件的具体细节，它们如何工作，以及攻击者如何规避它们。不过，首先，我们将整体考虑EDR并定义一些你在本书中经常看到的术语。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Agent</samp>
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">代理</samp>
- en: The EDR *agent* is an application that controls and consumes data from sensor
    components, performs some basic analysis to determine whether a given activity
    or series of events aligns with attacker behavior, and forwards the telemetry
    to the main server, which further analyzes events from all agents deployed in
    an environment.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: EDR *代理*是一个应用程序，它控制并消耗来自传感器组件的数据，进行一些基本分析以确定某个活动或一系列事件是否与攻击者行为一致，并将遥测数据转发到主服务器，后者进一步分析环境中所有代理收集的事件。
- en: 'If the agent deems some activity to be worthy of its attention, it may take
    any of the following actions: *log* that malicious activity in the form of an
    alert sent to a central logging system, such as the EDR’s dashboard or a security
    incident and event management (SIEM) solution; *block* the malicious operation’s
    execution by returning values indicating failure to the program that is performing
    the action; or *deceive* the attacker by returning to the caller invalid values,
    such as incorrect memory addresses or modified access masks, causing the offensive
    tooling to believe that the operation completed successfully even though subsequent
    operations will fail.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代理认为某些活动值得关注，它可能会采取以下任何操作：*记录*该恶意活动，并以警报的形式发送到中央日志系统，如EDR的仪表板或安全事件与信息管理（SIEM）解决方案；*阻止*恶意操作的执行，通过返回表示失败的值给正在执行该操作的程序；或*欺骗*攻击者，返回无效值，例如错误的内存地址或修改过的访问掩码，导致攻击工具相信操作已经成功完成，即使随后的操作会失败。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Telemetry</samp>
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">遥测</samp>
- en: 'Every sensor in an EDR serves a common purpose: the collection of telemetry.
    Roughly defined, *telemetry* is the raw data generated by a sensor component or
    the host itself, and defenders can analyze it to determine whether malicious activity
    has occurred. Every action on the system, from opening a file to creating a new
    process, generates some form of telemetry. This information becomes a datapoint
    in the security product’s internal alerting logic.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每个EDR传感器都服务于一个共同的目的：收集遥测数据。大致定义，*遥测*是由传感器组件或主机本身生成的原始数据，防御者可以分析这些数据来确定是否发生了恶意活动。系统上的每个操作，从打开文件到创建新进程，都会生成某种形式的遥测数据。这些信息成为安全产品内部警报逻辑中的数据点。
- en: '[Figure 1-1](#fig1-1) compares telemetry to the data collected by a radar system.
    Radars use electromagnetic waves to detect the presence, heading, and velocity
    of objects within some range.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1-1](#fig1-1)将遥测数据与雷达系统收集的数据进行比较。雷达使用电磁波来检测一定范围内物体的存在、方向和速度。'
- en: When a radio wave bounces off an object and returns to the radar system, it
    creates a datapoint indicating that there is something there. Using these datapoints,
    the radar system’s processor can determine things such as the object’s speed,
    location, and altitude and then handle each case differently. For instance, the
    system might need to respond to an object flying at a slow speed at lower altitudes
    differently from one flying at a fast speed at higher altitudes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当无线电波从物体上反射并返回雷达系统时，它会创建一个数据点，表示那里有东西。通过这些数据点，雷达系统的处理器可以确定诸如物体的速度、位置和高度等信息，并据此处理每个情况。例如，系统可能需要根据物体飞行的速度和高度来不同地响应：飞行在较低高度、速度较慢的物体与飞行在较高高度、速度较快的物体可能需要不同的响应。
- en: This is very similar to how an EDR handles the telemetry collected by its sensors.
    On its own, information about how a process was created or a file was accessed
    rarely provides enough context to make an informed decision regarding actions
    to be taken. They’re just blips on the radar display. Moreover, a process detected
    by an EDR can terminate at any point in time. Therefore, it is important for the
    telemetry feeding into the EDR to be as complete as possible.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 EDR 处理其传感器收集的遥测数据非常相似。仅凭关于一个进程是如何创建的或文件是如何被访问的信息，通常无法提供足够的上下文来做出有关采取何种措施的明智决策。它们就像雷达屏幕上的瞬间闪光点。此外，EDR
    检测到的进程可以在任何时刻终止。因此，传递给 EDR 的遥测数据必须尽可能完整。
- en: '![](../images/Figure1-1.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure1-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-1: Visualizing security
    events as radar blips</samp>'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 1-1：将安全事件可视化为雷达闪光点</samp>
- en: The EDR then passes the data to its detection logic. This detection logic takes
    all available telemetry and uses some internal method, such as environmental heuristics
    or static signature libraries, to attempt to ascertain whether the activity was
    benign or malicious and whether the activity meets its threshold for logging or
    prevention.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，EDR 将数据传递给其检测逻辑。该检测逻辑会利用所有可用的遥测数据，采用某些内部方法，如环境启发式算法或静态签名库，尝试判断该活动是良性还是恶意，以及该活动是否达到了记录或防止的阈值。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Sensors</samp>
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">传感器</samp>
- en: 'If telemetry represents the blips on the radar, then *sensors* are the transmitter,
    duplexer, and receiver: the components responsible for detecting objects and turning
    them into blips. Whereas radar systems constantly ping objects to track their
    movements, EDR sensors work a bit more passively by intercepting data flowing
    through an internal process, extracting information, and forwarding it to the
    central agent.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遥测数据代表雷达上的闪光点，那么 *传感器* 就是发射器、双工器和接收器：这些组件负责探测物体并将其转化为闪光点。与雷达系统不断发射信号以跟踪物体的运动不同，EDR
    传感器通过拦截流经内部进程的数据，提取信息并将其转发给中央代理，工作方式相对较为被动。
- en: Because these sensors often need to sit inline of some system process, they
    must also work incredibly fast. Imagine that a sensor monitoring registry queries
    took 5 ms to perform its work before the registry operation was allowed to continue.
    That doesn’t sound like much of a problem until you consider that thousands of
    registry queries can occur per second on some systems. A 5 ms processing penalty
    applied to 1,000 events would introduce a five-second delay to system operations.
    Most users would find this unacceptable, driving customers away from using the
    EDR altogether.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些传感器通常需要与某些系统进程并行工作，所以它们必须非常快速。假设一个监控注册表查询的传感器在允许注册表操作继续之前，需要花费 5 毫秒来完成工作。直到你考虑到某些系统每秒可能发生数千个注册表查询时，这个问题才显得重要。对
    1,000 个事件应用 5 毫秒的处理延迟，会导致系统操作出现 5 秒的延迟。大多数用户会觉得这是无法接受的，这将使客户远离使用 EDR。
- en: Although Windows has numerous telemetry sources available, EDRs typically focus
    on only a select few. This is because certain sources may lack data quality or
    quantity, may not be relevant to host security, or may not be easily accessible.
    Some sensors are built into the operating system, such as the native event log.
    EDRs may also introduce their own sensor components to the system, such as drivers,
    function-hooking DLLs, and minifilters, which we’ll discuss in later chapters.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Windows 提供了众多遥测数据源，但 EDR 通常只关注少数几个数据源。这是因为某些数据源可能缺乏数据质量或数量，可能与主机安全性无关，或可能不容易访问。一些传感器是内置于操作系统中的，例如本地事件日志。EDR
    也可能会向系统引入其自有的传感器组件，如驱动程序、函数挂钩 DLL 和微过滤器，我们将在后续章节中讨论。
- en: Those of us on the offensive side of things mostly care about preventing, limiting,
    or normalizing (as in blending in with) the flow of telemetry collected by the
    sensor. The goal of this tactic is to reduce the number of datapoints that the
    product could use to create high-fidelity alerts or prevent our operation from
    executing. Essentially, we’re trying to generate a false negative. By understanding
    each of an EDR’s sensor components and the telemetry it can collect, we can make
    informed decisions about the tradecraft to use in certain situations and develop
    robust evasion strategies backed by data rather than anecdotal evidence.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这些在进攻方的人通常关心的是如何防止、限制或规范化（即与其他流量融合）传感器收集到的遥测数据流。这个策略的目标是减少产品可以用来生成高保真警报的数据显示点数量，或者防止我们的操作被执行。本质上，我们在试图制造一个假阴性。通过了解EDR的每个传感器组件及其可以收集的遥测数据，我们可以在特定情况下做出关于使用何种手段的明智决策，并制定由数据支持的强大规避策略，而不是依赖轶事证据。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Detections</samp>
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">检测</samp>
- en: Simply put, *detections* are the logic that correlates discrete pieces of telemetry
    with some behavior performed on the system. A detection can check for a singular
    condition (for example, the presence of a file whose hash matches that of known
    malware) or a complex sequence of events coming from many different sources (for
    example, that a child process of *chrome.exe* was spawned and then communicated
    over TCP port 88 with the domain controller).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，*检测*是将离散的遥测数据与系统上执行的某些行为关联起来的逻辑。一个检测可以检查单一条件（例如，文件的哈希值与已知恶意软件匹配），或者检查来自多个不同来源的复杂事件序列（例如，*chrome.exe*的子进程被启动，并随后通过TCP端口88与域控制器通信）。
- en: Typically, a detection engineer writes these rules based on the available sensors.
    Some detection engineers work for the EDR vendor and so must carefully consider
    scale, as the detection will likely affect a substantial number of organizations.
    On the other hand, detection engineers working within an organization can build
    rules that extend the EDR’s capabilities beyond those that the vendor provides
    to tailor their detection to the needs of their environment.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，检测工程师根据可用的传感器编写这些规则。一些检测工程师为EDR供应商工作，因此必须仔细考虑规模问题，因为检测可能会影响大量组织。另一方面，工作在组织内部的检测工程师可以编写规则，扩展EDR的能力，超出供应商提供的功能，从而根据环境的需要量身定制检测。
- en: An EDR’s detection logic usually exists in the agent and its subordinate sensors
    or in the backend collection system (the system to which all agents in the enterprise
    report). Sometimes it is found in some combination of the two. There are pros
    and cons to each approach. A detection implemented in the agent or its sensors
    may allow the EDR to take immediate preventive action but won’t provide it with
    the ability to analyze a complex situation. By contrast, a detection implemented
    at the backend collection system can support a huge set of detection rules but
    introduces delays to any preventive action taken.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: EDR的检测逻辑通常存在于代理程序及其附属传感器中，或者存在于后端收集系统中（所有企业中的代理程序都向该系统报告）。有时它们会出现在两者的某种组合中。每种方法都有其优缺点。在代理程序或其传感器中实现的检测可以让EDR立即采取预防措施，但不能提供分析复杂情况的能力。相反，在后端收集系统中实现的检测可以支持大量的检测规则，但会导致采取任何预防措施时出现延迟。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Challenges of EDR Evasion</samp>
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">EDR规避的挑战</samp>
- en: Many adversaries rely on bypasses described anecdotally or in public proofs
    of concept to avoid detection on a target’s systems. This approach can be problematic
    for a number of reasons.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 许多对手依赖于通过轶事或公开的概念验证中描述的绕过方法，来避免目标系统的检测。这种方法可能由于多种原因而存在问题。
- en: First, those public bypasses only work if an EDR’s capabilities stay the same
    over time and across different organizations. This isn’t a huge issue for internal
    red teams, which likely encounter the same product deployed across their entire
    environment. For consultants and malicious threat actors, however, the evolution
    of EDR products poses a significant headache, as each environment’s software has
    its own configuration, heuristics, and alert logic. For example, an EDR might
    not scrutinize the execution of PsExec, a Windows remote-administration tool,
    in one organization if its use there is commonplace. But another organization
    might rarely use the tool, so its execution might indicate malicious activity.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这些公共绕过方式只有在EDR的功能在不同时间和不同组织中保持一致时才有效。对于内部红队来说，这不是一个大问题，因为它们很可能会在整个环境中遇到相同的产品。然而，对于顾问和恶意威胁行为者来说，EDR产品的演变则带来了重大头痛，因为每个环境的软件都有自己的配置、启发式规则和警报逻辑。例如，在某个组织中，如果PsExec（Windows远程管理工具）的使用很常见，EDR可能不会对PsExec的执行进行严格审查。但另一个组织可能很少使用该工具，因此其执行可能表明恶意活动。
- en: Second, these public evasion tools, blog posts, and papers often use the term
    *bypass* loosely. In many cases, their authors haven’t determined whether the
    EDR merely allowed some action to occur or didn’t detect it at all. Sometimes,
    rather than automatically blocking an action, an EDR triggers alerts that require
    human interaction, introducing a delay to the response. (Imagine that the alert
    fired at 3 AM on a Saturday, allowing the attacker to continue moving through
    the environment.) Most attackers hope to completely evade detection, as a mature
    security operations center (SOC) can efficiently hunt down the source of any malicious
    activity once an EDR detects it. This can be catastrophic to an attacker’s mission.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，这些公共规避工具、博客文章和论文经常宽松地使用*绕过*一词。在许多情况下，作者并未确定EDR仅仅允许某个操作发生，还是根本没有检测到它。有时候，EDR并不会自动阻止一个操作，而是触发需要人工干预的警报，从而引入响应延迟。（试想一下，如果警报是在星期六凌晨3点触发的，攻击者就可以继续在环境中移动。）大多数攻击者希望完全避免被检测，因为一旦EDR检测到恶意活动，成熟的安全运营中心（SOC）可以高效地追踪到恶意活动的源头。这对攻击者的任务来说可能是灾难性的。
- en: Third, researchers who disclose new techniques typically don’t name the products
    they tested, for a number of reasons. For instance, they might have signed a nondisclosure
    agreement with a client or worry that the affected vendor will threaten legal
    action. Consequentially, those researchers may think that some technique can bypass
    all EDRs instead of only a certain product and configuration. For example, a technique
    might evade user-mode function hooking in one product because the product happens
    not to monitor the targeted function, but another product might implement a hook
    that would detect the malicious API call.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，披露新技术的研究人员通常不会透露他们测试的产品，原因有很多。例如，他们可能与客户签署了保密协议，或者担心受到受影响厂商的法律威胁。因此，这些研究人员可能认为某些技术可以绕过所有EDR，而不仅仅是特定产品和配置。例如，一种技术可能会绕过某一产品中的用户模式函数挂钩，因为该产品恰好没有监控目标函数，但另一种产品可能实现了一个钩子，能够检测到恶意的API调用。
- en: Finally, researchers might not clarify which component of the EDR their technique
    evades. Modern EDRs are complex pieces of software with many sensor components,
    each of which can be bypassed in its own way. For example, an EDR might track
    suspicious parent–child process relationships by obtaining data from a kernel-mode
    driver, Event Tracing for Windows (ETW), function hooks, and a number of other
    sources. If an evasion technique targets an EDR agent that relies on ETW to collect
    its data, it may not work against a product that leverages its driver for the
    same purpose.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，研究人员可能不会明确说明他们的技术绕过了EDR的哪个组件。现代EDR是复杂的软件，拥有多个传感器组件，每个组件都可以以不同的方式被绕过。例如，EDR可能通过从内核模式驱动程序、Windows事件跟踪（ETW）、函数钩子以及其他多个来源获取数据来跟踪可疑的父子进程关系。如果一种规避技术针对的是依赖ETW收集数据的EDR代理，那么它可能无法在使用驱动程序执行相同目的的产品上起作用。
- en: To effectively evade EDR, then, adversaries need a detailed understanding of
    how these tools work. The rest of this chapter dives into their components and
    structure.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要有效地绕过EDR，攻击者需要对这些工具的工作原理有详细的了解。本章的其余部分将深入探讨这些工具的组成部分和结构。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Identifying Malicious Activity</samp>
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">识别恶意活动</samp>
- en: To build successful detections, an engineer must understand more than the latest
    attacker tactics; they must also know how a business operates and what an attacker’s
    objectives might be. Then they must take the distinct and potentially unrelated
    datapoints gleaned from an EDR’s sensors and identify clusters of activity that
    could indicate something malicious happening on the system. This is much easier
    said than done.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了建立有效的检测系统，工程师必须了解的不仅仅是最新的攻击者战术；他们还必须了解业务的运作方式以及攻击者的目标是什么。接下来，他们必须从 EDR 传感器收集的独特且可能不相关的数据点中，识别出可能指示系统上发生恶意行为的活动簇。这远比说起来容易做起来难。
- en: For example, does the creation of a new service indicate that an adversary has
    installed malware persistently on the system? Potentially, but it’s more likely
    that the user installed new software for legitimate reasons. What if the service
    was installed at 3 AM? Suspicious, but maybe the user is burning the midnight
    oil on a big project. How about if *rundll32.exe*, the native Windows application
    for executing DLLs, is the process responsible for installing the service? Your
    gut reaction may be to say, “Aha! We’ve got you now!” Still, the functionality
    could be part of a legitimate but poorly implemented installer. Deriving intent
    from actions can be extremely difficult.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，创建一个新服务是否意味着对手已在系统上持久性地安装了恶意软件？可能是，但更可能的是用户因正当理由安装了新软件。如果该服务是在凌晨 3 点安装的呢？虽然可疑，但也许用户正在通宵达旦处理一个大项目。如果是
    *rundll32.exe*，即执行 DLL 的 Windows 原生应用程序，负责安装该服务呢？你可能本能地会说：“哈！我们抓到你了！”但这个功能也可能是合法的、实现不佳的安装程序的一部分。从行为中推断意图可能非常困难。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Considering Context</samp>
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">考虑上下文</samp>
- en: The best way to make informed decisions is to consider the context of the actions
    in question. Compare them with user and environmental norms, known adversary tradecraft
    and artifacts, and other actions that the affected user performed in some timeframe.
    [Table 1-1](#tab1-1) provides an example of how this may work.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 做出明智决策的最佳方法是考虑相关行为的上下文。将其与用户和环境规范、已知的对手手法和工具、以及受影响用户在某段时间内执行的其他操作进行对比。[表 1-1](#tab1-1)
    提供了一个例子，展示了这如何起作用。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 1-1:</samp> <samp class="SANS_Futura_Std_Book_11">Evaluating
    a Series of Events on the System</samp>
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 1-1：</samp> <samp class="SANS_Futura_Std_Book_11">评估系统中的一系列事件</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Event</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Context</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Determination</samp> |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">事件</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">上下文</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">判断</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">2:55</samp> <samp class="SANS_Futura_Std_Book_SC_11">AM</samp><samp
    class="SANS_Futura_Std_Book_11">: The application</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">chatapp.exe</samp>
    <samp class="SANS_Futura_Std_Book_11">spawns under the context</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">CONTOSO\jdoe.</samp>
    | <samp class="SANS_Futura_Std_Book_11">The user</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">JDOE</samp>
    <samp class="SANS_Futura_Std_Book_11">frequently travels inter</samp><samp class="SANS_Futura_Std_Book_11">nationally
    and works off-hours to meet with business partners in other regions.</samp> |
    <samp class="SANS_Futura_Std_Book_11">Benign</samp> |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">2:55</samp> <samp class="SANS_Futura_Std_Book_SC_11">AM</samp><samp
    class="SANS_Futura_Std_Book_11">：应用程序</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">chatapp.exe</samp>
    <samp class="SANS_Futura_Std_Book_11">在上下文中启动</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">CONTOSO\jdoe。</samp>
    | <samp class="SANS_Futura_Std_Book_11">用户</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">JDOE</samp>
    <samp class="SANS_Futura_Std_Book_11">经常进行国际旅行，并且在非工作时间与其他地区的业务伙伴开会。</samp> |
    <samp class="SANS_Futura_Std_Book_11">良性</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">2:55</samp> <samp class="SANS_Futura_Std_Book_SC_11">AM</samp><samp
    class="SANS_Futura_Std_Book_11">: The application</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">chatapp.exe</samp>
    <samp class="SANS_Futura_Std_Book_11">loads an unsigned DLL,</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">usp10.dll</samp><samp
    class="SANS_Futura_Std_Book_11">, from the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">%APPDATA%</samp>
    <samp class="SANS_Futura_Std_Book_11">directory.</samp> | <samp class="SANS_Futura_Std_Book_11">This
    chat application isn’t known to load unsigned code in its default configuration,
    but users at the organization are permitted to install third-party plug-ins that
    may change the application’s behavior at startup.</samp> | <samp class="SANS_Futura_Std_Book_11">Mildly
    suspicious</samp> |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">2:55</samp> <samp class="SANS_Futura_Std_Book_SC_11">AM</samp><samp
    class="SANS_Futura_Std_Book_11">: 应用程序</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">chatapp.exe</samp>
    <samp class="SANS_Futura_Std_Book_11">加载了一个未签名的DLL，</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">usp10.dll</samp><samp
    class="SANS_Futura_Std_Book_11">，来自</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">%APPDATA%</samp>
    <samp class="SANS_Futura_Std_Book_11">目录。</samp> | <samp class="SANS_Futura_Std_Book_11">这个聊天应用程序在默认配置下并不加载未签名的代码，但组织中的用户被允许安装可能改变应用程序启动时行为的第三方插件。</samp>
    | <samp class="SANS_Futura_Std_Book_11">轻微可疑</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">2:56</samp> <samp class="SANS_Futura_Std_Book_SC_11">AM</samp><samp
    class="SANS_Futura_Std_Book_11">: The application</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">chatapp.exe</samp>
    <samp class="SANS_Futura_Std_Book_11">makes a connection to the internet over
    TCP port 443.</samp> | <samp class="SANS_Futura_Std_Book_11">This chat application’s
    server is hosted by a cloud provider, so it regularly polls the server for information.</samp>
    | <samp class="SANS_Futura_Std_Book_11">Benign</samp> |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">2:56</samp> <samp class="SANS_Futura_Std_Book_SC_11">AM</samp><samp
    class="SANS_Futura_Std_Book_11">: 应用程序</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">chatapp.exe</samp>
    <samp class="SANS_Futura_Std_Book_11">通过TCP端口443连接到互联网。</samp> | <samp class="SANS_Futura_Std_Book_11">该聊天应用程序的服务器由云服务提供商托管，因此它定期从服务器获取信息。</samp>
    | <samp class="SANS_Futura_Std_Book_11">无害</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">2:59</samp> <samp class="SANS_Futura_Std_Book_SC_11">AM</samp><samp
    class="SANS_Futura_Std_Book_11">: The application</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">chatapp.exe</samp>
    <samp class="SANS_Futura_Std_Book_11">queries the registry value</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">HKLM:\System\CurrentControlSet\Control\LSA\LsaCfgFlags</samp><samp
    class="SANS_Futura_Std_Book_11">.</samp> | <samp class="SANS_Futura_Std_Book_11">This
    chat application regularly pulls system- and application-configuration information
    from the registry but isn’t known to access registry keys associated with Credential
    Guard.</samp> | <samp class="SANS_Futura_Std_Book_11">Highly suspicious</samp>
    |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">2:59</samp> <samp class="SANS_Futura_Std_Book_SC_11">AM</samp><samp
    class="SANS_Futura_Std_Book_11">: 应用程序</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">chatapp.exe</samp>
    <samp class="SANS_Futura_Std_Book_11">查询了注册表值</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">HKLM:\System\CurrentControlSet\Control\LSA\LsaCfgFlags</samp><samp
    class="SANS_Futura_Std_Book_11">。</samp> | <samp class="SANS_Futura_Std_Book_11">该聊天应用程序定期从注册表中提取系统和应用程序配置的信息，但并未被知晓访问与凭证保护相关的注册表项。</samp>
    | <samp class="SANS_Futura_Std_Book_11">高度可疑</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">3</samp> <samp class="SANS_Futura_Std_Book_SC_11">AM</samp><samp
    class="SANS_Futura_Std_Book_11">: The application</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">chatapp.exe</samp>
    <samp class="SANS_Futura_Std_Book_11">opens a handle to</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">lsass.exe</samp>
    <samp class="SANS_Futura_Std_Book_11">with</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS
    _VM_READ</samp> <samp class="SANS_Futura_Std_Book_11">access.</samp> | <samp class="SANS_Futura_Std_Book_11">This
    chat application doesn’t access the address spaces of other processes, but the
    user</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">JDOE</samp> <samp
    class="SANS_Futura_Std_Book_11">does have the required permissions.</samp> | <samp
    class="SANS_Futura_Std_Book_11">Malicious</samp> |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">3</samp> <samp class="SANS_Futura_Std_Book_SC_11">AM</samp><samp
    class="SANS_Futura_Std_Book_11">: 应用程序</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">chatapp.exe</samp>
    <samp class="SANS_Futura_Std_Book_11">打开一个指向</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">lsass.exe</samp>
    <samp class="SANS_Futura_Std_Book_11">的句柄，具有</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS
    _VM_READ</samp> <samp class="SANS_Futura_Std_Book_11">访问权限。</samp> | <samp class="SANS_Futura_Std_Book_11">该聊天应用程序并未访问其他进程的地址空间，但用户</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">JDOE</samp> <samp class="SANS_Futura_Std_Book_11">确实拥有所需的权限。</samp>
    | <samp class="SANS_Futura_Std_Book_11">恶意</samp> |'
- en: This contrived example shows the ambiguity involved in determining intent based
    on the actions taken on a system. Remember that the overwhelming majority of activities
    on a system are benign, assuming that something horrible hasn’t happened. Engineers
    must determine how sensitive an EDR’s detections should be (in other words, how
    much they should skew toward saying something is malicious) based on how many
    false negatives the customer can tolerate.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个精心设计的例子展示了基于系统上采取的行为来判断意图时的模糊性。请记住，系统上的绝大多数活动都是无害的，前提是没有发生什么严重的事情。工程师必须根据客户能够容忍的误报率来确定EDR检测的敏感性（换句话说，检测应该偏向于判断某些东西是恶意的程度）。
- en: One way that a product can meet its customers’ needs is by using a combination
    of so-called brittle and robust detections.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一种让产品满足客户需求的方法是通过结合使用所谓的脆弱检测和稳健检测。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Applying Brittle
    vs. Robust Detections</samp>
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">应用脆弱与稳健检测</samp>
- en: '*Brittle* detections are those designed to detect a specific artifact, such
    as a simple string or hash-based signature commonly associated with known malware.
    *Robust* detections aim to detect behaviors and could be backed by machine-learning
    models trained for the environment. Both detection types have a place in modern
    scanning engines, as they help balance false positives and false negatives.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*脆弱*检测是指那些设计用来检测特定工件的检测，例如通常与已知恶意软件相关的简单字符串或基于哈希的特征。*稳健*检测旨在检测行为，并且可能会基于针对环境训练的机器学习模型。两种检测类型在现代扫描引擎中都有其作用，它们有助于平衡误报和漏报。'
- en: For example, a detection built around the hash of a malicious file will very
    effectively detect a specific version of that one file, but any slight variation
    to the file will change its hash, causing the detection rule to fail. This is
    why we call such rules “brittle.” They are extremely specific, often targeting
    a single artifact. This means that the likelihood of a false positive is almost
    nonexistent while the likelihood of a false negative is very high.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，基于恶意文件哈希的检测能够非常有效地检测该特定版本的文件，但文件的任何细微变化都会改变其哈希值，导致检测规则失败。这就是为什么我们称这种规则为“脆弱”的原因。它们非常具体，通常只针对单一的工件。这意味着误报的可能性几乎为零，而漏报的可能性却非常高。
- en: Despite their flaws, these detections offer distinct benefits to security teams.
    They are easy to develop and maintain, so engineers can change them rapidly as
    the organization’s needs evolve. They can also effectively detect some common
    attacks. For example, a single rule for detecting an unmodified version of the
    exploitation tool Mimikatz brings tremendous value, as its false-positive rate
    is nearly zero and the likelihood of the tool being used maliciously is high.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些检测存在缺陷，但它们为安全团队提供了独特的好处。它们易于开发和维护，因此工程师可以在组织需求变化时快速调整。它们还能够有效检测一些常见的攻击。例如，一个用于检测未经修改的Mimikatz利用工具的规则价值巨大，因为它的误报率几乎为零，而该工具被恶意使用的可能性很高。
- en: Even so, the detection engineer must carefully consider what data to use when
    creating their brittle detections. If an attacker can trivially modify the indicator,
    the detection becomes much easier to evade. For example, say that a detection
    checks for the filename *mimikatz.exe*; an adversary could simply change the filename
    to *mimidogz.exe* and bypass the detection logic. For this reason, the best brittle
    detections target attributes that are either immutable or at least difficult to
    modify.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，检测工程师在创建脆弱检测规则时，必须仔细考虑使用哪些数据。如果攻击者可以轻松修改指标，那么检测就变得更容易被绕过。例如，假设一个检测规则检查文件名
    *mimikatz.exe*；攻击者可以简单地将文件名更改为 *mimidogz.exe*，从而绕过检测逻辑。正因如此，最佳的脆弱检测规则应当针对那些不可变或至少难以修改的属性。
- en: On the other end of the spectrum, a robust ruleset backed by a machine-learning
    model might flag the modified file as suspicious because it is unique to the environment
    or contains some attribute that the classification algorithm weighted highly.
    Most robust detections are simply rules that more broadly try to target a technique.
    These types of detections exchange their specificity for the ability to detect
    an attack more generally, reducing the likelihood of false negatives by increasing
    the likelihood of false positives.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从另一个角度看，受机器学习模型支持的强大规则集可能会将修改后的文件标记为可疑，因为它对环境来说是独特的，或包含某些分类算法高度加权的属性。大多数强大的检测规则实际上是一些更广泛的规则，旨在更普遍地针对某一技术。这些类型的检测通过增加假阳性率，减少假阴性的可能性，来交换它们的特定性，以更一般的方式检测攻击。
- en: While the industry tends to favor robust detections, they have their own drawbacks.
    Compared to brittle signatures, these rules can be much harder to develop due
    to their complexity. Additionally, the detection engineer must consider an organization’s
    false-positive tolerance. If their detection has a very low false-negative rate
    but a high false-positive rate, the EDR will behave like the boy who cried wolf.
    If they go too far in their attempts to reduce false positives, they may also
    increase the rate of false negatives, allowing an attack to go unnoticed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管业界倾向于青睐强大的检测规则，但它们也有自身的缺点。与脆弱的签名相比，这些规则由于其复杂性，开发起来可能更加困难。此外，检测工程师必须考虑组织的假阳性容忍度。如果检测的假阴性率非常低，但假阳性率较高，EDR
    就会像“狼来了”的小男孩一样表现。如果他们在减少假阳性方面过于努力，也可能会增加假阴性的比例，使得攻击未被察觉。
- en: Because of this, most EDRs employ a hybrid approach, using brittle signatures
    to catch obvious threats and robust detections to detect attacker techniques more
    generally.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，大多数 EDR（端点检测与响应）采用混合方法，使用脆弱的签名来捕获明显的威胁，并通过强大的检测规则更普遍地检测攻击者技术。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Exploring Elastic
    Detection Rules</samp>
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">探索 Elastic 检测规则</samp>
- en: One of the only EDR vendors to publicly release its detection rules is Elastic,
    which publishes its SIEM rules in a GitHub repository. Let’s take a peek behind
    the curtain, as these rules contain great examples of both brittle and robust
    detections.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一公开发布检测规则的 EDR 供应商之一是 Elastic，它在 GitHub 仓库中发布了其 SIEM 规则。让我们一窥幕后，这些规则提供了脆弱和强大检测的良好示例。
- en: For example, consider Elastic’s rule for detecting Kerberoasting attempts that
    use Bifrost, a macOS tool for interacting with Kerberos, shown in [Listing 1-1](#list1-1).
    *Kerberoasting* is the technique of retrieving Kerberos tickets and cracking them
    to uncover service account credentials.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑 Elastic 用于检测使用 Bifrost（一个用于与 Kerberos 交互的 macOS 工具）进行 Kerberoasting 尝试的规则，见
    [列表 1-1](#list1-1)。*Kerberoasting* 是一种通过获取 Kerberos 票据并破解它们以揭示服务账户凭证的技术。
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 1-1: Elastic’s rule for detecting Kerberoasting based on command line
    arguments'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-1：Elastic 检测 Kerberoasting 的规则，基于命令行参数
- en: This rule checks for the presence of certain command line arguments that Bifrost
    supports. An attacker could trivially bypass this detection by renaming the arguments
    in the source code (for example, changing <samp class="SANS_TheSansMonoCd_W5Regular_11">-action</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">-dothis</samp>) and then recompiling
    the tool. Additionally, a false positive could occur if an unrelated tool supports
    the arguments listed in the rule.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则检查 Bifrost 支持的某些命令行参数的存在。攻击者可以通过重命名源代码中的参数（例如，将 <samp class="SANS_TheSansMonoCd_W5Regular_11">-action</samp>
    改为 <samp class="SANS_TheSansMonoCd_W5Regular_11">-dothis</samp>）并重新编译工具，从而轻松绕过此检测。此外，如果某个无关的工具支持规则中列出的参数，也可能会出现假阳性。
- en: For these reasons, the rule might seem like a bad detection. But remember that
    not all adversaries operate at the same level. Many threat groups continue to
    use off-the-shelf tooling. This detection serves to catch those who are using
    the basic version of Bifrost and nothing more.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这些原因，此规则可能看起来像是一个糟糕的检测。但请记住，并非所有对手都在同一水平上运作。许多威胁组继续使用现成的工具。此检测旨在捕获那些仅使用 Bifrost
    的基本版本的人。
- en: Because of the rule’s narrow focus, Elastic should supplement it with a more
    robust detection that covers these gaps. Thankfully, the vendor published a complementary
    rule, shown in [Listing 1-2](#list1-2).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于规则的狭窄焦点，Elastic 应该通过更为健壮的检测来补充它，以覆盖这些漏洞。幸运的是，供应商发布了一个补充规则，显示在 [第 1-2 列表](#list1-2)
    中。
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 1-2: Elastic’s rule for detecting atypical processes communicating
    over TCP port 88'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-2：Elastic 用于检测在 TCP 端口 88 上通信的非典型进程的规则
- en: This rule targets atypical processes that make outbound connections to TCP port
    88, the standard Kerberos port. While this rule contains some gaps to address
    false positives, it’s generally more robust than the brittle detection for Bifrost.
    Even if the adversary were to rename parameters and recompile the tool, the network
    behavior inherent to Kerberoasting would cause this rule to fire.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此规则针对于建立 TCP 端口 88 的出站连接的非典型进程。尽管此规则包含一些解决误报的漏洞，但通常比 Bifrost 的脆弱检测更为健壮。即使对手重新命名参数并重新编译工具，Kerberoasting
    所固有的网络行为也会导致此规则触发。
- en: To evade detection, the adversary could take advantage of the exemption list
    included at the bottom of the rule, perhaps changing Bifrost’s name to match one
    of those files, such as *opera.exe*. If the adversary also modified the tool’s
    command line arguments, they would evade both the brittle and robust detections
    covered here.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了躲避检测，对手可以利用规则底部包含的豁免列表，也许将 Bifrost 的名称更改为匹配其中一个文件，比如 *opera.exe*。如果对手还修改了工具的命令行参数，它们将能够避开这里介绍的脆弱和健壮的检测。
- en: Most EDR agents strive for a balance between brittle and robust detections but
    do so in an opaque way, so an organization might find it very difficult to ensure
    coverage, especially in agents that don’t support the introduction of custom rules.
    For this reason, a team’s detection engineers should test and validate detections
    using tooling such as Red Canary’s Atomic Test Harnesses.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 EDR 代理都努力在脆弱和健壮的检测之间取得平衡，但以不透明的方式进行，因此组织可能会发现确保覆盖范围非常困难，尤其是在不支持引入自定义规则的代理中。因此，团队的检测工程师应该使用
    Red Canary 的 Atomic Test Harnesses 等工具来测试和验证检测。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Agent Design</samp>
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">代理设计</samp>
- en: As attackers, we should pay close attention to the EDR agent deployed on the
    endpoints we’re targeting because this is the component responsible for detecting
    the activities we’ll use to complete our operation. In this section, we’ll review
    the parts of an agent and the various design choices they might make.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 作为攻击者，我们应该密切关注部署在我们目标端点上的 EDR 代理，因为这是检测我们将用来完成操作的活动的组件。在本节中，我们将审查代理的各个部分以及它们可能做出的各种设计选择。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Basic</samp>
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">基本</samp>
- en: 'Agents are composed of distinct parts, each of which has its own objective
    and type of telemetry it is able to collect. Most commonly, agents include the
    following components:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 代理包含独特的部分，每个部分都有自己的目标和能够收集的遥测类型。最常见的代理包括以下组件：
- en: '**The static scanner**   An application, or component of the agent itself,
    that performs static analysis of images, such as Portable Executable (PE) files
    or arbitrary ranges of virtual memory, to determine whether the content is malicious.
    Static scanners commonly form the backbone of antivirus services.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**静态扫描器**   一个应用程序或代理本身的组件，用于对图像进行静态分析，例如可执行文件 (PE) 或任意范围的虚拟内存，以确定内容是否恶意。静态扫描器通常是反病毒服务的核心。'
- en: '**The hooking DLL**   A DLL that is responsible for intercepting calls to specific
    application programming interface (API) functions. [Chapter 2](chapter2.xhtml)
    covers function hooking in detail.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**挂钩 DLL**   负责拦截特定应用程序编程接口 (API) 函数调用的 DLL。[第 2 章](chapter2.xhtml) 详细介绍了函数挂钩。'
- en: '**The kernel driver**   A kernel-mode driver responsible for injecting the
    hooking DLL into target processes and collecting kernel-specific telemetry. [Chapters
    3](chapter3.xhtml) through [7](chapter7.xhtml) cover its various detection techniques.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**内核驱动程序**   一个内核模式驱动程序，负责将钩子 DLL 注入目标进程并收集特定于内核的遥测数据。[第三章](chapter3.xhtml)到[第七章](chapter7.xhtml)将涵盖其各种检测技术。'
- en: '**The agent service**   An application responsible for aggregating telemetry
    created by the preceding two components. It sometimes correlates data or generates
    alerts. Then it relays the collected data to a centralized EDR server.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**代理服务**   一个负责聚合前两个组件创建的遥测数据的应用程序。它有时会对数据进行关联或生成警报，然后将收集到的数据转发到集中式 EDR 服务器。'
- en: '[Figure 1-2](#fig1-2) shows the most basic agent architecture that commercial
    products use today.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-2](#fig1-2)展示了商业产品今天使用的最基本的代理架构。'
- en: '![](../images/Figure1-2.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure1-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-2: The basic agent
    architecture</samp>'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 1-2：基本代理架构</samp>
- en: As we can see here, this basic design doesn’t have many sources of telemetry.
    Its three sensors (a scanner, a driver, and a function-hooking DLL) provide the
    agent with data about process-creation events, the invocation of functions deemed
    sensitive (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!CreateRemoteThread</samp>),
    the signatures of files, and potentially the virtual memory belonging to a process.
    This may be sufficient coverage for some use cases, but most commercial EDR products
    today go far beyond these capabilities. For instance, this basic EDR would be
    incapable of detecting files being created, deleted, or encrypted on the host.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这个基本设计没有太多的遥测数据来源。它的三个传感器（一个扫描器、一个驱动程序和一个功能钩子 DLL）为代理提供关于进程创建事件、被认为敏感的函数调用（如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">kernel32!CreateRemoteThread</samp>）、文件签名，以及可能属于进程的虚拟内存的数据。这对于某些用例可能足够，但如今大多数商业
    EDR 产品远远超出了这些功能。例如，这个基本的 EDR 无法检测主机上文件的创建、删除或加密情况。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Intermediate</samp>
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">中级</samp>
- en: While a basic agent can collect a large amount of valuable data with which to
    create detections, this data may not form a complete picture of the activities
    performed on the host. Usually, the endpoint security products deployed in enterprise
    environments today have substantially expanded their capabilities to collect additional
    telemetry.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一个基本的代理可以收集大量有价值的数据来创建检测，但这些数据可能无法形成主机上活动的完整画面。通常，今天在企业环境中部署的端点安全产品已经大大扩展了它们的能力，以收集额外的遥测数据。
- en: 'Most of the agents that attackers encounter fall into the intermediate level
    of sophistication. These agents not only introduce new sensors but also use telemetry
    sources native to the operating system. Additions commonly made at this level
    may include the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数攻击者遇到的代理都属于中级复杂度。这些代理不仅引入了新的传感器，还使用了操作系统原生的遥测数据源。在这一层级上常见的添加功能可能包括以下内容：
- en: '**Network filter drivers**   Drivers that perform network traffic analysis
    to identify indicators of malicious activity, such as beaconing. These will be
    covered in [Chapter 7](chapter7.xhtml).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络过滤驱动程序**   执行网络流量分析的驱动程序，用于识别恶意活动的指示符，如信标通信。这将在[第七章](chapter7.xhtml)中讨论。'
- en: '**Filesystem filter drivers**   A special type of driver that can monitor for
    operations on the host filesystem. They are discussed extensively in [Chapter
    6](chapter6.xhtml).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件系统过滤驱动程序**   一种特殊类型的驱动程序，可以监视主机文件系统上的操作。它们将在[第六章](chapter6.xhtml)中详细讨论。'
- en: '**ETW consumers**   Components of the agent that can subscribe to events created
    by the host operating system or third-party applications. ETW is covered in [Chapter
    8](chapter8.xhtml).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**ETW 消费者**   代理的组件，能够订阅主机操作系统或第三方应用程序创建的事件。ETW 在[第八章](chapter8.xhtml)中进行讨论。'
- en: '**Early Launch Antimalware (ELAM) components**   Features that provide a Microsoft-supported
    mechanism for loading an antimalware driver before other boot-start services to
    control the initialization of the other boot drivers. These components also grant
    the ability to receive Secure ETW events, a special type of event generated from
    a group of protected event providers. These functions of ELAM drivers are covered
    in [Chapter 11](chapter11.xhtml) and [Chapter 12](chapter12.xhtml).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**早期启动反恶意软件（ELAM）组件**   提供一种微软支持的机制，用于在其他启动服务之前加载反恶意软件驱动程序，以控制其他启动驱动程序的初始化。这些组件还提供接收安全ETW事件的功能，ETW事件是一种由一组受保护事件提供者生成的特殊事件。ELAM驱动程序的这些功能在[第11章](chapter11.xhtml)和[第12章](chapter12.xhtml)中进行了详细讨论。'
- en: While modern EDRs may not implement all of these components, you’ll commonly
    see the ELAM driver deployed alongside the primary kernel driver. [Figure 1-3](#fig1-3)
    illustrates what a more modern agent architecture may look like.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然现代EDR可能没有实现所有这些组件，但你通常会看到ELAM驱动程序与主内核驱动程序一起部署。[图1-3](#fig1-3)展示了更现代的代理架构可能是什么样子。
- en: '![](../images/Figure1-3.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure1-3.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-3: The intermediate
    agent architecture</samp>'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图1-3：中间代理架构</samp>
- en: This design builds upon the basic architecture and adds many new sensors from
    which telemetry can be collected. For instance, this EDR can now monitor filesystem
    events such as file creation, consume from ETW providers that offer data the agent
    wouldn’t otherwise be able to collect, and observe network communications on the
    host through its filter driver, potentially allowing the agent to detect command-and-control
    beaconing activity. It also adds a layer of redundancy so that if one sensor fails,
    another might be able to pick up the slack.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 该设计在基本架构的基础上构建，并添加了许多新的传感器，通过这些传感器可以收集遥测数据。例如，这个EDR现在可以监控文件系统事件，如文件创建，使用ETW提供的数据源，收集该代理原本无法收集的数据，并通过其过滤驱动程序观察主机上的网络通信，潜在地使代理能够检测命令与控制信标活动。它还增加了一层冗余，以便在一个传感器失败时，另一个传感器可以接管任务。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Advanced</samp>
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">高级</samp>
- en: 'Some products implement more advanced features to monitor specific areas of
    the system in which they’re interested. Here are two examples of such features:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一些产品实现了更高级的功能，用于监控它们感兴趣的系统特定区域。以下是其中两个功能的示例：
- en: '**Hypervisors**   Provide a method for the interception of system calls, the
    virtualization of certain system components, and the sandboxing of code execution.
    These also provide the agent with a way to monitor transitions in execution between
    the guest and host. They’re commonly leveraged as a component of anti-ransomware
    and anti-exploit functionality.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**虚拟机监控器（Hypervisors）**   提供一种拦截系统调用、虚拟化某些系统组件以及沙箱化代码执行的方法。这些功能还为代理提供了一种监控来宾与主机之间执行转换的方式。它们通常作为反勒索软件和反利用功能的组件被利用。'
- en: '**Adversary deception**   Provides false data to the adversary instead of preventing
    the malicious code’s execution. This may cause the adversary to focus on debugging
    their tooling without realizing that the data in use has been tampered with.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**对手欺骗**   提供虚假数据给对手，而不是阻止恶意代码的执行。这可能导致对手专注于调试他们的工具，而没有意识到正在使用的数据已经被篡改。'
- en: Because these are typically product-specific implementations and are not commonplace
    at the time of this writing, we won’t discuss these advanced features in significant
    detail. Additionally, many of the components in this category align more closely
    with prevention strategies rather than detection, pushing them slightly outside
    the scope of this book. As time goes on, however, some advanced features may become
    more common, and new ones will likely be invented.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些通常是特定于产品的实现，并且在本文写作时并不常见，因此我们不会详细讨论这些高级功能。此外，本类别中的许多组件更贴近预防策略，而非检测，这使得它们稍微超出了本书的范围。然而，随着时间的推移，一些高级功能可能会变得更为常见，新的功能也可能会被发明。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Types of Bypasses</samp>
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">绕过类型</samp>
- en: 'In his 2021 blog post “Evadere Classifications,” Jonathan Johnson groups evasions
    based on the location in the detection pipeline where they occur. Using the Funnel
    of Fidelity, a concept put forth by Jared Atkinson to describe phases of the detection
    and response pipeline, Johnson defines areas where an evasion can occur. The following
    are the ones we’ll discuss in later chapters:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在他2021年的博客文章《Evadere分类》中，Jonathan Johnson根据绕过发生的检测管道位置将绕过分为不同类型。使用Jared Atkinson提出的“忠实漏斗”概念，描述了检测和响应管道的各个阶段，Johnson定义了绕过可能发生的区域。以下是我们将在后续章节中讨论的那些区域：
- en: '**Configuration bypass**   Occurs when there is a telemetry source on the endpoint
    that could identify the malicious activity, but the sensor failed to collect data
    from it, leading to a gap in coverage. For example, even if the sensor is able
    to collect events from a specific ETW provider related to Kerberos authentication
    activity, it might not be configured to do so.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**配置绕过**   发生在端点上存在一个能够识别恶意活动的遥测源，但传感器未能从中收集数据，导致覆盖空白。例如，即使传感器能够收集与Kerberos认证活动相关的特定ETW提供程序的事件，它也可能未配置为这样做。'
- en: '**Perceptual bypass**   Occurs when the sensor or agent lacks the capability
    to collect the relevant telemetry. For example, the agent might not monitor filesystem
    interactions.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**感知绕过**   发生在传感器或代理缺乏收集相关遥测数据的能力时。例如，代理可能不会监控文件系统交互。'
- en: '**Logical bypass**   Occurs when the adversary abuses a gap in a detection’s
    logic. For example, a detection might contain a known gap that no other detection
    covers.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**逻辑绕过**   发生在攻击者利用检测逻辑中的漏洞时。例如，某个检测可能包含一个已知的漏洞，而其他检测并未覆盖该漏洞。'
- en: '**Classification bypass**   Occurs when the sensor or agent is unable to identify
    enough datapoints to classify the attacker’s behavior as malicious, despite observing
    it. For example, the attacker’s traffic might blend into normal network traffic.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**分类绕过**   发生在传感器或代理无法识别足够的数据点以将攻击者的行为分类为恶意，即使它观察到了这些行为。例如，攻击者的流量可能与正常的网络流量混合。'
- en: Configuration bypasses are one of the most common techniques. Sometimes they
    are even used unknowingly, as most mature EDR agents have the ability to collect
    certain telemetry but fail to do so for one reason or another, such as to reduce
    event volume. Perceptual bypasses are generally the most valuable because if the
    data doesn’t exist and no compensating components cover the gap, the EDR has no
    chance of detecting the attacker’s activities.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 配置绕过是最常见的技术之一。有时它们甚至是在不知情的情况下使用的，因为大多数成熟的EDR代理具备收集某些遥测数据的能力，但由于某些原因未能做到这一点，例如减少事件数量。感知绕过通常是最有价值的，因为如果数据不存在，并且没有补偿组件来弥补这一空白，那么EDR就无法检测到攻击者的活动。
- en: Logical bypasses are the trickiest to pull off because they generally require
    knowledge of the detection’s underlying logic. Lastly, classification bypasses
    require a bit of forethought and system profiling, but red teams use them frequently
    (for example, by beaconing over a slow HTTPS channel to a reputable site for their
    command-and-control activities). When executed well, classification bypasses can
    approach the efficacy of a perceptual bypass for less work than that required
    for a logical bypass.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑绕过是最难实现的，因为它们通常需要对检测的基本逻辑有了解。最后，分类绕过需要一些前瞻性思维和系统剖析，但红队经常使用它们（例如，通过慢速HTTPS通道与一个信誉良好的网站进行信标通信，进行命令与控制活动）。当操作得当时，分类绕过能够达到感知绕过的效果，且所需的工作量远低于逻辑绕过。
- en: On the defense side, these classifications let us discuss blind spots in our
    detection strategies with greater specificity. For instance, if we require that
    events be forwarded from the endpoint agent to the central collection server for
    analysis, our detection is inherently vulnerable to a configuration evasion, as
    an attacker could potentially change the agent’s configuration in such a way that
    the agent–server communication channel is interrupted.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在防御方面，这些分类使我们能够更具体地讨论检测策略中的盲点。例如，如果我们要求将事件从端点代理转发到中央收集服务器进行分析，那么我们的检测本身就容易受到配置规避的影响，因为攻击者可能会通过某种方式更改代理的配置，从而中断代理与服务器之间的通信通道。
- en: Perceptual bypasses are important to understand but are often the hardest to
    find. If our EDR simply lacks the ability to collect the required data, we have
    no choice but to find another way to build our detection. Logical bypasses happen
    due to decisions made when building the detection rules. Because SOCs aren’t staffed
    with an infinite number of analysts who can review alerts, engineers always seek
    to reduce false positives. But for every exemption they make in a rule, they inherit
    the potential for a logical bypass. Consider Elastic’s robust Kerberoasting rule
    described earlier and how an adversary could simply change the name of their tool
    to evade it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 感知规避是非常重要的，但通常最难被发现。如果我们的EDR根本没有能力收集所需的数据，那么我们只能找到其他方法来构建检测。逻辑规避是由于在构建检测规则时所做的决策所导致的。由于SOC中并非每位分析员都有无限的时间来审查警报，工程师总是寻求减少误报。但是，对于他们在规则中做出的每一个豁免，他们就可能引入逻辑规避的潜在风险。考虑一下Elastic之前提到的强大Kerberoasting规则，攻击者只需要简单地更改工具的名称即可规避此规则。
- en: Finally, classification evasions can be the trickiest to protect against. To
    do so, engineers must continue to tune the EDR’s detection threshold until it’s
    just right. Take command-and-control beaconing as an example. Say we build our
    detection strategy by assuming that an attacker will connect to a site with an
    uncategorized reputation at a rate greater than one request per minute. In what
    way could our adversary fly under the radar? Well, they might beacon through an
    established domain or slow their callback interval to once every two minutes.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，分类规避可能是最难防范的。为此，工程师必须不断调整EDR的检测阈值，直到达到最佳设置。以命令与控制信标为例。假设我们通过假设攻击者会以每分钟超过一次的请求频率连接到一个未分类信誉的站点来构建检测策略。那么我们的对手可能如何避开雷达呢？他们可能通过一个已经建立的域名进行信标传输，或者将回调间隔减慢到每两分钟一次。
- en: In response, we could change our rule to look for domains to which the system
    hasn’t previously connected, or we could increase the beaconing interval. But
    remember that we’d risk receiving more false positives. Engineers will continue
    to perform this dance as they strive to optimize their detection strategies to
    balance the tolerances of their organizations with the capabilities of their adversaries.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 作为回应，我们可以将规则修改为查找系统以前没有连接过的域，或者增加信标间隔。但请记住，这样做可能会带来更多的误报风险。工程师们将继续在这种博弈中前行，努力优化他们的检测策略，以平衡组织的容忍度与对手的能力。
- en: '<samp class="SANS_Futura_Std_Bold_B_11">Linking Evasion Techniques: An Example
    Attack</samp>'
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">链接规避技术：一个示例攻击</samp>
- en: There is typically more than one way to collect a piece of telemetry. For example,
    the EDR could monitor process-creation events using both a driver and an ETW consumer.
    This means that evasion isn’t a simple matter of finding a silver bullet. Rather,
    it’s the process of abusing gaps in a sensor to fly under the threshold at which
    the EDR generates an alert or takes preventive action.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，收集一条遥测数据有不止一种方式。例如，EDR可以同时使用驱动程序和ETW消费者来监视进程创建事件。这意味着规避并非简单地找到“银弹”。相反，它是利用传感器中的空白点，避开EDR生成警报或采取预防措施的阈值的过程。
- en: Consider [Table 1-2](#tab1-2), which describes a contrived classification system
    designed to catch command-and-control agent operations. In this example, any actions
    occurring within some window of time whose cumulative score is greater than or
    equal to 500 will cause a high-severity alert. A score higher than 750 will cause
    the offending process and its children to be terminated.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑[表 1-2](#tab1-2)，它描述了一个专门设计用来捕捉命令与控制代理操作的分类系统。在这个例子中，任何在某个时间窗口内发生的、其累计分数大于或等于500的行为都会触发高严重度警报。分数超过750时，相关进程及其子进程将被终止。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 1-2:</samp> <samp class="SANS_Futura_Std_Book_11">An
    Example Classification System</samp>
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 1-2:</samp> <samp class="SANS_Futura_Std_Book_11">一个示例分类系统</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Activity</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Risk
    score</samp> |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">活动</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">风险分数</samp>
    |'
- en: '| --- | --- |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Execution of an unsigned binary</samp>
    | <samp class="SANS_Futura_Std_Book_11">250</samp> |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">执行未签名的二进制文件</samp> | <samp class="SANS_Futura_Std_Book_11">250</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Atypical child process spawned</samp>
    | <samp class="SANS_Futura_Std_Book_11">400</samp> |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">非典型子进程已生成</samp> | <samp class="SANS_Futura_Std_Book_11">400</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Outbound HTTP traffic originating from
    a non-browser process</samp> | <samp class="SANS_Futura_Std_Book_11">100</samp>
    |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">非浏览器进程发起的外发 HTTP 流量</samp> | <samp
    class="SANS_Futura_Std_Book_11">100</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Allocation of a read-write-execute
    buffer</samp> | <samp class="SANS_Futura_Std_Book_11">200</samp> |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">分配读写执行缓冲区</samp> | <samp class="SANS_Futura_Std_Book_11">200</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Committed memory allocation not backed
    by an image</samp> | <samp class="SANS_Futura_Std_Book_11">350</samp> |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">未由镜像支持的已提交内存分配</samp> | <samp class="SANS_Futura_Std_Book_11">350</samp>
    |'
- en: An attacker could bypass each of these activities individually, but when they’re
    combined, evasion becomes much more difficult. How could we chain evasion techniques
    to avoid triggering the detection logic?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以单独绕过每个活动，但当它们结合在一起时，规避变得更加困难。我们如何将规避技术链式结合，以避免触发检测逻辑？
- en: Starting with configuration evasions, let’s imagine that the agent lacks a network-inspection
    sensor, so it can’t correlate outgoing network traffic with a client process.
    However, a compensating control may be present, such as an ETW consumer for the
    Microsoft-Windows-WebIO provider. In that case, we might opt to use a browser
    as a host process or employ another protocol, such as DNS, for command and control.
    We might also use a logical evasion to subvert the “atypical child process” detection
    by matching typical parent–child relationships on the system. For a perceptual
    evasion, let’s say that the agent lacks the ability to scan memory allocations
    to see if they’re backed by an image. As attackers, we won’t need to worry at
    all about being detected based on this indicator.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 从配置规避开始，假设代理缺少网络检查传感器，因此无法将外发网络流量与客户端进程关联。然而，可能存在补偿性控制，例如针对 Microsoft-Windows-WebIO
    提供程序的 ETW 消费者。在这种情况下，我们可能会选择使用浏览器作为宿主进程，或者使用其他协议，如 DNS，进行命令与控制。我们也可以使用逻辑规避，通过匹配系统上的典型父子关系来规避“非典型子进程”检测。对于感知规避，假设代理缺乏扫描内存分配的能力，无法判断这些分配是否由镜像支持。作为攻击者，我们完全不需要担心根据此指标被检测到。
- en: Let’s put this all together to describe how an attack might proceed. First,
    we could exploit an email client to achieve code execution under the context of
    that process. Because this mail-client binary is a legitimate product that existed
    on the system prior to compromise, we can reasonably assume that it is signed
    or has a signing exclusion. We’ll send and receive command-and-control traffic
    over HTTP, which triggers the detection for a non-browser process communicating
    over HTTP, bringing the current risk score up to 100.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些内容结合起来，描述攻击可能的进展。首先，我们可以利用电子邮件客户端在该进程上下文中实现代码执行。由于这个邮件客户端二进制文件是系统在遭到破坏之前就存在的合法产品，因此我们可以合理假设它是已签名的，或者具有签名豁免。我们将通过
    HTTP 发送和接收命令与控制流量，这会触发检测，即非浏览器进程通过 HTTP 进行通信，将当前风险评分提高到 100。
- en: Next, we need to spawn a sacrificial process at some point to perform our post-exploitation
    actions. Our tooling is written in PowerShell, but rather than spawning *powershell.exe*,
    which would be atypical and trigger an alert by bringing our risk score to 500,
    we instead spawn a new instance of the email client as a child process and use
    Unmanaged PowerShell to execute our tooling inside it. Our agent allocates a read-write-execute
    buffer in the child process, however, raising our risk score to 300.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在某个时刻生成一个牺牲进程来执行我们的后期利用操作。我们的工具是用 PowerShell 编写的，但我们并不是生成 *powershell.exe*，因为那样会显得不典型并触发警报，将风险评分提高到
    500。相反，我们生成一个新的邮件客户端实例作为子进程，并使用非托管 PowerShell 在其中执行我们的工具。我们的代理在子进程中分配了一个读写执行缓冲区，这将使风险评分提高到
    300。
- en: 'We receive the output from our tool and determine that we need to run another
    tool to perform some action to further our access. At this point, any additional
    detections will raise our risk score to 500 or greater, potentially burning our
    operation, so we have some decisions to make. Here are a few options:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到工具的输出，并确定需要运行另一个工具来执行某些操作以进一步扩大我们的访问权限。此时，任何额外的检测都将把我们的风险评分提高到 500 或更高，可能会导致操作失败，因此我们需要做出一些决策。以下是几种选择：
- en: Execute the post-exploitation tooling and accept the detection. After the alert,
    we could move very quickly in an attempt to outpace the response, hope for an
    ineffective response process that fails to eradicate us, or be okay with burning
    the operation and starting over again if needed.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行后渗透工具并接受检测。警报触发后，我们可以迅速行动，试图赶在响应之前，期待响应过程无效，从而未能根除我们，或者如果需要，可以接受烧掉操作并重新开始。
- en: Wait for some period of time before executing our tooling. Because the agent
    correlates only those events that occur within some window of time, we can simply
    wait until the state recycles, resetting our risk score to zero, and continue
    the operation from there.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行工具之前等待一段时间。由于代理仅关联在某个时间窗口内发生的事件，我们可以简单地等待，直到状态重新循环，将我们的风险分数重置为零，然后继续操作。
- en: Find another method of execution. This could range from simply dropping our
    script on the target and executing it there, to proxying in the post-exploitation
    tool’s traffic to reduce most of the host-based indicators it would create.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找另一种执行方法。这可以从简单地将脚本放置到目标上并在那里执行，到通过代理转发后渗透工具的流量，从而减少它可能产生的大部分基于主机的指标。
- en: 'Whatever we choose, our goal is clear: stay below the alerting threshold for
    as long as possible. By calculating the risks of each action that we need to perform,
    understanding the indicators our activities create, and using a combination of
    evasion tactics, we can evade an EDR’s complex detection systems. Note that no
    single evasion worked universally in this example. Rather, a combination of evasions
    targeted the most relevant detections for the task at hand.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们选择什么方法，目标是明确的：尽可能长时间保持在警报阈值以下。通过计算我们需要执行的每个操作的风险，理解我们的活动所产生的指标，并结合使用规避策略，我们可以避开EDR复杂的检测系统。请注意，在这个示例中没有任何单一的规避方法可以通用。相反，是多种规避手段结合起来，针对当前任务最相关的检测进行了防范。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Conclusion</samp>
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">结论</samp>
- en: In summary, an EDR agent is composed of any number of sensors that are responsible
    for collecting telemetry related to activity on the system. The EDR applies its
    own rules or detection logic across this data to pick out what things might indicate
    a malicious actor’s presence. Each of these sensors is susceptible to evasion
    in some way, and it is our job to identify those blind spots and either abuse
    them or compensate for them.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，EDR代理由多个传感器组成，负责收集与系统活动相关的遥测数据。EDR会在这些数据上应用其自身的规则或检测逻辑，以识别可能表明恶意行为者存在的迹象。这些传感器每个都有某种程度的规避风险，找出这些盲点并加以利用或弥补是我们的工作。
