- en: '**13'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**13'
- en: FOREIGN FILESYSTEMS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 外部文件系统**
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: FreeBSD supports a variety of filesystems other than ZFS and UFS. You’ll need
    to be able to interoperate with other hosts by using optical media, flash drives,
    and the like. Additionally, FreeBSD uses the special-purpose filesystem devfs(5)
    to manage device nodes. Jail users might need the process filesystem procfs(5).
    For extremely fast storage that doesn’t need to survive a reboot, you can use
    system RAM as a filesystem. You can mount filesystems over the network, using
    either the Unix-style Network File System or Microsoft’s Common Internet File
    System (CIFS). And no matter how hard you try to avoid it, sometimes you’re stuck
    mounting ISO images.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 支持多种除 ZFS 和 UFS 外的文件系统。你需要通过使用光盘、闪存驱动器等与其他主机互操作。此外，FreeBSD 使用特殊用途的文件系统
    devfs(5) 来管理设备节点。Jail 用户可能需要进程文件系统 procfs(5)。对于不需要在重启后存活的超快速存储，你可以将系统内存用作文件系统。你可以通过网络挂载文件系统，使用
    Unix 风格的网络文件系统（NFS）或 Microsoft 的常用互联网文件系统（CIFS）。不管你如何努力避免，有时候你还是不得不挂载 ISO 镜像。
- en: Using any of these requires a deeper understanding of mounting filesystems.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些命令需要对挂载文件系统有更深入的理解。
- en: '**FreeBSD Mount Commands**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**FreeBSD 挂载命令**'
- en: We saw mount(8) earlier when discussing UFS filesystems, but you’ll also use
    it to attach other filesystems to the directory tree. The mount(8) command assumes
    that any local partitions use UFS. If you try to mount a non-UFS filesystem, you’ll
    get an error.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在讨论 UFS 文件系统时曾提到过 mount(8)，但你也将使用它来将其他文件系统附加到目录树上。mount(8) 命令假设任何本地分区都使用 UFS。如果你尝试挂载一个非
    UFS 文件系统，将会遇到错误。
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The device node */dev/cd0* represents an optical drive. I put a CD in the drive
    just for this test, so it should work. Trying to mount it gives an error, though.
    To mount a UFS filesystem, you need the device node and a mount point. Mounting
    foreign filesystems means adding the filesystem type with `-t`. CDs use the ISO
    9660 filesystem, which FreeBSD calls cd9660\. Here, I specify the filesystem to
    mount that CD on */cdrom*:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 设备节点 */dev/cd0* 代表一个光驱。我为了这个测试将光盘放入驱动器，所以应该能正常工作。然而，尝试挂载时却出现错误。要挂载 UFS 文件系统，你需要设备节点和挂载点。挂载外部文件系统时，必须使用
    `-t` 参数指定文件系统类型。光盘使用 ISO 9660 文件系统，FreeBSD 称之为 cd9660。这里，我指定了挂载该光盘的文件系统，并将其挂载到
    */cdrom* 目录下：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: I can now go to the */media* directory and view the contents. Simple enough,
    eh?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我可以进入 */media* 目录查看内容。很简单，是吧？
- en: Many filesystems have their own custom variant of the mount(8) command. Get
    a full list by running `apropos mount_`. Yes, you need the trailing underscore;
    all of the mount(8) variants use that as a separator. You’ll find mount_cd9660(8),
    mount_msdosfs(8), mount_nfs(8), and more. Always use `mount -t` on filesystems
    without such a command.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 许多文件系统都有其自定义的 mount(8) 命令变体。通过运行 `apropos mount_` 可以获取完整的列表。是的，你需要在命令末尾加下划线；所有的
    mount(8) 变体都使用下划线作为分隔符。你会找到 mount_cd9660(8)、mount_msdosfs(8)、mount_nfs(8) 等等。对于没有这种命令的文件系统，始终使用
    `mount -t`。
- en: 'Apply mount options with the `-o` flag. You’ll need to check each mount command’s
    man page to see what mount options the filesystem supports. Separate multiple
    mount options with commas. Here, I mount a FAT32 drive at device node */dev/da1*
    read-only, assigning the owner and group to user *bert*:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-o` 标志应用挂载选项。你需要查看每个挂载命令的 man 页面，了解文件系统支持哪些挂载选项。多个挂载选项用逗号分隔。这里，我将一个 FAT32
    驱动器挂载到设备节点 */dev/da1*，并以只读方式挂载，同时将所有者和组分配给用户 *bert*：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can unmount any mounted filesystem with umount(8):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 umount(8) 卸载任何已挂载的文件系统：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The umount(8) command doesn’t care about the filesystem type. It just tries
    to disconnect the disk partition from the filesystem. It does care about whether
    someone is using the filesystem, however, and refuses to unmount it if even one
    process uses it. If you have an idle terminal with a shell prompt in the filesystem,
    umount(8) will refuse to unmount the filesystem.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: umount(8) 命令不关心文件系统类型。它只是尝试将磁盘分区从文件系统中断开。然而，它确实关心是否有进程正在使用该文件系统，如果有进程在使用，umount(8)
    会拒绝卸载该文件系统。如果你在文件系统中有一个空闲的终端并且显示 shell 提示符，umount(8) 会拒绝卸载该文件系统。
- en: If you’re constantly connecting and disconnecting filesystems, investigate autofs(5)
    to handle these mounts automatically.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你经常连接和断开文件系统，建议研究一下 autofs(5) 来自动处理这些挂载。
- en: '***Supported Foreign Filesystems***'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***支持的外部文件系统***'
- en: Here are some of the most commonly used foreign filesystems, along with a brief
    description of each and the appropriate mount command.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些最常用的外部文件系统，以及每个文件系统的简要描述和适用的挂载命令。
- en: '**FAT (MS-DOS)**'
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**FAT (MS-DOS)**'
- en: FreeBSD includes extensive support for FAT, the DOS/Windows 9*x* File Allocation
    Table filesystem, commonly used on removable media and some dual-boot systems.
    This support covers the FAT12, FAT16, and FAT32 varieties. You *can* format a
    thumb drive with a non-FAT filesystem, however, so don’t blindly assume that all
    thumb drives use FAT. As the most common use for a thumb drive these days is transferring
    files between machines, however, most are FAT32\. The mount type is `msdosfs`
    (`mount -t msdosfs`).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 包含了广泛的 FAT 支持，FAT 是 DOS/Windows 9*x* 文件分配表文件系统，通常用于可移动媒体和一些双启动系统。此支持涵盖了
    FAT12、FAT16 和 FAT32 类型。不过，你*可以*使用非 FAT 文件系统格式化 U 盘，因此不要盲目认为所有的 U 盘都使用 FAT。由于现在
    U 盘最常见的用途是机器之间传输文件，因此大多数 U 盘都是 FAT32 格式。挂载类型为 `msdosfs`（`mount -t msdosfs`）。
- en: If you handle a lot of FAT32 disks, investigate the `mtools` package, a collection
    of programs for working with FAT filesystems that offer greater flexibility than
    the default FreeBSD tools.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你处理大量的 FAT32 磁盘，建议调查一下 `mtools` 包，它是一组用于处理 FAT 文件系统的程序，提供比默认的 FreeBSD 工具更高的灵活性。
- en: '**ISO 9660**'
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**ISO 9660**'
- en: ISO 9660 is the standard filesystem for CDs and is occasionally used on DVDs.
    FreeBSD supports reading and writing CDs if you have a CD burner. Just about every
    CD you encounter is formatted with ISO 9660\. The mount command is `mount -t cd9660`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ISO 9660 是 CD 的标准文件系统，偶尔也用于 DVD。FreeBSD 支持读取和写入 CD，如果你有 CD 刻录机的话。几乎所有遇到的 CD
    都使用 ISO 9660 格式。挂载命令是 `mount -t cd9660`。
- en: The `cdrtools` package, in */usr/ports/sysutils/cdrtools*, contains many helpful
    tools for working with CD images, including tools that build an ISO image from
    files on disk.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`cdrtools` 包位于 */usr/ports/sysutils/cdrtools*，包含了许多有用的工具，用于处理 CD 镜像，包括可以从磁盘上的文件生成
    ISO 镜像的工具。'
- en: '**UDF**'
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**UDF**'
- en: UDF, or Universal Disk Format, is a replacement for ISO 9660\. You’ll find UDF
    on some DVDs and Blu-Ray disks and on a few thumb drives larger than the 32GB
    supported under FAT32\. As the capacity of removable media increases, you’ll see
    more and more UDF filesystems. The mount command is `mount -t udf`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: UDF（通用磁盘格式）是 ISO 9660 的替代品。你会在一些 DVD 和 Blu-Ray 磁盘上找到 UDF，此外一些大于 FAT32 支持的 32GB
    的 U 盘也使用 UDF。随着可移动媒体容量的增加，UDF 文件系统会越来越常见。挂载命令是 `mount -t udf`。
- en: '**EXT**'
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**EXT**'
- en: The standard Linux filesystems—EXT2, EXT3, and EXT4—support many of the same
    features as UFS. FreeBSD can safely read from and write to EXT2 and EXT3 filesystems
    without any problems but can mount EXT4 filesystems only as read-only.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 Linux 文件系统——EXT2、EXT3 和 EXT4——支持许多与 UFS 相同的功能。FreeBSD 可以安全地读取和写入 EXT2 和
    EXT3 文件系统，但只能将 EXT4 文件系统挂载为只读模式。
- en: Mounting Linux filesystems is most useful for disaster recovery, dual-boot systems,
    or system migrations. Despite the name, `mount -t ext2fs` supports mounting all
    versions of EXT.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 挂载 Linux 文件系统最常用于灾难恢复、双启动系统或系统迁移。尽管名字如此，`mount -t ext2fs` 支持挂载所有版本的 EXT。
- en: Linux filesystem users might find the tools in */usr/ports/sysutils/e2fsprogs*
    useful. They let you fsck(8) and assess Linux filesystems, among other things.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 文件系统用户可能会发现 */usr/ports/sysutils/e2fsprogs* 中的工具很有用，它们可以让你 fsck(8) 并检查
    Linux 文件系统，除此之外还有其他功能。
- en: '***Permissions and Foreign Filesystems***'
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***权限和外部文件系统***'
- en: Permissions of a filesystem depend on the filesystem features and the person
    who mounts it. FreeBSD tries to support features that aren’t too different from
    those in UFS or ZFS.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统的权限取决于文件系统的特性和挂载它的人。FreeBSD 会尝试支持那些与 UFS 或 ZFS 中的特性差异不大的功能。
- en: Consider the Linux filesystem, EXT. EXT stores permissions in the filesystem
    and lets the kernel map them to UIDs. Since EXT permissions behave much like UFS
    permissions and all the necessary permissions information is available within
    the filesystem, FreeBSD respects the permissions on these filesystems. EXT doesn’t
    support BSD file flags, however, so you can’t assign those flags to a file on
    EXT.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下 Linux 文件系统 EXT。EXT 在文件系统中存储权限，并让内核将其映射到 UID。由于 EXT 权限与 UFS 权限非常相似，并且所有必要的权限信息都可以在文件系统内找到，因此
    FreeBSD 会尊重这些文件系统上的权限。然而，EXT 不支持 BSD 文件标志，因此你不能在 EXT 上为文件分配这些标志。
- en: FAT has no permissions system. Even if you mount your FAT32 thumb drive in your
    FreeBSD host, you can’t apply permissions to files.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: FAT 没有权限系统。即使你将 FAT32 U 盘挂载到 FreeBSD 主机上，也无法对文件应用权限。
- en: 'By default, only root can mount filesystems, and root owns all non-Unix filesystems.
    If that’s not your preference, you can use the `-u` and `-g` flags to set the
    user ID and group ID of the owner when you’re mounting a FAT32, ISO 9660, or UDF
    filesystem. For example, if you’re mounting a FAT32 USB device for the user *xistence*
    and want him to be able to edit the contents, use this command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，只有root用户可以挂载文件系统，并且root拥有所有非Unix文件系统。如果这不是你想要的配置，你可以使用`-u`和`-g`标志来设置挂载FAT32、ISO
    9660或UDF文件系统时的用户ID和组ID。例如，如果你要为用户*xistence*挂载一个FAT32 USB设备，并希望他能够编辑其内容，可以使用以下命令：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The user *xistence* now owns the files on the device.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，用户*xistence*拥有设备上的文件。
- en: You might get sick of mounting media for your users, especially in a facility
    with dozens of machines. To let users mount filesystems, set the sysctl `vfs.usermount`
    to `1`. Users can then mount any device they have permission to access on any
    mount point they own. While *xistence* couldn’t mount the removable device on
    */media*, he could mount it on */home/xistence/media*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会厌倦为用户挂载介质，尤其是在拥有数十台机器的设施中。要允许用户挂载文件系统，可以将sysctl `vfs.usermount`设置为`1`。用户就可以在他们有权限访问的任何挂载点上挂载任何设备。虽然*xistence*不能将可移动设备挂载到*/media*，但他可以将其挂载到*/home/xistence/media*。
- en: '**Using Removable Media**'
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用可移动介质**'
- en: You must be able to manage any removable media that might wander in through
    the door of your data center. Here, we’ll discuss optical disks and flash drives.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须能够管理任何可能进入数据中心的可移动介质。在这里，我们将讨论光盘和闪存驱动器。
- en: I recommend not plugging removable media willy-nilly into your production servers—for
    security reasons if nothing else. Who knows what’s actually on that vendor’s USB
    device? Worse, you can order “USB killer” devices that deliberately damage hardware.
    Mount suspicious devices on a disposable workstation, examine the contents, and
    then copy the desired data over to the FreeBSD machine. This isn’t guaranteed
    to be safe, as the many USB interfaces can inject data into the hardware beneath
    the OS layer, but it’s as safe as you’ll get. Removable media is just too easy
    for certain applications, however, and of course the rules change when it’s my
    personal USB device.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议不要随便把可移动介质插入你的生产服务器——至少出于安全原因，应该避免这样做。谁知道那个供应商的USB设备上到底有什么？更糟糕的是，你甚至可以订购“USB杀手”设备，它们故意损坏硬件。将可疑设备挂载在可丢弃的工作站上，检查其内容，然后将所需的数据复制到FreeBSD机器上。这并不能保证安全，因为许多USB接口可以在操作系统层下面注入数据，但这是你能做到的最安全方式。然而，某些应用程序仍然觉得可移动介质太方便，当然，当是我的个人USB设备时，规则会有所不同。
- en: Using the device requires a filesystem type, a device node, and a mount point.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用设备需要一个文件系统类型、一个设备节点和一个挂载点。
- en: Figuring out a removable drive’s filesystem can require a bit of trial and error.
    CDs use the ISO 9660 filesystem, while DVDs and Blu-Rays use either a UDF or a
    combination of ISO 9660 and UDF. When in doubt, try CD9660 first. USB devices
    and floppy disks are usually FAT32\. While it was once expected that large USB
    devices would use UDF, most of them still use FAT32\. Run fstyp(8) on a device
    node to help identify the filesystem on it, or try `gpart show` on the disk’s
    device node.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 确定可移动驱动器的文件系统可能需要一些试验和错误。CD使用ISO 9660文件系统，而DVD和蓝光光盘则使用UDF或ISO 9660和UDF的组合。若不确定，首先尝试CD9660。USB设备和软盘通常使用FAT32。虽然曾经预计大容量USB设备会使用UDF，但大多数仍然使用FAT32。运行fstyp(8)命令来帮助识别设备节点上的文件系统，或者可以在磁盘的设备节点上尝试`gpart
    show`。
- en: Removable devices can have a different device node each time you plug them in.
    Optical drives are a little easier to identify in that most hosts have very few
    optical drives. If you have one optical drive, it’s */dev/cd0*. USB devices appear
    as the next available unit of */dev/da*. When you insert a USB device, a message
    giving the device node and type appears on the console and in */var/log/messages*,
    or you could check `camcontrol devlist` for the new device.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 可移动设备每次插入时可能会有不同的设备节点。光驱稍微容易识别，因为大多数主机的光驱数量非常少。如果你有一个光驱，它的设备节点是*/dev/cd0*。USB设备会显示为*/dev/da*的下一个可用单元。当你插入USB设备时，控制台和*/var/log/messages*会显示一个包含设备节点和类型的消息，或者你也可以通过`camcontrol
    devlist`查看新设备。
- en: FreeBSD provides a */media* mount point for general *removable media* mounts.
    You can create additional mount points as you like—they’re just directories. For
    miscellaneous short-term mounts, FreeBSD offers */mnt*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD提供了一个*/media*挂载点用于一般的*可移动媒体*挂载。你可以根据需要创建其他挂载点——它们只是目录。对于一些杂项的短期挂载，FreeBSD提供了*/mnt*。
- en: 'So, to mount your FAT32 USB device */dev/da0* on */media*, run:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，要将你的FAT32 USB设备*/dev/da0*挂载到*/media*，运行：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Occasionally, you’ll find a thumb drive with a partition table. These devices
    will insist you mount */dev/da0s1* or */dev/da0p1* rather than */dev/da0*. The
    device’s formatting dictates this, not anything in FreeBSD. The `gpart show` command
    can help you figure out which partitions are on a device and what filesystem is
    on each partition.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔，你会发现一个带有分区表的U盘。这些设备会要求你挂载*/dev/da0s1*或*/dev/da0p1*，而不是*/dev/da0*。这是设备的格式化方式所决定的，而不是FreeBSD的设置。`gpart
    show`命令可以帮助你弄清楚设备上的分区以及每个分区上的文件系统。
- en: '***Ejecting Removable Media***'
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***弹出可移动媒体***'
- en: 'To disconnect removable media from your FreeBSD system, first unmount the filesystem.
    Your optical drive won’t open until you unmount the disk. You can pull a USB flash
    drive from its port, but doing so while the filesystem is mounted might damage
    data on the device. Use umount(8) just as you would for any other filesystem:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要从FreeBSD系统中断开可移动媒体，首先卸载文件系统。直到卸载磁盘之前，光驱将无法打开。你可以从端口拔出USB闪存驱动器，但在文件系统挂载的情况下拔出可能会损坏设备上的数据。像对待任何其他文件系统一样，使用umount(8)：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: On many optical drives, `camcontrol eject` opens the drive tray.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多光驱上，`camcontrol eject`可以打开驱动器托盘。
- en: '***Removable Media and /etc/fstab***'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***可移动媒体和/etc/fstab***'
- en: You can update */etc/fstab* with entries for removable media to make system
    maintenance a little easier. If a removable filesystem has an entry in */etc/fstab*,
    you can drop both the filesystem and the device name when mounting it. This means
    that you don’t have to remember the exact device name or filesystem to mount the
    device.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过更新*/etc/fstab*来为可移动媒体添加条目，以便简化系统维护。如果一个可移动文件系统在*/etc/fstab*中有条目，你可以在挂载时省略文件系统和设备名称。这意味着你不必记住精确的设备名称或文件系统来挂载设备。
- en: When listing removable media in */etc/fstab*, be sure to include the `noauto`
    flag. Otherwise, whenever you don’t have the removable media in place, your boot
    will stop in single-user mode because a filesystem is missing.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在*/etc/fstab*中列出可移动媒体时，务必包含`noauto`标志。否则，每当你没有插入可移动媒体时，启动过程会停在单用户模式，因为缺少文件系统。
- en: 'Here’s an */etc/fstab*’s entry for an optical drive:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是光驱的*/etc/fstab*条目：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: While I’m sure you’ve already memorized the meaning of every column in */etc/fstab*,
    we’ll remind you that this entry means, “Mount */dev/cd0* on */cdrom*, using the
    ISO 9660 filesystem. Mount it as read-only, and don’t mount it automatically at
    boot.”
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我确信你已经记住了*/etc/fstab*中每一列的含义，但我们仍然提醒你，这个条目的意思是，“将*/dev/cd0*挂载到*/cdrom*，使用ISO
    9660文件系统。将其设置为只读，并且在启动时不要自动挂载。”
- en: Here’s a similar entry for a thumb drive. I use the `large` option to support
    filesystems larger than 128GB, as discussed in mount_msdosfs(8).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个类似的U盘条目。我使用`large`选项来支持大于128GB的文件系统，如mount_msdosfs(8)中所述。
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: FreeBSD doesn’t provide these by default, but I find having them to be much
    easier on systems where I use removable media regularly. Confirm that your next
    available da device is */dev/da0* ➊, as trying to mount a hard drive that’s already
    mounted won’t work.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD默认不提供这些设置，但在我经常使用可移动媒体的系统中，拥有这些设置会更加方便。确认你下一个可用的da设备是*/dev/da0* ➊，因为尝试挂载一个已经挂载的硬盘是无法成功的。
- en: '***Formatting FAT32 Media***'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***格式化FAT32媒体***'
- en: Thumb drives use the FAT32 filesystem but always come preformatted. As thumb
    drives have a limited number of reads and writes directly proportional to their
    cheapness, do not reformat them capriciously.^([1](footnote.xhtml#ch13fn1)) Only
    reformat thumb drives when their filesystem becomes corrupt. Use newfs_msdos(8)
    to create a FAT32 filesystem.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: U盘使用FAT32文件系统，但总是已经预格式化。由于U盘的读写次数与其价格成反比，切勿轻易重新格式化它们。^([1](footnote.xhtml#ch13fn1))
    只有在文件系统损坏时才重新格式化U盘。使用newfs_msdos(8)来创建FAT32文件系统。
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You’ll get a couple lines of output, and you have a new filesystem.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到几行输出，并且你会有一个新的文件系统。
- en: '***Creating Optical Media***'
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建光盘介质***'
- en: FreeBSD will let you bundle up a bunch of files into an image suitable for burning
    onto a CD, DVD, or Blu-Ray, using either CD 9660 or UDF formats. You can burn
    either image onto disk. FreeBSD supports creating ISOs natively, but you’ll need
    programs from the `cdrtools` package to create UDF.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD允许你将多个文件打包成适合刻录到CD、DVD或Blu-Ray上的镜像，使用CD 9660或UDF格式。你可以将任一镜像刻录到磁盘上。FreeBSD原生支持创建ISO文件，但你需要从`cdrtools`包中获取程序来创建UDF。
- en: In either case, start by putting all of the files and directories you want to
    burn into a single directory. The image will contain these files and directories
    exactly as you arrange them. Remember, optical disk images are read-only. You
    can’t update an image; you can only create a new image, so be sure you have everything
    exactly as you want it. Later this chapter, you’ll learn to mount these images
    with mdconfig(8).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，首先将你想要刻录的所有文件和目录放入一个单一的目录。镜像将包含这些文件和目录，按照你安排的方式保存。记住，光盘镜像是只读的。你不能更新一个镜像；你只能创建一个新的镜像，所以一定要确保所有内容都正确无误。稍后本章你将学到如何使用mdconfig(8)挂载这些镜像。
- en: In both of these examples, we’re creating an image from the files contained
    in */home/xistence/cdfiles*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个示例中，我们都是从*/home/xistence/cdfiles*中的文件创建一个镜像。
- en: '**Creating ISOs**'
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建ISO**'
- en: Use makefs(8) to create an ISO.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用makefs(8)来创建ISO。
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Start by using `-t` ➊ to specify the type of filesystem to create—in this case,
    CD 9660\. The `-o` flag ➋ lets you specify filesystem-specific options. You can
    get a whole list of options from the makefs(8) man page, but the ones shown here
    suffice for most images. We then need the filename ➌ for the created image and
    the source directory ➍ for those files.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先使用`-t` ➊指定要创建的文件系统类型——在本例中是CD 9660。`-o`标志➋允许你指定特定于文件系统的选项。你可以从makefs(8)的手册页中获得完整的选项列表，但这里显示的选项对于大多数镜像已经足够。接下来，我们需要指定创建的镜像文件名
    ➌ 和源目录 ➍，该目录中包含要复制的文件。
- en: 'To make an image containing the files in */home/xistence/cdfiles* as *bert.iso*,
    run:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个包含*/home/xistence/cdfiles*中所有文件的镜像，并命名为*bert.iso*，运行：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Bert can now wastefully burn his ISO to physical media.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Bert现在可以浪费地将ISO刻录到物理介质上。
- en: '**Creating a UDF**'
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建UDF**'
- en: Creating a UDF requires using mkisofs(1) from the `cdrtools` package. Give the
    destination image file with `-o`. Enable the Joliet and Rock Ridge extensions
    with `-J` and `-R`, respectively. (I’m not going to go into what each of these
    do, but if you want your ISO to behave like a disk from this millennium, you need
    them.) Add the `-udf` and `-iso-level 3` flags.^([2](footnote.xhtml#ch13fn2))
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 创建UDF需要使用来自`cdrtools`包的mkisofs(1)命令。使用`-o`指定目标镜像文件。使用`-J`和`-R`分别启用Joliet和Rock
    Ridge扩展。（我不会详细说明这些选项的作用，但如果你希望ISO像本世纪的光盘一样工作，你需要它们。）添加`-udf`和`-iso-level 3`标志。^([2](footnote.xhtml#ch13fn2))
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You now have a UDF image based on what’s in */home/xistence/cdfiles*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了一个基于*/home/xistence/cdfiles*内容的UDF镜像。
- en: Whichever format you create, I encourage you to mount it and double-check your
    work before burning a physical disk. If you’re lucky, you’ll remember the stuff
    you forgot to include on the image.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你创建哪种格式，我建议你在刻录物理光盘之前先挂载它，并仔细检查你的工作。如果你幸运的话，你会记得在镜像中忘记包含的东西。
- en: '**Burning ISOs to Optical Media**'
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**刻录ISO到光学介质**'
- en: Use cdrecord(1) from the `cdrtools` package to burn ISO images to the disk.
    Give the image file as an argument.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用来自`cdrtools`包的cdrecord(1)命令将ISO镜像刻录到光盘。将镜像文件作为参数提供。
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Depending on the drive speed and image size, this might take a while.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 根据驱动器速度和映像大小，这可能需要一些时间。
- en: The cdrecord(1) program defaults to using */dev/cd0*. If you have additional
    optical drives, use the `-dev` flag to give an alternate device name.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: cdrecord(1)程序默认使用*/dev/cd0*。如果你有其他光驱，可以使用`-dev`标志指定另一个设备名称。
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You now have a flimsy plastic disk that you’ll use twice before flinging it
    into the landfill. Congratulations!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了一张脆弱的塑料光盘，你将在使用两次后把它丢进垃圾填埋场。恭喜！
- en: '**Burning UDF to Optical Media**'
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**将UDF刻录到光学介质**'
- en: While you *can* use cdrecord(1) to burn UDF images to media, the growisofs(1)
    command from the `dvd+rw-tools` package is generally recommended. You’ll need
    the `-dvd-compat` and `-Z` flags. Then, specify the device and the image file.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你*可以*使用cdrecord(1)将UDF镜像刻录到介质上，但通常推荐使用`dvd+rw-tools`包中的growisofs(1)命令。你需要使用`-dvd-compat`和`-Z`标志。然后，指定设备和镜像文件。
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Suppose I want to burn *bert.udf* to the Blu-Ray in */dev/cd0*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我想将*bert.udf*刻录到*/dev/cd0*的蓝光光盘中。
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: UDF files can be huge. Go make some tea. Eventually, you’ll have a burned disk.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: UDF文件可能非常大。去泡杯茶吧。最终，你会得到一张刻录好的光盘。
- en: '***Writing Images to Thumb Drives***'
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***将映像写入闪存驱动器***'
- en: USB thumb drives have increasingly supplanted optical disks, thanks in part
    to their reusability. FreeBSD supports writing disk images to thumb drives with
    dd(1).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: USB闪存驱动器由于其可重复使用性，逐渐取代了光盘。FreeBSD支持使用dd(1)命令将磁盘映像写入闪存驱动器。
- en: Be very certain which device node is your thumb drive and which is your system
    hard drive. Thumb drives show up as */dev/da* devices, exactly like many hard
    drives. Overwriting the wrong hard drive is embarrassing.^([3](footnote.xhtml#ch13fn3))
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要非常确定哪个设备节点是你的 U 盘，哪个是你的系统硬盘。U 盘显示为 */dev/da* 设备，就像许多硬盘一样。覆盖错误的硬盘是非常尴尬的。^([3](footnote.xhtml#ch13fn3))
- en: The dd(1) command looks confusing at first glance.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: dd(1) 命令乍一看可能会让人感到困惑。
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `if=` argument ➊ gives the file you want to copy. The `of=` argument ➋
    is the device node to copy to. The `bs=` flag ➌ gives the amount to copy at one
    time. Without this, dd(1) copies in 512-byte increments. The `conv=` argument
    ➍ gives dd(1) instructions about how to convert the incoming file. In this case,
    *sync* tells dd(1) to synchronize the size of the incoming and outgoing buffer.
    To burn *bertimage.udf* to thumb drive */dev/da9*, I would run:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`if=` 参数 ➊ 指定你要复制的文件。`of=` 参数 ➋ 指定你要复制到的设备节点。`bs=` 标志 ➌ 指定一次复制的数据量。如果没有这个，dd(1)
    会按 512 字节递增进行复制。`conv=` 参数 ➍ 给 dd(1) 提供如何转换输入文件的指令。在这种情况下，*sync* 告诉 dd(1) 同步输入和输出缓冲区的大小。为了将
    *bertimage.udf* 刻录到 U 盘 */dev/da9*，我会运行：'
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Wait a bit, and you’ll have an imaged thumb drive. Other uses of dd(1) might
    not need the `conv=` flag, but always use `bs`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下，你就会得到一个镜像的 U 盘。dd(1) 的其他用法可能不需要 `conv=` 标志，但始终使用 `bs`。
- en: Now let’s look at some other filesystems you might find useful.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看一些你可能会发现有用的其他文件系统。
- en: '**Memory Filesystems**'
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**内存文件系统**'
- en: In addition to putting filesystems on disks or partitions, FreeBSD lets you
    create partitions from files, pure RAM, and a combination of the two. One of the
    most popular uses of this feature is for *memory filesystems*, or *memory disks*.
    Reading and writing files to and from memory is much faster than accessing files
    on disk, which makes a memory-backed filesystem a huge optimization for certain
    applications. As with everything else in memory, however, you lose the contents
    of your memory disk at system shutdown.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将文件系统放在磁盘或分区上，FreeBSD 还允许你从文件、纯 RAM 或两者的组合中创建分区。这个功能最常见的用途之一是 *内存文件系统* 或 *内存磁盘*。将文件读写到内存中的速度比访问磁盘上的文件要快得多，这使得内存支持的文件系统在某些应用中是一项巨大的优化。然而，和其他所有内存操作一样，你会在系统关闭时丢失内存磁盘中的内容。
- en: 'FreeBSD supports two different memory-backed disks: *tmpfs* (pronounced “temp
    f s”) and *memory disks*. While they have similar concepts behind them, the underlying
    code is completely different, and they serve different roles. Use tmpfs(5) for
    memory-backed filesystems on long-running systems. Memory disks are more flexible
    but better suited for short-term use or mounting disk images.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 支持两种不同的内存支持磁盘：*tmpfs*（发音为“temp f s”）和*内存磁盘*。虽然它们背后有相似的概念，但底层代码完全不同，而且它们的作用也不同。在长期运行的系统上使用
    tmpfs(5) 作为内存支持文件系统。内存磁盘更加灵活，但更适合短期使用或挂载磁盘镜像。
- en: '***tmpfs***'
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***tmpfs***'
- en: The *tmp* in tmpfs(5) doesn’t mean “temporary.” It literally means *tmp*, as
    in */tmp*. Use tmpfs for a speedy memory-backed */tmp* and similar filesystems.
    Don’t deploy tmpfs everywhere you see a path with *tmp* in it, though. While */tmp*
    is supposed to be cleared at every boot, */var/tmp* is supposed to survive a reboot.
    You might use tmpfs for application lock files and other ephemeral data where
    vastly increased speed would improve application performance. While tmpfs has
    a troubled history, as of FreeBSD 10, it’s widely deployed and considered ready
    for production.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: tmpfs(5) 中的 *tmp* 并不意味着“临时”。它字面上意味着 *tmp*，即 */tmp*。使用 tmpfs 来加速内存支持的 */tmp*
    和类似的文件系统。不过，不要在你看到路径中有 *tmp* 时就到处部署 tmpfs。虽然 */tmp* 应该在每次启动时清空，但 */var/tmp* 应该在重启后依然存在。你可能会使用
    tmpfs 来处理应用程序锁文件和其他短暂数据，这些数据的速度大幅提升会改善应用程序性能。尽管 tmpfs 曾有过一段困难的历史，但从 FreeBSD 10
    开始，它已广泛部署并被认为可以用于生产环境。
- en: Create a tmpfs by mounting it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通过挂载来创建一个 tmpfs。
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If your system has the sysctl `vfs.usermount` set to 1, users can create and
    mount tmpfs filesystems.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的系统将 sysctl `vfs.usermount` 设置为 1，用户就可以创建和挂载 tmpfs 文件系统。
- en: '**tmpfs Options**'
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**tmpfs 选项**'
- en: A tmpfs defaults to the size of the system’s available RAM plus the available
    swap space. Repeatedly copying a file to */tmp* could exhaust system memory. This
    would be bad. Set a maximum size for your tmpfs with the `size` option.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，tmpfs 的大小为系统可用的 RAM 加上可用的交换空间。反复将文件复制到 */tmp* 可能会耗尽系统内存。这将是非常糟糕的。通过 `size`
    选项为你的 tmpfs 设置一个最大大小。
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Control the ownership and permissions on a tmpfs with the `uid`, `gid`, and
    `mode` options. An actual */tmp* directory needs to be world-writable with the
    sticky bit set, so be sure to use the option `mode=1777`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `uid`、`gid` 和 `mode` 选项来控制 tmpfs 的所有权和权限。实际的 */tmp* 目录需要具有世界可写权限，并设置粘滞位，因此请确保使用选项
    `mode=1777`。
- en: If the tmpfs is for a specific user, even an unprivileged user that runs only
    a single application, assign that user ownership of the tmpfs.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 tmpfs 是为特定用户而设置的，即使是只运行一个应用程序的无特权用户，也应将该用户的所有权分配给 tmpfs。
- en: '**tmpfs at Boot**'
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Boot 时的 tmpfs**'
- en: Now that you can set a maximum size and the proper permissions, it’s okay to
    use */etc/fstab* to automatically create a tmpfs at boot.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以设置最大大小和适当的权限，因此可以使用 */etc/fstab* 来自动在启动时创建 tmpfs。
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: For more complicated memory-backed disks, consider a traditional memory disk.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的内存后备磁盘，可以考虑使用传统的内存磁盘。
- en: '***Memory Disks***'
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***内存磁盘***'
- en: A memory disk is an ephemeral storage device. Despite the name, a memory disk
    isn’t always a chunk of memory being treated as a disk. It can be such a device,
    but it might instead use a file or swap space or some other backing store. No
    matter what, the memory disk disappears at system shutdown.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 内存磁盘是一个短暂的存储设备。尽管名称是内存磁盘，内存磁盘并不总是将一块内存当作磁盘来使用。它也可以是这样一个设备，但它可能使用文件、交换空间或其他后备存储。无论如何，内存磁盘在系统关闭时会消失。
- en: '**Memory Disk Types**'
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**内存磁盘类型**'
- en: 'Memory disks come in four types: malloc-backed, swap-backed, vnode-backed,
    and null.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 内存磁盘有四种类型：malloc-backed、swap-backed、vnode-backed 和 null。
- en: '*Malloc-backed* memory disks are pure memory. Even if your system runs short
    on memory, FreeBSD won’t swap out the malloc-backed disk. Much like tmpfs(5),
    using a large malloc-backed disk is a great way to exhaust system memory. Malloc-backed
    disks are most useful for swapless embedded devices.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*Malloc-backed* 内存磁盘是纯内存磁盘。即使系统内存不足，FreeBSD 也不会将 malloc-backed 磁盘交换出去。与 tmpfs(5)
    类似，使用大容量的 malloc-backed 磁盘是耗尽系统内存的一种好方法。Malloc-backed 磁盘对于没有交换空间的嵌入式设备特别有用。'
- en: '*Swap-backed* memory disks are mostly memory, but they also access the system
    swap partition. If the system runs out of memory, it moves the least recently
    used parts of memory to swap, as discussed in [Chapter 21](ch21.xhtml#ch21). Swap-backed
    disks are usually the best compromise between speed and performance.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*Swap-backed* 内存磁盘大多数是内存，但它们也会访问系统的交换分区。如果系统内存不足，它会将最近最少使用的内存部分移动到交换区，正如在[第21章](ch21.xhtml#ch21)中讨论的那样。Swap-backed
    磁盘通常是速度和性能之间最好的折衷。'
- en: '*Vnode-backed* memory disks are files on disk. While you can use a file as
    backing for your memory disk, this is mostly useful for mounting disk images and
    testing.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*Vnode-backed* 内存磁盘是磁盘上的文件。虽然你可以使用文件作为内存磁盘的后备存储，但这主要用于挂载磁盘映像和测试。'
- en: A *null* memory disk discards everything sent to it. Any writes are successful,
    while any reads return zero. If I didn’t mention null memory disks, someone would
    write to complain, but I’m not giving a disk guaranteed to lose all data any more
    coverage than this.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*Null* 内存磁盘会丢弃发送到它的所有内容。所有写入操作都会成功，而所有读取操作都返回零。如果我没有提到 null 内存磁盘，可能有人会写信抱怨，但我不会再给一个保证丢失所有数据的磁盘更多的介绍。'
- en: Once you know what you want to do, use mdmfs(8) to perform the action.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你知道想要做什么，就使用 mdmfs(8) 执行操作。
- en: '**Creating and Mounting Memory Disks**'
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建和挂载内存磁盘**'
- en: The mdmfs(8) utility is a handy frontend for several programs, such as mdconfig(8)
    and newfs(8). It handles the drudgery of configuring devices and creating filesystems
    on those devices, and makes creating memory disks as easy as possible. You need
    to know only the size of the disk you want to use, the type of the memory disk,
    and the mount point.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: mdmfs(8) 工具是多个程序的便捷前端，例如 mdconfig(8) 和 newfs(8)。它处理设备配置和文件系统创建的繁琐工作，使创建内存磁盘尽可能简单。你只需知道你想使用的磁盘大小、内存磁盘类型和挂载点。
- en: 'Swap-backed memory disks are the default. Just tell mdmfs(8) the size of the
    disk and the mount point. Here, we create a 48MB swap-backed memory disk on */home/mwlucas/test*:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Swap-backed 内存磁盘是默认设置。只需告诉 mdmfs(8) 磁盘的大小和挂载点。这里，我们在 */home/mwlucas/test* 上创建了一个
    48MB 的 swap-backed 内存磁盘：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `-s` flag gives the size of the disk. If you run mount(8) without any arguments,
    you’ll see that you now have the memory disk device */dev/md0* mounted on that
    directory.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`-s` 标志指定磁盘大小。如果你运行 mount(8) 而不带任何参数，你会看到你现在已经在该目录上挂载了内存磁盘设备 */dev/md0*。'
- en: The `-t` flag enables TRIM, which we’ll discuss in the following section, “Memory
    Disk Headaches.”
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`-t` 标志启用 TRIM，我们将在接下来的“内存磁盘问题”一节中讨论。'
- en: To create and mount a malloc-backed disk, add the `-M` flag.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并挂载一个malloc支持的磁盘，添加`-M`标志。
- en: To mount a vnode-backed memory disk, use the `-F` flag and the path to the image
    file.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要挂载一个vnode支持的内存磁盘，使用`-F`标志并指定映像文件的路径。
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `md` entry we’ve been using all along here means, “I don’t care what device
    name I get; just give me the next free one.” You can also specify a particular
    device name if you like. Here, I declare I want disk device */dev/md9*:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直使用的`md`条目意味着，“我不在乎我得到什么设备名称，给我下一个空闲的就行。”你也可以指定一个特定的设备名称，如果你愿意的话。在这里，我声明我想要磁盘设备*/dev/md9*：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**Memory Disk Headaches**'
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**内存磁盘头痛**'
- en: Traditional swap-backed memory disks never returned used memory to the system.
    Once you wrote to a memory disk, that memory was used up. If you needed a larger
    memory disk, you had to permanently allocate memory for it. This was one reason
    FreeBSD included tmpfs(5).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的交换支持的内存磁盘从未将已使用的内存返回给系统。一旦你写入内存磁盘，那块内存就被消耗掉了。如果你需要一个更大的内存磁盘，你必须为其永久分配内存。这是FreeBSD包括tmpfs(5)的原因之一。
- en: If the filesystem on the memory disk supports *TRIM*, however, FreeBSD now returns
    unused memory to the system. TRIM is not an acronym but rather a protocol for
    telling a disk which sectors are no longer in use. UFS, the default memory disk
    format, supports TRIM. Enable TRIM in mdmfs with the `-t` flag. If you’re using
    a different filesystem on a memory disk, though, be sure it’s strictly temporary.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果内存磁盘上的文件系统支持*TRIM*，FreeBSD现在会将未使用的内存返回给系统。TRIM不是一个缩写，而是一种告诉磁盘哪些扇区不再使用的协议。UFS，默认的内存磁盘格式，支持TRIM。在mdmfs中通过`-t`标志启用TRIM。如果你在内存磁盘上使用的是其他文件系统，请确保它是严格临时的。
- en: To free the memory from a memory disk, shut down the memory disk.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要释放内存磁盘的内存，关闭内存磁盘。
- en: '**Memory Disk Shutdown**'
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**内存磁盘关闭**'
- en: 'To remove a memory disk, you must unmount the partition and destroy the disk
    device. Destroying the disk device frees the memory used by the device, which
    is useful when your system is heavily loaded. To find the disk device, run mount(8)
    and find your memory disk partition. Somewhere in the output, you’ll find a line
    like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除内存磁盘，必须卸载分区并销毁磁盘设备。销毁磁盘设备会释放该设备占用的内存，这在系统负载较重时非常有用。要找到磁盘设备，运行mount(8)并查找你的内存磁盘分区。在输出的某个位置，你会找到类似这样的行：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we see memory disk */dev/md41* mounted on */mnt*. Let’s unmount it and
    destroy it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到内存磁盘*/dev/md41*挂载在*/mnt*上。让我们卸载并销毁它。
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Unmounting with `umount` ➊ is done exactly as with other filesystems. The mdconfig(8)
    call is a new one, however. Use mdconfig(8) to directly manage memory devices.
    The `-d` flag ➋ means *destroy*, and the `-u` flag ➌ gives a device number. The
    above destroys the device */dev/md41*, or the `md` device number 41\. The memory
    used by this device is now freed for other uses.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`umount` ➊卸载就像处理其他文件系统一样。mdconfig(8)调用是一个新的命令。使用mdconfig(8)直接管理内存设备。`-d`标志
    ➋表示*销毁*，`-u`标志 ➌提供一个设备号。上述操作销毁了设备*/dev/md41*，即`md`设备号41。该设备占用的内存现在被释放，可以供其他用途。
- en: '**Memory Disks and /etc/fstab**'
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**内存磁盘与/etc/fstab**'
- en: If you list memory disks in */etc/fstab*, FreeBSD automatically creates them
    at boot time. These entries look more complicated than the other entries but aren’t
    too bad if you understand the mdmfs(8) commands we’ve been using so far.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在*/etc/fstab*中列出了内存磁盘，FreeBSD会在启动时自动创建它们。这些条目看起来比其他条目复杂，但如果你理解我们到目前为止使用的mdmfs(8)命令，其实也不难。
- en: 'We’re allowed to use *md* as a device name to indicate a memory disk. Choose
    the mountpoint just as for any other device, and use the filesystem type `mfs`.
    Under `Options`, list *rw* (for read-write) and the command line options used
    to create this device. If this is a long-term mount, add `-t` to enable TRIM.
    To create our 48MB filesystem mounted at */home/mwlucas/test*, use the following
    */etc/fstab* entry:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用*md*作为设备名称来表示内存磁盘。选择挂载点，就像任何其他设备一样，并使用文件系统类型`mfs`。在`Options`下，列出*rw*（表示可读写）以及用于创建此设备的命令行选项。如果这是一个长期挂载，添加`-t`以启用TRIM。要创建一个48MB的文件系统并将其挂载到*/home/mwlucas/test*，使用以下*/etc/fstab*条目：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Looks easy, doesn’t it? The only problem is that the long line messes up your
    nice and even */etc/fstab* entry’s appearance. Well, they’re not the only things
    that will make this file ugly, as we’ll soon see.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很简单，是不是？唯一的问题是，长长的一行会弄乱你漂亮整齐的*/etc/fstab*条目的外观。好吧，它们并不是唯一会让这个文件变丑的东西，正如我们很快将看到的。
- en: '***Mounting Disk Images***'
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***挂载磁盘映像***'
- en: 'You can use mdmfs(8) to view UFS disk images, but most often you want to examine
    the contents of an ISO or UDF file without burning it to disk. (FreeBSD’s tar(1)
    can access the contents of an ISO, but not a UDF.) Just attach a memory disk to
    a file with the mdconfig(8) command’s `-a` flag. Here, I attach Bert’s ISO to
    a memory device:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用mdmfs(8)查看UFS磁盘镜像，但通常你希望查看ISO或UDF文件的内容，而不需要将其刻录到磁盘上。（FreeBSD的tar(1)可以访问ISO的内容，但无法访问UDF。）只需使用mdconfig(8)命令的`-a`标志将内存磁盘附加到文件。这里，我将Bert的ISO附加到一个内存设备：
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We tell mdconfig(8) to attach ➊ a vnode-backed ➋ memory device to the file
    specified ➌. The mdconfig(8) command responds by telling us the device ➍ it’s
    attached to. Now we just mount the device with the proper mount command for the
    filesystem:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉mdconfig(8)将一个基于vnode的内存设备➊附加到指定的文件➌。mdconfig(8)命令响应并告诉我们它附加到的设备➍。现在，我们只需使用适当的挂载命令将该设备挂载到文件系统：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: I can now verify that the ISO contains Bert’s files, so he doesn’t get to whine
    that the ISO is busted.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在可以验证ISO中包含了Bert的文件，这样他就不会抱怨ISO文件坏掉了。
- en: One common mistake people make at this point is mounting the image without specifying
    the filesystem type. You might get an error, or you might get a successful mount
    that contains no data—by default, mount(8) assumes that the filesystem is UFS!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步，常见的错误是没有指定文件系统类型就挂载镜像。你可能会遇到错误，或者可能会成功挂载但没有数据——默认情况下，mount(8)会假设文件系统是UFS！
- en: When you’re done accessing the data, be sure to unmount the image and destroy
    the memory disk device just as you would for any other memory device. While vnode-backed
    memory disks don’t consume system memory, leaving unused memory devices around
    will confuse you months later when you wonder why they appear in */dev*. If you’re
    not sure what memory devices a system has, use `mdconfig -l` to view all configured
    md(5) devices.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 完成数据访问后，请确保卸载镜像并销毁内存磁盘设备，就像你对待任何其他内存设备一样。虽然基于vnode的内存磁盘不会消耗系统内存，但如果你留下未使用的内存设备，几个月后你可能会困惑为什么它们出现在*/dev*中。如果你不确定系统上有哪些内存设备，可以使用`mdconfig
    -l`查看所有已配置的md(5)设备。
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'I have two memory devices? Add the `-u` flag and the device number to see what
    type of memory device it is. Let’s see what memory device 1 (*/dev/md1*) is:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我有两个内存设备？添加`-u`标志和设备编号，看看它是什么类型的内存设备。让我们来看一下内存设备1（*/dev/md1*）是什么：
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: I have an ISO image mounted on this system? Wow. I should probably reboot some
    month. Nah, that’s too much work; I’ll just unmount the filesystem and destroy
    the memory device.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这个系统上挂载了一个ISO镜像？哇。我可能应该在某个月重启一下。算了，太麻烦了，我直接卸载文件系统并销毁内存设备就好了。
- en: '***Filesystems in Files***'
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***文件系统中的文件***'
- en: One trick used in embedded systems is building complete filesystem images on
    a local file. In the previous section, we saw how we could use memory disks to
    mount and access CD disk images. You can use the same techniques to create, update,
    and access UFS disk images.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式系统中使用的一个技巧是将完整的文件系统镜像构建在本地文件中。在前一部分中，我们看到如何使用内存磁盘挂载和访问CD磁盘镜像。你可以使用相同的技术来创建、更新和访问UFS磁盘镜像。
- en: To use a filesystem in a file, you must create a file of the proper size, attach
    the file to a memory device, place a filesystem on the device, and mount the device.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要在文件中使用文件系统，必须创建一个合适大小的文件，将该文件附加到内存设备上，在设备上放置文件系统，然后挂载该设备。
- en: '**Creating an Empty Filesystem File**'
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建空的文件系统文件**'
- en: 'Use truncate(1) to create an empty file for a filesystem. These files are sparse
    files: they’re labeled as having a certain size but don’t actually take up any
    space until you put something in them. An empty sparse file takes up one filesystem
    block and grows when you put stuff in it. This means you can create an image for
    a disk of any size but use up only an amount of space equal to the stuff you put
    in the image.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用truncate(1)创建一个空的文件系统文件。这些文件是稀疏文件：它们标记为具有某个大小，但在你往里面放东西之前并不会占用任何空间。一个空的稀疏文件只占用一个文件系统块，放入数据后它才会增长。这意味着你可以为任意大小的磁盘创建一个镜像文件，但实际占用的空间只等于你放入镜像中的数据量。
- en: 'Use the `-s` option and the file size to create an image file. Here, I create
    a 1GB file:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-s`选项和文件大小来创建镜像文件。这里，我创建了一个1GB的文件：
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The resulting file claims to be pretty large.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 结果文件显示它的大小相当大。
- en: '[PRE33]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: But if you check the disk usage, you’ll see something different.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你检查磁盘使用情况，你会看到不同的结果。
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This 1GB file uses one block on the disk.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个1GB的文件在磁盘上使用一个块。
- en: Sparse files never shrink. They can only grow. If you erase a bunch of files
    from your disk image, the image file still needs that space.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 稀疏文件永远不会缩小。它们只能增长。如果你从磁盘镜像中删除了大量文件，镜像文件仍然需要这些空间。
- en: Also, not all filesystems support sparse files. UFS and ZFS do. If you’re trying
    to create a sparse file on a FAT32 filesystem, you’re probably solving the wrong
    problem.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，并不是所有文件系统都支持稀疏文件。UFS 和 ZFS 支持。如果你正在尝试在 FAT32 文件系统上创建稀疏文件，那可能是你在解决错误的问题。
- en: '**Creating the Filesystem on the File**'
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**在文件上创建文件系统**'
- en: 'To get a filesystem on the file, first associate the file with a device with
    a vnode-backed memory disk. We did exactly this in the last section:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要在文件上获取文件系统，首先通过 vnode 支持的内存磁盘将文件与设备关联。我们在上一节中做的就是这个操作：
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, let’s make a filesystem on this device. This is much like creating a UFS
    filesystem on a thumb disk with the newfs(8) command. Soft updates journaling
    is exactly as useful on file-backed filesystems as on disk-backed ones, so enable
    them with `-j`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在这个设备上创建一个文件系统。这很像在一个闪存盘上使用 newfs(8) 命令创建 UFS 文件系统。软更新日志与文件支持文件系统一样对磁盘支持的文件系统非常有用，因此通过
    `-j` 启用它们。
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The newfs(8) program prints out basic information about the disk, such as its
    size, block and fragment sizes, and the inode count.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: newfs(8) 程序会输出磁盘的基本信息，例如其大小、块和碎片大小，以及 inode 数量。
- en: 'Now that you have a filesystem, mount it:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了一个文件系统，挂载它：
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Congratulations! You now have a 1GB file-backed filesystem. Copy files to it,
    dump it to tape, or use it in any way you would use any other filesystem. But
    in addition to that, you can move it just like any other file.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你现在拥有了一个 1GB 的文件支持文件系统。你可以将文件复制到其中，将其转储到磁带上，或以任何你使用其他文件系统的方式使用它。但除此之外，你还可以像对待其他文件一样移动它。
- en: '**File-Backed Filesystems and /etc/fstab**'
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**文件支持文件系统和 /etc/fstab**'
- en: You can mount a file-backed filesystem automatically at boot with the proper
    entry in */etc/fstab*, much like you can automatically mount any other memory
    disk. You simply have to specify the name of the file with `-F` and use `-P` to
    tell the system not to create a new filesystem on this file but just to use the
    one already there. Here, we mount the file-backed filesystem we created on */mnt*
    automatically at boot time.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在 */etc/fstab* 中添加正确的条目，自动在启动时挂载文件支持文件系统，就像自动挂载其他内存磁盘一样。你只需使用 `-F` 指定文件名，并使用
    `-P` 告诉系统不要在这个文件上创建新文件系统，而是使用已经存在的那个文件系统。在这里，我们将创建的文件支持文件系统自动挂载到 */mnt*，并在启动时挂载。
- en: '[PRE38]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: I told you we’d see */etc/fstab* entries uglier than the one for generic memory
    disks, didn’t I?
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我告诉过你，我们会看到比通用内存磁盘更丑的 */etc/fstab* 条目，是吧？
- en: '**devfs**'
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**devfs**'
- en: devfs(5) is a dynamic filesystem for managing device nodes. Remember, in a Unix-like
    operating system, *everything* is a file. This includes physical hardware. Almost
    all devices on the system have a device node under */dev*. You’ve seen a bunch
    of device nodes for disks, but you’ll also see keyboards (*/dev/ukbd0* or */dev/kbd0*),
    the console (*/dev/console*), sound mixers (*/dev/mixer0*), and more. You’ll also
    find device nodes for logical devices, like the random number generator (*/dev/random*),
    terminal sessions (*/dev/ttyv0*), and so on.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: devfs(5) 是一个用于管理设备节点的动态文件系统。记住，在类 Unix 操作系统中，*一切*都是文件。这包括物理硬件。几乎所有系统上的设备都有一个
    */dev/* 下的设备节点。你已经见过一些磁盘的设备节点，但你也会看到键盘（*/dev/ukbd0* 或 */dev/kbd0*）、控制台（*/dev/console*）、音频混音器（*/dev/mixer0*）等等。你还会找到逻辑设备的设备节点，例如随机数生成器（*/dev/random*）、终端会话（*/dev/ttyv0*）等等。
- en: Once upon a time, the sysadmin was responsible for making these device node
    files. Lucky sysadmins managed an operating system that came with a shell script
    to handle device node creation and permissions. If the OS authors hadn’t provided
    such a shell script, or if the server had unusual hardware not included in that
    shell script, the sysadmin had to create the node with animal sacrifices and mknod(8).
    If any little thing went wrong, the device wouldn’t work. The other option was
    to ship the operating system with device nodes for every piece of hardware imaginable.
    Sysadmins could be confident—well, *mostly* confident—that the desired device
    nodes were available, somewhere, buried within the thousands of files under */dev*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 曾几何时，系统管理员负责创建这些设备节点文件。幸运的系统管理员管理着一个带有用于处理设备节点创建和权限的 shell 脚本的操作系统。如果操作系统的开发者没有提供这样的脚本，或者如果服务器有不包含在脚本中的特殊硬件，那么系统管理员就得通过动物祭祀和
    mknod(8) 创建节点。如果出现任何小问题，设备就无法正常工作。另一种选择是将操作系统与每种硬件设备的设备节点一起发布。系统管理员可以放心——嗯，*大致*放心——所需的设备节点在某个地方，埋藏在
    */dev* 下的成千上万的文件中。
- en: 'Of course, the kernel knows exactly what characteristics each device node should
    have. With devfs(5), FreeBSD simply asks the kernel what device nodes the kernel
    thinks the system should have and provides exactly those—and no more. This works
    well for most people. You and I are not “most people,” however. We expect odd
    things from our computers. Perhaps we need to make device nodes available under
    different names, change device node ownership, or configure our hardware uniquely.
    FreeBSD breaks the problem of device node management into three pieces: configuring
    devices present at boot, global availability and permissions, and configuring
    devices that appear dynamically after boot with devd(8).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，内核确切知道每个设备节点应该具有什么特性。使用 devfs(5)，FreeBSD 仅询问内核系统应具备哪些设备节点，并提供这些设备节点——没有更多。对于大多数人来说，这样的方式非常有效。不过，你我并非“多数人”。我们对计算机有着不同寻常的需求。或许我们需要使用不同的名称来访问设备节点、改变设备节点的所有权，或者独特地配置硬件。FreeBSD
    将设备节点管理的问题分解为三部分：启动时配置设备、全局可用性与权限以及配置启动后通过 devd(8) 动态出现的设备。
- en: '***/dev at Boot***'
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***/dev 启动时***'
- en: 'When device nodes were permanent files on disk, the sysadmin could symlink
    to those nodes or change their permissions without worrying that his changes would
    vanish. With an automated, dynamic device filesystem, this assurance disappears.
    (Of course, you no longer have to worry about occult mknod(8) commands either,
    so you’re better off in the long run.) The device node changes could include,
    for example:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当设备节点是磁盘上的永久文件时，系统管理员可以创建指向这些节点的符号链接或更改它们的权限，而不必担心这些更改会消失。随着自动化的动态设备文件系统，这种保障消失了。（当然，你也不再需要担心神秘的
    mknod(8) 命令了，所以从长远来看，你会受益。）设备节点的更改可能包括例如：
- en: Making device nodes available under different names
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使设备节点以不同名称可用
- en: Changing ownership of device nodes
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改设备节点的所有权
- en: Concealing device nodes from users
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏设备节点不让用户访问
- en: '**DEVICE MANAGEMENT AND SERVERS**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**设备管理与服务器**'
- en: For the most part, device node management on servers works without any adjustment
    or intervention. The place I most often need to muck with device nodes is on laptops
    and the occasional workstation. FreeBSD’s device node management tools are very
    powerful and flexible, and include support for things I wouldn’t expect to use
    in a century. We’ll touch only upon the basics. Don’t think that you must master
    devfs(5) to get your server running well!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，服务器上的设备节点管理工作无需任何调整或干预。我最常需要调整设备节点的地方是在笔记本电脑和偶尔的工作站上。FreeBSD 的设备节点管理工具非常强大且灵活，支持一些我不曾预料到的使用方式。我们只讨论基础部分。不要认为你必须精通
    devfs(5) 才能让你的服务器运行得很好！
- en: At boot time, devfs(8) creates device nodes in accordance with the rules in
    */etc/devfs.conf*.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动时，devfs(8) 根据 */etc/devfs.conf* 中的规则创建设备节点。
- en: '**devfs.conf**'
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**devfs.conf**'
- en: 'The */etc/devfs.conf* file lets you create links, change ownership, and set
    permissions for devices available at boot. Each rule has the following format:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*/etc/devfs.conf* 文件允许您为启动时可用的设备创建链接、改变所有权和设置权限。每条规则的格式如下：'
- en: '[PRE39]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The valid actions are `link` (create a link), `perm` (set permissions), and
    `own` (set owner). The `realdevice` entry is a preexisting device node, while
    the last setting is your desired value. For example, here we create a new name
    for a device node:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的操作包括 `link`（创建链接）、`perm`（设置权限）和 `own`（设置所有者）。`realdevice` 条目是一个预存在的设备节点，而最后一个设置是您所需的值。例如，在这里我们为设备节点创建一个新名称：
- en: '[PRE40]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We want a symbolic link ➊ to the device node */dev/cd0* ➋ (an optical drive),
    and we want this link to be named */dev/cdrom* ➌. If we reboot with this entry
    in */etc/devfs.conf*, our optical drive */dev/cd0* also appears as */dev/cdrom*,
    as many desktop multimedia programs expect.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望为设备节点 */dev/cd0* ➋（光驱）创建一个符号链接 ➊，并希望该链接命名为 */dev/cdrom* ➌。只要我们在 */etc/devfs.conf*
    文件中添加这条规则并重启，光驱 */dev/cd0* 就会以 */dev/cdrom* 的形式出现，正如许多桌面多媒体程序所期望的那样。
- en: 'To change the permissions of a device node, give the desired permissions in
    octal form as the desired value:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改设备节点的权限，请以八进制形式提供所需的权限值：
- en: '[PRE41]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, we set the permissions on */dev/cd0* (our CD device, again) so that any
    system user can read or write to the device. Remember, changing the permissions
    on the */dev/cdrom* link won’t change the permissions on the device node, just
    the symlink.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置 */dev/cd0*（我们的 CD 设备）的权限，以便任何系统用户都可以读取或写入该设备。记住，更改 */dev/cdrom* 链接的权限不会更改设备节点的权限，只会更改符号链接的权限。
- en: 'Finally, we can also change the ownership of a device. Changing a device node’s
    owner usually indicates that you’re solving a problem the wrong way and that you
    may need to stop and think. FreeBSD happily lets you mess up your system if you
    insist, however. Here, we let a particular user have absolute control of the disk
    device */dev/da20*:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们也可以更改设备的所有权。更改设备节点的所有者通常表示你正在以错误的方式解决问题，可能需要停下来思考。FreeBSD虽然允许你如果坚持的话，随意搞砸系统，但还是能让你做这些操作。在这里，我们让一个特定的用户对磁盘设备*/dev/da20*拥有绝对控制权限：
- en: '[PRE42]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This might not have the desired effect, however, as some programs still think
    that you must be root to carry out operations on devices. I’ve seen more than
    one piece of software shut itself down if it’s not run by root, without even trying
    to access its device nodes. Changing the device node permissions won’t stop those
    programs’ complaints when they’re run by a regular user.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这可能不会产生预期的效果，因为有些程序仍然认为你必须是root用户才能执行设备上的操作。我见过不止一个软件如果不是由root用户运行，甚至在未尝试访问其设备节点之前就自行关闭。更改设备节点权限不会阻止这些程序在普通用户运行时的抱怨。
- en: Configuration with devfs.conf(5) solves many problems, but not all. If you want
    a device node to simply be invisible and inaccessible, you must use devfs rules.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用devfs.conf(5)进行配置解决了许多问题，但并非所有问题。如果你想让一个设备节点完全不可见且不可访问，你必须使用devfs规则。
- en: '***Global devfs Rules***'
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***全局devfs规则***'
- en: Every devfs(5) instance behaves according to the rules defined in *devfs.rules*.
    The devfs rules apply to both devices present at boot and devices that appear
    and disappear dynamically. Rules allow you to set ownership and permissions on
    device nodes and make device nodes visible or invisible. You cannot create symlinks
    to device nodes with devfs rules.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 每个devfs(5)实例的行为都遵循*devfs.rules*中定义的规则。devfs规则适用于启动时存在的设备和动态出现或消失的设备。规则允许你设置设备节点的所有权和权限，并使设备节点可见或不可见。你不能使用devfs规则创建指向设备节点的符号链接。
- en: Similar to */etc/rc.conf* and */etc/defaults/rc.conf*, FreeBSD uses */etc/devfs.rules*
    and */etc/defaults/devfs.rules*. Create an */etc/defvs.rules* for your custom
    rules and leave the entries in the defaults file alone.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于*/etc/rc.conf*和*/etc/defaults/rc.conf*，FreeBSD使用*/etc/devfs.rules*和*/etc/defaults/devfs.rules*。为你的自定义规则创建一个*/etc/devfs.rules*，并保持默认文件中的条目不变。
- en: '**devfs Ruleset Format**'
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**devfs规则集格式**'
- en: 'Each set of devfs rules starts with a name and a ruleset number between square
    brackets. For example, here’s a devfs rule from the default configuration:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 每一组devfs规则以一个名称和一个方括号中的规则集编号开始。例如，这是来自默认配置的一个devfs规则：
- en: '[PRE43]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The first rule in *devfs.rules* is called `devfs_hide_all` ➊ and is ruleset
    number 1 ➋. This ruleset contains only one rule ➌.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*devfs.rules*中的第一条规则被称为`devfs_hide_all` ➊，并且是规则集编号1 ➋。这个规则集只包含一条规则 ➌。'
- en: 'Once you have a set of devfs rules you like, enable them at boot in */etc/rc.conf*.
    Here, we activate the devfs ruleset named `laptoprules`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了一组喜欢的devfs规则，就可以在启动时在*/etc/rc.conf*中启用它们。这里，我们激活了名为`laptoprules`的devfs规则集：
- en: '[PRE44]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Remember, devfs rules apply to the devices in the system at boot and the devices
    configured dynamically after startup.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，devfs规则适用于启动时系统中的设备，以及启动后动态配置的设备。
- en: '**Ruleset Content**'
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**规则集内容**'
- en: 'All devfs rules (in files) begin with the word `add`, to add a rule to the
    ruleset. You then have either a `path` keyword and a regex of device names, or
    a `type` keyword and a device type. At the end of the rule, you have an *action*,
    or a command to perform. Here’s an example of a devfs rule:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 所有devfs规则（在文件中）都以单词`add`开始，以将规则添加到规则集中。然后，你可以选择使用`path`关键字和设备名称的正则表达式，或者使用`type`关键字和设备类型。在规则的末尾，你有一个*动作*，或者是执行的命令。以下是一个devfs规则的示例：
- en: '[PRE45]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This rule assigns the user *mwlucas* ownership of all device nodes with a node
    name beginning with `da`. This is probably a bad idea.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 该规则将用户*mwlucas*的所有权分配给所有名称以`da`开头的设备节点。这可能不是一个好主意。
- en: Devices specified by path use standard shell regular expressions. If you want
    to match a variety of devices, use an asterisk as a wildcard. For example, `path
    ada1s1` matches exactly the device */dev/ada1s1*, but `path ada*s*` matches every
    device node with a name beginning with `ada`, a character, the letter `s`, and
    possibly more characters. You could tell exactly what devices are matched by a
    wildcard by using it at the command line.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 通过路径指定的设备使用标准的Shell正则表达式。如果你想匹配多种设备，可以使用星号作为通配符。例如，`path ada1s1`仅匹配设备*/dev/ada1s1*，而`path
    ada*s*`匹配所有以`ada`开头，后跟一个字符，字母`s`，并且可能有更多字符的设备节点。你可以通过在命令行上使用通配符来精确了解匹配了哪些设备。
- en: '[PRE46]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This lists all MBR slices and partitions on your SATA hard drives, but not the
    devices for the entire drive.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这将列出你所有 SATA 硬盘上的所有 MBR 切片和分区，但不包括整个硬盘的设备。
- en: The `type` keyword indicates that you want the rule to apply to all devices
    of a given type. Valid keywords are `disk` (disk devices), `mem` (memory devices),
    `tape` (tape devices), and `tty` (terminal devices, including pseudoterminals).
    The `type` keyword is rarely used exactly because it’s so sweeping.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`type` 关键字表示你希望规则应用于给定类型的所有设备。有效的关键字包括 `disk`（磁盘设备）、`mem`（内存设备）、`tape`（磁带设备）和
    `tty`（终端设备，包括伪终端）。`type` 关键字很少使用，因为它的作用范围太广。'
- en: If you include neither a `path` nor a `type`, devfs applies the action at the
    end of the rule to all device nodes. In almost all cases, this is undesirable.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你既没有包含 `path` 也没有包含 `type`，devfs 会将规则末尾的动作应用到所有设备节点。在几乎所有情况下，这都是不希望的。
- en: 'The ruleset action can be any one of `group`, `user`, `mode`, `hide`, and `unhide`.
    The `group` action lets you set the group owner of the device, given as an additional
    argument. Similarly, the `user` action assigns the device owner. Here, we set
    the ownership of `da` disks to the username *desktop* and the group *usb*:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 规则集动作可以是 `group`、`user`、`mode`、`hide` 和 `unhide` 中的任何一种。`group` 动作让你设置设备的组所有者，作为附加参数。类似地，`user`
    动作分配设备所有者。在这里，我们将 `da` 磁盘的所有权设置为用户名 *desktop* 和组 *usb*：
- en: '[PRE47]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `mode` action lets you assign permissions to the device in standard octal
    form.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`mode` 动作允许你以标准的八进制形式分配设备的权限。'
- en: '[PRE48]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `hide` keyword lets you make device nodes disappear, and `unhide` makes
    them reappear. Since no program can use a device node if the device is invisible,
    this is of limited utility except when the system uses jail(8). Hiding and unhiding
    makes the most sense when including rules in rules.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`hide` 关键字可以让你让设备节点消失，`unhide` 让它们重新出现。由于没有程序可以使用不可见的设备节点，这在除了系统使用 jail(8)
    时的用途有限。隐藏和重新显示最有意义的场景是包含规则中的规则。'
- en: '**Including Rules in Rules**'
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**在规则中包含规则**'
- en: As in so many parts of systems administration, making devfs rules modular so
    they can be reused is a good way to reduce problems. The default jail rules show
    exactly how FreeBSD’s devfs supports reuse, through the `include` keyword.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 和许多系统管理方面一样，使 devfs 规则模块化以便重用是减少问题的好方法。默认的监狱规则正好展示了 FreeBSD 的 devfs 如何通过 `include`
    关键字支持重用。
- en: 'Here’s the start of the default configuration:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这是默认配置的开始：
- en: '[PRE49]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Rule number one, `devfsrules_hide_all` ➊, conceals all device nodes ➋.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 规则一，`devfsrules_hide_all` ➊，隐藏所有设备节点 ➋。
- en: Rule number two, `devfsrules_unhide_basic` ➌, contains only a series of `unhide`
    statements. This rule does nothing but unhide critical Unix device nodes, like
    */dev/log* ➍, */dev/null* ➎, */dev/zero* ➏, */dev/crypto* ➐, and so on. Most processes
    won’t run without these devices. These device nodes are already exposed in a standard
    system, so why would you need a rule just to unhide them? Similarly, ruleset number
    three, `devfsrules_unhide_login`, does nothing but unhide device nodes for logged-in
    users.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 规则二，`devfsrules_unhide_basic` ➌，仅包含一系列 `unhide` 声明。此规则只会做一件事：重新显示关键的 Unix 设备节点，如
    */dev/log* ➍、*/dev/null* ➎、*/dev/zero* ➏、*/dev/crypto* ➐ 等。大多数进程没有这些设备就无法运行。这些设备节点在标准系统中已经暴露，那么为什么还需要一个规则来重新显示它们呢？类似地，规则集三，`devfsrules_unhide_login`，仅仅是重新显示已登录用户的设备节点。
- en: The last ruleset leverages all of these.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个规则集利用了所有这些。
- en: '[PRE50]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This ruleset, `devfsrules_jail`, uses `include` statements to pull in the previous
    rulesets by reference. The last statement also unhides */dev/zfs*, allowing ZFS
    tools to work within jails.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则集 `devfsrules_jail` 使用 `include` 语句通过引用引入之前的规则集。最后一个语句还重新显示了 */dev/zfs*，使得
    ZFS 工具可以在监狱中工作。
- en: If you want to make additional device nodes available within all of your jails,
    you could add that device node to the jails ruleset. Or you could define a new
    ruleset and use it for all your jails. Better still, you could define a ruleset
    for just the jails that absolutely need that device and assign that ruleset to
    those jails.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望在所有监狱中都能使用额外的设备节点，你可以将该设备节点添加到监狱的规则集中。或者，你可以定义一个新的规则集，并在所有监狱中使用它。更好的做法是，你可以为仅需要该设备的监狱定义一个规则集，并将该规则集分配给那些监狱。
- en: To finish up, let’s look at dynamic devices.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看一下动态设备。
- en: '***Dynamic Device Management with devd(8)***'
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 devd(8) 进行动态设备管理***'
- en: Hot-swappable hardware is now routine. FreeBSD’s devfs dynamically creates new
    device nodes when this hardware is plugged in and erases the nodes when the hardware
    is removed, making using these dynamic devices much simpler. The devd(8) daemon
    takes this a step further by letting you run userland programs when hardware appears
    and disappears.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 热插拔硬件现在已经是常规操作。FreeBSD的devfs在插入硬件时动态创建新的设备节点，并在硬件移除时删除这些节点，这使得使用这些动态设备变得更加简单。devd(8)守护进程更进一步，允许你在硬件出现和消失时运行用户空间程序。
- en: FreeBSD’s default configuration, */etc/devd.conf*, handles most modern hardware
    just fine. If you need to customize devd(8), put your configuration files under
    */usr/local/etc/devd/* to simplify upgrades. You could also add different rules
    files for different types of devices if you find your devd(8) configuration becoming
    very complicated.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD的默认配置，*/etc/devd.conf*，能够很好地处理大多数现代硬件。如果你需要定制devd(8)，可以将配置文件放在*/usr/local/etc/devd/*下，以简化升级。你还可以为不同类型的设备添加不同的规则文件，如果你发现devd(8)配置变得非常复杂。
- en: '**devd Configuration**'
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**devd 配置**'
- en: 'You’ll find four types of devd(8) rules: `attach`, `detach`, `nomatch`, and
    `notify`.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现四种类型的devd(8)规则：`attach`、`detach`、`nomatch`和`notify`。
- en: The `attach` rules are triggered when matching hardware is attached to the system.
    When you plug in a network card, an `attach` rule configures the card with an
    IP address and brings up the network.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`attach`规则在匹配的硬件附加到系统时被触发。当你插入一个网络卡时，`attach`规则会为卡配置一个IP地址并启动网络。'
- en: The `detach` rules are triggered when matching hardware is removed from the
    system. `detach` rules are uncommon, as the kernel automatically marks resources
    unavailable when the underlying hardware disappears, but you might find uses for
    them.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`detach`规则在匹配的硬件从系统中移除时被触发。`detach`规则不常见，因为当底层硬件消失时，内核会自动标记资源为不可用，但你可能会在某些情况下用到它们。'
- en: The `nomatch` rules are triggered when new hardware is installed but not attached
    to a device driver. These devices don’t have device drivers in the current kernel.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`nomatch`规则在新硬件安装但未附加到设备驱动时被触发。这些设备在当前内核中没有设备驱动。'
- en: devd(8) applies `notify` rules when the kernel sends a matching event notice
    to userland. For example, the console message that a network interface has come
    up is a `notify` event. Notifications generally appear on the console or in */var/log/messages*.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: devd(8)在内核向用户空间发送匹配的事件通知时应用`notify`规则。例如，网络接口已启动的控制台消息就是一个`notify`事件。通知通常会出现在控制台或*/var/log/messages*中。
- en: 'Rules also have priority, with 0 being the lowest. Only the highest matching
    rule is processed, while lower-priority matching rules are skipped. Here’s a sample
    devd(8) rule:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 规则也有优先级，0是最低的。只有最高匹配的规则会被处理，而优先级较低的匹配规则会被跳过。以下是一个devd(8)规则的示例：
- en: '[PRE51]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is a `notify` rule ➊, which means it activates when the kernel sends a
    message to userland. As a priority 0 rule ➋, this rule can be triggered only if
    no rule of higher priority matches the criteria we specify. This rule is triggered
    only if the notification is on the network system `IFNET` ➌ (network) and only
    if the subsystem ➍ doesn’t match the expression `usbus[0-9]`. It excludes USB
    network cards. The notification type is `ATTACH` ➎—in other words, this matches
    only when someone plugs in a network interface. If all three of these matches
    hit, devd(8) runs a command to configure the network interface ➏.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`notify`规则➊，意味着当内核向用户空间发送消息时，它会被触发。作为一个优先级为0的规则➋，只有在没有更高优先级的规则匹配我们指定的条件时，这个规则才会被触发。这个规则只有在通知发生在网络系统`IFNET`
    ➌（网络）且子系统 ➍不匹配表达式`usbus[0-9]`时才会被触发。它排除了USB网卡。当通知类型为`ATTACH` ➎时，也就是说，只有在有人插入网络接口时才会匹配。如果这三个条件都满足，devd(8)会运行一个命令来配置网络接口➏。
- en: Read the devd(8) man page to see about all the options you can put in rules.
    If you want to automatically mount a particular USB flash disk on a certain mount
    point, you can do that by checking the serial number of every USB device you put
    in. If you want to configure Intel network cards differently than Atheros network
    cards, you can do that by checking the vendor. Whatever you need to write a rule
    for, it’s probably in there somewhere.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读devd(8)的手册页，了解你可以在规则中使用的所有选项。如果你想在特定的挂载点上自动挂载某个USB闪存盘，可以通过检查每个插入的USB设备的序列号来实现。如果你希望对Intel网卡和Atheros网卡进行不同的配置，可以通过检查供应商来做到这一点。无论你需要编写什么规则，它可能都能在这里找到相关信息。
- en: '**Miscellaneous Filesystems**'
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**其他文件系统**'
- en: FreeBSD supports several lesser-known filesystems. Most of them are useful only
    in bizarre circumstances, but bizarre circumstances arise daily in system administration.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 支持一些鲜为人知的文件系统。它们大多数只有在特殊情况下才有用，但系统管理中每天都会出现这种特殊情况。
- en: The process filesystem, procfs(5), contains lots of information about processes.
    It’s considered a security risk and is officially deprecated on modern FreeBSD
    releases. You can learn a lot about processes from a mounted process filesystem,
    however. A few older applications still require a process filesystem mounted on
    */proc*; if a server application requires procfs, try to find a similar application
    that does the job without requiring it.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 进程文件系统 procfs(5) 包含了大量关于进程的信息。它被视为一个安全风险，并且在现代 FreeBSD 版本中已正式弃用。然而，通过挂载进程文件系统，你可以了解很多关于进程的信息。少数旧应用程序仍然需要挂载在
    */proc* 上的进程文件系统；如果一个服务器应用程序需要 procfs，试着找到一个类似的应用程序，它可以完成相同的任务而不需要它。
- en: If you’re using Linux mode (see [Chapter 17](ch17.xhtml#ch17)), you might need
    the Linux process filesystem linprocfs(5). Much Linux software requires a process
    filesystem, and FreeBSD suggests installing linprocfs at */compat/linux/proc*
    when you install Linux mode. I’d recommend installing linprocfs only if a piece
    of software complains it’s not there.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Linux 模式（参见 [第 17 章](ch17.xhtml#ch17)），你可能需要 Linux 进程文件系统 linprocfs(5)。许多
    Linux 软件都需要进程文件系统，FreeBSD 建议在安装 Linux 模式时，在 */compat/linux/proc* 安装 linprocfs。我建议只有当某个软件提示找不到它时再安装
    linprocfs。
- en: The file descriptor filesystem fdesc(5) offers a filesystem view of file descriptors
    for each process. Some software, notably Java and the popular Bash shell, requires
    fdescfs(5). It’s less of a security risk than procfs, but still undesirable. You’ll
    get instructions on mounting fdescfs(5) when you install a package that requires
    it.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 文件描述符文件系统 fdesc(5) 提供了每个进程的文件描述符文件系统视图。一些软件，特别是 Java 和流行的 Bash shell，需要 fdescfs(5)。它比
    procfs 风险小，但仍然不太理想。当你安装需要它的软件包时，会提供如何挂载 fdescfs(5) 的说明。
- en: Now that we’ve talked about local filesystems, let’s look at the network.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了本地文件系统，让我们来看看网络。
- en: '**The Network File System**'
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**网络文件系统**'
- en: A network filesystem allows accessing files on another machine over the network.
    The two most commonly used network filesystems are the original Network File System
    (NFS) implemented in Unix and the CIFS (aka SMB) filesystem popularized by Microsoft
    Windows. We’ll touch on both of these, but start with the old Unix standard of
    NFS.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 网络文件系统允许通过网络访问另一台计算机上的文件。最常用的两种网络文件系统是 Unix 中实现的原始网络文件系统（NFS）和由 Microsoft Windows
    推广的 CIFS（也称为 SMB）文件系统。我们会简单提及这两者，但先从老旧的 Unix 标准 NFS 开始。
- en: Sharing directories and partitions between Unix-like systems is perhaps the
    simplest Network File System you’ll find. FreeBSD supports the Unix standard Network
    File System out of the box. Configuring NFS intimidates many junior sysadmins,
    but after setting up a file share or two, you’ll find it not so terribly difficult.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unix 类系统之间共享目录和分区，或许是你能找到的最简单的网络文件系统。FreeBSD 默认支持 Unix 标准的网络文件系统。配置 NFS 让许多初级系统管理员感到畏惧，但在设置了几个文件共享后，你会发现它并不像想象中那么难。
- en: NFS wasn’t designed as a secure protocol. Do not put NFS servers on the internet
    without a packet filter or firewall. Merely restricting access at the NFS level
    is completely inadequate—you must prevent random hosts from poking at the host’s
    remote procedure call (RPC) services. Restrict access to the host by IP address
    as well as port number.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: NFS 并不是作为安全协议设计的。不要在没有包过滤器或防火墙的情况下将 NFS 服务器暴露到互联网上。仅仅在 NFS 层面限制访问是完全不够的——你必须防止随机主机探测主机的远程过程调用（RPC）服务。需要通过
    IP 地址和端口号限制对主机的访问。
- en: Additionally, standard NFS isn’t encrypted. Anyone with a packet sniffer and
    access to your wire can see all filesystem activity. Once you deploy Kerberos,
    you can encrypt NFS, but Kerberos requires its own book.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，标准的 NFS 并未加密。任何拥有数据包嗅探器并能够访问你的网络线缆的人都能看到所有文件系统活动。一旦你部署了 Kerberos，你就可以加密 NFS，但
    Kerberos 需要单独的书籍来讲解。
- en: Each NFS connection uses a client-server model. One computer is the server;
    it offers filesystems to other computers. This is called *NFS exporting*, and
    the filesystems offered are called *exports*. The clients can mount server exports
    in a manner almost identical to that used to mount local filesystems.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 NFS 连接使用客户端-服务器模型。一台计算机是服务器；它向其他计算机提供文件系统。这被称为 *NFS 导出*，提供的文件系统称为 *导出*。客户端可以以几乎与挂载本地文件系统相同的方式挂载服务器的导出。
- en: One interesting thing about NFS is its statelessness. NFS doesn’t keep track
    of the condition of a connection. You can reboot an NFS server and the client
    won’t crash. It won’t be able to access files on the server’s export while the
    server is down, but once it returns, you’ll pick up right where things left off.
    Other network file sharing systems aren’t always so resilient. Of course, statelessness
    also causes problems; for example, clients can’t know when a file they currently
    have open is modified by another client.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 关于NFS，有一个有趣的特点是它的无状态性。NFS不会跟踪连接的状态。你可以重启NFS服务器，客户端不会崩溃。虽然在服务器停机时客户端无法访问服务器的导出文件，但一旦服务器恢复，客户端会接着之前的状态继续操作。其他网络文件共享系统并不总是如此健壮。当然，无状态性也会引发一些问题；例如，客户端无法知道它当前打开的文件是否被另一个客户端修改过。
- en: '**NFS INTEROPERABILITY**'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**NFS互操作性**'
- en: Every NFS implementation is slightly different. You’ll find minor NFS variations
    between Solaris, Linux, BSD, and other Unix-like systems. NFS should work between
    them all but might require the occasional tweak. If you’re having problems with
    another Unix-like operating system, check the *FreeBSD-net* mailing list archive;
    the issue has almost certainly been discussed there.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 每个NFS实现都有些微差异。你会发现Solaris、Linux、BSD和其他类Unix系统之间存在一些NFS的变种。NFS应该能在它们之间正常工作，但可能需要偶尔调整。如果你在与其他类Unix操作系统进行兼容时遇到问题，可以查看*FreeBSD-net*邮件列表的归档；该问题几乎肯定已经在其中讨论过。
- en: Both NFS servers and clients require kernel options, but the various NFS commands
    dynamically load the appropriate kernel modules. FreeBSD’s GENERIC kernel supports
    NFS, so this isn’t a concern for anyone who doesn’t customize their kernel.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: NFS服务器和客户端都需要内核选项，但各种NFS命令会动态加载相应的内核模块。FreeBSD的GENERIC内核支持NFS，因此对于没有自定义内核的用户来说，这不成问题。
- en: NFS is one of those topics that has entire books written about it. We’re not
    going to go into the intimate details about NFS, but rather focus on getting basic
    NFS operations working. If you’re deploying complicated NFS setups, you’ll want
    to do further research. Even this basic setup lets you accomplish many complicated
    tasks.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: NFS是一个有完整书籍专门讨论的主题。我们不会深入讨论NFS的细节，而是专注于使基本的NFS操作能够正常工作。如果你正在部署复杂的NFS设置，建议进行进一步的研究。即使是这个基础设置，也能让你完成许多复杂的任务。
- en: '***NFS Versions***'
  id: totrans-286
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***NFS版本***'
- en: 'Modern NFS comes in three versions: NFSv2, NFSv3, and NFSv4\. FreeBSD can transparently
    autodetect and interoperate with versions 2 and 3.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现代的NFS有三个版本：NFSv2、NFSv3和NFSv4。FreeBSD可以透明地自动检测并与版本2和3进行互操作。
- en: NFSv2 is rather minimal, dating from the time when people were delighted to
    get file sharing working at all.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: NFSv2相对简陋，源自于人们当时仅仅满足于能够实现文件共享的时期。
- en: NFSv3 contains many incremental improvements over and much better performance
    than NFSv2\. Most of these improvements don’t even require special configuration.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: NFSv3相较于NFSv2包含许多增量改进，并且性能大大提升。大多数这些改进甚至无需特别配置。
- en: NFSv4 is an entirely different and highly complex protocol that breaks many
    of the long-standing rules of NFS. It was deliberately designed to resemble Microsoft’s
    file sharing. Understanding NFSv4 requires understanding filesystem extended ACLs,
    synchronizing user IDs across the network, and other headaches.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: NFSv4是一个完全不同且高度复杂的协议，它打破了许多NFS的长期规则。它被刻意设计成类似微软的文件共享协议。理解NFSv4需要了解文件系统扩展ACL、跨网络同步用户ID等问题。
- en: When people say “NFS” they almost always mean NFSv2 or NFSv3\. Some folks call
    these protocols “traditional NFS.” Someone who means NFSv4 usually says “NFSv4.”
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们说“NFS”时，他们几乎总是指NFSv2或NFSv3。有些人将这些协议称为“传统NFS”。通常如果指NFSv4，人们会说“NFSv4”。
- en: 'This book sticks with the commonly deployed NFSv2 and NFSv3\. I devote a couple
    chapters to NFSv4 and related topics in *FreeBSD Mastery: Specialty Filesystems*
    (Tilted Windmill Press, 2016).'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '本书坚持使用常见的NFSv2和NFSv3。我在《*FreeBSD Mastery: Specialty Filesystems*》（Tilted Windmill
    Press，2016年）一书中专门花了几章讲解NFSv4及相关主题。'
- en: '***Configuring the NFS Server***'
  id: totrans-293
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***配置NFS服务器***'
- en: Turn on NFS server support with the following *rc.conf* options. While not all
    of these options are strictly necessary for all environments, turning them all
    on provides the broadest range of NFS compatibility and decent out-of-the-box
    performance.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下*rc.conf*选项开启NFS服务器支持。虽然并非所有选项在所有环境中都是严格必要的，但开启这些选项可以提供最广泛的NFS兼容性，并提供良好的开箱即用性能。
- en: '[PRE52]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: First, tell FreeBSD to load the *nfsserver.ko* ➊ kernel module. Everything will
    fail if the kernel doesn’t support NFS. The rpcbind(8) ➋ daemon maps remote procedure
    calls (RPCs) into local network addresses. Each NFS client asks the server’s rpcbind(8)
    daemon where it can find a mountd(8) daemon to connect to. The mountd(8) ➌ daemon
    listens to high-numbered ports for mount requests from clients. Enabling the NFS
    server also starts nfsd(8), which handles the actual file request. NFS ensures
    smooth file locking with rpc.lockd(8) ➍, and rpc.statd(8) ➎ monitors NFS clients
    so that the NFS server can free up resources when the host disappears.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，告诉 FreeBSD 加载 *nfsserver.ko* ➊ 内核模块。如果内核不支持 NFS，所有操作都会失败。rpcbind(8) ➋ 守护进程将远程过程调用（RPC）映射到本地网络地址。每个
    NFS 客户端都会向服务器的 rpcbind(8) 守护进程询问它可以找到哪个 mountd(8) 守护进程来连接。mountd(8) ➌ 守护进程监听来自客户端的挂载请求，使用高端口号。启用
    NFS 服务器还会启动 nfsd(8)，它处理实际的文件请求。NFS 通过 rpc.lockd(8) ➍ 确保文件锁定的顺利进行，rpc.statd(8)
    ➎ 监控 NFS 客户端，以便在主机消失时释放资源。
- en: While you can start all of these services at the command line, if you’re just
    learning NFS, it’s best to reboot your system after enabling the NFS server. Once
    NFS is running, the output of sockstat(1) will show `rpc.lockd`, `rpc.statd`,
    `nfsd`, `mountd`, and `rpcbind` listening. If you don’t see all of these daemons
    listening to the network, check */var/log/messages* for errors.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以在命令行启动所有这些服务，但如果你刚刚学习 NFS，最好在启用 NFS 服务器后重启系统。一旦 NFS 正常运行，sockstat(1) 的输出将显示
    `rpc.lockd`、`rpc.statd`、`nfsd`、`mountd` 和 `rpcbind` 在监听。如果你没有看到所有这些守护进程在监听网络，请检查
    */var/log/messages* 中的错误信息。
- en: The NFS server is designed to seamlessly interoperate a whole bunch of different
    NFS implementations. While it should transparently autonegotiate connections,
    you might find that you need to tweak your NFS server nfsd(8) to best fit your
    clients. Tune nfsd(8) at startup with the *rc.conf* option `nfs_server_flags`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: NFS 服务器旨在无缝地与各种 NFS 实现进行互操作。虽然它应该能自动协商连接，但你可能需要调整 NFS 服务器的 nfsd(8) 配置，以最佳适配你的客户端。通过
    *rc.conf* 中的选项 `nfs_server_flags` 调整 nfsd(8) 的启动参数。
- en: NFS can run over TCP or UDP. UDP is the traditional NFS transport protocol.
    TCP works better over lossy networks and can better cope with irregular network
    speeds. FreeBSD offers both protocols but defaults to using TCP mounts. Some clients
    behave better with one protocol or the other. You can explicitly enable only TCP
    with `-t` and only UDP with `-u`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: NFS 可以通过 TCP 或 UDP 运行。UDP 是传统的 NFS 传输协议。TCP 在丢包网络环境下表现更好，且能更好地应对不规则的网络速度。FreeBSD
    提供了这两种协议，但默认使用 TCP 挂载。一些客户端在某个协议下表现更好。你可以通过 `-t` 明确启用 TCP，或通过 `-u` 启用 UDP。
- en: The NFS server defaults to listening to all IP addresses on a machine. When
    a server has multiple IP addresses, replies to a UDP request can come from any
    of those addresses. This can confuse NFS clients. If your NFS server has multiple
    IP addresses and you have clients that prefer UDP, tell the NFS server to use
    only a single address with `-h` and the server IP.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: NFS 服务器默认会监听机器上的所有 IP 地址。当服务器有多个 IP 地址时，回复 UDP 请求的地址可以是这些地址中的任意一个。这可能会让 NFS
    客户端感到困惑。如果你的 NFS 服务器有多个 IP 地址，并且客户端偏好 UDP 协议，可以告诉 NFS 服务器仅使用一个 IP 地址，通过 `-h` 和服务器的
    IP 来指定。
- en: While nfsd(8) works well, highly loaded servers might need additional nfsd(8)
    processes. While FreeBSD starts four nfsd(8) processes by default, you can start
    additional processes with the `-n` flag and the desired number of processes.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 nfsd(8) 工作良好，但负载较高的服务器可能需要额外的 nfsd(8) 进程。虽然 FreeBSD 默认启动四个 nfsd(8) 进程，但你可以通过
    `-n` 标志和所需的进程数量启动额外的进程。
- en: This *rc.conf* entry tells NFS to use only UDP, bind to the IP address 198.51.100.71,
    and run six instances of nfsd(8).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 *rc.conf* 条目告诉 NFS 仅使用 UDP，绑定到 IP 地址 198.51.100.71，并运行六个 nfsd(8) 实例。
- en: '[PRE53]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Before you start tweaking server behavior, though, you really should have some
    exports.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，在你开始调整服务器行为之前，最好先配置一些共享目录。
- en: '***Configuring NFS Exports***'
  id: totrans-305
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***配置 NFS 导出***'
- en: Now tell your server what it can share, or *export*. You could export all directories
    and filesystems on the entire server, but any competent security administrator
    would have a (justified) fit. As with all server configurations, permit as little
    access as possible while still letting the server fulfill its role. For example,
    in most environments, clients have no need to remotely mount the NFS server’s
    root filesystem.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，告诉你的服务器它可以共享哪些内容，或者说 *导出*。你可以导出整个服务器上的所有目录和文件系统，但任何称职的安全管理员都会对此感到不满（并且是有正当理由的）。与所有服务器配置一样，在保证服务器履行其职能的同时，应尽量限制访问权限。例如，在大多数环境中，客户端并不需要远程挂载
    NFS 服务器的根文件系统。
- en: FreeBSD lets you configure exports through two different paths. The traditional
    method is the file */etc/exports*. A ZFS-based server can configure exports through
    each dataset’s `sharenfs` property. The server will create the ZFS exports file
    */etc/zfs/exports* based on these properties. Both exports files have the same
    format.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD让你通过两种不同的路径配置导出。传统方法是通过文件*/etc/exports*。基于ZFS的服务器可以通过每个数据集的`sharenfs`属性来配置导出。服务器将根据这些属性创建ZFS导出文件*/etc/zfs/exports*。这两种导出文件格式相同。
- en: Choose one method of managing your NFS exports. Either edit */etc/exports*,
    or use zfs(8). Using both methods simultaneously might merely confuse you but
    will probably break everything. If you use the ZFS method, never edit */etc/zfs/exports*
    by hand. Stick with one method.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一种管理NFS导出的方式。要么编辑*/etc/exports*，要么使用zfs(8)。同时使用这两种方法可能会让你感到困惑，甚至可能导致所有功能失效。如果使用ZFS方法，切勿手动编辑*/etc/zfs/exports*。坚持使用一种方法。
- en: No matter which method you choose, though, */etc/exports* must exist. If you
    manage NFS through zfs(8), I recommend creating a one-line */etc/exports* that
    contains only a comment telling people to use zfs(8).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 无论选择哪种方法，*/etc/exports*必须存在。如果你通过zfs(8)管理NFS，我建议创建一个仅包含注释的单行*/etc/exports*，告诉大家使用zfs(8)。
- en: '**Exports Entries**'
  id: totrans-310
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Exports条目**'
- en: So how do you configure an export? I’ll start with the exports file */etc/exports*,
    but most everything also applies to using ZFS. I’ll discuss the differences in
    “[Managing NFS with zfs(8)](ch13.xhtml#lev524)” on [page 308](ch13.xhtml#page_308),
    but understanding those limitations requires understanding */etc/exports*.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如何配置一个导出呢？我将从exports文件*/etc/exports*开始，但大多数内容也适用于使用ZFS。我将在[第308页](ch13.xhtml#page_308)的“[使用zfs(8)管理NFS](ch13.xhtml#lev524)”中讨论这些差异，但理解这些限制需要先理解*/etc/exports*。
- en: 'Each exports entry has up to three parts:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 每个exports条目最多有三部分：
- en: Directories or partitions to be exported (mandatory)
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要导出的目录或分区（必需）
- en: Options on that export
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该导出的选项
- en: Clients that can connect
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以连接的客户端
- en: Each combination of clients and a disk device can only have one line in the
    exports file. This means that if */usr/ports* and */usr/home* are on the same
    partition and you want to export both of them to a particular client, they must
    both appear in the same line. You can’t export */usr/ports* and */usr/home* to
    one client with different permissions. You don’t have to export the entire disk
    device, mind you; you can export a single directory within a partition. This directory
    cannot contain either symlinks or double or single dots.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 每个客户端和磁盘设备的组合在exports文件中只能有一行。这意味着，如果*/usr/ports*和*/usr/home*在同一分区上，并且你想将它们都导出到某个特定客户端，它们必须出现在同一行中。你不能将*/usr/ports*和*/usr/home*导出到一个客户端，且给它们不同的权限。请注意，你不必导出整个磁盘设备；你可以仅导出分区中的一个目录。这个目录不能包含符号链接或点。
- en: NFS mounts don’t cross partitions. If a host has separate UFS partitions for
    */usr* and */usr/src*, exporting */usr* doesn’t automatically export */usr/src*.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: NFS挂载不能跨越分区。如果主机为*/usr*和*/usr/src*配置了独立的UFS分区，导出*/usr*并不会自动导出*/usr/src*。
- en: 'Of the three parts of the */etc/exports* entry, only the directory is mandatory.
    An exports line cannot contain symlinks or periods. To export my home directory
    to every host on the internet, I could use an */etc/exports* line consisting entirely
    of:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在*/etc/exports*条目的三部分中，只有目录是必需的。exports行不能包含符号链接或点。为了将我的主目录导出到互联网上的所有主机，我可以使用完全由以下内容组成的*/etc/exports*行：
- en: '[PRE54]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This has no options and no host restrictions. Such an export would be foolish,
    of course, but I could do it.^([4](footnote.xhtml#ch13fn4))
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这没有任何选项和主机限制。当然，这种导出是愚蠢的，但我还是可以这么做。^([4](footnote.xhtml#ch13fn4))
- en: 'After editing the *exports* file, tell mountd(8) to reread it:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑完*exports*文件后，告诉mountd(8)重新读取该文件：
- en: '[PRE55]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Any problems with mountd(8) appear in */var/log/messages*. The log messages
    are generally enigmatic: while mountd(8) informs you that a line is bad, it usually
    doesn’t say why. The most common errors I experience involve symlinks. Use pwd(1)
    in a directory to get a directory’s actual path.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 与mountd(8)相关的问题会出现在*/var/log/messages*中。日志消息通常比较难以理解：虽然mountd(8)会告诉你某行有问题，但通常不会说明原因。我遇到的最常见错误涉及符号链接。在目录中使用pwd(1)可以获取目录的实际路径。
- en: '**NFS and Users**'
  id: totrans-324
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**NFS和用户**'
- en: NFSv2 and NFSv3 identify users by UID. (NFSv4 uses usernames because it assumes
    you’ve synchronized usernames across the entire network.) For example, on my laptop,
    the user *mwlucas* has the UID of 1001\. On the NFS server, *mwlucas* also has
    the UID 1001\. This makes my life easy, as I don’t have to worry too much about
    file ownership; I have the same privileges on the server as on my laptop.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: NFSv2 和 NFSv3 通过 UID 来识别用户。（NFSv4 使用用户名，因为它假设你已在整个网络中同步了用户名。）例如，在我的笔记本上，用户 *mwlucas*
    的 UID 是 1001。在 NFS 服务器上，*mwlucas* 也有 UID 1001。这使得我的工作变得简单，因为我不必太担心文件所有权；我在服务器上的权限与在笔记本上的权限相同。
- en: This can be a problem on a large network, where users have root on their own
    machines. The best way around this is to create a central repository of authorized
    users via Kerberos. On a small network or on a network with a limited number of
    NFS users, this usually isn’t a problem; you can synchronize */etc/master.passwd*
    on your systems or just assign the same UID to each user on each system.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这在大规模网络中可能成为一个问题，尤其是当用户在自己的机器上拥有 root 权限时。解决这个问题的最佳方法是通过 Kerberos 创建一个授权用户的中央存储库。在小型网络或用户数量有限的
    NFS 网络中，通常不会遇到这个问题；你可以同步系统上的*/etc/master.passwd*，或者在每个系统上为每个用户分配相同的 UID。
- en: The root user is handled slightly differently, however. An NFS server doesn’t
    trust root on other machines to execute commands as root on the server. After
    all, if an intruder breaks into an NFS client, you don’t want the server to automatically
    go down with it. NFS defaults to mapping requests from a client’s root account
    to the UID and GID of –2 on the server. This is where the highly unprivileged
    *nobody* account originated.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，root 用户的处理方式略有不同。NFS 服务器并不信任其他机器上的 root 用户执行服务器上的 root 命令。毕竟，如果入侵者突破了 NFS
    客户端，你不希望服务器自动跟着崩溃。NFS 默认将来自客户端 root 账户的请求映射到服务器上的 UID 和 GID 为 –2 的账户。这就是 highly
    unprivileged *nobody* 账户的由来。
- en: The authors of many other server programs thought the nobody account was a great
    idea, so they appropriated nobody for their own use. Multiple security entities
    simultaneously running as nobody creates security issues. FreeBSD’s packages create
    unprivileged users for all applications that need one. I consider the nobody user
    tainted and suggest you don’t permit its use.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他服务器程序的作者认为 nobody 账户是个好主意，因此他们将 nobody 用于自己的目的。多个安全实体同时以 nobody 身份运行会带来安全问题。FreeBSD
    的软件包为所有需要的应用程序创建了无特权用户。我认为 nobody 用户已被污染，建议不要允许使用它。
- en: 'You can map requests from root to any other username. For example, you might
    say that all requests from root on a client will run as the *nfsroot* user on
    the server. With careful use of groups, you could allow this nfsroot user to have
    limited file access. Use the `maproot` option to map root to another user. Here,
    we map UID 0 (root) on the client to UID 5000 on the server:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 root 的请求映射到其他用户名。例如，你可以指定所有来自客户端 root 的请求将作为服务器上的 *nfsroot* 用户运行。通过小心使用组，你可以允许该
    nfsroot 用户拥有有限的文件访问权限。使用 `maproot` 选项将 root 映射到其他用户。这里，我们将客户端上的 UID 0（root）映射到服务器上的
    UID 5000：
- en: '[PRE56]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: If you really want root on the client to have root privileges on the server,
    use `-maproot` to map root to UID 0\. This might be suitable on your home network
    or on a test system.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的希望客户端的 root 拥有服务器上的 root 权限，可以使用 `-maproot` 将 root 映射到 UID 0。这可能适用于你的家庭网络或测试系统。
- en: You can’t arbitrarily remap user accounts to each other. In complex environments,
    be sure you synchronize user accounts and UIDs on all machines on your network.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能随意将用户账户映射到彼此。在复杂环境中，确保你同步网络中所有机器上的用户账户和 UID。
- en: NFS users can belong to no more than 16 groups. Some operating systems can break
    that limit, but they violate the NFS protocols in doing so. If a user can’t access
    files with group-based access control, check the number of groups that they’re
    in.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: NFS 用户最多可以属于 16 个组。一些操作系统能够突破这个限制，但这样做违反了 NFS 协议。如果用户无法通过基于组的访问控制访问文件，请检查他们所属的组数。
- en: Remember to restart mountd(8) after editing the exports file.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 exports 文件后，请记得重新启动 mountd(8)。
- en: '**Exporting Multiple Directories**'
  id: totrans-335
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**导出多个目录**'
- en: 'A standard FreeBSD UFS install puts all the files on one partition. You might
    want to export multiple directories on that partition. List all directories on
    the same partition on the same line in */etc/exports*, right after the first exported
    directory, separated by spaces. Here’s a sample */etc/exports* with multiple exports:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 FreeBSD UFS 安装将所有文件放在一个分区上。你可能希望导出该分区上的多个目录。在 */etc/exports* 文件中，列出同一分区上的所有目录，并将它们与第一个导出的目录放在同一行上，之间用空格隔开。以下是一个具有多个导出的
    */etc/exports* 示例：
- en: '[PRE57]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Clients can mount any of these directories, and requests from root get mapped
    to nfsroot.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以挂载这些目录中的任何一个，来自root的请求会映射到nfsroot。
- en: There are no identifiers, separators, or delimiters between the parts of the
    line. Yes, it would be easier to read if we could put each shared directory on
    its own line, but we can’t—they’re all on the same partition. The FreeBSD team
    could rewrite this so that it had more structure, but then FreeBSD’s */etc/exports*
    would be incompatible with that from any other Unix.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 行的各个部分之间没有标识符、分隔符或定界符。是的，如果我们能将每个共享目录放在自己的一行上，阅读会更容易，但我们做不到——它们都在同一个分区上。FreeBSD团队可以重写它，使其结构更清晰，但那样的话，FreeBSD的*/etc/exports*就与其他Unix系统不兼容了。
- en: Perhaps you want clients to be able to mount any directory on a partition. Allow
    this with the `-alldirs` option. I wouldn’t do this on a host with a single partition.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你希望客户端能够挂载分区上的任何目录。可以使用`-alldirs`选项允许此操作。我不会在只有一个分区的主机上这样做。
- en: '[PRE58]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: You can only specify a partition mount point with `-alldirs`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能使用`-alldirs`指定一个分区的挂载点。
- en: '**Long Lines**'
  id: totrans-343
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**长行**'
- en: 'As with many other configuration files, you can use a backslash to break a
    single line of configuration into multiple lines. You might find the preceding
    configuration more readable as:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他配置文件一样，你可以使用反斜杠将一行配置分成多行。你可能会发现前面的配置在如下所示的情况下更易于阅读：
- en: '[PRE59]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Once your exports line gets long enough, this style suddenly gets more readable
    than the alternative.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的导出行变得足够长，这种样式突然比其他方式更具可读性。
- en: '**Restricting Clients**'
  id: totrans-347
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**限制客户端**'
- en: 'To allow only particular clients to access an NFS export, list them at the
    end of the */etc/exports* entry. Here, we restrict our preceding share to one
    IP address:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 要仅允许特定的客户端访问NFS导出，请将它们列在*/etc/exports*条目的末尾。在这里，我们将前面的共享限制为一个IP地址：
- en: '[PRE60]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'You can also restrict file shares to clients on a particular network by using
    the `-network` and `-mask` qualifiers:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用`-network`和`-mask`限定符，将文件共享限制为某个特定网络上的客户端：
- en: '[PRE61]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This lets any client with an IP address beginning in 203.0.113 access your NFS
    server. I use a setup much like this to upgrade clients quickly. I build a new
    world and kernel on the NFS server and then let the clients mount those partitions
    and install the binaries over NFS.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，任何IP地址以203.0.113开头的客户端都可以访问你的NFS服务器。我使用类似的设置来快速升级客户端。我在NFS服务器上构建一个新的世界和内核，然后让客户端挂载这些分区，并通过NFS安装二进制文件。
- en: To export to an IPv6 network, include the slash in the address.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 要将导出到IPv6网络，请在地址中包含斜杠。
- en: '[PRE62]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: You can also list hostnames rather than IP addresses, but this creates a dependency
    on name resolution. If you lose DNS, you’d lose file sharing. Also, the NFS server
    looks up the IP address of each host when you start mountd. Changing a client’s
    IP means reloading both DNS and mountd(8). If you must list hostnames, put them
    at the end of the line.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以列出主机名而不是IP地址，但这会依赖于名称解析。如果丢失了DNS，你将无法进行文件共享。此外，NFS服务器在启动mountd时会查找每个主机的IP地址。如果客户端的IP发生变化，你需要重新加载DNS和mountd(8)。如果必须列出主机名，请将它们放在行的末尾。
- en: '[PRE63]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Assigning NFS on a per-host basis is more labor. Assign NFS permissions as broadly
    as possible without compromising security.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 按每主机分配NFS会增加工作量。尽量在不妥协安全性的前提下，广泛地分配NFS权限。
- en: '**Combinations of Clients and Exports**'
  id: totrans-358
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**客户端和导出组合**'
- en: Each line in */etc/exports* specifies exports from one partition to one network,
    address, or set of hosts. Different hosts require entirely different export statements.
    You can change the options for each if you wish.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '*/etc/exports*中的每一行都指定了从一个分区到一个网络、地址或主机集合的导出。不同的主机需要完全不同的导出声明。如果需要，你可以为每个主机更改选项。'
- en: '[PRE64]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Here, I’ve exported several subdirectories of */usr* to the NFS client at 203.0.113.200\.
    The NFS client at 203.0.113.201 gets to mount the whole of */usr* and may even
    do so as root.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我将*/usr*的几个子目录导出给IP为203.0.113.200的NFS客户端。IP为203.0.113.201的NFS客户端可以挂载整个*/usr*，甚至可以作为root进行挂载。
- en: '**NFS and Firewalls**'
  id: totrans-362
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**NFS和防火墙**'
- en: 'NFS is famous for not liking firewalls. The dynamic port assignment of services
    like mountd(8), rpc.lockd(8), and rpc.statd(8) makes packet filtering nearly impossible.
    You can use the `-p` flag to assign each of these services a specific TCP port.
    Here, I use *rc.conf* entries to nail mountd(8) to port 4046, rpc.lockd(8) to
    4045, and rpc.statd(8) to 4047:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: NFS因不喜欢防火墙而著名。像mountd(8)、rpc.lockd(8)和rpc.statd(8)这样的服务动态端口分配，使得数据包过滤几乎不可能。你可以使用`-p`标志为这些服务分配特定的TCP端口。在这里，我使用*rc.conf*条目将mountd(8)绑定到4046端口，将rpc.lockd(8)绑定到4045端口，将rpc.statd(8)绑定到4047端口：
- en: '[PRE65]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: I can use these ports in my packet filter rules, providing some protection to
    my NFS server.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以在我的数据包过滤规则中使用这些端口，为我的NFS服务器提供一些保护。
- en: '**Managing NFS with zfs(8)**'
  id: totrans-366
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用zfs(8)管理NFS**'
- en: Using zfs(8) to manage NFS has advantages and disadvantages. You can configure
    NFS on a per-dataset basis, and you don’t need to manually restart mountd(8) after
    each change. Command line configuration is easier to automate, and many folks
    find it easier to type as well.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 使用zfs(8)管理NFS有优点也有缺点。你可以按数据集配置NFS，而且每次更改后不需要手动重启mountd(8)。命令行配置更容易自动化，很多人发现它也更容易输入。
- en: Use the `sharenfs` property to enable, disable, and configure NFS exports. Set
    this property to `on` to globally share a dataset and all its descendants. This
    is equivalent to listing the dataset on its own in */etc/exports*. Anyone in the
    world can mount this dataset or any of its children, with no restrictions and
    no options, unless you have other access control, such as a firewall.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`sharenfs`属性来启用、禁用和配置NFS导出。将该属性设置为`on`，可以全局共享一个数据集及其所有后代。这相当于在*/etc/exports*中单独列出该数据集。世界上的任何人都可以挂载这个数据集或它的任何子目录，除非你有其他访问控制，如防火墙。
- en: '[PRE66]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Similarly, set it to `off` to unshare the dataset.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，设置为`off`可以取消共享该数据集。
- en: You probably want some NFS options on an export, though. Set `sharenfs` to the
    desired options for the dataset. This example sets a maproot user and restricts
    clients to my local network. Put the options in quotes.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望在导出上设置一些NFS选项。将`sharenfs`设置为所需的选项。这个例子设置了一个maproot用户，并将客户端限制在我的本地网络内。将选项放在引号中。
- en: '[PRE67]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The problem with using ZFS to manage your NFS exports is that all permitted
    hosts get the same options. That is, if most of your hosts need to mount */home*
    with `-maproot=nfsroot` but you have one host that needs root to mount that dataset
    as root, you can’t use ZFS properties. Similarly, you can define only one permitted
    network with ZFS properties.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ZFS管理NFS导出的一个问题是，所有允许的主机都会获得相同的选项。也就是说，如果大多数主机需要使用`-maproot=nfsroot`挂载*/home*，但你有一台主机需要以root身份挂载该数据集，你就不能使用ZFS属性。同样，ZFS属性只允许定义一个被允许的网络。
- en: '***Enabling the NFS Client***'
  id: totrans-374
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***启用NFS客户端***'
- en: 'Configuring the NFS client is much simpler. In */etc/rc.conf*, put:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 配置NFS客户端要简单得多。在*/etc/rc.conf*中，添加以下内容：
- en: '[PRE68]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: You can reboot or run `service nfsclient start`. Either starts NFS client functions.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以重启或运行`service nfsclient start`。这两种方法都会启动NFS客户端功能。
- en: '**Show Available Mounts**'
  id: totrans-378
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**显示可用挂载点**'
- en: 'One obvious question for an NFS client to ask would be, “What can I mount from
    that server?” The showmount(8) command lists all exports available to a client.
    Give the `-e` flag and the name of the NFS server. Here, I ask the storm server
    what exports it offers:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 对于NFS客户端来说，显而易见的问题是：“我可以从这个服务器挂载什么？”showmount(8)命令列出了客户端可以访问的所有导出。给出`-e`标志和NFS服务器的名称。在这里，我询问storm服务器提供了哪些导出：
- en: '[PRE69]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This client is allowed to mount */usr/home* under the rule that permits the
    network 203.0.113.0.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 该客户端被允许根据允许网络203.0.113.0的规则挂载*/usr/home*。
- en: Running showmount(8) doesn’t offer any server-side options, like `-maproot`.
    These details aren’t readily available to clients, although touch(1) lets you
    easily test for read-only exports.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 运行showmount(8)不会提供任何服务器端选项，如`-maproot`。这些细节对客户端来说并不容易获取，尽管touch(1)可以让你轻松测试只读导出。
- en: '**Mounting Exports**'
  id: totrans-383
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**挂载导出**'
- en: 'Now you can mount directories or filesystems exported by NFS servers. Instead
    of using a device name, use the NFS server’s hostname and the directory you want
    to mount. For example, to mount the */home/mwlucas* directory from my storm server
    onto the */mnt* directory, I would run:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以挂载NFS服务器导出的目录或文件系统。与其使用设备名称，不如使用NFS服务器的主机名和你想要挂载的目录。例如，要将我的storm服务器上的*/home/mwlucas*目录挂载到*/mnt*目录，我会运行：
- en: '[PRE70]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Afterward, test your mount with df(1).
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，用df(1)命令测试你的挂载。
- en: '[PRE71]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The NFS-mounted directory shows up as a normal partition, and I can read and
    write files on it as I please.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: NFS挂载的目录显示为一个普通分区，我可以随意读取和写入文件。
- en: '**NFS Mount Options**'
  id: totrans-389
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**NFS挂载选项**'
- en: FreeBSD uses conservative NFS defaults so that it can interoperate with any
    other Unix-like operating system. You can use mount options to adjust how FreeBSD
    mounts NFS exports. Use these options at the command line with `-o` or add them
    to an */etc/fstab* entry.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD使用保守的NFS默认设置，以便与任何其他类Unix操作系统互操作。你可以使用挂载选项来调整FreeBSD挂载NFS导出的方式。你可以在命令行使用`-o`选项，或者将它们添加到*/etc/fstab*条目中。
- en: If you need to access a UDP-only NFS server, use the mount option `udp` to use
    UDP rather than the default TCP.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要访问一个仅支持 UDP 的 NFS 服务器，可以使用挂载选项`udp`来使用 UDP，而不是默认的 TCP。
- en: Programs expect the filesystem not to disappear, but when you’re using NFS,
    it’s possible that the server will vanish from the network. This makes programs
    on the client trying to access the NFS filesystem hang forever. By making your
    NFS mount *interruptible*, you’ll be able to interrupt processes hung on unavailable
    NFS mount with CTRL-C. Set interruptibility with `intr`.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 程序期望文件系统不会消失，但在使用 NFS 时，可能会发生服务器从网络中消失的情况。这会导致客户端上试图访问 NFS 文件系统的程序永久挂起。通过将 NFS
    挂载设置为*可中断*，你将能够通过 CTRL-C 中断挂起的进程。使用 `intr` 设置可中断性。
- en: By using a soft mount, FreeBSD will notify programs that the file they were
    working on is no longer available. What programs do with that information depends
    on the program, but they’ll no longer hang forever. Enable soft mounts with the
    `soft` option.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用软挂载，FreeBSD 会通知程序它们正在处理的文件不再可用。程序如何处理这些信息取决于程序本身，但它们将不再无限期挂起。使用`soft`选项启用软挂载。
- en: If you want a read-only mount, use the `ro` mount option.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要只读挂载，请使用`ro`挂载选项。
- en: Putting everything together, I might mount my home directory as an interruptible
    soft mount.^([5](footnote.xhtml#ch13fn5))
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 综合来看，我可能会将我的主目录挂载为可中断的软挂载。^([5](footnote.xhtml#ch13fn5))
- en: '[PRE72]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'I could add this to */etc/fstab* as follows:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以像这样将其添加到*/etc/fstab*文件中：
- en: '[PRE73]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: While NFS is pretty straightforward for simple uses, you can spend many hours
    adjusting, tuning, and enhancing it. If you wish to build a complicated NFS environment,
    don’t rely entirely on this brief introduction but spend time with a good book
    on the subject.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 NFS 对于简单使用来说非常直接，但你可能会花费很多时间进行调整、优化和增强。如果你希望建立一个复杂的 NFS 环境，不要完全依赖这个简短的介绍，而是花时间阅读一本关于这个主题的好书。
- en: Now, let’s look at reading Windows shares.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看读取 Windows 共享。
- en: '**The Common Internet File System**'
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**通用互联网文件系统**'
- en: If you’re on a typical office network, the standard network file sharing protocol
    is Microsoft’s *Common Internet File System (CIFS)*. You might know CIFS as Server
    Message Block (SMB), “Network Neighborhood,” or “Why can’t I mount that drive?”
    While originally provided only by Microsoft Windows systems, this protocol has
    become something of a pseudostandard.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个典型的办公网络中，标准的网络文件共享协议是微软的*通用互联网文件系统（CIFS）*。你可能知道 CIFS 作为服务器消息块（SMB）、"网络邻居"或"为什么我无法挂载那个驱动器？"最初仅由
    Microsoft Windows 系统提供，但这个协议已经变成了某种伪标准。
- en: FreeBSD includes the smbutil(8) program to find, mount, and use CIFS shares
    as a CIFS client. FreeBSD doesn’t include a CIFS server in the base system, but
    the open source CIFS server Samba (*[https://www.samba.org/](https://www.samba.org/)*)
    works well on FreeBSD.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 包含 smbutil(8) 程序，用于查找、挂载和作为 CIFS 客户端使用 CIFS 共享。FreeBSD 在基础系统中不包括 CIFS
    服务器，但开源 CIFS 服务器 Samba (*[https://www.samba.org/](https://www.samba.org/)*）在 FreeBSD
    上运行良好。
- en: Use FreeBSD’s CIFS support to interoperate with existing Microsoft infrastructure.
    Don’t deploy CIFS to support Unix-like systems.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 FreeBSD 的 CIFS 支持与现有的 Microsoft 基础设施进行互操作。不要部署 CIFS 来支持类似 Unix 的系统。
- en: '***Prerequisites***'
  id: totrans-405
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***先决条件***'
- en: 'Before you begin working with Microsoft file shares, gather the following information
    about your Windows network:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用 Microsoft 文件共享之前，请收集以下有关 Windows 网络的信息：
- en: Workgroup or Windows domain name
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作组或 Windows 域名
- en: Valid Windows username and password
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效的 Windows 用户名和密码
- en: IP address of the Windows DNS server
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows DNS 服务器的 IP 地址
- en: '***Kernel Support***'
  id: totrans-410
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***内核支持***'
- en: 'FreeBSD uses several kernel modules to support CIFS. The *smbfs.ko* module
    supports basic CIFS operations. The *libmchain.ko* and *libiconv.ko* modules provide
    supporting functions and load automatically when you load *smbfs.ko*. You can
    compile these statically in your kernel as:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 使用多个内核模块来支持 CIFS。*smbfs.ko* 模块支持基本的 CIFS 操作。*libmchain.ko* 和 *libiconv.ko*
    模块提供支持函数，并在加载 *smbfs.ko* 时自动加载。你可以将这些静态编译到内核中：
- en: '[PRE74]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: You can load these automatically at boot time with a *boot/loader.conf* entry.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在*boot/loader.conf*文件中添加条目来在启动时自动加载这些设置。
- en: '[PRE75]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: You can now configure CIFS.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以配置 CIFS。
- en: '***Configuring CIFS***'
  id: totrans-416
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***配置 CIFS***'
- en: 'CIFS relies on a configuration file, either *$HOME/.nsmbrc* or */etc/nsmb.conf*.
    All settings in */etc/nsmb.conf* override the settings in user home directories.
    The configuration file is divided into sections by labels in square brackets.
    For example, settings that apply to every CIFS connection are in the `[default]`
    section. Create your own sections to specify servers, users, and shares, in one
    of the following formats:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: CIFS 依赖于一个配置文件，通常是*$HOME/.nsmbrc*或*/etc/nsmb.conf*。所有在*/etc/nsmb.conf*中的设置都会覆盖用户主目录中的设置。配置文件通过方括号中的标签分为多个部分。例如，适用于每个
    CIFS 连接的设置位于`[default]`部分。创建自己的部分以指定服务器、用户和共享，格式如下：
- en: '[PRE76]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Information that applies to an entire server goes into a section named after
    the server. Information that applies to a specific user is kept in a username
    section, and information that applies to only a single share is kept in a section
    that includes the sharename. You can lump the information for all the shares under
    a plain `[`servername`]` entry if you don’t have more specific per-user or per-share
    information.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 适用于整个服务器的信息放在以服务器名命名的部分中。适用于特定用户的信息保存在用户名部分中，适用于单个共享的信息保存在包含共享名称的部分中。如果你没有更具体的每用户或每共享信息，可以将所有共享的信息放在一个普通的`[servername]`条目下。
- en: Configuration entries use the values from the CIFS system—for example, Bert’s
    Windows username is *bertjw*, but his FreeBSD username is *xistence*, so I use
    *bertjw* in *nsmb.conf*.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 配置条目使用来自 CIFS 系统的值——例如，Bert 的 Windows 用户名是*bertjw*，但他的 FreeBSD 用户名是*xistence*，所以我在*nsmb.conf*中使用*bertjw*。
- en: '***nsmb.conf Keywords***'
  id: totrans-421
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***nsmb.conf 关键字***'
- en: Specify a *nsmb.conf* configuration with keywords and values under the appropriate
    section. For example, servers have IP addresses and users don’t, so you would
    use only an IP address assignment in the server section. To use a keyword, assign
    a value with an equal sign, as in *keyword=value*. Here are the common keywords;
    for a full list, see nsmb.conf(5).
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在适当的部分下，指定一个带有关键字和值的*nsmb.conf*配置。例如，服务器有 IP 地址而用户没有，所以在服务器部分仅使用 IP 地址分配。使用关键字时，用等号赋值，如*keyword=value*。以下是常用的关键字；有关完整列表，请参见
    nsmb.conf(5)。
- en: '**workgroup=string**'
  id: totrans-423
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**workgroup=string**'
- en: The `workgroup` keyword specifies the name of the Windows domain or workgroup
    you want to access. This is commonly a default setting used for all servers.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '`workgroup` 关键字指定要访问的 Windows 域或工作组的名称。这通常是所有服务器的默认设置。'
- en: '[PRE77]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '**addr=a.b.c.d**'
  id: totrans-426
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**addr=a.b.c.d**'
- en: The `addr` keyword sets the IP address of a CIFS server. This keyword can appear
    only under a plain `[servername]` label. You shouldn’t need this if you have working
    CIFS name resolution, but reality sometimes disagrees.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '`addr` 关键字设置 CIFS 服务器的 IP 地址。此关键字只能出现在简单的 `[servername]` 标签下。如果你已经有工作中的 CIFS
    名称解析，则不需要此项，但现实中有时并非如此。'
- en: '**nbns=a.b.c.d**'
  id: totrans-428
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**nbns=a.b.c.d**'
- en: The `nbns` keyword sets the IP address of a NetBIOS (WINS) nameserver. You can
    put this line in the default section or under a particular server. If you have
    Active Directory (which is based on DNS), you can use DNS hostnames. Adding a
    WINS server won’t hurt your configuration, however, and helps in testing basic
    CIFS setup.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '`nbns` 关键字设置 NetBIOS（WINS）名称服务器的 IP 地址。你可以将此行放在默认部分或特定服务器下。如果你使用 Active Directory（基于
    DNS），你可以使用 DNS 主机名。然而，添加一个 WINS 服务器不会影响你的配置，并有助于测试基本的 CIFS 设置。'
- en: '**password=string**'
  id: totrans-430
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**password=string**'
- en: The `password` keyword sets a clear-text password for a user or a share. If
    you must store passwords in */etc/nsmb.conf*, be absolutely certain that only
    root can read the file. Storing a password in *$HOME/.nsmbrc* is a bad idea on
    a multiuser system.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '`password` 关键字为用户或共享设置明文密码。如果必须将密码存储在*/etc/nsmb.conf*中，必须确保只有 root 用户可以读取该文件。在多用户系统中，在*$HOME/.nsmbrc*中存储密码是个坏主意。'
- en: You can scramble your Windows password with `smbutil crypt`, generating a string
    that you can use for this keyword. The scrambled string has double dollar signs
    (`$$`) in front of it. While this helps prevent someone accidentally discovering
    the password, a malicious user can unscramble it easily.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`smbutil crypt`对 Windows 密码进行加密，生成一个字符串，用于此关键字。加密后的字符串前面有双美元符号（`$$`）。虽然这有助于防止有人意外发现密码，但恶意用户可以轻松地解密它。
- en: '[PRE78]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: If the server needs access to a CIFS share to do its routine job, don’t use
    your account. Ask the Windows team for an account for your server so that problems
    with your account won’t interrupt the server’s functions.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器需要访问 CIFS 共享以执行其常规任务，请不要使用你的账户。请向 Windows 团队申请为你的服务器提供一个账户，以避免你的账户问题干扰服务器功能。
- en: '**Sample Configuration**'
  id: totrans-435
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例配置**'
- en: Here, I build an *nsmb.conf* allowing Bert access to his files on the corporate
    CIFS fileserver.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我创建了一个 *nsmb.conf*，允许Bert访问他在公司CIFS文件服务器上的文件。
- en: '[PRE79]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: With this configuration, Bert should be able to access whatever CIFS shares
    those tyrannical Windows admins permit.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种配置下，Bert 应该能够访问那些专制的Windows管理员允许的CIFS共享。
- en: '***CIFS Name Resolution***'
  id: totrans-439
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***CIFS名称解析***'
- en: Before FreeBSD can mount a CIFS share, it needs to identify the host the share
    is on. While Microsoft has used DNS for decades now, typical Windows environments
    often support a whole panoply of legacy protocols. Verify that smbutil(1) can
    find CIFS servers with `smbutil lookup`.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在 FreeBSD 挂载 CIFS 共享之前，它需要识别共享所在的主机。虽然微软已经使用DNS数十年，但典型的Windows环境通常支持多种旧版协议。通过
    `smbutil lookup` 验证 smbutil(1) 是否能够找到CIFS服务器。
- en: '[PRE80]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: If this works, you have basic CIFS functionality.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这有效，那么你已经具备了基本的CIFS功能。
- en: '***Other smbutil(1) Functions***'
  id: totrans-443
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***其他 smbutil(1) 功能***'
- en: You can view shares on a host at the command line. Start by logging into your
    host.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在命令行查看主机上的共享。首先登录到你的主机。
- en: '[PRE81]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: So, our configuration is correct. Let’s see what resources this server offers
    with smbutil’s `view` command.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们的配置是正确的。让我们使用 smbutil 的 `view` 命令查看此服务器提供了哪些资源。
- en: '[PRE82]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: You’ll get a list of every shared resource on the CIFS server. Now, assuming
    you’re finished, log out of the server.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到一个CIFS服务器上每个共享资源的列表。现在，假设你已经完成，退出服务器。
- en: '[PRE83]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '***Mounting a Share***'
  id: totrans-450
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***挂载共享***'
- en: 'Now that you’ve finished investigating, mount a share with mount_smbfs(8).
    The syntax is as follows:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在你完成调查后，使用 mount_smbfs(8) 挂载共享。语法如下：
- en: '[PRE84]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'I have a share on this Windows box called *MP3* that I want to access from
    my FreeBSD system. To mount this as */home/mwlucas/smbmount*, I would do this:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这台Windows机器上有一个叫 *MP3* 的共享，我想从我的FreeBSD系统访问它。为了将它挂载到 */home/mwlucas/smbmount*，我会这样做：
- en: '[PRE85]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The mount(8) and df(1) programs show this share attached to your system, and
    you can access documents on this server just as you could any other filesystem.
    Use umount(8) to disconnect from the server.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: mount(8) 和 df(1) 程序会显示此共享已附加到你的系统，你可以像访问任何其他文件系统一样访问服务器上的文档。使用 umount(8) 来断开与服务器的连接。
- en: '***Other mount_smbfs Options***'
  id: totrans-456
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***其他 mount_smbfs 选项***'
- en: mount_smbfs includes several options to tweak the behavior of mounted CIFS filesystems.
    Use the `-f` option to choose a different file permission mode and the `-d` option
    to choose a different directory permission mode. For example, to set a mount so
    that only I could access the contents of the directory, I would use `mount_smbfs
    -d 700`. This would make the FreeBSD permissions far more stringent than the Windows
    privileges, but that’s perfectly all right with me. I can change the owner of
    the files with the `-u` option and the group with the `-g` option.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: mount_smbfs 包括多个选项来调整挂载CIFS文件系统的行为。使用 `-f` 选项可以选择不同的文件权限模式，使用 `-d` 选项可以选择不同的目录权限模式。例如，若要设置一个挂载，使得只有我可以访问该目录的内容，我会使用
    `mount_smbfs -d 700`。这将使FreeBSD权限比Windows权限更严格，但我完全没问题。我可以通过 `-u` 选项更改文件的所有者，使用
    `-g` 选项更改组。
- en: 'Microsoft filesystems are case insensitive, but Unix-like operating systems
    are case sensitive. CIFS defaults to leaving the case as it finds it, but that
    may not be desirable. The `-c` flag makes mount_smbfs(8) change the case on the
    filesystem: `-c l` changes everything to lowercase and `-c u` changes everything
    to uppercase.'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的文件系统对大小写不敏感，但类Unix操作系统对大小写敏感。CIFS默认保持原样，但这可能并不总是理想的。`-c` 标志会让 mount_smbfs(8)
    修改文件系统中的大小写：`-c l` 会将所有字母改为小写，而 `-c u` 则会将所有字母改为大写。
- en: '***nsmb.conf Options***'
  id: totrans-459
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***nsmb.conf 选项***'
- en: Here are samples of *nsmb.conf* entries for different situations. They all assume
    they’re part of a configuration where you’ve already defined a workgroup, NetBIOS
    nameserver, and a username with privileges to access the CIFS shares.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是不同情况下 *nsmb.conf* 配置项的示例。它们都假设你已经在配置中定义了工作组、NetBIOS名称服务器，并且拥有访问CIFS共享的权限的用户名。
- en: '**Unique Password on a Standalone System**'
  id: totrans-461
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**独立系统上的唯一密码**'
- en: You’d use something like the following if you have a machine named *desktop*
    with a password-protected share. Many standalone Windows systems have this sort
    of password-protection feature.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一台名为 *desktop* 的机器，并且有一个受密码保护的共享，你可以使用类似以下的命令。许多独立的Windows系统都有这种密码保护功能。
- en: '[PRE86]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '**Accessing a Second Domain**'
  id: totrans-464
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**访问第二个域**'
- en: In this example, we’re accessing a second domain named *development*. This domain
    has a username and password different from those at our default domain.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们访问的是一个名为 *development* 的第二个域。该域的用户名和密码与我们默认域的不同。
- en: '[PRE87]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '***CIFS File Ownership***'
  id: totrans-467
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***CIFS文件所有权***'
- en: Ownership of files between Unix-like and Windows systems can be problematic.
    For one thing, your FreeBSD usernames probably won’t map to Windows usernames,
    and Unix has a very different permissions scheme compared to Windows.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: Unix-like系统和Windows系统之间的文件所有权可能会出现问题。首先，你的FreeBSD用户名可能无法映射到Windows用户名，而且Unix的权限机制与Windows有很大不同。
- en: Since you’re using a single Windows username to access the share, you have whatever
    access that account has to the Windows resources, but you must assign the proper
    FreeBSD permissions for that mounted share. By default, mount_smbfs(8) assigns
    the new share the same permissions as the mount point. In our earlier example,
    the directory */home/mwlucas/smbmount* is owned by the user *mwlucas* and has
    permissions of 755\. These permissions say that mwlucas can edit what’s in this
    directory but nobody else can. Even though FreeBSD says that this user can edit
    those files, Windows still might not let that particular user edit the files it’s
    sharing out.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你使用的是单一的Windows用户名来访问共享资源，因此你只能获得该帐户对Windows资源的访问权限，但必须为挂载的共享分配正确的FreeBSD权限。默认情况下，mount_smbfs(8)将为新的共享分配与挂载点相同的权限。在我们之前的示例中，目录*/home/mwlucas/smbmount*由用户*mwlucas*拥有，并且权限为755。这些权限表示mwlucas可以编辑该目录中的内容，但其他人不能。尽管FreeBSD表示该用户可以编辑这些文件，但Windows仍可能不允许该特定用户编辑它所共享的文件。
- en: '**Serving CIFS Shares**'
  id: totrans-470
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**提供CIFS共享**'
- en: Just as FreeBSD can access CIFS shares, it can also serve them to CIFS clients
    with Samba. You can find several recent versions of Samba in the packages collection.
    The Samba website at *[http://www.samba.org/](http://www.samba.org/)* contains
    many useful tutorials. Serving CIFS shares from FreeBSD is much more complicated
    than accessing them, so we’ll end our discussion here before this book grows even
    thicker.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 正如FreeBSD可以访问CIFS共享一样，它也可以通过Samba将共享提供给CIFS客户端。你可以在包集合中找到几个版本较新的Samba。Samba官网
    *[http://www.samba.org/](http://www.samba.org/)* 提供了许多有用的教程。从FreeBSD提供CIFS共享比访问它们要复杂得多，因此我们将在此结束讨论，以免本书变得更厚。
- en: We’ve now finished our tour of FreeBSD filesystems. While I’ve spent a few chapters
    on the topic, FreeBSD has several additional filesystems options, an automounter,
    and even Filesystem in Userspace (FUSE) support for accessing NTFS, Linux’s extfs,
    and more. It has special iSCSI support and special filesystems like nullfs(5)
    that make managing jails at scale very powerful. If I spend any more time on filesystems,
    though, you’ll track me down and use a blunt instrument to express your displeasure,
    so let’s proceed to some of FreeBSD’s advanced security features.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了对FreeBSD文件系统的介绍。虽然我已经花了几章来讲解这个主题，但FreeBSD还有几个额外的文件系统选项、一个自动挂载工具，甚至支持Filesystem
    in Userspace（FUSE），用于访问NTFS、Linux的extfs等。它还具有特殊的iSCSI支持和像nullfs(5)这样的特殊文件系统，使得在大规模管理监狱（jails）时非常强大。不过，如果我再花更多时间讲解文件系统，你们可能会追踪到我并用钝器表达你们的不满，所以让我们继续讨论FreeBSD的一些高级安全特性。
