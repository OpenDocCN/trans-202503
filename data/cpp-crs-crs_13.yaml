- en: '**10'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**10'
- en: TESTING**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 测试**
- en: '*“How could [the computer] pick up a picture of Ender’s brother and put it
    into the graphics in this Fairyland routine?” “Colonel Graff, I wasn’t there when
    it was programmed. All I know is that the computer’s never taken anyone to this
    place before.”'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*“[电脑]是怎么拿到恩德兄弟的照片并把它放进这个《仙境》程序的图形中的？” “格拉夫上校，我当时不在现场，程序是怎么写的我不知道。我只知道电脑从未带任何人来过这个地方。”*'
- en: —Orson Scott Card*, Ender’s Game
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —奥森·斯科特·卡德，《安德的游戏》
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: Many ways are available to you to test your software. The common thread running
    through all these testing methods is that each test provides some kind of input
    to your code and you evaluate the test’s output for suitability. The nature of
    the environment, the scope of the investigation, and the form of the evaluation
    vary widely among testing types. This chapter covers how to perform testing with
    a few different frameworks, but the material is extensible to other testing varieties.
    Before diving in, let’s take a quick survey of several kinds of testing.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以用来测试你的软件。所有这些测试方法的共同点是，每个测试都会为你的代码提供某种输入，你需要评估测试的输出是否合适。环境的性质、调查的范围和评估的形式在不同的测试类型中差异很大。本章介绍了如何使用几种不同的框架进行测试，但这些内容可以扩展到其他测试方法。在开始之前，让我们快速了解几种不同的测试类型。
- en: '**Unit Tests**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**单元测试**'
- en: '*Unit tests* verify that a focused, cohesive collection of code—a *unit*, such
    as a function or a class—behaves exactly as the programmer intended. Good unit
    tests isolate the unit being tested from its dependencies. Sometimes this can
    be hard to do: the unit might depend on other units. In such situations, you use
    mocks to stand in for these dependencies. *Mocks* are fake objects you use solely
    during testing to provide you with fine-grained control over how a unit’s dependencies
    behave during the test. Mocks can also record how a unit interacted with them,
    so you can test whether a unit is interacting with its dependencies as expected.
    You can also use mocks to simulate rare events, such as a system running out of
    memory, by programming them to throw an exception.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*单元测试*验证一组集中的、凝聚的代码——一个*单元*，比如一个函数或类——是否按程序员的意图正常运行。好的单元测试会将被测试的单元与其依赖项隔离开来。有时这可能会很困难：单元可能依赖于其他单元。在这种情况下，你可以使用模拟（mocks）来代替这些依赖项。*模拟*是你在测试期间专门使用的虚拟对象，用于精确控制单元的依赖项在测试中的表现。模拟还可以记录单元与它们的交互方式，这样你就可以测试单元是否按预期与依赖项交互。你还可以使用模拟来模拟一些罕见事件，比如系统内存不足，通过编程让它们抛出异常。'
- en: '***Integration Tests***'
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***集成测试***'
- en: Testing a collection of units together is called an *integration test*. Integration
    tests can also refer to testing interactions between software and hardware, which
    system programmers deal with often. Integration tests are an important layer on
    top of unit tests, because they ensure that the software you’ve written works
    together as a system. These tests complement, but don’t replace, unit tests.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 测试多个单元一起工作被称为*集成测试*。集成测试也可以指测试软件与硬件之间的交互，这是系统程序员常常涉及的内容。集成测试是单元测试之上的一个重要层级，因为它确保你编写的软件能作为一个系统协同工作。这些测试是对单元测试的补充，而不是替代。
- en: '***Acceptance Tests***'
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***验收测试***'
- en: '*Acceptance tests* ensure that your software meets all of your customers’ requirements.
    High-performing software teams can use acceptance tests to guide development.
    Once all of the acceptance tests pass, your software is deliverable. Because these
    acceptance tests become part of the code base, there is built-in protection against
    refactoring or feature regression, where you break an existing feature in the
    process of adding a new one.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*验收测试*确保你的软件符合所有客户的要求。高效的软件团队可以利用验收测试来指导开发。当所有的验收测试通过时，你的软件就可以交付了。因为这些验收测试成为代码库的一部分，所以它们在重构或特性回归时提供了内建的保护，防止在添加新特性时破坏现有功能。'
- en: '***Performance Tests***'
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***性能测试***'
- en: '*Performance tests* evaluate whether software meets effectiveness requirements,
    such as speed of execution or memory/power consumption. Optimizing code is a fundamentally
    empirical exercise. You can (and should) have ideas about which parts of your
    code are causing performance bottlenecks but can’t know for sure unless you measure.
    Also, you cannot know whether the code changes you implement with the intent of
    optimizing are improving performance unless you measure again. You can use performance
    tests to instrument your code and provide relevant measures. *Instrumentation*
    is a technique for measuring product performance, detecting errors, and logging
    how a program executes. Sometimes customers have strict performance requirements
    (for example, computation cannot take more than 100 milliseconds or the system
    cannot allocate more than 1MB of memory). You can automate testing such requirements
    and make sure that future code changes don’t violate them.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*性能测试*评估软件是否满足有效性要求，例如执行速度或内存/功耗。优化代码本质上是一个经验性的过程。你可以（也应该）有一些关于哪些代码部分可能导致性能瓶颈的想法，但除非你进行测量，否则无法确定。并且，除非你再次进行测量，否则无法知道你为了优化所做的代码修改是否真的提升了性能。你可以使用性能测试来给你的代码添加测量功能，并提供相关的度量。*仪表化*是一种测量产品性能、检测错误并记录程序执行方式的技术。有时，客户有严格的性能要求（例如，计算不能超过100毫秒，或系统不能分配超过1MB的内存）。你可以自动化测试这些要求，并确保未来的代码更改不会违反它们。'
- en: Code testing can be an abstract, dry subject. To avoid this, the next section
    introduces an extended example that lends context to the discussion.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 代码测试可能是一个抽象、枯燥的话题。为了避免这种情况，下一部分将介绍一个扩展示例，为讨论提供背景。
- en: '**An Extended Example: Taking a Brake**'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**扩展示例：刹车**'
- en: Suppose you’re programming the software for an autonomous vehicle. Your team’s
    software is very complicated and involves hundreds of thousands of code lines.
    The entire software solution is composed of several binaries. To deploy your software,
    you must upload the binaries into a car (using a relatively time-consuming process).
    Making a change to your code, compiling, uploading, and executing it in a live
    vehicle takes several hours per iteration.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在为一辆自动驾驶汽车编写软件。你们团队的软件非常复杂，涉及数十万行代码。整个软件解决方案由多个二进制文件组成。为了部署你的软件，你必须将二进制文件上传到汽车（这是一个相对耗时的过程）。对代码进行修改、编译、上传并在实际车辆中执行，每次迭代需要几个小时。
- en: The monumental task of writing all the vehicle’s software is broken out into
    teams. Each team is responsible for a *service*, such as the steering wheel control,
    audio/video, or vehicle detection. Services interact with each other via a service
    bus, where each service publishes events. Other services subscribe to these events
    as needed. This design pattern is called a *service bus architecture*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 写出所有车辆软件的庞大任务被分解为多个团队。每个团队负责一个*服务*，例如方向盘控制、音视频或车辆检测。服务通过服务总线相互交互，其中每个服务发布事件。其他服务根据需要订阅这些事件。这种设计模式被称为*服务总线架构*。
- en: 'Your team is responsible for the autonomous braking service. The service must
    determine whether a collision is about to happen and, if so, tell the car to brake.
    Your service subscribes to two event types: the `SpeedUpdate` class, which tells
    you that the car’s speed has changed, and the `CarDetected` class, which tells
    you that some other car has been detected in front of you. Your system is responsible
    for publishing a `BrakeCommand` to the service bus whenever an imminent collision
    is detected. These classes appear in [Listing 10-1](ch10.xhtml#ch10ex01).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你的团队负责自动刹车服务。该服务必须判断是否即将发生碰撞，如果发生碰撞，便指示汽车刹车。你的服务订阅了两种事件类型：`SpeedUpdate`类，通知你车辆的速度已经变化，以及`CarDetected`类，通知你前方有其他车辆被检测到。每当检测到即将发生碰撞时，你的系统负责向服务总线发布`BrakeCommand`。这些类出现在[Listing
    10-1](ch10.xhtml#ch10ex01)中。
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 10-1: The POD classes that your service interacts with*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 10-1: 你的服务所交互的POD类*'
- en: 'You’ll publish the `BrakeCommand` using a `ServiceBus` object that has a `pub``lish`
    method:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用具有`publish`方法的`ServiceBus`对象发布`BrakeCommand`：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The lead architect wants you to expose an `observe` method so you can subscribe
    to `SpeedUpdate` and `CarDetected` events on the service bus. You decide to build
    a class called `AutoBrake` that you’ll initialize in the program’s entry point.
    The `AutoBrake` class will keep a reference to the `publish` method of the service
    bus, and it will subscribe to `SpeedUpdate` and `CarDetected` events through its
    `observe` method, as in [Listing 10-2](ch10.xhtml#ch10ex02).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首席架构师希望你暴露一个 `observe` 方法，以便你可以订阅服务总线上的 `SpeedUpdate` 和 `CarDetected` 事件。你决定构建一个名为
    `AutoBrake` 的类，并在程序的入口点初始化它。`AutoBrake` 类将保留对服务总线 `publish` 方法的引用，并通过其 `observe`
    方法订阅 `SpeedUpdate` 和 `CarDetected` 事件，如[清单10-2](ch10.xhtml#ch10ex02)所示。
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 10-2: The `AutoBrake` class, which provides the automatic braking
    service*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单10-2：提供自动刹车服务的 `AutoBrake` 类*'
- en: '[Figure 10-1](ch10.xhtml#ch10fig01) summarizes the relationship between the
    service bus `ServiceBus`, the automatic braking system `AutoBrake`, and other
    services.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10-1](ch10.xhtml#ch10fig01) 总结了服务总线 `ServiceBus`、自动刹车系统 `AutoBrake` 和其他服务之间的关系。'
- en: '![image](../images/fig10_1.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig10_1.jpg)'
- en: '*Figure 10-1: A high-level depiction of the interaction between services and
    the service bus*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-1：服务与服务总线之间交互的高级示意图*'
- en: The service integrates into the car’s software, yielding something like the
    code in [Listing 10-3](ch10.xhtml#ch10ex03).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务集成到汽车的软件中，生成类似于[清单10-3](ch10.xhtml#ch10ex03)中的代码。
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 10-3: A sample entry point using your `AutoBrake` service*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单10-3：使用 `AutoBrake` 服务的示例入口点*'
- en: You construct an `AutoBrake` with a lambda that captures a reference to a `ServiceBus`
    ➊. All the details of how `AutoBrake` decides when to brake are completely hidden
    from the other teams. The service bus mediates all interservice communication.
    You’ve simply passed any commands from the `AutoBrake` directly to the `ServiceBus`
    ➋. Within the event loop, a `ServiceBus` can pass `SpeedUpdate` ➌ and `CarDetected`
    objects ➍ to the `observe` method on your `auto_brake`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过一个 lambda 来构造 `AutoBrake`，它捕获对 `ServiceBus` 的引用 ➊。`AutoBrake` 何时决定刹车的所有细节对其他团队完全隐藏。服务总线调解所有服务间的通信。你只是将
    `AutoBrake` 的任何命令直接传递给 `ServiceBus` ➋。在事件循环中，`ServiceBus` 可以将 `SpeedUpdate` ➌
    和 `CarDetected` 对象 ➍ 传递给你的 `auto_brake` 的 `observe` 方法。
- en: '***Implementing AutoBrake***'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***实现 AutoBrake***'
- en: The conceptually simple way to implement `AutoBrake` is to iterate among writing
    some code, compiling the production binary, uploading it to a car, and testing
    functionality manually. This approach is likely to cause program (and car) crashes
    and to waste a whole lot of time. A better approach is to write code, compile
    a unit-test binary, and run it in your desktop development environment. You can
    iterate among these steps more quickly; once you’re reasonably confident that
    the code you’ve written works as intended, you can do a manual test with a live
    car.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 `AutoBrake` 的概念上简单的方法是通过编写一些代码、编译生成的二进制文件、将其上传到汽车并手动测试功能来进行迭代。这个方法可能会导致程序（和汽车）崩溃，并浪费大量时间。更好的方法是编写代码、编译单元测试二进制文件，并在桌面开发环境中运行。你可以更快速地在这些步骤之间迭代；一旦你对所编写的代码是否按预期工作有了合理的信心，就可以进行带有实际汽车的手动测试。
- en: The *unit-test binary* will be a simple console application targeting the desktop
    operating system. In the unit-test binary, you’ll run a suite of unit tests that
    pass specific inputs into an `AutoBrake` and assert that it produces the expected
    results.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*单元测试二进制文件* 将是一个简单的控制台应用程序，针对桌面操作系统。在单元测试二进制文件中，你将运行一套单元测试，将特定输入传递给 `AutoBrake`
    并断言它产生预期的结果。'
- en: 'After consulting with your management team, you’ve collected the following
    requirements:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在与管理团队商讨后，你收集了以下需求：
- en: '`AutoBrake` will consider the car’s initial speed zero.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AutoBrake` 将把汽车的初始速度视为零。'
- en: '`AutoBrake` should have a configurable sensitivity threshold based on how many
    seconds are forecast until a collision. The sensitivity must not be less than
    1 second. The default sensitivity is 5 seconds.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AutoBrake` 应该具有可配置的灵敏度阈值，该阈值基于预测的碰撞发生前的秒数。灵敏度不得低于1秒，默认灵敏度为5秒。'
- en: '`AutoBrake` must save the car’s speed in between `SpeedUpdate` observations.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AutoBrake` 必须在 `SpeedUpdate` 观察之间保存汽车的速度。'
- en: Each time `AutoBrake` observes a `CarDetected` event, it must publish a `BrakeCommand`
    if a collision is forecasted in less time than the configured sensitivity threshold.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次 `AutoBrake` 观察到 `CarDetected` 事件时，如果预测的碰撞时间少于配置的灵敏度阈值，它必须发布一个 `BrakeCommand`。
- en: Because you have such a pristine requirements list, the next step is to try
    implementing the automatic braking service using *test-driven development (TDD)*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你有这样一个完善的需求列表，下一步是尝试使用 *测试驱动开发（TDD）* 实现自动刹车服务。
- en: '**NOTE**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Because this book is about C++ and not about physics, your `AutoBrake` only
    works when a car is directly in front of you.*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*因为本书是关于 C++ 的，而不是物理学，你的 `AutoBrake` 仅在车子直接在你面前时起作用。*'
- en: '***Test-Driven Development***'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***测试驱动开发***'
- en: At some point in the history of unit-testing adoption, some intrepid software
    engineers thought, “If I know I’m going to write a bunch of unit tests for this
    class, why not write the tests first?” This manner of writing software, known
    as TDD, underpins one of the great religious wars in the software engineering
    community. Vim or Emacs? Tabs or spaces? To use TDD or not to use TDD? This book
    humbly abstains from weighing in on these questions. But we’ll use TDD because
    it fits so naturally into a unit-testing discussion.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试采用的历史过程中，曾有一些勇敢的软件工程师想：“如果我知道我将为这个类编写一堆单元测试，为什么不先编写测试呢？”这种编写软件的方式，被称为 TDD，它是软件工程界一场伟大的宗教战争的基石。Vim
    还是 Emacs？制表符还是空格？使用 TDD 还是不使用 TDD？本书谦虚地避免对这些问题发表评论。但我们将使用 TDD，因为它与单元测试的讨论非常契合。
- en: '**Advantages of TDD**'
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**TDD 的优势**'
- en: The process of writing a test that encodes a requirement *before* implementing
    the solution is the fundamental idea behind TDD. Proponents say that code written
    this way tends to be more modular, robust, clean, and well designed. Writing good
    tests is the best way to document your code for other developers. A good test
    suite is a fully working set of examples that never gets out of sync. It protects
    against regressions in functionality whenever you add new features.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个测试来编码需求*在*实现解决方案之前，是 TDD 背后的基本理念。支持者认为，以这种方式编写的代码通常更模块化、健壮、清晰且设计良好。编写良好的测试是为其他开发人员记录代码的最佳方式。一个好的测试套件是一个完全可工作的示例集，永远不会失去同步。它可以防止在添加新特性时出现功能回退。
- en: Unit tests also serve as a fantastic way to submit bug reports by writing a
    unit test that fails. Once the bug is fixed, it will stay fixed because the unit
    test and the code that fixes the bug become part of the test suite.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试还可以作为提交 bug 报告的绝佳方式，方法是编写一个失败的单元测试。一旦 bug 被修复，它将始终保持修复状态，因为单元测试和修复 bug 的代码会成为测试套件的一部分。
- en: '**Red-Green-Refactor**'
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**红-绿-重构**'
- en: 'TDD practitioners have a mantra: *red, green, refactor*. Red is the first step,
    and it means to implement a failing test. This is done for several reasons, principal
    of which is to make sure you’re actually testing something. You might be surprised
    how common it is to accidentally design a test that doesn’t make any assertions.
    Next, you implement code that makes the test pass. No more, no less. This turns
    the test from red to green. Now that you have working code and a passing test,
    you can refactor your production code. To refactor means to restructure existing
    code without changing its functionality. For example, you might find a more elegant
    way to write the same code, replace your code with a third-party library, or rewrite
    your code to have better performance characteristics.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: TDD 实践者有一个口号：*红色、绿色、重构*。红色是第一步，它意味着实现一个失败的测试。这么做有几个原因，最主要的是确保你真的在测试某个东西。你可能会惊讶于，设计一个没有任何断言的测试是多么常见。接下来，你实现使测试通过的代码。仅此而已。这将把测试从红色变为绿色。现在，你已经有了工作的代码和通过的测试，你可以重构你的生产代码。重构是指在不改变功能的前提下重组现有代码。例如，你可能会找到一种更优雅的方式来编写相同的代码，或者用第三方库替代你的代码，或者重写你的代码以获得更好的性能特征。
- en: If you accidentally break something, you’ll know immediately because your test
    suite will tell you. Then you continue to implement the remainder of the class
    using TDD. You can work on the collision threshold next.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不小心破坏了某些东西，你会立即知道，因为你的测试套件会告诉你。然后，你继续使用 TDD 实现类的其余部分。接下来，你可以开始处理碰撞阈值。
- en: '**Writing a Skeleton AutoBrake Class**'
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**编写一个骨架 AutoBrake 类**'
- en: Before you can write tests, you need to write a *skeleton class*, which implements
    an interface but provides no functionality. It’s useful in TDD because you can’t
    compile a test without a shell of the class you’re testing.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在你编写测试之前，你需要编写一个 *骨架类*，它实现了一个接口，但没有提供任何功能。在 TDD 中，这非常有用，因为如果没有你正在测试的类的外壳，你无法编译测试。
- en: Consider the skeleton `AutoBrake` class in [Listing 10-4](ch10.xhtml#ch10ex04).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考 [示例 10-4](ch10.xhtml#ch10ex04) 中的骨架 `AutoBrake` 类。
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 10-4: A skeleton `AutoBrake` class*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 10-4：一个骨架 `AutoBrake` 类*'
- en: 'The `AutoBrake` class has a single constructor that takes the template parameter
    `publish` ➊, which you save off into a `const` member. One of the requirements
    states that you’ll invoke `publish` with a `BrakeCommand`. Using the template
    parameter `T` allows you to program generically against any type that supports
    invocation with a `BrakeCommand`. You provide two different observe functions:
    one for each kind of event you want to subscribe to ➋➌. Because this is just a
    skeleton class, no instructions are in the body. You just need a class that exposes
    the appropriate methods and compiles without error. Because the methods return
    `void`, you don’t even need a return statement.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`AutoBrake`类有一个构造函数，接受模板参数`publish` ➊，并将其保存在一个`const`成员中。一个需求指出，你将使用`BrakeCommand`调用`publish`。使用模板参数`T`允许你针对任何支持用`BrakeCommand`调用的类型编写通用代码。你提供了两个不同的观察函数：每个函数订阅你想要关注的事件类型
    ➋➌。由于这只是一个骨架类，函数体中没有任何指令。你只需要一个暴露适当方法并能够编译通过的类。因为这些方法返回`void`，你甚至不需要返回语句。'
- en: You implement a setter ➍ and getter ➎. These methods mediate interaction with
    the private member variable `collision_threshold_s`. One of the requirements implies
    a class invariant about valid values for `collision_threshold_s`. Because this
    value can change after construction, you can’t just use the constructor to establish
    a class invariant. You need a way to enforce this class invariant throughout the
    object’s lifetime. You can use the setter to perform validation before the class
    sets a member’s value. The getter allows you to read the value of `collision_threshold_s`
    without permitting modification. It enforces a kind of *external constness*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你实现了一个setter ➍和getter ➎方法。这些方法调解与私有成员变量`collision_threshold_s`的交互。一个需求意味着关于`collision_threshold_s`有效值的类不变式。因为该值在构造后可能会发生变化，你不能仅仅通过构造函数来建立类的不变式。你需要一种方式来在整个对象生命周期内强制执行这个类的不变式。你可以使用setter方法在类设置成员的值之前进行验证。getter方法允许你读取`collision_threshold_s`的值，但不允许修改它。这强制执行了一种*外部常量性*。
- en: Finally, you have a getter for `speed_mps` ➏ with no corresponding setter. This
    is similar to making `speed_mps` a public member, with the important difference
    that it would be possible to modify `speed_mps` from an external class if it were
    public.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你有一个`speed_mps` ➏的getter方法，但没有对应的setter方法。这类似于将`speed_mps`设为公共成员，唯一的重要区别是如果它是公共的，外部类就可以修改`speed_mps`。
- en: '**Assertions: The Building Blocks of Unit Tests**'
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**断言：单元测试的构建块**'
- en: A unit test’s most essential component is the *assertion*, which checks that
    some condition is met. If the condition isn’t met, the enclosing test fails.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试最重要的组成部分是*断言*，它检查某个条件是否满足。如果条件不满足，则相应的测试将失败。
- en: '[Listing 10-5](ch10.xhtml#ch10ex05) implements an `assert_that` function that
    throws an exception with an error message whenever some Boolean `statement` is
    `false`.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-5](ch10.xhtml#ch10ex05)实现了一个`assert_that`函数，当某个布尔`statement`为`false`时，它会抛出一个带有错误信息的异常。'
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 10-5: A program illustrating `assert_that` (Output is from a binary
    compiled by GCC v7.1.1.)*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-5：一个演示`assert_that`的程序（输出来自GCC v7.1.1编译的二进制文件）*'
- en: The `assert_that` function checks whether the `statement` ➊ parameter is `false`,
    in which case it throws an exception with the `message` parameter ➋. The first
    assertion checks that `1 + 2 > 2`, which passes ➌. The second assertion checks
    that `24 == 42`, which fails and throws an uncaught exception ➍.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert_that`函数检查`statement` ➊参数是否为`false`，如果是，则抛出带有`message`参数 ➋的异常。第一个断言检查`1
    + 2 > 2`，该断言通过 ➌。第二个断言检查`24 == 42`，该断言失败并抛出一个未捕获的异常 ➍。'
- en: '**Requirement: Initial Speed Is Zero**'
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**需求：初始速度为零**'
- en: Consider the first requirement that the car’s initial speed is zero. Before
    implementing this functionality in `AutoBrake`, you need to write a unit test
    that encodes this requirement. You’ll implement the unit test as a function that
    creates an `AutoBrake`, exercises the class, and makes assertions about the results.
    [Listing 10-6](ch10.xhtml#ch10ex06) contains a unit test that encodes the requirement
    that the initial speed is zero.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 假设汽车的初始速度为零。在`AutoBrake`中实现此功能之前，你需要编写一个单元测试来编码这一需求。你将把单元测试实现为一个函数，创建一个`AutoBrake`对象，执行类中的方法，并对结果进行断言。[清单
    10-6](ch10.xhtml#ch10ex06)包含了一个编码初始速度为零的需求的单元测试。
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 10-6: A unit test encoding the requirement that the initial speed
    be zero*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-6：一个编码初始速度为零的单元测试*'
- en: You first construct an `AutoBrake` with an empty `BrakeCommand publish` function
    ➊. This unit test is only concerned with the initial value of `AutoBrake` for
    car speed. Because this unit test is not concerned with how or when `AutoBrake`
    publishes a `BrakeCommand`, you give it the simplest argument that will still
    compile.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先构造一个带有空`BrakeCommand publish`函数的`AutoBrake` ➊。这个单元测试只关心`AutoBrake`的初始车速。因为这个单元测试不关心`AutoBrake`如何或何时发布`BrakeCommand`，你给它提供一个最简单的参数，这样仍然可以编译。
- en: '**NOTE**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*A subtle but important feature of unit tests is that if you don’t care about
    some dependency of the unit under test, you can just provide an empty implementation
    that performs some innocuous, default behavior. This empty implementation is sometimes
    called a* stub.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*单元测试的一个微妙但重要的特点是，如果你不关心待测试单元的某些依赖项，你可以提供一个空的实现，执行一些无害的默认行为。这个空实现有时被称为*桩（stub）*。*'
- en: In `initial_speed_is_zero`, you only want to assert that the initial speed of
    the car is zero and nothing else ➋. You use the getter `get_speed_mps` and compare
    the return value to `0`. That’s all you have to do; `assert` will throw an exception
    if the initial speed isn't zero.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在`initial_speed_is_zero`中，你只想断言汽车的初速为零，其他什么都不做 ➋。你使用getter `get_speed_mps`并将返回值与`0`进行比较。就这样；如果初速不是零，`assert`会抛出异常。
- en: Now you need a way to run the unit tests.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要一种方法来运行单元测试。
- en: '**Test Harnesses**'
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**测试工具**'
- en: A *test harness* is code that executes unit tests. You can make a test harness
    that will invoke your unit test functions, like `initial_speed_is_zero`, and handle
    failed assertions gracefully. Consider the test harness `run_test` in [Listing
    10-7](ch10.xhtml#ch10ex07).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*测试工具*是执行单元测试的代码。你可以制作一个测试工具，它会调用你的单元测试函数，如`initial_speed_is_zero`，并优雅地处理失败的断言。参考[列表
    10-7](ch10.xhtml#ch10ex07)中的测试工具`run_test`。'
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 10-7: A test harness*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-7：测试工具*'
- en: The `run_test` harness accepts a unit test as a function pointer named `unit_test`
    and invokes it within a `try`-`catch` statement ➊. As long as `unit_test` doesn’t
    throw an exception, `run_test` will print a friendly message stating that the
    unit test passed before returning ➋. If any `exception` is thrown, the test fails
    and prints a disapproving message ➌.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`run_test`工具接受一个名为`unit_test`的函数指针作为单元测试，并在`try`-`catch`语句中调用它 ➊。只要`unit_test`没有抛出异常，`run_test`将打印一条友好的消息，表示单元测试通过，然后返回
    ➋。如果抛出任何`exception`，测试失败并打印一条不赞同的消息 ➌。'
- en: To make a *unit-test program* that will run all of your unit tests, you place
    the `run_test` test harness inside the `main` function of a new program. All together,
    the unit-test program looks like [Listing 10-8](ch10.xhtml#ch10ex08).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个*单元测试程序*来运行你所有的单元测试，你将`run_test`测试工具放置在新程序的`main`函数中。整个单元测试程序如下所示：[列表
    10-8](ch10.xhtml#ch10ex08)。
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 10-8: The unit-test program*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-8：单元测试程序*'
- en: When you compile and run this unit-test binary, you can see that the unit test
    `initial_speed_is_zero` fails with an informative message ➊.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编译并运行这个单元测试二进制文件时，你可以看到单元测试`initial_speed_is_zero`失败，并显示一条有用的消息 ➊。
- en: '**NOTE**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Because the `AutoBrake` member `speed_mps` is uninitialized in [Listing 10-8](ch10.xhtml#ch10ex08),
    this program has undefined behavior. It’s not actually certain that the test will
    fail. The solution, of course, is that you shouldn’t write programs with undefined
    behavior.*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*因为[列表 10-8](ch10.xhtml#ch10ex08)中的`AutoBrake`成员`speed_mps`没有初始化，所以该程序具有未定义的行为。实际上并不能确定测试是否会失败。当然，解决方案是，你不应该编写具有未定义行为的程序。*'
- en: '**Getting the Test to Pass**'
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**让测试通过**'
- en: 'To get `initial_speed_is_zero` to pass, all that’s required is to initialize
    `speed_mps` to zero in the constructor of `AutoBrake`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让`initial_speed_is_zero`通过，所需的唯一操作是将`speed_mps`在`AutoBrake`的构造函数中初始化为零：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Simply add the initialization to zero ➊. Now, if you update, compile, and run
    the unit-test program in [Listing 10-8](ch10.xhtml#ch10ex08), you’re greeted with
    more pleasant output:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将初始化值设置为零 ➊。现在，如果你更新、编译并运行[列表 10-8](ch10.xhtml#ch10ex08)中的单元测试程序，你会看到更加愉快的输出：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Requirement: Default Collision Threshold Is Five**'
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**要求：默认的碰撞阈值为五**'
- en: The default collision threshold needs to be 5\. Consider the unit test in [Listing
    10-9](ch10.xhtml#ch10ex09).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的碰撞阈值需要是5。参考[列表 10-9](ch10.xhtml#ch10ex09)中的单元测试。
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 10-9: A unit test encoding the requirement that the initial speed
    be zero*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-9：一个编码了初速必须为零要求的单元测试*'
- en: You can insert this test into the test program, as shown in [Listing 10-10](ch10.xhtml#ch10ex10).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将此测试插入到测试程序中，如[列表 10-10](ch10.xhtml#ch10ex10)所示。
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 10-10: Adding the `initial-sensitivity-is-5 test` to the test harness*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-10：将`initial-sensitivity-is-5`测试添加到测试工具中*'
- en: As expected, [Listing 10-10](ch10.xhtml#ch10ex10) reveals that `initial_speed_is_zero`
    still passes and the new test `initial_sensitivity_is_five` fails.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，[清单 10-10](ch10.xhtml#ch10ex10)显示`initial_speed_is_zero`仍然通过，而新的测试`initial_sensitivity_is_five`失败。
- en: Now, make it pass. Add the appropriate member initializer to `AutoBrake`, as
    demonstrated in [Listing 10-11](ch10.xhtml#ch10ex11).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让它通过。像[清单 10-11](ch10.xhtml#ch10ex11)中所示，向`AutoBrake`添加适当的成员初始化器。
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 10-11: Updating `AutoBrake` to satisfy the collision threshold requirement*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-11：更新`AutoBrake`以满足碰撞阈值要求*'
- en: 'The new member initializer ➊ sets `collision_threshold_s` to 5\. Recompiling
    the test program, you can see `initial_sensitivity_is_five` is now passing:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 新的成员初始化器 ➊ 将`collision_threshold_s`设置为5。重新编译测试程序后，你可以看到`initial_sensitivity_is_five`现在通过了：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Next, handle the class invariant that the sensitivity must be greater than 1.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，处理类的不变量，即灵敏度必须大于1。
- en: '**Requirement: Sensitivity Must Always Be Greater Than One**'
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**要求：灵敏度必须始终大于1**'
- en: To encode the sensitivity validation errors using exceptions, you can build
    a test that expects an exception to be thrown when `collision_threshold_s` is
    set to a value less than 1, as [Listing 10-12](ch10.xhtml#ch10ex12) shows.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用异常编码灵敏度验证错误，你可以构建一个测试，期望当`collision_threshold_s`被设置为小于1的值时抛出异常，正如[清单 10-12](ch10.xhtml#ch10ex12)所示。
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 10-12: A test encoding the requirement that sensitivity is always
    greater than 1*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-12：一个编码灵敏度始终大于1要求的测试*'
- en: You expect the `set_collision_threshold_s` method of `auto_brake` to throw an
    exception when called with a value of 0.5 ➊. If it does, you catch the exception
    and return immediately from the test ➋. If `set_collision_threshold_s` doesn’t
    throw an exception, you fail an assertion with the message `no excep``tion thrown`
    ➌.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你期望当调用`auto_brake`的`set_collision_threshold_s`方法并传入值0.5时，它会抛出异常 ➊。如果它确实抛出异常，你会捕获该异常并立即从测试中返回
    ➋。如果`set_collision_threshold_s`没有抛出异常，你会使用`no excep``tion thrown`的消息来失败一个断言 ➌。
- en: Next, add `sensitivity_greater_than_1` to the test harness, as demonstrated
    in [Listing 10-13](ch10.xhtml#ch10ex13).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，按照[清单 10-13](ch10.xhtml#ch10ex13)中的示范，将`sensitivity_greater_than_1`添加到测试工具中。
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 10-13: Adding `set_collision_threshold_s` to the test harness*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-13：将`set_collision_threshold_s`添加到测试工具中*'
- en: As expected, the new unit test fails ➊.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，新的单元测试失败 ➊。
- en: You can implement validation that will make the test pass, as [Listing 10-14](ch10.xhtml#ch10ex14)
    shows.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以实现验证，使得测试通过，正如[清单 10-14](ch10.xhtml#ch10ex14)所示。
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 10-14: Updating the `set_collision_threshold` method of `AutoBrake`
    to validate its input*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-14：更新`AutoBrake`的`set_collision_threshold`方法以验证其输入*'
- en: 'Recompiling and executing the unit-test suite turns the test green:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 重新编译并执行单元测试套件后，测试变为绿色：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Next, you want to make sure that an `AutoBrake` saves the car’s speed in between
    each `SpeedUpdate`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你想确保`AutoBrake`在每次`SpeedUpdate`之间保存汽车的速度。
- en: '**Requirement: Save the Car’s Speed Between Updates**'
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**要求：在更新之间保存汽车的速度**'
- en: The unit test in [Listing 10-15](ch10.xhtml#ch10ex15) encodes the requirement
    that an `AutoBrake` saves the car’s speed.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-15](ch10.xhtml#ch10ex15)中的单元测试编码了`AutoBrake`保存汽车速度的要求。'
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 10-15: Encoding the requirement that an `AutoBrake` saves the car’s
    speed*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-15：编码`AutoBrake`保存汽车速度的要求*'
- en: After constructing an `AutoBrake` ➊, you pass a `SpeedUpdate` with `velocity_mps`
    equal to 100 into its `observe` method ➋. Next, you get the speed back from `auto_brake`
    using the `get_speed_mps` method and expect it is equal to 100 ➌.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建了一个`AutoBrake` ➊后，你将`velocity_mps`等于100的`SpeedUpdate`传递给它的`observe`方法 ➋。接下来，你通过`get_speed_mps`方法从`auto_brake`中获取速度，并期望它等于100
    ➌。
- en: '**NOTE**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*As a general rule, you should have a single assertion per test. This test
    violates the strictest interpretation of this rule, but it’s not violating its
    spirit. All of the assertions are examining the same, cohesive requirement, which
    is that the speed is saved whenever a `SpeedUpdate` is observed.*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*通常来说，每个测试应该有一个单独的断言。这个测试违反了对规则的最严格解释，但并没有违背其精神。所有的断言都在检查同一个、一致的要求，那就是每当观察到`SpeedUpdate`时，速度都会被保存。*'
- en: You add the test in [Listing 10-15](ch10.xhtml#ch10ex15) to the test harness
    in the usual way, as demonstrated in [Listing 10-16](ch10.xhtml#ch10ex16).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你以通常的方式将[清单 10-15](ch10.xhtml#ch10ex15)中的测试添加到测试工具中，正如[清单 10-16](ch10.xhtml#ch10ex16)所示。
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 10-16: Adding the speed-saving unit test into the test harness*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-16：将节速单元测试添加到测试工具中*'
- en: 'Unsurprisingly, the new test fails ➊. To make this test pass, you implement
    the appropriate `observe` function:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 不出所料，新的测试失败了➊。为了让这个测试通过，你需要实现适当的`observe`函数：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You extract the `velocity_mps` from the `SpeedUpdate` and store it into the
    `speed_mps` member variable ➊. Recompiling the test binary shows that the unit
    test now passes:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你从`SpeedUpdate`中提取`velocity_mps`并将其存储到`speed_mps`成员变量中➊。重新编译测试二进制文件后，单元测试通过了：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Finally, you require that `AutoBrake` can compute the correct time to collision
    and, if appropriate, publish a `BrakeCommand` using the `publish` function.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要确保`AutoBrake`能够计算出正确的碰撞时间，并且在适当的时候，使用`publish`函数发布一个`BrakeCommand`。
- en: '**Requirement: AutoBrake Publishes a BrakeCommand When Collision Detected**'
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**需求：当检测到碰撞时，AutoBrake 发布 BrakeCommand**'
- en: 'The relevant equations for computing times to collision come directly from
    high school physics. First, you calculate your car’s relative velocity to the
    detected car:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 计算碰撞时间的相关方程直接来源于高中物理。首先，你计算你车与检测到的车之间的相对速度：
- en: '![image](../images/fig294_1.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig294_1.jpg)'
- en: 'If your relative velocity is constant and positive, the cars will eventually
    collide. You can compute the time to such a collision as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的相对速度是恒定的且为正，那么车辆最终会发生碰撞。你可以通过以下方式计算碰撞的时间：
- en: '![image](../images/fig294_2.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig294_2.jpg)'
- en: If Time[Collision] is greater than zero and less than or equal to `collision_threshold_s`,
    you invoke `publish` with a `BrakeCommand`. The unit test in [Listing 10-17](ch10.xhtml#ch10ex17)
    sets the collision threshold to 10 seconds and then observes events that indicate
    a crash.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Time[Collision]大于零并且小于或等于`collision_threshold_s`，你就会调用`publish`并发布一个`BrakeCommand`。[清单
    10-17](ch10.xhtml#ch10ex17)中的单元测试将碰撞阈值设置为10秒，并观察那些指示碰撞的事件。
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 10-17: Unit testing for brake events*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-17：刹车事件的单元测试*'
- en: Here, you initialize the local variable `brake_commands_published` to zero ➊.
    This will keep track of the number of times that the `publish` callback is invoked.
    You pass this local variable by reference into the lambda used to construct your
    `auto_brake` ➋. Notice that you increment `brake_commands_published` ➌. Because
    the lambda captures by reference, you can inspect the value of `brake_commands_published`
    later in the unit test. Next, you set `set_collision_threshold` to 10 ➍. You update
    the car’s speed to 100 meters per second ➎, and then you detect a car 100 meters
    away traveling at 0 meters per second (it is stopped) ➏. The `AutoBrake` class
    should determine that a collision will occur in 1 second. This should trigger
    a callback, which will increment `brake_commands_published`. The assertion ➐ ensures
    that the callback happens exactly once.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将本地变量`brake_commands_published`初始化为零➊。这个变量用于追踪`publish`回调被调用的次数。你将这个本地变量通过引用传递给用于构造`auto_brake`的lambda表达式➋。注意，你会递增`brake_commands_published`➌。由于lambda是通过引用捕获的，因此你可以在单元测试中稍后检查`brake_commands_published`的值。接下来，你将`set_collision_threshold`设置为10
    ➍。你将汽车的速度更新为每秒100米➎，然后你检测到一辆距离100米的车，速度为0米每秒（它已经停止）➏。`AutoBrake`类应该能判断出1秒后会发生碰撞。这应该会触发一个回调，进而递增`brake_commands_published`。断言
    ➐ 确保回调仅发生一次。
- en: 'After adding to `main`, compile and run to yield a new red test:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在将代码添加到`main`之后，编译并运行，结果是一个新的红色测试：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You can implement the code to make this test pass. [Listing 10-18](ch10.xhtml#ch10ex18)
    provides all the code needed to issue brake commands.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以实现代码来使得这个测试通过。[清单 10-18](ch10.xhtml#ch10ex18)提供了发布刹车命令所需的所有代码。
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 10-18: Code implementing the braking functionality*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-18：实现刹车功能的代码*'
- en: First, you calculate the relative velocity ➊. Next, you use this value to compute
    the time to collision ➋. If this value is positive ➌ and less than or equal to
    the collision threshold ➍, you publish a `BrakeCommand` ➎.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你计算相对速度➊。接下来，使用这个值来计算碰撞时间➋。如果这个值为正➌且小于或等于碰撞阈值➍，你就发布一个`BrakeCommand`➎。
- en: 'Recompiling and running the unit-test suite yields success:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 重新编译并运行单元测试套件后，测试通过了：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Finally, you need to check that the `AutoBrake` will not invoke `publish` with
    a `BrakeCommand` if a collision will occur later than `collision_threshold_s`.
    You can repurpose the `alert_when_imminent` unit test, as in [Listing 10-19](ch10.xhtml#ch10ex19).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要检查`AutoBrake`是否不会在碰撞发生时间晚于`collision_threshold_s`时调用`publish`发布`BrakeCommand`。你可以重新利用`alert_when_imminent`单元测试，如[清单
    10-19](ch10.xhtml#ch10ex19)中所示。
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 10-19: Testing that the car doesn’t issue a `BrakeCommand` if a collision
    isn’t anticipated within the collision threshold*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-19：测试如果碰撞不在碰撞阈值内，汽车不会发出`BrakeCommand`*'
- en: This changes the setup. Your car’s threshold is set to 2 seconds with a speed
    of 100 meters per second. A car is detected 1,000 meters away traveling 50 meters
    per second. The `AutoBrake` class should forecast a collision in 20 seconds, which
    is more than the 2-second threshold. You also change the assertion ➊.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这改变了设置。你的汽车阈值设置为2秒，速度为每秒100米。汽车在1000米外被检测到，速度为每秒50米。`AutoBrake`类应预测20秒内发生碰撞，这超过了2秒的阈值。你还更改了断言➊。
- en: 'After adding this test to `main` and running the unit-test suite, you have
    the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在将此测试添加到`main`并运行单元测试套件后，你得到了以下结果：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: For this test case, you already have all the code needed for this test to pass
    ➊. Not having a failing test at the outset bends the red, green, refactor mantra,
    but that’s okay. This test case is closely related to `alert_when_imminent`. The
    point of TDD is not dogmatic adherence to strict rules. TDD is a set of reasonably
    loose guidelines that helps you write better software.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个测试用例，你已经拥有了通过此测试所需的所有代码➊。测试一开始没有失败的测试，违背了红、绿、重构的经典法则，但这没关系。这个测试用例与`alert_when_imminent`紧密相关。TDD的重点不是盲目遵循严格的规则。TDD是一组合理宽松的指南，帮助你编写更好的软件。
- en: '***Adding a Service-Bus Interface***'
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***添加一个服务总线接口***'
- en: 'The `AutoBrake` class has a few dependencies: `CarDetected, SpeedUpdated`,
    and a generic dependency on some `publish` object callable with a single `BrakeCommand`
    parameter. The `CarDetected` and `SpeedUpdated` classes are plain-old-data types
    that are easy to use directly in your unit tests. The `publish` object is a little
    more complicated to initialize, but thanks to lambdas, it’s really not bad.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`AutoBrake`类有一些依赖：`CarDetected`、`SpeedUpdated`和一个通用的依赖于可以调用的`publish`对象，它接受一个`BrakeCommand`参数。`CarDetected`和`SpeedUpdated`类是简单的数据类型，直接在单元测试中使用很方便。`publish`对象的初始化稍微复杂一些，但得益于lambda表达式，这并不难。'
- en: Suppose you want to refactor the service bus. You want to accept a `std::function`
    to subscribe to each service, as in the new `IServiceBus` interface in [Listing
    10-20](ch10.xhtml#ch10ex20).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想重构服务总线。你希望接受一个`std::function`来订阅每个服务，如[清单 10-20](ch10.xhtml#ch10ex20)中的新`IServiceBus`接口所示。
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 10-20: The `IServiceBus` interface*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-20：`IServiceBus`接口*'
- en: Because `IServiceBus` is an interface, you don’t need to know the implementation
    details. It’s a nice solution because it allows you to do your own wiring into
    the service bus. But there’s a problem. How do you test `AutoBrake` in isolation?
    If you try to use the production bus, you’re firmly in integration-test territory,
    and you want easy-to-configure, isolated unit tests.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`IServiceBus`是一个接口，你无需了解其实现细节。这是一个很好的解决方案，因为它允许你自己将服务总线接入。但是有一个问题。如何在隔离环境中测试`AutoBrake`？如果你尝试使用生产总线，你就进入了集成测试领域，而你希望的是易于配置的、独立的单元测试。
- en: '**Mocking Dependencies**'
  id: totrans-165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**模拟依赖**'
- en: 'Fortunately, you don’t depend on the implementation: you depend on the interface.
    You can create a mock class that implements the `IServiceBus` interface and use
    this within `AutoBrake`. A mock is a special implementation that you generate
    for the express purpose of testing a class that depends on the mock.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你并不依赖于实现：你依赖于接口。你可以创建一个实现了`IServiceBus`接口的模拟类，并在`AutoBrake`中使用它。模拟是你专门为测试依赖于模拟的类而生成的特殊实现。
- en: 'Now when you exercise `AutoBrake` in your unit tests, `AutoBrake` interacts
    with the mock rather than the production service bus. Because you have complete
    control over the mock’s implementation and the mock is a unit-test-specific class,
    you have major flexibility in how you can test classes that depend on the interface:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你在单元测试中使用`AutoBrake`时，`AutoBrake`与模拟对象交互，而不是生产服务总线。因为你完全控制模拟的实现，而且模拟是专为单元测试设计的类，你可以在测试依赖于接口的类时拥有极大的灵活性：
- en: You can capture arbitrarily detailed information about how the mock gets called.
    This can include information about the parameters and the number of times the
    mock was called, for example.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以捕捉关于模拟被调用的详细信息。这可以包括参数信息和模拟被调用的次数等。
- en: You can perform arbitrary computation in the mock.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在模拟中执行任意计算。
- en: In other words, you have complete control over the inputs and the outputs of
    the dependency of `AutoBrake`. How does `AutoBrake` handle the case where the
    service bus throws an out-of-memory exception inside of a `publish` invocation?
    You can unit test that. How many times did `AutoBrake` register a callback for
    `SpeedUpdates`? Again, you can unit test that.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，您完全控制着`AutoBrake`的依赖项的输入和输出。当服务总线在`publish`调用中抛出内存溢出异常时，`AutoBrake`如何处理？您可以对这一点进行单元测试。`AutoBrake`注册了多少次`SpeedUpdates`的回调？同样，您可以对这一点进行单元测试。
- en: '[Listing 10-21](ch10.xhtml#ch10ex21) presents a simple mock class you can use
    for your unit tests.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-21](ch10.xhtml#ch10ex21)展示了一个简单的模拟类，您可以在单元测试中使用它。'
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 10-21: A definition of `MockServiceBus`*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-21：`MockServiceBus`的定义*'
- en: The `publish` method records the number of times a `BrakeCommand` is published
    ➊ and the `last_command` that was published ➋. Each time `AutoBrake` publishes
    a command to the service bus, you’ll see updates to the members of `MockServiceBus`.
    You’ll see in a moment that this allows for some very powerful assertions about
    how `AutoBrake` behaved during a test. You save the callback functions used to
    subscribe to the service bus ➌➍. This allows you to simulate events by manually
    invoking these callbacks on the mock object.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`publish`方法记录每次发布`BrakeCommand`的次数 ➊ 和发布的`last_command` ➋。每次`AutoBrake`向服务总线发布命令时，您会看到`MockServiceBus`的成员发生更新。您很快就会发现，这允许您对`AutoBrake`在测试中的行为进行非常强大的断言。您保存了用于订阅服务总线的回调函数
    ➌➍。这使您能够通过手动调用这些回调函数来模拟事件。'
- en: Now, you can turn your attention to refactoring `AutoBrake`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以将注意力集中到重构`AutoBrake`上。
- en: '**Refactoring AutoBrake**'
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**重构 AutoBrake**'
- en: '[Listing 10-22](ch10.xhtml#ch10ex22) updates `AutoBrake` with the minimum changes
    necessary to get the unit-test binary compiling again (but not necessarily passing!).'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-22](ch10.xhtml#ch10ex22)用最小的更改更新了`AutoBrake`，以使单元测试二进制文件重新编译（但不一定通过！）。'
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 10-22: A refactored `AutoBrake` skeleton taking an `IServiceBus` reference*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-22：重构后的`AutoBrake`骨架，接受`IServiceBus`引用*'
- en: Notice that all the `observe` functions have been removed. Additionally, `AutoBrake`
    is no longer a template ➊. Rather, it accepts an `IServiceBus` reference in its
    constructor ➋.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有的`observe`函数都已被移除。此外，`AutoBrake`不再是一个模板 ➊。相反，它在构造函数中接受一个`IServiceBus`引用
    ➋。
- en: You’ll also need to update your unit tests to get the test suite compiling again.
    One TDD-inspired approach is to comment out all the tests that are not compiling
    and update `AutoBrake` so all the failing unit tests pass. Then, one by one, uncomment
    each unit test. You reimplement each unit test using the new `IServiceBus` mock,
    then update `AutoBrake` so the tests pass.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要更新您的单元测试，以使测试套件重新编译。一个受TDD启发的方法是将所有无法编译的测试注释掉，并更新`AutoBrake`，直到所有失败的单元测试通过。然后，逐个取消注释每个单元测试。使用新的`IServiceBus`模拟重新实现每个单元测试，然后更新`AutoBrake`，使测试通过。
- en: Let’s give it a try.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试吧。
- en: '**Refactoring the Unit Tests**'
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**重构单元测试**'
- en: 'Because you’ve changed the way to construct an `AutoBrake` object, you’ll need
    to reimplement every test. The first three are easy: [Listing 10-23](ch10.xhtml#ch10ex23)
    just plops the mock into the `AutoBrake` constructor.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您已更改构造`AutoBrake`对象的方式，您需要重新实现每个测试。前三个很简单：[清单 10-23](ch10.xhtml#ch10ex23)只需将模拟对象传入`AutoBrake`构造函数中。
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 10-23: Reimplemented unit-test functions using the `MockServiceBus`*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-23：使用`MockServiceBus`重新实现的单元测试函数*'
- en: 'Because these three tests deal with functionality not related to the service
    bus, it’s unsurprising that you didn’t need to make any major changes to `AutoBrake`.
    All you need to do is create a `MockServiceBus` ➊ and pass it into the `AutoBrake`
    constructor ➋. Running the unit-test suite, you have the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这三个测试处理的功能与服务总线无关，您不需要对`AutoBrake`进行任何重大更改也不足为奇。您需要做的就是创建一个`MockServiceBus`
    ➊ 并将其传递到`AutoBrake`的构造函数中 ➋。运行单元测试套件后，您将看到以下内容：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Next, look at the `speed_is_saved` test. The `AutoBrake` class no longer exposes
    an `observe` function, but because you’ve saved the `SpeedUpdateCallback` on the
    mock service bus, you can invoke the callback directly. If `AutoBrake` subscribed
    properly, this callback will update the car’s speed, and you’ll see the effects
    when you call the `get_speed_mps` method. [Listing 10-24](ch10.xhtml#ch10ex24)
    contains the refactor.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，查看`speed_is_saved`测试。`AutoBrake`类不再暴露`observe`函数，但由于你在模拟的服务总线上保存了`SpeedUpdateCallback`，你可以直接调用回调函数。如果`AutoBrake`正确订阅了，该回调将更新汽车的速度，并且你将在调用`get_speed_mps`方法时看到效果。[列表
    10-24](ch10.xhtml#ch10ex24)包含了重构内容。
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 10-24: Reimplemented `speed_is_saved` unit-test function using the
    `MockServiceBus`*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-24：使用`MockServiceBus`重新实现`speed_is_saved`单元测试函数*'
- en: 'The test didn’t change too much from the previous implementation. You invoke
    the `speed_update_callback function` stored on the mock bus ➊. You make sure that
    the `AutoBrake` object updated the car’s speed correctly ➋. Compiling and running
    the resulting unit-test suite results in the following output:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试与之前的实现差异不大。你调用了存储在模拟总线上的`speed_update_callback`函数 ➊。你确保`AutoBrake`对象正确更新了汽车的速度
    ➋。编译并运行该单元测试套件后，得到如下输出：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Recall that the `bad function call` message comes from the `std::bad_func``tion_call`
    exception. This is expected: you still need to subscribe from `AutoBrake`, so
    `std::function` throws an exception when you invoke it.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`bad function call`消息来自于`std::bad_func``tion_call`异常。这是预期中的情况：你仍然需要从`AutoBrake`进行订阅，因此当你调用它时，`std::function`会抛出异常。
- en: Consider the approach in [Listing 10-25](ch10.xhtml#ch10ex25).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑[列表 10-25](ch10.xhtml#ch10ex25)中的方法。
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 10-25: Subscribing the `AutoBrake` to speed updates from the `IServiceBus`*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-25：将`AutoBrake`订阅到来自`IServiceBus`的速度更新*'
- en: 'Thanks to `std::function`, you can pass your callback into the subscribe method
    of `bus` as a lambda that captures `speed_mps`. (Notice that you don’t need to
    save a copy of `bus`.) Recompiling and running the unit-test suite yields the
    following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了`std::function`，你可以将回调作为lambda传递给`bus`的订阅方法，该lambda捕获了`speed_mps`。 (注意，你不需要保存`bus`的副本。)
    重新编译并运行单元测试套件后，得到如下输出：
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Next, you have the first of the alert-related unit tests, `no_alert_when_not_imminent`.
    [Listing 10-26](ch10.xhtml#ch10ex26) highlights one way to update this test with
    the new architecture.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将执行第一个与警报相关的单元测试`no_alert_when_not_imminent`。[列表 10-26](ch10.xhtml#ch10ex26)展示了如何根据新架构更新这个测试。
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 10-26: Updating the `no_alert_when_not_imminent` test with the `IServiceBus`*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-26：使用`IServiceBus`更新`no_alert_when_not_imminent`测试*'
- en: As in the `speed_is_saved` test, you invoke the callbacks on the `bus` mock
    to simulate events on the service bus ➊➋. Recompiling and running the unit-test
    suite results in an expected failure.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在`speed_is_saved`测试中，你通过在`bus`模拟对象上调用回调来模拟服务总线上的事件 ➊➋。重新编译并运行单元测试套件时，结果会出现预期的失败。
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You need to subscribe with `CarDetectedCallback`. You can add this into the
    `AutoBus` constructor, as demonstrated in [Listing 10-27](ch10.xhtml#ch10ex27).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要使用`CarDetectedCallback`进行订阅。你可以将其添加到`AutoBus`构造函数中，正如[列表 10-27](ch10.xhtml#ch10ex27)中展示的那样。
- en: '[PRE40]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*Listing 10-27: An updated `AutoBrake` constructor that wires itself into the
    service bus*'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-27：一个更新后的`AutoBrake`构造函数，将其接入服务总线*'
- en: 'All you’ve done is port over the original `observe` method corresponding to
    `CarDetected` events. The lambda captures `this` ➊ and `bus` ➋ by reference in
    the callback. Capturing `this` allows you to compute collision times, whereas
    capturing `bus` allows you to publish a `BrakeCommand` ➌ if the conditions are
    satisfied. Now the unit-test binary outputs the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你所做的只是移植了原来的`observe`方法，用于处理`CarDetected`事件。lambda表达式通过引用捕获了`this` ➊和`bus` ➋。捕获`this`使你能够计算碰撞时间，而捕获`bus`则可以在条件满足时发布`BrakeCommand`
    ➌。现在，单元测试的二进制文件输出如下内容：
- en: '[PRE41]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Finally, turn on the last test, `alert_when_imminent`, as displayed in [Listing
    10-28](ch10.xhtml#ch10ex28).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，开启最后一个测试项`alert_when_imminent`，如[列表 10-28](ch10.xhtml#ch10ex28)所示。
- en: '[PRE42]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '*Listing 10-28: Refactoring the `alert_when_imminent` unit test*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-28：重构`alert_when_imminent`单元测试*'
- en: In `MockServiceBus`, you actually saved the last `BrakeCommand` published to
    the bus into a member. In the test, you can use this member to verify that the
    time to collision was computed correctly. If a car is going 100 meters per second,
    it will take 1 second to hit a stationary car parked 100 meters away. You check
    that the `BrakeCommand` has the correct time to collision recorded by referring
    to the `time_to_collision_s` field on our mock `bus` ➊.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MockServiceBus`中，您实际上将最后发布到总线的`BrakeCommand`保存为一个成员变量。在测试中，您可以使用这个成员变量来验证碰撞时间是否计算正确。如果一辆车以100米每秒的速度行驶，它将在1秒钟内撞上停在100米外的静止汽车。您可以通过引用我们模拟的`bus`
    ➊上的`time_to_collision_s`字段，检查`BrakeCommand`是否记录了正确的碰撞时间。
- en: 'Recompiling and rerunning, you finally have the test suite fully green again:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 重新编译并重新运行，您终于将测试套件恢复到全绿状态：
- en: '[PRE43]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Refactoring is now complete.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 重构现已完成。
- en: '**Reevaluating the Unit-Testing Solution**'
  id: totrans-217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**重新评估单元测试解决方案**'
- en: Looking back at the unit-testing solution, you can identify several components
    that have nothing to do with `AutoBrake`. These are general purpose unit-testing
    components that you could reuse in future unit tests. Recall the two helper functions
    created in [Listing 10-29](ch10.xhtml#ch10ex29).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾单元测试解决方案，您可以识别出几个与`AutoBrake`无关的组件。这些是通用的单元测试组件，您可以在未来的单元测试中重复使用。回想一下在[清单10-29](ch10.xhtml#ch10ex29)中创建的两个辅助函数。
- en: '[PRE44]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '*Listing 10-29: An austere unit-testing framework*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单10-29：一个简洁的单元测试框架*'
- en: 'These two functions reflect two fundamental aspects of unit testing: making
    assertions and running tests. Rolling your own simple `assert_that` function and
    `run_test` harness works, but this approach doesn’t scale very well. You can do
    a lot better by leaning on a unit-testing framework.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数反映了单元测试的两个基本方面：进行断言和运行测试。自己编写简单的`assert_that`函数和`run_test`框架是可行的，但这种方法扩展性不强。通过依赖单元测试框架，您可以做得更好。
- en: '**Unit-Testing and Mocking Frameworks**'
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**单元测试与模拟框架**'
- en: '*Unit-testing frameworks* provide commonly used functions and the scaffolding
    you need to tie your tests together into a user-friendly program. These frameworks
    provide a wealth of functionality that helps you create concise, expressive tests.
    This section offers a tour of several popular unit-testing and mocking frameworks.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*单元测试框架*提供了常用的功能和您需要的架构，以便将您的测试组织成一个用户友好的程序。这些框架提供了大量功能，帮助您创建简洁、富有表现力的测试。本节将介绍几种流行的单元测试和模拟框架。'
- en: '***The Catch Unit-Testing Framework***'
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Catch单元测试框架***'
- en: One of the most straightforward unit-testing frameworks, Catch by Phil Nash,
    is available at [https://github.com/catchorg/Catch2/](https://github.com/catchorg/Catch2/).
    Because it's a header-only library, you can set up Catch by downloading the single-header
    version and including it in each translation unit that contains unit-testing code.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 由Phil Nash开发的最直观的单元测试框架Catch可以在[https://github.com/catchorg/Catch2/](https://github.com/catchorg/Catch2/)找到。因为它是一个仅包含头文件的库，您只需下载单头版本并在每个包含单元测试代码的翻译单元中包含它即可设置Catch。
- en: '**NOTE**'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*At press time, Catch’s latest version is 2.9.1.*'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*在写作时，Catch的最新版本是2.9.1。*'
- en: '**Defining an Entry Point**'
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**定义入口点**'
- en: 'Tell Catch to provide your test binary’s entry point with `#define CATCH_CONFIG_MAIN`.
    Together, the Catch unit-test suite starts as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉Catch通过`#define CATCH_CONFIG_MAIN`提供您的测试二进制文件的入口点。Catch单元测试套件的启动过程如下：
- en: '[PRE45]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: That’s it. Within the `catch.hpp` header, it looks for the `CATCH_CONFIG_MAIN`
    preprocessor definition. When present, Catch will add in a `main` function so
    you don’t have to. It will automatically grab all the unit tests you’ve defined
    and wrap them with a nice harness.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。在`catch.hpp`头文件中，它会查找`CATCH_CONFIG_MAIN`预处理器定义。存在时，Catch会自动添加一个`main`函数，您无需手动编写。它会自动获取您定义的所有单元测试，并将其包裹在一个漂亮的测试框架中。
- en: '**Defining Test Cases**'
  id: totrans-232
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**定义测试用例**'
- en: Earlier, in “Unit Tests” on [page 282](ch10.xhtml#page_282), you defined a separate
    function for each unit test. Then you would pass a pointer to this function as
    the first parameter to `run_test`. You passed the name of the test as the second
    parameter, which is a bit redundant because you’ve already provided a descriptive
    name for the function pointed to by the first argument. Finally, you had to implement
    your own `assert` function. Catch handles all of this ceremony implicitly. For
    each unit test, you use the `TEST_CASE` macro, and Catch handles all the integration
    for you.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在“单元测试”一节中，你在 [第 282 页](ch10.xhtml#page_282) 定义了每个单元测试的单独函数。然后你会将该函数的指针作为第一个参数传递给
    `run_test`。你将测试的名称作为第二个参数传递，这有点冗余，因为你已经为第一个参数所指向的函数提供了描述性的名称。最后，你还需要实现自己的 `assert`
    函数。Catch 会隐式处理所有这些步骤。对于每个单元测试，你使用 `TEST_CASE` 宏，而 Catch 会为你处理所有集成工作。
- en: '[Listing 10-30](ch10.xhtml#ch10ex30) illustrates how to build a trivial Catch
    unit test program.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-30](ch10.xhtml#ch10ex30) 演示了如何构建一个简单的 Catch 单元测试程序。'
- en: '[PRE46]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '*Listing 10-30: A simple Catch unit-test program*'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-30：一个简单的 Catch 单元测试程序*'
- en: The Catch entry point detects that you declared one test called `AutoBrake`
    ➊. It also provides a warning that you haven’t made any assertions ➋.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Catch 入口点检测到你声明了一个名为 `AutoBrake` 的测试 ➊。它还提供了一个警告，指出你没有进行任何断言 ➋。
- en: '**Making Assertions**'
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**进行断言**'
- en: 'Catch comes with a built-in assertion that features two distinct families of
    assertion macros: `REQUIRE` and `CHECK`. The difference between them is that `REQUIRE`
    will fail a test immediately, whereas `CHECK` will allow the test to run to completion
    (but still cause a failure). `CHECK` can be useful sometimes when groups of related
    assertions that fail lead the programmer down the right path of debugging problems.
    Also included are `REQUIRE_FALSE` and `CHECK_FALSE`, which check that the contained
    statement evaluates to false rather than true. In some situations, you might find
    this a more natural way to represent a requirement.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Catch 自带了一组内置的断言，它包含两类不同的断言宏：`REQUIRE` 和 `CHECK`。它们的区别在于，`REQUIRE` 会立即使测试失败，而
    `CHECK` 会允许测试继续运行（但仍会导致失败）。`CHECK` 在某些情况下非常有用，特别是当一组相关的断言失败时，它能引导程序员进行调试。此外，还有
    `REQUIRE_FALSE` 和 `CHECK_FALSE`，它们检查包含的语句是否评估为假，而不是为真。在某些情况下，这可能是表达要求的更自然方式。
- en: 'All you need to do is wrap a Boolean expression with the `REQUIRE` macro. If
    the expression evaluates to false, the assertion fails. You provide an *assertion
    expression* that evaluates to true if the assertion passes and false if it fails:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要用 `REQUIRE` 宏包装一个布尔表达式。如果表达式评估为假，断言失败。你提供一个 *断言表达式*，如果断言通过则为真，若失败则为假：
- en: '[PRE47]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Let’s look at how to combine `REQUIRE` with a `TEST_CASE` to build a unit test.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何将 `REQUIRE` 与 `TEST_CASE` 结合起来构建单元测试。
- en: '**NOTE**'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Because it’s by far the most common Catch assertion, we’ll use `REQUIRE` here.
    Refer to the Catch documentation for more information.*'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*因为这是 Catch 中最常用的断言，所以我们在这里使用 `REQUIRE`。有关更多信息，请参考 Catch 文档。*'
- en: '**Refactoring the initial_speed_is_zero Test to Catch**'
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**将 initial_speed_is_zero 测试重构为 Catch**'
- en: '[Listing 10-31](ch10.xhtml#ch10ex31) shows the `initial_speed_is_zero` test
    refactored to use Catch.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-31](ch10.xhtml#ch10ex31) 显示了重构为使用 Catch 的 `initial_speed_is_zero` 测试。'
- en: '[PRE48]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '*Listing 10-31: An `initial_speed_is_zero` unit test refactored to use Catch*'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-31：将 `initial_speed_is_zero` 单元测试重构为使用 Catch*'
- en: You use the `TEST_CASE` macro to define a new unit test ➊. The test is described
    by its sole parameter ➋. Inside the body of the `TEST_CASE` macro, you proceed
    with the unit test. You also see the `REQUIRE` macro in action ➌. To see how Catch
    handles failed tests, comment out the `speed_mps` member initializer to cause
    a failing test and observe the program’s output, as shown in [Listing 10-32](ch10.xhtml#ch10ex32).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用 `TEST_CASE` 宏定义一个新的单元测试 ➊。该测试由它的唯一参数 ➋ 描述。在 `TEST_CASE` 宏的主体内，你继续进行单元测试。你还会看到
    `REQUIRE` 宏的应用 ➌。要查看 Catch 如何处理失败的测试，注释掉 `speed_mps` 成员初始化器以导致测试失败，并观察程序的输出，如
    [清单 10-32](ch10.xhtml#ch10ex32) 所示。
- en: '[PRE49]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '*Listing 10-32: Intentionally commenting out the `speed_mps` member initializer
    to cause test failures (using Catch)*'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-32：故意注释掉 `speed_mps` 成员初始化器以导致测试失败（使用 Catch）*'
- en: The appropriate member initializer ➊ is commented out, resulting in a test failure.
    Rerunning the Catch test suite in [Listing 10-31](ch10.xhtml#ch10ex31) yields
    the output in [Listing 10-33](ch10.xhtml#ch10ex33).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 适当的成员初始化器 ➊ 被注释掉，导致测试失败。在 [清单 10-31](ch10.xhtml#ch10ex31) 中重新运行 Catch 测试套件，输出结果如
    [清单 10-33](ch10.xhtml#ch10ex33) 所示。
- en: '[PRE50]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '*Listing 10-33: The output from running the test suite after implementing Listing
    10-31*'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 10-33：在实现示例 10-31 后运行测试套件的输出*'
- en: This is vastly superior output to what you had produced in the home-grown unit-test
    suite. Catch tells you the exact line where the unit test failed ➊ and then prints
    this line for you ➋. Next, it expands this line into the actual values encountered
    at runtime. You can see that the grotesque (uninitialized) value returned by `get_speed_mps()`
    is clearly not `0` ➌. Compare this output to the output of the home-grown unit
    test; I think you’ll agree that there’s immediate value to using Catch.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这是远远优于你在自定义单元测试框架中生成的输出。Catch 会告诉你单元测试失败的确切行号➊，并为你打印出这一行➋。接着，它会展开这行并显示在运行时遇到的实际值。你可以看到`get_speed_mps()`返回的怪异（未初始化的）值显然不是`0`
    ➌。将这个输出与自定义单元测试的输出进行比较，我相信你会同意使用 Catch 立刻能带来价值。
- en: '**Assertions and Exceptions**'
  id: totrans-256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**断言和异常**'
- en: 'Catch also provides a special assertion called `REQUIRE_THROWS`. This macro
    requires that the contained expression throw an exception. To achieve similar
    functionality in the home-grown unit-test framework, consider this multiline monstrosity:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Catch 还提供了一种特殊的断言，叫做`REQUIRE_THROWS`。这个宏要求包含的表达式必须抛出异常。为了在自定义单元测试框架中实现类似的功能，可以参考这个多行的庞然大物：
- en: '[PRE51]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Other exception-aware macros are available as well. You can require that some
    expression evaluation not throw an exception using the `REQUIRE_NOTHROW` and `CHECK_NOTHROW`
    macros. You can also be specific about the type of the exception you expect to
    be thrown by using the `REQUIRE_THROWS_AS` and `CHECK_THROWS_AS` macros. These
    expect a second parameter describing the expected type. Their usages are similar
    to `REQUIRE`; you simply provide some expression that must throw an exception
    for the assertion to pass:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他感知异常的宏。你可以使用`REQUIRE_NOTHROW`和`CHECK_NOTHROW`宏要求某个表达式的求值不能抛出异常。你还可以通过使用`REQUIRE_THROWS_AS`和`CHECK_THROWS_AS`宏来指定你期望抛出的异常类型。这些宏期望第二个参数描述预期的类型。它们的使用方式类似于`REQUIRE`；你只需提供一个必须抛出异常的表达式，才能使断言通过：
- en: '[PRE52]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If the expression-to-evaluate doesn’t throw an exception, the assertion fails.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表达式没有抛出异常，断言将失败。
- en: '**Floating-Point Assertions**'
  id: totrans-262
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**浮点数断言**'
- en: The `AutoBrake` class involves floating-point arithmetic, and we’ve been glossing
    over a potentially very serious problem with the assertions. Because floating-point
    numbers entail rounding errors, it’s not a good idea to check for equality using
    `operator==`. The more robust approach is to test whether the difference between
    floating-point numbers is arbitrarily small. With Catch, you can handle these
    situations effortlessly using the `Approx` class, as shown in [Listing 10-34](ch10.xhtml#ch10ex34).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`AutoBrake` 类涉及浮点数运算，我们一直在忽略可能非常严重的断言问题。因为浮点数会产生舍入误差，使用`operator==`进行相等性检查并不是一个好主意。更稳健的方法是测试浮点数之间的差异是否足够小。在
    Catch 中，你可以轻松处理这些情况，使用`Approx`类，如[示例 10-34](ch10.xhtml#ch10ex34)所示。'
- en: '[PRE53]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '*Listing 10-34: A refactor of the “initializes sensitivity to five” test using
    the `Approx` class*'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 10-34：使用`Approx`类重构“将灵敏度初始化为五”的测试*'
- en: The `Approx` class helps Catch perform tolerant comparisons of floating-point
    values. It can exist on either side of a comparison expression. It has sensible
    defaults for how tolerant it is, but you have fine-grained control over the specifics
    (see the Catch documentation on `epsilon, margin`, and `scale`).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`Approx` 类帮助 Catch 执行浮点值的容差比较。它可以出现在比较表达式的任意一侧。它有合理的默认容差设置，但你可以精细控制具体的容差设置（请参见
    Catch 文档中的`epsilon, margin`和`scale`）。'
- en: '**Fail**'
  id: totrans-267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**失败**'
- en: 'You can cause a Catch test to fail using the `FAIL()` macro. This can sometimes
    be useful when combined with conditional statements, as in the following:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`FAIL()`宏使 Catch 测试失败。当与条件语句结合使用时，这有时会很有用，如下所示：
- en: '[PRE54]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Use a `REQUIRE` statement if a suitable one is available.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有合适的`REQUIRE`语句，请使用它。
- en: '**Test Cases and Sections**'
  id: totrans-271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**测试用例和测试部分**'
- en: 'Catch supports the idea of test cases and sections, which make common setup
    and teardown in your unit tests far easier. Notice that each of the tests has
    some repeated ceremony each time you construct an `AutoBrake`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Catch 支持测试用例和测试部分的概念，这使得在单元测试中进行常见的设置和拆卸变得更加容易。请注意，每个测试在构造`AutoBrake`时都有一些重复的准备工作：
- en: '[PRE55]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: There’s no need to repeat this code over and over again. Catch’s solution to
    this common setup is to use nested `SECTION` macros. You can nest `SECTION` macros
    within a `TEST_CASE` in the basic usage pattern, as demonstrated in [Listing 10-35](ch10.xhtml#ch10ex35).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 无需一遍又一遍地重复这些代码。Catch 对这个常见设置的解决方案是使用嵌套的 `SECTION` 宏。你可以在基本的使用模式中将 `SECTION`
    宏嵌套在 `TEST_CASE` 中，如 [清单 10-35](ch10.xhtml#ch10ex35) 中所示。
- en: '[PRE56]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '*Listing 10-35: An example Catch setup with nested macros*'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-35：一个包含嵌套宏的 Catch 设置示例*'
- en: You can perform all of the setup once at the beginning of a `TEST_CASE` ➊. When
    Catch sees `SECTION` macros nested within a `TEST_CASE`, it (conceptually) copies
    and pastes all the setup into each `SECTION` ➋➌. Each `SECTION` runs independently
    of the others, so generally any side effects on objects created in the `TEST_CASE`
    aren’t observed across `SECTION` macros. Further, you can embed a `SECTION` macro
    within another `SECTION` macro. This might be useful if you have a lot of setup
    code for a suite of closely related tests (although it may just make sense to
    split this suite into its own `TEST_CASE`).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`TEST_CASE` ➊的开始时一次性完成所有的设置。当 Catch 看到 `SECTION` 宏嵌套在一个 `TEST_CASE` 内时，它（从概念上讲）会将所有的设置复制并粘贴到每个
    `SECTION` 中 ➋➌。每个 `SECTION` 都独立运行，因此通常在 `TEST_CASE` 中创建的对象的副作用不会在 `SECTION` 宏之间互相影响。此外，你可以在另一个
    `SECTION` 宏中嵌套一个 `SECTION` 宏。如果你有大量的设置代码用于一组紧密相关的测试，这可能会很有用（尽管将该组测试拆分成单独的 `TEST_CASE`
    可能更为合理）。
- en: Let’s look at how this approach simplifies the `AutoBrake` unit-test suite.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这种方法是如何简化 `AutoBrake` 单元测试套件的。
- en: '**Refactoring the AutoBrake Unit Tests to Catch**'
  id: totrans-279
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**将 AutoBrake 单元测试重构为 Catch**'
- en: '[Listing 10-36](ch10.xhtml#ch10ex36) refactors all the unit tests into a Catch
    style.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-36](ch10.xhtml#ch10ex36) 将所有单元测试重构为 Catch 风格。'
- en: '[PRE57]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '*Listing 10-36: Using the Catch framework to implement the unit tests*'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-36：使用 Catch 框架实现单元测试*'
- en: 'Here, `TEST_CASE` is renamed to `AutoBrake` to reflect its more generic purpose
    ➊. Next, the body of the `TEST_CASE` begins with the common setup code that all
    the `AutoBrake` unit tests share ➋➌. Each of the unit tests has been converted
    into a `SECTION` macro ➍. You name each of the sections ➎ and then place the test-specific
    code within the `SECTION` body. Catch will do all the work of stitching together
    the setup code with each of the `SECTION` bodies. In other words, you get a fresh
    `AutoBrake` each time: the order of the `SECTIONS` doesn’t matter here, and they’re
    totally independent.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`TEST_CASE` 被重命名为 `AutoBrake`，以反映其更通用的用途 ➊。接下来，`TEST_CASE` 的主体开始于所有 `AutoBrake`
    单元测试共享的公共设置代码 ➋➌。每个单元测试都已转换为一个 `SECTION` 宏 ➍。你为每个部分命名 ➎，然后将特定于测试的代码放入 `SECTION`
    主体内。Catch 会将设置代码与每个 `SECTION` 主体拼接起来，完成所有的工作。换句话说，每次你都会得到一个新的 `AutoBrake`：`SECTIONS`
    的顺序在这里并不重要，它们是完全独立的。
- en: '***Google Test***'
  id: totrans-284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Google Test***'
- en: Google Test is another extremely popular unit-testing framework. Google Test
    follows the xUnit unit-testing framework tradition, so if you’re familiar with,
    for example, junit for Java or nunit for .NET, you’ll feel right at home using
    Google Test. One nice feature when you’re using Google Test is that the mocking
    framework Google Mocks was merged in some time ago.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Google Test 是另一个极为流行的单元测试框架。Google Test 遵循 xUnit 单元测试框架的传统，因此，如果你熟悉 Java 的 junit
    或 .NET 的 nunit，使用 Google Test 会非常得心应手。使用 Google Test 的一个好处是，Google Mocks（一个模拟框架）已与其合并。
- en: '**Configuring Google Test**'
  id: totrans-286
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**配置 Google Test**'
- en: Google Test takes some time to get up and running. Unlike Catch, Google Test
    is not a header-only library. You must download it from *[https://github.com/google/googletest/](https://github.com/google/googletest/)*,
    compile it into a set of libraries, and link those libraries into your test project
    as appropriate. If you use a popular desktop build system, such as GNU Make, Mac
    Xcode, or Visual Studio, some templates are available that you can use to start
    building the relevant libraries.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: Google Test 启动需要一些时间。与 Catch 不同，Google Test 不是一个仅包含头文件的库。你必须从 *[https://github.com/google/googletest/](https://github.com/google/googletest/)*
    下载它，将其编译成一组库，并根据需要将这些库链接到你的测试项目中。如果你使用流行的桌面构建系统，如 GNU Make、Mac Xcode 或 Visual
    Studio，提供了一些模板，可以用来启动相关库的构建。
- en: For more information about getting Google Test up and running, refer to the
    Primer available in the repository’s `docs` directory.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何启动和运行 Google Test，请参考仓库中`docs`目录下的 Primer 文档。
- en: '**NOTE**'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*At press time, Google Test’s latest version is 1.8.1\. See this book’s companion
    source, available at* [https://ccc.codes](https://ccc.codes), *for one method
    of integrating Google Test into a Cmake build*.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '*截至目前，Google Test的最新版本是1.8.1\. 有关将Google Test集成到Cmake构建中的一种方法，请参阅本书的配套源代码，链接在*
    [https://ccc.codes](https://ccc.codes)*，*中。*'
- en: Within your unit-test project, you must perform two operations to set up Google
    Test. First, you must ensure that the included directory of your Google Test installation
    is in the header search path of your unit-test project. This allows you to use
    `#include "gtest/gtest.h"` within your tests. Second, you must instruct your linker
    to include `gtest` and `gtest_main` static libraries from your Google Test installation.
    Make sure that you link in the correct architecture and configuration settings
    for your computer.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的单元测试项目中，必须执行两个操作来设置Google Test。首先，确保你的Google Test安装目录中的include文件夹在单元测试项目的头文件搜索路径中。这将使你能够在测试中使用`#include
    "gtest/gtest.h"`。其次，你需要指示链接器将`gtest`和`gtest_main`静态库从Google Test安装目录中包含进来。确保链接正确的架构和配置设置以匹配你的计算机。
- en: '**NOTE**'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*A common gotcha getting Google Test set up in Visual Studio is that the C/C++
    > Code Generation > Runtime Library option for Google Test must match your project’s
    option. By default, Google Test compiles the runtime statically (that is, with
    the /MT or MTd options). This choice is different from the default, which is to
    compile the runtime dynamically (for example, with the `/MD` or `/MDd` options
    in Visual Studio)*.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '*在Visual Studio中设置Google Test时，常见的一个问题是，Google Test的C/C++ > 代码生成 > 运行时库选项必须与你项目的选项匹配。默认情况下，Google
    Test将运行时静态编译（即使用/MT或MTd选项）。这个选择与默认的动态编译运行时不同（例如，Visual Studio中的/MD或/MDd选项）。*'
- en: '**Defining an Entry Point**'
  id: totrans-294
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**定义入口点**'
- en: Google Test will supply a `main()` function for you when you link `gtest_main`
    into your unit-test project. Think of this as Google Test’s analogy for Catch’s
    `#define CATCH_CONFIG_MAIN`; it will locate all the unit tests you’ve defined
    and roll them together into a nice test harness.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将`gtest_main`链接到单元测试项目中时，Google Test会为你提供一个`main()`函数。可以将其看作是Google Test对Catch中`#define
    CATCH_CONFIG_MAIN`的类比；它会找到你定义的所有单元测试，并将它们整合成一个良好的测试工具。
- en: '**Defining Test Cases**'
  id: totrans-296
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**定义测试用例**'
- en: To define test cases, all you need to do is provide unit tests using the `TEST`
    macro, which is quite similar to Catch’s `TEST_CASE`. [Listing 10-37](ch10.xhtml#ch10ex37)
    illustrates the basic setup of a Google Test unit test.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义测试用例，你只需使用`TEST`宏提供单元测试，这与Catch的`TEST_CASE`非常相似。[列表10-37](ch10.xhtml#ch10ex37)展示了一个Google
    Test单元测试的基本设置。
- en: '[PRE58]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '*Listing 10-37: An example Google Test unit test*'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表10-37：一个示例的Google Test单元测试*'
- en: 'First, you include the `gtest/gtest.h` header ➊. This pulls in all the definitions
    you need to define your unit tests. Each unit test starts with the `TEST` macro
    ➋. You define each unit test with two labels: a *test case name*, which is `AutoBrake`
    ➌ and a *test name*, which is `UnitTestName` ➍. These are roughly analogous to
    the `TEST_CASE` and `SECTION` names (respectively) in Catch. A test case contains
    one or many tests. Usually, you place tests together that share some a common
    theme. The framework will group the tests together, which can be useful for some
    of the more advanced uses. Different test cases can have tests with the same name.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，包含`gtest/gtest.h`头文件➊。这将引入你定义单元测试所需的所有定义。每个单元测试都以`TEST`宏开始➋。你用两个标签定义每个单元测试：一个*测试用例名称*，例如`AutoBrake`
    ➌，和一个*测试名称*，例如`UnitTestName` ➍。这些大致相当于Catch中的`TEST_CASE`和`SECTION`名称。一个测试用例包含一个或多个测试。通常，你将具有共同主题的测试放在一起。框架会将这些测试分组，这在一些更高级的用法中非常有用。不同的测试用例可以有相同名称的测试。
- en: You would put the code for your unit test within the braces ➎. When you run
    the resulting unit-test binary, you can see that Google Test provides an entry
    point for you ➏. Because you provided no assertions (or code that could throw
    an exception), your unit tests pass with flying colors ➐.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你将单元测试的代码放在大括号➎中。当你运行生成的单元测试二进制文件时，你会看到Google Test为你提供了一个入口点➏。由于你没有提供任何断言（或可能抛出异常的代码），所以你的单元测试顺利通过➐。
- en: '**Making Assertions**'
  id: totrans-302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**做出断言**'
- en: Assertions in Google Test are less magical than in Catch’s `REQUIRE`. Although
    they’re also macros, the Google Test assertions require a lot more work on the
    programmer’s part. Where `REQUIRE` will parse the Boolean expression and determine
    whether you’re testing for equality, a greater-than relationship, and so on, Google
    Test’s assertions don’t. You must pass in each component of the assertion separately.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: Google Test 的断言比 Catch 的 `REQUIRE` 少了一些魔法。虽然它们也是宏，但 Google Test 的断言需要程序员做更多的工作。在
    `REQUIRE` 中，它会解析布尔表达式并确定你是否在测试相等、大于关系等，而 Google Test 的断言不会。你必须分别传递断言的每个组成部分。
- en: There are many other options for formulating assertions in Google Test. [Table
    10-1](ch10.xhtml#ch10tab01) summarizes them.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: Google Test 提供了许多其他选择来编写断言。[表 10-1](ch10.xhtml#ch10tab01) 总结了它们。
- en: '**Table 10-1:** `Google Test Assertions`'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10-1：** `Google Test 断言`'
- en: '| **Assertion** | **Verifies that** |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| **断言** | **验证** |'
- en: '| `ASSERT_TRUE(`condition`)` | condition is true. |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| `ASSERT_TRUE(`condition`)` | condition 为真。 |'
- en: '| `ASSERT_FALSE(`condition`)` | condition is false. |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| `ASSERT_FALSE(`condition`)` | condition 为假。 |'
- en: '| `ASSERT_EQ(`val1, val2`)` | val1 == val2 is true. |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| `ASSERT_EQ(`val1, val2`)` | val1 == val2 为真。 |'
- en: '| `ASSERT_FLOAT_EQ(`val1`,` val2) | val1 `-` val2 is a rounding error (`float`).
    |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| `ASSERT_FLOAT_EQ(`val1`,` val2) | val1 `-` val2 是一个舍入误差（`float`）。 |'
- en: '| `ASSERT_DOUBLE_EQ(`val1`,` val2) | val1 `-` val2 is a rounding error (`double`).
    |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| `ASSERT_DOUBLE_EQ(`val1`,` val2) | val1 `-` val2 是一个舍入误差（`double`）。 |'
- en: '| `ASSERT_NE(`val1`,` val2) | val1 `!=` val2 is true. |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `ASSERT_NE(`val1`,` val2) | val1 `!=` val2 为真。 |'
- en: '| `ASSERT_LT(`val1`,` val2) | val1 `<` val2 is true. |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| `ASSERT_LT(`val1`,` val2) | val1 `<` val2 为真。 |'
- en: '| `ASSERT_LE(`val1`,` val2) | val1 `<=` val2 is true. |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| `ASSERT_LE(`val1`,` val2) | val1 `<=` val2 为真。 |'
- en: '| `ASSERT_GT(`val1`,` val2) | val1 `>` val2 is true. |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| `ASSERT_GT(`val1`,` val2) | val1 `>` val2 为真。 |'
- en: '| `ASSERT_GE(`val1`,` val2) | val1 `>=` val2 is true. |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| `ASSERT_GE(`val1`,` val2) | val1 `>=` val2 为真。 |'
- en: '| `ASSERT_STREQ(`str1`,` str2) | The two C-style strings `*str1*` and `*str2*`
    have the same content. |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| `ASSERT_STREQ(`str1`,` str2) | 两个 C 风格的字符串 `*str1*` 和 `*str2*` 内容相同。 |'
- en: '| `ASSERT_STRNE(`str1`,` str2) | The two C-style strings `*str1*` and `*str2*`
    have different content. |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| `ASSERT_STRNE(`str1`,` str2) | 两个 C 风格的字符串 `*str1*` 和 `*str2*` 内容不同。 |'
- en: '| `ASSERT_STRCASEEQ(`str1`,` str2) | The two C-style strings `*str1*` and `*str2*`
    have the same content, ignoring case. |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| `ASSERT_STRCASEEQ(`str1`,` str2) | 忽略大小写的情况下，两个 C 风格的字符串 `*str1*` 和 `*str2*`
    内容相同。 |'
- en: '| `ASSERT_STRCASENE(`str1`,` str2) | The two C-style strings `*str1*` and `*str2*`
    have different content, ignoring case. |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| `ASSERT_STRCASENE(`str1`,` str2) | 忽略大小写的情况下，两个 C 风格的字符串 `*str1*` 和 `*str2*`
    内容不同。 |'
- en: '| `ASSERT_THROW(`statement`,` ex_type) | The evaluating `*statement*` causes
    an exception of type `*ex_type*` to be thrown. |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| `ASSERT_THROW(`statement`,` ex_type) | 评估 `*statement*` 会导致抛出类型为 `*ex_type*`
    的异常。 |'
- en: '| `ASSERT_ANY_THROW(`statement) | The evaluating `*statement*` causes an exception
    of any type to be thrown. |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| `ASSERT_ANY_THROW(`statement) | 评估 `*statement*` 会导致抛出任何类型的异常。 |'
- en: '| `ASSERT_NO_THROW(`statement) | The evaluating `*statement*` causes no exception
    to be thrown. |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| `ASSERT_NO_THROW(`statement) | 评估 `*statement*` 不会抛出任何异常。 |'
- en: '| `ASSERT_HRESULT_SUCCEEDED(`statement) | The `HRESULT` returned by `*statement*`
    corresponds with a success (Win32 API only). |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| `ASSERT_HRESULT_SUCCEEDED(`statement) | `*statement*` 返回的 `HRESULT` 对应一个成功（仅限
    Win32 API）。 |'
- en: '| `ASSERT_HRESULT_FAILED(`statement) | The `HRESULT` returned by `*statement*`
    corresponds with a failure (Win32 API only). |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| `ASSERT_HRESULT_FAILED(`statement) | `*statement*` 返回的 `HRESULT` 对应一个失败（仅限
    Win32 API）。 |'
- en: Let’s combine a unit-test definition with an assertion to see Google Test in
    action.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们结合单元测试定义和断言来看看 Google Test 的实际应用。
- en: '**Refactoring the initial_car_speed_is_zero Test to Google Test**'
  id: totrans-327
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**将 initial_car_speed_is_zero 测试重构为 Google Test**'
- en: With the intentionally broken `AutoBrake` in [Listing 10-32](ch10.xhtml#ch10ex32),
    you can run the following unit test to see what the test harness’s failure messages
    look like. (Recall that you commented out the member initializer for `speed_mps`.)
    [Listing 10-38](ch10.xhtml#ch10ex38) uses `ASSERT_FLOAT_EQ` to assert that the
    car’s initial speed is zero.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 使用故意破坏的 `AutoBrake` 在 [清单 10-32](ch10.xhtml#ch10ex32) 中，你可以运行以下单元测试，看看测试框架的失败信息是什么样的。（回想一下，你注释掉了
    `speed_mps` 的成员初始化器。）[清单 10-38](ch10.xhtml#ch10ex38) 使用 `ASSERT_FLOAT_EQ` 来断言汽车的初始速度为零。
- en: '[PRE59]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '*Listing 10-38: Intentionally commenting out the `collision_threshold_s` member
    initializer to cause test failures (using Google Test)*'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-38：故意注释掉 `collision_threshold_s` 成员初始化器以导致测试失败（使用 Google Test）*'
- en: You declare a unit test ➊ with the test case name `AutoBrakeTest` ➋ and test
    name `InitialCarSpeedIsZero` ➌. Within the test, you set up the `auto_brake` and
    assert ➍ that the car’s initial speed is zero ➎. Notice that the constant value
    is the first parameter and the quantity you’re testing is the second parameter
    ➏.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 你声明一个单元测试 ➊，测试用例名称为 `AutoBrakeTest` ➋，测试名称为 `InitialCarSpeedIsZero` ➌。在测试中，你设置
    `auto_brake` 并断言 ➍ 车的初始速度为零 ➎。请注意，常量值是第一个参数，而你正在测试的数量是第二个参数 ➏。
- en: Like the Catch output in [Listing 10-33](ch10.xhtml#ch10ex33), the Google Test
    output in [Listing 10-38](ch10.xhtml#ch10ex38) is very clear. It tells you that
    a test failed, identifies the failed assertion, and gives a good indication of
    how you might fix the issue.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 就像[示例 10-33](ch10.xhtml#ch10ex33)中的 Catch 输出一样，[示例 10-38](ch10.xhtml#ch10ex38)中的
    Google Test 输出也非常清晰。它告诉你测试失败，指出失败的断言，并很好地提示你如何修复问题。
- en: '**Test Fixtures**'
  id: totrans-333
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**测试夹具**'
- en: Unlike Catch’s `TEST_CASE` and `SECTION` approach, Google Test’s approach is
    to formulate *test fixture classes* when a common setup is involved. These fixtures
    are classes that inherit from the `::testing::Test` class that the framework provides.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Catch 的 `TEST_CASE` 和 `SECTION` 方法不同，Google Test 的方法是在涉及共同设置时，制定 *测试夹具类*。这些夹具是继承自框架提供的
    `::testing::Test` 类的类。
- en: Any members you plan to use inside tests you should mark as `public` or `protected`.
    If you want some setup or teardown computation, you can put it inside the (default)
    constructor or destructor (respectively).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 你计划在测试中使用的任何成员应标记为 `public` 或 `protected`。如果你需要一些设置或拆卸计算，可以将其放入（默认的）构造函数或析构函数中（分别）。
- en: '**NOTE**'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You can also place such setup and teardown logic in overridden `SetUp()` and
    `TearDown()` functions, although it’s rare that you would need to. One case is
    if the teardown computation might throw an exception. Because you generally shouldn’t
    allow an uncaught exception to throw from a destructor, you would have to put
    such code in a `TearDown()` function. (Recall from “Throwing in Destructors” on
    [page 106](ch04.xhtml#page_106) that throwing an uncaught exception in a destructor
    when another exception is already in flight calls `std::terminate`.)*'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '*你也可以将这样的设置和拆卸逻辑放在重写的 `SetUp()` 和 `TearDown()` 函数中，尽管你通常不需要这样做。一个例外是如果拆卸计算可能抛出异常。因为你通常不应该允许未捕获的异常从析构函数中抛出，所以你必须将此类代码放在
    `TearDown()` 函数中。（回想一下在[第106页](ch04.xhtml#page_106)“析构函数中的抛出”中提到的，当另一个异常已经被抛出时，在析构函数中抛出未捕获的异常会调用
    `std::terminate`。）*'
- en: If a test fixture is like a Catch `TEST_CASE`, then `TEST_F` is like a Catch
    `SECTION`. Like `TEST, TEST_F` takes two parameters. The first *must* be the exact
    name of the test fixture class. The second is the name of the unit test. [Listing
    10-39](ch10.xhtml#ch10ex39) illustrates the basic usage of Google Test’s test
    fixtures.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试夹具类似于 Catch 的 `TEST_CASE`，那么 `TEST_F` 就像 Catch 的 `SECTION`。与 `TEST` 一样，`TEST_F`
    也接受两个参数。第一个 *必须* 是测试夹具类的准确名称。第二个是单元测试的名称。[示例 10-39](ch10.xhtml#ch10ex39) 说明了 Google
    Test 测试夹具的基本用法。
- en: '[PRE60]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '*Listing 10-39: The basic setup of Google Test’s test fixtures*'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 10-39：Google Test 测试夹具的基本设置*'
- en: You declare a class `MyTestFixture` ➊ that inherits from the `::testing::Test`
    class that Google Test provides ➋. You use the class’s name as the first parameter
    to the `TEST_F` macro ➌. The unit test then has access to any public or protected
    methods inside `MyTestFixture`, and you can use the constructor and destructor
    of `MyTestFixture` to perform any common test setup/teardown. The second argument
    is the name of the unit test ➍➎.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 你声明一个类 `MyTestFixture` ➊，它继承自 Google Test 提供的 `::testing::Test` 类 ➋。你使用该类的名称作为
    `TEST_F` 宏的第一个参数 ➌。然后，单元测试可以访问 `MyTestFixture` 中的任何公共或受保护方法，并且你可以使用 `MyTestFixture`
    的构造函数和析构函数来执行任何公共的测试设置/拆卸操作。第二个参数是单元测试的名称 ➍➎。
- en: Next, let’s look at how to use Google Test Fixtures to reimplement the `AutoBrake`
    unit tests.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何使用 Google Test 测试夹具重新实现 `AutoBrake` 单元测试。
- en: '**Refactoring AutoBrake Unit Tests with Google Test**'
  id: totrans-343
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用 Google Test 重构 AutoBrake 单元测试**'
- en: '[Listing 10-40](ch10.xhtml#ch10ex40) reimplements all the `AutoBrake` unit
    tests into Google Test’s test-fixture framework.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10-40](ch10.xhtml#ch10ex40) 将所有 `AutoBrake` 单元测试重新实现到 Google Test 的测试夹具框架中。'
- en: '[PRE61]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '*Listing 10-40: Using Google Test to implement the `AutoBrake` unit tests*'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 10-40：使用 Google Test 实现 `AutoBrake` 单元测试*'
- en: 'First, you implement the test fixture `AutoBrakeTest` ➊. This class encapsulates
    the common setup code across all the unit tests: to construct a `MockServiceBus`
    and use it to construct an `AutoBrake`. Each of the unit tests is represented
    by a `TEST_F` macro ➋. These macros take two parameters: the test fixture, such
    as `AutoBrakeTest` ➌, and the name of the test, such as `InitialCarSpeedIsZero`
    ➍. Within the body of the unit tests, you have the correct invocations for each
    of the assertions, such as `ASSERT_DOUBLE_EQ` ➎ and `ASSERT_ANY_THROW` ➏.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你实现测试夹具 `AutoBrakeTest` ➊。这个类封装了所有单元测试中的公共设置代码：构造一个 `MockServiceBus` 并用它构造一个
    `AutoBrake`。每个单元测试通过 `TEST_F` 宏来表示 ➋。这些宏需要两个参数：测试夹具，例如 `AutoBrakeTest` ➌，以及测试的名称，例如
    `InitialCarSpeedIsZero` ➍。在单元测试的主体中，你有每个断言的正确调用，例如 `ASSERT_DOUBLE_EQ` ➎ 和 `ASSERT_ANY_THROW`
    ➏。
- en: '**Comparing Google Test and Catch**'
  id: totrans-348
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**比较 Google Test 和 Catch**'
- en: 'As you’ve seen, several major differences exist between Google Test and Catch.
    The most striking initial impression should be your investment in installing Google
    Test and making it work correctly in your solution. Catch is on the opposite end
    of this spectrum: as a header-only library, it’s trivial to make it work in your
    project.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Google Test 和 Catch 之间存在几个主要的区别。最显著的初步印象应该是你在安装 Google Test 并使其在你的解决方案中正常工作时所投入的精力。Catch
    则处于这个范围的另一端：作为一个仅包含头文件的库，它在你的项目中工作几乎是微不足道的。
- en: Another major difference is the assertions. To a newcomer, `REQUIRE` is a lot
    simpler to use than the Google Test assertion style. To a seasoned user of another
    xUnit framework, Google Test might seem more natural. The failure messages are
    also a bit different. It’s really up to you to determine which of these styles
    is more sensible.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个主要的区别是断言。对于新手来说，`REQUIRE` 比 Google Test 的断言风格更简单易用。对于另一个 xUnit 框架的资深用户来说，Google
    Test 可能看起来更自然。失败的消息也有所不同。最终，这取决于你自己判断哪种风格更为合理。
- en: Finally, there’s performance. Theoretically, Google Test will compile more quickly
    than Catch because all of Catch must be compiled for each translation unit in
    your unit-test suite. This is the trade-off for header-only libraries; the setup
    investment you make when setting up Google Test pays you back later with faster
    compilation. This might or might not be perceptible depending on the size of your
    unit-test suite.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 最后是性能。从理论上讲，Google Test 的编译速度会比 Catch 快，因为每个单元测试单元中必须编译 Catch 的所有内容。这是仅包含头文件的库的权衡；你在设置
    Google Test 时所做的投入，最终会通过更快的编译速度得到回报。根据单元测试套件的大小，这一点可能会或不会显而易见。
- en: '***Boost Test***'
  id: totrans-352
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Boost Test***'
- en: Boost Test is a unit-testing framework that ships as part of the *Boost C++
    libraries* (or simply *Boost*). Boost is an excellent collection of open source
    C++ libraries. It has a history of incubating many ideas that are eventually incorporated
    into the C++ standard, although not all Boost libraries aim for eventual inclusion.
    You’ll see mention of a number of Boost libraries throughout the remainder of
    this book, and Boost Test is the first. For help installing boost into your environment,
    see Boost’s home page [https://www.boost.org](https://www.boost.org) or have a
    look at this book’s companion code.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: Boost Test 是一个单元测试框架，它作为 *Boost C++ 库*（简称 *Boost*）的一部分发布。Boost 是一个优秀的开源 C++
    库集合。它有着孵化许多最终被纳入 C++ 标准的想法的历史，尽管并非所有 Boost 库都旨在最终被纳入标准。你会在本书的其余部分看到提到许多 Boost
    库，Boost Test 是其中的第一个。有关如何将 Boost 安装到你的环境中的帮助，请参阅 Boost 的主页 [https://www.boost.org](https://www.boost.org)
    或查看本书的配套代码。
- en: '**NOTE**'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*At press time, the latest version of the Boost libraries is 1.70.0.*'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '*截至出版时，Boost 库的最新版本是 1.70.0。*'
- en: 'You can use Boost Test in three modes: as a header-only library (like Catch),
    as a static library (like Google Test), or as a shared library, which will link
    the Boost Test module at runtime. The dynamic library usage can save quite a bit
    of disk space in the event you have multiple unit-test binaries. Rather than baking
    the unit-test framework into each of the unit-test binaries, you can build a single
    shared library (like a *.so* or *.dll*) and load it at runtime.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过三种模式使用 Boost Test：作为仅包含头文件的库（像 Catch），作为静态库（像 Google Test），或者作为共享库，这将在运行时链接
    Boost Test 模块。动态库的使用可以在你有多个单元测试二进制文件时节省相当多的磁盘空间。你可以构建一个单一的共享库（如 *.so* 或 *.dll*），然后在运行时加载它，而不是将单元测试框架嵌入到每个单元测试二进制文件中。
- en: As you’ve discovered while exploring Catch and Google Test, trade-offs are involved
    with each of these approaches. A major advantage of Boost Test is that it allows
    you to choose the best mode as you see fit. It’s not terribly difficult to switch
    modes should a project evolve, so one possible approach is to begin using Boost
    Test as a header-only library and transition into another mode as requirements
    change.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在探索Catch和Google Test时所发现的，每种方法都有其权衡之处。Boost Test的一个主要优势是它允许你根据自己的需要选择最佳模式。如果项目发生变化，切换模式并不困难，因此一种可能的做法是首先将Boost
    Test用作仅包含头文件的库，并随着需求的变化转向其他模式。
- en: '**Setting Up Boost Test**'
  id: totrans-358
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**设置Boost Test**'
- en: 'To set up Boost Test in the header-only mode (what Boost documentation calls
    the “single-header variant”), you simply include the `<boost/test/included/unit_test.hpp>`
    header. For this header to compile, you need to define `BOOST_TEST_MODULE` with
    a user-defined name. For example:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 要在仅头文件模式下设置Boost Test（即Boost文档中所称的“单头文件变体”），你只需包含`<boost/test/included/unit_test.hpp>`头文件。为了让这个头文件能够编译，你需要定义一个用户自定义的`BOOST_TEST_MODULE`名称。例如：
- en: '[PRE62]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Unfortunately, you cannot take this approach if you have more than one translation
    unit. For such situations, Boost Test contains prebuilt static libraries that
    you can use. By linking these in, you avoid having to compile the same code for
    every translation unit. When taking this approach, you include the `boost/test/unit_test.hpp`
    header for each translation unit in the unit-test suite:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，如果你有多个翻译单元，就无法采用这种方法。对于这种情况，Boost Test包含了可以使用的预构建静态库。通过链接这些库，你避免了为每个翻译单元编译相同的代码。当采取这种方法时，你需要在单元测试套件的每个翻译单元中包含`boost/test/unit_test.hpp`头文件：
- en: '[PRE63]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In exactly *one* translation unit, you also include the `BOOST_TEST_MODULE`
    definition:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在**一个**翻译单元中，你还需要包含`BOOST_TEST_MODULE`定义：
- en: '[PRE64]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: You must also configure the linker to include the appropriate Boost Test static
    library that comes with the Boost Test installation. The compiler and architecture
    corresponding to the selected static library must match the rest of your unit-test
    project.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 你还必须配置链接器，以包含Boost Test安装中附带的适当Boost Test静态库。所选静态库对应的编译器和架构必须与单元测试项目的其余部分匹配。
- en: '**Setting Up Shared Library Mode**'
  id: totrans-366
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**设置共享库模式**'
- en: 'To set up Boost Test in shared library mode, you must add the following lines
    to each translation unit of the unit-test suite:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 要在共享库模式下设置Boost Test，你必须在每个单元测试套件的翻译单元中添加以下行：
- en: '[PRE65]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In exactly *one* translation unit, you must also define `BOOST_TEST_MODULE`:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在**一个**翻译单元中，你还必须定义`BOOST_TEST_MODULE`：
- en: '[PRE66]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: As with the static library usage, you must instruct the linker to include Boost
    Test. At runtime, the unit-test shared library must be available as well.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 与静态库的使用一样，你必须指示链接器包含Boost Test。在运行时，单元测试共享库也必须可用。
- en: '**Defining Test Cases**'
  id: totrans-372
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**定义测试用例**'
- en: You can define a unit test in Boost Test with the `BOOST_AUTO_TEST_CASE` macro,
    which takes a single parameter corresponding to the name of the test. [Listing
    10-41](ch10.xhtml#ch10ex41) shows the basic usage.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`BOOST_AUTO_TEST_CASE`宏在Boost Test中定义一个单元测试，该宏接受一个参数，表示测试的名称。[列表10-41](ch10.xhtml#ch10ex41)展示了基本用法。
- en: '[PRE67]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '*Listing 10-41: Using Google Test to implement the `AutoBrake` unit tests*'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表10-41：使用Google Test实现`AutoBrake`单元测试*'
- en: The test module’s name is `TestModuleName` ➊, which you define as the `BOOST_TEST_MODULE`.
    You include the `boost/test/unit_test.hpp` header ➋, which provides you with access
    to all the components you need from Boost Test. The `BOOST_AUTO_TEST_CASE` declaration
    ➌ denotes a unit test called `TestA` ➍. The body of the unit test goes between
    the braces ➎.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 测试模块的名称是`TestModuleName` ➊，你将其定义为`BOOST_TEST_MODULE`。你包含`boost/test/unit_test.hpp`头文件
    ➋，该文件提供了你所需的所有Boost Test组件。`BOOST_AUTO_TEST_CASE`声明 ➌ 表示一个名为`TestA` ➍的单元测试。单元测试的主体位于大括号之间
    ➎。
- en: '**Making Assertions**'
  id: totrans-377
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**进行断言**'
- en: 'Assertions in Boost are very similar to the assertions in Catch. The `BOOST_``TEST`
    macro is like the `REQUIRE` macro in Catch. You simply provide an expression that
    evaluates to true if the assertion passes and false if it fails:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: Boost中的断言与Catch中的断言非常相似。`BOOST_TEST`宏类似于Catch中的`REQUIRE`宏。你只需提供一个表达式，如果断言通过，该表达式的值为true；如果断言失败，则为false：
- en: '[PRE68]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'To require an expression to throw an exception upon evaluation, use the `BOOST_REQUIRE_THROW`
    macro, which is similar to Catch’s `REQUIRE_THROWS` macro, except you must also
    provide the type of the exception you want thrown. Its usage is as follows:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 要求某个表达式在求值时抛出异常，可以使用 `BOOST_REQUIRE_THROW` 宏，它类似于 Catch 的 `REQUIRE_THROWS` 宏，但你还必须提供你希望抛出的异常类型。其使用方法如下：
- en: '[PRE69]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: If the `*expression*` doesn’t throw an exception of type `*desired-exception-type*`,
    the assertion will fail.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `*expression*` 没有抛出 `*desired-exception-type*` 类型的异常，则断言将失败。
- en: Let’s examine what the `AutoBrake` unit-test suite looks like using Boost Test.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用 Boost Test 的 `AutoBrake` 单元测试套件是什么样的。
- en: '**Refactoring the initial_car_speed_is_zero Test to Boost Test**'
  id: totrans-384
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**将 initial_car_speed_is_zero 测试重构为 Boost Test**'
- en: You’ll use the intentionally broken `AutoBrake` in [Listing 10-32](ch10.xhtml#ch10ex32)
    with the missing member initializer for `speed_mps`. [Listing 10-42](ch10.xhtml#ch10ex42)
    causes Boost Test to deal with a failed unit test.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用 [Listing 10-32](ch10.xhtml#ch10ex32) 中故意破坏的 `AutoBrake`，其缺少 `speed_mps`
    的成员初始化器。[Listing 10-42](ch10.xhtml#ch10ex42) 使 Boost Test 处理一个失败的单元测试。
- en: '[PRE70]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '*Listing 10-42: Intentionally commenting out the `speed_mps` member initializer
    to cause test failures (using Boost Test)*'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 10-42: 故意注释掉 `speed_mps` 成员初始化器以导致测试失败（使用 Boost Test）*'
- en: The test module name is `AutoBrakeTest` ➊. After commenting out the `speed_mps`
    member initializer ➋, you have the `InitialCarSpeedIsZero` test ➌. The `BOOST_TEST`
    assertion tests whether `speed_mps` is zero ➍. As with Catch and Google Test,
    you have an informative error message that tells you what went wrong ➎.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 测试模块名称为 `AutoBrakeTest` ➊。在注释掉 `speed_mps` 成员初始化器 ➋ 后，你有了 `InitialCarSpeedIsZero`
    测试 ➌。`BOOST_TEST` 断言测试 `speed_mps` 是否为零 ➍。与 Catch 和 Google Test 一样，你会看到一个详细的错误信息，告诉你出了什么问题
    ➎。
- en: '**Test Fixtures**'
  id: totrans-389
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**测试夹具**'
- en: Like Google Test, Boost Test deals with common setup code using the notion of
    test fixtures. Using them is as simple as declaring an RAII object where the setup
    logic for the test is contained in that class’s constructor and the teardown logic
    is contained in the destructor. Unlike Google Test, you don’t have to derive from
    a parent class in your test fixture. The test fixtures work with any user-defined
    structure.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Google Test 类似，Boost Test 使用测试夹具的概念来处理常见的设置代码。使用测试夹具很简单，只需声明一个 RAII 对象，其中测试的设置逻辑包含在该类的构造函数中，拆卸逻辑包含在析构函数中。与
    Google Test 不同，你不必在测试夹具中继承父类。测试夹具可以与任何用户定义的结构一起使用。
- en: To use the test fixture in a unit test, you employ the `BOOST_FIXTURE_TEST_CASE`
    macro, which takes two parameters. The first parameter is the name of the unit
    test, and the second parameter is the test fixture class. Within the body of the
    macro, you implement a unit test as if it were a method of the test fixture class,
    as demonstrated in [Listing 10-43](ch10.xhtml#ch10ex43).
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 要在单元测试中使用测试夹具，你使用 `BOOST_FIXTURE_TEST_CASE` 宏，该宏接受两个参数。第一个参数是单元测试的名称，第二个参数是测试夹具类。在宏体内，你实现一个单元测试，就像它是测试夹具类的方法一样，如
    [Listing 10-43](ch10.xhtml#ch10ex43) 所示。
- en: '[PRE71]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '*Listing 10-43: Illustrating Boost test fixture usage*'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 10-43: 说明 Boost 测试夹具的使用*'
- en: 'Here, you define a class called `MyTestFixture` ➊ and use it as the second
    parameter for each instance of `BOOST_FIXTURE_TEST_CASE` ➋. You declare two unit
    tests: `MyTestA` ➌ and `MyTestB` ➍. Any setup you perform within `MyTestFixture`
    affects each `BOOST_FIXTURE_TEST_CASE`.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你定义一个名为 `MyTestFixture` ➊ 的类，并将其作为 `BOOST_FIXTURE_TEST_CASE` 的第二个参数 ➋。你声明了两个单元测试：`MyTestA`
    ➌ 和 `MyTestB` ➍。在 `MyTestFixture` 中执行的任何设置操作都会影响每个 `BOOST_FIXTURE_TEST_CASE`。
- en: Next, you’ll use Boost Test fixtures to reimplement the `AutoBrake` test suite.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将使用 Boost Test 测试夹具重新实现 `AutoBrake` 测试套件。
- en: '**Refactoring AutoBrake Unit Tests with Boost Test**'
  id: totrans-396
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用 Boost Test 重构 AutoBrake 单元测试**'
- en: '[Listing 10-44](ch10.xhtml#ch10ex44) implements the `AutoBrake` unit-test suite
    using Boost Test’s test fixture.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 10-44](ch10.xhtml#ch10ex44) 使用 Boost Test 的测试夹具实现了 `AutoBrake` 单元测试套件。'
- en: '[PRE72]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '*Listing 10-44: Using Boost Test to implement your unit tests*'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 10-44: 使用 Boost Test 实现单元测试*'
- en: You define the test fixture class `AutoBrakeTest` to perform the setup of the
    `AutoBrake` and `MockServiceBus` ➊. It’s identical to the Google Test test fixture
    except you didn’t need to inherit from any framework-issued parent classes. You
    represent each unit test with a `BOOST_FIXTURE_TEST_CASE` macro ➋. The rest of
    the tests use the `BOOST_TEST` and `BOOST_REQUIRE_THROW` assertion macros; otherwise,
    the tests look very similar to Catch tests. Instead of `TEST_CASE` and `SECTION`
    elements, you have a test fixture class and `BOOST_FIXTURE_TEST_CASE`.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 你定义了测试夹具类 `AutoBrakeTest` 来执行 `AutoBrake` 和 `MockServiceBus` 的设置 ➊。它与 Google
    Test 的测试夹具相同，只是你不需要继承任何框架提供的父类。你通过 `BOOST_FIXTURE_TEST_CASE` 宏来表示每个单元测试 ➋。其余的测试使用
    `BOOST_TEST` 和 `BOOST_REQUIRE_THROW` 断言宏；否则，这些测试看起来与 Catch 测试非常相似。与 `TEST_CASE`
    和 `SECTION` 元素不同，你有一个测试夹具类和 `BOOST_FIXTURE_TEST_CASE`。
- en: '***Summary: Testing Frameworks***'
  id: totrans-401
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***总结：测试框架***'
- en: Although three different unit-testing frameworks were presented in this section,
    dozens of high-quality options are available. None of them is universally superior.
    Most frameworks support the same basic set of features, whereas some of the more
    advanced features will have heterogeneous support. Mainly, you should select a
    unit-testing framework based on the style that makes you comfortable and productive.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本节介绍了三种不同的单元测试框架，但实际上有数十种高质量的选项可供选择。没有任何一个框架是绝对优越的。大多数框架都支持相同的基本功能集，而一些更高级的功能则会有不同的支持程度。总的来说，你应该根据最适合你工作风格和提高生产力的框架来选择单元测试框架。
- en: '**Mocking Frameworks**'
  id: totrans-403
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**模拟框架**'
- en: The unit-testing frameworks you just explored will work in a wide range of settings.
    It would be totally feasible to build integration tests, acceptance tests, unit
    tests, and even performance tests using Google Test, for example. The testing
    frameworks support a broad range of programming styles, and their creators have
    only modest opinions about how you must design your software to make them testable.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚探索的单元测试框架适用于各种设置。例如，完全可以使用 Google Test 构建集成测试、验收测试、单元测试，甚至是性能测试。这些测试框架支持广泛的编程风格，它们的创建者对你如何设计软件以使其可测试有着相对保守的看法。
- en: Mocking frameworks are a bit more opinionated than unit-testing frameworks.
    Depending on the mocking framework, you must follow certain design guidelines
    for how classes depend on each other. The `AutoBrake` class used a modern design
    pattern called *dependency injection*. The `AutoBrake` class depends on an `IServiceBus`,
    which you injected using the constructor of `AutoBrake`. You also made `IServiceBus`
    an interface. Other methods for achieving polymorphic behavior exist (like templates),
    and each involves trade-offs.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟框架比单元测试框架有更多的主观看法。根据不同的模拟框架，你必须遵循一定的设计指南来确定类之间的依赖关系。`AutoBrake` 类使用了一种现代设计模式，叫做
    *依赖注入*。`AutoBrake` 类依赖于一个 `IServiceBus`，你通过 `AutoBrake` 的构造函数将其注入。你还将 `IServiceBus`
    设为一个接口。也存在其他实现多态行为的方法（如模板），每种方法都有其优缺点。
- en: All the mocking frameworks discussed in this section work extremely well with
    dependency injection. To varying degrees, the mocking frameworks remove the need
    to define your own mocks. Recall that you implemented a `MockServiceBus` to allow
    you to unit test `AutoBrake`, as displayed in [Listing 10-45](ch10.xhtml#ch10ex45).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论的所有模拟框架都与依赖注入非常兼容。模拟框架在不同程度上减少了定义自己模拟对象的需求。回想一下，你实现了一个 `MockServiceBus`
    来允许你单元测试 `AutoBrake`，如 [列表 10-45](ch10.xhtml#ch10ex45) 所示。
- en: '[PRE73]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '*Listing 10-45: Your hand-rolled `MockServiceBus`*'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-45：你自己编写的`MockServiceBus`*'
- en: 'Each time you want to add a unit test involving some new kind of interaction
    with `IServiceBus`, you’ll likely need to update your `MockServiceBus` class.
    This is tedious and error prone. Additionally, it’s not clear that you can share
    this mock class with other teams: you’ve implemented a lot of your own logic in
    it that won’t be very useful to, say, the tire-pressure-sensor team. Also, each
    test might have different requirements. Mocking frameworks enables you to define
    mock classes, often using macro or template voodoo. Within each unit test, you
    can customize the mock specifically for that test. This would be extremely difficult
    to do with a single mock definition.'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你想添加一个涉及与`IServiceBus`交互的新单元测试时，你可能需要更新你的`MockServiceBus`类。这是繁琐且容易出错的。此外，你也不清楚是否可以将这个模拟类共享给其他团队：你在其中实现了很多自己的逻辑，这对比如轮胎压力传感器团队可能没有什么用。而且，每个测试可能有不同的要求。模拟框架使你能够定义模拟类，通常通过宏或模板的魔法。在每个单元测试中，你可以根据该测试的需要自定义模拟。这对于单一的模拟定义来说是非常困难的。
- en: This decoupling of the mock’s declaration from the mock’s test-specific definition
    is extremely powerful for two reasons. First, you can define different kinds of
    behavior for each unit test. This allows you to, for example, simulate exceptional
    conditions for some unit tests but not for others. Second, it makes the unit tests
    far more specific. By placing the custom mock’s behavior within a unit test rather
    than in a separate source file, it’s much clearer to the developer what the test
    is trying to achieve.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟声明与模拟特定测试定义的解耦对于两个原因来说非常强大。首先，你可以为每个单元测试定义不同的行为。这允许你例如为某些单元测试模拟异常条件，而不为其他测试模拟。其次，它使得单元测试更加具体。通过将自定义模拟行为放置在单元测试中，而不是在单独的源文件中，开发人员更清楚地了解测试的目标是什么。
- en: The net effect of using a mocking framework is that it makes mocking much less
    problematic. When mocking is easy, it makes good unit testing (and TDD) possible.
    Without mocking, unit testing can be very difficult; tests can be slow, unreliable,
    and brittle due to slow or error-prone dependencies. It’s generally preferable,
    for example, to use a mock database connection instead of a full-blown production
    instance while you’re trying to use TDD to implement new features into a class.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模拟框架的净效果是它使得模拟变得更加简单。模拟变得容易时，良好的单元测试（以及TDD）变得可行。如果没有模拟，单元测试可能会非常困难；由于依赖关系的缓慢或易出错，测试可能会变得缓慢、不可靠且脆弱。例如，在你试图使用TDD将新功能实现到类中时，通常更倾向于使用模拟数据库连接，而不是完整的生产实例。
- en: This section provides a tour of two mocking frameworks, Google Mock and HippoMocks,
    and includes a brief mention of two others, FakeIt and Trompeloeil. For technical
    reasons having to do with a lack of compile time code generation, creating a mocking
    framework is much harder in C++ than in most other languages, especially those
    with type reflection, a language feature that allows code to programmatically
    reason about type information. Consequently, there are a lot of high-quality mocking
    frameworks, each with their own trade-offs resulting from the fundamental difficulties
    associated with mocking C++.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了两个模拟框架，Google Mock和HippoMocks，并简要提到另外两个框架，FakeIt和Trompeloeil。由于缺乏编译时代码生成技术，创建模拟框架在C++中比在大多数其他语言中要困难，尤其是在具有类型反射的语言中，类型反射是一种允许代码程序化推理类型信息的语言特性。因此，有许多高质量的模拟框架，每个框架都有自己的权衡，这些权衡源自模拟C++的根本困难。
- en: '***Google Mock***'
  id: totrans-413
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Google Mock***'
- en: One of the most popular mocking frameworks is the Google C++ Mocking Framework
    (or Google Mock), which is included as part of Google Test. It’s one of the oldest
    and most feature-rich mocking frameworks. If you’ve already installed Google Test,
    incorporating Google Mock is easy. First, make sure you include the `gmock` static
    library in your linker, as you did for `gtest` and `gtest_main`. Next, add `#include
    "gmock/gmock.h"`.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 最流行的模拟框架之一是Google C++模拟框架（或Google Mock），它作为Google Test的一部分包含在内。它是最古老且功能最丰富的模拟框架之一。如果你已经安装了Google
    Test，集成Google Mock非常简单。首先，确保你在链接器中包含了`gmock`静态库，就像你为`gtest`和`gtest_main`做的那样。接下来，添加`#include
    "gmock/gmock.h"`。
- en: If you’re using Google Test as your unit-testing framework, that’s all the setup
    you’ll need to do. Google Mock will work seamlessly with its sister library. If
    you’re using another unit-testing framework, you’ll need to provide the initialization
    code in the entry point of the binary, as shown in [Listing 10-46](ch10.xhtml#ch10ex46).
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Google Test作为单元测试框架，那么只需要进行上述设置。Google Mock将与其姐妹库无缝配合工作。如果你使用的是其他单元测试框架，你需要在二进制文件的入口点提供初始化代码，如[示例10-46](ch10.xhtml#ch10ex46)所示。
- en: '[PRE74]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '*Listing 10-46: Adding Google Mock to a third-party unit-testing framework*'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例10-46：将Google Mock添加到第三方单元测试框架中*'
- en: The `GTEST_FLAG` `throw_on_failure` ➊ causes Google Mock to throw an exception
    when some mock-related assertion fails. The call to `InitGoogleMock` ➋ consumes
    the command line arguments to make any necessary customization (refer to the Google
    Mock documentation for more details).
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`GTEST_FLAG`中的`throw_on_failure` ➊ 会导致Google Mock在一些mock相关的断言失败时抛出异常。调用`InitGoogleMock`
    ➋ 会消耗命令行参数，并进行必要的定制（更多细节请参见Google Mock文档）。'
- en: '**Mocking an Interface**'
  id: totrans-419
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Mock一个接口**'
- en: For each interface you need to mock, there is some unfortunate ceremony. You
    need to take each `virtual` function of the interface and transmute it into a
    macro. For non-`const` methods, you use `MOCK_METHOD*`, and for `const` methods,
    you use `MOCK_CONST_METHOD*`, replacing `*` with the number of parameters that
    the function takes. The first parameter of `MOCK_METHOD` is the name of the `virtual`
    function. The second parameter is the function prototype. For example, to make
    a mock `IServiceBus`, you would build the definition shown in [Listing 10-47](ch10.xhtml#ch10ex47).
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个需要mock的接口，都有一些不太愉快的仪式。你需要将接口的每个`virtual`函数转换成一个宏。对于非`const`方法，你使用`MOCK_METHOD*`，而对于`const`方法，则使用`MOCK_CONST_METHOD*`，并用函数参数的个数替换`*`。`MOCK_METHOD`的第一个参数是`virtual`函数的名称，第二个参数是函数的原型。例如，为了构建一个mock的`IServiceBus`，你需要编写如[示例10-47](ch10.xhtml#ch10ex47)所示的定义。
- en: '[PRE75]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '*Listing 10-47: A Google Mock `MockServiceBus`*'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例10-47：一个Google Mock的`MockServiceBus`*'
- en: The beginning of the definition of `MockServiceBus` is identical to the definition
    of any other `IServiceBus` implementation ➊. You then employ `MOCK_METHOD` three
    times ➋. The first parameter ➌ is the name of the `virtual` function, and the
    second parameter ➍ is the prototype of the function.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '`MockServiceBus`的定义开头与任何其他`IServiceBus`实现的定义相同 ➊。接下来，你会使用三次`MOCK_METHOD` ➋。第一个参数
    ➌ 是`virtual`函数的名称，第二个参数 ➍ 是函数的原型。'
- en: It’s a bit tedious to have to generate these definitions on your own. There’s
    no additional information in the `MockServiceBus` definition that isn’t already
    available in the `IServiceBus`. For better or worse, this is one of the costs
    of using Google Mock. You can take the sting out of generating this boilerplate
    by using the `gmock_gen.py` tool included in the `scripts/generator` folder of
    the Google Mock distribution. You’ll need Python 2 installed, and it’s not guaranteed
    to work in all situations. See the Google Mock documentation for more information.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 自己生成这些定义有点繁琐。在`MockServiceBus`的定义中，并没有比`IServiceBus`中已有的额外信息。无论好坏，这就是使用Google
    Mock的一项成本。你可以通过使用Google Mock分发包中的`scripts/generator`文件夹内的`gmock_gen.py`工具来减轻生成这些样板代码的负担。你需要安装Python
    2，并且不能保证在所有情况下都能正常工作。有关更多信息，请参见Google Mock文档。
- en: Now that you’ve defined a `MockServiceBus`, you can use it in your unit tests.
    Unlike the mock you defined on your own, you can configure a Google Mock specifically
    for each unit test. You have an incredible amount of flexibility in this configuration.
    The key to successful mock configuration is the use of appropriate expectations.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了一个`MockServiceBus`，可以在单元测试中使用它。与自己定义的mock不同，你可以为每个单元测试专门配置一个Google Mock。你在配置中有极大的灵活性。成功的mock配置的关键是使用适当的期望（expectations）。
- en: '**Expectations**'
  id: totrans-426
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**期望（Expectations）**'
- en: An *expectation* is like an assertion for a mock object; it expresses the circumstances
    in which the mock expects to be called and what it should do in response. The
    “circumstances” are specified using objects called *matchers*. The “what it should
    do in response” part is called an *action*. The sections that follow will introduce
    each of these concepts.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '*期望（expectation）*就像是mock对象的断言；它表示mock期望在什么情况下被调用以及它应当做出什么响应。所谓的“情况”是通过称为*匹配器（matchers）*的对象来指定的。而“它应该做出什么响应”的部分称为*动作（action）*。接下来的部分将介绍这些概念。'
- en: 'Expectations are declared with the `EXPECT_CALL` macro. The first parameter
    to this macro is the mock object, and the second is the expected method call.
    This method call can optionally contain matchers for each parameter. These matchers
    help Google Mock decide whether a particular method invocation qualifies as an
    expected call. The format is as follows:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 期望通过`EXPECT_CALL`宏来声明。该宏的第一个参数是模拟对象，第二个参数是预期的方法调用。这个方法调用可以选择性地包含每个参数的匹配器。这些匹配器帮助Google
    Mock判断某个特定的方法调用是否符合预期调用。格式如下：
- en: '[PRE76]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'There are several ways to formulate assertions about expectations, and which
    you choose depends on how strict your requirements are for how the unit being
    tested interacts with the mock. Do you care whether your code calls mocked functions
    that you didn’t expect? It really depends on the application. That’s why there
    are three options: naggy, nice, and strict.'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方式可以对期望值进行断言，选择哪种方式取决于你对被测试单元与模拟对象交互的要求有多严格。你在乎代码是否调用了你没有预期的模拟函数吗？这实际上取决于应用场景。这就是为什么有三种选择：烦人的、友好的和严格的。
- en: A *naggy mock* is the default. If a naggy mock’s function is called and no `EXPECT_CALL`
    matches the call, Google Mock will print a warning about an “uninteresting call,”
    but the test won’t fail just because of the uninteresting call. You can just add
    an `EXPECT_CALL` into the test as a quick fix to suppress the uninteresting call
    warning, because the call then ceases to be unexpected.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '*烦人的模拟对象* 是默认选项。如果烦人模拟对象的函数被调用且没有与之匹配的`EXPECT_CALL`，Google Mock会打印一个关于“不感兴趣的调用”的警告，但测试并不会因为这个不感兴趣的调用而失败。你可以通过在测试中添加一个`EXPECT_CALL`来快速修复并抑制不感兴趣的调用警告，因为调用就不再是未预期的了。'
- en: In some situations, there might be too many uninteresting calls. In such cases,
    you should use a *nice mock*. The nice mock won’t produce a warning about uninteresting
    calls.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，可能会有太多不感兴趣的调用。在这种情况下，你应该使用*友好的模拟对象*。友好的模拟对象不会因为不感兴趣的调用而发出警告。
- en: If you’re very concerned about any interaction with the mock that you haven’t
    accounted for, you might use a *strict mock*. Strict mocks will fail the test
    if any call is made to the mock for which you don’t have a corresponding `EXPECT_CALL`.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你非常担心与模拟对象的任何未考虑到的交互，你可能会使用*严格的模拟对象*。如果任何未包含在`EXPECT_CALL`中的调用发生，严格的模拟对象会使测试失败。
- en: Each of these types of mocks is a class template. The way to instantiate these
    classes is straightforward, as outlined in [Listing 10-48](ch10.xhtml#ch10ex48).
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 每种模拟对象类型都是一个类模板。实例化这些类的方式非常简单，如[Listing 10-48](ch10.xhtml#ch10ex48)中所述。
- en: '[PRE77]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '*Listing 10-48: Three different styles of Google Mock*'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 10-48：Google Mock的三种不同风格*'
- en: Naggy mocks ➊ are the default. Every `::testing::NiceMock` ➋ and `::testing::StrictMock`
    ➌ takes a single template parameter, the class of the underlying mock. All three
    of these options are perfectly valid first parameters to an `EXPECT_CALL`.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '**烦人的模拟对象** ➊ 是默认选项。每个`::testing::NiceMock` ➋ 和 `::testing::StrictMock` ➌ 都需要一个模板参数，即底层模拟对象的类。这三种选项都可以作为`EXPECT_CALL`的有效第一个参数。'
- en: As a general rule, you should use nice mocks. Using naggy and strict mocks can
    lead to very brittle tests. When you’re using a strict mock, consider whether
    it’s really necessary to be so restrictive about the way the unit under test collaborates
    with the mock.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，你应该使用友好的模拟对象。使用烦人和严格的模拟对象可能导致非常脆弱的测试。当你使用严格的模拟对象时，考虑是否真的有必要对被测试单元与模拟对象的交互做出如此严格的限制。
- en: The second parameter to `EXPECT_CALL` is the name of the method you expect to
    be called followed by the parameters you expect the method to be called with.
    Sometimes, this is easy. Other times, there are more complicated conditions you
    want to express for what invocations match and don’t match. In such situations,
    you use matchers.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXPECT_CALL`的第二个参数是你预期被调用的方法的名称，后面跟着你期望该方法使用的参数。有时这很简单，其他时候，你可能需要表达更复杂的条件来指定哪些调用匹配，哪些不匹配。在这种情况下，你可以使用匹配器。'
- en: '**Matchers**'
  id: totrans-440
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**匹配器**'
- en: When a mock’s method takes arguments, you have broad discretion over whether
    an invocation matches the expectation. In simple cases, you can use literal values.
    If the mock method is invoked with exactly the specified literal value, the invocation
    matches the expectation; otherwise, it doesn’t. On the other extreme, you can
    use Google Mock’s `::testing::_` object, which tells Google Mock that *any* value
    matches.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 当模拟对象的方法带有参数时，你可以自由决定调用是否匹配期望。在简单的情况下，你可以使用字面值。如果模拟方法以完全相同的字面值被调用，则调用会匹配期望；否则，不匹配。另一方面，你可以使用Google
    Mock的`::testing::_`对象，它告诉Google Mock，*任何*值都匹配。
- en: Suppose, for example, that you want to invoke `publish`, and you don’t care
    what the argument is. The `EXPECT_CALL` in [Listing 10-49](ch10.xhtml#ch10ex49)
    would be appropriate.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，例如，你想调用`publish`，并且不关心参数是什么。[Listing 10-49](ch10.xhtml#ch10ex49)中的`EXPECT_CALL`将是合适的选择。
- en: '[PRE78]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '*Listing 10-49: Using the `::testing::_` matcher in an expectation*'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 10-49: 在期望中使用`::testing::_`匹配器*'
- en: To make the unit test nice and tidy, you employ a `using` for `::testing::_`➊.
    You use `_` to tell Google Mock that *any* invocation of `publish` with a single
    argument will match ➋.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让单元测试更简洁，你使用了`using`来处理`::testing::_`➊。你使用`_`来告诉Google Mock，*任何*带有单个参数的`publish`调用都会匹配
    ➋。
- en: A slightly more selective matcher is the class template `::testing::A`, which
    will match only if a method is invoked with a particular type of parameter. This
    type is expressed as the template parameter to `A`, so `A<MyType>` will match
    only a parameter of type `MyType`. In [Listing 10-50](ch10.xhtml#ch10ex50), the
    modification to [Listing 10-49](ch10.xhtml#ch10ex49) illustrates a more restrictive
    expectation that requires a `BrakeCommand` as the parameter to `publish`.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 一个稍微更具选择性的匹配器是类模板`::testing::A`，它仅在方法调用时使用特定类型的参数时才会匹配。这个类型作为`A`的模板参数来表达，因此`A<MyType>`只会匹配`MyType`类型的参数。在[Listing
    10-50](ch10.xhtml#ch10ex50)中，对[Listing 10-49](ch10.xhtml#ch10ex49)的修改展示了一个更严格的期望，它要求`publish`的参数为`BrakeCommand`。
- en: '[PRE79]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '*Listing 10-50: Using the `::testing::A` matcher in an expectation*'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 10-50: 在期望中使用`::testing::A`匹配器*'
- en: Again, you employ `using` ➊ and use `A<BrakeCommand>` to specify that only a
    `BrakeCommand` will match this expectation.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用`using` ➊，并使用`A<BrakeCommand>`来指定只有`BrakeCommand`类型的参数才能匹配这个期望。
- en: 'Another matcher, `::testing::Field`, allows you to inspect fields on arguments
    passed to the mock. The `Field` matcher takes two parameters: a pointer to the
    field you want to expect and then another matcher to express whether the pointed-to
    field meets the criteria. Suppose you want to be even more specific about the
    call to `publish` ➋: you want to specify that the `time_to_collision_s` is equal
    to 1 second. You can accomplish this task with the refactor of [Listing 10-49](ch10.xhtml#ch10ex49)
    shown in [Listing 10-51](ch10.xhtml#ch10ex51).'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个匹配器，`::testing::Field`，允许你检查传递给模拟对象的参数中的字段。`Field`匹配器接受两个参数：一个指向你想要检查的字段的指针，另一个是用来表示该字段是否符合标准的匹配器。假设你想要更加具体地指定对`publish`的调用
    ➋：你希望指定`time_to_collision_s`等于1秒。你可以通过[Listing 10-49](ch10.xhtml#ch10ex49)中重构的代码实现这一任务，该代码在[Listing
    10-51](ch10.xhtml#ch10ex51)中显示。
- en: '[PRE80]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '*Listing 10-51: Using the `Field` matcher in an expectation*'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 10-51: 在期望中使用`Field`匹配器*'
- en: You employ `using` for `Field` ➊ and `DoubleEq` ➋ to clean up the expectation
    code a bit. The `Field` matcher takes a pointer to the field you’re interested
    in `time_to_collision_s` ➌ and the matcher that decides whether the field meets
    the criteria `DoubleEq` ➍.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`using`来简化`Field` ➊和`DoubleEq` ➋的期望代码。`Field`匹配器接受指向你关心的字段`time_to_collision_s`
    ➌的指针，以及决定该字段是否符合标准的匹配器`DoubleEq` ➍。
- en: Many other matchers are available, and they’re summarized in [Table 10-2](ch10.xhtml#ch10tab02).
    But refer to the Google Mock documentation for all the details about their usages.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他的匹配器，它们在[表 10-2](ch10.xhtml#ch10tab02)中进行了总结。但请参考Google Mock文档了解它们的所有用法细节。
- en: '**Table 10-2:** Google Mock Matchers'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10-2：** Google Mock 匹配器'
- en: '| **Matcher** | **Matches when argument is . . .** |'
  id: totrans-456
  prefs: []
  type: TYPE_TB
  zh: '| **匹配器** | **当参数是...时匹配** |'
- en: '| `_` | Any value of the correct type |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
  zh: '| `_` | 任何正确类型的值 |'
- en: '| `A<`type`>)()` | Of the given `*type*` |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '| `A<`type`>)()` | 给定的`*type*`的值 |'
- en: '| `An<`type`>)()` | Of the given `*type*` |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '| `An<`type`>)()` | 给定的`*type*`的值 |'
- en: '| `Ge(`value`)` | Greater than or equal to `*value*` |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '| `Ge(`value`)` | 大于或等于`*value*` |'
- en: '| `Gt(value`) | Greater than `*value*` |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '| `Gt(value)` | 大于`*value*` |'
- en: '| `Le`(value) | Less than or equal to `*value*` |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '| `Le(`value`)` | 小于或等于`*value*` |'
- en: '| `Lt(`value) | Less than `*value*` |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '| `Lt(`value`)` | 小于`*value*` |'
- en: '| `Ne(`value) | Not equal to `*value*` |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '| `Ne(`value) | 不等于`*value*` |'
- en: '| `IsNull()` | Null |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '| `IsNull()` | 空值 |'
- en: '| `NotNull()` | Not null |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
  zh: '| `NotNull()` | 非空值 |'
- en: '| `Ref`(variable) | A reference to `*variable*` |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
  zh: '| `Ref`(variable) | `*variable*`的引用 |'
- en: '| `DoubleEq`(variable) | A `double` value approximately equal to `*variable*`
    |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '| `DoubleEq`(variable) | 一个大致等于`*variable*`的`double`值 |'
- en: '| `FloatEq`(variable) | A `float` value approximately equal to `*variable*`
    |'
  id: totrans-469
  prefs: []
  type: TYPE_TB
  zh: '| `FloatEq`(variable) | 一个大致等于`*variable*`的`float`值 |'
- en: '| `EndsWith`(str) | A string ending with `*str*` |'
  id: totrans-470
  prefs: []
  type: TYPE_TB
  zh: '| `EndsWith`(str) | 以`*str*`结尾的字符串 |'
- en: '| `HasSubstr`(str) | A string containing the substring `*str*` |'
  id: totrans-471
  prefs: []
  type: TYPE_TB
  zh: '| `HasSubstr`(str) | 一个包含子字符串`*str*`的字符串 |'
- en: '| `StartsWith`(str) | A string starting with `*str*` |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
  zh: '| `StartsWith`(str) | 一个以`*str*`开头的字符串 |'
- en: '| `StrCaseEq`(str) | A string equal to `*str*` (ignoring case) |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '| `StrCaseEq`(str) | 一个与`*str*`相等的字符串（忽略大小写） |'
- en: '| `StrCaseNe`(str) | A string not equal to `*str*` (ignoring case) |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '| `StrCaseNe`(str) | 一个与`*str*`不相等的字符串（忽略大小写） |'
- en: '| `StrEq`(str) | A string equal to `*str*` |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '| `StrEq`(str) | 一个与`*str*`相等的字符串 |'
- en: '| `StrNeq`(string) | A string not equal to `*str*` |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
  zh: '| `StrNeq`(string) | 字符串不等于`*str*` |'
- en: '**NOTE**'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*One beneficial feature of matchers is that you can use them as an alternate
    kind of assertion for your unit tests. The alternate macro is one of `EXPECT_THAT`*(`value,
    matcher`) or `*ASSERT_THAT*`(`value, matcher`). *For example, you could replace
    the assertion*'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '*匹配器的一个有益特性是你可以将它们用作你单元测试中的另一种断言。另一种宏是`EXPECT_THAT`*(`value, matcher`) 或 `*ASSERT_THAT*`(`value,
    matcher`)。*例如，你可以替换掉该断言*'
- en: '[PRE81]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '*with the more syntactically pleasing*'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用更具语法美感的*'
- en: '[PRE82]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: You can use `EXPECT_CALL` with `StrictMock` to enforce how the unit under test
    interacts with the mock. But you might also want to specify how many times the
    mock should respond to calls. This is called the expectation’s *cardinality*.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`EXPECT_CALL`与`StrictMock`来强制测试单元与模拟对象的交互方式。但你也可能需要指定模拟对象应如何响应调用的次数。这被称为期望的*基数*。
- en: '**Cardinality**'
  id: totrans-483
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**基数**'
- en: Perhaps the most common method for specifying cardinality is `Times`, which
    specifies the number of times that a mock should expect to be called. The `Times`
    method takes a single parameter, which can be an integer literal or one of the
    functions listed in [Table 10-3](ch10.xhtml#ch10tab03).
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的指定基数的方法可能是`Times`，它指定模拟对象应该期望被调用的次数。`Times`方法接受一个参数，可以是整数字面量或[表 10-3](ch10.xhtml#ch10tab03)中列出的函数之一。
- en: '**Table 10-3:** A Listing of the Cardinality Specifiers in Google Mock'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10-3：** Google Mock中基数指定符的列表'
- en: '| **Cardinality** | **Specifies that a method will be called . . .** |'
  id: totrans-486
  prefs: []
  type: TYPE_TB
  zh: '| **基数** | **指定一个方法将被调用的次数...** |'
- en: '| `AnyNumber()` | Any number of times |'
  id: totrans-487
  prefs: []
  type: TYPE_TB
  zh: '| `AnyNumber()` | 任意次数 |'
- en: '| `AtLeast`(n) | At least n times |'
  id: totrans-488
  prefs: []
  type: TYPE_TB
  zh: '| `AtLeast`(n) | 至少n次 |'
- en: '| `AtMost`(n) | At most n times |'
  id: totrans-489
  prefs: []
  type: TYPE_TB
  zh: '| `AtMost`(n) | 最多n次 |'
- en: '| `Between`(m`,` n) | Between m and n times |'
  id: totrans-490
  prefs: []
  type: TYPE_TB
  zh: '| `Between`(m`,` n) | 在m和n之间的次数 |'
- en: '| `Exactly`(n) | Exactly n times |'
  id: totrans-491
  prefs: []
  type: TYPE_TB
  zh: '| `Exactly`(n) | 正好n次 |'
- en: '[Listing 10-52](ch10.xhtml#ch10ex52) elaborates [Listing 10-51](ch10.xhtml#ch10ex51)
    to indicate that `publish` must be called only once.'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 10-52](ch10.xhtml#ch10ex52)详细说明了[列表 10-51](ch10.xhtml#ch10ex51)，指明`publish`必须只被调用一次。'
- en: '[PRE83]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '*Listing 10-52: Using the `Times` cardinality specifier in an expectation*'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-52：在期望中使用`Times`基数指定符*'
- en: The `Times` call ➊ ensures that `publish` gets called exactly once (regardless
    of whether you use a nice, strict, or naggy mock).
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '`Times`调用 ➊ 确保`publish`被精确调用一次（无论你使用的是友好、严格还是苛刻的模拟）。'
- en: '**NOTE**'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Equivalently, you could have specified Times(Exactly(1)).*'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '*同样，你可以指定Times(Exactly(1))。*'
- en: Now that you have some tools to specify the criteria and cardinality for an
    expected invocation, you can customize how the mock should respond to expectations.
    For this, you employ actions.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经掌握了一些工具，可以指定预期调用的标准和基数，你可以自定义模拟对象如何响应这些期望。为此，你需要使用动作。
- en: '**Actions**'
  id: totrans-499
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**动作**'
- en: 'Like cardinalities, all actions are chained off `EXPECT_CALL` statements. These
    statements can help clarify how many times a mock expects to be called, what values
    to return each time it’s called, and any side effects (like throwing an exception)
    it should perform. The `WillOnce` and `WillRepeatedly` actions specify what a
    mock should do in response to a query. These actions can get quite complicated,
    but for brevity’s sake, this section covers two usages. First, you can use the
    `Return` construct to return values to the caller:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 像基数一样，所有的操作都通过`EXPECT_CALL`语句进行链式调用。这些语句有助于澄清模拟期望被调用的次数，每次调用时返回的值，以及它应该执行的任何副作用（如抛出异常）。`WillOnce`和`WillRepeatedly`操作指定了模拟在接收到查询时应该执行的动作。这些操作可能会变得相当复杂，但为了简洁起见，本节只涵盖两种用法。首先，你可以使用`Return`构造返回值给调用者：
- en: '[PRE84]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: You set up an `EXPECT_CALL` the usual way and then tag on some actions that
    specify what value the `jenny_mock` will return each time `get_your_number` is
    called ➊. These are read sequentially from left to right, so the first action,
    `WillOnce` ➋, specifies that the first time `get_your_number` is called, the value
    `8675309` is returned by `jenny_mock`. The next action, `WillRepeatedly` ➌, specifies
    that for all subsequent calls, the value `911` will be returned.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 你按照常规方式设置一个`EXPECT_CALL`，然后添加一些操作，指定每次调用`get_your_number`时`jenny_mock`将返回什么值
    ➊。这些操作按从左到右的顺序读取，因此第一个操作`WillOnce` ➋指定第一次调用`get_your_number`时，`jenny_mock`返回值`8675309`。下一个操作`WillRepeatedly`
    ➌指定在所有后续调用中，返回值`911`。
- en: Because `IServiceBus` doesn’t return any values, you’ll need the action to be
    a little more involved. For highly customizable behavior, you can use the `Invoke`
    construct, which enables you to pass an `Invocable` that will get called with
    the exact arguments passed into the mock’s method. Let’s say you want to save
    off a reference to the callback function that the `AutoBrake` registers via `subscribe`.
    You can do this easily with an `Invoke`, as illustrated in [Listing 10-53](ch10.xhtml#ch10ex53).
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`IServiceBus`不会返回任何值，所以你需要让操作稍微复杂一些。对于高度可定制的行为，你可以使用`Invoke`构造，它使你能够传递一个`Invocable`，该对象将在模拟方法调用时使用传入的精确参数。假设你想保存对`AutoBrake`通过`subscribe`注册的回调函数的引用。你可以通过`Invoke`轻松实现这一点，正如[示例
    10-53](ch10.xhtml#ch10ex53)所示。
- en: '[PRE85]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '*Listing 10-53: Using `Invoke` to save off a reference to the `subscribe` callback
    registered by an `AutoBrake`*'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 10-53：使用`Invoke`保存对`AutoBrake`通过`subscribe`注册的回调函数的引用*'
- en: The first (and only) time that `subscribe` is called with a `CarDetectedCallback`,
    the `WillOnce(Invoke(...))` action will call the lambda that’s been passed in
    as a parameter. This lambda captures the `CarDetectedCallback` declared ➊ by reference
    ➋. By definition, the lambda has the same function prototype as the `subscribe`
    function, so you can use auto-type deduction ➌ to determine the correct type for
    `callback_in` (it’s `CarDetectedCallback`). Finally, you assign `callback_in`
    to `callback` ➍. Now, you can pass events off to whoever `subscribes` simply by
    invoking your `callback` ➊. The `Invoke` construct is the Swiss Army Knife of
    actions, because you get to execute arbitrary code with full information about
    the invocation parameters. *Invocation parameters* are the parameters that the
    mocked method received at runtime.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 当`subscribe`第一次（也是唯一一次）使用`CarDetectedCallback`被调用时，`WillOnce(Invoke(...))`操作将调用作为参数传入的lambda。这个lambda通过引用捕获了声明的`CarDetectedCallback`
    ➊。根据定义，lambda具有与`subscribe`函数相同的函数原型，因此你可以使用自动类型推断 ➌ 来确定`callback_in`的正确类型（它是`CarDetectedCallback`）。最后，你将`callback_in`赋值给`callback`
    ➍。现在，你可以通过调用你的`callback` ➊来将事件传递给任何`subscribe`的对象。`Invoke`构造是操作的瑞士军刀，因为你可以在完全了解调用参数的情况下执行任意代码。*调用参数*是模拟方法在运行时接收到的参数。
- en: '**Putting It All Together**'
  id: totrans-507
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**将所有内容整合起来**'
- en: Reconsidering our `AutoBrake` testing suite, you can reimplement the Google
    Test unit-test binary to use Google Mock rather than the hand-rolled mock, as
    demonstrated in [Listing 10-54](ch10.xhtml#ch10ex54).
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 在重新考虑我们的`AutoBrake`测试套件时，你可以将Google Test单元测试二进制文件重新实现为使用Google Mock，而不是手动编写的模拟，正如[示例
    10-54](ch10.xhtml#ch10ex54)所示。
- en: '[PRE86]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '*Listing 10-54: Reimplementing your unit tests using a Google Mock rather than
    a roll-your-own mock*'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 10-54：使用Google Mock重新实现单元测试，而不是自己编写模拟*'
- en: 'Here, you actually have two different test fixtures: `NiceAutoBrakeTest` ➊
    and `StrictAutoBrakeTest` ➋. The `NiceAutoBrakeTest` test instantiates a `NiceMock`.
    This is useful for `InitialCarSpeedIsZero, InitialSensitivityIsFive`, and `SensitivityGreaterThanOne`,
    because you don’t want to test any meaningful interactions with the mock; it’s
    not the focus of these tests. But you do want to focus on `AlertWhenImminent`
    and `NoAlertWhenNotImminent`. Each time an event is published or a type is subscribed
    to, it could have potentially major ramifications on your system. The paranoia
    of a `StrictMock` here is warranted.'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你实际上有两个不同的测试固定器：`NiceAutoBrakeTest` ➊ 和 `StrictAutoBrakeTest` ➋。`NiceAutoBrakeTest`测试实例化了一个`NiceMock`。这对于`InitialCarSpeedIsZero`、`InitialSensitivityIsFive`和`SensitivityGreaterThanOne`非常有用，因为你不希望测试与模拟对象的任何实际交互；这不是这些测试的重点。但你确实希望关注`AlertWhenImminent`和`NoAlertWhenNotImminent`。每次发布事件或订阅类型时，它可能会对你的系统产生重大影响。在这种情况下，使用`StrictMock`的偏执是有道理的。
- en: In the `StrictAutoBrakeTest` definition, you can see the `WillOnce`/`Invoke`
    approach to saving off the callbacks for each subscription ➌➍. These are used
    in `AlertWhenImminent` and `NoAlertWhenNotImminent` to simulate events coming
    off the service bus. It gives the unit tests a nice, clean, succinct feel, even
    though there’s a lot of mocking logic going on behind the scenes. Remember, you
    don’t even require a working service bus to do all this testing!
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 在`StrictAutoBrakeTest`的定义中，你可以看到使用`WillOnce`/`Invoke`方法保存每个订阅的回调 ➌➍。这些回调用于`AlertWhenImminent`和`NoAlertWhenNotImminent`，以模拟来自服务总线的事件。即使在后台有大量的模拟逻辑，这也使单元测试看起来简洁、清晰且简短。记住，你甚至不需要一个正常工作的服务总线来进行所有这些测试！
- en: '***HippoMocks***'
  id: totrans-513
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***HippoMocks***'
- en: Google Mock is one of the original C++ mocking frameworks, and it’s still a
    mainstream choice today. HippoMocks is an alternative mocking framework created
    by Peter Bindels. As a header-only library, HippoMocks is trivial to install.
    Simply pull down the latest version from GitHub ([https://github.com/dascandy/hippomocks/](https://github.com/dascandy/hippomocks/)).
    You must include the `"hippomocks.h"` header in your tests. HippoMocks will work
    with any testing framework.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: Google Mock是最早的C++模拟框架之一，至今仍是主流选择。HippoMocks是由Peter Bindels创建的一个替代性模拟框架。作为一个仅包含头文件的库，HippoMocks的安装非常简单。只需从GitHub拉取最新版本（[https://github.com/dascandy/hippomocks/](https://github.com/dascandy/hippomocks/)）。你必须在你的测试中包含`"hippomocks.h"`头文件。HippoMocks可以与任何测试框架一起使用。
- en: '**NOTE**'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*At press time, the latest version of HippoMocks is v5.0.*'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '*截至发稿时，HippoMocks的最新版本是v5.0。*'
- en: 'To create a mock using HippoMocks, you start by instantiating a `MockRespository`
    object. By default, all the mocks derived from this `MockRepository` will require
    *strict ordering* of expectations. Strictly ordered expectations cause a test
    to fail if each of the expectations is not invoked in the exact order you’ve specified.
    Usually, this is not what you want. To modify this default behavior, set the `autoExpect`
    field on `MockRepository` to `false`:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用HippoMocks创建模拟对象，首先需要实例化一个`MockRespository`对象。默认情况下，所有从这个`MockRepository`派生的模拟对象都需要*严格的顺序*期望。如果每个期望没有按你指定的确切顺序被调用，测试将会失败。通常，这不是你想要的。要修改这种默认行为，可以将`MockRepository`上的`autoExpect`字段设置为`false`：
- en: '[PRE87]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Now you can use `MockRepository` to generate a mock of `IServiceBus`. This
    is done through the (member) function template `Mock`. This function will return
    a pointer to your newly minted mock:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以使用`MockRepository`来生成`IServiceBus`的一个模拟对象。这是通过（成员）函数模板`Mock`完成的。这个函数将返回一个指向你新创建的模拟对象的指针：
- en: '[PRE88]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'A major selling point of `HippoMocks` is illustrated here: notice that you
    didn’t need to generate any macro-laden boilerplate for the mock `IServiceBus`
    like you did for Google Mock. The framework can handle vanilla interfaces without
    any further effort on your part.'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '`HippoMocks`的一个主要卖点在这里得到了展示：注意你不需要像使用Google Mock那样生成任何宏化的样板代码来模拟`IServiceBus`。该框架可以处理普通接口，无需你额外的努力。'
- en: 'Setting up expectations is very straightforward as well. For this, use the
    `ExpectCall` macro on `MockRespository`. The `ExpectCall` macro takes two parameters:
    a pointer to your mock and a pointer to the method you’re expecting:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 设置期望也非常简单。为此，请在`MockRespository`上使用`ExpectCall`宏。`ExpectCall`宏接受两个参数：一个指向你模拟对象的指针和一个指向你期望的方法的指针：
- en: '[PRE89]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: This example adds an expectation that `bus.subscribe_to_speed` will be invoked.
    You have several matchers you can add to this expectation, as summarized in [Table
    10-4](ch10.xhtml#ch10tab04).
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例添加了一个期望，即`bus.subscribe_to_speed`将被调用。你可以向此期望添加几个匹配器，具体如[表10-4](ch10.xhtml#ch10tab04)所总结。
- en: '**Table 10-4:** HippoMocks Matchers'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10-4：** HippoMocks 匹配器'
- en: '| **Matcher** | **Specifies that an expectation matches when . . .** |'
  id: totrans-526
  prefs: []
  type: TYPE_TB
  zh: '| **匹配器** | **指定期望匹配的条件 . . .** |'
- en: '| `With`(args) | The invocation parameters match `*args*` |'
  id: totrans-527
  prefs: []
  type: TYPE_TB
  zh: '| `With`(args) | 调用参数与`*args*`匹配 |'
- en: '| `Match`(predicate) | `*predicate*` invoked with the invocation parameters
    returns true |'
  id: totrans-528
  prefs: []
  type: TYPE_TB
  zh: '| `Match`(predicate) | 用调用参数调用`*predicate*`时返回 true |'
- en: '| `After`(expectation) | `*expectation*` has already been satisfied (This is
    useful for referring to a previously registered call.) |'
  id: totrans-529
  prefs: []
  type: TYPE_TB
  zh: '| `After`(expectation) | `*expectation*` 已经满足（这对引用先前注册的调用很有用。） |'
- en: You can define actions to perform in response to `ExpectCall`, as summarized
    in [Table 10-5](ch10.xhtml#ch10tab05).
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义在响应`ExpectCall`时执行的操作，详情请见[表 10-5](ch10.xhtml#ch10tab05)。
- en: '**Table 10-5:** HippoMocks Actions'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10-5：** HippoMocks 操作'
- en: '| **Action** | **Does the following upon invocation:** |'
  id: totrans-532
  prefs: []
  type: TYPE_TB
  zh: '| **Action** | **在调用时执行以下操作：** |'
- en: '| `Return`(value) | Returns `*value*` to the caller |'
  id: totrans-533
  prefs: []
  type: TYPE_TB
  zh: '| `Return`(value) | 返回 `*value*` 给调用者 |'
- en: '| `Throw`(exception) | Throws `*exception*` |'
  id: totrans-534
  prefs: []
  type: TYPE_TB
  zh: '| `Throw`(exception) | 抛出`*exception*` |'
- en: '| `Do`(callable) | Executes `*callable*` with the invocation parameters |'
  id: totrans-535
  prefs: []
  type: TYPE_TB
  zh: '| `Do`(callable) | 使用调用参数执行`*callable*` |'
- en: By default, HippoMocks requires an expectation to be met exactly once (like
    Google Mock’s `.Times(1)` cardinality).
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，HippoMocks 要求期望准确地满足一次（类似于 Google Mock 的 `.Times(1)` 基数）。
- en: 'For example, you can express the expectation that `publish` is called with
    a `BrakeCommand` having a `time_to_collision_s` of `1.0` in the following way:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以通过以下方式表达期望，即 `publish` 被调用时，`BrakeCommand` 的 `time_to_collision_s` 为 `1.0`：
- en: '[PRE90]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: You use `ExpectCall` to specify that `bus` should be called with the `publish`
    method ➊. You refine this expectation with the `Match` matcher ➋, which takes
    a predicate accepting the same arguments as the `publish` method—a single `const
    BrakeCommand` reference. You return `true` if the `time_to_collision_s` field
    of the `BrakeCommand` is 1.0; otherwise, you return `false` ➌, which is fully
    compatible.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`ExpectCall`来指定`bus`应该使用`publish`方法被调用 ➊。你通过`Match`匹配器 ➋来细化这个期望，`Match`接受一个谓词，该谓词接受与`publish`方法相同的参数——一个`const
    BrakeCommand`引用。如果`BrakeCommand`的`time_to_collision_s`字段为1.0，你返回`true`；否则，你返回`false`
    ➌，这是完全兼容的。
- en: '**NOTE**'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*As of v5.0, HippoMocks doesn’t have built-in support for approximate matchers.
    Instead, Catch’s `Approx` ➌ was used.*'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '*从 v5.0 版本开始，HippoMocks 不再内置支持近似匹配器。相反，使用了 Catch 的 `Approx` ➌。*'
- en: 'HippoMocks supports function overloads for free functions. It also supports
    overloads for methods, but the syntax is not very pleasing to the eye. If you
    are using HippoMocks, it is best to avoid method overloads in your interface,
    so it would be better to refactor `IServiceBus` along the following lines:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: HippoMocks 支持自由函数的函数重载。它也支持方法的重载，但语法不太美观。如果你使用 HippoMocks，最好避免在接口中使用方法重载，因此最好按以下方式重构
    `IServiceBus`：
- en: '[PRE91]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '**NOTE**'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*One design philosophy states that it’s undesirable to have an overloaded method
    in an interface, so if you subscribe to that philosophy, the lack of support in
    HippoMocks is a moot point.*'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '*有一种设计哲学认为，接口中不应有重载方法，因此如果你认同这一点，那么 HippoMocks 不支持重载方法的问题就不再重要了。*'
- en: Now `subscribe` is no longer overloaded, and it’s possible to use HippoMocks.
    [Listing 10-55](ch10.xhtml#ch10ex55) refactors the test suite to use HippoMocks
    with Catch.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`subscribe`不再是重载的，可以使用 HippoMocks。[列表 10-55](ch10.xhtml#ch10ex55)重构了测试套件，使用
    HippoMocks 与 Catch。
- en: '[PRE92]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '*Listing 10-55: Reimplementing [Listing 10-54](ch10.xhtml#ch10ex54) to use
    HippoMocks and Catch rather than Google Mock and Google Test.*'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-55：重新实现[列表 10-54](ch10.xhtml#ch10ex54)，使用 HippoMocks 和 Catch，而不是 Google
    Mock 和 Google Test。*'
- en: '**NOTE**'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*This section couples HippoMocks with Catch for demonstration purposes, but
    HippoMocks works with all the unit-testing frameworks discussed in this chapter.*'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '*本节将 HippoMocks 与 Catch 配合使用以进行演示，但 HippoMocks 与本章讨论的所有单元测试框架都兼容。*'
- en: You create the `MockRepository` ➊ and relax the strict ordering requirements
    by setting `autoExpect` to `false`. After declaring the two callbacks, you create
    an `IServiceBusMock` (without having to define a mock class!), and then set expectations
    ➋➌ that will hook up your callback functions with `AutoBrake`. Finally, you create
    `auto_brake` using a reference to the mock bus.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建了 `MockRepository` ➊，并通过设置 `autoExpect` 为 `false` 来放宽严格的调用顺序要求。在声明了两个回调函数后，你创建了一个
    `IServiceBusMock`（无需定义模拟类！），然后设置期望 ➋➌，这些期望将把你的回调函数与 `AutoBrake` 关联起来。最后，你使用对模拟总线的引用创建
    `auto_brake`。
- en: The `initializes speed to zero, initializes sensitivity to five`, and `throws
    when sensitivity less than one` tests require no further interaction with the
    mock. In fact, as a strict mock, `bus` won’t let any further interactions happen
    without complaining. Because HippoMocks doesn’t allow nice mocks like Google Mock,
    this is actually a fundamental difference between [Listing 10-54](ch10.xhtml#ch10ex54)
    and [Listing 10-55](ch10.xhtml#ch10ex55).
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '`initializes speed to zero, initializes sensitivity to five`和`throws when sensitivity
    less than one`测试不需要与模拟进行进一步交互。事实上，作为一个严格模拟，`bus`不会让任何进一步的交互发生，而不会抱怨。由于HippoMocks不允许像Google
    Mock那样的友好模拟，这实际上是[Listing 10-54](ch10.xhtml#ch10ex54)和[Listing 10-55](ch10.xhtml#ch10ex55)之间的一个根本区别。'
- en: In the `saves speed after update` test ➍, you issue a series of `speed_update`
    callbacks and assert that the speeds are saved off correctly as before. Because
    `bus` is a strict mock, you’re also implicitly asserting that no further interaction
    happens with the service bus here.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 在`saves speed after update`测试 ➍中，你发出一系列`speed_update`回调，并像之前一样断言速度被正确保存。因为`bus`是一个严格模拟，你也在隐式地断言没有与服务总线的进一步交互发生。
- en: In the `no alert when not imminent` test, no changes are needed to `speed_update_callback`
    ➎. Because the mock is strict (and you don’t expect a `BrakeCommand` to get published),
    no further expectations are needed.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 在`no alert when not imminent`测试中，无需对`speed_update_callback` ➎做任何更改。因为模拟是严格的（且你不期望发布`BrakeCommand`），因此无需其他期望。
- en: '**NOTE**'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*HippoMocks offers the `NeverCall` method on its mocks, which will improve
    the clarity of your tests and errors if it’s called.*'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '*HippoMocks为其模拟提供了`NeverCall`方法，如果被调用，将提高测试和错误的清晰度。*'
- en: 'However, in the `alert when imminent` test, you expect that your program will
    invoke `publish` on a `BrakeCommand`, so you set up this expectation ➏. You use
    the `Match` matcher to provide a predicate that checks for `time_to_collision_s`
    to equal approximately `1`. The rest of the test is as before: you send `AutoBrake`
    a `SpeedUpdate` event and a subsequent `CarDetected` event that should cause a
    collision to be detected.'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在`alert when imminent`测试中，你期望程序会在`BrakeCommand`上调用`publish`，因此你设置了这个期望 ➏。你使用`Match`匹配器提供一个谓词，用于检查`time_to_collision_s`是否大约等于`1`。测试的其余部分与之前相同：你向`AutoBrake`发送`SpeedUpdate`事件和随后的`CarDetected`事件，这应导致检测到碰撞。
- en: HippoMocks is a more streamlined mocking framework than Google Mock is. It requires
    far less ceremony, but it’s a little less flexible.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: HippoMocks是一个比Google Mock更精简的模拟框架。它需要的额外设置较少，但灵活性稍差。
- en: '**NOTE**'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*One area where HippoMocks is *more* flexible than Google Mock is in mocking
    free functions. HippoMocks can mock free functions and static class functions
    directly, whereas Google Mock requires you to rewrite the code to use an interface.*'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '*HippoMocks在模拟自由函数方面比Google Mock更灵活。HippoMocks可以直接模拟自由函数和静态类函数，而Google Mock则要求你重写代码以使用接口。*'
- en: '***A Note on Other Mocking Options: FakeIt and Trompeloeil***'
  id: totrans-561
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***关于其他模拟选项的说明：FakeIt和Trompeloeil***'
- en: 'A number of other excellent mocking frameworks are available. But for the sake
    of keeping an already long chapter from getting much longer, let’s briefly look
    at two more frameworks: FakeIt (by Eran Pe’er, available at *[https://github.com/eranpeer/FakeIt/](https://github.com/eranpeer/FakeIt/)*)
    and Trompeloeil (by Björn Fahller, available at *[https://github.com/rollbear/trompeloeil/](https://github.com/rollbear/trompeloeil/)*).'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他优秀的模拟框架可用。为了避免这一长章节变得更加冗长，让我们简要地看一下另外两个框架：FakeIt（由Eran Pe’er开发，可在*[https://github.com/eranpeer/FakeIt/](https://github.com/eranpeer/FakeIt/)*找到）和Trompeloeil（由Björn
    Fahller开发，可在*[https://github.com/rollbear/trompeloeil/](https://github.com/rollbear/trompeloeil/)*找到）。
- en: FakeIt is similar to HippoMocks in its succinct usage patterns, and it’s a header-only
    library. It differs in that it follows the record-by-default pattern in building
    expectations. Rather than specifying expectations up front, FakeIt verifies that
    a mock’s methods were invoked correctly at the *end* of the test. Actions, of
    course, are still specified at the beginning.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: FakeIt在使用模式上与HippoMocks相似，并且它是一个仅包含头文件的库。不同之处在于，它在构建期望时遵循默认记录模式。FakeIt并不像指定期望那样一开始就明确，而是在测试*结束*时验证模拟方法是否正确调用。当然，操作仍然需要在开始时指定。
- en: Although this is a totally valid approach, I prefer the Google Mock/HippoMocks
    approach of specifying expectations—and their associated actions—all up front
    in one concise location.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种方法完全有效，我更喜欢Google Mock/HippoMocks的方法，即在一个简洁的位置提前指定所有期望及其相关操作。
- en: Trompeloeil (from the French *trompe-l’œil* for “deceive the eye”) can be considered
    a modern replacement for Google Mock. Like Google Mock, it requires some macro-laden
    boilerplate for each of the interfaces you want to mock. In exchange for this
    extra effort, you gain many powerful features, including actions, such as setting
    test variables, returning values based on invocation parameters, and forbidding
    particular invocations. Like Google Mock and HippoMocks, Trompeloeil requires
    you to specify your expectations and actions up front (see the documentation for
    more details).
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: Trompeloeil（来自法语 *trompe-l’œil*，意为“欺骗眼睛”）可以被视为 Google Mock 的现代替代品。与 Google Mock
    类似，它需要为每个要模拟的接口编写一些宏定义的模板代码。作为对这些额外工作的回报，您将获得许多强大的功能，包括动作，例如设置测试变量、根据调用参数返回值以及禁止特定的调用。与
    Google Mock 和 HippoMocks 一样，Trompeloeil 需要您提前指定期望和操作（更多细节请参见文档）。
- en: '**Summary**'
  id: totrans-566
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**摘要**'
- en: This chapter used an extended example of building the automatic braking system
    for an autonomous vehicle to explore the basics of TDD. You rolled your own testing
    and mocking framework, then learned about the many benefits of using available
    testing and mocking frameworks. You toured Catch, Google Test, and Boost Test
    as possible testing frameworks. For mocking frameworks, you dove into Google Mock
    and HippoMocks (with a brief mention of FakeIt and Trompeloeil). Each of these
    frameworks has strengths and weaknesses. Which you choose should be driven principally
    by which frameworks make you most efficient and productive.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过扩展的自动驾驶车辆自动制动系统构建示例，探索了 TDD 的基础知识。您自己编写了测试和模拟框架，然后了解了使用现有测试和模拟框架的许多好处。您了解了
    Catch、Google Test 和 Boost Test 作为可能的测试框架。对于模拟框架，您深入了解了 Google Mock 和 HippoMocks（简要提及了
    FakeIt 和 Trompeloeil）。每个框架都有其优缺点。选择哪个框架，主要应该由哪个框架能使您工作更高效和富有成效来决定。
- en: '**NOTE**'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For the remainder of the book, examples will be couched in terms of unit tests.
    Accordingly, I had to choose a framework for the examples. I’ve chosen Catch for
    a few reasons. First, Catch’s syntax is the most succinct, and it lends itself
    well to book form. In header-only mode, Catch compiles much quicker than Boost
    Test. This might be considered an endorsement of the framework (and it is), but
    it’s not my intention to discourage the use of Google Test, Boost Test, or any
    other testing framework. You should make such decisions after careful consideration
    (and hopefully some experimentation.)*'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本书的其余部分，示例将以单元测试的形式进行。因此，我必须为这些示例选择一个框架。我选择了 Catch，有几个原因。首先，Catch 的语法最简洁，且非常适合书籍形式。以头文件模式编译时，Catch
    比 Boost Test 编译得更快。这可以被视为对该框架的推荐（是的，它是），但我的目的是不鼓励使用 Google Test、Boost Test 或其他任何测试框架。您应该在仔细考虑（并且希望有些实验）的基础上做出这样的决策。*'
- en: '**EXERCISES**'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '**10-1.** Your car company has completed work on a service that detects speed
    limits based on signage it observes on the side of the road. The speed-limit-detection
    team will publish objects of the following type to the event bus periodically:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '**10-1.** 您的汽车公司已经完成了一个服务的开发，该服务基于观察到的路边标志来检测限速。限速检测团队将定期向事件总线发布以下类型的对象：'
- en: '[PRE93]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The service bus has been extended to incorporate this new type:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 服务总线已扩展以包含这种新类型：
- en: '[PRE94]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Update the service with the new interface and make sure the tests still pass.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 更新服务以支持新接口，并确保测试仍然通过。
- en: '**10-2.** Add a private field for the last known speed limit. Implement a getter
    method for this field.'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '**10-2.** 为最后已知的速度限制添加一个私有字段。实现一个该字段的 getter 方法。'
- en: '**10-3.** The product owner wants you to initialize the last known speed limit
    to 39 meters per second. Implement a unit test that checks a newly constructed
    AutoBrake that has a last known speed limit of 39.'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '**10-3.** 产品负责人希望您将最后已知的速度限制初始化为 39 米每秒。实现一个单元测试，检查一个新构建的 AutoBrake 对象，该对象的最后已知速度限制为
    39。'
- en: '**10-4.** Make unit tests pass.'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '**10-4.** 使单元测试通过。'
- en: '**10-5.** Implement a unit test where you publish three different `SpeedLimitDetected`
    objects using the same callback technique you used for `SpeedUpdate` and `CarDetected`.
    After invoking each of the callbacks, check the last known speed limit on the
    `AutoBrake` object to ensure it matches.'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '**10-5.** 实现一个单元测试，在该测试中，使用与 `SpeedUpdate` 和 `CarDetected` 相同的回调技术发布三个不同的 `SpeedLimitDetected`
    对象。调用每个回调后，检查 `AutoBrake` 对象上最后已知的速度限制，以确保其匹配。'
- en: '**10-6.** Make all unit tests pass.'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '**10-6.** 使所有单元测试通过。'
- en: '**10-7.** Implement a unit test where the last known speed limit is 35 meters
    per second, and you’re traveling at 34 meters per second. Ensure that no `BrakeCommand`
    is published by `AutoBrake`.'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '**10-7.** 实现一个单元测试，其中最后已知的速度限制是每秒35米，且当前速度为每秒34米。确保`AutoBrake`没有发布任何`BrakeCommand`。'
- en: '**10-8.** Make all unit tests pass.'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '**10-8.** 确保所有单元测试都通过。'
- en: '**10-9.** Implement a unit test where the last known speed limit is 35 meters
    per second and then publish a `SpeedUpdate` at 40 meters per second. Ensure that
    exactly one `BrakeCommand` is issued. The `time_to_collision_s` field should equal
    0.'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '**10-9.** 实现一个单元测试，其中最后已知的速度限制是每秒35米，然后发布一个速度更新`SpeedUpdate`，速度为每秒40米。确保只发布一个`BrakeCommand`。`time_to_collision_s`字段应等于0。'
- en: '**10-10.** Make all unit tests pass.'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '**10-10.** 确保所有单元测试都通过。'
- en: '**10-11.** Implement a new unit test where the last known speed limit is 35
    meters per second and then publish a `SpeedUpdate` at 30 meters per second. Then
    issue a `SpeedLimitDetected` with a `speed_mps` of 25 meters per second. Ensure
    that exactly one `BrakeCommand` is issued. The `time_to_collision_s` field should
    equal 0.'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '**10-11.** 实现一个新的单元测试，其中最后已知的速度限制是每秒35米，然后发布一个速度更新`SpeedUpdate`，速度为每秒30米。然后发布一个`SpeedLimitDetected`，其`speed_mps`为每秒25米。确保只发布一个`BrakeCommand`。`time_to_collision_s`字段应等于0。'
- en: '**10-12.** Make all unit tests pass.'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '**10-12.** 确保所有单元测试都通过。'
- en: '**FURTHER READING**'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: '*Specification by Example* by Gojko Adzic (Manning, 2011)'
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过实例规范* 由Gojko Adzic著（Manning, 2011）'
- en: '*BDD in Action* by John Ferguson Smart (Manning, 2014)'
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*BDD实践* 由John Ferguson Smart著（Manning, 2014）'
- en: '*Optimized C++: Proven Techniques for Heightened Performance* by Kurt Guntheroth
    (O’Reilly, 2016)'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*优化C++：提高性能的有效技术* 由Kurt Guntheroth著（O’Reilly, 2016）'
- en: '*Agile Software Development and Agile Principles, Patterns, and Practices in
    C#* by Robert C. Martin (Prentice Hall, 2006)'
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*敏捷软件开发与敏捷原则、模式与实践（C#实现）* 由Robert C. Martin著（Prentice Hall, 2006）'
- en: '*Test-Driven Development: By Example* by Kent Beck (Pearson, 2002)'
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*测试驱动开发：通过实例* 由Kent Beck著（Pearson, 2002）'
- en: '*Growing Object-Oriented Software, Guided by Tests* by Steve Freeman and Nat
    Pryce (Addison-Wesley, 2009)'
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*引导测试的面向对象软件开发* 由Steve Freeman和Nat Pryce著（Addison-Wesley, 2009）'
- en: “Editor war.” *[https://en.wikipedia.org/wiki/Editor_war](https://en.wikipedia.org/wiki/Editor_war)*
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “编辑器之战。” *[https://en.wikipedia.org/wiki/Editor_war](https://en.wikipedia.org/wiki/Editor_war)*
- en: '“Tabs versus Spaces: An Eternal Holy War” by Jamie Zawinski. *[https://www.jwz.org/doc/tabs-vs-spaces.html](https://www.jwz.org/doc/tabs-vs-spaces.html)*'
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “制表符与空格：永恒的圣战” 由Jamie Zawinski著。 *[https://www.jwz.org/doc/tabs-vs-spaces.html](https://www.jwz.org/doc/tabs-vs-spaces.html)*
- en: “Is TDD dead?” by Martin Fowler. *[https://martinfowler.com/articles/is-tdd-dead/](https://martinfowler.com/articles/is-tdd-dead/)*
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “TDD死了吗？” 由Martin Fowler著。 *[https://martinfowler.com/articles/is-tdd-dead/](https://martinfowler.com/articles/is-tdd-dead/)*
