- en: '**4**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**4**'
- en: '**NON-NUMERIC VALUES**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**非数值类型**'
- en: '![image](../images/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common-01.jpg)'
- en: 'So far, you’ve been working almost exclusively with numeric values. But statistical
    programming also requires non-numeric values. In this chapter, we’ll consider
    three important non-numeric data types: logicals, characters, and factors. These
    data types play an important role in effective use of R, especially as we get
    into more complex R programming in [Part II](part02.xhtml#part02).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你几乎只在处理数值类型。但统计编程也需要非数值类型。在本章中，我们将考虑三种重要的非数值数据类型：逻辑值、字符和因子。这些数据类型在有效使用
    R 时起着重要作用，特别是当我们进入[第二部分](part02.xhtml#part02)的更复杂的 R 编程时。
- en: '**4.1 Logical Values**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**4.1 逻辑值**'
- en: 'Logical values (also simply called *logicals*) are based on a simple premise:
    a logical-valued object can only be either `TRUE` or `FALSE`. These can be interpreted
    as yes/no, one/zero, satisfied/not satisfied, and so on. This is a concept that
    appears across all programming languages, and logical values have many important
    uses. Often, they signal whether a condition has been satisfied or whether a parameter
    should be switched on or off.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑值（也叫做*逻辑型*）基于一个简单的前提：逻辑值对象只能是`TRUE`或`FALSE`。这些可以解释为是/否、1/0、满足/不满足，等等。这是一个出现在所有编程语言中的概念，逻辑值有许多重要的用途。通常，它们用来表示某个条件是否已满足，或者某个参数是否应该开启或关闭。
- en: You encountered logical values briefly when you used the `sort` function in
    [Section 2.3.2](ch02.xhtml#ch02lev2sec21) and the `matrix` function in [Section
    3.1](ch03.xhtml#ch03lev1sec12). When using `sort`, setting `decreasing=TRUE` returns
    a vector ordered from largest to smallest, and `decreasing=FALSE` sorts the vector
    the other way around. Similarly, when constructing a matrix, `byrow=TRUE` fills
    the matrix entries row-wise; otherwise, the matrix is filled column-wise. Now,
    you’ll take a more detailed look at ways to use logicals.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你在使用[第 2.3.2 节](ch02.xhtml#ch02lev2sec21)中的`sort`函数和[第 3.1 节](ch03.xhtml#ch03lev1sec12)中的`matrix`函数时，简要地接触过逻辑值。在使用`sort`时，设置`decreasing=TRUE`返回一个从大到小排序的向量，`decreasing=FALSE`则将向量按相反顺序排序。类似地，在构造矩阵时，`byrow=TRUE`按行填充矩阵条目；否则，矩阵按列填充。现在，我们将更详细地探讨如何使用逻辑值。
- en: '***4.1.1 TRUE or FALSE?***'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***4.1.1 TRUE 还是 FALSE？***'
- en: Logical values in R are written fully as `TRUE` and `FALSE`, but they are frequently
    abbreviated as `T` or `F`. The abbreviated version has no effect on the execution
    of the code, so, for example, using `decreasing=T` is equivalent to `decreasing=TRUE`
    in the `sort` function. (But do not create objects named `T` or `F` if you want
    to make use of this convenience—see [Section 9.1.3](ch09.xhtml#ch09lev2sec81).)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 'R 中的逻辑值完全写作`TRUE`和`FALSE`，但通常缩写为`T`或`F`。缩写版对代码执行没有影响，因此，例如，使用`decreasing=T`与在`sort`函数中使用`decreasing=TRUE`等效。（但是，如果你想利用这种便捷性，千万不要创建名为`T`或`F`的对象——参见[第
    9.1.3 节](ch09.xhtml#ch09lev2sec81)）。 '
- en: Assigning logical values to an object is the same as assigning numeric values.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 将逻辑值赋给一个对象与赋给数值相同。
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This gives you one object with the value `TRUE` and one with the value `FALSE`.
    Similarly, vectors can be filled with logical values.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给你一个值为`TRUE`的对象和一个值为`FALSE`的对象。类似地，向量也可以用逻辑值填充。
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Matrices (and other higher-dimensional arrays) can be created with these values
    too. Using `foo` and `baz` from earlier, you could construct something like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵（和其他高维数组）也可以用这些值创建。使用之前的`foo`和`baz`，你可以构造类似这样的内容：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***4.1.2 A Logical Outcome: Relational Operators***'
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***4.1.2 逻辑结果：关系运算符***'
- en: Logicals are commonly used to check relationships between values. For example,
    you might want to know whether some number *a* is greater than a predefined threshold
    *b*. For this, you use the standard *relational operators* shown in [Table 4-1](ch04.xhtml#ch4tab1),
    which produce logical values as results.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑值通常用于检查值之间的关系。例如，你可能想知道某个数字*a*是否大于预定义的阈值*b*。为此，你可以使用[表 4-1](ch04.xhtml#ch4tab1)中显示的标准*关系运算符*，它们的结果是逻辑值。
- en: '**Table 4-1:** Relational Operators'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-1：** 关系运算符'
- en: '| **Operator** | **Interpretation** |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **解释** |'
- en: '| --- | --- |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `==` | Equal to |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `==` | 等于 |'
- en: '| `!=` | Not equal to |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `!=` | 不等于 |'
- en: '| `>` | Greater than |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `>` | 大于 |'
- en: '| `<` | Less than |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `<` | 小于 |'
- en: '| `>=` | Greater than or equal to |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `>=` | 大于或等于 |'
- en: '| `<=` | Less than or equal to |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `<=` | 小于或等于 |'
- en: 'Typically, these operators are used on numeric values (though you’ll look at
    some other possibilities in [Section 4.2.1](ch04.xhtml#ch04lev2sec42)). Here’s
    an example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这些操作符用于数值型数据（尽管你将在[第 4.2.1 节](ch04.xhtml#ch04lev2sec42)中查看其他可能性）。这里是一个例子：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The results should be unsurprising: `1` being equal to `2` is `FALSE` and `1`
    being greater than `2` is also `FALSE`, while the result of `2-1` being less than
    or equal to `2` is `TRUE` and it is also `TRUE` that `1` is not equal to `5` (`2+3`).
    These kinds of operations are much more useful when used on numbers that are variable
    in some way, as you’ll see shortly.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该不令人惊讶：`1` 等于 `2` 是 `FALSE`，而 `1` 大于 `2` 也是 `FALSE`，但 `2-1` 小于或等于 `2` 的结果是
    `TRUE`，同样，`1` 不等于 `5`（`2+3`）也是 `TRUE`。这种类型的操作在处理某些方式可变的数字时更加有用，正如你稍后会看到的那样。
- en: You’re already familiar with R’s element-wise behavior when working with vectors.
    The same rules apply when using relational operators. To illustrate this, let’s
    first create two vectors and double-check that they’re of equal length.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用向量时，R 的按元素行为你已经很熟悉。当使用关系运算符时，规则相同。为了说明这一点，让我们先创建两个向量，并再次检查它们的长度是否相等。
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now consider the following four evaluations:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑以下四个评估：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first line checks whether the entries in `foo` are equal to the corresponding
    entries in `bar`, which is true only for the fifth and ninth entries. The returned
    vector will contain a logical result for each pair of elements, so it will be
    the same length as the vectors being compared. The second line compares `foo`
    and `bar` in the same way, this time checking whether the entries in `foo` are
    less than the entries in `bar`. Contrast this result with the third comparison,
    which asks whether entries are less than *or equal to* one another. Finally, the
    fourth line checks whether `foo`’s members are less than or equal to `bar`, when
    the elements of `bar` are increased by `10`. Naturally, the results are all `TRUE`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行检查 `foo` 中的条目是否等于 `bar` 中的对应条目，只有第 5 和第 9 个条目为 `TRUE`。返回的向量将包含每对元素的逻辑结果，因此它将与正在比较的向量长度相同。第二行以相同的方式比较
    `foo` 和 `bar`，这次检查 `foo` 中的条目是否小于 `bar` 中的条目。与第三个比较结果对比，第三个比较检查条目是否小于*或等于*彼此。最后，第四行检查
    `foo` 的成员是否小于或等于 `bar`，当 `bar` 的元素增加 `10` 时。自然地，结果都是 `TRUE`。
- en: Vector recycling also applies to logicals. Let’s use `foo` from earlier, along
    with a shorter vector, `baz`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 向量回收也适用于逻辑值。我们使用之前的 `foo`，以及一个较短的向量 `baz`。
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here you create `baz` as a vector of length 2 comprised of the 10th and 3rd
    elements of `foo`. Now consider the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你创建了 `baz`，它是一个长度为 2 的向量，包含了 `foo` 的第 10 和第 3 个元素。现在考虑以下内容：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, the two elements of `baz` are recycled and checked against the 10 elements
    of `foo`. Elements `1` and `2` of `foo` are checked against `1` and `2` of `baz`,
    elements `3` and `4` of `foo` are checked against `1` and `2` of `baz`, and so
    on. You can also check all the values of a vector against a single value. Here’s
    an example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`baz` 的两个元素会被回收，并与 `foo` 的 10 个元素进行比较。`foo` 的第 1 和第 2 个元素与 `baz` 的第 1 和第
    2 个元素进行比较，`foo` 的第 3 和第 4 个元素与 `baz` 的第 1 和第 2 个元素进行比较，依此类推。你也可以将向量的所有值与单一值进行比较。这里是一个例子：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is a typical operation when handling data sets in R.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 R 中处理数据集时的典型操作。
- en: Now let’s rewrite the contents of `foo` and `bar` as 5 × 2 column-filled matrices.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将 `foo` 和 `bar` 的内容重写为一个 5 × 2 的列填充矩阵。
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The same element-wise behavior applies here; if you compare the matrices, you
    get a matrix of the same size filled with logicals.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里同样应用按元素行为；如果你比较矩阵，你将得到一个大小相同、填充了逻辑值的矩阵。
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This kind of evaluation also applies to arrays of more than two dimensions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这种评估也适用于多维数组。
- en: 'There are two useful functions you can use to quickly inspect a collection
    of logical values: `any` and `all`. When examining a vector, `any` returns `TRUE`
    if any of the logicals in the vector are `TRUE` and returns `FALSE` otherwise.
    The function `all` returns a `TRUE` only if *all* of the logicals are `TRUE`,
    and returns `FALSE` otherwise. As a quick example, let’s work with two of the
    logical vectors formed by the comparisons of `foo` and `bar` from the beginning
    of this section.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用两个有用的函数来快速检查逻辑值的集合：`any` 和 `all`。在检查一个向量时，如果向量中的任何一个逻辑值为 `TRUE`，则 `any`
    返回 `TRUE`，否则返回 `FALSE`。函数 `all` 只有在*所有*逻辑值都为 `TRUE` 时才返回 `TRUE`，否则返回 `FALSE`。作为一个快速示例，我们来处理在本节开头通过比较
    `foo` 和 `bar` 形成的两个逻辑向量。
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, the `qux` contains two `TRUE`s, and the rest are `FALSE`—so the result
    of `any` is of course `TRUE`, but the result of `all` is `FALSE`. Following the
    same rules, you get this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`qux` 包含两个 `TRUE`，其余为 `FALSE`——因此，`any` 的结果自然是 `TRUE`，但 `all` 的结果是 `FALSE`。按照相同的规则，你会得到以下结果：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `any` and `all` functions do the same thing for matrices and arrays of logical
    values.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`any` 和 `all` 函数对逻辑值的矩阵和数组执行相同的操作。'
- en: '**Exercise 4.1**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 4.1**'
- en: 'Store the following vector of 15 values as an object in your workspace: `c(6,9,7,3,6,7,9,6,3,6,6,7,1,9,1)`.
    Identify the following elements:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下包含 15 个值的向量存储为工作空间中的一个对象：`c(6,9,7,3,6,7,9,6,3,6,6,7,1,9,1)`。识别以下元素：
- en: Those equal to 6
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些等于 6 的元素
- en: Those greater than or equal to 6
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些大于或等于 6 的元素
- en: Those less than 6 + 2
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些小于 6 + 2 的元素
- en: Those not equal to 6
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些不等于 6 的元素
- en: 'Create a new vector from the one used in (a) by deleting its first three elements.
    With this new vector, fill a 2 × 2 × 3 array. Examine the array for the following
    entries:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从（a）中使用的向量创建一个新向量，通过删除其前 3 个元素。使用这个新向量，填充一个 2 × 2 × 3 的数组。检查数组中的以下条目：
- en: Those less than or equal to 6 divided by 2, plus 4
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些小于或等于 6 除以 2 后加 4 的元素
- en: Those less than or equal to 6 divided by 2, plus 4, *after* increasing every
    element in the array by 2
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些小于或等于 6 除以 2 后加 4 的元素，*在*将数组中的每个元素增加 2 后
- en: Confirm the specific locations of elements equal to 0 in the 10 × 10 identity
    matrix *I[10]* (see [Section 3.3](ch03.xhtml#ch03lev1sec14)).
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认在 10 × 10 单位矩阵 *I[10]* 中等于 0 的元素的具体位置（参见 [第 3.3 节](ch03.xhtml#ch03lev1sec14)）。
- en: Check whether *any* of the values of the logical arrays created in (b) are `TRUE`.
    If they are, check whether they are *all* `TRUE`.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查在（b）中创建的逻辑数组中的*任何*值是否为 `TRUE`。如果是，检查它们是否*全部*为 `TRUE`。
- en: By extracting the diagonal elements of the logical matrix created in (c), use
    `any` to confirm there are no `TRUE` entries.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过提取在（c）中创建的逻辑矩阵的对角元素，使用 `any` 来确认没有 `TRUE` 条目。
- en: '***4.1.3 Multiple Comparisons: Logical Operators***'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***4.1.3 多重比较：逻辑运算符***'
- en: Logicals are especially useful when you want to examine whether multiple conditions
    are satisfied. Often you’ll want to perform certain operations only if a number
    of different conditions have been met.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑值特别有用，当你想检查多个条件是否都满足时。通常，你希望只有在满足多个不同条件的情况下执行某些操作。
- en: The previous section looked at relational operators, used to compare the literal
    values (that is, numeric or otherwise) of stored R objects. Now you’ll look at
    *logical operators*, which are used to compare two `TRUE` or `FALSE` objects.
    These operators are based on the statements AND and OR. [Table 4-2](ch04.xhtml#ch4tab2)
    summarizes the R syntax and the behavior of logical operators. The AND and OR
    operators each have a “single” and “element-wise” version—you’ll see how they’re
    different in a moment.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节介绍了关系运算符，用于比较存储的 R 对象的字面值（即数值或其他）。现在，你将学习 *逻辑运算符*，它们用于比较两个 `TRUE` 或 `FALSE`
    对象。这些运算符基于 AND 和 OR 语句。[表 4-2](ch04.xhtml#ch4tab2) 总结了 R 语法和逻辑运算符的行为。AND 和 OR
    运算符各自有“单一”和“逐元素”版本——稍后你会看到它们的不同。
- en: '**Table 4-2:** Logical Operators Comparing Two Logical Values'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-2：** 比较两个逻辑值的逻辑运算符'
- en: '| **Operator** | **Interpretation** | **Results** |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **解释** | **结果** |'
- en: '| --- | --- | --- |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `&` | AND (element-wise) | `TRUE & TRUE` is `TRUE` `TRUE & FALSE` is `FALSE`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '| `&` | 与（逐元素） | `TRUE & TRUE` 为 `TRUE`，`TRUE & FALSE` 为 `FALSE` |'
- en: '`FALSE & TRUE` is `FALSE`'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`FALSE & TRUE` 为 `FALSE`'
- en: '`FALSE & FALSE` is `FALSE` |'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`FALSE & FALSE` 为 `FALSE` |'
- en: '| `&&` | AND (single comparison) | Same as `&` above |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `&&` | 与（单一比较） | 与上面的 `&` 相同 |'
- en: '| `&#124;` | OR (element-wise) | `TRUE&#124;TRUE` is `TRUE` `TRUE&#124;FALSE`
    is `TRUE`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '| `&#124;` | 或（逐元素） | `TRUE&#124;TRUE` 为 `TRUE`，`TRUE&#124;FALSE` 为 `TRUE`
    |'
- en: '`FALSE&#124;TRUE` is `TRUE`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`FALSE&#124;TRUE` 为 `TRUE`'
- en: '`FALSE&#124;FALSE` is `FALSE` |'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`FALSE&#124;FALSE` 为 `FALSE` |'
- en: '| `&#124;&#124;` | OR (single comparison) | Same as `&#124;` above |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;&#124;` | 或（单一比较） | 与上面的 `&#124;` 相同 |'
- en: '| `!` | NOT | `!TRUE` is `FALSE !FALSE` is `TRUE` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `!` | 非 | `!TRUE` 为 `FALSE`，`!FALSE` 为 `TRUE` |'
- en: The result of using any logical operator is a logical value. An AND comparison
    is true only if *both* logicals are `TRUE`. An OR comparison is true if at least
    one of the logicals is `TRUE`. The NOT operator (`!`) simply returns the opposite
    of the logical value it’s used on. You can combine these operators to examine
    multiple conditions at once.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用任何逻辑运算符的结果都是一个逻辑值。只有当*两个*逻辑值都为 `TRUE` 时，AND 比较才为真。当 OR 比较时，只要至少有一个逻辑值为 `TRUE`，结果就为真。NOT
    运算符（`!`）简单地返回它所作用的逻辑值的相反值。你可以将这些运算符组合起来，一次检查多个条件。
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As with numeric arithmetic, there is an order of importance for logical operations
    in R. An AND statement has a higher precedence than an OR statement. It’s helpful
    to place each comparative pair in parentheses to preserve the correct order of
    evaluation and make the code more readable. You can see this in the first line
    of this code, where the innermost comparison is the first to be carried out: `T&&TRUE`
    results in `TRUE`; this is then provided as one of the logical values for the
    next bracketed comparison where `TRUE||FALSE` results in `TRUE`. The final comparison
    is then `FALSE||TRUE`, and the result, `TRUE`, is printed to the console. The
    second line reads as NOT `TRUE` AND `TRUE`, which of course returns `FALSE`. In
    the third line, once again the innermost pair is evaluated first: `TRUE||F` is
    `TRUE`; `T&&TRUE` is `TRUE`; and finally `TRUE&&FALSE` is `FALSE`. The fourth
    and final example evaluates two distinct conditions in parentheses, which are
    then compared using a logical operator. Since `6<4` is `FALSE` and `3!=1` is `TRUE`,
    that gives you a logical comparison of `FALSE||TRUE` and a final result of `TRUE`.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 与数字算术一样，R中的逻辑运算也有优先级。AND语句的优先级高于OR语句。将每对比较项放入括号中有助于保留正确的运算顺序，并使代码更具可读性。你可以在这段代码的第一行看到这一点，其中最内层的比较是首先执行的：`T&&TRUE`的结果是`TRUE`；然后它作为下一个括号比较中的逻辑值之一参与计算，其中`TRUE||FALSE`的结果是`TRUE`。最后的比较是`FALSE||TRUE`，结果为`TRUE`，并打印到控制台。第二行表示NOT
    `TRUE` AND `TRUE`，结果当然是`FALSE`。在第三行，再次是最内层的配对首先被计算：`TRUE||F`为`TRUE`；`T&&TRUE`为`TRUE`；最后`TRUE&&FALSE`为`FALSE`。第四个也是最后一个例子比较了两个括号中的条件，然后使用逻辑运算符进行比较。由于`6<4`为`FALSE`，而`3!=1`为`TRUE`，所以得到逻辑比较`FALSE||TRUE`，最终结果是`TRUE`。
- en: In [Table 4-2](ch04.xhtml#ch4tab2), there is a short (`&`, `|`) and long (`&&`,
    `||`) version of the AND and OR operators. The short versions are meant for element-wise
    comparisons, where you have two logical vectors and you want multiple logicals
    as a result. The long versions, which you’ve been using so far, are meant for
    comparing two individual values and will return a single logical value. This is
    important when programming conditional checks in R in an `if` statement, which
    you’ll look at in [Chapter 10](ch10.xhtml#ch10). It’s possible to compare a single
    pair of logicals using the short version—though it’s considered better practice
    to use the longer versions when a single `TRUE`/`FALSE` result is needed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在[表 4-2](ch04.xhtml#ch4tab2)中，有AND和OR运算符的简短版本（`&`，`|`）和长版本（`&&`，`||`）。简短版本用于逐元素比较，其中你有两个逻辑向量，并且希望得到多个逻辑值作为结果。长版本，正如你到目前为止所使用的，是用于比较两个单独的值并返回单一逻辑值的。当你在R中编写条件判断语句时（在[第10章](ch10.xhtml#ch10)中会介绍），这是非常重要的。使用简短版本也可以比较一对逻辑值，尽管当只需要一个`TRUE`或`FALSE`结果时，通常推荐使用长版本。
- en: 'Let’s look at some examples of element-wise comparisons. Suppose you have two
    vectors of equal length, `foo` and `bar`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些逐元素比较的例子。假设你有两个等长的向量，`foo` 和 `bar`：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: and
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The short versions of the logical operators match each pair of elements by position
    and return the result of the comparison.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符的简短版本通过位置匹配每对元素，并返回比较的结果。
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Using the long version of the operators, on the other hand, means R carries
    out the comparison only on the first pair of logicals in the two vectors.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用运算符的长版本意味着R只对两个向量中的第一个逻辑对进行比较。
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice that the last two results match the first entries of the vectors you
    got using the short versions of the logical operators.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，最后两个结果与使用逻辑运算符简短版本得到的向量的第一个条目相匹配。
- en: '**Exercise 4.2**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 4.2**'
- en: Store the vector `c(7,1,7,10,5,9,10,3,10,8)` as `foo`. Identify the elements
    greater than 5 OR equal to 2.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将向量`c(7,1,7,10,5,9,10,3,10,8)`存储为`foo`。识别大于5或等于2的元素。
- en: Store the vector `c(8,8,4,4,5,1,5,6,6,8)` as `bar`. Identify the elements less
    than or equal to 6 AND not equal to 4.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将向量`c(8,8,4,4,5,1,5,6,6,8)`存储为`bar`。识别小于或等于6并且不等于4的元素。
- en: Identify the elements that satisfy (a) in `foo` AND satisfy (b) in `bar`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo`中识别满足（a）并且在`bar`中满足（b）的元素。
- en: 'Store a third vector called `baz` that is equal to the element-wise sum of
    `foo` and `bar`. Determine the following:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储一个名为`baz`的第三个向量，该向量等于`foo`和`bar`的逐元素和。确定以下内容：
- en: The elements of `baz` greater than or equal to 14 but not equal to 15
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`baz`中大于或等于14但不等于15的元素。'
- en: The elements of the vector obtained via an element-wise division of `baz` by
    `foo` that are greater than 4 OR less than or equal to 2
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过对`baz`除以`foo`进行逐元素除法得到的向量，其中元素大于4或小于等于2
- en: Confirm that using the long version in all of the preceding exercises performs
    only the first comparison (that is, the results each match the first entries of
    the previously obtained vectors).
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认在之前的所有练习中使用长版本时，只执行了第一个比较（即，结果与之前获得的向量的第一个条目相匹配）。
- en: '***4.1.4 Logicals Are Numbers!***'
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***4.1.4 逻辑值就是数字！***'
- en: Because of the binary nature of logical values, they’re often represented with
    `TRUE` as 1 and `FALSE` as 0\. In fact, in R, if you perform elementary numeric
    operations on logical values, `TRUE` is treated like `1`, and `FALSE` is treated
    like `0`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于逻辑值的二元性质，它们通常用`TRUE`表示为1，`FALSE`表示为0。实际上，在R中，如果对逻辑值进行基本的数值运算，`TRUE`会被当作`1`，而`FALSE`会被当作`0`。
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: These operations turn out the same as if you had used the digits 1 and 0\. In
    some situations when you’d use logicals, you can substitute the numeric values.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作的结果与直接使用数字1和0相同。在某些情况下，当你使用逻辑值时，可以用数字值来替代。
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Being able to interpret logicals as zeros and ones means you can use a variety
    of functions to summarize a logical vector, and you’ll explore this further in
    [Part III](part03.xhtml#part03).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 能够将逻辑值解释为零和一，意味着你可以使用多种函数来总结逻辑向量，你将在[第三部分](part03.xhtml#part03)中进一步探索这个问题。
- en: '***4.1.5 Logical Subsetting and Extraction***'
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***4.1.5 逻辑子集化和提取***'
- en: Logicals can also be used to extract and subset elements in vectors and other
    objects, in the same way as you’ve done so far with index vectors. Rather than
    entering explicit indexes in the square brackets, you can supply logical *flag*
    vectors, where an element is extracted if the corresponding entry in the flag
    vector is `TRUE`. As such, logical flag vectors should be the same length as the
    vector that’s being accessed (though recycling does occur for shorter flag vectors,
    as a later example shows).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑值也可以用于提取和子集化向量及其他对象中的元素，方式与之前使用索引向量相同。你可以用逻辑*标志*向量来替代显式索引，当标志向量中相应位置的值为`TRUE`时，该元素就会被提取。因此，逻辑标志向量应该与正在访问的向量具有相同的长度（不过，对于较短的标志向量，R会进行回收，如后面的示例所示）。
- en: 'At the beginning of [Section 2.3.3](ch02.xhtml#ch02lev2sec22) you defined a
    vector of length 10 as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2.3.3节](ch02.xhtml#ch02lev2sec22)的开头，你定义了一个长度为10的向量，如下所示：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you wanted to extract the two negative elements, you could either enter
    `myvec[c(2,10)]`, or you could do the following using logical flags:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想提取两个负数元素，可以输入`myvec[c(2,10)]`，或者你也可以使用逻辑标志来做如下操作：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This particular example may seem far too cumbersome for practical use. It becomes
    useful, however, when you want to extract elements based on whether they satisfy
    a certain condition (or several conditions). For example, you can easily use logicals
    to find negative elements in `myvec` by applying the condition `<0`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的例子可能看起来过于繁琐，难以在实际中使用。然而，当你想要基于某个条件（或多个条件）提取元素时，它会变得非常有用。例如，你可以轻松地使用逻辑值通过应用条件`<0`来找到`myvec`中的负数元素。
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This a perfectly valid flag vector that you can use to subset `myvec` to get
    the same result as earlier.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个完全有效的标志向量，你可以使用它对子集化`myvec`，并得到与之前相同的结果。
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As mentioned, R recycles the flag vector if it’s too short. To extract every
    second element from `myvec`, starting with the first, you could enter the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果标志向量太短，R会对其进行回收。要从`myvec`中提取每隔一个元素，从第一个元素开始，你可以输入以下内容：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can do more complicated extractions using relational and logical operators,
    such as:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用关系运算符和逻辑运算符进行更复杂的提取，例如：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This returns the positive elements that are less than 1,000\. You can also overwrite
    specific elements using a logical flag vector, just as with index vectors.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这会返回小于1,000的正数元素。你还可以像使用索引向量一样，使用逻辑标志向量来覆盖特定元素。
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This replaces all existing negative entries with −200\. Note, though, that you
    cannot directly use negative logical flag vectors to delete specific elements;
    this can be done only with numeric index vectors.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将所有现有的负值条目替换为−200。请注意，你不能直接使用负逻辑标志向量来删除特定的元素；只能使用数字索引向量来做到这一点。
- en: As you can see, logicals are therefore very useful for element extraction. You
    don’t need to know beforehand which specific index positions to return, since
    the conditional check can find them for you. This is particularly valuable when
    you’re dealing with large data sets and you want to inspect records or recode
    entries that match certain criteria.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，逻辑值在元素提取中非常有用。你不需要事先知道要返回的具体索引位置，因为条件检查可以为你找到它们。当你处理大型数据集时，特别是在需要检查记录或重新编码符合特定条件的条目时，这尤其有价值。
- en: In some cases, you might want to convert a logical flag vector into a numeric
    index vector. This is helpful when you need the explicit indexes of elements that
    were flagged `TRUE`. The R function `which` takes in a logical vector as the argument
    `x` and returns the indexes corresponding to the positions of any and all `TRUE`
    entries.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能希望将逻辑标志向量转换为数值索引向量。当你需要明确标记为`TRUE`的元素的索引时，这非常有用。R 函数`which`接受一个逻辑向量作为参数`x`，并返回对应于所有`TRUE`条目的位置的索引。
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can use this to identify the index positions of `myvec` that meet a certain
    condition; for example, those containing negative numbers:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用它来识别`myvec`中满足某些条件的索引位置；例如，包含负数的那些元素：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The same can be done for the other `myvec` selections you experimented with.
    Note that a line of code such as `myvec[which(x=myvec<0)]` is redundant because
    that extraction can be made using the condition by itself, that is, via `myvec[myvec<0]`,
    without using `which`. On the other hand, using `which` lets you delete elements
    based on logical flag vectors. You can simply use `which` to identify the numeric
    indexes you want to delete and render them negative. To omit the negative entries
    of `myvec`, you could execute the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你实验过的其他`myvec`选择项，也可以执行相同的操作。请注意，像`myvec[which(x=myvec<0)]`这样的代码行是多余的，因为提取可以仅使用条件本身进行，即通过`myvec[myvec<0]`，无需使用`which`。另一方面，使用`which`可以让你基于逻辑标志向量删除元素。你可以简单地使用`which`来识别要删除的数值索引，并将它们设为负数。要省略`myvec`中的负数条目，你可以执行以下操作：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The same can be done with matrices and other arrays. In [Section 3.2](ch03.xhtml#ch03lev1sec13),
    you stored a 3 × 3 matrix as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对矩阵和其他数组也可以做同样的操作。在[第3.2节](ch03.xhtml#ch03lev1sec13)中，你按照以下方式存储了一个3×3的矩阵：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To extract the second and third column elements of the first row of `A` using
    numeric indexes, you could execute `A[1,2:3]`. To do this with logical flags,
    you could enter the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 若要使用数值索引提取`A`的第一行的第二列和第三列元素，你可以执行`A[1,2:3]`。要使用逻辑标志来实现这一点，你可以输入以下内容：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Again, though, you usually wouldn’t explicitly specify the logical vectors.
    Suppose for example you want to replace all elements in `A` that are less than
    1 with −7\. Performing this using numeric indexes is rather fiddly. It’s much
    easier to use the logical flag matrix created with the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常你不会显式地指定逻辑向量。假设你想将`A`中所有小于1的元素替换为−7。使用数值索引来执行此操作相当繁琐。使用以下方式创建逻辑标志矩阵要容易得多：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can supply this logical matrix to the square bracket operators, and the
    replacement is done as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这个逻辑矩阵提供给方括号操作符，替换过程如下：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is the first time you’ve subsetted a matrix without having to list row
    or column positions inside the square brackets, using commas to separate out dimensions
    (see [Section 3.2](ch03.xhtml#ch03lev1sec13)). This is because the flag matrix
    has the same number of rows and columns as the target matrix, thereby providing
    all the relevant structural information.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你第一次在不需要在方括号内列出行或列位置的情况下对子集化矩阵，使用逗号分隔维度（参见[第3.2节](ch03.xhtml#ch03lev1sec13)）。这是因为标志矩阵的行列数与目标矩阵相同，从而提供了所有相关的结构信息。
- en: If you use `which` to identify numeric indexes based on a logical flag structure,
    you have to be a little more careful when dealing with two-dimensional objects
    or higher. Suppose you want the index positions of the elements that are greater
    than 25\. The appropriate logical matrix is as follows.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`which`基于逻辑标志结构来识别数值索引，那么在处理二维或更高维对象时你必须小心一些。假设你想要大于25的元素的索引位置。适当的逻辑矩阵如下所示。
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, say you ask R the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你询问 R 以下问题：
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This returns the four indexes of the elements that satisfied the relational
    check, but they are provided as scalar values. How do these correspond to the
    row/column positioning of the matrix?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这会返回四个满足关系检查的元素的索引，但它们作为标量值提供。这些如何对应于矩阵的行/列位置呢？
- en: The answer lies in R’s default behavior for the `which` function, which essentially
    treats the multidimensional object as a single vector (laid out column after column)
    and then returns the vector of corresponding indexes. Say the matrix `A` was arranged
    as a vector by stacking the columns first through third, using `c(A[,1],A[,2],A[,3])`.
    Then the indexes returned make more sense.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 答案在R的`which`函数的默认行为中，该函数本质上将多维对象视为一个单一向量（按列堆叠），然后返回对应的索引向量。假设矩阵`A`通过首先将第一列到第三列按列堆叠，形成一个向量`c(A[,1],A[,2],A[,3])`。那么返回的索引就更有意义了。
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: With the columns laid out end to end, the elements that return `TRUE` are the
    third, fourth, sixth, and ninth elements in the list. This can be difficult to
    interpret, though, especially when dealing with higher-dimensional arrays. In
    this kind of situation, you can make `which` return dimension-specific indexes
    using the optional argument `arr.ind` (array indexes). By default, this argument
    is set to `FALSE`, resulting in the vector converted indexes. Setting `arr.ind`
    to `TRUE`, on the other hand, treats the object as a matrix or array rather than
    a vector, providing you with the row and column positions of the elements you
    requested.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将列按顺序排列时，返回`TRUE`的元素是列表中的第三、第四、第六和第九个元素。然而，这种情况可能较难解释，尤其是在处理高维数组时。在这种情况下，你可以通过使用可选参数`arr.ind`（数组索引），使`which`返回特定维度的索引。默认情况下，这个参数设置为`FALSE`，这会导致返回一个转换后的向量索引。而将`arr.ind`设置为`TRUE`时，R会将对象视为矩阵或数组，而不是向量，从而为你提供所请求元素的行和列位置。
- en: '[PRE37]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The returned object is now a matrix, where each row represents an element that
    satisfied the logical comparison and each column provides the position of the
    element. Comparing the output here with `A`, you can see these positions do indeed
    correspond to elements where `A>25`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的对象现在是一个矩阵，其中每一行表示一个满足逻辑比较的元素，每一列提供该元素的位置。将这里的输出与`A`进行比较，你会发现这些位置确实对应于`A >
    25`的元素。
- en: Both versions of the output (with `arr.ind=T` or `arr.ind=F`) can be useful—the
    correct choice depends on the application.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 两种输出版本（`arr.ind=T`或`arr.ind=F`）都可能有用——正确的选择取决于具体应用。
- en: '**Exercise 4.3**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 4.3**'
- en: 'Store this vector of 10 values: `foo <- c(7,5,6,1,2,10,8,3,8,2)`. Then, do
    the following:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储这个10个值的向量：`foo <- c(7,5,6,1,2,10,8,3,8,2)`。然后，执行以下操作：
- en: Extract the elements greater than or equal to 5, storing the result as `bar`.
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取大于或等于5的元素，并将结果存储为`bar`。
- en: Display the vector containing those elements from `foo` that remain after omitting
    all elements that are greater than or equal to 5.
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示包含那些从`foo`中去除所有大于或等于5的元素后剩下的元素的向量。
- en: 'Use `bar` from (a)(i) to construct a 2 × 3 matrix called `baz`, filled in a
    row-wise fashion. Then, do the following:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用(a)(i)中的`bar`构造一个2×3的矩阵，称为`baz`，按行填充。然后，执行以下操作：
- en: Replace any elements that are equal to 8 with the *squared* value of the element
    in row 1, column 2 of `baz` itself.
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将任何等于8的元素替换为`baz`中第1行第2列元素的*平方*值。
- en: Confirm that *all* values in `baz` are now less than or equal to 25 AND greater
    than 4.
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认`baz`中的*所有*值现在都小于或等于25且大于4。
- en: 'Create a 3 × 2 × 3 array called `qux` using the following vector of 18 values:
    `c(10,5,1,4,7,4,3,3,1,3,4,3,1,7,8,3,7,3)`. Then, do the following:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下18个值的向量`c(10,5,1,4,7,4,3,3,1,3,4,3,1,7,8,3,7,3)`创建一个3×2×3的数组，称为`qux`。然后，执行以下操作：
- en: Identify the dimension-specific index positions of elements that are either
    3 OR 4.
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定元素值为3或4的维度特定索引位置。
- en: Replace all elements in `qux` that are less than 3 OR greater than or equal
    to 7 with the value 100.
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`qux`中所有小于3或大于等于7的元素替换为100。
- en: Return to `foo` from (a). Use the vector `c(F,T)` to extract every second value
    from `foo`. In [Section 4.1.4](ch04.xhtml#ch04lev2sec40), you saw that in some
    situations, you can substitute `0` and `1` for `TRUE` and `FALSE`. Can you perform
    the same extraction from `foo` using the vector `c(0,1)`? Why or why not? What
    does R return in this case?
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从(a)返回到`foo`。使用向量`c(F,T)`从`foo`中提取每隔一个的值。在[第4.1.4节](ch04.xhtml#ch04lev2sec40)中，你已经看到，在某些情况下，可以将`TRUE`和`FALSE`替换为`0`和`1`。你能使用向量`c(0,1)`从`foo`中执行相同的提取操作吗？为什么或为什么不？在这种情况下，R会返回什么？
- en: '**4.2 Characters**'
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**4.2 字符**'
- en: Character strings are another common data type, and are used to represent text.
    In R, strings are often used to specify folder locations or software options (as
    shown briefly in [Section 1.2](ch01.xhtml#ch01lev1sec06)); to supply an argument
    to a function; and to annotate stored objects, provide textual output, or help
    clarify plots and graphics. In a simple way, they can also be used to define different
    groups making up a categorical variable, though as you’ll see in see [Section
    4.3](ch04.xhtml#ch04lev1sec18), *factors* are better suited for that.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是另一种常见的数据类型，用于表示文本。在R中，字符串常用于指定文件夹位置或软件选项（如[第1.2节](ch01.xhtml#ch01lev1sec06)简要所示）；传递函数参数；以及注释存储的对象、提供文本输出或帮助澄清绘图和图形。简单来说，它们也可以用来定义构成分类变量的不同组，尽管正如你将在[第4.3节](ch04.xhtml#ch04lev1sec18)中看到的，*因子*更适合用于此目的。
- en: '**NOTE**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*There are three different string formats in the R environment. The default
    string format is called an* extended regular expression*; the other variants are
    named* Perl *and* literal regular expressions*. The intricacies of these variants
    are beyond the scope of this book, so any mention of character strings from here
    on refers to an extended regular expression. For more technical details about
    other string formats, enter* `?regex` *at the prompt.*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*R环境中有三种不同的字符串格式。默认的字符串格式叫做*扩展正则表达式*；其他变种分别被称为*Perl*和*字面正则表达式*。这些变种的复杂性超出了本书的范围，因此从这里开始提到的字符字符串都指的是扩展正则表达式。有关其他字符串格式的更多技术细节，请在提示符下输入*`?regex`*。*'
- en: '***4.2.1 Creating a String***'
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***4.2.1 创建字符串***'
- en: Character strings are indicated by double quotation marks, `"`. To create a
    string, just enter text between a pair of quotes.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串由双引号`"`表示。要创建一个字符串，只需在一对引号之间输入文本。
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'R treats the string as a single entity. In other words, `foo` is a vector of
    length 1 because R counts only the total number of distinct strings rather than
    individual words or characters. To count the number of individual characters,
    you can use the `nchar` function. Here’s an example using `foo`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: R将字符串视为一个单独的实体。换句话说，`foo`是一个长度为1的向量，因为R只计算不同字符串的总数，而不是单个的单词或字符。要计算单个字符的数量，可以使用`nchar`函数。以下是一个使用`foo`的示例：
- en: '[PRE39]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Almost any combination of characters, including numbers, can be a valid character
    string.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎任何字符组合，包括数字，都可以是有效的字符字符串。
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note that in this form, the string has no numeric meaning, and it won’t be treated
    like the number 23.3\. Attempting to multiply it by 2, for example, results in
    an error.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这种形式下，字符串没有数值含义，它不会像数字23.3一样被处理。例如，尝试将其乘以2会导致错误。
- en: '[PRE41]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This error occurs because `*` is expecting to operate on two numeric values
    (not one number and one string, which makes no sense).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误发生是因为`*`期望对两个数值进行操作（而不是一个数字和一个字符串，这没有意义）。
- en: Strings can be compared in several ways, the most common comparison being a
    check for equality.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串可以通过多种方式进行比较，最常见的比较是检查是否相等。
- en: '[PRE42]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Other relational operators work as you might expect. For example, R considers
    letters that come later in the alphabet to be greater than earlier letters, meaning
    it can determine whether one string of letters is greater than another with respect
    to alphabetical order.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 其他关系运算符的行为如你所料。例如，R认为字母表中后面的字母大于前面的字母，这意味着它可以根据字母表顺序判断一个字符串是否大于另一个字符串。
- en: '[PRE43]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Furthermore, uppercase letters are considered greater than lowercase letters.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，大写字母被视为大于小写字母。
- en: '[PRE44]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Most symbols can also be used in a string. The following string is valid, for
    example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数符号也可以在字符串中使用。例如，以下字符串是有效的：
- en: '[PRE45]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: One important exception is the backslash `\`, also called an *escape*. When
    a backslash is used within the quotation marks of a string, it initiates some
    simple control over the printing or display of the string itself. You’ll see how
    this works in a moment in [Section 4.2.3](ch04.xhtml#ch04lev2sec44). First let’s
    look at two useful functions for combining strings.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的例外是反斜杠`\`，也称为*转义符*。当反斜杠在字符串的引号内使用时，它启动了一些简单的控制，用于控制字符串本身的打印或显示。你将在[第4.2.3节](ch04.xhtml#ch04lev2sec44)中看到这一点。首先，让我们看一下两个用于合并字符串的有用函数。
- en: '***4.2.2 Concatenation***'
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***4.2.2 拼接***'
- en: 'There are two main functions used to *concatenate* (or glue together) one or
    more strings: `cat` and `paste`. The difference between the two lies in how their
    contents are returned. The first function, `cat`, sends its output directly to
    the console screen and doesn’t formally *return* anything. The `paste` function
    concatenates its contents and then returns the final character string as a usable
    R object. This is useful when the result of a string concatenation needs to be
    passed to another function or used in some secondary way, as opposed to just being
    displayed. Consider the following vector of character strings:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个主要函数用于*连接*（或将多个字符串粘合在一起）：`cat`和`paste`。这两者之间的区别在于它们如何返回内容。第一个函数，`cat`，将其输出直接发送到控制台屏幕，并且不正式*返回*任何内容。`paste`函数将其内容连接起来，然后将最终的字符字符串作为可用的R对象返回。当字符串连接的结果需要传递给另一个函数或以某种二次方式使用时，这非常有用，而不仅仅是显示出来。考虑以下字符字符串的向量：
- en: '[PRE46]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As with numbers and logicals, you can also store any number of strings in a
    matrix or array structure if you want.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 与数字和逻辑值一样，您也可以将任意数量的字符串存储在矩阵或数组结构中，前提是您愿意这样做。
- en: 'When calling `cat` or `paste`, you pass arguments to the function in the order
    you want them combined. The following lines show identical usage yet different
    types of output from the two functions:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`cat`或`paste`时，您按希望的顺序将参数传递给函数进行合并。以下几行展示了这两个函数的相同用法，但输出类型有所不同：
- en: '[PRE47]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here, you’ve used the three elements of `qux` as well as two additional strings,
    `"totally"` and `"!"`, to produce the final concatenated string. In the output,
    note that `cat` has simply concatenated and printed the text to the screen. This
    means you cannot directly assign the result to a new variable and treat it as
    a character string. For `paste`, however, the `[1]` to the left of the output
    and the presence of the `"` quotes indicate the returned item is a vector containing
    a character string, and this can be assigned to an object and used in other functions.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您使用了`qux`的三个元素以及两个附加字符串`"totally"`和`"!"`，以生成最终的连接字符串。在输出中，请注意，`cat`只是将文本连接并打印到屏幕上。这意味着您不能直接将结果赋值给一个新变量，并将其作为字符字符串使用。而对于`paste`，输出左侧的`[1]`以及`"`引号的存在表明返回的项是一个包含字符字符串的向量，且可以将其赋值给对象并在其他函数中使用。
- en: '**NOTE**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*There’s a slight difference between OS X and Windows in the default handling
    of string concatenation when using the R GUI. After calling* `cat` *in Windows,
    the new R prompt awaiting your next command appears on the same line as the printed
    string, in which case you can just hit* ENTER *to move to the next line, or use
    an* escape sequence*, which you’ll look at in [Section 4.2.3](ch04.xhtml#ch04lev2sec44).
    In OS X, the new prompt appears on the next line as usual.*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*在使用R GUI时，OS X和Windows在默认的字符串连接处理上有所不同。在Windows中调用`cat`后，新R提示符会出现在与打印字符串同一行，在这种情况下，您可以直接按*ENTER*键进入下一行，或者使用*转义序列*，您将在[第4.2.3节](ch04.xhtml#ch04lev2sec44)中学习到。在OS
    X中，新提示符照常出现在下一行。*'
- en: 'These two functions have an optional argument, `sep`, that’s used as a separator
    between strings as they’re concatenated. You pass `sep` a character string, and
    it will place this string between all other strings you’ve provided to `paste`
    or `cat`. For example:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数都有一个可选参数`sep`，用于在字符串连接时作为分隔符。您将字符字符串传递给`sep`，它将在您传递给`paste`或`cat`的所有其他字符串之间插入该字符串。例如：
- en: '[PRE48]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The same behavior would occur for `cat`. Note that if you don’t want any separation,
    you set `sep=""`, an empty string, as shown in the second example. The empty string
    separator can be used to achieve correct sentence spacing; note the gap between
    `awesome` and the exclamation mark in the previous code when you first used `paste`
    and `cat`. If the `sep` argument isn’t included, R will insert a space between
    strings by default.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`cat`，也会发生相同的行为。请注意，如果您不想要任何分隔，可以将`sep=""`（一个空字符串）设置为分隔符，如第二个示例所示。空字符串分隔符可以用于正确的句子间距；请注意，在您首次使用`paste`和`cat`时，`awesome`和感叹号之间的间隙。如果没有包含`sep`参数，R默认会在字符串之间插入空格。
- en: 'For example, using manual insertion of spaces where necessary, you can write
    the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以手动插入必要的空格，编写如下代码：
- en: '[PRE49]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Concatenation can be useful when you want to neatly summarize the results from
    a certain function or set of calculations. Many kinds of R objects can be passed
    directly to `paste` or `cat`; the software will attempt to automatically *coerce*
    these items into character strings. This means R will convert the input into a
    string so the values can be included in the final concatenated string. This works
    particularly well with numeric objects, as the following examples demonstrate:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要简洁地总结某个函数或一组计算的结果时，连接操作非常有用。许多类型的R对象可以直接传递给`paste`或`cat`函数；软件会尝试自动*强制转换*这些项为字符字符串。这意味着R会将输入转换为字符串，以便将值包含在最终的连接字符串中。对于数值对象，这种方式尤其有效，以下示例可以证明这一点：
- en: '[PRE50]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, the values of the non-string objects are placed where you want them in
    the final string output. The results of calculations can also appear as fields,
    as shown with the arithmetic `a+b` and the logical comparison `a+b<10`. You’ll
    see more details about coercion from one kind of value to another in [Section
    6.2.4](ch06.xhtml#ch06lev2sec62).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，非字符串对象的值被放置在你希望它们出现在最终字符串输出中的位置。计算结果也可以作为字段显示，如算术运算`a+b`和逻辑比较`a+b<10`所示。你将在[第6.2.4节](ch06.xhtml#ch06lev2sec62)看到更多关于一种类型的值强制转换为另一种类型的细节。
- en: '***4.2.3 Escape Sequences***'
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***4.2.3 转义序列***'
- en: In [Section 4.2.1](ch04.xhtml#ch04lev2sec42), I noted that a stand-alone backslash
    doesn’t act like a normal character within a string. The `\` is used to invoke
    an *escape sequence*. An escape sequence lets you enter characters that control
    the format and spacing of the string, rather than being interpreted as normal
    text. [Table 4-3](ch04.xhtml#ch4tab3) describes some of the most common escape
    sequences, and you can find a full list by entering `?Quotes` at the prompt.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4.2.1节](ch04.xhtml#ch04lev2sec42)中，我提到过独立的反斜杠在字符串中不像普通字符那样起作用。`\\`用于调用*转义序列*。转义序列允许你输入控制字符串格式和间距的字符，而不是被解释为普通文本。[表4-3](ch04.xhtml#ch4tab3)描述了一些最常见的转义序列，完整列表可以通过在提示符下输入`?Quotes`来查找。
- en: '**Table 4-3:** Common Escape Sequences for Use in Character Strings'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**表4-3：** 常用的字符字符串转义序列'
- en: '| **Escape sequence** | **Result** |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| **转义序列** | **结果** |'
- en: '| --- | --- |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `\n` | Starts a newline |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `\n` | 开始换行 |'
- en: '| `\t` | Horizontal tab |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `\t` | 水平制表符 |'
- en: '| `\b` | Invokes a backspace |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `\b` | 调用退格 |'
- en: '| `\\` | Used as a single backslash |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `\\` | 用作单个反斜杠 |'
- en: '| `\"` | Includes a double quote |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `\"` | 包含双引号 |'
- en: Escape sequences add flexibility to the display of character strings, which
    can be useful for summaries of results and plot annotations. You enter the sequence
    precisely where you want it to take effect. Let’s look at an example.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 转义序列为字符字符串的显示增加了灵活性，这在结果汇总和图表注释中非常有用。你可以精确地在想要的地方输入这些序列。我们来看一个例子。
- en: '[PRE51]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Since the signal for an escape is `\` and the signal to begin and end a string
    is `"`, if you want either of these characters to be included in a string, you
    must also use an escape to have them be interpreted as a normal character.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由于转义符号是`\`，而字符串的开始和结束符号是`"`，如果你希望这些字符之一包含在字符串中，必须使用转义符号让它们被解释为普通字符。
- en: '[PRE52]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: These escape sequences mean that you can’t use a stand-alone backslash in file
    path strings in R. As noted in [Section 1.2.3](ch01.xhtml#ch01lev2sec08) (where
    you used `getwd` to print the current working directory and `setwd` to change
    it), folder separation must use a forward slash `/` and not a backslash.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这些转义序列意味着你不能在R中使用独立的反斜杠来表示文件路径字符串。如[第1.2.3节](ch01.xhtml#ch01lev2sec08)中所述（你曾使用`getwd`打印当前工作目录，使用`setwd`更改工作目录），文件夹分隔符必须使用正斜杠`/`，而不是反斜杠。
- en: '[PRE53]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: File path specification crops up when reading and writing files, which you’ll
    explore in [Chapter 8](ch08.xhtml#ch08).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 文件路径的指定在读取和写入文件时经常出现，你将在[第8章](ch08.xhtml#ch08)中深入探索。
- en: '***4.2.4 Substrings and Matching***'
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***4.2.4 子字符串和匹配***'
- en: '*Pattern matching* lets you inspect a given string to identify smaller strings
    within it.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*模式匹配*让你检查给定的字符串，以识别其中的较小字符串。'
- en: The function `substr` takes a string `x` and extracts the part of the string
    between two character positions (inclusive), indicated with numbers passed as
    `start` and `stop` arguments. Let’s try it on the object `foo` from [Section 4.2.1](ch04.xhtml#ch04lev2sec42).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`substr`接受一个字符串`x`并提取字符串中两个字符位置之间的部分（包括这两个位置），这两个位置由作为`start`和`stop`参数传递的数字指定。让我们试一下[第4.2.1节](ch04.xhtml#ch04lev2sec42)中的对象`foo`。
- en: '[PRE54]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here, you’ve extracted the characters between positions 21 and 27, inclusive,
    to get `"string!"`. The function `substr` can also be used with the assignment
    operator to directly substitute in a new set of characters. In this case, the
    replacement string should contain the same number of characters as the selected
    area.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你提取了第21个字符到第27个字符之间的部分，得到`"string!"`。`substr`函数也可以与赋值运算符一起使用，直接替换为一组新的字符。在这种情况下，替换字符串应包含与选定区域相同数量的字符。
- en: '[PRE55]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If the replacement string is longer than the number of characters indicated
    by `start` and `stop`, then replacement still takes place, beginning at `start`
    and ending at `stop`. It cuts off any characters that overrun the number of characters
    you’re replacing. If the string is shorter than the number of characters you’re
    replacing, then replacement ends when the string is fully inserted, leaving the
    original characters up to `stop` untouched.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果替换字符串的长度超过`start`和`stop`指示的字符数，则仍然会进行替换，从`start`位置开始，到`stop`位置结束。它会截断任何超过替换字符数的部分。如果字符串短于替换的字符数，则替换在字符串完全插入时结束，原始字符保持不变，直到`stop`位置。
- en: 'Substitution is more flexible using the functions `sub` and `gsub`. The `sub`
    function searches a given string `x` for a smaller string `pattern` contained
    within. It then replaces the first instance with a new string, given as the argument
    `replacement`. The `gsub` function does the same thing, but it replaces *every*
    instance of `pattern`. Here’s an example:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`sub`和`gsub`函数进行替换更加灵活。`sub`函数会在给定的字符串`x`中搜索包含的小字符串`pattern`，然后用新的字符串（作为`replacement`参数）替换第一个匹配项。`gsub`函数做的是相同的事情，但它会替换*每个*匹配的`pattern`。以下是一个例子：
- en: '[PRE56]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: With `sub` and `gsub`, the `replacement` value need not have the same number
    of characters as the `pattern` being replaced. These functions also have search
    options like case-sensitivity. The help files `?substr` and `?sub` have more details,
    as well as noting a handful of other pattern-matching functions and techniques.
    You might also want to check out the `grep` command and its variants; see the
    relevant help file `?grep`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`sub`和`gsub`时，`replacement`值的字符数不需要与要替换的`pattern`相同。这些函数还具有像大小写敏感度这样的搜索选项。帮助文件`?substr`和`?sub`有更多详细信息，还列出了其他一些模式匹配函数和技术。你可能还想查看`grep`命令及其变体；请参阅相关的帮助文件`?grep`。
- en: '**Exercise 4.4**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 4.4**'
- en: 'Re-create exactly the following output:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完全重新创建以下输出：
- en: '[PRE57]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Suppose you’ve stored the values `num1 <- 4` and `num2 <- 0.75`. Write a line
    of R code that returns the following string:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你已经存储了值`num1 <- 4`和`num2 <- 0.75`。写一行R代码，返回以下字符串：
- en: '[PRE58]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Make sure your code produces a string with the correct multiplication result
    for *any* two numbers stored as `num1` and `num2`.
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保你的代码能够生成正确的乘法结果，适用于存储在`num1`和`num2`中的*任何*两个数字。
- en: On my local machine, the directory for my work on this book is specified in
    R as `"/Users/tdavies/Documents/RBook/"`. Imagine it is your machine—write a line
    of code that replaces `tdavies` in this string with your first initial and surname.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我的本地机器上，我在R中为这本书的工作指定的目录是`"/Users/tdavies/Documents/RBook/"`。假设这是你的机器——写一行代码，将这个字符串中的`tdavies`替换为你的名字首字母和姓氏。
- en: 'In [Section 4.2.4](ch04.xhtml#ch04lev2sec45), you stored the following string:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[第4.2.4节](ch04.xhtml#ch04lev2sec45)中，你存储了以下字符串：
- en: '[PRE59]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Store a new string by gluing onto `bar` the words `"if a woodchuck could chuck
    wood"`.
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将`"if a woodchuck could chuck wood"`这句话粘贴到`bar`后，存储一个新字符串。
- en: In the result of (i), replace all instances of `wood` with `metal`.
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在(i)的结果中，将所有`wood`替换为`metal`。
- en: 'Store the string `"Two 6-packs for $12.99"`. Then do the following:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储字符串`"Two 6-packs for $12.99"`。然后执行以下操作：
- en: Use a check for equality to confirm that the substring beginning with character
    5 and ending with character 10 is `"6-pack"`.
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相等性检查，确认从字符5开始，到字符10结束的子字符串是`"6-pack"`。
- en: Make it a better deal by changing the price to $10.99.
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将价格更改为$10.99，使其成为更好的交易。
- en: '**4.3 Factors**'
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**4.3 因子**'
- en: In this section, you’ll look at some simple functions related to creating, handling,
    and inspecting *factors*. Factors are R’s most natural way of representing data
    points that fit in only one of a finite number of distinct categories, rather
    than belonging to a continuum. Categorical data like this can play an important
    role in data science, and you’ll look at factors again in more detail from a statistical
    perspective in [Chapter 13](ch13.xhtml#ch13).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，你将学习一些与创建、处理和检查*因子*相关的简单函数。因子是R表示仅属于有限类别的离散数据点的最自然方式，而不是属于连续体的数据。像这样的分类数据在数据科学中扮演着重要角色，你将在[第13章](ch13.xhtml#ch13)中从统计学的角度再次详细学习因子。
- en: '***4.3.1 Identifying Categories***'
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***4.3.1 确定类别***'
- en: To see how factors work, let’s start with a simple data set. Suppose you find
    eight people and record their first name, sex, and month of birth in [Table 4-4](ch04.xhtml#ch4tab4).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解因子的工作原理，让我们从一个简单的数据集开始。假设你找到八个人，并记录下他们的名字、性别和出生月份，见[表4-4](ch04.xhtml#ch4tab4)。
- en: '**Table 4-4:** An Example Data Set of Eight Individuals'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**表4-4：** 八个个体的示例数据集'
- en: '| **Person** | **Sex** | **Month of birth** |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| **姓名** | **性别** | **出生月份** |'
- en: '| --- | --- | --- |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Liz | Female | April |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| Liz | Female | April |'
- en: '| Jolene | Female | January |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| Jolene | Female | January |'
- en: '| Susan | Female | December |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| Susan | Female | December |'
- en: '| Boris | Male | September |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| Boris | Male | September |'
- en: '| Rochelle | Female | November |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| Rochelle | Female | November |'
- en: '| Tim | Male | July |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| Tim | Male | July |'
- en: '| Simon | Male | July |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| Simon | Male | July |'
- en: '| Amy | Female | June |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| Amy | Female | June |'
- en: There’s really only one sensible way to represent the name of each person in
    R—as a vector of character strings.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，表示每个人姓名的合理方式只有一种——作为字符字符串的向量。
- en: '[PRE60]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'You have more flexibility when it comes to recording sex, however. Coding females
    as 0 and males as 1, a numeric option would be as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在记录性别时，你有更多的灵活性。将女性编码为0，男性编码为1，数值选项如下：
- en: '[PRE61]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Of course, character strings are also possible, and many prefer this because
    you don’t need to remember the numeric code for each group.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也可以使用字符字符串，许多人更喜欢这种方式，因为你不需要记住每个组的数字代码。
- en: '[PRE62]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: There is, however, a fundamental difference between an individual’s name and
    their sex when stored as data. Where a person’s name is a unique identifier that
    can take any one of an infinite number of possibilities, there are generally only
    two options for recording a person’s sex. These kinds of data, where all possible
    values fall into a finite number of categories, are best represented in R using
    factors.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，存储个人姓名和性别数据时，有一个根本性的区别。个人姓名是一个独特的标识符，可以有无限多种可能性，而记录性别通常只有两种选择。这类数据，即所有可能的值都属于有限的类别时，最适合使用R中的因子来表示。
- en: 'Factors are typically created from a numeric or a character vector (note that
    you cannot fill matrices or multidimensional arrays using factor values; factors
    can only take the form of vectors). To create a factor vector, use the function
    `factor`, as in this example working with `sex.num` and `sex.char`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 因子通常是从数值向量或字符向量中创建的（请注意，你不能使用因子值来填充矩阵或多维数组；因子只能以向量的形式存在）。要创建因子向量，可以使用`factor`函数，下面是一个使用`sex.num`和`sex.char`的示例：
- en: '[PRE63]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Here, you obtain factor versions of the two vectors storing gender values.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以得到存储性别值的两个向量的因子版本。
- en: At first glance, these objects don’t look much different from the character
    and numeric vectors from which they were created. Indeed, factor objects work
    in much the same way as vectors, but with a little extra information attached
    (R’s internal representation of factor objects is a little different as well).
    Functions like `length` and `which` work the same way on factor objects as with
    vectors, for example.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这些对象看起来与它们所创建的字符向量和数值向量没什么不同。事实上，因子对象的工作方式与向量非常相似，只不过附加了一些额外的信息（R内部表示因子对象的方式也略有不同）。例如，像`length`和`which`这样的函数在因子对象上的工作方式与在向量上的使用方式是一样的。
- en: The most important extra piece of information (or *attribute*; see [Section
    6.2.1](ch06.xhtml#ch06lev2sec59)) that a factor object contains is its *levels*,
    which store the possible values in the factor. These levels are printed at the
    bottom of each factor vector. You can extract the levels as a vector of character
    strings using the `levels` function.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 因子对象包含的最重要的额外信息（或*属性*；见[第6.2.1节](ch06.xhtml#ch06lev2sec59)）是其*水平*，即存储因子中可能值的部分。这些水平会打印在每个因子向量的底部。你可以使用`levels`函数提取这些水平作为字符字符串的向量。
- en: '[PRE64]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'You can also relabel a factor using `levels`. Here’s an example:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`levels`重新标记因子。下面是一个示例：
- en: '[PRE65]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This relabels the females `1` and the males `2`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这将重新标记女性为`1`，男性为`2`。
- en: Factor-valued vectors are subsetted in the same way as any other vector.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 因子值向量的子集提取与其他任何向量的子集提取方式相同。
- en: '[PRE66]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Note that after subsetting a factor object, the object continues to store *all*
    defined levels even if some of the levels are no longer represented in the subsetted
    object.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在对子集化的因子对象进行子集提取后，即使某些层次不再出现在子集对象中，该对象仍然会继续存储*所有*已定义的层次。
- en: 'If you want to subset from a factor using a logical flag vector, keep in mind
    that the levels of a factor are stored as character strings, even if the original
    data vector was numeric, so you need to use a string when requesting or testing
    for a particular level. To, for example, identify all the men using the newly
    relabeled `sex.num.fac`, use this:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想通过逻辑标志向量从因子中提取子集，请记住，即使原始数据向量是数值型的，因子的层次是以字符字符串形式存储的，因此在请求或测试特定层次时，需要使用字符串。例如，要使用新标记的`sex.num.fac`来识别所有男性，可以使用以下代码：
- en: '[PRE67]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Since the elements in `firstname` and `sex` have corresponding positions in
    their factor vectors, you can then use this logical vector to obtain the names
    of all the men (this time using the `"male"`/`"female"` factor vector).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`firstname`和`sex`中的元素在它们的因子向量中有相应的位置，你可以使用这个逻辑向量来获取所有男性的名字（这次使用的是`"male"`/`"female"`因子向量）。
- en: '[PRE68]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Of course, this simple subsetting could have been achieved in much the same
    way with the raw numeric vector `sex.num` or the raw character vector `sex.char`.
    In the next section, you’ll explore some more distinctive advantages to having
    categorical data represented as a factor in R.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种简单的子集提取方式也可以通过原始的数字向量`sex.num`或原始的字符向量`sex.char`以类似的方式实现。在下一节中，你将探索将分类数据表示为R中的因子所带来的一些更独特的优势。
- en: '***4.3.2 Defining and Ordering Levels***'
  id: totrans-280
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***4.3.2 定义和排序层次***'
- en: The sex factor from the previous section represents the simplest kind of factor
    variable—there are only two possible levels with no ordering, in that one level
    is not intuitively considered “higher than” or “following” the other. Here you’ll
    look at factors with levels that can be logically ordered; for example, month
    of birth (MOB), where there are 12 levels that have a natural order. Let’s store
    the observed MOB data from earlier as a character vector.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中的性别因子表示了最简单的因子变量——它只有两个可能的层次，并且没有顺序，因为一个层次并不直观地被认为是“高于”或“跟随”另一个层次。在这里，你将查看具有逻辑顺序的因子层次；例如，出生月份（MOB），其中有12个层次，它们有自然的顺序。让我们将之前观察到的MOB数据存储为字符向量。
- en: '[PRE69]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'There are two problems with the data in this vector. First, not all possible
    categories are represented since `mob` contains only seven unique months. Second,
    this vector doesn’t reflect the natural order of the months. If you compare January
    and December to see which is greater, you get:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这个向量中的数据存在两个问题。首先，并非所有可能的类别都有表示，因为`mob`只包含七个独特的月份。其次，这个向量没有反映月份的自然顺序。如果你比较一月和十二月，看看哪个更大，你会得到：
- en: '[PRE70]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Alphabetically, this result is of course correct—*J* doesn’t occur before *D*.
    But in terms of the order of the calendar months, which is what we’re interested
    in, the `FALSE` result is incorrect.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 按字母顺序排列，这个结果当然是正确的——*J*显然不会出现在*D*之前。但从日历月份的顺序来看，也就是我们感兴趣的部分，`FALSE`的结果就是不正确的。
- en: If you create a factor object from these values, you can deal with both of these
    problems by supplying additional arguments to the `factor` function. You can define
    additional levels by supplying a character vector of all possible values to the
    `levels` argument and then instruct R to order the values precisely as they appear
    in `levels` by setting the argument `ordered` to `TRUE`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从这些值创建一个因子对象，你可以通过向`factor`函数提供额外的参数来解决这两个问题。你可以通过向`levels`参数提供一个包含所有可能值的字符向量来定义额外的层次，然后通过将`ordered`参数设置为`TRUE`，指示R按`levels`中出现的顺序精确排列这些值。
- en: '[PRE71]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Here, the `mob.fac` vector contains the same individual entries at the same
    index positions as the `mob` vector from earlier. But notice that this variable
    has 12 levels, even though you have not made any observations for the levels `"Feb"`,
    `"Mar"`, `"May"`, `"Aug"`, or `"Oct"`. (Note that if your R console window is
    too narrow to print all the levels to the screen, you may see a `...`, indicating
    there’s more output that’s been hidden. Just widen your window and reprint the
    object to see the hidden levels.) Also, the strict order of these levels is shown
    by the `<` symbol in the object output. Using this new factor object, you can
    perform the relational comparison from earlier and get the result you might expect.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`mob.fac`向量包含了与之前的`mob`向量相同的单独条目，并且它们处于相同的索引位置。但请注意，这个变量有12个水平，尽管你并没有为`"Feb"`、`"Mar"`、`"May"`、`"Aug"`和`"Oct"`这些水平进行任何观测。（请注意，如果你的R控制台窗口太窄，无法显示所有的水平，你可能会看到`...`，表示有更多的输出被隐藏了。只需调整窗口宽度并重新打印对象，就可以看到隐藏的水平。）此外，这些水平的严格顺序通过对象输出中的`<`符号显示。使用这个新的因子对象，你可以执行之前的关系比较，并得到你预期的结果。
- en: '[PRE72]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: These improvements are far from just cosmetic. There’s a big difference, for
    example, between a data set with zero observations in some of the categories and
    the same data set defined with fewer categories to begin with. The choice of whether
    to instruct R to formally order a factor vector can also have important consequences
    in the implementation of various statistical methods, such as regression and other
    types of modeling.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这些改进远不仅仅是外观上的。举个例子，具有某些类别零观测值的数据集，与最初定义时类别较少的同一数据集之间，存在很大区别。是否指示R正式对因子向量进行排序，也可能对各种统计方法的实现产生重要影响，例如回归和其他类型的建模。
- en: '***4.3.3 Combining and Cutting***'
  id: totrans-291
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***4.3.3 合并与切割***'
- en: 'As you’ve seen, it’s usually simple to combine multiple vectors of the same
    kind (whether numeric, logical, or character) using the `c` function. Here’s an
    example:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，通常使用`c`函数将多个相同类型的向量（无论是数值型、逻辑型还是字符型）合并起来都很简单。这里有一个例子：
- en: '[PRE73]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This combines the two numeric vectors into one.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把两个数值向量合并成一个。
- en: However, the `c` function doesn’t work the same way with factor-valued vectors.
    Let’s see what happens when you use it on the data in [Table 4-4](ch04.xhtml#ch4tab4)
    and the MOB factor vector `mob.fac`, from [Section 4.3.2](ch04.xhtml#ch04lev2sec47).
    Suppose you now observe three more individuals with MOB values `"Oct"`, `"Feb"`,
    and `"Feb"`, which are stored as a factor object, as follows.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`c`函数在处理因子值向量时并不像处理其他向量那样工作。让我们看看当你在[表4-4](ch04.xhtml#ch4tab4)的数据和MOB因子向量`mob.fac`（来自[4.3.2节](ch04.xhtml#ch04lev2sec47)）上使用它时会发生什么。假设现在你再观察了三个新的个体，其MOB值分别是`"Oct"`、`"Feb"`和`"Feb"`，这些值作为因子对象存储，如下所示。
- en: '[PRE74]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Now you have `mob.fac` with the original eight observations and `new.values`
    with an additional three. Both are factor objects, defined with identical, ordered
    levels. You might expect that you can just use `c` to combine the two as follows.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了带有原始八个观测值的`mob.fac`和包含三个额外观测值的`new.values`。它们都是因子对象，定义了相同的、有序的水平。你可能会认为可以通过`c`函数将两者合并，如下所示。
- en: '[PRE75]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Clearly, this has not done what you want it to do. Combining the two factor
    objects resulted in a numeric vector. This is because the `c` function interprets
    factors as integers. Comparing this with the defined levels, you can see that
    the numbers refer to the index of each month within the ordered levels.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这并没有达到你想要的效果。将这两个因子对象合并后得到了一个数值向量。这是因为`c`函数将因子解释为整数。通过与已定义的水平进行比较，你可以看到这些数字对应于有序水平中每个月的索引位置。
- en: '[PRE76]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This means you can use these integers with `levels(mob.fac)` to retrieve a character
    vector of the complete observed data—the original eight observations plus the
    additional three.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你可以使用这些整数与`levels(mob.fac)`结合，获取一个完整的字符向量，包含所有观测数据——原始的八个观测值加上额外的三个。
- en: '[PRE77]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Now you have all the observations stored in a vector, but they are currently
    stored as strings, not factor values. The final step is to turn this vector into
    a factor object.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将所有的观测值存储在一个向量中，但它们目前是作为字符串存储的，而不是因子值。最后一步是将这个向量转换为因子对象。
- en: '[PRE78]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: As this example shows, combining factors requires you to essentially deconstruct
    the two objects, obtaining the numeric index positions of each entry with respect
    to the factor levels, and then rebuild them together. This helps ensure that the
    levels are consistent and the observations are valid in the final product.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这个例子所示，合并因素要求你实际上拆解这两个对象，获取每个条目相对于因素级别的数值索引位置，然后将它们重新组合在一起。这有助于确保级别的一致性，并确保最终产品中的观察值有效。
- en: 'Factors are also often created from data that was originally measured on a
    continuum, for example the weight of a set of adults or the amount of a drug given
    to a patient. Sometimes you’ll need to group (or *bin*) these types of observations
    into categories, like Small/Medium/Large or Low/High. In R, you can mold this
    kind of data into discrete factor categories using the `cut` function. Consider
    the following numeric vector of length 10:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 因素通常也是从原本在连续范围内测量的数据中创建的，例如一组成年人的体重或给患者服用的药物量。有时候，你需要将这些类型的观察值分组（或*分箱*）成不同的类别，比如小/中/大或低/高。在
    R 中，你可以使用 `cut` 函数将这类数据转化为离散的因素类别。考虑以下长度为 10 的数值向量：
- en: '[PRE79]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Suppose you want to bin the data as follows: *Small* refers to observations
    in the interval [0,2), *Medium* refers to [2,4), and *Large* refers to [4,6].
    A square bracket refers to *inclusion* of its nearest value, and a parenthesis
    indicates *exclusion*, so an observation *y* will fall in the Small interval if
    0 ≤ *y* < 2, in Medium if 2 ≤ *y* < 4, or in Large if 4 ≤ *y* ≤ 6\. For this you’d
    use `cut` and supply your desired break intervals to the `breaks` argument:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想按以下方式对数据进行分箱：*小*表示区间[0,2)，*中*表示[2,4)，*大*表示[4,6]。方括号表示*包含*其最接近的值，圆括号表示*排除*，所以如果
    0 ≤ *y* < 2，观察值 *y* 将落入小区间；如果 2 ≤ *y* < 4，则落入中区间；如果 4 ≤ *y* ≤ 6，则落入大区间。为此，你可以使用
    `cut` 并将所需的分界区间传递给 `breaks` 参数：
- en: '[PRE80]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This gives you a factor, with each observation now assigned an interval. However,
    notice that your boundary intervals are back-to-front—you want the boundary levels
    on the left like [0,2), rather than the right as they appear by default, (0,2].
    You can fix this by setting the logical argument `right` to `FALSE`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这会给你一个因素，每个观察值现在被分配了一个区间。然而，注意到你的边界区间是颠倒的——你希望边界级别位于左侧，例如 [0,2)，而不是默认情况下位于右侧的
    (0,2]。你可以通过将逻辑参数 `right` 设置为 `FALSE` 来修正这个问题。
- en: '[PRE81]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now you’ve swapped which boundaries are inclusive and exclusive. This is important
    because it changes which categories the values fall into. Notice that the seventh
    observation has changed categories. But there’s still a problem: the final interval
    currently *excludes* 6, and you want this maximum value to be *included* in the
    highest level. You can fix this with another logical argument: `include.lowest`.
    Even though it’s called “`include.lowest`,” this argument can also be used to
    include the *highest* value if `right` is `FALSE`, as indicated in the help file
    `?cut`.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你交换了哪些边界是包含的，哪些是排除的。这很重要，因为它会改变哪些类别值落入。注意第七个观察值的类别已经发生了变化。但是，仍然存在一个问题：当前的最后一个区间*排除了*
    6，而你希望这个最大值能够*包含*在最高的级别中。你可以通过另一个逻辑参数来修正这个问题：`include.lowest`。尽管它被称为“`include.lowest`”，但如果
    `right` 设置为 `FALSE`，这个参数也可以用来包含*最高*值，正如帮助文件 `?cut` 中所指出的那样。
- en: '[PRE82]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The intervals are now defined how you want. Finally, you want to add better
    labels to the categories, rather than using the interval levels that R applies
    by default, by passing a character string vector to the `labels` argument. The
    order of labels must match the order of the levels in the factor object.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，区间已经按你想要的方式定义好了。最后，你希望为类别添加更好的标签，而不是使用 R 默认应用的区间级别，可以通过将一个字符向量传递给 `labels`
    参数来实现。标签的顺序必须与因素对象中的级别顺序匹配。
- en: '[PRE83]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '**Exercise 4.5**'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 4.5**'
- en: 'The New Zealand government consists of the political parties National, Labour,
    Greens, and Māori, with several smaller parties labeled as Other. Suppose you
    asked 20 New Zealanders which of these they identified most with and obtained
    the following data:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 新西兰政府由国家党、工党、绿党和毛利党组成，还有几个较小的党派统称为其他。假设你问了 20 位新西兰人他们最认同哪个党派，并获得了以下数据：
- en: • There were 12 males and 8 females; the individuals numbered 1, 5–7, 12, and
    14–16 were females.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: • 有 12 个男性和 8 个女性；编号为 1、5–7、12、14–16 的个体为女性。
- en: • The individuals numbered 1, 4, 12, 15, 16, and 19 identified with Labour;
    no one identified with Māori; the individuals numbered 6, 9, and 11 identified
    with Greens; 10 and 20 identified with Other; and the rest identified with National.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: • 编号为1、4、12、15、16和19的个体认同工党；没有人认同毛利党；编号为6、9和11的个体认同绿党；10和20认同其他党派；其余认同国民党。
- en: 'Use your knowledge of vectors (for example, subsetting and overwriting) to
    create two character vectors: `sex` with entries `"M"` (male) and `"F"` (female)
    and `party` with entries `"National"`, `"Labour"`, `"Greens"`, `"Maori"`, and
    `"Other"`. Make sure the entries are placed in the correct positions as outlined
    earlier.'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运用你对向量的知识（例如，子集和重写）创建两个字符向量：`sex`，其中包含`"M"`（男性）和`"F"`（女性）；`party`，其中包含`"National"`（国民党）、`"Labour"`（工党）、`"Greens"`（绿党）、`"Maori"`（毛利党）和`"Other"`（其他党派）。确保条目按照前面概述的正确位置放置。
- en: Create two different factor vectors based on `sex` and `party`. Does it make
    any sense to use `ordered=TRUE` in either case? How has R appeared to arrange
    the levels?
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个不同的因子向量，分别基于`sex`和`party`。在这两种情况下使用`ordered=TRUE`是否有意义？R是如何排列这些水平的？
- en: 'Use factor subsetting to do the following:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用因子子集来执行以下操作：
- en: Return the factor vector of chosen parties for only the male participants.
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回仅包含男性参与者所选政党的因子向量。
- en: Return the factor vector of genders for those who chose National.
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回选择国民党参与者的性别因子向量。
- en: Another six people joined the survey, with the results `c("National","Maori","Maori","Labour","Greens","Labour")`
    for the preferred party and `c("M","M","F","F","F","M")` as their gender. Combine
    these results with the original factors from (b).
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 又有六人加入了调查，偏好的政党结果是`c("National","Maori","Maori","Labour","Greens","Labour")`，性别为`c("M","M","F","F","F","M")`。将这些结果与(b)中的原始因子结合起来。
- en: 'Suppose you also asked all individuals to state how confident they were that
    Labour will win more seats in Parliament than National in the next election and
    to attach a subjective percentage to that confidence. The following 26 results
    were obtained: 93, 55, 29, 100, 52, 84, 56, 0, 33, 52, 35, 53, 55, 46, 40, 40,
    56, 45, 64, 31, 10, 29, 40, 95, 18, 61.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你还要求所有参与者陈述他们对工党在下一次选举中获得比国民党更多议席的信心，并为这种信心附加一个主观百分比。以下是获得的26个结果：93，55，29，100，52，84，56，0，33，52，35，53，55，46，40，40，56，45，64，31，10，29，40，95，18，61。
- en: 'Create a factor with levels of confidence as follows: Low for percentages [0,30];
    Moderate for percentages (30,70]; and High for percentages (70,100].'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个表示信心水平的因子，信心水平如下：低为百分比在[0,30]之间；中等为百分比在(30,70]之间；高为百分比在(70,100]之间。
- en: From (e), extract the levels corresponding to those individuals who originally
    said they identified with Labour. Do this also for National. What do you notice?
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从(e)中提取出那些最初表示认同工党的个体所对应的水平。也为国民党提取相应的水平。你注意到什么了吗？
- en: '**Important Code in This Chapter**'
  id: totrans-329
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**本章重要代码**'
- en: '| **Function/operator** | **Brief description** | **First occurrence** |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| **函数/运算符** | **简要描述** | **首次出现** |'
- en: '| --- | --- | --- |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `TRUE`, `FALSE` | Reserved logical values | [Section 4.1.1](ch04.xhtml#ch04lev2sec37),
    [p. 60](ch04.xhtml#page_60) |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| `TRUE`, `FALSE` | 保留的逻辑值 | [第4.1.1节](ch04.xhtml#ch04lev2sec37)，[第60页](ch04.xhtml#page_60)
    |'
- en: '| `T`, `F` | Unreserved versions of above | [Section 4.1.1](ch04.xhtml#ch04lev2sec37),
    [p. 60](ch04.xhtml#page_60) |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| `T`, `F` | 上述的非保留版本 | [第4.1.1节](ch04.xhtml#ch04lev2sec37)，[第60页](ch04.xhtml#page_60)
    |'
- en: '| `==`, `!=`, `>`, `<`, `>=`, `<=` | relational operators | [Section 4.1.2](ch04.xhtml#ch04lev2sec38),
    [p. 61](ch04.xhtml#page_61) |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| `==`, `!=`, `>`, `<`, `>=`, `<=` | 关系运算符 | [第4.1.2节](ch04.xhtml#ch04lev2sec38)，[第61页](ch04.xhtml#page_61)
    |'
- en: '| `any` | Checks whether any entries are `TRUE` | [Section 4.1.2](ch04.xhtml#ch04lev2sec38),
    [p. 63](ch04.xhtml#page_63) |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| `any` | 检查是否有任何条目为`TRUE` | [第4.1.2节](ch04.xhtml#ch04lev2sec38)，[第63页](ch04.xhtml#page_63)
    |'
- en: '| `all` | Checks whether all entries are `TRUE` | [Section 4.1.2](ch04.xhtml#ch04lev2sec38),
    [p. 63](ch04.xhtml#page_63) |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| `all` | 检查所有条目是否为`TRUE` | [第4.1.2节](ch04.xhtml#ch04lev2sec38)，[第63页](ch04.xhtml#page_63)
    |'
- en: '| `&&`, `&`, `&#124;&#124;`, `&#124;`, `!` | logical operators | [Section 4.1.3](ch04.xhtml#ch04lev2sec39),
    [p. 65](ch04.xhtml#page_65) |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| `&&`, `&`, `&#124;&#124;`, `&#124;`, `!` | 逻辑运算符 | [第4.1.3节](ch04.xhtml#ch04lev2sec39)，[第65页](ch04.xhtml#page_65)
    |'
- en: '| `which` | Determines indexes of `TRUE`s | [Section 4.1.5](ch04.xhtml#ch04lev2sec41),
    [p. 69](ch04.xhtml#page_69) |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| `which` | 确定`TRUE`值的索引 | [第4.1.5节](ch04.xhtml#ch04lev2sec41)，[第69页](ch04.xhtml#page_69)
    |'
- en: '| `" "` | Creates a character string | [Section 4.2.1](ch04.xhtml#ch04lev2sec42),
    [p. 73](ch04.xhtml#page_73) |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| `" "` | 创建一个字符字符串 | [第4.2.1节](ch04.xhtml#ch04lev2sec42)，[第73页](ch04.xhtml#page_73)
    |'
- en: '| `nchar` | Gets number of characters in a string | [Section 4.2.1](ch04.xhtml#ch04lev2sec42),
    [p. 73](ch04.xhtml#page_73) |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| `nchar` | 获取字符串中的字符数 | [第4.2.1节](ch04.xhtml#ch04lev2sec42), [第73页](ch04.xhtml#page_73)
    |'
- en: '| `cat` | Concatenates strings (no return) | [Section 4.2.2](ch04.xhtml#ch04lev2sec43),
    [p. 74](ch04.xhtml#page_74) |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| `cat` | 拼接字符串（无返回值） | [第4.2.2节](ch04.xhtml#ch04lev2sec43), [第74页](ch04.xhtml#page_74)
    |'
- en: '| `paste` | Pastes strings (returns a string) | [Section 4.2.2](ch04.xhtml#ch04lev2sec43),
    [p. 74](ch04.xhtml#page_74) |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| `paste` | 拼接字符串（返回一个字符串） | [第4.2.2节](ch04.xhtml#ch04lev2sec43), [第74页](ch04.xhtml#page_74)
    |'
- en: '| `\` | String escape | [Section 4.2.3](ch04.xhtml#ch04lev2sec44), [p. 76](ch04.xhtml#page_76)
    |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| `\` | 字符串转义 | [第4.2.3节](ch04.xhtml#ch04lev2sec44), [第76页](ch04.xhtml#page_76)
    |'
- en: '| `substr` | Subsets a string | [Section 4.2.4](ch04.xhtml#ch04lev2sec45),
    [p. 77](ch04.xhtml#page_77) |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| `substr` | 提取字符串子集 | [第4.2.4节](ch04.xhtml#ch04lev2sec45), [第77页](ch04.xhtml#page_77)
    |'
- en: '| `sub`, `gsub` | String matching and replacement | [Section 4.2.4](ch04.xhtml#ch04lev2sec45),
    [p. 78](ch04.xhtml#page_78) |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| `sub`, `gsub` | 字符串匹配与替换 | [第4.2.4节](ch04.xhtml#ch04lev2sec45), [第78页](ch04.xhtml#page_78)
    |'
- en: '| `factor` | Creates a factor vector | [Section 4.3.1](ch04.xhtml#ch04lev2sec46),
    [p. 80](ch04.xhtml#page_80) |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| `factor` | 创建因子向量 | [第4.3.1节](ch04.xhtml#ch04lev2sec46), [第80页](ch04.xhtml#page_80)
    |'
- en: '| `levels` | Gets levels of a factor | [Section 4.3.1](ch04.xhtml#ch04lev2sec46),
    [p. 81](ch04.xhtml#page_81) |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| `levels` | 获取因子的水平 | [第4.3.1节](ch04.xhtml#ch04lev2sec46), [第81页](ch04.xhtml#page_81)
    |'
- en: '| `cut` | Creates factor from continuum | [Section 4.3.3](ch04.xhtml#ch04lev2sec48),
    [p. 85](ch04.xhtml#page_85) |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| `cut` | 从连续型数据创建因子 | [第4.3.3节](ch04.xhtml#ch04lev2sec48), [第85页](ch04.xhtml#page_85)
    |'
