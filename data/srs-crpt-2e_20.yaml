- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">15</samp> <samp class="SANS_Dogma_OT_Bold_B_11">CRYPTOCURRENCY
    CRYPTOGRAPHY</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">15</samp> <samp class="SANS_Dogma_OT_Bold_B_11">加密货币加密学</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: This chapter wasn’t in the initial edition of this book when it came out in
    fall 2017, a period when cryptocurrency and blockchain were at peak hype. While
    blockchain hasn’t quite lived up to its promises of disrupting several industries,
    it has profoundly influenced cryptographic research and engineering. Blockchain
    applications have brought new exciting problems, attracted fresh talent, and offered
    a novel way to bridge theory and practice.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章并未包含在2017年秋季初版的书中，那时加密货币和区块链正处于 hype 的巅峰期。虽然区块链并未完全实现其颠覆多个行业的承诺，但它已深刻影响了加密学研究和工程领域。区块链应用带来了新的激动人心的挑战，吸引了新的人才，并提供了一种新的方式来弥合理论与实践之间的差距。
- en: Before “crypto” became synonymous with cryptocurrency, cryptographic algorithms
    and protocols largely pertained to standard functionalities such as encryption
    and secure channels. The more arcane protocols were restricted to niche research
    areas and technical articles, typically catering to researchers’ interests and
    presented only in academic conferences. New algorithms were predominantly crafted
    by academic researchers and would see real-world deployment, if ever, after at
    least five years of peer review and analysis and after numerous research papers
    detailing unsuccessful cryptanalysis attempts.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在“加密”成为加密货币的代名词之前，加密算法和协议主要涉及标准功能，如加密和安全通道。那些较为深奥的协议通常局限于小众研究领域和技术文章，通常服务于研究人员的兴趣，并仅在学术会议上呈现。新的算法主要由学术研究人员设计，并且至少在经过五年的同行评审和分析，以及众多未成功破解的加密分析文章之后，才会在现实世界中部署（如果有的话）。
- en: Blockchain turned that process upside down. Much like how the cryptographic
    protocols of Signal and Tor sidestepped the conventional academic route, blockchain
    enthusiasts were less bound by tradition. Groundbreaking protocols often debuted
    in blog posts or informal white papers, with implementation following shortly
    after. Occasionally, they’d forgo written specifications altogether, letting the
    code speak for itself. Only after widespread adoption would academia take notice.
    The most notable case is the Bitcoin protocol, which didn’t undergo formal peer
    review before being deployed.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链颠覆了这一过程。就像Signal和Tor的加密协议避开了传统的学术途径一样，区块链爱好者在某种程度上也不受传统束缚。突破性的协议通常会在博客文章或非正式的白皮书中首次亮相，随后很快进行实现。有时，他们会完全放弃书面规范，让代码本身发声。只有在广泛采用后，学术界才会注意到它们。最著名的案例是比特币协议，在部署之前并没有经过正式的同行评审。
- en: Many seasoned researchers identified novel challenges within the blockchain
    domain, often collaborating directly with blockchain entities. They developed
    complex protocols that not only pushed boundaries and garnered peer recognition
    but also saw rapid real-world implementation, impacting thousands, if not millions,
    of systems. Prime instances include efficient ECDSA threshold signature schemes
    and zero-knowledge proof systems. In some scenarios, existing protocols with little
    practical use found impactful use cases, such as Boneh–Lynn–Shacham (BLS) signatures.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 许多资深研究人员在区块链领域识别出了新颖的挑战，通常与区块链实体直接合作。他们开发了复杂的协议，这些协议不仅突破了边界并获得同行认可，而且在现实世界中得到了迅速实施，影响了成千上万，甚至百万个系统。重要的例子包括高效的ECDSA门限签名方案和零知识证明系统。在某些情况下，现有的几乎没有实际应用的协议找到了具有重大影响的应用场景，例如Boneh–Lynn–Shacham（BLS）签名。
- en: This chapter provides an overview of these cryptographic algorithms and protocols—those
    tailored for blockchain and those that thrived due to it. I won’t delve into defining
    blockchain or its workings, as there are myriad online resources. Instead, I emphasize
    the cryptographic schemes underpinning blockchains, which hold significance irrespective
    of the blockchain use cases. Even if you remain skeptical of the blockchain phenomenon,
    I trust you’ll find this chapter enlightening.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了这些加密算法和协议的概述——那些专为区块链量身定制的协议以及由于区块链而蓬勃发展的协议。我不会深入定义区块链或其工作原理，因为网络上有大量资源可以参考。相反，我强调的是支撑区块链的加密方案，这些方案在任何区块链应用场景中都有重要意义。即使你对区块链现象仍持怀疑态度，我相信你会发现本章内容具有启发性。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Hashing Applications</samp>
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">哈希应用</samp>
- en: 'Hash functions, the Swiss Army knives of cryptography, serve numerous applications
    in blockchain systems, including:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数，密码学的瑞士军刀，在区块链系统中担任着多种应用，包括：
- en: '**Hashing a transaction’s data**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**哈希交易的数据**'
- en: Hash functions can produce a digest signed by the transaction’s issuer, typically
    with ECDSA-secp256k1 or Ed25519\. Verifying the signature ensures that the owner
    of a given address approved of the information hashed, leading to including the
    transaction in the chain’s ledger.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数可以生成由交易发行者签名的摘要，通常使用ECDSA-secp256k1或Ed25519。验证签名确保给定地址的所有者批准了被哈希的信息，从而将交易包含在链的分类帐中。
- en: In the blockchain Ethereum, a transaction’s hash serves as its unique identifier;
    for example, you can enter a hash in the search field of *[https://<wbr>etherscan<wbr>.io](https://etherscan.io)*
    to retrieve the associated transaction. Ethereum transaction hashes use Keccak-256—which
    is similar but not identical to SHA3-256—and process-encoded data. This data includes
    the recipient’s address, the amount of ether (ticker ETH) sent, any smart contract
    input, the gas price and limit, a nonce (increasing for each new transaction),
    and a signature of the transaction.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在以太坊区块链中，交易的哈希作为其唯一标识符；例如，您可以在*[https://<wbr>etherscan<wbr>.io](https://etherscan.io)*的搜索字段中输入哈希来检索相关交易。以太坊交易哈希使用Keccak-256——这与SHA3-256类似但不完全相同——并处理编码数据。该数据包括收款人地址、发送的以太（代号ETH）数量、任何智能合约输入、燃气价格和限制、一个随机数（每个新交易递增）以及交易的签名。
- en: '**Hashing the content of a block**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**哈希块的内容**'
- en: Hash functions can include the digest in the subsequent block to “chain” the
    blocks. For example, each Bitcoin block has a *block header* that includes the
    previous block’s hash, a tree hash of the recorded transactions, and some metadata
    (version, timestamp, nonce, and so on). Bitcoin computes the previous block’s
    hash by hashing the header of the previous block using double SHA-256, or **SHA-256**(**SHA-256**(block
    header)). This unorthodox construction eliminates the risk of length extension
    attacks and adds a safety net in case SHA-256 was found to be insecure—which is
    unlikely.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数可以在后续块中包含摘要以“链接”这些块。例如，每个比特币块都有一个*块头*，其中包括上一个块的哈希，记录的交易的树哈希，以及一些元数据（版本、时间戳、随机数等）。比特币通过对上一个块的头部进行双SHA-256哈希或**SHA-256**（**SHA-256**（块头））来计算上一个块的哈希。这种非正统的构建消除了长度扩展攻击的风险，并在SHA-256被发现不安全时提供了安全保障——尽管这种情况不太可能发生。
- en: Aside from these basic use cases, hash functions are the main building block
    in key components of blockchain systems.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些基本用例外，哈希函数是区块链系统关键组件中的主要构建块。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Merkle Trees</samp>
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Merkle树</samp>
- en: '*Merkle trees* are a type of hash tree, which is a data structure computing
    a root value from leaf values according to a tree pattern. In hash trees, the
    parent node is computed by hashing the child nodes. Merkle trees are, for example,
    used to create a Bitcoin block’s header. They’re named after computer scientist
    Ralph Merkle, whose 1979 cryptographic scheme construction used binary hash trees.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*Merkle树*是一种哈希树，它是一种根据树模式从叶子值计算根值的数据结构。在哈希树中，父节点通过对子节点进行哈希计算而生成。例如，Merkle树用于创建比特币块的头部。它们以计算机科学家拉尔夫·默克尔命名，其1979年的加密方案构建使用了二进制哈希树。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Tree Hashing Computation</samp>
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">树哈希计算</samp>
- en: A Merkle tree takes as input values that constitute its *leaves*—that is, the
    values from which the *root* (the output) is computed. You generally represent
    data structure trees with their root at the top and leaves at the bottom.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Merkle树将构成其*叶子*的值作为输入，即计算其*根*（输出）的值。通常，您将数据结构树的根表示为顶部，叶子表示为底部。
- en: For example, [Figure 15-1](chapter15.xhtml#fig15-1) shows a Merkle tree hashing
    four values (*A*, *B*, *C*, *D*).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[图15-1](chapter15.xhtml#fig15-1)展示了一个Merkle树对四个值（*A*、*B*、*C*、*D*）进行哈希。
- en: '![](../images/fig15-1.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig15-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-1: A hash tree, where
    the leaves are the input and the root is the output</samp>'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图15-1：一个哈希树，其中叶子是输入，根是输出</samp>
- en: 'The tree hashing then works as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，树哈希工作如下：
- en: Hashing each of the four values to obtain the four hashes **H**(*A*), **H**(*B*),
    **H**(*C*), and **H**(*D*).
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对四个值中的每一个进行哈希以获得四个哈希**H**（*A*）、**H**（*B*）、**H**（*C*）和**H**（*D*）。
- en: Hashing together each consecutive pair of hashes to obtain **H**(**H**(*A*)
    || **H**(*B*)) and **H**(**H**(*C*) || **H**(*D*)). Here you concatenate the hash
    values (as the || symbol denotes).
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将每一对连续的哈希值组合起来得到**H**(**H**(*A*) || **H**(*B*))和**H**(**H**(*C*) || **H**(*D*)）。这里你将哈希值进行连接（如符号||所示）。
- en: 'Hashing the two hashes together to obtain the root of the tree, which is the
    final output of the tree hashing: **H**(**H**(**H**(*A*) || **H**(*B*)) || **H**(**H**(*C*)
    || **H**(*D*))).'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将两个哈希值组合在一起，得到树的根节点，这是树哈希的最终输出：**H**(**H**(**H**(*A*) || **H**(*B*)) || **H**(**H**(*C*)
    || **H**(*D*))).
- en: If you omit the initial hashing of the input values—which is necessary only
    if the values aren’t already the size of the hash—you go from four values to one
    with a tree of two layers, or of *height* two. Note that while the input data
    may be a different size, all hash values are the same size. Generally, a tree
    of *n* layers has 2*^n* leaves, allowing you to process up to 2*^n* values by
    computing 2*^n* – 1 hashes from the (hashed) leaves.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略了输入值的初始哈希——仅在输入值不是哈希大小时才需要——你将从四个值开始，最终得到一个具有两层树结构的单一值，或者说*高度*为二。注意，虽然输入数据可能具有不同的大小，但所有哈希值的大小都是相同的。通常，一个*高度*为*n*的树具有2*^n*个叶子，允许你通过计算2*^n*
    - 1个哈希值（从哈希后的叶子开始）来处理最多2*^n*个值。
- en: If the number of input values isn’t exactly 2*^n* for some integer *n*, a common
    technique is to add dummy values (for example, set to zero or to the last value
    in the list); the padding rule should, however, be carefully chosen to avoid trivial
    collisions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入值的数量不是2*^n*（对于某个整数*n*），一种常见的技术是添加虚拟值（例如，将其设为零或列表中的最后一个值）；但是，填充规则应该仔细选择，以避免出现简单的冲突。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Merkle Proofs</samp>
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Merkle证明</samp>
- en: A Merkle tree’s structure can be leveraged to prove that a given value belongs
    to the list of 2*^n* values hashed without recomputing the whole tree (which takes
    on the order of 2*^n* operations) but only in time proportional to the *height*
    of the tree—that is, its number of layers *n*. Depending on the context, such
    proofs are called a *membership path*, an *inclusion proof*, or a *Merkle proof*.
    This is a Merkle tree’s killer feature, which general-purpose hash functions don’t
    offer.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Merkle树的结构可以用来证明某个给定的值属于被哈希的2*^n*个值的列表，而无需重新计算整个树（这将涉及2*^n*次操作），而只需要与树的*高度*（即其层数*n*）成比例的时间。根据具体情况，这种证明被称为*成员路径*、*包含证明*或*Merkle证明*。这是Merkle树的一个杀手级特性，而通用哈希函数则不提供这一功能。
- en: '[Figure 15-2](chapter15.xhtml#fig15-2) shows how this works. The shaded cells
    are the values sufficient to prove that *V*[1] is one of the values hashed to
    obtain the root.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[图15-2](chapter15.xhtml#fig15-2)展示了这一过程的工作原理。阴影单元格是足够证明*V*[1]是被哈希得到根节点的值之一。'
- en: '![](../images/fig15-2.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig15-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-2: A Merkle tree,
    wherein the shaded cells constitute the membership path of</samp> <samp class="SANS_Futura_Std_Book_11">A</samp>'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图15-2：一个Merkle树，其中阴影单元格构成了</samp>
    <samp class="SANS_Futura_Std_Book_11">A</samp>的成员路径
- en: 'Say you want to prove that *A* was one of the values hashed, without revealing
    *B*, *C*, or *D*. First, hash *A* to obtain the actual leaf of the hash tree.
    Then, assume that you’ve received *A*’s membership path, which consists of the
    other shaded values, **H**(*B*) and **H**(**H**(*C*) || **H**(*D*)). To verify
    that *A* belongs to the tree, compute the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想证明*A*是被哈希的值之一，而不暴露*B*、*C*或*D*。首先，对*A*进行哈希处理，得到哈希树的实际叶子节点。然后，假设你已经收到了*A*的成员路径，该路径包含其他阴影值，**H**(*B*)和**H**(**H**(*C*)
    || **H**(*D*)）。为了验证*A*是否属于这棵树，计算以下内容：
- en: '*X* = **H**(**H**(*A*) || **H**(*B*)), since you know *A* and **H**(*B*)'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*X* = **H**(**H**(*A*) || **H**(*B*))，因为你知道*A*和**H**(*B*)'
- en: '**H(H**(*X*) || **H**(**H**(*C*) || **H**(*D*))), since you know **H**(**H**(*C*)
    || **H**(*D*))'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**H(H**(*X*) || **H**(**H**(*C*) || **H**(*D*)))，因为你知道**H**(**H**(*C*) || **H**(*D*))'
- en: It took only two hashes of sibling values to prove *A*’s inclusion, or as many
    hashes as the height of the tree. A tree with eight leaves has a height of three;
    thus, a membership path verification needs three sibling hashes. With 16 leaves,
    you need four sibling hashes, and so on, with *n* sibling hashes for a tree with
    2*^n* leaves.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过两次哈希操作就能证明*A*的包含性，或者根据树的高度，进行的哈希操作次数即为树的高度。具有八个叶子的树的高度为三；因此，验证成员路径需要三个兄弟哈希。对于16个叶子，您需要四个兄弟哈希，以此类推，对于具有2*^n*个叶子的树，需要*n*个兄弟哈希。
- en: Blockchain applications often use Merkle trees to hash transactions into a single
    *Merkle root*, such as that included in a Bitcoin block header. A typical Bitcoin
    block registers about 2,000 transactions, which requires a tree of height 11 (2^(11)
    = 2,048). In this case, it takes 2,048 – 1 = 2,047 sibling hashes to compute the
    root from the leaves, where each leaf is the hash of a transaction’s data. Each
    hash computes a double SHA-256, so in the case of 2,048 transactions, it takes
    2,047 + 2,048 = 4,095 double SHA-256s, or 8,190 calls to SHA-256.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链应用通常使用梅克尔树将交易哈希成一个单一的*梅克尔根*，例如比特币区块头中包含的那个。一个典型的比特币区块注册大约2,000个交易，这需要一个高度为11的树（2^(11)
    = 2,048）。在这种情况下，从叶子节点计算根节点需要2,048 - 1 = 2,047个兄弟哈希，每个叶子节点是交易数据的哈希。每个哈希计算一次双重SHA-256，因此，在2,048个交易的情况下，需要2,047
    + 2,048 = 4,095次双重SHA-256计算，或者8,190次SHA-256调用。
- en: 'Ethereum uses a slightly more complex tree-based data structure, combining
    Merkle trees with *Patricia tries* (this is not a typo; “trie” comes from “retrieval”),
    a tree-like structure that stores key-value pairs. This structure serves Ethereum’s
    state-based model, which significantly differs from Bitcoin’s UTXO (unspent transaction
    output) model, for which simpler Merkle trees are sufficient.  #### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Proof
    of Work</samp>'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '以太坊使用一种稍微复杂的基于树的数据结构，将梅克尔树与*帕特里夏树*（这不是打字错误；“trie”来自“检索”）结合起来，帕特里夏树是一种存储键值对的树状结构。该结构服务于以太坊的状态模型，这与比特币的UTXO（未花费交易输出）模型有显著不同，后者对于简单的梅克尔树就足够了。
    #### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">工作量证明</samp>'
- en: Proof of work (PoW) is arguably the most critical component of a blockchain’s
    consensus protocol—for those based on PoW rather than proof of stake (PoS) or
    other protocols.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 工作量证明（PoW）可以说是区块链共识协议中最关键的组成部分——对于那些基于PoW而非权益证明（PoS）或其他协议的区块链。
- en: A *PoW* is essentially a hash function that takes some fixed inputs and variable
    inputs and whose result must match a certain pattern to be valid. Parties that
    aim to *solve* a PoW repeatedly compute the hash with different values of the
    variable inputs until the result satisfies some constraint.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*PoW*本质上是一个哈希函数，它接受一些固定输入和可变输入，并且其结果必须匹配某种模式才能有效。旨在*解决* PoW的各方会重复计算哈希，使用不同的可变输入值，直到结果满足某种约束条件。'
- en: For example, in Bitcoin and some other PoW-based blockchains, the constraint
    is that the hash value when seen as a 256-bit number must be less than a given
    number. This can also be seen as the hash value having a given number of leading
    zeros, when seeing the hash as the big-endian encoding of a 256-bit number.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在比特币和一些其他基于PoW的区块链中，约束条件是将哈希值视为一个256位数字时，该值必须小于给定的数字。也可以将其视为哈希值具有一定数量的前导零，前提是将哈希值视为一个256位数字的大端编码。
- en: For example, in 2022 the highest Bitcoin difficulty value (as reported on *[https://<wbr>btc<wbr>.com<wbr>/stats<wbr>/diff](https://btc.com/stats/diff)*)
    was 34,244,331,613,176, or approximately 2^(45). You multiply this by 2^(32) to
    find the actual value that the hash must be less than, 2^(77). For each block,
    all the network participants (*miners*) jointly compute in the order of 2^(77)
    double SHA-256 computations to find a solution to the PoW. Such a solution consists
    of a nonce (the variable part of the PoW hash’s input) that yields a hash value
    less than 2^(77). The fixed part of the PoW hash’s input consists of the block
    header values (version, previous block hash, Merkle tree root, timestamp, and
    difficulty target value).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在2022年，比特币的最高难度值（如* [https://<wbr>btc<wbr>.com<wbr>/stats<wbr>/diff](https://btc.com/stats/diff)
    *上报道）是34,244,331,613,176，约为2^(45)。你将其乘以2^(32)，得到哈希值必须小于的实际值，即2^(77)。对于每个区块，所有网络参与者（*矿工*）共同计算大约2^(77)次双重SHA-256计算，以找到PoW的解决方案。这样的解决方案包括一个nonce（PoW哈希输入的可变部分），该nonce使哈希值小于2^(77)。PoW哈希输入的固定部分包括区块头的值（版本、前一个区块哈希、梅克尔树根、时间戳和难度目标值）。
- en: Without a PoW “slowing down” the production of blocks in a blockchain, new valid
    blocks could be produced instantaneously, meaning that histories of transactions
    could be produced and re-created at will. It would be impossible to achieve *finality*
    (that is, the assurance that a block, and thus a set of transactions, cannot be
    reverted or changed once accepted by the network). In particular, it would be
    impossible to protect the network against *double spending*, or spending the same
    coins in two distinct transactions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有PoW“减缓”区块链中区块生产的速度，新有效区块可能会瞬间生成，这意味着交易历史可以随意创建和重建。这样就不可能实现*最终性*（即，一旦区块被网络接受，不能被撤回或更改，交易也无法被修改）。特别是，无法保护网络免受*双重支付*攻击，即在两笔不同交易中花费相同的币。
- en: 'Not all PoW schemes are as simple as Bitcoin’s, which uses a general-purpose
    hash function (SHA-256). Several PoWs attempted to make its computation on dedicated
    hardware less efficient compared to general-purpose CPUs to discourage the centralization
    of mining by organizations investing in the development of optimized hardware
    miner technology—as opposed to off-the-shelf servers and computers that anyone
    can use. Implemented tricks include the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有PoW方案都像比特币那样简单，它使用了一种通用哈希函数（SHA-256）。一些PoW尝试使其在专用硬件上的计算效率低于通用CPU，从而阻止由投资于优化硬件矿机技术的组织垄断挖矿——与任何人都能使用的现成服务器和计算机不同。实施的技巧包括以下几种：
- en: '**Memory hardness **You can force the PoW to use a large amount of memory,
    typically by generating a huge table and accessing at unpredictable addresses.
    For example, Ethereum’s PoW used the Ethash algorithm, which required approximately
    4GB of memory. (In September 2022, Ethereum abandoned Ethash and switched from
    a PoW to a proof-of-stake mechanism.)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存难度** 你可以强迫工作量证明（PoW）使用大量内存，通常通过生成一个巨大的表格并访问不可预测的地址。例如，以太坊的PoW使用了Ethash算法，需要大约4GB的内存。（在2022年9月，以太坊放弃了Ethash，并从PoW机制切换为权益证明机制。）'
- en: '**Virtual machines **As some malware do, you can create a custom set of computer
    instructions that would be translated to standard instructions by a virtual machine
    application, while also potentially using a large amount of memory to compute
    a PoW’s solution. This is the approach of RandomX, a PoW algorithm adopted by
    the Monero blockchain.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**虚拟机** 就像一些恶意软件那样，你可以创建一组自定义的计算机指令，这些指令将由虚拟机应用程序转换为标准指令，同时还可能使用大量内存来计算PoW的解决方案。这是Monero区块链采用的PoW算法——RandomX的做法。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Hierarchical Key
    Derivation</samp>
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">分层密钥派生</samp>
- en: 'Blockchain users generally want to manage multiple accounts, such that each
    account consists of a key pair where:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链用户通常希望管理多个账户，每个账户由一对密钥组成，其中：
- en: The *private key* must be secret, as it’s the signing key required to sign transactions
    and transfer funds from the account.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*私钥*必须保密，因为它是签名密钥，用于签署交易并从账户中转移资金。'
- en: The *public key* must be public, as it’s used to verify signatures of transactions.
    It’s also the value from which the account’s address is derived. For example,
    Bitcoin derives addresses from a public key using a combination of SHA-256 and
    RIPEMD-160 hashing. Note that in some blockchains, such as Bitcoin, the public
    key is not public until the account issues a transaction.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*公钥*必须公开，因为它用于验证交易的签名。它也是从中衍生出账户地址的值。例如，比特币通过SHA-256和RIPEMD-160哈希的组合从公钥衍生出地址。需要注意的是，在一些区块链中，如比特币，公钥在账户发起交易之前并不公开。'
- en: To reliably manage all these keys, blockchain developers defined *hierarchical
    deterministic wallets (HD wallets)*, which make key management less cumbersome
    and risky than having to generate and back up a fresh random key for each new
    account.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可靠地管理所有这些密钥，区块链开发人员定义了*分层确定性钱包（HD钱包）*，这种方式比为每个新账户生成并备份一个随机密钥更加简便且减少风险。
- en: With HD wallets, you generate and store one secret, the *seed* (also called
    the *master key* or *entropy*). This seed is the only randomly generated value
    and the only one providing entropy, or uncertainty, and therefore secrecy to the
    private signing keys derived from it. Wallet software applications often encode
    the seed as a *seed phrase*, or *mnemonic*, a sequence of 12 to 24 words that
    makes it easier to save and memorize.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 HD 钱包时，你生成并存储一个秘密，即*种子*（也称为*主密钥*或*熵*）。该种子是唯一随机生成的值，是唯一提供熵或不确定性，从而保证通过它推导出来的私有签名密钥的保密性。因此，钱包软件应用通常将种子编码为*种子短语*或*助记符*，这是一组由
    12 到 24 个单词组成的序列，便于保存和记忆。
- en: 'Let’s review how this key derivation works using the HMAC-SHA-512 pseudorandom
    function (the HMAC construction instantiated with SHA-512): from a seed *S* of
    128 or 256 bits, compute HMAC-SHA-512 with the seed as a key input, and as a message
    input an identifier of the underlying elliptic curve (a string that can be “Bitcoin
    seed,” “Nist256p1 seed,” or “ed25519 seed”). The first 256 bits of the result
    are the master key, *k*, and the last 256 bits are the master chain code, *c*,
    a value used to derive more keys.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下如何使用 HMAC-SHA-512 伪随机函数（通过 SHA-512 实现的 HMAC 构造）来执行此密钥推导：从一个 128 或 256
    位的种子 *S* 开始，使用该种子作为密钥输入计算 HMAC-SHA-512，将底层椭圆曲线的标识符作为消息输入（该字符串可以是“比特币种子”，“Nist256p1
    种子”或“ed25519 种子”）。结果的前 256 位是主密钥 *k*，后 256 位是主链码 *c*，该值用于推导更多的密钥。
- en: 'You can derive a *child private key* from *k* and *c* as follows, given an
    identifier *i* (a number at most 2^(31)): compute HMAC-SHA-512 with the chain
    code *c* as a key, and a message including *k* and *i*. The 512-bit result is
    parsed as a 256-bit value *L* followed by a 256-bit chain code *R*. In simplified
    notation, *L* || *R* = HMAC-SHA-512(*c*, *k* || *i*). You then set the child private
    key to *k* + *L*, and its chain code is *R*.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 *k* 和 *c* 推导一个*子私钥*，方法如下：给定一个标识符 *i*（最大为 2^(31) 的数字），使用链码 *c* 作为密钥计算 HMAC-SHA-512，并将
    *k* 和 *i* 作为消息输入。512 位的结果被解析为 256 位的值 *L*，后跟 256 位的链码 *R*。简化表示为 *L* || *R* = HMAC-SHA-512(*c*,
    *k* || *i*)。然后将子私钥设置为 *k* + *L*，其链码为 *R*。
- en: 'You can in turn derive keys from the obtained key and chain code to establish
    a key *hierarchy*. For example, from the key with index 0, you derive all your
    keys for Bitcoin, and from the key with index 60, you derive all your keys for
    Ethereum. Conventions associating a number to each blockchain network are standardized
    as part of the document “SLIP-0044: Registered Coin Types for BIP-0044.”'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以依此推导密钥，并通过获得的密钥和链码建立密钥的*层次结构*。例如，从标识符为 0 的密钥推导出所有比特币的密钥，从标识符为 60 的密钥推导出所有以太坊的密钥。将一个数字与每个区块链网络关联的约定已在文档“SLIP-0044:
    BIP-0044 注册硬币类型”中标准化。'
- en: If you first derive a child key with identifier 0 and next derive a key with
    identifier (say) 29 from this key and its chain code, then the key’s *derivation
    path* is 0/29\. You’ll have done two calls of HMAC-SHA-512, yielding, respectively,
    *L*[1] and *L*[2] as their first 256 bits, and the final private key is *k* +
    *L*[1] + *L*[2]. Therefore, you can see all keys derived from a given master key
    *k* as *k* plus the sum of values HMAC-SHA-512 returns. This derivation is called
    *hardened* because you need both the private key *k* and the chain code *c* of
    the parent key.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你首先通过标识符 0 推导一个子密钥，然后再通过该密钥及其链码推导一个标识符为（假设）29的密钥，那么该密钥的*推导路径*为 0/29。你将执行两次
    HMAC-SHA-512 调用，分别生成*L*[1]和*L*[2]作为它们的前 256 位，最终的私钥为 *k* + *L*[1] + *L*[2]。因此，你可以将所有由给定主密钥
    *k* 推导的密钥视为 *k* 加上 HMAC-SHA-512 返回的值的总和。此推导称为*硬化*，因为你需要父密钥的私钥 *k* 和链码 *c*。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*For the* nonhardened *version, use the public key instead of the private key,
    which allows you to determine the public key of a child key from its parent public
    key. For more details, see the initial Bitcoin standard document “BIP32: Hierarchical
    Deterministic Wallets” and its generalized standard document “SLIP-0010: Universal
    Private Key Derivation from Master Private Key.”*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于* 非硬化 *版本，请使用公钥而不是私钥，这样可以从父公钥确定子公钥。详细信息，请参阅初始比特币标准文档“BIP32: 分层确定性钱包”和其通用标准文档“SLIP-0010:
    从主私钥推导通用私钥”。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Algebraic Hash Functions</samp>
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">代数哈希函数</samp>
- en: Hash functions like SHA-3 and BLAKE3 operate on *bytes*, or on *words* of 4
    or 8 bytes, where a byte is a chunk of 8 bits. The input data is a sequence of
    bytes, where each byte can take any of the 256 possible values from 0x00 to 0xff
    (255), and likewise the output data is a sequence of arbitrary bytes. This works
    well when using data efficiently converted into a sequence of bytes and when operations
    on bytes or words are efficient (such as XOR, word bit shift, and integer addition).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数如 SHA-3 和 BLAKE3 作用于*字节*，或者 4 字节或 8 字节的*字*，其中一个字节是 8 位的一个数据单元。输入数据是一系列字节，每个字节可以取从
    0x00 到 0xff（255）之间的 256 个可能值，输出数据同样是任意字节的序列。当数据有效地转化为字节序列时，并且字节或字的操作（如 XOR、字移位和整数加法）高效时，这种方式效果很好。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Mathematical Computer</samp>
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">数学计算机</samp>
- en: Say you have a computer that works with numbers only in a given range, such
    as numbers modulo 13\. The XOR operation won’t do well with such numbers, because
    not all 4-bit numbers are less than 13; for example, a XOR between 10 and 4 will
    give you 14, which is out of range. You might reduce it modulo 13 to obtain 1,
    but then 10 XOR 4 yields the same result as 10 XOR 11, a problem you don’t have
    when working with bytes. This tends to significantly reduce the security of the
    hash function—through collisions, for example.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一台计算机，它只能处理特定范围内的数字，比如模 13 的数字。XOR 操作对这些数字的效果不好，因为并非所有 4 位数字都小于 13；例如，10
    和 4 的 XOR 运算结果是 14，这超出了范围。你可能会将结果按模 13 进行缩减，得到 1，但这样一来，10 XOR 4 和 10 XOR 11 会产生相同的结果，而在处理字节时不会出现这种问题。这通常会显著降低哈希函数的安全性——例如，通过碰撞。
- en: 'Even worse, your computer knows only operations modulo 13: addition, subtraction,
    multiplication, and division. It doesn’t have a built-in bitwise XOR instruction,
    so it simulates it with its modulo 13 arithmetic instructions, which isn’t straightforward
    or computationally efficient. I’ll leave the details of this simulation as an
    exercise.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟的是，你的计算机只能进行模 13 的运算：加法、减法、乘法和除法。它没有内建的按位 XOR 指令，所以只能用模 13 的算术运算来模拟，这既不直接也不高效。我将把这个模拟过程的细节留给你作为练习。
- en: Your task is to create a hash function that works only (or mostly) with arithmetic
    operations for the given range of numbers and doesn’t use bitwise operations including
    XOR, OR, AND, or bit shifts.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你的任务是创建一个只使用（或主要使用）算术运算的哈希函数，适用于给定数字范围，并且不使用按位操作，包括 XOR、OR、AND 或位移运算。
- en: You need this kind of function to efficiently run certain advanced cryptographic
    protocols—namely, multiparty computation (MPC) and zero-knowledge proofs, which
    you’ll see later in this chapter. Such protocols often operate in the realm of
    mathematical structures such as finite fields (for example, sets of integers modulo
    a prime number) and sometimes have to “convert” a program into mathematical equations.
    In principle, you can convert any program into equations. But when the program
    isn’t optimized for the underlying math structure, the equations get very large
    and slow to compute. *Algebraic hash functions* aim to address this issue by designing
    hash functions that are both secure and easy to implement with only arithmetic
    operations in a finite field.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要这种类型的函数来高效地运行某些高级加密协议——即多方计算（MPC）和零知识证明，后面你将看到这一章的内容。此类协议通常在数学结构的范围内操作，比如有限域（例如，模素数的整数集合），有时还需要将程序“转化”为数学方程。从原则上讲，任何程序都可以转化为方程。但当程序没有针对底层数学结构进行优化时，方程会变得非常庞大且计算缓慢。*代数哈希函数*旨在通过设计既安全又易于仅使用有限域中的算术运算实现的哈希函数来解决这个问题。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Design Principles</samp>
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">设计原则</samp>
- en: Let’s consider the design principles of *Poseidon*, a hash function designed
    in 2019 for zero-knowledge proof systems and rapidly adopted by many blockchain
    systems. Such proofs sometimes have to express a hash function as a circuit of
    arithmetic operations over a large finite field, such as those of integers modulo
    a 255-bit prime number. In that case, Poseidon proved orders of magnitude more
    efficient than general-purpose hash functions like SHA-256.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来考虑 *Poseidon* 的设计原则，这是一个在 2019 年为零知识证明系统设计的哈希函数，并迅速被许多区块链系统采纳。这类证明有时需要将哈希函数表示为一个关于大有限域的算术运算电路，比如模
    255 位素数的整数集合。在这种情况下，Poseidon 比像 SHA-256 这样的通用哈希函数高效几个数量级。
- en: Poseidon uses the sponge hash function construction (see [Chapter 7](chapter7.xhtml)),
    so it needs to construct a *permutation*, an invertible transformation with input
    and output of the same size. It applies this permutation to a state that is a
    vector of finite field elements. In the relevant applications, such a finite field
    usually consists of numbers modulo a prime, which may be as small as 31 bits and
    as large as 381 bits, depending on the application.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Poseidon 使用海绵哈希函数构造（参见 [第 7 章](chapter7.xhtml)），因此需要构建一个 *置换*，这是一种输入输出大小相同的可逆变换。它将这个置换应用于一个有限域元素的向量状态。在相关应用中，这样的有限域通常由模素数的数字组成，大小可能从
    31 位小到 381 位不等，具体取决于应用。
- en: Then, like most hash functions, the permutation iterates a series of rounds,
    so it needs to design a *round function*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，像大多数哈希函数一样，置换会迭代一系列轮次，因此需要设计一个 *轮次函数*。
- en: 'Finally, Poseidon breaks down its permutation into three layers, with three
    different purposes, reminiscent of AES’s rounds:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Poseidon 将其置换分解为三个层，具有三个不同的目的，类似于 AES 的轮次：
- en: A *unicity* layer, *AddRoundConstants*, which Poseidon notes as *ARC*() in the
    documentation. This adds constant values to the state’s elements, such that the
    constants are different for each round. Making each round unique prevents attacks
    including the slide attack. To avoid defining and storing many constants, Poseidon
    generates constants from a deterministic random bit generator initialized with
    an encoding of the Poseidon instance characteristics (number of rounds, finite
    field, S-box type, and so on).
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *唯一性* 层，*AddRoundConstants*，在 Poseidon 文档中标记为 *ARC*()。这个层向状态的元素添加常数值，使得每一轮的常数都不同。使每一轮具有唯一性可以防止包括滑动攻击在内的攻击。为了避免定义和存储许多常数，Poseidon
    使用一个确定性随机位生成器来生成常数，该生成器初始化时使用 Poseidon 实例特征（如轮次数量、有限域、S-box 类型等）的编码。
- en: A *nonlinear* layer or *S-box layer*, *SubWords*, which Poseidon’s documentation
    notes as *S*. This layer adds *confusion*, the property that the input and output
    values of the function are related by high-degree algebraic equations—and thus
    are as far as possible from linear and low-degree equations, which differential
    cryptanalysis can exploit. S-box transforms each element of its state independently
    of the others, typically mapping a field element *x* to *x*³ or *x*⁵. The exponent
    is kept relatively low to be efficiently computed.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *非线性* 层或 *S-box 层*，*SubWords*，在 Poseidon 文档中标记为 *S*。这个层引入了 *混淆*，即输入和输出值之间通过高阶代数方程关联的特性——因此它们尽可能远离线性和低阶方程，后者是差分密码分析可以利用的。S-box
    会独立地转换其状态的每个元素，通常将域元素 *x* 映射到 *x*³ 或 *x*⁵。指数保持相对较低，以便高效计算。
- en: A *linear* layer, *MixLayer*, which Poseidon notes as *M*() in the documentation.
    MixLayer brings *diffusion*, or the propagation of differences in the initial
    state across all elements. For example, if the state consists of the four-element
    vector (*x*[1], *x*[2], *x*[3], *x*[4]), then *M*() replaces each element with
    a linear combination of all elements. It might replace *x*[1] with the result
    of 2*x*[1] + 10*x*[2] + *x*[3] + 3*x*[4]. Such a transformation corresponds to
    a multiplication of a vector by a matrix. Poseidon’s matrices must satisfy certain
    security properties and should be designed for efficient implementation.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *线性* 层，*MixLayer*，在 Poseidon 文档中标记为 *M*()。MixLayer 引入了 *扩散*，即初始状态中各元素之间差异的传播。例如，如果状态由四元素向量（*x*[1],
    *x*[2], *x*[3], *x*[4]）组成，则 *M*() 会将每个元素替换为所有元素的线性组合。它可能会用 2*x*[1] + 10*x*[2]
    + *x*[3] + 3*x*[4] 的结果替换 *x*[1]。这样的变换对应于将一个向量乘以一个矩阵。Poseidon 的矩阵必须满足某些安全性要求，并应为高效实现而设计。
- en: 'A *full round* of Poseidon applies the three layers in this order: *ARC*(),
    *S* to each element, and *M*(). A *partial round* applies *S* to only one element
    and may use a different matrix in *M*(). A Poseidon *instance* then iterates full
    rounds, partial rounds, and full rounds—the number of which depends on the instance,
    number of elements, finite field, and target security level.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *完整轮次* 的 Poseidon 按以下顺序应用三个层：*ARC*()，*S* 到每个元素，再应用 *M*()。一个 *部分轮次* 只对一个元素应用
    *S*，并且可能在 *M*() 中使用不同的矩阵。一个 Poseidon *实例* 会反复执行完整轮次、部分轮次和完整轮次——这些轮次的数量取决于实例、元素数量、有限域和目标安全等级。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*For more details on Poseidon, see* [https://<wbr>www<wbr>.poseidon<wbr>-hash<wbr>.info](https://www.poseidon-hash.info)
    *as well as the initial Poseidon paper (*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2019<wbr>/458<wbr>.pdf](https://eprint.iacr.org/2019/458.pdf)*)
    and the improved design Poseidon2 paper (*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2023<wbr>/323<wbr>.pdf](https://eprint.iacr.org/2023/323.pdf)*).*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*欲了解更多关于Poseidon的详细信息，请参见* [https://<wbr>www<wbr>.poseidon<wbr>-hash<wbr>.info](https://www.poseidon-hash.info)
    *以及初始的Poseidon论文(*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2019<wbr>/458<wbr>.pdf](https://eprint.iacr.org/2019/458.pdf)*)和改进版Poseidon2论文(*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2023<wbr>/323<wbr>.pdf](https://eprint.iacr.org/2023/323.pdf)*)。*'
- en: Poseidon is one of many algebraic hash functions created to address practical
    use cases. Other designs include MiMC, Monolith, Rescue-Prime, and Tip5.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Poseidon是为了解决实际应用问题而创建的众多代数哈希函数之一。其他设计包括MiMC、Monolith、Rescue-Prime和Tip5。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">How Things Can Go
    Wrong</samp>
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">事情是如何出错的</samp>
- en: Let’s look at some security failures that involve hash functions and their applications
    in the blockchain world.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下在区块链世界中涉及哈希函数及其应用的一些安全失败案例。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Broken Custom Hash</samp>
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">破损的自定义哈希</samp>
- en: The 2017 blockchain project Iota was quite weird. It claimed to use an architecture
    different from the sequential chain of blocks of most blockchains, closer to direct
    acyclic graph (DAG), which was much less secure. It also encoded data not in bits
    but in *trits*, units taking three values instead of two, supposedly to make computations
    more efficient on processors that don’t exist.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 2017年的区块链项目Iota相当奇怪。它声称采用不同于大多数区块链顺序区块链结构的架构，更接近直接无环图（DAG），这使得它的安全性大大降低。它还不是用位来编码数据，而是用*三值*（trit），这种单位有三种值而不是两种，目的是让计算在不存在的处理器上更高效。
- en: Iota didn’t use an elliptic curve-based signature scheme like ECDSA or Ed25519
    but rather a hash-based signature scheme based on the established Winternitz construction,
    thus offering post-quantum security—except Iota also designed its own custom hash
    function, Curl.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Iota并没有使用像ECDSA或Ed25519那样基于椭圆曲线的签名方案，而是使用了一种基于已建立的Winternitz结构的基于哈希的签名方案，从而提供了后量子安全性——然而Iota也设计了自己的自定义哈希函数Curl。
- en: Iota became one of the top 10 most popular cryptocurrencies and made grandiose
    claims about its potential usefulness and its security. But its custom hash function,
    which it claimed to develop with the aid of artificial intelligence, turned out
    to be very weak against collision attacks. Using off-the-shelf hardware, researchers
    found collisions within minutes, which could be exploited only in contrived attack
    scenarios. Iota quickly patched its hash function.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Iota 成为了十大最流行的加密货币之一，并对其潜在的有用性和安全性做出了宏大的声明。但它声称通过人工智能的帮助开发的自定义哈希函数，在碰撞攻击面前却非常脆弱。研究人员使用市售硬件，在几分钟内就发现了碰撞，这些碰撞仅在设计好的攻击场景中才能被利用。Iota
    很快修补了其哈希函数。
- en: After this fiasco, renowned cryptography and security expert Bruce Schneier
    commented, “In 2017, leaving your crypto algorithm vulnerable to differential
    cryptanalysis is a rookie mistake. It says that no one of any caliber analyzed
    their system, and that the odds that their fix makes the system secure is low.”
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次失败之后，著名的密码学和安全专家布鲁斯·施奈尔评论道：“在2017年，让你的加密算法容易受到差分密码分析攻击是一个新手错误。这表明没有任何有能力的人分析他们的系统，而他们的修复措施让系统变得安全的可能性很低。”
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Wallet with Low Entropy</samp>'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">低熵钱包</samp>'
- en: The hierarchical key derivation model from earlier in this section is secure
    on paper but in practice only if it’s implemented correctly. You can usually verify
    this using test vectors within the BIP32 and SLIP-0010 standard documents. If
    you obtain the same input/output values as those documented, your implementation
    is likely correct, though not necessarily secure.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 本节早些时候提到的分层密钥派生模型在理论上是安全的，但在实践中只有在正确实现时才是安全的。通常可以通过使用BIP32和SLIP-0010标准文档中的测试向量来验证这一点。如果你得到的输入/输出值与文档中记录的相同，那么你的实现很可能是正确的，尽管不一定是安全的。
- en: In 2022, the popular cryptocurrency mobile wallet application Trust Wallet announced
    the release of a browser extension version that used WebAssembly (Wasm) technology
    to run efficiently on different browsers. However, Wasm couldn’t use the same
    PRNG as the mobile versions; it had to define a different one.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 2022 年，流行的加密货币移动钱包应用 Trust Wallet 宣布发布了一款浏览器扩展版本，采用 WebAssembly（Wasm）技术，能够在不同的浏览器中高效运行。然而，Wasm
    无法使用与移动版本相同的 PRNG，它必须定义一个不同的 PRNG。
- en: A poor PRNG can be cryptography’s Achilles’ heel (see [Chapter 2](chapter2.xhtml)).
    In Trust Wallet, the developers used the Mersenne Twister PRNG (mt19937), which
    is not a cryptographic PRNG. Its entropy is at most 32 bits, and it produces its
    output bits using simple linear combinations of the internal state values.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一个糟糕的 PRNG 可能是加密学的致命弱点（参见 [第二章](chapter2.xhtml)）。在 Trust Wallet 中，开发者使用了 Mersenne
    Twister PRNG（mt19937），它并不是一个加密学 PRNG。它的熵最多为 32 位，且通过对内部状态值的简单线性组合来生成输出比特。
- en: As Trust Wallet’s PRNG had 32 bits of entropy, it could generate only 2^(32)
    different seeds for users’ wallets. An attacker could then compute all the 2^(32)
    possible seeds and, for each seed, compute the private keys and addresses derived
    using hierarchical key derivation. They could then scan blockchains to find addresses
    generated by Trust Wallet and steal their tokens. The Ledger company researchers
    who found the flaw commented, “Running such an attack takes much more than a couple
    of hours, but is doable with a few GPUs in less than a day.”
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Trust Wallet 的 PRNG 具有 32 位的熵，它只能为用户的钱包生成 2^(32) 个不同的种子。攻击者可以计算出所有 2^(32)
    个可能的种子，并针对每个种子，计算出通过层级密钥派生法得到的私钥和地址。然后，他们可以扫描区块链，找到由 Trust Wallet 生成的地址并窃取其代币。发现该漏洞的
    Ledger 公司研究人员评论道：“执行这样的攻击需要的时间远不止几个小时，但只需几张 GPU，便可在一天之内完成。”
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Collisions from Domain Separation
    Failures</samp>
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">来自域分离失败的碰撞</samp>
- en: Let’s discuss how to find collisions for a hash function that is collision resistant.
    As cryptographer Moti Yung said, “If it sounds impossible, then it’s cryptographically
    interesting.”
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论如何找到一个抗碰撞的哈希函数的碰撞。正如加密学家 Moti Yung 所说：“如果这听起来不可能，那就从加密学的角度来看非常有趣。”
- en: 'Imagine the following simple case: an application receives messages *A* and
    *B* from two parties, Alice and Bob, and then hashes these two messages together
    to create a hash value unique for these messages. It could then compute **H**(*A*
    || *B*) by hashing the string consisting of *A* followed by *B*. Even if your
    hash function is collision resistant, you’ll get the same hash value for *A* =
    COL and *B* = LISION as for *A* = CO and *B* = LLISION. You end up with a hash
    collision with respect to the application’s input values, although it’s not a
    collision for the hash function because the hash function **H** processes the
    same string in the two cases, COLLISION.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 假设以下简单情况：一个应用从两方，Alice 和 Bob，接收消息 *A* 和 *B*，然后将这两条消息一起哈希，生成一个唯一的哈希值。它接着可以通过对字符串
    *A* 后跟 *B* 进行哈希来计算 **H**(*A* || *B*)。即使你的哈希函数是抗碰撞的，当 *A* = COL 且 *B* = LISION
    时，得到的哈希值与 *A* = CO 且 *B* = LLISION 时的哈希值相同。你会遇到针对应用输入值的哈希碰撞，尽管对哈希函数而言并不算碰撞，因为哈希函数
    **H** 在这两种情况下处理的是相同的字符串，即 COLLISION。
- en: 'To avoid the problem, encode the application’s input values into a string that’s
    unique per input, with no ambiguous encoding: for each string, you should be able
    to uniquely identify the original set of input values. In our example, adding
    a dollar sign ($) character as a separator between the two inputs seems to avoid
    the collision between COL || LISION and CO || LLISION: you would get the strings
    COL$LISION and CO$LLISION, leading to different hash values.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个问题，将应用的输入值编码为唯一的字符串，并且不采用模糊的编码方式：对于每个字符串，你应该能够唯一识别原始的输入值集合。在我们的例子中，在两个输入之间添加美元符号（$）作为分隔符似乎可以避免
    COL || LISION 和 CO || LLISION 之间的碰撞：你将得到字符串 COL$LISION 和 CO$LLISION，从而生成不同的哈希值。
- en: 'But a separator symbol isn’t enough to eliminate ambiguities when the character
    is authorized in the application’s input values. For example, take the string
    COL$$LISION as the concatenation of two input strings separated with $. You could
    have obtained that string from two pairs of inputs: COL and $LISION, COL$ and
    LISION. Note that the problem doesn’t occur when the input values are a fixed,
    constant size—for example, a first string of two characters and a second of three
    characters. Even in that case, it’s still safer to use some separator or encoding
    that prevents collisions, as a future patch may introduce variable-length input.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，仅仅使用分隔符符号不足以消除当字符在应用程序的输入值中被授权时产生的歧义。例如，考虑字符串COL$$LISION，它是两个输入字符串通过$符号连接起来的结果。你可以从两个输入对中得到该字符串：COL和$LISION，或者COL$和LISION。注意，当输入值的大小固定且常量时，问题不会出现——例如，第一个字符串由两个字符组成，第二个字符串由三个字符组成。即便如此，仍然更安全使用某些分隔符或编码来防止冲突，因为未来的补丁可能会引入可变长度的输入。
- en: Researchers have found bugs of this type in threshold signing protocols, which
    you’ll see later in this chapter, as well as in e-voting protocols, where the
    resulting hash collisions could be exploited to violate the security properties
    of these protocols.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 研究人员发现了在门限签名协议中存在这种类型的漏洞，稍后你将在本章中看到，此外在电子投票协议中也有类似问题，其中生成的哈希冲突可能被利用来破坏这些协议的安全属性。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Multisignature Protocols</samp>
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">多重签名协议</samp>
- en: In a cryptographic *multisignature protocol*, participants jointly produce a
    signature of a message that’s functionally equivalent to having all parties separately
    sign the message; an obtained signature means all parties agreed to sign the message.
    The advantage is that instead of having as many signatures as signers, there’s
    only one. Anyone who has the public keys of all the signers can then verify the
    signature.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在加密的*多重签名协议*中，参与者共同生成一条消息的签名，功能上相当于所有方分别签署消息；获得的签名意味着所有参与者同意签署该消息。其优点是，签名的数量不再与签署者的数量相等，而只有一个。任何拥有所有签署者公钥的人都可以验证该签名。
- en: Blockchain platforms employ multisignatures when multiple parties manage an
    account to ensure that all parties endorse issued transactions. A single party
    can also use them if they have multiple keys on multiple devices to prevent a
    single compromised key from allowing the attack to issue transactions. Such multisignature
    protocols are one of the many types of *collective signature* protocols, where
    parties run a protocol to produce a signature.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链平台在多个参与方共同管理账户时使用多重签名，以确保所有参与方都支持已发起的交易。如果单个方在多个设备上有多个密钥，他们也可以使用多重签名，以防止单个被泄露的密钥允许攻击者发起交易。此类多重签名协议是*集体签名*协议的众多类型之一，在这些协议中，参与方运行一个协议以生成签名。
- en: Before diving into the technical details, let’s clarify how these multisignatures
    differ from related protocols.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入技术细节之前，让我们先澄清这些多重签名与相关协议的不同之处。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Multiple Multiparty
    Signatures</samp>
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">多方多重签名</samp>
- en: Despite their similar name, the multisignature protocols we’ll discuss are different
    from on-chain multisignature scripts or multisignature smart contracts, as used
    in Bitcoin and Ethereum, respectively. The latter aren’t cryptographic protocols
    because participants independently submit their individual signature to the blockchain
    network. The network in turn verifies a rule such as “if a transaction has signatures
    from *pub*[1] and *pub*[2], then accept it” or “if a transaction is signed by
    any two parties among *pub*[1], *pub*[2], and *pub*[3], then accept it”—rejecting
    the transaction otherwise. Here we implicitly view public keys *pub* as the identifiers
    of the parties, as is common in blockchain protocols.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管名称相似，我们将要讨论的多重签名协议与比特币和以太坊中使用的链上多重签名脚本或多重签名智能合约不同。后者并不是加密协议，因为参与者独立提交各自的签名到区块链网络，网络则验证如“如果交易拥有来自*pub*[1]和*pub*[2]的签名，则接受它”或“如果交易由*pub*[1]、*pub*[2]和*pub*[3]中的任意两方签署，则接受它”这样的规则——否则拒绝该交易。在这里，我们隐含地将公钥*pub*视为参与方的标识符，这在区块链协议中是常见的做法。
- en: Compared to on-chain multisigs, multisignature protocols produce a single signature;
    there’s then only one signature to verify rather than multiple ones. The multisignature
    scripts and smart contracts instead process several signatures and consist of
    a verification rule rather than a protocol on the signers’ end. In both cases,
    verification requires the public keys of all signers.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与链上多签不同，多签名协议生成单一签名；然后只需要验证一个签名，而不是多个签名。多签名脚本和智能合约代替处理几个签名并包含验证规则，而不是签署者端的协议。在两种情况下，验证都需要所有签署者的公钥。
- en: 'Multisignature protocols also differ from two types of other collective signature
    protocols, which you’ll see in the following sections. In both protocols, the
    outcome is a single signature, but the difference is how and from what it’s created:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 多签名协议也不同于其他两种集体签名协议类型，你将在以下部分看到。在这两种协议中，结果是一个单一的签名，但不同之处在于如何以及从何创建：
- en: '**Aggregate signature protocols**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**聚合签名协议**'
- en: Like in multisignatures, each participant has their own key pair (public and
    private keys).
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像在多签名中一样，每个参与者都有自己的密钥对（公钥和私钥）。
- en: Unlike in multisignatures, participants may sign different messages, rather
    than the same one. A participant can also sign multiple messages.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不像在多签名中一样，参与者可以签署不同的消息，而不是相同的消息。一个参与者还可以签署多个消息。
- en: Like in multisignatures, the verification of a signature requires multiple public
    keys (or a single aggregate version thereof, for supporting protocols).
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像在多签名中一样，验证签名需要多个公钥（或其单个聚合版本，用于支持协议）。
- en: '**Threshold signature protocols**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**门限签名协议**'
- en: Unlike in multisignatures, participants don’t use their own keys. Instead, they
    have shares (also called *shards*) of a single private key, such that no single
    participant ever knows the full key, even during the protocol’s execution.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与多签名不同，参与者不使用自己的密钥。相反，他们有一个单一私钥的份额（也称为*碎片*），以便在协议执行期间没有单个参与者知道完整的密钥。
- en: Like in multisignatures, participants sign a single message.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像在多签名中一样，参与者签署单个消息。
- en: Unlike in multisignatures, verification requires a single public key.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与多签名不同，验证只需要单个公钥。
- en: 'Now that we’ve defined what multisignatures are, let’s see how they work in
    their most illustrious use case: Schnorr signatures.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了多签名，让我们看看它们在它们最显著的用例中是如何工作的：Schnorr 签名。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Schnorr Signature
    Protocols</samp>
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">施诺尔签名协议</samp>
- en: Mathematician Claus-Peter Schnorr created the eponymous signature scheme in
    1989 and filed a patent for it, which prevented its wide adoption until 2008,
    when the EdDSA scheme (see [Chapter 12](chapter12.xhtml)) optimized it to work
    with modern elliptic curves. Schnorr’s scheme is simpler than the ECDSA standard,
    making it easier to turn into a multisignature scheme. Bitcoin supports Schnorr
    signatures, which were introduced in 2022 as better support for multisignature
    protocols.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 数学家克劳斯-彼得·施诺尔于1989年创建了同名签名方案，并对其进行了专利申请，这阻碍了其广泛采用，直到2008年EdDSA方案（参见[第12章](chapter12.xhtml)）优化了它以适应现代椭圆曲线。施诺尔的方案比ECDSA标准更简单，更容易转换为多签名方案。比特币支持施诺尔签名，这些签名在2022年作为更好的多签名协议支持引入。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*We’ll use additive notation (as with EdDSA and when working with elliptic
    curve), rather than the original multiplicative notation (as used when working
    with integers in a multiplicative group). Therefore, the public key* A *associated
    with a private key* a *is the elliptic curve point* A *=* aG*, where* G *is a
    predefined base point, and group elements are points combined by addition. This
    is opposed to the multiplicative notation where we’d have* A *=* g^a *for some
    group generator* g*, where group elements are numbers multiplied together.*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将使用加法表示法（与EdDSA以及处理椭圆曲线时一样），而不是原始的乘法表示法（用于整数的乘法群中使用）。因此，与私钥* a *相关联的公钥*
    A *是椭圆曲线点* A *=* aG*，其中* G *是预定义的基点，而组元素是通过加法组合的点。这与在乘法表示法中的情况相反，那里我们会有* A *=*
    g^a *，其中组元素是相乘在一起的数字。*'
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Single-Signer Schnorr
    Signatures</samp>'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">单签名 Schnorr 签名</samp>'
- en: Before seeing how multiparty signing works, let’s see how single-party Schnorr
    signing works. Suppose Alice has a private key *a*, with associated public key
    *A* = *aG*. Here *a* is a number, or scalar, in a given range of numbers (specifically,
    the finite field over which the elliptic curve is defined, typically positive
    integers modulo some large prime numbers, of at least approximately 256 bits),
    and *G* is a fixed base point of the curve.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解如何进行多方签名之前，我们先看看单方Schnorr签名是如何工作的。假设Alice有一个私钥 *a*，对应的公钥是 *A* = *aG*。这里的
    *a* 是一个数字，或者说是一个标量，在给定的数字范围内（具体来说，是椭圆曲线定义的有限域，通常是模某些大质数的正整数，至少大约为256位），而 *G* 是曲线的固定基点。
- en: 'To sign a message *M*, Alice proceeds as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了签署一条消息 *M*，Alice按以下步骤进行：
- en: 1.  Pick a secret random number, *r*, and compute the point *R* = *rG*. The
    value *r* is a *nonce*, a one-time private key with *R* its public key.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  选择一个秘密随机数 *r*，并计算点 *R* = *rG*。值 *r* 是一个 *nonce*，即一次性的私钥，*R* 是其公钥。
- en: 2.  Compute *h* = **H**(*R* || *A* || *M*), the value that you’ll “connect”
    to the private key *a* and the one-time private key *r* to sign *M*. We not only
    hash the message but also bind *h* to the signer and the nonce, respectively,
    via the nonsecret values *A* and *R*. Without these, different attacks would be
    possible.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  计算 *h* = **H**(*R* || *A* || *M*)，这是你将“连接”到私钥 *a* 和一次性私钥 *r* 以签署 *M* 的值。我们不仅对消息进行哈希处理，而且通过非秘密值
    *A* 和 *R* 分别将 *h* 绑定到签名者和nonce上。如果没有这些，不同的攻击将成为可能。
- en: 3.  Compute *s* = *r* + *ha* and return the pair (*R*, *s*) as a signature.
    You can see *s* as the multiplication between the secret key and the data to sign,
    where the secret *r* masks the result; without this, it’s trivial to recover the
    private key from a signature.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  计算 *s* = *r* + *ha*，并返回一对 (*R*, *s*) 作为签名。你可以把 *s* 看作是私钥和数据进行签名时的乘积，其中秘密
    *r* 对结果进行掩码；如果没有这个，恢复私钥从签名中将变得很容易。
- en: Verify a signature by checking that *sG* equals *R* + **H**(*R* || *A* || *M*)*A*.
    This works because from *s* = *r* + *ha*, substituting *r* + *ha* for *s* in *sG*,
    you obtain
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 验证签名时，检查 *sG* 是否等于 *R* + **H**(*R* || *A* || *M*)*A*。这是因为从 *s* = *r* + *ha*，将
    *r* + *ha* 代入 *sG*，你会得到：
- en: '![](../images/pg308-1.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg308-1.jpg)'
- en: with *h* = **H**(*R* || *A* || *M*), which the verifier must compute from the
    message *M*, the public key *A*, and the *R* part of the signature.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *h* = **H**(*R* || *A* || *M*)，验证者必须根据消息*M*、公钥*A*和签名的*R*部分来计算该值。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Schnorr Multisignatures</samp>
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Schnorr多重签名</samp>
- en: 'In multisignatures we don’t have one signer but multiple ones. For the sake
    of simplicity, we’ll describe the case of two cosigners: meet Bob, who’ll sign
    messages jointly with Alice. Bob’s private key is *b* and his public key is *B*
    = *bG*. To jointly create a multisignature, Alice and Bob could proceed as follows
    to sign a message *M*:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在多重签名中，我们不仅仅有一个签名者，而是多个签名者。为了简化，我们描述两位共同签名者的情况：见Bob，他将与Alice共同签署消息。Bob的私钥是*b*，他的公钥是*B*
    = *bG*。为了共同创建一个多重签名，Alice和Bob可以按照以下步骤来签署消息*M*：
- en: 1.  Alice picks a nonce *r*[A], computes *R*[A] = *r*[A]*G*, and sends *R*[A]
    to Bob.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  Alice选择一个nonce *r*[A]，计算 *R*[A] = *r*[A]*G*，并将 *R*[A]发送给Bob。
- en: 2.  Bob picks a nonce *r*[B], computes *R*[B] = *r*[B]*G*, and sends *R*[B]
    to Alice.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  Bob选择一个nonce *r*[B]，计算 *R*[B] = *r*[B]*G*，并将 *R*[B]发送给Alice。
- en: 3.  They compute *R* = *R*[A] + *R*[B] and set *h* = **H**(*R* || *A* || *B*
    || *M*), the value that Alice and Bob will use to generate their part of the signature.
    A specific value of *h* is bound to the parties via their public keys (*A* and
    *B*) and bound to the current signing session via the nonce *R* only for the specific
    signature execution as defined by the nonce *R*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  他们计算 *R* = *R*[A] + *R*[B]，并设置 *h* = **H**(*R* || *A* || *B* || *M*)，这是Alice和Bob将用来生成其签名部分的值。*h*的特定值通过他们的公钥(*A*和*B*)与签名者绑定，并且仅通过nonce
    *R*与当前的签名会话绑定，这个绑定只适用于由nonce *R*定义的特定签名执行。
- en: 4.  Alice computes *s*[A] = *r*[A] + *ha* and sends it to Bob.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  Alice计算 *s*[A] = *r*[A] + *ha*，并将其发送给Bob。
- en: 5.  Bob computes *s*[B] = *r*[B] + *hb* and sends it to Alice.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  Bob计算 *s*[B] = *r*[B] + *hb*，并将其发送给Alice。
- en: 6.  They both compute *R* = *R*[A] + *R*[B] and *s* = *s*[A] + *s*[B] and return
    (*R*, *s*) as the signature.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  他们一起计算 *R* = *R*[A] + *R*[B] 和 *s* = *s*[A] + *s*[B]，并返回 (*R*, *s*) 作为签名。
- en: 'To verify a signature, check that *sG* equals *R* + *h*(*A + B*). Substituting
    *s* in *sG* by the previously computed value results in the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 验证签名时，检查 *sG* 是否等于 *R* + *h*(*A + B*)。将 *s* 代入 *sG* 后，结果如下：
- en: '![](../images/pg309-1.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg309-1.jpg)'
- en: Note that the verifier needs to know both *A* and *B*, and not only their sum
    *A* + *B*, because they need both values to compute **H**(*R* || *A* || *B* ||
    *M*). However, if *h* is instead defined as **H**(*R* || *A* + *B* || *M*), a
    verifier can use a single public key *A* + *B* without knowing that the signature
    is issued by two parties. We call the “merging” of multiple public keys into one
    *key aggregation*. This is particularly useful to reduce the size of the data
    to hash when there are many signers.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，验证者需要知道 *A* 和 *B*，而不仅仅是它们的和 *A* + *B*，因为他们需要这两个值来计算 **H**(*R* || *A* ||
    *B* || *M*)。然而，如果 *h* 被定义为 **H**(*R* || *A* + *B* || *M*), 那么验证者就可以使用一个公钥 *A*
    + *B*，而无需知道签名是由两方发布的。我们称将多个公钥合并为一个的方式为 *密钥聚合*。这在有多个签名者的情况下尤其有用，可以减少哈希时数据的大小。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*I’ve described basic Schnorr multisignatures in the case of two parties, but
    the protocol scales to an arbitrary number of parties with public keys* P1*,*
    P2 *, . . . ,* P[n]*. In the definition, replace* A *+* B *with* P1 *+* P2 *+
    . . . +* P[n]*, replace* A *||* B *with* P1 *||* P2 *|| . . . ||* P[n]*, and replace
    “sends it to Bob/Alice” with “sends it to everyone.” You can apply a similar protocol
    to EdDSA and Ed25519, variants of Schnorr’s scheme.*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*我描述了基本的 Schnorr 多重签名方案，适用于两方的情况，但该协议可以扩展到任意数量的公钥 *P1*, *P2*, …, *P[n]* 的情况。在定义中，替换
    *A* + *B* 为 *P1* + *P2* + … + *P[n]*，将 *A* || *B* 替换为 *P1* || *P2* || … || *P[n]*，并将“发送给
    Bob/Alice”替换为“发送给所有人”。你可以将类似的协议应用到 EdDSA 和 Ed25519，这些是 Schnorr 方案的变种。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">How Things Can Go
    Wrong</samp>
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">事情可能出错的方式</samp>
- en: The Schnorr multisignature protocol is relatively simple but may fail in the
    following attack scenarios.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Schnorr 多重签名协议相对简单，但在以下攻击场景中可能会失败。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Key Cancellation Attack</samp>
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">密钥取消攻击</samp>
- en: In this attack, Bob convinces signature verifiers that he jointly signed a message
    with Alice, whereas Alice hasn’t seen the message and didn’t interact with Bob.
    An attacker could exploit this in a scenario where you expect Alice and Bob to
    jointly sign messages—for example, in transactions that require both parties’
    approval. In the normal case, the verifiers would know Alice’s public key *A*
    and Bob’s public key *B*, and Bob and Alice would know each other’s keys.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在此攻击中，Bob 让签名验证者相信他与 Alice 一起签署了消息，而实际上 Alice 没有看到这条消息，也没有与 Bob 互动。攻击者可以在你期望
    Alice 和 Bob 一起签署消息的场景中利用这一点——例如，在需要双方批准的交易中。在正常情况下，验证者会知道 Alice 的公钥 *A* 和 Bob
    的公钥 *B*，并且 Bob 和 Alice 会知道彼此的公钥。
- en: 'Now suppose the following happens: Alice sends her public key *A* to everyone
    including Bob, but instead of sharing his public key *B*, Bob shares *C* = *B*
    – *A* = (*b* – *a*)*G* with the verifiers, and *B* with Alice. That Bob doesn’t
    know the private key corresponding to *C* won’t matter for the attack.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 假设发生以下情况：Alice 将她的公钥 *A* 发送给所有人，包括 Bob，但 Bob 并没有分享他的公钥 *B*，而是将 *C* = *B* – *A*
    = (*b* – *a*)*G* 分享给验证者，并将 *B* 分享给 Alice。Bob 不知道与 *C* 对应的私钥，对于攻击来说并不重要。
- en: Bob has to sign a message using his private key *b*, as in the single-signer
    case, but with *h* = **H**(*R* || *A* || *C* || *M*), as if he were signing with
    Alice. He returns (*R*, *s*) as a signature, with *R* = *rG* for an *r* of his
    choice and *s* = *r* + *hb.*
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Bob 必须使用他的私钥 *b* 来签署消息，就像单签名者的情况一样，但此时 *h* = **H**(*R* || *A* || *C* || *M*),
    就像他在与 Alice 一起签名一样。他返回 (*R*, *s*) 作为签名，其中 *R* = *rG*（*r* 为他选择的值），*s* = *r* + *hb*。
- en: Expecting signatures from Alice and Bob, verifiers check that *sG* equals *R*
    + *h*(*A + C*), which is correct because *A* + *C* = *A* + (*B* – *A*) = *B*.
    Bob can therefore forge multisignature without even interacting with Alice and
    without knowing her private key.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在期望 Alice 和 Bob 签名的情况下，验证者检查 *sG* 是否等于 *R* + *h*(*A + C*), 这是正确的，因为 *A* + *C*
    = *A* + (*B* – *A*) = *B*。因此，Bob 可以伪造多重签名，而无需与 Alice 交互，也无需知道她的私钥。
- en: In practice, you can avoid this attack by requesting signers to prove the knowledge
    of the private key—for example, by signing a message. Since Bob doesn’t know the
    private key corresponding to *C*, he can’t provide such evidence. As you’ll see
    with the MuSig protocol, you can also avoid the attack at the protocol level.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可以通过要求签名者证明他们知道私钥（例如，通过签署一条消息）来避免这种攻击。由于 Bob 不知道与 *C* 对应的私钥，他无法提供这种证明。如你在
    MuSig 协议中看到的，你也可以在协议层面避免这种攻击。
- en: The attack scales to an arbitrary number of parties, a context that’s often
    called a *rogue key attack*. Having received the public keys of all other parties,
    an attacker Bob would just define his public key as *B* – *X*, with *X* the sum
    of all other parties’ public keys.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 该攻击可以扩展到任意数量的参与方，这种情境通常被称为 *流氓密钥攻击*。攻击者Bob在接收到所有其他方的公钥后，只需将他的公钥定义为 *B* – *X*，其中
    *X* 是所有其他方公钥的总和。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Repeated Nonces</samp>
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">重复随机数</samp>
- en: 'Like in ECDSA, repeated nonces are lethal to the Schnorr multisignature protocol.
    Imagine that Alice’s pseudorandom generator fails and she generates the same secret
    nonce *r*[A] twice in two runs of the protocol: she sends an initial *s*[A] =
    *r*[A] + *ha* to Bob, and a second *s*[A]*''* = *r*[A] + *h''a* where the first
    *h* and the second *h''* also depend on Bob’s randomness. You thus have *r*[A]
    = *ha – s*[A] and *r*[A] = *h''a – s*[A]*''*, which implies *ha – s*[A] = *h''a
    – s*[A]*''* or, equivalently,'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在ECDSA中一样，重复的随机数对Schnorr多重签名协议致命。假设Alice的伪随机生成器出现故障，她在协议的两次运行中生成了相同的秘密随机数
    *r*[A]：她第一次发送 *s*[A] = *r*[A] + *ha* 给Bob，第二次发送 *s*[A]*'* = *r*[A] + *h'a*，其中第一次的
    *h* 和第二次的 *h'* 也依赖于Bob的随机性。这样，你得到 *r*[A] = *ha – s*[A] 和 *r*[A] = *h'a – s*[A]*'，这意味着
    *ha – s*[A] = *h'a – s*[A]*'，或者等价地，
- en: '![](../images/pg310-1.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg310-1.jpg)'
- en: from which you can compute Alice’s private key *a* = (*s*[A] – *s*[A]*'*) /
    (*h – h'*).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过此方法，你可以计算出Alice的私钥 *a* = (*s*[A] – *s*[A]*'*) / (*h – h'* )。
- en: 'One approach to eliminate security risks caused by a randomness failure is
    to get rid of randomness. For example, computing the nonce by hashing the message
    and the private key as in Ed25519 works when there’s a single signer. However,
    setting *r* to **H**(*a* || *M*) won’t work in the case of multisignatures: if
    Alice and Bob sign the same message twice, then Alice computes a first *s*[A]
    = *r*[A] + *ha* and a second *s*[A]*''* = *r*[A] + *h''a*, where in both cases
    *r*[A] *=* **H**(*a* **||** *M*), where *h''* will be distinct from *h* if a malicious
    Bob sends a different value than **H**(*b* **||** *M*). In this case, Bob—and
    any eavesdropper of the communications—can again compute *a* as (*s*[A] – *s*[A]*''*)
    / (*h – h''*).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 消除由随机性失败引起的安全风险的一种方法是去除随机性。例如，通过对消息和私钥进行哈希计算来生成随机数，像在Ed25519中那样，当只有一个签名者时是有效的。然而，在多重签名的情况下，设置
    *r* 为 **H**(*a* || *M*) 是行不通的：如果Alice和Bob两次签署相同的消息，Alice会计算第一次的 *s*[A] = *r*[A]
    + *ha* 和第二次的 *s*[A]*'* = *r*[A] + *h'a*，在这两种情况下，*r*[A] = **H**(*a* **||** *M*)，如果恶意的Bob发送了与
    **H**(*b* **||** *M*) 不同的值，则 *h'* 会与 *h* 不同。在这种情况下，Bob——以及任何监听通信的人——都可以再次计算 *a*
    为 (*s*[A] – *s*[A]*'*) / (*h – h'* )。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Parallel Execution Insecurity</samp>
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">并行执行的不安全性</samp>
- en: The Schnorr multisignature protocol is insecure when the attacker can initiate
    multiple simultaneous signature protocols. The attack is too complicated to describe
    here but is documented in the research articles available at *[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2018<wbr>/417](https://eprint.iacr.org/2018/417)*
    and *[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2020<wbr>/945](https://eprint.iacr.org/2020/945)*.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当攻击者能够发起多个同时进行的签名协议时，Schnorr多重签名协议是不安全的。这个攻击过程太复杂，无法在这里详细描述，但可以在以下研究文章中找到相关文献：*[https://eprint.iacr.org/2018/417](https://eprint.iacr.org/2018/417)*
    和 *[https://eprint.iacr.org/2020/945](https://eprint.iacr.org/2020/945)*。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Safer Schnorr Multisignatures</samp>
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">更安全的Schnorr多重签名</samp>
- en: 'To avoid the key cancellation attack and repeated nonce issues, researchers
    developed more advanced multisignature protocols and in particular the MuSig protocols:
    MuSig, MuSig2, and MuSig-DN, where *MuSig* stands for *multisignature* and *DN*
    for *deterministic nonce*. MuSig protocols also support key aggregation to allow
    a verifier to check a signature using only one public key that’s derived from
    the signers’ keys, such that the aggregated key doesn’t reveal the number of signers
    or their public keys.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免密钥冲突攻击和重复随机数问题，研究人员开发了更先进的多重签名协议，特别是MuSig协议：MuSig、MuSig2 和 MuSig-DN，其中 *MuSig*
    代表 *多重签名*，*DN* 代表 *确定性随机数*。MuSig协议还支持密钥聚合，允许验证者仅使用一个由签名者的密钥衍生出的公钥来检查签名，从而聚合的密钥不会泄露签名者的数量或公钥。
- en: Let’s see MuSig’s main trick in action. If we’re in the simplest case of two
    signers, Alice and Bob, using the same notations as in the previous sections,
    instead of computing *s*[A] = *r*[A] + *ha* as her share of the signature, Alice
    computes *s*[A] = *r*[A] + *μ*[A]*ha*, thus multiplying the *ha* part with the
    *μ*[A] value. She computes *μ*[A] (where *μ* is the Greek letter mu) by hashing
    the list of participants’ public keys followed by Alice’s key, **H**(*A* || *B*
    || *A*). Likewise, Bob computes *s*[B] = *r*[B] + *μ*[B]*hb* with *μ*[B] = **H**(*A*
    || *B* || *B*), hashing the list of public keys followed by his key.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看MuSig的主要技巧如何运作。如果我们处于最简单的情况，只有两个签名者，Alice和Bob，并且使用与前面章节相同的符号，那么Alice不再计算*s*[A]
    = *r*[A] + *ha*作为她的签名部分，而是计算*s*[A] = *r*[A] + *μ*[A]*ha*，从而将* ha*部分与* μ*[A]值相乘。她通过哈希参与者的公钥列表，再加上Alice的密钥，**H**(*A*
    || *B* || *A*)，来计算* μ*[A]（其中* μ*是希腊字母mu）。同样，Bob通过哈希公钥列表，再加上他的密钥，**H**(*A* || *B*
    || *B*)来计算* μ*[B]，从而计算*s*[B] = *r*[B] + *μ*[B]*hb*。
- en: Alice then computes the *aggregate public key* as *X* = *μ*[A]*A* + *μ*[B]*B*,
    the sum of the public keys multiplied by their respective *μ* values. The hash
    of the message is then *h* = **H**(*R* || *X* || *M*) instead of **H**(*R* ||
    (*A* + *B*) || *M*) in the vulnerable version multisignature scheme supporting
    key aggregation.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，Alice计算*聚合公钥*为*X* = *μ*[A]*A* + *μ*[B]*B*，即公钥与各自* μ*值的乘积之和。消息的哈希值为*h* = **H**(*R*
    || *X* || *M*)，而不是脆弱版本的多重签名方案中支持密钥聚合的**H**(*R* || (*A* + *B*) || *M*)。
- en: This trick works because a malicious Bob can no longer forge another public
    key that would “cancel” Alice’s *A*, as he could by setting *C* = *B* – *A* in
    the key cancellation attack. In the equation *X* = *μ*[A]*A* + *μ*[B]*B*, Bob
    has to find a new value of *B* that yields the “right” *μ* coefficients to remove
    *A* from the equation. But that’s now impossible because the equation is nonlinear
    with respect to *A* and *B* (linearity is often synonymous with insecurity—see
    [Chapter 2](chapter2.xhtml)).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧之所以有效，是因为恶意的Bob不再能够伪造另一个“取消”Alice的公钥* A*，就像他可以通过设置*C* = *B* – *A* 在密钥取消攻击中做到的那样。在方程式*
    X* = *μ*[A]*A* + *μ*[B]*B*中，Bob必须找到一个新的* B*值，得出“正确”的* μ*系数，以从方程中移除* A*。但这现在是不可能的，因为该方程式对*
    A*和* B*是非线性的（线性通常意味着不安全——参见[第二章](chapter2.xhtml)）。
- en: When there are more than two signers, you apply the trick in a similar way,
    computing the *μ* coefficients by hashing the list of keys followed by the signer’s
    key and then aggregating the public keys into a single *X* by computing the sum
    of the public keys multiplied by their respective *μ*.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当签名者超过两个时，可以以类似的方式应用这个技巧，通过哈希公钥列表和签名者的密钥来计算* μ*系数，然后通过计算公钥乘以各自的* μ*值，将公钥聚合为一个单一的*
    X*。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*For more details on the MuSig protocols and how the MuSig-DN version securely
    derives nonces from the message, see* [https://<wbr>bitcoinops<wbr>.org<wbr>/en<wbr>/topics<wbr>/musig<wbr>/](https://bitcoinops.org/en/topics/musig/).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*有关MuSig协议的更多详情，以及MuSig-DN版本如何从消息中安全地推导出随机数，请参见* [https://<wbr>bitcoinops<wbr>.org<wbr>/en<wbr>/topics<wbr>/musig<wbr>/](https://bitcoinops.org/en/topics/musig/)。'
- en: <samp class="SANS_Futura_Std_Bold_B_11">Aggregate Signature Protocols</samp>
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">聚合签名协议</samp>
- en: '*Aggregate signatures* have multiple signers, and each signer signs a message
    (which can be distinct for all signers); then these signatures are merged into
    a single signature. From only this signature and from the signers’ public keys
    and the messages they signed, verification checks that all signers signed their
    respective messages. Because a single signature must be stored, instead of as
    many signatures as signers, verification time is proportional to the number of
    messages. When all signers sign the same message, verification can be as fast
    as the verification of a single signer’s signature, regardless of the number of
    signers.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*聚合签名*有多个签名者，每个签名者签署一条消息（每个签名者的消息可以不同）；然后将这些签名合并为一个单一的签名。通过这个签名、签名者的公钥和他们签署的消息，验证过程检查所有签名者是否都签署了各自的消息。由于只需要存储一个签名，而不是与签名者数量相等的签名，因此验证时间与消息的数量成正比。当所有签名者签署相同的消息时，验证速度可以和单一签名者的签名验证一样快，无论签名者有多少个。'
- en: 'Aggregate signatures are notably used in Ethereum, specifically in its consensus
    layer. In this use case, validator nodes endorse proposals to change the state
    of the system (as blocks) and leverage aggregate signatures to minimize the signature
    storage space and verification time. They use the Boneh–Lynn–Shacham (BLS) signature
    scheme, which you’ll learn about in this section, starting with the magic behind
    BLS signatures: cryptographic pairings.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合签名在以太坊中特别用于其共识层。在这种用例中，验证节点支持提议以改变系统状态（作为区块），并利用聚合签名来最小化签名存储空间和验证时间。它们使用Boneh-Lynn-Shacham（BLS）签名方案，你将在本节中了解到，从BLS签名的魔力开始：密码学配对。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Pairings</samp>'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">配对</samp>'
- en: 'In elliptic curve cryptography, a *pairing* is an operation that transforms
    two points from two elliptic curve groups (not necessarily the same) into a finite
    field element. The standard notation for a pairing between two elliptic curve
    points *P* and *Q* is *e*(*P*, *Q*). Pairings used in cryptography have the property
    called *bilinearity* and are thus called *bilinear pairings*, which means they
    satisfy the following for any points *P*, *Q*, and *R*:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在椭圆曲线密码学中，*配对*是一种操作，它将两个来自两个椭圆曲线群（不一定相同）的点转换为有限域元素。两个椭圆曲线点*P*和*Q*之间的配对的标准表示法是*e*(*P*,
    *Q*)。在密码学中使用的配对具有称为*双线性*的属性，因此称为*双线性配对*，这意味着对于任何点*P*、*Q*和*R*，它们满足以下条件：
- en: '![](../images/pg312-1.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg312-1.jpg)'
- en: Here, adding a point *R* to an operand is equivalent to multiplying the result
    by the pairing between *R* and the other operand. Consequently, if you add a point
    to itself *n* times—that is, if you multiply it by a number *n*—then you have
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，将点*R*添加到操作数相当于将结果乘以*R*与另一个操作数之间的配对。因此，如果你将一个点加上它自身*n*次，也就是说，将其乘以一个数字*n*，那么你得到的是
- en: '![](../images/pg312-2.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg312-2.jpg)'
- en: or *e*(*P*, *Q*) multiplied by itself *n* times, which is also equal to *e*(*P*,
    *nQ*).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 或者是*e*(*P*, *Q*)乘以它自身*n*次，这也等同于*e*(*P*, *nQ*)。
- en: 'If you have different points *P*[1], *P*[2], . . . , *P*n, you can turn addition
    of the input values into multiplication of the output values:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有不同的点*P*[1]、*P*[2]、...、*P*[n]，你可以将输入值的加法转换为输出值的乘法：
- en: '![](../images/pg312-3.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg312-3.jpg)'
- en: The internals of how pairings work is beyond this book’s scope. For more details,
    see the article “Cryptographic Pairings” by Kristin Lauter and Michael Naehrig
    (*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2017<wbr>/1108](https://eprint.iacr.org/2017/1108)*)
    and the book *Guide to Pairing-Based Cryptography* by Nadia El Mrabet and Marc
    Joye (Chapman and Hall/CRC, 2016).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 配对的内部工作原理超出了本书的范围。更多详情请参阅Kristin Lauter和Michael Naehrig的文章“密码学配对”（*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2017<wbr>/1108](https://eprint.iacr.org/2017/1108)*）以及Nadia
    El Mrabet和Marc Joye的书籍《基于配对的密码学指南》（Chapman and Hall/CRC, 2016）。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">BLS Signatures</samp>
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">BLS签名</samp>
- en: 'BLS signatures were presented in 2006 in the article “Short Signatures from
    the Weil Pairing” by Dan Boneh, Ben Lynn, and Hovav Shacham. It stated that the
    scheme was designed “for systems where signatures are typed in by a human or signatures
    are sent over a low-bandwidth channel.” BLS signatures turned out to be used in
    highly automated systems over high-bandwidth channels, which benefited from a
    property described in a subsequent paper: aggregation of signatures and of public
    keys.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 2006年，Dan Boneh，Ben Lynn和Hovav Shacham在文章“从Weil配对获得的短签名”中提出了BLS签名。文章指出，该方案设计用于“由人类输入签名或通过低带宽信道发送签名的系统”。BLS签名后来被用于高度自动化的系统，这些系统通过后续论文描述的一种特性受益匪浅：签名和公钥的聚合。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*Don’t confuse BLS signatures with BLS (Barreto–Lynn–Scott) curves, which have
    an author (Lynn) in common. BLS curves are elliptic curves designed to be pairing
    friendly, allowing secure and efficient pairing operations. In fact, BLS signatures
    often work with points over a BLS curve. For example, the Ethereum BLS signature
    relies on the curve BLS12-381.*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要将BLS签名与BLS（Barreto-Lynn-Scott）曲线混淆，这两者共同的作者是（Lynn）。BLS曲线是设计成配对友好的椭圆曲线，允许安全高效的配对操作。事实上，BLS签名通常使用BLS曲线上的点。例如，以太坊的BLS签名依赖于曲线BLS12-381。*'
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Single-Signer Signature
    and Verification</samp>'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">单签名签名与验证</samp>'
- en: 'In BLS signatures, Alice’s private key is a scalar number *a*, and her public
    key is *A* = *aG*, for a predefined base point *G*. To sign a message *M*, she
    first computes *H* = **H**(*M*), where the hash function returns a curve point
    rather than a bit string or a scalar—the *H* notation follows the general convention
    that you denote points as capital letters. The signature is then *S* = *aH*. This
    looks much simpler than a Schnorr’s or an ECDSA signature: just hash the message
    and multiply the result with the private key.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在BLS签名中，爱丽丝的私钥是标量数值*a*，她的公钥是*A* = *aG*，其中*G*是预定义的基点。要对消息*M*进行签名，她首先计算*H* = **H**(*M*)，其中哈希函数返回的是一个曲线点，而不是比特串或标量——*H*符号遵循一般惯例，将点表示为大写字母。签名是*S*
    = *aH*。这看起来比Schnorr或ECDSA签名要简单得多：只需对消息进行哈希，并将结果与私钥相乘。
- en: 'To verify a BLS signature, compute two pairing operations:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证BLS签名，计算两个配对操作：
- en: '*e*(*A*, *H*) between the public key and the hashed message (note that *A*
    = *aG*)'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*e*(*A*, *H*)是公钥和哈希消息之间的配对（注意*A* = *aG*）'
- en: '*e*(*G*, *S*) between the base point and the signature (note that *S* = *aH*)'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*e*(*G*, *S*)是基点和签名之间的配对（注意*S* = *aH*）'
- en: 'These values should be equal because of the pairing’s bilinearity property:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于配对的双线性特性，这些值应该相等：
- en: '![](../images/pg313-1.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg313-1.jpg)'
- en: If the equality holds, the signature is accepted; otherwise, it’s rejected.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果等式成立，则接受该签名；否则，拒绝该签名。
- en: Ignoring the complexity of the pairing operation, such pairing-based signatures
    are the simplest signature scheme.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略配对操作的复杂性，这种基于配对的签名是最简单的签名方案。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Aggregate Signatures from
    Multiple Signers</samp>
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">来自多个签名者的聚合签名</samp>
- en: Let’s further exploit the magic of BLS signatures and bilinear pairings, considering
    a scenario wherein *n* signers with private keys *k*[1], *k*[2], . . . , *k*n
    and public keys *P*[1], *P*[2], . . . , *P*n sign *n* messages *M*[1], *M*[2],
    . . . , *M*n and produce the signatures *S*[1], *S*[2], . . . , *S*n. Note that
    *H*i = **H**(*M*i) is the hash of the *i*th message.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步利用BLS签名和双线性配对的神奇，考虑这样一个场景：*n*个签名者，私钥为*k*[1]、*k*[2]、…、*k*n，公钥为*P*[1]、*P*[2]、…、*P*n，签署*n*条消息*M*[1]、*M*[2]、…、*M*n，并生成签名*S*[1]、*S*[2]、…、*S*n。注意，*H*i
    = **H**(*M*i)是第*i*条消息的哈希。
- en: 'You can aggregate signatures *S*i = *k*i*H*i into one by adding them to obtain
    *S* = *S*[1] + *S*[2] + . . . + *S*n. Observe that computing *e*(*G*, *S*), as
    in the verification of a single signature, results in the following, owing to
    the bilinearity property:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将多个签名*S*i = *k*i*H*i相加，聚合成一个签名*S* = *S*[1] + *S*[2] + . . . + *S*n。观察到，在验证单个签名时，计算*e*(*G*,
    *S*)会因双线性特性而得到以下结果：
- en: '![](../images/pg313-2.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg313-2.jpg)'
- en: 'Remember that pairings satisfy *e*(*nP*, *Q*) = *e*(*P*, *nQ*). You can thus
    replace each *e*(*G*, *S*i) term with *e*(*P*i, *H*i) by “moving” the multiplicative
    factor *k*i to the left operand of the pairing: the first operand will thus be
    *k*i*G* = *P*i instead of *G*, and the second will be *H*i instead of *S*i = *k*i*H*i.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，配对满足*e*(*nP*, *Q*) = *e*(*P*, *nQ*)。因此，你可以通过将乘法因子*k*i“移到”配对的左操作数，来将每个*e*(*G*,
    *S*i)项替换为*e*(*P*i, *H*i)：第一个操作数将是*k*i*G* = *P*i，而不是*G*，第二个操作数将是*H*i，而不是*S*i =
    *k*i*H*i。
- en: After aggregating multiple signatures of multiple signers over multiple messages
    into a single signature, you can verify the aggregate signature from the signers’
    public keys and messages signed. Verification just checks the equality between
    *e*(*G*, *S*) and the product of all pairings *e*(*P*i, *H*i). There are 1 + *n*
    pairings to compute, rather than the 2*n* pairings if you hadn’t aggregated the
    signatures—in this case, the signatures occupy *n* times as much memory as the
    aggregated one.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 将多个签名者在多个消息上的多个签名聚合成一个单一签名后，你可以通过签名者的公钥和签名消息来验证聚合签名。验证只需检查*e*(*G*, *S*)与所有配对乘积*e*(*P*i,
    *H*i)之间的相等性。需要计算1 + *n*个配对，而不是如果没有聚合签名时需要计算的2*n*个配对——在这种情况下，签名占用了聚合签名的*n*倍内存。
- en: Let’s consider a scenario where you’ll aggregate both signatures and public
    keys.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个同时聚合签名和公钥的场景。
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Aggregate Public Keys</samp>'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">聚合公钥</samp>'
- en: 'Imagine that all signers sign the same message *M* and that you aggregate all
    public keys into a single one: *P* = *P*[1] + *P*[2] + . . . + *P*n. Note that
    *k*[1], *k*[2], . . . , *k*n still represents their respective private keys and
    *H* = **H**(*M*) the hash of the message. Given valid signatures *S*i, you obtain
    the following equality:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 假设所有签名者都对相同的消息 *M* 进行签名，并且你将所有公钥聚合成一个：*P* = *P*[1] + *P*[2] + . . . + *P*n。注意，*k*[1]、*k*[2]、.
    . . 、*k*n 仍然代表各自的私钥，*H* = **H**(*M*) 是消息的哈希值。给定有效的签名 *S*i，你得到以下等式：
- en: '![](../images/pg314-1.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg314-1.jpg)'
- en: You therefore verify the signatures of *n* parties over the same message using
    only two pairing operations, *e*(*P*, *H*) and *e*(*G*, *S*). This is extremely
    efficient, as it makes signature verification essentially independent of the number
    of parties, as you can add points efficiently, whereas pairings are costly to
    compute. In addition to the computing efficiency, aggregating keys and signatures
    also saves memory.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你仅使用两个配对操作 *e*(*P*, *H*) 和 *e*(*G*, *S*) 来验证 *n* 方对相同消息的签名。这是非常高效的，因为它使得签名验证基本上不依赖于参与方的数量，你可以高效地添加点，而配对运算的计算成本较高。除了计算效率外，聚合密钥和签名还能节省内存。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">How Things Can Go
    Wrong</samp>
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">事情如何出错</samp>
- en: Like many elliptic curve cryptography schemes, BLS signatures should avoid invalid
    keys and weak parameters to be secure. And like the previous protocols, BLS signatures
    could be vulnerable to key cancellation attack. Let’s explore the details.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多椭圆曲线密码学方案一样，BLS 签名在确保安全性时应避免无效密钥和弱参数。与之前的协议类似，BLS 签名也可能受到密钥取消攻击的威胁。让我们来探讨一下具体细节。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Invalid Keys</samp>
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">无效密钥</samp>
- en: BLS signatures are specified in an Internet-Draft, a working document of the
    IETF available at *[https://<wbr>github<wbr>.com<wbr>/cfrg<wbr>/draft<wbr>-irtf<wbr>-cfrg<wbr>-bls<wbr>-signature](https://github.com/cfrg/draft-irtf-cfrg-bls-signature)*.
    This specifies core operations including key generation (the algorithm <samp class="SANS_TheSansMonoCd_W5Regular_11">KeyGen</samp>),
    signature (<samp class="SANS_TheSansMonoCd_W5Regular_11">CoreSign</samp>), verification
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">CoreVerify</samp>), and key validation
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">KeyValidate</samp>). Given a public
    key, the latter ensures the validity of a public key in that it “represents a
    valid, non-identity point that is in the correct subgroup.”
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: BLS 签名在一份互联网草案中有明确规定，这是 IETF 的一份工作文档，地址为 *[https://<wbr>github<wbr>.com<wbr>/cfrg<wbr>/draft<wbr>-irtf<wbr>-cfrg<wbr>-bls<wbr>-signature](https://github.com/cfrg/draft-irtf-cfrg-bls-signature)*。该文档指定了包括密钥生成（算法
    <samp class="SANS_TheSansMonoCd_W5Regular_11">KeyGen</samp>）、签名（<samp class="SANS_TheSansMonoCd_W5Regular_11">CoreSign</samp>）、验证（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CoreVerify</samp>）和密钥验证（<samp class="SANS_TheSansMonoCd_W5Regular_11">KeyValidate</samp>）在内的核心操作。给定公钥，后者确保公钥的有效性，即它“表示一个有效的非单位点，且在正确的子群中。”
- en: Key validation prevents the use of weak private/public keys pairs, for which
    signatures are easier to forge. For example, take the trivial case of a zero secret
    key *a* = 0\. It follows that the signature of any message *M* is 0 × **H**(*M*)
    = 0\. It’s therefore trivial to forge a signature for any message. In that case,
    the public key is then 0 × *G* = *O*, which is the point at infinity. If key validation
    rejects public keys equal to *O*, it ensures that the secret key is not zero.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥验证可以防止使用弱的私钥/公钥对，因为这类密钥的签名更容易伪造。例如，考虑一个简单的情况，零秘密密钥 *a* = 0\. 由此可得，任何消息 *M*
    的签名为 0 × **H**(*M*) = 0\. 因此，伪造任何消息的签名变得极其简单。在这种情况下，公钥则为 0 × *G* = *O*，即无穷远点。如果密钥验证拒绝等于
    *O* 的公钥，它就能确保秘密密钥不是零。
- en: A less trivial case is when the public key, as an elliptic curve point, has
    a value that makes it easier to forge signatures—that is, to create a valid signature
    without knowing the private key. Not all points on a given elliptic curve are
    equally secure—in particular, points that belong to a small subgroup rather than
    to the main subgroup of points. If a public key point belongs to one such small
    subgroup, there will be way fewer possible valid signatures, making it easier
    to forge a signature. Likewise, if the public key offered to the verification
    function doesn’t belong to the elliptic curve, then valid signatures are easy
    to forge.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不那么简单的情况是，当公钥作为椭圆曲线点时，其值使得伪造签名更容易——也就是说，可以在不知道私钥的情况下创建有效的签名。并非所有的椭圆曲线上的点都同样安全——特别是属于小子群而非主子群的点。如果公钥点属于这样的小子群，那么可能的有效签名会少得多，从而使伪造签名变得更加容易。同样，如果提供给验证函数的公钥不属于椭圆曲线，那么有效签名也容易被伪造。
- en: It’s therefore crucial to check that public keys are valid using the <samp class="SANS_TheSansMonoCd_W5Regular_11">KeyValidate</samp>
    algorithm from the aforementioned specification, as copied in [Listing 15-1](chapter15.xhtml#Lis15-1).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用上述规范中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">KeyValidate</samp>
    算法检查公钥是否有效是至关重要的，正如 [清单 15-1](chapter15.xhtml#Lis15-1) 中所复制的那样。
- en: '[PRE0]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-1: The</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">KeyValidate</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">algorithm
    ensures that a BLS public key is valid.</samp>'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 15-1：该</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">KeyValidate</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">算法确保BLS公钥是有效的。</samp>
- en: If you implement BLS signatures, make sure your code does all the checks described
    in the BLS specification when validating public keys and signatures.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你实现BLS签名，确保你的代码在验证公钥和签名时执行BLS规范中描述的所有检查。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Key Cancellation Attack</samp>
  id: totrans-211
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">密钥取消攻击</samp>
- en: 'In their basic form, BLS aggregate signatures with aggregate public keys are
    subject to the same type of key cancellation attack as Schnorr signatures: if
    an attacker knows the public keys *P*[1], *P*[2], . . . , *P*n – [1] of the first
    *n* – 1 signers, they can claim that their public key is'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在其基本形式中，带有聚合公钥的BLS聚合签名会受到与Schnorr签名相同类型的密钥取消攻击：如果攻击者知道前 *n* - 1 个签名者的公钥 *P*[1],
    *P*[2], . . . , *P*n – [1]，他们可以声称自己的公钥是
- en: '![](../images/pg315-1.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg315-1.jpg)'
- en: where *X* is the public key for which they know the private key *x*, such that
    *X* = *xG*. When the attacker presents a signature created from *x*, unsuspecting
    users verify a message’s signature using the public key *P*[1] + *P*[2] + . .
    . + *P*n, which is equal to *X*. The attacker can single-handedly sign a message
    on behalf of the set of supposed signers.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *X* 是他们知道私钥 *x* 的公钥，满足 *X* = *xG*。当攻击者提供一个由 *x* 创建的签名时，毫不怀疑的用户使用公钥 *P*[1]
    + *P*[2] + . . . + *P*n 验证消息签名，这等于 *X*。攻击者可以单方面代表假定的签名者集合签署一条消息。
- en: To prevent this attack, users may prove the knowledge of their public key’s
    private key by signing a message. As the attacker doesn’t know the private key
    of *P*n, they would fail this test.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种攻击，用户可以通过签名消息来证明他们知道其公钥的私钥。由于攻击者不知道 *P*n 的私钥，他们会未能通过此测试。
- en: Another mitigation is to modify the aggregate signature scheme so that the returned
    signature isn’t just the sum of signature *S* = *S*[1] + *S*[2] + . . . + *S*n
    but instead the sum with coefficients derived from public keys, as in
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种缓解方法是修改聚合签名方案，使返回的签名不仅仅是签名的和 *S* = *S*[1] + *S*[2] + . . . + *S*n，而是通过从公钥派生的系数和，如下所示
- en: '![](../images/pg315-2.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg315-2.jpg)'
- en: where *t*i = **H**(*P*i || *P*[1] || *P*[2] || . . . || *P*n) for *i* = 1, 2,
    . . . , *n*. The aggregate public key used to verify a signature is then *P* =
    *t*[1]*P*[1] + *t*[2]*P*[2] + . . . + *t*n*P*n. You can see that this trick works
    by checking that *e*(*P*, **H**(*M*)) still equals *e*(*G*, *S*).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *t*i = **H**(*P*i || *P*[1] || *P*[2] || . . . || *P*n)，对于 *i* = 1, 2, .
    . . , *n*。然后用于验证签名的聚合公钥是 *P* = *t*[1]*P*[1] + *t*[2]*P*[2] + . . . + *t*n*P*n。你可以通过检查
    *e*(*P*, **H**(*M*)) 是否仍然等于 *e*(*G*, *S*) 来验证这个技巧。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Threshold Signature Protocols</samp>
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">门限签名协议</samp>
- en: '*Threshold signatures* differ from multisignatures and aggregate signatures—which
    require all participants in the signing protocol to have their own public and
    private key—in that there’s a single private key *k* and a single public key *P*,
    and there are *n* participants that each has a distinct *share* of the key *k*i
    where a parameter *t* (the *threshold*) is defined such that *t* < *n* and:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*门限签名*与多重签名和聚合签名不同——后者要求所有参与签名协议的成员都必须有自己的公钥和私钥——其区别在于，门限签名有一个单一的私钥*k*和一个单一的公钥*P*，并且有*n*个参与者，每个参与者拥有私钥*k*的一个独特的*份额*
    *k*i，其中定义了一个参数*t*（*门限*），使得*t* < *n*，并且：'
- en: '*t* + 1 signers can jointly issue a valid signature of some message that is
    verified using the public key *P*, in such a way that no signer learns the private
    key *k*. This is done by running a protocol that uses the shares *k*i of each
    signer and the message to be signed, without ever exposing the private key to
    any party.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*t* + 1个签名者可以共同签署一个有效的消息签名，使用公钥*P*进行验证，从而确保没有任何签名者了解私钥*k*。这是通过运行一个协议来实现的，协议使用每个签名者的*k*i份额和需要签名的消息，在过程中永远不暴露私钥给任何一方。'
- en: A set of *t* signers or fewer can’t create a signature and therefore can’t determine
    the private key *k* either.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 少于*t*个签名者无法创建签名，因此也无法确定私钥*k*。
- en: The issued signature looks like a normal, single-signer signature and verifies
    as such.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 已签发的签名看起来像是一个普通的单签名签名，并且以这种方式进行验证。
- en: Threshold signatures are a specific type of *multiparty computation (MPC)*,
    a class of protocols wherein *n* participants compute the output of some function
    *f*(*x*[1], *x*[2], . . . , *x*n) such that each participant knows their respective
    input *x*i and learns the output of the function but doesn’t learn the other participants’
    *x*i inputs. In the case of threshold signatures, the *x*is are shares of the
    private key, and the output is a signature. I’ll elaborate on what a share is
    in the “Secret-Sharing Techniques” section on [page 319](#sec38).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 门限签名是一种特定类型的*多方计算（MPC）*，这是一个协议类，其中*n*个参与者计算某个函数*f*(*x*[1], *x*[2], . . . , *x*n)的输出，其中每个参与者知道自己的输入*x*i并学习函数的输出，但不会知道其他参与者的*x*i输入。对于门限签名而言，*x*i是私钥的份额，输出是签名。我将在“秘密共享技术”部分的[第319页](#sec38)详细说明什么是份额。
- en: Threshold signatures have the benefit of “hiding” the number of co-signers and
    their identities, as verifiers see only a signature from a single private key.
    While some multisignature and aggregate signature schemes share this property,
    threshold signatures better suit the use case of crypto asset custody because
    there’s only one private key and one public key; you can directly apply threshold
    signatures to distribute control of any address.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 门限签名的好处是“隐藏”了共同签名者的数量和身份，因为验证者只看到来自单一私钥的签名。尽管一些多重签名和聚合签名方案也具有这个特性，但门限签名更适合加密资产托管的使用场景，因为只有一个私钥和一个公钥；你可以直接将门限签名应用于分配任何地址的控制权。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Use Cases</samp>
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用案例</samp>
- en: 'Threshold signatures are used in cryptocurrency and digital asset management
    to distribute control of an address across multiple systems or parties. They can
    serve to share control of an account between a service provider and a user’s device:
    each party has one share of the key and must run a protocol together to sign a
    transaction, thus spending funds. This setup ensures that an attacker can’t autonomously
    authorize transactions, even if they breach the user’s device and obtain the key
    shares. Similarly, the provider can’t initiate transactions without the user’s
    consent. However, implementing this model reliably poses challenges, particularly
    key management aspects (key generation, key rotation, backups, and so on).'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 门限签名被广泛应用于加密货币和数字资产管理，用于在多个系统或各方之间分配对某个地址的控制权。它们可以用于在服务提供商和用户设备之间共享账户控制权：每个方拥有一个密钥份额，必须共同运行协议来签署交易，从而支出资金。这种设置确保了攻击者无法单独授权交易，即使他们突破了用户设备并获取了密钥份额。同样，服务提供商也无法在没有用户同意的情况下发起交易。然而，可靠地实现这一模型面临着挑战，尤其是在密钥管理方面（密钥生成、密钥轮换、备份等）。
- en: An organization can also use threshold signatures to distribute custody of funds
    across multiple systems, such as different device types, data centers, operating
    systems, and software components. This approach is particularly suitable for cold
    wallets and accounts containing significant assets. Relying solely on threshold
    signatures is insufficient, as comprehensive security measures and controls are
    crucial. For example, one must properly separate accesses to IT components to
    ensure that distinct individuals or IT service providers have access to different
    systems (thus different shares). Moreover, the initiation and approval of transactions
    must be subject to strict controls and an audit trail.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一个组织还可以使用门限签名将资金的托管分布在多个系统之间，例如不同的设备类型、数据中心、操作系统和软件组件。此方法特别适用于冷钱包和包含大量资产的账户。仅依赖门限签名是不够的，因为全面的安全措施和控制至关重要。例如，必须正确分离对IT组件的访问，确保不同的个人或IT服务提供商只能访问不同的系统（从而获得不同的份额）。此外，交易的发起和批准必须受到严格的控制，并具有审计跟踪。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Security Model</samp>
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">安全模型</samp>
- en: As with all cryptographic protocols, we need to define what it means for a threshold
    signing scheme to be secure. Such a security model includes the security goal
    (what should be hard for an attacker to do) and the attacker model (the assumptions
    about the attacker’s capabilities). Let’s delve into these two characteristics.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有密码学协议一样，我们需要定义门限签名方案安全的含义。这样的安全模型包括安全目标（攻击者应该难以做的事）和攻击者模型（对攻击者能力的假设）。让我们深入探讨这两个特性。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Security Goals</samp>
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">安全目标</samp>
- en: 'The main security goal of threshold signature is the same as that of single-party
    signatures: an attacker must not be able to forge valid signatures, which implies
    they must not be able to determine the private key. This also implies that the
    protocol ensures *input privacy*: the key shares held by the parties shouldn’t
    leak to any other party. Finally, the protocol must ensure *correctness*: the
    signature the protocol computes must be valid and accessible to all participants
    in the protocol execution.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 门限签名的主要安全目标与单一签名的安全目标相同：攻击者必须无法伪造有效签名，这意味着他们必须无法确定私钥。这还意味着协议必须确保*输入隐私*：各方持有的密钥份额不应泄漏给任何其他方。最后，协议必须确保*正确性*：协议计算出的签名必须有效，并且所有参与者在协议执行过程中都能够访问该签名。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Attacker Models</samp>
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">攻击者模型</samp>
- en: There isn’t one security model for threshold signatures; instead, an attacker
    is characterized according to several dimensions. The common threat in all attack
    scenarios is the assumption that an attacker can actively attack network communications—capturing,
    modifying, and injecting messages. Using a secure channel to establish authenticated
    and encrypted communications between the parties thwarts such attacks. Protocol
    designers also assume reliable communications in that all transmitted messages
    should be received in the same order they were sent.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 门限签名没有统一的安全模型；相反，攻击者是根据多个维度来定义的。所有攻击场景中的共同威胁是假设攻击者可以主动攻击网络通信——捕获、修改和注入消息。通过使用安全通道来建立参与方之间的身份验证和加密通信，可以防止此类攻击。协议设计者还假设通信是可靠的，即所有传输的消息应按发送的顺序接收。
- en: The attacker model of threshold signatures considers the *corruption* of participants—namely,
    that an attacker compromises their system, learns their secrets, and essentially
    gets them to do what they want. The model assumes that an attacker can’t corrupt
    more than *t* parties; otherwise, they’d be able to forge signatures, by definition
    of the threshold signing functionality.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 门限签名的攻击者模型考虑了*参与者的腐化*——即攻击者妥协其系统，获取其秘密，并基本上让他们做攻击者想做的事。该模型假设攻击者无法腐化超过*t*个参与者；否则，攻击者就能伪造签名，这符合门限签名功能的定义。
- en: Let’s examine the parameters to consider when an attacker can corrupt participants.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来审视当攻击者能够腐化参与者时需要考虑的参数。
- en: 'First, we characterize an attacker by the *number of parties* they could corrupt.
    Two categories of threshold signatures exist, each defined by the maximum number
    of malicious participants that can be compromised without compromising the security
    of the protocol:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过攻击者可以破坏的*方的数量*来描述攻击者。存在两类阈值签名，每类都由可以被攻破的恶意参与者的最大数量定义，而不破坏协议的安全性：
- en: '**Honest majority **Here, the attacker is limited to corrupting less than half
    of the key-sharing parties. Therefore, the threshold *t* must satisfy *t* < *n*/2\.
    By definition, a threshold signing protocol with parameters (*t*, *n*) must be
    safe even with compromised *t* participants. Protocols designed under the honest
    majority assumption are typically more efficient, but they can’t accommodate arbitrary
    values of *t*. For instance, a protocol with parameters (4, 5) is infeasible in
    this model, as it requires tolerating up to four corrupted parties.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**诚实的多数**在此模型下，攻击者仅限于破坏少于一半的密钥共享方。因此，阈值 *t* 必须满足 *t* < *n*/2。根据定义，具有参数（*t*,
    *n*）的阈值签名协议即使在 *t* 个参与方被破坏的情况下也必须是安全的。在诚实多数假设下设计的协议通常更高效，但它们无法容纳任意值的 *t*。例如，具有参数（4，5）的协议在此模型下是不可行的，因为它要求容忍最多四个被破坏的方。'
- en: '**Dishonest majority **This model allows the protocol to support any value
    of *t* from 1 to *n* – 1\. It enables the creation of protocols where all but
    one of the *n* parties could be corrupted, yet the malicious parties would still
    be incapable of forging signatures or recovering the private key. This model offers
    more flexibility in terms of the threshold value but often requires more complex
    and robust security mechanisms.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**不诚实的多数**该模型允许协议支持从 1 到 *n* - 1 的任何 *t* 值。它使得创建协议成为可能，在这种协议中，*n* 个参与方中，除了一个，其他的都可能被攻破，但恶意方仍然无法伪造签名或恢复私钥。该模型在阈值值方面提供了更多的灵活性，但通常需要更复杂和更强大的安全机制。'
- en: 'We also characterize an attacker by what they can do once they corrupt a party
    and learn their secret values (including the key share). There are two attacker
    models defining this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过攻击者在破坏一个方并获取其秘密值（包括密钥份额）后的行为来描述攻击者。有两种攻击者模型定义了这一点：
- en: '**Passive, or honest-but-curious **They learn information from corrupted parties
    but can’t force them to deviate from the protocol. This models “read-only” compromises,
    where an attacker gets a snapshot of a system’s memory, both storage and volatile
    memory (RAM, processor registers).'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**被动或诚实但好奇**他们从被破坏的方那里获取信息，但不能强迫其偏离协议。这种模型描述的是“只读”破坏，其中攻击者获得系统内存的快照，包括存储内存和易失性内存（RAM、处理器寄存器）。'
- en: '**Active, or malicious **Parties may arbitrarily deviate from the prescribed
    protocol. This models systems fully compromised by an attacker or controlled by
    a malicious insider (such as an operator, administrator, or cloud provider).'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**主动或恶意**各方可以任意偏离规定的协议。这种模型描述的是系统完全被攻击者攻破或被恶意内部人员（例如操作员、管理员或云服务提供商）控制的情况。'
- en: A protocol secure against active attackers is therefore always secure against
    passive attackers, but not the other way around.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个对主动攻击者安全的协议总是对被动攻击者安全，但反之则不然。
- en: 'There are two ways for an attacker to choose which parties to corrupt, which
    are defined by the following models of corruption type:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者有两种选择破坏哪些方的方式，这由以下破坏类型模型定义：
- en: '**Static corruption **The attacker must choose which participants to corrupt
    before starting the protocol.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**静态破坏**攻击者必须在协议开始之前选择哪些参与方进行破坏。'
- en: '**Adaptive corruption **The attacker may wait until after the protocol begins
    to choose which participants to corrupt—and then learn the history of their operations
    throughout the protocol.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**自适应破坏**攻击者可以等到协议开始后再选择破坏哪些参与方，并在协议过程中了解他们的操作历史。'
- en: A protocol secure against static corruption is always secure against adaptive
    corruption, but not the other way around. However, there are techniques to convert
    a protocol from secure against static corruption to secure against adaptive corruption.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对静态破坏安全的协议总是对自适应破坏安全，但反之则不然。然而，有一些技术可以将一个协议从对静态破坏安全转化为对自适应破坏安全。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Secret-Sharing
    Techniques</samp>'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">秘密共享技术</samp>'
- en: A key ingredient of threshold signatures is *secret-sharing* protocols, or techniques
    that split a secret into multiple pieces (*shares*) distributed to different parties
    in a way that the parties can then jointly recompute the initial secret. Secret-sharing
    protocols can notably be used when creating backups of private keys such that
    different parties store different shares in different locations.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 阈值签名的一个关键组成部分是 *秘密共享* 协议，或者是将秘密分割成多个部分（*共享*）并分发给不同方的技术，这样各方可以共同重建初始的秘密。秘密共享协议可以特别用于创建私钥的备份，其中不同方在不同位置存储不同的共享。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Additive Sharing</samp>
  id: totrans-250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">加法共享</samp>
- en: 'The simplest way to share a secret that you see as a number is through *additive
    sharing*: given a number *s*, you share it as *n* values *s*[1], *s*[2], . . .
    , *s*n such that *s*[1] + *s*[2] + . . . + *s*n = *s.* For example, if you work
    with numbers modulo 100, you could create a random additive sharing of the number
    *s* = 47 into four shares as follows: pick three random numbers between 0 and
    99, say *s*[1] = 12, *s*[2] = 94, and *s*[3] = 80, and set *s*[4] = *s* – *s*[1]
    – *s*[2] – *s*[3] = 61\. (Note that subtraction is computed modulo 100, such that
    –1 = 99, –2 = 98, and so on.)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 分享你认为是数字的秘密的最简单方法是通过 *加法共享*：给定一个数字 *s*，你将其分享为 *n* 个值 *s*[1]、*s*[2]、…、*s*n，使得
    *s*[1] + *s*[2] + … + *s*n = *s*。例如，如果你使用模100的数字，可以将数字 *s* = 47 随机加法共享成四个份额，如下所示：随机选择三个介于0和99之间的数字，假设
    *s*[1] = 12、*s*[2] = 94、*s*[3] = 80，然后设定 *s*[4] = *s* – *s*[1] – *s*[2] – *s*[3]
    = 61。 （注意，减法是按模100计算的，因此 –1 = 99，–2 = 98，依此类推。）
- en: This approach is very simple but requires using all the shares to recover the
    original secret.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法非常简单，但需要使用所有的共享来恢复原始秘密。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Threshold Sharing</samp>
  id: totrans-253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">阈值共享</samp>
- en: 'Threshold sharing is closer to what threshold signatures do: given parameters
    *n* and *t* < *n* and the secret *s*, it creates shares such that you can recover
    the secret using any set of *t* shares out of the *n* created.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 阈值共享更接近阈值签名的功能：给定参数 *n* 和 *t* < *n* 以及秘密 *s*，它生成共享，使得你可以通过任意 *t* 个共享来恢复秘密，*n*
    个共享中任意选取。
- en: 'The best-known threshold sharing method is *Shamir’s secret sharing*, which
    leverages the following property of polynomials: given a polynomial of degree
    *t* of the form'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 最著名的阈值共享方法是 *Shamir 的秘密共享*，它利用多项式的以下特性：给定一个次数为 *t* 的多项式，形式为
- en: '![](../images/pg319-1.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg319-1.jpg)'
- en: you need the result of only *t* + 1 evaluations of *f*(*x*) on *t* + 1 distinct
    values of *x* to determine all *a*i coefficients, which are fixed values.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要对 *f*(*x*) 在 *t* + 1 个不同的 *x* 值上进行 *t* + 1 次评估，就可以确定所有的 *a*i 系数，这些系数是固定值。
- en: To create a threshold secret sharing from this property, set *a*[0] = *s*, the
    secret. Then pick random values of *a*[1] to *a*t and compute *f*(*x*) for *n*
    distinct values of *x*, which will be the *n* shares of the secret.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要从这个性质创建阈值秘密共享，设定 *a*[0] = *s*，即秘密。然后随机选择 *a*[1] 到 *a*t 的值，并计算 *f*(*x*) 在 *n*
    个不同的 *x* 值上，这些将是 *n* 个秘密的共享。
- en: Recomputing the coefficients from the *f*(*x*) values is a technique called
    *Lagrange interpolation*, from the 18th-century Italian mathematician who developed
    a general method to determine the equation of a curve given a list of points on
    that curve. Indeed, you can view the problem geometrically. If the equation has
    degree 1 (and is of the form *a*[0] + *a*[1]*x*), then it’s the equation of a
    line, and knowing two points on a line is sufficient to uniquely identify the
    line. Likewise, if the equation has degree 2 (of the form *a*[0] + *a*[1]*x* +
    *a*[2]*x*²), then the curve is a parabola, whose equation can be determined with
    three points.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *f*(*x*) 值重新计算系数是一种叫做 *拉格朗日插值* 的技术，这项技术源自18世纪的意大利数学家，他开发了一种通用方法来确定给定曲线上多个点的曲线方程。实际上，你可以从几何角度来看这个问题。如果方程的次数是1（形式为
    *a*[0] + *a*[1]*x*），那么它是直线方程，知道直线上的两个点足以唯一确定这条直线。同样，如果方程的次数是2（形式为 *a*[0] + *a*[1]*x*
    + *a*[2]*x*²），那么曲线是抛物线，可以通过三个点来确定其方程。
- en: We sometimes find implementations of Shamir’s secret sharing defining a function
    **Lagrange**() that computes the interpolation and returns the *a*[0] coefficient,
    which is the shared secret. If you have values of *f*(*x*) to combine to recover
    the secret, you can define the operation **Lagrange**(*s*[1], *s*[2], . . . ,
    *s*t) returning the shared secret *s*. This works for any combination of *t* distinct
    shares, not necessarily the first *t* ones. The details of the **Lagrange**()
    operation are a bit too technical for this book, but you can implement it as a
    series of basic additions, multiplications, and inverses.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有时会发现Shamir秘密共享的实现中定义了一个函数**拉格朗日**()，该函数计算插值并返回*a*[0]系数，即共享秘密。如果你有*f*(*x*)值要组合以恢复秘密，你可以定义操作**拉格朗日**(*s*[1],
    *s*[2], . . . , *s*t)，返回共享秘密*s*。这适用于任何*t*个不同共享的组合，而不一定是前*t*个共享。**拉格朗日**()操作的细节对于本书来说有些过于技术性，但你可以将其实现为一系列基本的加法、乘法和求逆运算。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Trivial Case</samp>
  id: totrans-261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">平凡情况</samp>
- en: 'One of the simplest types of threshold signature uses the BLS signature, as
    viewed earlier in the context of aggregate signatures. Recall that given a private
    key *k*, BLS signatures compute a signature by multiplying *k* with the curve
    point *H* = **H**(*M*). You can use additive sharing to create a threshold scheme
    with parameters (*n* – 1, *n*). For example, if *n* = 3, split the key into three
    shares such that *k*[1] + *k*[2] + *k*[3] = *k*. Each party then computes their
    share of the signature by multiplying their share *k*i with *H*. Adding the three
    shares then yields the following:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的门限签名类型之一使用了BLS签名，如前文在聚合签名的上下文中所提到的。回顾一下，给定一个私钥*k*，BLS签名通过将*k*与曲线点*H* = **H**(*M*)相乘来计算签名。你可以使用加法共享创建一个门限方案，其参数为(*n*
    – 1, *n*)。例如，如果*n* = 3，将密钥分为三个共享，使得*k*[1] + *k*[2] + *k*[3] = *k*。然后，每个参与方通过将各自的共享*k*i与*H*相乘来计算他们的签名部分。将三个共享相加后，得到如下结果：
- en: '![](../images/pg320-1.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg320-1.jpg)'
- en: Combining the three shares via addition gives a valid signature with *k*, even
    if none of the parties knows *k*. The parties could also recover *k* if they add
    their respective shares, but adding the shares of two parties reveals no information
    on *k* if the shares were randomly generated.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 通过加法组合三个共享，可以得到一个有效的签名，即使没有任何一方知道*k*。各方还可以通过相加各自的共享来恢复*k*，但如果共享是随机生成的，两个参与方共享相加不会泄露任何关于*k*的信息。
- en: 'To create a threshold signature scheme with arbitrary *t* and *n*, use the
    Shamir secret-sharing technique and leverage the linearity of the **Lagrange**()
    operation: you generate the key shares *k*i as described in the “Threshold Sharing”
    section and compute the signature like so:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个具有任意*t*和*n*的门限签名方案，使用Shamir秘密共享技术，并利用**拉格朗日**()运算的线性特性：你生成如“门限共享”部分中描述的密钥共享*k*i，并按照以下方式计算签名：
- en: '![](../images/pg320-2.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg320-2.jpg)'
- en: Again, you obtain a valid signature with the key *k*.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以用密钥*k*得到一个有效的签名。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Simple Case</samp>
  id: totrans-268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">简单情况</samp>
- en: 'You’ll now compute Schnorr signatures in the threshold setting, which is a
    bit more technical than with BLS signatures. Recall the Schnorr scheme computes
    a signature as *s* = *r* + *ha*, where *h* = **H**(*R* || *A* || *M*), *r* is
    the per-signature random nonce, and *a* is the signer’s private key. The signature
    also includes *R* = *rG*, the public nonce value. This is relatively easy to turn
    into a threshold signature scheme, owing to its linearity with respect to secret
    values: observe that the secret *r* is added to the secret *a* multiplied by the
    hash *h*, which is not secret.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在将在门限设置中计算Schnorr签名，这比使用BLS签名更为技术性。回顾一下，Schnorr方案通过*s* = *r* + *ha*来计算签名，其中*h*
    = **H**(*R* || *A* || *M*)，*r*是每个签名的随机nonce，*a*是签名者的私钥。签名还包括*R* = *rG*，即公共nonce值。由于它对秘密值的线性关系，这相对容易转化为一个门限签名方案：注意到秘密*r*与秘密*a*相加，乘以哈希*h*（哈希*h*不是秘密）。
- en: 'Imagine the simplest case of two signers, with an additive sharing of the private
    signing key *k* = *a* + *b*, with *a* and *b* the respective key shares of the
    two signers. To sign, the two parties could generate secret nonces *r*[A] and
    *r*[B], with respective public values *R*[A] = *r*[A]*G* and *R*[B] = *r*[B]*G*.
    The parties can then exchange these values and compute the public nonce *R* =
    *R*[A] + *R*[B], which will be part of the signature. *R* is then the public value
    you derive from the private value *r* = *r*[A] + *r*[B], since you have:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 想象最简单的情况：两个签名者，私钥*k* = *a* + *b*的加法共享，其中*a*和*b*是两个签名者的各自密钥份额。为了签名，两个参与方可以生成秘密随机数*r*[A]
    和 *r*[B]*，其相应的公钥值为*R*[A] = *r*[A]*G* 和 *R*[B] = *r*[B]*G*。参与方然后可以交换这些值并计算公钥随机数*R*
    = *R*[A] + *R*[B]*，该值将成为签名的一部分。*R*即是你从私有值*r* = *r*[A] + *r*[B]中派生出来的公共值，因为你有：
- en: '![](../images/pg320-3.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg320-3.jpg)'
- en: 'Next, the parties compute their shares of the signature: *s*[A] = *r*[A] +
    *ha* and *s*[B] = *r*[B] + *hb*, which are added together to yield:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，参与方计算他们的签名份额：*s*[A] = *r*[A] + *ha* 和 *s*[B] = *r*[B] + *hb*，然后将其加起来得到：
- en: '![](../images/pg321-1.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg321-1.jpg)'
- en: You thus obtain *r* + *hk*, a signature from the key *k*, even though participants
    used only the additive shares *a* and *b* in their computations. To obtain a threshold
    construction for arbitrary parameters *t* and *n*, Shamir’s secret sharing can
    be used instead of additive sharing.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你得到*r* + *hk*，一个来自密钥*k*的签名，尽管参与方只在计算中使用了加法共享的*a*和*b*。要获得任意参数*t*和*n*的门限构造，可以使用Shamir的秘密共享，而不是加法共享。
- en: The previous construction isn’t secure enough to satisfy all the security requirements
    of a threshold signing scheme. It’s notably vulnerable to key cancellation attacks
    unless participants *commit* to their nonces in a preliminary phase of the protocol—for
    example, by sending the hash of their nonce. It also has a number of subtle vulnerabilities
    addressed by the protocol Flexible Round-Optimized Schnorr Threshold (FROST) signatures,
    designed by cryptographers Chelsea Komlo and Ian Goldberg in 2020 and documented
    at *[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2020<wbr>/852](https://eprint.iacr.org/2020/852)*.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的构造不足以满足门限签名方案的所有安全要求。特别是，除非参与方在协议的预备阶段*承诺*他们的随机数，否则它容易受到密钥撤销攻击——例如，通过发送其随机数的哈希值。它还存在一些微妙的漏洞，这些漏洞已通过协议“灵活轮次优化Schnorr门限（FROST）签名”得以解决，该协议由密码学家Chelsea
    Komlo和Ian Goldberg于2020年设计，并在*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2020<wbr>/852](https://eprint.iacr.org/2020/852)*中有文档说明。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*The EdDSA signature protocol from [Chapter 12](chapter12.xhtml) is similar
    to Schnorr’s signatures but computes the nonce as a hash from the message, rather
    than as a random, arbitrary value. This complicates the creation of threshold
    signature protocols compliant with the original EdDSA specification.*'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '*[第12章](chapter12.xhtml)中的EdDSA签名协议类似于Schnorr签名，但它是将消息的哈希值作为随机的、任意的值来计算nonce，而不是一个随机数值。这使得根据原始EdDSA规范构建符合要求的门限签名协议变得复杂。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Hard Case</samp>
  id: totrans-278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">复杂情况</samp>
- en: The hardest signature scheme to run in a threshold setting is also the most
    common. The ECDSA signature algorithm (see [Chapter 12](chapter12.xhtml)) is more
    complex than Schnorr signatures and EdDSA because it involves a division. Given
    a message hash *h* = **H**(*M*), the signer picks a random number *k*, computes
    the number *r* from the point *kG*’s coordinates, and computes the signature as
    *s* = (*h* + *ra*) / *k*, where *a* is the private key of the signer.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在门限设置中，最难运行的签名方案也是最常见的。ECDSA签名算法（参见[第12章](chapter12.xhtml)）比Schnorr签名和EdDSA更复杂，因为它涉及除法。给定消息哈希*h*
    = **H**(*M*)，签名者选择一个随机数*k*，根据点*kG*的坐标计算数字*r*，并将签名计算为*s* = (*h* + *ra*) / *k*，其中*a*是签名者的私钥。
- en: Efficient and secure ECDSA threshold signatures remain a challenging research
    problem among cryptographers. The first practical protocols appeared in the late
    2010s, motivated by the use case of cryptocurrency—most of the leading cryptocurrencies,
    including Bitcoin and Ethereum, then supported only ECDSA as a transaction signing
    scheme.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 高效且安全的ECDSA门限签名仍然是密码学家们面临的一个具有挑战性的研究课题。第一个实际协议出现在2010年代末期，受到加密货币使用案例的推动——当时，大多数领先的加密货币，包括比特币和以太坊，只支持ECDSA作为交易签名方案。
- en: Cryptographers devised several approaches to build ECDSA threshold signing protocols.
    For example, Yehuda Lindell’s 2017 “Fast Secure Two-Party ECDSA Signing” (*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2017<wbr>/552](https://eprint.iacr.org/2017/552)*)
    required a commitment scheme, homomorphic encryption scheme, and zero-knowledge
    proof system. The complexity of such protocols complicated their understanding,
    implementation, and security analysis, leading to a number of security flaws in
    deployed systems.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学家们设计了几种方法来构建ECDSA阈值签名协议。例如，Yehuda Lindell在2017年提出的“快速安全的双方ECDSA签名” (*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2017<wbr>/552](https://eprint.iacr.org/2017/552)*)
    需要一个承诺方案、同态加密方案和零知识证明系统。这些协议的复杂性使得它们的理解、实现和安全分析变得困难，从而导致了已部署系统中的一些安全漏洞。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">How Things Can Go
    Wrong</samp>
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">事物如何出错</samp>
- en: Specific security issues in threshold signature protocols are often complex
    and involve details of cryptographic constructions that I haven’t covered in this
    book. Therefore, instead of specific problems, I’ll discuss categories of problems
    that impacted real deployments of threshold signatures, from widely used open
    source software to commercial solutions.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 阈值签名协议中的具体安全问题通常非常复杂，涉及密码学构造的细节，而这些内容我在本书中没有涵盖。因此，我将讨论影响阈值签名实际部署的各种问题，而不是具体问题，这些问题来自广泛使用的开源软件到商业解决方案。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Papers vs. Code</samp>
  id: totrans-284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">论文与代码</samp>
- en: 'When engineers need to implement a threshold signature protocol from their
    research papers, they encounter challenges. These papers, primarily aimed at cryptography
    researchers, often vary in editorial quality and are complicated, heavy in mathematics,
    and quite new. This recency can mean that an experimental protocol might not be
    as secure as intended. These factors contribute to a range of real-world security
    issues, which can be categorized into four main areas:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当工程师们需要根据研究论文实现一个阈值签名协议时，他们会遇到挑战。这些论文主要面向密码学研究人员，通常编辑质量不一，内容复杂、数学重，并且相当新颖。正因为如此，这些协议可能在实验中并没有达到预期的安全性。这些因素导致了一系列现实世界中的安全问题，可以分为四个主要领域：
- en: '**Insecure protocol **If the protocol isn’t secure on paper, it won’t be more
    secure in implementation. Common issues include overlooked edge cases or inadequate
    validation when receiving inputs from other parties. For example, some protocols
    failed to verify if an encrypted number falls within the expected range, leading
    to practical attacks.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**不安全的协议** 如果协议在纸面上不安全，那么在实现过程中也不会更安全。常见的问题包括忽略了边缘情况或在接收来自其他方的输入时缺乏充分的验证。例如，一些协议未能验证加密后的数字是否在预期范围内，从而导致实际攻击的发生。'
- en: '**Incomplete description **Research papers aren’t technical specifications
    but are written for academic audiences, so they often lack practical implementation
    details like networking and encoding. A notable example is the TSSHOCK attack
    on threshold signatures, which exploited ambiguous encoding in a hash function’s
    input elements, as described in “Collisions from Domain Separation Failures” on
    [page 305](#sec13).'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**描述不完整** 研究论文不是技术规格，而是为学术读者编写的，因此通常缺乏像网络和编码这样的实际实现细节。一个显著的例子是TSSHOCK攻击，它利用了阈值签名中的哈希函数输入元素中的模糊编码，正如在“领域分离失败导致的冲突”一文中描述的那样，见[第305页](#sec13)。'
- en: '**Incomplete implementation **The complexity of threshold signing protocols,
    with their numerous subcomponents and detailed requirements, can lead to overlooked
    security validations, particularly if these are mentioned only in appendixes.
    An instance of this was when a protocol required a number *N* = *pq* (for Paillier
    encryption) to be verified as the product of two large enough primes via a zero-knowledge
    proof, but this verification was omitted in the implementation, allowing insecure
    *N* values.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现不完整** 阈值签名协议的复杂性，包括其众多子组件和详细要求，可能导致一些安全验证被忽视，尤其是当这些验证仅在附录中提及时。一个例子是，当一个协议要求对一个数字
    *N* = *pq*（用于Paillier加密）进行零知识证明，验证其为两个足够大的素数的乘积时，但在实现中忽略了这个验证，从而允许不安全的 *N* 值。'
- en: '**Insecure component choice **Descriptions of protocols usually don’t say “use
    the hash function BLAKE3” or “use the 256-bit elliptic curve nistp256”; instead,
    they say “use a hash function and an elliptic curve that offer the security level
    you need.” It’s thus up to the implementers to pick suitable primitives and use
    their programming interfaces securely. For example, using an RSA modulus of 1,024
    bits isn’t enough to ensure 128-bit security.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**不安全的组件选择** 协议的描述通常不会说“使用哈希函数BLAKE3”或“使用256位椭圆曲线nistp256”；相反，它们会说“使用提供所需安全级别的哈希函数和椭圆曲线”。因此，选择合适的原语并安全地使用它们的编程接口是由实现者来决定的。例如，使用1,024位的RSA模数并不足以确保128位的安全性。'
- en: 'Additionally, risks arise when implementers intentionally modify a protocol,
    perhaps to enhance efficiency or fit a specific use case. This usually doesn’t
    end well. For examples of attacks on threshold signatures, see the papers “Alpha-Rays:
    Key Extraction Attacks on Threshold ECDSA Implementations” by Dmytro Tymokhanov
    and Omer Shlomovits (*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2021<wbr>/1621](https://eprint.iacr.org/2021/1621)*)
    and “Practical Key-Extraction Attacks in Leading MPC Wallets” by Nikolaos Makriyannis,
    Oren Yomtov, and Arik Galansky (*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2023<wbr>/1234](https://eprint.iacr.org/2023/1234)*).'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '此外，当实现者故意修改协议时，也会产生风险，可能是为了提高效率或适应特定的使用案例。这通常不会有好的结果。有关阈值签名攻击的示例，请参阅Dmytro
    Tymokhanov和Omer Shlomovits的论文“Alpha-Rays: Key Extraction Attacks on Threshold
    ECDSA Implementations”（*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2021<wbr>/1621](https://eprint.iacr.org/2021/1621)）以及Nikolaos
    Makriyannis、Oren Yomtov和Arik Galansky的论文“Practical Key-Extraction Attacks in Leading
    MPC Wallets”（*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2023<wbr>/1234](https://eprint.iacr.org/2023/1234)*）。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Key Management Aspects</samp>
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">密钥管理方面</samp>
- en: A friend once remarked, “For every 10 lines of encryption code, there are 1,500
    lines of key management,” which emphasizes the criticality and intricacy of key
    management processes, including key creation, storage, backup, and recovery. While
    these facets may be overlooked in academic papers focusing on theoretical aspects,
    they’re vital in practical applications. Engineers and security professionals
    implementing threshold signing in a production environment must prioritize these
    key management issues—even the most robust threshold signature protocols are no
    substitute for comprehensive key management practices.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 一位朋友曾经说过：“每10行加密代码，就有1,500行密钥管理代码”，这强调了密钥管理过程的关键性和复杂性，包括密钥创建、存储、备份和恢复。尽管这些方面在专注于理论方面的学术论文中可能被忽视，但它们在实际应用中至关重要。在生产环境中实现阈值签名的工程师和安全专家必须优先考虑这些密钥管理问题——即使是最强大的阈值签名协议也无法替代全面的密钥管理实践。
- en: 'Let’s review the main key management considerations for an organization employing
    threshold signatures to safeguard substantial cryptocurrency holdings:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下一个组织在使用阈值签名来保护大量加密货币资产时的主要密钥管理考虑因素：
- en: '**Key generation **Whether you’re using distributed key generation or centralized
    generation, you must ensure that the secret values aren’t exposed to unauthorized
    systems or parties during or after the key generation. This assurance is generally
    provided through rigorous processes such as key ceremonies, ensuring supply-chain
    integrity and audit trail, to demonstrate that keys have been generated properly.
    Don’t allow another party (such as a cloud provider) to generate keys on your
    behalf or to have the capability to read them at any time.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '**密钥生成** 无论是使用分布式密钥生成还是集中式生成，必须确保在密钥生成期间或之后，秘密值不会暴露给未经授权的系统或方。这种保证通常通过严格的流程提供，如密钥仪式、确保供应链的完整性和审计跟踪，以证明密钥已正确生成。不要允许其他方（如云服务提供商）代表你生成密钥，或随时有能力读取它们。'
- en: '**Key storage **Storing a key as multiple shares instead of a single value
    doesn’t diminish the necessity for secure storage. Safeguarding numerous secrets
    across diverse platforms can present more of a challenge than protecting a single
    secret on a unified platform. Key shares must be stored in some type of secure
    memory, protected against unauthorized access, tampering, and physical attacks.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**密钥存储** 将密钥作为多个份额存储而不是单一值，并不会减少对安全存储的必要性。在不同平台上保护多个秘密可能比在统一平台上保护单一秘密更加具有挑战性。密钥份额必须存储在某种类型的安全内存中，防止未经授权的访问、篡改和物理攻击。'
- en: '**Key backup and recovery **Implementing a threshold scheme where, for instance,
    you require three out of six shares to sign a transaction, protects against the
    loss of key shares or system outages. Nevertheless, this doesn’t negate the necessity
    for key backups, which you should also maintain as threshold shares. It’s imperative
    to distribute access to these backup shares among distinct parties. Additionally,
    validate the reliability of backups periodically to ensure they haven’t been compromised
    and can be effectively utilized to reconstruct the key when necessary, such as
    during disaster recovery drills.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**密钥备份和恢复** 实施一种阈值方案，例如要求六个共享中的三个签名以执行交易，可以防止密钥共享丢失或系统停机。然而，这并不意味着不再需要密钥备份，你仍然需要将备份作为阈值共享进行保存。至关重要的是，将这些备份共享的访问权限分配给不同的方。此外，定期验证备份的可靠性，以确保它们未被破坏，并且在需要时能够有效地用来重建密钥，例如在灾难恢复演练中。'
- en: <samp class="SANS_Futura_Std_Bold_B_11">Zero-Knowledge Proofs</samp>
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">零知识证明</samp>
- en: '*Zero-knowledge proofs (ZKPs)* are one of cryptographers’ most powerful tools.
    These are protocols between two parties, a *prover* and a *verifier*, where the
    prover convinces the verifier that something is true without revealing anything
    about why. For example, the prover could prove that they know a solution to some
    hard computational problem without revealing the solution. You might create a
    ZKP for any **NP**-complete problems to prove you know a solution without revealing
    it.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '*零知识证明（ZKP）*是密码学家最强大的工具之一。这些协议涉及两个参与方，一个是*证明者*，另一个是*验证者*，其中证明者向验证者证明某个事情是真实的，但并不会透露任何有关原因的信息。例如，证明者可以证明他们知道某个困难计算问题的解决方案，但并不透露该解决方案。你可能会为任何**NP**-完全问题创建一个ZKP，以证明你知道解决方案，但不透露它。'
- en: More generally, ZKPs are used to prove a statement, such as “the number encrypted
    in this ciphertext is between 100 and 200” or “for a given plaintext *P* and ciphertext
    *C*, I know a secret key *K* for which *C* = **AES**(*K*, *P*).”
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地说，ZKP用于证明某个陈述，例如“这个密文中加密的数字在100和200之间”或“对于给定的明文*P*和密文*C*，我知道一个秘密密钥*K*，使得*C*
    = **AES**(*K*, *P*)。”
- en: For a non-technical introduction to zero-knowledge proofs, I recommend cryptographer
    Amit Sahai’s video “Computer Scientist Explains One Concept in 5 Levels of Difficulty”
    (*[https://<wbr>youtu<wbr>.be<wbr>/fOGdb1CTu5c](https://youtu.be/fOGdb1CTu5c)*).
    For mathematical details, see the links on *[https://<wbr>github<wbr>.com<wbr>/matter<wbr>-labs<wbr>/awesome<wbr>-zero<wbr>-knowledge<wbr>-proofs](https://github.com/matter-labs/awesome-zero-knowledge-proofs)*.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 对于零知识证明的非技术性介绍，我推荐密码学家Amit Sahai的的视频“计算机科学家用5个难度级别解释一个概念”（* [https://<wbr>youtu<wbr>.be<wbr>/fOGdb1CTu5c](https://youtu.be/fOGdb1CTu5c)*）。如需数学细节，请参阅*[https://<wbr>github<wbr>.com<wbr>/matter<wbr>-labs<wbr>/awesome<wbr>-zero<wbr>-knowledge<wbr>-proofs](https://github.com/matter-labs/awesome-zero-knowledge-proofs)*上的链接。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*The term* zero-knowledge proof *is a simplification of more accurate terms
    from the research literature. For example, many “zero-knowledge proof” protocols
    are in fact* zero-knowledge arguments of knowledge*. Researchers reserve the term*
    proof *for unconditional security and use* argument *for computational security.
    Furthermore, the term* witness *refers to the secret allowing the prover to prove
    its statement, as a generalization of* secret *or* secret key*, due to its broader
    scope.*'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '*零知识证明*这一术语是对研究文献中更准确术语的简化。例如，许多“零知识证明”协议实际上是*零知识论证*。研究人员将“证明”一词保留给无条件安全性，并将“论证”一词用于计算安全性。此外，“见证人”一词指的是使证明者能够证明其陈述的秘密，作为*秘密*或*密钥*的广义化，因为其涵盖范围更广。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Security Model</samp>
  id: totrans-303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">安全模型</samp>
- en: What does it mean for a ZKP protocol to be secure? Is the attacker the prover
    or the verifier? How can they attack the protocol? Let’s answer these questions
    by examining security goals and attacker models.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 对于ZKP协议来说，什么才算安全？攻击者是证明者还是验证者？他们如何攻击该协议？让我们通过检查安全目标和攻击者模型来回答这些问题。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Security Goals</samp>
  id: totrans-305
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">安全目标</samp>
- en: 'A secure ZKP must satisfy the following notions:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 一个安全的零知识证明（ZKP）必须满足以下概念：
- en: '**Completeness **If the prover follows the protocol using the correct secret,
    an honest verifier is convinced of the truth of the statement. In other words,
    the protocol always works.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '**完整性** 如果证明者遵循协议并使用正确的密钥，诚实的验证者会确信陈述的真实性。换句话说，协议总是有效的。'
- en: '**Soundness **If the prover doesn’t know the secret, they can’t convince the
    honest verifier of a false statement (except with negligible probability). In
    other words, provers can’t cheat.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**健全性** 如果证明者不知道秘密，他们无法说服诚实的验证者一个虚假的陈述（除非是极小的概率）。换句话说，证明者不能作弊。'
- en: '**Zero-knowledge **A verifier learns nothing beyond the fact that the statement
    is true. Specifically, they can’t learn anything about the prover’s secret.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**零知识** 验证者除了知道陈述为真之外，什么也不会学到。具体来说，他们不能学到任何关于证明者秘密的信息。'
- en: The notion that a verifier “will be convinced of the truth of the statement”
    is guaranteed by the mutual agreement that the protocol satisfies these three
    properties—namely, that a prover could not complete the protocol if the statement
    was false (for example, if they didn’t know the solution they claim to).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: “验证者将被说服相信陈述的真实性”这一概念由协议满足这三项属性的相互一致性保证——即如果陈述为假（例如，如果他们不知道自己声称知道的解决方案），证明者将无法完成协议。
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Attacker Models</samp>'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">攻击者模型</samp>'
- en: 'Both parties can potentially be attackers attempting to compromise soundness
    and zero-knowledge, respectively:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 双方都有可能是攻击者，分别尝试妥协健全性和零知识属性：
- en: '**Malicious provers **Want to prove a false statement—for example, to wrongly
    convince the verifier that they know a solution to some hard problem. Such an
    attacker can deviate from the protocol to try to fool the verifier. In practice,
    this is the greatest threat to ZKPs in applications like confidential program
    execution.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**恶意证明者** 想要证明一个虚假的陈述——例如，错误地说服验证者他们知道某个难题的解决方案。这样的攻击者可能会偏离协议，试图欺骗验证者。实际上，这对像机密程序执行这样的应用中的零知识证明（ZKP）构成了最大的威胁。'
- en: '**Malicious verifiers **Want to extract information about the secret (the *witness*),
    thereby breaking the zero-knowledge property. Attacker models distinguish *passive*
    verifier attackers (honest-but-curious) and *active* verifier attackers (who can
    arbitrarily deviate from the protocol).'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '**恶意验证者** 想要提取关于秘密的信息（即 *证人*），从而破坏零知识特性。攻击者模型区分了 *被动* 验证者攻击者（诚实但好奇）和 *主动* 验证者攻击者（可以任意偏离协议）。'
- en: Note that malicious verifiers can challenge completeness by claiming they aren’t
    convinced by the truth of a statement. In practice, this isn’t an issue, as the
    prover can repeat the proof protocol for other (honest) verifiers who would expose
    the lying verifier.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，恶意验证者可能通过声称他们不相信陈述的真实性来挑战完整性。实际上，这不是问题，因为证明者可以为其他（诚实的）验证者重复证明协议，从而揭露撒谎的验证者。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Schnorr’s Protocol</samp>
  id: totrans-316
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Schnorr 协议</samp>
- en: Claus-Peter Schnorr, who created the eponymous signature scheme, also described
    a similar construction that is a zero-knowledge *proof of knowledge of a discrete
    logarithm*. It’s the basis for Schnorr’s and EdDSA signatures, as well as for
    many more complex ZKPs.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Claus-Peter Schnorr，发明了同名签名方案的他，也描述了一种类似的构造，它是零知识的 *离散对数知识证明*。这构成了 Schnorr 和
    EdDSA 签名的基础，以及许多更复杂的零知识证明的基础。
- en: 'Schnorr’s protocol works in three steps to prove the knowledge of *a* such
    that *aG* = *A*—that is, the discrete logarithm of *A* with respect to the generator
    *G*:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: Schnorr 协议通过三个步骤证明 *a* 的知识，即 *aG* = *A*——也就是 *A* 相对于生成元 *G* 的离散对数：
- en: '1.  *Commitment*: The prover picks a random number *r* and sends *R* = *rG*.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  *承诺*：证明者选择一个随机数 *r* 并发送 *R* = *rG*。
- en: '2.  *Challenge*: The verifier sends a random number *c*.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  *挑战*：验证者发送一个随机数 *c*。
- en: '3.  *Response*: The prover sends *s* = *r* + *ca*, and the verifier accepts
    if and only if *sG* = *R + cA*.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  *响应*：证明者发送 *s* = *r* + *ca*，且当且仅当 *sG* = *R + cA* 时，验证者接受。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-322
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*This kind of three-step protocol, with a commitment, a challenge, and a response,
    is called a* sigma protocol*, after the shape of the uppercase Greek letter sigma
    (Σ).*'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '*这种具有承诺、挑战和响应的三步协议称为* sigma 协议，以大写希腊字母 Sigma（Σ）的形状命名。*'
- en: 'The *completeness* of Schnorr’s protocol is the easiest to verify: if *a* satisfies
    *aG* = *A*, you’ll have'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '*Schnorr 协议* 的 **完整性** 最容易验证：如果 *a* 满足 *aG* = *A*，你将得到'
- en: '![](../images/pg325-1.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg325-1.jpg)'
- en: which is the prover’s validation condition.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这是证明者的验证条件。
- en: To see that the protocol ensures *soundness*—that the prover must know *a*—imagine
    that the prover uses the same *r* twice in two runs of the protocol. The verifier
    thus gets two responses, *s*[1] = *r* + *c*[1]*a* and *s*[2] = *r* + *c*[2]*a*,
    for the two distinct challengers *c*[1] and *c*[2]. Now they can compute
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明协议的*健全性*——即证明者必须知道 *a*——假设证明者在协议的两次运行中使用相同的 *r*。验证者将得到两个回应，*s*[1] = *r*
    + *c*[1]*a* 和 *s*[2] = *r* + *c*[2]*a*，分别对应于两个不同的挑战者 *c*[1] 和 *c*[2]。现在他们可以计算
- en: '![](../images/pg326-1.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg326-1.jpg)'
- en: and divide the result by (*c*[1] – *c*[2]) to obtain *a*. Since the check that
    *sG* equals *R* + *cA* ensures that you had *s* = *r* + *ca*, it follows that
    the prover must know *a* when executing this protocol correctly. This kind of
    logical reasoning is called a *knowledge extractor*, and it’s the main technique
    to show that a ZKP is sound.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将结果除以 (*c*[1] - *c*[2]) 来得到 *a*。由于检查 *sG* 是否等于 *R* + *cA* 能确保 *s* = *r* +
    *ca*，因此可以推导出证明者在正确执行此协议时必须知道 *a*。这种逻辑推理被称为*知识提取器*，它是证明 ZKP（零知识证明）健全性的主要技术。
- en: The protocol can also be proved to be zero-knowledge, using a technique called
    a *simulator*, an algorithm that creates messages (or a *transcript of communication*)
    that are indistinguishable from those in a real execution of a zero-knowledge
    proof. However, unlike a real prover, the simulator doesn’t necessarily know the
    secret (or witness) being proven. Despite this, the messages it generates still
    appear valid and convincing to the verifier in the context of the proof system.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 该协议也可以通过一种叫做*模拟器*的技术来证明其为零知识的。模拟器是一种算法，它生成的消息（或*通信记录*）与真实的零知识证明执行结果无法区分。然而，与真实的证明者不同，模拟器不一定知道正在证明的秘密（或见证）。尽管如此，它生成的消息在证明系统的上下文中依然看起来有效且具有说服力。
- en: In Schnorr’s protocol, the simulator works backward and first chooses a random
    response, *s*, to show that a real *s* will be “as random” as a purely random
    one. Then it picks a random challenge *c* and computes the original commitment
    as *R* = *sG* – *cA*. The proof that the protocol is zero-knowledge then demonstrates
    that these three values are indistinguishable from those of a real execution of
    a protocol yet don’t require the knowledge of the secret *a*. (Note that in Schnorr’s
    case, you must assume that the verifier follows the protocol and picks a random
    *c*.)
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Schnorr 协议中，模拟器从后向前工作，首先选择一个随机回应 *s*，以证明一个真实的 *s* 将会和纯随机的 *s* “一样随机”。然后它挑选一个随机的挑战
    *c*，并计算原始的承诺 *R* = *sG* - *cA*。随后，协议的零知识证明展示了这三个值与协议的真实执行结果无法区分，但不需要知道秘密 *a*。（注意，在
    Schnorr 的情况下，你必须假设验证者遵循协议并选择一个随机的 *c*。）
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Noninteractive Proofs</samp>
  id: totrans-332
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">非交互式证明</samp>
- en: 'Schnorr’s protocol is *interactive*: the prover sends a first message, the
    verifier responds with a challenge, and the prover sends them a response—the parties
    interact over three rounds of messages. But what if the verifier can’t send messages
    and just wants to receive a single message that convinces them? How can one create
    such *noninteractive* proofs from an interactive protocol?'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: Schnorr 协议是*交互式*的：证明者发送第一个消息，验证者回应一个挑战，证明者再发送回应——双方在三个回合的消息交换中互动。那么，如果验证者无法发送消息，只想接收一个能够说服他们的单一消息，该如何创建这种*非交互式*证明呢？
- en: 'Let’s take another look at the Schnorr protocol, wherein the verifier sends
    a random challenge *c*, a value that must be unpredictable to the prover. If the
    prover knows *c* before sending *R*, they can cheat, as follows: given *c*, choose
    some arbitrary value for *s*, and compute *R* = *sG* – *cA*; then send this *R*
    to the verifier, and send *s* as a response to *c*. Verification succeeds, yet
    the prover didn’t need to use the secret value *a*.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一遍 Schnorr 协议，其中验证者发送一个随机挑战 *c*，这个值对证明者来说必须是不可预测的。如果证明者在发送 *R* 之前知道 *c*，他们就可以作弊，如下所示：给定
    *c*，选择任意一个 *s* 值，然后计算 *R* = *sG* - *cA*；接着将这个 *R* 发送给验证者，并将 *s* 作为对 *c* 的回应发送。验证成功，但证明者并没有使用秘密值
    *a*。
- en: How do you make *c* unpredictable to the prover without interacting with a verifier?
    The trick is to derive *c* from *R* using a hash function, which prevents the
    prover from finding a pair (*R*, *c*) that satisfies *sG* = *R* + *cA* due to
    the pseudorandom behavior of hash functions.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如何在不与验证者交互的情况下使*c*对证明者不可预测？技巧是通过哈希函数从*R*派生出*c*，这阻止了证明者找到满足 *sG* = *R* + *cA*
    的一对(*R*, *c*)，因为哈希函数的伪随机行为。
- en: 'To generate a *noninteractive zero-knowledge (NIZK)* proof of knowledge of
    the secret *a* using Schnorr’s protocol, a prover proceeds as follows:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Schnorr协议生成一个*非交互式零知识（NIZK）*知识证明，证明者按以下步骤进行：
- en: '1.  *Commitment*: The prover picks a random number *r* and computes *R* = *rG*.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 1. *承诺*：证明者选择一个随机数 *r* 并计算 *R* = *rG*。
- en: '2.  *Challenge*: The prover computes *c* = **H**(*G* || *R* || *A*); you must
    include the values *G* and *A* to bind the *c* generation to the generator parameter
    *G* and to the public key *A* of the prover.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 2. *挑战*：证明者计算 *c* = **H**(*G* || *R* || *A*)；你必须包括值 *G* 和 *A*，以将 *c* 的生成绑定到生成器参数
    *G* 和证明者的公钥 *A*。
- en: '3.  *Response*: The prover computes *s* = *r* + *ca* and generates the proof
    as an encoding of *R* and *s*.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 3. *响应*：证明者计算 *s* = *r* + *ca* 并生成证明，作为 *R* 和 *s* 的编码。
- en: To verify a proof (*R*, *s*) received from the prover with public key *A*, a
    verifier recomputes the challenge *c* = **H**(*G* || *R* || *A*) and checks the
    equality if *sG* = *R* + *cA*.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证从证明者那里收到的证明(*R*, *s*)，并使用公钥*A*，验证者重新计算挑战*c* = **H**(*G* || *R* || *A*)，并检查是否满足
    *sG* = *R* + *cA*。
- en: The trick in hash function protocol data to replace verifier-generated challenges
    was formalized by the *Fiat–Shamir transform*, a general technique to turn an
    interactive protocol into a noninteractive one. For this transform to be applicable,
    a verifier’s random challenges must be independent of the prover’s message and
    be public (nonsecret) values.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数协议数据中的技巧，替代了验证者生成的挑战，它由*Fiat–Shamir变换*正式化，这是一种将交互式协议转化为非交互式协议的通用技术。为了使该变换适用，验证者的随机挑战必须与证明者的消息独立，并且是公开的（非保密）值。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">zkSNARKs</samp>
  id: totrans-342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">zkSNARKs</samp>
- en: 'Let’s talk about the kind of zero-knowledge proof that’s seen wide adoption
    in blockchain applications due to its power and efficiency. For example, zkSNARKs
    are the cornerstone of the Zcash confidential transaction platform: in Zcash,
    zkSNARKs prove that a certain amount has been deducted from an account and credited
    to another account, without revealing the amount of the accounts and without leading
    to a prohibitively large amount of computation or storage.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一种因其强大和高效性而在区块链应用中得到广泛应用的零知识证明。例如，zkSNARK是Zcash机密交易平台的基石：在Zcash中，zkSNARK证明某个金额已从一个账户扣除并已存入另一个账户，而不透露账户金额，也不导致计算或存储量过大。
- en: 'A *zkSNARK* is a type of noninteractive proof of knowledge that offers the
    zero-knowledge (*zk*) property, where *SNARK* stands for the following:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '*zkSNARK*是一种非交互式知识证明，它提供了零知识(*zk*)特性，其中*SNARK*代表以下含义：'
- en: '**Succinct **The proof is very small compared to the size of the statement
    and the secret. It may be similar in size to the statement size’s logarithm, or
    even of *constant size*—always of the same size regardless of the statement’s
    size.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '**简洁** 证明相较于声明和秘密的大小非常小。它的大小可能与声明大小的对数相似，甚至是*常量大小*——无论声明的大小如何，证明的大小始终相同。'
- en: '**Noninteractive **A SNARK is a noninteractive argument of knowledge, typically
    using the Fiat–Shamir transform to turn an interactive protocol into a noninteractive
    one. It doesn’t need the verifier to send messages to the prover.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '**非交互式** A SNARK是一个非交互式知识论证，通常使用Fiat–Shamir变换将交互式协议转化为非交互式协议。它不需要验证者向证明者发送消息。'
- en: '**Argument **The *argument* of knowledge is a computationally secure proof
    that is conditionally secure. In other words, it wouldn’t be secure against an
    attacker with infinite computing power, which is generally a tolerable limitation.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '**论证** 知识的*论证*是一种计算上安全的证明，但其安全性是有条件的。换句话说，它不会抵抗拥有无限计算能力的攻击者，这通常是可以接受的限制。'
- en: '**Of knowledge **A SNARK offers completeness and soundness, as an argument
    of knowledge.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '**知识** A SNARK提供了完整性和健壮性，作为一种知识论证。'
- en: In addition, proving and verifying a zkSNARK must be computationally efficient.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，证明和验证zkSNARK必须在计算上高效。
- en: Generating such a succinct proof when you want to prove the knowledge of a solution
    to a problem whose description doesn’t even fit in the proof size sounds counterintuitive.
    For example, what about statements like “I know a solution to the equation *f*(*x*)
    = 0,” when the equation *f*(*x*) can be of arbitrary size? From a theoretical
    perspective, short proofs make sense because the only information a proof must
    convey is the *knowledge* of some solution and generally the *correctness* of
    some statement, as opposed to the actual solution and secrets; the proof must
    be zero-knowledge and reveal only that information to the verifier.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想证明一个问题的解的知识，而这个问题的描述甚至无法适应证明大小时，生成这样一个简洁的证明听起来似乎违反直觉。例如，像“我知道方程 *f*(*x*)
    = 0 的解”这样的陈述，如何处理，当方程 *f*(*x*) 可能是任意大小时？从理论角度看，简短的证明是有意义的，因为证明必须传达的信息仅仅是*解的知识*，以及通常是某个陈述的*正确性*，而不是实际的解和秘密；证明必须是零知识的，并且仅向验证者揭示这些信息。
- en: In 2016, cryptographer Jens Groth published the article “On the Size of Pairing-Based
    Non-interactive Arguments” (*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2016<wbr>/260](https://eprint.iacr.org/2016/260)*),
    which describes an exceptionally efficient zkSNARK. The proof consisted of only
    three group elements and could be verified by computing three pairing operations
    (the same type of pairing as with BLS signatures). The Zcash protocol adopted
    this breakthrough result, which laid the foundation for several other zkSNARKs.
    Groth’s zkSNARK is usually just called *Groth16*.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 2016年，密码学家Jens Groth发布了文章《On the Size of Pairing-Based Non-interactive Arguments》
    (*[https://eprint.iacr.org/2016/260](https://eprint.iacr.org/2016/260)*)，该文描述了一种极为高效的zkSNARK。该证明只包含三个群元素，并且可以通过计算三个配对操作来验证（与BLS签名使用的配对类型相同）。Zcash协议采用了这一突破性结果，为其他几种zkSNARK奠定了基础。Groth的zkSNARK通常被称为*Groth16*。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">From Statements to
    Proofs</samp>
  id: totrans-352
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">从陈述到证明</samp>
- en: zkSNARKs are some of the most complex cryptographic constructions, with one
    of their most complex and costly steps being *arithmetization*, an operation that
    converts the statement to prove into a fixed number of polynomial equations, which
    are generally of the form
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: zkSNARKs是一些最复杂的密码学构造，其中最复杂和最昂贵的步骤之一是*算术化*，这是一种将待证明的陈述转换为固定数量的多项式方程的操作，这些方程通常的形式是：
- en: '![](../images/pg328-1.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg328-1.jpg)'
- en: for a polynomial of degree *n*, where the coefficients *a*i are elements of
    some finite ring or finite field structure. The proving algorithm then processes
    the polynomials to create the zkSNARK proof.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个*n*次多项式，其中系数*a*i是某些有限环或有限域结构的元素。然后，证明算法处理这些多项式来创建zkSNARK证明。
- en: 'Arithmetization follows a general workflow:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 算术化遵循一个通用的工作流程：
- en: 1.  Describe the statement to prove using formal notations, such as a computer
    program, equations, or logical formulas.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  使用正式符号描述待证明的陈述，如计算机程序、方程或逻辑公式。
- en: 2.  Transform the formal expression from step 1 into a *circuit*, which defines
    an output from input values by applying a sequence of *gates* to the input, similar
    to logical gates in a Boolean or electronic circuit, except that the gates may
    be algebraic operations such as addition and multiplication.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  将步骤1中的正式表达式转化为一个*电路*，该电路通过对输入应用一系列*门*来定义输出值，类似于布尔或电子电路中的逻辑门，除了这些门可能是加法和乘法等代数运算。
- en: 3.  Turn the circuit into a structured list of *constraints*, according to the
    zkSNARK proof system’s constraint system. Such constraints are lists of conditions
    that the input must fulfill to satisfy the statement to prove.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  根据zkSNARK证明系统的约束系统，将电路转化为一个结构化的*约束*列表。这些约束是输入必须满足的条件列表，以证明所要证明的陈述。
- en: 'The statement to prove may be as trivial as “I know integer *x* and *y* satisfying
    the equation *x*³ + *y*² + *xy* + 55 = 0 mod 57.” This completes step 1 by having
    a formal equation expressing the problem. To complete step 2, you may break down
    the equation as a sequence of simple operations involving two operands (Groth16
    requires this). This works as follows, where you write the intermediate values
    *v*[0], *v*[1], . . . , *v*[6]:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 要证明的陈述可能是如此简单，如“我知道整数*x*和*y*，它们满足方程 *x*³ + *y*² + *xy* + 55 = 0 mod 57。”通过得到一个正式的方程来表达问题，完成步骤1。要完成步骤2，你可以将该方程分解为一系列涉及两个操作数的简单操作（Groth16要求这样做）。具体如下，你需要写出中间值
    *v*[0]、*v*[1]、...、*v*[6]：
- en: Set *v*[0] = *x* × *x*.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 *v*[0] = *x* × *x*。
- en: Set *v*[1] = *x* × *v*[0]; thus *v*[1] = *x*³.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 *v*[1] = *x* × *v*[0]；因此 *v*[1] = *x*³。
- en: Set *v*[2] = *y* × *y*.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 *v*[2] = *y* × *y*。
- en: Set *v*[3] = *x* × *y*.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 *v*[3] = *x* × *y*。
- en: Set *v*[4] = *v*[1] *+ v*[2].
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 *v*[4] = *v*[1] + *v*[2]。
- en: Set *v*[5] = *v*[4] *+ v*[3].
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 *v*[5] = *v*[4] + *v*[3]。
- en: Set *v*[6] = *v*[5] + 55; thus *v*[6] = *x*³ + *y*² + *xy* + 55.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 *v*[6] = *v*[5] + 55；因此 *v*[6] = *x*³ + *y*² + *xy* + 55。
- en: Such a translation of a long equation into a series of small ones is called
    *flattening*.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个长方程转化为一系列小方程的过程称为*展平*。
- en: The prover then converts these operations—the circuit—into a set of mathematical
    structures that serve to construct the polynomials processed by the prover. The
    long polynomials are finally “compressed” into a proof using randomness, specifically
    the concept of *probabilistically checkable proof (PCP)*, which is a major discovery
    from the field of complexity theory. This convinces a verifier that many constraints
    are satisfied with only a few actual constraint checks, while preserving the zero-knowledge
    property.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，证明者将这些操作——电路——转换为一组数学结构，用于构建由证明者处理的多项式。这些长多项式最终通过使用随机性，特别是*概率可验证证明（PCP）*的概念，进行“压缩”以形成证明，这是复杂性理论领域的一个重大发现。这使得验证者能够通过少量的实际约束检查，确信许多约束条件已被满足，同时保持零知识特性。
- en: 'To learn more about the intricacies of arithmetization, research the two main
    approaches used by zkSNARKs: rank-1 constraint systems (R1CS) and algebraic intermediate
    representations (AIR).'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解算术化的复杂性，研究 zkSNARKs 使用的两种主要方法：等级-1 约束系统（R1CS）和代数中间表示（AIR）。
- en: 'Finally, note that we distinguish *nonuniversal* and *universal* zkSNARK proof
    systems: in the former, the prover works for a specific, predefined statement.
    In particular, the setup phase of the proof system creates parameters suitable
    only to a given statement. However, universal proof systems such as Marlin and
    Plonk take as input a statement and create a proof for it. They’re more flexible
    but also more complex to construct and have higher computation overhead.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，注意我们区分*非通用*和*通用* zkSNARK 证明系统：在前者中，证明者仅适用于特定的预定义声明。特别地，证明系统的设置阶段会创建仅适用于给定声明的参数。然而，像
    Marlin 和 Plonk 这样的通用证明系统则接受声明并为其生成证明。它们更灵活，但构建起来更为复杂，并且计算开销更高。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">How Things Can Go
    Wrong</samp>
  id: totrans-372
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">事情如何出错</samp>
- en: zkSNARKs can suffer from the same classes of problems as in the context of threshold
    signatures, from an insecure protocol to implementation flaws. Security issues
    can arise at different stages of the workflow, from the statement definition to
    the arithmetization step and the proof computation. The security notion impacted
    may be completeness, soundness, or zero-knowledge. But most of the time, the greatest
    risk concerns soundness, or the possibility of an attacker to cheat and fool a
    verifier—both because of the potential impact on the application and the subtlety
    of soundness bugs, whereas a leak of “knowledge” is less likely, especially if
    the proof must remain a valid one accepted by a verifier.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: zkSNARKs 可能会遇到与阈值签名上下文中相同的问题类别，从不安全的协议到实现缺陷。安全问题可能出现在工作流程的不同阶段，从声明定义到算术化步骤和证明计算。受影响的安全性概念可能是完备性、健壮性或零知识。但大多数情况下，最大风险涉及健壮性，或者攻击者可能欺骗并愚弄验证者——因为对应用的潜在影响以及健壮性缺陷的微妙性，而“知识”泄露的可能性较小，特别是当证明必须保持验证者接受的有效证明时。
- en: In the forthcoming examples, we’ll focus on Schnorr’s protocol. The problems
    are relatively simple, but more complex proof systems can have much subtler issues.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，我们将重点介绍 Schnorr 的协议。这些问题相对简单，但更复杂的证明系统可能会有更微妙的问题。
- en: Recall that Schnorr’s noninteractive protocol proves the knowledge of *a* to
    a verifier that knows *A* = *aG* by sending a verifier *s* = *r* + *ca* and *R*
    = *rG* for a random *r* and *c* = **H**(*G* || *R* || *A*). The verifier then
    checks the equality *sG* = *R* + *cA* after recomputing *c*. In the interactive
    version, the verifier chooses *c* randomly.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，Schnorr 的非交互式协议通过发送验证者 *s* = *r* + *ca* 和 *R* = *rG* 来证明知识 *a*，其中 *A* =
    *aG*，并且 *c* = **H**(*G* || *R* || *A*)。然后验证者通过重新计算 *c* 来检查等式 *sG* = *R* + *cA*。在交互式版本中，验证者随机选择
    *c*。
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Insufficient Fiat–Shamir
    Hashing</samp>'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">不充分的 Fiat–Shamir 哈希</samp>'
- en: Imagine that instead of *c* = **H**(*G* || *R* || *A*), a noninteractive Schnorr
    proof did *c* = **H**(*G* || *A*), making the challenge *c* independent of the
    nonce *R*. The attacker then picks an arbitrary value for *s* and computes *R*
    = *sG* – *cA*. The resulting proof consisting of *s* and *R* is valid, yet the
    attacker didn’t need to know *a*, thereby breaking the protocol’s soundness.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果非交互式Schnorr证明中，*c* = **H**(*G* || *A*)，使得挑战值*c*与随机数*R*无关，攻击者可以选择任意的*s*值，并计算出*R*
    = *sG* – *cA*。这样得到的证明，由*s*和*R*组成，是有效的，但攻击者并不需要知道*a*，从而破坏了协议的安全性。
- en: 'Likewise, if *c* = **H**(*G* || *R*), omitting the public key *A* from the
    data hashed to define the challenge *c*, an attack is possible: the attacker can
    now choose arbitrary *R* and *s* values and compute the point *B* = (1/*c*) ×
    (*sG* – *R*), which satisfies *sG* = *R* + *cB*. This gives the attacker a proof
    of knowledge of the discrete logarithm of *B*—namely, *b* such that *B* = *bG*—whereas
    they don’t know it.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果*c* = **H**(*G* || *R*)，并且在定义挑战值*c*时省略了公钥*A*，则可能会发生攻击：攻击者可以选择任意的*R*和*s*值，并计算出点*B*
    = (1/*c*) × (*sG* – *R*)，满足*sG* = *R* + *cB*。这使攻击者得到了*B*的离散对数证明——即*b*，使得*B* =
    *bG*——然而他们并不知道*b*。
- en: These attacks illustrate the importance of including all necessary values in
    the hash function input when using the Fiat–Shamir transform to make a protocol
    noninteractive.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这些攻击展示了在使用Fiat–Shamir变换将协议非交互化时，将所有必要的值包含在哈希函数输入中的重要性。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Replay Attacks</samp>
  id: totrans-380
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">重放攻击</samp>
- en: A replay is a trivial but potentially devastating attack. If an attacker learns
    the value of some noninteractive proof of knowledge, they can send it to another
    party and say they created it, claiming the credit for the knowledge proven.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 重放攻击是一种简单但可能造成严重后果的攻击。如果攻击者获知某个非交互式知识证明的值，他们可以将其发送给另一方并声称是自己创建的，从而窃取证明的信用。
- en: You may avoid this by binding the proof to the identity of the prover, including
    their public key in the data hashed. To prevent replay by the same party over
    time, you may bind the proof to a session identifier or timestamp by including
    such values in the data processed by the Fiat–Shamir hashes.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将证明绑定到证明者的身份，包含他们的公钥在哈希数据中来避免这种攻击。为了防止同一方随着时间的推移进行重放攻击，你可以通过将证明绑定到会话标识符或时间戳来避免这种情况，方法是将这些值包含在Fiat–Shamir哈希处理的数据中。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Randomness Reuse</samp>
  id: totrans-383
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">随机性重用</samp>
- en: Consider the interactive Schnorr protocol, where the verifier picks a random
    *c*. If the prover has a flawed pseudorandom generator and reuses the same challenge
    *r* twice, then an attacker observing the exchanged values can recover the secret
    *a* by using the two proofs *s*[1] = *r* + *c*[1]*a* and *s*[2] = *r* + *c*[2]*a*
    for two distinct challengers, *c*[1] and *c*[2], and computing *a* = (*s*[1] –
    *s*[2]) / (*c*[1] – *c*[2]).
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 以交互式Schnorr协议为例，验证者选择一个随机的*c*。如果证明者拥有一个有缺陷的伪随机生成器，并且两次重用了相同的挑战值*r*，那么观察到交换值的攻击者可以通过使用两个不同挑战值*c*[1]和*c*[2]的两个证明*s*[1]
    = *r* + *c*[1]*a*和*s*[2] = *r* + *c*[2]*a*来恢复秘密*a*，并计算出*a* = (*s*[1] – *s*[2])
    / (*c*[1] – *c*[2])。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Really Serious Crypto</samp>
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">真正严肃的加密学</samp>
- en: With this final chapter, we’ve reviewed some of the most captivating topics
    in cryptography at the time of writing, from both theoretical and practical viewpoints.
    We’ve touched only the surface, though, particularly in the realm of zero-knowledge
    proof systems, an active research and engineering space with extensive applications
    beyond blockchain technology. But cool cryptography isn’t the panacea of blockchains.
    From multiparty computation protocols such as private set intersection (PSI) to
    homomorphic encryption used for private evaluation of AI models, new applications
    and use cases call for better, faster cryptographic functionalities.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了加密学领域中一些最引人入胜的话题，从理论和实践的角度进行探讨。尽管如此，我们仅仅触及了表面，特别是在零知识证明系统领域，这个领域是一个活跃的研究和工程领域，具有广泛的应用，超出了区块链技术的范畴。然而，酷炫的加密学并不是区块链的万能良方。从多方计算协议，如私密集合交集（PSI）到同态加密技术，应用于人工智能模型的私密评估，新的应用场景和用例要求更好、更快的加密功能。
- en: We’re witnessing a golden age in cryptography, with an unprecedented convergence
    of theoretical principles and practical applications. This synergy is providing
    almost magical solutions to some of the most daunting security and privacy problems.
    Nonetheless, significant challenges need to be addressed, particularly in the
    legal and regulatory spheres. It’s imperative that technologists and policymakers
    collaborate closely to navigate these challenges and that both attempt to understand
    each other’s perspectives. It is my hope that this book, and particularly this
    last chapter, contributes to demystifying cryptography and making it more accessible
    and less enigmatic for all its readers.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正见证着密码学的黄金时代，理论原理与实际应用前所未有地融合。这种协同效应为一些最具挑战性的安全和隐私问题提供了几乎魔法般的解决方案。尽管如此，仍然有许多重大挑战需要解决，尤其是在法律和监管领域。技术人员和政策制定者必须密切合作，共同应对这些挑战，并且双方都要努力理解对方的观点。希望这本书，特别是最后一章，能够帮助解开密码学的神秘面纱，使其对所有读者更易理解，更加亲民。
