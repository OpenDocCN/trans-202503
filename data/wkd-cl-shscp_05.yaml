- en: '**4**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**4**'
- en: '**TWEAKING UNIX**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**调整Unix**'
- en: '![image](../images/common4.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common4.jpg)'
- en: An outsider might imagine Unix as a nice, uniform command line experience across
    many different systems, helped by their compliance with the POSIX standards. But
    anyone who’s ever used more than one Unix system knows how much they can vary
    within these broad parameters. You’d be hard-pressed to find a Unix or Linux box
    that doesn’t have `ls` as a standard command, for example, but does your version
    support the `--color` flag? Does your version of the Bourne shell support variable
    slicing (like `${var:0:2}`)?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 外行可能会把Unix想象成在许多不同系统上都有一个良好、统一的命令行体验，这得益于它们遵循POSIX标准。但任何曾使用过不止一个Unix系统的人都知道它们在这些广泛参数内部有多么不同。例如，你很难找到一个Unix或Linux系统，它没有`ls`作为标准命令，但你的版本是否支持`--color`标志？你的Bourne
    shell版本是否支持变量切片（如`${var:0:2}`）？
- en: Perhaps one of the most valuable uses of shell scripts is tweaking your particular
    flavor of Unix to make it more like other systems. Although most modern GNU utilities
    run just fine on non-Linux Unixes (for example, you can replace clunky old `tar`
    with the newer GNU `tar`), often the system updates involved in tweaking Unix
    don’t need to be so drastic, and it’s possible to avoid the potential problems
    inherent in adding new binaries to a supported system. Instead, shell scripts
    can be used to map popular flags to their local equivalents, to use core Unix
    capabilities to create a smarter version of an existing command, or even to address
    the longtime lack of certain functionality.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 或许Shell脚本最有价值的用途之一是调整你特定版本的Unix系统，使其更像其他系统。尽管大多数现代GNU实用工具在非Linux Unix上都能正常运行（例如，你可以用更新的GNU
    `tar`替换古老的`tar`），但通常在调整Unix系统时不需要如此激进的系统更新，避免向支持的系统添加新二进制文件带来的潜在问题。相反，Shell脚本可以用来将流行的标志映射到其本地等效项，利用核心Unix功能创建现有命令的智能版本，甚至解决某些功能长期缺失的问题。
- en: '**#27 Displaying a File with Line Numbers**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#27 显示带行号的文件**'
- en: 'There are several ways to add line numbers to a displayed file, many of which
    are quite short. For example, here’s one solution using `awk`:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 添加行号到显示文件有几种方法，其中许多方法都非常简短。例如，这里是一个使用`awk`的解决方案：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: On some Unix implementations, the `cat` command has an `-n` flag, and on others,
    the `more` (or `less`, or `pg`) pager has a flag for specifying that each line
    of output should be numbered. But on some Unix flavors, none of these methods
    will work, in which case the simple script in [Listing 4-1](ch04.xhtml#ch4ex1)
    can do the job.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些Unix实现中，`cat`命令有一个`-n`标志，而在其他系统上，`more`（或`less`、`pg`）分页器有一个指定每行输出应编号的标志。但在某些Unix版本中，这些方法都行不通，这时可以使用[列表
    4-1](ch04.xhtml#ch4ex1)中的简单脚本。
- en: '***The Code***'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 4-1: The* `*numberlines*` *script*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-1：* `*numberlines*` *脚本*'
- en: '***How It Works***'
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: 'There’s a trick to the main loop in this program: it looks like a regular `while`
    loop, but the important part is actually `done < $filename` ➌. It turns out that
    every major block construct acts as its own virtual subshell, so this file redirection
    is not only valid but also an easy way to have a loop that iterates line by line
    with the content of `$filename`. Couple that with the `read` statement at ➊—an
    inner loop that loads each line, iteration by iteration, into the `line` variable—and
    it’s then easy to output the line with its line number as a preface and increment
    the `linecount` variable ➋.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的主循环有一个技巧：它看起来像一个普通的`while`循环，但实际上重要的部分是`done < $filename` ➌。事实证明，每个主要的块结构都作为自己的虚拟子shell，因此这种文件重定向不仅有效，而且是一种轻松的方法，可以让循环逐行迭代`$filename`的内容。再结合➊处的`read`语句——一个内部循环，逐次将每行加载到`line`变量中——输出带有行号的行和增加`linecount`变量
    ➋ 就变得很容易了。
- en: '***Running the Script***'
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: You can feed as many filenames as you want into this script. You can’t feed
    it input via a pipe, though that wouldn’t be too hard to fix by invoking a `cat
    -` sequence if no starting parameters are given.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将任意数量的文件名输入到这个脚本中。但你不能通过管道输入，不过如果没有提供起始参数，通过调用`cat -`序列来修复这个问题也不是很难。
- en: '***The Results***'
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: '[Listing 4-2](ch04.xhtml#ch4ex2) shows a file displayed with line numbers using
    the `numberlines` script.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4-2](ch04.xhtml#ch4ex2)展示了使用`numberlines`脚本对《爱丽丝梦游仙境》摘录进行行号标记的文件。'
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 4-2: Testing the* `*numberlines*` *script on an excerpt from* Alice
    in Wonderland'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-2：* 在《爱丽丝梦游仙境》摘录上测试* `*numberlines*` *脚本*'
- en: '***Hacking the Script***'
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***黑客脚本***'
- en: 'Once you have a file with numbered lines, you can reverse the order of all
    the lines in the file, like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了一个带有行号的文件，你可以像这样将文件中的所有行的顺序反转：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This does the trick on systems supporting the `-n` flag to `cat`, for example.
    Where might this be useful? One obvious situation is when displaying a log file
    in newest-to-oldest order.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这在支持 `cat` 的 `-n` 标志的系统中有效。例如，这种方法可能在哪些地方有用呢？一个明显的场景是按从新到旧的顺序显示日志文件。
- en: '**#28 Wrapping Only Long Lines**'
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#28 只换行长行**'
- en: 'One limitation of the `fmt` command and its shell script equivalent, [Script
    #14](ch02.xhtml#ch02lev1sec01) on [page 53](ch02.xhtml#page_53), is that they
    wrap and fill every line they encounter, whether or not it makes sense to do so.
    This can mess up email (wrapping your `.signature` is not good, for example) and
    any input file format where line breaks matter.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmt` 命令及其对应的 shell 脚本版本的一个限制是，它们会换行并填充每一行，不管这样做是否合理。例如，这可能会搞乱电子邮件（例如，换行你的
    `.signature` 是不好的）以及任何需要保留行分隔符的输入文件格式。'
- en: 'What if you have a document in which you want to wrap just the long lines but
    leave everything else intact? With the default set of commands available to a
    Unix user, there’s only one way to accomplish this: explicitly step through each
    line in an editor, feeding the long ones to `fmt` individually. (You could accomplish
    this in `vi` by moving the cursor onto the line in question and using `!$fmt`.)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个文档，你只想将长行换行，而保持其他部分不变呢？对于 Unix 用户来说，默认的命令集只有一种方法可以完成这项任务：在编辑器中逐行处理每一行，将长行单独传给
    `fmt`。（你可以在 `vi` 中通过将光标移到目标行并使用 `!$fmt` 来完成此操作。）
- en: The script in [Listing 4-3](ch04.xhtml#ch4ex3) automates that task, making use
    of the shell `${#*varname*}` construct, which returns the length of the contents
    of the data stored in the variable `*varname*`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-3](ch04.xhtml#ch4ex3) 中的脚本自动化了这个任务，利用了 shell 的 `${#*varname*}` 结构，它返回存储在变量
    `*varname*` 中的数据的长度。'
- en: '***The Code***'
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 4-3: The* `*toolong*` *script*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-3：* `*toolong*` *脚本*'
- en: '***How It Works***'
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: Notice that the file is fed to the `while` loop with a simple `< $1` associated
    with the end of the loop ➋ and that each line can then be analyzed by reading
    it with `read input` ➊, which assigns each line of the file to the `input` variable,
    line by line.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，文件通过简单的 `< $1` 被传递给 `while` 循环，并与循环的结束位置 ➋ 关联，然后每一行通过 `read input` ➊ 被读取，从而一行一行地将文件内容分配给
    `input` 变量。
- en: 'If your shell doesn’t have the `${#*var*}` notation, you can emulate its behavior
    with the super useful “word count” command `wc`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 shell 不支持 `${#*var*}` 这种表示法，你可以通过超实用的“字数统计”命令 `wc` 来模拟它的行为：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'However, `wc` has an annoying habit of prefacing its output with spaces to
    get values to align nicely in the output listing. To sidestep that pesky problem,
    a slight modification is necessary to let only digits through the final pipe step,
    as shown here:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`wc` 有个恼人的习惯，它会在输出前加上空格以使数值对齐。为了避免这个麻烦，需要稍微修改，确保只通过最终的管道步骤传递数字，如下所示：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***Running the Script***'
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: This script accepts exactly one filename as input, as [Listing 4-4](ch04.xhtml#ch4ex4)
    shows.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本接受正好一个文件名作为输入，正如 [清单 4-4](ch04.xhtml#ch4ex4) 所示。
- en: '***The Results***'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 4-4: Testing the* `*toolong*` *script*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-4：测试* `*toolong*` *脚本*'
- en: Notice that unlike a standard invocation of `fmt`, `toolong` has retained line
    breaks where possible, so the word *sneeze*, which is on a line by itself in the
    input file, is also on a line by itself in the output.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与标准的 `fmt` 调用不同，`toolong` 在可能的情况下保留了换行，因此在输入文件中单独一行的单词 *sneeze* 在输出中也会单独占一行。
- en: '**#29 Displaying a File with Additional Information**'
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#29 显示包含附加信息的文件**'
- en: 'Many of the most common Unix and Linux commands were originally designed for
    slow, barely interactive output environments (we did talk about Unix being an
    ancient OS, right?) and therefore offer minimal output and interactivity. An example
    is `cat`: when used to view a short file, it doesn’t give much helpful output.
    It would be nice to have more information about the file, though, so let’s get
    it! [Listing 4-5](ch04.xhtml#ch4ex5) details the `showfile` command, an alternative
    to `cat`.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 许多最常用的 Unix 和 Linux 命令最初是为缓慢、几乎没有交互的输出环境设计的（我们谈过 Unix 是一个古老的操作系统，对吧？），因此它们提供的输出和交互性非常有限。例如，`cat`：当用来查看一个短文件时，它不会提供太多有用的信息。不过，假如我们想知道文件的更多信息，那就来获取它吧！[清单
    4-5](ch04.xhtml#ch4ex5) 详细介绍了 `showfile` 命令，这是 `cat` 的一种替代方法。
- en: '***The Code***'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 4-5: The* `*showfile*` *script*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-5：* `*showfile*` *脚本*'
- en: '***How It Works***'
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: 'To simultaneously read the input line by line and add head and foot information,
    this script uses a handy shell trick: near the end of the script, it redirects
    the input to the `while` loop with the snippet `done < $input` ➊. Perhaps the
    most complex element in this script, however, is the invocation of `sed` for lines
    longer than the specified length:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了同时逐行读取输入并添加头部和尾部信息，这个脚本使用了一个方便的 shell 技巧：在脚本的末尾，它通过 `done < $input` ➊ 将输入重定向到
    `while` 循环中。然而，可能这个脚本中最复杂的元素是对于超过指定长度的行，调用 `sed` 进行处理：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Lines greater than the maximum allowable length are wrapped with `fmt` (or
    its shell script replacement, [Script #14](ch02.xhtml#ch02lev1sec01) on [page
    53](ch02.xhtml#page_53)). To visually denote which lines are continuations and
    which are retained intact from the original file, the first output line of the
    excessively long line has the usual two-space indent, but subsequent lines are
    prefixed with a plus sign and a single space instead. Finally, piping the output
    into `${PAGER:more}` displays the file with the pagination program set with the
    system variable `$PAGER` or, if that’s not set, the `more` program ➋.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '超过最大允许长度的行会通过 `fmt`（或其 shell 脚本替代品，[脚本 #14](ch02.xhtml#ch02lev1sec01) 在[第 53
    页](ch02.xhtml#page_53)）进行换行处理。为了直观地标示哪些行是续行，哪些行是从原文件中保留的，过长行的第一行输出会有通常的两个空格缩进，但后续行则以加号和一个空格作为前缀。最后，将输出通过管道传送到
    `${PAGER:more}` 会使用系统变量 `$PAGER` 设置的分页程序显示文件，或者如果未设置该变量，则使用 `more` 程序 ➋。'
- en: '***Running the Script***'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: You can run `showfile` by specifying one or more filenames when the program
    is invoked, as [Listing 4-6](ch04.xhtml#ch4ex6) shows.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在调用程序时指定一个或多个文件名来运行 `showfile`，正如[清单 4-6](ch04.xhtml#ch4ex6)所示。
- en: '***The Results***'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 4-6: Testing the* `*showfile*` *script*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-6：测试* `*showfile*` *脚本*'
- en: '**#30 Emulating GNU-Style Flags with quota**'
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#30 模拟 GNU 样式标志与 quota**'
- en: The inconsistency across the command flags of various Unix and Linux systems
    is a perpetual problem that causes lots of grief for users who switch between
    any of the major releases, particularly between a commercial Unix system (SunOS/Solaris,
    HP-UX, and so on) and an open source Linux system. One command that demonstrates
    this problem is `quota`, which supports full-word flags on some Unix systems but
    accepts only one-letter flags on others.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 各种 Unix 和 Linux 系统中命令标志的不一致性是一个长期存在的问题，这给那些在主要版本之间切换的用户带来了很多麻烦，尤其是从商业 Unix 系统（如
    SunOS/Solaris、HP-UX 等）切换到开源 Linux 系统时。一个展示此问题的命令是 `quota`，它在某些 Unix 系统上支持全名标志，但在其他系统上仅接受单字母标志。
- en: A succinct shell script (shown in [Listing 4-7](ch04.xhtml#ch4ex7)) solves the
    problem by mapping any full-word flags specified to the equivalent single-letter
    alternatives.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简洁的 shell 脚本（如[清单 4-7](ch04.xhtml#ch4ex7)所示）通过将任何指定的全名标志映射到相应的单字母替代标志来解决问题。
- en: '***The Code***'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 4-7: The* `*newquota*` *script*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-7：* `*newquota*` *脚本*'
- en: '***How It Works***'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: This script really boils down to a `while` statement that steps through every
    argument specified to the script, identifying any of the matching full-word flags
    and adding the associated one-letter flag to the `flags` variable. When done,
    it simply invokes the original quota program ➊ and adds the user-specified flags
    as needed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本实际上归结为一个 `while` 语句，它遍历传递给脚本的每个参数，识别任何匹配的全名标志，并将相关的单字母标志添加到 `flags` 变量中。完成后，它会简单地调用原始的
    quota 程序 ➊，并根据需要添加用户指定的标志。
- en: '***Running the Script***'
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: 'There are a couple of ways to integrate a wrapper of this nature into your
    system. The most obvious is to rename this script `quota`, then place this script
    in a local directory (say, */usr/local/bin*), and ensure that users have a default
    `PATH` that looks in this directory before looking in the standard Linux binary
    distro directories (*/bin* and */usr/bin*). Another way is to add system-wide
    aliases so that a user entering `quota` actually invokes the `newquota` script.
    (Some Linux distros ship with utilities for managing system aliases, such as Debian’s
    `alternatives` system.) This last strategy could be risky, however, if users call
    `quota` with the new flags in their own shell scripts: if those scripts don’t
    use the user’s interactive login shell, they might not see the specified alias
    and will end up calling the base `quota` command rather than `newquota`.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以将这种包装程序集成到你的系统中。最明显的方法是将此脚本重命名为`quota`，然后将该脚本放置在本地目录（例如，*/usr/local/bin*）中，并确保用户的默认`PATH`在查找标准Linux二进制目录（*/bin*和*/usr/bin*）之前会先查找这个目录。另一种方法是添加系统范围的别名，使得输入`quota`的用户实际上调用的是`newquota`脚本。（一些Linux发行版附带了管理系统别名的工具，如Debian的`alternatives`系统。）然而，最后一种策略可能存在风险，因为如果用户在自己的脚本中使用带有新标志的`quota`，如果这些脚本没有使用用户的交互式登录shell，它们可能看不到指定的别名，最终会调用基础的`quota`命令，而不是`newquota`。
- en: '***The Results***'
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: '[Listing 4-8](ch04.xhtml#ch4ex8) details running `newquota` with the `--verbose`
    and `--quiet` arguments.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-8](ch04.xhtml#ch4ex8)详细说明了如何使用`--verbose`和`--quiet`参数运行`newquota`。'
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 4-8: Testing the* `*newquota*` *script*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-8：测试* `*newquota*` *脚本*'
- en: The `--quiet` mode emits output only if the user is over quota. You can see
    that this is working correctly from the last result, where we’re not over quota.
    Phew!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`--quiet`模式只在用户超出配额时才会输出信息。从最后的结果中可以看到，这正正常工作，因为我们没有超出配额。呼——！'
- en: '**#31 Making sftp Look More Like ftp**'
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#31 让sftp更像ftp**'
- en: The secure version of the File Transfer Protocol `ftp` program is included as
    part of `ssh`, the Secure Shell package, but its interface can be a bit confusing
    for users who are making the switch from the crusty old `ftp` client. The basic
    problem is that `ftp` is invoked as `ftp remotehost` and it then prompts for account
    and password information. By contrast, `sftp` wants to know the account and remote
    host on the command line and won’t work properly (or as expected) if only the
    host is specified.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 文件传输协议`ftp`的安全版本包含在`ssh`（安全Shell包）中，但对于从老旧的`ftp`客户端切换过来的用户来说，它的界面可能有些让人困惑。基本问题在于，`ftp`是以`ftp
    remotehost`的形式调用的，然后它会提示输入帐户和密码信息。相比之下，`sftp`希望在命令行中指定帐户和远程主机，如果只指定主机，它就无法正常工作（或者无法按预期工作）。
- en: To address this, the simple wrapper script detailed in [Listing 4-9](ch04.xhtml#ch4ex9)
    allows users to invoke `mysftp` exactly as they would have invoked the `ftp` program
    and be prompted for the necessary fields.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，[清单 4-9](ch04.xhtml#ch4ex9)中详细介绍的简单包装脚本允许用户像调用`ftp`程序一样调用`mysftp`，并提示输入必要的字段。
- en: '***The Code***'
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 4-9: The* `*mysftp*` *script, a friendlier version of* `*sftp*`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-9：* `*mysftp*` *脚本，`*sftp*`的更友好版本*'
- en: '***How It Works***'
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: 'There’s a trick in this script worth mentioning. It’s actually something we’ve
    done in previous scripts, though we haven’t highlighted it for you before: the
    last line is an `exec` call ➊. What this does is *replace* the currently running
    shell with the application specified. Because you know there’s nothing left to
    do after calling the `sftp` command, this method of ending our script is much
    more resource efficient than having the shell hanging around waiting for `sftp`
    to finish using a separate subshell, which is what would happen if we just invoked
    `sftp` instead.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本中有一个值得一提的技巧。实际上，这是我们在之前的脚本中做过的，只不过之前没有特别强调：最后一行是一个`exec`调用➊。它的作用是*替换*当前运行的shell，执行指定的应用程序。因为你知道，在调用`sftp`命令后，已经没有其他操作需要做了，这种结束脚本的方法比让shell等待`sftp`完成并使用一个单独的子shell要更高效——如果我们直接调用`sftp`的话，情况就会是这样。
- en: '***Running the Script***'
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: As with the `ftp` client, if users omit the remote host, the script continues
    by prompting for a remote host. If the script is invoked as `mysftp remotehost`,
    the `remotehost` provided is used instead.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 和`ftp`客户端一样，如果用户省略了远程主机，脚本会继续并提示输入远程主机。如果脚本以`mysftp remotehost`的形式调用，则使用提供的`remotehost`。
- en: '***The Results***'
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: Let’s see what happens when you invoke this script without any arguments versus
    invoking `sftp` without any arguments. [Listing 4-10](ch04.xhtml#ch4ex10) shows
    running `sftp`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当你在没有任何参数的情况下调用这个脚本时，和在没有任何参数的情况下调用`sftp`时会发生什么。[清单4-10](ch04.xhtml#ch4ex10)展示了运行`sftp`的情况。
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 4-10: Running the* `*sftp*` *utility with no arguments yields very
    cryptic help output.*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单4-10：运行`*sftp*`工具时不带参数会产生非常难以理解的帮助输出。*'
- en: That’s useful but confusing. By contrast, with the `mysftp` script you can proceed
    to make an actual connection, as [Listing 4-11](ch04.xhtml#ch4ex11) shows.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有用，但也很混淆。相比之下，通过`mysftp`脚本，你可以继续进行实际连接，正如[清单4-11](ch04.xhtml#ch4ex11)所示。
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 4-11: Running the* `*mysftp*` *script with no arguments is much clearer.*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单4-11：运行`*mysftp*`脚本时不带参数更为清晰。*'
- en: Invoke the script as if it were an `ftp` session by supplying the remote host,
    and it’ll prompt for the remote account name (detailed in [Listing 4-12](ch04.xhtml#ch4ex12))
    and then invisibly invoke `sftp`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 像调用`ftp`会话一样调用脚本，提供远程主机，它将提示输入远程帐户名（在[清单4-12](ch04.xhtml#ch4ex12)中详细说明），然后悄悄地调用`sftp`。
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 4-12: Running the* `*mysftp*` *script with a single argument: the
    host to connect to*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单4-12：运行`*mysftp*`脚本时提供单个参数：要连接的主机*'
- en: '***Hacking the Script***'
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: 'One thing to always think about when you have a script like this is whether
    it can be the basis of an automated backup or sync tool, and `mysftp` is a perfect
    candidate. So a great hack would be to designate a directory on your system, for
    example, then write a wrapper that would create a ZIP archive of key files, and
    use `mysftp` to copy them up to a server or cloud storage system. In fact, we’ll
    do just that later in the book with [Script #72](ch09.xhtml#ch09lev1sec04) on
    [page 229](ch09.xhtml#page_229).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '当你有这样的脚本时，始终要思考的一件事是，它是否可以作为自动备份或同步工具的基础，而`mysftp`就是一个完美的候选者。所以一个很好的技巧就是在你的系统上指定一个目录，例如，然后写一个包装器来创建关键文件的ZIP归档，并使用`mysftp`将它们复制到服务器或云存储系统。实际上，我们将在本书稍后通过[脚本
    #72](ch09.xhtml#ch09lev1sec04)在[第229页](ch09.xhtml#page_229)来做这个。'
- en: '**#32 Fixing grep**'
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#32 修复grep**'
- en: Some versions of `grep` offer a remarkable range of capabilities, including
    the particularly useful ability to show the context (a line or two above and below)
    of a matching line in the file. Additionally, some versions of `grep` can highlight
    the region in the line (for simple patterns, at least) that matches the specified
    pattern. You might already have such a version of `grep`. Then again, you might
    not.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一些版本的`grep`提供了丰富的功能，包括特别有用的显示匹配行上下文（上下各一两行）的能力。此外，一些版本的`grep`还可以高亮显示匹配指定模式的行中的区域（至少对于简单模式）。你可能已经拥有这样的版本的`grep`，但也可能没有。
- en: 'Fortunately, both of these features can be emulated with a shell script, so
    you can still use them even if you’re on an older commercial Unix system with
    a relatively primitive `grep` command. To specify the number of lines of context
    both above and below the line matching the pattern that you specified, use `-c
    *value*`, followed by the pattern to match. This script (shown in [Listing 4-13](ch04.xhtml#ch4ex13))
    also borrows from the ANSI color script, [Script #11](ch01.xhtml#ch01lev1sec12)
    on [page 40](ch01.xhtml#page_40), to do region highlighting.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '幸运的是，这两个功能都可以通过Shell脚本来模拟，因此即使你使用的是旧版商业Unix系统，且`grep`命令相对原始，仍然可以使用它们。要指定匹配指定模式的行上下文的行数，可以使用`-c
    *value*`，后面跟上要匹配的模式。这个脚本（见[清单4-13](ch04.xhtml#ch4ex13)）还借用了ANSI颜色脚本，[脚本 #11](ch01.xhtml#ch01lev1sec12)在[第40页](ch01.xhtml#page_40)中，来进行区域高亮。'
- en: '***The Code***'
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 4-13: The* `*cgrep*` *script*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单4-13：`*cgrep*`脚本*'
- en: '***How It Works***'
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***它是如何工作的***'
- en: This script uses `grep -n` to get the line numbers of all matching lines in
    the file ➋ and then, using the specified number of lines of context to include,
    identifies a starting ➌ and ending ➍ line for displaying each match. These are
    written out to the temporary `sed` script defined at ➊, which executes a word
    substitution command that wraps the specified pattern in bold-on and bold-off
    ANSI sequences. That’s 90 percent of the script, in a nutshell.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本使用`grep -n`来获取文件中所有匹配行的行号➋，然后，使用指定的上下文行数，确定显示每个匹配项的起始➌和结束➍行。这些行会写入在➊定义的临时`sed`脚本中，该脚本执行一个单词替换命令，将指定的模式包装在加粗开关ANSI序列中。这就是脚本的90%，简而言之。
- en: The other thing worth mentioning in this script is the useful `trap` command
    ➎, which lets you tie events into the shell’s script execution system itself.
    The first argument is the command or sequence of commands you want invoked, and
    all subsequent arguments are the specific signals (events). In this case, we’re
    telling the shell that when the script exits, invoke `rm` to remove the two temp
    files.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本中值得一提的另一个点是有用的 `trap` 命令 ➎，它让你将事件与 shell 脚本执行系统本身关联起来。第一个参数是你希望调用的命令或命令序列，所有后续参数是具体的信号（事件）。在这个案例中，我们告诉
    shell 当脚本退出时，调用 `rm` 删除两个临时文件。
- en: What’s particularly nice about working with `trap` is that it works regardless
    of where you exit the script, not just at the very bottom. In subsequent scripts,
    you’ll see that `trap` can be tied to a wide variety of signals, not just `SIGEXIT`
    (or `EXIT`, or the numeric equivalent of `SIGEXIT`, which is `0`). In fact, you
    can have different `trap` commands associated with different signals, so you might
    output a “cleaned-up temp files” message if someone sends a `SIGQUIT` (CTRL-C)
    to a script, while that wouldn’t be displayed on a regular (`SIGEXIT`) event.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `trap` 工作的特别好的一点是，无论你从脚本的哪里退出，它都会起作用，而不仅仅是在脚本的最底部。在后续的脚本中，你将看到 `trap` 可以绑定到各种信号，而不仅仅是
    `SIGEXIT`（或 `EXIT`，或 `SIGEXIT` 的数值等价物，`0`）。事实上，你可以将不同的 `trap` 命令与不同的信号关联，因此，如果有人向脚本发送
    `SIGQUIT`（CTRL-C），你可能会输出“已清理临时文件”的消息，而在常规的 (`SIGEXIT`) 事件中则不会显示该消息。
- en: '***Running the Script***'
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: This script works either with an input stream, in which case it saves the input
    to a temp file and then processes the temp file as if its name had been specified
    on the command line, or with a list of one or more files on the command line.
    [Listing 4-14](ch04.xhtml#ch4ex14) shows passing a single file via the command
    line.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本可以处理输入流，在这种情况下它会将输入保存到临时文件中，然后像处理命令行指定的文件一样处理该临时文件，或者处理命令行中的一个或多个文件列表。[清单
    4-14](ch04.xhtml#ch4ex14) 显示了通过命令行传递单个文件的示例。
- en: '***The Results***'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 4-14: Testing the* `*cgrep*` *script*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-14：测试* `*cgrep*` *脚本*'
- en: '***Hacking the Script***'
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: A useful refinement to this script would return line numbers along with the
    matched lines.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个脚本的一个有用改进是返回匹配行的行号。
- en: '**#33 Working with Compressed Files**'
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#33 处理压缩文件**'
- en: 'Throughout the years of Unix development, few programs have been reconsidered
    and redeveloped more times than `compress`. On most Linux systems, three significantly
    different compression programs are available: `compress`, `gzip`, and `bzip2`.
    Each uses a different suffix (*.z*, *.gz*, and *.bz2*, respectively), and the
    degree of compression can vary among the three programs, depending on the layout
    of data within a file.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来的 Unix 开发中，很少有程序像`compress`那样被反复考虑和重新开发。在大多数 Linux 系统上，有三种明显不同的压缩程序可供使用：`compress`、`gzip`
    和 `bzip2`。每种程序使用不同的后缀（分别是 *.z*、*.gz* 和 *.bz2*），并且压缩程度可能会根据文件中数据的布局而有所不同。
- en: 'Regardless of the level of compression, and regardless of which compression
    programs you have installed, working with compressed files on many Unix systems
    requires decompressing them by hand, accomplishing the desired tasks, and recompressing
    them when finished. Tedious, and thus a perfect job for a shell script! The script
    detailed in [Listing 4-15](ch04.xhtml#ch4ex15) acts as a convenient compression/decompression
    wrapper for three functions you’ll often find yourself wanting to use on compressed
    files: `cat`, `more`, and `grep`.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 无论压缩级别如何，也无论你安装了哪个压缩程序，在许多 Unix 系统上，处理压缩文件都需要手动解压，完成所需任务后再重新压缩。这是一个繁琐的过程，因此非常适合用
    shell 脚本来处理！[清单 4-15](ch04.xhtml#ch4ex15) 中详细的脚本作为一个方便的压缩/解压包装器，适用于你经常需要在压缩文件上使用的三个功能：`cat`、`more`
    和 `grep`。
- en: '***The Code***'
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 4-15: The* `*zcat*`*/*`*zmore*`*/*`*zgrep*` *script*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-15：* `*zcat*`*/*`*zmore*`*/*`*zgrep*` *脚本*'
- en: '***How It Works***'
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***它是如何工作的***'
- en: 'For any given suffix, three steps are necessary: decompress the file, rename
    the filename to remove the suffix, and add it to the list of files to recompress
    at the end of the script. By keeping three separate lists, one for each compression
    program, this script also lets you easily `grep` across files compressed using
    different compression utilities.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何给定的后缀，都需要三个步骤：解压文件、重命名文件以去除后缀，并将其添加到脚本末尾重新压缩的文件列表中。通过保持三个单独的列表，每个压缩程序一个，这个脚本还让你可以轻松地在使用不同压缩工具压缩的文件之间进行
    `grep` 搜索。
- en: The most important trick is the use of the `eval` directive when recom-pressing
    the files ➊➋➌. This is necessary to ensure that filenames with spaces are treated
    properly. When the `Zlist`, `gzlist,` and `bzlist` variables are instantiated,
    each argument is surrounded by quotes, so a typical value might be `""sample.c"
    "test.pl" "penny.jar""`. Because the list has nested quotes, invoking a command
    like `cat $Zlist` results in `cat` complaining that file `"sample.c"` wasn’t found.
    To force the shell to act as if the command were typed at a command line (where
    the quotes are stripped once they have been utilized for `arg` parsing), use `eval`,
    and all will work as desired.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的技巧是在重新压缩文件时使用`eval`指令 ➊➋➌。这对于确保带空格的文件名被正确处理是必要的。当`Zlist`、`gzlist`和`bzlist`变量被实例化时，每个参数都会被引号括起来，因此一个典型的值可能是`""sample.c"
    "test.pl" "penny.jar""`。由于列表中有嵌套的引号，调用类似`cat $Zlist`的命令会导致`cat`抱怨找不到文件`"sample.c"`。为了强制
    shell 执行命令，仿佛命令是在命令行中输入的（引号在`arg`解析后会被去除），使用`eval`，这样一切就能按预期工作。
- en: '***Running the Script***'
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: 'To work properly, this script should have three names. How do you do that in
    Linux? Simple: links. You can use either symbolic links, which are special files
    that store the names of link destinations, or hard links, which are actually assigned
    the same inode as the linked file. We prefer symbolic links. These can easily
    be created (here the script is already called `zcat`), as [Listing 4-16](ch04.xhtml#ch4ex16)
    shows.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确运行，该脚本应该有三个名称。如何在Linux中实现这一点？简单：链接。您可以使用符号链接，它是存储链接目标名称的特殊文件，或者使用硬链接，硬链接实际上会被分配与被链接文件相同的inode。我们更倾向于使用符号链接。这些链接可以很容易地创建（这里脚本已经被命名为`zcat`），如[清单
    4-16](ch04.xhtml#ch4ex16)所示。
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 4-16: Symbolically linking the* `*zcat*` *script to the* `*zmore*`
    *and* `*zgrep*` *commands*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-16：符号链接* `*zcat*` *脚本到* `*zmore*` *和* `*zgrep*` *命令*'
- en: Once that’s done, you have three new commands that have the same actual (shared)
    contents, and each accepts a list of files to process as needed, decompressing
    and then recompressing them when done.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，您将有三个新的命令，它们具有相同的实际（共享的）内容，每个命令都接受一个文件列表，根据需要处理文件，完成后解压缩并重新压缩它们。
- en: '***The Results***'
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: 'The ubiquitous `compress` utility quickly shrinks down *ragged.txt* and gives
    it a *.z* suffix:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 无处不在的`compress`工具可以快速压缩*ragged.txt*并为其添加*.z*后缀：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With *ragged.txt* in its compressed state, we can view the file with `zcat`,
    as [Listing 4-17](ch04.xhtml#ch4ex17) details.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在*ragged.txt*的压缩状态下，我们可以使用`zcat`查看文件，具体细节见[清单 4-17](ch04.xhtml#ch4ex17)。
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 4-17: Using* `*zcat*` *to print the compressed text file*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-17：使用* `*zcat*` *打印压缩的文本文件*'
- en: And then search for *teacup* again.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后再次搜索*teacup*。
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: All the while, the file starts and ends in its original compressed state, shown
    in [Listing 4-18](ch04.xhtml#ch4ex18).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，文件保持在其原始的压缩状态，起始和结束状态都如[清单 4-18](ch04.xhtml#ch4ex18)所示。
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 4-18: The results of* `*ls*`*, showing only that the compressed file
    exists*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-18：`*ls*`*的结果，只显示压缩文件存在*'
- en: '***Hacking the Script***'
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: Probably the biggest weakness of this script is that if it is canceled in midstream,
    the file isn’t guaranteed to recompress. A nice addition would be to fix this
    with a smart use of the `trap` capability and a recompress function that does
    error checking.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本可能最大的问题是，如果在中途取消，文件不能保证会重新压缩。一个不错的改进是使用`trap`功能智能地解决这个问题，并增加一个带有错误检查的重新压缩函数。
- en: '**#34 Ensuring Maximally Compressed Files**'
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#34 确保最大压缩的文件**'
- en: 'As highlighted in [Script #33](ch04.xhtml#ch04lev1sec07) on [page 109](ch04.xhtml#page_109),
    most Linux implementations include more than one compression method, but the onus
    is on the user to figure out which one does the best job of compressing a given
    file. As a result, users typically learn how to work with just one compression
    program without realizing that they could attain better results with a different
    one. Even more confusing is the fact that some files compress better with one
    algorithm than with another, and there’s no way to know which is better without
    experimentation.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '正如[脚本 #33](ch04.xhtml#ch04lev1sec07)在[第109页](ch04.xhtml#page_109)中强调的那样，大多数Linux实现都包括多种压缩方法，但用户需要自己弄清楚哪种方法对给定文件压缩效果最好。因此，用户通常只学会使用一种压缩程序，而没有意识到他们可以通过使用其他程序获得更好的效果。更让人困惑的是，某些文件使用一种算法压缩效果更好，而使用另一种则较差，而没有实验就无法知道哪种更好。'
- en: The logical solution is to have a script that compresses files using each of
    the tools and then selects the smallest resultant file as the best. That’s exactly
    what `bestcompress` does, shown in [Listing 4-19](ch04.xhtml#ch4ex19)!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑上的解决方案是使用一个脚本来利用每个工具压缩文件，然后选择最小的文件作为最佳结果。这正是`bestcompress`所做的，见[清单 4-19](ch04.xhtml#ch4ex19)！
- en: '***The Code***'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 4-19: The* `*bestcompress*` *script*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-19：* `*bestcompress*` *脚本*'
- en: '***How It Works***'
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***原理***'
- en: The most interesting line in this script is at ➋. This line has `ls` output
    the size of each file (the original and the three compressed files, in a known
    order), chops out just the file sizes with `awk`, sorts these numerically, and
    ends up with the line number of the smallest resultant file. If the compressed
    versions are all bigger than the original file, the result is `1`, and an appropriate
    message is printed out ➌. Otherwise, `smallest` will indicate which of `compress`,
    `gzip`, or `bzip2` did the best job. Then it’s just a matter of moving the appropriate
    file into the current directory and removing the original file.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本中最有趣的一行是 ➋。这一行让 `ls` 输出每个文件的大小（原始文件以及三个压缩文件，按已知顺序），然后用 `awk` 剪切出文件大小，按数字排序，最终得出最小文件的行号。如果所有压缩版本的文件都比原文件大，结果将是
    `1`，并打印出相应的信息 ➌。否则，`smallest` 将指示是 `compress`、`gzip` 还是 `bzip2` 做得最好。然后，脚本只需将相应的文件移到当前目录，并删除原文件。
- en: The three compression calls starting at ➊ are also worth pointing out. These
    calls are done in parallel by using the trailing `&` to drop each of them into
    its own subshell, followed by the call to `wait`, which stops the script until
    all the calls are completed. On a uniprocessor, this might not offer much performance
    benefit, but with multiple processors, it should spread the task out and potentially
    complete quite a bit faster.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从 ➊ 开始的三个压缩调用也值得注意。这些调用是并行进行的，通过使用尾随的 `&` 将每个调用放入自己的子 shell 中，接着调用 `wait`，直到所有调用完成，脚本才会停止。在单处理器的情况下，这可能不会带来太大的性能提升，但在多处理器的环境下，它应该可以分摊任务，并可能更快完成。
- en: '***Running the Script***'
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: This script should be invoked with a list of filenames to compress. If some
    of them are already compressed and you want to try compressing them further, use
    the `-a` flag; otherwise they’ll be skipped.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本应该使用文件名列表进行调用，以压缩这些文件。如果其中某些文件已经被压缩，并且你想尝试进一步压缩它们，请使用`-a`标志；否则，这些文件将被跳过。
- en: '***The Results***'
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: The best way to demonstrate this script is with a file that needs to be compressed,
    as [Listing 4-20](ch04.xhtml#ch4ex20) shows.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 演示该脚本的最佳方式是使用一个需要压缩的文件，正如[清单 4-20](ch04.xhtml#ch4ex20)所示。
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 4-20: Showing the* `*ls*` *output of a copy of* Alice in Wonderland*.
    Note the file size of 154872 bytes.*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-20：显示* `*ls*` *命令输出的《爱丽丝梦游仙境》副本。请注意，文件大小为 154872 字节。*'
- en: The script hides the process of compressing the file with each of the three
    compression tools and instead simply displays the results, shown in [Listing 4-21](ch04.xhtml#ch4ex21).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本隐藏了使用三种压缩工具压缩文件的过程，而是简单地显示结果，结果见[清单 4-21](ch04.xhtml#ch4ex21)。
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 4-21: Running the* `*bestcompress*` *script on* alice.txt'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-21：运行* `*bestcompress*` *脚本来压缩* alice.txt'
- en: '[Listing 4-22](ch04.xhtml#ch4ex22) demonstrates that the file is now quite
    a bit smaller.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-22](ch04.xhtml#ch4ex22)演示了文件现在变得相当小。'
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 4-22: Demonstrating the much-reduced file size of the compressed file
    (66287 bytes) compared to [Listing 4-20](ch04.xhtml#ch4ex20)*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-22：演示压缩文件（66287 字节）相比于[清单 4-20](ch04.xhtml#ch4ex20)的文件大小大幅减小。*'
