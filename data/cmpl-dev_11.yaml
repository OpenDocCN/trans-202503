- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp> <samp class="SANS_Dogma_OT_Bold_B_11">CONTAINERIZATION
    WITH DOCKER</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp> <samp class="SANS_Dogma_OT_Bold_B_11">使用
    Docker 进行容器化</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/Drop-image.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Drop-image.jpg)'
- en: Professional full-stack developers frequently work with Docker and, more broadly,
    containers. *Docker,* an open source containerization platform, solves three common
    problems.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 专业的全栈开发者经常使用 Docker，广义上也使用容器。*Docker* 作为一个开源容器化平台，解决了三个常见问题。
- en: First, it lets us run a particular version of some software, such as Node.js,
    for each of our projects. Second, it decouples the development environment from
    our local machine and creates a reproducible way to run the application. Third,
    unlike traditional virtual machines, Docker containers run on a shared host. Therefore,
    they are smaller in size and consume less memory than classic virtual machines,
    which emulate a complete system and are often hardware specific. As a result,
    container-based applications are lightweight and easy to scale. These advantages
    have made Docker the most appreciated development platform in recent years.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它使我们能够为每个项目运行某个特定版本的软件，如 Node.js。其次，它将开发环境与本地机器解耦，并创建一种可复现的方式来运行应用程序。第三，与传统的虚拟机不同，Docker
    容器运行在共享主机上。因此，它们的体积更小，消耗的内存比传统虚拟机要少，后者需要模拟完整的系统，且通常依赖特定硬件。因此，基于容器的应用程序轻量且易于扩展。这些优势使得
    Docker 成为近年来最受欢迎的开发平台。
- en: This chapter covers the fundamentals of Docker. We first walk through the steps
    required to containerize our Next.js application by creating a Docker container
    running the latest Node.js version and serving the application from inside the
    container. Then we explore the concept of a microservice architecture and create
    two microservices using Docker.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍 Docker 的基础知识。我们首先演示如何通过创建一个运行最新 Node.js 版本并在容器内提供应用程序的 Docker 容器，将我们的
    Next.js 应用容器化。接着，我们将探讨微服务架构的概念，并使用 Docker 创建两个微服务。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Containerization Architecture</samp>
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">容器化架构</samp>
- en: In their daily lives, developers must regularly switch between applications
    that require different versions of the same library. For example, a JavaScript-focused
    developer might need a different Node.js or TypeScript version for each of their
    projects. Of course, they could switch the installed Node.js version on their
    local machine with tools such as nvm whenever they need to work on a different
    project. But instead of resorting to crude hacks, they could choose a more elegant
    solution.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常工作中，开发者必须频繁地在需要不同版本同一库的应用程序之间切换。例如，专注于 JavaScript 的开发者可能需要为每个项目使用不同版本的 Node.js
    或 TypeScript。当然，他们可以使用像 nvm 这样的工具，在本地机器上切换已安装的 Node.js 版本，每当需要切换到不同的项目时。但与其采取这种粗糙的方式，他们可以选择一个更优雅的解决方案。
- en: Using Docker, we can separate our application or its services into independent
    containers, each of which provides a service-specific environment. These containers
    run on an operating system of our choosing (often Debian, Ubuntu, or Alpine),
    with only the dependencies necessary to this particular application. Containers
    are isolated from one another and communicate through defined APIs.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker，我们可以将应用程序或其服务分离到独立的容器中，每个容器都提供特定服务的环境。这些容器运行在我们选择的操作系统上（通常是 Debian、Ubuntu
    或 Alpine），并且只包含此特定应用程序所需的依赖项。容器之间是隔离的，并通过定义的 API 进行通信。
- en: When we use a Docker container during the development process, we facilitate
    the application’s later deployment. After all, the container provides a location-independent
    version of our application that is platform agnostic. Therefore, we already know
    that our application works with the installed dependencies and that no conflicts
    or additional installation steps are necessary. Instead of setting up a remote
    server with the required software and then deploying and testing our application
    afterward, we can simply move our Docker container to the server and spin it up
    there.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在开发过程中使用 Docker 容器时，我们便于应用程序的后续部署。毕竟，容器提供了一个与平台无关的版本，这意味着无论在哪个环境中，应用程序都能正常运行。因此，我们已经知道我们的应用程序能够与已安装的依赖项配合使用，不需要解决冲突或执行额外的安装步骤。与其设置一个远程服务器，安装所需的软件，然后再部署和测试我们的应用程序，我们可以直接将
    Docker 容器移到服务器上，并在那里启动它。
- en: In situations when we need to move to a different server, scale our application,
    add additional database servers, or distribute instances across several locations,
    Docker lets us deploy our application by using the same straightforward process.
    Instead of managing different hosts and configurations, we can effectively build
    a platform-agnostic application and run the same containers everywhere.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要迁移到不同服务器、扩展应用程序、添加额外数据库服务器或将实例分布到多个位置时，Docker 使我们能够通过相同的简便流程部署应用程序。我们无需管理不同的主机和配置，就能有效地构建一个与平台无关的应用程序，并在任何地方运行相同的容器。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Installing Docker</samp>
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">安装 Docker</samp>
- en: To check whether you already have Docker installed, open the command line and
    run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker -v</samp>. If you see
    a version number higher than 20, you should be able to follow along with the examples
    in this chapter. Otherwise, you’ll need to install the most recent version of
    Docker from Docker Inc. Go to [*https://<wbr>www<wbr>.docker<wbr>.com<wbr>/products<wbr>/docker<wbr>-desktop<wbr>/*](https://www.docker.com/products/docker-desktop/).
    Then choose the Docker desktop installer for your operating system and download
    it. Execute the application and check the Docker version number on the command
    line. It should match the one you downloaded.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查是否已经安装 Docker，请打开命令行并运行 <samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker
    -v</samp>。如果看到的版本号高于 20，则应该能够继续跟随本章中的示例。否则，你需要从 Docker Inc. 安装最新版本的 Docker。请访问
    [*https://<wbr>www<wbr>.docker<wbr>.com<wbr>/products<wbr>/docker<wbr>-desktop<wbr>/*](https://www.docker.com/products/docker-desktop/)。然后选择适合你操作系统的
    Docker 桌面安装程序并下载。执行应用程序，并在命令行中检查 Docker 版本号。它应该与你下载的版本一致。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Creating a Docker Container</samp>
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">创建 Docker 容器</samp>
- en: Docker has several components. The physical or virtual machine on which the
    Docker daemon runs is the *host system*. While you’re developing your application
    locally, the host is your physical machine, and when you deploy your container,
    the host is the server that runs the application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 有几个组件。运行 Docker 守护进程的物理或虚拟机器称为 *主机系统*。当你在本地开发应用程序时，主机是你的物理机器，而当你部署容器时，主机是运行应用程序的服务器。
- en: We use the *Docker daemon service* on the host system to interact with all components
    of the Docker platform. The daemon provides Docker’s functionality through APIs
    and is the actual Docker application installed on our machine. Access the daemon
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker</samp> command
    from the command line. Run <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    --help</samp> to display all possible interactions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在主机系统上使用 *Docker 守护进程服务* 来与 Docker 平台的所有组件进行交互。守护进程通过 API 提供 Docker 的功能，并且是安装在我们机器上的实际
    Docker 应用程序。使用命令行中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">docker</samp>
    命令访问守护进程。运行 <samp class="SANS_TheSansMonoCd_W5Regular_11">docker --help</samp>
    以显示所有可能的交互。
- en: We use Docker *containers* to run our containerized applications. These containers
    are running instances of a particular Docker image, which is the artifact that
    contains the application. Each Docker image relies on a Dockerfile, which defines
    the configuration and the content of the Docker image.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Docker *容器* 来运行容器化的应用程序。这些容器是特定 Docker 镜像的运行实例，镜像是包含应用程序的工件。每个 Docker 镜像都依赖于一个
    Dockerfile，该文件定义了 Docker 镜像的配置和内容。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing the Dockerfile</samp>
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">编写 Dockerfile</samp>
- en: A *Dockerfile* is a text file containing the information we need to set up a
    Docker image. It commonly builds upon some existing base image, such as a bare-bones
    Linux machine on which we’ve installed additional software or a pre-provisioned
    environment. For example, we might use a Linux image with Node.js, MongoDB, and
    all relevant dependencies installed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*Dockerfile* 是一个文本文件，包含我们设置 Docker 镜像所需的信息。它通常基于一些现有的基础镜像，例如一个基础的 Linux 系统，在此基础上我们安装了额外的软件或预配置的环境。例如，我们可能会使用一个包含
    Node.js、MongoDB 和所有相关依赖项的 Linux 镜像。'
- en: Often, we can build upon an official image. For example, [Listing 10-1](chapter10.xhtml#Lis10-1)
    shows the basic Dockerfile we use to containerize our refactored Next.js application.
    Dockerfiles contain keywords followed by commands, and we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">FROM</samp>
    keyword here to select the official Node.js Docker image. Create a file called
    *Dockerfile* in your project’s root directory, next to the *package.json* file,
    and add the code in [Listing 10-1](chapter10.xhtml#Lis10-1) to it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们可以基于官方镜像进行构建。例如，[清单10-1](chapter10.xhtml#Lis10-1)展示了我们用于容器化重构后的Next.js应用程序的基本Dockerfile。Dockerfile包含关键字和后续命令，我们在这里使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">FROM</samp>关键字来选择官方的Node.js Docker镜像。在项目根目录下（与*package.json*文件相邻）创建一个名为*Dockerfile*的文件，并将[清单10-1](chapter10.xhtml#Lis10-1)中的代码添加到其中。
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 10-1: A simple Dockerfile for a typical Node.js-based application'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 清单10-1：用于典型Node.js应用程序的简单Dockerfile
- en: The image we’ve selected contains a preconfigured Node.js system running on
    Debian. The version tag <samp class="SANS_TheSansMonoCd_W5Regular_11">current</samp>
    gives you the most recent Node.js version; alternatively, we could provide a particular
    version number here. Hence, if you need to lock any application to a specific
    Node.js version, this is the line to do so. You could also use the slimmer <samp
    class="SANS_TheSansMonoCd_W5Regular_11">node:current-slim</samp> image, a lightweight
    Debian distribution that contains only the software packages necessary to run
    Node.js. However, we need MongoDB’s in-memory server, so we’ll choose the regular
    image. You can see a list of the available images at [*https://<wbr>hub<wbr>.docker<wbr>.com*](https://hub.docker.com).
    Other images you’ll probably use in your career include those for WordPress, MySQL,
    Redis, Apache, and NGINX.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择的镜像包含一个运行在Debian上的预配置Node.js系统。版本标签<samp class="SANS_TheSansMonoCd_W5Regular_11">current</samp>提供了最新的Node.js版本；或者，我们可以在此处指定特定的版本号。因此，如果需要将应用程序锁定到特定的Node.js版本，这是实现的方法。你还可以使用更轻量级的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">node:current-slim</samp>镜像，它是一个精简的Debian发行版，仅包含运行Node.js所需的软件包。不过，由于我们需要MongoDB的内存服务器，因此我们选择了常规镜像。你可以在[*https://<wbr>hub<wbr>.docker<wbr>.com*](https://hub.docker.com)查看可用的镜像列表。在你的职业生涯中，你可能还会使用其他镜像，如WordPress、MySQL、Redis、Apache和NGINX的镜像。
- en: Finally, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">WORKDIR</samp>
    keyword to set the working directory inside the Docker image to the user’s home
    directory. All future commands will now execute in this directory. We use the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">COPY</samp> keyword to add the *package
    .json* and *package-lock.json* files to the working directory. A Node.js application
    runs on port 3000 by default, so we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">EXPORT</samp>
    keyword to choose port 3000 for TCP connections. This connection will provide
    access to the application from outside the container.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">WORKDIR</samp>关键字将Docker镜像内的工作目录设置为用户的主目录。所有后续命令将会在该目录中执行。我们使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">COPY</samp>关键字将*package .json*和*package-lock.json*文件添加到工作目录中。Node.js应用程序默认运行在3000端口，因此我们使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">EXPORT</samp>关键字选择3000端口用于TCP连接。这个连接将允许从容器外部访问应用程序。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Building the Docker
    Image</samp>
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">构建Docker镜像</samp>
- en: 'To create a Docker image from the Dockerfile, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    image build</samp> command. During the build process, the Docker daemon reads
    the Dockerfile and executes the commands defined there to download and install
    software, copy local files into the image, and configure the environment. Run
    the following next to your Dockerfile to build the image from it:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Dockerfile创建Docker镜像，我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    image build</samp>命令。在构建过程中，Docker守护进程读取Dockerfile并执行其中定义的命令，下载和安装软件，复制本地文件到镜像中，并配置环境。运行以下命令来构建镜像：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">--tag</samp> flag gives the
    image the name <samp class="SANS_TheSansMonoCd_W5Regular_11">nextjs</samp> and
    sets its version to <samp class="SANS_TheSansMonoCd_W5Regular_11">latest</samp>.
    Now we can easily refer to this specific image at a later time. We use a period
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>) at the end of the command
    to set the build context, limiting the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    build</samp> command’s file access to the current directory. In the output, the
    Docker daemon indicates that it successfully built the tagged image.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">--tag</samp> 标志为镜像命名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">nextjs</samp>
    并将其版本设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">latest</samp>。现在我们可以在后续的操作中轻松引用这个特定的镜像。我们在命令末尾使用一个句点
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>) 来设置构建上下文，将 <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    build</samp> 命令的文件访问限制在当前目录。输出中，Docker 守护进程表示它已成功构建了标记的镜像。
- en: 'Now, to verify that we have access to the image, run the following. This command
    lists all locally available Docker images:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了验证我们是否可以访问镜像，运行以下命令。这条命令会列出所有本地可用的 Docker 镜像：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As expected, our newly created image has a random ID (<samp class="SANS_TheSansMonoCd_W5Regular_11">98b28358e19a</samp>),
    is tagged as <samp class="SANS_TheSansMonoCd_W5Regular_11">nextjs</samp>, and
    is available in the <samp class="SANS_TheSansMonoCd_W5Regular_11">latest</samp>
    version. The Docker daemon may also display additional information, such as the
    size and age of the image, which aren’t relevant to us for now.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，我们新创建的镜像有一个随机的 ID (<samp class="SANS_TheSansMonoCd_W5Regular_11">98b28358e19a</samp>)，并被标记为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">nextjs</samp>，且版本为 <samp class="SANS_TheSansMonoCd_W5Regular_11">latest</samp>。Docker
    守护进程可能还会显示额外的信息，比如镜像的大小和创建时间，暂时这些对我们来说并不重要。
- en: 'Docker provides additional commands for managing local and remote images. You
    can view a list of all available commands by running <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    image --help</samp>. For example, to remove an existing image from your local
    machine, use <samp class="SANS_TheSansMonoCd_W5Regular_11">docker image rm</samp>:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 提供了额外的命令来管理本地和远程镜像。你可以通过运行 <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    image --help</samp> 查看所有可用的命令列表。例如，要从本地机器中删除一个现有的镜像，可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    image rm</samp>：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After a while, you’ll find that you’ve collected unused or outdated versions
    of your images, so deleting them to free up space on your machine with <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    image prune</samp> is a good practice.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一段时间后，你会发现自己收集了许多未使用或过时的镜像版本，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    image prune</samp> 删除它们以释放你机器上的空间是一种好习惯。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Serving the Application
    from the Docker Container</samp>
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">从 Docker 容器提供应用服务</samp>
- en: Docker containers are running instances of Docker images. You could use the
    same Docker image to spin up multiple containers, each with a unique name or ID.
    Once the container is running, you can synchronize local files to it. It listens
    on an exposed TCP or UDP port, so you can connect to it and execute commands inside
    it using SSH.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 容器是 Docker 镜像的运行实例。你可以使用相同的 Docker 镜像启动多个容器，每个容器都有唯一的名称或 ID。一旦容器运行，你可以将本地文件同步到容器中。容器会监听一个暴露的
    TCP 或 UDP 端口，你可以通过 SSH 连接到容器并在其中执行命令。
- en: 'Let’s containerize our application. We’ll spin up the Docker container from
    our image, map the local Next.js files to the working directory, publish the exposed
    port, and finally start the Next.js development server. We can do all of this
    using <samp class="SANS_TheSansMonoCd_W5Regular_11">docker container run</samp>:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将应用容器化。我们将从镜像启动 Docker 容器，将本地的 Next.js 文件映射到工作目录，暴露端口，最后启动 Next.js 开发服务器。我们可以通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">docker container run</samp> 完成这一切：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: At first glance, this command might look complicated, but once we take a closer
    look at it, you’ll easily understand what it is doing. We pass it several flags,
    starting with the <samp class="SANS_TheSansMonoCd_W5Regular_11">--name</samp>
    flag, which assigns a unique name to the running container. We’ll use this name
    to identify the container later.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这个命令可能看起来很复杂，但一旦我们仔细看，你就会轻松理解它的作用。我们给它传递了几个标志，第一个是 <samp class="SANS_TheSansMonoCd_W5Regular_11">--name</samp>，它为正在运行的容器分配一个唯一的名称。我们稍后会用这个名称来标识容器。
- en: Then we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">--volume</samp>
    flag to create a Docker volume. *Volumes* are a simple way to share data between
    containers. Docker itself manages them, and they let us synchronize our application
    files to the *home/node/* directory inside the container. We use the format <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">source:destination</samp> to
    define a volume, and depending on your file structure, you might need to adjust
    the absolute path to this folder. In this example, we map */nextjs_refactored/*
    from the user’s home folder into the container.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">--volume</samp> 标志来创建一个
    Docker 卷。*卷*是容器之间共享数据的一种简单方式。Docker 本身管理它们，它们让我们将应用程序文件同步到容器内的 *home/node/* 目录。我们使用
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">source:destination</samp>
    格式来定义卷，并根据你的文件结构，可能需要调整该文件夹的绝对路径。在这个例子中，我们将 */nextjs_refactored/* 从用户的主文件夹映射到容器内。
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">--publish-all</samp> flag
    publishes all exported ports and assigns them to random ports on the host system.
    We use <samp class="SANS_TheSansMonoCd_W5Regular_11">docker container ls</samp>
    later to view the ports for our application. The last two arguments are intuitive:
    <samp class="SANS_TheSansMonoCd_W5Regular_11">nextjs:latest</samp> points to the
    Docker image we want to use for the container, and <samp class="SANS_TheSansMonoCd_W5Regular_11">npm
    run dev</samp> starts the Next.js development server as usual. The console output
    shows that the Node.js app inside the container is running and listening on port
    3000.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">--publish-all</samp> 标志发布所有导出的端口，并将它们分配给主机系统上的随机端口。我们稍后使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">docker container ls</samp> 查看我们应用程序的端口。最后两个参数是直观的：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">nextjs:latest</samp> 指向我们希望用于容器的 Docker
    镜像，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">npm run dev</samp> 启动 Next.js
    开发服务器，像往常一样运行。控制台输出显示容器内部的 Node.js 应用程序正在运行并监听端口 3000。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Locating the Exposed
    Docker Port</samp>
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">定位暴露的 Docker 端口</samp>
- en: Unfortunately, as soon as we try to access our Next.js application on port 3000,
    the browser notifies us that it isn’t accessible; no application is listening
    there. The problem is that we didn’t map the exposed Docker port 3000 to the host’s
    port 3000\. Instead, we used the <samp class="SANS_TheSansMonoCd_W5Regular_11">--publish-all</samp>
    flag and assigned a random port to the exposed Docker port.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，一旦我们尝试通过端口 3000 访问 Next.js 应用程序，浏览器会通知我们该端口不可访问；没有应用程序在该端口监听。问题是我们没有将暴露的
    Docker 端口 3000 映射到主机的端口 3000。相反，我们使用了 <samp class="SANS_TheSansMonoCd_W5Regular_11">--publish-all</samp>
    标志，并将暴露的 Docker 端口分配给了一个随机端口。
- en: 'Let’s run <samp class="SANS_TheSansMonoCd_W5Regular_11">docker container ls</samp>
    to see details about all running Docker containers:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行 <samp class="SANS_TheSansMonoCd_W5Regular_11">docker container ls</samp>
    查看所有运行中 Docker 容器的详细信息：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Search for the name we assigned to our container, *nextjs_container*, and notice
    that port 55000 on the host maps to the Docker port 3000\. Hence, we can access
    our application at *http://localhost:55000*. Open this URL in your browser. You
    should see the Next.js application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索我们为容器指定的名称，*nextjs_container*，并注意主机上的端口 55000 映射到 Docker 端口 3000。因此，我们可以在
    *http://localhost:55000* 访问我们的应用程序。在浏览器中打开此 URL，你应该能看到 Next.js 应用程序。
- en: If you glance at the URL bar, you’ll notice that the port we use to access the
    application is different from the one used in previous chapters because it is
    now running inside the Docker container. Try to access all of the pages and APIs
    we created previously before moving to the next section.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看一下 URL 地址栏，你会注意到我们用来访问应用程序的端口与前几章中使用的不同，因为它现在运行在 Docker 容器内部。尝试访问我们在之前章节中创建的所有页面和
    API，然后再继续下一部分。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Interacting with
    the Container</samp>
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">与容器交互</samp>
- en: 'You can view a list of all Docker commands for interacting with containers
    by running <samp class="SANS_TheSansMonoCd_W5Regular_11">docker container --help</samp>.
    In most contexts, though, you’ll find it sufficient to know just a few of these.
    For example, use <samp class="SANS_TheSansMonoCd_W5Regular_11">exec</samp> to
    execute commands inside an already running Docker container. We could use <samp
    class="SANS_TheSansMonoCd_W5Regular_11">exec</samp> to connect to a shell inside
    the container by passing it the <samp class="SANS_TheSansMonoCd_W5Regular_11">-it</samp>
    flag and the path to the shell, such as */bin/sh*. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-i</samp>
    flag is short for <samp class="SANS_TheSansMonoCd_W5Regular_11">--interactive</samp>,
    whereas <samp class="SANS_TheSansMonoCd_W5Regular_11">-t</samp> runs a pseudoterminal.
    The interactive option lets us interact with the container, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">tty</samp>
    pseudoterminal keeps the Docker container running so that we can actually interact
    with it:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行<samp class="SANS_TheSansMonoCd_W5Regular_11">docker container --help</samp>查看所有与容器交互的
    Docker 命令列表。然而，在大多数情况下，了解其中的一些命令就足够了。例如，使用<samp class="SANS_TheSansMonoCd_W5Regular_11">exec</samp>可以在已经运行的
    Docker 容器内执行命令。我们可以通过传递<samp class="SANS_TheSansMonoCd_W5Regular_11">-it</samp>标志和
    shell 路径（例如*/bin/sh*）来使用<samp class="SANS_TheSansMonoCd_W5Regular_11">exec</samp>连接到容器内部的
    shell。<samp class="SANS_TheSansMonoCd_W5Regular_11">-i</samp>标志是<samp class="SANS_TheSansMonoCd_W5Regular_11">--interactive</samp>的简写，而<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-t</samp>则启动一个伪终端。交互选项让我们能够与容器进行交互，而<samp
    class="SANS_TheSansMonoCd_W5Regular_11">tty</samp>伪终端保持 Docker 容器运行，从而使我们能够与其实际互动：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">kill</samp> command stops
    a running Docker container:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">kill</samp>命令停止正在运行的 Docker 容器：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can select the container by name or by using the container ID shown in the
    list of local running containers.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过名称或使用在本地运行容器列表中显示的容器 ID 来选择容器。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Creating Microservices with Docker Compose</samp>
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">使用 Docker Compose 创建微服务</samp>
- en: Docker provides us with a way to break up an application into small, autonomous
    units, called *microservices*. A microservice-driven architecture splits an application
    into a collection of self-contained services that communicate through well-defined
    APIs. It’s a relatively new architectural concept that gained traction around
    the late 2000s to early 2010s, when Docker and other tools that allowed for easier
    partitioning and orchestration of server resources became available. These tools
    form the technical foundation of a microservice architecture.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 为我们提供了一种将应用程序分解为小而独立的单元——称为*微服务*的方法。微服务驱动的架构将应用程序拆分为一组自包含的服务，这些服务通过定义良好的
    API 进行通信。这是一个相对较新的架构概念，最初在 2000 年代末至 2010 年代初期获得关注，当时 Docker 和其他可以更轻松分割和编排服务器资源的工具开始普及。这些工具构成了微服务架构的技术基础。
- en: Microservices have several advantages. First, each independent service has a
    single purpose, which reduces its complexity. Therefore, it is more testable and
    maintainable. We can also deploy the microservices separately, spin up multiple
    instances of a single microservice to improve its performance, or swap it out
    altogether without affecting the whole application. Contrast these features with
    a traditional monolithic application whose user interface, middleware, and data
    storage exist in one single program built from a single code base. Even if a monolith
    uses a more modular approach, the code base couples them tightly, and you can’t
    swap out the elements easily.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务有几个优点。首先，每个独立的服务只有一个单一的目的，这减少了其复杂性。因此，它更容易进行测试和维护。我们还可以单独部署微服务，启动同一微服务的多个实例来提高其性能，或完全替换它而不影响整个应用程序。与此对比的是传统的单体应用程序，其用户界面、中间件和数据存储都存在于一个由单一代码库构建的单一程序中。即使单体应用程序采用更模块化的方法，代码库也将它们紧密耦合，你无法轻松地替换其中的元素。
- en: Another characteristic feature of microservices is that dedicated teams can
    own just a single service and its code base. This means that they can select the
    appropriate tools, frameworks, and programming languages on a per-service basis.
    On the other hand, you’d typically use a single core language to write a monolithic
    application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的另一个特点是，专门的团队可以只负责单一服务及其代码库。这意味着他们可以根据每个服务选择适当的工具、框架和编程语言。另一方面，你通常会使用一种核心语言来编写单体应用程序。
- en: Now that you know how to create a single container from scratch, we’ll practice
    creating multiple containers; each will serve one part of an application. One
    way to use microservices is to create one service for the frontend and a second
    for the backend. The Food Finder application we’ll create in [Part II](part2.xhtml)
    will use this structure. The main benefit of this approach is that it lets us
    use a preconfigured MongoDB image for the database. For the example in this chapter,
    we’ll create a second service that watches our weather service and reruns its
    test suite as soon as the file changes. To do so, we’ll use the Docker Compose
    interface and define our microservice architecture in a *docker-compose.yml* file.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何从零开始创建一个单一容器，我们将练习创建多个容器；每个容器将服务于应用程序的一个部分。使用微服务的一种方法是为前端创建一个服务，为后端创建另一个服务。我们将在[第二部分](part2.xhtml)中创建的Food
    Finder应用程序将使用这种结构。此方法的主要好处是它允许我们使用预配置的MongoDB镜像作为数据库。对于本章中的示例，我们将创建第二个服务来监视我们的天气服务，并在文件更改时立即重新运行其测试套件。为此，我们将使用Docker
    Compose接口，并在*docker-compose.yml*文件中定义我们的微服务架构。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing the docker-compose.yml
    File</samp>
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">编写docker-compose.yml文件</samp>
- en: We define all services in *docker-compose.yml*, a text file in the YAML format.
    This file also sets the properties, dependencies, and volumes for each service.
    Most properties are similar to the command line flags you specify when creating
    Docker images and containers. Create the file in the root folder of your application
    and add the code from [Listing 10-2](chapter10.xhtml#Lis10-2) to it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*docker-compose.yml*中定义所有服务，这是一个YAML格式的文本文件。该文件还为每个服务设置属性、依赖关系和卷。大多数属性类似于你在创建Docker镜像和容器时指定的命令行标志。创建文件并将[清单10-2](chapter10.xhtml#Lis10-2)中的代码添加到应用程序的根文件夹中。
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 10-2: A basic docker-compose.yml file that defines the application
    and Jest services'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 清单10-2：定义应用程序和Jest服务的基本docker-compose.yml文件
- en: 'Every *docker-compose.yml* file starts by setting the version of the Docker
    Compose specification used. Depending on the version, we can use different properties
    and values. We then define each service as a single property under <samp class="SANS_TheSansMonoCd_W5Regular_11">services</samp>.
    As discussed, we want to have two services: our Next.js application running on
    port 3000 and the Jest service, which watches the *services .test.ts* file we
    created in [Chapter 8](chapter8.xhtml) and reruns the tests as soon as we change
    a file. We limit the watch command to retest only the services. This limits the
    scope of the exercises, but of course, you can rerun all tests if you’d like.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 每个*docker-compose.yml*文件首先通过设置所使用的Docker Compose规范的版本来开始。根据版本的不同，我们可以使用不同的属性和值。然后，我们在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">services</samp>下定义每个服务作为单独的属性。如前所述，我们希望有两个服务：我们的Next.js应用程序运行在3000端口，和Jest服务，它监视我们在[第8章](chapter8.xhtml)中创建的*services
    .test.ts*文件，并在我们更改文件时立即重新运行测试。我们将watch命令限制为仅重新测试services。这限制了练习的范围，但当然，如果你愿意，也可以重新运行所有测试。
- en: Each service follows roughly the same structure. First we define the image from
    which Docker Compose should create each container. This can be an official distribution
    or a locally built one. We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">nextjs</samp>
    image in the <samp class="SANS_TheSansMonoCd_W5Regular_11">latest</samp> version
    for both services. Then, instead of using the <samp class="SANS_TheSansMonoCd_W5Regular_11">--publishAll</samp>
    flag, we map the <samp class="SANS_TheSansMonoCd_W5Regular_11">ports</samp> directly
    from 3000 to 3000\. By doing so, we can connect to the application’s port 3000
    from the host’s port 3000.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务的结构大致相同。首先，我们定义Docker Compose应从哪个镜像创建每个容器。这可以是官方发行版，也可以是本地构建的镜像。我们为两个服务都使用<sup
    class="SANS_TheSansMonoCd_W5Regular_11">nextjs</sup>镜像的<sup class="SANS_TheSansMonoCd_W5Regular_11">latest</sup>版本。然后，我们不使用<sup
    class="SANS_TheSansMonoCd_W5Regular_11">--publishAll</sup>标志，而是直接将<sup class="SANS_TheSansMonoCd_W5Regular_11">ports</sup>从3000映射到3000。这样，我们就可以从主机的3000端口连接到应用程序的3000端口。
- en: With the <samp class="SANS_TheSansMonoCd_W5Regular_11">volumes</samp> property,
    we synchronize the files and paths from the host system into the container. This
    is similar to the mapping we used in the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    run</samp> command, but instead of supplying an absolute path, we can use relative
    paths for the source. Here we map the whole local directory *./* into the container’s
    working directory */home/node*. As before, we can edit the TypeScript files locally,
    and the application inside the container always uses the latest version of the
    files.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">volumes</samp> 属性，我们将主机系统中的文件和路径同步到容器中。这类似于我们在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">docker run</samp> 命令中使用的映射方式，但与提供绝对路径不同，我们可以对源使用相对路径。在这里，我们将整个本地目录
    *./* 映射到容器的工作目录 */home/node*。如前所述，我们可以在本地编辑 TypeScript 文件，容器中的应用程序始终使用文件的最新版本。
- en: Until now, these properties have matched the command line arguments we used
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker run</samp> command.
    Now we add the <samp class="SANS_TheSansMonoCd_W5Regular_11">command</samp> property,
    which specifies the command that each container executes on startup. For the application
    service, we’ll start Next.js with the usual <samp class="SANS_TheSansMonoCd_W5Regular_11">npm
    run dev</samp> command, whereas the Jest service should call Jest directly through
    <samp class="SANS_TheSansMonoCd_W5Regular_11">npx</samp>. Providing the path to
    the test file and the <samp class="SANS_TheSansMonoCd_W5Regular_11">--watchAll</samp>
    flag causes Jest to rerun the tests when the source code changes.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这些属性与我们在 <samp class="SANS_TheSansMonoCd_W5Regular_11">docker run</samp>
    命令中使用的命令行参数相匹配。现在我们添加 <samp class="SANS_TheSansMonoCd_W5Regular_11">command</samp>
    属性，用于指定每个容器在启动时执行的命令。对于应用服务，我们将使用常规的 <samp class="SANS_TheSansMonoCd_W5Regular_11">npm
    run dev</samp> 命令启动 Next.js，而 Jest 服务则应该通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">npx</samp>
    直接调用 Jest。提供测试文件的路径和 <samp class="SANS_TheSansMonoCd_W5Regular_11">--watchAll</samp>
    标志会导致 Jest 在源代码变化时重新运行测试。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running the Containers</samp>
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">运行容器</samp>
- en: 'Start the multi-container app with the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    compose up</samp> command. The output should look similar to what is shown here:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">docker compose up</samp> 命令启动多容器应用。输出应该类似于这里所示：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The Docker daemon spins up all services. As soon as the application is ready,
    we see the status message from the Express.js server and can connect to it on
    the exposed port 3000\. At the same time, the Jest container runs the tests for
    the weather services and reports that all are successful.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 守护进程启动所有服务。一旦应用程序准备就绪，我们会看到来自 Express.js 服务器的状态消息，并且可以通过暴露的端口 3000 连接到它。同时，Jest
    容器运行天气服务的测试并报告所有测试成功。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Rerunning the Tests</samp>
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">重新运行测试</samp>
- en: Now that we’ve started the Docker environment, let’s verify that the command
    to look for changes in the code and rerun tests is working as intended. To do
    so, we need to modify the source code to trigger Jest. Therefore, we open the
    *mongoose/weather/service.ts* file and modify the contents by adding a blank line
    and then saving the file. Jest should rerun the test inside the container, as
    you can see from the output in [Listing 10-3](chapter10.xhtml#Lis10-3).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经启动了 Docker 环境，接下来验证一下用于查找代码变化并重新运行测试的命令是否按预期工作。为此，我们需要修改源代码来触发 Jest。因此，我们打开
    *mongoose/weather/service.ts* 文件，修改内容，添加一个空行，然后保存文件。Jest 应该会重新运行容器内的测试，正如你可以从
    [清单 10-3](chapter10.xhtml#Lis10-3) 的输出中看到的那样。
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 10-3: Rerunning the tests on files changed with <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">jest
    --watchAll</samp>'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10-3：使用 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">jest --watchAll</samp>
    重新运行已更改文件的测试
- en: All tests continue to pass. Connect to *http://localhost:3000* and verify that
    your browser can still render the application.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试仍然通过。连接到 *http://localhost:3000* 并验证你的浏览器是否仍然能够渲染应用程序。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Interacting with
    Docker Compose</samp>
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">与 Docker Compose
    交互</samp>
- en: Docker Compose provides a complete interface for managing microservice applications.
    You can see a list of available commands by running <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    compose --help</samp>. The following are the most essential.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose 提供了一个完整的接口，用于管理微服务应用程序。你可以通过运行 <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    compose --help</samp> 查看可用的命令列表。以下是最重要的命令。
- en: 'We use <samp class="SANS_TheSansMonoCd_W5Regular_11">docker compose ls</samp>
    to get a list of all locally running Docker applications defined in *docker-compose.yml*
    files. The command returns the name and status of the application:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">docker compose ls</samp>
    来获取所有本地运行的 Docker 应用程序列表，这些应用程序在 *docker-compose.yml* 文件中定义。该命令返回应用程序的名称和状态：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To shut down all running services defined in the *docker-compose.yml* file
    in the current directory, run <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    compose kill</samp>, which sends a <samp class="SANS_TheSansMonoCd_W5Regular_11">SIGKILL</samp>
    command to the primary process inside each container:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭当前目录中 *docker-compose.yml* 文件中定义的所有正在运行的服务，请运行 <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    compose kill</samp>，该命令会向每个容器中的主进程发送 <samp class="SANS_TheSansMonoCd_W5Regular_11">SIGKILL</samp>
    命令：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To kill the services with a more graceful <samp class="SANS_TheSansMonoCd_W5Regular_11">SIGTERM</samp>
    command, use the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要以更优雅的 <samp class="SANS_TheSansMonoCd_W5Regular_11">SIGTERM</samp> 命令关闭服务，请使用以下命令：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Instead of forcing a shutdown, this command gracefully removes all processes,
    containers, networks, and volumes created by <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    compose up</samp>.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 与强制关闭不同，这个命令会优雅地移除通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">docker compose
    up</samp> 创建的所有进程、容器、网络和卷。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: 'Using the Docker containerization platform makes it easy to deploy applications
    and use a microservice architecture. This chapter covered the building blocks
    of the Docker ecosystem: the host, the Docker daemon, Dockerfiles, images, and
    containers. Using Docker Compose and Docker volumes, you split your application
    into single, self-contained services.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker 容器化平台使得部署应用程序和使用微服务架构变得更加容易。本章介绍了 Docker 生态系统的基本构件：主机、Docker 守护进程、Dockerfile、镜像和容器。通过使用
    Docker Compose 和 Docker 卷，你可以将应用程序分割成单个、独立的服务。
- en: To unleash the full potential of Docker, read the official tutorials at [*https://<wbr>docs<wbr>.docker<wbr>.com<wbr>/get<wbr>-started<wbr>/*](https://docs.docker.com/get-started/)
    or those at [*https://<wbr>docker<wbr>-curriculum<wbr>.com*](https://docker-curriculum.com).
    In the next chapter, you’ll start to build the Food Finder application. This full-stack
    web application will build upon the knowledge you’ve gained in all previous chapters.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要充分释放 Docker 的潜力，请阅读官方教程 [*https://<wbr>docs<wbr>.docker<wbr>.com<wbr>/get<wbr>-started<wbr>/*](https://docs.docker.com/get-started/)
    或者 [*https://<wbr>docker<wbr>-curriculum<wbr>.com*](https://docker-curriculum.com)。在下一章中，你将开始构建
    Food Finder 应用程序。这个全栈 Web 应用程序将建立在你在之前所有章节中获得的知识基础上。
