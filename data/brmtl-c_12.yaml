- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: The Linker
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 链接器
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: This chapter explores in extreme detail how the linking process works. The linker’s
    job is to take all the object files that make up a program and put them together.
    The linker must know exactly what the memory layout of your device is so it can
    fit the program into memory. It’s also responsible for connecting external symbols
    in one file with their actual definitions in another. This process is called *linking
    symbols*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章极为详细地探讨了链接过程的工作原理。链接器的工作是将构成程序的所有目标文件组合在一起。链接器必须准确知道设备的内存布局，以便能够将程序装入内存。它还负责将一个文件中的外部符号与另一个文件中的实际定义连接起来。这个过程称为*链接符号*。
- en: It is the linker that knows exactly where things are. On big systems where we
    have gigabytes of memory, this doesn’t matter that much, but on a microcontroller
    with 16KB of RAM, knowing what every byte is used for is important.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 正是链接器知道事物的具体位置。在拥有数GB内存的大型系统中，这没什么大不了的，但在具有16KB RAM的微控制器上，了解每个字节的用途非常重要。
- en: Let’s take a look at a typical problem that shows how better understanding the
    linker can be helpful. Say you have a system in the field that’s crashing. When
    it crashes, it prints a stack trace showing the call stack that details the faults
    leading up to the problem (see [Listing 11-1](#listing11-1)).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个典型问题，看看更好地理解链接器如何帮助解决问题。假设你在现场有一个系统发生崩溃。当它崩溃时，它会打印出一个堆栈跟踪，显示出导致问题的调用堆栈（见[示例
    11-1](#listing11-1)）。
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 11-1: A sample stack trace'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-1：一个示例堆栈跟踪
- en: This tells you that the fault was in the function whose address is `0x0000000000001136`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉你故障发生在地址为`0x0000000000001136`的函数中。
- en: Since you didn’t write your program using absolute addresses, the name of the
    function would be more useful to you. That’s where the linker map comes in.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你没有使用绝对地址编写程序，因此函数的名称对你来说更有用。链接器映射就是在这种情况下发挥作用的。
- en: '[Listing 11-2](#listing11-2) shows an excerpt from the map of this program.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 11-2](#listing11-2) 显示了该程序映射的一个片段。'
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 11-2: An excerpt from the map of the program in [Listing 11-1](#listing11-1)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-2：来自[示例 11-1](#listing11-1)程序映射的片段
- en: We aborted at `0x1136` in [Listing 11-1](#listing11-1). In [Listing 11-2](#listing11-2),
    function `three` starts at `0x1129` and goes on until the next function at `0x113e`.
    In fact, we are 13 bytes into function `three`, so we are somewhere near the start
    of the function.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[示例 11-1](#listing11-1)中的`0x1136`处中止了。在[示例 11-2](#listing11-2)中，函数`three`从`0x1129`开始，一直到下一个函数`0x113e`。实际上，我们已经进入了函数`three`的13个字节，所以我们离函数的开始位置很近。
- en: '[Listing 11-1](#listing11-1) shows that function `three` was called by someone
    at address `0x1150`. [Listing 11-2](#listing11-2) shows that function `two` goes
    from `0x113e` to `0x1153`, so it called `three`. Using a similar analysis, we
    can tell that `two` was called by `one`, and `one` was called by `main`.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 11-1](#listing11-1) 显示了函数`three`是由位于地址`0x1150`的某个地方调用的。[示例 11-2](#listing11-2)
    显示函数`two`从`0x113e`到`0x1153`，因此它调用了`three`。通过类似的分析，我们可以看出`two`是由`one`调用的，而`one`又是由`main`调用的。'
- en: The Linker’s Job
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接器的工作
- en: The linker’s job is to take the object files that make up the program and put
    them together to form a single program file. An object file contains code and
    data organized into named sections. (The actual names of the sections are compiler-dependent.
    Advanced programmers can even make up their own names.)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 链接器的工作是将组成程序的目标文件组合在一起，形成一个单一的程序文件。目标文件包含代码和数据，这些代码和数据按名称组织成不同的部分。（部分的实际名称依赖于编译器。高级程序员甚至可以自定义部分名称。）
- en: The sections in the object file have no fixed address. They are said to be *relocatable*,
    which means they can be put almost anywhere, but the linker puts them in a specific
    place in memory.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 目标文件中的部分没有固定地址。它们被称为*可重定位*的，这意味着它们几乎可以放置在任何地方，但链接器会将它们放置在内存中的特定位置。
- en: 'The ARM chip contains two types of memory: random access memory (RAM) and flash.
    RAM is where the variables go. One problem with this type of memory is that all
    the data is lost when the power goes off. Flash memory, for all practical purposes,
    is a type of read-only memory. (You can write to it if you’re very clever with
    the I/O system.) The data in flash memory is not erased when the system loses
    power.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ARM芯片包含两种类型的内存：随机存取内存（RAM）和闪存。RAM用于存储变量。这种类型内存的问题之一是，当电源关闭时，所有数据都会丢失。闪存，在实际应用中，类似于只读存储器。（如果你在I/O系统上非常聪明，当然也可以写入它。）闪存中的数据不会在系统断电时丢失。
- en: The linker takes the data from all the object files and packs it into the RAM.
    It then splits up the remaining RAM into the stack and the heap. The code and
    read-only data get put in the flash memory. This description is somewhat oversimplified,
    but we’ll leave the details for later in this chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 链接器从所有对象文件中提取数据，并将其打包进RAM中。然后，它将剩余的RAM分配给堆栈和堆。代码和只读数据存放在闪存中。这个描述有些过于简化，但我们会在本章后面详细讨论这些细节。
- en: The final thing the linker does is write out a map file telling you where it
    put everything. Why do we care where the linker puts things? After all, the principal
    thing is that the program gets put in the memory. When it comes to debugging in
    the field, however, we need to know where things are. Also, there are times when
    we may want to define specialized memory sections or attach additional memory
    chips to our system.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 链接器的最终任务是写出一个映射文件，告诉你它将每个部分放在哪里。为什么我们关心链接器把东西放在哪里？毕竟，最重要的事情是程序被加载到内存中。然而，在现场调试时，我们需要知道各个部分的位置。此外，有时我们可能需要定义特定的内存区域或为系统附加额外的内存芯片。
- en: 'And then there’s the big reason: the firmware upgrade. It has been said that
    the hardware people have to get the hardware right the first time. The only thing
    the software people have to get right is the firmware upgrade. But how do you
    use the running software to replace the running software? And more importantly,
    how do you do it without bricking your system? (*Bricking* refers to a failed
    upgrade process that turns your system into something about as useful as a brick.)
    That involves some tricky programming, which I’ll explain near the end of this
    chapter.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是一个重要原因：固件升级。据说硬件人员必须第一次就把硬件做对。软件人员唯一需要做对的事情就是固件升级。但如何使用正在运行的软件来替换正在运行的软件呢？更重要的是，如何做到这一点而不会把系统弄成“砖头”？（*砖头*是指固件升级失败后，系统变得和砖头一样毫无用处。）这涉及一些复杂的编程，我将在本章末尾解释。
- en: Compilation and Linking Memory Models
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译和链接的内存模型
- en: A *memory model* describes how memory is specified in a system. Basically, memory
    is divided into named sections. The C standard, the object files, and the ARM
    chip all use different names to describe their memory. Worse, it is possible to
    define custom names through C language extensions. The linker must then be told
    what to do with those custom sections.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*内存模型*描述了系统中内存的配置方式。基本上，内存被划分为命名的区域。C标准、对象文件和ARM芯片使用不同的名称来描述它们的内存。更糟糕的是，还可以通过C语言扩展来定义自定义名称。链接器必须知道如何处理这些自定义区域。'
- en: The Ideal C Model
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理想的C模型
- en: 'Everything in a C program ideally will go into one of the standard sections:
    `text`, `data`, or `bss`.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，C程序中的所有内容都会放入标准部分之一：`text`、`data`或`bss`。
- en: 'Read-only instructions and read-only data go in the `text` section. Here, both
    the code for `main` and the text string (read-only) go in the `text` section:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 只读指令和只读数据存放在`text`部分。这里，`main`的代码和文本字符串（只读）都放在`text`部分：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Initialized data (initialized global variables) goes in the `data` section:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 已初始化的数据（已初始化的全局变量）存放在`data`部分：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Uninitialized data (uninitialized global variables) goes in the `bss` section:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 未初始化的数据（未初始化的全局变量）存放在`bss`部分：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Technically, `bss` is uninitialized according to the standard. However, in every
    implementation I’ve seen of a C programming system, the `bss` section is initialized
    to zero.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，`bss`根据标准是未初始化的。然而，在我见过的每一个C编程系统的实现中，`bss`部分都会被初始化为零。
- en: The data for these sections is allocated at compile time. The C compiler will
    spit out an object file that says, “I need this much `text`, and here are the
    contents. I need this much `data`, and here are the contents. I need this much
    `bss`, with no contents specified.”
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些部分的数据在编译时分配。C编译器会输出一个对象文件，表示：“我需要这么多`text`，这里是内容。我需要这么多`data`，这里是内容。我需要这么多`bss`，但是没有指定内容。”
- en: The `size` command shows how much space your program is using in each section.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`size`命令显示程序在每个部分使用了多少空间。'
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The object file uses 481 bytes of `text`, 4 bytes of `data`, and another 4 bytes
    of `bss`. The total number of bytes for all three is 489, or 1e9 in hexadecimal.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对象文件使用了481字节的`text`，4字节的`data`，以及另外4字节的`bss`。这三者总共占用489字节，或在十六进制下为1e9。
- en: The ideal C model has two other memory sections. However, they are not allocated
    by the compiler; they are allocated by the linker. These are the *stack* and the
    *heap*. The stack is used for local variables and is dynamically allocated as
    procedures are called. The heap is a pool of memory that can be dynamically allocated
    and freed (more on the heap in Chapter 13).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 理想的 C 模型还有两个其他内存区块。然而，这些区块并不是由编译器分配的，而是由链接器分配的。它们分别是 *栈* 和 *堆*。栈用于局部变量，并在调用过程时动态分配。堆是一个可以动态分配和释放的内存池（有关堆的更多内容，请参见第
    13 章）。
- en: The compiler takes our variable definitions and assigns them to memory sections.
    Those sections use a different namespace from the ideal C memory section names.
    In some cases the names are similar, and in some cases they are completely different.
    Different compilers and even different versions of the same compiler might use
    different names for the sections.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会将我们的变量定义分配到内存区块中。这些区块使用的命名空间与理想的 C 内存区块名称不同。在某些情况下，名称相似，而在其他情况下，名称完全不同。不同的编译器，甚至同一编译器的不同版本，可能会为这些区块使用不同的名称。
- en: '[Listing 11-3](#listing11-3) shows a program that contains every type of data
    we’ve discussed.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 11-3](#listing11-3) 显示了一个包含我们讨论的所有类型数据的程序。'
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 11-3: Examples of data types'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-3：数据类型示例
- en: Let’s see what our GNU GCC compiler does with our sample program from [Listing
    11-3](#listing11-3)—specifically, how it really allocates memory for the various
    types of variables and data.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的 GNU GCC 编译器如何处理 [清单 11-3](#listing11-3) 中的示例程序——具体来说，它是如何为不同类型的变量和数据分配内存的。
- en: 'First, here’s `initializedGlobal` from [Listing 11-3](#listing11-3):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这是来自 [清单 11-3](#listing11-3) 的 `initializedGlobal`：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `.global` directive tells the assembler that this is a global symbol and
    can be referred to by other object files. The `.data` directive tells the assembler
    that what follows goes in the `.data` section. So far, we’re following the ideal
    C memory model naming convention.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`.global` 指令告诉汇编器这是一个全局符号，其他目标文件可以引用它。`.data` 指令告诉汇编器接下来的内容应该放入 `.data` 区块。到目前为止，我们遵循了理想的
    C 内存模型命名规范。'
- en: The `.align` directive tells the assembler that the following data should be
    aligned on a 4-byte boundary. (The last 2 bits of the address must be zero, thus
    the `.align 2`.) Finally, there is the `initializedGlobal` label and the `.word
    1` data.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`.align` 指令告诉汇编器接下来的数据应当按 4 字节对齐。（地址的最后两位必须为零，因此使用 `.align 2`。）最后，有 `initializedGlobal`
    标签和 `.word 1` 数据。'
- en: 'When a variable is initialized to zero (`initializedToZero` in [Listing 11-3](#listing11-3)),
    we see slightly different code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个变量被初始化为零（[清单 11-3](#listing11-3) 中的 `initializedToZero`）时，我们会看到略有不同的代码：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, the compiler uses the `.bss` directive to put the variable in the `bss`
    section. It also uses the `.space` directive instead of `.word`, which tells the
    assembler that this variable takes up 4 bytes of space and to initialize those
    bytes to zero.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，编译器使用 `.bss` 指令将变量放入 `bss` 区块。它还使用 `.space` 指令而不是 `.word`，告诉汇编器该变量占用 4 字节空间，并将这些字节初始化为零。
- en: 'Now let’s deal with an uninitialized global variable (`uninitializedGlobal`
    from [Listing 11-3](#listing11-3)):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们处理一个未初始化的全局变量（[清单 11-3](#listing11-3) 中的 `uninitializedGlobal`）：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `.comm` section tells the assembler to define a symbol that is 4 bytes long
    and aligned on a 4-byte boundary. The symbol goes into a memory section called
    `COMMON`. In this case, the section name does not follow the ideal C memory model
    naming convention.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`.comm` 区块告诉汇编器定义一个 4 字节长且按 4 字节对齐的符号。该符号会被放入名为 `COMMON` 的内存区块中。在这种情况下，区块名称并不遵循理想的
    C 内存模型命名规范。'
- en: 'The statement that defines `aString` in [Listing 11-3](#listing11-3) also defines
    a string constant (`"A string."`). The string constant is read-only, while the
    pointer (`aString`) is read/write. Here’s the generated code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [清单 11-3](#listing11-3) 中定义 `aString` 的语句同时定义了一个字符串常量（`"A string."`）。字符串常量是只读的，而指针（`aString`）是读写的。以下是生成的代码：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First, the compiler must generate the constant for `"A string."`. It generates
    an internal name (`.LC0`) for this constant, and the contents of this constant
    are generated with the `.ascii` assembler directive. The `.section .rodata` directive
    puts the constant in a linker section called `.rodata`. (The ideal C memory model
    calls this `text`.)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，编译器必须为 `"A string."` 生成常量。它为该常量生成一个内部名称（`.LC0`），并通过 `.ascii` 汇编指令生成该常量的内容。`.section
    .rodata` 指令将常量放入名为 `.rodata` 的链接器区块中。（理想的 C 内存模型将其称为 `text`。）
- en: Now we come to the definition of the variable itself, `aString`. The `.data`
    directive puts it in the `data` section. Since it’s a pointer, it is initialized
    with the address of the string (namely, `.LC0`).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看变量本身的定义，`aString`。`.data`指令将其放入`data`区域。由于它是一个指针，因此它被初始化为字符串的地址（即`.LC0`）。
- en: 'The last major section is the one that contains the code. The ideal C memory
    model calls this `text`. Here’s the assembly listing for the start of `main`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的主要区域是包含代码的区域。理想的C语言内存模型将其称为`text`。以下是`main`函数开始的汇编代码：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The name for this section is `text.main`. In this case, the compiler decided
    to take the `text` prefix and add on the name of the module (`main`) to form the
    section name.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个区域的名称是`text.main`。在这种情况下，编译器决定将`text`前缀和模块名（`main`）组合成区域名。
- en: We’ve covered the major memory sections that the compiler knows about, so next
    let’s look at the code generated by some other types of declarations. The `static`
    keyword used outside any procedure indicates a variable that can be used only
    within the current module.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经覆盖了编译器知道的主要内存区域，接下来让我们看看由其他类型声明生成的代码。`static`关键字用于任何过程之外时，表示该变量只能在当前模块内使用。
- en: 'Here’s the code that creates the `initializedModule` variable from [Listing
    11-3](#listing11-3):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是从[清单11-3](#listing11-3)中创建`initializedModule`变量的代码：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It looks pretty much the same as `initializedGlobal`, only the `.global` directive
    is missing.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来与`initializedGlobal`非常相似，唯一的区别是缺少`.global`指令。
- en: 'Similarly, the `uninitializedModule` variable from [Listing 11-3](#listing11-3)
    looks much like `uninitializedGlobal`, only again, we are missing the `.global`
    directive:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，来自[清单11-3](#listing11-3)的`uninitializedModule`变量看起来与`uninitializedGlobal`非常相似，只不过我们再次缺少`.global`指令：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now we come to the variables declared `static` inside a procedure. These variables
    are allocated at compile time in main memory, but their scope is local to the
    procedure where they are defined.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来讲解在过程内声明为`static`的变量。这些变量在编译时分配到主内存中，但它们的作用域仅限于它们定义的过程内。
- en: 'Let’s start with the `uninitializedStatic` variable from [Listing 11-3](#listing11-3):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从[清单11-3](#listing11-3)中的`uninitializedStatic`变量开始：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It looks like any uninitialized local, except the compiler changed the name
    of the variable from `uninitializedStatic` to `uninitializedStatic.4108`. Why?
    Each block, or section of code enclosed in curly brackets (`{}`), can have its
    own `uninitializedStatic` variable. The scope of the C variable name is local
    to the block in which it is defined. The scope of the assembly language is the
    entire file, so the compiler makes the name unique by appending a unique random
    number to the end of the variable declaration.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来像任何未初始化的局部变量，只不过编译器将变量名从`uninitializedStatic`改为`uninitializedStatic.4108`。为什么？每个用大括号（`{}`）括起来的代码块可以有自己的`uninitializedStatic`变量。C语言变量名的作用域局限于定义它的代码块。而汇编语言的作用域是整个文件，因此编译器通过在变量声明的末尾附加一个唯一的随机数来使得变量名唯一。
- en: 'Similarly, the `initializedStatic` variable looks pretty much like its global
    brother:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`initializedStatic`变量看起来也与它的全局变量版本非常相似：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this case, the `.global` is missing and the name has been transformed by
    the addition of a suffix.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`.global`缺失，并且通过添加后缀，变量名发生了变化。
- en: Nonstandard Sections
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非标准区域
- en: We’ve discussed the standard memory sections that the GNU toolchain generates.
    The STM32 chips use a custom section named `.isr_vector`, and it must be the first
    data programmed into the flash memory because the ARM hardware uses this section
    of memory to service interrupts and other hardware-related functions. [Table 11-1](#table11-1),
    adapted from the STM32F030x4 manual, describes the interrupt vector.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了GNU工具链生成的标准内存区域。STM32芯片使用一个名为`.isr_vector`的自定义区域，它必须是写入闪存的第一个数据，因为ARM硬件使用这部分内存来处理中断和其他硬件相关功能。[表11-1](#table11-1)，来自STM32F030x4手册，描述了中断向量。
- en: 'Table 11-1: Interrupt Vector Documentation (Truncated)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 表11-1：中断向量文档（截断）
- en: '| **Position** | **Priority** | **Type of priority** | **Acronym** | **Description**
    | **Address** |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| **位置** | **优先级** | **优先级类型** | **缩写** | **描述** | **地址** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| — | — | — | — | Reserved | `0x0000 0000` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| — | — | — | — | 保留 | `0x0000 0000` |'
- en: '| — | –3 | Fixed | Reset | Reset | `0x0000 0004` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| — | –3 | 固定 | 重置 | 重置 | `0x0000 0004` |'
- en: '| — | –2 | Fixed | NMI | Non-maskable interrupt. The RCC Clock Security System
    (CSS) is linked to the NMI vector. | `0x0000 0008` |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| — | –2 | 固定 | NMI | 不可屏蔽中断。RCC时钟安全系统（CSS）链接到NMI向量。 | `0x0000 0008` |'
- en: '| — | –1 | Fixed | HardFault | All class of fault | `0x0000 000C` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| — | –1 | 固定 | HardFault | 所有类型的故障 | `0x0000 000C` |'
- en: '| — | 3 | Settable | SVCall | System service call via SWI instruction | `0x0000
    002C` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| — | 3 | 可设置 | SVCall | 通过SWI指令调用系统服务 | `0x0000 002C` |'
- en: '| — | 5 | Settable | PendSV | Pendable request for system service | `0x0000
    0038` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| — | 5 | 可设置 | PendSV | 可挂起的系统服务请求 | `0x0000 0038` |'
- en: '| — | 6 | Settable | SysTick | System tick timer | `0x0000 003C` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| — | 6 | 可设置 | SysTick | 系统滴答定时器 | `0x0000 003C` |'
- en: '| 0 | 7 | Settable | WWDG | Window watchdog interrupt | `0x0000 0040` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 7 | 可设置 | WWDG | 窗口看门狗中断 | `0x0000 0040` |'
- en: '| 1 |  |  | Reserved |  | `0x0000 0044` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 1 |  |  | 保留 |  | `0x0000 0044` |'
- en: '| 2 | 9 | Settable | RTC | RTC interrupts (combined EXTI lines 17, 19, and
    20) | `0x0000 0048` |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 9 | 可设置 | RTC | RTC中断（组合的EXTI线路17、19和20） | `0x0000 0048` |'
- en: 'The STM firmware file *startup_stm32f030x8.s* (an assembly language file) contains
    the code that defines this table. Here’s an excerpt:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: STM固件文件 *startup_stm32f030x8.s*（汇编语言文件）包含定义此表的代码。以下是一个摘录：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first line tells the linker that the table goes in a section called `.isr_vector`.
    This section is highly hardware-specific, precisely defined, and must go in exactly
    the right place. Otherwise, nothing will work.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行告诉链接器，该表将放在一个名为 `.isr_vector` 的段中。这个段是高度硬件特定的，定义非常精确，必须放在正确的位置，否则系统将无法正常工作。
- en: 'The code defines an array called `g_pfnVectors` that contains the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码定义了一个名为 `g_pfnVectors` 的数组，其中包含以下内容：
- en: The address of the initial stack
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始栈的地址
- en: The address reset handler
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复位处理程序的地址
- en: The address of the non-maskable interrupt (NMI) handler
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可屏蔽中断（NMI）处理程序的地址
- en: Other interrupt vectors, as described in [Table 11-1](#table11-1)
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他中断向量，详见 [表11-1](#table11-1)
- en: We’ll see how the linker handles this code in the next section.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节看到链接器如何处理这段代码。
- en: The Linking Process
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接过程
- en: 'The compiler and assembler produced a set of object files that divide up the
    code and data into the following sections:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器和汇编器生成了一组目标文件，将代码和数据划分为以下几个部分：
- en: '`text.``<name>` Read-only data and code'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`text.` `<name>` 只读数据和代码'
- en: '`rodata` Read-only data'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rodata` 只读数据'
- en: '`data` Initialized data'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`data` 已初始化数据'
- en: '`bss` Data initialized to zero (slightly different definition from the one
    the ideal C memory model uses)'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`bss` 初始化为零的数据（与理想的C内存模型略有不同的定义）'
- en: '`COMMON` Uninitialized data'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`COMMON` 未初始化数据'
- en: '`.isr_vector` Interrupt and reset handlers that must go in a specific place'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`.isr_vector` 中断和复位处理程序，必须放在特定位置'
- en: 'The linker is controlled by a script named *LinkerScript.ld*, which is part
    of each STM32 Workbench project. The script tells the linker that the system’s
    memory consists of two sections:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 链接器由名为 *LinkerScript.ld* 的脚本控制，该脚本是每个STM32工作台项目的一部分。脚本告诉链接器，系统的内存由两个部分组成：
- en: Flash, starting at `0x8000000`, 64KB long
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 闪存，从 `0x8000000` 开始，长度 64KB
- en: RAM, starting at `0x20000000`, 8KB long
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RAM，从 `0x20000000` 开始，长度 8KB
- en: 'The linker’s job is to take the data from the object files and pack it into
    memory via the following steps:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 链接器的工作是将目标文件中的数据通过以下步骤打包到内存中：
- en: Put the `.isr_vector` section at the beginning of flash.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `.isr_vector` 段放置在闪存的开头。
- en: Put all the data from the `.text.*` sections into flash.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `.text.*` 段中的所有数据放入闪存中。
- en: Put the `.rodata` section into flash.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `.rodata` 段放入闪存。
- en: Put the `.data` section into RAM, however the initializers for the `.data` section
    go into flash (we’ll discuss this more later).
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `.data` 段放入RAM中，但 `.data` 段的初始化器需要放入闪存中（我们稍后会详细讨论）。
- en: Put the `.bss` section into RAM.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `.bss` 段放入RAM。
- en: Finally, load the `COMMON` section into RAM.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将 `COMMON` 段加载到RAM中。
- en: 'The `.data` section is the tricky one. Consider the declaration:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`.data` 段是比较复杂的部分。考虑以下声明：'
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The linker allocates space in RAM for `initializedGlobal`. The initializer (`1234`)
    goes into flash. At startup, the initializers are copied as a block into RAM to
    initialize the `.data` section.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 链接器为 `initializedGlobal` 在RAM中分配空间。初始化器（`1234`）放入闪存中。在启动时，初始化器会作为一个块复制到RAM中，以初始化
    `.data` 段。
- en: Symbols Defined by the Linker
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接器定义的符号
- en: 'During the linking process, the linker defines some important symbols, including
    the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在链接过程中，链接器会定义一些重要的符号，包括以下内容：
- en: '`_sidata` Start of the initializers for the `.data` section in flash'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`_sidata` 闪存中 `.data` 段初始化器的起始位置'
- en: '`_sdata` Start of the `.data` section in RAM'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`_sdata` `.data` 段在 RAM 中的起始位置'
- en: '`_edata` End of the `.data` section in RAM'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`_edata` `.data` 段在 RAM 中的结束位置'
- en: '`_sbss` Start of the `.bss` and `COMMON` sections in RAM'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`_sbss` `.bss` 和 `COMMON` 段在 RAM 中的起始位置'
- en: '`_ebss` End of the `.bss` and `COMMON` sections in RAM'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`_ebss` `.bss` 和 `COMMON` 段在 RAM 中的结束位置'
- en: '`_estack` Last address of RAM'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`_estack` RAM 的最后地址'
- en: 'Upon reset, the code in *startup_stm32f030x8.S* executes and performs the following
    steps:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在复位时，*startup_stm32f030x8.S* 中的代码会执行，并完成以下步骤：
- en: Load the stack register with `_estack`. The stack will grow down.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `_estack` 加载堆栈寄存器，堆栈将向下增长。
- en: Fill the section of memory from `_sdata` to `_edata` with the initialization
    values stored starting at `_sidata`.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将从 `_sdata` 到 `_edata` 之间的内存区域填充为从 `_sidata` 开始存储的初始化值。
- en: Zero the memory between `_sbss` and `_ebss`.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `_sbss` 和 `_ebss` 之间的内存清零。
- en: Call the function `SystemInit` to initialize the STM32 chip.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `SystemInit` 函数来初始化 STM32 芯片。
- en: Call the function `__libc_init_array` to initialize the C library.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `__libc_init_array` 函数来初始化 C 库。
- en: Call `main`.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `main`。
- en: Loop forever.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 永久循环。
- en: Relocation and Linking Object Files
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重定位和链接目标文件
- en: 'There are two types of object files: *absolute* and *relocatable*. An absolute
    file defines everything in terms of a fixed (absolute) address. In other words,
    the symbol `main` is at `0x7B0`, and it cannot be set to another address by the
    linker or any other tool.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 目标文件有两种类型：*绝对* 和 *可重定位*。绝对文件将所有内容定义为固定（绝对）地址。换句话说，符号 `main` 位于 `0x7B0`，且不能由链接器或其他任何工具设置为其他地址。
- en: 'A relocatable object file is designed to have the location of its data move
    around (relocate). For example, the *main.c* source file produces the *main.o*
    object file. If we look at the assembly listing, we see the symbol `main` is defined
    at `0000`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 可重定位目标文件设计为其数据的位置可以变动（重定位）。例如，*main.c* 源文件会生成 *main.o* 目标文件。如果查看汇编列表，我们会看到符号
    `main` 被定义在 `0000`：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This symbol is relative to the section where it resides (namely, `text.main`).
    Because the object file is relocatable, `text.main` can be located anywhere in
    memory. In this case, the linker decided to put it in flash memory at `0x00000000080007b0`.
    (We found this value using the linker map, which is discussed in the next section.)
    Because `main` is at the beginning of this segment, it gets the value `0x00000000080007b0`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个符号是相对于它所在的段（即 `text.main`）而言的。由于目标文件是可重定位的，`text.main` 可以位于内存中的任何地方。在这种情况下，链接器决定将其放置在闪存中的
    `0x00000000080007b0` 位置。（我们通过链接器映射找到了这个值，接下来的章节会详细讨论。）由于 `main` 位于该段的开始位置，因此它被赋值为
    `0x00000000080007b0`。
- en: As part of the linker process, the linker takes the relocatable object files
    and assigns them a location in the memory. The result is a program file with absolute
    addresses for each object file.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 作为链接器过程的一部分，链接器会将可重定位目标文件分配到内存中的位置。最终结果是一个程序文件，每个目标文件都有绝对地址。
- en: The linker also links the object files together. For example, the *startup_stm32f030x8.S*
    file calls `main`. The problem is that this code doesn’t know where `main` is.
    It’s defined in another module (*main.o*), so at link time, the linker will see
    that *startup_stm32f030x8.S* needs to know where the `main` symbol is defined
    and will perform a link operation between the *startup_stm32f030x8.S* call to
    `main` and the absolute address of main (`0x7B0`).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 链接器还会将目标文件链接在一起。例如，*startup_stm32f030x8.S* 文件会调用 `main`。问题在于，这段代码并不知道 `main`
    位于哪里。它在另一个模块（*main.o*）中定义，因此在链接时，链接器会看到 *startup_stm32f030x8.S* 需要知道 `main` 符号的定义位置，并会执行从
    *startup_stm32f030x8.S* 中调用 `main` 到 `main` 的绝对地址（`0x7B0`）的链接操作。
- en: 'A library is a collection of object (*.o*) files in an archive format (similar
    to *.zip*, but not as sophisticated). The linker script tells the linker to include
    the libraries *libc.a*, *libm.a*, and *libgcc.a*. For example, the *libm.a* library
    contains the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 库是以归档格式（类似 *.zip*，但不如其复杂）收集的目标文件（*.o*）。链接器脚本会告诉链接器包括 *libc.a*、*libm.a* 和 *libgcc.a*
    库。例如，*libm.a* 库包含以下内容：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When processing a library, the linker will load an object file only if it defines
    a symbol that your program needs. For example, if your program uses the `sin`
    function, it will link in the object *s_sin.o* file that defines this function.
    If you don’t use the `sin` function, then the linker knows you don’t need the
    code in *s_sin.o* and therefore will not link in the file.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理库时，链接器只会加载定义了你的程序所需符号的目标文件。例如，如果你的程序使用了 `sin` 函数，它将链接包含该函数定义的目标文件 *s_sin.o*。如果你没有使用
    `sin` 函数，则链接器知道你不需要 *s_sin.o* 中的代码，因此不会将该文件链接进来。
- en: The Linker Map
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接器映射
- en: 'As the linker loads data into the program, it produces a map file (*Debug/output.map*)
    that contains information about where our code and data are. This map file is
    very complete and contains a lot of useful information as well as a lot of stuff
    we don’t care about. For example, it tells us what our memory configuration looks
    like, which shows the various types of memory and their locations for our processor:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当链接器将数据加载到程序中时，它会生成一个映射文件（*Debug/output.map*），其中包含有关我们代码和数据位置的信息。此映射文件非常完整，包含许多有用信息以及我们不关心的许多内容。例如，它告诉我们我们的内存配置是什么样的，显示处理器的各种类型和位置：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this case, our chip has `FLASH` memory, which has the read (`r`) and execute
    (`x`) attributes set. It starts at `0x8000000` and goes on for `0x10000` bytes.
    The `RAM` section starts at `0x20000000` and goes on for only `0x2000` bytes.
    It is readable (`r`), writable (`w`), and executable (`x`).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的芯片具有`FLASH`存储器，其具有设置了读取（`r`）和执行（`x`）属性。它从`0x8000000`开始，延伸至`0x10000`字节。`RAM`部分从`0x20000000`开始，仅延伸至`0x2000`字节。它可读（`r`）、可写（`w`）和可执行（`x`）。
- en: 'As mentioned previously, the `.isr_vector` section is loaded first. The linker
    map tells us where this is located:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`.isr_vector`部分首先加载。链接器映射告诉我们它的位置：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The address `0x8000000` is the start of flash. The hardware expects the interrupt
    vector to be at this address, so that is a good thing. The other bit of information
    is that this section is `0xc0` bytes long.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 地址`0x8000000`是Flash的起始地址。硬件期望中断向量位于该地址，这是一个好消息。另一点信息是，此部分长度为`0xc0`字节。
- en: 'The `main` symbol is defined in *src/main.o*. It is part of the `.text.main`
    segment and is located at `0x0000000008000138`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`符号定义在*src/main.o*中。它是`.text.main`段的一部分，并位于`0x0000000008000138`处：'
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It also contains a bit of code (`0x60` bytes, which is large considering [Listing
    11-3](#listing11-3) is a nothing program).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 它还包含一些代码（`0x60`字节，考虑到[清单 11-3](#listing11-3)只是一个无用的程序）。
- en: 'We can also see where our global variables are located. For example, here’s
    the location for `uninitializedGlobal`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到全局变量的位置。例如，这是`uninitializedGlobal`的位置：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The linker map provides the absolute address of every variable and function
    in this program. Why is that useful? When we are debugging in the field (no JTAG
    debugger), frequently we have only absolute addresses, so if your program suffers
    a fatal error and you see:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 链接器映射提供了此程序中每个变量和函数的绝对地址。这有什么用呢？当我们在现场调试时（没有JTAG调试器），我们经常只有绝对地址，因此如果您的程序遇到致命错误并看到
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: on the debug console, you’ll know the error occurred `0x20` bytes into `main`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试控制台上，您会知道错误发生在`main`的`0x20`字节处。
- en: We’ve been using an *external* debugger with our STM board. This system consists
    of a host computer running the debugger, a JTAG debugging pod, and a target machine.
    The debugger on the host computer has access to the source code and the symbol
    table (from the linker). When it detects an error at `0x8000158`, it can look
    into the symbol table, see that the error occurred `0x20` bytes into the program,
    figure out on which line the error occurred, and display in the source file a
    big red arrow pointing to where the error occurred.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在使用一个*外部*调试器与我们的STM板。该系统由运行调试器的主机计算机、一个JTAG调试探针和一个目标机组成。主机计算机上的调试器可以访问源代码和符号表（来自链接器）。当它检测到`0x8000158`处的错误时，它可以查看符号表，查看错误发生在程序的`0x20`字节处，找出错误发生的行，并在源文件中显示一个大红箭头指向错误发生的位置。
- en: Some systems have an *internal* debugger, where the debugger and all the files
    it needs are on the target system. Some internal debuggers provide the ability
    to dump memory based on absolute addresses. Such debuggers are small and dumb,
    yet they can be surprisingly useful when it comes to debugging in the field.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 有些系统有*内部*调试器，在其中调试器和所有需要的文件都在目标系统上。一些内部调试器提供基于绝对地址转储内存的能力。这些调试器虽然小而愚笨，但在现场调试时非常有用。
- en: Suppose you have such a debugger and need to know the value of `uninitializedGlobal`.
    A dumb debugger doesn’t know anything about symbol names. It dumps memory based
    on address, and that’s it.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有这样一个调试器，并且需要知道`uninitializedGlobal`的值。愚笨的调试器不知道符号名称。它只基于地址转储内存，就这样。
- en: 'On the other hand, you do know about symbol names. You’ve got the linker map,
    so you can tell the debugger to display a 4-byte value at location `0x20000464`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，您确实知道符号名称。您拥有链接器映射，因此可以告诉调试器在`0x20000464`位置显示4字节值：
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This sort of debugging is primitive and difficult, but sometimes with embedded
    systems, it’s the only way to perform debugging.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这种调试方式原始且困难，但在嵌入式系统中，有时它是唯一可以进行调试的方法。
- en: Maybe you’re wondering why we don’t tell the debugger where `uninitializedGlobal`
    is, which would make things much easier. The problem is that a symbol table takes
    up a lot of space, and we are space-limited. Also, having the symbol table on
    the system itself is a security risk. (A hacker would just love to know the address
    of `passwordCheckingFunction`!)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你会想知道为什么我们不直接告诉调试器 `uninitializedGlobal` 的位置，这样会更简单。问题在于符号表占用了大量空间，而我们空间有限。而且，符号表存放在系统本身上是一个安全隐患。（黑客会很喜欢知道
    `passwordCheckingFunction` 的地址！）
- en: Advanced Linker Usage
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级链接器使用
- en: So far, we’ve used the linker only with the default settings. However, there
    will be times when you’ll want to perform more advanced functions than what you
    get with the defaults.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们仅使用了默认设置的链接器。然而，在某些时候，你可能会想执行一些比默认设置更高级的功能。
- en: Flash Memory for “Permanent” Storage
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 闪存用于“永久”存储
- en: One of the problems with the default C memory model is that all your data is
    reset when the program starts. On the STM32, this means resetting the device causes
    it to lose all data. Suppose you want to keep some configuration data around between
    boots. The default setup won’t let that happen. How do we do it?
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 C 内存模型存在一个问题，就是程序启动时所有数据都会被重置。在 STM32 中，这意味着重置设备会导致其丢失所有数据。假设你希望在重启之间保留一些配置信息。默认的设置无法实现这一点。我们该怎么做呢？
- en: Let’s start with the serial “Hello World” program from Chapter 9. We’re going
    to add a counter that tells how many times the system has booted and then write
    a message with the reset count to the serial device.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第 9 章的串口 “Hello World” 程序开始。我们将添加一个计数器，记录系统已经启动了多少次，然后将重置计数信息通过串口设备发送出去。
- en: Our design is simple. We’re going to take the top 4KB of flash and use it for
    configuration data. We’ll give it the imaginative name of `CONFIG`, and we’ll
    define a new memory section called `.config` in which we’ll put our reset variable.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的设计很简单。我们将使用闪存的顶部 4KB 来存储配置信息。我们给它取了个富有创意的名字 `CONFIG`，并定义了一个新的内存区域 `.config`，在其中存放我们的重置变量。
- en: 'Here’s the C code to do that:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完成这一操作的 C 代码：
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we need to modify the linker script to handle our new section. We start
    by dividing up the flash memory into two sections. The first will be the traditional
    flash memory we discussed earlier. The second, `CONFIG`, will hold our configuration
    data, which means we need to edit *LinkerScript.ld* and replace this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要修改链接脚本，以处理我们的新区域。我们首先将闪存内存分为两个区域。第一个是我们之前讨论过的传统闪存内存。第二个，`CONFIG`，将存储我们的配置信息，这意味着我们需要编辑
    *LinkerScript.ld* 并替换以下内容：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'with this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 用这个：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This reduces the size of `FLASH` by 4KB and then uses that 4KB for the memory
    section called `CONFIG`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 `FLASH` 的大小减少 4KB，然后将这 4KB 用作名为 `CONFIG` 的内存区域。
- en: Flash is different from normal memory in that you can write it only once before
    you must erase it. Erasing must be done a page at a time. In the STM32’s case,
    that means our `CONFIG` section must be at least 1KB long and must be a multiple
    of 1KB in size. We’ve chosen 4KB because we will probably want to store a lot
    more configuration data later on.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 闪存与普通内存不同，它只能在写入一次之后才能擦除。擦除必须一次进行一页。在 STM32 的情况下，这意味着我们的 `CONFIG` 区域必须至少有 1KB
    长，并且必须是 1KB 的倍数。我们选择了 4KB，因为我们可能希望以后存储更多的配置信息。
- en: 'Now we need to tell the linker to put the `.config` section into the memory
    block called `CONFIG`. This is done by adding the following to the `SECTIONS`
    portion of the *LinkerScript.ld* file:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要告诉链接器将 `.config` 区域放入名为 `CONFIG` 的内存块中。这可以通过在 *LinkerScript.ld* 文件的 `SECTIONS`
    部分添加以下内容来完成：
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Changing this variable is not as simple as just writing the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 更改这个变量并不像简单地写下以下代码那样容易：
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: A whole sequence of steps is needed to program the chip. We’ve put all the steps
    in a function called `updateCounter`, shown in [Listing 11-4](#listing11-4).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 编程芯片需要一系列的步骤。我们把所有步骤都放在了一个名为 `updateCounter` 的函数中，见 [列表 11-4](#listing11-4)。
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 11-4: The `updateCounter` procedure'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-4：`updateCounter` 程序
- en: The flash memory on the STM32 chip is protected, so we need to unprotect it
    by calling `HAL_FLASH_Unlock` 1. This function writes two password values to the
    flash protection system that enable the writing of flash. However, we still can’t
    write `resetCount` directly to flash, so instead we assign `resetCount` (a flash
    value) to `newResetCount` (a regular variable) 2, which we can increment.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: STM32 芯片上的闪存是受保护的，因此我们需要通过调用 `HAL_FLASH_Unlock` 1 来解锁它。此函数将两个密码值写入闪存保护系统，以启用闪存的写入操作。然而，我们仍然不能直接将
    `resetCount` 写入闪存，因此我们将 `resetCount`（一个闪存值）赋值给 `newResetCount`（一个常规变量）2，这样我们就可以对其进行递增。
- en: Before we can write to flash, we must erase it, and the smallest unit we can
    erase is a page. We first need to initialize a structure 3 to specify how many
    pages to erase at what address, and then pass this as a parameter to `HAL_FLASHEx_Erase`
    to erase the memory 4.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在写入闪存之前，我们必须先擦除闪存，而擦除的最小单位是一个页面。我们首先需要初始化一个结构 3，指定要擦除的页面数量及地址，然后将其作为参数传递给 `HAL_FLASHEx_Erase`
    来擦除内存 4。
- en: Now that the memory holding `resetCount` has been erased, we can write it. Unfortunately,
    we have a 32-bit value, and the flash memory writes only 16 bits at a time, so
    we use another HAL function, `HAL_FLASH_Program` 5, to do the job.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，存储 `resetCount` 的内存已被清除，我们可以进行写入。不幸的是，我们有一个 32 位的值，而闪存一次只能写入 16 位，因此我们使用另一个
    HAL 函数 `HAL_FLASH_Program` 5 来完成这项任务。
- en: '[Listing 11-5](#listing11-5) shows the whole program.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11-5](#listing11-5) 显示了完整的程序。'
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 11-5: The reset counting program'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-5：重置计数程序
- en: Multiple Configuration Items
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多个配置项
- en: Suppose we want to keep more than one configuration variable in flash memory.
    The problem is that flash memory is not ordinary memory. After you store a value
    in a flash memory variable, you cannot change it until you erase the entire memory
    page containing the variable.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在闪存中保持多个配置变量。问题在于，闪存并不是普通内存。当你将一个值存储到闪存变量中后，除非擦除包含该变量的整个内存页面，否则无法更改该值。
- en: 'That works fine when you store one variable per page (a very wasteful way of
    doing things), but how do you store multiple configuration variables in memory
    and update one? It requires a little work. Here is the process:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当每页存储一个变量时（这种做法非常浪费），这能正常工作，但如果我们想在内存中存储多个配置变量并更新其中一个怎么办呢？这需要一点工作。下面是处理过程：
- en: Save all the configuration variables in RAM.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有配置变量保存在 RAM 中。
- en: Update the value you need to change in RAM.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 RAM 中更新你需要更改的值。
- en: Erase all the configuration variables in flash. (Erase the flash page.)
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 擦除闪存中的所有配置变量。（擦除闪存页面。）
- en: Copy the RAM version back into flash.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 RAM 版本复制回闪存。
- en: '[Listing 11-6](#listing11-6) shows an outline of the code to declare a configuration
    structure in the `.config` section and update a value in the `struct`.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11-6](#listing11-6) 显示了在 `.config` 部分声明配置结构并更新 `struct` 中值的代码框架。'
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 11-6: Updating the configuration in flash'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-6：更新闪存中的配置
- en: A number of problems are associated with flash memory. As mentioned previously,
    the first problem is that an entire page must be erased in order to write a single
    word. It takes time to write a page into flash, and it’s possible for the system
    to be powered off or reset while you are writing. If that happens, the write will
    be incomplete and your configuration data will be corrupted.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 闪存有许多问题。如前所述，第一个问题是必须擦除整个页面才能写入一个字。这需要时间来写入页面到闪存，并且在写入过程中系统可能会断电或重启。如果发生这种情况，写入将不完整，且你的配置数据将会损坏。
- en: A solution to this is to have two configuration sections, a primary and a backup,
    that each contain a checksum. The program first tries to read the primary configuration.
    If the checksum is bad, it reads the second. Because only one configuration is
    written at a time, you can be pretty sure that either the primary or the secondary
    is going to be correct.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此问题的方法是拥有两个配置区，一个主配置区和一个备份配置区，每个配置区都包含一个校验和。程序首先尝试读取主配置，如果校验和不正确，则读取第二个配置。因为每次只写入一个配置，所以你可以相当确定主配置或备份配置中的一个是正确的。
- en: Another problem with flash is that it suffers from *memory wear*. You can go
    through only so many program/erase cycles before the memory becomes corrupted.
    Depending on the type of flash being used, this can be between 100,000 and 1,000,000
    cycles. So, using the flash memory to store a configuration that is expected to
    change at the rate of once per month will work. Using it for something that will
    change several times a second will quickly wear out the memory.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个关于闪存的问题是，它存在*内存磨损*。你只能进行有限次数的编程/擦除周期，之后内存会变得损坏。根据使用的闪存类型，这个周期可以在100,000到1,000,000次之间。所以，使用闪存存储一个预期每月更改一次的配置是可以的。但如果用它来存储每秒更改几次的内容，闪存很快就会磨损。
- en: There are ways of programming around the limits of flash memory. You also can
    add external memory chips to your system that don’t have the design limitations
    of flash.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一些方法可以绕过闪存的限制进行编程。你还可以为你的系统添加外部内存芯片，这些芯片没有闪存的设计限制。
- en: Field Customization Example
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 现场定制示例
- en: 'Let’s say we work for a company that makes alarms. These alarms go out to alarm
    service companies who install them at end-user sites. Now, Joe’s Alarm Company
    and Bait Shop is not going to be happy if the alarm panel it installs shows an
    Acme Alarm Maker logo when it boots. Joe is into branding and wants his own logo
    to appear, which means we need to give customers a way of customizing the logos
    inside their boxes. We can reserve a section of memory for the logo:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在一家制造报警器的公司工作。这些报警器会发送给报警服务公司，由它们在最终用户的现场进行安装。现在，如果Joe的报警公司和钓具店安装的报警面板在启动时显示的是Acme报警制造商的标志，他会不高兴的。Joe注重品牌，他希望显示自己的标志，这意味着我们需要给客户提供一种定制标志的方法。我们可以为标志预留一块内存空间：
- en: '[PRE34]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now the question is, how do we get the logo into the system? We could program
    it at the factory, but that would mean every time we shipped a unit, someone would
    have to open the box, plug in the device, program the logo, and put it back in
    the box, which is an expensive operation.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在问题是，我们如何将标志导入系统？我们可以在工厂进行编程，但这意味着每次我们发货时，都需要有人打开盒子，插入设备，编程标志，然后再放回盒子里，这是一项昂贵的操作。
- en: Instead, we could let the customers do it themselves. We’d give them a cable
    and some software and let them program the logo. We can sell that ability as a
    feature that allows customers to update units with a new logo if needed.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们可以让客户自己做这件事。我们可以给他们一根电缆和一些软件，让他们自己编程设置标志。我们可以将这个功能作为一项特性来出售，允许客户在需要时更新设备的标志。
- en: The programming can be accomplished using the same hardware and software we
    use to load our code into flash, or we can write an onboard program that takes
    data off the serial line and programs it into the `LOGO` memory.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 编程可以通过我们用来将代码加载到闪存的相同硬件和软件来完成，或者我们可以编写一个板载程序，从串行线获取数据并将其编程到`LOGO`内存中。
- en: Replacing a logo is a simple customization to perform. Also, if the replacement
    is botched, a bad logo won’t stop the system. However, replacing the firmware
    is another matter.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 更换标志是一个简单的定制操作。而且，如果更换过程出错，坏的标志不会影响系统的正常运行。然而，更换固件则是另外一回事。
- en: Firmware Upgrade
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 固件升级
- en: 'Upgrading software while you are running that software is a bit tricky, but
    there are several ways to do it. One of the simplest is to divide up the flash
    memory into three sections:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行软件的同时升级软件是有点棘手的，但有几种方法可以做到这一点。最简单的方法之一是将闪存划分为三个部分：
- en: The bootloader
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引导加载程序
- en: Program section 1
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序部分 1
- en: Program section 2
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序部分 2
- en: The bootloader is a very small program that will never be upgraded. It has a
    rather simple job to do, so hopefully we’ll get it right the first time. The program
    sections contain a complete version of the program. They also contain a program
    version number and a checksum.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 引导加载程序是一个非常小的程序，永远不会被升级。它的工作相对简单，希望我们能第一次就做对。程序部分包含程序的完整版本，它们还包含程序版本号和校验和。
- en: 'The bootloader’s job is to decide which program section should be used. It
    verifies the checksum for the two sections and then decides which one to use based
    on the following calculation:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 引导加载程序的任务是决定应该使用哪个程序部分。它会验证两个部分的校验和，然后根据以下计算决定使用哪个部分：
- en: '[PRE35]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is the general idea, but we’ve skipped some bookkeeping steps. For example,
    the interrupt table in the `.isr_vector` section needs to be changed so that all
    interrupts go to the proper place.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这是总体思路，但我们跳过了一些记录步骤。例如，`.isr_vector`部分中的中断表需要进行修改，以确保所有的中断都能正确地指向相应的位置。
- en: Summary
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Memory is a limited resource, especially when you’re doing embedded programming.
    You need to know exactly where your memory is located and how to get the most
    out of it.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 内存是有限资源，尤其是在进行嵌入式编程时。你需要确切知道你的内存位置以及如何最大限度地利用它。
- en: The linker’s job is to take the pieces of your program, link them together,
    and produce a program that you can load into memory. For simple programs, the
    default configuration works well. However, as you get into more advanced systems,
    you’ll need to control more precisely exactly what’s being done with your limited
    memory resources, so understanding the linker is vital to being an effective embedded
    programmer.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 链接器的工作是将你的程序的各个部分连接起来，生成一个可以加载到内存中的程序。对于简单的程序，默认配置效果很好。然而，随着你深入更高级的系统，你将需要更精确地控制有限内存资源的使用，因此理解链接器对于成为一名有效的嵌入式程序员至关重要。
- en: Programming Problems
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程问题
- en: Modify the config program ([Listing 11-6](#listing11-6)) so that the `CONFIG`
    segment does not start on a page boundary. What happens?
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改配置程序（[Listing 11-6](#listing11-6)），使得`CONFIG`段不再从页面边界开始。会发生什么？
- en: Change the config program so that instead of printing a single-digit reset number,
    the program prints a complete number.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改配置程序，使其打印一个完整的数字，而不是打印一个单一的重置数字。
- en: The linker script defines a number of symbols to indicate the start and end
    of a memory area. Examine the linker script or linker map to find the symbols
    that define the start and end of the text area. Using these symbols, print the
    size of the text area. Use the `arm-none-eabi-size` command to verify your result.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链接器脚本定义了多个符号，用于指示内存区域的起始和结束。检查链接器脚本或链接器映射，以找到定义文本区域起始和结束的符号。使用这些符号，打印文本区域的大小。使用`arm-none-eabi-size`命令验证你的结果。
- en: Use the same techniques to print the amount of stack space allocated.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的技术打印分配的栈空间量。
- en: 'Advanced: Print the stack space left. This will require reading the current
    value of the stack register into a variable using the `asm` keyword.'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 高级：打印剩余的栈空间。这需要使用`asm`关键字将栈寄存器的当前值读取到变量中。
- en: 'Figuring out what’s in a binary file can be very useful, and the GNU toolchain
    has a number of programs to do so. Examine the documentation for the following
    commands:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 了解二进制文件中的内容非常有用，GNU工具链提供了多个程序来实现这一点。检查以下命令的文档：
- en: '`objdump`, which dumps object file information'
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`objdump`，用于转储目标文件信息'
- en: '`nm`, which lists the symbols in a file'
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`nm`，用于列出文件中的符号'
- en: '`ar`, which creates libraries or extracts information and files from them'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ar`，用于创建库或从中提取信息和文件'
- en: '`readelf`, which displays information on elf (program) files'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`readelf`，用于显示 elf（程序）文件的信息'
