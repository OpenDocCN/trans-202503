- en: '1'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '1'
- en: ANATOMY OF A BINARY
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制文件的构成
- en: Binary analysis is all about analyzing binaries. But what exactly is a binary?
    This chapter introduces you to the general anatomy of binary formats and the binary
    life cycle. After reading this chapter, you’ll be ready to tackle the next two
    chapters on ELF and PE binaries, two of the most widely used binary formats on
    Linux and Windows systems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制分析就是分析二进制文件。那么，究竟什么是二进制文件呢？本章将介绍二进制格式的基本构成以及二进制文件的生命周期。阅读本章后，你将为接下来的两章ELF和PE二进制文件的学习做好准备，ELF和PE是Linux和Windows系统中最广泛使用的二进制格式。
- en: Modern computers perform their computations using the binary numerical system,
    which expresses all numbers as strings of ones and zeros. The machine code that
    these systems execute is called *binary code*. Every program consists of a collection
    of binary code (the machine instructions) and data (variables, constants, and
    the like). To keep track of all the different programs on a given system, you
    need a way to store all the code and data belonging to each program in a single
    self-contained file. Because these files contain executable binary programs, they
    are called *binary executable files*, or simply *binaries*. Analyzing these binaries
    is the goal of this book.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现代计算机使用二进制数字系统进行计算，该系统将所有数字表示为一串一和零。计算机执行的机器代码被称为*二进制代码*。每个程序都由一组二进制代码（机器指令）和数据（变量、常量等）组成。为了跟踪系统中所有不同的程序，你需要一种方法来将每个程序的所有代码和数据存储在一个自包含的文件中。因为这些文件包含可执行的二进制程序，所以它们被称为*二进制可执行文件*，简称*二进制文件*。分析这些二进制文件是本书的目标。
- en: Before getting into the specifics of binary formats such as ELF and PE, let’s
    start with a high-level overview of how executable binaries are produced from
    source. After that, I’ll disassemble a sample binary to give you a solid idea
    of the code and data contained in binary files. You’ll use what you learn here
    to explore ELF and PE binaries in [Chapters 2](ch02.xhtml#ch02) and [3](ch03.xhtml#ch03),
    and you’ll build your own binary loader to parse binaries and open them up for
    analysis in [Chapter 4](ch04.xhtml#ch04).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨如ELF和PE这样的二进制格式之前，我们先来看看从源代码生成可执行二进制文件的高层次概述。之后，我将反汇编一个示例二进制文件，以便让你更清楚地了解二进制文件中包含的代码和数据。你将在这里学到的内容，用于在[第2章](ch02.xhtml#ch02)和[第3章](ch03.xhtml#ch03)中探索ELF和PE二进制文件，并且你将构建自己的二进制加载器，以解析二进制文件并在[第4章](ch04.xhtml#ch04)中进行分析。
- en: 1.1 The C Compilation Process
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1 C语言编译过程
- en: Binaries are produced through *compilation*, which is the process of translating
    human-readable source code, such as C or C++, into machine code that your processor
    can execute.^([1](footnote.xhtml#ch01fn_1)) [Figure 1-1](ch01.xhtml#ch01fig1)
    shows the steps involved in a typical compilation process for C code (the steps
    for C++ compilation are similar). Compiling C code involves four phases, one of
    which (awkwardly enough) is also called *compilation*, just like the full compilation
    process. The phases are *preprocessing*, *compilation*, *assembly*, and *linking*.
    In practice, modern compilers often merge some or all of these phases, but for
    demonstration purposes, I will cover them all separately.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制文件是通过*编译*生成的，编译是将人类可读的源代码（如C或C++）转换为处理器可以执行的机器代码的过程。^([1](footnote.xhtml#ch01fn_1))
    [图 1-1](ch01.xhtml#ch01fig1) 显示了典型C语言编译过程中的各个步骤（C++的编译步骤类似）。编译C语言代码涉及四个阶段，其中一个（很不巧的）也叫做*编译*，与完整的编译过程相同。这些阶段是*预处理*、*编译*、*汇编*和*链接*。实际上，现代编译器通常会合并这些阶段中的某些或所有阶段，但为了演示目的，我将分别介绍每个阶段。
- en: '![image](Images/f012-01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f012-01.jpg)'
- en: '*Figure 1-1: The C compilation process*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-1：C语言编译过程*'
- en: '*1.1.1 The Preprocessing Phase*'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*1.1.1 预处理阶段*'
- en: The compilation process starts with a number of source files that you want to
    compile (shown as *file-1.c* through *file-n.c* in [Figure 1-1](ch01.xhtml#ch01fig1)).
    It’s possible to have just one source file, but large programs are typically composed
    of many files. Not only does this make the project easier to manage, but it speeds
    up compilation because if one file changes, you only have to recompile that file
    rather than all of the code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 编译过程从你想要编译的一些源文件开始（如[图 1-1](ch01.xhtml#ch01fig1)中所示，*file-1.c* 到 *file-n.c*）。虽然可以只有一个源文件，但大型程序通常由多个文件组成。这不仅使项目更容易管理，还加速了编译过程，因为如果某个文件发生更改，你只需要重新编译该文件，而不是所有的代码。
- en: C source files contain macros (denoted by `#define`) and `#include` directives.
    You use the `#include` directives to include *header files* (with the extension
    *.h*) on which the source file depends. The preprocessing phase expands any `#define`
    and `#include` directives in the source file so all that’s left is pure C code
    ready to be compiled.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: C源文件包含宏（通过`#define`表示）和`#include`指令。你使用`#include`指令来包含源文件所依赖的*头文件*（扩展名为*.h*）。预处理阶段展开源文件中的所有`#define`和`#include`指令，结果就是纯粹的C代码，准备好被编译。
- en: Let’s make this more concrete by looking at an example. This example uses the
    `gcc` compiler, which is the default on many Linux distributions (including Ubuntu,
    the operating system installed on the virtual machine). The results for other
    compilers, such as `clang` or Visual Studio, would be similar. As mentioned in
    the Introduction, I’ll compile all code examples in this book (including the current
    example) into x86-64 code, except where stated otherwise.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来具体说明。这个例子使用了`gcc`编译器，它是许多Linux发行版（包括安装在虚拟机上的Ubuntu操作系统）的默认编译器。其他编译器，如`clang`或Visual
    Studio，的结果也会类似。如在引言中提到的，我将在本书中编译所有代码示例（包括当前示例）为x86-64代码，除非另有说明。
- en: Suppose you want to compile a C source file, as shown in [Listing 1-1](ch01.xhtml#ch01list1),
    that prints the ubiquitous “Hello, world!” message to the screen.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想编译一个C源文件，如[列表 1-1](ch01.xhtml#ch01list1)所示，目的是将无处不在的“Hello, world!”消息打印到屏幕上。
- en: '*Listing 1-1:* compilation_example.c'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 1-1：* compilation_example.c'
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In a moment, you’ll see what happens with this file in the rest of the compilation
    process, but for now, we’ll just consider the output of the preprocessing stage.
    By default, `gcc` will automatically execute all compilation phases, so you have
    to explicitly tell it to stop after preprocessing and show you the intermediate
    output. For `gcc`, this can be done using the command `gcc -E -P`, where `-E`
    tells `gcc` to stop after preprocessing and `-P` causes the compiler to omit debugging
    information so that the output is a bit cleaner. [Listing 1-2](ch01.xhtml#ch01list2)
    shows the output of the preprocessing stage, edited for brevity. Start the VM
    and follow along to see the full output of the preprocessor.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，你将看到这个文件在编译过程中接下来的变化，但现在我们先来看预处理阶段的输出。默认情况下，`gcc`会自动执行所有编译阶段，所以你需要明确告诉它在预处理之后停止，并显示中间输出。对于`gcc`，这可以通过命令`gcc
    -E -P`来实现，其中`-E`告诉`gcc`在预处理后停止，`-P`使编译器省略调试信息，以便输出更加简洁。[列表 1-2](ch01.xhtml#ch01list2)展示了预处理阶段的输出，已为简洁起见进行编辑。启动虚拟机并跟着操作，查看预处理器的完整输出。
- en: '*Listing 1-2: Output of the C preprocessor for the “Hello, world!” program*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 1-2：C预处理器输出的“Hello, world!”程序*'
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The *stdio.h* header is included in its entirety, with all of its type definitions,
    global variables, and function prototypes “copied in” to the source file. Because
    this happens for every `#include` directive, preprocessor output can be quite
    verbose. The preprocessor also fully expands all uses of any macros you defined
    using `#define`. In the example, this means both arguments to `printf` (`FORMAT_STRING`
    ➊ and `MESSAGE` ➋) are evaluated and replaced by the constant strings they represent.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*stdio.h*头文件被完整地包含进来，其中的所有类型定义、全局变量和函数原型都被“复制”到源文件中。由于每个`#include`指令都会发生这种情况，预处理器的输出可能会相当冗长。预处理器还会完全展开你通过`#define`定义的所有宏。在这个例子中，这意味着`printf`的两个参数（`FORMAT_STRING`
    ➊ 和 `MESSAGE` ➋）都会被评估并替换为它们所代表的常量字符串。'
- en: '*1.1.2 The Compilation Phase*'
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*1.1.2 编译阶段*'
- en: After the preprocessing phase is complete, the source is ready to be compiled.
    The compilation phase takes the preprocessed code and translates it into assembly
    language. (Most compilers also perform heavy optimization in this phase, typically
    configurable as an *optimization level* through command line switches such as
    options `-O0` through `-O3` in `gcc`. As you’ll see in [Chapter 6](ch06.xhtml#ch06),
    the degree of optimization during compilation can have a profound effect on disassembly.)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理阶段完成后，源代码就可以进入编译阶段。编译阶段将预处理后的代码翻译成汇编语言。（大多数编译器在此阶段还会进行大量优化，通常可以通过命令行选项如`-O0`至`-O3`在`gcc`中配置为*优化级别*。正如你在[第6章](ch06.xhtml#ch06)中看到的，编译过程中的优化程度对反汇编有着深远的影响。）
- en: Why does the compilation phase produce assembly language and not machine code?
    This design decision doesn’t seem to make sense in the context of just one language
    (in this case, C), but it does when you think about all the other languages out
    there. Some examples of popular compiled languages include C, C++, Objective-C,
    Common Lisp, Delphi, Go, and Haskell, to name a few. Writing a compiler that directly
    emits machine code for each of these languages would be an extremely demanding
    and time-consuming task. It’s better to instead emit assembly code (a task that
    is already challenging enough) and have a single dedicated assembler that can
    handle the final translation of assembly to machine code for every language.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么编译阶段会生成汇编语言而不是机器代码？这个设计决策在单一语言的上下文中似乎没有意义（以 C 语言为例），但当你考虑到其他所有语言时，它是合理的。一些流行的编译语言包括
    C、C++、Objective-C、Common Lisp、Delphi、Go 和 Haskell，仅举几例。为每种语言编写一个直接生成机器代码的编译器将是一个极为繁重且耗时的任务。与其这样，不如生成汇编代码（这已经是一个足够具挑战性的任务），然后有一个专门的汇编器来处理每种语言的汇编到机器代码的最终转换。
- en: So, the output of the compilation phase is assembly, in reasonably human-readable
    form, with symbolic information intact. As mentioned, `gcc` normally calls all
    compilation phases automatically, so to see the emitted assembly from the compilation
    stage, you have to tell `gcc` to stop after this stage and store the assembly
    files to disk. You can do this using the `-S` flag (*.s* is a conventional extension
    for assembly files). You also pass the option `-masm=intel` to `gcc` so that it
    emits assembly in Intel syntax rather than the default AT&T syntax. [Listing 1-3](ch01.xhtml#ch01list3)
    shows the output of the compilation phase for the example program.^([2](footnote.xhtml#ch01fn_2))
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，编译阶段的输出是汇编语言，形式相对人类可读，符号信息保持完整。如前所述，`gcc` 通常会自动调用所有编译阶段，因此，要查看编译阶段生成的汇编代码，你需要告诉`gcc`在此阶段停止并将汇编文件存储到磁盘。你可以通过使用`-S`标志来实现（*.s*
    是汇编文件的常规扩展名）。你还需要传递选项`-masm=intel`给`gcc`，这样它会以 Intel 语法而不是默认的 AT&T 语法生成汇编代码。[列表
    1-3](ch01.xhtml#ch01list3)展示了编译阶段为示例程序生成的输出。^([2](footnote.xhtml#ch01fn_2))
- en: '*Listing 1-3: Assembly generated by the compilation phase for the “Hello, world!”
    program*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 1-3：编译阶段为“Hello, world!”程序生成的汇编代码*'
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For now, I won’t go into detail about the assembly code. What’s interesting
    to note in [Listing 1-3](ch01.xhtml#ch01list3) is that the assembly code is relatively
    easy to read because the symbols and functions have been preserved. For instance,
    constants and variables have symbolic names rather than just addresses (even if
    it’s just an automatically generated name, such as `LC0` ➊ for the nameless “Hello,
    world!” string), and there’s an explicit label for the `main` function ➋ (the
    only function in this case). Any references to code and data are also symbolic,
    such as the reference to the “Hello, world!” string ➌. You’ll have no such luxury
    when dealing with stripped binaries later in the book!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我不会深入讨论汇编代码。在[列表 1-3](ch01.xhtml#ch01list3)中值得注意的是，汇编代码相对容易阅读，因为符号和函数被保留了。例如，常量和变量有符号名称，而不仅仅是地址（即使它只是一个自动生成的名称，如“Hello,
    world!”字符串的`LC0` ➊），并且有一个明确的标签标记`main`函数 ➋（在这个例子中是唯一的函数）。任何对代码和数据的引用也是符号化的，比如对“Hello,
    world!”字符串的引用 ➌。在本书后面处理剥离的二进制文件时，你就无法享受到这样的便利了！
- en: '*1.1.3 The Assembly Phase*'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*1.1.3 汇编阶段*'
- en: In the assembly phase, you finally get to generate some real machine code! The
    input of the assembly phase is the set of assembly language files generated in
    the compilation phase, and the output is a set of *object files*, sometimes also
    referred to as *modules*. Object files contain machine instructions that are in
    principle executable by the processor. But as I’ll explain in a minute, you need
    to do some more work before you have a ready-torun binary executable file. Typically,
    each source file corresponds to one assembly file, and each assembly file corresponds
    to one object file. To generate an object file, you pass the `-c` flag to `gcc`,
    as shown in [Listing 1-4](ch01.xhtml#ch01list4).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编阶段，你终于可以生成一些真正的机器代码了！汇编阶段的输入是编译阶段生成的一组汇编语言文件，输出是一组*目标文件*，有时也称为*模块*。目标文件包含的机器指令原则上是可以由处理器执行的。但正如我接下来会解释的，你还需要做一些工作才能得到一个可以运行的二进制可执行文件。通常，每个源文件对应一个汇编文件，每个汇编文件对应一个目标文件。要生成目标文件，你需要给`gcc`传递`-c`标志，如[列表
    1-4](ch01.xhtml#ch01list4)所示。
- en: '*Listing 1-4: Generating an object file with* `*gcc*`'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 1-4：使用* `*gcc*` 生成目标文件'
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can use the `file` utility (a handy utility that I’ll return to in [Chapter
    5](ch05.xhtml#ch05)) to confirm that the produced file, *compilation_example.o*,
    is indeed an object file. As you can see in [Listing 1-4](ch01.xhtml#ch01list4),
    this is the case: the file shows up as an `ELF 64-bit LSB relocatable` file.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`file`工具（这是一个非常方便的工具，我将在[第5章](ch05.xhtml#ch05)中再次提到）来确认生成的文件，*compilation_example.o*，确实是一个目标文件。正如你在[清单
    1-4](ch01.xhtml#ch01list4)中看到的那样，情况确实如此：该文件显示为`ELF 64-bit LSB 可重定位`文件。
- en: What exactly does this mean? The first part of the `file` output shows that
    the file conforms to the ELF specification for binary executables (which I’ll
    discuss in detail in [Chapter 2](ch02.xhtml#ch02)). More specifically, it’s a
    64-bit ELF file (since you’re compiling for x86-64 in this example), and it is
    *LSB*, meaning that numbers are ordered in memory with their least significant
    byte first. But most important, you can see that the file is *relocatable*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这到底意味着什么呢？`file`输出的第一部分显示该文件符合二进制可执行文件的ELF规范（我将在[第2章](ch02.xhtml#ch02)中详细讨论）。更具体地说，它是一个64位ELF文件（因为你在这个示例中为x86-64进行编译），并且它是*LSB*，意味着数字在内存中的顺序是以最不重要的字节为先。但最重要的是，你可以看到该文件是*可重定位的*。
- en: Relocatable files don’t rely on being placed at any particular address in memory;
    rather, they can be moved around at will without this breaking any assumptions
    in the code. When you see the term *relocatable* in the `file` output, you know
    you’re dealing with an object file and not with an executable.^([3](footnote.xhtml#ch01fn_3))
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 可重定位文件不依赖于被放置在内存中的特定地址；相反，它们可以随意移动而不破坏代码中的任何假设。当你在`file`输出中看到*可重定位*这个术语时，你就知道你正在处理的是目标文件，而不是可执行文件。^([3](footnote.xhtml#ch01fn_3))
- en: Object files are compiled independently from each other, so the assembler has
    no way of knowing the memory addresses of other object files when assembling an
    object file. That’s why object files need to be relocatable; that way, you can
    link them together in any order to form a complete binary executable. If object
    files were not relocatable, this would not be possible.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 目标文件是相互独立编译的，因此在汇编目标文件时，汇编器无法知道其他目标文件的内存地址。这就是为什么目标文件需要是可重定位的；这样，你可以将它们以任何顺序链接在一起，形成一个完整的二进制可执行文件。如果目标文件不可重定位，这将无法实现。
- en: You’ll see the contents of the object file later in this chapter, when you’re
    ready to disassemble a file for the first time.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备好第一次拆解文件时，稍后在本章中你将看到目标文件的内容。
- en: '*1.1.4 The Linking Phase*'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*1.1.4 链接阶段*'
- en: The linking phase is the final phase of the compilation process. As the name
    implies, this phase links together all the object files into a single binary executable.
    In modern systems, the linking phase sometimes incorporates an additional optimization
    pass, called *link-time optimization (LTO)*.^([4](footnote.xhtml#ch01fn_4))
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 链接阶段是编译过程的最后阶段。顾名思义，这一阶段将所有目标文件链接成一个单一的二进制可执行文件。在现代系统中，链接阶段有时会加入一个额外的优化过程，称为*链接时优化（LTO）*。^([4](footnote.xhtml#ch01fn_4))
- en: Unsurprisingly, the program that performs the linking phase is called a *linker*,
    or *link editor*. It’s typically separate from the compiler, which usually implements
    all the preceding phases.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 不出所料，执行链接阶段的程序被称为*链接器*，或*链接编辑器*。它通常与编译器分开，编译器通常实现所有之前的阶段。
- en: As I’ve already mentioned, object files are relocatable because they are compiled
    independently from each other, preventing the compiler from assuming that an object
    will end up at any particular base address. Moreover, object files may reference
    functions or variables in other object files or in libraries that are external
    to the program. Before the linking phase, the addresses at which the referenced
    code and data will be placed are not yet known, so the object files only contain
    *relocation symbols* that specify how function and variable references should
    eventually be resolved. In the context of linking, references that rely on a relocation
    symbol are called *symbolic references*. When an object file references one of
    its own functions or variables by absolute address, the reference will also be
    symbolic.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，目标文件是可重定位的，因为它们是独立编译的，防止了编译器假设某个目标会位于特定的基地址。此外，目标文件可能引用其他目标文件或程序外部库中的函数或变量。在链接阶段之前，引用的代码和数据将被放置的地址尚未确定，因此目标文件只包含*重定位符号*，这些符号指定了函数和变量引用应如何最终解析。在链接的上下文中，依赖于重定位符号的引用称为*符号引用*。当目标文件通过绝对地址引用其自身的函数或变量时，该引用也将是符号引用。
- en: The linker’s job is to take all the object files belonging to a program and
    merge them into a single coherent executable, typically intended to be loaded
    at a particular memory address. Now that the arrangement of all modules in the
    executable is known, the linker can also resolve most symbolic references. References
    to libraries may or may not be completely resolved, depending on the type of library.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 链接器的工作是将属于一个程序的所有目标文件合并为一个单一的连贯可执行文件，通常是打算加载到特定内存地址的。现在，所有模块在可执行文件中的安排已知，链接器还可以解决大多数符号引用。对于库的引用，可能完全解决，也可能没有完全解决，这取决于库的类型。
- en: Static libraries (which on Linux typically have the extension *.a*, as shown
    in [Figure 1-1](ch01.xhtml#ch01fig1)) are merged into the binary executable, allowing
    any references to them to be resolved entirely. There are also dynamic (shared)
    libraries, which are shared in memory among all programs that run on a system.
    In other words, rather than copying the library into every binary that uses it,
    dynamic libraries are loaded into memory only once, and any binary that wants
    to use the library needs to use this shared copy. During the linking phase, the
    addresses at which dynamic libraries will reside are not yet known, so references
    to them cannot be resolved. Instead, the linker leaves symbolic references to
    these libraries even in the final executable, and these references are not resolved
    until the binary is actually loaded into memory to be executed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 静态库（在 Linux 上通常扩展名为 *.a*，如[图 1-1](ch01.xhtml#ch01fig1)所示）被合并到二进制可执行文件中，这样对它们的所有引用都可以完全解决。还有动态（共享）库，它们在内存中由所有在系统上运行的程序共享。换句话说，动态库不会被复制到每个使用它的二进制文件中，而是只加载一次到内存中，任何想要使用该库的二进制文件都需要使用这个共享副本。在链接阶段，动态库将驻留的地址尚未确定，因此无法解决对它们的引用。相反，链接器会在最终可执行文件中保留这些库的符号引用，这些引用直到二进制文件实际加载到内存并执行时才会被解决。
- en: Most compilers, including `gcc`, automatically call the linker at the end of
    the compilation process. Thus, to produce a complete binary executable, you can
    simply call `gcc` without any special switches, as shown in [Listing 1-5](ch01.xhtml#ch01list5).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编译器，包括 `gcc`，在编译过程结束时会自动调用链接器。因此，要生成一个完整的二进制可执行文件，你可以直接调用 `gcc` 而无需任何特殊选项，如[示例
    1-5](ch01.xhtml#ch01list5)所示。
- en: '*Listing 1-5: Generating a binary executable with* `*gcc*`'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 1-5: 使用* `*gcc*` *生成二进制可执行文件*'
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: By default, the executable is called *a.out*, but you can override this naming
    by passing the `-o` switch to `gcc`, followed by a name for the output file. The
    `file` utility now tells you that you’re dealing with an `ELF 64-bit LSB executable`
    ➊, rather than a relocatable file as you saw at the end of the assembly phase.
    Other important information is that the file is dynamically linked ➋, meaning
    that it uses some libraries that are not merged into the executable but are instead
    shared among all programs running on the same system. Finally, `interpreter /lib64/ld-linux-x86-64.so.2`
    ➌ in the `file` output tells you which *dynamic linker* will be used to resolve
    the final dependencies on dynamic libraries when the executable is loaded into
    memory to be executed. When you run the binary (using the command `./a.out`),
    you can see that it produces the expected output (printing “Hello, world!” to
    standard output), which confirms that you have produced a working binary.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，可执行文件名为 *a.out*，但是你可以通过向 `gcc` 传递 `-o` 参数并指定输出文件的名称来覆盖该名称。`file` 工具现在告诉你，你正在处理的是一个
    `ELF 64-bit LSB 可执行文件` ➊，而不是在汇编阶段末尾看到的可重定位文件。其他重要信息是文件是动态链接的 ➋，这意味着它使用一些未合并到可执行文件中的库，而是与所有在同一系统上运行的程序共享。最后，`file`
    输出中的 `interpreter /lib64/ld-linux-x86-64.so.2` ➌ 告诉你，当可执行文件加载到内存并执行时，将使用哪个 *动态链接器*
    来解析对动态库的最终依赖关系。当你运行这个二进制文件（使用命令 `./a.out`）时，可以看到它产生了预期的输出（将“Hello, world!”打印到标准输出），这确认你已经生成了一个有效的二进制文件。
- en: But what’s this bit about the binary not being “stripped” ➍? I’ll discuss that
    next!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这个二进制文件没有被“去除符号” ➍ 是什么意思呢？我接下来会讨论这个问题！
- en: 1.2 Symbols and Stripped Binaries
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2 符号与去除符号的二进制文件
- en: High-level source code, such as C code, centers around functions and variables
    with meaningful, human-readable names. When compiling a program, compilers emit
    *symbols*, which keep track of such symbolic names and record which binary code
    and data correspond to each symbol. For instance, function symbols provide a mapping
    from symbolic, high-level function names to the first address and the size of
    each function. This information is normally used by the linker when combining
    object files (for instance, to resolve function and variable references between
    modules) and also aids debugging.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 高级源代码，如 C 代码，围绕着具有有意义、可读名称的函数和变量展开。当编译一个程序时，编译器会生成*符号*，这些符号用于追踪这些符号名称，并记录每个符号对应的二进制代码和数据。例如，函数符号提供了从符号化的高级函数名称到每个函数的起始地址和大小的映射。这些信息通常由链接器在合并目标文件时使用（例如，解决模块间的函数和变量引用），并且对调试也有帮助。
- en: '*1.2.1 Viewing Symbolic Information*'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*1.2.1 查看符号信息*'
- en: To give you an idea of what the symbolic information looks like, [Listing 1-6](ch01.xhtml#ch01list6)
    shows some of the symbols in the example binary.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你了解符号信息的样子，[列表 1-6](ch01.xhtml#ch01list6)展示了示例二进制文件中的一些符号。
- en: '*Listing 1-6: Symbols in the* `*a.out*` *binary as shown by* `*readelf*`'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 1-6：*`*a.out*` *二进制文件中的符号，如通过*`*readelf*`*所示*'
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In [Listing 1-6](ch01.xhtml#ch01list6), I’ve used `readelf` to display the symbols
    ➊. You’ll return to using the `readelf` utility, and interpreting all its output,
    in [Chapter 5](ch05.xhtml#ch05). For now, just note that, among many unfamiliar
    symbols, there’s a symbol for the `main` function ➋. You can see that it specifies
    the address (`0x400526`) at which `main` will reside when the binary is loaded
    into memory. The output also shows the code size of `main` (32 bytes) and indicates
    that you’re dealing with a function symbol (type `FUNC`).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 1-6](ch01.xhtml#ch01list6)中，我使用`readelf`来显示符号➊。你将会继续使用`readelf`工具，并解释其所有输出内容，具体内容在[第
    5 章](ch05.xhtml#ch05)中讨论。现在，你只需要注意，在许多不熟悉的符号中，存在一个`main`函数的符号➋。你可以看到它指定了`main`在二进制加载到内存时所驻留的地址（`0x400526`）。输出还显示了`main`的代码大小（32
    字节），并且表明它是一个函数符号（类型为`FUNC`）。
- en: Symbolic information can be emitted as part of the binary (as you’ve seen just
    now) or in the form of a separate symbol file, and it comes in various flavors.
    The linker needs only basic symbols, but far more extensive information can be
    emitted for debugging purposes. Debugging symbols go as far as providing a full
    mapping between source lines and binary-level instructions, and they even describe
    function parameters, stack frame information, and more. For ELF binaries, debugging
    symbols are typically generated in the DWARF format,^([5](footnote.xhtml#ch01fn_5))
    while PE binaries usually use the proprietary Microsoft Portable Debugging (PDB)
    format.^([6](footnote.xhtml#ch01fn_6)) DWARF information is usually embedded within
    the binary, while PDB comes in the form of a separate symbol file.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 符号信息可以作为二进制文件的一部分（如你刚刚看到的那样）或以单独的符号文件形式存在，并且有多种不同的格式。链接器只需要基本符号，但为了调试的目的，可能会生成更多的扩展信息。调试符号提供了源代码行和二进制指令之间的完整映射，甚至描述了函数参数、栈帧信息等。对于
    ELF 二进制文件，调试符号通常以 DWARF 格式生成^([5](footnote.xhtml#ch01fn_5))，而 PE 二进制文件通常使用专有的
    Microsoft Portable Debugging (PDB) 格式^([6](footnote.xhtml#ch01fn_6))。DWARF 信息通常嵌入在二进制文件中，而
    PDB 以单独的符号文件形式存在。
- en: As you might imagine, symbolic information is extremely useful for binary analysis.
    To name just one example, having a set of well-defined function symbols at your
    disposal makes disassembly much easier because you can use each function symbol
    as a starting point for disassembly. This makes it much less likely that you’ll
    accidentally disassemble data as code, for instance (which would lead to bogus
    instructions in the disassembly output). Knowing which parts of a binary belong
    to which function, and what the function is called, also makes it much easier
    for a human reverse engineer to compartmentalize and understand what the code
    is doing. Even just basic linker symbols (as opposed to more extensive debugging
    information) are already a tremendous help in many binary analysis applications.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所料，符号信息对于二进制分析非常有用。仅举一个例子，拥有一套明确定义的函数符号可以大大简化反汇编过程，因为你可以将每个函数符号作为反汇编的起点。这使得你不太可能错误地将数据当作代码反汇编（这将导致反汇编输出中出现虚假的指令）。知道二进制文件中哪些部分属于哪个函数，以及函数的名称，也能帮助逆向工程师更容易地对代码进行分块，从而理解代码的功能。即使是基本的链接器符号（与更详细的调试信息相比）在许多二进制分析应用中也已足够有用。
- en: You can parse symbols with `readelf`, as I mentioned above, or programmatically
    with a library like `libbfd`, as I’ll explain in [Chapter 4](ch04.xhtml#ch04).
    There are also libraries like `libdwarf` specifically designed for parsing DWARF
    debug symbols, but I won’t cover them in this book.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，你可以使用`readelf`来解析符号，或者像`libbfd`这样的库进行编程解析，后者我将在[Chapter 4](ch04.xhtml#ch04)中解释。此外，还有专门用于解析DWARF调试符号的库，如`libdwarf`，但在本书中我不会涉及这些。
- en: Unfortunately, extensive debugging information typically isn’t included in production-ready
    binaries, and even basic symbolic information is often stripped to reduce file
    sizes and prevent reverse engineering, especially in the case of malware or proprietary
    software. This means that as a binary analyst, you often have to deal with the
    far more challenging case of stripped binaries without any form of symbolic information.
    Throughout this book, I therefore assume as little symbolic information as feasible
    and focus on stripped binaries, except where noted otherwise.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，生产环境中的二进制文件通常不包含大量的调试信息，甚至基本的符号信息也经常会被去除，以减少文件大小并防止逆向工程，特别是在恶意软件或专有软件的情况下。这意味着，作为二进制分析师，你通常需要处理没有任何符号信息的被去除符号的二进制文件的更具挑战性的情况。因此，在本书中，我假设尽可能少的符号信息，并专注于去除符号的二进制文件，除非另有说明。
- en: '*1.2.2 Another Binary Turns to the Dark Side: Stripping a Binary*'
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*1.2.2 另一个二进制文件走向黑暗面：去除二进制文件的符号信息*'
- en: You may remember that the example binary is not yet stripped (as shown in the
    output from the `file` utility in [Listing 1-5](ch01.xhtml#ch01list5)). Apparently,
    the default behavior of `gcc` is not to automatically strip newly compiled binaries.
    In case you’re wondering how binaries with symbols end up stripped, it’s as simple
    as using a single command, aptly named `strip`, as shown in [Listing 1-7](ch01.xhtml#ch01list7).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，示例二进制文件还没有被去除符号信息（如[Listing 1-5](ch01.xhtml#ch01list5)中的`file`工具输出所示）。显然，`gcc`的默认行为是不会自动去除新编译二进制文件的符号。如果你在想如何去除带符号的二进制文件，操作其实很简单，只需使用一个名为`strip`的命令，如[Listing
    1-7](ch01.xhtml#ch01list7)所示。
- en: '*Listing 1-7: Stripping an executable*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 1-7: 去除可执行文件的符号信息*'
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Just like that, the example binary is now stripped ➊, as confirmed by the `file`
    output ➋. Only a few symbols are left in the `.dynsym` symbol table ➌. These are
    used to resolve dynamic dependencies (such as references to dynamic libraries)
    when the binary is loaded into memory, but they’re not much use when disassembling.
    All the other symbols, including the one for the `main` function that you saw
    in [Listing 1-6](ch01.xhtml#ch01list6), have disappeared.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，示例二进制文件已经被去除符号信息 ➊，如`file`输出 ➋所确认。只有少数符号保留在`.dynsym`符号表中 ➌。这些符号用于在二进制文件加载到内存时解析动态依赖（例如动态库的引用），但在反汇编时作用不大。所有其他符号，包括在[Listing
    1-6](ch01.xhtml#ch01list6)中看到的`main`函数符号，已经消失。
- en: 1.3 Disassembling a Binary
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3 反汇编二进制文件
- en: Now that you’ve seen how to compile a binary, let’s take a look at the contents
    of the object file produced in the assembly phase of compilation. After that,
    I’ll disassemble the main binary executable to show you how its contents differ
    from those of the object file. This way, you’ll get a clearer understanding of
    what’s in an object file and what’s added during the linking phase.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何编译一个二进制文件，让我们来看一下在编译阶段汇编生成的目标文件内容。之后，我将反汇编主二进制可执行文件，向你展示它的内容与目标文件的不同之处。通过这种方式，你将更清楚地了解目标文件中包含了什么，以及在链接阶段添加了什么内容。
- en: '*1.3.1 Looking Inside an Object File*'
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*1.3.1 查看目标文件内部*'
- en: For now, I’ll use the `objdump` utility to show how to do all the disassembling
    (I’ll discuss other disassembly tools in [Chapter 6](ch06.xhtml#ch06)). It’s a
    simple, easy-to-use disassembler included with most Linux distributions, and it’s
    perfect to get a quick idea of the code and data contained in a binary. [Listing
    1-8](ch01.xhtml#ch01list8) shows the disassembled version of the example object
    file, *compilation_example.o*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我将使用`objdump`工具来展示如何进行反汇编（我将在[第六章](ch06.xhtml#ch06)讨论其他反汇编工具）。这是一个简单且易于使用的反汇编工具，通常包含在大多数Linux发行版中，非常适合快速了解二进制文件中包含的代码和数据。[清单1-8](ch01.xhtml#ch01list8)展示了示例目标文件*compilation_example.o*的反汇编版本。
- en: '*Listing 1-8: Disassembling an object file*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单1-8：反汇编目标文件*'
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you look carefully at [Listing 1-8](ch01.xhtml#ch01list8), you’ll see I’ve
    called `objdump` twice. First, at ➊, I tell `objdump` to show the contents of
    the `.rodata` section. This stands for “read-only data,” and it’s the part of
    the binary where all constants are stored, including the “Hello, world!” string.
    I’ll return to a more detailed discussion of `.rodata` and other sections in ELF
    binaries in [Chapter 2](ch02.xhtml#ch02), which covers the ELF binary format.
    For now, notice that the contents of `.rodata` consist of an ASCII encoding of
    the string, shown on the left side of the output. On the right side, you can see
    the human-readable representation of those same bytes.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果仔细查看[清单1-8](ch01.xhtml#ch01list8)，你会看到我调用了两次`objdump`。第一次，在➊处，我让`objdump`显示`.rodata`段的内容。`.rodata`表示“只读数据”，它是二进制文件中存储所有常量的部分，包括“Hello,
    world!”字符串。我将在[第二章](ch02.xhtml#ch02)中对`.rodata`和其他ELF二进制段进行更详细的讨论，该章介绍了ELF二进制格式。现在请注意，`.rodata`的内容由字符串的ASCII编码组成，显示在输出的左侧。右侧则是这些字节的可读表示。
- en: The second call to `objdump` at ➋ disassembles all the code in the object file
    in Intel syntax. As you can see, it contains only the code of the `main` function
    ➌ because that’s the only function defined in the source file. For the most part,
    the output conforms pretty closely to the assembly code previously produced by
    the compilation phase (give or take a few assembly-level macros). What’s interesting
    to note is that the pointer to the “Hello, world!” string (at ➍) is set to zero.
    The subsequent call ➎ that should print the string to the screen using `puts`
    also points to a nonsensical location (offset 19, in the middle of `main`).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在➋处对`objdump`的第二次调用反汇编了目标文件中的所有代码，使用了Intel语法。正如你所看到的，它仅包含`main`函数的代码➌，因为这是源文件中唯一定义的函数。在大多数情况下，输出与之前编译阶段生成的汇编代码非常接近（略有一些汇编级别的宏）。有趣的是，指向“Hello,
    world!”字符串的指针（在➍处）被设置为零。随后，应该使用`puts`打印该字符串的调用➎也指向了一个无意义的位置（偏移量19，在`main`中间）。
- en: Why does the call that should reference `puts` point instead into the middle
    of `main`? I previously mentioned that data and code references from object files
    are not yet fully resolved because the compiler doesn’t know at what base address
    the file will eventually be loaded. That’s why the call to `puts` is not yet correctly
    resolved in the object file. The object file is waiting for the linker to fill
    in the correct value for this reference. You can confirm this by asking `readelf`
    to show you all the relocation symbols present in the object file, as shown in
    [Listing 1-9](ch01.xhtml#ch01list9).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么应该引用`puts`的调用反而指向了`main`的中间？我之前提到过，目标文件中的数据和代码引用尚未完全解析，因为编译器还不知道文件最终将被加载到哪个基地址。这就是为什么在目标文件中`puts`的调用尚未正确解析的原因。目标文件正在等待链接器填入此引用的正确值。你可以通过请求`readelf`显示目标文件中所有的重定位符号来确认这一点，如[清单1-9](ch01.xhtml#ch01list9)所示。
- en: '*Listing 1-9: Relocation symbols as shown by* `*readelf*`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单1-9：* `*readelf*`显示的重定位符号'
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The relocation symbol at ➊ tells the linker that it should resolve the reference
    to the string to point to whatever address it ends up at in the `.rodata` section.
    Similarly, the line marked ➋ tells the linker how to resolve the call to `puts`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ➊处的重定位符号告诉链接器，它应该解析字符串的引用，指向它最终在`.rodata`段中的地址。类似地，标记为➋的行告诉链接器如何解析对`puts`的调用。
- en: You may notice the value 4 being subtracted from the `puts` symbol. You can
    ignore that for now; the way the linker computes relocations is a bit involved,
    and the `readelf` output can be confusing, so I’ll just gloss over the details
    of relocation here and focus on the bigger picture of disassembling a binary instead.
    I’ll provide more information about relocation symbols in [Chapter 2](ch02.xhtml#ch02).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到从`puts`符号中减去了值4。你现在可以忽略这一点；链接器计算重定位的方式有些复杂，而`readelf`的输出可能令人困惑，所以我这里就不详细讲解重定位的细节，而是集中讲解反汇编二进制文件的整体过程。我将在[第2章](ch02.xhtml#ch02)提供更多关于重定位符号的信息。
- en: The leftmost column of each line in the `readelf` output (shaded) in [Listing
    1-9](ch01.xhtml#ch01list9) is the offset in the object file where the resolved
    reference must be filled in. If you’re paying close attention, you may have noticed
    that in both cases, it’s equal to the offset of the instruction that needs to
    be fixed, plus 1\. For instance, the call to `puts` is at code offset `0x14` in
    the `objdump` output, but the relocation symbol points to offset `0x15` instead.
    This is because you only want to overwrite the *operand* of the instruction, not
    the *opcode* of the instruction. It just so happens that for both instructions
    that need fixing up, the opcode is 1 byte long, so to point to the instruction’s
    operand, the relocation symbol needs to skip past the opcode byte.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 1-9](ch01.xhtml#ch01list9)中的`readelf`输出中，每行最左侧的列（阴影部分）是目标文件中需要填充解析引用的偏移地址。如果你仔细观察，你可能已经注意到，在两种情况下，它等于需要修复的指令的偏移量加1。例如，在`objdump`的输出中，调用`puts`的代码偏移量是`0x14`，但重定位符号指向的偏移量却是`0x15`。这是因为你只想覆盖指令的*操作数*，而不是*操作码*。恰巧的是，对于需要修复的两条指令，操作码是1字节长的，因此，为了指向指令的操作数，重定位符号需要跳过操作码字节。
- en: '*1.3.2 Examining a Complete Binary Executable*'
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*1.3.2 检查完整的二进制可执行文件*'
- en: Now that you’ve seen the innards of an object file, it’s time to disassemble
    a complete binary. Let’s start with an example binary with symbols and then move
    on to the stripped equivalent to see the difference in disassembly output. There
    is a big difference between disassembling an object file and a binary executable,
    as you can see in the `objdump` output in [Listing 1-10](ch01.xhtml#ch01list10).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经看过目标文件的内部结构，现在是时候反汇编一个完整的二进制文件了。我们先从一个带符号的二进制文件开始，然后再处理去符号化的版本，看看反汇编输出的差异。反汇编目标文件和二进制可执行文件之间有很大的区别，你可以在[清单
    1-10](ch01.xhtml#ch01list10)中的`objdump`输出中看到这一点。
- en: '*Listing 1-10: Disassembling an executable with* `*objdump*`'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-10：使用* `*objdump*` 反汇编可执行文件*'
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can see that the binary has a lot more code than the object file. It’s no
    longer just the `main` function or even just a single code section. There are
    multiple sections now, with names like `.init` ➊, `.plt` ➋, and `.text` ➌. These
    sections all contain code serving different functions, such as program initialization
    or stubs for calling shared libraries.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，二进制文件的代码比目标文件多得多。它不再仅仅是`main`函数，甚至不仅仅是一个代码段。现在有多个段，名称包括`.init` ➊、`.plt`
    ➋ 和 `.text` ➌。这些段包含了执行不同功能的代码，如程序初始化或调用共享库的存根。
- en: The `.text` section is the main code section, and it contains the `main` function
    ➍. It also contains a number of other functions, such as `_start`, that are responsible
    for tasks such as setting up the command line arguments and runtime environment
    for `main` and cleaning up after `main`. These extra functions are standard functions,
    present in any ELF binary produced by `gcc`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`.text`段是主要的代码段，包含了`main`函数 ➍。它还包含了其他一些函数，如`_start`，这些函数负责设置命令行参数和为`main`准备运行时环境，并在`main`执行完后进行清理。这些额外的函数是标准函数，在任何由`gcc`生成的ELF二进制文件中都存在。'
- en: You can also see that the previously incomplete code and data references have
    now been resolved by the linker. For instance, the call to `puts` ➎ now points
    to the proper stub (in the `.plt` section) for the shared library that contains
    `puts`. (I’ll explain the workings of PLT stubs in [Chapter 2](ch02.xhtml#ch02).)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以看到，之前未完成的代码和数据引用现在已经被链接器解析了。例如，调用 `puts` ➎ 现在指向了包含 `puts` 的共享库的正确存根（位于 `.plt`
    部分）。(我将在[第 2 章](ch02.xhtml#ch02)中解释 PLT 存根的工作原理。)
- en: So, the full binary executable contains significantly more code (and data, though
    I haven’t shown it) than the corresponding object file. But so far, the output
    isn’t much more difficult to interpret. That changes when the binary is stripped,
    as shown in [Listing 1-11](ch01.xhtml#ch01list11), which uses `objdump` to disassemble
    the stripped version of the example binary.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，完整的二进制可执行文件包含了比相应的目标文件显著更多的代码（和数据，尽管我没有展示）。但到目前为止，输出的解释并没有更加困难。当二进制文件被去除符号后，情况就不同了，正如[清单
    1-11](ch01.xhtml#ch01list11)所示，它使用 `objdump` 来反汇编去除了符号的示例二进制文件。
- en: '*Listing 1-11: Disassembling a stripped executable with* `*objdump*`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-11：使用* `*objdump*` *反汇编一个去除符号的可执行文件*'
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The main takeaway from [Listing 1-11](ch01.xhtml#ch01list11) is that while the
    different sections are still clearly distinguishable (marked ➊, ➋, and ➌), the
    functions are not. Instead, all functions have been merged into one big blob of
    code. The `_start` function begins at ➍, and `deregister_tm_clones` begins at
    ➏. The `main` function starts at ➐ and ends at ➑, but in all of these cases, there’s
    nothing special to indicate that the instructions at these markers represent function
    starts. The only exceptions are the functions in the `.plt` section, which still
    have their names as before (as you can see in the call to `__libc_start_main`
    at ➎). Other than that, you’re on your own to try to make sense of the disassembly
    output.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 1-11](ch01.xhtml#ch01list11)的主要结论是，尽管不同的部分仍然可以清晰地区分（标记为 ➊、➋ 和 ➌），但是函数却不再是这样。相反，所有函数都被合并成了一大块代码。`_start`
    函数从 ➍ 开始，`deregister_tm_clones` 从 ➏ 开始。`main` 函数从 ➐ 开始，到 ➑ 结束，但在这些情况下，并没有任何特别的标记来表明这些标记位置的指令代表函数的开始。唯一的例外是
    `.plt` 部分的函数，它们仍然保留了原来的名称（如你在 ➎ 处调用 `__libc_start_main` 时看到的那样）。除此之外，其他部分的输出你需要自己去理解反汇编结果。'
- en: Even in this simple example, things are already confusing; imagine trying to
    make sense of a larger binary containing hundreds of different functions all fused
    together! This is exactly why accurate automated function detection is so important
    in many areas of binary analysis, as I’ll discuss in detail in [Chapter 6](ch06.xhtml#ch06).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这个简单的例子中，情况已经很混乱了；试想一下，如果要理解一个包含数百个不同函数且所有函数都融合在一起的大型二进制文件该有多困难！这正是为什么在许多二进制分析领域中，准确的自动化函数检测如此重要的原因，我将在[第
    6 章](ch06.xhtml#ch06)中详细讨论这一点。
- en: 1.4 Loading and Executing a Binary
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4 加载和执行二进制文件
- en: Now you know how compilation works as well as how binaries look on the inside.
    You also learned how to statically disassemble binaries using `objdump`. If you’ve
    been following along, you should even have your own shiny new binary sitting on
    your hard drive. Now you’ll learn what happens when you load and execute a binary,
    which will be helpful when I discuss dynamic analysis concepts in later chapters.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了编译过程以及二进制文件的内部结构。你也学会了如何使用 `objdump` 静态反汇编二进制文件。如果你一直跟着做，你应该已经有了一个全新的二进制文件保存在你的硬盘上。接下来，你将学习当你加载和执行一个二进制文件时会发生什么，这对我在后续章节中讨论动态分析概念非常有帮助。
- en: Although the exact details vary depending on the platform and binary format,
    the process of loading and executing a binary typically involves a number of basic
    steps. [Figure 1-2](ch01.xhtml#ch01fig2) shows how a loaded ELF binary (like the
    one just compiled) is represented in memory on a Linux-based platform. At a high
    level, loading a PE binary on Windows is quite similar.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管具体细节因平台和二进制格式不同而有所变化，但加载和执行二进制文件的过程通常涉及一些基本步骤。[图 1-2](ch01.xhtml#ch01fig2)展示了在基于
    Linux 的平台上如何将加载的 ELF 二进制文件（如刚才编译的文件）在内存中表示出来。从高层次来看，在 Windows 上加载 PE 二进制文件也非常相似。
- en: '![image](Images/f027-01.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f027-01.jpg)'
- en: '*Figure 1-2: Loading an ELF binary on a Linux-based system*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-2：在基于 Linux 的系统上加载 ELF 二进制文件*'
- en: Loading a binary is a complicated process that involves a lot of work by the
    operating system. It’s also important to note that a binary’s representation in
    memory does not necessarily correspond one-to-one with its on-disk representation.
    For instance, large regions of zero-initialized data may be collapsed in the on-disk
    binary (to save disk space), while all those zeros will be expanded in memory.
    Some parts of the on-disk binary may be ordered differently in memory or not loaded
    into memory at all. Because the details depend on the binary format, I defer the
    topic of on-disk versus in-memory binary representations to [Chapter 2](ch02.xhtml#ch02)
    (on the ELF format) and [Chapter 3](ch03.xhtml#ch03) (on the PE format). For now,
    let’s stick to a high-level overview of what happens during the loading process.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 加载二进制文件是一个复杂的过程，涉及操作系统的大量工作。还需要注意的是，二进制文件在内存中的表示不一定与它在磁盘上的表示一一对应。例如，大量的零初始化数据可能会在磁盘上的二进制文件中被压缩（以节省磁盘空间），但这些零在内存中会被展开。磁盘上的二进制文件某些部分可能在内存中排列的顺序不同，或者根本不加载到内存中。由于这些细节取决于二进制格式，因此我将在[第2章](ch02.xhtml#ch02)（ELF格式）和[第3章](ch03.xhtml#ch03)（PE格式）中讨论磁盘上与内存中的二进制表示。现在，我们暂时只做一个关于加载过程的高层概述。
- en: When you decide to run a binary, the operating system starts by setting up a
    new process for the program to run in, including a virtual address space.^([7](footnote.xhtml#ch01fn_7))
    Subsequently, the operating system maps an *interpreter* into the process’s virtual
    memory. This is a user space program that knows how to load the binary and perform
    the necessary relocations. On Linux, the interpreter is typically a shared library
    called *ld-linux.so*. On Windows, the interpreter functionality is implemented
    as part of *ntdll.dll*. After loading the interpreter, the kernel transfers control
    to it, and the interpreter begins its work in user space.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当你决定运行一个二进制文件时，操作系统首先会为程序设置一个新的进程环境，包括一个虚拟地址空间。^([7](footnote.xhtml#ch01fn_7))
    随后，操作系统会将一个*解释器*映射到进程的虚拟内存中。这个解释器是一个用户空间程序，知道如何加载二进制文件并执行必要的重定位操作。在 Linux 中，解释器通常是一个名为
    *ld-linux.so* 的共享库。在 Windows 中，解释器功能实现为 *ntdll.dll* 的一部分。加载解释器后，内核将控制权转交给它，解释器开始在用户空间工作。
- en: Linux ELF binaries come with a special section called `.interp` that specifies
    the path to the interpreter that is to be used to load the binary, as you can
    see with `readelf`, as shown in [Listing 1-12](ch01.xhtml#ch01list12).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Linux ELF 二进制文件包含一个名为 `.interp` 的特殊部分，该部分指定了用于加载二进制文件的解释器路径，如你在`readelf`中看到的那样，参见[清单1-12](ch01.xhtml#ch01list12)。
- en: '*Listing 1-12: Contents of the* `*.interp*` *section*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单1-12：`*.interp*` 部分的内容*'
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As mentioned, the interpreter loads the binary into its virtual address space
    (the same space in which the interpreter is loaded). It then parses the binary
    to find out (among other things) which dynamic libraries the binary uses. The
    interpreter maps these into the virtual address space (using `mmap` or an equivalent
    function) and then performs any necessary last-minute relocations in the binary’s
    code sections to fill in the correct addresses for references to the dynamic libraries.
    In reality, the process of resolving references to functions in dynamic libraries
    is often deferred until later. In other words, instead of resolving these references
    immediately at load time, the interpreter resolves references only when they are
    invoked for the first time. This is known as *lazy binding*, which I’ll explain
    in more detail in [Chapter 2](ch02.xhtml#ch02). After relocation is complete,
    the interpreter looks up the entry point of the binary and transfers control to
    it, beginning normal execution of the binary.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，解释器将二进制文件加载到其虚拟地址空间中（即解释器本身被加载的空间）。然后，它解析二进制文件，找出（其中包括）该二进制文件所使用的动态库。解释器将这些动态库映射到虚拟地址空间中（使用`mmap`或等效函数），并在二进制文件的代码段中执行必要的最后时刻重定位操作，以填充动态库引用的正确地址。实际上，解决动态库函数引用的过程通常会被延迟到稍后。换句话说，解释器并不会在加载时立即解析这些引用，而是在首次调用时才会解析它们。这种方法被称为*懒加载绑定*，我将在[第2章](ch02.xhtml#ch02)中详细解释。重定位完成后，解释器查找二进制文件的入口点并将控制权转交给它，开始正常执行二进制文件。
- en: 1.5 Summary
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5 总结
- en: Now that you’re familiar with the general anatomy and life cycle of a binary,
    it’s time to dive into the details of a specific binary format. Let’s start with
    the widespread ELF format, which is the subject of the next chapter.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了二进制文件的一般结构和生命周期，是时候深入了解特定的二进制格式了。我们从广泛使用的 ELF 格式开始，它是下一章的主题。
- en: Exercises
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: 1\. Locating Functions
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 定位函数
- en: Write a C program that contains several functions and compile it into an assembly
    file, an object file, and an executable binary, respectively. Try to locate the
    functions you wrote in the assembly file and in the disassembled object file and
    executable. Can you see the correspondence between the C code and the assembly
    code? Finally, strip the executable and try to identify the functions again.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个包含多个函数的 C 程序，并分别将其编译成汇编文件、目标文件和可执行二进制文件。尝试在汇编文件、反汇编的目标文件和可执行文件中定位你写的函数。你能看到
    C 代码和汇编代码之间的对应关系吗？最后，剥离可执行文件并再次尝试识别函数。
- en: 2\. Sections
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 节
- en: As you’ve seen, ELF binaries (and other types of binaries) are divided into
    sections. Some sections contain code, and others contain data. Why do you think
    the distinction between code and data sections exists? How do you think the loading
    process differs for code and data sections? Is it necessary to copy all sections
    into memory when a binary is loaded for execution?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，ELF 二进制文件（以及其他类型的二进制文件）被划分为多个节。有些节包含代码，有些节包含数据。你认为为什么会有代码节和数据节的区别？你认为代码节和数据节的加载过程有何不同？当加载一个二进制文件执行时，是否有必要将所有节都复制到内存中？
