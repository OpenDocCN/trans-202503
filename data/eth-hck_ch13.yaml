- en: '**13'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**13'
- en: SERIOUS CROSS-SITE SCRIPTING EXPLOITATION**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 严重的跨站脚本攻击**
- en: '*Love all, trust a few, do wrong to none.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*爱所有人，信任少数人，伤害任何人都不行。*'
- en: –William Shakespeare, *All’s Well That Ends Well*
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: –威廉·莎士比亚，*《一切都好，结局皆好》*
- en: '![image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: This chapter explores a website exploitation technique called *cross-site scripting
    (XSS)* that lets you run your own JavaScript in other users’ browsers when they
    visit a vulnerable site. Successful XSS attacks can block access to websites,
    steal cookies and credentials, and even compromise a user’s machine.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了一种名为*跨站脚本（XSS）*的网站利用技术，它让你能够在其他用户访问一个脆弱的网站时，在他们的浏览器中运行你自己的JavaScript。成功的XSS攻击可以阻止访问网站，窃取Cookies和凭证，甚至危及用户的计算机。
- en: Once you’re comfortable identifying and performing XSS attacks manually, we’ll
    explore the Browser Exploitation Framework, which allows you to quickly inject
    JavaScript into a vulnerable site for a variety of purposes. We’ll use this framework
    to perform social engineering attacks and collect credentials. You’ll also learn
    how to use a chain of exploits to take over a browser and load a reverse shell
    onto a machine that visits your website.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你能够熟练地识别并手动执行XSS攻击，我们将探讨浏览器利用框架（Browser Exploitation Framework），该框架允许你快速地将JavaScript注入到一个脆弱的网站中，进行多种目的的攻击。我们将使用这个框架进行社会工程学攻击并收集凭证。你还将学习如何使用一系列漏洞利用手段接管浏览器，并将反向Shell加载到访问你网站的机器上。
- en: '**Cross-Site Scripting**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**跨站脚本**'
- en: If a web app doesn’t correctly sanitize user inputs, such as comments or blog
    entries, an attacker could inject malicious code into the site by entering JavaScript
    code into the comment form instead of a legitimate comment. For example, say the
    web page uses a template like the one in [Figure 13-1](ch13.xhtml#ch13fig1).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个Web应用没有正确地清理用户输入，比如评论或博客条目，攻击者可以通过在评论表单中输入JavaScript代码而不是合法的评论，将恶意代码注入到网站中。例如，假设网页使用了像[图13-1](ch13.xhtml#ch13fig1)这样的模板。
- en: '![image](../images/ch13fig01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch13fig01.jpg)'
- en: '*Figure 13-1: JavaScript that has been injected into a template using XSS*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-1：通过XSS注入到模板中的JavaScript*'
- en: Templates are skeletons containing placeholders that represent a web page’s
    general structure. When a page is rendered, a program called a template engine
    replaces these placeholders with values the programmer specifies. For example,
    a programmer may tell the template engine to replace the `{{name}}` placeholder
    with the last value entered into the database. If the last name in the database
    was Frances, the template engine would generate a page that reads `"Welcome Frances."`
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是包含占位符的框架，表示网页的基本结构。当页面被渲染时，一种名为模板引擎的程序会用程序员指定的值替换这些占位符。例如，程序员可能会告诉模板引擎将`{{name}}`占位符替换为数据库中最后输入的值。如果数据库中的姓氏是Frances，模板引擎会生成一页显示“欢迎Frances”。
- en: 'The goal of an XSS attack is to get a web app to add malicious JavaScript to
    a page. In this example, an attacker could trick the web page into adding malicious
    code by writing a comment containing the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: XSS攻击的目标是让Web应用将恶意JavaScript添加到页面中。在这个例子中，攻击者可以通过写一个包含以下内容的评论来欺骗网页，将恶意代码添加到页面中：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `<script>` and `</script>` tags represent where the JavaScript code starts
    and ends, respectively. In this case, the tags contain the JavaScript command
    `alert()`, which causes a message to pop up on the screen. The template engine
    will now generate a web page that contains this comment; however, because this
    comment contains the `<script>` tag, the browser interprets it as code instead
    of text. When the browser runs this code, it will open a dialog box containing
    the message `"You've been Hacked!"` If the programmer had correctly sanitized
    the comment, it wouldn’t have contained the `<script>` tags and the browser wouldn’t
    have interpreted it as code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`<script>`和`</script>`标签分别表示JavaScript代码的开始和结束。在这种情况下，标签内包含JavaScript命令`alert()`，该命令会在屏幕上弹出一个消息。模板引擎现在将生成一个包含此评论的网页；然而，由于该评论包含`<script>`标签，浏览器会将其解释为代码而不是文本。当浏览器运行这段代码时，它会打开一个对话框，显示消息“你被黑了！”如果程序员正确地清理了评论，它就不会包含`<script>`标签，浏览器也不会将其解释为代码。'
- en: Because the malicious JavaScript is stored in the web app, we commonly call
    this type of XSS attack a *stored XSS* attack. There are other types of XSS attacks,
    too, including reflected XSS and DOM XSS attacks. We’ll discuss reflected XSS
    attacks later in this chapter. You can find a detailed discussion of DOM XSS attacks
    on OWASP’s website.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因为恶意的 JavaScript 存储在 Web 应用程序中，我们通常称这种类型的 XSS 攻击为*存储型 XSS* 攻击。还有其他类型的 XSS 攻击，包括反射型
    XSS 和 DOM XSS 攻击。我们将在本章稍后讨论反射型 XSS 攻击。你可以在 OWASP 的网站上找到关于 DOM XSS 攻击的详细讨论。
- en: '***How JavaScript Can Be Malicious***'
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***JavaScript 如何变得恶意***'
- en: The payload you inject into the website’s code can be quite harmful. For example,
    it could include JavaScript code that steals a user’s cookies, allowing the attacker
    to impersonate them.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你注入到网站代码中的有效载荷可能是相当有害的。例如，它可能包含盗取用户 Cookies 的 JavaScript 代码，从而允许攻击者冒充用户。
- en: When you visit a web page, the web server sends your browser the HTML, JavaScript,
    and cascading styles sheet (CSS) code it needs to render the page, and if you’ve
    successfully authenticated, the web server might also send your browser a cookie.
    As discussed in [Chapter 12](ch12.xhtml#ch12), a cookie is a field in the HTTP
    request and response that the browser and web server use to store values and maintain
    state. Your browser stores this cookie and includes it in any future HTTP requests
    it sends to the web server. This keeps users from having to log in each time they
    perform an action on the site. The web server verifies that the HTTP requests
    are authentic by checking the cookie, so if an attacker steals this cookie, they
    can access the victim’s account by sending HTTP requests containing the stolen
    cookie.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当你访问一个网页时，Web 服务器会将它需要渲染页面的 HTML、JavaScript 和层叠样式表（CSS）代码发送到你的浏览器，并且如果你已经成功认证，Web
    服务器可能还会将一个 Cookie 发送到浏览器。如[第12章](ch12.xhtml#ch12)所讨论，Cookie 是 HTTP 请求和响应中的一个字段，浏览器和
    Web 服务器用它来存储值并维持状态。浏览器会存储这个 Cookie，并将它包含在未来发送给 Web 服务器的任何 HTTP 请求中。这样用户就不必在每次执行操作时都重新登录。Web
    服务器通过检查 Cookie 来验证 HTTP 请求是否真实有效，因此，如果攻击者窃取了这个 Cookie，他们就可以通过发送包含被窃取 Cookie 的
    HTTP 请求来访问受害者的账户。
- en: To better understand cookies, let’s look at the web developer tools that allow
    you to view and analyze the HTML, Javascript, CSS, and cookies your browser receives.
    Open Firefox and then press CTRL-SHIFT-I to open its developer tools ([Figure
    13-2](ch13.xhtml#ch13fig2)).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解 Cookie，让我们来看一下允许你查看和分析浏览器接收到的 HTML、JavaScript、CSS 和 Cookie 的 Web 开发者工具。打开
    Firefox，然后按 CTRL-SHIFT-I 打开它的开发者工具（[图 13-2](ch13.xhtml#ch13fig2)）。
- en: '![image](../images/ch13fig02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch13fig02.jpg)'
- en: '*Figure 13-2: Accessing the developer tools in Firefox*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-2：在 Firefox 中访问开发者工具*'
- en: Click the **Debugger** tab ➊ to reveal a window that lets you explore the page’s
    code. Using the panel ➋, navigate to the associated files and folders. The window
    ➌ shows the associated source code. To run this JavaScript and see what it does,
    click the **Console** tab ➍.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **Debugger** 标签 ➊ 打开一个窗口，让你可以查看页面的代码。使用面板 ➋，导航到相关的文件和文件夹。窗口 ➌ 显示相关的源代码。要运行这个
    JavaScript 并查看它的作用，点击 **Console** 标签 ➍。
- en: 'JavaScript is an interpreted language, which means you don’t need to recompile
    the program to run a new command. Try entering new commands into the console.
    For example, enter the following command to view the page’s cookies:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是一种解释型语言，这意味着你不需要重新编译程序就可以运行新的命令。试着在控制台中输入新命令。例如，输入以下命令查看页面的 Cookies：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To steal a victim’s cookie using this JavaScript, the attacker must inject the
    code into a page on the domain to which the cookie belongs. This is because of
    a security policy called the *same origin policy* that allows only JavaScript
    running on the same page to access that page’s resources. So, JavaScript on one
    domain can’t access cookies associated with a different domain. For example, JavaScript
    running on *virginia.edu* can’t access cookies created by *[nostarch.com](http://nostarch.com)*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个 JavaScript 偷取受害者的 Cookie，攻击者必须将代码注入到属于该 Cookie 所在域的页面中。这是因为有一个被称为*同源策略*的安全策略，它只允许在同一页面上运行的
    JavaScript 访问该页面的资源。所以，运行在一个域上的 JavaScript 不能访问与另一个域相关的 Cookie。例如，运行在 *virginia.edu*
    上的 JavaScript 无法访问由 *[nostarch.com](http://nostarch.com)* 创建的 Cookie。
- en: 'To better understand the attack’s mechanisms, consider the following JavaScript
    code. It includes an HTML image tag that contains carefully crafted malicious
    code to steal cookies. This JavaScript is the payload that the attacker will inject
    into the page:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解攻击的机制，考虑以下 JavaScript 代码。它包含一个 HTML 图像标签，其中包含精心设计的恶意代码，用于窃取 Cookie。这段
    JavaScript 是攻击者将注入页面的有效载荷：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Inside the `<script>` tags, the JavaScript command `document.write()` uses the
    browser document API to write to the *document object model (DOM)*, which is a
    virtual representation of the web page. Here, it writes an image (`<img>`). However,
    this image is special. Its source URL, the location from which the browser should
    retrieve the image, points to the attacker’s server, and its query string parameter
    (`cookie`) contains the user’s cookies. So when the image loads it will send the
    users cookies to the attacker’s server. Once an attacker has access to a victim’s
    cookies, they can attempt to authenticate as the user.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `<script>` 标签内，JavaScript 命令 `document.write()` 使用浏览器的文档 API 向 *文档对象模型（DOM）*
    写入内容，DOM 是网页的虚拟表示。这里，它写入了一张图片（`<img>`）。然而，这张图片是特殊的。它的源 URL，浏览器应该从该位置获取图片，指向攻击者的服务器，并且它的查询字符串参数（`cookie`）包含用户的
    Cookie。所以，当图片加载时，它会将用户的 Cookie 发送到攻击者的服务器。一旦攻击者访问了受害者的 Cookie，他们就可以尝试以用户身份进行身份验证。
- en: Lastly, the cookie might contain characters that aren’t allowed in a URL, so
    we must escape these before sending the cookie by including it as a query string
    parameter in the source URL. When the browser attempts to load the image, it will
    generate a `GET` request to the attacker’s server, essentially sending the user’s
    cookies directly to the attacker.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Cookie 可能包含 URL 中不允许的字符，因此我们必须在发送 Cookie 时进行转义，将其作为查询字符串参数包含在源 URL 中。当浏览器尝试加载图片时，它将生成一个
    `GET` 请求发送到攻击者的服务器，实际上是将用户的 Cookie 直接发送给攻击者。
- en: 'The attacker’s server that receives the cookies might be running a simple Python
    program like the following, which extracts the query string parameter from the
    `GET` request:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接收这些 Cookie 的攻击者服务器可能正在运行一个简单的 Python 程序，如下所示，它提取 `GET` 请求中的查询字符串参数：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that it’s using an encrypted socket, so you’ll need to generate your
    *server.crt* certificate and private key, *server.key*. See [Chapter 6](ch06.xhtml#ch6)
    for details on doing so. To be even more stealthy, you could purchase a certificate
    for a domain you own. After you’ve extracted the cookies, you can load them into
    your browser and access the user’s accounts. One way to do this is with *Cookie
    Quick Manager*, a Firefox extension that allows you to edit, add, and delete cookies
    from your browser ([Figure 13-3](ch13.xhtml#ch13fig3)).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，它正在使用加密的套接字，因此你需要生成你的 *server.crt* 证书和私钥 *server.key*。有关如何生成的详细信息，请参见[第 6
    章](ch06.xhtml#ch6)。为了更加隐秘，你可以购买一个你拥有的域名的证书。在你提取了 Cookie 后，你可以将其加载到浏览器中并访问用户的账户。实现这一点的一种方法是使用
    *Cookie Quick Manager*，一个 Firefox 扩展，允许你编辑、添加和删除浏览器中的 Cookie（[图 13-3](ch13.xhtml#ch13fig3)）。
- en: '![image](../images/ch13fig03.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch13fig03.jpg)'
- en: '*Figure 13-3: An example of Quick Cookie Manager*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-3：Quick Cookie Manager 的示例*'
- en: When you install the extension, you will see a cookie icon in your toolbar ➊.
    Click the cookie icon and then select **Manage all Cookies**. This will show all
    the cookies your browser currently has. When you click a specific domain ➋, it
    will show you all the cookies your browser has stored for that domain. You can
    edit the cookies by changing the value field ➌. You’ll need to enable editing
    by clicking the pencil icon at the bottom of the page. Once you’ve loaded the
    stolen cookies, you can access the victim’s account.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当你安装扩展程序时，你会在工具栏看到一个饼干图标 ➊。点击该饼干图标，然后选择**管理所有 Cookie**。这将显示你浏览器当前拥有的所有 Cookie。当你点击一个特定的域名
    ➋，它将显示你浏览器为该域名存储的所有 Cookie。你可以通过修改值字段 ➌ 来编辑 Cookie。你需要点击页面底部的铅笔图标来启用编辑功能。一旦你加载了被窃取的
    Cookie，你就可以访问受害者的账户。
- en: '***Stored XSS Attacks***'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***存储型 XSS 攻击***'
- en: Now that you understand the general mechanisms of an XSS attack, let’s walk
    through a real example by performing a stored XSS attack. As shown earlier, we’ll
    use a blog post to insert malicious JavaScript into a server. We’ll attack a blog
    page on the vulnerable Mutillidae app we used in [Chapter 12](ch12.xhtml#ch12).
    This app is hosted on Metasploitable, so start the Metasploitable virtual machine,
    log in to it, and get the server’s IP address using `**ifconfig**`. Now start
    the web browser on your Kali Linux virtual machine and visit the “add your own
    blog” page in the Mutillidae app by selecting **OWASP Top 10** ▶ **A2 Cross Site
    Scripting (XSS)** ▶ **Persistent (Second Order)** ▶ **Add to your blog**.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了 XSS 攻击的一般机制，让我们通过执行一个存储型 XSS 攻击来逐步了解一个真实的例子。如前所述，我们将使用博客帖子将恶意 JavaScript
    插入到服务器中。我们将攻击在[第 12 章](ch12.xhtml#ch12)中使用的易受攻击的 Mutillidae 应用程序的博客页面。这个应用托管在
    Metasploitable 上，所以启动 Metasploitable 虚拟机，登录并使用 `**ifconfig**` 获取服务器的 IP 地址。现在启动
    Kali Linux 虚拟机中的 Web 浏览器，并通过选择 **OWASP Top 10** ▶ **A2 Cross Site Scripting (XSS)**
    ▶ **Persistent (Second Order)** ▶ **Add to your blog** 来访问 Mutillidae 应用中的“添加你的博客”页面。
- en: Now let’s test whether this page is vulnerable to XSS by attempting to inject
    some JavaScript into our blog post ([Figure 13-4](ch13.xhtml#ch13fig4)).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过尝试向我们的博客帖子注入一些 JavaScript 来测试这个页面是否容易受到 XSS 攻击（[图 13-4](ch13.xhtml#ch13fig4)）。
- en: '![image](../images/ch13fig04.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch13fig04.jpg)'
- en: '*Figure 13-4: Executing the stored XSS attack in Mutillidae’s blog*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-4：在 Mutillidae 博客中执行存储型 XSS 攻击*'
- en: Instead of writing a regular blog post in the text box, we’ll write some JavaScript
    code (`<script> alert("Hacked") </script>`) and save the post. Once you’ve refreshed
    the page, Mutillidae will retrieve the malicious JavaScript and embed it in the
    page as it would any other blog post. However, unlike other blog posts, your new
    blog post contains JavaScript code, which the browser will execute. If it runs
    successfully, it should open a pop-up containing the word *Hacked*. Save the blog
    post and refresh the page. This should embed the JavaScript code in the page and
    cause the browser to display a pop-up.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在文本框中写常规的博客帖子，而是会写一些 JavaScript 代码（`<script> alert("Hacked") </script>`）并保存该帖子。刷新页面后，Mutillidae
    会检索恶意 JavaScript 并将其嵌入到页面中，就像处理其他博客帖子一样。然而，不同于其他博客帖子，你的新博客帖子包含 JavaScript 代码，浏览器会执行它。如果成功运行，它应该会弹出一个包含
    *Hacked* 的弹窗。保存博客帖子并刷新页面，这应该会将 JavaScript 代码嵌入页面并使浏览器显示弹窗。
- en: To understand why this attack worked, take a look at the table in [Figure 13-5](ch13.xhtml#ch13fig5)
    that shows the blog entries located directly below the **Save Blog Entry** button.
    You’ll notice an empty blog entry ➊. This is the one we just created. To read
    the source code for this entry, right-click the entry and select the **Inspect**
    option from the drop-down. This will launch the developer tools.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么这个攻击有效，请查看[图 13-5](ch13.xhtml#ch13fig5)中的表格，该表格显示了直接位于**保存博客条目**按钮下方的博客条目。你会注意到一个空的博客条目
    ➊。这就是我们刚刚创建的条目。要查看该条目的源代码，右键点击该条目，并从下拉菜单中选择**检查**选项。这将启动开发者工具。
- en: If you use the tools to read the table code and data, you should notice the
    table data entry (`<td>`) that contains your newly created post ➋. The entry contains
    your malicious JavaScript, which the browser will run as code rather than displaying
    as text in the browser. This is why our blog entry is blank.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用工具读取表格代码和数据，你应该注意到包含你新创建帖子 ➋ 的表格数据项（`<td>`）。该条目包含你的恶意 JavaScript，浏览器会将其作为代码执行，而不是在浏览器中显示为文本。这就是我们博客条目为空的原因。
- en: '![image](../images/ch13fig05.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch13fig05.jpg)'
- en: '*Figure 13-5: Using the developer tools to show where the malicious script
    was inserted*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-5：使用开发者工具显示恶意脚本被插入的位置*'
- en: This malicious JavaScript runs when any user visits the blog page. We’ve executed
    a mere alert here, but we can execute any malicious JavaScript such as the cookie
    stealing script we wrote earlier.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个恶意 JavaScript 会在任何用户访问博客页面时运行。我们这里只执行了一个简单的 alert，但我们可以执行任何恶意 JavaScript，例如我们之前编写的窃取
    cookie 的脚本。
- en: '***Reflected XSS Attacks***'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***反射型 XSS 攻击***'
- en: A *reflected XSS* attack exploits a vulnerability in a web app that occurs when
    the app includes data from the HTTP request message in the HTTP response without
    adequately sanitizing it. Consider the following attack scenario. An attacker
    sends an email with the text “Check out this great article about hacking.” However,
    unbeknownst to the victim, the attacker has embedded some malicious JavaScript
    code into one of the query string parameters of the link included in the email.
    When a user clicks the link, the web server adds the malicious JavaScript in the
    query string parameter to the page and the browser executes it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*反射型 XSS* 攻击利用了 web 应用中的一个漏洞，该漏洞发生在应用将 HTTP 请求消息中的数据包含到 HTTP 响应中时，而没有进行充分的清理。考虑以下攻击场景。攻击者发送一封邮件，邮件内容是“看看这篇关于黑客的好文章。”然而，受害者并不知道，攻击者在邮件中包含的链接的查询字符串参数中嵌入了一些恶意的
    JavaScript 代码。当用户点击链接时，Web 服务器会将恶意的 JavaScript 代码从查询字符串参数添加到页面中，并且浏览器会执行它。'
- en: 'To see an example of how query string parameters are added to pages, copy the
    following URL into your web browser: *[https://www.google.com/?q=Ethical+Hacking](https://www.google.com/?q=Ethical+Hacking)*.
    Notice that Google’s server added the value in the query string parameter to the
    search box as a search term. Now suppose that a website doesn’t correctly sanitize
    query string parameters. In that case, an attacker may use a reflected XSS attack
    to inject malicious JavaScript into a victim’s browser.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看查询字符串参数如何添加到页面中的例子，复制以下 URL 到你的网页浏览器： *[https://www.google.com/?q=Ethical+Hacking](https://www.google.com/?q=Ethical+Hacking)*。注意到谷歌的服务器将查询字符串参数中的值添加到搜索框中作为搜索词。现在假设一个网站没有正确清理查询字符串参数。在这种情况下，攻击者可能利用反射型
    XSS 攻击将恶意 JavaScript 注入到受害者的浏览器中。
- en: Take a look at an example that targets the DVWA installed on your Metasploitable
    server. You can access it using a browser on your Kali Linux machine to navigate
    to *http://<Metasploitable-IP>/dvwa/login.php*. Log in using the username **admin**
    and password **password**. Just like the Mutillidae app, DVWA has security levels.
    Click the **Security** tab and set the security level to **low**. Click the tab
    **XSS Reflected**. You should see a submission box that lets you send input to
    the server ([Figure 13-6](ch13.xhtml#ch13fig6)). Try entering “test” in the submission
    box.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 看看一个针对你在 Metasploitable 服务器上安装的 DVWA 的例子。你可以通过 Kali Linux 机器上的浏览器访问它，导航到 *http://<Metasploitable-IP>/dvwa/login.php*。使用用户名
    **admin** 和密码 **password** 登录。就像 Mutillidae 应用一样，DVWA 有安全级别。点击 **Security** 标签，并将安全级别设置为
    **low**。点击 **XSS Reflected** 标签。你应该能看到一个提交框，允许你向服务器发送输入（[图13-6](ch13.xhtml#ch13fig6)）。试着在提交框中输入“test”。
- en: '![image](../images/ch13fig06.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch13fig06.jpg)'
- en: '*Figure 13-6: DVWA’s reflected XSS page*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-6：DVWA 的反射型 XSS 页面*'
- en: 'Now take a look at the URL. You should notice that the `name` query parameter
    now contains the value `test`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看这个 URL。你应该注意到，`name` 查询参数现在包含了值 `test`：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Also notice the value of the query string parameter is reflected in the page,
    below the submission box. If we include JavaScript in the URL and the app doesn’t
    correctly sanitize it, we can inject JavaScript directly into the page. Copy the
    following URL into your browser and press ENTER:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，查询字符串参数的值反射到页面中，位于提交框下方。如果我们在 URL 中包含 JavaScript，并且应用没有正确地清理它，我们可以直接将 JavaScript
    注入到页面中。将以下 URL 复制到你的浏览器中并按回车键：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here we’re using the name query parameter to inject our alert script. If you
    see an alert box, you’ve successfully executed your first reflected XSS attack.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用 `name` 查询参数来注入我们的 alert 脚本。如果你看到一个警告框，那么你就成功地执行了第一次反射型 XSS 攻击。
- en: '**Finding Vulnerabilities with OWASP Zed Attack Proxy**'
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 OWASP Zed Attack Proxy 查找漏洞**'
- en: As with SQL injection, websites protect against XSS attacks by sanitizing user
    input through a variety of means. OWASP maintains a document on the best ways
    to prevent XSS attacks, as well as strategies for evading those protections. You
    can find these on OWASP’s website.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与 SQL 注入类似，网站通过多种手段清理用户输入来防御 XSS 攻击。OWASP 维护了一份关于防止 XSS 攻击的最佳方法文档，以及绕过这些防护的策略。你可以在
    OWASP 的网站上找到这些信息。
- en: To help companies audit their websites, OWASP developed OWASP *Zed Attack Proxy
    (ZAP)*, an auditing tool that comes preinstalled with Kali Linux, that can scan
    applications to discover web vulnerabilities like XSS or the SQL injection attacks
    discussed in [Chapter 12](ch12.xhtml#ch12).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助公司审计其网站，OWASP 开发了 OWASP *Zed Attack Proxy (ZAP)*，这是一种预装在 Kali Linux 中的审计工具，可以扫描应用程序，发现像
    XSS 或 SQL 注入攻击等 web 漏洞，这些攻击在[第12章](ch12.xhtml#ch12)中有讨论。
- en: Let’s scan the Mutillidae app to see what vulnerabilities we find. Launch OWASP
    and select the default setup options. After the setup is complete, click the **Quick
    Start** tab and select the automated scan.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扫描Mutillidae应用，看看能发现什么漏洞。启动OWASP并选择默认设置选项。设置完成后，点击**快速开始**选项卡并选择自动扫描。
- en: '![image](../images/ch13fig07.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch13fig07.jpg)'
- en: '*Figure 13-7: Starting the ZAP scan*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-7：启动ZAP扫描*'
- en: Enter the URL of the Mutillidae app in the box. ZAP will explore all the URLs
    in the domain by following the links it discovers. We call the process of exploring
    the links in a domain *spidering* or *crawling*. However, modern web apps may
    sometimes use JavaScript to dynamically render URLs or access APIs, which can’t
    be detected with traditional spidering. For this reason, the ZAP team created
    the *Ajax spider*, a tool that launches the browser and then waits for the page
    to load before exploring it by clicking links and entering data. To use this tool,
    select the **Use ajax spider** option and the **Firefox Headless** option, which
    uses the Firefox browser without opening a window. If you select the Firefox option
    instead, ZAP will open Firefox and you’ll be able to watch it explore the page
    with the Selenium testing framework. Once you’ve chosen these options, start the
    scan by clicking **Attack**.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在框中输入Mutillidae应用的URL。ZAP将通过跟随它发现的链接来探索该域中的所有URL。我们将此过程称为*蜘蛛爬行*或*爬取*。然而，现代Web应用有时会使用JavaScript动态渲染URL或访问API，而这无法通过传统的蜘蛛爬行来检测。因此，ZAP团队创建了*Ajax蜘蛛*，这是一个启动浏览器并等待页面加载后通过点击链接和输入数据来探索页面的工具。要使用此工具，选择**使用ajax蜘蛛**选项和**Firefox无头模式**选项，该选项使用Firefox浏览器而不打开窗口。如果您选择Firefox选项，ZAP将打开Firefox，您将能够看到它使用Selenium测试框架探索页面。选择好这些选项后，点击**攻击**开始扫描。
- en: '![image](../images/ch13fig08.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch13fig08.jpg)'
- en: '*Figure 13-8: The result of running a quick ZAP scan*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-8：运行快速ZAP扫描的结果*'
- en: When the scan completes, you should see the screen shown in [Figure 13-8](ch13.xhtml#ch13fig8).
    The lower-left panel shows a list of possible web vulnerabilities ZAP has discovered.
    You should see that the ZAP tool found the *add-to-your-blog.php* page ➊ containing
    the XSS vulnerability we exploited earlier. The tool also shows the headers of
    the HTTP response the server generated ➋ and the body of the response, which contains
    the HTML ➌. As evidence that the XSS attack is possible, the tool has highlighted
    where it injected the JavaScript. ZAP highlights details about the attack ➍. This
    panel also contains information on the URL with the vulnerability and a short
    description of the vulnerability.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当扫描完成后，您应该会看到[图13-8](ch13.xhtml#ch13fig8)所示的屏幕。左下角面板显示了ZAP发现的可能的Web漏洞列表。您应该会看到ZAP工具发现了包含我们之前利用的XSS漏洞的*add-to-your-blog.php*页面➊。该工具还显示了服务器生成的HTTP响应的头部➋，以及响应的主体，其中包含HTML
    ➌。作为XSS攻击可能存在的证据，工具突出显示了它注入JavaScript的位置。ZAP还突出显示了攻击的细节 ➍。该面板还包含有关存在漏洞的URL以及漏洞的简短描述的信息。
- en: You can probably already see that ZAP is a very useful tool. Take some time
    to familiarize yourself with its great features by exploring its documentation
    online. Another way to scan a web app is to search for known vulnerabilities associated
    with the technologies used to build it. Use the tools and techniques discussed
    in [Chapter 8](ch08.xhtml#ch8) to discover a target’s underlying technologies.
    For example, you might perform a `whatweb` scan and use the `searchsploit` command
    line tool to find vulnerabilities associated with a specific version of the software
    used to build the app.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经能看出，ZAP是一个非常有用的工具。花些时间通过在线浏览其文档来熟悉它的各种强大功能。扫描Web应用的另一种方式是搜索与构建它所使用的技术相关的已知漏洞。使用[第8章](ch08.xhtml#ch8)中讨论的工具和技术来发现目标的底层技术。例如，您可能会执行`whatweb`扫描，并使用`searchsploit`命令行工具查找与用于构建应用的特定版本软件相关的漏洞。
- en: '**Using Browser Exploitation Framework Payloads**'
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用浏览器利用框架有效载荷**'
- en: 'The *Browser Exploitation Framework (BeEF)* allows hackers to easily embed
    and control malicious JavaScript payloads in vulnerable apps. We’ll use the tool
    to explore the many things you can achieve with your malicious JavaScript. BeEF
    should come preinstalled in Kali Linux; however, if your version doesn’t have
    it, you can install it by using the following command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*浏览器利用框架（BeEF）* 使黑客能够轻松地将恶意JavaScript有效载荷嵌入到易受攻击的应用程序中并进行控制。我们将使用该工具探索使用恶意JavaScript可以实现的许多功能。BeEF应该在Kali
    Linux中预安装；然而，如果您的版本没有它，您可以通过以下命令进行安装：'
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***Injecting the BeEF Hook***'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***注入 BeEF Hook***'
- en: 'When the installation completes, run BeEF:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，运行 BeEF：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You might be asked to enter a username and password when the framework starts.
    Create these, and make sure to remember them. Your terminal should then display
    the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在框架启动时，你可能需要输入用户名和密码。创建这些账户，并确保记住它们。你的终端应显示如下内容：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Copy the URL for the BeEF web interface ➊ and enter it into your browser. You
    should see the BeEF login screen, as shown in [Figure 13-9](ch13.xhtml#ch13fig9).
    Log in using the username and password you created earlier.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 复制 BeEF Web 界面的 URL ➊ 并输入到你的浏览器中。你应该会看到 BeEF 登录界面，如 [图 13-9](ch13.xhtml#ch13fig9)
    所示。使用你之前创建的用户名和密码登录。
- en: '![image](../images/ch13fig09.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch13fig09.jpg)'
- en: '*Figure 13-9: The BeEF login screen*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-9：BeEF 登录界面*'
- en: At this point, you’ve set up your BeEF server. The server will listen for connections
    from the malicious JavaScript you’ll implant. The framework should also provide
    you with the JavaScript to inject ➋. The script tag included here will load the
    *hook.js* file, a malicious JavaScript file that communicates with the BeEF server.
    Once the module is loaded, you can access all the features of that module.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你已经设置好了 BeEF 服务器。服务器将监听来自你植入的恶意 JavaScript 的连接。框架还会提供你要注入的 JavaScript ➋。这里包含的
    script 标签将加载 *hook.js* 文件，这是一种与 BeEF 服务器通信的恶意 JavaScript 文件。一旦模块加载完成，你就可以访问该模块的所有功能。
- en: Use the stored XSS attack covered earlier in this chapter to inject this payload
    into Mutillidae’s blog page at *add-to-your-blog.php*. If you successfully execute
    the attack, the script should become embedded in the web page and your Kali Linux
    browser should show up in the list of the victim machines in the BeEF web UI ([Figure
    13-10](ch13.xhtml#ch13fig10)). Any browser that visits the web page should be
    hooked by the malicious JavaScript.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本章之前介绍的存储 XSS 攻击，将此有效载荷注入到 Mutillidae 的博客页面 *add-to-your-blog.php* 中。如果你成功执行了攻击，脚本应嵌入到网页中，你的
    Kali Linux 浏览器应出现在 BeEF Web UI 中的受害者机器列表中 ([图 13-10](ch13.xhtml#ch13fig10))。任何访问该网页的浏览器都会被恶意
    JavaScript 挂钩。
- en: '![image](../images/ch13fig10.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch13fig10.jpg)'
- en: '*Figure 13-10: List of browsers running the malicious JavaScript*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-10：运行恶意 JavaScript 的浏览器列表*'
- en: To test this, try hooking the Firefox browser on the Ubuntu virtual machine.
    Start Ubuntu and visit the blog page. When the Ubuntu machine loads the page,
    it should be added to the list of online browsers.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个，尝试挂钩 Ubuntu 虚拟机上的 Firefox 浏览器。启动 Ubuntu 并访问博客页面。当 Ubuntu 机器加载页面时，它应该会被添加到在线浏览器的列表中。
- en: '***Performing a Social Engineering Attack***'
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***执行社会工程学攻击***'
- en: What can you do after you’ve hooked the browser? Try using the BeEF framework
    to launch a social engineering attack. This attack will show the victim a fake
    login screen when they try to access the blog page. When the user enters in their
    username and password, the BeEF framework will capture the credentials and redirect
    the user to the blog page.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在你已经挂钩浏览器之后，你可以做什么？尝试使用 BeEF 框架发起社会工程学攻击。当受害者尝试访问博客页面时，这个攻击将展示一个假登录界面。当用户输入用户名和密码时，BeEF
    框架将捕获这些凭证并将用户重定向到博客页面。
- en: To get started, click the Ubuntu machine’s IP address in the list of hooked
    browsers and select the **Commands** tab ([Figure 13-11](ch13.xhtml#ch13fig11)).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请点击列表中挂钩的浏览器的 Ubuntu 机器 IP 地址，并选择 **命令** 标签 ([图 13-11](ch13.xhtml#ch13fig11))。
- en: The **Command** tab contains a list of BeEF modules. I recommend looking through
    them; you might be surprised at all the things you can do once you can inject
    your own JavaScript into a site. You can even write your own BeEF modules using
    Ruby and JavaScript. If you’re interested in trying this, check out the documentation
    at *[https://github.com/beefproject/beef/wiki/Module-Creation/](https://github.com/beefproject/beef/wiki/Module-Creation/)*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令** 标签包含了 BeEF 模块的列表。我建议你浏览一下这些模块；你会对你能够做的事情感到惊讶，因为一旦你能将自己的 JavaScript 注入到网站中，你几乎可以做任何事。你甚至可以使用
    Ruby 和 JavaScript 编写自己的 BeEF 模块。如果你有兴趣尝试，请查看文档：*[https://github.com/beefproject/beef/wiki/Module-Creation/](https://github.com/beefproject/beef/wiki/Module-Creation/)*。'
- en: '![image](../images/ch13fig11.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch13fig11.jpg)'
- en: '*Figure 13-11: Performing a social engineering attack in BeEF*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-11：在 BeEF 中执行社会工程学攻击*'
- en: Click the **Social Engineering** folder and select the **Google Phishing** attack.
    This attack injects JavaScript that mimics the Gmail login page. After you execute
    the attack, you’ll see a page similar to [Figure 13-12](ch13.xhtml#ch13fig12)
    on the victim’s machine.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**社会工程学**文件夹，选择**Google 钓鱼**攻击。此攻击注入了模仿 Gmail 登录页面的 JavaScript。执行攻击后，你将在受害者的机器上看到类似于[图
    13-12](ch13.xhtml#ch13fig12)的页面。
- en: '![image](../images/ch13fig12.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch13fig12.jpg)'
- en: '*Figure 13-12: The fake Google login screen*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-12：伪造的 Google 登录页面*'
- en: Set the **XSS hook URL** to */index.php?page=add-to-your-blog.php*. When the
    user enters their credentials, they’ll be redirected to the page specified by
    the hook URL. Then, click **Execute** and use the Ubuntu browser to navigate to
    the blog page. Try entering some fake credentials in the fraudulent login screen.
    When you click **command 1** in the **Module Results History** panel of the BeEF
    interface, you should see the captured username and password ([Figure 13-13](ch13.xhtml#ch13fig13)).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 将**XSS hook URL**设置为*/index.php?page=add-to-your-blog.php*。当用户输入他们的凭据时，他们将被重定向到
    hook URL 指定的页面。然后，点击**执行**，并使用 Ubuntu 浏览器访问博客页面。在伪造的登录页面中尝试输入一些虚假的凭据。当你在 BeEF
    界面的**模块结果历史**面板中点击**命令 1**时，你应该能看到捕获的用户名和密码（[图 13-13](ch13.xhtml#ch13fig13)）。
- en: '![image](../images/ch13fig13.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch13fig13.jpg)'
- en: '*Figure 13-13: Credentials stolen using the phishing attack*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-13：通过钓鱼攻击窃取的凭据*'
- en: The **Details** tab offers information the BeEF framework has collected on the
    browser, including the browser’s version and the type of attacks to which it might
    be susceptible.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**详情**标签提供了 BeEF 框架收集到的关于浏览器的信息，包括浏览器的版本以及可能受到哪些类型攻击的影响。'
- en: '**Moving from Browser to Machine**'
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**从浏览器到机器的转变**'
- en: So you’ve compromised a website. But if you hope to access the computer visiting
    the website, you may feel stuck. Most modern browser tabs are *sandboxed*; that
    is, isolated from other tabs and the operating system. This prevents malicious
    code running in one tab from accessing anything else on the same device.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你已经攻破了一个网站。但如果你希望访问访问该网站的计算机，你可能会感到困惑。大多数现代浏览器标签页都是*沙盒化*的；也就是说，它们与其他标签页和操作系统是隔离的。这防止了在一个标签页中运行的恶意代码访问同一设备上的其他内容。
- en: 'Now suppose there are vulnerabilities in the sandbox. In that case, an attacker
    might be able to use malicious JavaScript to exploit these vulnerabilities, escape
    the browser, and run a reverse shell on the targeted machine. This would allow
    an attacker to compromise a user’s machine by exploiting the vulnerable website.
    This attack could be extremely detrimental: imagine if an attacker injected malicious
    code into a popular social media site or search engine and subsequently accessed
    the machines of every visitor.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设沙盒中存在漏洞。在这种情况下，攻击者可能能够利用恶意 JavaScript 来利用这些漏洞，突破浏览器限制，并在目标机器上运行反向 shell。这将允许攻击者通过利用脆弱的网站来攻破用户的机器。这种攻击可能会造成极大的危害：想象一下，如果攻击者向一个流行的社交媒体网站或搜索引擎注入恶意代码，并随后访问每个访客的机器。
- en: Such an attack is not out of the ordinary. Each year, the Pwn2Own hacking contest
    gives hackers three days to break into machines through a web browser. These machines
    always run the latest operating systems and browsers, and there’s a winner most
    years.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这种攻击并不罕见。每年，Pwn2Own 黑客竞赛都会给黑客三天时间，通过网页浏览器入侵机器。这些机器通常运行最新的操作系统和浏览器，并且每年都有获胜者。
- en: '***Case Study: Exploiting an Old Version of the Chrome Browser***'
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***案例研究：利用旧版 Chrome 浏览器的漏洞***'
- en: In 2017, Oliver Chang, an engineer on the Chrome security team, discovered a
    vulnerability in Chrome’s V8 JavaScript engine. The vulnerability allowed an attacker
    to perform an out-of-bounds write to launch a shell on the victim’s machine. You
    can find the code for the exploit in the Exploit Database under the ID 42078\.
    When the code is run, a vulnerable version of the Chrome browser will launch the
    calculator app on a Linux machine. Launching a calculator has become the de facto
    way of demonstrating that you can escape the browser. Out-of-bounds reads and
    writes are great bugs to find. An attacker can use these bugs to load and execute
    a shell by chaining together a collection of exploitation techniques.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 2017年，Chrome安全团队的工程师Oliver Chang发现了Chrome V8 JavaScript引擎中的一个漏洞。这个漏洞允许攻击者执行越界写操作，从而在受害者的机器上启动一个shell。你可以在Exploit
    Database中找到这个漏洞的代码，ID为42078。当代码运行时，受影响版本的Chrome浏览器会在Linux机器上启动计算器应用程序。启动计算器已经成为展示可以逃离浏览器的事实标准方式。越界读取和写入是非常值得寻找的漏洞。攻击者可以利用这些漏洞，通过链式利用一系列攻击技术来加载并执行shell。
- en: In practice, discovering and writing exploits for browsers can be an involved
    process. The most popular browsers, Chrome and Safari, are developed by two large
    tech companies with in-house testing teams, so although traditional techniques
    like fuzzing and concolic execution may help you discover vulnerabilities, keep
    in mind that these companies use fuzzing tools, too. For example, Google has an
    in-house tool for fuzzing Chrome, called *ClusterFuzz*, that they almost certainly
    run before releasing a new version of the browser. Thus, you might have the best
    results doing manual code inspection. Luckily, the browser engines used by Chrome
    (Blink) and Safari (Webkit) are open source, and the projects are well documented,
    so you can compile and debug them yourself. The Chrome team even has a free YouTube
    lecture series for Google Chrome developers called Chrome University. The lecture
    series dedicates an entire lecture to exploring the CVE-2019-5786 vulnerability,
    which affected Chrome in 2019 and was exploited by a state actor.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，发现并编写浏览器的漏洞利用代码可能是一个复杂的过程。最流行的浏览器，Chrome和Safari，由两家大型科技公司开发，并且拥有内部测试团队。因此，虽然传统的技术如模糊测试和符号执行可能有助于你发现漏洞，但请记住，这些公司也使用模糊测试工具。例如，Google有一个内部工具来对Chrome进行模糊测试，名为*ClusterFuzz*，他们几乎肯定会在发布新版本浏览器之前运行它。因此，你可能会通过手动代码检查获得最佳结果。幸运的是，Chrome（Blink）和Safari（Webkit）所使用的浏览器引擎是开源的，并且这些项目有着很好的文档记录，因此你可以自己编译和调试它们。Chrome团队甚至有一个免费的YouTube讲座系列，供Google
    Chrome开发者观看，叫做Chrome University。该系列讲座专门讲解了CVE-2019-5786漏洞，这个漏洞影响了2019年的Chrome，并被某个国家行为者利用。
- en: Once these vulnerabilities are fixed, it takes time (days to weeks) to update
    the user’s device. Because these projects are open source, attackers can view
    and exploit these fixes before they make it to production.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些漏洞被修复，更新用户设备需要时间（从几天到几周）。由于这些项目是开源的，攻击者可以在修复内容进入生产环境之前查看并利用这些修复。
- en: '***Installing Rootkits via Website Exploitation***'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***通过网站利用安装Rootkit***'
- en: 'How might an attacker chain the exploits covered in this chapter to, say, install
    a rootkit on a machine when the victim visits a certain website? Consider the
    following attack scenario: you’ve scanned a website and discovered an XSS vulnerability
    in the app. We’ll call this vulnerability 1\. Next, you use this vulnerability
    to upload malicious JavaScript code that will escape the browser’s sandbox and
    load a malicious reverse shell onto the victim’s machine (vulnerability 2). Once
    the reverse shell connects to your attacker server, you use a kernel vulnerability
    (discussed in [Chapter 14](ch14.xhtml#ch14)) to escalate your privileges (vulnerability
    3) and install a rootkit. You now can invisibly control the machine.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者如何将本章所涵盖的漏洞串联起来，比如在受害者访问某个网站时安装Rootkit？考虑以下攻击场景：你扫描了一个网站并发现了一个应用程序中的XSS漏洞。我们将这个漏洞称为漏洞1。接下来，你利用这个漏洞上传恶意JavaScript代码，使其跳出浏览器的沙盒，并将恶意的反向shell加载到受害者的机器上（漏洞2）。一旦反向shell连接到你的攻击者服务器，你就可以利用一个内核漏洞（在[第14章](ch14.xhtml#ch14)中讨论）提升权限（漏洞3）并安装Rootkit。你现在可以隐秘地控制这台机器。
- en: '[Figure 13-14](ch13.xhtml#ch13fig14) shows the process of performing this exploit
    using BeEF and Metasploit.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[图13-14](ch13.xhtml#ch13fig14)展示了使用BeEF和Metasploit执行此漏洞的过程。'
- en: '![image](../images/ch13fig14.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch13fig14.jpg)'
- en: '*Figure 13-14: The interactions between a web server, the victim’s laptop,
    and the hacker’s server*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-14：Web服务器、受害者笔记本和黑客服务器之间的交互*'
- en: First, the victim visits a website containing the malicious JavaScript ➊ you’ve
    injected. After the victim’s browser loads the page ➋, it activates the code,
    which then connects to the BeEF server ➌. The BeEF server will then inject additional
    malicious JavaScript ➍ containing a link to the exploitation code on the Metasploit
    server. The browser will then connect to the Metasploit server ➎ and download
    JavaScript code that automatically scans for browser vulnerabilities ➏. If it
    finds a vulnerability, the code exploits the browser and loads a reverse shell
    onto the machine that will connect to the Metasploit server ➐. Now the attacker
    can perform a privilege escalation attack and install a rootkit.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，受害者访问一个包含你注入的恶意 JavaScript ➊ 的网站。当受害者的浏览器加载页面 ➋ 后，代码被激活，接着它连接到 BeEF 服务器 ➌。BeEF
    服务器随后注入额外的恶意 JavaScript ➍，该代码包含指向 Metasploit 服务器上漏洞利用代码的链接。浏览器将连接到 Metasploit
    服务器 ➎，并下载自动扫描浏览器漏洞的 JavaScript 代码 ➏。如果发现漏洞，代码会利用该漏洞并在受害者机器上加载一个反向 Shell，该 Shell
    会连接到 Metasploit 服务器 ➐。现在，攻击者可以执行权限提升攻击并安装 rootkit。
- en: 'We can try performing this attack by installing a vulnerable version of the
    Firefox browser on the Ubuntu virtual machine. We’ll use Metasploit’s `browser_autopwn2`
    module to automatically scan a browser for a collection of exploits. Start the
    Metasploit console by opening a terminal in your Kali Linux virtual machine and
    running `msfconsole`. Once the Metasploit Framework is up and running, select
    the `browser_autopwn2` module by running the following command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试通过在 Ubuntu 虚拟机上安装一个易受攻击的 Firefox 浏览器版本来执行此攻击。我们将使用 Metasploit 的 `browser_autopwn2`
    模块自动扫描浏览器中的一系列漏洞。通过在 Kali Linux 虚拟机中打开终端并运行 `msfconsole` 启动 Metasploit 控制台。一旦
    Metasploit 框架启动并运行，运行以下命令选择 `browser_autopwn2` 模块：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Use the `options` command to see a list of available options. We’ll keep the
    default options, but to be stealthier, you might want to specify an SSL certificate
    and URL path instead of using a randomly generated one. For example, the tool
    URLCrazy can identify domains that look similar to domains you’re attacking.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `options` 命令查看可用选项列表。我们将保持默认选项，但为了更具隐蔽性，你可能想指定一个 SSL 证书和 URL 路径，而不是使用随机生成的选项。例如，工具
    URLCrazy 可以识别看起来与目标域名相似的域名。
- en: 'Now start the Metasploit server running the `browser_autopwn` code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过运行 `browser_autopwn` 代码来启动 Metasploit 服务器：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You should see the URL of the server ➊ and a list of the exploits the module
    will try ➋. Many of the exploits are outdated, though, and work only on Firefox
    27 or earlier. However, this module is open source, so maybe someone reading this
    book will update it with new exploits. For now, you’ll simply need to run them
    against an older version of Firefox. Download and install an older version on
    the Ubuntu virtual machine with the following commands:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能看到服务器的 URL ➊ 和模块将尝试的一系列漏洞 ➋。不过，许多漏洞已经过时，只能在 Firefox 27 或更早版本中工作。然而，这个模块是开源的，也许本书的某个读者会更新它，加入新的漏洞。现在，你只需在一个旧版本的
    Firefox 上运行它们。使用以下命令下载并安装 Ubuntu 虚拟机上的旧版本：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Time to use BeEF to inject some malicious JavaScript. Ensure that you’ve hooked
    the browser on the Ubuntu virtual machine by injecting a payload in the blog page
    on the Metasploitable server. Then, open the browser window containing the BeEF
    UI and click the browser associated with the Ubuntu virtual machine. As you did
    earlier in this chapter, select **Commands** and open the **Misc** folder. Click
    the **Raw JavaScript** module. This module allows you to inject any JavaScript
    you please into the page. In this case, we’ll inject a script that loads a malicious
    page associated with the `browser_autopwn2` module:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用 BeEF 注入一些恶意 JavaScript。确保你已经通过在 Metasploitable 服务器的博客页面中注入有效负载，成功挂钩了 Ubuntu
    虚拟机上的浏览器。然后，打开包含 BeEF UI 的浏览器窗口，点击与 Ubuntu 虚拟机关联的浏览器。正如本章前面所做的，选择 **Commands**
    并打开 **Misc** 文件夹。点击 **Raw JavaScript** 模块。这个模块允许你将任何 JavaScript 注入到页面中。在这种情况下，我们将注入一个脚本，加载与
    `browser_autopwn2` 模块关联的恶意页面：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This JavaScript command opens a tab in the user’s browser that will navigate
    to the malicious page. This is not very stealthy, but it is effective. A subtler
    approach would be to inject the JavaScript associated with the attack directly
    into the page. Click **Execute** and switch over to the terminal running your
    `browser_autopwn2` module. If the attack has successfully executed, you should
    have a new Meterpreter session. Enter `**sessions**` to see a list of your available
    sessions:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 JavaScript 命令会在用户的浏览器中打开一个标签页，并导航到恶意页面。这种方式不太隐蔽，但很有效。更微妙的方法是直接将与攻击相关的 JavaScript
    注入页面中。点击**执行**并切换到运行 `browser_autopwn2` 模块的终端。如果攻击成功执行，你应该会有一个新的 Meterpreter 会话。输入
    `**sessions**` 查看可用会话列表：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can interact with a session by entering the `**session**` keyword followed
    by the session number. For example, `sessions 1` lets you interface with the first
    session. Try running a simple command such as `**whoami**` or `**pwd**`, or you
    can run `**help**` to see all possible commands. You might want to use this shell
    to download a rootkit so that you can avoid detection and maintain access to the
    machine even after the browser has been updated.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过输入 `**session**` 关键字后跟会话号与会话互动。例如，`sessions 1` 让你与第一个会话交互。试着运行一些简单的命令，如
    `**whoami**` 或 `**pwd**`，或者你可以运行 `**help**` 查看所有可用的命令。你可能想利用这个 Shell 下载一个 rootkit，这样即使浏览器被更新后，你仍能避免被发现并保持对机器的访问权限。
- en: Pretty spooky, right? To protect yourself, pay attention to the sites you visit,
    and if you’re super paranoid, install the NoScript plug-in. It prevents your browser
    from running any JavaScript.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来有点吓人，对吧？为了保护自己，要注意你访问的网站，如果你特别偏执，可以安装 NoScript 插件。它会阻止浏览器运行任何 JavaScript。
- en: '**Exercise: Hunting for Bugs in a Bug Bounty Program**'
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**练习：在漏洞奖励计划中寻找漏洞**'
- en: It’s time for you to go out and hunt on your own. Because you’re an ethical
    hacker, you won’t attack companies without their permission. Luckily, many companies
    create *bug bounty programs* that allow ethical hackers to attack their websites
    and receive payment for any vulnerabilities they find. Each bug bounty program
    has its own rules outlining what parts of the website can be attacked and other
    limitations (for example, no social engineering attacks). *[Hackerone.com](http://Hackerone.com)*
    maintains a list of bug bounty programs. To sharpen your skills while you hunt
    for bugs, take a look at *Real-World Bug Hunting* by Peter Yaworski (No Starch
    Press, 2019), which describes the bugs discovered while participating in bug bounty
    programs (and the rewards earned). In addition to XSS and SQL injection, Yaworski
    covers other vulnerabilities, such as race conditions, memory vulnerabilities,
    and cross-site request forgery. Happy hunting.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在该你自己去猎杀了。因为你是一个道德黑客，你不会在没有公司许可的情况下攻击它们。幸运的是，许多公司创建了*漏洞奖励计划*，允许道德黑客攻击它们的网站，并为发现的任何漏洞支付报酬。每个漏洞奖励计划都有自己的规则，列明可以攻击网站的哪些部分以及其他限制（例如，不允许社会工程学攻击）。*[Hackerone.com](http://Hackerone.com)*
    维护着一个漏洞奖励计划的列表。为了在寻找漏洞时提升你的技能，看看 Peter Yaworski 的 *《现实世界漏洞狩猎》*（No Starch Press，2019），这本书描述了在参与漏洞奖励计划时发现的漏洞（以及所获得的奖励）。除了
    XSS 和 SQL 注入，Yaworski 还介绍了其他漏洞，如竞态条件、内存漏洞和跨站请求伪造。祝你好运。
