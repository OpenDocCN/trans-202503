- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp> <samp class="SANS_Dogma_OT_Bold_B_11">EXPRESSIONS
    AND OPERATORS</samp>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp> <samp class="SANS_Dogma_OT_Bold_B_11">表达式与运算符</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: In this chapter, you’ll learn about operators and how to write simple expressions
    to perform operations on various object types. An *operator* is a keyword or one
    or more punctuation characters used to perform an operation. When an operator
    is applied to one or more operands, it becomes an expression that computes a value
    and that might have side effects. *Expressions* are sequences of operators and
    operands that compute a value or accomplish another purpose. The operands can
    be identifiers, constants, string literals, and other expressions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习运算符以及如何编写简单的表达式来对各种对象类型进行操作。*运算符*是用于执行操作的关键字或一个或多个标点符号。当运算符应用于一个或多个操作数时，它会成为一个计算值的表达式，并且可能具有副作用。*表达式*是由运算符和操作数组成的序列，用来计算一个值或完成其他目的。操作数可以是标识符、常量、字符串字面量或其他表达式。
- en: In this chapter, we discuss simple assignment before stepping back to examine
    the mechanics of expressions (operators and operands, value computations, side
    effects, precedence, and order of evaluation). We then consider specific operators
    including <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>, arithmetic,
    bitwise, cast, conditional, alignment, relational, compound assignment, and the
    comma operator. We’ve introduced many of these operators and expressions in previous
    chapters; here, we detail their behavior and how best to use them. Finally, we
    end the chapter with a discussion of pointer arithmetic.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们在深入探讨表达式的机制（包括运算符与操作数、值计算、副作用、优先级以及求值顺序）之前，先讨论简单赋值。接着，我们会讨论具体的运算符，包括
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>、算术运算符、按位运算符、强制类型转换运算符、条件运算符、对齐运算符、关系运算符、复合赋值运算符以及逗号运算符。我们在前几章中已经介绍了这些运算符和表达式；在这一章，我们详细讲解它们的行为及最佳使用方式。最后，我们将以指针运算的讨论结束本章内容。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Simple Assignment</samp>
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">简单赋值</samp>
- en: 'A *simple assignment* replaces the value stored in the object designated by
    the left operand with the right operand. The value of the right operand is converted
    to the type of the assignment expression. Simple assignment has three components:
    the left operand, the assignment (<samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>)
    operator, and the right operand, as shown in the following example:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*简单赋值*将左操作数指定的对象中的值替换为右操作数的值。右操作数的值会被转换为赋值表达式的类型。简单赋值有三个组成部分：左操作数、赋值（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp>）运算符和右操作数，如下例所示：'
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first two lines are *declarations* that define and initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    with the value 21 and <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> with
    the value 7\. Initialization is different from simple assignment despite having
    similar syntax. An *initializer* is an optional part of a declaration; when present,
    it provides the initial value for the object. If the initializer is not present,
    objects (with automatic storage duration) are uninitialized.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行是*声明*，它们将变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> 初始化为 21，将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> 初始化为 7。初始化不同于简单赋值，尽管它们具有相似的语法。*初始化器*是声明中的可选部分；如果存在，它会为对象提供初始值。如果没有初始化器，具有自动存储周期的对象将未初始化。
- en: The third line contains a simple assignment. You must define or declare all
    identifiers that appear in an expression (such as a simple assignment) for your
    code to compile.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 第三行包含一个简单赋值。为了使代码能够编译，你必须定义或声明所有在表达式中出现的标识符（例如在简单赋值中）。
- en: The left operand in a simple assignment is always an expression (with an object
    type other than <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>), referred
    to as an *lvalue*. The *l* in lvalue originally comes from it being the *left*
    operand, but it may be more correct to think of it as standing for *locator value*,
    because it must designate an object. The right operand is also an expression,
    but it can simply be a value and doesn’t need to identify an object. We refer
    to this value as an *rvalue* (*right* operand) or *expression value*. In this
    example, the identifiers for both objects <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> are lvalues. An lvalue
    can also be an expression, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">*(p
    + 4)</samp>, provided it references an object in memory.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单赋值中，左操作数总是一个表达式（其对象类型不为 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>），称为
    *左值*。左值中的 *l* 原本来源于它是 *左* 操作数，但更准确地说，可以理解为 *定位值*（locator value），因为它必须指向一个对象。右操作数也是一个表达式，但它可以仅仅是一个值，并不需要指向一个对象。我们将这个值称为
    *右值*（*右* 操作数）或 *表达式值*。在这个例子中，两个对象的标识符 <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> 都是左值。左值也可以是一个表达式，例如 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">*(p + 4)</samp>，只要它引用了内存中的一个对象。
- en: In a simple assignment, the rvalue is converted to the type of the lvalue and
    then stored in the object designated by the lvalue. In the assignment <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp>,
    the value is read from <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp>
    and written to <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>. Because
    both <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp>
    are the same type (<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>),
    no conversion is necessary. The assignment expression has the value of the result
    of the assignment and the type of the lvalue.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单的赋值中，右值（rvalue）会被转换为左值（lvalue）的类型，然后存储到由左值指定的对象中。在赋值 <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp>
    中，值从 <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> 中读取并写入到 <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    中。由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp>
    是相同类型（<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>），因此不需要转换。赋值表达式的结果值是赋值的结果，类型为左值的类型。
- en: 'The rvalue does not need to refer to an object, as you can see in the following
    statement, which uses the types and values from the preceding example:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 右值不需要指向一个对象，如以下语句所示，它使用了前面示例中的类型和值：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The expression <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp>
    is not an lvalue, because there is no underlying object storing the result. Instead,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> by itself is an lvalue
    that is automatically converted into an rvalue to be used as an operand to the
    addition operation. The resulting value from the addition operation (which has
    no memory location associated with it) is also an rvalue. C constrains where lvalues
    and rvalues may appear. The following statements illustrate the correct and incorrect
    use of lvalues and rvalues:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp> 不是左值，因为没有底层对象存储结果。相反，单独的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> 是一个左值，会自动转换为右值，作为加法操作的操作数。加法操作的结果（没有与之关联的内存位置）也是一个右值。C
    语言规定了左值和右值出现的位置。以下语句展示了左值和右值的正确与错误使用：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The assignment <samp class="SANS_TheSansMonoCd_W5Regular_11">7</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    doesn’t compile because the rvalue must always appear on the right side of the
    operator.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值 <samp class="SANS_TheSansMonoCd_W5Regular_11">7</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> 无法编译，因为右值必须始终出现在操作符的右侧。
- en: 'In the following example, the right operand has a different type from the assignment
    expression, so the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    is first converted to a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>
    type. The value of the expression enclosed in parentheses is then converted to
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">long int</samp> type and assigned
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp>:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，右操作数的类型与赋值表达式不同，因此<samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>的值首先被转换为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>类型。括号内的表达式值随后被转换为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">long int</samp>类型，并赋值给<samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp>：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Assignment must deal with real-world constraints. Specifically, simple assignment
    can result in truncation if a value is converted to a narrower type. As mentioned
    in [Chapter 3](chapter3.xhtml), each object requires a fixed number of bytes of
    storage. The value of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> can
    always be represented by <samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp>
    (a larger type of the same signedness). However, in this example, the value of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> is converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char</samp> (the type of the assignment expression <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>).
    The value of the expression enclosed in parentheses is then converted to the type
    of the outer assignment expression—that is, <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    int</samp> type. If your implementation’s <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char</samp> type has insufficient width to fully represent the value stored in
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>, values greater than <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SCHAR_MAX</samp> are truncated, and the
    value stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp> (−1) is
    truncated. To prevent values from being truncated, make sure that you choose sufficiently
    wide types that can represent any value that might arise.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值必须处理现实世界的约束。具体来说，简单的赋值如果将值转换为较窄的类型，可能会导致截断。正如在[第3章](chapter3.xhtml)中提到的，每个对象都需要固定数量的字节存储。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">i</samp>的值始终可以由<samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp>（相同符号的较大类型）表示。然而，在这个例子中，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">i</samp>的值被转换为<samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char</samp>（赋值表达式<samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>的类型）。括号内的表达式值接着被转换为外层赋值表达式的类型——即<samp
    class="SANS_TheSansMonoCd_W5Regular_11">long int</samp>类型。如果你的实现中<samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char</samp>类型的宽度不足以完全表示存储在<samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>中的值，则大于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SCHAR_MAX</samp>的值会被截断，而存储在<samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp>中的值（−1）也会被截断。为了防止值被截断，确保选择足够宽的类型来表示可能出现的任何值。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Evaluations</samp>
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">评估</samp>
- en: Now that we’ve looked at simple assignment, let’s step back for a moment and
    look at how expressions are evaluated. *Evaluation* mostly means simplifying an
    expression down to a single value. The evaluation of an expression can include
    both value computations and the initiation of side effects.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过了简单赋值，让我们暂时回顾一下表达式是如何评估的。*评估*主要是指将表达式简化为单一的值。表达式的评估可以包括值计算和副作用的引发。
- en: 'A *value computation* is the calculation of the value that results from the
    evaluation of the expression. Computing the final value may involve determining
    the identity of the object or reading the value previously assigned to an object.
    For example, the following expression contains several value computations to determine
    the identity of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">a[i]</samp>:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*值计算*是指通过表达式的评估计算出的结果值。计算最终值可能包括确定对象的身份或读取先前赋值给对象的值。例如，以下表达式包含多个值计算，用于确定<samp
    class="SANS_TheSansMonoCd_W5Regular_11">i</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">a[i]</samp>的身份：'
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Because <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> is a function
    and not an object, the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">f()</samp>
    doesn’t involve determining the identity of <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>.
    The value computations of operands must occur before the value computation of
    the result of the operator. In this example, separate value computations read
    the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">a[i]</samp> and determine
    the value returned by the call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    function. A third computation then sums these values to obtain the value returned
    by the overall expression. If <samp class="SANS_TheSansMonoCd_W5Regular_11">a[i]</samp>
    is an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">f()</samp> returns an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    the result of the expression will have the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    type.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> 是一个函数而不是一个对象，所以表达式
    <samp class="SANS_TheSansMonoCd_W5Regular_11">f()</samp> 不涉及确定 <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    的身份。操作数的值计算必须在操作符结果的值计算之前发生。在这个示例中，单独的值计算读取了 <samp class="SANS_TheSansMonoCd_W5Regular_11">a[i]</samp>
    的值，并确定了调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> 函数返回的值。然后，第三次计算将这些值相加，得到整体表达式返回的值。如果
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a[i]</samp> 是一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    类型的数组，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">f()</samp> 返回一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    类型的值，则该表达式的结果将是 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型。
- en: '*Side effects* are changes to the state of the execution environment. Side
    effects include writing to an object, accessing (reading or writing) a <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>-qualified
    object, input/output (I/O), assignment, or calling a function that does any of
    these things. We can slightly modify the previous example to add an assignment.
    Updating the stored value of <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp>
    is a side effect of the assignment:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*副作用* 是对执行环境状态的改变。副作用包括写入一个对象、访问（读取或写入）一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>
    修饰的对象、输入/输出（I/O）、赋值或调用任何执行这些操作的函数。我们可以稍微修改前面的示例，添加一个赋值。更新 <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp>
    的存储值是赋值的副作用：'
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The assignment to <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> is
    a side effect that changes the state of the execution environment. Depending on
    the definition of the <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> function,
    the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> may also have
    side effects.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对 <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> 的赋值是一个副作用，它改变了执行环境的状态。根据
    <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> 函数的定义，调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    也可能会有副作用。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Function Invocation</samp>
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">函数调用</samp>
- en: 'A *function designator* is an expression that has a function type and is used
    to invoke a function. In the following function invocation, <samp class="SANS_TheSansMonoCd_W5Regular_11">max</samp>
    is the function designator:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数设计符* 是具有函数类型的表达式，用于调用函数。在以下函数调用中，<samp class="SANS_TheSansMonoCd_W5Regular_11">max</samp>
    是函数设计符：'
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">max</samp> function returns
    the larger of its two arguments. In an expression, a function designator is converted
    to a *pointer-to-function returning type* at compile time. The value of each argument
    must be of a type that can be assigned to an object with (the unqualified version
    of) the type of its corresponding parameter. The number and type of each argument
    must agree with the number and type of each parameter accepted by the function.
    Here, that means two integer arguments. C also supports *variadic functions*,
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>, which accept
    a variable number of arguments.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">max</samp> 函数返回两个参数中较大的一个。在表达式中，函数设计符在编译时会被转换为
    *返回类型的函数指针*。每个参数的值必须是可以赋值给与其对应的参数类型（无限定符版本）相匹配的对象的类型。每个参数的数量和类型必须与函数接受的参数数量和类型一致。这里指的是两个整数参数。C
    语言还支持 *变参函数*，例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>，它可以接受可变数量的参数。
- en: We can also pass one function to another, as shown by [Listing 4-1](chapter4.xhtml#Lis4-1).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将一个函数传递给另一个函数，如 [示例 4-1](chapter4.xhtml#Lis4-1) 所示。
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-1: Passing one function
    to another function</samp>'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 4-1：将一个函数传递给另一个函数</samp>
- en: This code passes the address of a function designated by <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    to another function, <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>. The
    function <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> accepts a pointer
    to a function that accepts no arguments and returns <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    A function passed as an argument is implicitly converted to a function pointer.
    The definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> makes
    this explicit; an equivalent declaration is <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    g(int func(void))</samp>.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将由<samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>指定的函数的地址传递给另一个函数<samp
    class="SANS_TheSansMonoCd_W5Regular_11">g</samp>。函数<samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>接受一个指向无参数并返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>类型的函数的指针。作为参数传递的函数会隐式转换为函数指针。函数<samp
    class="SANS_TheSansMonoCd_W5Regular_11">g</samp>的定义使这一点变得显式；等价的声明为<samp class="SANS_TheSansMonoCd_W5Regular_11">void
    g(int func(void))</samp>。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Increment and Decrement Operators</samp>
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">增量和减量运算符</samp>
- en: The *increment* (<samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp>) and
    *decrement* (<samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>) operators
    increment and decrement a modifiable lvalue, respectively. Both are *unary operators*
    because they take a single operand.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*增量*（<samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp>）和*减量*（<samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>）运算符分别对可修改的左值进行增减操作。它们都是*一元运算符*，因为它们只接受一个操作数。'
- en: These operators can be used as either *prefix operators*, which appear before
    the operand, or *postfix operators*, which come after the operand. The prefix
    and postfix operators have different behaviors, which means they are commonly
    used as trick questions in quizzes and interviews. A prefix increment performs
    the increment before returning the value, whereas a postfix increment returns
    the value and then performs the increment. [Listing 4-2](chapter4.xhtml#Lis4-2)
    illustrates these behaviors by performing a prefix or postfix increment or decrement
    operation and then assigning the result to <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp>.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运算符可以作为*前缀运算符*使用，出现在操作数之前，也可以作为*后缀运算符*使用，出现在操作数之后。前缀和后缀运算符的行为不同，这意味着它们通常作为测验和面试中的难题。前缀增量运算符在返回值之前执行增量操作，而后缀增量运算符则在返回值之后执行增量操作。[示例
    4-2](chapter4.xhtml#Lis4-2)通过执行前缀或后缀增量或减量操作，并将结果赋值给<samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp>，展示了这些行为。
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-2: The prefix and
    postfix increment and decrement operators</samp>'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 4-2：前缀和后缀增量和减量运算符</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">i++</samp> operation in this
    example returns the unchanged value <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>,
    which is then assigned to <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp>.
    The value of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> is then incremented
    as a side effect of the operation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中的<samp class="SANS_TheSansMonoCd_W5Regular_11">i++</samp>操作返回未更改的值<samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>，然后将其赋值给<samp
    class="SANS_TheSansMonoCd_W5Regular_11">e</samp>。然后，<samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>的值作为该操作的副作用被增量化。
- en: 'The *prefix* increment operator increments the value of the operand, and the
    expression returns the new value of the operand after it has been incremented.
    Consequently, the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">++i</samp>
    is equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    except that <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> is evaluated
    only once. The <samp class="SANS_TheSansMonoCd_W5Regular_11">++i</samp> operation
    in this example returns the incremented value <samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp>,
    which is then assigned to <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp>.  ##
    <samp class="SANS_Futura_Std_Bold_B_11">Operator Precedence and Associativity</samp>'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*前缀*递增运算符增加操作数的值，并且该表达式返回递增后的操作数的新值。因此，表达式<samp class="SANS_TheSansMonoCd_W5Regular_11">++i</samp>等同于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">i</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>，唯一的区别是<samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>只会被评估一次。此示例中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">++i</samp>操作返回递增后的值<samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp>，然后将其赋值给<samp
    class="SANS_TheSansMonoCd_W5Regular_11">e</samp>。  ## <samp class="SANS_Futura_Std_Bold_B_11">运算符优先级与结合性</samp>'
- en: In mathematics and computer programming, the *order of operations* (or *operator
    precedence*) is a collection of rules that dictates the order in which operations
    are performed during the evaluation of an expression. For example, multiplication
    is granted a higher precedence than addition. Therefore, the expression 2 + 3
    × 4 is interpreted to have the value 2 + (3 × 4) = 14, not (2 + 3) × 4 = 20.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学和计算机编程中，*运算顺序*（或*运算符优先级*）是一组规则，规定了在求值表达式时，操作执行的顺序。例如，乘法的优先级高于加法。因此，表达式2 +
    3 × 4的值为2 + (3 × 4) = 14，而不是(2 + 3) × 4 = 20。
- en: '*Associativity* determines how operators of the same precedence are grouped
    when no parentheses are used. C associativity differs from mathematics associativity.
    For example, while floating-point addition and multiplication are both commutative
    (*a* + *b* = *b* + *a* and *a* × *b* = *b* × *a*), they are not necessarily associative.
    If adjacent operators have equal precedence, the choice of which operation to
    apply first is determined by the associativity. *Left-associative* operators cause
    the operations to be grouped from the left, while *right-associative* operators
    cause the operations to be grouped from the right. You can think of grouping as
    the implicit introduction of parentheses. For example, the addition (<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>)
    operator has left associativity, so the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    is interpreted as <samp class="SANS_TheSansMonoCd_W5Regular_11">((a</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b)</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c)</samp>.
    The assignment operator is right-associative, so the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    is interpreted as <samp class="SANS_TheSansMonoCd_W5Regular_11">(a</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c))</samp>.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*结合性*决定了在没有使用括号时，相同优先级的运算符如何进行分组。C 的结合性与数学中的结合性不同。例如，虽然浮点加法和乘法都是交换律成立的（*a*
    + *b* = *b* + *a* 和 *a* × *b* = *b* × *a*），但它们不一定是结合律成立的。如果相邻的运算符具有相同的优先级，决定首先执行哪个操作的依据是结合性。*左结合*的运算符会使操作从左向右分组，而*右结合*的运算符则会使操作从右向左分组。你可以把分组理解为隐式地引入了括号。例如，加法（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp>）运算符是左结合的，因此表达式 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    会被解释为 <samp class="SANS_TheSansMonoCd_W5Regular_11">((a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b)</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">c)</samp>。赋值运算符是右结合的，因此表达式 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> 会被解释为 <samp class="SANS_TheSansMonoCd_W5Regular_11">(a</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c))</samp>。'
- en: '[Table 4-1](chapter4.xhtml#tab4-1), derived from the C Operator Precedence
    table at the C++ References website (*[https://<wbr>en<wbr>.cppreference<wbr>.com<wbr>/w<wbr>/c<wbr>/language<wbr>/operator<wbr>_precedence](https://en.cppreference.com/w/c/language/operator_precedence)*),
    lists the precedence and associativity of C operators, as specified by the language
    syntax. Operators are listed in order of descending precedence (that is, higher
    rows have higher precedence).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 4-1](chapter4.xhtml#tab4-1)，来源于 C++ References 网站上的 C 运算符优先级表 (*[https://<wbr>en<wbr>.cppreference<wbr>.com<wbr>/w<wbr>/c<wbr>/language<wbr>/operator<wbr>_precedence](https://en.cppreference.com/w/c/language/operator_precedence)*)，列出了
    C 运算符的优先级和结合性，按照语言语法进行规定。运算符按照优先级递减的顺序列出（也就是说，越靠上的行优先级越高）。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-1:</samp> <samp class="SANS_Futura_Std_Book_11">Operator
    Precedence and Associativity</samp>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 4-1：</samp> <samp class="SANS_Futura_Std_Book_11">运算符优先级和结合性</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Precedence</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Operator</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Associativity</samp>
    |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">优先级</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">运算符</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">描述</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">结合性</samp>
    |'
- en: '| --- | --- | --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">(...)</samp>
    | <samp class="SANS_Futura_Std_Book_11">Forced grouping</samp> | <samp class="SANS_Futura_Std_Book_11">Left</samp>
    |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">(...)</samp>
    | <samp class="SANS_Futura_Std_Book_11">强制分组</samp> | <samp class="SANS_Futura_Std_Book_11">左侧</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> | <samp class="SANS_Futura_Std_Book_11">Postfix
    increment and decrement</samp> | <samp class="SANS_Futura_Std_Book_11">Left</samp>
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> | <samp class="SANS_Futura_Std_Book_11">后缀递增与递减</samp>
    | <samp class="SANS_Futura_Std_Book_11">左侧</samp> |'
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">()</samp> | <samp class="SANS_Futura_Std_Book_11">Function
    call</samp> |  |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">()</samp> | <samp class="SANS_Futura_Std_Book_11">函数调用</samp>
    |  |'
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp> | <samp class="SANS_Futura_Std_Book_11">Array
    subscripting</samp> |  |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp> | <samp class="SANS_Futura_Std_Book_11">数组下标</samp>
    |  |'
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> | <samp class="SANS_Futura_Std_Book_11">Structure
    and union member access</samp> |  |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> | <samp class="SANS_Futura_Std_Book_11">结构体与联合体成员访问</samp>
    |  |'
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp> | <samp class="SANS_Futura_Std_Book_11">Structure
    and union member access through pointer</samp> |  |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp> | <samp class="SANS_Futura_Std_Book_11">通过指针访问结构体与联合体成员</samp>
    |  |'
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">type</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">){</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">list</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">}</samp> | <samp class="SANS_Futura_Std_Book_11">Compound
    literal</samp> |  |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">type</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">){</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">list</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">}</samp> | <samp class="SANS_Futura_Std_Book_11">复合字面量</samp>
    |  |'
- en: '| <samp class="SANS_Futura_Std_Book_11">2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> | <samp class="SANS_Futura_Std_Book_11">Prefix
    increment and decrement</samp> | <samp class="SANS_Futura_Std_Book_11">Right</samp>
    |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> | <samp class="SANS_Futura_Std_Book_11">前缀递增与递减</samp>
    | <samp class="SANS_Futura_Std_Book_11">右侧</samp> |'
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>
    | <samp class="SANS_Futura_Std_Book_11">Unary plus and minus</samp> |  |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>
    | <samp class="SANS_Futura_Std_Book_11">一元加与减</samp> |  |'
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">! ~</samp> | <samp class="SANS_Futura_Std_Book_11">Logical
    NOT and bitwise NOT</samp> |  |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">! ~</samp> | <samp class="SANS_Futura_Std_Book_11">逻辑非与按位非</samp>
    |  |'
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">type</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp> | <samp class="SANS_Futura_Std_Book_11">Type
    cast</samp> |  |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">type</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp> | <samp class="SANS_Futura_Std_Book_11">类型转换</samp>
    |  |'
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> | <samp class="SANS_Futura_Std_Book_11">Indirection
    (dereference)</samp> |  |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> | <samp class="SANS_Futura_Std_Book_11">间接寻址（解引用）</samp>
    |  |'
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> | <samp class="SANS_Futura_Std_Book_11">Address-of</samp>
    |  |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> | <samp class="SANS_Futura_Std_Book_11">取地址</samp>
    |  |'
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> | <samp class="SANS_Futura_Std_Book_11">Size
    of</samp> |  |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> | <samp class="SANS_Futura_Std_Book_11">大小</samp>
    |  |'
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">_Alignof</samp> | <samp
    class="SANS_Futura_Std_Book_11">Alignment requirement</samp> |  |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">_Alignof</samp> | <samp
    class="SANS_Futura_Std_Book_11">对齐要求</samp> |  |'
- en: '| <samp class="SANS_Futura_Std_Book_11">3</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">*
    / %</samp> | <samp class="SANS_Futura_Std_Book_11">Multiplication, division, and
    remainder</samp> | <samp class="SANS_Futura_Std_Book_11">Left</samp> |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">3</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">*
    / %</samp> | <samp class="SANS_Futura_Std_Book_11">乘法、除法和余数</samp> | <samp class="SANS_Futura_Std_Book_11">左</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">4</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> | <samp class="SANS_Futura_Std_Book_11">Addition
    and subtraction</samp> |  |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">4</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> | <samp class="SANS_Futura_Std_Book_11">加法和减法</samp>
    |  |'
- en: '| <samp class="SANS_Futura_Std_Book_11">5</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11"><<
    >></samp> | <samp class="SANS_Futura_Std_Book_11">Bitwise left shift and right
    shift</samp> |  |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">5</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11"><<
    >></samp> | <samp class="SANS_Futura_Std_Book_11">按位左移和右移</samp> |  |'
- en: '| <samp class="SANS_Futura_Std_Book_11">6</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11"><
    <=</samp> | <samp class="SANS_Futura_Std_Book_11">Relational operators < and ≤</samp>
    |  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">6</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11"><
    <=</samp> | <samp class="SANS_Futura_Std_Book_11">关系运算符 < 和 ≤</samp> |  |'
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">> >=</samp> | <samp class="SANS_Futura_Std_Book_11">Relational
    operators > and ≥</samp> |  |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">> >=</samp> | <samp class="SANS_Futura_Std_Book_11">关系运算符
    > 和 ≥</samp> |  |'
- en: '| <samp class="SANS_Futura_Std_Book_11">7</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp> | <samp class="SANS_Futura_Std_Book_11">Equal
    to and not equal to</samp> |  |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">7</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp> | <samp class="SANS_Futura_Std_Book_11">等于和不等于</samp>
    |  |'
- en: '| <samp class="SANS_Futura_Std_Book_11">8</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    | <samp class="SANS_Futura_Std_Book_11">Bitwise AND</samp> |  |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">8</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    | <samp class="SANS_Futura_Std_Book_11">按位与</samp> |  |'
- en: '| <samp class="SANS_Futura_Std_Book_11">9</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp>
    | <samp class="SANS_Futura_Std_Book_11">Bitwise XOR (exclusive or)</samp> |  |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">9</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp>
    | <samp class="SANS_Futura_Std_Book_11">按位异或（独占或）</samp> |  |'
- en: '| <samp class="SANS_Futura_Std_Book_11">10</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">&#124;</samp>
    | <samp class="SANS_Futura_Std_Book_11">Bitwise OR (inclusive or)</samp> |  |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">10</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">&#124;</samp>
    | <samp class="SANS_Futura_Std_Book_11">按位或（包括或）</samp> |  |'
- en: '| <samp class="SANS_Futura_Std_Book_11">11</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>
    | <samp class="SANS_Futura_Std_Book_11">Logical AND</samp> |  |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">11</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>
    | <samp class="SANS_Futura_Std_Book_11">逻辑与</samp> |  |'
- en: '| <samp class="SANS_Futura_Std_Book_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">&#124;&#124;</samp>
    | <samp class="SANS_Futura_Std_Book_11">Logical OR</samp> |  |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">&#124;&#124;</samp>
    | <samp class="SANS_Futura_Std_Book_11">逻辑或</samp> |  |'
- en: '| <samp class="SANS_Futura_Std_Book_11">13</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">?
    :</samp> | <samp class="SANS_Futura_Std_Book_11">Conditional operator</samp> |
    <samp class="SANS_Futura_Std_Book_11">Right</samp> |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">13</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">?
    :</samp> | <samp class="SANS_Futura_Std_Book_11">条件运算符</samp> | <samp class="SANS_Futura_Std_Book_11">右</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">14</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    | <samp class="SANS_Futura_Std_Book_11">Simple assignment</samp> |  |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">14</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    | <samp class="SANS_Futura_Std_Book_11">简单赋值</samp> |  |'
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">+=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-=</samp>
    | <samp class="SANS_Futura_Std_Book_11">Assignment by sum and difference</samp>
    |  |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">+=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-=</samp>
    | <samp class="SANS_Futura_Std_Book_11">加减赋值</samp> |  |'
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">*=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">/=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">%=</samp> | <samp class="SANS_Futura_Std_Book_11">Assignment
    by product, quotient, and remainder</samp> |  |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">*=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">/=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">%=</samp> | <samp class="SANS_Futura_Std_Book_11">按乘积、商和余数赋值</samp>
    |  |'
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11"><<=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">>>=</samp>
    | <samp class="SANS_Futura_Std_Book_11">Assignment by bitwise left shift and right
    shift</samp> |  |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11"><<=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">>>=</samp>
    | <samp class="SANS_Futura_Std_Book_11">按位左移和右移赋值</samp> |  |'
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">&= ^=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&#124;=</samp>
    | <samp class="SANS_Futura_Std_Book_11">Assignment by bitwise AND, XOR, and OR</samp>
    |  |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">&= ^=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&#124;=</samp>
    | <samp class="SANS_Futura_Std_Book_11">按位与、异或和或赋值</samp> |  |'
- en: '| <samp class="SANS_Futura_Std_Book_11">15</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp>
    | <samp class="SANS_Futura_Std_Book_11">Expression sequencing</samp> | <samp class="SANS_Futura_Std_Book_11">Left</samp>
    |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">15</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp>
    | <samp class="SANS_Futura_Std_Book_11">表达式顺序</samp> | <samp class="SANS_Futura_Std_Book_11">左</samp>
    |'
- en: Sometimes operator precedence can be intuitive, and sometimes it can be misleading.
    For example, the postfix <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> operators have higher
    precedence than both the prefix <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> operators, which in
    turn have the same precedence as the unary <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    operator. For example, if <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    is a pointer, then <samp class="SANS_TheSansMonoCd_W5Regular_11">*p++</samp> is
    equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">*(p++)</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">++*p</samp> is equivalent to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">++(*p)</samp>, because both the prefix
    <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp> operator and the unary
    <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> operator are right-associative.
    If two operators have the same precedence and associativity, they are evaluated
    from left to right. [Listing 4-3](chapter4.xhtml#Lis4-3) illustrates the precedence
    rules among these operators.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，运算符的优先级是直观的，但有时也可能会误导。例如，后缀运算符 <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> 的优先级高于前缀运算符 <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>，而前缀运算符和一元运算符 <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    的优先级相同。例如，如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> 是一个指针，那么 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">*p++</samp> 等同于 <samp class="SANS_TheSansMonoCd_W5Regular_11">*(p++)</samp>，而
    <samp class="SANS_TheSansMonoCd_W5Regular_11">++*p</samp> 等同于 <samp class="SANS_TheSansMonoCd_W5Regular_11">++(*p)</samp>，因为前缀运算符
    <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp> 和一元运算符 <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    都是右结合的。如果两个运算符具有相同的优先级和结合性，它们将按从左到右的顺序进行求值。[示例 4-3](chapter4.xhtml#Lis4-3) 展示了这些运算符之间的优先级规则。
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-3: The operator precedence
    rules</samp>'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 4-3: 运算符优先级规则</samp>'
- en: The pointer in the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">++*p</samp>
    is first dereferenced, producing the <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    character. This value is then incremented, resulting in the character <samp class="SANS_TheSansMonoCd_W5Regular_11">d</samp>.
    In this case, the prefix <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp>
    operator operates on the object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    pointed to by <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> and not the
    pointer. On the other hand, the pointer in the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">*q++</samp>
    is incremented first, so it refers to the <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    character. However, the result of *postfix* increment operators is the value of
    the operand so that the original pointer value is dereferenced, producing the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> character. Consequently,
    this code prints out the characters <samp class="SANS_TheSansMonoCd_W5Regular_11">dx</samp>.
    You can use parentheses to change or clarify the order of operations.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 <samp class="SANS_TheSansMonoCd_W5Regular_11">++*p</samp> 中的指针首先被解引用，产生
    <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> 字符。然后该值被递增，结果为字符 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">d</samp>。在这种情况下，前缀 <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp>
    运算符作用于指针 <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> 所指向的 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    类型的对象，而不是指针本身。另一方面，表达式 <samp class="SANS_TheSansMonoCd_W5Regular_11">*q++</samp>
    中的指针先被递增，因此它指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> 字符。然而，后缀递增运算符的结果是操作数的值，因此原始的指针值被解引用，产生了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 字符。因此，这段代码打印出字符 <samp class="SANS_TheSansMonoCd_W5Regular_11">dx</samp>。你可以使用括号来改变或明确操作顺序。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Order of Evaluation</samp>
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">求值顺序</samp>
- en: The *order of evaluation* of the operands of any C operator, including the order
    of evaluation of any subexpressions, is generally unspecified. The compiler will
    evaluate them in any order and may choose a different order when the same expression
    is evaluated again. This latitude allows the compiler to produce faster code by
    choosing the most efficient order. The order of evaluation is constrained by operator
    precedence and associativity.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 C 运算符的操作数的*求值顺序*，包括任何子表达式的求值顺序，通常是未指定的。编译器会以任意顺序对它们进行求值，并且在相同表达式再次求值时，可能会选择不同的顺序。这种灵活性允许编译器通过选择最有效的顺序来生成更快的代码。求值顺序受运算符优先级和结合性的约束。
- en: '[Listing 4-4](chapter4.xhtml#Lis4-4) demonstrates the order of evaluation for
    function arguments.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4-4](chapter4.xhtml#Lis4-4) 演示了函数参数的求值顺序。'
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-4: The order of evaluation
    for function arguments</samp>'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 4-4：函数参数的求值顺序</samp>
- en: Both functions <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">g</samp> access the global variable <samp
    class="SANS_TheSansMonoCd_W5Regular_11">glob</samp>, meaning they rely on a shared
    state. Because the order of evaluation of functions <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> is unspecified, the
    arguments passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">max</samp> may
    differ between compilations. If <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    is called first, it will return 10, but if it’s called last, it will return 52\.
    Function <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> always returns
    42 regardless of the order of evaluation. Consequently, the <samp class="SANS_TheSansMonoCd_W5Regular_11">max</samp>
    function (which returns the greater of the two values) may return either 42 or
    52, depending on the order of evaluation of its arguments. The only *sequencing
    guarantees* provided by this code are that both <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> are called before <samp
    class="SANS_TheSansMonoCd_W5Regular_11">max</samp> and that the executions of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>
    do not interleave.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>
    都访问全局变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">glob</samp>，意味着它们依赖于共享状态。由于函数
    <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>
    的评估顺序未指定，因此传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">max</samp> 的参数在不同编译之间可能会有所不同。如果
    <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> 首先被调用，它会返回 10，但如果最后调用，它会返回
    52。函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> 始终返回 42，无论评估顺序如何。因此，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">max</samp> 函数（返回两个值中的较大者）可能会根据评估参数的顺序返回
    42 或 52。此代码提供的唯一*顺序保证*是，<samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> 都会在 <samp class="SANS_TheSansMonoCd_W5Regular_11">max</samp>
    之前被调用，并且 <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>
    的执行不会交叉进行。
- en: 'We can rewrite this code as follows to ensure it always behaves in a predictable,
    portable manner:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这段代码重写如下，以确保它总是以可预测、可移植的方式执行：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this revised program, <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    is called to initialize the <samp class="SANS_TheSansMonoCd_W5Regular_11">f_val</samp>
    variable. This is guaranteed to be sequenced before the execution of <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>,
    which is called in the subsequent declaration to initialize the variable <samp
    class="SANS_TheSansMonoCd_W5Regular_11">g_val</samp>. If one evaluation is *sequenced
    before* another evaluation, the first evaluation must complete before the second
    evaluation can begin. You can use sequence points (discussed in the following
    subsections) to guarantee that an object will be written before it is read. The
    execution of <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> is guaranteed
    to be sequenced before the execution of <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>
    because a sequence point exists between the evaluation of one full expression
    and the next full expression.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个修改后的程序中，<samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> 被调用来初始化 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">f_val</samp> 变量。保证在执行 <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>
    之前，<samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> 会先被执行，<samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>
    会在后续声明中被调用来初始化 <samp class="SANS_TheSansMonoCd_W5Regular_11">g_val</samp> 变量。如果一个评估是*先于*另一个评估执行的，第一个评估必须在第二个评估开始之前完成。你可以使用顺序点（在接下来的小节中讨论）来保证一个对象在被读取之前会被写入。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">f</samp> 的执行被保证在 <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>
    的执行之前，因为在一个完整表达式的评估和下一个完整表达式的评估之间存在顺序点。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unsequenced and Indeterminately
    Sequenced Evaluations</samp>
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">无序和不确定顺序的评估</samp>
- en: The executions of unsequenced evaluations can *interleave*, meaning that the
    instructions can be executed in any order, provided that reads and writes are
    performed in the order specified by the program. A program that performs reads
    and writes in the order specified by the program is *sequentially consistent*
    (Lamport 1979).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 无序评估的执行可以*交错*，意味着指令可以按任何顺序执行，只要按照程序指定的顺序执行读取和写入。一个按照程序指定顺序执行读取和写入的程序是*顺序一致*的（Lamport
    1979）。
- en: 'Some evaluations are *indeterminately sequenced*, which means they cannot interleave
    but can still be executed in any order. For example, the following statement contains
    several value computations and side effects:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一些评估是*不确定顺序的*，这意味着它们不能交织在一起，但仍然可以以任何顺序执行。例如，以下语句包含几个值计算和副作用：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The values of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">j</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp>
    must be read before their values can be incremented or decremented. This means
    that the reading of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> must
    be sequenced before the increment side effect, for example. Similarly, all side
    effects for the operands of the multiplication operation need to complete before
    the multiplication can occur. The multiplication must complete before the addition
    because of operator precedence rules. Finally, all side effects on the operands
    of the addition operation must complete before the addition can occur. These constraints
    produce a partial ordering among these operations because they don’t require that
    <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> be incremented before <samp
    class="SANS_TheSansMonoCd_W5Regular_11">k</samp> is decremented, for example.
    Unsequenced evaluations in this expression can be performed in any order, which
    allows the compiler to both reorder operations and to cache values in registers,
    allowing for faster overall execution. Function executions, on the other hand,
    are indeterminately sequenced and do not interleave with each other.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">k</samp>的值必须在它们的值被递增或递减之前读取。这意味着，读取<samp
    class="SANS_TheSansMonoCd_W5Regular_11">i</samp>必须在递增副作用之前按顺序进行。例如，乘法操作数的所有副作用必须在乘法发生之前完成。由于运算符优先级规则，乘法必须在加法之前完成。最后，加法操作数的所有副作用必须在加法发生之前完成。这些约束在这些操作之间产生了部分排序，因为它们并不要求在递增<samp
    class="SANS_TheSansMonoCd_W5Regular_11">j</samp>之前必须递减<samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp>。这个表达式中的无顺序求值可以按任意顺序执行，这使得编译器可以重新排序操作并将值缓存到寄存器中，从而提高整体执行速度。另一方面，函数执行的顺序是不可确定的，它们不会交织在一起。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Sequence Points</samp>
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">顺序点</samp>
- en: A *sequence point* is the juncture at which all side effects will have completed.
    These are implicitly defined by the language, but you can control when they occur
    by how you code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*顺序点*是所有副作用完成的交点。这些由语言隐式定义，但你可以通过编码方式控制它们发生的时机。'
- en: The sequence points are enumerated in Annex C of the C Standard. A sequence
    point occurs between the evaluation of one *full expression* (an expression that
    is not part of another expression or declarator) and the next full expression
    to be evaluated. A sequence point also occurs upon entering or exiting a called
    function.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序点在C标准的附录C中进行了枚举。顺序点发生在一个*完整表达式*（不是另一个表达式或声明符的一部分）和下一个待评估的完整表达式之间。顺序点还发生在进入或退出被调用函数时。
- en: 'If a side effect is unsequenced relative to either a different side effect
    on the same scalar or a value computation that uses the value of the same scalar
    object, the code has undefined behavior. A *scalar type* is either an arithmetic
    type or pointer type. The expression <samp class="SANS_TheSansMonoCd_W5Regular_11">i++</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">* i++</samp> performs two unsequenced
    operations on <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> as the following
    code snippet shows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个副作用相对于同一标量对象的另一个副作用或使用该标量对象值的计算没有顺序关系，则代码会有未定义行为。*标量类型*可以是算术类型或指针类型。表达式<samp
    class="SANS_TheSansMonoCd_W5Regular_11">i++</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">*
    i++</samp>对<i>进行两个无顺序操作，如以下代码片段所示：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You might think this code will produce the value 30, but because it has undefined
    behavior, that outcome isn’t guaranteed.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为这段代码会产生值30，但由于它具有未定义行为，结果并不保证。
- en: 'Conservatively, we can ensure that side effects have completed before the value
    is read by placing every side-effecting operation in its own full expression.
    We can rewrite that code as follows to eliminate the undefined behavior:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 保守地说，我们可以通过将每个副作用操作放入其自己的完整表达式中，确保副作用在读取值之前已完成。我们可以将代码重写如下，以消除未定义行为：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This example now contains a sequence point between every side-effecting operation.
    However, it’s impossible to tell whether this rewritten code represents the programmer’s
    original intent because the original code had no defined meaning. If you choose
    to omit sequence points, you must be sure you completely understand the sequencing
    of side effects. We also can write this same code as follows without changing
    the behavior:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例现在包含了每个副作用操作之间的顺序点。然而，我们无法判断这段重写的代码是否代表了程序员的原始意图，因为原始代码没有定义的意义。如果你选择省略顺序点，必须确保你完全理解副作用的顺序。我们也可以按如下方式编写相同的代码，而不改变其行为：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now that we have described the mechanics of expressions, we’ll return to discussing
    specific operators.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经描述了表达式的机制，我们将回到讨论具体的运算符。
- en: <samp class="SANS_Futura_Std_Bold_B_11">sizeof Operator</samp>
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">sizeof 运算符</samp>
- en: We can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator
    to find the size in bytes of its operand; specifically, it returns an unsigned
    integer of <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp> type that
    represents the size. Knowing the correct size of an operand is necessary for most
    memory operations, including allocating and copying storage. The <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp>
    type is defined in <samp class="SANS_TheSansMonoCd_W5Regular_11"><stddef.h></samp>
    as well as in other header files. We need to include one of these header files
    to compile any code that references the <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp>
    type.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> 运算符来查找其操作数的字节大小；具体来说，它返回一个无符号整数，类型为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp>，表示该大小。了解操作数的正确大小对于大多数内存操作是必要的，包括分配和复制存储。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp> 类型在 <samp class="SANS_TheSansMonoCd_W5Regular_11"><stddef.h></samp>
    中定义，也在其他头文件中定义。我们需要包含这些头文件之一，才能编译引用 <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp>
    类型的代码。
- en: 'We can pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    operator an unevaluated expression of a complete object type or a parenthesized
    name of such a type:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> 运算符传递一个未求值的完整对象类型表达式，或者是该类型的括号化名称：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It’s always safe to parenthesize the operand to <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>,
    because parenthesizing an expression doesn’t change the way the size of the operand
    is calculated. The result of invoking the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    operator is a constant expression unless the operand is a variable-length array.
    The operand to <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> is
    not evaluated.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对 <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> 的操作数加上括号始终是安全的，因为括号表达式不会改变操作数大小的计算方式。调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> 运算符的结果是常量表达式，除非操作数是一个可变长度数组。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> 运算符的操作数不会被求值。
- en: If you need to determine the number of bits of storage available, you can multiply
    the size of an object by <samp class="SANS_TheSansMonoCd_W5Regular_11">CHAR_BIT</samp>,
    which gives the number of bits contained in a byte. For example, the expression
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CHAR_BIT * sizeof(int)</samp> will
    produce the number of bits in an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要确定可用存储的位数，可以将对象的大小乘以 <samp class="SANS_TheSansMonoCd_W5Regular_11">CHAR_BIT</samp>，它表示一个字节中包含的位数。例如，表达式
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CHAR_BIT * sizeof(int)</samp> 将产生一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型对象的位数。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Arithmetic Operators</samp>
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">算术运算符</samp>
- en: Operators that perform arithmetic operations on arithmetic types are detailed
    in the following sections. We can also use some of these operators with nonarithmetic
    operands.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在算术类型上执行算术操作的运算符，以下章节进行了详细介绍。我们还可以将这些运算符中的一些与非算术操作数一起使用。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unary + and –</samp>
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">一元 + 和 –</samp>
- en: The *unary* <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">–</samp> *operators* operate on a single
    operand of arithmetic type. The <samp class="SANS_TheSansMonoCd_W5Regular_11">–</samp>
    operator returns the negative of its operand (that is, it behaves as though the
    operand were multiplied by –1). The unary <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    operator just returns the value. These operators exist primarily to express positive
    and negative numbers.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*一元* <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">–</samp>
    *运算符* 作用于单一的算术类型操作数。<samp class="SANS_TheSansMonoCd_W5Regular_11">–</samp> 操作符返回其操作数的负值（即，它的行为就像操作数被乘以
    -1）。一元 <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> 操作符仅返回值本身。这些运算符主要存在于表达正数和负数。'
- en: If the operand has a small integer type, it’s promoted (see [Chapter 3](chapter3.xhtml)),
    and the result of the operation has the result of the promoted type. As a point
    of trivia, C has no negative integer literals. A value such as <samp class="SANS_TheSansMonoCd_W5Regular_11">–25</samp>
    is actually an rvalue of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    with the value <samp class="SANS_TheSansMonoCd_W5Regular_11">25</samp> preceded
    by the unary <samp class="SANS_TheSansMonoCd_W5Regular_11">–</samp> operator.
    However, the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">-25</samp>
    is guaranteed to be a constant integer expression.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作数是一个小整数类型，它会被提升（见 [第3章](chapter3.xhtml)），并且操作的结果会是提升后的类型的结果。顺便提一句，C 语言没有负整数字面量。像
    <samp class="SANS_TheSansMonoCd_W5Regular_11">–25</samp> 这样的值实际上是一个类型为 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    的右值，其值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">25</samp>，前面带有一元操作符 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">–</samp>。然而，表达式 <samp class="SANS_TheSansMonoCd_W5Regular_11">-25</samp>
    保证是一个常量整数表达式。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Logical Negation</samp>
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">逻辑非</samp>
- en: 'The result of the unary logical negation operator (<samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>)
    is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一元逻辑非操作符 (<samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>) 的结果如下：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> if the evaluated value
    of its operand is not <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> 如果其操作数的求值结果不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> if the evaluated value
    of its operand is <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> 如果其操作数的求值结果是 <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
- en: The operand is a scalar type. The result has type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    for historical reasons. The expression <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">E</samp> is equivalent to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">(0</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">E</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>.
    The logical negation operator is frequently used to check for null pointers; for
    example, <samp class="SANS_TheSansMonoCd_W5Regular_11">!p</samp> is equivalent
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">(nullptr</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">p)</samp>. Null pointers may not
    hold the value zero but are guaranteed to evaluate to false.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 操作数是标量类型。结果的类型为 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>，出于历史原因。表达式
    <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">E</samp>
    等价于 <samp class="SANS_TheSansMonoCd_W5Regular_11">(0</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">E</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>。逻辑非操作符经常用于检查空指针；例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">!p</samp> 等价于 <samp class="SANS_TheSansMonoCd_W5Regular_11">(nullptr</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">p)</samp>。空指针可能不持有零值，但保证评估为假。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Additive</samp>
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">加法运算</samp>
- en: The binary additive operators include addition (<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>)
    and subtraction (<samp class="SANS_TheSansMonoCd_W5Regular_11">−</samp>). We can
    apply addition and subtraction to two operands of arithmetic types, but we can
    also use them to perform scaled pointer arithmetic. I’ll discuss pointer arithmetic
    near the end of this chapter.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 二元加法运算符包括加法 (<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>) 和减法 (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">−</samp>)。我们可以对两种算术类型的操作数应用加法和减法，也可以使用它们进行缩放的指针运算。我将在本章末尾讨论指针运算。
- en: The binary <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> operator sums
    its two operands. The binary <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>
    operator subtracts the right operand from the left operand. The usual arithmetic
    conversions are performed on operands of arithmetic type for both operations.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 二元运算符 <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> 将两个操作数相加。二元运算符
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> 将右操作数从左操作数中减去。对于这两种操作，都会对算术类型的操作数执行常规的算术转换。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Multiplicative</samp>
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">乘法</samp>
- en: The binary multiplicative operators include multiplication (<samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>),
    division (<samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>), and remainder
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp>). The usual arithmetic
    conversions are implicitly performed on multiplicative operands to find a common
    type. You can multiply and divide both floating-point and integer operands, but
    remainder operates only on integer operands.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 二元乘法运算符包括乘法 (<samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>)、除法 (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">/</samp>) 和余数 (<samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp>)。为了找出共同类型，通常会隐式地对乘法操作数进行算术转换。你可以对浮点数和整数操作数进行乘法和除法运算，但余数操作仅适用于整数操作数。
- en: Various programming languages implement different kinds of integer division
    operations, including Euclidean, flooring, and truncating. In *Euclidean division*,
    the remainder is always nonnegative (Boute 1992). In *flooring division*, the
    quotient is rounded toward negative infinity (Knuth 1997). In *truncating division*,
    the fractional part of the quotient is discarded, which is often referred to as
    *truncation toward zero*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 各种编程语言实现了不同类型的整数除法操作，包括欧几里得除法、向下取整除法和截断除法。在*欧几里得除法*中，余数总是非负的（Boute 1992）。在*向下取整除法*中，商会向负无穷大取整（Knuth
    1997）。在*截断除法*中，商的小数部分会被舍弃，这通常被称为*截断到零*。
- en: The C programming language implements truncating division, meaning that the
    remainder always has the same sign as the dividend, as shown in [Table 4-2](chapter4.xhtml#tab4-2).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: C 编程语言实现了截断除法，这意味着余数总是与被除数具有相同的符号，如[表4-2](chapter4.xhtml#tab4-2)所示。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-2:</samp> <samp class="SANS_Futura_Std_Book_11">Truncating
    Division</samp>
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表4-2：</samp> <samp class="SANS_Futura_Std_Book_11">截断除法</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">/</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Quotient</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">%</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Remainder</samp>
    |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">/</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">商</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">%</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">余数</samp>
    |'
- en: '| --- | --- | --- | --- |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">  10 / 3</samp> | <samp class="SANS_Futura_Std_Book_11">  3</samp>
    | <samp class="SANS_Futura_Std_Book_11">  10 % 3</samp> | <samp class="SANS_Futura_Std_Book_11">  1</samp>
    |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">  10 / 3</samp> | <samp class="SANS_Futura_Std_Book_11">  3</samp>
    | <samp class="SANS_Futura_Std_Book_11">  10 % 3</samp> | <samp class="SANS_Futura_Std_Book_11">  1</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">  10 / –3</samp> | <samp class="SANS_Futura_Std_Book_11">–3</samp>
    | <samp class="SANS_Futura_Std_Book_11">  10 % –3</samp> | <samp class="SANS_Futura_Std_Book_11">  1</samp>
    |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">  10 / –3</samp> | <samp class="SANS_Futura_Std_Book_11">–3</samp>
    | <samp class="SANS_Futura_Std_Book_11">  10 % –3</samp> | <samp class="SANS_Futura_Std_Book_11">  1</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">–10 / 3</samp> | <samp class="SANS_Futura_Std_Book_11">–3</samp>
    | <samp class="SANS_Futura_Std_Book_11">–10 % 3</samp> | <samp class="SANS_Futura_Std_Book_11">–1</samp>
    |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">–10 / 3</samp> | <samp class="SANS_Futura_Std_Book_11">–3</samp>
    | <samp class="SANS_Futura_Std_Book_11">–10 % 3</samp> | <samp class="SANS_Futura_Std_Book_11">–1</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">–10 / –3</samp> | <samp class="SANS_Futura_Std_Book_11">  3</samp>
    | <samp class="SANS_Futura_Std_Book_11">–10 % –3</samp> | <samp class="SANS_Futura_Std_Book_11">  1</samp>
    |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">–10 / –3</samp> | <samp class="SANS_Futura_Std_Book_11">  3</samp>
    | <samp class="SANS_Futura_Std_Book_11">–10 % –3</samp> | <samp class="SANS_Futura_Std_Book_11">  1</samp>
    |'
- en: To generalize, if the quotient <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    / b</samp> is representable, then the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">(a
    / b) * b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    % b</samp> equals <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>. Otherwise,
    if the value of the divisor is equal to 0 or <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    / b</samp> overflows, both <samp class="SANS_TheSansMonoCd_W5Regular_11">a / b</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">a % b</samp> will result in
    undefined behavior.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果商 <samp class="SANS_TheSansMonoCd_W5Regular_11">a / b</samp> 可表示，那么表达式
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(a / b) * b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a % b</samp> 等于 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>。否则，如果除数为
    0 或者 <samp class="SANS_TheSansMonoCd_W5Regular_11">a / b</samp> 溢出，则 <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    / b</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">a % b</samp> 都会导致未定义行为。
- en: 'It’s worth taking the time to understand the behavior of the <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp>
    operator to avoid surprises. For example, the following code defines a faulty
    function called <samp class="SANS_TheSansMonoCd_W5Regular_11">is_odd</samp> that
    attempts to test whether an integer is odd:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 花时间理解 <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp> 运算符的行为是值得的，这样可以避免出现意外情况。例如，下面的代码定义了一个名为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">is_odd</samp> 的有缺陷函数，试图判断一个整数是否为奇数：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Because the result of the remainder operation always has the sign of the dividend
    <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>, when <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>
    is negative and odd, <samp class="SANS_TheSansMonoCd_W5Regular_11">n % 2</samp>
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">−1</samp>, and the function
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于余数操作的结果始终具有被除数 <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> 的符号，当
    <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> 为负且为奇数时，<samp class="SANS_TheSansMonoCd_W5Regular_11">n
    % 2</samp> 返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">−1</samp>，而函数返回 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">false</samp>。
- en: 'A correct, alternative solution is to test that the remainder is not <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp> (because a remainder of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp> is the same regardless of the
    sign of the dividend):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一个正确的替代解决方案是检查余数是否不为 <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>（因为无论被除数的符号如何，余数为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> 的情况是一样的）：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Many central processing units (CPUs) implement remainder as part of the division
    operator, which can overflow if the dividend is equal to the minimum negative
    value for the signed integer type and the divisor is equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">−1</samp>.
    This occurs even though the mathematical result of such a remainder operation
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 许多中央处理单元（CPU）将余数操作作为除法运算符的一部分实现，当被除数等于带符号整数类型的最小负值，并且除数等于 <samp class="SANS_TheSansMonoCd_W5Regular_11">−1</samp>
    时，可能会发生溢出。即使这种余数操作的数学结果是 <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>，也会出现这种情况。
- en: The C standard library provides floating-point remainder, truncation, and rounding
    functions, including <samp class="SANS_TheSansMonoCd_W5Regular_11">fmod</samp>,
    among others.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: C 标准库提供了浮点余数、截断和舍入函数，包括 <samp class="SANS_TheSansMonoCd_W5Regular_11">fmod</samp>
    等。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Bitwise Operators</samp>
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">按位运算符</samp>
- en: We use *bitwise operators* to manipulate the bits of an object or any integer
    expression. Bitwise operators (<samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>) treat the bits as a pure
    binary model without concern for the values represented by these bits. Typically,
    they’re used on objects that represent *masks* or *bitmaps* where each bit indicates
    that something is “on” or “off,” “enabled” or “disabled,” or some other binary
    pairing. Using a mask, multiple bits can be set, unset, or inverted in a single
    bitwise operation. Masks and bitmaps are best represented as unsigned integer
    types, as the sign bit can be better used as a value and unsigned operations are
    less prone to undefined behavior.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用*按位运算符*来操作对象或任何整数表达式的位。按位运算符（<samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>）将位当作纯二进制模型处理，而不关心这些位所表示的值。通常，它们用于表示*掩码*或*位图*的对象，在这些对象中，每一位表示某些事物是“开启”还是“关闭”，“启用”还是“禁用”，或者是其他二元配对。通过使用掩码，可以在一次按位操作中设置、取消设置或翻转多个位。掩码和位图最好使用无符号整数类型来表示，因为符号位可以更好地作为值使用，而无符号操作不易导致未定义行为。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Complement</samp>
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">补码</samp>
- en: The *unary complement operator* (<samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>)
    works on a single operand of integer type and returns the *bitwise complement*
    of its operand—that is, a value in which each bit of the original value is flipped.
    The complement operator is used in applying the POSIX <samp class="SANS_TheSansMonoCd_W5Regular_11">umask</samp>,
    for example. The <samp class="SANS_TheSansMonoCd_W5Regular_11">umask</samp> masks
    or subtracts permissions. For example, a <samp class="SANS_TheSansMonoCd_W5Regular_11">umask</samp>
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">077</samp> turns off read, write,
    and execute permissions for the group and others. A file’s permission mode is
    the result of a logical AND operation between the complement of the mask and the
    process’s requested permission mode setting.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*一元补码运算符*（<samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>）作用于一个整数类型的单一操作数，并返回其操作数的*按位补码*，也就是说，返回一个值，其中原始值的每一位都被翻转。补码运算符用于应用
    POSIX 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">umask</samp>，例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">umask</samp>
    用来掩盖或减去权限。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">umask</samp> 为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">077</samp> 时，会关闭组用户和其他用户的读、写和执行权限。文件的权限模式是掩码的补码与进程请求的权限模式设置之间进行逻辑与运算的结果。'
- en: 'Integer promotions are performed on the operand of the complement operator,
    and the result has the promoted type. For example, the following code snippet
    applies the <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp> operator to
    a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>
    type:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对补码运算符的操作数进行整数提升，结果会得到提升后的类型。例如，以下代码片段将 <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>
    运算符应用于一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> 类型的值：
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: On an architecture with an 8-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    type and 32-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> type,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">uc</samp> is assigned the value
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0xFF</samp>. When <samp class="SANS_TheSansMonoCd_W5Regular_11">uc</samp>
    is used as the operand to the <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>
    operator, <samp class="SANS_TheSansMonoCd_W5Regular_11">uc</samp> is promoted
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp> by zero-extending
    it to 32 bits, <samp class="SANS_TheSansMonoCd_W5Regular_11">0x000000FF</samp>.
    The complement of this value is <samp class="SANS_TheSansMonoCd_W5Regular_11">0xFFFFFF00</samp>.
    Therefore, on this platform, complementing an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> type always results in a negative value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    int</samp>. As a general policy and to avoid surprises such as this, bitwise operations
    should operate only on values of sufficiently wide unsigned integer types.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个具有8位<samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>类型和32位<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>类型的架构上，<samp class="SANS_TheSansMonoCd_W5Regular_11">uc</samp>被赋值为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0xFF</samp>。当<samp class="SANS_TheSansMonoCd_W5Regular_11">uc</samp>作为操作数传递给<samp
    class="SANS_TheSansMonoCd_W5Regular_11">~</samp>操作符时，<samp class="SANS_TheSansMonoCd_W5Regular_11">uc</samp>通过零扩展被提升为32位的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp>，即<samp class="SANS_TheSansMonoCd_W5Regular_11">0x000000FF</samp>。该值的补码为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0xFFFFFF00</samp>。因此，在该平台上，对一个<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp>类型进行取补操作总是会得到一个负值，该值类型为<samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    int</samp>。为了避免这种意外，一般来说，位运算应仅对足够宽的无符号整数类型的值进行操作。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Shift</samp>
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">移位</samp>
- en: '*Shift operations* shift the value of each bit of an operand of integer type
    by a specified number of positions. Shifting is commonly performed in system programming,
    where bitmasks are common. Shift operations may also be used in code that manages
    network protocols or file formats to pack or unpack data. They include left-shift
    operations of the form'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*移位操作*将整数类型操作数的每一位按照指定的位数进行移位。移位操作在系统编程中常见，其中位掩码被广泛使用。移位操作也常用于管理网络协议或文件格式的代码中，用于打包或解包数据。它们包括以下形式的左移操作：'
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'and right-shift operations of the form:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以及以下形式的右移操作：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The *shift expression* is the value to be shifted, and the *additive expression*
    is the number of bits by which to shift the value. [Figure 4-1](chapter4.xhtml#fig4-1)
    illustrates a logical left shift of 1 bit.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*移位表达式*是需要移位的值，*加法表达式*是移位的位数。[图4-1](chapter4.xhtml#fig4-1)展示了1位的逻辑左移。'
- en: '![](../images/f04001.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/f04001.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-1: A logical left
    shift of 1 bit</samp>'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图4-1：1位的逻辑左移</samp>
- en: The additive expression determines the number of bits by which to shift the
    value. For example, the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">E1
    << E2</samp> is the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp>
    left-shifted <samp class="SANS_TheSansMonoCd_W5Regular_11">E2</samp> bit positions;
    vacated bits are filled with zeros. If <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp>
    has an unsigned type, the resulting value is <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">×</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUP_11">E2</samp>. Values that cannot be represented
    in the resulting type will wrap around. If <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp>
    has a signed type and nonnegative value and if <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">×</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUP_11">E2</samp> is representable in the
    result type, then that is the resulting value; otherwise, it is undefined behavior.
    Similarly, the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">E1 >> E2</samp>
    is the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp> right-shifted
    <samp class="SANS_TheSansMonoCd_W5Regular_11">E2</samp> bit positions. If <samp
    class="SANS_TheSansMonoCd_W5Regular_11">E1</samp> has an unsigned type or if <samp
    class="SANS_TheSansMonoCd_W5Regular_11">E1</samp> has a signed type and a nonnegative
    value, the value of the result is the integral part of the quotient of <samp class="SANS_TheSansMonoCd_W5Regular_11">E1/2</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUP_11">E2</samp>. If <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp>
    has a signed type and a negative value, the resulting value is implementation
    defined and may be either an arithmetic (sign-extended) shift or a logical (unsigned)
    shift, as shown in [Figure 4-2](chapter4.xhtml#fig4-2).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 加法表达式决定了需要移动值的位数。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">E1 << E2</samp>的结果是将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">E1</samp>左移<samp class="SANS_TheSansMonoCd_W5Regular_11">E2</samp>位；移出的位将用零填充。如果<samp
    class="SANS_TheSansMonoCd_W5Regular_11">E1</samp>是无符号类型，结果值为<samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">×</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUP_11">E2</samp>。如果结果类型无法表示某些值，它们会发生溢出。如果<samp
    class="SANS_TheSansMonoCd_W5Regular_11">E1</samp>是有符号类型并且值为非负数，且<samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">×</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUP_11">E2</samp>能在结果类型中表示，则结果值为该值；否则，行为未定义。类似地，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">E1 >> E2</samp>的结果是将<samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp>右移<samp
    class="SANS_TheSansMonoCd_W5Regular_11">E2</samp>位。如果<samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp>是无符号类型，或者如果<samp
    class="SANS_TheSansMonoCd_W5Regular_11">E1</samp>是有符号类型并且值为非负数，则结果值为<samp class="SANS_TheSansMonoCd_W5Regular_11">E1/2</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUP_11">E2</samp>的整数部分。如果<samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp>是有符号类型并且值为负数，则结果值由实现定义，可能是算术（符号扩展）右移或逻辑（无符号）右移，如图[4-2](chapter4.xhtml#fig4-2)所示。
- en: '![](../images/f04002.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/f04002.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-2: An arithmetic (signed)
    right shift and a logical (unsigned) right shift of 1 bit</samp>'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 4-2：1位的算术（有符号）右移和逻辑（无符号）右移</samp>
- en: In both shift operations, the integer promotions are performed on the operands,
    each of which has an integer type. The type of the result is that of the promoted
    left operand. The usual arithmetic conversions are *not* performed.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种移位操作中，会对操作数进行整数提升，每个操作数都有整数类型。结果的类型与提升后的左操作数类型相同。通常的算术转换*不会*执行。
- en: '[Listing 4-5](chapter4.xhtml#Lis4-5) shows how to perform right-shift operations
    on signed and unsigned integers that are free from undefined behavior.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4-5](chapter4.xhtml#Lis4-5)展示了如何对有符号和无符号整数进行右移操作，且没有引发未定义行为。'
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-5: Correct right-shift
    operations</samp>'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 4-5：正确的右移操作</samp>
- en: For signed integers ❶, you must ensure that the number of bits shifted is not
    negative, greater than, or equal to the width of the promoted left operand. For
    unsigned integers ❷, you omit the test for negative values, as unsigned integers
    can never be negative. You can perform safe left-shift operations in a similar
    manner.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有符号整数 ❶，必须确保移位的位数不为负数，且不大于或等于提升后的左操作数的宽度。对于无符号整数 ❷，可以省略负值检查，因为无符号整数永远不会是负数。你也可以通过类似的方式进行安全的左移操作。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Bitwise AND</samp>
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">按位与</samp>
- en: The binary *bitwise AND operator* (<samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>)
    returns the bitwise AND of two operands of integer type. The usual arithmetic
    conversions are performed on both operands. Each bit in the result is set if and
    only if each of the corresponding bits in the converted operands is set, as shown
    in [Table 4-3](chapter4.xhtml#tab4-3).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制 *按位与运算符*（<samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>）返回两个整数操作数的按位与。对两个操作数执行常规的算术转换。如果转换后的操作数中的每个位都为
    1，则结果中对应的位也为 1，具体如下所示：[表 4-3](chapter4.xhtml#tab4-3)。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-3:</samp> <samp class="SANS_Futura_Std_Book_11">Bitwise
    AND Truth Table</samp>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 4-3：</samp> <samp class="SANS_Futura_Std_Book_11">按位与真值表</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">x</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">y</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">x</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">&</samp>
    <samp class="SANS_Futura_Std_Heavy_B_11">y</samp> |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">x</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">y</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">x</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">&</samp>
    <samp class="SANS_Futura_Std_Heavy_B_11">y</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
- en: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Bitwise Exclusive
    OR</samp>'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">按位异或</samp>'
- en: The *bitwise exclusive OR operator* (<samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp>)
    returns the bitwise exclusive OR of the operands of integer type. The operands
    must be integers, and the usual arithmetic conversions are performed on both.
    Each bit in the result is set if and only if exactly one of the corresponding
    bits in the converted operands is set, as shown in [Table 4-4](chapter4.xhtml#tab4-4).
    You can also think of this operation as “one or the other, but not both.”
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*按位异或运算符*（<samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp>）返回两个整数操作数的按位异或。操作数必须为整数，并且对两个操作数执行常规的算术转换。如果转换后的操作数中的每个位正好有一个为
    1，则结果中对应的位为 1，具体如下所示：[表 4-4](chapter4.xhtml#tab4-4)。你也可以将此操作理解为“要么是一个，要么是另一个，但不能同时是两个。”'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-4:</samp> <samp class="SANS_Futura_Std_Book_11">Bitwise
    Exclusive OR Truth Table</samp>
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 4-4：</samp> <samp class="SANS_Futura_Std_Book_11">按位异或真值表</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">x</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">y</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">x</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">^</samp>
    <samp class="SANS_Futura_Std_Heavy_B_11">y</samp> |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">x</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">y</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">x</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">^</samp>
    <samp class="SANS_Futura_Std_Heavy_B_11">y</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
- en: Exclusive OR is equivalent to the addition operation on the integers modulo
    2—that is, because of wraparound 1 + 1 mod 2 = 0 (Lewin 2012).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 按位异或相当于对整数进行模 2 加法操作——即因为溢出，1 + 1 mod 2 = 0（Lewin 2012）。
- en: Beginners commonly mistake the exclusive OR operator for an exponent operator,
    erroneously believing that the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">7</samp>
    will compute 2 raised to the power of 7\. The correct way to raise a number to
    a certain power in C is to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">pow</samp>
    functions defined in <samp class="SANS_TheSansMonoCd_W5Regular_11"><math.h></samp>,
    as shown in [Listing 4-6](chapter4.xhtml#Lis4-6). The <samp class="SANS_TheSansMonoCd_W5Regular_11">pow</samp>
    functions operate on floating-point arguments and return a floating-point result,
    so be aware that these functions might fail to produce the expected results because
    of truncation or other errors.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 初学者常常将按位异或运算符误认为是指数运算符，错误地认为表达式 <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">7</samp>
    会计算 2 的 7 次方。在 C 语言中，正确的计算方法是使用在 <samp class="SANS_TheSansMonoCd_W5Regular_11"><math.h></samp>
    中定义的 <samp class="SANS_TheSansMonoCd_W5Regular_11">pow</samp> 函数，如 [示例 4-6](chapter4.xhtml#Lis4-6)
    所示。<samp class="SANS_TheSansMonoCd_W5Regular_11">pow</samp> 函数操作的是浮点数参数，并返回浮点结果，因此需要注意，这些函数可能由于截断或其他错误而未能产生预期的结果。
- en: '[PRE23]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-6: Using the</samp>
    <samp class="I">pow</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">functions</samp>'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 4-6: 使用</samp> <samp class="I">pow</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">函数</samp>'
- en: This code calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">pow</samp>
    function to compute 2 raised to the power of 7\. Because 2⁷ equals 128, this program
    will print <samp class="SANS_TheSansMonoCd_W5Regular_11">equal</samp>.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码调用了 <samp class="SANS_TheSansMonoCd_W5Regular_11">pow</samp> 函数来计算 2 的 7
    次方。由于 2⁷ 等于 128，因此该程序将输出 <samp class="SANS_TheSansMonoCd_W5Regular_11">equal</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Bitwise Inclusive
    OR</samp>
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">按位或</samp>
- en: The *bitwise inclusive OR* (<samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp>)
    *operator* returns the bitwise inclusive OR of two operands. Each bit in the result
    is set if and only if at least one of the corresponding bits in the converted
    operands is set, as shown in [Table 4-5](chapter4.xhtml#tab4-5).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*按位或* (<samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp>) *运算符* 返回两个操作数的按位或。只有当转换后的操作数中的至少一个相应位为
    1 时，结果中的对应位才为 1，具体见 [表 4-5](chapter4.xhtml#tab4-5)。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-5:</samp> <samp class="SANS_Futura_Std_Book_11">Bitwise
    Inclusive OR Truth Table</samp>
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 4-5:</samp> <samp class="SANS_Futura_Std_Book_11">按位或真值表</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">x</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">y</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">x</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">&#124;</samp>
    <samp class="SANS_Futura_Std_Heavy_B_11">y</samp> |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">x</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">y</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">x</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">&#124;</samp>
    <samp class="SANS_Futura_Std_Heavy_B_11">y</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
- en: The operands must be integers, and the usual arithmetic conversions are performed
    on both.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 操作数必须是整数，并且会对两者执行通常的算术转换。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Logical Operators</samp>
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">逻辑运算符</samp>
- en: The *logical AND* (<samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>)
    and *OR* (<samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>) *operators*
    are used primarily for logically joining two or more expressions of scalar type.
    They’re commonly used in condition tests to combine multiple comparisons together,
    such as in the first operand of the conditional operator, the controlling expression
    of an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement, or the
    controlling expression of a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop. You shouldn’t use logical operators with bitmap operands, as they are intended
    primarily for Boolean logic.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*逻辑与* (<samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>) 和 *逻辑或* (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">||</samp>) *运算符* 主要用于逻辑连接两个或更多标量类型的表达式。它们通常用于条件测试中，将多个比较结合在一起，例如条件运算符的第一个操作数、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句的控制表达式，或 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环的控制表达式。你不应当使用逻辑运算符与位图操作数一起使用，因为它们主要用于布尔逻辑。'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp> operator returns
    1 if neither of its operands is equal to 0 and returns 0 otherwise. Logically,
    this means that <samp class="SANS_TheSansMonoCd_W5Regular_11">a && b</samp> is
    true only if both <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is true
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> is true.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp> 运算符如果两个操作数都不等于 0，则返回
    1，否则返回 0。从逻辑上讲，这意味着 <samp class="SANS_TheSansMonoCd_W5Regular_11">a && b</samp>
    只有在 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    都为真时才为真。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> operator returns
    1 if either of its operands is not equal to 0 and returns 0 otherwise. Logically,
    this means that <samp class="SANS_TheSansMonoCd_W5Regular_11">a || b</samp> is
    true if <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is true, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp> is true, or both <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> are true.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> 运算符如果其操作数之一不等于 0，则返回
    1，否则返回 0。从逻辑上讲，这意味着 <samp class="SANS_TheSansMonoCd_W5Regular_11">a || b</samp>
    为真，如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> 为真，<samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    为真，或 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    都为真。
- en: The C standard defines both operations in terms of “not equal to zero” because
    the operands can have values other than 0 and 1\. Both operators accept operands
    of scalar type (integers, floats, and pointers), and the result of the operation
    has type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: C 标准将这两种运算定义为“非零”的概念，因为操作数可以有 0 和 1 以外的值。这两种运算符都接受标量类型（整数、浮点数和指针）的操作数，运算结果的类型为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>。
- en: 'Unlike the corresponding bitwise binary operators, the logical AND operator
    and logical OR operator guarantee left-to-right evaluation. Both operators *short-circuit*:
    The second operand is not evaluated if the result can be deduced solely by evaluating
    the first operand. If the second operand is evaluated, there is a sequence point
    between the evaluations of the first and second operands. For example, the expression
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0 && unevaluated</samp> returns
    0 regardless of the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">unevaluated</samp>
    because there is no possible value for <samp class="SANS_TheSansMonoCd_W5Regular_11">unevaluated</samp>
    that produces a different result. Because of this, <samp class="SANS_TheSansMonoCd_W5Regular_11">unevaluated</samp>
    is not evaluated to determine its value. The same is true for <samp class="SANS_TheSansMonoCd_W5Regular_11">1
    || unevaluated</samp> because this expression always returns 1.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 与对应的按位二进制操作符不同，逻辑与操作符和逻辑或操作符保证从左到右的求值顺序。这两个操作符 *短路*：如果结果仅通过评估第一个操作数就能推断出来，第二个操作数就不会被评估。如果第二个操作数被评估，则第一个和第二个操作数之间有一个序列点。例如，表达式
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0 && unevaluated</samp> 无论 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">unevaluated</samp> 的值如何都返回 0，因为没有任何可能的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unevaluated</samp> 值会产生不同的结果。由于这个原因，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">unevaluated</samp> 不会被评估来确定其值。对于 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">1 || unevaluated</samp> 也是如此，因为这个表达式始终返回
    1。
- en: 'Short-circuiting is commonly used in operations with pointers:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 短路操作通常用于指针操作：
- en: '[PRE24]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This code tests the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>.
    If <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> is null, the second
    <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp> operand is not evaluated,
    preventing a null pointer dereference.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码测试 <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> 的值。如果 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> 为 null，第二个 <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>
    操作数将不会被求值，从而避免了空指针解引用。
- en: 'Short-circuiting can also be used to avoid unnecessary computing. In the following
    expression, the <samp class="SANS_TheSansMonoCd_W5Regular_11">is_file_ready</samp>
    predicate function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>
    if the file is ready:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 短路操作也可以用于避免不必要的计算。在以下表达式中，<samp class="SANS_TheSansMonoCd_W5Regular_11">is_file_ready</samp>
    谓词函数在文件准备好时返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>：
- en: '[PRE25]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When the <samp class="SANS_TheSansMonoCd_W5Regular_11">is_file_ready</samp>
    function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>, the
    second <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> operand is not
    evaluated, as there is no need to prepare the file. This avoids potential errors
    or, when <samp class="SANS_TheSansMonoCd_W5Regular_11">prepare_file</samp> is
    idempotent, unnecessary computing, assuming the cost of determining whether the
    file is ready is less than the cost of preparing the file.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当 <samp class="SANS_TheSansMonoCd_W5Regular_11">is_file_ready</samp> 函数返回 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">true</samp> 时，第二个 <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>
    操作数不会被求值，因为文件无需准备。这避免了潜在的错误，或者当 <samp class="SANS_TheSansMonoCd_W5Regular_11">prepare_file</samp>
    是幂等时，避免了不必要的计算，假设判断文件是否准备好的成本小于准备文件的成本。
- en: 'Programmers should exercise caution if the second operand contains side effects,
    because it may not be apparent whether these side effects occur. For example,
    in the following code, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    is incremented only when <samp class="SANS_TheSansMonoCd_W5Regular_11">i >=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第二个操作数包含副作用，程序员应当小心，因为可能不容易察觉这些副作用是否发生。例如，在以下代码中，只有当 <samp class="SANS_TheSansMonoCd_W5Regular_11">i
    >=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> 时，<samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    的值才会递增：
- en: '[PRE26]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code may be correct, but it’s likely a programmer error.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可能是正确的，但很可能是程序员的错误。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Cast Operators</samp>
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">类型转换操作符</samp>
- en: '*Casts* (also known as *type casts*) explicitly convert a value of one type
    to a value of another type. To perform a cast, we precede an expression with a
    parenthesized type name, which converts the value of the expression to the unqualified
    version of the named type. The following code illustrates an explicit conversion,
    or cast, of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> from type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型转换*（也称为*类型转换*）明确地将一个类型的值转换为另一个类型的值。要执行类型转换，我们在表达式前加上带括号的类型名称，这会将表达式的值转换为该类型的无符号版本。以下代码演示了将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 从 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    类型显式转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型：'
- en: '[PRE27]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Unless the type name specifies a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    type, the type name must be a qualified or unqualified scalar type. The operand
    must also have scalar type; a pointer type cannot be converted to any floating-point
    type, and vice versa.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 除非类型名称指定了 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 类型，否则类型名称必须是有符号或无符号的标量类型。操作数也必须是标量类型；指针类型不能转换为任何浮点类型，反之亦然。
- en: 'Casts are extremely powerful and must be used carefully. For one thing, casts
    may reinterpret the existing bits as a value of the specified type without changing
    the bits:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换非常强大，必须小心使用。一方面，类型转换可能会将现有的位重新解释为指定类型的值，而不更改这些位：
- en: '[PRE28]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Casts may also change these bits into whatever bits are needed to represent
    the original value in the resulting type:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换也可能将这些位转换为所需的位，以表示结果类型中的原始值：
- en: '[PRE29]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Casts can also disable diagnostics. For example:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换还可以禁用诊断。例如：
- en: '[PRE30]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This generates the following diagnostic when compiled with Visual C++ 2022
    with warning level <samp class="SANS_TheSansMonoCd_W5Regular_11">/W4</samp>:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Visual C++ 2022 编译，并且警告级别为 <samp class="SANS_TheSansMonoCd_W5Regular_11">/W4</samp>
    时，这将生成以下诊断：
- en: '[PRE31]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Adding a cast to <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    disables the diagnostic without fixing the problem:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 将类型转换添加到 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 可以禁用诊断，但并没有解决问题：
- en: '[PRE32]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: To mitigate these risks, C++ defines its own casts, which are less powerful.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少这些风险，C++ 定义了自己的类型转换，它们的功能较弱。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Conditional Operator</samp>
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">条件运算符</samp>
- en: 'The *conditional operator* (<samp class="SANS_TheSansMonoCd_W5Regular_11">?
    :</samp>) is the only C operator that takes three operands. It returns a result
    based on the condition. You can use the conditional operator like this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*条件运算符* (<samp class="SANS_TheSansMonoCd_W5Regular_11">? :</samp>) 是唯一一个需要三个操作数的
    C 运算符。它根据条件返回一个结果。你可以像这样使用条件运算符：'
- en: '[PRE33]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The conditional operator evaluates the first operand, called the *condition*.
    The second operand (<samp class="SANS_TheSansMonoCd_W5Regular_11">valueReturnedIfTrue</samp>)
    is evaluated if the condition is true, or the third operand (<samp class="SANS_TheSansMonoCd_W5Regular_11">valueReturnedIfFalse</samp>)
    is evaluated if the condition is false. The result is the value of either the
    second or third operand (depending on which operand was evaluated).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 条件运算符评估第一个操作数，称为*条件*。如果条件为真，则评估第二个操作数（<samp class="SANS_TheSansMonoCd_W5Regular_11">valueReturnedIfTrue</samp>）；如果条件为假，则评估第三个操作数（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">valueReturnedIfFalse</samp>）。结果是第二个或第三个操作数的值（取决于哪个操作数被评估）。
- en: This result is converted to a common type based on the second and third operands.
    There is a sequence point between the evaluation of the first operand and the
    evaluation of the second or third operand (whichever is evaluated) so that the
    compiler will ensure that all side effects resulting from evaluating the condition
    have completed before the second or third operand is evaluated.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果会根据第二个和第三个操作数转换为一个通用类型。在第一个操作数和第二个或第三个操作数（无论哪一个先计算）之间有一个序列点，确保在评估第二个或第三个操作数之前，评估条件时产生的所有副作用已经完成。
- en: 'The conditional operator is similar to an <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp>
    control flow block but returns a value as a function does. Unlike with an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp> control flow block, you
    can use the conditional operator to initialize a <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified
    object:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 条件运算符类似于一个<samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp>控制流块，但它返回一个值，像函数一样。与<samp
    class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp>控制流块不同，你可以使用条件运算符来初始化一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">const</samp>限定的对象：
- en: '[PRE34]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The first operand to the conditional operator must have scalar type. The second
    and third operands must have compatible types (roughly speaking). For more details
    on the constraints for this operator and the specifics of determining the return
    type, refer to Section 6.5.15 of the C standard (ISO/IEC 9899:2024).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 条件运算符的第一个操作数必须具有标量类型。第二个和第三个操作数必须具有兼容的类型（粗略地说）。有关此运算符的约束以及确定返回类型的具体细节，请参阅C标准（ISO/IEC
    9899:2024）第6.5.15节。
- en: <samp class="SANS_Futura_Std_Bold_B_11">alignof Operator</samp>
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">alignof 运算符</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">alignof</samp> operator yields
    an integer constant representing the alignment requirement of its operand’s declared
    complete object type. It does not evaluate the operand. When applied to an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">array</samp> type, it returns the alignment
    requirement of the element type. An alternative spelling of <samp class="SANS_TheSansMonoCd_W5Regular_11">_Alignof</samp>
    is available for this operator. Prior to C23, the <samp class="SANS_TheSansMonoCd_W5Regular_11">alignof</samp>
    spelling was available through a convenience macro provided in the header <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><stdalign.h></samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">alignof</samp>
    operator is useful in static assertions that are used to verify assumptions about
    your program (discussed further in [Chapter 11](chapter11.xhtml)). The purpose
    of these assertions is to diagnose situations in which your assumptions are invalid.
    [Listing 4-7](chapter4.xhtml#Lis4-7) demonstrates the use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">alignof</samp>
    operator.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">alignof</samp>运算符返回一个整数常量，表示其操作数声明的完整对象类型的对齐要求。它不会对操作数进行求值。当应用于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">array</samp>类型时，它返回元素类型的对齐要求。此运算符还有一个可选的拼写形式<samp
    class="SANS_TheSansMonoCd_W5Regular_11">_Alignof</samp>。在C23之前，<samp class="SANS_TheSansMonoCd_W5Regular_11">alignof</samp>的拼写是通过头文件<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><stdalign.h></samp>提供的便捷宏来实现的。<samp class="SANS_TheSansMonoCd_W5Regular_11">alignof</samp>运算符在静态断言中非常有用，静态断言用于验证程序中的假设（在[第11章](chapter11.xhtml)中有进一步讨论）。这些断言的目的是诊断假设无效的情况。[清单
    4-7](chapter4.xhtml#Lis4-7)展示了如何使用<code class="SANS_TheSansMonoCd_W5Regular_11">alignof</code>运算符。
- en: '[PRE35]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-7: The</samp> <samp
    class="I">alignof</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">operator</samp>'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 4-7: The</samp> <samp class="I">alignof</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">运算符</samp>'
- en: 'This simple program doesn’t accomplish anything particularly useful. It declares
    an array <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> of four integers
    followed by a static assertion concerning the alignment of the array and a runtime
    assertion concerning the alignment of <samp class="SANS_TheSansMonoCd_W5Regular_11">max_align_t</samp>
    (an object type whose alignment is the greatest fundamental alignment). It then
    prints out these values. This program will not compile if either static assertion
    is false, or it will output the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的程序并没有完成任何特别有用的事情。它声明了一个包含四个整数的数组<samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>，随后进行了一个关于数组对齐的静态断言，以及一个关于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">max_align_t</samp>（一种对齐要求最大的基础对齐对象类型）的运行时断言。然后，它打印出这些值。如果其中任何静态断言为假，则该程序将无法编译，或者它将输出以下内容：
- en: '[PRE36]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'These alignments are characteristic of the x86-64 architecture.  ## <samp class="SANS_Futura_Std_Bold_B_11">Relational
    Operators</samp>'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '这些对齐要求是x86-64架构的特征。  ## <samp class="SANS_Futura_Std_Bold_B_11">关系运算符</samp>'
- en: The *relational operators* include equal to (<samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>),
    not equal to (<samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp>), less than
    (<samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>), greater than (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">></samp>), less than or equal to (<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><=</samp>), and greater than or equal
    to (<samp class="SANS_TheSansMonoCd_W5Regular_11">>=</samp>). Each returns 1 if
    the specified relationship is true and 0 if it is false. The result has type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, again, for historical reasons.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '*关系运算符*包括等于（<samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>）、不等于（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">!=</samp>）、小于（<samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>）、大于（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">></samp>）、小于或等于（<samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp>）和大于或等于（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">>=</samp>）。每个运算符如果指定的关系为真，则返回1，如果为假，则返回0。结果的类型为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>，这也是由于历史原因。'
- en: 'Note that C does not interpret the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    < b < c</samp> to mean that <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    is greater than <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> but less
    than <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>, as ordinary mathematics
    does. Instead, the expression is interpreted to mean <samp class="SANS_TheSansMonoCd_W5Regular_11">(a
    < b) < c</samp>. In English, if <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    is less than <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, the compiler
    should compare <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">c</samp>; otherwise, it compares <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>.
    If this is your intent, include the parentheses to make that clear to any potential
    code reviewer. Some compilers such as GCC and Clang provide the <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wparentheses</samp>
    flag to diagnose those problems. To determine whether <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    is greater than <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> but less
    than <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>, you can write this
    test: <samp class="SANS_TheSansMonoCd_W5Regular_11">(a < b) && (b < c)</samp>.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，C语言并不将表达式<samp class="SANS_TheSansMonoCd_W5Regular_11">a < b < c</samp> 解释为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> 大于 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    并且小于 <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>，如同普通数学那样。相反，表达式被解释为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(a < b) < c</samp>。用英文来说，如果 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp> 小于 <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>，编译器将比较
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> 与 <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>；否则，比较
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> 与 <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>。如果这是你想要的结果，记得加上括号，以便让任何潜在的代码审查者清楚。像GCC和Clang这样的编译器提供了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wparentheses</samp> 标志来诊断这些问题。要判断
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> 是否大于 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    且小于 <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>，你可以写如下测试：<samp class="SANS_TheSansMonoCd_W5Regular_11">(a
    < b) && (b < c)</samp>。
- en: The equality and inequality operators have lower precedence than the relational
    operators—and assuming otherwise is a common mistake. This means that the expression
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a < b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">c < d</samp> is evaluated the same
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">(a < b)</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(c < d)</samp>. In both cases, the
    comparisons <samp class="SANS_TheSansMonoCd_W5Regular_11">a < b</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">c < d</samp> are evaluated first, and
    the resulting values (either <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>) are compared for equality.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 等于和不等于运算符的优先级低于关系运算符——假设它们优先级更高是一个常见的错误。这意味着表达式<samp class="SANS_TheSansMonoCd_W5Regular_11">a
    < b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c
    < d</samp> 的计算方式与<samp class="SANS_TheSansMonoCd_W5Regular_11">(a < b)</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(c
    < d)</samp> 相同。在这两种情况下，首先会计算<samp class="SANS_TheSansMonoCd_W5Regular_11">a <
    b</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">c < d</samp>，然后将得到的值（0
    或 1）进行相等性比较。
- en: We can use these operators to compare arithmetic types or pointers. When we
    compare two pointers, the result depends on the relative locations in the address
    space of the objects pointed to. If both pointers point to the same object, they
    are equal.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这些运算符来比较算术类型或指针。当我们比较两个指针时，结果取决于它们指向的对象在地址空间中的相对位置。如果两个指针指向相同的对象，则它们相等。
- en: 'Equality and inequality operators differ from the other relational operators.
    For example, you cannot use the other relational operators on two pointers to
    unrelated objects, because doing so makes no sense and is consequently undefined
    behavior:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 等式和不等式运算符与其他关系运算符不同。例如，你不能在两个指向不相关对象的指针上使用其他关系运算符，因为这样做没有意义，且会导致未定义行为：
- en: '[PRE37]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You might compare pointers, for example, to determine whether you have reached
    the too-far element of an array.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会比较指针，例如，判断是否已到达数组的末尾。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Compound Assignment Operators</samp>
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">复合赋值运算符</samp>
- en: '*Compound assignment operators*, shown in [Table 4-6](chapter4.xhtml#tab4-6),
    modify the current value of an object by performing an operation on it.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '*复合赋值运算符*，如[表 4-6](chapter4.xhtml#tab4-6)所示，通过对对象执行某种操作来修改对象的当前值。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-6:</samp> <samp class="SANS_Futura_Std_Book_11">Compound
    Assignment Operators</samp>
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 4-6：</samp> <samp class="SANS_Futura_Std_Book_11">复合赋值运算符</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Operator</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assignment
    by</samp> |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">运算符</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">赋值方式</samp>
    |'
- en: '| --- | --- |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">+=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-=</samp>
    | <samp class="SANS_Futura_Std_Book_11">Sum and difference</samp> |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">+=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-=</samp>
    | <samp class="SANS_Futura_Std_Book_11">和与差</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">*=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">/=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">%=</samp> | <samp class="SANS_Futura_Std_Book_11">Product,
    quotient, and remainder</samp> |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">*=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">/=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">%=</samp> | <samp class="SANS_Futura_Std_Book_11">乘积、商和余数</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11"><<=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">>>=</samp>
    | <samp class="SANS_Futura_Std_Book_11">Bitwise left shift and right shift</samp>
    |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11"><<=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">>>=</samp>
    | <samp class="SANS_Futura_Std_Book_11">按位左移和右移</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">&= ^=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&#124;=</samp>
    | <samp class="SANS_Futura_Std_Book_11">Bitwise AND, XOR, and OR</samp> |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">&= ^=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&#124;=</samp>
    | <samp class="SANS_Futura_Std_Book_11">按位与、异或和或</samp> |'
- en: A compound assignment of the form <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">op</samp> *=* <samp class="SANS_TheSansMonoCd_W5Regular_11">E2</samp>
    is equivalent to the simple assignment expression <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">op</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(E2)</samp>,
    except that <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp> is evaluated
    only once. Compound assignments are primarily used as shorthand notation. There
    are no compound assignment operators for logical operators.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 形式为 <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">op</samp>
    *=* <samp class="SANS_TheSansMonoCd_W5Regular_11">E2</samp> 的复合赋值与简单赋值表达式 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">E1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">op</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(E2)</samp> 等效，区别在于 <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp>
    仅被计算一次。复合赋值主要作为简写符号使用。逻辑运算符没有复合赋值运算符。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Comma Operator</samp>
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">逗号运算符</samp>
- en: 'In C, we use commas in two distinct ways: as operators and to separate items
    in a list (such as arguments to functions or lists of declarations). The *comma*
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp>) *operator* is a way to
    evaluate one expression before another. First, the left operand of a comma operator
    is evaluated as a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> expression.
    There is a sequence point between the evaluation of the left operand and the evaluation
    of the right operand. Then, the right operand is evaluated after the left. The
    comma operation has the type and value of the right operand—mostly because it
    is the last expression evaluated.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 中，我们以两种不同的方式使用逗号：作为运算符和用于分隔列表项（如函数的参数或声明的列表）。*逗号* (<samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp>)
    *运算符* 是一种在执行一个表达式之前先执行另一个表达式的方式。首先，逗号运算符的左操作数被当作 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    表达式来计算。左操作数和右操作数的计算之间有一个顺序点。然后，左操作数计算后，右操作数会被计算。逗号运算的结果具有右操作数的类型和值——这主要是因为它是最后一个被计算的表达式。
- en: 'You can’t use the comma operator in contexts in which a comma might separate
    items in a list. Instead, you would include a comma within a parenthesized expression
    or within the second expression of a conditional operator. For example, assume
    that <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> each have type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp> in the following call to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">f</samp>:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要使用逗号分隔列表项的上下文中，不能使用逗号运算符。相反，你可以在括号表达式内或条件运算符的第二个表达式中包含逗号。例如，假设在以下调用中，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> 每个都有类型 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>，调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>：
- en: '[PRE38]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The first comma separates the first and second arguments to the function. The
    second comma is a comma operator. The assignment is evaluated first, followed
    by the addition. Because of the sequence point, the assignment is guaranteed to
    complete before the addition takes place. The result of the comma operation has
    the type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and value <samp
    class="SANS_TheSansMonoCd_W5Regular_11">5</samp>. The third comma separates the
    second and third arguments to the function.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个逗号分隔函数的第一个和第二个参数。第二个逗号是逗号运算符。赋值操作先被计算，再执行加法操作。由于顺序点，赋值操作在加法操作之前保证完成。逗号运算的结果具有类型
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 和值 <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>。第三个逗号分隔函数的第二个和第三个参数。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Pointer Arithmetic</samp>
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">指针运算</samp>
- en: Earlier in this chapter, we mentioned that the additive operators (addition
    and subtraction) can be used with either arithmetic operands or object pointers.
    In this section, we discuss adding a pointer and an integer, subtracting two pointers,
    and subtracting an integer from a pointer.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章早些时候，我们提到过加法运算符（加法和减法）可以与算术操作数或对象指针一起使用。在本节中，我们讨论了将指针与整数相加、两个指针相减以及从指针中减去整数。
- en: 'Adding or subtracting an expression that has an integer type to or from a pointer
    returns a value with the type of the pointer operand. If the pointer operand points
    to an element of an array, then the result points to an element offset from the
    original element. If the resulting pointer is beyond the bounds of the array,
    undefined behavior occurs. The difference of the array subscripts of the resulting
    and original array elements equals the integer expression:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 将具有整数类型的表达式加到指针上，或从指针中减去整数，返回一个与指针操作数类型相同的值。如果指针操作数指向数组中的一个元素，则结果指向相对于原始元素偏移的元素。如果结果指针超出了数组的边界，将会发生未定义行为。结果数组元素与原始数组元素的下标之差等于该整数表达式的值：
- en: '[PRE39]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Pointer arithmetic is automatically *scaled* to the size of the array element,
    rather than individual bytes. C allows a pointer to be formed to each element
    of an array, including one past the last element of the array object (also referred
    to as the *too-far* pointer). While this might seem unusual or unnecessary, many
    early C programs incremented a pointer until it was equal to the too-far pointer,
    and the C standards committee didn’t want to break all this code, which is also
    idiomatic in C++ iterators. [Figure 4-3](chapter4.xhtml#fig4-3) illustrates forming
    the *too-far* pointer.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 指针运算会自动根据数组元素的大小进行*缩放*，而不是按单个字节进行缩放。C语言允许形成指向数组中每个元素的指针，包括指向数组对象最后一个元素之后的指针（也称为*越界*指针）。虽然这看起来不寻常或不必要，但许多早期的C程序会增加指针，直到它等于越界指针，C标准委员会不希望破坏所有这些代码，这也是C++迭代器中的常见用法。[图4-3](chapter4.xhtml#fig4-3)展示了如何形成*越界*指针。
- en: '![](../images/f04003.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/f04003.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-3: One past the last
    element of an array object</samp>'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图4-3：数组对象最后一个元素之后的指针</samp>
- en: If both the pointer operand and the result point to elements of the same array
    object or the too-far pointer, the evaluation did not overflow; otherwise, the
    behavior is undefined. To satisfy the too-far requirement, an implementation need
    only provide one extra byte (which can overlap another object in the program)
    just after the end of the object.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指针操作数和结果指向的是同一个数组对象的元素或“越界”指针，则计算没有发生溢出；否则，行为是未定义的。为了满足越界要求，实现只需在对象的末尾提供一个额外的字节（该字节可以与程序中的其他对象重叠）。
- en: C also allows objects to be treated as an array containing only a single element,
    allowing you to obtain a too-far pointer from a scalar.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: C语言还允许将对象视为只包含一个元素的数组，使你能够从标量值中获得一个越界指针。
- en: 'The too-far special case allows us to advance a pointer until it is equal to
    the too-far pointer, as in the following function:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 越界特殊情况允许我们将指针递增，直到它等于越界指针，如以下函数所示：
- en: '[PRE40]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> statement
    (explained in detail in the next chapter) in the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum_m_elems</samp>
    function loops while <samp class="SANS_TheSansMonoCd_W5Regular_11">pi</samp> is
    less than the address of the too-far pointer for the array <samp class="SANS_TheSansMonoCd_W5Regular_11">m</samp>.
    The pointer <samp class="SANS_TheSansMonoCd_W5Regular_11">pi</samp> is incremented
    at the end of each iteration of the loop until the too-far pointer is formed,
    causing the loop condition to evaluate to 0 when tested.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>语句（将在下一章中详细解释）在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">sum_m_elems</samp>函数中循环执行，直到<samp class="SANS_TheSansMonoCd_W5Regular_11">pi</samp>小于数组<samp
    class="SANS_TheSansMonoCd_W5Regular_11">m</samp>的越界指针地址为止。在每次循环结束时，指针<samp class="SANS_TheSansMonoCd_W5Regular_11">pi</samp>会递增，直到形成越界指针，这会导致循环条件在测试时计算为0。
- en: When we subtract one pointer from another, both must point to elements of the
    same array object or the too-far element. This operation returns the difference
    of the subscripts of the two array elements. The type of the result is <samp class="SANS_TheSansMonoCd_W5Regular_11">ptrdiff_t</samp>
    (a signed integer type). You should take care when subtracting pointers, because
    the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">ptrdiff_t</samp> may
    not be sufficient to represent the difference of pointers to elements of very
    large character arrays.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从一个指针中减去另一个指针时，两个指针必须指向同一个数组对象的元素或越界元素。此操作返回两个数组元素下标的差值。结果的类型是<samp class="SANS_TheSansMonoCd_W5Regular_11">ptrdiff_t</samp>（有符号整数类型）。在进行指针减法时要小心，因为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ptrdiff_t</samp>的范围可能不足以表示指向非常大的字符数组元素之间的指针差异。
- en: '## <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '## <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>'
- en: In this chapter, you learned how to use operators to write simple expressions
    that perform operations on various object types. Along the way, you learned about
    some core C concepts, such as lvalues, rvalues, value computations, and side effects,
    which determine how expressions are evaluated. You also learned how operator precedence,
    associativity, order of evaluation, sequencing, and interleaving can affect the
    total order in which a program is executed. In the next chapter, you’ll learn
    more about how to control the execution of your program by using selection, iteration,
    and jump statements.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用运算符编写简单的表达式，对各种对象类型执行操作。在此过程中，你还了解了一些核心的C语言概念，如左值、右值、值计算和副作用，这些概念决定了表达式的求值方式。你还学习了运算符优先级、结合性、求值顺序、序列化和交错执行等概念，它们会影响程序执行的整体顺序。在下一章中，你将学习更多如何通过使用选择、迭代和跳转语句来控制程序的执行。
