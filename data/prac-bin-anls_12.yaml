- en: '9'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '9'
- en: BINARY INSTRUMENTATION
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制插桩
- en: In [Chapter 7](ch07.xhtml#ch07), you learned several techniques for modifying
    and augmenting binary programs. While relatively simple to use, those techniques
    are limited in the amount of new code you can insert into the binary and where
    you can insert it. In this chapter, you’ll learn about a technique called *binary
    instrumentation* that allows you to insert a practically unlimited amount of code
    at any location in a binary to observe or modify that binary’s behavior.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第七章](ch07.xhtml#ch07)中，你学习了几种修改和增强二进制程序的技术。尽管这些技术相对容易使用，但它们在能够向二进制中插入多少新代码以及能插入到何处方面有所限制。在本章中，你将学习一种叫做*二进制插桩*的技术，它允许你在二进制中的任何位置插入几乎无限量的代码，以观察或修改该二进制的行为。
- en: After a brief overview of binary instrumentation, I’ll discuss how to implement
    *static binary instrumentation (SBI)* and *dynamic binary instrumentation (DBI)*,
    two types of binary instrumentation with different trade-offs. Finally, you’ll
    learn how to build your own binary instrumentation tools with Pin, a popular DBI
    system made by Intel.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在简要介绍二进制插桩之后，我将讨论如何实现*静态二进制插桩（SBI）*和*动态二进制插桩（DBI）*，这两种二进制插桩方式具有不同的权衡。最后，你将学习如何使用
    Intel 提供的流行 DBI 系统 Pin，构建自己的二进制插桩工具。
- en: 9.1 What Is Binary Instrumentation?
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1 什么是二进制插桩？
- en: Inserting new code at any point in an existing binary to observe or modify the
    binary’s behavior in some way is called *instrumenting* the binary. The point
    where you add new code is called the *instrumentation point*, and the added code
    is called *instrumentation code*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在现有二进制文件的任何位置插入新代码，以观察或修改该二进制行为的方式，称为*插桩*二进制。你添加新代码的位置称为*插桩点*，而添加的代码则称为*插桩代码*。
- en: For example, let’s say you want to know which functions in a binary are called
    most often so that you can focus on optimizing those functions. To find this out,
    you can instrument all `call` instructions in the binary,^([1](footnote.xhtml#ch09fn_1))
    adding instrumentation code that records the target of the call so that the instrumented
    binary produces a list of called functions when you execute it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想知道一个二进制文件中哪些函数被调用得最频繁，以便集中精力优化这些函数。要找出这个信息，你可以在二进制文件中对所有`call`指令进行插桩，^([1](footnote.xhtml#ch09fn_1))
    添加记录调用目标的插桩代码，使得当你执行插桩后的二进制文件时，它能够生成被调用函数的列表。
- en: Although this example only observes the binary’s behavior, you can also modify
    it. For instance, you can improve a binary’s security against control-flow-hijacking
    attacks by instrumenting all indirect control transfers (such as `call rax` and
    `ret`) with code that checks whether the control-flow target is in a set of expected
    targets. If not, you abort the execution and raise an alert.^([2](footnote.xhtml#ch09fn_2))
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个例子只是观察二进制的行为，你也可以对其进行修改。例如，你可以通过对所有间接控制流转移（如`call rax`和`ret`）进行插桩，添加代码检查控制流目标是否在一组预期目标中，从而提高二进制的安全性，防止控制流劫持攻击。如果目标不在预期范围内，你就中止执行并触发警报。^([2](footnote.xhtml#ch09fn_2))
- en: '*9.1.1 Binary Instrumentation APIs*'
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*9.1.1 二进制插桩 API*'
- en: Generic binary instrumentation that allows you to add new code at every point
    in a binary is far more difficult to implement correctly than the simple binary
    modification techniques you saw in [Chapter 7](ch07.xhtml#ch07). Recall that you
    cannot simply insert new code into an existing binary code section because the
    new code will shift existing code to different addresses, thereby breaking references
    to that code. It’s practically impossible to locate and patch all existing references
    after moving code around, because binaries don’t contain any information that
    tells you where these references are and there’s no way to reliably distinguish
    referenced addresses from constants that *look* like addresses but aren’t.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通用的二进制插桩技术，允许你在二进制的每个位置添加新代码，远比你在[第七章](ch07.xhtml#ch07)中看到的简单二进制修改技术更难正确实现。回想一下，你不能简单地将新代码插入到现有的二进制代码段中，因为新代码会将现有代码移动到不同的地址，从而破坏对这些代码的引用。移动代码之后，几乎不可能找到并修补所有现有的引用，因为二进制文件中没有任何信息告诉你这些引用的位置，也没有可靠的方法来区分引用地址和看起来像地址但实际上不是地址的常量。
- en: Fortunately, there are generic binary instrumentation platforms you can use
    to handle all of the implementation complexities for you, and they offer relatively
    easy-to-use APIs with which you can implement binary instrumentation tools. These
    APIs typically allow you to install callbacks to instrumentation code at instrumentation
    points of your choice.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一些通用的二进制插装平台可以帮助你处理所有实现的复杂性，并提供相对易于使用的 API，你可以用它们实现二进制插装工具。这些 API 通常允许你在选择的插装点安装回调到插装代码中。
- en: Later in this chapter, you’ll see two practical examples of binary instrumentation
    using Pin, a popular binary instrumentation platform. You’ll use Pin to implement
    a profiler that records statistics about a binary’s execution to aid optimization.
    You’ll also use Pin to implement an automatic unpacker that helps you deobfuscate
    *packed binaries*.^([3](footnote.xhtml#ch09fn_3))
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面，你将看到两个使用 Pin 平台的二进制插装的实际示例。Pin 是一个流行的二进制插装平台，你将使用它实现一个分析器，记录二进制文件执行过程中的统计数据以帮助优化。你还将使用
    Pin 实现一个自动解压程序，帮助你去混淆 *打包的二进制文件*。^([3](footnote.xhtml#ch09fn_3))
- en: 'You can distinguish two classes of binary instrumentation platforms: static
    and dynamic. Let’s first discuss the differences between these two classes and
    then explore how they work at a low level.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以区分两类二进制插装平台：静态和动态。我们首先讨论这两类的区别，然后再探讨它们在底层的工作原理。
- en: '*9.1.2 Static vs. Dynamic Binary Instrumentation*'
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*9.1.2 静态与动态二进制插装*'
- en: Static and dynamic binary instrumentation solve the difficulties with inserting
    and relocating code using different approaches. SBI uses *binary rewriting* techniques
    to permanently modify binaries on disk. You’ll learn about the various binary
    rewriting approaches that SBI platforms use in [Section 9.2](ch09.xhtml#ch09_2).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 静态和动态二进制插装通过不同的方法解决了插入和重定位代码的难题。SBI 使用 *二进制重写* 技术永久修改磁盘上的二进制文件。你将在 [第9.2节](ch09.xhtml#ch09_2)
    学到 SBI 平台使用的各种二进制重写方法。
- en: On the other hand, DBI doesn’t modify binaries on disk at all but instead monitors
    binaries as they execute and inserts new instructions into the instruction stream
    on the fly. The advantage of this approach is that it avoids code relocation issues.
    The instrumentation code is injected only into the instruction stream, not into
    the binary’s code section in memory, so it doesn’t break references. However,
    the trade-off is that DBI’s runtime instrumentation is more computationally expensive,
    causing larger slowdowns in the instrumented binary than SBI.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，DBI 完全不修改磁盘上的二进制文件，而是在执行过程中监控二进制文件，并动态插入新的指令流。此方法的优势在于避免了代码重定位问题。插装代码仅被注入到指令流中，而不是内存中二进制代码段中，因此不会破坏引用。然而，权衡是
    DBI 的运行时插装更为计算密集，导致插装后的二进制文件比 SBI 慢得多。
- en: '[Table 9-1](ch09.xhtml#ch09tab1) summarizes the main advantages and disadvantages
    of SBI and DBI, showing advantages with a + symbol and disadvantages with a –
    symbol.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 9-1](ch09.xhtml#ch09tab1)总结了SBI和DBI的主要优缺点，优点用 + 符号表示，缺点用 - 符号表示。'
- en: '**Table 9-1:** Trade-offs of Dynamic and Static Binary Instrumentation'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-1：** 动态与静态二进制插装的权衡'
- en: '| **Dynamic instrumentation** | **Static instrumentation** |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| **动态插装** | **静态插装** |'
- en: '| --- | --- |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| – Relatively slow (4 times or more) | + Relatively fast (10% to 2 times)
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| – 相对较慢（4 倍或更多） | + 相对较快（10% 到 2 倍） |'
- en: '| --- | --- |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| – Depends on DBI library and tool | + Stand-alone binary |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| – 依赖于 DBI 库和工具 | + 独立的二进制文件 |'
- en: '| --- | --- |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| + Transparently instruments libraries | – Must explicitly instrument libraries
    |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| + 透明地插装库 | – 必须显式插装库 |'
- en: '| --- | --- |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| + Handles dynamically generated code | – Dynamically generated code unsupported
    |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| + 处理动态生成的代码 | – 不支持动态生成的代码 |'
- en: '| --- | --- |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| + Can dynamically attach/detach | – Instruments entire execution |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| + 可以动态附加/分离 | – 插装整个执行过程 |'
- en: '| --- | --- |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| + No need for disassembly | – Prone to disassembly errors |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| + 无需反汇编 | – 易出错的反汇编 |'
- en: '| --- | --- |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| + Transparent, no need to modify binary | – Error-prone binary rewriting
    |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| + 透明，不需要修改二进制文件 | – 易出错的二进制重写 |'
- en: '| --- | --- |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| + No symbols needed | – Symbols preferable to minimize errors |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| + 无需符号 | – 为了最小化错误，最好有符号 |'
- en: '| --- | --- |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: 'As you can see, DBI’s need for runtime analysis and instrumentation induces
    slowdowns of four times or more, while SBI only induces a slowdown of 10 percent
    to two times. Note that these are ballpark numbers, and the actual slowdown can
    vary significantly depending on your instrumentation needs and the implementation
    quality of your tool. Moreover, binaries instrumented with DBI are more difficult
    to distribute: you have to ship not only the binary itself but also the DBI platform
    and tool that contain the instrumentation code. On the other hand, binaries instrumented
    with SBI are stand-alone, and you can distribute them normally once the instrumentation
    is done.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，DBI对运行时分析和插桩的需求导致了四倍或更多的性能下降，而SBI只会导致10%到两倍的性能下降。请注意，这些只是大致数字，实际的性能下降可能会根据你的插桩需求和工具的实现质量有所不同。此外，使用DBI插桩的二进制文件更难分发：你不仅需要分发二进制文件本身，还需要分发包含插桩代码的DBI平台和工具。另一方面，使用SBI插桩的二进制文件是独立的，插桩完成后，你可以正常分发它们。
- en: A major advantage of DBI is that it’s much easier to use than SBI. Because DBI
    uses runtime instrumentation, it automatically accounts for all executed instructions,
    whether those are part of the original binary or of libraries used by the binary.
    In contrast, with SBI you have to explicitly instrument and distribute all libraries
    that the binary uses, unless you’re willing to leave those libraries uninstrumented.
    The fact that DBI operates on the executed instruction stream also means that
    it supports dynamically generated code that SBI cannot support, such as JIT-compiled
    code or self-modifying code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: DBI的一个主要优点是，它比SBI更易于使用。因为DBI使用运行时插桩，它自动考虑所有执行的指令，无论这些指令是原始二进制文件的一部分还是二进制文件使用的库的一部分。相比之下，使用SBI时，你必须显式地插桩并分发二进制文件使用的所有库，除非你愿意让这些库不进行插桩。DBI在执行的指令流上操作，这意味着它支持SBI无法支持的动态生成代码，如JIT编译代码或自修改代码。
- en: Additionally, DBI platforms can typically attach to and detach from processes
    dynamically, just like debuggers can. That’s convenient if you want to observe
    part of the execution of a long-running process, for example. With DBI, you can
    simply attach to that process, gather the information you want, and then detach,
    leaving the process running normally again. With SBI, this is not possible; you
    either instrument the entire execution or don’t instrument at all.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，DBI平台通常可以像调试器一样动态地附加到和分离进程。这在你想观察长时间运行的进程的部分执行时非常方便。例如，使用DBI，你可以简单地附加到该进程，收集你需要的信息，然后分离，使进程恢复正常运行。而SBI则做不到这一点；你要么插桩整个执行过程，要么根本不插桩。
- en: Finally, DBI is far less error-prone than SBI. SBI instruments binaries by disassembling
    them and then making any needed changes. That means disassembly errors can easily
    cause errors in the instrumentation, potentially causing incorrect results or
    even breaking the binary. DBI doesn’t have this problem because it doesn’t require
    disassembly; it simply observes instructions as they’re being executed, so it’s
    guaranteed to see the correct instruction stream.^([4](footnote.xhtml#ch09fn_4))
    To minimize the possibility of disassembly errors, many SBI platforms require
    symbols, while DBI has no such requirement.^([5](footnote.xhtml#ch09fn_5))
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，DBI比SBI更不容易出错。SBI通过反汇编二进制文件并进行必要的修改来插桩。这意味着反汇编错误很容易导致插桩错误，可能会导致不正确的结果，甚至使二进制文件崩溃。而DBI没有这个问题，因为它不需要反汇编；它只是在指令执行时观察指令，因此可以确保看到正确的指令流。^([4](footnote.xhtml#ch09fn_4))
    为了最小化反汇编错误的可能性，许多SBI平台需要符号，而DBI则没有此要求。^([5](footnote.xhtml#ch09fn_5))
- en: As I mentioned earlier, there are various ways to implement SBI’s binary rewriting
    and DBI’s runtime instrumentation. In the next two sections, let’s look at the
    most popular ways to implement SBI and DBI, respectively.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，实现SBI的二进制重写和DBI的运行时插桩有多种方式。在接下来的两个部分中，我们将分别看看实现SBI和DBI的最流行方式。
- en: 9.2 Static Binary Instrumentation
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2 静态二进制插桩
- en: Static binary instrumentation works by disassembling a binary and then adding
    instrumentation code where needed and storing the updated binary permanently on
    disk. Well-known SBI platforms include PEBIL^([6](footnote.xhtml#ch09fn_6)) and
    Dyninst^([7](footnote.xhtml#ch09fn_7)) (which supports both DBI and SBI). PEBIL
    requires symbols while Dyninst does not. Note that both PEBIL and Dyninst are
    research tools, so they’re not as well documented as a production-quality tool.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 静态二进制插装（SBI）通过反汇编二进制文件，然后在需要的地方添加插装代码，并将更新后的二进制文件永久存储在磁盘上。著名的SBI平台包括PEBIL^([6](footnote.xhtml#ch09fn_6))和Dyninst^([7](footnote.xhtml#ch09fn_7))（它同时支持DBI和SBI）。PEBIL需要符号，而Dyninst则不需要。请注意，PEBIL和Dyninst都是研究工具，因此它们的文档不如生产级工具那么完备。
- en: The main challenge in implementing SBI is finding a way to add the instrumentation
    code and rewrite the binary without breaking any existing code or data references.
    Let’s consider two popular solutions to this challenge, which I call the *int
    3 approach* and the *trampoline approach*. Note that, in practice, SBI engines
    may incorporate elements from both these techniques or use another technique entirely.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 实现SBI的主要挑战是找到一种方法来添加插装代码并重写二进制文件，同时不破坏任何现有的代码或数据引用。让我们考虑两种常见的解决方案，我称之为*int 3方法*和*跳板方法*。请注意，在实际应用中，SBI引擎可能结合这两种技术的元素，或者采用完全不同的技术。
- en: '*9.2.1 The int 3 Approach*'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*9.2.1 int 3 方法*'
- en: The *int 3 approach* gets its name from the x86 `int 3` instruction, which debuggers
    use to implement software breakpoints. To illustrate the need for `int 3`, let’s
    first consider an SBI approach that does *not* work in the general case.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*int 3方法*得名于x86的`int 3`指令，调试器使用它来实现软件断点。为了说明`int 3`的必要性，我们首先考虑一种在一般情况下*不*有效的SBI方法。'
- en: A Naive SBI Implementation
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个简单的SBI实现
- en: Given the practical impossibility of fixing all references to relocated code,
    it’s clear that SBI cannot store the instrumentation code inline in an existing
    code section. Because there’s no room for arbitrary amounts of new code in the
    existing code sections, it follows that SBI approaches must store instrumentation
    code in a separate location, such as a new section or a shared library, and then
    somehow transfer control to the instrumentation code when execution reaches an
    instrumentation point. To achieve this, you might come up with the solution shown
    in [Figure 9-1](ch09.xhtml#ch09fig1).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于修复所有指向已重新定位代码的引用在实际中几乎不可能，显然SBI不能将插装代码内联到现有的代码段中。由于现有代码段中没有足够的空间来添加任意数量的新代码，因此SBI方法必须将插装代码存储在一个独立的位置，比如一个新的代码段或共享库中，然后在执行到插装点时，某种方式将控制转移到插装代码。为了实现这一点，你可能会想到[图9-1](ch09.xhtml#ch09fig1)中所示的解决方案。
- en: '![image](Images/f227-01.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f227-01.jpg)'
- en: '*Figure 9-1: A nongeneric SBI approach that uses* `jmp` *to hook instrumentation
    points*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-1：一种非通用的SBI方法，它使用* `jmp` *来挂钩插装点*'
- en: The leftmost column of [Figure 9-1](ch09.xhtml#ch09fig1) shows a chunk of original,
    uninstrumented code. Let’s say you want to instrument the instruction `mov edx,0x1`
    ➊, adding instrumentation code to run before and after that instruction. To get
    around the problem that there’s no room to add the new code inline, you overwrite
    `mov edx,0x1` with a `jmp` to your instrumentation code ➋, stored in a separate
    code section or library. The instrumentation code first runs any *pre-instrumentation*
    code that you added ➌, which is code that runs before the original instruction.
    Next, it runs the original `mov edx,0x1` instruction ➍ and then the *post-instrumentation*
    code ➎. Finally, the instrumentation code jumps back to the instruction following
    the instrumentation point ➏, resuming normal execution.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9-1](ch09.xhtml#ch09fig1)的最左列展示了一块原始的、未插装的代码。假设你想在指令`mov edx,0x1` ➊前后添加插装代码。为了绕过无法在原地添加新代码的问题，你可以将`mov
    edx,0x1`替换为一个跳转指令`jmp`，该跳转指令指向你存储在独立代码段或库中的插装代码 ➋。插装代码首先运行你添加的*前置插装*代码 ➌，也就是在原始指令之前执行的代码。接着，它运行原始的`mov
    edx,0x1`指令 ➍，然后执行*后置插装*代码 ➎。最后，插装代码跳转回插装点后面的指令 ➏，恢复正常执行。'
- en: Note that if the pre-instrumentation or post-instrumentation code changes register
    contents, that may inadvertently affect other parts of the program. That’s why
    SBI platforms store the register state before running this added code and restore
    the state afterward, unless you explicitly tell the SBI platform that you *want*
    to change the register state.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果预先或后置的代码更改了寄存器内容，这可能会无意中影响程序的其他部分。因此，SBI 平台在运行这些新增代码之前会保存寄存器的状态，并在之后恢复状态，除非你明确告诉
    SBI 平台你*想要*更改寄存器状态。
- en: As you can see, the approach in [Figure 9-1](ch09.xhtml#ch09fig1) is a simple
    and elegant way to run arbitrary amounts of code of your choice before or after
    any instruction. So what’s the problem with this approach? The issue is that `jmp`
    instructions take up multiple bytes; to jump to instrumentation code, you typically
    need a 5-byte `jmp` instruction that consists of 1 opcode byte with a 32-bit offset.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，[图 9-1](ch09.xhtml#ch09fig1) 中的方法是一种简单而优雅的方式，可以在任意指令之前或之后运行你选择的任意量的代码。那么这个方法有什么问题呢？问题在于，`jmp`
    指令占用多个字节；要跳转到仪器化代码，你通常需要一个 5 字节的 `jmp` 指令，其中包括 1 个操作码字节和一个 32 位的偏移量。
- en: When you instrument a short instruction, the `jmp` to your instrumentation code
    may be longer than the instruction it replaces. For example, the `xor esi,esi`
    instruction at the top left of [Figure 9-1](ch09.xhtml#ch09fig1) is only 2 bytes
    long, so if you replace that with a 5-byte `jmp`, the `jmp` will overwrite and
    corrupt part of the next instruction. You can’t solve this issue by making that
    next overwritten instruction part of the instrumentation code because the instruction
    may be a branch target. Any branches targeting that instruction would end up in
    the middle of the `jmp` you inserted, breaking the binary.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对一条短指令进行仪器化时，跳转到仪器化代码的 `jmp` 可能比它所替代的指令要长。例如，[图 9-1](ch09.xhtml#ch09fig1)
    左上角的 `xor esi,esi` 指令只有 2 个字节长，因此，如果你用 5 字节的 `jmp` 替换它，`jmp` 会覆盖并破坏下一条指令的一部分。你无法通过将被覆盖的下一条指令作为仪器化代码的一部分来解决这个问题，因为该指令可能是一个分支目标。任何指向该指令的分支都将落入你插入的
    `jmp` 的中间，破坏二进制文件。
- en: This brings us back to the `int 3` instruction. You can use the `int 3` instruction
    to instrument short instructions where multibyte jumps don’t fit, as you’ll see
    next.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这又将我们带回到 `int 3` 指令。你可以使用 `int 3` 指令来仪器化那些无法适配多字节跳转的短指令，正如接下来所看到的那样。
- en: Solving the Multibyte Jump Problem with int 3
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `int 3` 解决多字节跳转问题
- en: The x86 `int 3` instruction generates a software interrupt that user-space programs
    like SBI libraries or debuggers can catch (on Linux) in the form of a `SIGTRAP`
    signal delivered by the operating system. The key detail about `int 3` is that
    it’s only 1 byte long, so you can overwrite any instruction with it without fear
    of overwriting a neighboring instruction. The opcode for `int 3` is `0xcc`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: x86 的 `int 3` 指令生成一个软件中断，用户空间程序（如 SBI 库或调试器）可以捕获该中断（在 Linux 上以 `SIGTRAP` 信号的形式由操作系统传递）。关于
    `int 3` 的关键细节是，它只有 1 个字节长，因此你可以用它覆盖任何指令，而无需担心覆盖相邻的指令。`int 3` 的操作码是 `0xcc`。
- en: From an SBI viewpoint, to instrument an instruction using `int3`, you simply
    overwrite the first byte of that instruction with `0xcc`. When a `SIGTRAP` happens,
    you can use Linux’s `ptrace` API to find out at which address the interrupt occurred,
    telling you the instrumentation point address. You can then invoke the appropriate
    instrumentation code for that instrumentation point, just as you saw in [Figure
    9-1](ch09.xhtml#ch09fig1).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从 SBI 的角度来看，要使用 `int 3` 来仪器化一条指令，你只需将该指令的第一个字节覆盖为 `0xcc`。当发生 `SIGTRAP` 时，你可以使用
    Linux 的 `ptrace` API 来查找中断发生的地址，从而告诉你仪器化点的地址。然后，你可以调用该仪器化点的适当仪器化代码，正如你在 [图 9-1](ch09.xhtml#ch09fig1)
    中看到的那样。
- en: From a purely functional standpoint, `int 3` is an ideal way to implement SBI
    because it’s easy to use and doesn’t require any code relocation. Unfortunately,
    software interrupts like `int 3` are slow, causing excessive overhead in the instrumented
    application. Moreover, the *int 3 approach* is incompatible with programs that
    are already being debugged using `int 3` for breakpoints. That’s why in practice
    many SBI platforms use more complicated but faster rewriting methods, such as
    the trampoline approach.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从纯粹的功能角度来看，`int 3` 是实现 SBI 的理想方式，因为它易于使用且不需要任何代码重定位。不幸的是，像 `int 3` 这样的软件中断较慢，会导致仪器化应用程序产生过多的开销。此外，*int
    3 方法*与已经使用 `int 3` 作为断点的程序不兼容。因此，在实际应用中，许多 SBI 平台使用更复杂但更快速的重写方法，如跳板方法。
- en: '*9.2.2 The Trampoline Approach*'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*9.2.2 跳板方法*'
- en: Unlike the `int 3` approach, the trampoline approach makes no attempt to instrument
    the original code directly. Instead, it creates a copy of all the original code
    and instruments only this copied code. The idea is that this won’t break any code
    or data references because these all still point to the original, unchanged locations.
    To ensure that the binary runs the instrumented code instead of the original code,
    the trampoline approach uses `jmp` instructions called *trampolines* to redirect
    the original code to the instrumented copy. Whenever a call or jump transfers
    control to a part of the original code, the trampoline at that location immediately
    jumps to the corresponding instrumented code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 与`int 3`方法不同，跳板方法不会直接尝试对原始代码进行插装。相反，它创建了原始代码的副本，仅对这个副本进行插装。其理念是，这样做不会破坏任何代码或数据引用，因为这些引用仍然指向原始、未更改的位置。为了确保二进制文件运行插装后的代码而不是原始代码，跳板方法使用`jmp`指令，称为*跳板*，将原始代码重定向到插装后的副本。每当调用或跳转将控制权转移到原始代码的某个部分时，那个位置的跳板会立即跳转到对应的插装代码。
- en: To clarify the trampoline approach, consider the example shown in [Figure 9-2](ch09.xhtml#ch09fig2).
    The figure shows an uninstrumented binary on the left side, while the right side
    shows how that binary transforms when you instrument it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地理解跳板方法，参考[图9-2](ch09.xhtml#ch09fig2)中展示的示例。图中左侧显示的是未插装的二进制文件，右侧则显示了插装后的二进制文件如何变化。
- en: '![image](Images/f229-01.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f229-01.jpg)'
- en: '*Figure 9-2: Static binary instrumentation with trampolines*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-2：使用跳板的静态二进制插装*'
- en: Let’s assume the original noninstrumented binary contains two functions called
    `f1` and `f2`. [Figure 9-2](ch09.xhtml#ch09fig2) shows that `f1` contains the
    following code. The contents of `f2` are not important for this example.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 假设原始的未插装二进制文件包含两个函数，分别是`f1`和`f2`。[图9-2](ch09.xhtml#ch09fig2)显示了`f1`包含的代码。`f2`的内容对于这个示例并不重要。
- en: '[PRE0]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When you instrument a binary using the trampoline approach, the SBI engine
    creates copies of all the original functions, places them in a new code section
    (called `.text.instrum` in [Figure 9-2](ch09.xhtml#ch09fig2)), and overwrites
    the first instruction of each original function with a `jmp` trampoline that jumps
    to the corresponding copied function. For example, the SBI engine rewrites the
    original `f1` as follows to redirect it to `f1_copy`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用跳板方法对二进制文件进行插装时，SBI引擎会创建所有原始函数的副本，将它们放置在一个新的代码段中（在[图9-2](ch09.xhtml#ch09fig2)中称为`.text.instrum`），并用`jmp`跳板指令覆盖每个原始函数的第一条指令，指向相应的复制函数。例如，SBI引擎会按如下方式重写原始的`f1`，将其重定向到`f1_copy`：
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The trampoline instruction is a 5-byte `jmp`, so it may partially overwrite
    and corrupt multiple instructions, creating “junk bytes” just after the trampoline.
    However, this isn’t normally a problem for the trampoline approach because it
    ensures that these corrupted instructions are never executed. You’ll see some
    cases where this may go wrong at the end of this section.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 跳板指令是一个5字节的`jmp`，因此它可能部分覆盖并破坏多个指令，导致跳板后面出现“垃圾字节”。然而，这通常不是跳板方法的问题，因为它确保这些损坏的指令永远不会被执行。你将在本节末尾看到一些可能出错的情况。
- en: Trampoline Control Flow
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跳板控制流
- en: To get a better sense of the control flow of a program instrumented with the
    trampoline approach, let’s return to the right side of [Figure 9-2](ch09.xhtml#ch09fig2)
    showing the instrumented binary and assume that the original `f1` function has
    just been called. As soon as `f1` is called, the trampoline jumps to `f1_copy`
    ➊, the instrumented version of `f1`. There may be some junk bytes following the
    trampoline ➋, but these aren’t executed.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解通过跳板方法插装的程序控制流，回到[图9-2](ch09.xhtml#ch09fig2)右侧显示的插装二进制文件，并假设原始的`f1`函数刚刚被调用。只要`f1`被调用，跳板就会跳转到`f1_copy`
    ➊，即`f1`的插装版本。跳板后面可能会有一些垃圾字节 ➋，但这些字节不会被执行。
- en: The SBI engine inserts several `nop` instructions at every possible instrumentation
    point in `f1_copy` ➌. That way, to instrument an instruction, the SBI engine can
    simply overwrite the `nop` instructions at that instrumentation point with a `jmp`
    or `call` to a chunk of instrumentation code. Note that both the `nop` insertion
    and the instrumentation are done statically, not at runtime. In [Figure 9-2](ch09.xhtml#ch09fig2),
    all of the `nop` regions are unused except for the last one, just before the `ret`
    instruction, as I’ll explain in a moment.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: SBI引擎会在`f1_copy`中的每个可能的插装点插入若干个`nop`指令 ➌。这样，为了插装一条指令，SBI引擎只需将该插装点的`nop`指令覆盖为跳转`jmp`或调用`call`到一个插装代码块。请注意，`nop`插入和插装操作都是静态完成的，而不是在运行时完成的。在[图9-2](ch09.xhtml#ch09fig2)中，所有的`nop`区域除了最后一个区域——位于`ret`指令之前——都没有使用，正如我稍后会解释的那样。
- en: To maintain the correctness of relative jumps despite the code shifting because
    of newly inserted instructions, the SBI engine patches the offsets of all relative
    `jmp` instructions. Additionally, the engine replaces all 2-byte relative `jmp`
    instructions, which have an 8-bit offset, with a corresponding 5-byte version
    that has a 32-bit offset ➍. This is necessary because as you shift code around
    in `f1_copy`, the offset between `jmp` instructions and their targets may become
    too large to encode in 8 bits.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在插入新指令后代码发生偏移时仍能保持相对跳转的正确性，SBI引擎会修补所有相对`jmp`指令的偏移量。此外，SBI引擎还会将所有2字节的相对`jmp`指令（具有8位偏移量）替换为相应的5字节版本，这些版本具有32位的偏移量
    ➍。这是必要的，因为当你在`f1_copy`中移动代码时，`jmp`指令与其目标之间的偏移可能会变得过大，无法用8位编码。
- en: Similarly, the SBI engine rewrites direct calls, such as `call f2`, so that
    they target the instrumented function instead of the original ➎. Given this rewriting
    of direct calls, you may wonder why the trampolines at the start of every original
    function are needed at all. As I’ll explain in a moment, they’re necessary to
    accommodate indirect calls.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，SBI引擎会重写直接调用，如`call f2`，使它们指向插装后的函数，而不是原始函数 ➎。鉴于这种对直接调用的重写，你可能会想知道为什么每个原始函数开头的跳板仍然是必要的。正如我稍后会解释的那样，它们是为了适应间接调用而必需的。
- en: Now let’s assume you’ve told the SBI engine to instrument every `ret` instruction.
    To do this, the SBI engine overwrites the `nop` instructions reserved for this
    purpose with a `jmp` or `call` to your instrumentation code ➏. In the example
    of [Figure 9-2](ch09.xhtml#ch09fig2), the instrumentation code is a function named
    `hook_ret`, which is placed in a shared library and reached by a `call` that the
    SBI engine placed at the instrumentation point.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你已经告诉SBI引擎插装每条`ret`指令。为此，SBI引擎会将为此目的预留的`nop`指令覆盖为跳转`jmp`或调用`call`到你的插装代码
    ➏。在[图9-2](ch09.xhtml#ch09fig2)的示例中，插装代码是一个名为`hook_ret`的函数，它被放置在共享库中，并通过SBI引擎在插装点插入的`call`调用来访问。
- en: The `hook_ret` function first saves state ➐, such as register contents, and
    then runs any instrumentation code that you specified. Finally, it restores the
    saved state ➑ and resumes normal execution by returning to the instruction following
    the instrumentation point.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`hook_ret`函数首先保存状态 ➐，例如寄存器内容，然后运行你指定的任何插装代码。最后，它恢复保存的状态 ➑，并通过返回到插装点后的指令来恢复正常执行。'
- en: Now that you’ve seen how the trampoline approach rewrites direct control flow
    instructions, let’s take a look at how it handles indirect control flow.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了跳板方法如何重写直接控制流指令，让我们来看一下它是如何处理间接控制流的。
- en: Handling Indirect Control Flow
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理间接控制流
- en: 'Because indirect control flow instructions target dynamically computed addresses,
    there’s no reliable way for SBI engines to statically redirect them. The trampoline
    approach allows indirect control transfers to flow to original, uninstrumented
    code and uses trampolines placed in the original code to intercept and redirect
    the control flow back to the instrumented code. [Figure 9-3](ch09.xhtml#ch09fig3)
    shows how the trampoline approach handles two types of indirect control flow:
    indirect function calls and indirect jumps used to implement C/C++ `switch` statements.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于间接控制流指令的目标是动态计算的地址，因此SBI引擎无法静态地重定向它们。跳板技术允许间接控制流转移到原始的、未插装的代码，并通过在原始代码中放置跳板来拦截并将控制流重新定向回插装过的代码。[图9-3](ch09.xhtml#ch09fig3)展示了跳板方法如何处理两种类型的间接控制流：间接函数调用和用于实现C/C++
    `switch`语句的间接跳转。
- en: '![image](Images/f231-01.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f231-01.jpg)'
- en: '*Figure 9-3: Indirect control transfers in a statically instrumented binary*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-3：静态插装二进制中的间接控制转移*'
- en: '[Figure 9-3a](ch09.xhtml#ch09fig3) shows how the trampoline approach handles
    indirect calls. The SBI engine doesn’t alter code that computes addresses, so
    the target addresses used by indirect calls point to the original function ➊.
    Because there’s a trampoline at the start of every original function, control
    flows immediately back to the instrumented version of the function ➋.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-3a](ch09.xhtml#ch09fig3) 展示了跳板方法如何处理间接调用。SBI 引擎不会改变计算地址的代码，因此间接调用使用的目标地址指向原始函数
    ➊。由于每个原始函数的开始处都有一个跳板，控制流会立即返回到该函数的插桩版本 ➋。'
- en: For indirect jumps, things are more complicated, as you can see in [Figure 9-3b](ch09.xhtml#ch09fig3).
    For the purposes of this example, let’s assume an indirect jump that’s part of
    a C/C++ `switch` statement. At the binary level, switch statements are often implemented
    using a *jump table* that contains all the addresses of the possible `switch`
    cases. To jump to a particular case, the `switch` computes the corresponding jump
    table index and uses an indirect `jmp` to jump to the address stored there ➊.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于间接跳转，事情变得更加复杂，正如你在[图 9-3b](ch09.xhtml#ch09fig3)中看到的那样。为了简化这个例子，假设这是一个作为 C/C++
    `switch` 语句一部分的间接跳转。在二进制级别，`switch` 语句通常使用一个*跳转表*来实现，该表包含所有可能的 `switch` 情况的地址。为了跳转到特定的情况，`switch`
    会计算出对应的跳转表索引，并使用间接的 `jmp` 跳转到该地址 ➊。
- en: Trampolines in Position-Independent Code
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 位置无关代码中的跳板
- en: 'SBI engines based on the trampoline approach require special support for indirect
    control flows in position-independent executables (PIE binaries), which don’t
    depend on any particular load address. PIE binaries read the value of the program
    counter and use it as the basis for address computations. On 32-bit x86, PIE binaries
    read the program counter by executing a `call` instruction and then reading the
    return address from the stack. For example, `gcc 5.4.0` emits the following function
    that you can call to read the address of the instruction after the `call`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 基于跳板方法的 SBI 引擎需要对位置独立可执行文件（PIE 二进制文件）中的间接控制流提供特别支持，这些文件不依赖于任何特定的加载地址。PIE 二进制文件会读取程序计数器的值，并将其作为地址计算的基础。在
    32 位 x86 上，PIE 二进制文件通过执行 `call` 指令来读取程序计数器，然后从栈中读取返回地址。例如，`gcc 5.4.0` 会生成以下函数，你可以调用它来读取
    `call` 指令之后的指令地址：
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This function copies the return address into `ebx` and then returns. On x64,
    you can read the program counter (`rip`) directly.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将返回地址复制到 `ebx` 中，然后返回。在 x64 中，你可以直接读取程序计数器（`rip`）。
- en: The danger with PIE binaries is that they may read the program counter while
    running instrumented code and use it in address computations. This likely yields
    incorrect results because the layout of the instrumented code differs from the
    original layout that the address computation assumes. To solve this, SBI engines
    instrument code constructs that read the program counter such that they return
    the value the program counter would have in the original code. That way, subsequent
    address computations yield the original code location just as in an uninstrumented
    binary, allowing the SBI engine to intercept control there with a trampoline.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: PIE（二进制位置独立）可执行文件的危险在于，它们可能在运行插桩代码时读取程序计数器并将其用于地址计算。这很可能导致错误的结果，因为插桩代码的布局与地址计算假设的原始布局不同。为了解决这个问题，SBI
    引擎会对读取程序计数器的代码结构进行插桩，使其返回原始代码中程序计数器应有的值。这样，随后的地址计算将像在未插桩的二进制文件中一样，得出原始代码的位置，从而允许
    SBI 引擎通过跳板拦截该位置的控制流。
- en: By default, the addresses stored in the jump table all point into the original
    code ➋. Thus, the indirect `jmp` ends up in the middle of an original function,
    where there’s no trampoline, and resumes execution there ➌. To avoid this problem,
    the SBI engine must either patch the jump table, changing original code addresses
    to new ones, or place a trampoline at every `switch` case in the original code.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，跳转表中存储的地址都指向原始代码 ➋。因此，间接的 `jmp` 最终会跳到原始函数的中间，那里没有跳板，然后继续执行 ➌。为了避免这个问题，SBI
    引擎必须要么修补跳转表，修改原始代码地址为新的地址，要么在原始代码中的每个 `switch` 情况处放置一个跳板。
- en: Unfortunately, basic symbolic information (as opposed to extensive DWARF information)
    contains no information on the layout of `switch` statements, making it hard to
    figure out where to place the trampolines. Additionally, there may not be enough
    room between the `switch` statements to accommodate all trampolines. Patching
    jump tables is also dangerous because you risk erroneously changing data that
    just happens to be a valid address but isn’t really part of a jump table.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，基本的符号信息（与大量DWARF信息不同）没有包含`switch`语句的布局信息，这使得很难判断在哪里放置跳板。此外，`switch`语句之间可能没有足够的空间来容纳所有的跳板。修补跳转表也是危险的，因为你有可能错误地改变一些数据，这些数据恰好是一个有效的地址，但并不真正属于跳转表的一部分。
- en: Reliability of the Trampoline Approach
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跳板方法的可靠性
- en: As you can tell from the problems handling `switch` statements, the trampoline
    approach is error-prone. Similar to `switch` cases that are too small to accommodate
    a normal trampoline, programs may (however unlikely) contain very short functions
    that don’t have enough room for a 5-byte `jmp`, requiring the SBI engine to fall
    back to another solution like the `int 3` approach. Moreover, if the binary contains
    any inline data mixed in with the code, trampolines may inadvertently overwrite
    part of that data, causing errors when the program uses the data. All this is
    assuming that the disassembly used is correct in the first place; if it’s not,
    any changes made by the SBI engine may break the binary.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，处理`switch`语句时，跳板方法容易出错。类似于那些空间不足以容纳正常跳板的`switch`语句，程序可能（尽管不太可能）包含非常短的函数，它们没有足够的空间放置一个5字节的`jmp`，这时SBI引擎需要回退到另一种解决方案，比如`int
    3`方法。此外，如果二进制文件中包含任何与代码混合的内联数据，跳板可能会不小心覆盖部分数据，导致程序在使用这些数据时出现错误。所有这些假设反汇编本身就是正确的；如果不正确，SBI引擎所做的任何修改都可能会破坏二进制文件。
- en: Unfortunately, there’s no known SBI technique that’s both efficient and sound,
    making SBI dangerous to use on production binaries. In many cases, DBI solutions
    are preferable, because they’re not prone to the errors SBI faces. Although they’re
    not as fast as SBI, modern DBI platforms perform efficiently enough for many practical
    use cases. The rest of this chapter focuses on DBI, specifically on a well-known
    DBI platform called Pin. Let’s take a look at some of DBI’s implementation details
    and then explore practical examples.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，目前没有一种既高效又可靠的SBI技术，这使得SBI在生产二进制文件中使用时存在风险。在许多情况下，DBI解决方案更为可取，因为它们不容易遭遇SBI所面临的错误。尽管DBI的速度不如SBI，但现代DBI平台在许多实际应用场景中已经足够高效。本章的其余部分将重点介绍DBI，特别是一个著名的DBI平台——Pin。我们将首先看看DBI的实现细节，然后探讨一些实际的例子。
- en: 9.3 Dynamic Binary Instrumentation
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3 动态二进制插装
- en: Because DBI engines monitor binaries (or rather, processes) as they execute
    and instrument the instruction stream, they don’t require disassembly or binary
    rewriting like SBI does, making them less error-prone.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因为DBI引擎在执行过程中监控二进制文件（或更准确地说，监控进程），并对指令流进行插装，它们不像SBI那样需要反汇编或二进制重写，因此它们更不容易出错。
- en: '[Figure 9-4](ch09.xhtml#ch09fig4) shows the architecture of modern DBI systems
    like Pin and DynamoRIO. These systems are all based on the same high-level approach,
    although they differ in implementation details and optimizations. I’ll focus the
    rest of this chapter on the kind of “pure” DBI systems shown in the figure, rather
    than hybrid platforms like Dyninst that support both SBI and DBI by using code-patching
    techniques such as trampolines.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-4](ch09.xhtml#ch09fig4)展示了现代DBI系统（如Pin和DynamoRIO）的架构。这些系统都基于相同的高级方法，尽管它们在实现细节和优化上有所不同。我将把本章的其余部分集中在图中展示的“纯”DBI系统，而不是像Dyninst这样的混合平台，后者通过使用代码修补技术（如跳板）来支持SBI和DBI。'
- en: '*9.3.1 Architecture of a DBI System*'
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*9.3.1 DBI系统架构*'
- en: DBI engines dynamically instrument processes by monitoring and controlling all
    the executed instructions. The DBI engine exposes an API that allows you to write
    user-defined DBI tools (often in the form of a shared library loaded by the engine)
    that specify which code should be instrumented and how. For example, the DBI tool
    shown on the right side of [Figure 9-4](ch09.xhtml#ch09fig4) implements (in pseudocode)
    a simple profiler that counts how many basic blocks are executed. To achieve that,
    it uses the DBI engine’s API to instrument the last instruction of every basic
    block with a callback to a function that increments a counter.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: DBI 引擎通过监控和控制所有已执行的指令来动态地插桩进程。DBI 引擎暴露了一个 API，允许你编写用户定义的 DBI 工具（通常是由引擎加载的共享库形式），以指定哪些代码需要插桩以及如何插桩。例如，[图
    9-4](ch09.xhtml#ch09fig4) 右侧显示的 DBI 工具实现了一个简单的性能分析器（伪代码），该分析器统计执行了多少个基本块。为了实现这一点，它使用
    DBI 引擎的 API，在每个基本块的最后一条指令上插桩一个回调函数，以增加计数器。
- en: Before the DBI engine starts the main application process (or resumes it, if
    you attach to an existing process), it allows the DBI tool to initialize itself.
    In [Figure 9-4](ch09.xhtml#ch09fig4), the DBI tool’s initialization function registers
    a function called `instrument_bb` with the DBI engine ➊. This function tells the
    DBI engine how to instrument every basic block; in this case, it adds a callback
    to `bb_callback` after the last instruction in the basic block. Next, the initialization
    function informs the DBI engine that it’s done initializing and ready to start
    the application ➋.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DBI 引擎启动主应用程序进程之前（或者如果你附加到现有进程，则在恢复它之前），它允许 DBI 工具进行初始化。在[图 9-4](ch09.xhtml#ch09fig4)中，DBI
    工具的初始化函数将一个名为`instrument_bb`的函数注册到 DBI 引擎 ➊。这个函数告诉 DBI 引擎如何对每个基本块进行插桩；在这种情况下，它在基本块的最后一条指令后添加了一个回调到`bb_callback`。接下来，初始化函数通知
    DBI 引擎它已完成初始化并准备启动应用程序 ➋。
- en: '![image](Images/f234-01.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f234-01.jpg)'
- en: '*Figure 9-4: Architecture of a DBI system*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-4：DBI 系统的架构*'
- en: The DBI engine never runs the application process directly but instead runs
    code in a *code cache* that contains all the instrumented code. Initially, the
    code cache is empty, so the DBI engine fetches a block of code from the process
    ➌ and instruments that code ➍ as instructed by the DBI tool ➎. Note that DBI engines
    don’t necessarily fetch and instrument code at basic block granularity, as I’ll
    explain further in [Section 9.4](ch09.xhtml#ch09_4). However, for this example
    I’ll assume that the engine instruments code at basic block granularity by calling
    `instrument_bb`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: DBI 引擎从不直接运行应用程序进程，而是运行包含所有插桩代码的*代码缓存*中的代码。最初，代码缓存是空的，因此 DBI 引擎从进程中获取一块代码 ➌，并按照
    DBI 工具的指示对该代码进行插桩 ➍。请注意，DBI 引擎不一定以基本块粒度获取和插桩代码，正如我将在[第 9.4 节](ch09.xhtml#ch09_4)中进一步解释的那样。然而，在这个例子中，我假设引擎通过调用`instrument_bb`以基本块粒度插桩代码。
- en: After instrumenting the code, the DBI engine compiles it with a just-intime
    (JIT) compiler ➏, which re-optimizes the instrumented code and stores the compiled
    code in the code cache ➐. The JIT compiler also rewrites control flow instructions
    to ensure that the DBI engine retains control, preventing control transfers from
    continuing execution in the uninstrumented application process. Note that unlike
    most compilers, the JIT compiler in a DBI engine doesn’t translate the code into
    a different language; it compiles from native machine code to native machine code.
    It’s only necessary to instrument and JIT-compile code the first time it’s executed.
    After that, it’s stored in the code cache and reused.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在对代码进行插桩后，DBI 引擎使用即时编译器（JIT） ➏进行编译，JIT 编译器重新优化插桩后的代码，并将编译后的代码存储在代码缓存中 ➐。JIT
    编译器还会重写控制流指令，确保 DBI 引擎保持控制，防止控制转移继续在未插桩的应用程序进程中执行。请注意，与大多数编译器不同，DBI 引擎中的 JIT 编译器不会将代码翻译成不同的语言；它是从原生机器码编译到原生机器码。只需在首次执行代码时进行插桩和
    JIT 编译。之后，代码会存储在代码缓存中并重用。
- en: The instrumented and JIT-compiled code now executes in the code cache until
    there’s a control-flow instruction that requires fetching new code or looking
    up another code chunk in the cache ➑ DBI engines like Pin and DynamoRIO reduce
    runtime overhead by rewriting control-flow instructions when possible, so they
    jump directly to the next block in the code cache without mediation by the DBI
    engine. When that’s not possible (for example, for indirect calls), the rewritten
    instructions return control to the DBI engine so that it can prepare and start
    the next code chunk.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 插装并 JIT 编译后的代码现在在代码缓存中执行，直到遇到需要获取新代码或在缓存中查找另一个代码块的控制流指令 ➑。像 Pin 和 DynamoRIO
    这样的 DBI 引擎通过在可能的情况下重写控制流指令，减少了运行时开销，从而使它们能够直接跳转到代码缓存中的下一个块，而无需经过 DBI 引擎的中介。当不可能这样做时（例如，对于间接调用），重写的指令会将控制权返回给
    DBI 引擎，以便它准备并启动下一个代码块。
- en: While most instructions run natively in the code cache, the DBI engine may emulate
    some instructions instead of running them directly. For example, Pin does this
    for system calls like `execve` that require special handling by the DBI engine.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数指令在代码缓存中本地运行，但 DBI 引擎可能会模拟某些指令，而不是直接运行它们。例如，Pin 对像 `execve` 这样的系统调用进行模拟，因为它们需要
    DBI 引擎特别处理。
- en: The instrumented code contains callbacks to functions in the DBI tool that observe
    or modify the code’s behavior ➒. For instance, in [Figure 9-4](ch09.xhtml#ch09fig4),
    the DBI tool’s `instrument_bb` function adds a callback at the end of every basic
    block that invokes `bb_callback`, which increments the DBI tool’s basic block
    counter. The DBI engine automatically saves and restores register state when transferring
    control to or from a callback function in the DBI tool.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 插装后的代码包含回调到 DBI 工具中的函数，这些函数观察或修改代码的行为 ➒。例如，在 [图 9-4](ch09.xhtml#ch09fig4) 中，DBI
    工具的 `instrument_bb` 函数在每个基本块的末尾添加一个回调，调用 `bb_callback`，该回调递增 DBI 工具的基本块计数器。DBI
    引擎在将控制转移到或从 DBI 工具中的回调函数时，会自动保存和恢复寄存器状态。
- en: Now that you’re familiar with the workings of DBI engines, let’s discuss Pin,
    the DBI engine I’ll use for the examples in this chapter.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了 DBI 引擎的工作原理，让我们来讨论 Pin，这是我在本章示例中使用的 DBI 引擎。
- en: '*9.3.2 Introduction to Pin*'
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*9.3.2 Pin 介绍*'
- en: One of the most popular DBI platforms, Intel Pin is an actively developed, free-to-use
    (though not open source), and well-documented tool that offers a relatively easy-to-use
    API.^([8](footnote.xhtml#ch09fn_8)) You’ll find Pin v3.6 preinstalled on the virtual
    machine in *~/pin/pin-3.6-97554-g31f0a167d-gcc-linux*. Pin ships with many example
    tools that you can find in the *source/tools* subdirectory of the main Pin directory.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最受欢迎的 DBI 平台之一，Intel Pin 是一个积极开发的、免费使用（尽管不是开源的）且文档齐全的工具，它提供了一个相对易用的 API。^([8](footnote.xhtml#ch09fn_8))
    你会在虚拟机的 *~/pin/pin-3.6-97554-g31f0a167d-gcc-linux* 路径下找到预装的 Pin v3.6。Pin 附带了许多示例工具，你可以在主
    Pin 目录的 *source/tools* 子目录中找到它们。
- en: Pin Internals
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pin 内部结构
- en: Pin currently supports Intel CPU architectures including x86 and x64 and is
    available for Linux, Windows, and macOS. Its architecture is similar to [Figure
    9-4](ch09.xhtml#ch09fig4). Pin fetches and JIT-compiles code at *trace* granularity,
    a basic block-like abstraction that can be entered only at the top but may contain
    multiple exits, unlike regular basic blocks.^([9](footnote.xhtml#ch09fn_9)) Pin
    defines a trace as a straight-line instruction sequence that ends when it hits
    an unconditional control transfer or reaches a predefined maximum length or number
    of conditional control-flow instructions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Pin 当前支持包括 x86 和 x64 在内的 Intel CPU 架构，并可用于 Linux、Windows 和 macOS。其架构类似于 [图 9-4](ch09.xhtml#ch09fig4)。Pin
    按 *trace* 粒度获取和 JIT 编译代码，*trace* 是一种类似基本块的抽象，可以仅在顶部进入，但可能包含多个退出点，不同于常规的基本块。^([9](footnote.xhtml#ch09fn_9))
    Pin 将 trace 定义为一条直线指令序列，直到遇到无条件控制转移或达到预定义的最大长度或条件控制流指令数量时结束。
- en: Although Pin always JIT-compiles code at trace granularity, it allows you to
    instrument code at many granularities, including instruction, basic block, trace,
    function, and image (a complete executable or library). Both Pin’s DBI engine
    and Pintools run in user space, so you can only instrument user-space processes
    with Pin.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Pin 始终按 trace 粒度进行 JIT 编译代码，但它允许你在多种粒度下对代码进行插装，包括指令、基本块、trace、函数和镜像（完整的可执行文件或库）。Pin
    的 DBI 引擎和 Pintools 都在用户空间运行，因此你只能使用 Pin 对用户空间进程进行插装。
- en: Implementing Pintools
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现 Pintools
- en: The DBI tools you implement with Pin are called *Pintools*, which are shared
    libraries that you write in C/C++ using the Pin API. The Pin API is architecture
    independent as far as possible, using architecture-specific components only when
    needed. This allows you to write Pintools that are portable between architectures
    or require only minimal changes to support another architecture.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用Pin实现的DBI工具被称为*Pintools*，它们是你用C/C++编写的共享库，利用Pin API。Pin API尽可能独立于架构，只有在需要时才使用特定架构的组件。这使得你可以编写跨架构可移植的Pintools，或者仅需进行最小的修改即可支持另一种架构。
- en: 'To create a Pintool, you write two different kinds of functions: *instrumentation
    routines* and *analysis routines*. Instrumentation routines tell Pin which instrumentation
    code to add and where; these functions run only the first time Pin encounters
    a particular piece of code that’s not yet instrumented. To instrument code, the
    instrumentation routines install callbacks to analysis routines that contain the
    actual instrumentation code and are called every time an instrumented code sequence
    runs.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个Pintool，你需要编写两种不同类型的函数：*插桩例程*和*分析例程*。插桩例程告诉Pin需要添加哪些插桩代码以及代码的位置；这些函数仅在Pin首次遇到尚未插桩的特定代码时运行。为了插桩代码，插桩例程安装回调到包含实际插桩代码的分析例程，每次执行插桩的代码序列时都会调用这些回调。
- en: Note that you shouldn’t confuse Pin’s *instrumentation routines* with the SBI
    term *instrumentation code*. Instrumentation code is new code added to an instrumented
    program and corresponds to Pin’s analysis routines, not to the instrumentation
    routines that insert the callbacks to the analysis routines. The distinction between
    instrumentation and analysis routines will become clearer in the practical examples
    that follow.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你不应该将Pin的*插桩例程*与SBI术语中的*插桩代码*混淆。插桩代码是添加到已插桩程序中的新代码，且对应于Pin的分析例程，而不是插桩例程。插桩例程会插入到分析例程的回调中。插桩与分析例程之间的区别将在后续的实际示例中变得更加清晰。
- en: Because of Pin’s popularity, many other binary analysis platforms are based
    on it. For example, you’ll see Pin again in [Chapters 10](ch10.xhtml#ch10) through
    [13](ch13.xhtml#ch13) about dynamic taint analysis and symbolic execution.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Pin的普及，许多其他二进制分析平台都基于它。例如，在关于动态污点分析和符号执行的[第10章](ch10.xhtml#ch10)到[第13章](ch13.xhtml#ch13)中，你将再次看到Pin的身影。
- en: 'In this chapter, you’ll see two practical examples implemented with Pin: a
    profiling tool and an automatic unpacker. In the course of implementing these
    tools, you’ll learn about Pin’s internals, such as the instrumentation points
    it supports. Let’s start with the profiling tool.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将看到两个使用Pin实现的实际示例：一个分析工具和一个自动解包器。在实现这些工具的过程中，你将了解Pin的内部机制，如它所支持的插桩点。我们先从分析工具开始。
- en: 9.4 Profiling with Pin
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4 使用Pin进行分析
- en: The profiling tool records statistics about a program’s execution to help optimize
    that program. Specifically, it counts the number of executed instructions and
    the number of times basic blocks, functions, and syscalls are invoked.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 分析工具记录程序执行的统计信息，帮助优化该程序。具体来说，它统计执行的指令数量，以及基本块、函数和系统调用被调用的次数。
- en: '*9.4.1 The Profiler’s Data Structures and Setup Code*'
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*9.4.1 分析器的数据结构和设置代码*'
- en: '[Listing 9-1](ch09.xhtml#ch09list1) shows the first part of the profiler’s
    code. The following discussion omits standard includes and functions that don’t
    use any Pin functionality, such as the usage function and the function that prints
    the results. You can see these in the *profiler.cpp* source file on the VM. I’ll
    refer to the profiler Pintool as “the Pintool” or “the profiler” and to the profiled
    program, which the profiler instruments, as “the application.”'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 9-1](ch09.xhtml#ch09list1)展示了分析器代码的第一部分。以下讨论省略了标准的包含文件和未使用Pin功能的函数，例如使用函数和打印结果的函数。你可以在VM中的*profiler.cpp*源文件中看到这些。我将把分析器Pintool称为“Pintool”或“分析器”，而将分析器所插桩的被分析程序称为“应用程序”。'
- en: '*Listing 9-1:* profiler.cpp'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 9-1:* profiler.cpp'
- en: '[PRE3]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Every Pintool must include *pin.H* to access the Pin API ➊.^([10](footnote.xhtml#ch09fn_10))
    This single header file provides the entire API.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Pintool必须包含*pin.H*来访问Pin API ➊。^([10](footnote.xhtml#ch09fn_10))这个单一的头文件提供了完整的API。
- en: Note that Pin observes the program starting from the first instruction, which
    means the profiler sees not only the application code but also the instructions
    executed by the dynamic loader and shared libraries. This is important to keep
    in mind for all Pintools that you write.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Pin从第一条指令开始观察程序，这意味着分析器不仅能看到应用程序代码，还能看到动态加载器和共享库执行的指令。编写任何Pintool时都需要牢记这一点。
- en: Command Line Options and Data Structures
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令行选项和数据结构
- en: Pintools can implement tool-specific command line options, which are called
    *knobs* in Pin parlance. The Pin API includes a dedicated `KNOB` class that you
    use to create command line options. In [Listing 9-1](ch09.xhtml#ch09list1), there
    are two Boolean options (`KNOB<bool>`) ➋ called `ProfileCalls` and `ProfileSyscalls`.
    The options use mode `KNOB_MODE_WRITEONCE` because they’re Boolean flags that
    are set only once when you supply the flag. You enable the `ProfileCalls` option
    by passing the flag `-c` to the Pintool, and you enable `ProfileSyscalls` by passing
    `-s`. (You’ll see how to pass these options in the profiler tests.) Both options
    have the default value 0, meaning they’re false if you don’t pass the flag. Pin
    also allows you to create other types of command line options, such as `string`
    or `int` options. To learn more about these options, you can refer to the Pin
    documentation online or take a look at the example tools.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Pintool可以实现特定工具的命令行选项，在Pin术语中称为*knobs*。Pin API包括一个专门的`KNOB`类，用于创建命令行选项。在[清单
    9-1](ch09.xhtml#ch09list1)中，有两个布尔选项（`KNOB<bool>`） ➋，分别为`ProfileCalls`和`ProfileSyscalls`。这些选项使用模式`KNOB_MODE_WRITEONCE`，因为它们是布尔标志，只会在你提供标志时设置一次。你可以通过传递`-c`标志来启用`ProfileCalls`选项，通过传递`-s`来启用`ProfileSyscalls`。(你将在分析器测试中看到如何传递这些选项。)这两个选项的默认值为0，即如果不传递标志，它们为假。Pin还允许你创建其他类型的命令行选项，如`string`或`int`选项。有关这些选项的更多信息，你可以参考Pin文档或查看示例工具。
- en: The profiler uses multiple `std::map` data structures and counters to keep track
    of the program’s runtime statistics ➌. The `cflows` and `calls` data structures
    map addresses of control flow targets (basic blocks or functions) to another map
    that in turn tracks the addresses of the control flow instructions (jumps, calls,
    and so on) that invoked each target and counts how often that control transfer
    was taken. The `syscall` map simply tracks how often each syscall number was invoked,
    and `funcnames` maps function addresses to symbolic names, if known. The counters
    (`insn_count`, `cflow_count`, `call_count`, and `syscall_count`) track the total
    number of executed instructions, control flow instructions, calls, and syscalls,
    respectively.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器使用多个`std::map`数据结构和计数器来跟踪程序的运行时统计数据 ➌。`cflows`和`calls`数据结构将控制流目标的地址（基本块或函数）映射到另一个映射，该映射又跟踪调用每个目标的控制流指令的地址（跳转、调用等），并计算控制流被触发的频率。`syscall`映射仅跟踪每个系统调用号被调用的频率，`funcnames`将函数地址映射到符号名称（如果已知）。计数器（`insn_count`、`cflow_count`、`call_count`和`syscall_count`）分别跟踪已执行指令的总数、控制流指令、调用次数和系统调用次数。
- en: Initializing Pin
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化Pin
- en: Like normal C/C++ programs, Pintools start in the `main` function. The first
    Pin function that the profiler calls is `PIN_InitSymbols` ➍, which causes Pin
    to read the application’s symbol tables. To use symbols in your Pintool, Pin requires
    that you call `PIN_InitSymbols` before any other Pin API function. The profiler
    uses symbols when they’re available to show human-readable statistics on how often
    each function was called.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与普通的C/C++程序一样，Pintool从`main`函数开始。分析器调用的第一个Pin函数是`PIN_InitSymbols` ➍，该函数使Pin读取应用程序的符号表。为了在Pintool中使用符号，Pin要求你在调用任何其他Pin
    API函数之前先调用`PIN_InitSymbols`。分析器在符号可用时使用它们，以显示每个函数被调用的次数的可读统计信息。
- en: The next function the profiler calls is `PIN_Init` ➎, which initializes Pin
    and must be called before any other Pin function except `PIN_InitSymbols`. It
    returns `true` if anything went wrong during initialization, in which case the
    profiler prints usage instructions and exits. The `PIN_Init` function processes
    Pin’s command line options as well as your Pintool’s options as specified by the
    `KNOB`s you created. Usually, your Pintool won’t need to implement any of its
    own command line processing code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器调用的下一个函数是`PIN_Init` ➎，该函数初始化Pin，必须在调用任何其他Pin函数之前调用，除了`PIN_InitSymbols`。如果初始化过程中出现任何问题，它将返回`true`，此时分析器会打印使用说明并退出。`PIN_Init`函数处理Pin的命令行选项以及通过你创建的`KNOB`指定的Pintool选项。通常，Pintool无需实现自己的命令行处理代码。
- en: Registering Instrumentation Functions
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册插桩函数
- en: Now that Pin is initialized, it’s time to initialize the Pintool. The most important
    part of that is registering the instrumentation routines that are responsible
    for instrumenting the application.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 既然Pin已经初始化，现在是时候初始化Pintool了。最重要的部分是注册负责对应用程序进行插桩的插桩例程。
- en: The profiler registers three instrumentation routines ➏. The first of these,
    called `parse_funcsyms`, instruments at image granularity, while `instrument_trace`
    and `instrument_insn` instrument at trace and instruction granularity, respectively.
    To register these routines with Pin, you call `IMG _AddInstrumentFunction`, `TRACE_AddInstrument
    Function`, and `INS_AddInstrument Function`, respectively. Note that you can add
    as many instrumentation routines of each type as you want.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器注册了三种插桩例程 ➏。其中第一个叫做`parse_funcsyms`，它在图像粒度下进行插桩，而`instrument_trace`和`instrument_insn`则分别在跟踪粒度和指令粒度下进行插桩。要将这些例程注册到Pin中，分别调用`IMG_AddInstrumentFunction`、`TRACE_AddInstrumentFunction`和`INS_AddInstrumentFunction`。请注意，你可以根据需要添加任意数量的每种类型的插桩例程。
- en: As you’ll see shortly, the three instrumentation routines take an `IMG`, a `TRACE`,
    and an `INS` object as their first parameter, respectively, depending on their
    type. Additionally, they all take a `void*` as their second parameter, which allows
    you to pass a Pintool-specific data structure that you specify when you register
    the instrumentation routines using `*_AddInstrument Function`. The profiler doesn’t
    use this facility (it passes `NULL` for each `void*`).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将很快看到的，三种插桩例程分别以`IMG`、`TRACE`和`INS`对象作为它们的第一个参数，具体取决于它们的类型。此外，它们都将一个`void*`作为第二个参数，这允许你传递一个由你在使用`*_AddInstrumentFunction`注册插桩例程时指定的Pintool特定数据结构。分析器没有使用此功能（它为每个`void*`传递`NULL`）。
- en: Registering a Syscall Entry Function
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册系统调用入口函数
- en: Pin also allows you to register functions that are called before or after every
    syscall, in the same way as you register instrumentation callbacks. Note that
    you can’t specify callbacks for only some syscalls; you can only differentiate
    between syscalls inside the callback function.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Pin还允许你注册在每个系统调用之前或之后调用的函数，方法与注册插桩回调相同。请注意，你不能仅为某些系统调用指定回调；你只能在回调函数内区分不同的系统调用。
- en: The profiler uses `PIN_AddSyscallEntryFunction` to register a function named
    `log_syscall` that’s called whenever a syscall is entered ➐. To register a callback
    that triggers when a syscall exits, use `PIN_AddSyscallExitFunction` instead.
    The profiler registers the callback only if `ProfileSyscalls.Value()`, the value
    of the `ProfileSyscalls` knob, is `true`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器使用`PIN_AddSyscallEntryFunction`注册一个名为`log_syscall`的函数，该函数在每次进入系统调用时被调用 ➐。要注册一个在系统调用退出时触发的回调，使用`PIN_AddSyscallExitFunction`。只有当`ProfileSyscalls.Value()`，即`ProfileSyscalls`开关的值为`true`时，分析器才会注册回调。
- en: Registering a Fini Function
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册Fini函数
- en: The final callback that the profiler registers is a *fini function*, which is
    called when the application exits or when you detach Pin from it ➑. Fini functions
    receive an exit status code (an `INT32`) and a user-defined `void*`. To register
    a fini function, you use `PIN_AddFiniFunction`. Note that fini functions may not
    be called reliably for some programs, depending on how the program exits.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器注册的最终回调是一个*fini函数*，当应用程序退出或从其分离Pin时 ➑ 会调用该函数。fini函数接收一个退出状态码（`INT32`）和一个用户定义的`void*`。要注册fini函数，使用`PIN_AddFiniFunction`。请注意，某些程序的fini函数可能无法可靠地调用，具体取决于程序的退出方式。
- en: The fini function that the profiler registers is responsible for printing the
    profiling results. I won’t discuss it here because it doesn’t contain any Pin-specific
    code, but you can see the output of `print_results` when testing the profiler.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器注册的fini函数负责打印分析结果。由于它不包含任何Pin特定的代码，因此我不会在此讨论它，但你可以在测试分析器时看到`print_results`的输出。
- en: Starting the Application
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动应用程序
- en: The last step of every Pintool’s initialization is to call `PIN_StartProgram`,
    which starts the application running ➒. After that, it’s no longer possible to
    register any new callbacks; the Pintool gets back control only when an instrumentation
    or analysis routine is called. The `PIN_StartProgram` function never returns,
    meaning that the `return 0` at the end of `main` is never reached.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Pintool初始化的最后一步是调用`PIN_StartProgram`，它启动应用程序运行 ➒。之后，无法再注册任何新的回调；Pintool仅在调用插桩或分析例程时才会重新获得控制权。`PIN_StartProgram`函数永远不会返回，这意味着`main`末尾的`return
    0`永远不会被执行。
- en: '*9.4.2 Parsing Function Symbols*'
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*9.4.2 解析函数符号*'
- en: Now that you know how to initialize a Pintool and register instrumentation routines
    and other callbacks, let’s take a detailed look at the callback functions just
    registered. Let’s start with `parse_funcsyms`, shown in [Listing 9-2](ch09.xhtml#ch09list2).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何初始化一个 Pintool 并注册仪器化例程和其他回调函数，我们来详细看看刚刚注册的回调函数。首先从 `parse_funcsyms`
    开始，如[列表 9-2](ch09.xhtml#ch09list2)所示。
- en: '*Listing 9-2:* profiler.cpp *(continued)*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-2:* profiler.cpp *(续)*'
- en: '[PRE4]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Recall that `parse_funcsyms` is an image-granularity instrumentation routine,
    which you can tell because it receives an `IMG` object as its first argument.
    Image instrumentation routines are called when a new image (an executable or shared
    library) loads, allowing you to instrument the image as a whole. Among other things,
    this lets you loop over all the functions in the image and add analysis routines
    that run before or after each function. Note that function instrumentation is
    reliable only if the binary contains symbolic information, and after-function
    instrumentation doesn’t work with some optimizations, such as tail calls.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`parse_funcsyms` 是一种图像粒度的仪器化例程，你可以通过它接收一个 `IMG` 对象作为第一个参数来识别它。图像仪器化例程在加载新图像（可执行文件或共享库）时调用，允许你对整个图像进行仪器化。除此之外，这还允许你遍历图像中的所有函数，并在每个函数之前或之后添加分析例程。需要注意的是，只有当二进制文件包含符号信息时，函数仪器化才可靠，并且在某些优化（如尾调用）下，后函数仪器化无法正常工作。
- en: However, `parse_funcsyms` doesn’t add any instrumentation at all. Instead, it
    takes advantage of another feature of image instrumentation, which lets you inspect
    the symbolic names of all functions in the image. The profiler saves these names
    so that it can read them back later to show human-readable function names in the
    output.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`parse_funcsyms` 并没有添加任何仪器化代码。相反，它利用了图像仪器化的另一个特性，可以查看图像中所有函数的符号名称。性能分析器会保存这些名称，以便稍后读取并在输出中显示人类可读的函数名称。
- en: Before using its `IMG` argument, `parse_funcsyms` calls `IMG_Valid` to ensure
    that it’s a valid image ➊. If it is, `parse_funcsyms` loops over all the `SEC`
    objects in the image, which represent all the sections ➋. `IMG_SecHead` returns
    the first section in the image, and `SEC_Next` returns the next section; the loop
    continues until `SEC_Valid` returns `false`, indicating that there’s no next remaining
    section.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `IMG` 参数之前，`parse_funcsyms` 会调用 `IMG_Valid` 来确保它是一个有效的图像 ➊。如果是有效的，`parse_funcsyms`
    会遍历图像中的所有 `SEC` 对象，代表图像中的所有节 ➋。`IMG_SecHead` 返回图像中的第一个节，`SEC_Next` 返回下一个节；该循环会一直继续，直到
    `SEC_Valid` 返回 `false`，表示没有剩余的下一个节。
- en: For each section, `parse_funcsyms` loops over all the functions (represented
    by `RTN` objects, as in “routine”) ➌ and maps each function’s address (as returned
    by `RTN_Address`) in the `funcnames` map to the symbolic name of the function
    (as returned by `RTN_Name`) ➍. If the function’s name is not known (for example,
    when the binary has no symbol table), `RTN_Name` returns an empty string.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个节，`parse_funcsyms` 会遍历所有函数（由 `RTN` 对象表示，如“routine”），并将每个函数的地址（由 `RTN_Address`
    返回）映射到 `funcnames` 映射中的符号名称（由 `RTN_Name` 返回）。如果函数名称未知（例如，二进制文件没有符号表），`RTN_Name`
    会返回一个空字符串。
- en: After `parse_funcsyms` completes, `funcnames` contains a mapping of all known
    function addresses to symbolic names.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `parse_funcsyms` 完成后，`funcnames` 包含所有已知函数地址到符号名称的映射。
- en: '*9.4.3 Instrumenting Basic Blocks*'
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*9.4.3 基本块的仪器化*'
- en: Recall that one of the things the profiler records is the number of instructions
    the program executes. To that end, the profiler instruments every basic block
    with a call to an analysis function that increases the instruction counter (`insn_count`)
    by the number of instructions in the basic block.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，性能分析器记录的其中一项内容是程序执行的指令数。为此，性能分析器会对每个基本块进行仪器化，调用一个分析函数，该函数会根据基本块中的指令数量增加指令计数器（`insn_count`）。
- en: A Few Notes on Basic Blocks in Pin
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于 Pin 中基本块的一些说明
- en: Because Pin discovers basic blocks dynamically, the basic blocks that Pin finds
    may differ from what you would find based on static analysis. For example, Pin
    may initially find a large basic block, only to later discover a jump into the
    middle of that basic block, forcing Pin to renew its decision, break the basic
    block in two, and reinstrument both basic blocks. Although this doesn’t matter
    for the profiler since it doesn’t care about the shape of basic blocks, only the
    number of executed instructions, it’s important to keep in mind to prevent confusion
    with some Pintools.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Pin 是动态发现基本块的，所以 Pin 发现的基本块可能与静态分析时发现的不同。例如，Pin 可能最初发现了一个大的基本块，后来又发现一个跳转指令进入该基本块的中间，迫使
    Pin 更新决策，将基本块拆分成两个并重新插桩这两个基本块。虽然这对分析器没有影响，因为分析器只关心执行的指令数量，而不关心基本块的形状，但需要牢记这一点，以防某些
    Pintool 混淆。
- en: Also note that as an alternative implementation, you could increment `insn_count`
    on every instruction. However, that would be significantly slower than the basic
    block-level implementation because it requires one callback per instruction to
    the analysis function that increments `insn_count`. In contrast, the basic block-level
    implementation requires only one callback per basic block. When writing a Pintool,
    it’s important to optimize the analysis routines as much as you can because they’re
    called repeatedly throughout the execution, unlike instrumentation routines, which
    are called only the first time a piece of code is encountered.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 另外请注意，作为一种替代实现，你可以在每条指令上增加 `insn_count`。然而，这比基本块级别的实现要慢得多，因为它需要每条指令调用一次回调函数来增加
    `insn_count`。相比之下，基本块级别的实现只需要每个基本块调用一次回调。当编写 Pintool 时，优化分析例程是非常重要的，因为它们会在执行过程中反复被调用，而插桩例程只会在遇到某段代码的第一次时被调用。
- en: Implementing Basic Block Instrumentation
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现基本块插桩
- en: You can’t directly instrument basic blocks in the Pin API. That is, there’s
    no `BBL_AddInstrumentFunction`. To instrument basic blocks, you have to add a
    trace-level instrumentation routine and then loop over all the basic blocks in
    the trace, instrumenting each one, as shown in [Listing 9-3](ch09.xhtml#ch09list3).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能直接在 Pin API 中对基本块进行插桩。也就是说，没有 `BBL_AddInstrumentFunction`。要对基本块进行插桩，你必须添加一个跟踪级别的插桩例程，然后遍历跟踪中的所有基本块，对每一个进行插桩，如[列表
    9-3](ch09.xhtml#ch09list3)所示。
- en: '*Listing 9-3:* profiler.cpp *(continued)*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-3：* profiler.cpp *(续)*'
- en: '[PRE5]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first function in the listing, `instrument_trace`, is the trace-level instrumentation
    routine that the profiler registered earlier. Its first argument is the `TRACE`
    to instrument.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的第一个函数，`instrument_trace`，是分析器先前注册的跟踪级别插桩例程。它的第一个参数是要插桩的 `TRACE`。
- en: First, `instrument_trace` calls `IMG_FindByAddress` with the trace’s address
    to find the `IMG` that the trace is part of ➊. Next, it verifies that the image
    is valid and calls `IMG_IsMainExecutable` to check that the trace is part of the
    main application executable. If not, `instrument_trace` returns without instrumenting
    the trace. The rationale behind this is that when you’re profiling an application,
    you typically want to count code only inside the application itself, not code
    in shared libraries or the dynamic loader.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`instrument_trace` 使用跟踪的地址调用 `IMG_FindByAddress` 来找到跟踪所在的 `IMG` ➊。接下来，它验证图像是否有效，并调用
    `IMG_IsMainExecutable` 检查该跟踪是否属于主应用程序可执行文件。如果不是，`instrument_trace` 将返回，不对该跟踪进行插桩。这样做的理由是，在对应用程序进行分析时，通常只希望统计应用程序内部的代码，而不包括共享库或动态加载器中的代码。
- en: If the trace is valid and part of the main application, `instrument_trace` loops
    over all the basic blocks (`BBL` objects) in the trace ➋. For each `BBL`, it calls
    `instrument_bb` ➌, which performs the actual instrumentation of each `BBL`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果跟踪有效且属于主应用程序，`instrument_trace` 会遍历跟踪中的所有基本块（`BBL` 对象）➋。对于每个 `BBL`，它会调用 `instrument_bb`
    ➌，该函数会对每个 `BBL` 进行实际的插桩。
- en: 'To instrument a given `BBL`, `instrument_bb` calls `BBL_InsertCall` ➍, which
    is Pin’s API function to instrument a basic block with an analysis routine callback.
    The `BBL_InsertCall` function takes three mandatory arguments: the basic block
    to instrument (`bb` in this case), an *insertion point*, and a function pointer
    to the analysis routine you want to add.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要对给定的 `BBL` 进行插桩，`instrument_bb` 会调用 `BBL_InsertCall` ➍，这是 Pin 的 API 函数，用于用分析例程回调函数插桩基本块。`BBL_InsertCall`
    函数有三个必需的参数：要插桩的基本块（此例中为 `bb`），*插入点*，以及要添加的分析例程的函数指针。
- en: The insertion point determines where in the basic block Pin inserts the analysis
    callback. In this case, the insertion point is `IPOINT_ANYWHERE` ➎ because it
    doesn’t matter at what point in the basic block the instruction counter is updated.
    This allows Pin to optimize the placement of the analysis callback. [Table 9-2](ch09.xhtml#ch09tab2)
    shows all the possible insertion points. These apply not only for basic block-level
    instrumentation but also for instruction instrumentation and all other granularities.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 插入点决定了 Pin 在基本块中的哪个位置插入分析回调。在这种情况下，插入点是 `IPOINT_ANYWHERE` ➎，因为在基本块中的哪个位置更新指令计数器并不重要。这使得
    Pin 可以优化分析回调的插入位置。[表 9-2](ch09.xhtml#ch09tab2)展示了所有可能的插入点。这些不仅适用于基本块级的仪器化，还适用于指令级的仪器化及所有其他粒度。
- en: The name of the analysis routine is `count_bb_insns` ➏, and you’ll see its implementation
    in a moment. Pin provides an `AFUNPTR` type that you should cast function pointers
    to when passing them to Pin API functions.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 分析例程的名称是 `count_bb_insns` ➏，稍后你将看到它的实现。Pin 提供了一种 `AFUNPTR` 类型，当你将函数指针传递给 Pin
    API 函数时，应该将其转换为该类型。
- en: 'Table 9-2: Pin Insertion Points'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '表 9-2: Pin 插入点'
- en: '| **Insertion point** | **Analysis callback** | **Validity** |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| **插入点** | **分析回调** | **有效性** |'
- en: '| --- | --- | --- |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `IPOINT_BEFORE` | Before instrumented object | Always valid |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `IPOINT_BEFORE` | 在仪器化对象之前 | 总是有效 |'
- en: '| `IPOINT_AFTER` | On fallthrough edge (of branch or “regular” instruction)
    | If `INS_HasFallthrough` is `true` |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `IPOINT_AFTER` | 在分支或“常规”指令的落空边缘 | 如果 `INS_HasFallthrough` 为 `true` |'
- en: '| `IPOINT_ANYWHERE` | Anywhere in instrumented object | For `TRACE` or `BBL`
    only |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `IPOINT_ANYWHERE` | 在被仪器化对象的任何位置 | 仅适用于 `TRACE` 或 `BBL` |'
- en: '| `IPOINT_TAKEN_BRANCH` | On taken edge of branch | If `INS_IsBranchOrCall`
    is `true` |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `IPOINT_TAKEN_BRANCH` | 在分支的被采纳边缘 | 如果 `INS_IsBranchOrCall` 为 `true` |'
- en: After the mandatory arguments to `BBL_InsertCall`, you can add optional arguments
    to pass to the analysis routine. In this case, there’s an optional argument of
    type `IARG_UINT32` ➐ with value `BBL_NumIns`. This way, the analysis routine (`count_bb_insns`)
    receives a `UINT32` argument containing the number of instructions in the basic
    block so that it can increment the instruction counter as needed. You’ll see other
    types of arguments in the rest of this example and the next example. You can find
    a complete overview of all possible argument types in the Pin documentation. When
    you’re done passing in optional arguments, you add the special argument `IARG_END`
    ➑ to inform Pin that the argument list is complete.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `BBL_InsertCall` 的必选参数之后，你可以添加可选参数来传递给分析例程。在这种情况下，有一个类型为 `IARG_UINT32` ➐，值为
    `BBL_NumIns` 的可选参数。通过这种方式，分析例程（`count_bb_insns`）接收一个 `UINT32` 类型的参数，包含基本块中的指令数量，以便按需增加指令计数器。你将在本例的其余部分和下一个例子中看到其他类型的参数。你可以在
    Pin 文档中找到所有可能的参数类型的完整概述。当你传递完所有可选参数后，添加特殊参数 `IARG_END` ➑，告知 Pin 参数列表已经结束。
- en: The final result of the code in [Listing 9-3](ch09.xhtml#ch09list3) is that
    Pin instruments each executed basic block in the main application with a callback
    to `count _bb_insns`, which increases the profiler’s instruction counter by the
    number of instructions in the basic block.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 9-3](ch09.xhtml#ch09list3)中的代码最终结果是，Pin 为主应用程序中每个执行的基本块插入一个回调函数`count_bb_insns`，该回调通过基本块中的指令数量增加分析器的指令计数器。'
- en: '*9.4.4 Instrumenting Control Flow Instructions*'
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*9.4.4 控制流指令的仪器化*'
- en: Besides counting how many instructions the application executes, the profiler
    also counts the number of control flow transfers and, optionally, the number of
    calls. It uses the instruction-level instrumentation routine shown in [Listing
    9-4](ch09.xhtml#ch09list4) to insert the analysis callbacks that count control-flow
    transfers and calls.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 除了计算应用程序执行了多少指令，分析器还会统计控制流转移的次数，并可以选择性地统计调用次数。它使用[清单 9-4](ch09.xhtml#ch09list4)中展示的指令级仪器化例程来插入用于统计控制流转移和调用的分析回调。
- en: '*Listing 9-4:* profiler.cpp *(continued)*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-4:* profiler.cpp *(续)*'
- en: '[PRE6]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The instrumentation routine, named `instrument_insn`, receives an `INS` object
    as its first argument, representing the instruction to instrument. First, `instrument_insn`
    calls `INS_IsBranchOrCall` to check whether this is a control-flow instruction
    ➊. If not, it doesn’t add any instrumentation. After ensuring that it’s dealing
    with a control-flow instruction, `instrument_insn` checks that the instruction
    is part of the main application, just as you saw for the basic block instrumentation.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 名为 `instrument_insn` 的仪器例程接收一个 `INS` 对象作为其第一个参数，表示要处理的指令。首先，`instrument_insn`
    调用 `INS_IsBranchOrCall` 来检查这是否是一个控制流指令 ➊。如果不是，它不会添加任何仪器。确保它处理的是控制流指令后，`instrument_insn`
    会检查该指令是否属于主应用程序，就像你在基本块仪器中看到的那样。
- en: Instrumenting the Taken Edge
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理已执行分支
- en: 'To record control transfers and calls, `instrument_insn` inserts three different
    analysis callbacks. First, it uses `INS_InsertPredicatedCall` ➋ to insert a callback
    on the instruction’s taken edge ➌ (see [Figure 9-5](ch09.xhtml#ch09fig5)). The
    inserted analysis callback to `count_cflow` increments the control-flow counter
    (`cflow_count`) in case the branch is taken and records the source and target
    addresses of the control transfer. To that end, the analysis routine takes two
    arguments: the instruction pointer value at the time of the callback (`IARG_INST_PTR`)
    ➍ and the target address of the branch’s taken edge (`IARG_BRANCH_TARGET_ADDR`)
    ➎.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了记录控制转移和调用，`instrument_insn` 插入了三种不同的分析回调。首先，它使用 `INS_InsertPredicatedCall`
    ➋ 在指令的已执行分支边缘 ➌ 插入一个回调（见 [图 9-5](ch09.xhtml#ch09fig5)）。插入的分析回调 `count_cflow` 会在分支已执行时增加控制流计数器（`cflow_count`），并记录控制转移的源地址和目标地址。为此，分析例程需要两个参数：回调时的指令指针值（`IARG_INST_PTR`）
    ➍ 和分支已执行边缘的目标地址（`IARG_BRANCH_TARGET_ADDR`） ➎。
- en: Note that `IARG_INST_PTR` and `IARG_BRANCH_TARGET_ADDR` are special argument
    types for which the data type and value are implicit. In contrast, for the `IARG_UINT32`
    argument you saw in [Listing 9-3](ch09.xhtml#ch09list3), you have to separately
    specify the type (`IARG_UINT32`) and the value (`BBL_NumIns` in that example).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`IARG_INST_PTR` 和 `IARG_BRANCH_TARGET_ADDR` 是特殊的参数类型，其数据类型和值是隐式的。相比之下，对于
    [清单 9-3](ch09.xhtml#ch09list3) 中看到的 `IARG_UINT32` 参数，你必须分别指定类型（`IARG_UINT32`）和值（例如示例中的
    `BBL_NumIns`）。
- en: As you saw in [Table 9-2](ch09.xhtml#ch09tab2), the taken edge is a valid instrumentation
    point only for branch or call instructions (`INS_IsBranchOrCall` must return `true`).
    In this case, the check at the start of `instrument_insn` guarantees that it’s
    a branch or call.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在 [表 9-2](ch09.xhtml#ch09tab2) 中看到的那样，已执行的分支边缘是分支或调用指令（`INS_IsBranchOrCall`
    必须返回 `true`）的有效仪器插入点。在这种情况下，`instrument_insn` 开始时的检查确保它是一个分支或调用指令。
- en: '![image](Images/f245-01.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f245-01.jpg)'
- en: '*Figure 9-5: Insertion points on the fallthrough and taken edges of a branch*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-5：分支的“fallthrough”和“taken”边缘的插入点*'
- en: Note that `instrument_insn` uses `INS_InsertPredicatedCall` to insert the analysis
    callback instead of `INS_InsertCall`. Some x86 instructions, such as conditional
    moves (`cmov`) and string operations with `rep` prefixes, have built-in predicates
    that cause the instruction to repeat if certain conditions hold. Analysis callbacks
    inserted with `INS_InsertPredicatedCall` are called only if that condition holds
    and the instruction is actually executed. In contrast, callbacks inserted with
    `INS_InsertCall` are called even if the repeat condition doesn’t hold, leading
    to an overestimation of the instruction count.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`instrument_insn` 使用 `INS_InsertPredicatedCall` 来插入分析回调，而不是 `INS_InsertCall`。一些
    x86 指令，例如条件移动（`cmov`）和带有 `rep` 前缀的字符串操作，具有内建的谓词，如果满足某些条件，指令会重复执行。使用 `INS_InsertPredicatedCall`
    插入的分析回调只有在条件成立且指令实际执行时才会被调用。相比之下，使用 `INS_InsertCall` 插入的回调即使在不满足重复条件的情况下也会被调用，这可能导致对指令计数的高估。
- en: Instrumenting the Fallthrough Edge
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理 Fallthrough 边缘
- en: You’ve just seen how the profiler instruments the taken edge of control-flow
    instructions. However, the profiler should record control transfers regardless
    of the branch direction. In other words, it should instrument not only the taken
    edge but also the fallthrough edge of control-flow instructions that have one
    (see [Figure 9-5](ch09.xhtml#ch09fig5)). Note that some instructions, such as
    unconditional jumps, have no fallthrough edge, so you have to explicitly check
    `INS_HasFallthrough` before you try to instrument an instruction’s fallthrough
    edge ➏. Also note that by Pin’s definition, non-control-flow instructions that
    just continue to the next instruction do have a fallthrough edge.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚看到分析器如何对控制流指令的执行路径进行插桩。然而，分析器应该记录控制转移，无论分支方向如何。换句话说，它不仅应该对执行路径进行插桩，还应该对那些有后续路径的控制流指令进行插桩（参见[图
    9-5](ch09.xhtml#ch09fig5)）。请注意，某些指令（例如无条件跳转指令）没有后续路径，因此在尝试对指令的后续路径进行插桩之前，必须显式检查`INS_HasFallthrough`
    ➏。另外需要注意的是，根据 Pin 的定义，非控制流指令如果直接跳到下一条指令，它们也有后续路径。
- en: If the given instruction turns out to have a fallthrough edge, `instrument _insn`
    inserts an analysis callback to `count_cflow` on that edge just as it did for
    the taken edge. The only difference is that this new callback uses insertion point
    `IPOINT_AFTER` ➐ and passes the fallthrough address (`IARG _FALLTHROUGH_ADDR`)
    as the target address to record ➑.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给定的指令确实有后续路径，`instrument_insn`会像对执行路径那样，在该路径上插入一个分析回调到`count_cflow`。唯一的区别是，这个新的回调使用插入点`IPOINT_AFTER`
    ➐，并将后续地址（`IARG_FALLTHROUGH_ADDR`）作为目标地址进行记录 ➑。
- en: Instrumenting Calls
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 插桩调用
- en: Finally, the profiler keeps a separate counter and mapping to track called functions
    so that you can see which functions are the most rewarding options for optimizing
    your application. Recall that to track called functions, you have to enable the
    profiler’s `-c` option.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，分析器保持一个独立的计数器和映射，跟踪被调用的函数，以便你可以看到哪些函数是优化应用程序时最有价值的选择。回想一下，要跟踪被调用的函数，你必须启用分析器的`-c`选项。
- en: To instrument calls, `instrument_insn` first uses `INS_IsCall` to separate calls
    from other instructions ➒. If the instruction currently being instrumented is
    indeed a call and if the `-c` option was passed to the Pintool, the profiler inserts
    an analysis callback before the call instruction (at `IPOINT _BEFORE`) ➓ to an
    analysis routine called `count_call`, passing in the call’s source (`IARG_INST_PTR`)
    and target address (`IARG_BRANCH_TARGET_ADDR`). Note that in this case, it’s safe
    to use `INS_InsertCall` instead of `INS_InsertPredicatedCall` because there are
    no call instructions with built-in conditionals.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对调用进行插桩，`instrument_insn`首先使用`INS_IsCall`将调用指令与其他指令区分开来 ➒。如果当前正在插桩的指令确实是一个调用，并且`-c`选项已传递给
    Pintool，分析器将在调用指令之前（`IPOINT_BEFORE`）插入一个分析回调 ➓，该回调调用一个名为`count_call`的分析例程，传入调用的源地址（`IARG_INST_PTR`）和目标地址（`IARG_BRANCH_TARGET_ADDR`）。需要注意的是，在这种情况下，使用`INS_InsertCall`而不是`INS_InsertPredicatedCall`是安全的，因为没有带有内置条件的调用指令。
- en: '*9.4.5 Counting Instructions, Control Transfers, and Syscalls*'
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*9.4.5 计数指令、控制转移和系统调用*'
- en: So far, you’ve seen all the code responsible for initializing the Pintool and
    inserting the required instrumentation in the form of callbacks to analysis routines.
    The only code you haven’t seen yet consists of the actual analysis routines that
    count and record statistics as the application runs. [Listing 9-5](ch09.xhtml#ch09list5)
    shows all the analysis routines that the profiler uses.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了所有负责初始化 Pintool 并通过回调形式插入所需插桩的代码。你还没有看到的唯一代码是实际的分析例程，这些例程在应用程序运行时负责计数和记录统计信息。[清单
    9-5](ch09.xhtml#ch09list5)展示了分析器使用的所有分析例程。
- en: '*Listing 9-5:* profiler.cpp *(continued)*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-5:* profiler.cpp *(续)*'
- en: '[PRE7]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, the analysis routines are simple, implementing only the bare
    minimum code to track the required statistics. That’s important because analysis
    routines are called often as the application executes and so have a major impact
    on the performance of your Pintool.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，分析例程非常简单，只实现了追踪所需统计数据的基本代码。这一点非常重要，因为分析例程在应用程序执行过程中被频繁调用，因此它们对 Pintool
    的性能有着重要影响。
- en: The first analysis routine `count_bb_insns` ➊ is called when a basic block executes
    and simply increments `insn_count` by the number of instructions in the basic
    block. Similarly, `count_cflow` ➋ increments `cflow_count` when a control flow
    instruction executes. Additionally, it records the branch’s source and target
    address in the `cflows` map and increments the counter for this particular combination
    of source and target. In Pin, you use the `ADDRINT` integer type ➌ to store addresses.
    The analysis routine that records call information, `count_call` ➍, is analogous
    to `count_cflow`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个分析例程 `count_bb_insns` ➊ 在基本块执行时被调用，它简单地通过基本块中的指令数来增加 `insn_count`。类似地，`count_cflow`
    ➋ 在控制流指令执行时增加 `cflow_count`。此外，它会记录分支的源地址和目标地址到 `cflows` 映射中，并增加该特定源地址和目标地址组合的计数。在
    Pin 中，你使用 `ADDRINT` 整数类型 ➌ 来存储地址。记录调用信息的分析例程 `count_call` ➍ 与 `count_cflow` 类似。
- en: 'The last function in [Listing 9-5](ch09.xhtml#ch09list5), `log_syscall` ➎,
    is not a regular analysis routine but a callback for syscall entry events. In
    Pin, syscall handlers take four arguments: a `THREADID` identifying the thread
    that made the syscall; a `CONTEXT*` containing things like the syscall number,
    arguments, and return value (only for syscall exit handlers); a `SYSCALL_STANDARD`
    argument that identifies the syscall’s calling convention; and finally, the now-familiar
    `void*` that lets you pass in a user-defined data structure.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [清单 9-5](ch09.xhtml#ch09list5) 中的最后一个函数 `log_syscall` ➎，不是一个常规的分析例程，而是一个用于系统调用入口事件的回调函数。在
    Pin 中，系统调用处理程序接受四个参数：一个 `THREADID`，用于标识发起系统调用的线程；一个 `CONTEXT*`，包含诸如系统调用号、参数和返回值等信息（仅对于系统调用退出处理程序）；一个
    `SYSCALL_STANDARD` 参数，标识系统调用的调用约定；最后是现在熟悉的 `void*`，允许你传递一个用户定义的数据结构。
- en: Recall that the purpose of `log_syscall` is to record how often each syscall
    is called. To that end, it calls `PIN_GetSyscallNumber` to get the number of the
    current syscall ➏ and records a hit for that syscall in the `syscalls` map.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 请回忆一下，`log_syscall` 的目的是记录每个系统调用被调用的频率。为此，它调用 `PIN_GetSyscallNumber` 获取当前系统调用的编号
    ➏，并在 `syscalls` 映射中记录该系统调用的命中。
- en: Now that you’ve seen all of the profiler’s important code, let’s test it!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了性能分析器的重要代码，接下来让我们测试一下它！
- en: '*9.4.6 Testing the Profiler*'
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*9.4.6 测试性能分析器*'
- en: In this test, you’ll see two use cases for the profiler. First you’ll see how
    to profile an application’s entire execution from the start, and then you’ll learn
    how to attach the profiler Pintool to a running application.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，你将看到性能分析器的两个使用案例。首先，你将看到如何从一开始对应用程序的整个执行过程进行分析，然后你将学习如何将分析器 Pintool 附加到一个正在运行的应用程序上。
- en: Profiling an Application from the Start
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从一开始就对应用程序进行性能分析
- en: '[Listing 9-6](ch09.xhtml#ch09list6) shows how to profile an application from
    the start.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 9-6](ch09.xhtml#ch09list6)展示了如何从一开始就对应用程序进行性能分析。'
- en: '*Listing 9-6: Profiling* /bin/true *with the profiler Pintool*'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-6: 使用性能分析器 Pintool 对* /bin/true *进行性能分析*'
- en: '[PRE8]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To use Pin, you first navigate to the main Pin directory ➊, where you’ll find
    an executable called `pin` that starts the Pin engine. Next, you start your application
    running under the control of `pin` with the Pintool of your choice ➋.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Pin 时，你首先导航到主 Pin 目录 ➊，在那里你会找到一个名为 `pin` 的可执行文件，它启动 Pin 引擎。接下来，你使用你选择的 Pintool
    启动应用程序，并在 `pin` 的控制下运行 ➋。
- en: As you can see, `pin` uses a special format for the command line parameters.
    The `-t` option indicates the path to the Pintool you want to use and is followed
    by any options you want to pass *to the Pintool*. In this case, the used options
    are `-c` and `-s` to enable profiling for both calls and syscalls. Next, the `--`
    indicates the end of the Pintool’s options, which is followed by the name and
    options of the application you want to run with Pin (*/bin/true* in this case,
    without any command line options).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`pin` 使用了一种特殊格式的命令行参数。`-t` 选项表示你想要使用的 Pintool 的路径，后面跟着你想传递给 *Pintool* 的任何选项。在这种情况下，使用的选项是
    `-c` 和 `-s`，用于启用对调用和系统调用的性能分析。接下来，`--` 表示 Pintool 选项的结束，后面跟着你想要用 Pin 运行的应用程序的名称和选项（此案例为
    */bin/true*，没有任何命令行选项）。
- en: When the application terminates, the Pintool invokes its fini function to print
    the recorded statistics, and then Pin terminates itself after the fini function
    completes. The profiler prints statistics on the number of executed instructions
    ➌, the taken control transfers ➍, the function calls ➎, and the syscalls ➏. Because
    */bin/true* is an extremely simple program,^([11](footnote.xhtml#ch09fn_11)) it
    executes only 95 instructions during its lifetime.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序终止时，Pintool会调用其fini函数打印记录的统计信息，然后在fini函数完成后，Pin会终止自身。分析器打印关于执行指令数量 ➌、已执行的控制转移
    ➍、函数调用 ➎和系统调用 ➏的统计信息。因为*/bin/true*是一个极其简单的程序，^([11](footnote.xhtml#ch09fn_11))它在生命周期内只执行了95条指令。
- en: 'The profiler reports control transfers in the format `target <- source: count`,
    where the count indicates how often this specific branch edge was taken and for
    what percentage of all control transfers the branch edge accounts. In this case,
    all control transfers are taken exactly once: there were apparently no loops or
    other repetitions of the same code. Aside from `_init` and `__libc_start_main`,
    */bin/true* makes only two function calls to internal functions with no known
    symbolic name. The most used syscall is syscall number 9, which is `sys_mmap`.
    This is because of the dynamic loader, which sets up the address space for */bin/true*.
    (In contrast to instructions and control transfers, the profiler does record syscalls
    that originate in the loader or shared libraries.)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '分析器以`target <- source: count`的格式报告控制转移，其中count表示该特定分支边缘被执行的次数，以及该分支边缘占所有控制转移的百分比。在这种情况下，所有的控制转移都恰好执行了一次：显然没有出现循环或相同代码的重复执行。除了`_init`和`__libc_start_main`，*/bin/true*
    只调用了两个没有已知符号名称的内部函数。使用最多的系统调用是系统调用号9，即`sys_mmap`。这是因为动态加载器设置了*/bin/true*的地址空间。（与指令和控制转移不同，分析器确实记录了来自加载器或共享库的系统调用。）'
- en: Now that you know how to run an application with a Pintool from the start, let’s
    look at how to attach Pin to an already running process.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何从一开始就运行带有Pintool的应用程序，让我们来看一下如何将Pin附加到一个已经在运行的进程。
- en: Attaching the Profiler to a Running Application
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将分析器附加到正在运行的应用程序
- en: To attach Pin to a running process, you use the `pin` program just like when
    you instrument an application from the start. However, the `pin` options are a
    little different, as you can see in [Listing 9-7](ch09.xhtml#ch09list7).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Pin附加到一个正在运行的进程，你可以像从一开始就为应用程序加装探针一样使用`pin`程序。然而，`pin`的选项略有不同，正如在[清单 9-7](ch09.xhtml#ch09list7)中所看到的。
- en: '*Listing 9-7: Attaching the profiler to a running* netcat *process*'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-7：将分析器附加到正在运行的* netcat *进程*'
- en: '[PRE9]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: On some Linux platforms, including the Ubuntu distribution on the virtual machine,
    there’s a security mechanism in place that prevents Pin from attaching to running
    processes. To allow Pin to attach normally, you have to temporarily disable that
    security mechanism, as shown in [Listing 9-7](ch09.xhtml#ch09list7) ➊ (it will
    automatically be re-enabled on the next reboot). Additionally, you’ll need a suitable
    test process to attach Pin to. [Listing 9-7](ch09.xhtml#ch09list7) starts a background
    `netcat` process for this purpose that listens on UDP port 9999 on the local-host
    ➋. To attach to a process, you need to know its PID, which you can write down
    when you start the process ➌ or find with `ps`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些Linux平台上，包括虚拟机中的Ubuntu发行版，存在一种安全机制，防止Pin附加到运行中的进程。为了允许Pin正常附加，你需要暂时禁用该安全机制，如[清单
    9-7](ch09.xhtml#ch09list7) ➊所示（下次重启时它会自动重新启用）。此外，你还需要一个合适的测试进程来附加Pin。[清单 9-7](ch09.xhtml#ch09list7)启动了一个后台的`netcat`进程，该进程在本地主机的UDP端口9999上监听
    ➋。要附加到一个进程，你需要知道其PID，可以在启动进程时记录下来 ➌，或者使用`ps`命令查找。
- en: With these preliminaries out of the way, you can now navigate to the Pin folder
    ➍ and start `pin` ➎. The `-pid` option tells Pin to attach to the running process
    with the given PID (3100 for the example `netcat` process), and the `-t` option
    tells Pin the path to your Pintool as usual.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些准备工作后，你现在可以导航到Pin文件夹 ➍ 并启动`pin` ➎。`-pid`选项告诉Pin附加到具有给定PID（示例`netcat`进程的PID是3100）的运行中进程，`-t`选项告诉Pin像往常一样指定你的Pintool路径。
- en: To coax the listening `netcat` process into executing some instructions rather
    than blocking waiting for network input, [Listing 9-7](ch09.xhtml#ch09list7) uses
    another `netcat` instance to send it the message “Testing the profiler” ➏. Then,
    it brings the listening `netcat` process to the foreground ➐ and terminates it.
    When the application terminates, the profiler calls its fini function and prints
    statistics for you to inspect, including a list of control transfers ➑, called
    functions ➒ and syscalls ➓. You can see network-related function calls like `connect`,
    as well as a `sys_recvfrom` system call (number 45) that `netcat` used to receive
    the test message.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了促使正在监听的 `netcat` 进程执行一些指令，而不是阻塞等待网络输入，[清单 9-7](ch09.xhtml#ch09list7)使用另一个
    `netcat` 实例向其发送消息“测试分析器” ➏。然后，它将监听中的 `netcat` 进程带到前台 ➐ 并终止它。当应用程序终止时，分析器会调用其 fini
    函数，并打印出可供检查的统计信息，包括控制转移列表 ➑，被调用的函数 ➒ 和系统调用 ➓。你可以看到类似 `connect` 的网络相关函数调用，以及 `netcat`
    用于接收测试消息的 `sys_recvfrom` 系统调用（编号 45）。
- en: Note that once you attach Pin to a running process, it will stay attached until
    that process terminates or you call `PIN_Detach` from somewhere inside your Pintool.
    This means if you want to instrument a system process that never terminates, you
    have to incorporate some suitable termination criterion into your Pintool.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一旦你将 Pin 附加到一个正在运行的进程，它将一直保持附加状态，直到该进程终止或者你在 Pintool 内部调用 `PIN_Detach`。这意味着，如果你想对一个永不终止的系统进程进行插桩，你必须在
    Pintool 中加入合适的终止条件。
- en: 'Now let’s look at a slightly more complex Pintool: an automatic unpacker that
    can extract obfuscated binaries!'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一个稍微复杂一些的 Pintool：一个能够解压混淆二进制文件的自动解包器！
- en: 9.5 Automatic Binary Unpacking with Pin
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5 使用 Pin 进行自动二进制解包
- en: In this example, you’ll see how to use Pin to build a Pintool that can automatically
    unpack packed binaries. But first, let’s briefly discuss what packed binaries
    are so that you can better understand the example that follows.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你将看到如何使用 Pin 构建一个可以自动解包打包二进制文件的 Pintool。但首先，让我们简要讨论一下打包二进制文件是什么，以便你能更好地理解接下来的示例。
- en: '*9.5.1 Introduction to Executable Packers*'
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*9.5.1 可执行打包器简介*'
- en: '*Executable packers*, or *packers* for short, are programs that take a binary
    as input and “pack” that binary’s code and data sections together into a compressed
    or encrypted data region, producing a new *packed executable*. Originally, packers
    were used mainly for compressing binaries, but nowadays they’re often used by
    malware to produce binaries that are more difficult for reverse engineers to analyze
    statically. [Figure 9-6](ch09.xhtml#ch09fig6) illustrates the packing process
    and the loading process of a packed binary.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*可执行打包器*，简称 *打包器*，是将二进制文件作为输入， “打包”该二进制文件的代码和数据段到一个压缩或加密的数据区域，生成一个新的 *打包可执行文件*
    的程序。最初，打包器主要用于压缩二进制文件，但如今它们常被恶意软件使用，以生成更难以静态分析的二进制文件。[图 9-6](ch09.xhtml#ch09fig6)展示了打包过程以及打包二进制文件的加载过程。'
- en: '![image](Images/f251-01.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f251-01.jpg)'
- en: '*Figure 9-6: Creating and running a packed binary*'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-6：创建和运行打包二进制文件*'
- en: The left part of [Figure 9-6](ch09.xhtml#ch09fig6) shows a normal binary containing
    an executable header and a code and data section ➊. The entry point field in the
    executable header points into the code section.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-6](ch09.xhtml#ch09fig6)的左侧展示了一个包含可执行头和代码与数据段的正常二进制文件 ➊。可执行头中的入口点字段指向代码段。'
- en: Creating and Executing Packed Binaries
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建和执行打包的二进制文件
- en: When you process the binary with a packer, it produces a new binary in which
    all the original code and data are compressed or encrypted into a packed region
    ➋ (see [Figure 9-6](ch09.xhtml#ch09fig6)). Additionally, the packer inserts a
    new code section that contains bootstrap code and redirects the binary’s entry
    point to the bootstrap code. When you try to statically disassemble and analyze
    the packed program, you see only the packed region and the bootstrap code, which
    don’t give you any idea of what the binary actually does at runtime.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用打包器处理二进制文件时，它会生成一个新的二进制文件，其中所有原始的代码和数据都被压缩或加密到打包区域 ➋（见 [图 9-6](ch09.xhtml#ch09fig6)）。此外，打包器还插入了一个新的代码段，包含启动代码，并将二进制文件的入口点重定向到启动代码。当你尝试静态反汇编并分析打包程序时，你只能看到打包区域和启动代码，这并不能让你了解该二进制文件在运行时的实际行为。
- en: When you load and execute the packed binary, the bootstrap code extracts the
    original code and data into memory and then transfers control to the *original
    entry point (OEP)* of the binary, resuming execution normally ➌.^([12](footnote.xhtml#ch09fn_12))
    The point of the automatic unpacking Pintool you’ll see shortly is to detect the
    moment that the bootstrap code transfers control to the OEP and then to dump the
    unpacked code and data to disk so that you can statically disassemble and reverse
    engineer it as you would a normal binary.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当你加载并执行打包的二进制文件时，启动代码将原始代码和数据提取到内存中，然后将控制权转移到二进制的*原始入口点（OEP）* ➌。^([12](footnote.xhtml#ch09fn_12))
    你将看到的自动解包Pintool的目的是检测启动代码将控制权转移到OEP的时刻，然后将解包的代码和数据转储到磁盘，以便你像处理普通二进制文件一样对其进行静态反汇编和逆向工程。
- en: Unpacking Packed Binaries
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解包打包的二进制文件
- en: There are many different packers that pack binaries in their own way. For well-known
    packers, such as UPX^([13](footnote.xhtml#ch09fn_13)) and AsPack,^([14](footnote.xhtml#ch09fn_14))
    there are specialized unpacking tools that can automatically extract an approximation
    of the original binary from a packed binary. However, that’s not always possible
    for packers used in malware, which malware authors often customize or design from
    scratch. To unpack such malware, you have to build your own unpacking tool, unpack
    the malware manually (for instance, by using a debugger to locate the jump to
    OEP and then dumping the code to disk), or use a generic unpacker, as you’ll see
    next.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的打包器以自己的方式打包二进制文件。对于一些知名的打包器，如UPX^([13](footnote.xhtml#ch09fn_13))和AsPack,^([14](footnote.xhtml#ch09fn_14))，有专门的解包工具可以自动从打包的二进制文件中提取出原始二进制文件的近似版本。然而，对于恶意软件中使用的打包器，这通常不可能，因为恶意软件作者经常自定义或从零设计打包器。要解包这种恶意软件，你必须自己构建解包工具，手动解包恶意软件（例如，使用调试器定位跳转到OEP并将代码转储到磁盘），或者使用通用解包器，正如你接下来将看到的那样。
- en: Generic unpackers rely on common (but not foolproof) runtime patterns indicative
    of packers to try to detect the jump to the original entry point and then dump
    the memory region that contains the OEP (and ideally the rest of the code) to
    disk. The automatic unpacker you’ll see in a moment is a simple generic unpacker.
    It assumes that when you run a packed binary, the bootstrap code unpacks the original
    code completely, writes it into memory, and later transfers control to the OEP
    in the previously written code. When the unpacker detects that control transfer,
    it dumps the targeted memory region to disk.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 通用解包器依赖于一些常见的（但并非万无一失的）运行时模式，这些模式通常是打包器的指示器，用来尝试检测跳转到原始入口点并将包含OEP的内存区域（理想情况下还包括其余代码）转储到磁盘。你将看到的自动解包器是一个简单的通用解包器。它假设当你运行一个打包的二进制文件时，启动代码会完全解包原始代码，将其写入内存，并随后将控制权转移到先前写入代码中的OEP。当解包器检测到控制转移时，它会将目标内存区域转储到磁盘。
- en: Now that you know how packers work and have a high-level intuition of the automatic
    unpacker’s behavior, let’s implement the automatic unpacker with Pin. After that,
    you’ll learn how to use it to unpack a UPX-packed binary.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了打包器的工作原理，并且对自动解包器的行为有了高层次的直觉，我们可以开始用Pin实现自动解包器。之后，你将学会如何使用它来解包一个UPX打包的二进制文件。
- en: '*9.5.2 The Unpacker’s Data Structures and Setup Code*'
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*9.5.2 解包器的数据结构和设置代码*'
- en: Let’s begin by taking a look at the unpacker’s setup code and the data structures
    it revolves around. [Listing 9-8](ch09.xhtml#ch09list8) shows the first part of
    the unpacker’s code, omitting standard C++ includes.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看解包器的设置代码和它所涉及的数据结构。[Listing 9-8](ch09.xhtml#ch09list8)展示了解包器代码的第一部分，省略了标准C++的包含部分。
- en: '*Listing 9-8:* unpacker.cpp'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-8:* unpacker.cpp'
- en: '[PRE10]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The unpacker tracks memory activity by logging written or executed memory bytes
    in a `struct` type called `mem_access_t` ➊, which records the type of memory access
    (write or execute) and the value of written bytes. Later in the unpacking process,
    when dumping memory to disk, the unpacker needs to cluster adjacent memory bytes.
    It uses a second `struct` type called `mem_cluster_t` ➋ to cluster those bytes,
    recording the base address, size, and access permissions of the memory cluster.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 解包器通过记录写入或执行的内存字节在`struct`类型`mem_access_t` ➊中跟踪内存活动，该结构记录内存访问类型（写入或执行）以及写入字节的值。在解包过程的后期，当将内存转储到磁盘时，解包器需要对相邻的内存字节进行聚类。它使用第二个`struct`类型`mem_cluster_t`
    ➋来聚类这些字节，记录内存集群的基地址、大小和访问权限。
- en: There are four global variables ➌. First, there’s a log file where the unpacker
    logs details on the unpacking progress and the written memory regions. Then there’s
    a global `std::map` called `shadow_mem`, which is a “shadow memory” that maps
    memory addresses to `mem_access_t` objects that detail the accesses and writes
    to each address. The `std::vector` called `clusters` is where the unpacker stores
    all the unpacked memory clusters it’s found, and `saved_addr` is a temporary variable
    that’s needed for storing state between two analysis routines.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个全局变量 ➌。首先是一个日志文件，解包器将在其中记录解包进度和已写入的内存区域的详细信息。然后是一个名为`shadow_mem`的全局`std::map`，它是一个“影像内存”，将内存地址映射到`mem_access_t`对象，这些对象详细描述了对每个地址的访问和写入。名为`clusters`的`std::vector`是解包器存储所有找到的解包内存集群的地方，`saved_addr`是一个临时变量，用于在两个分析例程之间存储状态。
- en: Note that `clusters` can contain multiple unpacked memory regions because some
    binaries may have multiple layers of packing. In other words, you can pack an
    already packed binary again with another packer. When the unpacker detects a control
    transfer to a previously written memory region, it has no way of knowing whether
    that’s the jump to the OEP or simply a jump to the bootstrap code of the next
    packer. Therefore, the unpacker dumps all of the candidate regions it finds to
    disk, leaving you to figure out which dumped file is the final unpacked binary.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`clusters`可能包含多个解包的内存区域，因为某些二进制文件可能经过了多层打包。换句话说，你可以使用另一个打包工具再次打包已经打包过的二进制文件。当解包器检测到跳转到先前写入的内存区域时，它无法确定这是否是跳转到OEP（原始入口点），还是仅仅跳转到下一个打包工具的引导代码。因此，解包器会将所有发现的候选区域转储到磁盘上，留给你自己去弄清楚哪个转储文件是最终解包后的二进制文件。
- en: 'The unpacker has only one command line option ➍: a `string` knob where you
    can specify the name of the log file. By default, the log file is named *unpacker.log*
    .'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 解包器只有一个命令行选项 ➍：一个`string`类型的选项，用于指定日志文件的名称。默认情况下，日志文件名为*unpacker.log*。
- en: As you’ll see shortly, the unpacker registers one fini function called `fini`
    ➎, which calls `print_clusters` to print a summary of all the memory clusters
    the unpacker found to the log file. I won’t show the listing of that function
    here because it doesn’t use any Pin functionality, but you’ll see its output when
    we test the unpacker.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你即将看到的，解包器注册了一个名为`fini` ➎的fini函数，它调用`print_clusters`函数，将解包器找到的所有内存集群的摘要打印到日志文件中。我在这里不会展示该函数的代码，因为它不使用任何Pin功能，但你将在我们测试解包器时看到它的输出。
- en: The unpacker’s `main` function is similar to the profiler’s you saw previously.
    It initializes Pin ➏, skipping symbol initialization since the unpacker doesn’t
    use symbols. Next, it opens the log file ➐, registers an instruction-level instrumentation
    routine called `instrument_mem_cflow` ➑ and the fini function ➒, and finally starts
    the packed application running ➓.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 解包器的`main`函数与之前看到的分析器类似。它初始化了Pin ➏，跳过符号初始化，因为解包器不使用符号。接下来，它打开日志文件 ➐，注册一个名为`instrument_mem_cflow`
    ➑的指令级监控例程和`fini`函数 ➒，最后启动打包应用程序 ➓。
- en: Now, let’s look at the instrumentation that `instrument_mem_cflow` adds to the
    packed program to track its memory access and control flow activity.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下`instrument_mem_cflow`如何向打包程序中添加监控工具，以跟踪其内存访问和控制流活动。
- en: '*9.5.3 Instrumenting Memory Writes*'
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*9.5.3 内存写入的监控*'
- en: '[Listing 9-9](ch09.xhtml#ch09list9) shows how `instrument_mem_cflow` instruments
    memory writes and control-flow instructions.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9-9](ch09.xhtml#ch09list9)展示了`instrument_mem_cflow`如何对内存写入和控制流指令进行监控。'
- en: '*Listing 9-9:* unpacker.cpp *(continued)*'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-9:* unpacker.cpp *(续)*'
- en: '[PRE11]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first three analysis callbacks that `instrument_mem_cflow` inserts (at ➊
    through ➑) are for tracking memory writes. It adds these callbacks only for instructions
    for which `INS_IsMemoryWrite` and `INS_hasKnownMemorySize` are both true ➊. The
    first of these, `INS_IsMemoryWrite`, tells you whether an instruction writes to
    memory, while `INS_hasKnownMemorySize` tells you whether the size (in bytes) of
    the write is known. That’s important because the unpacker records written bytes
    in `shadow_mem`, and it can copy the right number of bytes only if the write size
    is known. Because memory writes with an unknown size occur only for special-purpose
    instructions, such as MMX and SSE instructions, the unpacker simply ignores them.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`instrument_mem_cflow` 插入的前三个分析回调（在 ➊ 到 ➑ 之间）用于跟踪内存写操作。它仅为那些 `INS_IsMemoryWrite`
    和 `INS_hasKnownMemorySize` 都为真的指令添加这些回调 ➊。第一个回调，`INS_IsMemoryWrite`，告诉你某个指令是否写入内存，而
    `INS_hasKnownMemorySize` 告诉你写入的大小（以字节为单位）是否已知。这一点非常重要，因为解包器会将写入的字节记录在 `shadow_mem`
    中，只有在已知写入大小时，它才能正确复制相应的字节。由于大小未知的内存写入只会出现在某些特殊用途的指令中，比如 MMX 和 SSE 指令，解包器会直接忽略这些指令。'
- en: For every memory write, the unpacker needs to know the written address and the
    write size so that it can record all the written bytes. Unfortunately, in Pin
    the write address is known only *before* the memory write happens (at `IPOINT_BEFORE`),
    but you can’t copy the written bytes until after the write is done. That’s why
    `instrument_mem_cflow` inserts multiple analysis routines for every write.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每次内存写入，解包器需要知道写入地址和写入大小，以便记录所有写入的字节。不幸的是，在 Pin 中，写入地址仅在内存写入发生*之前*是已知的（在 `IPOINT_BEFORE`），但直到写入完成后才能复制已写入的字节。这就是为什么
    `instrument_mem_cflow` 为每次写入插入多个分析程序的原因。
- en: First, it adds an analysis callback to `queue_memwrite` before every memory
    write ➋, which saves the write’s effective address (`IARG_MEMORYWRITE_EA` ➌) into
    the global `saved_addr` variable. Then, for memory write instructions that have
    a fallthrough edge ➍, `instrument_mem_cflow` instruments that fallthrough edge
    with a callback to `log_memwrite` ➎, which records all the written bytes in `shadow_mem`.
    The `IARG_MEMORYWRITE_SIZE` parameter ➏ tells `log_memwrite` how many bytes to
    record, starting from the `saved_addr` that `queue_memwrite` saved before the
    write. Similarly, for writes that happen as part of a branch or call ➐, the unpacker
    adds an analysis callback to `log_memwrite` on the taken edge ➑, ensuring that
    the write will be recorded regardless of which branch direction the application
    takes at runtime.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它在每次内存写入之前，向 `queue_memwrite` 添加一个分析回调 ➋，该回调将写入的有效地址（`IARG_MEMORYWRITE_EA`
    ➌）保存到全局变量 `saved_addr` 中。然后，对于具有下行分支的内存写入指令 ➍，`instrument_mem_cflow` 对下行分支进行插桩，并回调
    `log_memwrite` ➎，该回调会将所有写入的字节记录到 `shadow_mem` 中。`IARG_MEMORYWRITE_SIZE` 参数 ➏ 告诉
    `log_memwrite` 需要记录多少字节，从 `queue_memwrite` 在写入前保存的 `saved_addr` 开始。类似地，对于发生在分支或调用中的写入
    ➐，解包器会在被取走的分支 ➑ 上添加一个分析回调到 `log_memwrite`，确保无论应用程序在运行时选择哪个分支方向，写入都会被记录。
- en: '*9.5.4 Instrumenting Control-Flow Instructions*'
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*9.5.4 控制流指令的插桩*'
- en: Recall that the unpacker’s goal is to detect the control transfer to the original
    entry point and then dump the unpacked binary to disk. To that end, `instrument_mem_cflow`
    instruments indirect branches and calls ➒ with a call-back to `check_indirect_ctransfer`
    ➓, an analysis routine that checks whether the branch targets a previously writable
    memory region and, if so, marks it as a possible jump to OEP and dumps the targeted
    memory region to disk.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，解包器的目标是检测到原始入口点的控制转移，并将解包后的二进制文件转储到磁盘上。为此，`instrument_mem_cflow` 对间接分支和调用
    ➒ 进行插桩，并回调 `check_indirect_ctransfer` ➓，该分析程序会检查分支是否指向一个先前可写的内存区域，如果是，它会将该内存区域标记为可能跳转到
    OEP，并将目标内存区域转储到磁盘。
- en: Note that for optimization, `instrument_mem_cflow` instruments only indirect
    control transfers because many packers use indirect branches or calls to jump
    to the unpacked code. This may not be true for all packers, and you can easily
    change `instrument_mem_cflow` to instrument all control transfers instead of only
    indirect ones, but this will be at the cost of a significant performance hit.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了优化性能，`instrument_mem_cflow` 只对间接控制转移进行插桩，因为许多加壳程序使用间接分支或调用来跳转到解包后的代码。这对于所有加壳程序来说可能并不准确，您可以轻松地更改
    `instrument_mem_cflow` 以对所有控制转移进行插桩，而不仅仅是间接转移，但这样会导致显著的性能损失。
- en: '*9.5.5 Tracking Memory Writes*'
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*9.5.5 跟踪内存写入*'
- en: '[Listing 9-10](ch09.xhtml#ch09list10) shows the analysis routines responsible
    for recording memory writes, which you’ve already seen in the previous sections.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9-10](ch09.xhtml#ch09list10)展示了负责记录内存写入的分析例程，你在前面的章节中已经看过。'
- en: '*Listing 9-10:* unpacker.cpp *(continued)*'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-10:* unpacker.cpp *(续)*'
- en: '[PRE12]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first of the analysis routines, `queue_memwrite` ➊, is called before every
    memory write and stores the write’s address in the global variable `saved_addr`.
    Recall that this is necessary because Pin allows you to inspect the write’s address
    only at `IPOINT_BEFORE`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个分析例程`queue_memwrite` ➊在每次内存写入之前被调用，并将写入的地址存储在全局变量`saved_addr`中。回想一下，这是必要的，因为Pin仅允许你在`IPOINT_BEFORE`时检查写入的地址。
- en: After every memory write (on the fallthrough or taken edge), there’s a callback
    to `log_memwrite` ➋, which records all the written bytes in `shadow_mem`. It first
    retrieves the write’s base address by reading `saved_addr` ➌ and then loops over
    all the written addresses ➍. It marks each address as written in `shadow_mem`
    ➎ and calls `PIN_SafeCopy` to copy the value of the written byte from application
    memory into `shadow_mem` ➏.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 每次内存写入（在fallthrough或taken边缘上）后，都会回调`log_memwrite` ➋，它将所有写入的字节记录在`shadow_mem`中。它首先通过读取`saved_addr`
    ➌来获取写入的基地址，然后循环遍历所有写入的地址 ➍。它将每个地址标记为在`shadow_mem`中写入 ➎，并调用`PIN_SafeCopy`将写入字节的值从应用程序内存复制到`shadow_mem`中
    ➏。
- en: Note that the unpacker must copy all written bytes into its own memory because
    when it later dumps unpacked memory to disk, the application may have already
    deallocated part of that memory region. When copying bytes from application memory,
    you should always use `PIN_SafeCopy` because Pin may modify some memory contents.
    If you read from application memory directly, you’d see the contents written by
    Pin, which is usually not what you want. In contrast, `PIN_SafeCopy` will always
    show you the memory state as written by the original application and will also
    safely handle cases where memory regions are inaccessible without causing a segmentation
    fault.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，解包器必须将所有已写字节复制到自己的内存中，因为当它稍后将解包的内存转储到磁盘时，应用程序可能已经释放了该内存区域的部分内容。复制应用程序内存中的字节时，应该始终使用`PIN_SafeCopy`，因为Pin可能会修改某些内存内容。如果直接从应用程序内存读取，你会看到Pin写入的内容，这通常不是你想要的。相反，`PIN_SafeCopy`将始终显示由原始应用程序写入的内存状态，并且会安全地处理那些无法访问的内存区域而不会导致段错误。
- en: You may notice that the unpacker ignores the return value of `PIN _SafeCopy`,
    which indicates the number of bytes it successfully read. For the unpacker, there’s
    nothing it can do if a read from application memory fails; the unpacked code will
    simply be corrupted. In other Pintools, you’ll want to check the return value
    and handle errors gracefully.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，解包器忽略了`PIN _SafeCopy`的返回值，该返回值表示它成功读取的字节数。对于解包器来说，如果从应用程序内存读取失败，它无能为力；解包后的代码将会被损坏。在其他Pintools中，你需要检查返回值并优雅地处理错误。
- en: '*9.5.6 Detecting the Original Entry Point and Dumping the Unpacked Binary*'
  id: totrans-267
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*9.5.6 检测原始入口点并转储解包的二进制文件*'
- en: The ultimate goal of the unpacker is to detect the jump to the OEP and dump
    the unpacked code. [Listing 9-11](ch09.xhtml#ch09list11) shows the analysis routine
    that implements this.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 解包器的最终目标是检测到跳转到OEP并转储解包后的代码。[列表 9-11](ch09.xhtml#ch09list11)展示了实现这一目标的分析例程。
- en: '*Listing 9-11:* unpacker.cpp *(continued)*'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-11:* unpacker.cpp *(续)*'
- en: '[PRE13]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When `check_indirect_ctransfer` detects a suspected jump to OEP, it builds a
    memory cluster ➊ of all the consecutive bytes surrounding the OEP and dumps that
    to disk. Because `check_indirect_ctransfer` is called only on control-flow instructions,
    it always marks the target address as executable ➋. If the target address lies
    within a once-written memory region ➌, then this may be a jump to OEP, and the
    unpacker proceeds to dump the targeted memory region if it hasn’t already done
    so. To check whether the region has been dumped before, the unpacker calls `in_cluster`
    ➍, which checks whether there’s already a memory cluster containing the target
    address. I won’t discuss `in_cluster`’s code here since it doesn’t use any Pin
    functionality.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 当`check_indirect_ctransfer`检测到怀疑的跳转到OEP时，它会构建一个包含OEP周围所有连续字节的内存集群➊，并将其转储到磁盘。因为`check_indirect_ctransfer`仅在控制流指令上调用，所以它始终将目标地址标记为可执行的➋。如果目标地址位于一个曾经被写入的内存区域➌内，那么这可能是跳转到OEP，解包器将在尚未转储该内存区域时继续转储该区域。为了检查该区域是否已被转储过，解包器调用`in_cluster`
    ➍，该函数检查是否已经存在包含目标地址的内存集群。我这里不讨论`in_cluster`的代码，因为它没有使用任何Pin功能。
- en: '![image](Images/f258-01.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f258-01.jpg)'
- en: '*Figure 9-7: Building a memory cluster after a control transfer to a candidate
    OEP*'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-7：控制转移到候选OEP后的内存集群构建*'
- en: If the targeted region isn’t unpacked yet, `check_indirect_ctransfer` calls
    `set_cluster` ➎ to cluster the memory around the suspected OEP into a contiguous
    chunk it can dump to disk and stores that chunk into `clusters` ➏, the global
    list of all unpacked regions. I won’t go over `set_cluster`’s code here, but [Figure
    9-7](ch09.xhtml#ch09fig7) illustrates how it simply searches backward and forward
    in `shadow_mem` starting from the suspected OEP, expanding the cluster across
    all neighboring bytes that have been written, until it hits a “gap” of unwritten
    memory locations.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标区域尚未解包，`check_indirect_ctransfer`会调用`set_cluster` ➎，将怀疑的OEP周围的内存集群整理成一个连续的块，以便它可以将该块转储到磁盘，并将该块存储到`clusters`
    ➏中，这是所有已解包区域的全局列表。我不会在这里详细讲解`set_cluster`的代码，但[图 9-7](ch09.xhtml#ch09fig7)展示了它如何从怀疑的OEP开始，在`shadow_mem`中前后搜索，扩展集群，覆盖所有已写入的相邻字节，直到它遇到一个未写入内存位置的“间隙”。
- en: Next, `check_indirect_ctransfer` unpacks the just-built memory cluster by dumping
    it to disk ➐. Rather than assuming that the unpacking was successful and exiting
    the application, the unpacker continues just as it did before because there might
    be another layer of packing to discover and unpack.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`check_indirect_ctransfer`通过将刚构建的内存集群转储到磁盘来解包它 ➐。解包器不会假设解包已经成功并退出应用程序，而是继续像之前一样运行，因为可能还有另一层打包需要发现和解包。
- en: '*9.5.7 Testing the Unpacker*'
  id: totrans-276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*9.5.7 测试解包器*'
- en: Now let’s test the automatic unpacker by using it to unpack an executable packed
    with UPX, a well-known packer that you can install on Ubuntu with `apt install
    upx`. [Listing 9-12](ch09.xhtml#ch09list12) shows how to pack a test binary with
    UPX (the *Makefile* for this chapter does this automatically).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过使用自动解包器来测试它，解包一个用UPX打包的可执行文件，UPX是一个著名的打包工具，您可以通过`apt install upx`在Ubuntu上安装。[列表
    9-12](ch09.xhtml#ch09list12)展示了如何用UPX打包一个测试二进制文件（本章的*Makefile*会自动执行此操作）。
- en: '*Listing 9-12: Packing* /bin/ls *with UPX*'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-12：用UPX打包*/bin/ls*'
- en: '[PRE14]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For this example, let’s copy */bin/ls* to a file called *packed* ➊ and then
    pack it with UPX ➋. UPX reports that it successfully packed the binary and compressed
    it to 45.18 percent of its original size ➌. You can confirm that a binary is packed
    by viewing it in IDA Pro, as shown in [Figure 9-8](ch09.xhtml#ch09fig8). As you
    can see, the packed binary contains a much smaller number of functions than most
    binaries; IDA finds only four functions because all others are packed. You can
    also use IDA to see that there’s a large region of data containing the packed
    code and data (not shown in the figure).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，先将*/bin/ls*复制到一个名为*packed*的文件中 ➊，然后用UPX打包 ➋。UPX报告说它已成功打包该二进制文件并将其压缩到原始大小的45.18%
    ➌。您可以通过在IDA Pro中查看该二进制文件来确认它已被打包，正如[图 9-8](ch09.xhtml#ch09fig8)所示。正如您所看到的，打包的二进制文件包含的函数数量远少于大多数二进制文件；IDA只找到了四个函数，因为其他所有函数都被打包。您还可以使用IDA查看是否有一个大区域的数据显示着打包的代码和数据（该区域在图中未显示）。
- en: '![image](Images/f260-01.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f260-01.jpg)'
- en: '*Figure 9-8: The packed binary as shown in IDA Pro*'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-8：IDA Pro中显示的打包二进制文件*'
- en: Now let’s test the unpacker’s ability to recover *ls*’s original code and data
    from the packed binary. [Listing 9-13](ch09.xhtml#ch09list13) shows how to use
    the unpacker.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试解包器从打包的二进制文件中恢复*ls*的原始代码和数据的能力。[列表 9-13](ch09.xhtml#ch09list13)展示了如何使用解包器。
- en: '*Listing 9-13: Testing the binary unpacker*'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-13：测试二进制解包器*'
- en: '[PRE15]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To use the unpacker, you call `pin` with the unpacker as the Pintool and the
    packed binary (*packed*) as the application ➊. The application now runs with the
    unpacker’s instrumentation and, because it’s a copy of */bin/ls*, prints a directory
    listing ➋. You can see that the directory listing contains several unpacked files,
    each of which uses a naming scheme that indicates the dumped region’s start and
    end address and the entry point address detected by the instrumentation code.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用解包器，您需要调用`pin`，将解包器作为Pintool，并将打包的二进制文件（*packed*）作为应用程序 ➊。此时，应用程序在解包器的插装下运行，由于它是*/bin/ls*的副本，因此会打印出目录列表
    ➋。您可以看到，目录列表中包含多个已解包的文件，每个文件使用的命名方案指示了转储区域的起始和结束地址，以及由插装代码检测到的入口点地址。
- en: The log file *unpacker.log* details the extracted regions and lists all the
    memory clusters (even the ones that weren’t unpacked) that the unpacker found
    ➌. Let’s take a more detailed look at the largest unpacked file ➍, named *unpacked.0x400000-0x41da64_entry-0x40000c*.^([15](footnote.xhtml#ch09fn_15))
    Using `file`, you can tell it’s an ELF binary ➎, although a somewhat “damaged”
    one in the sense that ELF binaries’ memory representation doesn’t correspond directly
    to the on-disk representation that utilities like `file` expect. For example,
    the section header table isn’t available at runtime, so there’s no way for the
    unpacker to recover it. Nevertheless, let’s see if IDA Pro and other utilities
    can parse the unpacked file.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 日志文件*unpacker.log*详细列出了提取的区域，并列出了所有内存块（包括那些没有解包的）解包器找到的内容 ➌。我们来更详细地看看最大的一份解包文件
    ➍，名为*unpacked.0x400000-0x41da64_entry-0x40000c*。^([15](footnote.xhtml#ch09fn_15))
    使用`file`，你可以看出它是一个ELF二进制文件 ➎，尽管从某种程度上来说它是一个“损坏”的ELF文件，因为ELF二进制文件的内存表示与像`file`这样的工具期望的磁盘表示不完全对应。例如，段头表在运行时不可用，因此解包器无法恢复它。尽管如此，我们还是来看看IDA
    Pro和其他工具能否解析解包后的文件。
- en: As shown in [Figure 9-9](ch09.xhtml#ch09fig9), IDA Pro manages to find a lot
    more functions in the unpacked binary than it did in the packed one, which is
    promising.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 9-9](ch09.xhtml#ch09fig9)所示，IDA Pro在解包二进制文件中找到了比在打包文件中更多的函数，这很有前景。
- en: '![image](Images/f261-01.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f261-01.jpg)'
- en: '*Figure 9-9: The unpacked binary as shown in IDA Pro*'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-9：在IDA Pro中显示的解包二进制文件*'
- en: Moreover, you can use `strings` to see that the unpacked binary contains many
    human-readable strings that suggest a successful unpack, as shown in [Listing
    9-14](ch09.xhtml#ch09list14).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以使用`strings`查看解包后的二进制文件包含许多可读字符串，表明解包成功，如[清单 9-14](ch09.xhtml#ch09list14)所示。
- en: '*Listing 9-14: Strings found in the unpacked binary*'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-14：在解包二进制文件中找到的字符串*'
- en: '[PRE16]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Recall from [Chapter 5](ch05.xhtml#ch05) that `strings` ➊ is a Linux utility
    that shows you human-readable strings that it finds in any file. For the unpacked
    binary, `strings` shows the usage instructions for */bin/ls* ➋ (among many other
    strings).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第5章](ch05.xhtml#ch05)，`strings` ➊是一个Linux工具，它可以显示在任何文件中找到的可读字符串。对于解包后的二进制文件，`strings`
    显示了*/bin/ls*的使用说明 ➋（以及许多其他字符串）。
- en: As a final sanity check, let’s use `objdump` to compare the unpacked code to
    *ls*’s original code. [Listing 9-15](ch09.xhtml#ch09list15) shows part of the
    original `main` function in */bin/ls*, and [Listing 9-16](ch09.xhtml#ch09list16)
    shows the corresponding unpacked code.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个完整性检查，让我们使用`objdump`将解包后的代码与*ls*的原始代码进行比较。[清单 9-15](ch09.xhtml#ch09list15)显示了原始`main`函数在*/bin/ls*中的一部分，[清单
    9-16](ch09.xhtml#ch09list16)则显示了解包后的代码。
- en: To disassemble the original binary, you can use `objdump` normally ➊, but for
    the unpacked binary you need to pass some special options ➋ telling `objdump`
    to treat the file as a raw binary containing x86-64 code and to disassemble all
    of the file’s contents (`-D` instead of the usual `-d`). That’s necessary because
    the unpacked binary doesn’t contain a section header table that `objdump` can
    use to figure out where the code sections are.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 要反汇编原始二进制文件，你可以正常使用`objdump` ➊，但对于解包后的二进制文件，你需要传递一些特殊选项 ➋，告诉`objdump`将文件当作包含x86-64代码的原始二进制文件处理，并反汇编文件的全部内容（使用`-D`而不是通常的`-d`）。这是必要的，因为解包后的二进制文件没有包含`objdump`用来判断代码段位置的段头表。
- en: '*Listing 9-15: Partial disassembly of* main *in the original* /bin/ls'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-15：* main *函数在原始* /bin/ls中的部分反汇编*'
- en: '[PRE17]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 9-16: Partial disassembly of* main *in the unpacked binary*'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-16：* main *函数在解包二进制文件中的部分反汇编*'
- en: '[PRE18]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Comparing [Listings 9-15](ch09.xhtml#ch09list15) and [9-16](ch09.xhtml#ch09list16)
    side by side, you can see that the code is identical, except for code addresses
    at ➌ and ➍. That’s because `objdump` isn’t aware of the unpacked binary’s expected
    load address because of the missing section header table. Note that in the unpacked
    binary, `objdump` is also unable to automatically annotate calls to PLT stubs
    with the corresponding function names. Fortunately, disassemblers like IDA Pro
    allow you to manually specify a load address so that after some configuration,
    you can reverse engineer the unpacked binary just like you would a normal one!
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 将[清单 9-15](ch09.xhtml#ch09list15)和[9-16](ch09.xhtml#ch09list16)并排比较，你会看到代码是相同的，除了在
    ➌ 和 ➍ 处的代码地址不同。这是因为`objdump`由于缺少段头表，无法知道解包二进制文件的预期加载地址。请注意，在解包后的二进制文件中，`objdump`也无法自动注解PLT存根的调用对应的函数名。幸运的是，像IDA
    Pro这样的反汇编工具允许你手动指定加载地址，因此经过一些配置后，你可以像处理正常二进制文件一样反向工程解包后的二进制文件！
- en: 9.6 Summary
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.6 小结
- en: In this chapter, you learned how binary instrumentation techniques work and
    how to instrument binaries with Pin. You should now be ready to build your own
    Pintools to analyze and modify binaries at runtime. You’ll see Pin again in [Chapters
    10](ch10.xhtml#ch10) through [13](ch13.xhtml#ch13) when I cover taint analysis
    and symbolic execution platforms that build on Pin.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了二进制插桩技术的工作原理，以及如何使用Pin对二进制文件进行插桩。现在你应该准备好构建自己的Pintools，分析和修改运行时的二进制文件。在[第10章](ch10.xhtml#ch10)到[第13章](ch13.xhtml#ch13)中，你将再次看到Pin，我将在那时介绍基于Pin的污点分析和符号执行平台。
- en: Exercises
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: 1\. Extending the Profiler
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 扩展性能分析器
- en: The profiler records all syscalls, even ones that happen outside of the main
    application. Modify the profiler to check where a syscall originated and profile
    only those that originate in the main application. To find out how to do this,
    you’ll have to consult the Pin user manual online.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析器记录所有的系统调用，即使这些调用发生在主应用程序之外。修改性能分析器，检查系统调用的来源，并仅分析来自主应用程序的系统调用。要了解如何做到这一点，你需要查阅在线的Pin用户手册。
- en: 2\. Investigating Unpacked Files
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 调查解包后的文件
- en: When you were testing the unpacker, it dumped several files, one of which was
    the unpacked */bin/ls*. Investigate what the other files contain and why the unpacker
    dumped them.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 当你测试解包器时，它转储了几个文件，其中之一是解包后的*/bin/ls*。调查其他文件的内容以及解包器为什么会转储这些文件。
- en: 3\. Extending the Unpacker
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 扩展解包器
- en: Add a command line option to the automatic unpacker that, when enabled, causes
    it to instrument *all* control transfers, rather than just indirect ones, to look
    for the jump to OEP. Compare the runtimes of the unpacker with and without this
    option enabled. How would a packer that jumps to OEP with a direct control transfer
    work?
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 为自动解包器添加一个命令行选项，当启用时，它会对*所有*控制转移进行插桩，而不仅仅是间接控制转移，目的是查找跳转到OEP的地方。比较启用和未启用该选项时，解包器的运行时间。一个使用直接控制转移跳转到OEP的打包器如何工作？
- en: 4\. Dumping Decrypted Data
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 转储解密数据
- en: Build a Pintool that can monitor an application and automatically detect and
    dump data when the application decrypts it with RC4 (or another cryptographic
    algorithm of your choice). Your Pintool is allowed to report false positives (bogus
    data that’s not really decrypted) but should try to minimize them.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个Pintool，可以监视一个应用程序，并在该应用程序使用RC4（或你选择的其他加密算法）解密数据时自动检测并转储数据。你的Pintool可以报告假阳性（虚假的未解密数据），但应尽量减少这些情况。
