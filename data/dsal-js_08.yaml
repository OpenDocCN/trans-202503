- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 6 SORTING
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6 排序
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: In previous chapters we discussed concepts related to programming and designing
    algorithms. Now we’ll start considering their actual application. The problem
    we’ll explore is how to sort a set of records into order, where each record consists
    of a key (alphabetical, numerical, or several fields) and data.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们讨论了与编程和算法设计相关的概念。现在，我们将开始考虑这些概念的实际应用。我们要探讨的问题是如何将一组记录排序，每个记录由一个键（字母顺序、数字或多个字段）和数据组成。
- en: The algorithm’s output should include the exact same set of records, but shuffled
    so that the keys are in order. You usually want the keys in ascending order, but
    descending order requires only a minor change in sorting algorithms—namely, reversing
    comparisons—so you won’t see it here. (See question 6.1 at the end of the chapter.)
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的输出应包括完全相同的一组记录，但经过重新排列，以使键按顺序排列。通常，你希望键按升序排列，但降序排列只需要对排序算法进行一个小改动——即反转比较操作——所以在这里不会展示。（请参见本章末的第6.1题。）
- en: We’ll first consider general aspects of the sorting problem and then moves on
    to look at several algorithms based on comparisons of keys (the most common algorithms),
    followed by a few algorithms based on other principles. We’ll consider the performance
    of all algorithms and even toss in some humorous algorithms for comparison.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先会考虑排序问题的总体情况，然后继续研究几种基于键比较的算法（最常见的算法），接着会看一些基于其他原理的算法。我们将考虑所有算法的性能，甚至会加入一些幽默的算法进行比较。
- en: '### The Sorting Problem'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '### 排序问题'
- en: 'A *sorting algorithm* is basically an algorithm that, given a list of records
    containing a key and some data, reorders the list so that the keys are in nondecreasing
    order (no key is smaller than its preceding key), and the output list is a permutation
    of the input list, retaining all original records. Forgetting the second condition
    is easy, but ignoring it would mean that the following would be a valid sorting
    function:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*排序算法*本质上是一种算法，它接受包含键和值的数据记录列表，然后重新排列列表，使得键按非递减顺序排列（没有任何键小于其前一个键），输出列表是输入列表的一个排列，保留所有原始记录。忘记第二个条件很容易，但忽视它将意味着以下情况也可以被视为有效的排序函数：'
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Sorting is important in and of itself, but it also affects the efficiency of
    other algorithms. For instance, in [Chapter 9](chapter9.xhtml) we’ll see how working
    with sorted data allows for more efficient search procedures.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 排序本身很重要，但它也影响其他算法的效率。例如，在[第9章](chapter9.xhtml)中，我们将看到如何利用排序数据来实现更高效的搜索操作。
- en: For our examples, we’ll usually assume single-field keys that you can directly
    compare using the < and > operators. For more generic cases, you could modify
    the algorithms to use the compare(a,b) comparison function, as JavaScript’s sorting
    algorithm does (see the section “JavaScript’s Own Sort Method” on page 95). In
    the code examples in this book, you’ll always write tests as a>b, so modifying
    the code for generic sorting requires only changing that comparison to compare(a,b)>0.
    (See question 6.2 for a variation.) In [Chapter 14](chapter14.xhtml), you’ll actually
    use this kind of solution by applying a goesHigher(a,b) function to decide which
    of a or b should be higher in a heap.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们通常假设使用可以直接通过 < 和 > 运算符进行比较的单字段键。对于更通用的情况，你可以修改算法，使用 compare(a,b) 比较函数，正如
    JavaScript 的排序算法所做的那样（请参见第95页的“JavaScript 自带的排序方法”部分）。在本书中的代码示例中，你总是会写测试如 a>b，因此修改代码以支持通用排序只需要将该比较改为
    compare(a,b)>0。（参见第6.2题的变体。）在[第14章](chapter14.xhtml)中，你将通过应用 goesHigher(a,b) 函数来决定在堆中哪个元素应该更大。
- en: Internal vs. External Sorting
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 内部排序与外部排序
- en: An important consideration when sorting data is whether it can all be stored
    in memory at the same time, or whether it’s so large that it must reside in a
    storage device. The first case is called *internal sorting*, and the second is
    called *external sorting*. All the algorithms in this chapter fall into the first
    category, but what if you need to sort more data than can fit in memory?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 排序数据时，一个重要的考虑因素是数据是否能全部同时存储在内存中，还是数据过大必须存储在外部存储设备中。第一种情况称为*内部排序*，第二种情况称为*外部排序*。本章中的所有算法都属于第一类，但如果你需要排序的数据超过内存容量怎么办呢？
- en: External sorting breaks up all the input into runs that are as large as possible
    to fit in memory, then uses internal sorting to sort the runs, saves them to external
    storage, and merges the sorted runs into the final output. That said, it’s highly
    likely that for large sorting tasks like this, you’ll be better off using a standard
    system sort utility, which also might be optimized to use parallel threads, multiple
    central processing units (CPUs), and so on. In any case, should you decide to
    roll out your own external sort procedure, the algorithms in this section cover
    the needed internal sorting, and using a heap (as in [Chapter 14](chapter14.xhtml))
    would help with writing efficient merge code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 外部排序将所有输入数据分解成尽可能大的块，以适应内存，然后使用内部排序对这些块进行排序，保存到外部存储，并将已排序的块合并成最终的输出。也就是说，对于像这样的庞大排序任务，你可能更适合使用标准的系统排序工具，它可能还会优化以使用并行线程、多个中央处理单元（CPU）等。无论如何，如果你决定自己实现外部排序程序，本节中的算法涵盖了所需的内部排序，使用堆（如[第14章](chapter14.xhtml)所示）将有助于编写高效的合并代码。
- en: Adaptive Sorting
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自适应排序
- en: 'A sorting algorithm is called *adaptive* if it somehow takes advantage of whatever
    existing order already exists in its input. Shell sort, which you’ll learn about
    in the section “Making Bigger Jumps with Comb and Shell Sort” on page 103, is
    such a case: the algorithm performs better when data is partially sorted. On the
    other hand, quicksort, which you’ll learn about in the section “Going for Speed
    with Quicksort” on page 105, could be considered anti-adaptive. Its worst performance
    happens when data is already in order (though there are ways around this).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果排序算法能够利用输入数据中已经存在的任何顺序，那么它被称为 *自适应算法*。壳排序就是一个例子，你将在第103页的“通过组合排序和壳排序实现更大跳跃”部分学习到它：当数据部分排序时，算法的性能会更好。另一方面，快速排序，你将在第105页的“通过快速排序追求速度”部分学习到它，可以被视为反自适应算法。当数据已经有序时，它的最差表现会出现（尽管也有解决方法）。
- en: In-Place and Out-of-Place Sorting
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 原地排序与非原地排序
- en: Another consideration for sorting algorithms is whether they require extra data
    structures (and thus extra space). This requirement is often relaxed to allow
    for constant, less than *O*(*n*) extra memory—the key rule is whether extra space
    proportional to the input size is needed. We don’t take into account the *O*(*n*)
    space needed to store the *n* elements to be sorted. Algorithms that don’t require
    such extra space are called *in-place*, and those that do require more memory
    are known as *out-of-place* or *not-in-place* algorithms. This doesn’t mean that
    out-of-place algorithms return a new list; they may perfectly well reorder the
    input list in place, but they require *O*(*n*), or more, extra space to do so.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 排序算法的另一个考虑因素是它们是否需要额外的数据结构（因此需要额外的空间）。通常，这一要求被放宽，允许使用常量的、少于 *O*(*n*) 的额外内存——关键规则是是否需要与输入大小成比例的额外空间。我们不会考虑存储要排序的
    *n* 个元素所需的 *O*(*n*) 空间。那些不需要额外空间的算法称为 *原地算法*，而那些需要更多内存的则被称为 *非原地算法* 或 *不原地算法*。这并不意味着非原地算法会返回一个新的列表；它们完全可以在原地重新排列输入列表，但它们需要额外的
    *O*(*n*) 或更多的空间来完成此操作。
- en: 'Consider carefully how much memory an algorithm uses: some recursive algorithms
    like quicksort require internally using a stack that is *O*(*log n*) but that
    is also allowed to count as in-place. Merge sort usually requires extra space
    to merge sequences, so it has *O*(*n*) needs and thus falls into the out-of-place
    category.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细考虑算法使用的内存量：一些递归算法，如快速排序，内部需要使用一个栈，其空间复杂度为 *O*(*log n*)，但这也被认为是原地排序。归并排序通常需要额外的空间来合并序列，因此其空间复杂度为
    *O*(*n*)，因此属于非原地排序类别。
- en: Online and Offline Sorting
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在线排序与离线排序
- en: Another distinction to make when considering algorithms is whether they can
    process the input data in a serial stream-like fashion or whether all the data
    needs to be available from the beginning. Algorithms in the first category are
    called *online algorithms*, and those in the second are *offline algorithms*.
    This distinction applies not only to sorting but to other problems as well; for
    example, you’ll see it again when discussing sampling in [Chapter 8](chapter8.xhtml).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑算法时，另一个需要区分的是它们是否能够像串行流一样处理输入数据，还是所有数据必须从一开始就可用。第一类算法称为 *在线算法*，第二类则称为 *离线算法*。这个区别不仅适用于排序问题，也适用于其他问题；例如，在[第8章](chapter8.xhtml)中讨论采样时你将再次看到它。
- en: In terms of sorting, an online algorithm will always have a sorted list, adding
    new elements to it as they come in, while an offline algorithm will have to wait
    until all elements are available. Offline algorithms usually have better performance,
    though. Online algorithms don’t know the whole input, so they have to make decisions
    that may turn out later to be suboptimal, which is the same kind of situation
    as with greedy algorithms (see [Chapter 5](chapter5.xhtml)).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在排序方面，在线算法会始终保持一个已排序的列表，并将新元素按顺序加入其中，而离线算法则必须等到所有元素都可用后再开始排序。尽管如此，离线算法通常具有更好的性能。在线算法不知道所有输入，因此它们必须做出可能在后续阶段被证明是次优的决策，这与贪心算法的情形相同（参见[第5章](chapter5.xhtml)）。
- en: As an example of this distinction, consider how you could sort a set of playing
    cards. If you keep the cards you’ve sorted so far in your hand and then every
    time you get a new card you insert it into place among the previous ones, you
    are implementing an online algorithm—in fact, it’s an *insertion sort*, which
    we’ll study in the section “Sorting Strategies for Playing Cards” on page 100.
    If you wait until you have all the cards and then sort them somehow, that’s an
    offline sort.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这种区别的一个例子，考虑如何排序一副扑克牌。如果你将已经排序的牌保存在手中，然后每次得到新牌时，将它插入到之前牌的合适位置，你实际上是在实现一个在线算法——实际上，这是一个*插入排序*，我们将在“扑克牌排序策略”这一节中（第100页）学习它。如果你等到所有牌都到齐后，再通过某种方式进行排序，那就是离线排序。
- en: Sorting Stability
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 排序稳定性
- en: 'Sorting data with possibly equal keys raises a question: In what relative order
    do the elements with equal keys end up? A *stable sorting* algorithm maintains
    the same order as the input, so if one element preceded another and both had the
    same key, in the ordered output, the first one will precede the second.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 排序可能具有相等关键字的数据提出了一个问题：具有相等关键字的元素最终会以何种相对顺序排列？*稳定排序*算法保持与输入相同的顺序，因此，如果一个元素排在另一个元素前面且两者具有相同的关键字，在排序后的输出中，第一个元素会排在第二个元素前面。
- en: 'Why does stability matter? Imagine you want to have a drop-down element in
    an HTML page that shows your contacts but with this rule: starred contacts (favorites)
    should appear first, in alphabetical order, followed by nonstarred contacts, also
    in alphabetical order.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么稳定性很重要？假设你想在一个HTML页面中显示联系人，并且希望遵循这样一个规则：加星标的联系人（收藏）应该排在前面，按字母顺序排列，接着是没有星标的联系人，同样按字母顺序排列。
- en: To achieve the required ordering, you could first order the whole list by name
    and then reorder it so starred contacts are first. [Figure 6-1](chapter6.xhtml#fig6-1)
    illustrates this method.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现所需的排序，你可以先按名字排序整个列表，然后重新排序，使加星标的联系人排在前面。[图 6-1](chapter6.xhtml#fig6-1)展示了这种方法。
- en: '![](../images/Figure6-1.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-1.jpg)'
- en: 'Figure 6-1: Sorting by two fields with a stable sorting algorithm'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-1：通过稳定排序算法按两个字段排序
- en: The first sort reorders the list by name, alphabetically, and the second sort
    places starred names before the ones without stars. If the second sort is stable,
    this ordering won’t affect the previous alphabetical sorting. With an unstable
    sort, that might not be true. Stability is the reason Joliet precedes Romeo in
    the final list. Joliet preceded Romeo when sorting by name, and when sorting by
    star, they keep the same relative order.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次排序按字母顺序重排列表，第二次排序将加星标的名字排在没有星标的名字之前。如果第二次排序是稳定的，那么这种排序不会影响之前的字母顺序排序。如果是一个不稳定的排序，可能就不成立了。稳定性是朱丽叶在最终列表中排在罗密欧之前的原因。朱丽叶在按名字排序时排在罗密欧之前，而在按星标排序时，它们保持了相同的相对顺序。
- en: You can modify any sorting algorithm to force it to be stable. No matter what
    the key for ordering is, consider a new extended key formed by the original key
    followed by the item’s position in the list. Ordering this array by the new extended
    key, items that shared the same (original) key value will be sorted together,
    but because of the added position, they will keep the same original relative order,
    as shown in [Figure 6-2](chapter6.xhtml#fig6-2).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以修改任何排序算法，强制其变为稳定的。不论排序的关键是什么，考虑使用由原始关键字后接列表中项的位置形成的新扩展关键字。通过新的扩展关键字排序这个数组时，共享相同（原始）关键字值的项将会被一起排序，但由于添加了位置，它们将保持原有的相对顺序，如[图
    6-2](chapter6.xhtml#fig6-2)所示。
- en: '![](../images/Figure6-2.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-2.jpg)'
- en: 'Figure 6-2: Sorting made stable by using an extended key'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-2：通过使用扩展关键字使排序变得稳定
- en: The first step adds the item’s position as an extra key; the second step sorts
    by name and position. Elements that had the same original key (Alpha and Echo
    in the example) are kept in their original relative positions to each other. You
    would finish by dropping the added field.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步通过添加项目的位置信息作为额外的键值；第二步按姓名和位置排序。具有相同原始键值（例如示例中的 Alpha 和 Echo）的元素将保持它们之间的相对位置。最后，你可以删除添加的字段。
- en: '#### JavaScript’s Own Sort Method'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '#### JavaScript 自带的排序方法'
- en: When sorting data in JavaScript, don’t forget that the language already provides
    a .sort(...) method, and despite considering more (and possibly better) sorting
    algorithms later in this chapter, in many cases using JavaScript’s own sort might
    be most effective. Let’s quickly review how this sort works (see *[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)*
    for more information).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中排序时，不要忘记语言已经提供了一个 .sort(...) 方法，尽管本章稍后会考虑更多（可能更好的）排序算法，但在许多情况下，使用
    JavaScript 自带的排序方法可能是最有效的。我们来快速回顾一下这个排序方法是如何工作的（更多信息请参见 *[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)*）。
- en: 'Given an array, the .sort(comparisonFunction) method reorders the array in
    place using an optional comparison function. (The newer .toSorted() method doesn’t
    sort in place, but rather produces a new, sorted version of the array.) If that
    function is omitted, JavaScript converts elements to strings and then sorts lexicographically,
    which may not be what you wanted:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个数组，.sort(comparisonFunction) 方法使用一个可选的比较函数就地重新排序数组。（较新的 .toSorted() 方法不会就地排序，而是生成一个新的排序后的数组版本。）如果省略该函数，JavaScript
    会将元素转换为字符串，然后按字典顺序排序，这可能不是你想要的：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To accommodate other ways of sorting, you need to provide a function that will
    receive two elements, a and b, and return a negative value if a should precede
    b, a positive value if a should follow b, and zero if both keys are equal and
    if a and b could be in any order. You can fix the previous example quite easily:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持其他排序方式，你需要提供一个函数，该函数接收两个元素 a 和 b，并返回一个负值表示 a 应该排在 b 前面，返回一个正值表示 a 应该排在 b
    后面，返回零表示两个键值相等且 a 和 b 可以任意排序。你可以很容易地修正前面的例子：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can also implement more complex comparisons; the following example shows
    how you would sort objects by date and name:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以实现更复杂的比较；下面的例子展示了如何按日期和姓名对对象进行排序：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The data to sort ❶ has dates as three separate fields (d, m, and y, for day,
    month, and year) and name (n). If two persons are from different years ❷, you
    return the correct negative or positive value by subtracting years. If the years
    are equal, you can compare months with the same kind of logic ❸, and if the months
    are also equal ❹, you do the same once more for days. If the dates are equal,
    you resort to comparing names ❺, and since you cannot use math and just subtract
    dates, you need to make actual comparisons, date part by date part. The final
    return 0 is done ❻ only if all fields were compared and found to match.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 需要排序的数据❶包含日期作为三个独立的字段（d, m 和 y，分别表示日、月和年）以及姓名（n）。如果两个人来自不同的年份❷，你通过相减年份来返回正确的负值或正值。如果年份相同，你可以使用相同的逻辑来比较月份❸，如果月份也相同❹，你再用同样的方法比较日期。如果日期相同，你就比较姓名❺，由于不能直接使用数学运算来比较日期，你需要逐个字段进行实际比较。只有在所有字段都比较过且相等时，最终才返回
    0❻。
- en: 'If you sort the people array with the dateNameCompare(...) function you just
    wrote, you get the expected result:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用刚才写的 dateNameCompare(...) 函数对人员数组进行排序，你将得到预期的结果：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Finally, consider stability. Originally, the specification for the .sort(...)
    method didn’t require it, but ECMAScript 2019 added the requirement. Be aware,
    however, that if using an earlier JavaScript engine, you cannot assume stability,
    so you might have to resort to the solution described in “Sorting Stability” on
    [page 93](chapter6.xhtml#pg_93). Also, keep in mind that any given engine may
    just not correctly implement the standard.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，考虑稳定性。最初，.sort(...) 方法的规范并不要求稳定性，但 ECMAScript 2019 添加了这一要求。然而，需要注意的是，如果使用的是较早的
    JavaScript 引擎，你不能假定排序是稳定的，因此你可能需要求助于在 [第93页](chapter6.xhtml#pg_93) 中描述的“排序稳定性”解决方案。另外，记住任何给定的引擎可能根本没有正确实现该标准。
- en: Sort Performance
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 排序性能
- en: If you have to sort *n* values, your logic has to be able to deal with all possible
    *n*! permutations of those values. How many comparisons will be needed for that?
    Think of the game of 20 questions. In that game, you have to guess a selected
    object by asking, at most, 20 yes or no questions. If you plan your questions
    carefully, you should be able to pick any element out of more than a million (2^(20)
    = 1,048,576, actually) possible options. You can apply that logic to sorting *n*
    elements.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须对*n*个值进行排序，你的逻辑必须能够处理这些值的所有可能的*n*!排列。那需要多少次比较呢？想想20个问题游戏。在这个游戏中，你必须通过最多20个“是”或“否”的问题来猜测一个选定的物体。如果你仔细规划你的问题，你应该能够从超过一百万（2^(20)
    = 1,048,576，实际上）个可能的选项中挑选出任何一个元素。你可以将这个逻辑应用于排序*n*个元素。
- en: If you are comparing elements to sort an array, it’s indirectly implied that
    you’re deciding which was the original permutation. Well-placed questions divide
    the range of options in half, so you need to know how many questions are needed
    for *n*! possibilities. This is equivalent to asking how many times you should
    divide *n*! by 2 until you get down to 1\. The answer is log *n!*, in base 2\.
    (Alternatively, you can see it as asking what value of *k* is such that 2*^k*
    > *n*!) This section won’t go into its derivation, but Stirling’s approximation
    says that *n*! grows as *n**^n*, so the logarithm of *n*! is *O*(*n* log *n*).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在比较元素来排序一个数组，那么可以间接地推断出你在决定原始排列是什么。精心设置的问题将选项范围分成两半，所以你需要知道在*n*!可能性下需要多少个问题。这相当于在问你应该将*n*!除以2多少次，直到得到1。答案是log
    *n!*，以2为底。（或者，你可以将其看作是在问什么值的*k*使得2^*k* > *n*!）本节将不讨论它的推导，但斯特林近似法表示*n*!以*n**^n*的速度增长，所以*n*!的对数是*O*(*n*
    log *n*)。
- en: This automatically implies that any algorithm based on comparing elements will
    be *O*(*n* log *n*) at the very least. No better results are achievable, but worse
    results are obviously possible. With that in mind, in the next section we’ll consider
    several algorithms, from worst to best performance.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这自动意味着，任何基于比较元素的算法至少都是*O*(*n* log *n*)。没有更好的结果可以实现，但显然可能有更差的结果。考虑到这一点，在下一节中，我们将考虑几种算法，从最差到最好的表现。
- en: Note, however, the observation about these algorithms being “based on comparing
    elements.” If you manage to sort a list without making actual comparisons, all
    bets are off. You’ll see that some methods allow sorting in *O*(*n*) time, without
    ever comparing keys to each other.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 但是请注意，关于这些算法“基于比较元素”的观察。如果你设法在没有进行实际比较的情况下排序一个列表，那么一切都不再确定。你会发现一些方法允许在*O*(*n*)时间内排序，而不需要将键相互比较。
- en: Sorting with Comparisons
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于比较的排序
- en: As mentioned previously, we’ll consider the major sorting algorithms, all of
    which depend on comparing values to each other. The first algorithms we’ll consider
    are *O*(*n*²), so they’re not optimum, but we’ll move on to better ones until
    we reach several that achieve the best *O*(*n* log *n*) performance.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将考虑主要的排序算法，所有这些算法都依赖于相互比较值。我们将考虑的第一个算法是*O*(*n*²)，因此它们不是最优的，但我们将继续研究更好的算法，直到我们达到几种实现最佳*O*(*n*
    log *n*)表现的算法。
- en: In all cases you’ll write functions that receive an array of values (as stated
    earlier, you don’t have to worry about key + data pairs, as that can easily be
    accommodated), and you’ll also pass parameters to specify which part of the array
    (from, to) should be sorted. As usual, you’ll want to sort the whole array. Those
    parameters will have default values, so the whole array will be sorted if they’re
    not present.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，你都会编写接收值数组的函数（如前所述，你无需担心键+数据对，因为这可以很容易地适应），并且你还会传递参数来指定数组的哪个部分（从， 到）应该被排序。像往常一样，你会想要排序整个数组。那些参数将具有默认值，因此如果没有提供它们，整个数组将被排序。
- en: Bubbling Up and Down
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 上升和下降
- en: We’ll start our review of sorting algorithms with *bubble sort*, which probably
    has the catchiest name, possibly to compensate for its subpar performance. This
    algorithm is easy to implement, but you’d use it only for smaller sets of data.
    It also has generated several variations (you’ll look at comb sort in the next
    section, which actually leads to a better-performing algorithm).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从回顾排序算法开始，首先介绍*冒泡排序*，它可能是最有吸引力的名字，可能是为了弥补它的较差表现。这个算法很容易实现，但你只会在数据集较小的情况下使用它。它还产生了几个变体（你将在下一节查看组合排序，它实际上引出了一个表现更好的算法）。
- en: Bubble Sort
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 冒泡排序
- en: The bubble sort algorithm derives its name from the simple idea that larger
    numbers represent bubbles that bubble up to the top of the list. It starts at
    the beginning of the array and goes in order through all elements in the array,
    and if an element is greater than the following element, it swaps them (see [Figure
    6-3](chapter6.xhtml#fig6-3)).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序算法的名称来源于一个简单的概念，即较大的数字像气泡一样浮到列表的顶部。它从数组的开始位置开始，按顺序遍历数组中的所有元素，如果一个元素大于下一个元素，它就交换这两个元素（见[图6-3](chapter6.xhtml#fig6-3)）。
- en: '![](../images/Figure6-3.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-3.jpg)'
- en: 'Figure 6-3: With bubble sort, each pass moves another element to its place.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-3：在冒泡排序中，每次遍历都会将一个元素移到正确的位置。
- en: The first pass at the top of [Figure 6-3](chapter6.xhtml#fig6-3) goes from left
    to right, comparing adjacent values and swapping if needed so that the higher
    value is always to the right. After the first pass, 60 goes to the top of the
    array. You proceed in the same way with the rest of the array, and after the second
    pass, 56 goes to the next-to-last position, so you have at least two elements
    in the right place. After the third pass, three elements will be in place, and
    so on. The last two rows required no swapping, because previous passes had already
    moved the elements to the correct places, which frequently happens.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图6-3](chapter6.xhtml#fig6-3)的第一次遍历中，从左到右比较相邻的值，并在需要时交换它们，使得较大的值总是出现在右边。第一次遍历后，60被移到数组的顶部。接着以相同的方式处理数组的其余部分，第二次遍历后，56被移到倒数第二的位置，因此至少有两个元素已经到位。第三次遍历后，三个元素到位，以此类推。最后两行没有发生交换，因为之前的遍历已经将元素移到正确的位置，这种情况经常发生。
- en: 'Here’s the logic for this algorithm:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是该算法的逻辑：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'All sorting functions share the same signature: an array to sort (arr) and
    the limits for sorting (from, to) that, by default, will be the array’s extremes
    ❶. The outer loop ❷ goes from the right to the left; after each pass, the element
    in position j of the array will be in the right place. The inner loop ❸ goes from
    the left extreme to the right up to (but not reaching) the outer loop j; you compare
    each element with the next ❹, and if the second is smaller, you swap them.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 所有排序函数都具有相同的签名：一个待排序的数组（arr）和排序的限制（from，to），默认情况下是数组的极限❶。外层循环❷从右到左进行；每次遍历后，数组中位置j的元素将处于正确的位置。内层循环❸从左端开始遍历到外层循环j的位置（不包括j）；你将每个元素与下一个元素进行比较❹，如果第二个元素较小，就交换它们。
- en: You can improve performance in most sorted arrays (a not uncommon case) by checking
    whether any swaps occurred on each pass through the array. If none were detected,
    it means the array is in order (see question 6.7).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过检查每次遍历数组时是否发生了交换，来提高大多数已排序数组的性能（这种情况并不罕见）。如果没有检测到交换，说明数组已经是有序的（见问题6.7）。
- en: 'The performance of this algorithm is *O*(*n*²), which is easy to calculate.
    First count comparisons: the first pass does (*n* – 1) comparisons, the second
    pass does (*n* – 2), the third (*n* – 3), and so on. The total number of comparisons
    is then the sum of all numbers from (*n* – 1) down to 1, which is *n*(*n* – 1)
    / 2, so *O*(*n*²).  ##### Sinking Sort and Shuttle Sort'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '该算法的性能是*O*(*n*²)，计算起来很简单。首先计算比较次数：第一次遍历做了(*n* – 1)次比较，第二次遍历做了(*n* – 2)次比较，第三次做(*n*
    – 3)次，以此类推。所有比较次数的总和就是从(*n* – 1)到1的所有数之和，即*n*(*n* – 1) / 2，所以是*O*(*n*²)。 #####
    下沉排序与穿梭排序'
- en: Bubble sort quickly moves the greatest values to the end of an array, but the
    smallest values may take a while to reach their final positions. Similarly, *sinking
    sort* (see question 6.6) makes the lowest values quickly sink to the beginning
    of the array, but correspondingly, it takes longer for the greatest values to
    go to their places. You can alternate a pass of bubbling with a pass of sinking
    to get an enhanced algorithm, called *shuttle sort* (also known as *cocktail shaker
    sort* or *bidirectional* bubble sort). In comparison with bubble sort, the first
    passes of the shuttle sort proceed as shown in [Figure 6-4](chapter6.xhtml#fig6-4).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序迅速将最大的值移到数组的末尾，但最小的值可能需要一些时间才能到达最终位置。类似地，*下沉排序*（见问题6.6）将最小的值快速下沉到数组的开头，但相应地，最大值到达其位置的时间会更长。你可以交替进行冒泡遍历和下沉遍历，得到一个增强的算法，称为*穿梭排序*（也叫*鸡尾酒摇晃排序*或*双向*冒泡排序）。与冒泡排序相比，穿梭排序的前几次遍历如[图6-4](chapter6.xhtml#fig6-4)所示。
- en: '![](../images/Figure6-4.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-4.jpg)'
- en: 'Figure 6-4: Shuttle sort alternates left-to-right and right-to-left passes.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-4：穿梭排序交替进行从左到右和从右到左的遍历。
- en: Starting with the same elements, the first pass is the same as bubble sort’s,
    moving 60, which is the greatest value in the array, to the rightmost position.
    The second pass goes right to left and moves 04, the smallest value in the array,
    to the leftmost position. The third pass again goes left to right and moves 56
    to its place; after that, it goes right to left, then left to right, and so on,
    alternating direction every time.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 从相同的元素开始，第一次遍历与冒泡排序相同，将数组中最大的值 60 移动到最右端。第二次遍历从右到左，将数组中最小的值 04 移动到最左端。第三次遍历再次从左到右，将
    56 移动到其正确位置；之后，继续交替执行左到右和右到左的遍历，直到排序完成。
- en: 'Here’s the corresponding code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是相应的代码：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As mentioned earlier, the signature for this sort function is always the same:
    an array to sort and the portion to put in order ❶. You have two variables ❷ that
    mark how far to the left and right the array is already sorted: f (as in *from*)
    starts at the left and grows by 1 after each right-to-left pass, and t (as in
    *to*) starts at the right and decreases by 1 after each left-to-right pass. When
    these variables meet ❸, the sort is done. You perform a left-to-right pass as
    shown earlier ❹, and then you decrement t ❺, since you’ve placed a new value in
    the right place. After this pass, you do the same ❻, but right to left, and you
    increment f ❼ to finish.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这个排序函数的签名始终相同：一个要排序的数组和需要排序的部分 ❶。你有两个变量 ❷，标记数组已经排序到左边和右边的程度：f（来自*from*）从左边开始，每次从右到左遍历后增加
    1，而 t（来自*to*）从右边开始，每次从左到右遍历后减少 1。当这两个变量相遇 ❸ 时，排序完成。你首先执行如前所示的从左到右遍历 ❹，然后减少 t ❺，因为你已经将一个新值放到了正确的位置。之后，你执行同样的操作
    ❻，但顺序是从右到左，然后增加 f ❼ 来完成。
- en: The algorithm is still *O*(*n*²), but the actual implementation typically is
    double the speed or even better if you include testing for swaps (see question
    6.7). In any case, it’s easy to show that it can’t do any worse, for in each pass,
    it places one number at its final position, so after having placed (*n* – 1) numbers
    at their place, it will be done, the same as bubble sort.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法的时间复杂度仍然是 *O*(*n*²)，但实际实现通常速度是原来的两倍，甚至更快，如果你包括交换测试（参见问题 6.7）。无论如何，很容易证明它不能做得更差，因为在每次遍历中，它都会将一个数字放到最终位置，所以在将
    (*n* – 1) 个数字放到它们的位置之后，排序就完成了，这与冒泡排序相同。
- en: Nevertheless, despite the catchy name, this sort algorithm is not good enough
    in comparison with those that we’ll explore later in the chapter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管有个引人注目的名字，这种排序算法与我们在本章后面将要探讨的算法相比，还是不够优秀。
- en: Sorting Strategies for Playing Cards
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 扑克牌排序策略
- en: 'Thinking about how you do simple tasks can provide tips for developing an algorithm.
    For example, suppose you have a few playing cards in your hand and want to order
    them from lowest to highest. You could apply a couple of different strategies,
    which we’ll look at next: selection sort or insertion sort.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 思考如何完成简单的任务可以为开发算法提供一些提示。例如，假设你手里有几张扑克牌，想要按从低到高的顺序排列它们。你可以应用几种不同的策略，我们接下来将讨论：选择排序或插入排序。
- en: Selection Sort
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 选择排序
- en: 'A simple solution is to look for the lowest card and place it farthest to the
    left in your hand. Then look for the next lowest card and place it after the first,
    and keep doing that, always selecting the lowest remaining card and placing it
    next to the already sorted cards. This process is the basis for the *selection
    sort* algorithm, which adds a small detail: when placing a card to the left, you
    do a swap with the other card (see [Figure 6-5](chapter6.xhtml#fig6-5)).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的解决方案是寻找最小的牌并将其放置在手中最左边的位置。然后寻找下一个最小的牌并将其放在第一张之后，继续这样做，总是选择剩下的最小牌并将其放置在已经排序的牌旁边。这个过程就是
    *选择排序* 算法的基础，且它添加了一个小细节：当将一张牌放到左边时，你需要与另一张牌交换位置（参见 [图 6-5](chapter6.xhtml#fig6-5)）。
- en: '![](../images/Figure6-5.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-5.jpg)'
- en: 'Figure 6-5: Selection sort looks for the smallest element and swaps it to get
    it into place.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-5：选择排序通过查找最小元素并交换其位置来完成排序。
- en: In the first pass at the top, you find that the minimum number is 04, and you
    do a swap to move it to the first place in the array. The second pass finds 09
    and swaps it with 12, so you now have two numbers in order. The process continues
    the same way; an exception is in the next-to-last line, in which no swap is needed
    because 56 was already in the correct place.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在最上面的第一次遍历中，你找到最小的数字是 04，并交换将其移到数组的第一个位置。第二次遍历找到 09，并与 12 交换，现在你已经有了两个有序的数字。之后的过程保持相同，唯一的例外是在倒数第二行，在这一步中不需要交换，因为
    56 已经在正确的位置。
- en: 'Here’s an implementation:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个实现：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Go in order ❶ from the first place in the array to the last. The m variable
    ❷ keeps track of the position of the minimum value already found. As you loop
    through the yet unsorted numbers ❸, if you find a new minimum candidate ❹, you
    update m. After finishing this loop, if the minimum isn’t already in place ❺,
    do a swap.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 按照顺序❶从数组的第一个位置到最后一个位置。变量m❷跟踪已经找到的最小值的位置。当你循环处理未排序的数字❸时，如果找到新的最小值候选者❹，就更新m。完成这个循环后，如果最小值还没有排好位置❺，就进行交换。
- en: The order of this algorithm is, again, *O*(*n*²). You have to look at *n* elements
    to find what should go in the first place; then look at *n* – 1 for the second
    place, *n* – 2 for the third, and so on. You already know this sum is *O*(*n*²).
    The algorithm in the next section is also based on how you’d sort playing cards,
    but it has slightly better performance.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法的时间复杂度仍然是*O*(*n*²)。你需要查看*n*个元素来找出应该放在第一位的数；然后看*n*–1个元素找出第二位的数，依此类推。你已经知道这个总和是*O*(*n*²)。下一节中的算法也是基于如何排序扑克牌，但它的性能稍好。
- en: Insertion Sort
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 插入排序
- en: With selection sort, we thought about sorting playing cards, but you could have
    considered another method. Take the first card; that’s clearly already in order
    by itself. Now look at the second card, and either place it before the first (if
    it’s lower) or leave it where it is (if it’s higher). You now have two cards in
    order. Look at the third card, decide where it should go among the previous two,
    and place it there. As you go through all the cards in your hand, you’ll end up
    putting them in order, and this is called an *insertion sort*, because of the
    way you insert new cards among the previously sorted ones (see [Figure 6-6](chapter6.xhtml#fig6-6)).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择排序中，我们想到了排序扑克牌，但你也可以考虑其他方法。拿起第一张牌；显然它已经是排序好的了。现在看第二张牌，要么把它放在第一张牌之前（如果它较小），要么保持它原位（如果它较大）。现在你已经有了两张排序好的牌。看第三张牌，决定它应该放在前两张牌中的哪个位置，然后将它放到那里。当你处理完手中的所有牌后，你会发现它们已经排好序了，这就是所谓的*插入排序*，因为你是通过将新牌插入到已经排序好的牌中来排序的（见[图6-6](chapter6.xhtml#fig6-6)）。
- en: '![](../images/Figure6-6.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-6.jpg)'
- en: 'Figure 6-6: Sorting by insertion works the way one sorts playing cards.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-6：插入排序的工作原理就像排序扑克牌一样。
- en: Start with a single card in order, in this case, number 34\. Then consider the
    next value, 12, and place it to the left of 34, so the two numbers are in order.
    Then consider 22, which goes between 12 and 34, and now three values are ordered.
    Continue working this way, always inserting the next number where it belongs among
    the previously sorted ones, until you reach the last line. After placing 14 among
    the already sorted numbers, the whole array becomes ordered.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从一张已排序的牌开始，这里是数字34。然后考虑下一个数值12，把它放在34的左边，这样两张牌就排好了。接下来考虑22，它放在12和34之间，现在三个数值已经排序好。继续这样操作，总是把下一个数放在已经排序好的牌中，直到最后一张牌。将14放入已排序的牌中后，整个数组就变得有序了。
- en: 'The following code implements this method:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码实现了这个方法：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Set up a loop that starts at the second place in the array and goes to the end
    ❶, and loop back as long as the list isn’t in order ❷, swapping to get new numbers
    in place ❸.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个循环，从数组的第二个位置开始，一直到最后❶，然后在列表没有排序好的情况下继续循环❷，通过交换将新数值放到正确的位置❸。
- en: Looking at this carefully, you’ll notice it’s doing too many swaps to get the
    new element to its place.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察，你会发现它进行了过多的交换才能把新元素放到正确的位置。
- en: 'You can quickly optimize the code to avoid that and do just one swap per loop:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以快速优化代码，避免多次交换，每次循环只做一次交换：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first loop ❶ is exactly the same as earlier, but the difference lies within.
    You set the number to be inserted among the previously sorted aside ❷, and you
    loop to find where it should go ❸, pushing values that are greater to the right.
    At the end ❹, you place the new value in its final position.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个循环❶和之前一样，但是区别在于其中的操作。你将要插入的数值从已排序的数组中取出❷，然后循环找出它应该放在哪个位置❸，并将大于它的数值往右推。最后❹，你把新值放在它的最终位置。
- en: Insertion sort is a simple algorithm, which makes it a good choice for smaller
    arrays. Later in the chapter we’ll look at how it’s sometimes used in hybrid sorting
    algorithms as a replacement for theoretically more convenient, but practically
    slower, alternative methods.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 插入排序是一个简单的算法，这使得它在处理较小的数组时是一个不错的选择。章节后面我们将讨论它如何在混合排序算法中使用，作为理论上更方便但实际上较慢的替代方法的替代品。
- en: Making Bigger Jumps with Comb and Shell Sort
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用梳状排序和希尔排序进行更大的跳跃
- en: Bubble sort and its variants are not the best-performing sorting algorithms.
    However, the idea of swapping elements to make them bubble up or sink down isn’t
    bad, and applying the idea of making larger jumps (for example, swapping elements
    that are farther apart) eventually leads to a better algorithm, *Shell sort*.
    You’ll explore this idea with a bubble sort variant called *comb sort* first.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序及其变种不是性能最好的排序算法。然而，将元素交换使其上浮或下沉的想法并不坏，应用这种思想让元素做更大的跳跃（例如，交换更远的元素）最终会得到一个更好的算法，即*Shell排序*。你将首先通过一个名为*梳排序*的冒泡排序变种来探索这个思想。
- en: Comb Sort
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 梳排序
- en: Let’s go back to bubble sort and consider how keys move in an array like rabbits
    and turtles. Rabbits represent the large values near the beginning of the list,
    which quickly move to their places at the end of the array, swap after swap. On
    the other hand, turtles represent the small values near the end of the list, which
    slowly move to their places in a single swap per pass. You want both turtles and
    rabbits to move quickly to their respective sides of the array.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回到冒泡排序，考虑数组中的元素如何像兔子和乌龟一样移动。兔子代表位于列表前部的较大值，它们会快速通过一次次交换跳到数组末尾的正确位置。另一方面，乌龟代表位于列表后部的较小值，它们会慢慢地通过每次遍历交换移动到正确的位置。你希望兔子和乌龟都能迅速地各自移动到数组的两侧。
- en: The idea is to perform some passes with swaps, but instead of comparing one
    element with the next one, you’ll consider larger gaps. Thus, rabbits will jump
    further distances toward the right, but turtles will correspondingly jump further
    distances toward the left. You’ll do passes with successively smaller gaps, and
    when the gap becomes 1, you’ll apply the common bubble sort to finish.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个思想是进行一些交换操作的遍历，但与其将元素与下一个元素比较，不如考虑更大的间隔。因此，兔子会跳得更远，而乌龟则相应地跳得更远。你将以逐渐减小的间隔进行遍历，当间隔变为1时，你就应用常规的冒泡排序来完成。
- en: 'The logic is as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑如下：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It has been determined empirically that the first gap should equal the array’s
    length divided by 1.3, the “shrink factor” ❶, and successive gaps will always
    be 1.3 times smaller ❷. When the gap becomes 1 ❸, just apply bubble sort, and
    you’re done. While the gap is greater than 1 ❹, you do what’s essentially the
    central logic of bubble sort, but instead of comparing elements one place apart,
    you compare elements gap places apart.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过经验确定，第一个间隔应该等于数组长度除以1.3，即“收缩因子”❶，后续的间隔将始终是前一个间隔的1.3倍❷。当间隔变为1❸时，直接应用冒泡排序，任务完成。当间隔大于1❹时，你需要做的本质上是冒泡排序的核心逻辑，只不过不是比较相邻元素，而是比较间隔为“gap”的元素。
- en: Comb sort usually performs better than bubble sort, but it’s still *O*(*n*²)
    in the worst case and becomes *O*(*n* log *n*) in the best case. However, that’s
    not why we’re considering this idea; rather, the concept of sorting elements that
    are far apart provides real benefits, and you’ll see that Shell sort that does
    exactly that in a way similar to comb sort.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 梳排序通常比冒泡排序表现更好，但它在最坏情况下仍然是*O*(*n*²)，而在最好情况下变成*O*(*n* log *n*)。然而，我们考虑这个思想的原因并不是这个；而是排序远距离元素的概念带来了实际的好处，你会发现Shell排序正是以类似梳排序的方式做到了这一点。
- en: Shell Sort
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Shell排序
- en: To understand how Shell sort works, assume you want to order the array shown
    in [Figure 6-7](chapter6.xhtml#fig6-7).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解Shell排序的工作原理，假设你想对[图6-7](chapter6.xhtml#fig6-7)所示的数组进行排序。
- en: '![](../images/Figure6-7.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-7.jpg)'
- en: 'Figure 6-7: Shell sort works similarly to insertion sort, but with larger gaps.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-7：Shell排序类似于插入排序，但具有更大的间隔。
- en: In the first pass, do an insertion sort, but for elements set four places apart,
    which leads to an array consisting of four short-ordered sequences. Then lower
    the gap size to 2 and repeat the sort. The array now consists of two ordered sequences.
    Eventually, you reach a gap size of 1, and in that case, you’re just doing an
    insertion sort, but because of the previous partial sorts, it doesn’t do as many
    comparisons or swaps as with the normal algorithm, which is the advantage of Shell
    sort.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次遍历中，进行插入排序，但是元素之间间隔为四个位置，这样会得到一个由四个短序列组成的数组。然后将间隔大小降低为2，重复排序。此时，数组由两个有序序列组成。最终，你会将间隔大小降到1，到那时你就只是在进行插入排序，但由于前面的部分排序，它不会像正常算法那样进行那么多的比较或交换，这就是Shell排序的优势。
- en: 'Here’s the Shell sort implementation:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Shell排序的实现：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First select what gaps to use ❶, keeping in mind that the last one to be applied
    must be 1\. You’ll find many suggestions online as to which sequence to use, but
    this example will use Knuth’s proposal (1, 4, 13, 40, 121, . . . , with each term
    being triple the previous one, plus 1), which leads to an *O*(*n*^(1.5)) algorithm.
    Then, you take gaps in decreasing order ❷ and essentially do an insertion sort
    ❸ but for elements gap spaces apart ❹. With larger gaps, you’re ordering sequences
    of fewer elements, but as you decrease the gap size, you deal with longer sequences
    that tend to be almost in order, so insertion sort behaves well.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先选择要使用哪些间隔 ❶，记住最后应用的间隔必须是 1。你会在网上找到许多关于使用哪种间隔序列的建议，但本例将使用 Knuth 提出的序列（1, 4,
    13, 40, 121, ...，每个数字是前一个数字的三倍再加 1），这种序列会导致一个 *O*(*n*^(1.5)) 的算法。然后，按降序顺序选择间隔
    ❷，并实质上进行插入排序 ❸，不过是对间隔为该数值的元素进行排序 ❹。当间隔较大时，你排序的是较少元素的序列，但随着间隔的减小，你处理的序列会更长，而这些序列通常已经接近有序，因此插入排序表现良好。
- en: Going for Speed with Quicksort
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 提升快速排序的速度
- en: Let’s move on to the quicker algorithms that achieve the *O*(*n* log *n*) theoretical
    speed limit—albeit with a problematic worst-case quadratic performance! *Quicksort*
    (also known as *partition-exchange sort*) was created by Tony Hoare in the 1960s
    and is a divide-and-conquer algorithm with high speed. We’ll consider the standard
    version first and then discuss some possible enhancements.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看更快的算法，它们达到了 *O*(*n* log *n*) 的理论速度限制——尽管在最坏情况下，性能呈二次方增长！*快速排序*（也称为*分区交换排序*）由
    Tony Hoare 在 1960 年代创造，是一种分治算法，具有高速度。我们首先考虑标准版本，然后讨论一些可能的改进。
- en: Standard Version
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 标准版本
- en: How does quicksort work? The idea is first to select a “pivot” element from
    the array to be sorted and redistribute all the other elements in two subarrays,
    according to whether they are smaller or larger than the pivot. The array ends
    with lower values first, then the pivot, and then higher values. Then, each subarray
    is sorted recursively, and when that’s done, the whole array is sorted (see [Figure
    6-8](chapter6.xhtml#fig6-8)).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序是如何工作的？其基本思路是首先从待排序数组中选择一个“枢轴”元素，并根据元素是否小于或大于枢轴，将其他所有元素分布到两个子数组中。排序后的数组以较小的值为前，接着是枢轴，最后是较大的值。然后，递归地排序每个子数组，等到所有子数组都排好序，整个数组也就排序完成了（见[图
    6-8](chapter6.xhtml#fig6-8)）。
- en: '![](../images/Figure6-8.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-8.jpg)'
- en: 'Figure 6-8: Quicksort works by partitioning arrays and recursively sorting
    the parts.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-8：快速排序通过划分数组并递归地对各部分进行排序来实现。
- en: Let’s say we always choose the rightmost element of the array as the pivot.
    (It won’t prove to be a very wise option, as you’ll see.) In this case, the first
    choice is 14, and you rearrange the array so all values less than 14 come first,
    then 14 itself, and finally all values greater than 14\. The same procedure (select
    the pivot, rearrange, and sort recursively) is applied to each subarray until
    the whole array is sorted.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们始终选择数组中最右侧的元素作为枢轴。（这不会是一个明智的选择，正如你将看到的那样。）在这种情况下，第一个选择是 14，然后重新排列数组，使得所有小于
    14 的值排在前面，接着是 14 本身，最后是所有大于 14 的值。相同的过程（选择枢轴、重新排列并递归排序）应用于每个子数组，直到整个数组排序完成。
- en: 'Here’s a direct implementation of the procedure:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该过程的直接实现：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: First, check whether there’s actually anything to sort; if the left pointer
    is equal to or greater than the right one, you’re done ❶. The rightmost element
    will be the pivot ❷. Next, go through the array from left to right ❸ in a fashion
    reminiscent of the insertion sort, exchanging elements if needed so smaller elements
    move to the left, greater ones to the right, and the pivot ends at position p
    ❹. It would be a good idea to simulate a run of the pivoting code by hand. Despite
    its short length, it’s a bit tricky to get right. (What happens if the pivot value
    appears several times in the array? See question 6.10.) Finally, apply recursion
    to sort the two partitions ❺.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，检查是否真的有需要排序的内容；如果左指针大于或等于右指针，说明已经完成 ❶。最右侧的元素将是枢轴 ❷。接下来，从左到右遍历数组 ❸，以类似插入排序的方式交换元素，确保较小的元素移到左边，较大的元素移到右边，枢轴最终位于位置
    p ❹。手动模拟枢轴代码的执行过程是个好主意。尽管代码简短，但要正确实现它还是有点棘手的。（如果枢轴值在数组中出现多次，会发生什么？参见问题 6.10。）最后，使用递归对两个分区进行排序
    ❺。
- en: Analysis shows that *on average*, quicksort works in *O*(*n* log *n*) time.
    However, the worst case is easy to find. Consider sorting an already sorted (in
    ascending or descending order) array. Examining the code shows that partitioning
    will always end with just one subarray, and you’ll have the equivalent of a selection
    sort or bubble sort, which means performance goes down to *O*(*n*²). But you can
    fix that.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 分析表明，*平均而言*，快速排序的时间复杂度是 *O*(*n* log *n*)。然而，最坏情况是很容易找到的。考虑对一个已经排序好的（升序或降序）数组进行排序。检查代码后发现，划分操作总是会以只有一个子数组的形式结束，这就等同于选择排序或冒泡排序，意味着性能会降至
    *O*(*n*²)。但你可以修复这个问题。
- en: Pivot Selection Techniques
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 枢轴选择技巧
- en: How you choose the pivot can have a serious impact on quicksort’s performance.
    In particular, if you always choose the largest (or smallest) element in the array,
    you’ll get a negative hit in speed, so consider some alternative pivot-selecting
    techniques.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 枢轴的选择对快速排序的性能有着重大影响。特别是，如果你总是选择数组中最大的（或最小的）元素，排序速度会受到负面影响，因此请考虑一些替代的枢轴选择技巧。
- en: 'The first solution to avoid problems with sorted arrays is to choose the pivot
    randomly. Select a random position between left and right inclusive and, if needed,
    swap the selected element to move it to the rightmost position, so you can go
    on with the rest of the algorithm without any further changes:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 避免已排序数组问题的第一个解决方案是随机选择枢轴。选择左侧和右侧之间的一个随机位置（包括边界），如果需要，将选中的元素交换到最右侧位置，然后继续执行算法的其他部分，而不做进一步的修改：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We’ll look at random selection in more detail in [Chapter 8](chapter8.xhtml),
    but the way you calculate iPivot (the position of the pivot) ❶ selects a value
    from left to right inclusive with equal odds. The rest of the sorting algorithm
    assumes that the chosen pivot was at the right of the array, so if the chosen
    pivot is elsewhere ❷, just do a swap.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第8章](chapter8.xhtml)中更详细地讨论随机选择，但你计算iPivot（枢轴位置）❶的方式会从左到右（包括边界）以相等的概率选择一个值。排序算法的其余部分假设所选枢轴在数组的右侧，因此，如果选中的枢轴在其他位置❷，只需进行交换。
- en: This random selection solves the worst-case behavior for almost-sorted arrays,
    but there’s still the (assuredly low) probability that you’ll always just happen
    to pick the highest or lowest value in the array to be sorted, and in that case,
    performance will suffer.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个随机选择解决了几乎已排序数组的最坏情况，但仍然存在（虽然概率很低）你总是刚好选到数组中最大的或最小的值的可能性，在这种情况下，性能会受到影响。
- en: 'What’s the ideal pivot? Choosing the array’s median (the value that splits
    the array in two) would be optimum. A rule that comes close is called the *median
    of three*: choose the median of the left, middle, and right elements of the array:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 理想的枢轴是什么？选择数组的中位数（即将数组分成两部分的值）是最优的。一条接近的规则叫做*三数中位数*：选择数组中左边、中央和右边元素的中位数：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Testing this code with all possible permutations of three values shows that
    arr[right] always ends with the middle value. Even better, you might pick the
    “ninther,” defined as a “median of medians”: divide the array in three parts,
    apply the median of three to each third, and then take the median of those three
    values.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个代码进行测试，使用三个值的所有可能排列，结果表明`arr[right]`总是以中间值结束。更好的是，你可以选择“第九分位数”，定义为“中位数的中位数”：将数组分成三部分，对每一部分应用三数中位数算法，然后取这三者的中位数。
- en: You can help quicksort become faster by selecting pivots carefully, but you
    can enhance it even further.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通过仔细选择枢轴，你可以帮助快速排序变得更快，但你还可以进一步优化它。
- en: Hybrid Version
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 混合版本
- en: 'Quicksort is fast, but all the pivots and recursion have an impact on running
    times, so for small arrays, a combination of simpler algorithms may actually perform
    faster. You can apply a *hybrid algorithm* that uses two distinct methods together.
    For instance, you may find that for arrays under a certain cutoff limit, an insertion
    sort performs better, so whenever you want to sort an array smaller than the limit,
    switch to that algorithm:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序很快，但所有的枢轴和递归都会影响运行时间，因此对于小数组，简单算法的组合可能实际表现得更快。你可以应用一种*混合算法*，将两种不同的方法结合使用。例如，你可能会发现，对于某个特定的数组大小阈值，插入排序表现更好，因此每当你想对一个小于该阈值的数组进行排序时，就切换到该算法：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The lines in bold are all you need to change. Define the cutoff limit, and when
    sorting, if the array is small enough, apply the alternative sort.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 粗体部分是你需要更改的所有内容。定义截止值，然后在排序时，如果数组足够小，应用替代排序方法。
- en: Dual-Pivot Version
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 双枢轴版本
- en: You can extend the idea of splitting an array to be sorted in two parts, separated
    by a pivot, to splitting the array in three parts, separated by two pivots. This
    dual-pivot version is usually faster. (Java uses it as its default sorting algorithm
    for primitive types.) Choose the leftmost and rightmost elements as pivots, as
    shown in [Figure 6-9](chapter6.xhtml#fig6-9).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将将数组分为两部分并由一个枢轴分隔的思想，扩展为由两个枢轴分隔的三部分。这个双枢轴版本通常更快。（Java 使用它作为原始数据类型的默认排序算法。）选择最左和最右的元素作为枢轴，如
    [图 6-9](chapter6.xhtml#fig6-9) 所示。
- en: '![](../images/Figure6-9.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-9.jpg)'
- en: 'Figure 6-9: Dual-pivot sort is like quicksort, but it splits the array in three
    parts instead of two.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-9：双枢轴排序类似于快速排序，但它将数组分成三部分而不是两部分。
- en: Start by choosing 34 and 14 as pivots, and rearrange the array so that all values
    less than 14 (12, 9, 4) come first, then 14 itself, then values between 14 and
    34 (just 22), then 34, and finally values greater than 34 (60, 56). Each subarray
    is then sorted again with the same method.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从选择 34 和 14 作为枢轴开始，并重新排列数组，使得所有小于 14 的值（12、9、4）排在前面，然后是 14 本身，然后是介于 14 和 34
    之间的值（只有 22），接着是 34，最后是大于 34 的值（60、56）。然后，每个子数组使用相同的方法再次排序。
- en: 'The algorithm is similar to a basic quicksort; the main differences are in
    the selection of pivots and partitioning. For performance reasons, you’ll use
    the hybrid approach and turn to an insertion sort if the array to be sorted is
    small enough; for example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法类似于基本的快速排序；主要区别在于枢轴的选择和分区。出于性能考虑，当要排序的数组足够小时，你将采用混合方法，并转为插入排序；例如：
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You’re choosing the leftmost and rightmost elements as pivots, but, of course,
    you could take any two values and swap them so they end up in the extremes of
    the array, with the smaller on the left ❶. (Actually, when dealing with arrays
    nearly in order, choosing two middle elements is better.) Next, you start swapping
    elements, maintaining these invariants:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择最左侧和最右侧的元素作为枢轴，但当然，你可以选择任意两个值并交换它们，使它们最终位于数组的两端，较小的值在左 ❶。（实际上，当处理几乎有序的数组时，选择两个中间元素更好。）接下来，你开始交换元素，保持以下不变式：
- en: pivotLeft is at the left of the array.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pivotLeft 位于数组的左侧。
- en: From positions left + 1 to ll - 1, all values are less than pivotLeft.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从位置 left + 1 到 ll - 1，所有值都小于 pivotLeft。
- en: From positions ll to mm - 1, all values are strictly between pivotLeft and pivotRight.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从位置 ll 到 mm - 1，所有值严格位于 pivotLeft 和 pivotRight 之间。
- en: From positions mm to rr, the status of values is yet unknown.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从位置 mm 到 rr，值的状态尚未确定。
- en: From positions rr + 1 to right - 1, the values are greater than pivotRight.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从位置 rr + 1 到 right - 1，所有值都大于 pivotRight。
- en: pivotRight is at the right of the array.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pivotRight 位于数组的右侧。
- en: You can establish this invariant from the beginning by setting mm to left +
    1 and making it go up until it reaches the end of the array ❷. If the element
    at mm is less than pivotLeft ❸, a mere swap maintains the invariant. If the element
    at mm is greater than pivotRight ❹, you have to do a bit more work to maintain
    the invariant, moving rr to the left. (Remember, the idea is to keep the invariants;
    this loop ensures the next-to-last one.) After the loop is done ❺, swap the pivots
    to their final places and apply recursion to sort the three partitions ❻.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过从一开始就设定 mm 为 left + 1 并让它逐步增大直到到达数组末尾 ❷，来建立这个不变式。如果 mm 处的元素小于 pivotLeft
    ❸，仅需要交换即可保持不变式。如果 mm 处的元素大于 pivotRight ❹，你需要做更多的工作来保持不变式，将 rr 向左移动。（记住，目标是保持不变式；这个循环确保了倒数第二个不变式。）循环完成后
    ❺，交换枢轴到它们的最终位置，并应用递归对三个分区进行排序 ❻。
- en: Quicksort is a great algorithm with several variants, but it always comes with
    the possibility (albeit remote) of bad performance.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序是一个非常好的算法，有多种变体，但它总是存在着（尽管很小）性能不佳的可能性。
- en: Merging for Performance with Merge Sort
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用归并排序提升性能
- en: We’ll wrap up our study of comparison-based sorts with the *merge sort* algorithm
    that guarantees a constant performance, but with the cost of a higher need for
    memory. Merge sort basically does all sorting by merging. If you have two ordered
    sequences of values, *n* in total, merging them into a single-order sequence can
    be done in an *O*(*n*) process. The key idea of a merge sort is to apply recursion.
    First, split the array to be sorted into two halves, then recursively sort each
    half, and finally merge both ordered halves into a single sequence (see [Figure
    6-10](chapter6.xhtml#fig6-10)).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过*归并排序*算法来结束我们的比较类排序学习，归并排序能够保证稳定的性能，但代价是需要更高的内存。归并排序基本上通过合并来完成所有排序。如果你有两个已排序的值序列，总共*n*个元素，将它们合并成一个有序序列可以通过*O*(*n*)的过程完成。归并排序的关键思想是应用递归。首先，将待排序的数组分成两半，然后递归地排序每一半，最后将两个已排序的部分合并成一个有序序列（见[图6-10](chapter6.xhtml#fig6-10)）。
- en: '![](../images/Figure6-10.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-10.jpg)'
- en: 'Figure 6-10: Merge sort splits the array into two parts, sorts them, and ends
    by merging them.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-10：归并排序将数组分成两部分，对其排序，然后通过合并它们结束。
- en: Each array to be sorted is split into two parts, which are sorted and then joined
    back together. To sort an 8-element array, you need to sort two 4-element arrays,
    which means you have to sort four 2-element arrays, and that requires sorting
    eight 1-element arrays. Sorting the latter is trivial (nothing to do), and doing
    the merge reconstructs the original array.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 每个待排序的数组都会被分成两部分，分别排序后再合并。要排序一个8元素的数组，你需要先排序两个4元素的数组，这意味着你需要排序四个2元素的数组，而这又需要排序八个1元素的数组。排序后者非常简单（不用做任何事），而合并过程则重新构建了原数组。
- en: 'Here’s a recursive implementation:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个递归实现：
- en: '[PRE17]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'First, check whether you even need to sort ❶, which could include a hybrid
    approach, and if the array is small enough, you’d apply some other method, not
    merge sort. Then split the array in half ❷ and recursively sort each half ❸. Next,
    merge both sorted arrays ❹: ll and rr will traverse each array, and the output
    will go into the original array. Finally, return the sorted array.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，检查是否需要排序❶，这可能包括一种混合方法，如果数组足够小，你可以采用其他方法，而不是归并排序。然后将数组分成两半❷，并递归地排序每一半❸。接下来，合并两个已排序的数组❹：ll和rr将遍历每个数组，输出将放入原数组中。最后，返回排序后的数组。
- en: Merge sort has very good performance (despite the extra space needed to perform
    the merge), and it’s actually the basis of *Tim sort*, a stable adaptive method
    that’s widely used. Java utilizes it, JavaScript also applies it in the V8 engine,
    and other languages use it as well. We won’t delve into the actual implementation,
    as the algorithm is quite longer than the ones we’ve been considering (a couple
    of implementations in GitHub run to almost 1,000 lines each). Tim sort takes advantage
    of runs of elements that are already in order, merging shorter runs to create
    longer ones, and applying an insertion sort to make sure runs are long enough.
    You’ve already studied all the pieces that make up the complete Tim sort algorithm.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 归并排序具有非常好的性能（尽管执行合并时需要额外的空间），它实际上是*Tim排序*的基础，Tim排序是一种稳定的自适应方法，广泛应用于各种场景。Java采用了它，JavaScript也在V8引擎中应用了它，其他语言也使用它。我们不打算深入探讨其实际实现，因为这个算法比我们之前考虑的算法要长得多（GitHub上的几个实现几乎有1,000行代码）。Tim排序利用了已经有序的元素序列，通过合并较短的序列来生成更长的序列，并应用插入排序来确保序列足够长。你已经学习了构成完整Tim排序算法的所有部分。
- en: NOTE
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*There’s more to learn about comparison-based sorting methods, but we’ll postpone
    considering more algorithms until we’ve seen some data structures. In [Chapter
    14](chapter14.xhtml) we’ll explore priority queues and heaps. Likewise, in [Chapter
    12](chapter12.xhtml) we’ll study binary trees and, in particular, binary search
    trees. By adding all elements to be sorted into such a structure, you can traverse
    it in order later, thus producing another sort, although the performance and relative
    complexity of that solution don’t make it very attractive. Binary search trees
    are more oriented toward searching; sorting is just a* *by-product. In the same
    way, other structures such as skip lists (which we’ll analyze in [Chapter 11](chapter11.xhtml))
    could also provide a sorting method, but as with binary search trees, sorting
    isn’t the intended goal.*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*关于基于比较的排序方法还有更多内容可以学习，但我们将在看到一些数据结构之前推迟考虑更多的算法。在[第14章](chapter14.xhtml)中，我们将探索优先队列和堆。同样，在[第12章](chapter12.xhtml)中，我们将学习二叉树，特别是二叉搜索树。通过将所有要排序的元素添加到这样的结构中，你可以稍后按顺序遍历它，从而产生另一种排序方法，尽管这种解决方案的性能和相对复杂性使得它并不特别吸引人。二叉搜索树更侧重于搜索；排序只是一个*副产品*。同样，像跳表这样的其他结构（我们将在[第11章](chapter11.xhtml)中分析）也可以提供一种排序方法，但和二叉搜索树一样，排序并不是它的主要目的。*'
- en: Sorting Without Comparisons
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无需比较的排序
- en: In the previous section, all of the sorting algorithms depended on comparing
    keys and using that information to move, swap, or partition values. But there
    are other ways to sort. As an example, imagine you’re in charge of customer assistance
    and receive email for many different reasons. How can you simplify the classification
    task? You could use a different email address for each category so that messages
    are automatically sorted into the correct bins for processing.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，所有的排序算法都依赖于比较键值，并利用这些信息来移动、交换或划分值。但还有其他的排序方法。例如，假设你负责客户支持并且收到许多不同原因的电子邮件。如何简化分类任务呢？你可以为每个类别使用不同的电子邮件地址，这样消息就会自动被分类到正确的处理箱中。
- en: This simple solution provides a glimmer of what we’re going to do. Basically,
    you won’t compare keys; instead, you’ll use their values to figure out where they
    should go in the final, ordered list. It’s not always possible, but if you can
    apply the methods here, performance becomes *O*(*n*), which is impossible to beat.
    After all, no algorithm can sort *n* values without at least looking at them once,
    and that’s already an *O*(*n*) process. In this section, we’ll consider a couple
    of methods, *bitmap sort* and *counting sort*, and we’ll also look at a very old
    sorting method, *radix sort*, whose origins are on par with tabulating machines
    that used punched cards to do census work.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的解决方案展示了我们将要做的事情。基本上，你不会比较键值；相反，你将利用它们的值来确定它们在最终排序列表中的位置。这并非总是可能的，但如果你能应用这里的方法，性能将变为*O*(*n*)，这是无法超越的。毕竟，没有算法可以在不至少看一次这些值的情况下对*n*个值进行排序，而这本身就是一个*O*(*n*)的过程。在这一节中，我们将考虑几种方法，*位图排序*和*计数排序*，我们还会看看一种非常古老的排序方法，*基数排序*，它的起源与使用打孔卡片做普查工作的制表机相当。
- en: Bitmap Sort
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 位图排序
- en: Let’s start with a sorting method that has excellent performance but some limitations,
    if you can live with them. We have to make three suppositions. First, you’re going
    to sort only numbers on their own (no key + data). Second, you know the possible
    range of numbers, and it’s not very big. (For instance, if all you knew was that
    they were 64-bit numbers, the range from lowest to highest numbers would make
    you forget about attempting this algorithm.) And, third, the numbers are never
    going to be duplicated; all numbers to sort will be different.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一种性能优秀但有一些限制的排序方法开始，如果你能接受这些限制的话。我们必须做出三个假设。首先，你将只对数字进行排序（没有键+数据）。其次，你知道数字的可能范围，而且范围不是很大。（例如，如果你只知道它们是64位数字，那么从最低到最高的数字范围就会让你放弃尝试这个算法。）第三，这些数字不会重复；所有要排序的数字都是不同的。
- en: With these (too many) restrictions in mind, you can easily use a bitmap. Assume
    you are starting with all bits turned off, and whenever you read a number, set
    that bit to on. After you’re done, go through the bits in order, and whenever
    a bit is set, output the corresponding number, and you’re done (see [Figure 6-11](chapter6.xhtml#fig6-11)).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些（太多的）限制，你可以轻松地使用位图。假设你从所有位都关闭开始，每当你读取一个数字时，就将该位设置为开启。完成后，按照顺序检查这些位，每当某一位被设置时，就输出对应的数字，完成排序（见[图6-11](chapter6.xhtml#fig6-11)）。
- en: '![](../images/Figure6-11.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-11.jpg)'
- en: 'Figure 6-11: Bitmap sort takes advantage of knowing the range of values to
    be sorted.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-11：位图排序利用了已知要排序的值的范围。
- en: You must go through all the numbers to find the minimum and maximum values to
    define the size of the bitmap. After that, go through the numbers again, setting
    bits whenever a number appears. In [Figure 6-11](chapter6.xhtml#fig6-11), bits
    corresponding to numbers 22, 24, 25, 27, 28, and 31 are set. (JavaScript mandates
    that all arrays start at position 0, so you have to remember that position 0 actually
    corresponds to key 22, position 1 to key 23, and so on.) Finally, go through the
    bitmap, outputting the numbers whose bits are set; it’s simple.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须遍历所有数字，找到最小值和最大值，以定义位图的大小。之后，再次遍历这些数字，每当一个数字出现时，就设置一个标志位。在[图 6-11](chapter6.xhtml#fig6-11)中，设置了与数字
    22、24、25、27、28 和 31 对应的位。 (JavaScript 规定所有数组从位置 0 开始，因此你需要记住位置 0 实际上对应键 22，位置
    1 对应键 23，依此类推。) 最后，遍历位图，输出那些标志位被设置的数字；这很简单。
- en: 'This algorithm is limited, but it’s the basis for a different, enhanced algorithm.
    For simplicity, this example will use an array of booleans instead of a bitmap
    and write the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法有局限性，但它是另一个改进算法的基础。为了简单起见，这个例子将使用布尔值数组而不是位图，并编写以下代码：
- en: '[PRE18]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: First make a copy of the input array ❶ to simplify the next step, which is determining
    the minimum and maximum keys ❷. (This could be done in a single loop a tad more
    efficiently.) Then create a bitmap array of the right length ❸, but in reality
    you’ll be using common booleans, not bits. You need to be careful with indices,
    because JavaScript’s arrays always start at zero; a bit of index math will be
    needed to relate keys to array positions. Then go through the input array ❹ and
    check whether the key already appeared. If so ❺, there’s a problem. If not ❻,
    just mark that the number did appear. Finally, go through the bitmap ❼, and whenever
    you find a set flag ❽, output the corresponding number.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，复制输入数组 ❶ 以简化下一步，即确定最小值和最大值 ❷。（这可以在一个稍微更高效的循环中完成。）然后创建一个合适长度的位图数组 ❸，但实际上你将使用常规布尔值，而不是位。你需要小心索引，因为
    JavaScript 的数组总是从零开始；需要进行一些索引计算，将键与数组位置对应起来。接着遍历输入数组 ❹，检查该键是否已经出现。如果是 ❺，那就有问题。如果不是
    ❻，只需标记该数字已出现。最后，遍历位图 ❼，每当找到已设置的标志 ❽ 时，输出相应的数字。
- en: Not being able to allow for duplicate keys is a serious limitation, and dealing
    with numbers only is another; you need to be able to sort elements consisting
    of a key + data, as in all the other algorithms you’ve explored so far.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 无法处理重复键是一个严重的局限，另外只处理数字也是一个限制；你需要能够对由键+数据组成的元素进行排序，就像你迄今为止所探索的所有其他算法一样。
- en: '#### Counting Sort'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 计数排序'
- en: The previous sort is quite effective but applies in only limited cases. You
    can make improvements by calculating where each sorted element should go. To do
    that, you need to count how many times each key appears and then use that information
    to decide where to place sorted elements in the output array (see [Figure 6-12](chapter6.xhtml#fig6-12)).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的排序方法非常有效，但仅适用于有限的情况。你可以通过计算每个排序元素应该去哪里来进行改进。为此，你需要统计每个键出现的次数，然后利用这些信息决定如何将排序元素放入输出数组中（见[图
    6-12](chapter6.xhtml#fig6-12)）。
- en: '![](../images/Figure6-12.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-12.jpg)'
- en: 'Figure 6-12: Count sort is somewhat similar to bitmap sort, but it can deal
    with repeated keys.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-12：计数排序与位图排序有些相似，但它能够处理重复的键。
- en: In the same way as with bitmap sort, you need to find the minimum and maximum
    values in the array to be sorted and set up an appropriate array with counters,
    all initialized to zero. (Again, remember that position 0 corresponds to the minimum
    key, which is 47 in this case; position 1 corresponds to 48, and so on.) Then
    go through the array again, incrementing the corresponding counters. After you
    have all the counts, you can follow an easy procedure to determine where each
    key goes. For instance, elements with the minimum key (47) start at position 0
    of the output array; elements with the next key (48) follow two places later (because
    there were two 47s) at place 2\. Each new key is placed to the right of the previous
    key, leaving as many empty spaces as needed to place all the previous elements.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 与位图排序类似，你需要找到待排序数组中的最小值和最大值，并设置一个计数器数组，所有值初始化为零。（再次提醒，位置0对应最小键，这里是47；位置1对应48，以此类推。）然后再次遍历数组，递增相应的计数器。得到所有计数后，你可以按照一个简单的过程确定每个键的放置位置。例如，最小键（47）的元素从输出数组的第0位置开始；下一个键（48）的元素在两位后的位置（因为有两个47）开始，位于位置2。每个新的键都会放在前一个键的右边，留下足够的空位来安置所有前面的元素。
- en: 'The implementation for this algorithm follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法的实现步骤如下：
- en: '[PRE19]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first three lines of this algorithm are the same as the bitmap sort ❶, and
    you create a copy of the input array and determine the minimum and maximum keys.
    You then create an array with the counts for all keys (initialized to zero and
    needing the same kind of index math as in bitmap sort ❷). Then go through the
    input data ❸ and increment counts for each key value. Now generate a new array
    ❹ to calculate the starting place for elements with each key. The minimum key
    starts at position 0, and each key is a few spaces away from the previous one,
    according to the count of the previous key ❺. (For example, if the previous count
    was 5, you’ll have the new key 5 places away from the first occurrence of the
    previous key.) Finally, use the place array to start positioning sorted elements
    in their right places ❻; each time an element goes into the output array, the
    corresponding place is incremented by 1 ❼ for the next element with the same key.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法的前三行与位图排序相同❶，你需要创建输入数组的副本并确定最小和最大键。然后创建一个包含所有键计数的数组（初始化为零，并需要像位图排序那样的索引计算❷）。接下来遍历输入数据❸，并对每个键值递增计数。然后生成一个新数组❹来计算每个键元素的起始位置。最小键从位置0开始，每个键之间根据前一个键的计数相隔若干位置❺。（例如，如果前一个计数是5，则新键与前一个键的首次出现位置相隔5个位置。）最后，使用位置数组开始将排序后的元素放置到正确的位置❻；每次元素被放入输出数组时，对应的位置会递增1❼，以便下一个相同键的元素能够放置到正确的位置。
- en: Radix Sort
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基数排序
- en: The last sorting algorithm in this chapter is probably the oldest. It was used
    with Hollerith punch cards (see [Figure 6-13](chapter6.xhtml#fig6-13)) when tabulating
    census data, back in the days when IBM was founded.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后一种排序算法可能是最古老的。它曾在使用霍勒里斯打孔卡片（参见[图6-13](chapter6.xhtml#fig6-13)）进行人口普查数据汇总时使用，这发生在IBM成立的早期。
- en: '![](../images/Figure6-13.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-13.jpg)'
- en: 'Figure 6-13: An original Hollerith card (public domain)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-13：原始霍勒里斯卡片（公共领域）
- en: 'Suppose you have a disordered set of punch cards, numbered in columns 1 to
    6, and you want to sort them. Using a *classifier*, a machine that processes cards
    and separates them into bins according to the value on a specific column, you
    would follow these steps:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一组无序的打孔卡片，按第1列到第6列编号，并且你想要对它们进行排序。使用*分类器*，一种根据特定列的值将卡片分到不同箱子的机器，你可以按照以下步骤进行操作：
- en: 1. Separate cards into bins according to column 6 and choose cards with a 0,
    then cards with a 1, and so on, finishing with cards with a 9\. You have sorted
    the cards by the sixth column, but you have to keep working.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 按照第6列将卡片分到不同的箱子中，先选择0的卡片，再选择1的卡片，依此类推，直到最后选择9的卡片。你已经按照第六列对卡片进行了排序，但仍然需要继续工作。
- en: 2. Redo the same process, but use column 5\. When you pick the cards up, you’ll
    find that they are sorted by two columns (refer back to the “Sorting Stability”
    section on page 93 to understand why).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 重复相同的过程，但使用第5列。当你拿起卡片时，你会发现它们已经按两列排序（请参阅第93页的“排序稳定性”部分以了解原因）。
- en: 3. Do the process again for columns 4, 3, 2, and 1, in that order, and you’ll
    end up with a totally sorted deck of cards.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 按照顺序再次对第4列、第3列、第2列和第1列执行相同的过程，最终你将得到一副完全排序的卡片。
- en: You’ll explore this algorithm in more detail in [Chapter 10](chapter10.xhtml)
    when looking at lists, which will be the way you’ll emulate the bins.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在[第10章](chapter10.xhtml)中更详细地探讨这个算法，当时你会研究列表，这将是你模拟箱子的方法。
- en: Inefficient Sorting Algorithms
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 低效排序算法
- en: We’ll finish on a not-too-serious note by considering some algorithms that are
    really inefficient, going from bad to worse. These algorithms are not intended
    for actual use!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以一种不太严肃的方式结束，考虑一些真正低效的算法，从差到更差。这些算法不打算用于实际应用！
- en: Stooge Sort
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 傻瓜排序
- en: The name of this algorithm comes from the Three Stooges comedy group, and if
    you’re familiar with them, its inefficiency will remind you of their antics. The
    process to sort a list starts by comparing its first and last elements and swapping
    them (if needed) to ensure the greater one is at the end. Next, it recursively
    applies Stooge sort to the initial two-thirds of the list, then it sorts the last
    two-thirds of the list (which ensures that the last third will have the greatest
    values, in order), and finally, it sorts the first two-thirds of the list again.
    The number of comparisons needed for *n* elements satisfies *C*(*n*) = 3*C*(2*n*
    / 3) + 1, so the algorithm has a complexity of *O*(*n*^(2.71)), which makes it
    perform worse than bubble sort, but there’s even worse.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法的名字来自于“三个傻瓜”喜剧团体，如果你熟悉他们，它的低效性会让你想起他们的荒诞行为。排序一个列表的过程从比较其第一个和最后一个元素开始，如果需要的话交换它们，以确保较大的元素位于末尾。接下来，它递归地对列表的最初三分之二部分应用傻瓜排序，然后对列表的最后三分之二部分进行排序（这样可以确保最后三分之一部分按顺序包含最大值），最后再次对列表的前两部分进行排序。所需的比较次数满足
    *C*(*n*) = 3*C*(2*n* / 3) + 1，因此该算法的复杂度是 *O*(*n*^(2.71))，这使得它的表现比冒泡排序还差，但还有更糟的。
- en: Slow Sort
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 慢排序
- en: This algorithm was designed as a joke. Rather than divide and conquer, it’s
    based on “multiply and surrender.” The authors were proud to have found an algorithm
    worse than any that were previously created. To sort an array with two or more
    elements, the algorithm first splits it in half, and then it uses recursion to
    sort each half. Finally, it compares the last element of each half and places
    it (swapping if needed) at the end of the original array. After doing that, the
    algorithm proceeds to sort the list with the maximum extracted. The number of
    comparisons for this algorithm satisfies *C*(*n*) = 2*C*(*n* / 2) + *C*(*n* –
    1) + 1, and its time is *O*(*n* ^(log) *^n*). It’s not even polynomial!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法是作为笑话设计的。它不是基于分治法，而是基于“乘法与投降”。作者为发现一个比以前任何算法都更糟的算法而感到自豪。要排序一个包含两个或更多元素的数组，算法首先将其一分为二，然后使用递归分别排序每一部分。最后，它比较每一部分的最后一个元素，并将其（如有需要，进行交换）放置到原数组的末尾。完成这一操作后，算法继续排序已经提取出的最大值列表。该算法的比较次数满足
    *C*(*n*) = 2*C*(*n* / 2) + *C*(*n* – 1) + 1，且其时间为 *O*(*n* ^(log) *^n*)。它甚至不是多项式时间的！
- en: '#### Permutation Sort'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 排列排序'
- en: 'In [Chapter 5](chapter5.xhtml), you saw how to go forward from one permutation
    of values to the following one, which suggests an even worse algorithm for sorting
    a sequence: repeatedly attempting to produce the next permutation of the elements
    until the algorithm fails because the last permutation was reached and then reversing
    the sequence. For a random order, this algorithm requires testing on average *n*!
    / 2 permutations, which means its time is at least factorial. For almost any size,
    the algorithm becomes impossible to run because of its running time.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](chapter5.xhtml)中，你已经看到如何从一个值的排列转到下一个排列，这暗示了一个更糟的排序算法：反复尝试生成元素的下一个排列，直到算法失败，因为达到了最后一个排列，然后再反转序列。对于一个随机顺序，该算法平均需要测试
    *n*! / 2 个排列，这意味着它的时间至少是阶乘级别的。对于几乎任何大小，算法都因运行时间过长而无法执行。
- en: Bogosort
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 博格排序
- en: 'The last algorithm derives its name from a portmanteau of the words *bogus*
    and *sort*, and it’s a probabilistic algorithm that sorts its input with probability
    1, but without any certainty as to its running time. The idea also has to do with
    permutations: if the list to be sorted isn’t in order, it shuffles its elements
    randomly (we’ll look at such algorithms in [Chapter 8](chapter8.xhtml)) and tests
    again. If you were to apply this method to sorting a deck of cards, the logic
    would be as follows: if the cards are not in order, throw them into the air, pick
    them up, and check again—the odds of getting it right are 1/52!, so roughly around
    one in a hundred million million million million million million million million
    million million million. Not good!'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的算法名字来源于 *bogus*（假的）和 *sort*（排序）这两个词的合成，它是一种概率性算法，通过概率 1 来排序输入，但没有任何关于运行时间的确定性。这个思路也与排列有关：如果待排序的列表不是有序的，它就会随机打乱元素（我们将在[第八章](chapter8.xhtml)中看到类似的算法），然后再进行测试。如果你将这种方法应用于排序一副牌，逻辑如下：如果牌没有按顺序排列，就把它们抛向空中，捡起来，再检查一次——成功的几率是
    1/52!，大约是十亿亿亿亿亿亿亿亿亿亿亿的几率。并不太好！
- en: Sleep Sort
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 睡眠排序
- en: 'The last sort is specifically meant for JavaScript, and its running time depends
    on the maximum key to be sorted. It works with numeric keys, and the idea is that
    if an input key is *K*, wait *K* seconds and output its value. After enough time
    has passed, all values will be output in order:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的排序算法专为 JavaScript 设计，其运行时间取决于要排序的最大键值。它适用于数字键，其思想是：如果输入键是 *K*，则等待 *K* 秒并输出其值。经过足够的时间，所有值将按顺序输出：
- en: '[PRE20]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Even if this algorithm seems to work, with a sufficiently large dataset, it
    may crash (too many timeouts waiting) or fail. The algorithm goes through the
    list and starts to output numbers—think of processing a list such as 1, 2, 2,
    2, . . . , 2, 2, 0, and with enough 2s, the initial 1 may be output before the
    last 0 is processed.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这个算法看起来能够工作，使用足够大的数据集时，它可能会崩溃（因为等待超时过多）或失败。该算法会遍历列表并开始输出数字——可以想象处理一个类似于 1,
    2, 2, 2, . . . , 2, 2, 0 这样的列表，当 2 的数量足够多时，初始的 1 可能会在最后一个 0 被处理之前就输出。
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we’ve explored several sorting algorithms with different performance
    levels. In the next chapter, we’ll touch on a similar subject, the selection problem,
    which is akin to sorting only part of an array, because instead of getting all
    elements in order in their proper place, you care only about placing a single
    element in its final place, not necessarily sorting the whole list.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探索了几种具有不同性能水平的排序算法。在下一章中，我们将探讨一个类似的主题——选择问题，它类似于对数组的一部分进行排序，因为你并不关心将所有元素按正确顺序排序，而是只关心将一个元素放到最终位置，而不一定是排序整个列表。
- en: '### Questions'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '### 问题'
- en: '**6.1  Forced Reversal**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.1 强制反转**'
- en: Suppose you want to order a set of numbers in descending order, but you have
    a sorting function that sorts only in ascending order with no options whatsoever
    to change how it works. How can you manage to sort your data as you wish?
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想将一组数字按降序排列，但你有一个只按升序排序且没有任何选项可更改其排序方式的排序函数。你如何管理这些数据，按你希望的方式排序？
- en: '**6.2  Only Lower**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.2 仅限下限**'
- en: Suppose you had a boolean function lower(a,b) that returns true if a is lower
    in sorting order than b and false otherwise. How can you use it to decide whether
    a is higher in sorting order than b? And how can you use it to see whether both
    keys are equal in order?
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个布尔函数 lower(a, b)，如果 a 在排序中小于 b，则返回 true，否则返回 false。你如何利用它来判断 a 是否大于 b
    的排序顺序？你又如何用它来判断两个键是否相等？
- en: '**6.3  Testing a Sort Algorithm**'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.3 测试排序算法**'
- en: Imagine you’re trying out a new sorting algorithm of your own. How would you
    test that it actually sorted correctly?
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你正在尝试一种你自己设计的新排序算法。你将如何测试它是否正确排序？
- en: '**6.4  Missing ID**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.4 缺失 ID**'
- en: Imagine you got a set of six-digit IDs, but the count is under 1,000,000, so
    at least one ID is missing. How can you find one?
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你获得了一组六位数的 ID，但总数少于 1,000,000，因此至少有一个 ID 是缺失的。你如何找到这个缺失的 ID？
- en: '**6.5  Unmatched One**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.5 未匹配的一个**'
- en: Say you have an array with transaction numbers, and each number should appear
    twice somewhere in the array, but you know there was a mistake, and there’s a
    single transaction that appears only once. How do you detect it?
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个包含交易号的数组，每个数字应该在数组中出现两次，但你知道有个错误，出现了一个只出现一次的交易号。你如何检测到这个错误？
- en: '**6.6  Sinking Sort**'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.6 下沉排序**'
- en: This is a variant of bubble sort. Instead of starting at the bottom of the array
    and making higher values bubble to the top, sinking sort starts at the top of
    the array and makes smaller values sink to the bottom. In terms of performance,
    it’s the same as bubble sort, but it may be used if you want to find only the
    *k* lowest elements of the array, as you’ll see in [Chapter 7](chapter7.xhtml).
    Can you implement sinking sort?
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种冒泡排序的变种。与从数组底部开始让较大的值冒泡到顶部不同，沉降排序从数组顶部开始，让较小的值沉到底部。在性能上，它和冒泡排序相同，但如果你只想找到数组中最小的*k*个元素，它可能会派上用场，正如你在[第7章](chapter7.xhtml)中看到的那样。你能实现沉降排序吗？
- en: '**6.7  Bubble Swap Checking**'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.7  气泡交换检查**'
- en: Add a test to bubble sort after each pass through the array to exit earlier
    if no swaps were detected. This test will speed things up if you deal with arrays
    that were practically in order and just a few swap passes get everything in its
    place.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次遍历数组后，给冒泡排序添加一个测试，若没有检测到交换则提前退出。如果你处理的是几乎有序的数组，并且只有少数交换就能将所有元素放到正确位置，这个测试将加速排序过程。
- en: '**6.8  Inserting Recursively**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.8  递归插入**'
- en: Can you implement insertion sort in a recursive way?
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你能用递归的方式实现插入排序吗？
- en: '**6.9  Stable Shell?**'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.9  稳定的Shell排序？**'
- en: Is Shell sort stable?
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Shell排序是稳定的吗？
- en: '**6.10  A Dutch Enhancement**'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.10  荷兰国旗增强法**'
- en: 'The Dutch National Flag Problem requires you to arrange an array with elements
    that are either red, white, or blue, so all red elements come first, followed
    by all white ones, and finishing with all blue ones, as in the Dutch national
    flag. Show how you may similarly enhance quicksort’s performance with repeated
    elements by rearranging the array to be sorted into three parts: all elements
    less than the pivot, all elements equal to the pivot, and all elements greater
    than the pivot. The middle part won’t need any further sorting.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 荷兰国旗问题要求你对数组进行排序，数组中的元素要么是红色、白色或蓝色，排序后的顺序是所有红色元素排在前面，接着是所有白色元素，最后是所有蓝色元素，和荷兰国旗的颜色顺序一样。展示一下如何通过将待排序数组重新排列为三个部分：所有小于基准元素的元素、所有等于基准元素的元素和所有大于基准元素的元素，来提升快速排序的性能。中间的部分不需要再进行排序。
- en: '**6.11  Simpler Merging?**'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.11  更简单的合并？**'
- en: 'When merging halves in merge sort, you wrote the following (look specifically
    at the text in bold):'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在归并排序中合并两个子数组时，你写了以下内容（特别注意加粗的部分）：
- en: '[PRE21]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Why is it written that way? You always want to compare using the greater- than
    operator to be able to easily substitute a function for more complex comparisons,
    but why not write arr[rr]>arr[ll] instead?
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这样写？你总是希望使用大于运算符进行比较，以便能够轻松地替换为更复杂的比较函数，但是为什么不写成`arr[rr]>arr[ll]`呢？
- en: '**6.12  Try Not to Be Negative**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.12  尽量避免负数**'
- en: What happens with radix sort if some numbers are negative? Also, what happens
    if you have noninteger values? Can you do something about this?
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果基数排序中有负数会发生什么？如果有非整数值会怎么样？你能解决这个问题吗？
- en: '**6.13  Fill It Up!**'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.13  填满它！**'
- en: 'In radix sort, imagine you wanted to initialize the buckets array with 10 empty
    arrays, and you did it as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在基数排序中，假设你想用10个空数组来初始化桶数组，你可以这样做：
- en: '[PRE22]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Why wouldn’t the following alternative work?
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么下面的替代方法不可行？
- en: '[PRE23]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: And what about this other possibility?
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这种可能性呢？
- en: '[PRE24]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**6.14  What About Letters?**'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.14  字母呢？**'
- en: How would you modify radix sort to work with alphabetical strings?
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 你会如何修改基数排序，使其适用于字母字符串？
