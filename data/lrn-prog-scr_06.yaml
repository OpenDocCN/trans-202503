- en: 'Chapter 7. Repetition: A Deeper Exploration of Loops'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7章。重复：深入探索循环
- en: 'You’ve seen some of Scratch’s repetition structures before, but this chapter
    covers them in greater detail. It’s time to discuss new blocks that create loops,
    nested loops, and recursion. By the end of this chapter, we’ll have explored the
    following programming concepts:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前已经见过一些Scratch的重复结构，但本章将更详细地讲解它们。现在是时候讨论创建循环、嵌套循环和递归的新块了。在本章结束时，我们将探索以下编程概念：
- en: Repetition structures to execute statements repeatedly
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于重复执行语句的重复结构
- en: How to validate user input
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何验证用户输入
- en: Counter-controlled and event-controlled loops
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计数器控制的循环和事件控制的循环
- en: Procedures that can call themselves with recursion
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过递归调用自身的过程
- en: Although most people find repetitive tasks boring, computers seem to like nothing
    more. *Repetition structures*, better known as *loops*, are programming commands
    that tell a computer to repeatedly execute a statement or a sequence of statements.
    The simplest kind of loop is a *definite loop*, which repeats a sequence of statements
    a specific number of times. These loops are also called *counter-controlled loops*
    or *counted loops*. Other types of loops continue to repeat until some condition
    occurs; these are called *condition-controlled loops* or *indefinite loops*. Another
    loop, called an *infinite loop*, repeats forever.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数人觉得重复性任务无聊，但计算机似乎最喜欢做的就是这些。*重复结构*，也就是更常见的*循环*，是编程命令，指示计算机反复执行某个语句或一系列语句。最简单的循环类型是*确定循环*，它会在特定次数内重复执行一系列语句。这些循环也叫*计数器控制的循环*或*计数循环*。其他类型的循环则会一直重复，直到满足某个条件；这些被称为*条件控制的循环*或*不确定循环*。还有一种循环叫做*无限循环*，它会永远重复下去。
- en: In this chapter, you’ll learn about the different repetition structures available
    in Scratch. I’ll explain both counter-controlled and condition-controlled loops
    in detail, and I’ll introduce you to the **stop** block, which you can use to
    end infinite loops. You’ll learn how to use loops to validate user input, as well.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习Scratch中不同的重复结构。我将详细解释计数器控制的循环和条件控制的循环，并介绍**停止**块，你可以用它来结束无限循环。你还将学会如何使用循环来验证用户输入。
- en: The chapter also discusses *nested loops* (loops that contain other loops) and
    shows several examples of their use. We’ll also talk about *recursion*—a procedure
    calling itself—as another way to achieve repetition. At last, we’ll develop a
    number of interesting applications that use both loops and conditionals, and we’ll
    look at incorporating loops into practical programs.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还讨论了*嵌套循环*（包含其他循环的循环），并展示了几个使用它们的例子。我们还将讨论*递归*——一个过程调用自身——作为实现重复的另一种方式。最后，我们将开发一些有趣的应用程序，既使用循环也使用条件语句，并探索如何将循环融入实际程序中。
- en: More Loop Blocks in Scratch
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scratch中的更多循环块
- en: As you learned in [Chapter 2](ch02.html "Chapter 2. Motion and Drawing"), loop
    blocks allow you to repeat a command or a set of commands in a program. Scratch
    supports the three repetition blocks shown in [Figure 7-1](ch07.html#scratchapostrophes_repeat_blocks
    "Figure 7-1. Scratch’s repeat blocks").
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[第2章](ch02.html "第2章。运动与绘制")中学到的那样，循环块允许你在程序中重复执行命令或一组命令。Scratch支持[图7-1](ch07.html#scratchapostrophes_repeat_blocks
    "图7-1. Scratch的重复块")中显示的三种重复块。
- en: '![Scratch’s repeat blocks](httpatomoreillycomsourcenostarchimages2134793.png.jpg)Figure 7-1. Scratch’s
    repeat blocks'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '![Scratch的重复块](httpsatomoreillycomsourcenostarchimages2134793.png.jpg)图 7-1.
    Scratch的重复块'
- en: You’ve already used two of these blocks, the **repeat** and the **forever**
    blocks, in many examples throughout this book. In this section, we’ll examine
    the third kind of loop block—the **repeat until** block—and explain some of the
    technical terms associated with loops in general.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的多个示例中，你已经使用过这两个块：**重复**块和**永远**块。在本节中，我们将讨论第三种循环块——**直到重复**块，并解释与循环相关的一些技术术语。
- en: Each repetition of a loop is called an *iteration*, and the word *count* is
    often used to describe the number of times a loop repeats. The **repeat** block,
    which you are very familiar with, is a counter-controlled loop because it repeats
    its commands a specific number of times. We usually use this loop when we know
    the number of repetitions the loop will need to execute, as when we want to draw
    a polygon with a known number of sides.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每次循环的重复称为*迭代*，而*计数*一词通常用来描述循环重复的次数。你非常熟悉的**repeat**块是一个计数控制的循环，因为它会在指定的次数内重复执行命令。当我们知道循环需要执行多少次时，通常会使用这个循环，就像我们想要绘制一个已知边数的多边形时。
- en: On the other hand, the **repeat until** block is a condition-controlled loop.
    The statements inside this block are repeated based on the truth or falsity of
    its test expression. We use this block when we don’t know in advance how many
    times the loop will need to repeat and want the repetition to continue until some
    condition is met. You can say, for example, “Repeat the **ask** command until
    the user enters a positive number.” Or, “Repeat firing missiles until the player’s
    energy level drops below a certain value.” The following sections explain condition-controlled
    loops in more detail.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**repeat until** 块是一个条件控制的循环。这个块内的语句会根据其测试表达式的真假值进行重复。当我们无法预知循环需要重复多少次，并且希望循环在某个条件满足之前持续进行时，我们使用这个块。例如，你可以说：“重复**ask**命令，直到用户输入一个正数。”或者，“重复发射导弹，直到玩家的能量值降到某个特定值以下。”接下来的章节将更详细地解释条件控制循环。
- en: The repeat until Block
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: repeat until 块
- en: Let’s say you are developing a game that presents the player with an elementary
    math question. If the player’s answer is incorrect, the game asks the same question
    again to give the player another chance. In other words, the game asks the same
    question *until* the player enters the correct answer. Clearly, the **repeat**
    block is inappropriate for this task because you don’t know in advance how many
    times it will take the player to enter the right answer; the first try might be
    a winner, or it may take 100 tries. The **repeat until** block can help you in
    scenarios like this one. The structure of the **repeat until** block is illustrated
    in [Figure 7-2](ch07.html#repeat_until_block_allows_you_to_execute "Figure 7-2. The
    repeat until block allows you to execute a series of instructions repeatedly until
    some condition is true.").
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在开发一个游戏，游戏向玩家提出一个简单的数学问题。如果玩家的回答错误，游戏会再次提问，给玩家另一次机会。换句话说，游戏会一直提问*直到*玩家输入正确答案。显然，**repeat**块不适合这个任务，因为你无法预知玩家需要多少次才能输入正确答案；第一次就可能答对，也可能需要100次。**repeat
    until**块可以帮助你解决像这样的场景。**repeat until**块的结构如[图7-2](ch07.html#repeat_until_block_allows_you_to_execute
    "图7-2. **repeat until**块允许你反复执行一系列指令，直到某个条件成立。")所示。
- en: '![The repeat until block allows you to execute a series of instructions repeatedly
    until some condition is true.](httpatomoreillycomsourcenostarchimages2134795.png.jpg)Figure 7-2. The
    repeat until block allows you to execute a series of instructions repeatedly until
    some condition is true.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![The repeat until block allows you to execute a series of instructions repeatedly
    until some condition is true.](httpatomoreillycomsourcenostarchimages2134795.png.jpg)图7-2.
    **repeat until**块允许你反复执行一系列指令，直到某个条件成立。'
- en: This block contains a Boolean expression whose value is tested at the entry
    of the loop. If the expression is false, the commands inside the loop are executed.
    When the last command in the loop is executed, the loop starts over, and the expression
    is tested again. If the expression is still false, the commands inside the loop
    are executed again. This cycle repeats *until* the test expression becomes true.
    When that happens, the commands inside the loop are skipped, and the program moves
    to the command that immediately follows the loop.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个块包含一个布尔表达式，其值在进入循环时会被测试。如果表达式为假，循环内的命令将被执行。当循环中的最后一条命令执行完毕后，循环将重新开始，并再次测试表达式。如果表达式仍为假，循环内的命令会再次执行。这个过程将一直重复，*直到*测试表达式为真。当那时，循环内的命令会被跳过，程序将继续执行紧跟循环后的命令。
- en: Note that if the test condition is already true before the program runs the
    loop the first time, the commands in the loop won’t be executed. Also, the **repeat
    until** block won’t terminate unless a command (either inside the loop or in some
    other active part of the program) causes the test condition to become true. If
    the result of the test condition never becomes true, we get into an infinite loop.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果程序第一次运行循环时测试条件已经为真，那么循环中的命令将不会执行。而且，**repeat until**块不会终止，除非某个命令（无论是在循环内部还是程序的其他活动部分）使得测试条件变为真。如果测试条件的结果永远不会为真，我们就会陷入一个无限循环。
- en: '[Figure 7-3](ch07.html#simple_example_showing_the_repeat_until "Figure 7-3. A
    simple example showing the repeat until block in action") shows a practical example
    of using the **repeat until** block. In this example, as long as the `Player`
    sprite is more than 100 steps away from the `Guard` sprite, the `Guard` sprite
    will continue to move in its current direction (horizontally in this case), bouncing
    when it touches the left or the right edge of the Stage. If the distance between
    the two sprites becomes less than 100, the **repeat until** block will terminate,
    and the `Guard` sprite will start to chase the `Player` sprite. The code for the
    chase is not shown in the figure. The **distance to** block is found in the *Sensing*
    palette.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-3](ch07.html#simple_example_showing_the_repeat_until "图7-3。一个简单的示例，展示了repeat
    until块的实际应用")展示了使用**repeat until**块的实际示例。在这个示例中，只要`Player`精灵与`Guard`精灵之间的距离超过100步，`Guard`精灵就会继续沿当前方向移动（此情况下为水平方向），并在接触舞台的左右边缘时反弹。如果两者之间的距离小于100，**repeat
    until**块将终止，`Guard`精灵将开始追逐`Player`精灵。追逐的代码在图中没有显示。**distance to**块可以在*Sensing*面板中找到。'
- en: '![A simple example showing the repeat until block in action](httpatomoreillycomsourcenostarchimages2134797.png.jpg)Figure 7-3. A
    simple example showing the repeat until block in actionTry It Out 7-1'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![一个简单的示例，展示了repeat until块的实际应用](httpatomoreillycomsourcenostarchimages2134797.png.jpg)图7-3。一个简单的示例，展示了repeat
    until块的实际应用。尝试操作 7-1'
- en: Open the application *Chase.sb2* and run it. Use the arrow keys to move the
    `Player` sprite close to the `Guard` to see the chase in action. How would you
    change the test condition to unleash the `Guard` sprite if the *y*-position of
    the `Player` sprite goes outside a certain range (for example, –50 to 50)? Implement
    this change to check your solution.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 打开应用程序*Chase.sb2*并运行它。使用箭头键将`Player`精灵移到接近`Guard`精灵的位置，看看追逐效果。你会如何改变测试条件，使得如果`Player`精灵的*y*位置超出某个范围（例如，-50到50），`Guard`精灵会被释放？实施这个更改来验证你的解决方案。
- en: '*Chase.sb2*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*Chase.sb2*'
- en: Building a forever if Block
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建一个forever if块
- en: Infinite loops are useful in a lot of programming situations. In the previous
    chapters, for example, you used the **forever** block to play background music,
    and you animated sprites by changing their costumes continuously. The **forever**
    block is an *unconditional infinite loop* because it doesn’t have a test condition
    that controls the execution of the commands inside it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 无限循环在很多编程场景中都非常有用。例如，在前面的章节中，你使用了**forever**块来播放背景音乐，并通过不断更换角色服装来动画化精灵。**forever**块是一个*无条件的无限循环*，因为它没有控制内部命令执行的测试条件。
- en: You can easily change that, however, by nesting an **if** block inside a **forever**
    block to create a *conditional infinite loop*, as shown in [Figure 7-4](ch07.html#you_can_create_a_foreversolidusif_loop_b
    "Figure 7-4. You can create a forever/if loop by combining a forever block with
    an if block."). The test condition of the **if** block is tested at the beginning
    of every iteration, and its commands only execute when the test condition is true.
    Note that since the **forever** block is supposed to execute forever, you can’t
    snap command blocks after it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以通过将**if**块嵌套在**forever**块内来轻松改变这一点，从而创建一个*条件无限循环*，如[图7-4](ch07.html#you_can_create_a_foreversolidusif_loop_b
    "图7-4。你可以通过将forever块与if块结合来创建一个forever/if循环")所示。**if**块的测试条件会在每次迭代开始时进行检查，只有当测试条件为真时，其命令才会执行。注意，由于**forever**块是无限执行的，你不能在其后连接命令块。
- en: '![You can create a forever/if loop by combining a forever block with an if
    block.](httpatomoreillycomsourcenostarchimages2134799.png.jpg)Figure 7-4. You
    can create a forever/if loop by combining a forever block with an if block.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![你可以通过将forever块与if块结合来创建一个forever/if循环。](httpatomoreillycomsourcenostarchimages2134799.png.jpg)图7-4。你可以通过将forever块与if块结合来创建一个forever/if循环。'
- en: The combined **forever/if** structure is frequently used to control sprite movement
    with the keyboard arrow keys, as demonstrated in [Figure 7-5](ch07.html#these_scripts_allow_you_to_move_a_sprite
    "Figure 7-5. These scripts allow you to move a sprite using the keyboard arrow
    keys. Each script responds to one of the four keys.").
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 组合**永远/如果**结构通常用于用键盘箭头键控制精灵的运动，如[图7-5](ch07.html#these_scripts_allow_you_to_move_a_sprite
    "图7-5. 这些脚本允许你用键盘箭头键来移动精灵")所示。
- en: '![These scripts allow you to move a sprite using the keyboard arrow keys. Each
    script responds to one of the four keys.](httpatomoreillycomsourcenostarchimages2134801.png.jpg)Figure 7-5. These
    scripts allow you to move a sprite using the keyboard arrow keys. Each script
    responds to one of the four keys.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![这些脚本允许你用键盘箭头键来移动精灵。每个脚本响应其中一个箭头键。](httpatomoreillycomsourcenostarchimages2134801.png.jpg)图7-5.
    这些脚本允许你用键盘箭头键来移动精灵。每个脚本响应其中一个箭头键。'
- en: '*ArrowKeys1.sb2*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*ArrowKeys1.sb2*'
- en: When the green flag icon is pressed, the four keyboard arrow keys (left, right,
    up, and down) are monitored in four independent infinite loops. When any of these
    keys is pressed, the corresponding loop causes a change in the *x*- or *y*-coordinate
    of the sprite.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下绿色旗帜图标时，四个方向键（左、右、上、下）将在四个独立的无限循环中被监视。当按下任意一个键时，相应的循环会导致精灵的*x*坐标或*y*坐标发生变化。
- en: Create these scripts in Scratch (or open *ArrowKeys1.sb2*) and run the program.
    Notice that if you press the up and right arrow keys simultaneously, the sprite
    will move diagonally in the northeast direction. Try other combinations of the
    arrow keys to see how the application responds.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scratch中创建这些脚本（或打开*ArrowKeys1.sb2*）并运行程序。注意，如果同时按下上箭头和右箭头键，精灵会向东北方向对角移动。尝试其他箭头键组合，看看应用程序如何响应。
- en: Try It Out 7-2
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 试试看 7-2
- en: Another way to control the sprite’s movement with the arrow keys is shown below.
    Compare this method to the one shown in [Figure 7-5](ch07.html#these_scripts_allow_you_to_move_a_sprite
    "Figure 7-5. These scripts allow you to move a sprite using the keyboard arrow
    keys. Each script responds to one of the four keys."). Which is more responsive
    to keyboard strokes? How does the alternate script behave if you press two keys
    (for example, up and right) simultaneously? Now, try placing the four **if** blocks
    in [Figure 7-5](ch07.html#these_scripts_allow_you_to_move_a_sprite "Figure 7-5. These
    scripts allow you to move a sprite using the keyboard arrow keys. Each script
    responds to one of the four keys.") together in a single **forever** loop and
    press two arrow keys at the same time. How does the sprite’s behavior change?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种用箭头键控制精灵运动的方法如下所示。将这种方法与[图7-5](ch07.html#these_scripts_allow_you_to_move_a_sprite
    "图7-5. 这些脚本允许你用键盘箭头键来移动精灵")中的方法进行比较。哪一种对键盘敲击更为灵敏？如果同时按下两个键（例如，上键和右键），替代脚本会如何表现？现在，尝试将[图7-5](ch07.html#these_scripts_allow_you_to_move_a_sprite
    "图7-5. 这些脚本允许你用键盘箭头键来移动精灵")中四个**如果**区块放在一个**永远**循环中，并同时按下两个箭头键。精灵的行为有何变化？
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2134803.png.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2134803.png.jpg)'
- en: Stop Commands
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 停止命令
- en: Let’s say you’re writing a program to find the first integer less than 1,000
    that is evenly divisible by 3, 5, and 7\. You can write a script that checks the
    numbers 999, 998, 997, and so on, one by one, in a loop. You want to *stop* the
    search when you find the number you’re looking for (945 in this example).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在编写一个程序，用来找到第一个小于1,000的能被3、5和7整除的整数。你可以编写一个脚本，在循环中逐一检查数字999、998、997，依此类推。当你找到你要找的数字时（在这个例子中是945），你想要*停止*搜索。
- en: How can you tell Scratch to end the loop and stop the script? You can use the
    **stop** command (from the *Control* palette) to end active scripts. The drop-down
    menu provides the three options shown in [Figure 7-6](ch07.html#using_the_stop_command_in_scratch
    "Figure 7-6. Using the stop command in Scratch").
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如何告诉Scratch结束循环并停止脚本？你可以使用**停止**命令（来自*控制*调色板）来结束活动脚本。下拉菜单提供了如[图7-6](ch07.html#using_the_stop_command_in_scratch
    "图7-6. 在Scratch中使用停止命令")所示的三个选项。
- en: '![Using the stop command in Scratch](httpatomoreillycomsourcenostarchimages2134805.png.jpg)Figure 7-6. Using
    the stop command in Scratch'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![在Scratch中使用停止命令](httpatomoreillycomsourcenostarchimages2134805.png.jpg)图7-6.
    在Scratch中使用停止命令'
- en: The first option immediately terminates the script that calls it. The second
    option, on the other hand, stops all running scripts in your application; it is
    equivalent to the red stop icon located at the top of the Stage. Note that you
    can’t snap any commands after the **stop** block when you use either of these
    two options.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项立即终止调用它的脚本。第二个选项则停止应用程序中所有正在运行的脚本；它等同于舞台顶部的红色停止图标。请注意，在使用这两个选项时，**stop**
    块之后不能连接任何命令。
- en: '*StopDemo.sb2*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*StopDemo.sb2*'
- en: The third **stop** option allows a sprite or the Stage to end all of its scripts
    except the one that invoked the **stop** block. This command is shaped as a stack
    block, so you can add blocks below it to execute after it suspends the sprite’s
    other scripts. Let’s see this command in action in a simple game, illustrated
    in [Figure 7-7](ch07.html#in_this_gamecomma_the_player_moves_the_w "Figure 7-7. In
    this game, the player moves the witch on the Stage while trying to avoid the two
    balls.").
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个**stop**选项允许一个精灵或舞台结束其所有脚本，除了调用**stop**块的那个脚本。这个命令呈堆叠块的形状，因此你可以在它下面添加块，在暂停精灵其他脚本后执行它们。让我们通过一个简单的游戏来看看这个命令的作用，见[图
    7-7](ch07.html#in_this_gamecomma_the_player_moves_the_w "图 7-7。在这个游戏中，玩家在舞台上移动巫婆，同时尽量避开两个球。")。
- en: '![In this game, the player moves the witch on the Stage while trying to avoid
    the two balls.](httpatomoreillycomsourcenostarchimages2134807.png.jpg)Figure 7-7. In
    this game, the player moves the witch on the Stage while trying to avoid the two
    balls.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![在这个游戏中，玩家在舞台上移动巫婆，同时尽量避开两个球。](httpatomoreillycomsourcenostarchimages2134807.png.jpg)图
    7-7。在这个游戏中，玩家在舞台上移动巫婆，同时尽量避开两个球。'
- en: The two balls in this figure move around the Stage and chase the witch. The
    player moves the witch sprite with the keyboard and tries to avoid being touched
    by the two balls. If the red ball touches the player at any time, the game ends.
    If the green ball touches the player, it will stop chasing the player, but the
    red ball will start to move a little faster—which makes escaping it a real challenge.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的两个球在舞台上移动并追逐巫婆。玩家用键盘移动巫婆精灵，并尽量避免被两个球碰到。如果红色球在任何时候碰到玩家，游戏结束。如果绿色球碰到玩家，它将停止追逐玩家，但红色球会开始稍微加速——这使得逃避红球变得更具挑战性。
- en: The scripts for moving the witch sprite are similar to those of [Figure 7-5](ch07.html#these_scripts_allow_you_to_move_a_sprite
    "Figure 7-5. These scripts allow you to move a sprite using the keyboard arrow
    keys. Each script responds to one of the four keys."), so I won’t show them here.
    The scripts for the two balls are shown in [Figure 7-8](ch07.html#scripts_for_the_green_ball_left_parenthe
    "Figure 7-8. Scripts for the green ball (left) and red ball (right)")—let’s take
    a look at those.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 移动巫婆精灵的脚本与[图 7-5](ch07.html#these_scripts_allow_you_to_move_a_sprite "图 7-5。这些脚本允许你使用键盘的方向键移动精灵。每个脚本响应四个方向键中的一个")的脚本类似，所以这里不再展示。两个球的脚本如[图
    7-8](ch07.html#scripts_for_the_green_ball_left_parenthe "图 7-8. 绿色球（左）和红色球（右）的脚本")所示——我们来看一下这些脚本。
- en: '![Scripts for the green ball (left) and red ball (right)](httpatomoreillycomsourcenostarchimages2134809.png.jpg)Figure 7-8. Scripts
    for the green ball (left) and red ball (right)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![绿色球（左）和红色球（右）的脚本](httpatomoreillycomsourcenostarchimages2134809.png.jpg)图
    7-8。绿色球（左）和红色球（右）的脚本'
- en: When the green ball touches the player, it increases the `speed` variable (which
    sets the movement speed of the red ball), and it invokes the **stop this script**
    command to terminate its script. All other scripts in the game should continue
    to run normally. Using the **stop this script** command works well here because
    we only want to speed up the red ball once. If the red ball touches the player,
    however, it executes the **stop all** command, which causes all running scripts
    in the application to stop.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当绿色球碰到玩家时，它会增加`speed`变量（该变量设置红色球的移动速度），并调用**stop this script**命令来终止它的脚本。游戏中的其他脚本应该继续正常运行。在这里使用**stop
    this script**命令非常合适，因为我们只希望加速红色球一次。然而，如果红色球碰到玩家，它会执行**stop all**命令，这将导致应用程序中所有正在运行的脚本停止。
- en: Try It Out 7-3
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试示例 7-3
- en: Load this game and play it to see how it works. Watch what happens to the yellow
    border around the two scripts of [Figure 7-8](ch07.html#scripts_for_the_green_ball_left_parenthe
    "Figure 7-8. Scripts for the green ball (left) and red ball (right)") when the
    green and the red balls touch the `Player`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 加载这个游戏并进行游戏，看看它是如何运作的。观察[图 7-8](ch07.html#scripts_for_the_green_ball_left_parenthe
    "图 7-8. 绿色球（左）和红色球（右）的脚本")中两个脚本周围的黄色边框，在绿色球和红色球碰到`Player`时会发生什么。
- en: You can also use the **stop** block to terminate a procedure and make it return
    to the caller at any point during its execution. The next section shows this concept
    in action.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用**stop**语句块在程序执行的任何点终止一个过程并使其返回给调用者。下一节将展示这一概念的实际应用。
- en: Ending a Computational Loop
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结束计算循环
- en: '*NumberSearch.sb2*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*NumberSearch.sb2*'
- en: Let’s say that we want to find the first power of 2 that is larger than 1,000.
    We’ll write a procedure that checks the numbers 2¹, 2², 2³, 2⁴, and so on, in
    a loop. When we find the number we need, we want the program to say the answer
    and stop the procedure. [Figure 7-9](ch07.html#two_ways_to_find_the_first_power_of_2_th
    "Figure 7-9. Two ways to find the first power of 2 that is larger than 1,000")
    shows two ways to implement this approach.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们要找到大于1,000的第一个2的幂。我们将编写一个过程，在一个循环中检查2¹、2²、2³、2⁴等。当我们找到所需的数字时，我们希望程序说出答案并停止过程。[图7-9](ch07.html#two_ways_to_find_the_first_power_of_2_th
    "图7-9. 两种方法找到大于1,000的第一个2的幂")展示了实现这一方法的两种方式。
- en: '![Two ways to find the first power of 2 that is larger than 1,000](httpatomoreillycomsourcenostarchimages2134811.png.jpg)Figure 7-9. Two
    ways to find the first power of 2 that is larger than 1,000'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![两种方法找到大于1,000的第一个2的幂](httpatomoreillycomsourcenostarchimages2134811.png.jpg)图7-9.
    两种方法找到大于1,000的第一个2的幂'
- en: The procedure on the left in [Figure 7-9](ch07.html#two_ways_to_find_the_first_power_of_2_th
    "Figure 7-9. Two ways to find the first power of 2 that is larger than 1,000")
    initializes the `result` variable to 2, which is the first power of 2 to be checked,
    and enters an infinite loop in search for the answer. It checks the value of `result`
    in each iteration of the loop. If `result` is greater than 1,000, the procedure
    invokes the **stop this script** command to stop and return to the caller. Otherwise,
    the command after the **if** block (which multiplies the previous value of `result`
    by 2) executes, and the next iteration of the loop begins. If you trace through
    this procedure, you’ll see that the **if** block finds `result` to be 2 in the
    first iteration, 4 in the second iteration, 8 in the third iteration, and so on.
    This continues until `result` exceeds 1,000; at this point, the procedure stops
    and returns to the caller, which displays the result using the **say** block.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-9](ch07.html#two_ways_to_find_the_first_power_of_2_th "图7-9. 两种方法找到大于1,000的第一个2的幂")中左侧的程序将`result`变量初始化为2，这是要检查的第一个2的幂，并进入一个无限循环以寻找答案。它在每次循环迭代中检查`result`的值。如果`result`大于1,000，则程序调用**停止此脚本**命令停止并返回给调用者。否则，**if**语句块后的命令（即将`result`的前一个值乘以2）将执行，下一次迭代开始。如果你跟踪这个过程，你会看到**if**语句块在第一次迭代时将`result`设为2，第二次迭代时为4，第三次为8，以此类推。这将一直持续，直到`result`超过1,000；此时，程序停止并返回给调用者，调用者使用**say**语句块显示结果。'
- en: '[Figure 7-9](ch07.html#two_ways_to_find_the_first_power_of_2_th "Figure 7-9. Two
    ways to find the first power of 2 that is larger than 1,000") (right) shows another
    way to implement the procedure. Here, we used a **repeat until** block that continues
    to loop until `result` becomes greater than 1,000\. As in the first implementation,
    the loop continues to double the value of `result` until it exceeds 1,000\. When
    this happens, the loop terminates naturally, and the procedure returns to the
    caller. Note that we did not have to use the **stop** block in this case.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-9](ch07.html#two_ways_to_find_the_first_power_of_2_th "图7-9. 两种方法找到大于1,000的第一个2的幂")（右）展示了另一种实现该过程的方法。在这里，我们使用了一个**repeat
    until**语句块，该语句块将继续循环，直到`result`大于1,000。与第一种实现方式一样，循环会继续将`result`的值翻倍，直到它超过1,000。当发生这种情况时，循环自然终止，过程返回给调用者。请注意，在这种情况下我们不需要使用**stop**语句块。'
- en: The **stop** block is also useful when you need to validate input from users.
    You’ll see an example of this practical application next.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要验证用户输入时，**stop**语句块也非常有用。接下来你将看到这种实际应用的例子。
- en: Validating User Input
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证用户输入
- en: When you write an application that reads some data from the user, you should
    always check that the entered values are valid before starting to process the
    data. Repetition structures can help you with this task. If the user’s input is
    invalid, you can use a loop to display an appropriate error message and ask the
    user to reenter the value.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写一个从用户那里读取数据的应用时，你应该始终在开始处理数据之前检查输入的值是否有效。重复结构可以帮助你完成这个任务。如果用户输入无效，你可以使用一个循环显示适当的错误信息并要求用户重新输入值。
- en: To demonstrate, let’s say that you are developing a game with two levels and
    you want to let the user select a level to play. The only valid entries in this
    case are the numbers 1 and 2\. If the user enters a number other than these two
    numbers, you’d like to offer another chance to enter an acceptable value. One
    way to implement this check is shown in [Figure 7-10](ch07.html#input_validation_using_the_forever_block
    "Figure 7-10. Input validation using the forever block").
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设你正在开发一个有两个等级的游戏，并希望让用户选择一个等级进行游戏。在这种情况下，唯一有效的输入是数字1和2。如果用户输入一个不在这两个数字范围内的数字，你可能希望再给他们一次输入有效值的机会。实现这个检查的一种方式在[图
    7-10](ch07.html#input_validation_using_the_forever_block "图 7-10. 使用forever块进行输入验证")中展示。
- en: '![Input validation using the forever block](httpatomoreillycomsourcenostarchimages2134813.png.jpg)Figure 7-10. Input
    validation using the forever block'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用forever块进行输入验证](httpatomoreillycomsourcenostarchimages2134813.png.jpg)图
    7-10. 使用forever块进行输入验证'
- en: The **GetLevel** procedure asks the user to enter a choice and checks the answer
    inside a **forever** loop. If the user’s answer is invalid, the loop prompts the
    user to reenter the level. If the user enters a valid number, the procedure calls
    **stop this script** to terminate the loop and end the procedure. When this happens,
    the main script, which has been patiently waiting for the **GetLevel** procedure
    to return, moves on to execute the **say** command. [Figure 7-11](ch07.html#input_validation_using_the_repeat_until
    "Figure 7-11. Input validation using the repeat until block") shows how to achieve
    the same task using the **repeat until** block.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**GetLevel**过程要求用户输入一个选择，并在**forever**循环内检查答案。如果用户的答案无效，循环会提示用户重新输入等级。如果用户输入有效的数字，过程会调用**stop
    this script**来终止循环并结束过程。当这种情况发生时，主脚本（一直在耐心等待**GetLevel**过程返回）继续执行**say**命令。[图
    7-11](ch07.html#input_validation_using_the_repeat_until "图 7-11. 使用重复直到块进行输入验证")展示了如何使用**重复直到**块实现相同的任务。'
- en: '![Input validation using the repeat until block](httpatomoreillycomsourcenostarchimages2134815.png.jpg)Figure 7-11. Input
    validation using the repeat until block'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用重复直到块进行输入验证](httpatomoreillycomsourcenostarchimages2134815.png.jpg)图 7-11.
    使用重复直到块进行输入验证'
- en: The procedure in [Figure 7-11](ch07.html#input_validation_using_the_repeat_until
    "Figure 7-11. Input validation using the repeat until block") asks the user to
    enter a choice and waits for the answer. If the user enters 1 or 2, the condition
    in the header of the **repeat until** block evaluates to true, which naturally
    terminates the loop and ends the procedure. On the other hand, if the user enters
    anything other than 1 or 2, the loop’s condition evaluates to false, and the **ask**
    command inside the loop executes. This command waits for the user’s input again,
    and the **repeat until** block will continue asking for input until the user enters
    a valid choice. Once again, note that this implementation doesn’t require a **stop**
    block.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-11](ch07.html#input_validation_using_the_repeat_until "图 7-11. 使用重复直到块进行输入验证")中的过程要求用户输入一个选择并等待答案。如果用户输入1或2，**重复直到**块头部的条件会评估为真，从而自然终止循环并结束过程。另一方面，如果用户输入除了1或2之外的其他内容，循环条件会评估为假，循环内的**ask**命令会执行。这个命令会再次等待用户的输入，**重复直到**块会继续要求输入，直到用户输入一个有效的选择。再次提醒，这个实现不需要**stop**块。'
- en: Counters
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计数器
- en: Sometimes, you’ll need to keep track of the number of iterations a loop performs.
    For example, if you want to give users only three chances to enter the correct
    password, you’ll have to count their attempts and lock them out after the third
    try.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你需要跟踪一个循环执行的次数。例如，如果你想给用户三次机会输入正确的密码，你需要计算他们的尝试次数，并在第三次尝试后锁定他们。
- en: You can handle such programming scenarios by using a variable (commonly referred
    to as the *loop counter*) that counts the number of loop iterations. Let’s jump
    right in and explore some examples that demonstrate practical ways to use loop
    counters.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用一个变量（通常称为*循环计数器*）来处理这种编程场景，这个变量会统计循环的迭代次数。让我们直接进入并探索一些展示如何实际使用循环计数器的例子。
- en: Check a Password
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查密码
- en: 'The program in [Figure 7-12](ch07.html#this_script_gives_the_user_three_chances
    "Figure 7-12. This script gives the user three chances to enter the correct password.")
    asks the user to enter a password for unlocking a laptop. The `Laptop` sprite
    has two costumes: the off image indicates that the laptop is locked, and the on
    image indicates that the laptop is unlocked. The user will be denied access to
    the laptop if an invalid password is entered three times.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-12](ch07.html#this_script_gives_the_user_three_chances) 中的程序要求用户输入密码以解锁笔记本电脑。`Laptop`
    精灵有两种服装：off 图像表示笔记本电脑已被锁定，on 图像表示笔记本电脑已解锁。如果用户连续三次输入无效密码，则将拒绝访问该笔记本。'
- en: '*Password Check.sb2*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*Password Check.sb2*'
- en: '![This script gives the user three chances to enter the correct password.](httpatomoreillycomsourcenostarchimages2134817.png.jpg)Figure 7-12. This
    script gives the user three chances to enter the correct password.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![此脚本给用户三次机会输入正确的密码。](httpatomoreillycomsourcenostarchimages2134817.png.jpg)图
    7-12. 此脚本给用户三次机会输入正确的密码。'
- en: When the green flag is clicked, the `Laptop` sprite switches to the `off` costume
    and calls the **GetPassword** procedure to authenticate the user. This procedure
    is expected to return the password check result to the main script using the `gotPass`
    flag. When the procedure returns, the **if/else** block checks the `gotPass` flag
    to decide whether or not the user should be allowed to access the system. If `gotPass`
    was set to 1, meaning the user entered the correct password, the **if** block
    executes a **say** command that displays *Access granted* and changes the laptop’s
    costume to the `on` image. Otherwise, the script displays *Access denied!* and
    the sprite continues to show its initial `off` costume.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击绿色旗帜时，`Laptop` 精灵切换到 `off` 服装，并调用 **GetPassword** 过程来验证用户身份。此过程预计通过 `gotPass`
    标志将密码检查结果返回给主脚本。当过程返回时，**if/else** 代码块会检查 `gotPass` 标志，以决定是否允许用户访问系统。如果 `gotPass`
    被设置为 1，表示用户输入了正确的密码，则 **if** 代码块执行 **say** 命令，显示 *Access granted*（访问授权），并将笔记本的服装更改为
    `on` 图像。否则，脚本显示 *Access denied!*（访问拒绝！），并且精灵继续显示其初始的 `off` 服装。
- en: The **GetPassword** procedure sets the `gotPass` flag to 0, to indicate that
    it hasn’t received a valid password yet, and initializes the `failCount` variable
    (our loop counter) to 0\. It then executes a **repeat** loop with a maximum repeat
    count of three. During each iteration of the loop, the user is prompted to enter
    a password. If the user enters the correct password (`Pass123` in this example),
    the `gotPass` flag is set to 1, the procedure stops itself by invoking the **stop
    this script** command, and execution returns to the caller. Otherwise, if the
    user hasn’t used up all three attempts, an error message is displayed, and the
    user is given another chance. If the user fails three consecutive times, the **repeat**
    loop automatically terminates, and the procedure returns to the caller with the
    value of the `gotPass` flag still set to 0.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**GetPassword** 过程将 `gotPass` 标志设置为 0，表示尚未收到有效密码，并将 `failCount` 变量（我们的循环计数器）初始化为
    0。然后执行一个 **repeat** 循环，最大重复次数为三次。在每次循环中，系统提示用户输入密码。如果用户输入了正确的密码（例如 `Pass123`），则将
    `gotPass` 标志设置为 1，过程通过调用 **stop this script** 命令停止自身，并将执行返回给调用者。否则，如果用户还没有用完三次尝试机会，则显示错误消息，并给予用户再次尝试的机会。如果用户连续三次失败，**repeat**
    循环会自动终止，并且过程返回给调用者，`gotPass` 标志仍然保持为 0。'
- en: Try It Out 7-4
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试实践 7-4
- en: Open this application and run it. What happens if you enter `paSS123` (instead
    of `Pass123`) for the password? What does this tell you about string comparison
    in Scratch? Try to implement the **GetPassword** procedure using a **repeat until**
    block.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 打开此应用程序并运行它。如果你输入 `paSS123`（而不是 `Pass123`）作为密码，会发生什么？这告诉你在 Scratch 中字符串比较的特点是什么？尝试使用
    **repeat until** 代码块实现 **GetPassword** 过程。
- en: Counting by a Constant Amount
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按固定数量计数
- en: Of course, you don’t always have to increase your counters by 1 each time through
    a loop. The script in [Figure 7-13](ch07.html#you_can_increment_and_decrement_counters
    "Figure 7-13. You can increment and decrement counters by amounts other than 1.")
    at ①, for example, has a sprite count from 5 to 55 in increments of 5\. The script
    at ② causes the sprite to count down from 99 to 0 in decrements of 11—in other
    words, 99, 88, 77,..., 11, 0.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不必每次通过循环时都将计数器增加 1。例如，[图 7-13](ch07.html#you_can_increment_and_decrement_counters
    "Figure 7-13. You can increment and decrement counters by amounts other than 1.")
    中的脚本 ① 会使精灵从 5 计数到 55，每次增加 5。脚本 ② 会使精灵从 99 计数到 0，每次减少 11——也就是说，99, 88, 77, ...
    11, 0。
- en: '*CountingBy ConstAmount.sb2*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*CountingBy ConstAmount.sb2*'
- en: '![You can increment and decrement counters by amounts other than 1.](httpatomoreillycomsourcenostarchimages2134819.png.jpg)Figure 7-13. You
    can increment and decrement counters by amounts other than 1.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![你可以通过其他增量来递增和递减计数器，而不仅仅是 1。](httpatomoreillycomsourcenostarchimages2134819.png.jpg)图7-13。你可以通过其他增量来递增和递减计数器，而不仅仅是
    1。'
- en: To see this counting technique in a practical application, let’s say that we
    want to find the sum of all even integers from 2 to 20 (inclusive). (That is,
    we want the sum 2 + 4 + 6 + 8 + ... + 20.) The script of [Figure 7-14](ch07.html#this_script_finds_the_sum_of_all_even_in
    "Figure 7-14. This script finds the sum of all even integers from 2 to 20.") does
    exactly that.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在实际应用中看到这种计数技巧，我们假设我们想要计算从 2 到 20（包括 20）所有偶数的和。（也就是说，我们想要计算 2 + 4 + 6 + 8
    + ... + 20 的和。）[图 7-14](ch07.html#this_script_finds_the_sum_of_all_even_in "Figure 7-14. This
    script finds the sum of all even integers from 2 to 20.") 的脚本正是执行了这个任务。
- en: '![This script finds the sum of all even integers from 2 to 20.](httpatomoreillycomsourcenostarchimages2134821.png.jpg)Figure 7-14. This
    script finds the sum of all even integers from 2 to 20.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![这个脚本计算了从 2 到 20 所有偶数的和。](httpatomoreillycomsourcenostarchimages2134821.png.jpg)图7-14。这个脚本计算了从
    2 到 20 所有偶数的和。'
- en: This script starts by initializing the `sum` variable to 0 and the `count` variable
    to 2, and then enters a conditional loop that repeats until `count` exceeds 20\.
    Each time the loop iterates, the value of `count` is added to the current sum
    and the `count` variable is increased by 2 to get the next even integer in the
    sequence. Predict the output of this script then run it to check your answer.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本首先将 `sum` 变量初始化为 0，并将 `count` 变量初始化为 2，然后进入一个条件循环，直到 `count` 超过 20 为止。在每次迭代中，`count`
    的值会被添加到当前的和中，并且 `count` 变量会增加 2，以获得序列中的下一个偶数。预测这个脚本的输出，然后运行它来检查你的答案。
- en: Non-Integer Repeat Count
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 非整数重复计数
- en: What do you think would happen if you asked Scratch to repeat a loop 2.5 times?
    The three examples shown below demonstrate how Scratch handles non-integer repeat
    counts.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为如果让 Scratch 重复一个循环 2.5 次，会发生什么情况？下面的三个示例展示了 Scratch 如何处理非整数的重复计数。
- en: '*Non-Integer RepeatCount.sb2*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*Non-Integer RepeatCount.sb2*'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2134823.png.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2134823.png.jpg)'
- en: Of course, there is no such thing as “repeat 2.5 times,” but Scratch doesn’t
    prevent you from entering such values. Rather than giving an error message, Scratch
    automatically rounds a decimal repeat count to its nearest integer.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，根本没有“重复 2.5 次”这种说法，但 Scratch 并没有阻止你输入这样的值。Scratch 不会给出错误信息，而是自动将小数重复计数四舍五入到最接近的整数。
- en: Revisiting Nested Loops
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新审视嵌套循环
- en: Back in [Rotated Squares](ch02.html#rotated_squares "Rotated Squares"), we used
    nested loops to draw rotated squares. One loop (the *inner loop*) was responsible
    for drawing the square, while the other loop (the *outer loop*) controlled the
    number of rotations. In this section, you’ll learn how to use the concept of loop
    counters in conjunction with nested loops to create iterations in two (or more)
    dimensions. This technique is an essential part of programming and, as you’ll
    see in a moment, can be used to solve a wide range of programming problems.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在[旋转方块](ch02.html#rotated_squares "Rotated Squares")一节中，我们使用了嵌套循环来绘制旋转的方块。一个循环（*内循环*）负责绘制方块，而另一个循环（*外循环*）控制旋转的次数。在这一节中，你将学习如何结合使用循环计数器和嵌套循环，在二维（或更多维度）中创建迭代。这项技术是编程的一个重要部分，正如你接下来会看到的，它可以用来解决各种编程问题。
- en: To set the stage, let’s say that a local restaurant offers four kinds of pizza
    (P1, P2, P3, and P4) and three kinds of salads (S1, S2, and S3). If you ate there,
    you would have 12 possible combinations to choose from; you could have P1 with
    any of three salad types, P2 with any of three salad types, and so on. The restaurant’s
    owner wants to print out a menu that lists the available pizza/salad combinations
    along with their combined prices and calorie contents. Let’s see how nested loops
    can be used to generate a list of all possible combinations. (I’ll leave calculating
    the prices and calorie content as an exercise for you.)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一家本地餐厅提供四种披萨（P1、P2、P3 和 P4）和三种沙拉（S1、S2 和 S3）。如果你在这家餐厅用餐，你将有12种可能的组合可以选择；你可以将
    P1 与三种沙拉中的任意一种搭配，P2 与三种沙拉中的任意一种搭配，以此类推。餐厅老板想要打印一份菜单，列出所有可用的披萨/沙拉组合，以及它们的价格和卡路里含量。让我们看看如何使用嵌套循环来生成所有可能的组合。（计算价格和卡路里内容的部分留给你作为练习。）
- en: 'If you think about it, you’ll see that we just need two loops: one loop (the
    outer loop) to cycle through the pizza types and another loop (the inner loop)
    to cycle through the salad types. The outer loop starts with P1, while the inner
    loop tries S1, S2, and S3\. The outer loop then moves to P2, and the inner loop
    again chooses S1, S2, and S3\. This continues until the outer loop has passed
    through all four pizza types. An implementation of this idea is illustrated in
    [Figure 7-15](ch07.html#visualizing_nested_loopsdot_the_variable "Figure 7-15. Visualizing
    nested loops. The variable P controls the outer loop and the variable S controls
    the inner loop.").'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细想想，你会发现我们只需要两个循环：一个循环（外循环）用来遍历披萨类型，另一个循环（内循环）用来遍历沙拉类型。外循环从 P1 开始，而内循环依次尝试
    S1、S2 和 S3。然后外循环转到 P2，内循环再次选择 S1、S2 和 S3。这个过程一直持续，直到外循环遍历完所有四种披萨类型。这个思路的实现方式在[图
    7-15](ch07.html#visualizing_nested_loopsdot_the_variable "图 7-15. 可视化嵌套循环。变量 P
    控制外循环，变量 S 控制内循环。")中得到了说明。
- en: '*NestedLoops1.sb2*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*NestedLoops1.sb2*'
- en: '![Visualizing nested loops. The variable P controls the outer loop and the
    variable S controls the inner loop.](httpatomoreillycomsourcenostarchimages2134825.png.jpg)Figure 7-15. Visualizing
    nested loops. The variable `P` controls the outer loop and the variable `S` controls
    the inner loop.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![可视化嵌套循环。变量 P 控制外循环，变量 S 控制内循环。](httpatomoreillycomsourcenostarchimages2134825.png.jpg)图
    7-15. 可视化嵌套循环。变量 `P` 控制外循环，变量 `S` 控制内循环。'
- en: The script uses two loops and two counters. The counter for the outer loop is
    named `P`, and the counter for the inner loop is named `S`. In the first iteration
    of the outer loop (where `P = 1`), the value of counter `S` is set to 1, and the
    inner loop repeats three times. Each time, it executes a say command to display
    the current values of `P` and `S`, and then it increments `S` by 1\. Thus, the
    first iteration of the outer loop causes the sprite to say “P1,S1” and “P1,S2”
    and “P1,S3.”
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本使用了两个循环和两个计数器。外循环的计数器名为 `P`，内循环的计数器名为 `S`。在外循环的第一次迭代（`P = 1` 时），计数器 `S` 的值被设置为
    1，内循环重复执行三次。每次执行时，它会执行一个 `say` 命令来显示当前的 `P` 和 `S` 的值，然后将 `S` 增加 1。因此，外循环的第一次迭代会导致精灵依次说出“P1,S1”、“P1,S2”和“P1,S3”。
- en: When the inner loop terminates after looping three times, `P` is incremented
    by 1, and the second iteration of the outer loop starts. The value of `S` is reset
    to 1, and the inner loop is executed again. This causes the sprite to say “P2,S1”
    and “P2,S2” and “P2,S3.” The process continues in a similar manner, causing the
    sprite to say “P3,S1” and “P3,S2” and “P3,S3” and finally “P4,S1” and “P4,S2”
    and “P4,S3” before the script ends. Trace through this script to make sure you
    understand how it works.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当内循环在执行三次后终止时，`P` 的值增加 1，外循环的第二次迭代开始。此时，`S` 的值重置为 1，内循环再次执行。这会导致精灵依次说出“P2,S1”、“P2,S2”和“P2,S3”。这一过程以类似的方式继续，直到精灵说出“P3,S1”、“P3,S2”和“P3,S3”，最后是“P4,S1”、“P4,S2”和“P4,S3”，然后脚本结束。通过跟踪这个脚本，确保你理解它是如何工作的。
- en: Now that you’ve seen what nested loops can do, let’s apply this technique to
    solve an interesting math problem. We want to write a program to find three positive
    integers *n[1], n[2],* and *n[3]* such that *n[1] + n[2] + n[3] = 25* and *(n[1])²
    + (n[2])² + (n[3])²* = 243\. Because computers are good at repetitive tasks, our
    plan is to try all possible combinations of numbers (a technique called *exhaustive
    search*) and let the computer do the hard work.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了嵌套循环的应用，让我们将这一技巧应用于解决一个有趣的数学问题。我们要编写一个程序，找到三个正整数 *n[1]*、*n[2]* 和 *n[3]*，使得
    *n[1] + n[2] + n[3] = 25* 且 *(n[1])² + (n[2])² + (n[3])²* = 243。由于计算机擅长执行重复任务，我们的计划是尝试所有可能的数字组合（这种技巧称为
    *穷举搜索*），让计算机完成繁重的工作。
- en: Based on our first equation, the first number, *n[1]*, can have any value between
    1 and 23 since we’ll need to add two numbers to it to get 25\. (You might have
    noticed that *n[1]* can’t be more than 15 because 16² = 256, which is greater
    than 243\. But we’ll just ignore our second equation for now and set the upper
    limit of the loop to 23 anyway.)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的第一个方程，第一数字 *n[1]* 可以是 1 到 23 之间的任何值，因为我们需要再加两个数字才能得到 25。（你可能已经注意到，*n[1]*
    不能大于 15，因为 16² = 256，已经大于 243。但我们暂时忽略第二个方程，还是将循环的上限设置为 23。）
- en: The second number, *n[2]*, can be any value between 1 and 24 – *n[1]*. For example,
    if *n[1]* is 10, the maximum possible value of *n[2]* is 14 because *n[3]* must
    be at least 1\. If we know *n[1]* and *n[2]*, we can compute *n[3]* as 25 – (*n[1]*
    + *n[2]*). Then, we’ll need to check whether the sum of the squares of these three
    numbers is 243\. If it is, we are done. Otherwise, we need to try a different
    combination of *n[1]* and *n[2]*. You can see the finished script to find *n[1]*,
    *n[2]*, and *n[3]* in [Figure 7-16](ch07.html#this_script_searches_for_three_positive
    "Figure 7-16. This script searches for three positive numbers whose sum is 25
    and whose sum of squares is 243.").
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个数字 *n[2]* 可以是 1 到 24 - *n[1]* 之间的任何值。例如，如果 *n[1]* 为 10，则 *n[2]* 的最大可能值是 14，因为
    *n[3]* 至少为 1。如果我们知道了 *n[1]* 和 *n[2]*，就可以计算出 *n[3]* 为 25 - (*n[1]* + *n[2]*)。然后，我们需要检查这三个数字的平方和是否等于
    243。如果是，我们就完成了。否则，我们需要尝试不同的 *n[1]* 和 *n[2]* 组合。你可以在 [图7-16](ch07.html#this_script_searches_for_three_positive
    "图7-16。此脚本搜索三个正整数，其和为25，且平方和为243。") 中看到完成的脚本，用来找到 *n[1]*、*n[2]* 和 *n[3]*。
- en: '*NestedLoops2.sb2*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*NestedLoops2.sb2*'
- en: '![This script searches for three positive numbers whose sum is 25 and whose
    sum of squares is 243.](httpatomoreillycomsourcenostarchimages2134827.png.jpg)Figure 7-16. This
    script searches for three positive numbers whose sum is 25 and whose sum of squares
    is 243.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![此脚本搜索三个正整数，其和为25，且平方和为243。](httpatomoreillycomsourcenostarchimages2134827.png.jpg)
    图7-16。此脚本搜索三个正整数，其和为25，且平方和为243。'
- en: The outer loop tries all values of `n1` from 1 to 23\. For each value of `n1`,
    the inner loop tries all values of `n2` from 1 to (24 – `n1`). For each combination
    of `n1` and `n2`, the script sets `n3` equal to 25 – (`n1` + `n2`), and then it
    checks to see whether the sum of the squares of these three numbers is 243\. If
    it is, the script says the answer and stops.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 外层循环尝试从 1 到 23 的所有 `n1` 值。对于每个 `n1` 值，内层循环尝试从 1 到 (24 - `n1`) 的所有 `n2` 值。对于每个
    `n1` 和 `n2` 的组合，脚本将 `n3` 设置为 25 - (`n1` + `n2`)，然后检查这三个数字的平方和是否等于 243。如果是，脚本会输出答案并停止。
- en: Try It Out 7-5
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 实验 7-5
- en: Create the script shown in [Figure 7-16](ch07.html#this_script_searches_for_three_positive
    "Figure 7-16. This script searches for three positive numbers whose sum is 25
    and whose sum of squares is 243.") and run it to find *n*[1], *n*[2], and *n*[3].
    If you study the script carefully, you’ll find that it tries some (*n*[1], *n*[2])
    combinations more than once. For example, the numbers (1, 2) are tested in the
    first iteration of the outer loop, whereas the numbers (2, 1) are tried in the
    second iteration. These two tests are redundant; we only need one of them. You
    can fix this by having the inner loop start from *n*[1] instead of 1\. Make this
    change to the script and then run it to make sure it still works as expected.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 [图7-16](ch07.html#this_script_searches_for_three_positive "图7-16。此脚本搜索三个正整数，其和为25，且平方和为243。")
    中显示的脚本并运行它，以找出 *n*[1]、*n*[2]* 和 *n*[3]*。如果你仔细研究脚本，会发现它会多次尝试某些 (*n*[1]、*n*[2]*)
    组合。例如，数字 (1, 2) 在外层循环的第一次迭代中被测试，而数字 (2, 1) 会在第二次迭代中被测试。这两个测试是冗余的，我们只需要其中一个。你可以通过让内层循环从
    *n*[1] 而不是 1 开始来修复这个问题。对脚本进行此修改后，运行它并确保它仍然按预期工作。
- en: 'Recursion: Procedures that Call Themselves'
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归：调用自身的过程
- en: The repetition structures introduced so far allow us to repeat a command or
    a set of commands through iteration. Another powerful technique that produces
    repetition is *recursion*. Recursion allows a procedure to either call itself
    directly or do so indirectly through another procedure (for example, `A` calls
    `B`, `B` calls `C`, then `C` calls `A`). It may not be obvious why you want to
    do this, but it turns out that recursion can simplify the solution of many computer
    science problems. Let’s demonstrate this concept by considering the simple example
    shown in [Figure 7-17](ch07.html#recursive_procedure "Figure 7-17. A recursive
    procedure").
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止引入的重复结构允许我们通过迭代重复执行一个命令或一组命令。另一种强大的产生重复的技术是*递归*。递归允许一个过程直接调用自身，或通过另一个过程间接调用自身（例如，`A`调用`B`，`B`调用`C`，然后`C`调用`A`）。这可能不容易理解为什么要这么做，但事实证明，递归可以简化许多计算机科学问题的解决方案。让我们通过考虑[图7-17](ch07.html#recursive_procedure
    "图7-17. 一个递归过程")中展示的简单示例来演示这个概念。
- en: '*Recursion.sb2*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*Recursion.sb2*'
- en: '![A recursive procedure](httpatomoreillycomsourcenostarchimages2134829.png.jpg)Figure 7-17. A
    recursive procedure'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![递归过程](httpatomoreillycomsourcenostarchimages2134829.png.jpg)图7-17. 一个递归过程'
- en: The **Tic** procedure executes two **say** commands (the first says “Tic” and
    the second says “Tac”), then calls itself again. The second call does the same
    thing, and the sprite would continue saying, “Tic Tac” forever if no outside action
    stopped it. Of course, the only way to stop it in this case is to click the red
    stop icon. Having a procedure call itself this way allowed us to repeat the two
    **say** commands forever without using any loop blocks. The form of recursion
    used in this example is called *tail recursion* because the recursive call is
    located at the very end of the procedure. Scratch also allows recursive calls
    to come before the last line, but we won’t explore that type of recursion in this
    book.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**Tic**过程执行两个**say**命令（第一个说“Tic”，第二个说“Tac”），然后再次调用自身。第二次调用做同样的事情，如果没有外部操作停止，它会继续不断地说“Tik
    Tac”。当然，在这种情况下，唯一能停止它的方法是点击红色停止图标。让一个过程以这种方式调用自身，使我们能够无限重复这两个**say**命令，而无需使用任何循环块。这个示例中使用的递归形式称为*尾递归*，因为递归调用位于过程的最后一行。Scratch
    也允许递归调用出现在最后一行之前，但我们在本书中不会探讨这种递归类型。'
- en: Since infinite recursion is generally not a good idea, you must control the
    execution of a recursive procedure with conditionals. For example, the procedure
    could include an **if** block that determines whether the recursive call should
    be made. To demonstrate this technique, [Figure 7-18](ch07.html#if_block_is_used_to_determine_whether_le
    "Figure 7-18. The if block is used to determine whether (or not) the recursive
    call should be made.") shows a recursive procedure that counts from some initial
    number (specified by the parameter `count`) down to 0.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于无限递归通常不是一个好主意，你必须使用条件语句来控制递归过程的执行。例如，过程可以包括一个**if**语句块，用于判断是否应该进行递归调用。为了演示这一技巧，[图7-18](ch07.html#if_block_is_used_to_determine_whether_le
    "图7-18. 使用if语句块来确定是否进行递归调用")展示了一个递归过程，该过程从某个初始数字（由参数`count`指定）开始倒数到0。
- en: '![The if block is used to determine whether (or not) the recursive call should
    be made.](httpatomoreillycomsourcenostarchimages2134831.png.jpg)Figure 7-18. The
    if block is used to determine whether (or not) the recursive call should be made.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用if语句块来确定是否进行递归调用](httpatomoreillycomsourcenostarchimages2134831.png.jpg)图7-18.
    使用if语句块来确定是否进行递归调用'
- en: Let’s walk through how **CountDown** works when it is called with an argument
    of three. When the procedure starts, the **say** command shows the number 3, then
    checks whether `count` is greater than 0\. Since 3 is greater than 0, the procedure
    subtracts 1 from `count` to call itself with an argument of 2.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个实例如**CountDown**的调用，来了解它是如何工作的，当它的参数为3时。当过程开始时，**say**命令显示数字3，然后检查`count`是否大于0。由于3大于0，过程会从`count`中减去1，并以2作为参数再次调用自己。
- en: In the second call, the procedure shows the number 2 and, because 2 is greater
    than 0, calls itself one more time with an argument of 1\. This continues until
    the call `CountDown(0)` is made. After showing the number 0 in a voice bubble,
    the procedure checks whether `count` is greater than 0\. Since the expression
    in the header of the **if** block evaluates to false, no further recursive calls
    will be made, and the procedure returns. Try to follow the return path shown in
    [Figure 7-18](ch07.html#if_block_is_used_to_determine_whether_le "Figure 7-18. The
    if block is used to determine whether (or not) the recursive call should be made.").
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次调用中，过程显示数字2，并且由于2大于0，它会再次调用自己，参数为1。这一过程持续进行，直到调用`CountDown(0)`。在语音气泡中显示数字0后，过程检查`count`是否大于0。由于**if**块中的表达式计算结果为假，之后不会进行任何递归调用，过程返回。试着按照[图7-18](ch07.html#if_block_is_used_to_determine_whether_le
    "Figure 7-18. if块用于确定是否（或不）进行递归调用")所示的返回路径进行跟踪。
- en: Now that we’ve covered the basics of tail recursion, we can apply it to more
    interesting applications. Let’s consider, for example, the **Blade** procedure
    shown in [Figure 7-19](ch07.html#using_a_spriteapostrophes_direction_to_s "Figure 7-19. Using
    a sprite’s direction to stop recursion").
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了尾递归的基本概念，可以将其应用于更有趣的应用场景。例如，考虑[图7-19](ch07.html#using_a_spriteapostrophes_direction_to_s
    "Figure 7-19. 使用精灵的方向来停止递归")中所示的**Blade**过程。
- en: '*RecursionBlade.sb2*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*RecursionBlade.sb2*'
- en: '![Using a sprite’s direction to stop recursion](httpatomoreillycomsourcenostarchimages2134833.png.jpg)Figure 7-19. Using
    a sprite’s direction to stop recursion'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用精灵的方向来停止递归](httpatomoreillycomsourcenostarchimages2134833.png.jpg)图7-19.
    使用精灵的方向来停止递归'
- en: We assume that the sprite that executes this procedure starts somewhere on the
    Stage pointing in the direction of 90°. After drawing an equilateral triangle,
    the sprite moves 12 steps forward and then turns 10° counterclockwise. The procedure
    then checks the new direction of the sprite. If the sprite is not pointing in
    the direction of 90°, the procedure calls itself again to draw the next triangle
    in the sequence. Otherwise, the recursive call doesn’t happen, and the procedure
    ends after drawing the saw blade shown in [Figure 7-19](ch07.html#using_a_spriteapostrophes_direction_to_s
    "Figure 7-19. Using a sprite’s direction to stop recursion").
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设执行此过程的精灵从舞台上的某个位置开始，朝着90°的方向指向。绘制等边三角形后，精灵向前移动12步，然后逆时针转10°。此过程随后检查精灵的新方向。如果精灵没有指向90°的方向，过程会再次调用自己，绘制序列中的下一个三角形。否则，不会发生递归调用，过程在绘制完[图7-19](ch07.html#using_a_spriteapostrophes_direction_to_s
    "Figure 7-19. 使用精灵的方向来停止递归")所示的锯齿形后结束。
- en: For simple examples like the ones shown here, it is probably easier to use a
    **repeat** block to achieve the desired repetition. But as I mentioned at the
    start of this section, there are many problems that are easier to solve with recursion
    rather than iteration.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像这里展示的简单例子，使用**repeat**块可能更容易实现所需的重复。但是正如我在本节开始时提到的，很多问题使用递归比使用迭代更容易解决。
- en: Try It Out 7-6
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下 7-6
- en: What does the following procedure do? Implement it and call it with different
    arguments to check your answer.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下过程的功能是什么？实现它并使用不同的参数进行调用，以验证你的答案。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2134835.png.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2134835.png.jpg)'
- en: Scratch Projects
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scratch项目
- en: Now that you know how to use repetition to your advantage in Scratch scripts,
    it’s time to put what we’ve learned in this chapter to some practical use. In
    this section, I’ll guide you through a range of projects to help you strengthen
    your understanding of programming and provide you with some ideas for your own
    projects.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何在Scratch脚本中利用重复来获得优势，是时候将我们在本章学到的内容付诸实践了。在这一节中，我将引导你完成一系列项目，帮助你加深对编程的理解，并为你的项目提供一些灵感。
- en: Analog Clock
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟时钟
- en: 'The **current** block from the *Sensing* palette can report the current year,
    month, date, day of the week, hour, minutes, or seconds, depending on what you
    select from the drop-down menu. Our first project will use this block to implement
    the analog clock shown in [Figure 7-20](ch07.html#analog_clock_application "Figure 7-20. The
    Analog Clock application"). The application contains four sprites: the `Sec`,
    `Min`, and `Hour` sprites, which represent the three hands of the clock, and the
    `Time` sprite (a small white dot), which displays the time in digital format (see
    the thought bubble in the figure).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*Sensing*调色板中的**当前**模块可以报告当前的年份、月份、日期、星期几、小时、分钟或秒数，具体取决于你从下拉菜单中选择的项。我们的第一个项目将使用此模块来实现如[图7-20](ch07.html#analog_clock_application
    "图7-20. 模拟时钟应用")所示的模拟时钟。该应用包含四个精灵：`Sec`、`Min`和`Hour`精灵，代表时钟的三根指针，和`Time`精灵（一个小白点），显示数字格式的时间（见图中的思考气泡）。'
- en: '*AnalogClock.sb2*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*AnalogClock.sb2*'
- en: '![The Analog Clock application](httpatomoreillycomsourcenostarchimages2134837.png.jpg)Figure 7-20. The
    Analog Clock application'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![模拟时钟应用](httpatomoreillycomsourcenostarchimages2134837.png.jpg)图7-20. 模拟时钟应用'
- en: The clock starts running when the green flag is clicked. In response, all four
    sprites start a **forever** loop to update their status based on the current system
    time. The scripts for the `Sec` and `Min` sprites are shown in [Figure 7-21](ch07.html#scripts_for_the_sec_and_min_sprites
    "Figure 7-21. The scripts for the Sec and Min sprites").
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击绿色旗帜时，时钟开始运行。作为响应，所有四个精灵都开始一个**永远**循环，根据当前系统时间更新它们的状态。`Sec`和`Min`精灵的脚本如[图7-21](ch07.html#scripts_for_the_sec_and_min_sprites
    "图7-21. Sec和Min精灵的脚本")所示。
- en: '![The scripts for the Sec and Min sprites](httpatomoreillycomsourcenostarchimages2134839.png.jpg)Figure 7-21. The
    scripts for the `Sec` and `Min` sprites'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![Sec和Min精灵的脚本](httpatomoreillycomsourcenostarchimages2134839.png.jpg)图7-21.
    `Sec`和`Min`精灵的脚本'
- en: The number of seconds and minutes reported by the **current** block ranges from
    0 to 59\. When the system reports 0 seconds, the `Sec` sprite should point up
    (toward 0°), at 15 seconds, the `Sec` sprite should point right (toward 90°),
    and so on. Every second, the `Sec` hand should turn 6° (360° divided by 60 seconds)
    clockwise. A similar reasoning applies to the `Min` hand. If you watch this clock
    running, you’ll notice the `Sec` hand jumping every second and the `Min` hand
    jumping every minute. Now, let’s look at the script for the `Hour` sprite, shown
    in [Figure 7-22](ch07.html#script_for_the_hour_sprite "Figure 7-22. The script
    for the Hour sprite").
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**当前**模块报告的秒数和分钟数范围从0到59。当系统报告0秒时，`Sec`精灵应指向上方（朝向0°），在15秒时，`Sec`精灵应指向右方（朝向90°），以此类推。每秒钟，`Sec`指针应顺时针旋转6°（360°除以60秒）。同样的逻辑适用于`Min`指针。如果你观察这个时钟运行，你会注意到`Sec`指针每秒跳动一次，而`Min`指针每分钟跳动一次。现在，让我们看看`Hour`精灵的脚本，如[图7-22](ch07.html#script_for_the_hour_sprite
    "图7-22. Hour精灵的脚本")所示。'
- en: '![The script for the Hour sprite](httpatomoreillycomsourcenostarchimages2134841.png.jpg)Figure 7-22. The
    script for the `Hour` sprite'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![Hour精灵的脚本](httpatomoreillycomsourcenostarchimages2134841.png.jpg)图7-22. `Hour`精灵的脚本'
- en: The **current(hour)** block reports the system clock’s hour as a number from
    0 to 23\. We need the `Hour` hand to point toward 0° (that is, up) for hour 0,
    30° for hour one, 60° for hour two, and so on, as illustrated in the figure. Of
    course, if the current time is, let’s say, 11:50, we don’t want the `Hour` hand
    to point exactly at 11 but rather more toward 12\. We can make this adjustment
    by taking the current minutes into account.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**当前（小时）**模块报告系统时钟的小时数，范围从0到23。我们需要让`Hour`指针在小时0时指向0°（即朝上），小时1时指向30°，小时2时指向60°，依此类推，如图所示。当然，如果当前时间是11:50，我们并不希望`Hour`指针精确指向11，而是更接近12。我们可以通过考虑当前的分钟数来进行这种调整。'
- en: Since every hour (or 60 minutes) corresponds to 30° on the face of the clock,
    every minute is worth 2°. Therefore, every minute, we need to adjust the angle
    of the `Hour` hand by the current number of minutes divided by 2, as shown in
    the script.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每小时（或60分钟）对应时钟面上的30°，每分钟对应2°。因此，每分钟，我们需要根据当前的分钟数除以2来调整`Hour`指针的角度，如脚本所示。
- en: The script for the `Time` sprite is trivial and isn’t shown here. It uses nested
    **join** blocks to construct a display string of the form *hour*:*min*:*sec* and
    shows this string in a think bubble, as shown in [Figure 7-20](ch07.html#analog_clock_application
    "Figure 7-20. The Analog Clock application").
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`Time`精灵的脚本很简单，在这里不展示。它使用嵌套的**join**积木构造类似*hour*:*min*:*sec*的显示字符串，并将该字符串显示在思维气泡中，如图[7-20](ch07.html#analog_clock_application
    "图 7-20. 模拟时钟应用")所示。'
- en: Try It Out 7-7
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 实践 7-7
- en: 'Open the application and run it. Change the script for the `Min` sprite to
    make it move smoothly, instead of jumping every minute. (Hint: Use the same idea
    we applied to smooth the movement of the hour hand.) Also, change the script of
    the `Time` sprite to display a string of the form “3:25:00 PM” (12-hour format)
    instead of “15:25:00” (24-hour format). Think of other ways to enhance the application
    and try to implement them as well.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 打开应用程序并运行。修改`Min`精灵的脚本，使其平滑移动，而不是每分钟跳动一次。（提示：使用我们之前用来平滑时针移动的相同思路。）此外，修改`Time`精灵的脚本，使其显示类似“3:25:00
    PM”格式的字符串（12小时制），而不是“15:25:00”（24小时制）。想想其他可以增强应用程序的方式，并尝试实现它们。
- en: Bird Shooter Game
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 鸟类射击游戏
- en: Now, let’s make a simple game that uses most of the blocks we introduced in
    this chapter. The player’s goal will be to knock two birds out of the sky, and
    you can see the user interface in [Figure 7-23](ch07.html#user_interface_of_the_bird_shooter_game
    "Figure 7-23. User interface of the bird shooter game").
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们制作一个简单的游戏，使用本章介绍的大部分积木。玩家的目标是将两只鸟从天上打下来，您可以在图[7-23](ch07.html#user_interface_of_the_bird_shooter_game
    "图 7-23. 鸟类射击游戏的用户界面")中看到用户界面。
- en: '*BirdShooter.sb2*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*BirdShooter.sb2*'
- en: '![User interface of the bird shooter game](httpatomoreillycomsourcenostarchimages2134843.png.jpg)Figure 7-23. User
    interface of the bird shooter game'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![鸟类射击游戏的用户界面](httpatomoreillycomsourcenostarchimages2134843.png.jpg)图 7-23.
    鸟类射击游戏的用户界面'
- en: 'As shown, the game contains five sprites: `Bird1`, a clone of `Bird1`, `Bird2`,
    a shooter, and a bullet. The player can move the shooter horizontally using the
    left and right keyboard arrows. Pressing the spacebar fires a bullet into the
    sky. If the bullet hits `Bird1` or its clone, the player gets a point. `Bird2`
    is an endangered species, so the player isn’t allowed to shoot that one; if the
    bullet hits that sprite, the game ends. The player has one minute to shoot as
    many birds as possible.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，游戏包含五个精灵：`Bird1`、`Bird1`的克隆、`Bird2`、一个射击者和一颗子弹。玩家可以使用键盘左右箭头水平移动射击者。按下空格键会发射一颗子弹进入空中。如果子弹击中`Bird1`或其克隆，玩家会获得1分。`Bird2`是濒危物种，玩家不能射击它；如果子弹击中该精灵，游戏结束。玩家有一分钟时间尽可能多地射击鸟类。
- en: Each bird uses two costumes. When switching between these two costumes, the
    birds appear to be flapping their wings.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 每只鸟使用两个服装。在这两个服装之间切换时，鸟看起来像是在拍动翅膀。
- en: The Stage has two backgrounds named `start` and `end`. The `start` background
    is shown in [Figure 7-23](ch07.html#user_interface_of_the_bird_shooter_game "Figure 7-23. User
    interface of the bird shooter game"). The `end` background is identical, with
    the addition of the words *Game Over* to the center of the image. The scripts
    that belong to the Stage are shown in [Figure 7-24](ch07.html#scripts_for_the_stage_in_the_bird_shoote
    "Figure 7-24. The scripts for the Stage in the bird shooter game").
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 舞台有两个背景，分别命名为`start`和`end`。`start`背景如图[7-23](ch07.html#user_interface_of_the_bird_shooter_game
    "图 7-23. 鸟类射击游戏的用户界面")所示。`end`背景与之相同，只是在图像的中央添加了*游戏结束*字样。属于舞台的脚本如图[7-24](ch07.html#scripts_for_the_stage_in_the_bird_shoote
    "图 7-24. 鸟类射击游戏中舞台的脚本")所示。
- en: '![The scripts for the Stage in the bird shooter game](httpatomoreillycomsourcenostarchimages2134845.png.jpg)Figure 7-24. The
    scripts for the Stage in the bird shooter game'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![鸟类射击游戏中舞台的脚本](httpatomoreillycomsourcenostarchimages2134845.png.jpg)图 7-24.
    鸟类射击游戏中舞台的脚本'
- en: When the green flag icon is pressed, the Stage switches to the `start` background,
    resets the timer, and starts a loop that updates and checks the remaining game
    time, which is tracked by the `TimeLeft` variable. When `TimeLeft` reaches 0 or
    when the Stage receives the `GameOver` broadcast message, it executes the `GameOver`
    handler. This script waits for a short time to allow the birds to hide themselves,
    switches to the `end` backdrop, and calls **stop all** to end any running scripts.
    As you’ll see soon, the `GameOver` message will be sent by the `Bullet` sprite
    when it hits `Bird2`. Let’s now take a look at the script for the `Shooter` sprite,
    shown in [Figure 7-25](ch07.html#script_for_the_shooter_sprite "Figure 7-25. The
    script for the Shooter sprite").
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击绿色旗帜时，舞台切换到`start`背景，重置计时器，并启动一个循环，更新并检查剩余的游戏时间，这由`TimeLeft`变量跟踪。当`TimeLeft`为0或舞台收到`GameOver`广播消息时，执行`GameOver`处理程序。这个脚本等待一段时间，允许小鸟隐藏自己，切换到`end`背景，并调用**stop
    all**终止所有正在运行的脚本。如你所见，`GameOver`消息会在`Bullet`精灵击中`Bird2`时发送。现在我们来看一下`Shooter`精灵的脚本，如[图7-25](ch07.html#script_for_the_shooter_sprite
    "图7-25. Shooter精灵的脚本")所示。
- en: '![The script for the Shooter sprite](httpatomoreillycomsourcenostarchimages2134847.png.jpg)Figure 7-25. The
    script for the `Shooter` sprite'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![射手精灵的脚本](httpatomoreillycomsourcenostarchimages2134847.png.jpg)图7-25. `Shooter`精灵的脚本'
- en: This script starts by positioning the shooter in the middle of the bottom edge
    of the Stage. The script then enters an infinite loop that detects whether the
    left or right arrow keys have been pressed and moves the shooter in the corresponding
    direction. Now let’s move on to the scripts for `Bird1`, shown in [Figure 7-26](ch07.html#scripts_for_the_bird1_sprite
    "Figure 7-26. The scripts for the Bird1 sprite").
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本首先将射手定位在舞台底部中间位置。脚本随后进入一个无限循环，检测左箭头或右箭头是否被按下，并根据按键方向移动射手。接下来，让我们来看一下`Bird1`的脚本，如[图7-26](ch07.html#scripts_for_the_bird1_sprite
    "图7-26. Bird1精灵的脚本")所示。
- en: '![The scripts for the Bird1 sprite](httpatomoreillycomsourcenostarchimages2134849.png.jpg)Figure 7-26. The
    scripts for the `Bird1` sprite'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![Bird1精灵的脚本](httpatomoreillycomsourcenostarchimages2134849.png.jpg)图7-26.
    `Bird1`精灵的脚本'
- en: When the game starts, `Bird1` clones itself, moves to left edge of the Stage,
    and calls the **Start** procedure. The clone also starts at the left edge of the
    Stage (but at a different height) and calls **Start**. This procedure uses a **forever**
    loop to move the bird and its clone horizontally across the Stage, from left to
    right with random steps. When the bird approaches the right edge of the stage,
    it is moved back to the left edge, as if it wraps around and reappears. The last
    script hides both birds when the `GameOver` message is broadcast.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开始时，`Bird1`会克隆自己，移动到舞台的左边缘，并调用**开始**过程。克隆也从舞台的左边缘开始（但高度不同），并调用**开始**。这个过程使用**forever**循环，将小鸟及其克隆横向移动整个舞台，从左到右，步长随机。当小鸟接近舞台的右边缘时，会被移回左边缘，好像绕了过去重新出现。最后一个脚本会在`GameOver`消息广播时隐藏两只小鸟。
- en: The scripts for `Bird2` are very similar to those of `Bird1`, so we won’t show
    them here. When the green flag is clicked, `Bird2` moves to the right edge of
    the Stage at a height of 40 and then executes a loop similar to that of the **Start**
    procedure of [Figure 7-26](ch07.html#scripts_for_the_bird1_sprite "Figure 7-26. The
    scripts for the Bird1 sprite"). The bird simply moves from left to right, wrapping
    around when it reaches the right edge of the Stage. `Bird2` also responds to the
    `GameOver` broadcast by hiding itself.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bird2`的脚本与`Bird1`的脚本非常相似，因此我们在此不再展示。当点击绿色旗帜时，`Bird2`会移动到舞台右侧的高度40位置，然后执行一个类似于[图7-26](ch07.html#scripts_for_the_bird1_sprite
    "图7-26. Bird1精灵的脚本")的**开始**过程的循环。小鸟从左向右移动，遇到舞台右侧时会绕回去。`Bird2`还会响应`GameOver`广播，隐藏自己。'
- en: Of course, the player can’t hit any birds just by moving the shooter around,
    and that’s where the `Bullet` sprite comes in. The main script for this sprite
    is shown in [Figure 7-27](ch07.html#main_script_of_the_bullet_sprite "Figure 7-27. The
    main script of the Bullet sprite").
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，玩家光靠移动射手是无法击中任何小鸟的，这就是`Bullet`精灵的作用。该精灵的主脚本如[图7-27](ch07.html#main_script_of_the_bullet_sprite
    "图7-27. Bullet精灵的主脚本")所示。
- en: '![The main script of the Bullet sprite](httpatomoreillycomsourcenostarchimages2134851.png.jpg)Figure 7-27. The
    main script of the `Bullet` sprite'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![子弹精灵的主脚本](httpatomoreillycomsourcenostarchimages2134851.png.jpg)图7-27. `Bullet`精灵的主脚本'
- en: When the green flag is clicked, this script initializes the variables `Fired`
    (the number of bullets fired) and `Hits` (how many birds have been hit) to 0\.
    It then points the `Bullet` sprite up and hides it. After that, it enters an infinite
    loop to repeatedly check the status of the spacebar key. When spacebar is pressed,
    the script increments `Fired` by 1 and creates a clone of the `Bullet` sprite
    to move the bullet upward, as we’ll see next. The script then waits some time
    to prevent the player from firing another bullet too soon. Now we’re ready to
    study the script of the cloned bullet, shown in [Figure 7-28](ch07.html#startup_handler_of_a_cloned_bullet
    "Figure 7-28. The startup handler of a cloned Bullet").
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击绿色旗帜时，脚本会初始化变量 `Fired`（发射的子弹数量）和 `Hits`（击中鸟类的数量）为0。然后它会将 `Bullet` 精灵指向上方并将其隐藏。之后，进入一个无限循环，反复检查空格键的状态。当按下空格键时，脚本会将
    `Fired` 增加1，并创建一个 `Bullet` 精灵的克隆体，让子弹向上移动，如我们接下来所看到的。脚本接着等待一段时间，以防玩家过快发射下一个子弹。现在我们准备好研究克隆子弹的脚本，见[图7-28](ch07.html#startup_handler_of_a_cloned_bullet
    "图7-28. 克隆子弹的启动处理程序")。
- en: First, the `Bullet` is moved to the center of the `Shooter` and is made visible
    ①. The `Bullet` is then moved upward in increments of 10 steps using a **repeat
    until** block ②. If the bullet’s *y*-coordinate exceeds 160, then the `Bullet`
    has reached the upper edge of the Stage without touching any birds. In this case,
    the **repeat until** block exits ⑤, and the clone is deleted. A hit check, however,
    is performed each time the bullet moves. If the bullet touches `Bird1` (or its
    clone) ③, the script increases the `Hits` variable and plays a sound to make the
    game more exciting. On the other hand, if the bullet touches `Bird2` ④, the script
    broadcasts `GameOver` to signal the end of the game. In both cases, the clone
    is deleted since it has finished its job.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`Bullet` 被移动到 `Shooter` 的中心并显示出来①。然后，使用**repeat until**块以10步的增量将 `Bullet`
    向上移动②。如果子弹的 *y* 坐标超过160，则表示 `Bullet` 已经到达舞台的上边缘且未击中任何鸟类。在这种情况下，**repeat until**
    块退出⑤，克隆体被删除。然而，每次子弹移动时都会执行击中检查。如果子弹触碰到 `Bird1`（或其克隆体）③，脚本会增加 `Hits` 变量并播放一个音效，让游戏更加刺激。另一方面，如果子弹触碰到
    `Bird2` ④，脚本会广播 `GameOver` 信号，标志着游戏结束。在这两种情况下，克隆体都会被删除，因为它已经完成了任务。
- en: '![The startup handler of a cloned Bullet](httpatomoreillycomsourcenostarchimages2134853.png.jpg)Figure 7-28. The
    startup handler of a cloned `Bullet`'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![克隆子弹的启动处理程序](httpatomoreillycomsourcenostarchimages2134853.png.jpg)图7-28.
    克隆 `Bullet` 的启动处理程序'
- en: 'The game is now fully functional, but you could add many features to it. Here
    are two suggestions:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已经完全功能化，但你可以为其添加许多新特性。这里有两个建议：
- en: Give the player a limited number of bullets and keep score based on the number
    of missed shots.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给玩家设定一个有限的子弹数量，并根据错过的射击次数进行记分。
- en: Add more birds and have them move at different speeds. Reward the player with
    more points for hitting faster birds.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加更多的鸟类，并让它们以不同的速度移动。对于击中速度更快的鸟类，奖励玩家更多的分数。
- en: Try It Out 7-8
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 试试7-8
- en: Open the game and play it to see how it works. Modify the game with some of
    the enhancements suggested above—or come up with a few of your own and implement
    those!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 打开游戏并进行游玩，看看它是如何工作的。根据上述建议进行修改，或者想出一些自己的增强功能并实现它们！
- en: Free-Fall Simulation
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自由落体模拟
- en: In this section, I’ll present an application that simulates the motion of a
    falling object. Ignoring the effects of buoyancy and air resistance, when an object
    at rest is dropped from some height, the distance *d* (in meters) fallen by the
    object during time *t* (in seconds) is given by *d* = ½ *gt*², where *g* = 9.8
    m/s² is the gravitational acceleration. The goal of this simulation is to show
    the position of the falling object at times 0.5 s, 1.0 s, 1.5 s, 2.0 s, and so
    on, until the object reaches the ground. The interface for this simulation is
    shown in [Figure 7-29](ch07.html#user_interface_for_the_free-fall_simulat "Figure 7-29. User
    interface for the free-fall simulation").
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我将展示一个模拟自由落体运动的应用程序。忽略浮力和空气阻力的影响，当一个静止物体从某个高度被释放时，物体在时间 *t*（秒）内下落的距离 *d*（米）由公式
    *d* = ½ *gt*² 给出，其中 *g* = 9.8 m/s² 为重力加速度。这个模拟的目标是展示物体在0.5秒、1.0秒、1.5秒、2.0秒等时间点的下落位置，直到物体触地。这个模拟的界面如[图7-29](ch07.html#user_interface_for_the_free-fall_simulat
    "图7-29. 自由落体模拟的用户界面")所示。
- en: '*FreeFall.sb2*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*FreeFall.sb2*'
- en: '![User interface for the free-fall simulation](httpatomoreillycomsourcenostarchimages2134855.png.jpg)Figure 7-29. User
    interface for the free-fall simulation'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![自由落体仿真用户界面](httpatomoreillycomsourcenostarchimages2134855.png.jpg)图7-29.
    自由落体仿真用户界面'
- en: An object at rest (the ball in the figure) will be allowed to fall from a height
    of 35 m. A simple substitution in the above formula shows that the object will
    reach the ground after ![](httpatomoreillycomsourcenostarchimages2134857.png.jpg)
    s. The application has one sprite (called `Ball`) that has the two costumes shown
    in the figure. When it is time to show the position of the falling ball, the sprite
    changes momentarily to the `marker` costume, makes a stamp, and switches back
    to the `ball` costume.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一个静止的物体（图中的球）将被允许从35米的高度下落。通过简单的代入上述公式可以得出物体将在![](httpatomoreillycomsourcenostarchimages2134857.png.jpg)秒后到达地面。该应用程序有一个精灵（称为`Ball`），它有图中显示的两个服装。当需要显示下落球体的位置时，精灵会短暂地切换到`marker`服装，做出印章，并切换回`ball`服装。
- en: The simulation starts when the green flag is clicked. In response, the `Ball`
    sprite runs the script shown in [Figure 7-30](ch07.html#script_for_the_ball_sprite_in_the_free-f
    "Figure 7-30. Script for the Ball sprite in the free-fall simulation").
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 仿真在点击绿色旗帜时开始。作为响应，`Ball`精灵运行[图7-30](ch07.html#script_for_the_ball_sprite_in_the_free-f
    "图7-30. 自由落体仿真中的Ball精灵脚本")所示的脚本。
- en: During initialization ①, the sprite moves to its starting position, switches
    to the `ball` costume, clears its voice bubble from the previous run, and clears
    the Stage from any previous stamps. It then initializes `t` and `counter` to 0\.
    The variable `t` represents the duration of the fall, and `counter` keeps track
    of the number of loop repetitions.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化①期间，精灵移动到起始位置，切换到`ball`服装，清除上次运行的语音气泡，并清除舞台上之前的印章。接着，初始化`t`和`counter`为0。变量`t`代表下落的持续时间，`counter`用于跟踪循环的重复次数。
- en: The script then enters an infinite loop ② to calculate the simulation parameters
    at different time intervals. It performs those calculations and updates the ball’s
    position every 0.05 s ③ to ensure the ball’s smooth movement. Every 0.05 s, the
    value of the time variable `t` is updated, and the distance the ball has fallen
    (`d`) is calculated. The value of the `counter` variable is also incremented by
    1.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，脚本进入一个无限循环②，以在不同的时间间隔计算仿真参数。它每隔0.05秒③进行一次计算并更新球的位置，以确保球的平滑运动。每0.05秒，时间变量`t`的值会更新，计算球下落的距离（`d`）。`counter`变量的值也会增加1。
- en: '![Script for the Ball sprite in the free-fall simulation](httpatomoreillycomsourcenostarchimages2134859.png.jpg)Figure 7-30. Script
    for the `Ball` sprite in the free-fall simulation'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![自由落体仿真中的Ball精灵脚本](httpatomoreillycomsourcenostarchimages2134859.png.jpg)图7-30.
    自由落体仿真中的`Ball`精灵脚本'
- en: If the ball reaches the ground (which happens at `d` ≥ `35`), the script sets
    the ball’s *y*-position to that of the ground, displays the actual duration of
    the journey, and stops the script to end the simulation ④.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果球到达地面（当`d` ≥ `35`时发生），脚本将球的*y*位置设置为地面的高度，显示实际的运动时间，并停止脚本以结束仿真④。
- en: Otherwise, the script sets the vertical position of the ball in accordance with
    the fallen distance ⑤. Since a height of 35 m corresponds to 268 pixels on the
    Stage (see [Figure 7-29](ch07.html#user_interface_for_the_free-fall_simulat "Figure 7-29. User
    interface for the free-fall simulation")), a distance of *d* meters corresponds
    to `268 *` (`d / 35`). The final *y*-position is established by subtracting this
    number from the initial *y*-position, which is 136.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，脚本会根据下落的距离⑤设置球的垂直位置。由于35米的高度对应舞台上的268像素（见[图7-29](ch07.html#user_interface_for_the_free-fall_simulat
    "图7-29. 自由落体仿真用户界面")），*d*米的距离对应于`268 *`（`d / 35`）。最终的*y*位置通过从初始*y*位置（136）中减去这个数值来确定。
- en: Since the iteration duration is 0.05 s, it takes 10 iterations to get 0.5 s.
    Thus, when the counter becomes 10, 20, 30, and so on, the `Ball` sprite switches
    to (and stamps) the `marker` costume to show the position of the falling ball
    at those instants ⑥.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于迭代时间为0.05秒，获取0.5秒需要10次迭代。因此，当计数器达到10、20、30等时，`Ball`精灵会切换到（并且印上）`marker`服装，以显示下落球体在这些瞬间的位置⑥。
- en: '[Figure 7-31](ch07.html#output_of_the_free-fall_simulation "Figure 7-31. Output
    of the free-fall simulation") illustrates the result of running this simulation.
    Note how the distance fallen in each time interval increases as the object falls.
    Because of gravity, the ball accelerates—its velocity increases—at a rate of 9.8
    m/s².'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-31](ch07.html#output_of_the_free-fall_simulation "图 7-31. 自由落体模拟的结果")展示了运行该模拟的结果。注意每个时间间隔内物体下落的距离是如何随着物体下落而增大的。由于重力，球体加速——其速度增加——加速度为
    9.8 m/s²。'
- en: Try It Out 7-9
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下 7-9
- en: Open the application and run it to understand how it works. Try converting the
    simulation into a game in which players drop the ball to hit a moving object on
    the ground. You can add a score, change the speed of the target, or even set the
    action on another planet (change the gravitational acceleration).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 打开应用程序并运行它，以理解其工作原理。尝试将模拟转变为一款游戏，玩家需要将球投掷到地面上的移动物体上。你可以添加得分，改变目标的速度，甚至设定在另一个星球上的动作（改变重力加速度）。
- en: '![Output of the free-fall simulation](httpatomoreillycomsourcenostarchimages2134861.png.jpg)Figure 7-31. Output
    of the free-fall simulation'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![自由落体模拟的结果](httpatomoreillycomsourcenostarchimages2134861.png.jpg)图 7-31. 自由落体模拟的结果'
- en: Projectile Motion Simulator
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 投射运动模拟器
- en: Consider a ball fired at some initial velocity (*v*[0]) from a cannon that points
    at an angle *q* from the horizontal. You can analyze the ball’s trajectory by
    resolving the velocity vector (*v*[0]) into its horizontal and vertical components
    at different times. The horizontal component remains constant, but the vertical
    component is affected by gravity. When the motions corresponding to these two
    components are combined, the resulting path is a parabola. Let’s examine the equations
    that govern projectile motion (neglecting air resistance).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一颗初速为 (*v*[0]) 的球从炮筒发射，炮筒与水平方向夹角为 *q*。你可以通过将速度向量 (*v*[0]) 在不同时间点分解成水平和垂直分量来分析球的轨迹。水平分量保持不变，但垂直分量受到重力的影响。当这两个分量的运动结合起来时，结果路径是一个抛物线。让我们来研究一下支配投射运动的方程（忽略空气阻力）。
- en: '*Projectile .sb2*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*Projectile .sb2*'
- en: The origin of our coordinate system is the point at which the ball begins its
    flight, so the ball’s *x*-coordinate at any time, *t*, is given by *x*(*t*) *=
    v*[0]*[x]t*, and the *y*-coordinate is *y*(*t*) *= v*[0]*[y]t* – (0.5)*gt²*, where
    *v*[0]*[x] = v*[0] cos *q* is the *x*- component of *v*[0]; *v*[0]*[y] = v*[0]
    sin *q* is the *y*-component of *v*[0]; and *g* = 9.8 m/s² is the gravitational
    acceleration. Using these equations, we can calculate the total flight time, the
    maximum height, and the horizontal range of the ball. The equations for these
    quantities are shown in [Figure 7-32](ch07.html#parabolic_trajectory_of_a_ball
    "Figure 7-32. Parabolic trajectory of a ball").
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们坐标系的原点是球开始飞行的点，因此球体在任何时刻 *t* 的 *x* 坐标由 *x*(*t*) = *v*[0]*[x]t* 给出，*y* 坐标由
    *y*(*t*) = *v*[0]*[y]t* – (0.5)*gt²* 给出，其中 *v*[0]*[x] = *v*[0] cos *q* 是 *v*[0]
    的 *x* 分量；*v*[0]*[y] = *v*[0] sin *q* 是 *v*[0] 的 *y* 分量；*g* = 9.8 m/s² 是重力加速度。利用这些方程，我们可以计算出球的总飞行时间、最大高度和水平射程。这些量的方程如[图 7-32](ch07.html#parabolic_trajectory_of_a_ball
    "图 7-32. 球的抛物线轨迹")所示。
- en: '![Parabolic trajectory of a ball](httpatomoreillycomsourcenostarchimages2134863.png.jpg)Figure 7-32. Parabolic
    trajectory of a ball'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![球的抛物线轨迹](httpatomoreillycomsourcenostarchimages2134863.png.jpg)图 7-32. 球的抛物线轨迹'
- en: This information is all we need to realistically simulate the ball’s motion,
    so let’s create a Scratch program so we can see this bit of physics in action
    and deepen our understanding of trajectories. The user interface of the simulation
    is shown in [Figure 7-33](ch07.html#user_interface_for_the_projectile_motion "Figure 7-33. User
    interface for the projectile motion simulator").
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息是我们实际模拟球体运动所需的全部内容，因此让我们创建一个 Scratch 程序，以便观察这段物理过程的实际表现，并加深我们对轨迹的理解。模拟的用户界面如[图 7-33](ch07.html#user_interface_for_the_projectile_motion
    "图 7-33. 投射运动模拟器的用户界面")所示。
- en: '![User interface for the projectile motion simulator](httpatomoreillycomsourcenostarchimages2134865.png.jpg)Figure 7-33. User
    interface for the projectile motion simulator'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '![投射运动模拟器的用户界面](httpatomoreillycomsourcenostarchimages2134865.png.jpg)图 7-33. 投射运动模拟器的用户界面'
- en: As shown, the application contains four sprites. The `Wheel` sprite provides
    a rotation shaft for the cannon, while the `Cannon` sprite, which rotates in accordance
    with the `angle` slider, provides a visual indication of the launch angle. The
    `Fire` sprite is a button that the user clicks to fire the ball, and the `Ball`
    sprite contains the main script for calculating the ball’s coordinates and drawing
    its trajectory. The user specifies the launch angle and the initial velocity using
    the two slider controls, then clicks the `Fire` button. The `Ball` starts from
    point (–180, –140) on the Stage and draws the parabolic trajectory for the specified
    parameters. The two monitors at the lower-right corner of the Stage show the flight
    time and the horizontal range during the flight.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，应用程序包含四个角色精灵。`Wheel`精灵为大炮提供了旋转轴，而`Cannon`精灵则根据`angle`滑块旋转，提供发射角度的视觉指示。`Fire`精灵是一个按钮，用户点击它来发射球，而`Ball`精灵包含计算球坐标和绘制轨迹的主脚本。用户通过两个滑块控制指定发射角度和初始速度，然后点击`Fire`按钮。`Ball`从舞台上的点（–180,
    –140）开始，并根据指定的参数绘制抛物线轨迹。舞台右下角的两个监视器显示飞行时间和飞行中的水平射程。
- en: The simulation starts when the green flag icon is clicked. The scripts for the
    `Cannon` sprite (not shown here) point the cannon in the direction specified by
    the `angle` slider control. The user can also specify the angle by clicking and
    dragging the cannon. When the user clicks the `Fire` button, it broadcasts a `Fire`
    message, which is received and processed by the `Ball` sprite via the script shown
    in [Figure 7-34](ch07.html#script_for_the_ball_sprite "Figure 7-34. Script for
    the Ball sprite").
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟开始时，点击绿色旗帜图标。`Cannon`精灵的脚本（这里未显示）将大炮指向由`angle`滑块控制指定的方向。用户也可以通过点击并拖动大炮来指定角度。当用户点击`Fire`按钮时，它会广播一个`Fire`消息，该消息由`Ball`精灵通过[图7-34](ch07.html#script_for_the_ball_sprite
    "图7-34。`Ball`精灵的脚本")中的脚本接收并处理。
- en: To prepare to fire ①, the `Ball` moves in front of the `Cannon` and the `Wheel`
    and positions itself at the launch point. It puts its pen down and clears all
    pen marks from the Stage. The script then calculates the horizontal (or *x*) and
    vertical (or *y*) components of the initial velocity (named `vx` and `vy`, respectively)
    and initializes the time variable (`t`) to 0.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备发射①，`Ball`（球）在`Cannon`（大炮）和`Wheel`（轮子）前方移动并定位到发射点。它放下笔并清除舞台上的所有笔迹。然后，脚本计算初始速度的水平（或*x*）和垂直（或*y*）分量（分别命名为`vx`和`vy`），并将时间变量（`t`）初始化为0。
- en: '![Script for the Ball sprite](httpatomoreillycomsourcenostarchimages2134867.png.jpg)Figure 7-34. Script
    for the `Ball` sprite'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '![球精灵脚本](httpatomoreillycomsourcenostarchimages2134867.png.jpg)图7-34。`Ball`精灵的脚本'
- en: The script then enters an infinite loop ②, which calculates and updates the
    ball’s position every 0.02 s. First, the vertical distance (`dy`) of the sprite
    is calculated ③. If the calculated value is negative, then the ball has reached
    ground level. When this happens, the **stop this script** command is called to
    end the simulation.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，脚本进入一个无限循环②，计算并更新球的位置，每0.02秒更新一次。首先，计算精灵的垂直距离（`dy`）③。如果计算出的值为负，则表示球已到达地面。当发生这种情况时，调用**停止此脚本**命令来结束模拟。
- en: If `dy` is not negative, the horizontal distance (`d`) is calculated ④. The
    two distances (`dy` and `d`) are then scaled in accordance with the Stage’s backdrop.
    In the vertical direction, we have 320 steps (from –140 to 180) that correspond
    to 100 m, and in the horizontal direction, we have 420 steps (from –180 to 240)
    that correspond to 100 m. This means a vertical distance of `dy` meters is equivalent
    to `320 * dy / 100` steps, and a horizontal distance of `d` meters is equivalent
    to `420 * d / 100` steps. The *x*- and *y*-coordinates of the ball are updated,
    and the ball is moved to its current position on its trajectory. The time variable
    (`t`) is then incremented by a small amount (0.02 s in this case), and the loop
    is repeated to calculate the next position of the ball.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`dy`不是负值，则计算水平距离（`d`）④。然后，两个距离（`dy`和`d`）会根据舞台的背景进行缩放。在垂直方向上，我们有320步（从–140到180），对应100米；在水平方向上，我们有420步（从–180到240），也对应100米。这意味着`dy`米的垂直距离相当于`320
    * dy / 100`步，而`d`米的水平距离相当于`420 * d / 100`步。然后，更新球的*x*和*y*坐标，并将球移动到其轨迹上的当前位置。接着，时间变量（`t`）会增加一个小量（在这种情况下为0.02秒），并重复循环以计算球的下一个位置。
- en: As an example, if the ball is projected with a 70° launch angle and an initial
    speed of 30 m/s, as shown in [Figure 7-33](ch07.html#user_interface_for_the_projectile_motion
    "Figure 7-33. User interface for the projectile motion simulator"), the total
    flight time is 5.75 s, and the range is 59 m. An examination of the monitors in
    [Figure 7-33](ch07.html#user_interface_for_the_projectile_motion "Figure 7-33. User
    interface for the projectile motion simulator") shows that our simulation is very
    accurate. We could improve the simulation by updating our calculations more often
    (for example, every 0.01 s instead of every 0.02 s), but that would slow down
    the simulation. It’s necessary to adjust this parameter to achieve a good compromise
    between speed and accuracy.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果将球以 70° 的发射角度和 30 m/s 的初速度发射，如[图7-33](ch07.html#user_interface_for_the_projectile_motion
    "图7-33. 发射运动模拟器的用户界面")所示，总飞行时间为 5.75 秒，射程为 59 米。对[图7-33](ch07.html#user_interface_for_the_projectile_motion
    "图7-33. 发射运动模拟器的用户界面")中的监视器进行检查表明，我们的模拟非常准确。我们可以通过更频繁地更新计算（例如，每 0.01 秒而不是每 0.02
    秒）来改进模拟，但这样会减慢模拟速度。为了在速度和准确性之间取得良好的平衡，需要调整此参数。
- en: Try It Out 7-10
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下 7-10
- en: Open the application and run it to understand how it works. Then try converting
    this simulation into a game. You could, for example, show an object at a random
    height at the right edge of the stage and ask the player to try to hit it. If
    the player misses the target, the game can provide some hints on adjusting the
    firing angle and velocity.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 打开应用并运行它，以理解它是如何工作的。然后试着将这个模拟转换成一个游戏。例如，你可以在舞台的右边缘以随机高度显示一个物体，并要求玩家尝试击中它。如果玩家未能击中目标，游戏可以提供一些关于调整发射角度和速度的提示。
- en: Other Applications
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他应用
- en: The extra resources for this book (available at *[http://nostarch.com/learnscratch/](http://nostarch.com/learnscratch/)*)
    contain three more games that you can explore on your own, with full explanations
    of each script. The first is an educational game that can be used to test the
    counting skills of elementary students. It shows an amount of money in pennies
    and asks the player to find the smallest number of coins needed to get that amount.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的额外资源（可在 *[http://nostarch.com/learnscratch/](http://nostarch.com/learnscratch/)*
    获取）包含了三个你可以自行探索的游戏，每个脚本都有详细的解释。第一个是一个教育性游戏，可以用来测试小学生的计数能力。它显示一定数量的便士，并要求玩家找出获得该金额所需的最少硬币数量。
- en: '*MatchThat Amount.sb2*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*MatchThat Amount.sb2*'
- en: The second application is a planetary motion simulation for a simple solar system
    that contains a sun and a single planet. The third application is also a simulation,
    this one demonstrating the dynamics of motion as a single gas molecule collides
    with the walls of a container.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个应用是一个简单的太阳系行星运动模拟，其中包含太阳和一颗行星。第三个应用也是一个模拟，展示了单个气体分子与容器壁碰撞时的运动动态。
- en: '*Orbit.sb2 Molecules InMotion.sb2*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*Orbit.sb2 Molecules InMotion.sb2*'
- en: Open up these applications, run them, and read through my explanations to understand
    how they work. If you feel inspired to flex your programming muscles, try modifying
    the scripts to make them do new things!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 打开这些应用，运行它们，并阅读我的解释，以理解它们是如何工作的。如果你有兴趣挑战自己的编程技能，试着修改这些脚本，让它们做些新的事情！
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored different ways to repeat commands in Scratch. We
    first examined the various loop blocks and explained the technical terms associated
    with them. Then, we discussed definite and indefinite loops and the difference
    between counter-controlled and condition-controlled loops. We explored the **repeat
    until** block and the **forever if** structure and used them in several examples.
    I also explained Scratch’s **stop** commands and how you can use them to stop
    infinite loops and procedures. From there, we went on to discuss using loops to
    validate data from user input.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了在 Scratch 中重复命令的不同方式。我们首先研究了各种循环块，并解释了与之相关的技术术语。接着，我们讨论了确定性循环和不确定性循环，以及计数控制循环和条件控制循环之间的区别。我们探讨了**repeat
    until**块和**forever if**结构，并在多个示例中使用了它们。我还解释了 Scratch 的**stop**命令，以及如何使用它们来停止无限循环和过程。之后，我们讨论了如何使用循环来验证用户输入的数据。
- en: You then learned how to use counters to keep track of how many iterations of
    a loop have passed and how to use counters with nested loops to create iterations
    in two or more dimensions. After that, we looked at recursion—a procedure calling
    itself—as another way to achieve repetition. In the last section, we developed
    several applications that tied these new concepts together to create practical
    programs.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你接着学习了如何使用计数器来跟踪循环执行了多少次，以及如何在嵌套循环中使用计数器来创建多维度的迭代。之后，我们探讨了递归——一种通过调用自身来实现重复的过程。在最后一部分，我们开发了几个应用程序，将这些新概念结合起来，创建了实用的程序。
- en: The next chapter will expand on the topics you learned here and teach you how
    to use counters and loops to process strings and create a different class of interesting
    programs, such as a binary to decimal converter, a hangman game, and a math tutor
    for teaching fractions.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将扩展你在本章学到的知识，教你如何使用计数器和循环来处理字符串，并创建一类有趣的程序，例如二进制转十进制转换器、猜字游戏和一个教学分数的数学辅导程序。
- en: If you want to further explore the new concepts from this chapter, I suggest
    trying out some of the following problems.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想进一步探索本章中的新概念，建议你尝试一些以下的练习题。
- en: Problems
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: '| **Q:** | 1\. Create an input validation loop that only accepts numbers in
    the range of 1 through 10. |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| **问：** | 1\. 创建一个输入验证循环，仅接受 1 到 10 范围内的数字。 |'
- en: '| **Q:** | 2\. Write a script that asks the user, “Are you sure you want to
    quit [Y, N]?” The script then checks the user’s input and only accepts the letters
    *Y* and *N* as valid answers. |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| **问：** | 2\. 编写一个脚本，询问用户：“你确定要退出吗 [Y, N]？”然后脚本检查用户的输入，仅接受字母 *Y* 和 *N* 作为有效答案。
    |'
- en: '| **Q:** | 3\. Write a program that calculates and displays the sum of all
    integers between 1 and 20. |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| **问：** | 3\. 编写一个程序，计算并显示 1 到 20 之间所有整数的和。 |'
- en: '| **Q:** | 4\. Write a program that calculates and displays the sum of all
    odd integers between 1 and 20. |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| **问：** | 4\. 编写一个程序，计算并显示 1 到 20 之间所有奇数的和。 |'
- en: '| **Q:** | 5\. Write a program that displays the first 10 numbers in the following
    sequence (using the **say** command): 5, 9, 13, 17, 21, ....![image with no caption](httpatomoreillycomsourcenostarchimages2134869.png.jpg)
    |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| **问：** | 5\. 编写一个程序，显示以下数列中的前 10 个数字（使用 **say** 命令）：5, 9, 13, 17, 21, ....![image
    with no caption](httpatomoreillycomsourcenostarchimages2134869.png.jpg) |'
- en: '| **Q:** | 6\. What does the script on the right do? Implement the script and
    run it to check your answer. |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| **问：** | 6\. 右侧的脚本是做什么的？实现该脚本并运行它，检查你的答案。 |'
- en: '| **Q:** | 7\. If the remainder of dividing a whole number (*x*) by another
    whole number (*y*) is 0, we say that *y* is a factor of *x*. For example, 1, 2,
    4, and 8 are factors of 8\. The script below finds and displays all the factors
    of a given number (other than the number itself). Study this script and explain
    how it works. What are the outputs of this script when the input numbers are 125,
    324, and 419?![image with no caption](httpatomoreillycomsourcenostarchimages2134871.png.jpg)
    |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| **问：** | 7\. 如果一个整数 (*x*) 除以另一个整数 (*y*) 的余数为 0，我们就说 *y* 是 *x* 的因数。例如，1、2、4
    和 8 是 8 的因数。下面的脚本会查找并显示一个给定数字的所有因数（不包括该数字本身）。研究这个脚本并解释它是如何工作的。当输入数字为 125、324 和
    419 时，脚本的输出是什么？![image with no caption](httpatomoreillycomsourcenostarchimages2134871.png.jpg)
    |'
- en: '| **Q:** | 8\. An integer is said to be prime if it is divisible by only 1
    and itself. For example, 2, 3, 5, 7, 11 are prime numbers, but 4, 6, and 8 are
    not. The procedure on the next page tests whether a number is a prime number or
    not. Study this procedure and explain how it works. What are the outputs of this
    procedure for the inputs 127, 327, and 523?![image with no caption](httpatomoreillycomsourcenostarchimages2134873.png.jpg)
    |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| **问：** | 8\. 一个整数如果只被 1 和它本身整除，则称其为素数。例如，2、3、5、7、11 是素数，而 4、6 和 8 不是。下一页的程序会测试一个数是否是素数。研究这个程序并解释它是如何工作的。对于输入
    127、327 和 523，这个程序的输出是什么？![image with no caption](httpatomoreillycomsourcenostarchimages2134873.png.jpg)
    |'
- en: '| **Q:** | 9\. Although the procedure in problem 8 checks all integers up to
    one-half the input value, it is sufficient to set the upper limit to the square
    root of the input. Make this change to the procedure and test it to see if it
    still gives the same answers. |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| **问：** | 9\. 尽管第 8 问中的程序检查了输入值的一半范围内的所有整数，但实际上将上限设置为输入值的平方根就足够了。对程序进行这个修改，并进行测试，看它是否仍然给出相同的答案。
    |'
- en: '| **Q:** | 10\. The sequence of numbers0, 1, 1, 2, 3, 5, 8, 13, 21, 34 ....is
    called a Fibonacci series. The first two numbers in the series are 0 and 1\. Each
    subsequent number is then calculated as the sum of the previous two. Write a program
    that calculates the *n*th term of the Fibonacci series, where *n* is entered by
    the user. |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| **问:** | 10\. 数字序列0, 1, 1, 2, 3, 5, 8, 13, 21, 34 ....被称为斐波那契数列。数列中的前两个数字是0和1。之后的每个数字都是前两个数字之和。编写一个程序，计算斐波那契数列的第*n*项，其中*n*由用户输入。
    |'
- en: '| **Q:** | 11\. Consider the following program and its generated output. Re-create
    the program and run it to see how it works. Change the turn angle (from 10°) and
    the argument in the recursive call (to **side + 1** or **side + 3**, and so on)
    to discover what else you can create.![image with no caption](httpatomoreillycomsourcenostarchimages2134875.png.jpg)
    |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| **问:** | 11\. 请考虑以下程序及其生成的输出。重新创建该程序并运行，观察它是如何工作的。改变转向角度（从10°开始）和递归调用中的参数（例如**side
    + 1**或**side + 3**，依此类推），以发现还能创造出什么其他形状。![无标题的图片](httpatomoreillycomsourcenostarchimages2134875.png.jpg)
    |'
