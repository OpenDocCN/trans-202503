["```\nint main(void) {\n    return ~(-2);\n}\n```", "```\n .globl main\nmain:\n    pushq   %rbp\n    movq     %rsp, %rbp\n    subq     $8, %rsp\n  ❶ movl     $2, ❷ -4(%rbp)\n  ❸ negl     -4(%rbp)\n  ❹ movl     -4(%rbp), %r10d\n  ❺ movl     %r10d, -8(%rbp)\n  ❻ notl     -8(%rbp)\n  ❼ movl     -8(%rbp), %eax\n    movq     %rbp, %rsp\n    popq     %rbp\n    ret\n```", "```\nint main(void) {\n    return --2;\n}\n```", "```\nint main(void) {\n    return -(-2);\n}\n```", "```\nprogram = Program(function_definition)\nfunction_definition = Function(identifier name, statement body)\nstatement = Return(exp)\nexp = Constant(int) | **Unary(unary_operator, exp)**\n**unary_operator = Complement | Negate**\n```", "```\n<program> ::= <function>\n<function> ::= \"int\" <identifier> \"(\" \"void\" \")\" \"{\" <statement> \"}\"\n<statement> ::= \"return\" <exp> \";\"\n<exp> ::= <int> **| <unop> <exp> | \"(\" <exp> \")\"**\n**<unop> ::= \"-\" | \"~\"**\n<identifier> ::= ? An identifier token ?\n<int> ::= ? A constant token ?\n```", "```\nparse_exp(tokens):\n    next_token = peek(tokens)\n  ❶ if next_token is an int:\n        `--snip--`\n  ❷ else if next_token is \"~\" or \"-\":\n        operator = parse_unop(tokens)\n        inner_exp = parse_exp(tokens)\n      ❸ return Unary(operator, inner_exp)\n  ❹ else if next_token == \"(\":\n        take_token(tokens)\n        inner_exp = parse_exp(tokens)\n        expect(\")\", tokens)\n      ❺ return inner_exp\n  ❻ else:\n        fail(\"Malformed expression\")\n```", "```\ntmp0 = 2 * 3\ntmp1 = 1 + tmp0\nreturn tmp1\n```", "```\nprogram = Program(function_definition)\nfunction_definition = Function(identifier, ❶ instruction* body)\ninstruction = Return(val) | Unary(unary_operator, val src, val dst)\nval = Constant(int) | Var(identifier)\nunary_operator = Complement | Negate\n```", "```\nReturn(Unary(Negate,\n\t     Unary(Complement,\n\t\t  Unary(Negate, Constant(8)))))\n```", "```\nemit_tacky(e, instructions):\n    match e with\n  ❶ | Constant(c) ->\n        return ❷ Constant(c)\n    | Unary(op, inner) ->\n        src = emit_tacky(inner, instructions)\n        dst_name = make_temporary()\n        dst = Var(dst_name)\n        tacky_op = convert_unop(op)\n        instructions.append(Unary(tacky_op, src, dst))\n        return dst\n```", "```\nprogram = Program(function_definition)\nfunction_definition = Function(identifier name, instruction* instructions)\ninstruction = Mov(operand src, operand dst)\n            **| Unary(unary_operator, operand)**\n            **| AllocateStack(int)**\n            | Ret\n**unary_operator = Neg | Not**\noperand = Imm(int) | **Reg(reg) | Pseudo(identifier) | Stack(int)**\n**reg = AX | R10**\n```", "```\nMov(Imm(2), Pseudo(\"a\"))\nUnary(Neg, Pseudo(\"a\"))\n```", "```\nmovl    -4(%rbp), -8(%rbp)\n```", "```\nmovl    -4(%rbp), %r10d\nmovl    %r10d, -8(%rbp)\n```", "```\n<samp class=\"SANS_Futura_Std_Book_11\">Print out the function definition. On Linux, add at end of file:</samp> \n <samp class=\"SANS_TheSansMonoCd_W5Regular_11\">.section .note.GNU-stack,\"\",@progbits</samp>\n```", "```\n <samp class=\"SANS_TheSansMonoCd_W5Regular_11\">.globl</samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><name></samp>\n<samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><name></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">:</samp> \n <samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">pushq    %rbp</samp>\n <samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">movq    {@}%rsp, %rbp</samp> \n <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><instructions></samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">movl</samp> <samp class=\"SANS_Futura_Std_Book_11\"></samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><src></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">,</samp> <samp class=\"SANS_Futura_Std_Book_11\"><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><dst></samp></samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">movq    %rbp, %rsp</samp>\n<samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">popq    %rbp </samp> \n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">ret</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><unary_operator>    <operand></samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">subq    $</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><int></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">, %rsp</samp>\n```"]