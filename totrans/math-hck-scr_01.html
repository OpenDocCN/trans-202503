<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><p class="h2-ha" id="ch01"><span class="color2"><strong>1</strong></span></p>&#13;
<h2 class="h2-hd"><span epub:type="pagebreak" id="page_1"/><strong>What Computers Think About Numbers</strong></h2>&#13;
<div class="imagec"><img src="../images/common.jpg" alt="Image" width="167" height="189"/></div>&#13;
<p class="noindent">To do math, a computer needs a way of representing numbers. As it turns out, computers think about numbers pretty differently than humans do.</p>&#13;
<p class="indent">For example, we like to think we can keep counting to higher and higher numbers forever, but computers have a limited amount of storage space. If they start counting, they eventually run out of room. There is no biggest number, but there <em>is</em> a biggest number your computer can represent in Scratch.</p>&#13;
<p class="indent">Similarly, we think about fractions and decimal numbers as matching up with points on a number line, with an infinite number of points fitting between any two whole numbers. But as we pack points more and more tightly together in the finite world of computers, eventually we run out of room to keep track of them. There is no smallest positive number, but there <em>is</em> a smallest positive number your computer can work with in Scratch.</p>&#13;
<p class="indent">In this chapter, we’ll look at what’s going on behind your computer screen and how computers think about numbers. We’ll explore the limitations of what numbers Scratch can represent. It’s important to understand these limits so we can be sure the results we get from a program are accurate. You’ll also learn some hacks for getting around Scratch’s limits and tricking the computer into representing more numbers than would normally be possible.</p>&#13;
<h3 class="h3" id="ch01lev1"><span epub:type="pagebreak" id="page_2"/>What Are Numbers, Anyway?</h3>&#13;
<p class="noindent">Everybody <em>thinks</em> they know what numbers are, but there are many number systems to choose from, depending on what we want the numbers to do. We usually learn to count with numbers starting from 1, so we call those numbers <em>counting numbers</em>. Sometimes we want to start counting from 0, in which case the numbers are called <em>whole numbers</em>. When we go forward and backward, allowing negative numbers too, we generate the set of <em>integers</em>: { . . . , –3, –2, –1, 0, 1, 2, 3, . . . }.</p>&#13;
<p class="indent">We can make an association with geometry and think of numbers as corresponding to points on a line, building the set of <em>real numbers</em>. We can also divide integers by other (nonzero) integers to make <em>rational numbers</em>. Here we use <em>rational</em> not to mean logical and making sense, but because the numbers are built from <em>ratios</em>. Sometimes rational numbers are called <em>fractions</em>, but this can be misleading. In common language, a <em>fraction</em> of something is only a portion of it, suggesting a part less than 1, whereas rational numbers like 3/2 and 4/3 can be bigger than 1. Also, fractions are usually thought of with a denominator of 2 or more (halves, thirds, and so on), but rational numbers sometimes have a denominator of 1, as in 2/1, 3/1, and so on. In this way, an integer is a special kind of rational number.</p>&#13;
<p class="indent">With all these kinds of numbers, we use our intuition that when we name a particular number, we’re identifying one element of an infinite collection. That is, we expect numbers to go on forever: “To infinity and beyond,” as Buzz Lightyear says. There’s another way that numbers can be used, though, where they wrap around and recycle their values over and over, like the numbers on a clock. This way of working with numbers is useful for tracking things that happen regularly or repeatedly, and it has some interesting properties that we’ll explore in the next chapter when we look at modular arithmetic.</p>&#13;
<p class="indent">In the first few chapters of this book, we’ll be most interested in counting numbers, also called <em>positive integers</em>. When we talk about numbers without being more specific, that’s the default interpretation to use. But so far, we’ve considered only what numbers are or aren’t included in a number system. There’s a whole other factor to consider as well: how those numbers are <em>represented</em>.</p>&#13;
<h3 class="h3" id="ch01lev2">Base 10? Base 2? You Pick!</h3>&#13;
<p class="noindent">A <em>basis representation system</em> determines how numbers are broken down into groups for ease of counting and how many symbols are needed to represent those numbers. Probably because we have 10 fingers, humans typically think of numbers in <em>decimal</em>, a basis system that uses groups of 10. We start counting one at a time and use a different symbol for each new number, 1 through 9. When we run out of fingers, we group double handfuls of fingers and count by tens. When there are no units left over after separating groups of 10, we use the symbol 0, a closed fist, to show this. So we understand 34 as 3 tens and 4 ones, and 60 as 6 tens and 0 ones.</p>&#13;
<p class="indent">We can extend the pattern of grouping by 10 to represent increasingly large numbers with relatively few digits, introducing a third-place digit for 10 tens (100), <span epub:type="pagebreak" id="page_3"/>a fourth place for 10 hundreds (1,000), and so on. It helps to use exponents to indicate the repeated multiplication. For example:</p>&#13;
<div class="imagec"><img src="../images/pg23_Image_6.jpg" alt="Image" width="411" height="113"/></div>&#13;
<p class="noindent">We always have the option of sorting out the grouping using expanded notation. Here’s an example:</p>&#13;
<div class="imagec"><img src="../images/pg23_Image_7.jpg" alt="Image" width="712" height="29"/></div>&#13;
<p class="indent">Since the decimal system hinges on powers of 10, it’s also called <em>base 10</em>. But while humans favor base 10, other ways of grouping are possible. For example, if you wanted to count using only the fingers on one hand, you could group by fives and have a <em>base 5</em> system. Base 5 numeration needs only the symbols 0, 1, 2, 3, and 4. The number five is written as 10, six as 11, and so on.</p>&#13;
<p class="indent">Eggs and donuts are sold by the dozen, a group of 12, and we even have a word for a dozen dozen: a <em>gross</em>. <em>Base 12</em> numeration uses the symbols 0, 1, 2, 3, 4, 5, 6, 7, 8, and 9 as usual, but it needs two extra single-digit symbols to represent the numbers ten and eleven. Usually we use T and E. If we need to specify the base, we can do it with a subscript, such as 15<sub>10</sub> to indicate that 15 is written in base 10. This makes it easier to compare numbers written in different basis systems. For example, 15<sub>10</sub> = 13<sub>12</sub> = 30<sub>5</sub>, which is to say that (1 ⋅ 10) + 5 = (1 ⋅ 12) + 3 = (3 ⋅ 5) + 0.</p>&#13;
<p class="indent">Most computers use a <em>base 2</em> system, also called <em>binary</em>, to represent numbers internally. This system has the advantage that it requires only two symbols, 0 and 1. This matters because 0 and 1 are easy to keep track of with the position of a switch: the switch is either off (0) or on (1). Having only two symbols is good for expressing logic, too, where the two possibilities could represent <em>false</em> and <em>true</em>. A drawback is that powers of 2 (1, 2, 4, 8, 16, . . .) grow more slowly than powers of 10 (1, 10, 100, 1,000, . . .), so it typically takes more digits to represent a number in binary than it does to represent the same number in decimal. We’ll talk more about this later.</p>&#13;
<h4 class="h4" id="ch01lev3">Project 1: What’s 77 in Binary?</h4>&#13;
<p class="noindent">For a given positive integer, there’s a unique way of writing it in base 10, and it also has a unique representation in binary. In this project, we’ll write a Scratch program that converts from decimal to binary so we can see what the computer is seeing when it represents a number.</p>&#13;
<p class="indent">There are two ways we might approach this problem: strategies we can call <em>big-to-little</em> and <em>little-to-big</em>. According to the big-to-little strategy, we first find the largest power of 2 contained in a decimal number, to determine the leftmost digit of the base 2 representation. Then we subtract that power of 2 and find the <span epub:type="pagebreak" id="page_4"/>largest power of 2 in the difference. We keep repeating this process to build up the binary representation, generating the digits from left to right. For example:</p>&#13;
<div class="imagec"><img src="../images/pg24_Image_9.jpg" alt="Image" width="753" height="241"/></div>&#13;
<p class="indent">The big-to-little strategy matches the way most humans would approach doing a decimal-to-binary conversion in their heads, but the little-to-big strategy is much easier to code on a computer. Instead of searching for the largest power of 2 contained in a number, all we have to do is program a series of divisions by 2 and keep track of the remainders. This builds up the binary representation from right to left. <a href="ch01.xhtml#ch1fig1">Figure 1-1</a> shows a Scratch program that uses the little-to-big approach.</p>&#13;
<div class="image"><img id="ch1fig1" src="../images/pg24_Image_8.jpg" alt="Image" width="681" height="558"/></div>&#13;
<p class="figcap"><em>Figure 1-1: A program to convert decimal (base 10) numbers into binary (base 2)</em></p>&#13;
<p class="indent">We build up the binary version of a number in the <span class="literal">string</span> variable, which starts out blank at the beginning of the program. (A <em>string</em> is a sequence of characters; more on this in “Hacking the Code” on <a href="ch01.xhtml#ch01lev5">page 5</a>.) To get started, we use the <span class="literal">ask and wait</span> block to have Scratch Cat prompt the user for a number in base 10, storing the user’s <span class="literal">answer</span> in the <span class="literal">n</span> variable. Then we enter a <span class="literal">repeat until</span> loop <span class="ent">❶</span>, where the real logic is.</p>&#13;
<p class="indent"><span class="literal">n mod 2</span> returns the remainder of dividing <span class="literal">n</span> by <span class="literal">2</span>, which will be <span class="literal">1</span> if <span class="literal">n</span> is odd or <span class="literal">0</span> if <span class="literal">n</span> is even. Each time through the loop, this <span class="literal">mod</span> operation gives us one digit of the binary representation of the number, starting with the least significant (rightmost) digit. We use the <span class="literal">join</span> block to merge that digit with the contents already <span epub:type="pagebreak" id="page_5"/>in the <span class="literal">string</span> variable, putting the result back in <span class="literal">string</span>. Then we divide <span class="literal">n</span> by <span class="literal">2</span> and use <span class="literal">floor</span> to round the result down to the nearest whole number. This removes the value of the binary digit we just accounted for from <span class="literal">n</span>. Then, the loop can start again to find the next binary digit.</p>&#13;
<p class="indent">Once <span class="literal">n</span> gets down to <span class="literal">0</span>, we’ve built up the complete binary representation of the number from right to left. We then use some more <span class="literal">join</span> blocks to put together a meaningful sentence reporting the result, which Scratch Cat announces through the <span class="literal">say</span> block.</p>&#13;
<h5 class="h5" id="ch01lev4">The Results</h5>&#13;
<p class="noindent">Run the program and try entering <strong>77</strong> when Scratch Cat asks for a number. You should get 1001101 as the result, as shown in <a href="ch01.xhtml#ch1fig2">Figure 1-2</a>.</p>&#13;
<div class="image"><img id="ch1fig2" src="../images/pg25_Image_10.jpg" alt="Image" width="784" height="475"/></div>&#13;
<p class="figcap"><em>Figure 1-2: Converting 77<sub>10</sub> into base 2</em></p>&#13;
<p class="indent">Because of the way Scratch works, you’ll see a lot of figures in this book that combine different points from a program’s execution into one image, like this one. In this case, you can see Scratch Cat’s speech bubbles from both the <span class="literal">ask and wait</span> and <span class="literal">say</span> blocks, as well as the box for entering the base 10 number. The execution flow will be clear when you’re doing these experiments yourself, but when you’re looking at the figures in the book you might need to do a little interpretation of what happens when.</p>&#13;
<h5 class="h5" id="ch01lev5">Hacking the Code</h5>&#13;
<p class="noindent">The program treats the decimal-to-binary conversion as a sequence of halvings. You could also think of it in reverse, as a sequence of doublings, with a +1 for each 1 in the binary representation and a +0 for each 0. For example, we can represent the conversion of 77 mathematically as:</p>&#13;
<div class="imagec"><img src="../images/pg25_Image_11.jpg" alt="Image" width="654" height="65"/></div>&#13;
<p class="noindent">You can see the digits of the binary representation in red. Stacking up the multiplications in this way puts every binary digit with its appropriate power of 2.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_6"/>Another important thing to know about this program is that while the answer Scratch reports looks like a number, it’s actually a string. As I mentioned earlier, a string is just a list of characters. Usually those characters are letters of the alphabet strung together to form messages like <span class="literal">Hello</span> or <span class="literal">Tell me a number</span>, but in this case, the characters happen to be 0s and 1s. So even though the result looks like binary digits making up a number, Scratch has no idea that <span class="literal">1001101</span> is a binary number with a decimal value of 77.</p>&#13;
<p class="indent">We have to use strings because Scratch doesn’t have a built-in way to work directly with binary numbers. If we wanted Scratch to do binary arithmetic on base 2 numbers, we would have to write a custom program to teach it how. This is the first of many cases in this book where we’ll have to treat numbers as strings to “trick” Scratch into doing what we want.</p>&#13;
<div class="side-b">&#13;
<p class="centerb"><img class="inline" src="../images/pg26_Image_12.jpg" alt="Image" width="80" height="91"/> Programming Challenges</p>&#13;
<p class="indentib"><span class="blue"><strong>1.1</strong></span> Write a program that prompts for a base <em>b</em>, then prompts for a base 10 number <em>n</em>, and then returns the number <em>n</em> written in the base <em>b</em>. You might limit the base <em>b</em> to be between 2 and 10, or go on to use the digits E and T to allow base 11 or 12.</p>&#13;
<p class="indentib"><span class="blue"><strong>1.2</strong></span> A popular computer-related base is base 16, <em>hexadecimal</em>, which usully uses the extra symbols A, B, C, D, E, and F to stand for 10, 11, 12, 13, 14, and 15. Extend your base converter to give hexadecimal representations. See if you can spot the trick for converting back and forth between binary and hexadecimal.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch01lev6">Project 2: What’s 1001101 in Decimal?</h4>&#13;
<p class="noindent">Now let’s try converting backward from a binary representation to a decimal one. <a href="ch01.xhtml#ch1fig3">Figure 1-3</a> shows a Scratch program that does this.</p>&#13;
<p class="indent">We first ask the user for a string representing a binary value with an <span class="literal">ask and wait</span> block. Then we use a <span class="literal">repeat</span> loop and the <span class="literal">index</span> variable to look at the string one character at a time, from left to right, with <span class="literal">letter index of answer</span> accessing the current character. The variable <span class="literal">n</span> starts at <span class="literal">0</span>. For each digit in the binary representation, <span class="literal">n</span> is doubled and then has the value of the current digit (either <span class="literal">0</span> or <span class="literal">1</span>) added to it. When there are no more binary digits left, <span class="literal">n</span> holds the decimal representation of the number.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_7"/><img id="ch1fig3" src="../images/pg27_Image_13.jpg" alt="Image" width="680" height="567"/></div>&#13;
<p class="figcap"><em>Figure 1-3: A program to convert binary (base 2) numbers into decimal (base 10)</em></p>&#13;
<h5 class="h5" id="ch01lev7">The Results</h5>&#13;
<p class="noindent">We know that 77 in binary is 1001101. Try running the program and entering 1001101 to see if it gives 77 back. <a href="ch01.xhtml#ch1fig4">Figure 1-4</a> shows the results.</p>&#13;
<div class="image"><img id="ch1fig4" src="../images/pg27_Image_14.jpg" alt="Image" width="785" height="481"/></div>&#13;
<p class="figcap"><em>Figure 1-4: Converting 1001101<sub>2</sub> into base 10</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_8"/>We’ve worked a lot with 77, converting it to binary in <a href="ch01.xhtml#ch1fig2">Figure 1-2</a> and then back to decimal again in <a href="ch01.xhtml#ch1fig4">Figure 1-4</a>. But what is the number 77 <em>really</em>? Whether we write it in binary or decimal, 77 represents the same quantity. How we choose to write a number might reveal interesting facts about it (for instance, if a number written in decimal ends in a 0, the number must be divisible by 10, and if a number written in binary ends in a 0, the number has to be divisible by 2), but it doesn’t change the value of the number at all.</p>&#13;
<h5 class="h5" id="ch01lev8">Hacking the Code</h5>&#13;
<p class="noindent">One problem with our binary-to-decimal program is that it has no check to make sure it’s working with a string of binary digits. If you input something that isn’t a number in binary notation, Scratch Cat is happy to tell you nonsense, as the examples in <a href="ch01.xhtml#ch1fig5">Figure 1-5</a> show.</p>&#13;
<div class="image"><img id="ch1fig5" src="../images/pg28_Image_15.jpg" alt="Image" width="794" height="273"/></div>&#13;
<p class="figcap"><em>Figure 1-5: Three outputs from the binary-to-decimal converter. There’s nothing to stop you from entering something other than a binary number!</em></p>&#13;
<p class="indent">We could fix this by including a custom <span class="literal">Screen string</span> block to check the input. This block, shown in <a href="ch01.xhtml#ch1fig6">Figure 1-6</a>, makes sure the input is in the right form: a string of characters that includes only 0s and 1s.</p>&#13;
<div class="image"><img id="ch1fig6" src="../images/pg28_Image_16.jpg" alt="Image" width="881" height="495"/></div>&#13;
<p class="figcap"><em>Figure 1-6: Making sure only base 2 numbers are allowed</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_9"/>The block sets the logical (<em>Boolean</em>, or true/false) variable <span class="literal">binary string?</span> to <span class="literal">true</span> as long as the user didn’t input any other characters (like spaces, letters, or digits greater than 1). Otherwise, it sets <span class="literal">binary string?</span> to <span class="literal">false</span>. We can now use this block with an <span class="literal">if...else</span> statement so we don’t get any silly, incorrect answers, as shown in <a href="ch01.xhtml#ch1fig7">Figure 1-7</a>. The operator blocks that Scratch uses for Boolean tests are all green hexagons that you can plug into the test condition in control blocks.</p>&#13;
<div class="image"><img id="ch1fig7" src="../images/pg29_Image_17.jpg" alt="Image" width="681" height="802"/></div>&#13;
<p class="figcap"><em>Figure 1-7: The binary-to-decimal converter done more carefully</em></p>&#13;
<p class="indent">Here, we’ve moved the original binary-to-decimal code inside the <span class="literal">if</span> branch of an <span class="literal">if...else</span> block so it runs only if the <span class="literal">binary string?</span> variable is <span class="literal">true</span>. Otherwise, Scratch Cat will inform the user that the input wasn’t a binary number.</p>&#13;
<p class="indent">You may be disappointed that the program is a little longer now than it was originally. Scratch makes it easy to write really compact programs, and it even encourages this by telling you how many blocks there are in the programming window. But sometimes, it’s better to be careful even if it makes your program a bit longer. If it’s possible to misunderstand something or make a mistake in the input, at some point someone will do that, so it’s better to be safe than sorry! Some programming languages have special commands to intercept errors and reroute them somewhere harmless (the syntax usually involves the keywords <span class="literal">try</span> and <span class="literal">catch</span>), but Scratch leaves it up to you to anticipate problems and guard against them, as we’ve done with the <span class="literal">Screen string</span> block.</p>&#13;
<div class="side-b">&#13;
<p class="centerb"><span epub:type="pagebreak" id="page_10"/><img class="inline" src="../images/pg26_Image_12.jpg" alt="Image" width="80" height="91"/> Programming Challenge</p>&#13;
<p class="indentib"><span class="blue"><strong>1.3</strong></span> Sometimes news stories talk about <em>exponential growth</em> as a general term to suggest rapid increase. Exponential growth means something specific in mathematics, where progression from one value in a sequence of numbers to the next value is done by multiplication using a fixed factor. For example, every number might be two times larger than the one before it. An alternative is <em>linear growth</em>, where the change happens by <em>adding</em> a fixed increment, such as when each number is two more than the previous one.</p>&#13;
<p class="indenta">Write some Scratch code that prompts the user for a multiplier or an increment, and answers with a sequence of numbers that grows exponentially or linearly. Compare the growth: What happens if the user gives a number less than 1 for exponential growth? What happens if the user gives a number less than 0 for linear growth? Maybe this is a situation that calls for input screening.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch01lev9">How Computers Represent Numbers</h3>&#13;
<p class="noindent">Computers can represent numbers internally in different ways, but they all involve some kind of compromise. Earlier I mentioned that humans think of number systems like integers and real numbers as being infinite. Computers aren’t built to handle infinite collections, though. They have to work within the confines of the architecture of their hardware or the logical structure of the programming language they’re running.</p>&#13;
<p class="indent">On the hardware side, central processing units (CPUs) typically have <em>registers</em>, which are areas of the CPU that can hold and operate on a certain number of binary digits, or <em>bits</em>, at once. Programming languages are designed to allocate a fixed number of bits to represent each number, so language designers need to make decisions about what exactly those bits mean (for example, whether some represent a base and others an exponent). They also need to make decisions about things like how to represent a number as negative or positive and what to do if a number takes up more than the available space. Should the computation halt with a warning or an error, or should the representation wrap back around without complaint, possibly leading to unexpected and incorrect results?</p>&#13;
<p class="indent">Ultimately, we can’t fit infinitely many numbers into a computer’s finite space of possibilities, so “most” numbers have to be left out. This means the developers of a computer language need to decide which numbers and what kinds of numbers are interesting and important enough to include. Some people need to represent tiny numbers, the size of subatomic particles, while others need to represent massive numbers, the size of the universe, and still others need everything in between. Different languages may be designed to fill some of these needs but not others.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_11"/>Beyond questions of how big or small the numbers are, language designers might also want to consider how the numbers will be used. For instance, sometimes numbers are used to count, answering questions about “How many?” In this case, the answer is often a whole number. (This comes up often enough that lots of programming languages give integers their own representation system, separate from other kinds of numbers.) Other times, numbers are used to measure, answering questions about “How much?” The answers to those questions are less likely to be whole numbers. Language designers need a way to represent those “in between” numbers, and they have to decide exactly how far “in between” to go.</p>&#13;
<h4 class="h4o" id="ch01lev10">The Point of Floating Point</h4>&#13;
<p class="noindent"><em>Floating-point notation</em> allows for “in between” numbers by including powers of the base smaller than 1. In base 10, there’s a <em>decimal point</em>, with digits to the right of the decimal point representing a number between 0 and 1 with a combination of powers of 1/10, 1/100, and so on. For instance, the approximation of <em>π</em>, 3.14, indicates a number that’s a little more than 3:</p>&#13;
<div class="imagec"><img src="../images/pg31_Image_18.jpg" alt="Image" width="375" height="67"/></div>&#13;
<p class="noindent">If you need a closer approximation, you can include a few more digits:</p>&#13;
<div class="imagec"><img src="../images/pg31_Image_19.jpg" alt="Image" width="768" height="67"/></div>&#13;
<p class="indent">The same principle applies to floating-point notation for binary numbers, where digits to the right of the <em>binary point</em> (the binary equivalent of a decimal point) represent powers of 1/2. You’re probably familiar with using binary fractions to represent numbers—even if you don’t realize it—if you’ve ever measured lengths with a ruler or tape measure (see <a href="ch01.xhtml#ch1fig8">Figure 1-8</a>).</p>&#13;
<div class="image"><img id="ch1fig8" src="../images/pg31_Image_20.jpg" alt="Image" width="802" height="423"/></div>&#13;
<p class="figcap"><em>Figure 1-8: Binary fractions on a tape measure</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_12"/>Inches are subdivided into halves (1/2), quarters (1/4), eighths (1/8), sixteenths (1/16), and so on. These are binary fractions in that each denominator is a power of 2. You could measure 1 13/16 inches, for example, by going over 1, then 1/2, then 1/4, then 1/16, and write 1 13/16 with a binary representation of 1.1101.</p>&#13;
<p class="indent">Binary fractions give us a way to write non-whole numbers, but how many bits should be used to represent a number, and how should they be interpreted? Anyone who invents a computer language can make their own rules, but it’s better to have a standard that everyone agrees to use so there won’t be any confusion when switching from one language to another. One such standard is the IEEE Standard for Floating-Point Arithmetic, or IEEE 754. The makers of Scratch chose to use this standard to represent all numbers, even whole numbers, whereas some languages use IEEE 754 for floating-point numbers and a different standard for integers.</p>&#13;
<h4 class="h4o" id="ch01lev11">Double the Precision, Double the Fun</h4>&#13;
<p class="noindent">IEEE 754 uses <em>double precision</em>, meaning a floating-point number in binary will occupy 64 bits (unlike <em>single precision</em>, which allows for 32 bits per number). <a href="ch01.xhtml#ch1fig9">Figure 1-9</a> shows how the 64 bits are allocated.</p>&#13;
<div class="image"><img id="ch1fig9" src="../images/pg32_Image_21.jpg" alt="Image" width="1006" height="184"/></div>&#13;
<p class="figcap"><em>Figure 1-9: How bits are allocated in the IEEE 754 standard</em></p>&#13;
<p class="indent">The first bit, shown in cyan in the figure, is for the sign: 0 or 1 for plus or minus. The last 64 – 1 – 11 = 52 bits, shown in orange, represent a number, conventionally a value between 1 and 2, that is called the <em>mantissa</em>. Since a binary number between 1 and 2 always looks like a 1, then a binary point, then some other digits, we can save one binary digit by not writing the initial 1 explicitly. So instead of 52 bits of precision, we really have 53 bits. The 11 bits after the sign bit, colored in purple in the figure, are for the exponent, specifying a power of 2 used to multiply the mantissa. Sometimes the exponent is called the <em>characteristic</em>. Having 11 bits in the characteristic gives a range of 2<sup>11</sup> possible exponents, which are interpreted as going from 2<sup>–1,023</sup> to 2<sup>1,024</sup>, but the very top and bottom numbers are reserved for special use.</p>&#13;
<div class="note">&#13;
<p class="notet"><a id="common1"/><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>For a hands-on look at how IEEE 754 works, there are interactive online tools that let you change floating-point numbers bit by bit (literally) to see what happens. Some examples are the double-precision tools at</em> <a href="https://float.exposed">https://float.exposed</a> <em>and</em> <a href="http://evanw.github.io/float-toy/">http://evanw.github.io/float-toy/</a>.</p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_13"/>Keep in mind that 53 digits of precision in binary doesn’t translate into 53 digits of precision in decimal. For example, 2<sup>10</sup> = 1,024, which is about the same as 10<sup>3</sup> = 1,000. This indicates that 10 binary digits convey about as much information as 3 decimal digits, so 53 binary digits can hold as much information as about 16 or 17 decimal digits. That’s still a lot—way more than you’re likely to see on a calculator screen—but it’s far from infinite.</p>&#13;
<p class="indent">In this book, we’re mainly interested in integers, so 16 decimal digits of precision means that a 16-digit number, somewhere in the low quadrillions, is the biggest number Scratch can be counted on to represent exactly as a counting number. When we test numbers for properties such as divisibility in future chapters, we’ll need to be sure all the digits of the numbers are reliably represented to get correct results. We’ll explore this limitation in our next project.</p>&#13;
<h4 class="h4" id="ch01lev12">Project 3: 2<sup>53</sup> + 1 = ?</h4>&#13;
<p class="noindent">Some languages give the largest integer that can be represented exactly in floating-point notation a special name, <em>flintmax</em>, which is an abbreviation for <em>floating-point integer maximum</em>. The value of flintmax in Scratch is:</p>&#13;
<div class="imagec"><img src="../images/pg33_Image_22.jpg" alt="Image" width="342" height="29"/></div>&#13;
<p class="indent"><a href="ch01.xhtml#ch1fig10">Figure 1-10</a> shows a little program illustrating how arithmetic goes awry when you try to work with numbers bigger than flintmax. Keep an eye on the variables as you run the program to see where the problem arises.</p>&#13;
<div class="image"><img id="ch1fig10" src="../images/pg33_Image_23.jpg" alt="Image" width="432" height="563"/></div>&#13;
<p class="figcap"><em>Figure 1-10: Integer arithmetic is unreliable above flintmax.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_14"/>Subtracting 1 from flintmax works fine, but adding 1 to flintmax doesn’t give the expected result. The value of the variable <span class="literal">flintmax+1</span> is flintmax itself. You have to add 2 to change flintmax and get a correct answer.</p>&#13;
<h5 class="h5" id="ch01lev13">Hacking the Code</h5>&#13;
<p class="noindent">It’s always interesting to test the limits and see where a computer language or other system breaks down. People who are interested in video games, for example, spend lots of time looking for glitches and locations that break the game’s underlying model or make the game’s objects behave weirdly. It’s part of the fun to see how things can go wrong and to conduct experiments to try to work out how the computer is handling itself.</p>&#13;
<p class="indent">In this case, our program showed that when calculations in Scratch exceed flintmax, the results are suspect and may not correspond to exact integer arithmetic. We’ll need to keep that in mind as we design programs to explore integer arithmetic in Scratch. As long as the numbers, including intermediate results, remain under flintmax, though, the results will be exact. For instance, you can write a Scratch program that counts up starting from 1, and you’ll get all the way to flintmax before there’s a missing integer value.</p>&#13;
<p class="indent">Our program also showed that IEEE 754 can represent <em>some</em> integers above flintmax, such as flintmax + 2, correctly. In fact, it can represent even numbers (multiples of 2) above flintmax exactly for a while, but eventually it loses another digit of binary accuracy, after which point it represents only multiples of 4 exactly. You can try extending the program in <a href="ch01.xhtml#ch1fig10">Figure 1-10</a> to illustrate this. What’s the largest integer <em>n</em> for which Scratch can correctly distinguish between <em>n</em> and <em>n</em> + 2? How does that value compare with flintmax? Likewise, what’s the largest integer <em>n</em> where there’s a difference between <em>n</em> and <em>n</em> + 4?</p>&#13;
<p class="indent">Another way that arithmetic can get broken in Scratch is when the result of a computation doesn’t match any numerical value. For example, Scratch reports <span class="literal">Infinity</span> when you try to divide by 0, as in <a href="ch01.xhtml#ch1fig11">Figure 1-11</a>.</p>&#13;
<div class="image"><img id="ch1fig11" src="../images/pg34_Image_24.jpg" alt="Image" width="589" height="255"/></div>&#13;
<p class="figcap"><em>Figure 1-11: Sometimes the answer is</em> <span class="codeitalic">Infinity</span>.</p>&#13;
<p class="indent">But what happens when you try to subtract <span class="literal">Infinity</span> from <span class="literal">Infinity</span>? The answer reported in <a href="ch01.xhtml#ch1fig12">Figure 1-12</a> is <span class="literal">NaN</span>, which means <em>not a number</em>.</p>&#13;
<div class="image"><img id="ch1fig12" src="../images/pg35_Image_25.jpg" alt="Image" width="760" height="261"/></div>&#13;
<p class="figcap"><em>Figure 1-12: Sometimes the answer is not a number.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_15"/>We’ll encounter these special values, <span class="literal">Infinity</span> and <span class="literal">NaN</span>, in the output of some of our programs.</p>&#13;
<div class="side-b">&#13;
<p class="centerb"><img class="inline" src="../images/pg26_Image_12.jpg" alt="Image" width="80" height="91"/> Programming Challenges</p>&#13;
<p class="indentib"><span class="blue"><strong>1.4</strong></span> What’s the largest number that Scratch can represent, integer or not? What happens when that number is exceeded?</p>&#13;
<p class="indentib"><span class="blue"><strong>1.5</strong></span> Try using Scratch to create a floating-point simulator like the ones mentioned in the note on <a href="ch01.xhtml#common1">page 12</a>. You should be able to look at a 64-bit string of 0s and 1s and see the floating-point number associated with it, then change the bits to see how the number changes.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch01lev14">Project 4: A Million-Digit Number?</h4>&#13;
<p class="noindent">In this project, we’ll trick Scratch into doing exact integer arithmetic with many more digits of precision than flintmax provides. To get around the limits of the IEEE 754 standard for number representation, we’ll have to program our own alternative representation system for large numbers. We have a few different options here. For example, we could store decimal numbers one digit at a time in a list, in which case the only limit would be Scratch’s maximum list length of 200,000. If we stored five digits at a time as list entries, we could get to one million digits!</p>&#13;
<p class="indent">Another option could be to store the numbers as strings. Strings can be very long, even millions of characters. Scratch doesn’t provide any built-in operations for performing arithmetic on strings, though, so if we wanted to work with numbers represented as strings we’d have to program the arithmetic operations ourselves.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_16"/><a href="ch01.xhtml#ch1fig13">Figure 1-13</a> shows an example of a program that reliably performs calculations on numbers well beyond flintmax. The program prompts for an exponent <em>n</em> and then displays all the digits of 2<sup><em>n</em></sup>, both as a list of digits and as a string built by joining the digits together.</p>&#13;
<div class="image"><img id="ch1fig13" src="../images/pg36_Image_27.jpg" alt="Image" width="1017" height="1286"/></div>&#13;
<p class="figcap"><em>Figure 1-13: Calculating powers of 2 with extended precision</em></p>&#13;
<p class="indent">The program builds up 2<sup><em>n</em></sup> as a list of digits from right to left. The list (called <span class="literal">Digits</span>) starts with just the number 1, which is 2<sup>0</sup>. Then we repeat the process of <span epub:type="pagebreak" id="page_17"/>doubling <span class="literal">n</span> times, calculating the next highest power of 2 by stepping through each digit in the list (using the <span class="literal">i</span> variable) and doubling it <span class="ent">❶</span>. A problem comes up for digits with values between 5 and 9, though, which double into two-digit numbers.</p>&#13;
<p class="indent">To solve this problem, think about how addition works. In particular, consider how you’re taught to add multidigit numbers from right to left while keeping track of a <em>carry</em>. If you wanted to calculate 24 + 18, for example, you would start with the ones digit, so you would calculate 4 + 8 = 12, write down 2, and carry the 1. Then you would look at the tens digit; you would calculate 2 + 1 = 3, add the carry to get 4, and then report the answer as 42. The 1 that was carried in the first step was actually 10, so it counts as 1 ⋅ 10 when we keep track of the groups of 10 counted in the leftmost place.</p>&#13;
<p class="indent">The second nested repeat loop <span class="ent">➋</span> in <a href="ch01.xhtml#ch1fig13">Figure 1-13</a> implements this carrying logic to limit every number in the list to a single digit. Calculating <span class="literal">floor of item i of Digits / 10</span> gives us <span class="literal">1</span> if the current number has two digits. We add that <span class="literal">1</span> to the next item in the list (item <span class="literal">i + 1</span>) to perform the carry, then take <span class="literal">item i of Digits mod 10</span> to limit the current number to just its ones digit. Before all this, we add a <span class="literal">0</span> to the end of the list in case the last item needs a carry operation. The <span class="literal">if...then</span> statement near the end of the program removes that <span class="literal">0</span> if it wasn’t needed.</p>&#13;
<h5 class="h5" id="ch01lev15">Hacking the Code</h5>&#13;
<p class="noindent">It would be nice to see the answer reported so it looks like a number, not a digit-by-digit list. We can do that with the custom <span class="literal">To string</span> block shown in <a href="ch01.xhtml#ch1fig14">Figure 1-14</a>.</p>&#13;
<div class="image"><img id="ch1fig14" src="../images/pg37_Image_28.jpg" alt="Image" width="649" height="453"/></div>&#13;
<p class="figcap"><em>Figure 1-14: Merging the list of digits into a string</em></p>&#13;
<p class="indent">This block joins the items of the list into a string, building it up from right to left, so the answer is exhibited in a more readable way.</p>&#13;
<h5 class="h5" id="ch01lev16">The Results</h5>&#13;
<p class="noindent">Try testing the program on a bigger number than Scratch would normally be able to represent. For example, <a href="ch01.xhtml#ch1fig15">Figure 1-15</a> shows a run of the program calculating 2<sup>106</sup>, which is flintmax squared.</p>&#13;
<div class="image"><img id="ch1fig15" src="../images/pg38_Image_29.jpg" alt="Image" width="527" height="589"/></div>&#13;
<p class="figcap"><em>Figure 1-15: Accurately calculating flintmax squared</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_18"/>All 32 digits are reported correctly (after Scratch finishes, you can scroll down through the list to see them all). Notice that <span class="literal">Digits</span> lists the digits starting from the ones place.</p>&#13;
<div class="side-b">&#13;
<p class="centerb"><img class="inline" src="../images/pg26_Image_12.jpg" alt="Image" width="80" height="91"/> Programming Challenges</p>&#13;
<p class="indentib"><span class="blue"><strong>1.6</strong></span> Modify the power of 2 code in <a href="ch01.xhtml#ch1fig13">Figure 1-13</a> to calculate 3<sup>53</sup>.</p>&#13;
<p class="indentib"><span class="blue"><strong>1.7</strong></span> Modify the power of 2 code in <a href="ch01.xhtml#ch1fig13">Figure 1-13</a> so it works on “digits” that are between 0 and 99,999. That makes each list entry give five digits of the calculated power, allowing Scratch to hold up to one million digits.</p>&#13;
<p class="indentib"><span class="blue"><strong>1.8</strong></span> Program an extended precision addition, where Scratch Cat prompts for two large numbers entered as strings, resolves the numbers as lists of digits, and then adds the numbers using the same technique as the program in <a href="ch01.xhtml#ch1fig13">Figure 1-13</a>. Try to extend the code to handle multiplication as well.</p></div>&#13;
<h3 class="h3" id="ch01lev17"><span epub:type="pagebreak" id="page_19"/>Conclusion</h3>&#13;
<p class="noindent">If we understand how Scratch keeps track of numbers, we can be sure to avoid generating errors by asking for more than Scratch can give us. This will be especially important for integer arithmetic, where we need all the digits of a number to correctly manage questions about divisibility and counting.</p>&#13;
<p class="indent">Scratch’s internal representation of numbers matches that of many modern programming languages, so the information in this chapter is widely applicable. Once we know the limits, we can figure out how to work around them to get more information out of a program than the language could normally provide. That’s the best hack of all!<span epub:type="pagebreak" id="page_20"/></p>&#13;
</div>
</div>
</body></html>