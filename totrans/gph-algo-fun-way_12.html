<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch9">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_135" aria-label="135"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch9">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">9</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">TOPOLOGICAL SORT</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" role="presentation" alt="" width="386" height="386"/>&#13;
</figure>&#13;
<p class="ChapterIntro">In addition to their physical corollaries, such as one-way streets, we can use directed edges in a graph to specify a <i>dependency</i> or <i>ordering</i> between nodes. Incoming edges to a node represent links from actions that must be completed before reaching the current node. Meanwhile, outgoing edges point to actions enabled by the completion of the current node.</p>&#13;
<p class="TX">Consider the example of a recipe for chocolate chip cookies. Each node represents a step in the recipe, including instructions such as “Add the flour” and “Stir the mixture.” Some of the steps have a clear and non-negotiable ordering. We wouldn’t want to stir the mixture before adding anything to the bowl or add ingredients before we measure them.</p>&#13;
<p class="TX">This chapter introduces algorithms for <i>topological sort</i>, which orders a graph’s nodes in the order specified by directed edges. After discussing the concepts behind topological ordering and presenting several real-world use <span role="doc-pagebreak" epub:type="pagebreak" id="pg_136" aria-label="136"/>cases and algorithms for sorting, we’ll explore the importance of graphs without loops for topological sort and consider why instruction manuals are not drawn as graphs.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h-103"/><samp class="SANS_Futura_Std_Bold_B_11">How Topological Sort Algorithms Work</samp></h3>&#13;
<p class="TNI1">A topological sort algorithm finds an ordering of nodes such that if there exists a directed edge from node <i>u</i> to node <i>v</i>, then node <i>u</i> must precede node <i>v</i> in the ordering. In other words, each directed edge represents a <i>dependency</i>. Some graphs have multiple valid orderings. For example, <a href="#fig9-1">Figure 9-1</a> shows a graph with valid topological orderings [0, 1, 2, 4, 3] and [0, 2, 1, 4, 3].</p>&#13;
<figure class="IMG"><img id="fig9-1" class="img30" src="../images/f09001.jpg" alt="A graph with five nodes and directed edges (0, 1), (0, 2), (1, 3), (1, 4), (2, 4), and (4, 3)." width="461" height="273"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-1: A directed graph with two valid topological orderings</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">A key constraint for topological sort is that the graph must be <i>acyclic</i>, meaning it does not contain any <i>cycles</i>. A directed graph has a cycle if it is possible to define a path from a node such that the path returns to that same node, as shown in <a href="#fig9-2">Figure 9-2</a> (a slight modification of the graph in <a href="#fig9-1">Figure 9-1</a>). Starting from node 1, we can travel back to node 1 through nodes 4 and 3 via the path [1, 4, 3, 1].</p>&#13;
<figure class="IMG"><img id="fig9-2" class="img30" src="../images/f09002.jpg" alt="A graph with five nodes and directed edges (0, 1), (0, 2), (1, 4), (2, 4), (3, 1), and (4, 3)." width="461" height="273"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-2: A directed graph with a cycle</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">A graph with cycles will not have a valid topological ordering because it contains at least one node with a path that leads back to itself. That means this node must precede itself in the sorted list, which is obviously impossible. No matter how we order nodes 1, 3, and 4 in <a href="#fig9-2">Figure 9-2</a>, we’ll always have an edge pointing from a later to an earlier node. We call a directed graph with no cycles a <i>directed acyclic graph</i> or <i>DAG</i>.</p>&#13;
<p class="TX">We can test whether a topological ordering is valid by checking the relative ordering of each pair of nodes with a directed edge:</p>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_137" aria-label="137"/>def is_topo_ordered(g: Graph, ordering: list) -&gt; bool: &#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> if len(ordering) != g.num_nodes:&#13;
        return False&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> index_to_pos: list = [-1] * g.num_nodes&#13;
    for pos in range(g.num_nodes):&#13;
        current: int = ordering[pos]&#13;
        if index_to_pos[current] != -1:&#13;
            return False&#13;
        index_to_pos[current] = pos&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> for n in g.nodes:&#13;
        for edge in n.get_edge_list():&#13;
            if index_to_pos[edge.to_node] &lt;= index_to_pos[n.index]:&#13;
                return False&#13;
    return True&#13;
</code></pre>&#13;
<p class="TX">The code starts by checking that the ordering contains the same number of nodes as the graph <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. If not, the ordering cannot be valid, and the function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. Next, a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop builds an inverted index mapping each node to its location in the sorted array <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>. This will allow it to easily look up the relative ordering of any two nodes given their indices. During this loop, the code also checks for duplicate nodes in the ordering by testing if <samp class="SANS_TheSansMonoCd_W5Regular_11">index_to_pos</samp> is already set. If it finds a node listed twice, the function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> to indicate an invalid ordering.</p>&#13;
<p class="TX">The code then iterates through each node and each of its outgoing edges using a nested pair of <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops <span class="CodeAnnotationCode" aria-label="annotation3">❸</span>. For each of these directed edges, the code checks that the nodes are ordered correctly by comparing their positions in <samp class="SANS_TheSansMonoCd_W5Regular_11">ordering</samp> (using <samp class="SANS_TheSansMonoCd_W5Regular_11">index_to_pos</samp>). The function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> as soon as it finds a single pairing out of order. Finally, if the code has made it through this gauntlet of checks, it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h-104"/><samp class="SANS_Futura_Std_Bold_B_11">Use Cases</samp></h3>&#13;
<p class="TNI1">Topological sort has a variety of real-world use cases. This section describes how to represent several of these cases as graphs to which we could apply the topological sort.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h-105"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Code Dependencies</samp></h4>&#13;
<p class="TNI1">Programmers often break large programs into a series of modules or libraries to facilitate understandability, maintainability, and extensibility. Instead of a single file with a million lines of code, a programmer might create three modules: one for representing and processing graphs, another for handling the user interface, and a third for reading and writing files. Ideally, they would design the modules to build off one other, allowing them to reuse core library functions throughout the code. For example, the graph library and user interface code might rely on the file module to read and write configuration files.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_138" aria-label="138"/>Such code dependencies mean that the code is processed in a particular order. We can represent these dependencies as a directed graph where each module is a node in the graph and each <samp class="SANS_TheSansMonoCd_W5Regular_11">import</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">include</samp> statement represents an incoming edge to that node. The topological sort of this graph tells the computer the order in which it needs to process the files.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h-106"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Task Lists</samp></h4>&#13;
<p class="TNI1">We can extend the importance of following a recipe in a particular order to a wide range of tasks, from writing to cleaning to assembling furniture. In each of these cases, nodes represent steps on our task list and edges represent dependencies between them. For example, we need to get out the mop and bucket before we can wash the floor. As another example, <a href="#fig9-3">Figure 9-3</a> shows a graph representing the steps for making a peanut-butter-and-jelly sandwich.</p>&#13;
<figure class="IMG"><img id="fig9-3" class="img100" src="../images/f09003.jpg" alt="Seven boxes represent steps of making a sandwich. On the left are boxes for “Get two pieces of bread,” “Get jar of peanut butter,” and “Get jar of jelly or jam.” The box for “Get two pieces of bread” has an arrow to the box for “Place bread on plate.” The box for “Spread peanut butter onto one piece of bread” has arrows from the boxes “Place bread on plate” and “Get jar of peanut butter.” The box for “Spread jelly onto the other piece of bread” has arrows from the boxes “Spread peanut butter onto one piece of bread” and “Get jar of jelly or jam.” The box for “Place the bread with the peanut butter on top of the bread with jelly to make a sandwich” has an arrow from the box “Spread jelly onto the other piece of bread.”" width="1381" height="332"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-3: The task graph for making a peanut-butter-and-jelly sandwich</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Although most instruction manuals are written as a linear series of instructions, there is often some flexibility in the order, meaning the graph is not necessarily a straight line of nodes. For example, consider the process of assembling a prefabricated chair. It might not matter whether you attach the left or right arm first. However, it could be vital that you finish the body of the chair before attaching the seat cushion.</p>&#13;
<p class="TX">Representing instructions as a graph clearly offers opportunities for parallelism. Two people working on a single recipe could theoretically complete it more quickly than one alone; one baker can measure out the flour while another measures out the sugar, and so on. Unfortunately, this parallel representation would likely cause more rather than fewer problems. I personally struggle to remember which step I’m on when using linear instructions, spending minutes trying to remember whether I’ve added the salt to the bowl. Tracking which steps have been completed through a branching graph of tasks is almost guaranteed to result in me missing steps.</p>&#13;
<p class="TX">Fortunately, while humans struggle to track this type of state, computers excel at it, using graph structures to find opportunities for parallelism. In fact, there are entire systems that structure workflows as graphs. Distributed workflow systems are often built around the concept of task graphs, where multiple tasks are executed in an order determined by their dependency. The design and optimization of such workflows is an active area of development, and the topic could fill its own book.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_139" aria-label="139"/>&#13;
<h4 class="H2" id="sec5"><span id="h-107"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Teaching and Learning</samp></h4>&#13;
<p class="TNI1">Many academic subjects consist of a large set of interrelated concepts, some of which must be understood before moving on to the next. A math teacher would find it difficult to explain the concept of exponents before their students have learned how to multiply. Other concepts can be covered in parallel, however. When learning a foreign language, the student might be able to learn vocabulary related to coffee shops regardless of whether they know computer science terminology.</p>&#13;
<p class="TX">We can specify the recommended order for teaching or learning concepts as a graph. Nodes represent concepts, such as the French word for coffee or the idea of recursion, while edges represent dependencies between the concepts. In the case of computer science, we might put an edge from the concept of functions to that of recursion to indicate that a student should learn about functions before venturing into the world of recursion.</p>&#13;
<p class="TX">Relying on this graph representation, we can use topological sort to determine which courses in a college curriculum we need to take first. Consider the graph in <a href="#fig9-4">Figure 9-4</a> built from hypothetical course prerequisites.</p>&#13;
<figure class="IMG"><img id="fig9-4" class="img100" src="../images/f09004.jpg" alt="Seven boxes represent different computer science classes. The box for CS300: Advanced Algorithms lists prerequisites CS200 and CS201 and has incoming arrows from both of those boxes." width="1635" height="449"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-4: A graph representing the prerequisites of computer science courses</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">To take CS450: Advanced AI, a student would need to complete the chain of prerequisites for this course, all the way back to CS100: Introduction to Programming.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h3 class="H1" id="sec6"><span id="h-108"/><samp class="SANS_Futura_Std_Bold_B_11">Kahn’s Algorithm</samp></h3>&#13;
<p class="TNI1">Computer scientist Arthur B. Kahn developed one approach, now called <i>Kahn’s algorithm</i>, for performing topological sort on a directed acyclic graph. This algorithm operates by finding nodes with no incoming edges, removing them from the list of pending nodes, adding them to a sorted list, and then removing the outbound edges from that node. The algorithm repeats until it has added every node to the sorted list.</p>&#13;
<p class="TX">Intuitively, the Kahn’s algorithm sort mirrors how we might perform a complex task in the real world. We perform a subtask that we can accomplish without completing any other steps first, then move on to another <span role="doc-pagebreak" epub:type="pagebreak" id="pg_140" aria-label="140"/>subtask. Any action that requires us to have performed an as-yet-uncompleted task must wait until we have finished all its dependencies.</p>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h-109"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp></h4>&#13;
<p class="TNI1">When implementing Kahn’s algorithm, we don’t need to modify the graph we’re working with by removing nodes or edges. Instead, we can use an additional array <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> to track the number of incoming edges to each node and decrease those counts whenever we “remove” a node. Since we don’t have to modify the graph data structure, we can avoid making an initial copy, re-adding the removed edges, or leaving the structure altered.</p>&#13;
<p class="TX">The code for Kahn’s algorithm uses a stack and multiple loops, as shown in <a href="#list9-1">Listing 9-1</a>.</p>&#13;
<span id="list9-1"/>&#13;
<pre><code>def Kahns(g: Graph) -&gt; list: &#13;
    count: list = [0] * g.num_nodes&#13;
    s: list = []&#13;
    result: list = []&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> for current in g.nodes:&#13;
        for edge in current.get_edge_list():&#13;
            count[edge.to_node] = count[edge.to_node] + 1&#13;
    for current in g.nodes:&#13;
        if count[current.index] == 0:&#13;
            s.append(current.index)&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> while len(s) &gt; 0:&#13;
        current_index: int = s.pop()&#13;
        result.append(current_index)&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> for edge in g.nodes[current_index].get_edge_list():&#13;
            count[edge.to_node] = count[edge.to_node] - 1&#13;
            if count[edge.to_node] == 0:&#13;
                s.append(edge.to_node)&#13;
    return result&#13;
</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-1: Kahn’s algorithm for topological sorting</samp></p>&#13;
<p class="TX">The code starts by creating the helper data structures used by the algorithm. The array <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> stores the count of <i>incoming</i> nodes for each edge and will be used to check for nodes without any incoming edges. The stack <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> (implemented as a list) stores the indices of unprocessed nodes without incoming edges. These will be the nodes that the code can remove from the graph. Finally, the list <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp> will hold the topologically sorted list of node indices.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_141" aria-label="141"/>The code uses a pair of nested <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops to count the number of incoming edges for each node <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. In the first loop, since the algorithm is working on a directed graph, the code must iterate over all nodes (outer loop) and their outgoing edges (inner loop) and increment the count of incoming edges for the edge’s destination (<samp class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp>). The next <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop iterates over the <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> array, finds nodes that have no incoming edges (<samp class="SANS_TheSansMonoCd_W5Regular_11">count[current.index]</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>), and inserts their index into the stack <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>. The function has now set up all the initial information it needs to perform the topological sort.</p>&#13;
<p class="TX">The main body of the code is a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop that processes each item in the stack <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>. At each iteration, the code pops a node index from <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>. It retrieves the corresponding node and adds this index to the end of the <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp> array. The function then virtually removes the node and its outgoing edges by iterating over each outgoing edge and decreasing the count of edges going to the destination <span class="CodeAnnotationCode" aria-label="annotation3">❸</span>. In the process, it checks whether any node falls to zero incoming edges and, if so, adds that node’s index to the stack. The code completes by returning the array of sorted node indices with <samp class="SANS_TheSansMonoCd_W5Regular_11">return result</samp>.</p>&#13;
<p class="TX">Each iteration focuses on a single node and its outgoing edges, meaning the running time of the algorithm scales linearly with the number of nodes plus the number of outgoing edges.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h4 class="H2"><span id="sec8"/><span id="h-110"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp></h4>&#13;
<p class="TNI1"><a href="#fig9-5">Figure 9-5</a> shows how to run Kahn’s algorithm on an example graph, where each subfigure represents a step in the algorithm’s progression. The figure displays the count of the incoming edges (the values in <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp>) above each node and grays out removed nodes and edges.</p>&#13;
<p class="TX">The algorithm initializes the counts of incoming edges based on the input graph and stores the two nodes without any incoming edges (nodes 0 and 1) in the stack, as shown in <a href="#fig9-5">Figure 9-5(a)</a>. During the first step of the sort in <a href="#fig9-5">Figure 9-5(b)</a>, the algorithm takes the top element (node 1) off the next stack and “removes” it and its outgoing edges from the graph, resulting in decreased counts for nodes 3 and 4. Since neither destination node’s count decreases to zero, the code adds neither to the stack.</p>&#13;
<p class="TX">In <a href="#fig9-5">Figure 9-5(c)</a>, the sort continues by popping node 0 from the stack and removing its edges to nodes 2 and 3. This reduces the count in incoming edges to both nodes 2 and 3 down to zero, allowing the sort to add them to the stack. The process continues, node by node, until every node in the stack has been exhausted.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_142" aria-label="142"/>&#13;
<figure class="IMG"><img id="fig9-5" class="img100" src="../images/f09005.jpg" alt="The seven steps of Kahn’s algorithm. (A) shows a directed graph with edges (0, 2), (0, 3), (1, 3), (1, 4), (2, 4), (3, 4), and (4, 5). In (B), node 1 is grayed out along with its edges to nodes 3 and 4. The count to above node 3 is 1." width="1506" height="1675"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-5: Running Kahn’s algorithm on an example graph</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">We can picture Kahn’s algorithm in the context of a careful baker following a complex recipe. Before they start, the baker writes down all the tasks and which ones are the necessary prerequisites. Task 5a, “Add two cups of flour,” must come after Task 4, “Mix the wet ingredients in a large bowl,” and Task 1a, “Measure two cups of flour.” However, the baker can complete Task 5a either before or after Task 5b, “Add a tablespoon of baking soda,” because the order in which the flour and baking soda are added does not matter. The baker counts the number of prerequisites for each task and writes those numbers next to their respective tasks.</p>&#13;
<p class="TX">The baker begins by choosing one task with no outstanding prerequisites, performing that task, and checking it off the list. They then go <span role="doc-pagebreak" epub:type="pagebreak" id="pg_143" aria-label="143"/>through the list of tasks and update the count of unsatisfied prerequisites for all future tasks that depended on the one they just completed. After measuring out two cups of flour, for example, they can update the dependency count of Task 5a, “Add two cups of flour,” from 2 to 1—they’ve measured the flour but still need to mix the wet ingredients before proceeding. Once they’ve completed Task 4, “Mix the wet ingredients in a large bowl,” they can put Task 5a on their list of next steps.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h3 class="H1" id="sec9"><span id="h-111"/><samp class="SANS_Futura_Std_Bold_B_11">Depth-First Search</samp></h3>&#13;
<p class="TNI1">Beyond Kahn’s algorithm, an alternative approach to sorting the nodes in a directed acyclic graph is to use the trusty multipurpose tool of depth-first search. Depth-first search starts at a given node <i>u</i>, then explores the nodes after <i>u</i> in topological order. We can modify depth-first search to track the order in which we complete processing of each node. By saving the order in which the search finishes exploring each node, depth-first search can reconstruct the <i>inverse</i> ordering of nodes. The last nodes in topological ordering will be the first to finish in a depth-first search and thus will appear at the start of the list.</p>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2"><span id="sec10"/><span id="h-112"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp></h4>&#13;
<p class="TNI1">The code for topological sort based on depth-first search largely mirrors the other depth-first search implementations that we have used throughout the book, as shown in <a href="#list9-2">Listing 9-2</a>. However, we maintain one additional piece of information: a list <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> to track the order in which the search completes its visits to each node.</p>&#13;
<span id="list9-2"/>&#13;
<pre><code>def topological_dfs(g: Graph) -&gt; list: &#13;
    seen: list = [False] * g.num_nodes&#13;
    s: list = []&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> for ind in range(g.num_nodes):&#13;
        if not seen[ind]:&#13;
            topological_dfs_recursive(g, ind, seen, s)&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> s.reverse()&#13;
    return s&#13;
&#13;
def topological_dfs_recursive(g: Graph, index: int, seen: list, s: list):&#13;
    seen[index] = True&#13;
    current: Node = g.nodes[index]&#13;
    for edge in current.get_edge_list():&#13;
        neighbor: int = edge.to_node&#13;
        if not seen[neighbor]:&#13;
            topological_dfs_recursive(g, neighbor, seen, s)&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> s.append(index)&#13;
</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-2: The depth-first search algorithm for topological sorting</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_144" aria-label="144"/>The code in <a href="#list9-2">Listing 9-2</a> consists of two functions. The outer <samp class="SANS_TheSansMonoCd_W5Regular_11">topological _dfs()</samp> function sets up the data structures, calls depth-first search on different starting nodes, and processes the results. It starts by creating an empty list <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> and a list <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp> with all entries set to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. The function then loops through each node. If it finds a node that has not yet been visited, the function starts a depth-first search from that node <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. Finally, the function takes the list of node indices and outputs them to the result list in reverse order <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">The inner <samp class="SANS_TheSansMonoCd_W5Regular_11">topological_dfs_recursive()</samp> function that follows is a recursive implementation of depth-first search with one modification: it appends each completed node onto a list. This function starts by marking the current node as seen, then iterates through the neighbors via the list of edges and recursively explores any unseen neighbors. Finally, it inserts the current node index at the end of the list <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> to track the order in which it finished visiting the nodes <span class="CodeAnnotationCode" aria-label="annotation3">❸</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2"><span id="sec11"/><span id="h-113"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp></h4>&#13;
<p class="TNI1"><a href="#fig9-6">Figure 9-6</a> shows an example topological sort by depth-first search, where the current node being visited is circled by a dashed line and the seen nodes are shaded.</p>&#13;
<p class="TX">The search begins in <a href="#fig9-6">Figure 9-6(a)</a> on node 0 and explores down the path of node 2 in <a href="#fig9-6">Figure 9-6(b)</a>, node 4 in <a href="#fig9-6">Figure 9-6(c)</a>, and node 5 in <a href="#fig9-6">Figure 9-6(d)</a>. At each node, the algorithm marks the node as seen and recursively explores its unseen neighbors. It isn’t until the search finishes processing a node and backtracks to its predecessor that it inserts the node into the sorted list, as shown in <a href="#fig9-6">Figure 9-6(d)</a>, where the search hits a dead end at node 5 and is forced to backtrack. Inserting a node into the inversely sorted list means that node must come after all nodes that preceded it in the search.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_145" aria-label="145"/>&#13;
<figure class="IMG"><img id="fig9-6" class="img80" src="../images/f09006.jpg" alt="Twelve steps of the depth-first search algorithm on a graph with directed edges (0, 2), (0, 3), (1, 3), (1, 4), (2, 4), (3, 4), and (4, 5). In (D), nodes 0, 2, 4, and 5 are grayed out with node 5 circled. In (E), node 4 is circled and the list s now includes 5." width="1349" height="1821"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-6: Running a depth-first search for topological sort on an example graph</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">As the search backtracks through node 4 in <a href="#fig9-6">Figure 9-6(e)</a> and node 2 in <a href="#fig9-6">Figure 9-6(f)</a>, it checks for other outgoing edges. Finding none, it adds the current node to the list and backtracks. When it returns to node 0 in <a href="#fig9-6">Figure 9-6(g)</a>, the depth-first search can continue before backtracking once more. It recursively explores node 3 in <a href="#fig9-6">Figure 9-6(h)</a>.</p>&#13;
<p class="TX">As shown in <a href="#fig9-6">Figure 9-6(j)</a>, we might not be done after our initial depth-first search completes. Node 1 did not lie on any paths out of node 0 and thus has not been explored. The search continues by checking whether all <span role="doc-pagebreak" epub:type="pagebreak" id="pg_146" aria-label="146"/>the nodes have been seen and, if not, starting a depth-first search from that unseen node. At the end of the algorithm, the search has visited all nodes and assembled a list of nodes in inverse topological order, as shown in <a href="#fig9-6">Figure 9-6(l)</a>.</p>&#13;
<p class="TX">We can picture this search in the context of a college student planning out a series of courses to take. They list the courses they want to take as nodes in a graph and use directed edges to represent the prerequisites. The depth-first search starts at a node with the question, “What courses will this course allow me to take?” When the search reaches a dead end, the student knows they have found a course that is not a prerequisite for anything else in their curriculum</p>&#13;
<p class="TX">Returning to the course list in <a href="#fig9-4">Figure 9-4</a>, consider what happens when the student starts with CS200 and follows the path through CS350 to CS450. CS450 is fully explored, so they turn to their list of unexplored courses. The student returns to CS350, which is not a prerequisite for any other classes, and adds it to the list. Ultimately, they build up the list [CS450, CS350, CS300, CS201, CS200]. They continue to the next unvisited course (perhaps CS100 in this case) and continue building out their study plan.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2" id="sec12"><span id="h-114"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Order of Starting Nodes</samp></h4>&#13;
<p class="TNI1">One counterintuitive aspect of the depth-first search approach to topological sort is that the <samp class="SANS_TheSansMonoCd_W5Regular_11">topological_dfs()</samp> base function in <a href="#list9-2">Listing 9-2</a> starts the recursive searches on each node according to that node’s index in the graph. It does not bother to sort the nodes according to number of incoming edges or any other aspect of its location.</p>&#13;
<p class="TX">This leads to cases where the search might begin at a node that has incoming edges, as with the graph in <a href="#fig9-7">Figure 9-7</a>. After all, we naturally think of depth-first search as starting at the beginning of a chain of nodes.</p>&#13;
<figure class="IMG"><img id="fig9-7" class="img30" src="../images/f09007.jpg" alt="A graph with four nodes and three edges: (1, 0), (0,2), and (3, 2)" width="461" height="273"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-7: A graph where node 0 has an incoming connection</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Fortunately, depth-first search works perfectly well in situations where node 0 is not the start of the topological ordering. In <a href="#fig9-7">Figure 9-7</a>, the depth-first search algorithm will start at node 0 and find nodes 0 and 2 in the initial recursive depth-first search. At the end of the first recursive depth-first search, the list containing the reversed ordering is <samp class="SANS_TheSansMonoCd_W5Regular_11">[2, 0]</samp>. While it may seem like we are making an error in skipping node 1, we will add it to the correct location during the next search.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_147" aria-label="147"/>The algorithm next starts a search at node 1 and adds that to the end of the list. Since the list is in <i>reverse</i> topological ordering, node 1 is in the correct location <i>after</i> node 0. After the search starts at node 1, the list is <samp class="SANS_TheSansMonoCd_W5Regular_11">[2, 0, 1]</samp>. After starting at node 3, the list becomes <samp class="SANS_TheSansMonoCd_W5Regular_11">[2, 0, 1, 3]</samp>. When the function concludes, it reverses the list using Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">reverse()</samp> function and returns the correct ordering <samp class="SANS_TheSansMonoCd_W5Regular_11">[3, 1, 0, 2]</samp>.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h3 class="H1" id="sec13"><span id="h-115"/><samp class="SANS_Futura_Std_Bold_B_11">Detecting Cycles</samp></h3>&#13;
<p class="TNI1">As noted earlier, a key constraint of topological sort is that the graph must be acyclic. Consider the hypothetical course sequence shown in <a href="#fig9-8">Figure 9-8</a>. All students must begin by taking CS100: Introduction to Programming, which has no prerequisites. However, things get more complex in the next semester. In an attempt to cover more material, the instructor of CS200: Introduction to Algorithms wants their students to know both programming and the basics of graphs. They require both CS100 and CS202: Introduction to Graphs as prerequisites. At the same time, the instructor for CS202 wants their students to know data structures, so they require CS201: Introduction to Data Structures as a prerequisite. Unfortunately, the instructor for CS201 wants their students to already know basic algorithms, so they require CS200 as a prerequisite.</p>&#13;
<figure class="IMG"><img id="fig9-8" class="img80" src="../images/f09008.jpg" alt="Five boxes represent different computer science classes. The box for “CS200: Introduction to algorithms” lists prerequisites CS100 and CS202 and has incoming arrows from both of those boxes." width="1105" height="1148"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-8: A set of course prerequisites with a cycle</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_148" aria-label="148"/>When a student completes CS100, they look at the courses they can now take and run into a problem. Each of the 200 level courses requires a different 200 level course as a prerequisite. There are no 200 level courses the student can take without missing a prerequisite.</p>&#13;
<p class="TX">We can adapt the algorithms presented in this chapter to detect whether a graph has cycles, providing a useful tool for vetting school requirements, instruction manuals, recipes, or any other graph representation of a sequence of events. One easy approach to doing this is to look at what happens when we run Kahn’s algorithm from <a href="#list9-1">Listing 9-1</a> on a graph with cycles. This algorithm relies on incoming connections dropping to zero when it has removed all the preceding nodes. To remove a node that is part of a cycle, the algorithm would first need to remove its predecessors, including the node itself. Thus, the count for a node in a cycle will never drop to zero, and the node will never be added to the sorted list. We therefore know that if the algorithm’s returned list does not contain all the nodes from the graph, at least one node must be part of a cycle and thus be unremovable.</p>&#13;
<p class="TX">We wrap Kahn’s algorithm in a function called <samp class="SANS_TheSansMonoCd_W5Regular_11">check_cycle_kahns()</samp>:</p>&#13;
<pre><code>def check_cycle_kahns(g: Graph) -&gt; bool:  &#13;
    result: list = Kahns(g)&#13;
    if len(result) == g.num_nodes:&#13;
        return False&#13;
    return True&#13;
</code></pre>&#13;
<p class="TX">The code for this check requires one additional <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement to test the length of the returned list. If the list is the same size as the graph, the code returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> to indicate no cycles. Otherwise, it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h3 class="H1" id="sec14"><span id="h-116"/><samp class="SANS_Futura_Std_Bold_B_11">Reordering Lists</samp></h3>&#13;
<p class="TNI1">Let’s consider a task that uses <i>topological sort</i>: reordering a list of items with forward dependencies. As an example, we’ll use topological sort to carry out the practical task of sorting the pages of a choose-your-own-adventure book so that you never need to flip backward.</p>&#13;
<p class="TX">As shown in <a href="#fig9-9">Figure 9-9</a>, we can visualize a choose-your-own-adventure book with <i>N</i> pages as a graph with <i>N</i> nodes. Because the reader must turn most pages consecutively to follow individual storylines, the corresponding nodes for most pages have one incoming edge from the previous page and one outgoing edge to the next page. However, what makes these books exciting are the decision points. <a href="#fig9-9">Figure 9-9</a> shows transitions around page <i>k</i>. The reader has two options: they can either turn to page <i>i</i> to explore the haunted house or turn to page <i>j</i> to climb the rain-soaked cliffs.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_149" aria-label="149"/>&#13;
<figure class="IMG"><img id="fig9-9" class="img100" src="../images/f09009.jpg" alt="A linear graph. Node k has an incoming edge from node K-1 and outgoing edges to nodes i and j." width="1674" height="221"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-9: A graph representing a choose-your-own-adventure book in page order</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Topological sort allows us to rearrange the pages into story order, as shown in <a href="#fig9-10">Figure 9-10</a>. The story starts on page 1. The narrative paths progress from left to right. They branch off at decision points, with some decisions leading to an unfortunate early end (represented by shaded nodes).</p>&#13;
<figure class="IMG"><img id="fig9-10" class="img100" src="../images/f09010.jpg" alt="A graph with all edges moving to the node on the right, with decision points branching to higher or lower lines of nodes." width="1160" height="357"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-10: Reorganizing the book into story order</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">We can use the two algorithms in this chapter to do the sorting for us. As input, we take a list of lists that maps each page to its corresponding options. The list <samp class="SANS_TheSansMonoCd_W5Regular_11">[[1], [3, 4], [-1], [-1], [2]]</samp> represents a five-page story with the index in the list corresponding to the current page. Page 0 leads deterministically to page 1. Page 1 has an option to proceed to page 3 or 4. Both pages 2 and 3 represent the end of the story (as represented by <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>). Finally, page 4 leads deterministically back to page 2.</p>&#13;
<p class="TX"><a href="#list9-3">Listing 9-3</a> shows the code to sort the story by transforming the list into a graph and, for the purposes of this example, calling Kahn’s algorithm.</p>&#13;
<span id="list9-3"/>&#13;
<pre><code>def sort_forward_pointers(options: list) -&gt; list:&#13;
    num_nodes: int = len(options)&#13;
    g: Graph = Graph(num_nodes)&#13;
    for current in range(num_nodes):&#13;
        for next_index in options[current]:&#13;
            if next_index != -1:&#13;
                g.insert_edge(current, next_index, 1.0)&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> return Kahns(g)&#13;
</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-3: Sorting forward pointers</samp></p>&#13;
<p class="TX">The code creates a graph with one node for each page. It then uses one <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop to iterate through each page and a second <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop to iterate through the outgoing options for that page. It checks whether the page represents a terminal state (<samp class="SANS_TheSansMonoCd_W5Regular_11">next_index</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>); if not, the code adds an edge to the following page in story order. Finally, the code calls Kahn’s algorithm <span role="doc-pagebreak" epub:type="pagebreak" id="pg_150" aria-label="150"/>to perform the topological sort and returns the result <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. (Alternatively, the code could use <samp class="SANS_TheSansMonoCd_W5Regular_11">topological_dfs()</samp> from <a href="#list9-2">Listing 9-2</a>.)</p>&#13;
<p class="TX">As an example implementation of this code, let’s apply it to the 10-page adventure shown in <a href="#fig9-11">Figure 9-11</a>.</p>&#13;
<figure class="IMG"><img id="fig9-11" class="img100" src="../images/f09011.jpg" alt="A graph with 10 nodes and edges (0,1), (1, 2), (2, 4), (2, 6), (6, 7), (4, 5), (5, 3), (5, 8), (8, 9). Nodes 3, 7, and 9 are shaded." width="1194" height="516"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-11: A story graph with 10 pages</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">We represent the options as a list of lists, with option <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp> indicating the end of a narrative line, whether it’s a positive or negative conclusion:</p>&#13;
<p class="EQ"><samp class="SANS_TheSansMonoCd_W5Regular_11">[[1], [2], [4, 6], [-1], [5], [3, 8], [7], [-1], [9], [-1]]</samp></p>&#13;
<p class="TX">When we run the input through the <samp class="SANS_TheSansMonoCd_W5Regular_11">sort_forward_pointers()</samp> function from <a href="#list9-2">Listing 9-2</a>, the code returns the following ordering:</p>&#13;
<p class="EQ"><samp class="SANS_TheSansMonoCd_W5Regular_11">[0, 1, 2, 6, 7, 4, 5, 8, 9, 3]</samp></p>&#13;
<p class="TX">Comparing this result to <a href="#fig9-11">Figure 9-11</a>, we can see that if we were to reorder the pages to begin with page 0, then turn to pages 1, 2, 6, and so on, we would never need to flip backward while following a narrative line.</p>&#13;
<p class="TX">While sorting choose-your-own-adventure books might not be a typical problem you need to handle in your everyday workflow, it’s easy to extrapolate from this example and apply the same techniques to other use cases. You can simply construct dependency graphs from either forward pointers (for choose-your-own-adventure books or recipes) or backward pointers (course prerequisites or code dependencies).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h3 class="H1" id="sec15"><span id="h-117"/><samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp></h3>&#13;
<p class="TNI1">Topological sort demonstrates how to use directed edges in graphs to enforce more abstract constraints like the ordering of items. We can transform a range of dependency and ordering problems into graphs by modeling the items as nodes and the dependency between them as directed edges.</p>&#13;
<p class="TX">As shown throughout the chapter, topological sort has a range of real-world use cases. We often perform topological sort in our day-to-day lives without even realizing it. Before we brew coffee, we fill the kettle with water. We know the correct series of steps for this particular operation without <span role="doc-pagebreak" epub:type="pagebreak" id="pg_151" aria-label="151"/>needing to represent it as a graph, of course. However, transforming topological sort into a graph problem greatly scales up the types of problems we can solve using this algorithm. Compilers can use topological sort to determine the order in which to compile thousands of source files in a project, for example. Cloud-based workflow systems can likewise use it to determine which computation to perform next. Once you start looking for it, topological sort arises throughout both the computational and everyday domains. Knowing how to model such problems and sort the tasks is the first step in implementing efficient solutions.</p>&#13;
<p class="TX">The next chapter considers connectivity within graphs and how to choose a subset of edges that makes the graph fully connected. Specifically, we examine the problem of finding the minimum cost set of edges that connect all of the nodes.</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>