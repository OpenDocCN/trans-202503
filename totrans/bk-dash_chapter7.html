<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<title>7. Exploring Machine Learning</title>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="sbo-rt-content"><section aria-labelledby="ch7" epub:type="chapter" role="doc-chapter">
<header>
<h2 class="CHAPTER" id="ch7">
<span class="CN"><span aria-label=" Page 123. " epub:type="pagebreak" id="pg_123" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">EXPLORING MACHINE LEARNING</samp></span>
</h2>
</header>
<figure class="opener"><img alt="" class="opener" height="203" src="../images/opener-img.png" width="203"/></figure>
<p class="ChapterIntro">This chapter explains how you can use Dash to visually explore and present the internals of machine learning models and classification algorithms. For instance, say you create a machine learning model for self-driving cars that classifies objects into humans, plants, and other cars, and you need to be able to explain to other programmers and non-technical management how and why your model works. Dashboard apps can help you do this in a quick, convincing, and visually appealing way.</p>
<p class="TX">In particular, this chapter starts with a conceptual introduction to the <i>support vector machine (SVM)</i>, the popular machine learning classification algorithm. SVMs provide a way to categorize data by telling us how to accurately split the data so that it is placed in the correct category. We’ll <span aria-label=" Page 124. " epub:type="pagebreak" id="pg_124" role="doc-pagebreak"></span>visualize the functioning of SVMs in a dashboard app using various kinds of plots and graphs.</p>
<p class="TX">We’ll then use the powerful NumPy library for numerical computations and the easy-to-use machine learning algorithms from scikit-learn. Most importantly, you’ll experience the great benefit of being able to use the gallery as a basis for diving deeper into more advanced dashboard applications written by the pros.</p>
<p class="TX">This chapter also introduces <i>wrapper functions</i>, a new Dash concept for creating custom, reusable components to give you more options than just the predefined Dash and HTML components. You’ll also learn about some new Dash standard components such as contour plots and graphs, and we’ll cover the Dash <i>load spinner</i>, which gives the user visual feedback when a specific dashboard component is loading. Load spinners are useful for more complicated dashboard applications that build slowly, often due to heavy computational load.</p>
<p class="NTX-H"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>
<p class="NTX"><i>The purpose of this chapter is to provide you with an overview of what is possible with Dash and to help you develop further skills. We don’t go too far into the weeds on any one topic. Our intention is to be informative rather than comprehensive, so if anything is particularly interesting to you, we recommend you check out the supplementary material on the Charming Data YouTube channel and on the companion website to this book:</i> <a href="https://learnplotlydash.com"><span class="Roman">https://learnplotlydash.com</span></a>.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="H1" id="sec1"><a id="h1-46"></a><samp class="SANS_Futura_Std_Bold_B_11">Dashboard Apps to Make Machine Learning Models</samp> <samp class="SANS_Futura_Std_Bold_B_11">More Intuitive</samp></h3>
<p class="TNI">As machine learning becomes more prevalent in computer science and in our everyday lives, it’s increasingly important to understand how computers reach the conclusions they reach. Machines can beat human grandmasters in chess and Go, reduce accident rates in many traffic scenarios, and produce more goods than human workers in a factory environment. When it comes to measurable performance, machines can often prove their superiority, convincing even the fiercest critics that their power can free up human labor.</p>
<p class="TX">However, it can be dangerous to observe the effectiveness of machines only through their performance metrics. We can’t know how machines will perform in extreme situations that couldn’t have been learned from datasets; data-driven approaches will always be biased toward past experiences. If a machine has not observed a stock market crash of 95 percent in 100 years of stock market history, it will unlikely consider this scenario in its models, but this scenario will likely occur someday in the future.</p>
<p class="TX">To mitigate this danger, organizations must better understand where the “intelligence” of machines comes from. What are their assumptions? On what basis do they reach their conclusions? How does their behavior change when presented with extreme inputs? A machine learning model from the <span aria-label=" Page 125. " epub:type="pagebreak" id="pg_125" role="doc-pagebreak"></span>1960s would undoubtedly consider negative interest rates as “extreme” or even “impossible.” Today we know better.</p>
<p class="TX">This leads us to the motivation of machine learning dashboards. A dashboard is a powerful tool for visualizing what is going on <i>inside</i> a machine. You can train a model and observe how it performs when given changing inputs. You can test extreme cases. You can see the internals and assess potential risks by overfitting the learning to past data.</p>
<p class="TX">Visualizing machine learning models allows you to <i>show</i> your models to your clients, enabling them to play with the input parameters and reach a level of trust in the models that would never have been possible in command line models. Dashboards help make the intelligence of your machines tangible.</p>
<p class="HeadB"><a id="h2-43"></a><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Classification: A Short Guide</samp></p>
<p class="TNI">You don’t need to have an in-depth understanding of classification or SVMs to follow the app in this chapter. We’ll go into some detail to facilitate understanding for those who are interested, but if you want to skip this section and the SVM section after it, feel free to do so and treat the SVM algorithm as a black box as you read through the rest of the chapter.</p>
<p class="TX">Still here? Okay, let’s dive into the very basics of the classification problem in machine learning.</p>
<p class="TX">Generally, the classification problem attempts to assign a category (that is, a class) to input data based on the learnings from a set of provided labeled (classified) training data. For example, if we want to predict what major students will likely study at college based on training data, we might measure aptitude for creative and logical thinking for each student in a school. The goal is to create a classification algorithm that predicts a label—the students’ predicted majors—from the features: aptitude for creative versus logical thinking.</p>
<p class="TX">SVMs, such as the one visualized in this dashboard app, are <i>classification</i> algorithms. Classification algorithms take a set of data and assign to each data point a label corresponding to a particular category, based on model learnings from training data. More specifically, a classification algorithm will search for a <i>decision boundary</i> that divides the data into two or more classes. A linear SVM models the decision boundary in an <i>n</i>-dimensional space as an <i>(n – 1)</i>-dimensional plane that divides the data points into two classes. All data points on one side of the decision boundary belong to one class and all data points on the other side belong to another class. Thus, assuming you can represent all data points in an <i>n</i>-dimensional space and you have an <i>(n – 1)</i>-dimensional decision boundary, you can use the decision boundary to classify new data, because any new data point falls on exactly one side of the boundary. Roughly speaking, the goal of classification, then, is to identify the decision boundary that separates the training and test data well.</p>
<p class="TX"><a href="chapter7.xhtml#fig7-1">Figure 7-1</a> gives an example inspired by but slightly modified from <i>Python One-Liners</i> by Christian Mayer (No Starch Press, 2020).</p>
<span aria-label=" Page 126. " epub:type="pagebreak" id="pg_126" role="doc-pagebreak"></span><a id="fig7-1"></a>
<figure class="IMG"><img alt="" class="img70" height="294" src="../images/Figure7-1.png" width="510"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-1: Example classification problem: different decision boundaries would lead to different classifications of the new data point (either “computer science” or “art”)</samp></p></figcaption>
</figure>
<p class="TX">This classification scenario creates a classification model that helps aspiring university students find a field of study that may fit their strengths. We have training data from previous students from two fields: computer science and art. Fortunately, the students already provided us with an estimation of their own logical and creative thinking skills. When mapped into a two-dimensional space that models logical and creative thinking as separate axes, the data seems to be clustered so that the computer science students tend to be strong in logical thinking whereas the artists tend to be strong in creative thinking. We use the data to find a decision boundary that maximizes the classification accuracy for the training data. Technically, the obtained classification model will only give aspiring students a hint about what they are likely to pick based on their strengths. It doesn’t necessarily help them decide what they should be picking (for example, to maximize their happiness). That is a much harder problem.</p>
<p class="TX">We’ll use the decision boundary to classify new users for whom we only have data on their logic and creativity. The figure shows two linear classifiers (depicted with lines) that perfectly separate the data when used as decision boundaries. They have 100 percent accuracy when classifying the test data, so both lines seem to be equally good. For a machine learning algorithm to perform well, it must choose the decision boundary wisely. But how do we find the best one?</p>
<p class="HeadB"><a id="h2-44"></a><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Support Vector Machines</samp></p>
<p class="TNI">SVMs attempt to maximize the distance between the closest data points from both classes and the decision boundary; this distance between the closest points and the decision boundary line is known as the <i>margin of safety</i>, <i>safety margin</i>, or just <i>margin</i>. These closest data points are called <i>support vectors</i>. By maximizing the margin of safety, SVMs aim to minimize the error when classifying new points that are close to the decision boundary.</p>
<p class="TX">As a visual example, take a look at <a href="chapter7.xhtml#fig7-2">Figure 7-2</a>.</p>
<span aria-label=" Page 127. " epub:type="pagebreak" id="pg_127" role="doc-pagebreak"></span><a id="fig7-2"></a>
<figure class="IMG"><img alt="" class="img70" height="300" src="../images/Figure7-2.png" width="524"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-2: Example SVM classification with decision boundary and support vectors</samp></p></figcaption>
</figure>
<p class="TX">The SVM classifier finds the support vectors for each class and places the line at the greatest distance from each (halfway between) so that the zone between the different support vectors is as thick as possible. This line is the decision boundary. In <a href="chapter7.xhtml#fig7-2">Figure 7-2</a> a new data point is added that needs classifying; however, because the point to be classified falls in the margin zone, the model cannot confidently decide whether it belongs to the art class or the computer science class. This nicely demonstrates that SVMs come with a built-in mechanism to explicitly tell us whether the model performs a borderline classification. For example, the SVM may tell us that a student ranking high on creativity belongs to the art class and a student ranking high in logical thinking belongs to the computer science class, but a student ranking high in creativity <i>and</i> logic cannot be confidently assigned to either class.</p>
<p class="TX">Note that SVM models can also be trained in a way that allows for <i>outliers</i> in the training data; these are points that fall on one side of the decision boundary but belong to the other side. This is the most common case for real-world data. However, instead of exploring these SVM optimizations further, we suggest you check out the excellent SVM classification tutorials listed at the end of this chapter so that we can dive into the exciting dashboard app right away.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h3 class="H1" id="sec2"><a id="h1-47"></a><samp class="SANS_Futura_Std_Bold_B_11">The SVM Explorer App</samp></h3>
<p class="TNI"><a href="chapter7.xhtml#fig7-3">Figure 7-3</a> shows how we can visualize SVMs using the SVM Explorer app, a Python dashboard app from the gallery that uses various kinds of plots and graphs. Feel free to play with the live project at <a href="https://dash-gallery.plotly.host/dash-svm"><i>https://<wbr/>dash<wbr/>-gallery<wbr/>.plotly<wbr/>.host<wbr/>/dash<wbr/>-svm</i></a>.</p>
<span aria-label=" Page 128. " epub:type="pagebreak" id="pg_128" role="doc-pagebreak"></span><a id="fig7-3"></a>
<figure class="IMG"><img alt="" class="img90" height="325" src="../images/Figure7-3.png" width="694"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-3: The SVM Explorer app from the gallery</samp></p></figcaption>
</figure>
<p class="TX">We’ll give you an overview of the SVM Explorer app first so that you can gain a rough understanding. The app showcases how a given SVM model classifies a given training dataset. You control the model using the dashboard controls, such as sliders, dropdowns, and radio buttons. Based on your selections, the output graphs and plots change to reflect the changing instantiation of the SVM model.</p>
<p class="TX">One of the authors of this app, Xing Han, has kindly provided us with a quick overview of the SVM Explorer app:</p>
<p class="Blockquote">This app is fully written in Dash and scikit-learn. All the components are used as input parameters for scikit-learn functions, which then generate a model with respect to the parameters the user changes. The model then performs predictions that are displayed on a contour plot, and its predictions are evaluated to create the ROC [receiver operating characteristic] curve and confusion matrix. In addition to creating models, it uses scikit-learn to generate the datasets you see, as well as the data needed for the metrics plots.</p>
<p class="TX">Let’s quickly examine each visible component. There are multiple input components in the left column of the dashboard:</p>
<ul class="List-1">
<li class="BL">The <i>Select Dataset</i> dropdown menu allows you to choose the synthetic dataset to use for training and testing. The default selection is Moon, named for its moon-shaped dataset. This input dropdown allows you to explore how the SVM model works on data with different inherent properties. For example, you can select the Circles dataset (not shown in the figure), which is nonlinear, so that the two datasets to be classified are shaped like an inner circle and an outer ring around that circle. The SVM model can classify those types of data too!</li>
<li class="BL">The <i>Sample Size</i> slider allows you to control the number of data points used to test and train the model. A higher sample size usually leads to a more accurate model, which is why machine learning companies never <span aria-label=" Page 129. " epub:type="pagebreak" id="pg_129" role="doc-pagebreak"></span>stop collecting more data! In our toy dashboard, however, a higher sample size may result in a more crowded visualization.</li>
<li class="BL">The <i>Noise Level</i> slider allows you to control the standard deviation of Gaussian noise added to the data. A higher noise level yields a less accurate model because noise reduces the clarity of patterns in the data and makes it harder to find a separating decision boundary during the training phase. You can, however, use the Noise Level slider to check how robust the SVM model will be in practice, because real-world data tends to be noisy.</li>
<li class="BL">The <i>Threshold</i> slider allows you to add a bias toward one class or the other. Roughly speaking, by increasing the threshold value you shift the decision boundary from class A more toward class B (or vice versa by decreasing the threshold) so that for a given input, the likelihood of being classified as A increases. For example, if the threshold is 0.4, any score greater than 0.4 is considered a positive prediction and any score less than 0.4 is considered a negative prediction on whether the point belongs to a certain class.</li>
<li class="BL">The <i>Reset Threshold</i> button resets the threshold to a default value without a customized threshold or bias.</li>
<li class="BL">The <i>Kernel</i> dropdown menu, the <i>Costs</i> sliders, and other controls such as the <i>Gamma</i> slider and the <i>Shrinking</i> radio buttons allow you to further control other SVM parameters and their effect on classification accuracy. Discussing these parameters would need more than just one or two sentences in this quick overview, so we’ll skip it. If you’re interested in learning the theory behind these controls, feel free to consult Chapter 15 of <i>Introduction to Information Retrieval</i> (Cambridge University Press, 2008). You can read the chapter for free at <a href="https://nlp.stanford.edu/IR-book/pdf/15svm.pdf"><i>https://<wbr/>nlp<wbr/>.stanford<wbr/>.edu<wbr/>/IR<wbr/>-book<wbr/>/pdf<wbr/>/15svm<wbr/>.pdf</i></a>.</li>
</ul>
<p class="TX">Three output components change as the model changes:</p>
<ul class="List-1">
<li class="BL">The <i>Dash Graph component</i> is a contour plot that visualizes the training and testing data, as well as the model classification confidence levels, in a heat map overlay. The dots represent the training data and the triangles represent the test data. Red data points belong to one class and blue to another. First we train the SVM model based on a subset of the sample data. Then we classify the test data using the trained model and plot the predicted class in the visualization.</li>
<li class="BL">The <i>ROC curve plot</i> is a measure of quality of the SVM model on the given dataset. It measures the <i>true positive rate</i>, which is the proportion of data points that are correctly classified, against the <i>false positive rate,</i> which is the proportion of data points that are incorrectly classified.</li>
<li class="BL">The <i>confusion matrix</i> refers to the predicted versus actual classes. Specifically, it’s a bar chart that shows the number of true positive, true negative, false positive, and false negative classifications of the test data. You can think of this as yet another measure of how well the SVM model performs the training and classification task on the given dataset.</li>
</ul>
<p class="TX"><span aria-label=" Page 130. " epub:type="pagebreak" id="pg_130" role="doc-pagebreak"></span>We’ve provided links to more detailed explanations of the Dash <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>, the ROC curve plot, and the confusion matrix at the end of this chapter. However, a great way to get a better understanding is to play around with the SVM Explorer app. We recommend spending 10 to 20 minutes playing with the app to fully grasp the idea of each component.</p>
<p class="TX">You can find the code for the app in the GitHub repository at <a href="https://github.com/DashBookProject/Plotly-Dash/tree/master/Chapter-7"><i>https://<wbr/>github<wbr/>.com<wbr/>/DashBookProject<wbr/>/Plotly<wbr/>-Dash<wbr/>/tree<wbr/>/master<wbr/>/Chapter<wbr/>-7</i></a>. The complete code has more than 650 lines, but don’t worry, we will focus only on the most important aspects. Note that well-maintained code seldom stays the same forever. Since this chapter’s writing, the authors have already updated the original code base by adding new styles to the app, among other things. But because the core of the app didn’t change, we have provided the original code on the specified GitHub repository so you can download it and reproduce the exact app explained in this chapter. We highly recommend that you download the code to accelerate your learning.</p>
<p class="TX">Without further ado, let’s dive into the code!</p>
<p class="HeadB"><a id="h2-45"></a><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Python Libraries</samp></p>
<p class="TNI">We’ll stand on the shoulders of giants and rely on several Python libraries to create our SVM dashboard app. <a href="chapter7.xhtml#List7-1">Listing 7-1</a> shows the libraries used in this project.</p>
<a id="List7-1"></a>
<p class="_CodeSpaceAbove"><samp class="SANS_TheSansMonoCd_W5Regular_11">import time</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">import importlib</samp></p>
<p class="_CodeSpace"><samp class="SANS_TheSansMonoCd_W5Regular_11">from dash import Dash, dcc, html, Input, Output, State</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">import numpy as np</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">from dash.dependencies import Input, Output, State</samp></p>
<p class="Code-HANG"><span aria-label="annotation1" class="SANS_NSAnnotations500_Monospace500_11">❶</span> <samp class="SANS_TheSansMonoCd_W5Regular_11">from sklearn.model_selection import train_test_split</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">from sklearn.preprocessing import StandardScaler</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">from sklearn import datasets</samp></p>
<p class="_CodeSpaceBelow"><samp class="SANS_TheSansMonoCd_W5Regular_11">from sklearn.svm import SVC</samp></p>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-1: Dependencies for the SVM app</samp></p>
<p class="TX">You’ve already seen the Dash library statements that import the core and HTML components, as well as the overall Dash app functionality. The core code in this chapter consists of the computations for the SVM. We won’t implement our own SVM from scratch, but we will rely on the excellent implementations provided by the scikit-learn library. We therefore import some modules from this library, which we’ll look at in more detail as they come up <span aria-label="annotation1" class="SANS_NSAnnotations_Monospace_11">❶</span>. If you’re interested in machine learning, scikit-learn is your best friend!</p>
<p class="HeadB"><a id="h2-46"></a><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Data Management</samp></p>
<p class="TNI">scikit-learn provides some great synthetic datasets for testing all kinds of classification and prediction algorithms. In <a href="chapter7.xhtml#List7-2">Listing 7-2</a> we show how the function <samp class="SANS_TheSansMonoCd_W5Regular_11">generate_data()</samp> dynamically creates the dataset using the number of sample points, the type of the dataset, and the noise level, all specified <span aria-label=" Page 131. " epub:type="pagebreak" id="pg_131" role="doc-pagebreak"></span>in the left column of the SVM Explorer app shown in <a href="chapter7.xhtml#fig7-3">Figure 7-3</a>. We’ll use the functions <samp class="SANS_TheSansMonoCd_W5Regular_11">datasets.make_moons()</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">datasets.make_circles()</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">datasets.make_classification()</samp> to generate different datasets (<samp class="SANS_TheSansMonoCd_W5Regular_11">"moons"</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">"circles"</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">"linear"</samp>, respectively) according to the value obtained through the input dropdown menu. This dataset is used later to train and test our SVM.</p>
<a id="List7-2"></a>
<p class="_CodeSpaceAbove"><samp class="SANS_TheSansMonoCd_W5Regular_11">def generate_data(n_samples, dataset, noise):</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   if dataset == "moons":</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      return datasets.make_moons(n_samples=n_samples,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">                                 noise=noise, random_state=0)</samp></p>
<p class="_CodeSpace"><samp class="SANS_TheSansMonoCd_W5Regular_11">   elif dataset == "circles":</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      return datasets.make_circles(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">         n_samples=n_samples, noise=noise, factor=0.5, random_state=</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">    )</samp></p>
<p class="_CodeSpace"><samp class="SANS_TheSansMonoCd_W5Regular_11">   elif dataset == "linear":</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      X, y = datasets.make_classification(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">         n_samples=n_samples,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">         n_features=2,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">         n_redundant=0,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">         n_informative=2,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">         random_state=2,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">         n_clusters_per_class=1,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      )</samp></p>
<p class="_CodeSpace"><samp class="SANS_TheSansMonoCd_W5Regular_11">      rng = np.random.RandomState(2)</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      X +=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">noise * rng.uniform(size=X.shape)</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      linearly_separable = (X, y)</samp></p>
<p class="_CodeSpace"><samp class="SANS_TheSansMonoCd_W5Regular_11">      return linearly_separable</samp></p>
<p class="_CodeSpace"><samp class="SANS_TheSansMonoCd_W5Regular_11">   else:</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      raise ValueError(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">        "Data type incorrectly specified. Choose an existing dataset."</samp></p>
<p class="_CodeSpaceBelow"><samp class="SANS_TheSansMonoCd_W5Regular_11">      )</samp></p>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-2: Data management for the SVM app</samp></p>
<p class="TX">At a high level, the code consists of <samp class="SANS_TheSansMonoCd_W5Regular_11">if…elif…elif…else</samp> statements that differentiate user inputs. This allows the user to choose among three datasets: <samp class="SANS_TheSansMonoCd_W5Regular_11">"moons"</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">"circles"</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">"linear"</samp>. In each case, a new dataset is created with scikit-learn’s <samp class="SANS_TheSansMonoCd_W5Regular_11">dataset.make_X()</samp> function, which takes different input arguments (such as the number of sample points) and returns the data as a NumPy array. Interested readers can learn more about the input arguments we used here at <a href="https://scikit-learn.org/stable/modules/classes.xhtml#module-sklearn.datasets"><i>https://<wbr/>scikit<wbr/>-learn<wbr/>.org<wbr/>/stable<wbr/>/modules<wbr/>/classes<wbr/>.xhtml#module<wbr/>-sklearn<wbr/>.datasets</i></a>.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h3 class="H1" id="sec3"><a id="h1-48"></a><samp class="SANS_Futura_Std_Bold_B_11">Layout and Styling</samp></h3>
<p class="TNI">The layout and styling sections give you an idea of the structure of the SVM Explorer app and the basic Dash components from which it is built. Let’s start with the overall layout of the project.</p>
<p class="HeadB"><a id="h2-47"></a><span aria-label=" Page 132. " epub:type="pagebreak" id="pg_132" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Layout</samp></p>
<p class="TNI">As you start working on larger apps, the number of lines of code in the <i>app.py</i> file quickly becomes harder to manage. To help manage the code, the SVM Explorer app includes a <i>utils</i> folder with two helper modules, <i>dash_resuable_components.py</i> and <i>figures.py</i>, which contain the definitions of some customized Dash components that we’ll explore in more detail later in this chapter, as well as some plotting and styling functionality. This approach of pulling out utility functionality from the <i>app.py</i> file into some imported external modules is good practice for your own larger dashboard projects, to make sure the main <i>app.py</i> remains clean and focused.</p>
<p class="TX">The structure of the SVM Explorer app looks like this:</p>
<p class="_CodeSpaceAbove"><samp class="SANS_TheSansMonoCd_W5Regular_11">- app.py</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">- utils/</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   |--dash_reusable_components.py</samp></p>
<p class="_CodeSpaceBelow"><samp class="SANS_TheSansMonoCd_W5Regular_11">   |--figures.py</samp></p>
<p class="TX">The layout of the app is a hierarchically nested structure of HTML elements, as shown in <a href="chapter7.xhtml#List7-3">Listing 7-3</a>.</p>
<a id="List7-3"></a>
<p class="_CodeSpaceAbove"><samp class="SANS_TheSansMonoCd_W5Regular_11">app.layout = html.Div(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   children=[html.Div(…), # Heading etc.</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      html.Div(…)] # Body</samp></p>
<p class="_CodeSpaceBelow"><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp></p>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-3: Zooming one level in the SVM app layout</samp></p>
<p class="TX">The first child of the outer <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp> contains the app’s heading, logo, and other meta-information. The second child contains the body of the app, which is the central part of the app. <a href="chapter7.xhtml#List7-4">Listing 7-4</a> shows the full code for the layout section of our SVM Explorer app. Just skim over it and try to understand how the app is structured; we’ll discuss the relevant parts afterward.</p>
<a id="List7-4"></a>
<div class="code">
<p class="Code-HANG"><span aria-label="annotation1" class="SANS_NSAnnotations500_Monospace500_11">❶</span> <samp class="SANS_TheSansMonoCd_W5Regular_11">app.layout = html.Div(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   children=[</samp></p>
<p class="Code"><span class="gray"><samp class="SANS_TheSansMonoCd_W5Regular_11">     # .container class is fixed, .container.scalable is scalable</samp></span></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   </samp><span aria-label="annotation2" class="SANS_NSAnnotations_Monospace_11">❷</span> <samp class="SANS_TheSansMonoCd_W5Regular_11">html.Div(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">        className="banner",</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">        children=[</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">     </samp><samp class="SANS_TheSansMonoCd_W5Regular_11">      html.Div(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">              className="container scalable",</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">              children=</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">[</samp></p>
<p class="Code"><span class="gray"><samp class="SANS_TheSansMonoCd_W5Regular_11">                 # Change App Name here</samp></span></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">                 html.H2(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">                    id="banner-title",</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">                    children=[</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">                       html.A(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">                          "Support Vector Machine (SVM) Explorer",</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">                          href=("</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">https://github.com/"</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">                            "plotly/dash-svm"),</samp></p>
<p class="Code"><span aria-label=" Page 133. " epub:type="pagebreak" id="pg_133" role="doc-pagebreak"></span><samp class="SANS_TheSansMonoCd_W5Regular_11">            </samp><samp class="SANS_TheSansMonoCd_W5Regular_11">              style={</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">                            "text-decoration": "none",</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">                            "color": "inherit",</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">            </samp><samp class="SANS_TheSansMonoCd_W5Regular_11">              },</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">                      )</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">                    ],</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">                 ),</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">                 html.A(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">                    id="banner-logo",</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">                    children=[</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">        </samp><samp class="SANS_TheSansMonoCd_W5Regular_11">               html.Img(src=app.get_asset_url(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">                      </samp><samp class="SANS_TheSansMonoCd_W5Regular_11">    "dash-logo-new.png"))</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">                    ],</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">            </samp><samp class="SANS_TheSansMonoCd_W5Regular_11">        href="</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">https://plot.ly/products/dash/",</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">                 ),</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">             ],</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">          )</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">        ],</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">     ),</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   </samp><span aria-label="annotation3" class="SANS_NSAnnotations_Monospace_11">❸</span> <samp class="SANS_TheSansMonoCd_W5Regular_11">html.Div(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">        id="body",</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">        className="container scalable",</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">        children=[</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">           html.Div(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">              id="app-container",</samp></p>
<p class="Code"><span class="gray"><samp class="SANS_TheSansMonoCd_W5Regular_11">              # className="row",</samp></span></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">              children=[</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">                  html.Div(</samp></p>
<p class="Code"><span class="gray"><samp class="SANS_TheSansMonoCd_W5Regular_11">                    # className=</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">"three columns",</samp></span></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">                    id="left-column",</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">                    children=[</samp></p>
<p class="Code"><span class="gray"><samp class="SANS_TheSansMonoCd_W5Regular_11"># … See Dash Components</samp></span></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">                    ],</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">                  </samp><samp class="SANS_TheSansMonoCd_W5Regular_11">),</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">                  html.Div(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">                    id="div-graphs",</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">                    children=dcc.Graph(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">                      id="graph-sklearn-svm",</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">  </samp><samp class="SANS_TheSansMonoCd_W5Regular_11">                    figure=dict(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">                  </samp><samp class="SANS_TheSansMonoCd_W5Regular_11">       layout=dict(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">                            plot_bgcolor=</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">"#282b38",</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">                            paper_bgcolor="#282b38"</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">                      </samp><samp class="SANS_TheSansMonoCd_W5Regular_11">    )</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">                      ),</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">          </samp><samp class="SANS_TheSansMonoCd_W5Regular_11">          ),</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">                  ),</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">        </samp><samp class="SANS_TheSansMonoCd_W5Regular_11">      ],</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">            )</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">        ],</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">    ),</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">  ]</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp></p>
</div>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-4: Zooming multiple levels in the SVM app layout</samp></p>
<p class="TX"><span aria-label=" Page 134. " epub:type="pagebreak" id="pg_134" role="doc-pagebreak"></span>The code references stylesheets and Dash components that we’ll talk about in upcoming sections, so it may not be clear how this section works just yet. But it does show you what a nontrivial Dash app looks like: hierarchically nested HTML components using dash-html-components. In large apps you’ll use this structure to add more components as you modify the app’s look and feel.</p>
<p class="TX">As with the smaller apps we’ve seen in earlier chapters, the app consists of an outer <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp> <span aria-label="annotation1" class="SANS_NSAnnotations_Monospace_11">❶</span> that contains two inner <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp> elements at <span aria-label="annotation2" class="SANS_NSAnnotations_Monospace_11">❷</span> and <span aria-label="annotation3" class="SANS_NSAnnotations_Monospace_11">❸</span>. The first inner <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp> contains meta-information, such as the headline and logo. The second inner <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp> contains the body of the app.</p>
<p class="TX">In <span class="Xref">“Reusable Components” later in this chapter</span>, we’ll focus on the different Dash components to learn how they are working individually.</p>
<p class="TX">Next, we’ll look at the CSS stylesheets we used to style the SVM Explorer app.</p>
<p class="HeadB"><a id="h2-48"></a><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Styling</samp></p>
<p class="TNI">We know from <span class="Xref"><a href="chapter4.xhtml">Chapters 4</a> and <a href="chapter5.xhtml">5</a></span> that we can style our HTML elements using either a CSS stylesheet or dash-bootstrap-components. In this app we opt for the CSS stylesheet, since it allows us to create a more customized look and feel with margins, padding, colors, fonts, and borders. Note that the main styling is already built into the default Plotly Dash components, so using custom stylesheets is a relatively minor design decision by the creators of the SVM Explorer app.</p>
<p class="TX">We define the stylesheet in the <i>assets</i> subfolder, with a structure like this:</p>
<p class="_CodeSpaceAbove"><samp class="SANS_TheSansMonoCd_W5Regular_11">- app.py</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">- assets/</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   |--base-styles.css</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   |--custom-styles.css</samp></p>
<p class="_CodeSpaceBelow"><span class="gray"><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">--snip--</samp></span></p>
<p class="TX">We’ll use two stylesheets: the <i>base-styles.css</i> and <i>custom-styles.css</i> files that were added to the SVM Explorer app by the app creators. The <i>base-styles.css</i> stylesheet defines how basic HTML elements such as headings and paragraphs should be styled. The <i>custom-styles.css</i> stylesheet defines how Dash-specific elements such as named sliders, graph containers, and cards should be styled. Let’s quickly dip into <i>base-styles.css</i> to see how we can manipulate the default styling.</p>
<p class="TX">The <i>base-styles.css</i> stylesheet consists of the 13 sections shown in <a href="chapter7.xhtml#List7-5">Listing 7-5</a>, each defining how certain types of HTML elements look.</p>
<a id="List7-5"></a>
<p class="_CodeSpaceAbove"><span class="gray"><samp class="SANS_TheSansMonoCd_W5Regular_11">/* Table of contents</samp></span></p>
<p class="Code"><span class="gray"><samp class="SANS_TheSansMonoCd_W5Regular_11">—————————————————————————</samp></span></p>
<p class="Code"><span class="gray"><samp class="SANS_TheSansMonoCd_W5Regular_11">- Grid</samp></span></p>
<p class="Code"><span class="gray"><samp class="SANS_TheSansMonoCd_W5Regular_11">- Base Styles</samp></span></p>
<p class="Code"><span class="gray"><samp class="SANS_TheSansMonoCd_W5Regular_11">- Typography</samp></span></p>
<p class="Code"><span class="gray"><samp class="SANS_TheSansMonoCd_W5Regular_11">- Links</samp></span></p>
<p class="Code"><span class="gray"><samp class="SANS_TheSansMonoCd_W5Regular_11">- Buttons</samp></span></p>
<p class="Code"><span class="gray"><samp class="SANS_TheSansMonoCd_W5Regular_11">- Forms</samp></span></p>
<p class="Code"><span class="gray"><span aria-label=" Page 135. " epub:type="pagebreak" id="pg_135" role="doc-pagebreak"></span><samp class="SANS_TheSansMonoCd_W5Regular_11">- Lists</samp></span></p>
<p class="Code"><span class="gray"><samp class="SANS_TheSansMonoCd_W5Regular_11">- Code</samp></span></p>
<p class="Code"><span class="gray"><samp class="SANS_TheSansMonoCd_W5Regular_11">- Tables</samp></span></p>
<p class="Code"><span class="gray"><samp class="SANS_TheSansMonoCd_W5Regular_11">- Spacing</samp></span></p>
<p class="Code"><span class="gray"><samp class="SANS_TheSansMonoCd_W5Regular_11">- Utilities</samp></span></p>
<p class="Code"><span class="gray"><samp class="SANS_TheSansMonoCd_W5Regular_11">- Clearing</samp></span></p>
<p class="Code"><span class="gray"><samp class="SANS_TheSansMonoCd_W5Regular_11">- Media Queries</samp></span></p>
<p class="_CodeSpaceBelow"><span class="gray"><samp class="SANS_TheSansMonoCd_W5Regular_11">*/</samp></span></p>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-5: Overview of</samp> <samp class="SANS_Futura_Std_Book_11">base-styles.css</samp></p>
<p class="TX">This stylesheet allows you to define things like the fonts, background colors, margins, and padding for these basic elements. For example, in the typography section, shown in <a href="chapter7.xhtml#List7-6">Listing 7-6</a>, we define the font size, weight, and spacing for the different headings.</p>
<a id="List7-6"></a>
<p class="_CodeWideSpaceAbove"><span class="gray"><samp class="SANS_TheSansMonoCd_W5Regular_11">/* Typography</samp></span></p>
<p class="CodeWide"><samp class="SANS_TheSansMonoCd_W5Regular_11">—————————————————————————*/</samp></p>
<p class="CodeWide"><samp class="SANS_TheSansMonoCd_W5Regular_11">h1, h2, h3, h4, h5, h6 {</samp></p>
<p class="CodeWide"><samp class="SANS_TheSansMonoCd_W5Regular_11">   margin-top: 0;</samp></p>
<p class="CodeWide"><samp class="SANS_TheSansMonoCd_W5Regular_11">   margin-bottom: 0;</samp></p>
<p class="CodeWide"><samp class="SANS_TheSansMonoCd_W5Regular_11">   font-weight: 300;}</samp></p>
<p class="CodeWide"><samp class="SANS_TheSansMonoCd_W5Regular_11">h1 {font-size: 4.5rem; line-height: 1.2; letter-spacing: -.1rem; margin-bottom: 2rem;}</samp></p>
<p class="CodeWide"><samp class="SANS_TheSansMonoCd_W5Regular_11">h2 {font-size: 3.6rem; line-height: 1.25; letter-spacing: -.1rem; margin-bottom: 1.8rem; margin-top: 1.8rem;}</samp></p>
<p class="CodeWide"><samp class="SANS_TheSansMonoCd_W5Regular_11">h3 {font-size: 3.0rem; line-height: 1.3; letter-spacing: -.1rem; margin-bottom: 1.5rem; margin-top: 1.5rem;}</samp></p>
<p class="CodeWide"><samp class="SANS_TheSansMonoCd_W5Regular_11">h4 {font-size: 2.6rem; line-height: 1.35; letter-spacing: -.08rem; margin-bottom: 1.2rem; margin-top: 1.2rem;}</samp></p>
<p class="CodeWide"><samp class="SANS_TheSansMonoCd_W5Regular_11">h5 {font-size: 2.2rem; line-height: 1.5; letter-spacing: -.05rem; margin-bottom: 0.6rem; margin-top: 0.6rem;}</samp></p>
<p class="CodeWide"><samp class="SANS_TheSansMonoCd_W5Regular_11">h6 {font-size: 2.0rem; line-height: 1.6; letter-spacing: 0; margin-bottom: 0.75rem; margin-top: 0.75rem;}</samp></p>
<p class="_CodeWideSpace"><samp class="SANS_TheSansMonoCd_W5Regular_11">p {</samp></p>
<p class="_CodeWideSpacebelow"><samp class="SANS_TheSansMonoCd_W5Regular_11">   margin-top: 0;}</samp></p>
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-6: Zooming into the typography section of</samp> <samp class="SANS_Futura_Std_Book_11">base-styles.css</samp></p>
<p class="TX">You can see that we set the font size for the top-level heading <samp class="SANS_TheSansMonoCd_W5Regular_11">h1</samp> at <samp class="SANS_TheSansMonoCd_W5Regular_11">4.5rem</samp> so that it’s the largest.</p>
<p class="TX">We won’t go into the specifics of each element in this chapter, though we do recommend that you take a quick look at the code to see how we apply custom styles to various elements.</p>
<p class="TX">Instead of losing ourselves in minor CSS details (which you could decide to ignore in your own dashboard app and default to the Dash standard styling), let’s have a look at the heart of the SVM app: the Dash components.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h3 class="H1" id="sec4"><a id="h1-49"></a><samp class="SANS_Futura_Std_Bold_B_11">Reusable Components</samp></h3>
<p class="TNI">Here we’ll look at a new Dash concept in the form of <i>reusable components</i>, which allow you to add your own style and functionality to existing <span aria-label=" Page 136. " epub:type="pagebreak" id="pg_136" role="doc-pagebreak"></span>components. We use several components in our SVM Explorer app that are similar in pattern to the built-in components but with slight differences, such as dropdown menus with different labels and value ranges. We define the components in the <i>dash_reusable_components.py</i> file and instantiate the components with their custom features in <i>app.py</i>. First we’ll add the <i>dash_reusable_components.py</i> module to the <i>utils</i> folder:</p>
<p class="_CodeSpaceAbove"><samp class="SANS_TheSansMonoCd_W5Regular_11">- app.py</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">- assets/</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">- utils/</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   |--dash_reusable_components.py</samp></p>
<p class="_CodeSpaceBelow"><span class="gray"><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">--snip--</samp></span></p>
<p class="TX">Say our goal is to create a custom button we’ll use several times throughout the code. The custom button component could be arbitrarily complex; it might just contain a button label or it might have something more complex, like a chart showing how often the button was clicked over time (yes, Dash can do that!). We want to avoid creating the customized button repeatedly in our <i>app.py</i> file for clarity and conciseness. To accomplish this, we create this customized button as an instance of the custom class <samp class="SANS_TheSansMonoCd_W5Regular_11">CustomButton</samp>. We define the class in the <i>dash_reusable_components.py</i> module once and then can instantiate the customized button component as many times as we like in the main <i>app.py</i> file, each potentially with its own individual features, such as different background colors or text.</p>
<p class="HeadB"><a id="h2-49"></a><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Defining a Card</samp></p>
<p class="TNI">In <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span> we used a Bootstrap <samp class="SANS_TheSansMonoCd_W5Regular_11">Card</samp> to create a small contained area for content. Here we’ll create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Card</samp> with multiple components: a label, a slider, and a button. You can think of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Card</samp> as a meta component consisting of multiple child components, using a specific (relative) width and padding and adding a solid gray border at the bottom to group the components visually. A <samp class="SANS_TheSansMonoCd_W5Regular_11">Card</samp> is actually a wrapper around the HTML component <samp class="SANS_TheSansMonoCd_W5Regular_11">html.Section</samp>, a container that groups different HTML elements or text inside a (possibly) styled area. All content in a <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> belongs together semantically or thematically. <a href="chapter7.xhtml#fig7-4">Figure 7-4</a> gives an example of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Card</samp> in our SVM Explorer app that uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">html.Section</samp> element to group three components: a label, a slider, and a button.</p>
<a id="fig7-4"></a>
<figure class="IMG"><img alt="" class="img30" height="155" src="../images/Figure7-4.png" width="209"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-4: Example of a custom Card</samp></p></figcaption>
</figure>
<div class="gbox">
<p class="BH"><span aria-label=" Page 137. " epub:type="pagebreak" id="pg_137" role="doc-pagebreak"></span><samp class="SANS_Dogma_OT_Bold_B_11">WHAT IS A WRAPPER?</samp></p>
<p class="BoxBodyCustom1"><samp class="SANS_Futura_Std_Book_11">A</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">wrapper</samp> <samp class="SANS_Futura_Std_Book_11">is a function whose only purpose is to call another function. By doing so, the wrapper shields the caller from unnecessary complexity or redundancy. For example, the inner function call may be complicated, with many specific arguments the caller doesn’t know about. The wrapper function call simplifies access to the inner function by requiring fewer arguments and hardcoding the remaining arguments. This improves readability, reduces complexity, and improves maintainability of the code.</samp></p>
</div>
<p class="TX"><a href="chapter7.xhtml#List7-7">Listing 7-7</a> shows the actual definition of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Card</samp> wrapper function from <i>dash_reusable_components.py</i>.</p>
<a id="List7-7"></a>
<p class="_CodeWideSpaceAbove"><samp class="SANS_TheSansMonoCd_W5Regular_11">def Card(children, **kwargs):</samp></p>
<p class="_CodeWideSpacebelow"><samp class="SANS_TheSansMonoCd_W5Regular_11">   return html.Section(className=</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">"card", children=children, **_omit(["style"], kwargs))</samp></p>
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-7: Defining the Card component</samp></p>
<p class="TX">To see how the <samp class="SANS_TheSansMonoCd_W5Regular_11">Card</samp> component works in full, let’s dive deeper into these arguments:</p>
<div class="spc">
<p class="RunInPara"><span class="Bold"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">children   </samp><span class="R">A list of other Dash elements that are included in the</span></span><span class="Bold"> <samp class="SANS_TheSansMonoCd_W5Regular_11">Card</samp><b>,</b> <span class="R">and so are displayed grouped together in the dashboard app. You can create all kinds of nested and hierarchical HTML trees and pass any iterable of HTML elements into the</span> </span><span class="Bold"><samp class="SANS_TheSansMonoCd_W5Regular_11">Card</samp><b>.</b> <span class="R">The</span> </span><span class="Bold"><samp class="SANS_TheSansMonoCd_W5Regular_11">Card</samp> <span class="R">will then wrap these elements into one common element that resembles a physical card: a 2D box with consistent styling that encloses some other design elements.</span></span></p>
<p class="RunInPara"><span class="Bold"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">**kwargs   </samp><span class="R">Stands for</span></span><span class="Bold"> <i>arbitrary keyword arguments</i><span class="R">. The</span> </span><span class="Bold"><samp class="SANS_TheSansMonoCd_W5Regular_11">**kwargs</samp> <span class="R">argument packs all keyword arguments passed into the function call into a single</span> </span><span class="Bold"><samp class="SANS_TheSansMonoCd_W5Regular_11">kwargs</samp> <span class="R">dictionary. The keyword argument names are the dictionary keys, and the keyword arguments’ values are the dictionary values. For example, if somebody called the function</span> </span><span class="Bold"><samp class="SANS_TheSansMonoCd_W5Regular_11">Card(children, example</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">"123")</samp><span class="R">, we could use</span> </span><span class="Bold"><samp class="SANS_TheSansMonoCd_W5Regular_11">kwargs['example']</samp> <span class="R">within the function to obtain the value</span> </span><span class="Bold"><samp class="SANS_TheSansMonoCd_W5Regular_11">"123"</samp><span class="R">. We could use this dictionary later to unpack a potentially large number of arguments into the</span> </span><span class="Bold"><samp class="SANS_TheSansMonoCd_W5Regular_11">html.Section()</samp> <span class="R">constructor, including metadata such as the language of the section or the number of times this component has been clicked by the user. We don’t really use the opportunity to pass arbitrary keyword arguments in our SVM Explorer app, but this is an interesting aspect of the</span> </span><span class="Bold"><samp class="SANS_TheSansMonoCd_W5Regular_11">Card</samp> <span class="R">component. You can find a detailed tutorial on the double-asterisk operator at</span> </span><a href="https://blog.finxter.com/python-double-asterisk"><span class="Bold"><i>https://blog.finxter.com/python-double-asterisk</i></span></a>.</p>
</div>
<p class="TX"><span aria-label=" Page 138. " epub:type="pagebreak" id="pg_138" role="doc-pagebreak"></span>The other argument is actually a function. Let’s have a closer look at it:</p>
<div class="spc">
<p class="RunInPara"><span class="Bold"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">_omit</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">   </samp><span class="R">Allows us to exclude certain elements if they’re not needed. We might, for example, remove the</span></span><span class="Bold"> <samp class="SANS_TheSansMonoCd_W5Regular_11">"style"</samp> <span class="R">key from the dictionary because it is not needed in the</span> </span><span class="Bold"><samp class="SANS_TheSansMonoCd_W5Regular_11">html.Section()</samp> <span class="R">constructor, since we already defined the style using the CSS stylesheet. The</span> </span><span class="Bold"><samp class="SANS_TheSansMonoCd_W5Regular_11">_omit()</samp> function <span class="R">takes two arguments: a list of strings in the variable</span> </span><span class="Bold"><samp class="SANS_TheSansMonoCd_W5Regular_11">omitted _keys</samp> <span class="R">and a dictionary</span> </span><span class="Bold"><samp class="SANS_TheSansMonoCd_W5Regular_11">d</samp><span class="R">. The function returns a new dictionary that consists of the elements in the original dictionary</span> </span><span class="Bold"><samp class="SANS_TheSansMonoCd_W5Regular_11">d</samp> <span class="R">with all keys in</span> </span><span class="Bold"><samp class="SANS_TheSansMonoCd_W5Regular_11">omitted_keys</samp> <span class="R">and their associated values filtered out. Here is how the authors of the SVM Explorer app concisely accomplished this:</span></span></p>
</div>
<p class="_CodeSpaceAbove"><samp class="SANS_TheSansMonoCd_W5Regular_11">def _omit(omitted_keys, d):</samp></p>
<p class="_CodeSpaceBelow"><samp class="SANS_TheSansMonoCd_W5Regular_11"> return {k: v for k, v in d.items() if k not in omitted_keys}</samp></p>
<p class="TX">In the SVM Explorer app, you call <samp class="SANS_TheSansMonoCd_W5Regular_11">**_omit(["style"], kwargs)</samp> to pass the keyword arguments dictionary <samp class="SANS_TheSansMonoCd_W5Regular_11">kwargs</samp> from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Card()</samp> call after removing the key <samp class="SANS_TheSansMonoCd_W5Regular_11">"style"</samp> using the <samp class="SANS_TheSansMonoCd_W5Regular_11">_omit()</samp> function. The double-asterisk prefix unpacks all those values from the dictionary into the argument list of the <samp class="SANS_TheSansMonoCd_W5Regular_11">html.Section()</samp> constructor.</p>
<p class="TX">In <i>app.py</i>, we can now use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Card</samp> reusable component to create a card containing a named slider and a button, as shown in <a href="chapter7.xhtml#List7-8">Listing 7-8</a>.</p>
<a id="List7-8"></a>
<p class="_CodeSpaceAbove"><samp class="SANS_TheSansMonoCd_W5Regular_11">.drc.Card(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   id="button-card",</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   children=[</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      drc.NamedSlider(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">         name="Threshold",</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">         id="slider-threshold",</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">         min=0,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">         max=</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">1,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">         value=0.5,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">         step=0.01,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      ),</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      html.Button(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">         "Reset Threshold",</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">         id="button-zero-threshold",</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      ),</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   ],</samp></p>
<p class="_CodeSpaceBelow"><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp></p>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-8: Combining the named slider and button components within the Card definition</samp></p>
<p class="TX">Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">drc.NamedSlider</samp> is a reusable component itself, so we wrap a reusable component <samp class="SANS_TheSansMonoCd_W5Regular_11">drc.Card</samp> around another reusable component hierarchically.</p>
<p class="TX"><a href="chapter7.xhtml#fig7-4">Figure 7-4</a> shows how the <samp class="SANS_TheSansMonoCd_W5Regular_11">drc.Card</samp> looks in the SVM Explorer app. The named slider consists of two components: an HTML component to display the text <samp class="SANS_TheSansMonoCd_W5Regular_11">"Threshold"</samp> and a Dash <samp class="SANS_TheSansMonoCd_W5Regular_11">Slider</samp> component to set the float value between 0 and 1.</p>
<p class="TX"><span aria-label=" Page 139. " epub:type="pagebreak" id="pg_139" role="doc-pagebreak"></span>The threshold is later used as an input value for our SVM model as a means to control the bias of the classification model toward one class or the other. While this is a specific parameter in a specific classification model, you can use this exact strategy to display the performance impact of various model parameters in machine learning. Exploring the impact of a critical parameter becomes as simple as using a slider on your smartphone! Won’t this make a lasting impression when you present your next machine learning model to the public?</p>
<p class="TX">Now you know how to create reusable components using a wrapper function around another component. Don’t worry if you didn’t get all the details; we only want you to grasp the big picture: how to create reusable components by means of wrapper functions. Let’s dive into the next custom-defined component used in our app: the formatted slider.</p>
<p class="HeadB"><a id="h2-50"></a><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Defining a Formatted Slider</samp></p>
<p class="TNI">The formatted slider is another custom wrapper that consists of an HTML <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp> element and a <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Slider</samp>, a Dash Core component introduced in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>. A formatted slider is a <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Slider</samp> component with some predefined formatting applied, usually pertaining to padding. For simpler usage, we’d instead use simple CSS to associate formatting with a slider component, but the authors of this app probably considered adding some more advanced components or functionality later, so they made this a reusable component that is easily extendable.</p>
<p class="TX"><a href="chapter7.xhtml#List7-9">Listing 7-9</a> shows the code of the wrapper function we place in <i>dash_reusable_components.py</i>.</p>
<a id="List7-9"></a>
<p class="_CodeSpaceAbove"><samp class="SANS_TheSansMonoCd_W5Regular_11">def FormattedSlider(**kwargs):</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   return html.Div(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      style=kwargs.get("style", {}),</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      children=</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Slider(**_omit(["style"], kwargs))</samp></p>
<p class="_CodeSpaceBelow"><samp class="SANS_TheSansMonoCd_W5Regular_11">   )</samp></p>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-9: Defining the FormattedSlider component</samp></p>
<p class="TX">In <i>app.py</i> we create a particular instance of a formatted slider, presented in <a href="chapter7.xhtml#fig7-5">Figure 7-5</a>, with this slider creation code snippet:</p>
<p class="_CodeSpaceAbove"><samp class="SANS_TheSansMonoCd_W5Regular_11">drc.FormattedSlider(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   id="slider-svm-parameter-C-coef",</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   min=1,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   max=9,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   value=1,</samp></p>
<p class="_CodeSpaceBelow"><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp></p>
<p class="TX">This creates a formatted slider with a minimum value of 1, a maximum value of 9, and a slider granularity of 1 between two consecutive values. We pass four keyword arguments into the <samp class="SANS_TheSansMonoCd_W5Regular_11">FormattedSlider()</samp> function, which are then packed into the <samp class="SANS_TheSansMonoCd_W5Regular_11">kwargs</samp> dictionary. There’s no <samp class="SANS_TheSansMonoCd_W5Regular_11">style</samp> key in the <span aria-label=" Page 140. " epub:type="pagebreak" id="pg_140" role="doc-pagebreak"></span>dictionary, so the <samp class="SANS_TheSansMonoCd_W5Regular_11">kwargs.get("style", {})</samp> call from <a href="chapter7.xhtml#List7-9">Listing 7-9</a> returns the empty dictionary. In this case, the default styling from Dash is used. We pass the remaining key-value pairs in the dictionary as keyword arguments into the <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Slider()</samp> creation routine. These arguments build a new slider with the specified range; note that Dash automatically adds the labels 1, 3, 5, 7, and 9 as values of the specific formatted slider shown in the SVM Explorer app (see <a href="chapter7.xhtml#fig7-5">Figure 7-5</a>). If you try out the slider yourself, you’ll realize that the slider granularity is 1 even though the marks show only every other value. Of course, you can customize the marks if needed by adding another <samp class="SANS_TheSansMonoCd_W5Regular_11">marks</samp> argument that maps slider values to text labels in a dictionary.</p>
<a id="fig7-5"></a>
<figure class="IMG"><img alt="" class="img50" height="108" src="../images/Figure7-5.png" width="313"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-5: Example of a formatted slider</samp></p></figcaption>
</figure>
<p class="HeadB"><a id="h2-51"></a><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Defining a Named Slider</samp></p>
<p class="TNI">The named slider is another wrapper around the <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Slider</samp> component that adds a custom heading. <a href="chapter7.xhtml#fig7-6">Figure 7-6</a> shows a slider in our SVM Explorer app that we named Degree.</p>
<a id="fig7-6"></a>
<figure class="IMG"><img alt="" class="img50" height="128" src="../images/Figure7-6.png" width="313"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-6: Example of a named slider</samp></p></figcaption>
</figure>
<p class="TX">The code that defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">NamedSlider</samp> in <i>dash_reusable_components.py</i> is shown in <a href="chapter7.xhtml#List7-10">Listing 7-10</a>.</p>
<a id="List7-10"></a>
<p class="_CodeSpaceAbove"><samp class="SANS_TheSansMonoCd_W5Regular_11">def NamedSlider(name, **kwargs):</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   return html.Div(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      style={"padding": "20px 10px 25px 4px"},</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      children=[</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">        html.P(f"{name}:"),</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">        html.Div(style={"margin-left": "6px"},</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">          children=</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Slider(**kwargs)),</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">    ],</samp></p>
<p class="_CodeSpaceBelow"><samp class="SANS_TheSansMonoCd_W5Regular_11">   )</samp></p>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-10: Defining the NamedSlider component</samp></p>
<p class="TX">We create an HTML <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp> container that contains two elements: an HTML paragraph element that adds the label to the named slider using <span aria-label=" Page 141. " epub:type="pagebreak" id="pg_141" role="doc-pagebreak"></span><samp class="SANS_TheSansMonoCd_W5Regular_11">html.P()</samp> and another <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp> that contains a regular Dash <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Slider()</samp> element. Here we hardcode some style elements by setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">padding</samp> attribute of the style dictionary of the outer <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp>. This is a great example of why we might choose to remove the <samp class="SANS_TheSansMonoCd_W5Regular_11">style</samp> key from the dictionary using <samp class="SANS_TheSansMonoCd_W5Regular_11">_omit()</samp>, as discussed earlier; if we wanted to change the style, we’d use this specific style parameter of Dash’s HTML components. In our case, the custom styling extends the box width around the named slider component. If we were to change this in <i>dash_reusable_components.py</i>, every instance we create in <i>app.py</i> would change to match!</p>
<p class="TX">We use the formatting string <samp class="SANS_TheSansMonoCd_W5Regular_11">f"{name}:"</samp> to access the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> argument of the <samp class="SANS_TheSansMonoCd_W5Regular_11">NamedSlider()</samp> call from <i>app.py</i> and put it into the string that will serve as the label for our slider. This is what allows us to give each slider its own label.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">"margin-left"</samp> attribute of the inner <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp> shifts the whole slider slightly to the right to give the appearance of an indentation of the slider component.</p>
<p class="NTX-H"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>
<p class="NTX"><i>The custom function names in</i> <span class="Roman">dash_reusable_components.py</span> <i>start with a capitalized letter by convention because Dash components are capitalized too. This way, calling a reusable component feels similar to calling a predefined Dash component.</i></p>
<p class="TX"><a href="chapter7.xhtml#List7-11">Listing 7-11</a> shows the code in <i>app.py</i> that instantiates the named slider in <a href="chapter7.xhtml#fig7-6">Figure 7-6</a>.</p>
<a id="List7-11"></a>
<p class="_CodeSpaceAbove"><samp class="SANS_TheSansMonoCd_W5Regular_11">drc.NamedSlider(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   name="Degree",</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   id="slider-svm-parameter-degree",</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   min=2,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   max=10,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   value=3,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   step=1,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   marks={</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      str(i): str(i) for i in range(2, 11, 2)</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   },</samp></p>
<p class="_CodeSpaceBelow"><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp></p>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-11: Instantiating the NamedSlider component</samp></p>
<p class="TX">The slider has a minimum value of 2 and a maximum value of 10. We also set the marks of the slider to the integers 2, 4, 6, 8, and 10, created by the generator expression <samp class="SANS_TheSansMonoCd_W5Regular_11">str(i) for i in range(2, 11, 2)</samp>.</p>
<p class="HeadB"><a id="h2-52"></a><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Defining a Named Dropdown</samp></p>
<p class="TNI">As with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Slider</samp>, we’ll build on <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Dropdown()</samp> to create a named dropdown that includes a label. The process here is similar to creating a named slider, so we’ll go over it very briefly to show it to you in different contexts. <a href="chapter7.xhtml#List7-12">Listing 7-12</a> shows the definition that goes in <i>dash_reusable_components.py</i>.</p>
<a id="List7-12"></a>
<p class="_CodeSpaceAbove"><span aria-label=" Page 142. " epub:type="pagebreak" id="pg_142" role="doc-pagebreak"></span><samp class="SANS_TheSansMonoCd_W5Regular_11">def NamedDropdown(name, **kwargs):</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   return html.Div(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      style={"margin": "10px 0px"},</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      children=[</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">        html.P(children=f"{name}:", style={"margin-left": "3px"}),</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">        dcc.Dropdown(**kwargs),</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      ],</samp></p>
<p class="_CodeSpaceBelow"><samp class="SANS_TheSansMonoCd_W5Regular_11">   )</samp></p>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-12: Defining the NamedDropdown component</samp></p>
<p class="TX">We pass through the list of keyword arguments using the double-asterisk operator to both catch all keyword arguments in the <samp class="SANS_TheSansMonoCd_W5Regular_11">kwargs</samp> dictionary and unpack all those keyword arguments into the <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Dropdown()</samp> creation routine. The function argument <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> that is passed in when creating the <samp class="SANS_TheSansMonoCd_W5Regular_11">NamedDropdown</samp> instance serves as the text label in the HTML paragraph element.</p>
<p class="TX">The resultant <samp class="SANS_TheSansMonoCd_W5Regular_11">NamedDropdown</samp> reusable component will look something like <a href="chapter7.xhtml#fig7-7">Figure 7-7</a>.</p>
<a id="fig7-7"></a>
<figure class="IMG"><img alt="" class="img50" height="118" src="../images/Figure7-7.png" width="313"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-7: Example of a named dropdown</samp></p></figcaption>
</figure>
<p class="TX">In <a href="chapter7.xhtml#List7-13">Listing 7-13</a> we create this component in <i>app.py</i>.</p>
<a id="List7-13"></a>
<p class="_CodeSpaceAbove"><samp class="SANS_TheSansMonoCd_W5Regular_11">drc.NamedDropdown(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   name="Select Dataset",</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   id="dropdown-select-dataset",</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   options=[</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      {"label": "Moons", "value": "moons"},</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      {</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">        "label": "Linearly Separable",</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">        "value": "linear",</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      },</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      {</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">        "label": "Circles",</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">        "value": "circles",</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      },</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   ],</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   clearable=False,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   searchable=False,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   value="moons",</samp></p>
<p class="_CodeSpaceBelow"><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp></p>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-13: Instantiating the NamedDropdown</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">component</samp></p>
<p class="TX"><span aria-label=" Page 143. " epub:type="pagebreak" id="pg_143" role="doc-pagebreak"></span>We call the newly created <samp class="SANS_TheSansMonoCd_W5Regular_11">drc.NamedDropdown()</samp> function with the name we want to give the named dropdown component. The remaining keyword arguments <samp class="SANS_TheSansMonoCd_W5Regular_11">id</samp> (identifier of the HTML element), <samp class="SANS_TheSansMonoCd_W5Regular_11">options</samp> (labels and values of the dropdown), <samp class="SANS_TheSansMonoCd_W5Regular_11">clearable</samp> (a Boolean either allowing or disallowing users to clear the current selected entry by clicking a small icon), <samp class="SANS_TheSansMonoCd_W5Regular_11">searchable</samp> (a Boolean either allowing or disallowing users to search the dropdown for a specific value), and <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp> (a default dropdown value) are packed into the <samp class="SANS_TheSansMonoCd_W5Regular_11">kwargs</samp> dictionary and handed downstream to the <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Dropdown()</samp> creation routine.</p>
<p class="TX">This instantiation will create the named dropdown in <a href="chapter7.xhtml#fig7-8">Figure 7-8</a>, with the default dataset set to “Moons” and both <samp class="SANS_TheSansMonoCd_W5Regular_11">searchable</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">clearable</samp> disabled.</p>
<a id="fig7-8"></a>
<figure class="IMG"><img alt="" class="img50" height="339" src="../images/Figure7-8.png" width="417"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-8: Named dropdown clicked state</samp></p></figcaption>
</figure>
<p class="TX">Using reusable components is an extremely efficient way to scale your application and create whole new libraries for global use. Just define your own <i>dash_reusable_components.py</i> file and use the wrapper functions around existing Dash and HTML components in your main program file. Reusable components give you easy ways to customize the look and feel of your app and make your code easier to understand, more concise, and easier to maintain, even if your app requires thousands of lines of code!</p>
<p class="TX">Next, we’ll dive into some new Dash components in the SVM Explorer app that haven’t been covered yet.</p>
<p class="HeadB"><a id="h2-53"></a><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Using a Dash Graph</samp></p>
<p class="TNI">The core component of the whole SVM Explorer app is, of course, the graph that visualizes the learning and classification performance on the chosen training data. <a href="chapter7.xhtml#fig7-9">Figure 7-9</a> shows the final graph.</p>
<span aria-label=" Page 144. " epub:type="pagebreak" id="pg_144" role="doc-pagebreak"></span><a id="fig7-9"></a>
<figure class="IMG"><img alt="" class="img70" height="315" src="../images/Figure7-9.png" width="521"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-9: Example Dash graph</samp></p></figcaption>
</figure>
<p class="TX">First we train the model using the input parameters from the different controls in the dashboard. Then we test the accuracy of the model for the test dataset. The dots visualize the training data. The triangles visualize the test data. Red data points belong to one class and blue to another; we’ll call them class X and class Y, respectively. For each piece of training data, we already know whether it is X or Y; that is, whether it falls on one side of the decision boundary or the other. The model then estimates which class each piece of test data belongs to, based on the learned decision boundary from the training data.</p>
<p class="TX">The following function call accomplishes this powerful visualization (line 434 in the <i>app.py</i> sample project):</p>
<p class="CodeCustom1"><samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Graph(id="graph-sklearn-svm", figure=prediction_figure)</samp></p>
<p class="TX">We create a <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Graph</samp> component with the <samp class="SANS_TheSansMonoCd_W5Regular_11">id "graph-sklearn-svm"</samp>. As a <samp class="SANS_TheSansMonoCd_W5Regular_11">figure</samp> argument, we pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">prediction_figure</samp> variable, which we defined in lines 410 through 421 in <i>app.py</i> (see <a href="chapter7.xhtml#List7-14">Listing 7-14</a>).</p>
<a id="List7-14"></a>
<p class="_CodeSpaceAbove"><samp class="SANS_TheSansMonoCd_W5Regular_11">prediction_figure = figs.serve_prediction_plot(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   model=clf,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   X_train=X_train,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   X_test=X_test,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   y_train=y_train,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   y_test=y_test,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   Z=Z,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   xx=xx,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   yy=yy,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   mesh_step=</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">h,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   threshold=threshold,</samp></p>
<p class="_CodeSpaceBelow"><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp></p>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-14: Defining the graph’s attributes</samp></p>
<p class="TX"><span aria-label=" Page 145. " epub:type="pagebreak" id="pg_145" role="doc-pagebreak"></span>We won’t go into a lot of technical detail here, but notice that the function call uses four primary datasets: <samp class="SANS_TheSansMonoCd_W5Regular_11">X_train</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y_train</samp>, as well as <samp class="SANS_TheSansMonoCd_W5Regular_11">X_test</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y_test</samp>. Like in all supervised learning, we train the model using a training dataset consisting of a collection of <i>(X, y)</i> tuples for input data <i>X</i> and output data <i>y</i> to obtain the mapping <i>X</i> <span class="symbol">→</span> <i>y</i>. We pass all these bits of information into the following function:</p>
<p class="CodeCustom1"><samp class="SANS_TheSansMonoCd_W5Regular_11">figs.serve_prediction_plot()</samp></p>
<p class="TX">This function plots the prediction contour of the SVM, the threshold line, and the test and training scatter data. Then it returns the resultant figure as an object that can be passed in the <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Graph</samp> component, as shown before. We’ll break it down and discuss its composite parts. First, the <samp class="SANS_TheSansMonoCd_W5Regular_11">figs</samp> section refers to this import statement in the header of <i>app.py</i>:</p>
<p class="CodeCustom1"><samp class="SANS_TheSansMonoCd_W5Regular_11">import utils.figures as figs</samp></p>
<p class="TX">We import the <samp class="SANS_TheSansMonoCd_W5Regular_11">figures</samp> module from the <i>utils</i> folder and name it <samp class="SANS_TheSansMonoCd_W5Regular_11">figs</samp>. The module contains utility functions to create the various plots shown in the dashboard, including the <samp class="SANS_TheSansMonoCd_W5Regular_11">serve_prediction_plot()</samp> function for the SVM model’s training and testing data visualization.</p>
<p class="TX">The function <samp class="SANS_TheSansMonoCd_W5Regular_11">serve_prediction_plot()</samp> creates the Plotly graph object used to visualize the training and testing data and the contour plot (see <a href="chapter7.xhtml#fig7-10">Figure 7-10</a>). We define it in lines 7 through 96 in the <i>figures.py</i> module, shown in <a href="chapter7.xhtml#List7-15">Listing 7-15</a>.</p>
<a id="List7-15"></a>
<p class="_CodeSpaceAbove"><samp class="SANS_TheSansMonoCd_W5Regular_11">import plotly.graph_objs as go</samp></p>
<p class="_CodeSpace"><samp class="SANS_TheSansMonoCd_W5Regular_11">def serve_prediction_plot(...):</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">...</samp></p>
<p class="_CodeSpace"><span class="gray"><samp class="SANS_TheSansMonoCd_W5Regular_11">   # Create the plot</samp></span></p>
<p class="Code"><span class="gray"><samp class="SANS_TheSansMonoCd_W5Regular_11">   # Plot the prediction contour of the SVM</samp></span></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   trace0 = go.Contour(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">...</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   )</samp></p>
<p class="_CodeSpace"><span class="gray"><samp class="SANS_TheSansMonoCd_W5Regular_11">   # Plot the threshold</samp></span></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   trace1 = go.Contour(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">...</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   )</samp></p>
<p class="_CodeSpace"><span class="gray"><samp class="SANS_TheSansMonoCd_W5Regular_11">   # Plot Training Data</samp></span></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   trace2 = go.Scatter(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">...</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   )</samp></p>
<p class="_CodeSpace"><samp class="SANS_TheSansMonoCd_W5Regular_11">   trace3 = go.Scatter(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">...</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   )</samp></p>
<p class="Code"><span aria-label=" Page 146. " epub:type="pagebreak" id="pg_146" role="doc-pagebreak"></span><samp class="SANS_TheSansMonoCd_W5Regular_11">   layout = go.Layout(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">...</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   )</samp></p>
<p class="_CodeSpace"><samp class="SANS_TheSansMonoCd_W5Regular_11">   data = [trace0, trace1, trace2, trace3]</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   figure = go.Figure(data=</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">data, layout=layout)</samp></p>
<p class="_CodeSpaceBelowCustom"><samp class="SANS_TheSansMonoCd_W5Regular_11">   return figure</samp></p>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-15: Creating a graph object and filling it with data</samp></p>
<p class="TX">This code skeleton shows how we create the contour plots shown in <a href="chapter7.xhtml#fig7-10">Figure 7-10</a> that visualize the SVM confidence levels, as well as the two scatter plots for the training and test data. We store these plots in four variables: <samp class="SANS_TheSansMonoCd_W5Regular_11">trace0</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">trace1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">trace2</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">trace3</samp>. We then use these variables as the data input argument of the <samp class="SANS_TheSansMonoCd_W5Regular_11">go.Figure()</samp> constructor that creates a Plotly figure object containing the four datasets.</p>
<p class="TX">We’ll take a look at the <samp class="SANS_TheSansMonoCd_W5Regular_11">go.Contour</samp> component next.</p>
<p class="HeadB"><a id="h2-54"></a><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Creating a Plotly Contour Plot</samp></p>
<p class="TNI">A <i>contour line</i> is a great way to visualize three-dimensional data in a two-dimensional plot. Each point <i>(x,y)</i> in 2D space has an associated <i>z</i> value, which you can think of as the “height” of the point (for example, an altitude value for a 2D map). All points on a contour line have the same <i>z</i> values. <a href="chapter7.xhtml#fig7-10">Figure 7-10</a> shows an example of contour lines.</p>
<a id="fig7-10"></a>
<figure class="IMG"><img alt="" class="img90" height="248" src="../images/Figure7-10.png" width="695"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-10: Example contour plot</samp></p></figcaption>
</figure>
<p class="TX">To define these contour lines, we define the <i>z</i> values in a 2D array where cell <i>(x,y)</i> defines the <i>z</i> value for the respective <i>x</i> and <i>y</i> points in space. Python will then automatically “connect” these points in contour lines. The code snippet in <a href="chapter7.xhtml#List7-16">Listing 7-16</a> produces this plot.</p>
<a id="List7-16"></a>
<p class="_CodeSpaceAbove"><samp class="SANS_TheSansMonoCd_W5Regular_11">import plotly.graph_objects as go</samp></p>
<p class="_CodeSpaceCustom"><samp class="SANS_TheSansMonoCd_W5Regular_11">fig = go.Figure(data =</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   go.Contour(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      z = [[1, 2, 3],</samp></p>
<p class="Code"><span aria-label=" Page 147. " epub:type="pagebreak" id="pg_147" role="doc-pagebreak"></span><samp class="SANS_TheSansMonoCd_W5Regular_11">          [2, 3, 4],</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">          [3, 4, 5]]</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   ))</samp></p>
<p class="_CodeSpaceBelow"><samp class="SANS_TheSansMonoCd_W5Regular_11">fig.show()</samp></p>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-16: Creating a basic contour plot</samp></p>
<p class="TX">In the <i>z</i> array, which cells <i>(x,y)</i> have a <i>z</i> value of 3? The three cells (0,2), (1,1), and (2,0). Now, investigate the contour plot figure and find those points <i>(x,y)</i> in 2D space. Is the visualized <i>z</i> value the same value of 3?</p>
<p class="TX">You can see that by defining a few points with similar <i>z</i> values. Plotly does all the heavy lifting of visualizing the contour plot and even coloring it! If you want to learn more about the contour plot (for example, how to customize the <i>x</i> and <i>y</i> values or the shape of the contour lines), visit <a href="https://plotly.com/python/contour-plots"><i>https://<wbr/>plotly<wbr/>.com<wbr/>/python<wbr/>/contour<wbr/>-plots</i></a>.</p>
<p class="TX">In the contour plot in the SVM model, the contour lines are the points that generate the same certainty of a point belonging to a particular class. This “certainty” is called a <i>decision function</i>, and it associates a value to each point in space. It is the heart of the machine learning model. You could argue that the decision function <i>is</i> the model. For a given input <i>x</i>, the sign of the decision function <i>f(x)</i> defines whether the model <i>f</i> predicts that <i>x</i> belongs to one class. If it is positive, it belongs to class X, and if it is negative, it belongs to class Y. The more positive or negative the decision function is, the more certain it is that the input point belongs to the class.</p>
<p class="HeadB"><a id="h2-55"></a><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Using Dash Loading</samp></p>
<p class="TNI">In “Using a Dash Graph” earlier, you learned about the <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Graph</samp> component with the <samp class="SANS_TheSansMonoCd_W5Regular_11">prediction_figure</samp> argument. The computations involved are relatively complicated and may take some loading or initialization time. The user may have to wait, and it can hurt usability and feel clunky to use, so the designers of the SVM Explorer app decided to wrap the <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Graph</samp> in a <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Loading</samp> component. The idea is simple: while your Python interpreter crunches the numbers and runs the computation, Dash shows you a loading symbol (load spinner). Always keep the user in the loop!</p>
<p class="TX"><a href="chapter7.xhtml#fig7-11">Figure 7-11</a> shows what such a loading symbol may look like at different points in time.</p>
<a id="fig7-11"></a>
<figure class="IMG"><img alt="" class="img30" height="79" src="../images/Figure7-11.png" width="389"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-11: Example Dash loading symbol</samp></p></figcaption>
</figure>
<p class="TX">This dynamic loading symbol is then shown to the user for as long as it takes to load the Dash component that is wrapped by the <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Loading</samp> component.</p>
<p class="TX">Now let’s have a look at how we used the <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Loading</samp> component in the SVM Explorer app (see <a href="chapter7.xhtml#List7-17">Listing 7-17</a>).</p>
<a id="List7-17"></a>
<p class="_CodeSpaceAbove"><span aria-label=" Page 148. " epub:type="pagebreak" id="pg_148" role="doc-pagebreak"></span><samp class="SANS_TheSansMonoCd_W5Regular_11">children=dcc.Loading(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   className=</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">"graph-wrapper",</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   children=dcc.Graph(id="graph-sklearn-svm", figure=prediction_figure),</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   style={"display": "none"},</samp></p>
<p class="_CodeSpaceBelow"><samp class="SANS_TheSansMonoCd_W5Regular_11">),</samp></p>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-17: Setting the loading behavior</samp></p>
<p class="TX">The function call has three arguments:</p>
<div class="spc">
<p class="RunInPara"><span class="Bold"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">className   </samp><span class="R">We associate the</span> </span><span class="Bold"><samp class="SANS_TheSansMonoCd_W5Regular_11">graph-wrapper</samp> <span class="R">class definition from the CSS stylesheet. This simply defines some width and height constraints for the component.</span></span></p>
<p class="RunInPara"><span class="Bold"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">children   </samp><span class="R">This is the</span> </span><span class="Bold"><samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Graph</samp> <span class="R">object to be wrapped by the</span> </span><span class="Bold"><samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Loading</samp> <span class="R">component. While this object loads, the loading symbol is supposed to be shown.</span></span></p>
<p class="RunInPara"><span class="Bold"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">style</samp>   <span class="R">We add a dictionary of style attributes to the element. In particular, we set the</span></span><span class="Bold"> <samp class="SANS_TheSansMonoCd_W5Regular_11">"display"</samp> <span class="R">attribute to</span> </span><span class="Bold"><samp class="SANS_TheSansMonoCd_W5Regular_11">"none"</samp><span class="R">. This essentially hides the whole element. However, in the stylesheet, we overwrite the</span> </span><span class="Bold"><samp class="SANS_TheSansMonoCd_W5Regular_11">"display"</samp> <span class="R">attribute to</span> </span><span class="Bold"><samp class="SANS_TheSansMonoCd_W5Regular_11">"flex"</samp><span class="R">, which sets the size flexibly according to the available space. Code is never perfect, and this could have been written more concisely by the creators of the SVM app.</span></span></p>
</div>
<p class="TX">As it turns out, we won’t even see the loading symbol if we run the SVM Explorer app because the components load so quickly. We suspect that this app was initially implemented for a slower version of Dash. But Dash is improving rapidly in speed and usability, so this SVM app can now be computed quickly—and we can simply skip the <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Loading</samp> wrapper.</p>
<p class="TX">For a complete video tutorial on using loading spinners in Dash apps, see the video “Dash Bootstrap Spinner &amp; Progress Bar” available at <a href="https://learnplotlydash.com"><i>https://<wbr/>learnplotlydash<wbr/>.com</i></a>.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h3 class="H1" id="sec5"><a id="h1-50"></a><samp class="SANS_Futura_Std_Bold_B_11">Dash Callbacks</samp></h3>
<p class="TNI">The SVM Explorer app is an advanced app with many interacting code pieces. So far, we’ve focused on the isolated components you haven’t already seen in another app. Now it’s time to look at the bigger picture again, by exploring how the different components interact.</p>
<p class="TX">To get a quick overview of where to focus, let’s start with the callback graph provided by the Dash framework when you run your app with <samp class="SANS_TheSansMonoCd_W5Regular_11">debug=True</samp> (see <a href="chapter7.xhtml#List7-18">Listing 7-18</a>).</p>
<a id="List7-18"></a>
<p class="_CodeSpaceAbove"><span class="gray"><samp class="SANS_TheSansMonoCd_W5Regular_11"># Running the server</samp></span></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">if __name__ == "__main__":</samp></p>
<p class="_CodeSpaceBelow"><samp class="SANS_TheSansMonoCd_W5Regular_11">   app.run_server(debug=True)</samp></p>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-18: Enabling debugging</samp></p>
<p class="TX">You can now access the automatically generated callback graph via the button menu shown in <a href="chapter7.xhtml#fig7-12">Figure 7-12</a>.</p>
<span aria-label=" Page 149. " epub:type="pagebreak" id="pg_149" role="doc-pagebreak"></span><a id="fig7-12"></a>
<figure class="IMG"><img alt="" class="img30" height="72" src="../images/Figure7-12.png" width="186"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-12: Callback graph button menu</samp></p></figcaption>
</figure>
<p class="TX">This button menu should appear at the lower right of your Dash app in your browser. Click <b>Callback Graph</b> to obtain what’s shown in <a href="chapter7.xhtml#fig7-13">Figure 7-13</a>.</p>
<a id="fig7-13"></a>
<figure class="IMG"><img alt="" class="img90" height="405" src="../images/Figure7-13.png" width="635"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-13: The callback graph for the SVM Explorer app</samp></p></figcaption>
</figure>
<p class="TX">The names above the boxes are the Dash components you defined in your <i>app.py</i> file. <a href="chapter7.xhtml#List7-19">Listing 7-19</a> shows an example of the code for a named slider.</p>
<a id="List7-19"></a>
<p class="_CodeSpaceAbove"><samp class="SANS_TheSansMonoCd_W5Regular_11">drc.NamedSlider(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   name="Cost (C)",</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   id="slider-svm-parameter-C-power",</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   min=-2,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   max=4,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   value=</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">0,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   marks={</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      i: "{}".format(10 ** i)</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      for i in range(-2, 5)</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   },</samp></p>
<p class="_CodeSpaceBelow"><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp></p>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-19: NamedSlider component definition, showing where the names in the callback graph come from</samp></p>
<p class="TX">You can find the name <samp class="SANS_TheSansMonoCd_W5Regular_11">slider-svm-parameter-C-power</samp> in one of the upper four boxes. With the named slider, you feed into the <samp class="SANS_TheSansMonoCd_W5Regular_11">slider-svm-parameter-C-coef</samp> component. All components feed into the <samp class="SANS_TheSansMonoCd_W5Regular_11">div-graphs</samp> component that holds all our SVM graphs.</p>
<p class="TX"><span aria-label=" Page 150. " epub:type="pagebreak" id="pg_150" role="doc-pagebreak"></span>So, let’s focus on the callback function that maps all those inputs into the single output component <samp class="SANS_TheSansMonoCd_W5Regular_11">div-graphs</samp> in lines 346 through 453 in the <i>app.py</i> main file. In particular, we’re going to start with the input and output annotations and the function definition, shown in <a href="chapter7.xhtml#List7-20">Listing 7-20</a>.</p>
<a id="List7-20"></a>
<p class="_CodeSpaceAbove"><samp class="SANS_TheSansMonoCd_W5Regular_11">@app.callback(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   Output("div-graphs", "children"),</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   [</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      Input("dropdown-svm-parameter-kernel", "value"),</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      Input("slider-svm-parameter-degree", "value"),</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      Input("slider-svm-parameter-C-coef", "value"),</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      Input("slider-svm-parameter-C-power", "value"),</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      Input("slider-svm-parameter-gamma-coef", "value"),</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      Input("slider-svm-parameter-gamma-power", "value"),</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      Input("dropdown-select-dataset", "value"),</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      Input("slider-dataset-noise-level", "value"),</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      Input("radio-svm-parameter-shrinking", "value"),</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      Input("slider-threshold", "value"),</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      Input("slider-dataset-sample-size", "value"),</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   ],</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">def update_svm_graph(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   kernel,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   degree,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   C_coef,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   C_power,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   gamma_coef,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   gamma_power,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   dataset,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   noise,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   shrinking,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   threshold,</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">   sample_size,</samp></p>
<p class="_CodeSpaceBelow"><samp class="SANS_TheSansMonoCd_W5Regular_11">):</samp></p>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-20: Input and output annotations of the SVM graph</samp></p>
<p class="TX">Instead of a single input, the function has a list of inputs, as shown graphically in the callback graph. All those inputs are needed to calculate the SVM model. This SVM model is then used to create all the graphs you see in the SVM Explorer app.</p>
<p class="TX"><a href="chapter7.xhtml#List7-21">Listing 7-21</a> shows the code that generates the different graphs.</p>
<a id="List7-21"></a>
<p class="_CodeSpaceAbove"><span class="gray"><samp class="SANS_TheSansMonoCd_W5Regular_11">   # … Model Computations Skipped for Readability …</samp></span></p>
<p class="_CodeSpace"><samp class="SANS_TheSansMonoCd_W5Regular_11">   </samp><samp class="SANS_TheSansMonoCd_W5Regular_11">return [</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      html.Div(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">         id="svm-graph-container",</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">         children=</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Loading(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">            </samp><samp class="SANS_TheSansMonoCd_W5Regular_11">className="graph-wrapper",</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">            children=dcc.Graph(id="graph-sklearn-svm",</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">                               figure=prediction_figure),</samp></p>
<p class="Code"><span aria-label=" Page 151. " epub:type="pagebreak" id="pg_151" role="doc-pagebreak"></span><samp class="SANS_TheSansMonoCd_W5Regular_11">           style={"display": "none"},</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">        ),</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      ),</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">      html.Div(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">        id="graphs-container",</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">        children=[</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">           dcc.Loading(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">              className="graph-wrapper",</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">              children=dcc.Graph(id=</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">"graph-line-roc-curve",</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">                                 figure=roc_figure),</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">           ),</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">           dcc.Loading(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">              className="graph-wrapper",</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">              children=dcc.Graph(</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">                 id="graph-pie-confusion-matrix",</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">                 figure=confusion_figure</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">              ),</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">           ),</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">        </samp><samp class="SANS_TheSansMonoCd_W5Regular_11">],</samp></p>
<p class="Code"><samp class="SANS_TheSansMonoCd_W5Regular_11">    </samp><samp class="SANS_TheSansMonoCd_W5Regular_11">),</samp></p>
<p class="_CodeSpaceBelow"><samp class="SANS_TheSansMonoCd_W5Regular_11">   ]</samp></p>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-21: Return value of the update_svm_graph function that generates the graphs in the SVM Explorer app</samp></p>
<p class="TX">The return value is a list of two <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp> elements. The first holds the prediction figure discussed in the <span class="Xref">“Creating a Plotly Contour Plot”</span> section earlier in this chapter. The second holds two more <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Graph</samp> elements: a line graph and a pie chart. <a href="chapter7.xhtml#fig7-14">Figure 7-14</a> shows the three generated graphs.</p>
<a id="fig7-14"></a>
<figure class="IMG"><img alt="" class="img70" height="414" src="../images/Figure7-14.png" width="522"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-14: Three dcc.Graph</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">elements</samp></p></figcaption>
</figure>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h3 class="H1" id="sec6"><a id="h1-51"></a><span aria-label=" Page 152. " epub:type="pagebreak" id="pg_152" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>
<p class="TNI">We covered many advanced Dash concepts in this chapter. You learned about the robust SVM classification algorithm and how dashboards can help you visualize machine learning models. You learned how to integrate NumPy and scikit-learn into your Dashboard apps, and how to create reusable components. You also learned about or strengthened your understanding of Dash HTML components such as <samp class="SANS_TheSansMonoCd_W5Regular_11">html.Div</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">html.A</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">html.Section</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">html.P</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">html.Button</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">html.H2</samp>, as well as standard Dash components such as <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Graph</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Slider</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Dropdown</samp>.</p>
<p class="TX">You now possess the skills to go out there and create your own complex dashboard apps and dive into the gallery to learn about advanced Dash components and features. We didn’t just give you the fish; we told you how and where to get the fish yourself. The gallery is an ocean full of fish, and if you ever feel hungry for more, you’ll know where to go!</p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h3 class="H1" id="sec7"><a id="h1-52"></a><samp class="SANS_Futura_Std_Bold_B_11">Resources</samp></h3>
<p class="TNI">To dive deeper into the SVM Explorer app, feel free to check out the following resources recommended to us by Xing Han, one of the app’s creators:</p>
<ul class="List-1">
<li class="BL">Classifier comparison: <a href="https://scikit-learn.org/stable/auto_examples/classification/plot_classifier_comparison.xhtml"><i>https://<wbr/>scikit<wbr/>-learn<wbr/>.org<wbr/>/stable<wbr/>/auto<wbr/>_examples<wbr/>/classification<wbr/>/plot<wbr/>_classifier<wbr/>_comparison<wbr/>.xhtml</i></a></li>
<li class="BL">ROC metric: <a href="https://scikit-learn.org/stable/auto_examples/model_selection/plot_roc.xhtml"><i>https://<wbr/>scikit<wbr/>-learn<wbr/>.org<wbr/>/stable<wbr/>/auto<wbr/>_examples<wbr/>/model<wbr/>_selection<wbr/>/plot<wbr/>_roc<wbr/>.xhtml</i></a></li>
<li class="BL">Confusion matrix: <a href="https://scikit-learn.org/stable/modules/model_evaluation.xhtml#confusion-matrix"><i>https://<wbr/>scikit<wbr/>-learn<wbr/>.org<wbr/>/stable<wbr/>/modules<wbr/>/model<wbr/>_evaluation<wbr/>.xhtml#confusion<wbr/>-matrix</i></a></li>
<li class="BL">SVM classifier (SVC): <a href="https://scikit-learn.org/stable/modules/generated/sklearn.svm.SVC.xhtml"><i>https://<wbr/>scikit<wbr/>-learn<wbr/>.org<wbr/>/stable<wbr/>/modules<wbr/>/generated<wbr/>/sklearn<wbr/>.svm<wbr/>.SVC<wbr/>.xhtml</i></a></li>
<li class="BL">“A Practical Guide to Support Vector Classification (SVC)”: <a href="https://www.csie.ntu.edu.tw/~cjlin/papers/guide/guide.pdf"><i>https://<wbr/>www<wbr/>.csie<wbr/>.ntu<wbr/>.edu<wbr/>.tw<wbr/>/~cjlin<wbr/>/papers<wbr/>/guide<wbr/>/guide<wbr/>.pdf</i></a></li>
</ul>
</section>
</section>
</div></body>
</html>