<html><head></head><body><div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="73" id="Page_73"/>4</span><br/>
<span class="ChapterTitle">Working with Text and Files</span></h1>
</header><figure class="opener">
<img src="Images/chapterart.png" alt="" width="206" height="206"/>
</figure>
<h2 id="h1-501645c04-0001" class="HeadProject"><span><span epub:type="pagebreak" title="74" id="Page_74"/>Sketch 34: Fonts, Sizes, Character Properties</span></h2>
<p class="BodyFirst">When text is drawn on the screen, there are many ways to draw each character. The size, weight, orientation, and style can vary widely. A <span class="KeyTerm">font</span> specifies a particular size, weight, and style of a typeface. Fonts are saved as files that contain the instructions for drawing each character. Bold, italic, normal, and each important size are individual files. The font name, a style, and a size are frequently part of the filename. </p>
<p>Processing allows many fonts, but each one must be set up in advance as a file using the Tools menu. Select <b>Tools</b><span class="MenuArrow">▶</span><b>Create Font</b> to open a font-creation window, within which you can choose the font name, style, and size, as shown in <a href="#figure34-1" id="figureanchor34-1">Figure 34-1</a>. </p>
<figure>
<img src="Images/f034001.png" alt="f034001" class="keyline" width="324" height="392"/>
<figcaption><p><a id="figure34-1">Figure 34-1</a>: Setting up a font</p></figcaption>
</figure>
<p>Select CourierNewPS-BoldMT with size 48 and click <b>OK</b> to create a file named <em>CourierNewPS-BoldMT-48.vlw</em> inside a local directory named <em>data</em>. You can repeat this process as often as needed, creating many font files. You need font files in order to load and use fonts in Processing.</p>
<p>Using a font is a somewhat involved process. You need to first create a variable of type <code>PFont</code> (Processing font) for each font desired, and then load the font using the <code>loadFont()</code> function <span class="CodeAnnotation" aria-label="annotation1">1</span>: </p>
<pre><code>PFont font1;
font1 = loadFont ("CourierNewPS-BoldMT-48.vlw");</code></pre>
<p>To establish a font as the one to use, call <code>textFont()</code> with the font variable and desired size: <code>textFont(font1, 48)</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>.<b> </b>The size is specified in pixels, not the standard for a font, which is <span class="KeyTerm">points</span>. Finally, you can always change the font size by calling <code>textSize(size)</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>.<b> </b></p>
<p>This sketch loads the Courier Bold 48 font and establishes it. Then it draws the string “Hello” in sizes varying from 2 pixels to 55 pixels, changing by one pixel size each time <code>draw()</code> is called.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">

<pre><code><span epub:type="pagebreak" title="75" id="Page_75"/>PFont font1;
int x=20, y=100;
int size = 55, ds=-1;

void setup ()
{
  size (200, 200);
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> font1 = loadFont ("CourierNewPS-BoldMT-48.vlw");
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> textFont (font1, 48);
  fill (0);
}

void draw ()
{
  background(200);
  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> textSize (size);
  text ("Hello", x, y);
  size = size + ds;
  if (size &lt; 2)  ds = -ds;
  if (size &gt; 55) ds = -ds;
}</code></pre>
<figure class="graphic"><img src="Images/g034001.png" alt="g034001" width="463" height="444"/></figure>
<figure class="graphic"><img src="Images/g034002.png" alt="g034002" width="463" height="444"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c04-0002" class="HeadProject"><span><span epub:type="pagebreak" title="76" id="Page_76"/>Sketch 35: Scrolling Text</span></h2>
<p class="BodyFirst">A news <span class="KeyTerm">scroll</span> is a common feature of television news and weather stations. It is a summary of stories that scrolls from right to left across the bottom of the screen as other things are happening on the rest of the screen. It’s common to see stock prices displayed in this way as well. How could we do this in a Processing sketch window?</p>
<p>First, the text for a particular item has an x-coordinate where it is drawn, and it will be drawn using the <code>text()</code> function. The y-coordinate is constant and will be somewhere near the bottom of the screen. In this sketch the screen is 400×200 and the y-coordinate for the text is 190. The x-coordinate changes.</p>
<p>The text to be displayed should start near the right side of the screen; for example, at <code>width-10</code> pixels <span class="CodeAnnotation" aria-label="annotation2">2</span>. Each frame displayed should move the text to the left, so <code>draw()</code> will subtract one from <code>x</code> each time it is called:</p>
<pre><code>text (s1, x, y);
x = x - 1;</code></pre>
<p>There will usually be more than one message in the scroll. The first message could disappear before the second one is displayed, but this is unusual for a text scroll. Another idea is to have multiple scroll strings being drawn next to each other, moving in lockstep. So the strings themselves are in an array called <code>headlines</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>.</p>
<p>Suppose we have just two strings. Each one has an index into the array that accesses the strings (<code>i1</code> and <code>i2</code>) and x position (<code>x1</code>, <code>x2</code>). If the first string, <code>headlines[i1]</code>, is drawn at location <code>x1</code>, the second string should be drawn at location <code>x1</code> plus the number of pixels in the string <code>i1</code> plus a small space. In Processing terms, it looks like this:</p>
<pre><code>x2 = x1 + (int)textWidth(headlines[i1])+ 10;</code></pre>
<p><code>textWidth()</code> is a function that takes a string as a parameter and, using the current font size, returns the width in pixels of that string when drawn. The value 10 is the small space. When the first string disappears on the left of the screen, its plotted position plus its length will be less than 0 <span class="CodeAnnotation" aria-label="annotation3">3</span>:</p>
<pre><code>x1+textWidth(headlines[i1]) &lt; 0</code></pre>
<p>At this point, a new string (that is, the next index) should be obtained and positioned to the right of the second string:</p>
<pre><code>i1 = (i2+1)%5;
x1 = x2 + (int)textWidth(headlines[i2])+ 10;</code></pre>
<p>The same happens when the second string disappears on the left.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>PFont font1;
int x1, y=190, x2;
int size = 55;
int i1, i2;
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> String []headlines = new String[5];

void setup ()
{
  size (400, 200);
  font1 = loadFont ("CourierNewPS-BoldMT-48.vlw");
  textFont (font1, 12);
  
  headlines[0] = "2 Die, 8 Hurt in Pasadena as Vehicle Hits Crowd * ";
  headlines[1] = "L.A.'s Open Enrollment Plan Shrinks for 5th Year * ";
  headlines[2] = "Program for Writers for Young Adults Starts With Duo Behind 'Buffy' Books * ";
  headlines[3] = "Pickets Want Laguna Festival to Stay Put *         ";
  headlines[4] = "3rd Whale in a Month Washes Up on Coast *          ";
  fill (0);
  i1 = 0; i2 = 1;   <span class="CodeAnnotationHang" aria-label="annotation2">2</span> x1 = width-10;
  x2 = x1 + (int)textWidth(headlines[i1])+ 10;
}

void draw ()
{
  background(200);
  text (headlines[i1], x1, y);  text (headlines[i2], x2, y);  x1 = x1 - 1; x2 = x2 - 1;
  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> if (x1+textWidth(headlines[i1]) &lt; 0)
  {
    i1 = (i2+1)%5;
    x1 = x2 + (int)textWidth(headlines [i2])+ 10;
  }
  
  if (x2+textWidth(headlines[i2]) &lt; 0)
  {
    i2 = (i1+1)%5;
    x2 = x1 + (int)textWidth(headlines [i1])+ 10;
  }
}
</code></pre>
<span epub:type="pagebreak" title="77" id="Page_77"/><figure class="graphic"><img src="Images/g035001.png" alt="g035001" width="506" height="167"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c04-0003" class="HeadProject"><span><span epub:type="pagebreak" title="78" id="Page_78"/>Sketch 36: Text Animation</span></h2>
<p class="BodyFirst">Animating text can create an interesting effect. It has been used in commercials and by artists in the past, but it has never been as easy to do as it is now. A string can be drawn along a curved path, even a moving curved path; characters in the string can change in orientation, size, color, or even font. Motion can even vary according to user input, either by following the mouse or moving as a result of audio or video input. </p>
<p>A key to animating text is to access each character in the string using the <code>charAt()</code> function. The first character in the string <code>str</code> is returned by <code>str.charAt(0)</code>, the second character is <code>str.charAt(1)</code>, and so on. In this way, each character can be accessed individually and be made to behave in a different way from other characters.</p>
<p>This sketch causes the word <em>Processing</em> to explode, the component letters flying in all directions at different speeds; character sizes change too. Each character has a distinct position (arrays <code>x</code> and <code>y</code>), velocity (arrays <code>dx</code> and <code>dy</code>), and size (array <code>size</code>) <span class="CodeAnnotation" aria-label="annotation1">1</span>. </p>
<p>Initially, we draw the word <em>Processing</em> neatly in the center of the screen as a set of individual characters <span class="CodeAnnotation" aria-label="annotation2">2</span>:</p>
<pre><code>for (int i = 0; i&lt;10; i++)
  text (s1.charAt(i), x[i], y[i]);</code></pre>
<p>After a few seconds (60 frames) <span class="CodeAnnotation" aria-label="annotation3">3</span>, we change the position of each character every frame <span class="CodeAnnotation" aria-label="annotation4">4</span>, thus moving them, and we adjust individual sizes too. The characters move off in random directions, eventually disappearing from the screen. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>PFont font1;
int count = 0;
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> int x[] = new int [10];
int y[] = new int [10];
int size [] = new int [10];
int dx[] = new int [10]; 
int dy[] = new int[10];
String s1 = "Processing";

void setup ()
{
  size (400, 200);
  font1 = loadFont ("CourierNewPS-BoldMT-48.vlw");
  textFont (font1, 12);
  for (int i=0; i&lt;10; i++)
  {
    x[i] = 100+15*i; y[i] = 100;
    size[i] = 12;
    dx[i] = (int)(random(11)-6); 
    dy[i] = (int)(random(11)-6);
  }
  fill (0);
}

void draw ()
{
  background(200);
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> for (int i = 0; i&lt;10; i++)
    if (size[i] &gt; 0)
    {
     textSize(size[i]);
     text (s1.charAt(i), x[i], y[i]);
    }
  count = count + 1;
  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> if (count &gt; 60)
    for (int i=0; i&lt;10; i++)
    {
      <span class="CodeAnnotationHang" aria-label="annotation4">4</span> x[i] = x[i] + dx[i]; 
      y[i] = y[i] + dy[i];
      size[i] = size[i] + (int)(random (5)-3);
    }
}
</code></pre>
<span epub:type="pagebreak" title="79" id="Page_79"/><figure class="graphic"><img src="Images/g036001.png" alt="g036001" width="436" height="217"/></figure>
<figure class="graphic"><img src="Images/g036002-r.png" alt="g036002-r" width="436" height="435"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c04-0004" class="HeadProject"><span><span epub:type="pagebreak" title="80" id="Page_80"/>Sketch 37: Inputting a Filename</span></h2>
<p class="BodyFirst">All of the sketches developed in this book so far use filename constants when reading an image. To be more flexible, most programs allow the user to enter a command or filename, even a number, from the keyboard, and that user input directs the code to use specific data. This is our next task—to ask the user to enter an image filename from the keyboard and display that image in the sketch window.</p>
<p>We already know that the <code>keyPressed()</code> function is called whenever the user presses a key, and the variable <code>key</code> contains the character that represents the key that was pressed, at least for letters and numbers. Other keys, like arrow keys, use a keycode value, like <code>ENTER</code> or <code>BACKSPACE</code>, to tell us what the key is. Given these facts, one way to read a user-given filename would be to append the characters typed by the user to a string and, when we see the <span class="KeyCaps">enter</span> value, to use the preceding string as a filename. This should work fine, but we need to handle some conventions. </p>
<p>First, the user needs to see what they are typing. The string that the user has entered so far must appear somewhere on the screen so that the user can see what has actually been typed. </p>
<p>Next, corrections must be possible. Traditionally one presses the <span class="KeyCaps">backspace</span> key to move backward over the string and delete characters so that new, correct ones can be entered, so we’ll implement corrections using <span class="KeyCaps">backspace</span>. Finally, if an incorrect name is entered, a corresponding image file might not exist, and the user needs to be informed.</p>
<p>When the user types a letter or number, indicated by the variable <code>key</code>, we add that character to a string named <code>s</code> using the concatenation operation <span class="CodeAnnotation" aria-label="annotation3">3</span>:</p>
<pre><code>s = s + key;</code></pre>
<p>If that character is a backspace and the string has characters in it, we remove the last character entered <span class="CodeAnnotation" aria-label="annotation1">1</span>:</p>
<pre><code>if (s.length()&gt;0 &amp;&amp; key==BACKSPACE)   
s = s.substring (0, s.length()-1);</code></pre>
<p>The <code>draw()</code> function will display this string each time the screen is updated, allowing the user to see the current string. Finally, if the key pressed was <span class="KeyCaps">enter,</span> then the string is complete and we should open and display the file. If <code>loadImage()</code> returns <code>null</code>, there is no such image, and the word <code>Error</code> is displayed in place of the filename <span class="CodeAnnotation" aria-label="annotation2">2</span>.</p>
<pre><code>if(key==ENTER || key==RETURN)
{
  img = loadImage (s);
  if (img == null) s = "Error";
}</code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">

<pre><code><span epub:type="pagebreak" title="81" id="Page_81"/>PImage img;
String s = "";

void setup ()
{
  size(500, 500);
}

void draw ()
{
  background (200, 200, 200);
  if (img != null) image (img, 0, 0);
  fill(0);
  text (s, 20, height-20);
}

void keyPressed()
{
  fill(0);
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> if (s.length()&gt;0 &amp;&amp; key==BACKSPACE)
  {
    s = s.substring (0, s.length()-1);
  } 
    <span class="CodeAnnotationHang" aria-label="annotation2">2</span> else if(key==ENTER || key==RETURN)
    {
      img = loadImage (s);
      if (img == null) s = "Error";
    } else
        <span class="CodeAnnotationHang" aria-label="annotation3">3</span> s = s + key;
}
</code></pre>
<figure class="graphic"><img src="Images/g037001-r.png" alt="g037001-r" width="463" height="462"/></figure>
<figure class="graphic"><img src="Images/g037002-r.png" alt="g037002-r" width="463" height="462"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c04-0005" class="HeadProject"><span><span epub:type="pagebreak" title="82" id="Page_82"/>Sketch 38: Inputting an Integer</span></h2>
<p class="BodyFirst">In the previous sketch, we had the user enter a string from the keyboard, and we used the string as a filename. This is a basic use of a string—using a sequence of characters to communicate data to the computer and back. What if, instead of entering a filename, we wanted to specify some number of things to input? This would mean entering an integer. However, when a number is entered at the keyboard, the string is <em>not</em> the number but is a text representation of the number. To get the actual number, the characters that compose it have to be converted into numeric form.</p>
<p>The string “184” is an integer in string form, obviously representing the number one hundred eighty-four (184). This is one hundred plus eight tens plus four, or 10<sup>2 </sup>+ 8×10<sup>1</sup> + 4×10<sup>0</sup>. To convert from string form into numeric form, we need to peel off the digits one at a time and multiply by the correct power of 10.</p>
<p>We can take the first digit, 1, and add it to a sum. Then we take the next digit and add to the sum <em>multiplied by 10</em>; and repeat again and again until the incoming character is not a digit. The powers of 10 accumulate with the first digit representing the highest power and the final digit representing 10<sup>0</sup>, or one.</p>
<p>This is the essential piece of code <span class="CodeAnnotation" aria-label="annotation1">1</span>:</p>
<pre><code>val = val * 10 + (key-'0');</code></pre>
<p>The expression <code>key-'0'</code>, where <code>key</code> is a digit, represents the numeric value of a digit character (that is, from 0 to 9). Assuming that <code>val</code> is initially 0, we get this after the user types <code>'1'</code>:</p>
<pre><code>val = 0*10 + ('1'-'0') = 0 + 1 = 1</code></pre>
<p>Now the user types <code>'8'</code>, and we get this:</p>
<pre><code>val = 1 * 10 + ('8'-'0') = 10 + 8 = 18</code></pre>
<p>Finally the user types <code>'4'</code>:</p>
<pre><code>val = 18*10 + ('4'-'0') = 180 + 4 = 184</code></pre>
<p>To make this sketch marginally useful, it allows us to enter two values, an <em>x</em> and a <em>y</em> value, and draws a circle at these coordinates. An error on entry sets the coordinate to 0.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">

<pre><code>String s = "";
int val = 0;
int x=-1, y=-1;

void setup ()
{
  size(500, 500);
}

void draw ()
{
  background (200, 200, 200);
  fill(0);
  text (s, 20, height-20);
  if (y&gt;=0) ellipse (x, y, 10, 10);
}

void keyPressed()
{
  fill(0);
  if (s.length()&gt;0 &amp;&amp; key==BACKSPACE)
  {
    s = s.substring (0, s.length()-1);
    val = val/10;
  } else if(key==ENTER || key==RETURN)
    {
      if (x&lt;0) x = val;
      else if (y&lt;0) y = val;
      s = ""; val = 0;
    } else if ( (key&gt;='0') &amp;&amp; (key&lt;='9'))
      {
        s = s + key;
        <span class="CodeAnnotationHang" aria-label="annotation1">1</span> val = val * 10 + (key-'0');
      } else
        {
          s = "Error"; val = 0;
        }
}
</code></pre>
<span epub:type="pagebreak" title="83" id="Page_83"/><figure class="graphic"><img src="Images/g038001.png" alt="g038001" width="448" height="447"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c04-0006" class="HeadProject"><span><span epub:type="pagebreak" title="84" id="Page_84"/>Sketch 39: Reading Parameters from a File</span></h2>
<p class="BodyFirst">Many computer programs save values in files for use when the program starts, or restarts. Initial values, locations for buttons and other interface objects, high scores for a game: all can be read from files when a program begins. Most people have had the experience of playing a computer game and saving the state so that they can resume playing at a later time; this also involves saving data in a file and then retrieving it later. This sketch retrieves the state of a game, albeit a simple one—checkers—from a text file that contains the positions of all of the checkers in a game.</p>
<p>Checkers uses an 8×8 grid of squares on which disks of two colors, usually referred to as black and white, are placed. Only half of the squares are really used, and these squares also have two colors. Checkers can only sit on one of those colors, so the easy part of this sketch is to draw the squares and place checkers on those squares when it is known what the locations are. The new part is reading the data and interpreting that data as checker positions.</p>
<p>As a scheme for representing a checker board, imagine a set of squares with eight rows of eight columns each. A square can be indexed as (<em>i</em>, <em>j</em>), where <em>i</em> is the row and <em>j</em> is the column. The color of the checker on the square can be 0 for one color and 1 for another—the actual colors do not matter, only that checkers of color 0 belong to one player and the color 1 checkers belong to the other. The squares have fixed positions, but the checker locations are read from the file, which contains a row for the position and color of each checker, like this:</p>
<pre><code>row col color   (e.g. 1 2 1)
row col color   (e.g. 1 4 1)
...</code></pre>
<p>The file contains one-digit integers separated by single spaces, three per line. A structured format is easy to read and is, in fact, typical of data that has been created by a computer.</p>
<p>To read a file in Processing, we’ll use the built-in function <code>loadStrings()</code>, which reads a set of strings from a file (given as a string parameter), with one string being one line in the file. <code>loadStrings()</code> returns an array of strings that we’ll assign to the variable <code>dlines</code><b> </b><span class="CodeAnnotation" aria-label="annotation2">2</span>. To find the number of items in the array (the same as the number of lines of data in the file), we use the <code>length</code> property in <code>dlines</code>: <code>dlines</code><b>.</b><code>length</code>.</p>
<p>When a line is read in, we use it to place a checker on a square, and when all checkers are read in, we draw them on the screen. To place the checker, we extract the three integers from each string in <code>dlines</code> and then place the correct piece in the correct place using the row and column integers.</p>
<p>We convert the string data into numbers as follows <span class="CodeAnnotation" aria-label="annotation3">3</span>: </p>
<pre><code>y[i] = dlines[i].charAt(1) - '0';</code></pre>
<p>Each piece is one of two colors, indicated by the variable <code>k[i]</code>. A checker is 20 pixels wide, so we draw one at location (<code>x[i]</code>,<code> y[i]</code>) with these lines:</p>
<pre><code>if (k[i]==0) fill (200,0,0); else fill (200,2000,0);  // Color?
  ellipse (x[i]*40+20, y[i]*40+20, 20, 20);</code></pre>
<p>The horizontal position is offset from the left by 20 pixels, and each successive position is 40 pixels further right. The expression <code>x[i]*40+20</code> gives the <em>x</em> location at which to draw checker number <code>i</code>. It is symmetrical for the vertical <em>y</em> position.</p>
<p><span epub:type="pagebreak" title="85" id="Page_85"/>Squares are 40×40 pixels and alternate in color, so when we draw a red one, we toggle the fill color to that of the next square. After 8 squares, an extra toggle is done so that the colors alternate vertically as well. If <code>i</code> and <code>j</code> are the coordinates of a square, we draw it this way:</p>
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> rect (i*40, j*40, 40, 40)</code></pre>
<p>In the sketch, the checkers are red or green, and the squares are red or yellow.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">

<pre><code>String dlines[];
boolean errorFlag = false;
int []x = new int[12];    // Column for checker
int []y = new int[12];    // Row for checker 
int []k = new int[12];    // Color of checker
int n = 0;

void setup ()
{ 
  size (400, 400);
  readFile ("save.txt");  // Read data
}

void draw ()
{
  background (200);
  board ();               // Draw the board
}

void board ()
{  // Draw the squares
  for (int i=0; i&lt;8; i++)    // Columns
    for (int j=0; j&lt;8; j++)  // Rows
    {  // Alternate the color for the squares
      if ((i+j)%2 == 0) fill (255, 0, 0);
        else fill (255, 255, 0);
      <span class="CodeAnnotationHang" aria-label="annotation1">1</span> rect (i*40, j*40, 40, 40);
    }
    for (int i=0; i&lt;n; i++)  // Draw the checkers
    {
      if (k[i]==0) fill (200, 0, 0); else fill (100, 200, 0);  // Color?
      ellipse (x[i]*40+20, y[i]*40+20, 20, 20);                // Location.
    }
}

void readFile (String fileName)
{
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> dlines = loadStrings(fileName);       // Read the names as strings
  for (int i=0; i&lt;dlines.length; i++)   // dlines.length is how many items in the array
    {
      <span class="CodeAnnotationHang" aria-label="annotation3">3</span> y[i] = dlines[i].charAt(1) - '0';
      x[i] = dlines[i].charAt(3) - '0';
      k[i] = dlines[i].charAt(5) - '0';
    }
  n=dlines.length;
}</code></pre>
<figure class="graphic"><img src="Images/g039001.png" alt="g039001" width="434" height="433"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c04-0007" class="HeadProject"><span><span epub:type="pagebreak" title="86" id="Page_86"/>Sketch 40: Writing Text to a File</span></h2>
<p class="BodyFirst">Computer programs use text to tell their users what is going on. Sometimes, as in the previous sketch, they use text to save the state of the program, often a game; sometimes the program writes numerical results or records the progress of a program. Text is a typical and natural way for computers to communicate with humans. </p>
<p>Here’s the problem to be solved: we want to simulate a ball on the screen, moving at a constant speed, as was done in Sketch 28; write the position of the ball to a file during each frame; and record when the ball collides with the edge of the screen.</p>
<p>The output method that corresponds to <code>loadStrings()</code> is the function <code>saveStrings()</code>. We’ll declare an array of strings, where each string will be written as a line of text to the file. When a ball position is to be saved, a string is created that represents the position, and it is stored in one of the array locations. Then the array index is incremented so the next string goes in the next location <span class="CodeAnnotation" aria-label="annotation2">2</span>.</p>
<pre><code>data[index] = "(X0,Y0)= ("+x0+","+y0+")";
index = index+1;</code></pre>
<p>When the ball collides with a side of the screen, we put a message like “Collision left” in the array and then increment the index <span class="CodeAnnotation" aria-label="annotation1">1</span>.</p>
<p>When the array is full, which happens when the index is greater than 499, <code>saveStrings()</code> writes all of the strings to a file and ends the program <span class="CodeAnnotation" aria-label="annotation3">3</span>:</p>
<pre><code>saveStrings("save.txt", data);</code></pre>
<p>It is not possible to add more to a file using <code>saveStrings()</code> after the file has been closed; if you call it again with the same filename, it will overwrite the file. So you must save everything first, and then write it all out at once. With 500 strings, you can record about 7 seconds.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>String []data = new String[501];
int x0=40, y0=90, index, dx0=3, dy0=2; 
void setup ()
{  size (300, 300); }

void draw ()
{
  background (40, 40, 190);
  ellipse (x0, y0, 10, 10);
  x0 = x0 + dx0; y0 = y0 + dy0;
  if (x0&lt;10) 
  {
    dx0 = -dx0; 
    <span class="CodeAnnotationHang" aria-label="annotation1">1</span> data[index] = "Collision left"; index= index+1; 
  }
  if (x0&gt;width-10)
  {
    dx0 = -dx0;
    data[index] = "Collision right"; index= index+1;
  }
  if (y0&lt;0)
  {
    dy0 = -dy0;
    data[index] = "Collision top"; index= index+1;
  }
  if (y0&gt;width-10)
  {
    dy0 = -dy0;
    data[index] = "Collision bottom"; index= index+1;
  }
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> data[index] = "(X0,Y0)= ("+x0+","+y0+")";
  index = index+1;
  if (index &gt; 499) 
  {
    <span class="CodeAnnotationHang" aria-label="annotation3">3</span> saveStrings("save.txt", data);
    exit();
  }
}</code></pre>
<span epub:type="pagebreak" title="87" id="Page_87"/><figure class="graphic"><img src="Images/g040001.png" alt="g040001" width="410" height="410"/></figure>
<figure class="graphic"><img src="Images/g040002.png" alt="g040002" width="298" height="342"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c04-0008" class="HeadProject"><span><span epub:type="pagebreak" title="88" id="Page_88"/>Sketch 41: Simulating Text on a Computer Screen</span></h2>
<p class="BodyFirst">Imagine working on a made-for-TV movie. It’s about computers and hackers and programmers, and the actors playing the roles of the hackers are, well, <em>actors</em>. They don’t know anything about programming. They can’t type, and they certainly can’t enter code. So, in the scenes where the camera is looking over the main character’s shoulder at the screen while she types, we need a special effect—something that makes it appear as if she’s coding. Do we use computer animation? That can be expensive. No, the usual trick is to use a simple program that displays text, specific text, no matter what keys are struck. That way the actors don’t have to know anything except how to press a key.</p>
<p>Making this program in Processing is straightforward, given what we know so far. The program opens a window and initializes a string, <code>message</code>, to the text to be typed onto the screen <span class="CodeAnnotation" aria-label="annotation1">1</span>, which could be read from a file. A variable <code>N</code> starts as <code>0</code> and indexes the string: every character up to character <code>N</code> has been typed and should appear on the screen. The <code>draw()</code> function draws all of the characters up to <code>N</code> each time it is called, one character at a time, spacing them (in the example) nine pixels apart horizontally. </p>
<p>To organize the text into lines, we use the “!” character to indicate where lines end. When the program sees that character in the string, it doesn’t display it, but instead resets the <em>x</em> position to the starting value and increases the <em>y</em> position by 15 pixels (one line). </p>
<p>The <code>draw()</code> function outputs the text, starting at the statement <span class="CodeAnnotation" aria-label="annotation2">2</span>:</p>
<pre><code>for (int i=0; i&lt;N; i++) // display the next character</code></pre>
<p>Either it displays one of the characters in the string <span class="CodeAnnotation" aria-label="annotation4">4</span>:</p>
<pre><code>text (""+message.charAt(i), x, y);
x = x + 10;</code></pre>
<p class="BodyContinued">or the character in the string is “!” and it begins a new line <span class="CodeAnnotation" aria-label="annotation3">3</span>:</p>
<pre><code>if (message.charAt(i) == '!') 
{
  y = y + 15;    // Move vertically down to next line
  x = 15;        // and start over at pixel 15.
}</code></pre>
<p>Finally, when a key is pressed, as indicated by Processing calling the <code>keyPressed()</code> function, the count value <code>N</code> increases by one so that one more character appears on the screen <span class="CodeAnnotation" aria-label="annotation6">6</span>. Regardless of what character was typed, the predefined character in the <code>message</code> string will be displayed. If <code>N</code> exceeds the string length, the program can set <code>N</code> to <code>0</code>, which starts over again with a fresh screen, or further key presses could just be ignored.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Another possibility is to have the text display automatically, one character at a time, without anything being typed. The code to do so appears in the Processing program at the end of the <code>draw(</code><code>)</code> function but has been commented out <span class="CodeAnnotation" aria-label="annotation5">5</span>:</p>
<pre><code>//  N = N + 1
//  if(N &gt;= message.length()) N = 0;</code></pre>
<p class="continued">Removing the comment characters will make the text appear magically without a typist.</p>
<p class="continued">Note also that the background color is green because in older programming days, like the 1960s and 1970s, screens tended to be green. This is easy to change, and for a real movie application, the designers would specify the color they wanted.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>int count = 0;
int N = 0;
int increment = 2;
String message;

void setup ()
{
    size (450, 500);
    background (0, 80, 0);
    <span class="CodeAnnotationHang" aria-label="annotation1">1</span> message = "Processing 3.5.4 September 2021. !// J Parker - Sketch 041!";
    message = message + "void draw()!{!  boolean more = true;!  int x, y;!"+
         "!  x = 15; y = 50;!  background (0, 80, 0);!"+
         "!    for (int i=0; i&lt;N; i++)!    {!      if (message.charAt(i) == '-')"+ 
         "!      {!        y = y + 15; !        x = 15;!      }!      else!"+ 
         "      {!        text (message.charAt(i), x, y);!        x = x + 10;"+
         "!      }!    }!  !  count = count + 1;!  if (count &gt; increment) !  "+
         "{ count = 0; N++; }!"+
         "  if(N &gt; message.length()) N = 0;!}!";    
    message = message + "-- Abort at line 201 --!'   c = chr(128)'!        ^!!!";
}

void draw()
{
  boolean more = true;
  int x, y;
  
  x = 15; y = 50; 
  background (0, 80, 0);
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> for (int i=0; i&lt;N; i++)
  {
    <span class="CodeAnnotationHang" aria-label="annotation3">3</span> if (message.charAt(i) == '!') 
    {
      y = y + 15; 
      x = 15;
    }
      else 
      {
        <span class="CodeAnnotationHang" aria-label="annotation4">4</span> text (""+message.charAt(i), x, y);
        x = x + 10;
      }
    }
  <span class="CodeAnnotationHang" aria-label="annotation5">5</span> // N=N+1;  if(N &gt;= message.length()) N = 0;
}

void keyPressed()
{ 
  <span class="CodeAnnotationHang" aria-label="annotation6">6</span> N=(N+1)%message.length(); 
}</code></pre>
<span epub:type="pagebreak" title="89" id="Page_89"/><figure class="graphic"><img src="Images/g041001-r.png" alt="g041001-r" width="468" height="505"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
</section>
</div></body></html>