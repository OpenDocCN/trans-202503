<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" xml:lang="en" lang="en">
<head>
<title>2. The Windows Kernel</title>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="sbo-rt-content"><section aria-labelledby="ch2" epub:type="chapter" role="doc-chapter">
<hgroup>
<h2 class="CHAPTER" id="ch2">
<span class="CN"><span aria-label=" Page 23. " epub:type="pagebreak" id="pg_23" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">THE WINDOWS KERNEL</samp></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener" height="386" src="../images/chapter.jpg" width="386"/></figure>
<p class="ChapterIntro">Windows is a secure, multiuser operating system. However, it’s also one of the most challenging modern operating systems to understand in detail. Before we delve into the intricacies of its security, in this part of the book I’ll provide you with an overview of the operating system’s structure. We’ll also take this opportunity to understand how to use the PowerShell module that will form the core of this book.</p>
<p class="TX">We’ll consider the two parts of the running operating system: the kernel and the user-mode applications. The kernel makes the security decisions that determine what a user can do on the system. However, most of the applications you use on a Windows machine run in user mode. This chapter will focus on the kernel; the next chapter will focus on user-mode applications.</p>
<p class="TX">In the following sections, we’ll examine the various subsystems that make up the Windows kernel. For each subsystem, I’ll explain its purpose <span aria-label=" Page 24. " epub:type="pagebreak" id="pg_24" role="doc-pagebreak"></span>and how it’s used. We’ll begin with the object manager, where we’ll also explore system calls, which allow a user-mode application to access kernel objects. We’ll then discuss the input/output manager, how applications are created through the process and thread manager, and how memory is represented with the memory manager. Throughout, I’ll outline how you can inspect the behavior of these subsystems using PowerShell.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="H1" id="sec1"><span id="h1-10"></span><samp class="SANS_Futura_Std_Bold_B_11">The Windows Kernel Executive</samp></h3>
<p class="TNI1">The <i>Windows NTOS kernel executive</i>, or <i>kernel</i> for short, is the heart of Windows. It provides all the operating system’s privileged functionality, as well as interfaces through which the user applications can communicate with the hardware. The kernel is split into multiple subsystems, each with a dedicated purpose. <a href="chapter2.xhtml#fig2-1">Figure 2-1</a> shows a diagram of the components in which we’ll be most interested in this book.</p>
<figure class="IMG"><img alt="" class="img1" height="879" id="fig2-1" src="../images/Figure2-1.jpg" width="1352"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-1: The Windows kernel executive modules</samp></p></figcaption>
</figure>
<p class="TX">Each subsystem in the kernel executive exposes APIs for other subsystems to call. If you are looking at kernel code, you can quickly determine what subsystem each API belongs to using its two-character prefix. The prefixes for the subsystems in <a href="chapter2.xhtml#fig2-1">Figure 2-1</a> are shown in <a href="chapter2.xhtml#tab2-1">Table 2-1</a>.</p>
<span aria-label=" Page 25. " epub:type="pagebreak" id="pg_25" role="doc-pagebreak"></span>
<table class="Basic-Table">
<caption><p class="TT" id="tab2-1"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 2-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">API Prefix-to-Subsystem Mapping</samp></p></caption>
<thead>
<tr>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Prefix</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Subsystem</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Example</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Nt</samp> <samp class="SANS_Futura_Std_Book_11">or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">System call interface</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">NtOpenFile</samp><samp class="SANS_Futura_Std_Book_11">/</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">ZwOpenFile</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Se</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Security Reference Monitor</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SeAccessCheck</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Ob</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Object manager</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">ObReferenceObjectByHandle</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Ps</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Process and thread manager</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">PsGetCurrentProcess</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Cm</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Configuration manager</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">CmRegisterCallback</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Mm</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Memory manager</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">MmMapIoSpace</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Io</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Input/output manager</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">IoCreateFile</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Ci</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Code integrity</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">CiValidateFileObject</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">We’ll explore all of these subsystems in the sections that follow.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h3 class="H1" id="sec2"><span id="h1-11"></span><samp class="SANS_Futura_Std_Bold_B_11">The Security Reference Monitor</samp></h3>
<p class="TNI1">For the purposes of this book, the <i>Security Reference Monitor (SRM)</i> is the most important subsystem in the kernel. It implements the security mechanisms that restrict which users can access different resources. Without the SRM, you wouldn’t be able to prevent other users from accessing your files. <a href="chapter2.xhtml#fig2-2">Figure 2-2</a> shows the SRM and its related system components.</p>
<figure class="IMG"><img alt="" class="img1" height="868" id="fig2-2" src="../images/Figure2-2.jpg" width="1349"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-2: Components of the Security Reference Monitor</samp></p></figcaption>
</figure>
<p class="TX">Every process running on the system is assigned an <i>access token</i> when it’s created. This access token is managed by the SRM and defines the identity of the user associated with that process. The SRM can then perform an operation called an <i>access check</i>. This operation queries a resource’s security descriptor, compares it to the process’s access token, and either calculates the level of granted access or indicates that access is denied to the caller.</p>
<p class="TX"><span aria-label=" Page 26. " epub:type="pagebreak" id="pg_26" role="doc-pagebreak"></span>The SRM is also responsible for generating audit events whenever a user accesses a resource. Auditing is disabled by default due to the volume of events it can produce, so an administrator must enable it first. These audit events can be used to identify malicious behavior on a system as well as to diagnose security misconfigurations.</p>
<p class="TX">The SRM expects users and groups to be represented as binary structures called <i>security identifiers (SIDs)</i>. However, passing around raw binary SIDs isn’t very convenient for users, who normally refer to users and groups by meaningful names (for example, the user <i>bob</i> or the <i>Users</i> group). These names need to be converted to SIDs before the SRM can use them. The task of name–SID conversion is handled by the <i>Local Security Authority Subsystem (LSASS)</i>, which runs inside a privileged process independent from any logged-in users.</p>
<p class="TX">It’s infeasible to represent every possible SID as a name, so Microsoft defines the <i>Security Descriptor Definition Language (SDDL)</i> format to represent a SID as a string. SDDL can represent the entire security descriptor of a resource, but for now we’ll just use it to represent the SID. In <a href="chapter2.xhtml#Lis2-1">Listing 2-1</a>, we use PowerShell to look up the <i>Users</i> group name using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp> command; this should retrieve the SDDL string for the SID.</p>
<span id="Lis2-1"></span><pre><code>PS&gt; <b>Get-NtSid -Name "Users"</b>
Name          Sid
----          ---
BUILTIN\Users S-1-5-32-545
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-1: Querying the SID of the</span> <samp class="SANS_Futura_Std_Book_11">Users</samp> <span class="Futura_Std_Book_Oblique_I_11">group using Get-NtSid</span></p>
<p class="TX">We pass the name of the <i>Users</i> group to <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp>, which returns the fully qualified name, with the local domain <i>BUILTIN</i> attached. The <i>BUILTIN\Users</i> SID is always the same between different Windows systems. The output also contains the SID in SDDL format, which can be broken down into the following dash-separated parts:</p>
<ul class="ul">
<li class="ListBullet">The <samp class="SANS_TheSansMonoCd_W5Regular_11">S</samp> character prefix. This indicates that what follows is an SDDL SID.</li>
<li class="ListBullet">The version of the SID structure in decimal. This has a fixed value of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>.</li>
<li class="ListBullet">The security authority. Authority <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp> indicates the built-in NT authority.</li>
<li class="ListBullet">Two relative identifiers (RIDs), in decimal. The RIDs (here, <samp class="SANS_TheSansMonoCd_W5Regular_11">32</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">545</samp>) represent the NT authority group.</li>
</ul>
<p class="TX">We can also use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp> to perform the reverse operation, converting an SDDL SID back to a name, as shown in <a href="chapter2.xhtml#Lis2-2">Listing 2-2</a>.</p>
<span id="Lis2-2"></span><pre><code>PS&gt; <b>Get-NtSid -Sddl "S-1-5-32-545"</b>
Name          Sid
----          ---
BUILTIN\Users S-1-5-32-545
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-2: Using Get-NtSid to find the name associated with a SID</span></p>
<p class="TX">I’ll describe the SRM and its functions in much greater depth in <span class="Xref"><a href="chapter4.xhtml">Chapters 4</a></span> through <span class="Xref"><a href="chapter9.xhtml">9</a></span>, and we’ll revisit the SID structure in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>, when <span aria-label=" Page 27. " epub:type="pagebreak" id="pg_27" role="doc-pagebreak"></span>we discuss security descriptors. For now, remember that SIDs represent users and groups and that we can represent them as strings in SDDL form. Next, we’ll move on to another of the core Windows kernel executive subsystems, the object manager.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h3 class="H1" id="sec3"><span id="h1-12"></span><samp class="SANS_Futura_Std_Bold_B_11">The Object Manager</samp></h3>
<p class="TNI1">On Unix-like operating systems, everything is a file. On Windows, everything is an object, meaning that every file, process, and thread is represented in kernel memory as an object structure. Importantly for security, each of these objects can have an assigned security descriptor, which restricts which users can access the object and determines the type of access they have (for example, read or write).</p>
<p class="TX">The <i>object manager</i> is the component of the kernel responsible for managing these resource objects, their memory allocations, and their lifetimes. In this section, we’ll first discuss the types of objects the object manager supports. Then, we’ll explore how kernel objects can be opened through a naming convention using a system call. Finally, we’ll look at how to use a handle returned by the system call to access the object.</p>
<section aria-labelledby="sec4" epub:type="division">
<h4 class="H2" id="sec4"><span id="h2-8"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Object Types</samp></h4>
<p class="TNI1">The kernel maintains a list of all the types of objects it supports. This is necessary, as each object type has different supported operations and security properties. <a href="chapter2.xhtml#Lis2-3">Listing 2-3</a> shows how to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtType</samp> command to list all supported types in the kernel.</p>
<span id="Lis2-3"></span><pre><code>PS&gt; <b>Get-NtType</b>
Name
----
Type
Directory
SymbolicLink
Token
Job
Process
Thread
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-3: Executing Get-NtType</span></p>
<p class="TX">I’ve truncated the list of types (the machine I’m using supports 72 of them), but there are some noteworthy entries even in this short section. The first entry in the generated list is <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp>; even the list of kernel types is built from objects! Other types of note here are <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Thread</samp>, which represent the kernel objects for a process and a thread, respectively. We’ll examine other object types in more detail later in this chapter.</p>
<p class="TX">You can display the properties of a type with <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-List</samp>, which returns additional information about that type. We’ll look at an example later, but <span aria-label=" Page 28. " epub:type="pagebreak" id="pg_28" role="doc-pagebreak"></span>for now the question is how to access each of these types. To answer it, we’ll need to talk about the object manager namespace.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h4 class="H2" id="sec5"><span id="h2-9"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Object Manager Namespace</samp></h4>
<p class="TNI1">As a user of Windows, you typically see your filesystem drives in Explorer. But underneath the user interface is a whole additional filesystem just for kernel objects. Access to this filesystem, referred to as the <i>object manager namespace (OMNS)</i>, isn’t very well documented or exposed to most developers, which makes it even more interesting.</p>
<p class="TX">The OMNS is built out of <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp> objects. The objects act as if they were in a filesystem, so each directory contains other objects, which you can consider to be files. However, they are distinct from the file directories you’re used to. Each directory is configured with a security descriptor that determines which users can list its contents and which users can create new subdirectories and objects inside it. You can specify the full path to an object with a backslash-separated string.</p>
<p class="TX">We can enumerate the OMNS by using a drive provider that is part of this book’s PowerShell module. As shown in <a href="chapter2.xhtml#Lis2-4">Listing 2-4</a>, this exposes the OMNS as if it were a filesystem by listing the <i>NtObject</i> drive.</p>
<span id="Lis2-4"></span><pre><code>PS&gt; <b>ls NtObject:\ | Sort-Object Name</b>
Name             TypeName
----             --------
ArcName          Directory
BaseNamedObjects Directory
BindFltPort      FilterConnectionPort
Callback         Directory
CLDMSGPORT       FilterConnectionPort
clfs             Device
CsrSbSyncEvent   Event
Device           Directory
Dfs              SymbolicLink
DosDevices       SymbolicLink
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-4: Listing the root OMNS directory</span></p>
<p class="TX"><a href="chapter2.xhtml#Lis2-4">Listing 2-4</a> shows a short snippet of the root OMNS directory. By default, this output includes the name of each object and its type. We can see a few <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp> objects; you can list them if you have permission to do so. We can also see another important type, <samp class="SANS_TheSansMonoCd_W5Regular_11">SymbolicLink</samp>. You can use symbolic links to redirect one OMNS path to another. A <samp class="SANS_TheSansMonoCd_W5Regular_11">SymbolicLink</samp> object contains a <samp class="SANS_TheSansMonoCd_W5Regular_11">SymbolicLinkTarget</samp> property, which itself contains the target that the link should open. For example, <a href="chapter2.xhtml#Lis2-5">Listing 2-5</a> shows the target for a symbolic link in the root of the OMNS.</p>
<span id="Lis2-5"></span><pre><code>PS&gt; <b>ls NtObject:\Dfs | Select-Object SymbolicLinkTarget</b>
SymbolicLinkTarget
------------------
\Device\DfsClient

<span aria-label=" Page 29. " epub:type="pagebreak" id="pg_29" role="doc-pagebreak"></span>PS&gt; <b>Get-Item NtObject:\Device\DfsClient | Format-Table</b>
Name      TypeName
----      --------
DfsClient Device
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-5: Showing the target of a symbolic link</span></p>
<p class="TX">Here, we list the <i>\Dfs</i> OMNS path, then extract the <samp class="SANS_TheSansMonoCd_W5Regular_11">SymbolicLinkTarget</samp> property to get the real target. Next, we check the target path, <i>Device\DfsClient</i>, to show it’s a <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp> type, which is what the symbolic link can be used to access.</p>
<p class="TX">Windows preconfigures several important object directories, shown in <a href="chapter2.xhtml#tab2-2">Table 2-2</a>.</p>
<table class="Basic-Table">
<caption><p class="TT" id="tab2-2"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 2-2:</samp></span> <samp class="SANS_Futura_Std_Book_11">Well-Known Object Directories and Descriptions</samp></p></caption>
<thead>
<tr>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Path</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">\BaseNamedObjects</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Global directory for user objects</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">\Device</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Directory containing devices such as mounted filesystems</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">\GLOBAL??</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Global directory for symbolic links, including drive mappings</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">\KnownDlls</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Directory containing special, known DLL mappings</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">\ObjectTypes</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Directory containing named object types</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">\Sessions</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Directory for separate console sessions</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">\Windows</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Directory for objects related to the Window Manager</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">\RPC Control</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Directory for remote procedure call endpoints</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">The first directory in <a href="chapter2.xhtml#tab2-2">Table 2-2</a>, <i>BaseNamedObjects (BNO)</i>, is important in the context of the object manager. It allows any user to create named kernel objects. This single directory allows the sharing of resources between different users on the local system. Note that you don’t have to create objects in the BNO directory; it’s only a convention.</p>
<p class="TX">I’ll describe the other object directories in more detail later in this chapter. For now, you can list them in PowerShell by prefixing the path with <i>NtObject:</i>, as I’ve shown in <a href="chapter2.xhtml#Lis2-5">Listing 2-5</a>.</p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h4 class="H2" id="sec6"><span id="h2-10"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">System Calls</samp></h4>
<p class="TNI1">How can we access the named objects in the OMNS from a user-mode application? If we’re in a user-mode application, we need the kernel to access the objects, and we can call kernel-mode code in a user-mode application using the system call interface. Most system calls perform some operation on a specific type of kernel object exposed by the object manager. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp> system call creates a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> object, a mutual exclusion primitive used for locking and thread synchronization.</p>
<p class="TX">The name of a system call follows a common pattern. It starts with either <samp class="SANS_TheSansMonoCd_W5Regular_11">Nt</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp>. For user-mode callers, the two prefixes are equivalent; <span aria-label=" Page 30. " epub:type="pagebreak" id="pg_30" role="doc-pagebreak"></span>however, if the system call is invoked by code executing in the kernel, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp> prefix changes the security checking process. We’ll come back to the implications of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp> prefix in <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>, when we talk about access modes.</p>
<p class="TX">After the prefix comes the operation’s verb: <samp class="SANS_TheSansMonoCd_W5Regular_11">Create</samp>, in the case of <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>. The rest of the name relates to the kernel object type the system call operates on. Common system-call verbs that perform an operation on a kernel object include:</p>
<p class="RunInPara1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Create  </samp>Creates a new object. Maps to <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Nt</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;Type&gt;</samp> PowerShell commands.</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Open  </samp>Opens an existing object. Maps to <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Nt</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;Type&gt;</samp> PowerShell commands.</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">QueryInformation  </samp>Queries object information and properties.</p>
<p class="RunInPara2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">SetInformation  </samp>Sets object information and properties.</p>
<p class="TX">Certain system calls perform type-specific operations. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryDirectoryFile</samp> is used to query the entries in a <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp> object directory. Let’s look at the C-language prototype for the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp> system call to understand what parameters need to be passed to a typical call. As shown in <a href="chapter2.xhtml#Lis2-6">Listing 2-6</a>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp> system call creates a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> object.</p>
<span id="Lis2-6"></span><pre><code>NTSTATUS NtCreateMutant(
    HANDLE* FileHandle,
    ACCESS_MASK DesiredAccess,
    OBJECT_ATTRIBUTES* ObjectAttributes,
    BOOLEAN InitialOwner
);
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-6: The C prototype for NtCreateMutant</span></p>
<p class="TX">The first parameter for the system call is an outbound pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">HANDLE</samp>. Common in many system calls, this parameter is used to retrieve an opened handle to the object (in this case, a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>) when the function succeeds. We use handles along with other system calls to access properties and perform operations. In the case of our <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> object, the handle allows us to acquire and release the lock to synchronize threads.</p>
<p class="TX">Next is <samp class="SANS_TheSansMonoCd_W5Regular_11">DesiredAccess</samp>, which represents the operations the caller wants to be able to perform on the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> using the handle. For example, we could request access that allows us to wait for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> to be unlocked. If we didn’t request that access, any application that tried to wait on the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> would immediately fail. The access granted depends on the results of the SRM’s access check. We’ll discuss handles and <samp class="SANS_TheSansMonoCd_W5Regular_11">DesiredAccess</samp> in more detail in the next section.</p>
<p class="TX">Third is the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectAttributes</samp> parameter, which defines the attributes for the object to open or create. The <samp class="SANS_TheSansMonoCd_W5Regular_11">OBJECT_ATTRIBUTES</samp> structure is defined as shown in <a href="chapter2.xhtml#Lis2-7">Listing 2-7</a>.</p>
<span id="Lis2-7"></span><pre><code><span aria-label=" Page 31. " epub:type="pagebreak" id="pg_31" role="doc-pagebreak"></span>struct OBJECT_ATTRIBUTES {
    ULONG           Length;
    HANDLE          RootDirectory;
    UNICODE_STRING* ObjectName;
    ULONG           Attributes;
    PVOID           SecurityDescriptor;
    PVOID           SecurityQualityOfService;
}
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-7: The OBJECT_ATTRIBUTES structure</span></p>
<p class="TX">This C-language structure starts with <samp class="SANS_TheSansMonoCd_W5Regular_11">Length</samp>, which represents the length of the structure. Specifying the structure length at the start is a common C-style idiom to ensure that the correct structure has been passed to the system call.</p>
<p class="TX">Next come <samp class="SANS_TheSansMonoCd_W5Regular_11">RootDirectory</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectName</samp>. These are taken together, as they indicate how the system call should look up the resource being accessed. The <samp class="SANS_TheSansMonoCd_W5Regular_11">RootDirectory</samp> is a handle to an opened kernel object to use as the base for looking up the object. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectName</samp> field is a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">UNICODE_STRING</samp> structure. This is a counted string, defined in <a href="chapter2.xhtml#Lis2-8">Listing 2-8</a> as a C-language structure.</p>
<span id="Lis2-8"></span><pre><code>struct UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    WCHAR* Buffer;
};
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-8: The UNICODE_STRING structure</span></p>
<p class="TX">The structure references the string data through <samp class="SANS_TheSansMonoCd_W5Regular_11">Buffer</samp>, which is a pointer to an array of 16-bit Unicode characters. The string is represented in UCS-2 encoding; Windows predates many of the changes to Unicode, such as UTF-8 and UTF-16.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">UNICODE_STRING</samp> structure also contains two length fields, <samp class="SANS_TheSansMonoCd_W5Regular_11">Length</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">MaximumLength</samp>. The first length field represents the total valid length of the string pointed to by <samp class="SANS_TheSansMonoCd_W5Regular_11">Buffer</samp>, in bytes (not in Unicode characters). If you’re coming from a C programming background, this length does not include any NUL terminating character. In fact, a NUL character is permitted in object names.</p>
<p class="TX">The second length field represents the maximum length of the string pointed to by <samp class="SANS_TheSansMonoCd_W5Regular_11">Buffer</samp>, in bytes. Because the structure has two separate lengths, it’s possible to allocate an empty string with a large maximum length and a valid length of zero, then update the string value using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Buffer</samp> pointer. Note that the lengths are stored as <samp class="SANS_TheSansMonoCd_W5Regular_11">USHORT</samp> values, which are unsigned 16-bit integers. Coupled with the length-representing bytes, this means a string can be at most 32,767 characters long.</p>
<p class="TX">To specify the name of an object, you have two options: you can set <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectName</samp> to an absolute path of, for example, <i>\BaseNamedObjects\ABC</i>, or <span aria-label=" Page 32. " epub:type="pagebreak" id="pg_32" role="doc-pagebreak"></span>you can set <samp class="SANS_TheSansMonoCd_W5Regular_11">RootDirectory</samp> to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp> object for <i>\BaseNamedObjects</i> and then pass <samp class="SANS_TheSansMonoCd_W5Regular_11">ABC</samp> as the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectName</samp>. These two actions will open the same object.</p>
<p class="TX">Returning to <a href="chapter2.xhtml#Lis2-7">Listing 2-7</a>, after the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectName</samp> parameter comes <samp class="SANS_TheSansMonoCd_W5Regular_11">Attributes</samp>, which is a set of flags to modify the object name lookup process or change the returned handle’s properties. <a href="chapter2.xhtml#tab2-3">Table 2-3</a> shows the valid values for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Attributes</samp> field.</p>
<table class="Basic-Table">
<caption><p class="TT" id="tab2-3"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 2-3:</samp></span> <samp class="SANS_Futura_Std_Book_11">Object Attribute Flags and Descriptions</samp></p></caption>
<thead>
<tr>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">PowerShell name</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Inherit</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Marks the handle as inheritable.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Permanent</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Marks the handle as permanent.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Exclusive</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Marks the handle as exclusive if creating a new object. Only the same process can open a handle to the object.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">CaseInsensitive</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Looks up the object name in a case-insensitive manner.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">OpenIf</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">If using a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Create</samp> <samp class="SANS_Futura_Std_Book_11">call, opens a handle to an existing object if available.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">OpenLink</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Opens the object if it’s a link to another object; otherwise, follows the link. This is used only by the configuration manager.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">KernelHandle</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Opens the handle as a kernel handle when used in kernel mode. This prevents user-mode applications from accessing the handle directly.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">ForceAccessCheck</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">When used in kernel mode, ensures all access checks are performed, even if calling the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp> <samp class="SANS_Futura_Std_Book_11">version of the system call.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">IgnoreImpersonatedDeviceMap</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Disables the device map when impersonating.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">DontReparse</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Indicates not to follow any path that contains a symbolic link.</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">The final two fields in the <samp class="SANS_TheSansMonoCd_W5Regular_11">OBJECT_ATTRIBUTES</samp> structure allow the caller to specify the Security Quality of Service (SQoS) and security descriptor for the object. We’ll come back to SQoS in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span> and the security descriptor in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>.</p>
<p class="TX">Next in the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp> system call in <a href="chapter2.xhtml#Lis2-6">Listing 2-6</a> is the <samp class="SANS_TheSansMonoCd_W5Regular_11">InitialOwner</samp> Boolean parameter, which is specific to this type. In this case, it represents whether the created <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> is owned by the caller or not. Many other system calls, especially for files, have more complex parameters, which we’ll discuss in more detail later in the book.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h4 class="H2" id="sec7"><span id="h2-11"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">NTSTATUS Codes</samp></h4>
<p class="TNI1">All system calls return a 32-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS</samp> code. This status code is composed of multiple components packed into the 32 bits, as shown in <a href="chapter2.xhtml#fig2-3">Figure 2-3</a>.</p>
<span aria-label=" Page 33. " epub:type="pagebreak" id="pg_33" role="doc-pagebreak"></span>
<figure class="IMG"><img alt="" class="img1" height="248" id="fig2-3" src="../images/Figure2-3.jpg" width="1387"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-3: The NT status code structure</samp></p></figcaption>
</figure>
<p class="TX">The most significant two bits (31 and 30) indicate the <i>severity</i> of the status code. <a href="chapter2.xhtml#tab2-4">Table 2-4</a> shows the available values.</p>
<table class="Basic-Table">
<caption><p class="TT" id="tab2-4"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 2-4:</samp></span> <samp class="SANS_Futura_Std_Book_11">NT Status Severity Codes</samp></p></caption>
<thead>
<tr>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Severity name</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Value</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_SEVERITY_SUCCESS</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_SEVERITY_INFORMATIONAL</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_SEVERITY_WARNING</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_SEVERITY_ERROR</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">If the severity level indicates a warning or error, then bit 31 of the status code will be set to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. If the status code is treated as a signed 32-bit integer, this bit represents a negative value. It’s a common coding practice to assume that if the status code is negative it represents an error, and if it’s positive it represents a success. As we can see from the table, this assumption isn’t completely true—the negative status code could also be a warning—but it works well enough in practice.</p>
<p class="TX">The next component in <a href="chapter2.xhtml#fig2-3">Figure 2-3</a>, <i>CC</i>, is the customer code. This is a single-bit flag that indicates whether the status code is defined by Microsoft (a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>) or defined by a third party (a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>). Third parties are not obliged to follow this specification, so don’t treat it as fact.</p>
<p class="TX">Following the customer code is the <i>R</i> bit, a reserved bit that must be set to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.</p>
<p class="TX">The next 12 bits indicate the <i>facility</i>—that is, the component or subsystem associated with the status code. Microsoft has predefined around 50 facilities for its own purposes. Third parties should define their own facility and combine it with the customer code to distinguish themselves from Microsoft. <a href="chapter2.xhtml#tab2-5">Table 2-5</a> shows a few commonly encountered facilities.</p>
<table class="Basic-Table">
<caption><p class="TT" id="tab2-5"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 2-5:</samp></span> <samp class="SANS_Futura_Std_Book_11">Common Status Facility Values</samp></p></caption>
<thead>
<tr>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Facility name</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Value</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">FACILITY_DEFAULT</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">The default used for common status codes</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">FACILITY_DEBUGGER</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Used for codes associated with the debugger</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">FACILITY_NTWIN32</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">7</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Used for codes that originated from the Win32 APIs</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">The final component, the <i>status code</i>, is a 16-bit number chosen to be unique for the facility. It’s up to the implementer to define what each <span aria-label=" Page 34. " epub:type="pagebreak" id="pg_34" role="doc-pagebreak"></span>number means. The PowerShell module contains a list of known status codes, which we can query using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtStatus</samp> command with no parameters (<a href="chapter2.xhtml#Lis2-9">Listing 2-9</a>).</p>
<span id="Lis2-9"></span><pre><code>PS&gt; <b>Get-NtStatus</b>
Status     StatusName                Message
------     ----------                -------
00000000   STATUS_SUCCESS            STATUS_SUCCESS
00000001   STATUS_WAIT_1             STATUS_WAIT_1
00000080   STATUS_ABANDONED_WAIT_0   STATUS_ABANDONED_WAIT_0
000000C0   STATUS_USER_APC           STATUS_USER_APC
000000FF   STATUS_ALREADY_COMPLETE   The requested action was completed by...
00000100   STATUS_KERNEL_APC         STATUS_KERNEL_APC
00000101   STATUS_ALERTED            STATUS_ALERTED
00000102   STATUS_TIMEOUT            STATUS_TIMEOUT
00000103   STATUS_PENDING            The operation that was requested is p...
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-9: Example output from Get-NtStatus</span></p>
<p class="TX">Notice how some status values, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_PENDING</samp>, have a human-readable message. This message isn’t embedded in the PowerShell module; instead, it’s stored inside a Windows library and can be extracted at runtime.</p>
<p class="TX">When we call a system call via a PowerShell command, its status code is surfaced through a .NET exception. For example, if we try to open a <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp> object that doesn’t exist, we’ll see the exception shown in <a href="chapter2.xhtml#Lis2-10">Listing 2-10</a> displayed in the console.</p>
<span id="Lis2-10"></span><pre><code>PS&gt; <b>Get-NtDirectory \THISDOESNOTEXIST</b>
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> Get-NtDirectory : (0xC0000034) - Object Name not found.
<var>--snip--</var>

PS&gt; <b>Get-NtStatus 0xC0000034 | Format-List</b>
Status         : 3221225524
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> StatusSigned   : -1073741772
StatusName     : STATUS_OBJECT_NAME_NOT_FOUND
Message        : Object Name not found.
Win32Error     : ERROR_FILE_NOT_FOUND
Win32ErrorCode : 2
Code           : 52
CustomerCode   : False
Reserved       : False
Facility       : FACILITY_DEFAULT
Severity       : STATUS_SEVERITY_ERROR
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-10: An NTSTATUS exception generated when trying to open a nonexistent directory</span></p>
<p class="TX">In <a href="chapter2.xhtml#Lis2-10">Listing 2-10</a>, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtDirectory</samp> to open the nonexistent path <i>THISDOESNOTEXIST</i>. This generates the <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS 0xC0000034</samp> exception, shown here along with the decoded message <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. If you want more information about the status code, you can pass it to <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtStatus</samp> and format the <span aria-label=" Page 35. " epub:type="pagebreak" id="pg_35" role="doc-pagebreak"></span>output as a list to view all its properties, including <samp class="SANS_TheSansMonoCd_W5Regular_11">Facility</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Severity</samp>. The NT status code is an unsigned integer value; however, it’s common to also see it printed (incorrectly) as a signed value <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h4 class="H2" id="sec8"><span id="h2-12"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Object Handles</samp></h4>
<p class="TNI1">The object manager deals with pointers to kernel memory. A user-mode application cannot directly read or write to kernel memory, so how can it access an object? It does this using the handle returned by a system call, as discussed in the previous section. Each running process has an associated <i>handle table</i> containing three pieces of information:</p>
<ul class="ul">
<li class="ListBullet">The handle’s numeric identifier</li>
<li class="ListBullet">The granted access to the handle; for example, read or write</li>
<li class="ListBullet">The pointer to the object structure in kernel memory</li>
</ul>
<p class="TX">Before the kernel can use a handle, the system call implementation must look up the kernel object pointer from the handle table using a kernel API such as <samp class="SANS_TheSansMonoCd_W5Regular_11">ObReferenceObjectByHandle</samp>. By providing this handle indirectly, a kernel component can return the handle number to the user-mode application without exposing the kernel object directly. <a href="chapter2.xhtml#fig2-4">Figure 2-4</a> shows the handle lookup process.</p>
<figure class="IMG"><img alt="" class="img1" height="830" id="fig2-4" src="../images/Figure2-4.jpg" width="1389"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-4: The handle table lookup process</samp></p></figcaption>
</figure>
<p class="TX">In <a href="chapter2.xhtml#fig2-4">Figure 2-4</a>, the user process is trying to perform some operation on a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> object. When a user process wants to use a handle, it must first pass the handle’s value to the system call we defined in the previous section <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. The system call implementation then calls a kernel API to convert the handle to a kernel pointer by referencing the handle’s numeric value in the process’s handle table <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>.</p>
<p class="TX"><span aria-label=" Page 36. " epub:type="pagebreak" id="pg_36" role="doc-pagebreak"></span>To determine whether to grant the access, the conversion API considers the type of access that the user has requested for the system call’s operation, as well as the type of object being accessed. If the requested access doesn’t match the granted access recorded in the handle table entry, the API will return <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_ACCESS_DENIED</samp> and the conversion operation will fail. Likewise, if the object types don’t match <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>, the API will return <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_OBJECT_TYPE_MISMATCH</samp>.</p>
<p class="TX">These two checks are crucial for security. The access check ensures that the user can’t perform an operation on a handle to which they don’t have access (for example, writing to a file for which they have only read access). The type check ensures the user hasn’t passed an unrelated kernel object type, which might result in type confusion in the kernel, causing security issues such as memory corruption. If the conversion succeeds, the system call now has a kernel pointer to the object, which it can use to perform the user’s requested operation.</p>
<section aria-labelledby="sec9" epub:type="division">
<h5 class="H3" id="sec9"><span id="h3-1"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Access Masks</samp></h5>
<p class="TNI1">The granted access value in the handle table is a 32-bit bitfield called an <i>access mask</i>. This is the same bitfield used for the <samp class="SANS_TheSansMonoCd_W5Regular_11">DesiredAccess</samp> parameter specified in the system call. We’ll discuss how <samp class="SANS_TheSansMonoCd_W5Regular_11">DesiredAccess</samp> and the access check process determine the granted access in more detail in <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>.</p>
<p class="TX">An access mask has four components, as shown in <a href="chapter2.xhtml#fig2-5">Figure 2-5</a>.</p>
<figure class="IMG"><img alt="" class="img1" height="234" id="fig2-5" src="../images/Figure2-5.jpg" width="1376"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-5: The access mask structure</samp></p></figcaption>
</figure>
<p class="TX">The most important one is the 16-bit <i>type-specific access component</i>, which defines the operations that are allowed on a particular kernel object type. For example, a <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp> object might have separate bits to specify whether the file is allowed to be read or written to when using the handle. In contrast, a synchronization <samp class="SANS_TheSansMonoCd_W5Regular_11">Event</samp> might only have a single bit that allows the event to be signaled.</p>
<p class="TX">Working backward, the <i>standard access</i> component of the access mask defines operations that can apply to any object type. These operations include:</p>
<p class="RunInPara1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Delete  </samp>Removes the object; for example, by deleting it from disk or from the registry</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadControl  </samp>Reads the security descriptor information for the object</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">WriteDac  </samp>Writes the security descriptor’s discretionary access control (DAC) to the object</p>
<p class="RunInPara"><span aria-label=" Page 37. " epub:type="pagebreak" id="pg_37" role="doc-pagebreak"></span><samp class="SANS_TheSansMonoCd_W7Bold_B_11">WriteOwner  </samp>Writes the owner information to the object</p>
<p class="RunInPara2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Synchronize  </samp>Waits on the object; for example, waits for a process to exit or a mutant to be unlocked</p>
<p class="TX">We’ll cover security-related access in more detail in <span class="Xref"><a href="chapter5.xhtml">Chapters 5</a></span> and <span class="Xref"><a href="chapter6.xhtml">6</a></span>.</p>
<p class="TX">Before this are the <i>reserved</i> and <i>special access</i> bits. Most of these bits are reserved, but they include two access values:</p>
<p class="RunInPara1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">AccessSystemSecurity  </samp>Reads or writes audit information on the object</p>
<p class="RunInPara2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">MaximumAllowed  </samp>Requests the maximum access to an object when performing an access check</p>
<p class="TX">We’ll cover <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp> access in <span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span> and <samp class="SANS_TheSansMonoCd_W5Regular_11">MaximumAllowed</samp> access in <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>.</p>
<p class="TX">Finally, the four high-order bits of the access mask (the <i>generic access</i> component) are used only when requesting access to a kernel object using the system call’s <samp class="SANS_TheSansMonoCd_W5Regular_11">DesiredAccess</samp> parameter. There are four broad categories of access: <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericWrite</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericExecute</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp>.</p>
<p class="TX">When you request one of these generic access rights, the SRM will first convert the access into the corresponding type-specific access. This means you’ll never receive access to a handle with <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp>; instead, you’ll be granted access to the specific access mask that represents read operations for that type. To facilitate the conversion, each type contains a <i>generic mapping table</i>, which maps the four generic categories to type-specific access. We can display the mapping table using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtType</samp>, as shown in <a href="chapter2.xhtml#Lis2-11">Listing 2-11</a>.</p>
<span id="Lis2-11"></span><pre><code>PS&gt; <b>Get-NtType | Select-Object Name, GenericMapping</b>
Name                            GenericMapping
----                            --------------
Type                            R:00020000 W:00020000 E:00020000 A:000F0001
Directory                       R:00020003 W:0002000C E:00020003 A:000F000F
SymbolicLink                    R:00020001 W:00020000 E:00020001 A:000F0001
Token                           R:0002001A W:000201E0 E:00020005 A:000F01FF
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-11: Displaying the generic mapping table for object types</span></p>
<p class="TX">The type data doesn’t provide names for each specific access mask. However, for all common types, the PowerShell module provides an enumerated type that represents the type-specific access. We can access this type through the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtTypeAccess</samp> command. <a href="chapter2.xhtml#Lis2-12">Listing 2-12</a> shows an example for the <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp> type.</p>
<span id="Lis2-12"></span><pre><code>PS&gt; <b>Get-NtTypeAccess -Type File</b>
Mask       Value                GenericAccess
----       -----                -------------
00000001   ReadData             Read, All
00000002   WriteData            Write, All
00000004   AppendData           Write, All
00000008   ReadEa               Read, All
00000010   WriteEa              Write, All
<span aria-label=" Page 38. " epub:type="pagebreak" id="pg_38" role="doc-pagebreak"></span>00000020   Execute              Execute, All
00000040   DeleteChild          All
00000080   ReadAttributes       Read, Execute, All
00000100   WriteAttributes      Write, All
00010000   Delete               All
00020000   ReadControl          Read, Write, Execute, All
00040000   WriteDac             All
00080000   WriteOwner           All
00100000   Synchronize          Read, Write, Execute, All
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-12: Displaying the access mask for the File object type</span></p>
<p class="TX">The output of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtTypeAccess</samp> command shows the access mask value, the name of the access as known to the PowerShell module, and the generic access from which it will be mapped. Note how some access types are granted only to <samp class="SANS_TheSansMonoCd_W5Regular_11">All</samp>; this means that even if you requested generic read, write, and execute access, you wouldn’t be granted access to those rights.</p>
<aside aria-label="box-10" class="box">
<p class="BoxTitle" id="box-10"><samp class="SANS_Dogma_OT_Bold_B_11">SOFTWARE DEVELOPMENT KIT NAMES</samp></p>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To improve usability, the PowerShell module has modified the original names of the access rights found in the Windows software development kit (SDK). You can view the equivalent SDK names using the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">SDKName</samp> <samp class="SANS_Futura_Std_Book_11">property with the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtTypeAccess</samp> <samp class="SANS_Futura_Std_Book_11">command:</samp></p>
<pre><code><samp class="SANS_TheSansMonoCd_W5Regular_11">PS&gt;</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Get-NtTypeAccess -Type File | Select SDKName, Value</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">SDKName                  Value</samp>
-------                  -----
<samp class="SANS_TheSansMonoCd_W5Regular_11">FILE_READ_DATA        ReadData</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">FILE_WRITE_DATA      WriteData</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">FILE_APPEND_DATA    AppendData</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">--snip--</samp>
</code></pre>
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">These name mappings are useful for porting native code to PowerShell.</samp></p>
</aside>
<p class="TX">You can convert between a numeric access mask and specific object types using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtAccessMask</samp> command, as shown in <a href="chapter2.xhtml#Lis2-13">Listing 2-13</a>.</p>
<span id="Lis2-13"></span><pre><code>PS&gt; <b>Get-NtAccessMask -FileAccess ReadData, ReadAttributes, ReadControl</b>
Access
------
00020081

PS&gt; <b>Get-NtAccessMask -FileAccess GenericRead</b>
Access
------
80000000

<span aria-label=" Page 39. " epub:type="pagebreak" id="pg_39" role="doc-pagebreak"></span>PS&gt; <b>Get-NtAccessMask -FileAccess GenericRead -MapGenericRights</b>
Access
------
00120089

PS&gt; <b>Get-NtAccessMask 0x120089 -AsTypeAccess File</b>
ReadData, ReadEa, ReadAttributes, ReadControl, Synchronize
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-13: Converting access masks using Get-NtAccessMask</span></p>
<p class="TX">In <a href="chapter2.xhtml#Lis2-13">Listing 2-13</a>, we first request the access mask from a set of <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp> access names and receive the numeric access mask in hexadecimal. Next, we get the access mask for the <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp> access; as you can see, the value returned is just the numeric value of <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp>. We then request the access mask for <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp> but specify that we want to map the generic access to a specific access by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">MapGenericRights</samp> parameter. As we’ve specified the access for the <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp> type, this command uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp> type’s generic mapping to convert to the specific access mask. Finally, we convert the raw access mask back to a type access using the <samp class="SANS_TheSansMonoCd_W5Regular_11">AsTypeAccess</samp> parameter, specifying the kernel type to use.</p>
<p class="TX">As shown in <a href="chapter2.xhtml#Lis2-14">Listing 2-14</a>, you can query an object handle’s granted access mask through the PowerShell object’s <samp class="SANS_TheSansMonoCd_W5Regular_11">GrantedAccess</samp> property. This returns the enumerated type format for the access mask. To retrieve the numeric value, use the <samp class="SANS_TheSansMonoCd_W5Regular_11">GrantedAccessMask</samp> property.</p>
<span id="Lis2-14"></span><pre><code>PS&gt; <b>$mut = New-NtMutant</b>
PS&gt; <b>$mut.GrantedAccess</b>
ModifyState, Delete, ReadControl, WriteDac, WriteOwner, Synchronize

PS&gt; <b>$mut.GrantedAccessMask</b>
Access
------
001F0001
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-14: Displaying the numeric value of the access mask using GrantedAccessMask</span></p>
<p class="TX">The kernel provides a facility to dump all handle table entries on the system through the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySystemInformation</samp> system call. We can access the handle table from PowerShell using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtHandle</samp> command, as illustrated in <a href="chapter2.xhtml#Lis2-15">Listing 2-15</a>.</p>
<span id="Lis2-15"></span><pre><code>PS&gt; <b>Get-NtHandle -ProcessId $pid</b>
ProcessId  Handle     ObjectType           Object               GrantedAccess
---------  ------     ----------           ------               -------------
22460      4          Process              FFFF800224F02080     001FFFFF
22460      8          Thread               FFFF800224F1A140     001FFFFF
22460      12         SymbolicLink         FFFF9184AC639FC0     000F0001
22460      16         Mutant               FFFF800224F26510     001F0001
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-15: Displaying the handle table for the current process using Get-NtHandle</span></p>
<p class="TX"><span aria-label=" Page 40. " epub:type="pagebreak" id="pg_40" role="doc-pagebreak"></span>Each handle entry contains the type of the object, the address of the kernel object in kernel memory, and the granted access mask.</p>
<p class="TX">Once an application has finished with a handle, it can be closed using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtClose</samp> API. If you’ve received a PowerShell object from a <samp class="SANS_TheSansMonoCd_W5Regular_11">Get</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">New</samp> call, then you can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Close</samp> method on the object to close the handle. You can also close an object handle automatically in PowerShell by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Use-NtObject</samp> command to invoke a script block that closes the handle once it finishes executing. <a href="chapter2.xhtml#Lis2-16">Listing 2-16</a> provides examples of both approaches.</p>
<span id="Lis2-16"></span><pre><code>PS&gt; <b>$m = New-NtMutant \BaseNamedObjects\ABC</b>
PS&gt; <b>$m.IsClosed</b>
False

PS&gt; <b>$m.Close()</b>
PS&gt; <b>$m.IsClosed</b>
True

PS&gt; <b>Use-NtObject($m = New-NtMutant \BaseNamedObjects\ABC) {</b>
    <b>$m.FullPath</b>
<b>}</b>
\BaseNamedObjects\ABC

PS&gt; <b>$m.IsClosed</b>
True
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-16: Closing an object handle</span></p>
<p class="TX">If you do not close handles manually, the .NET garbage collector will close them automatically for objects that are not referenced (for example, held in a PowerShell variable). You should get into the habit of manually closing handles, though; otherwise, you might have to wait a long time for the resources to be released, as the garbage collector could run at any time.</p>
<p class="TX">If the kernel object structure is no longer referenced, either through a handle or by a kernel component, then the object will also be destroyed. Once an object is destroyed, all its allocated memory is cleaned up and, if it exists, its name in the OMNS is removed.</p>
<aside aria-label="box-11" class="box">
<p class="BoxTitle" id="box-11"><samp class="SANS_Dogma_OT_Bold_B_11">PERMANENT OBJECTS</samp></p>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">It is possible to get the kernel to mark an object as permanent, preventing the object from being destroyed when all handles close and allowing its name to remain in the OMNS. To make an object permanent, you need to either specify the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Permanent</samp> <samp class="SANS_Futura_Std_Book_11">attribute flag when creating the object or use the system call</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">NtMakePermanentObject</samp><samp class="SANS_Futura_Std_Book_11">, which is mapped to the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePermanent</samp> <samp class="SANS_Futura_Std_Book_11">call on any object handle returned by a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Get</samp> <samp class="SANS_Futura_Std_Book_11">or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">New</samp> <samp class="SANS_Futura_Std_Book_11">command. You need a special privilege,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">SeCreatePermanentPrivilege</samp><samp class="SANS_Futura_Std_Book_11">, to do this; we’ll discuss privileges in <a href="chapter4.xhtml">Chapter 4</a>.</samp></p>
<p class="BoxBody"><span aria-label=" Page 41. " epub:type="pagebreak" id="pg_41" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Book_11">The reverse operation,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">NtMakeTemporaryObject</samp> <samp class="SANS_Futura_Std_Book_11">(or the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">MakeTemporary</samp> <samp class="SANS_Futura_Std_Book_11">method in PowerShell), removes the permanent setting and allows an object to be destroyed. The destruction won’t happen until all handles to the object have closed. This operation doesn’t require any special privileges, but it does require</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Delete</samp> <samp class="SANS_Futura_Std_Book_11">access on the object to succeed.</samp></p>
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">Note that</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp> <samp class="SANS_Futura_Std_Book_11">and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Key</samp> <samp class="SANS_Futura_Std_Book_11">objects always have permanent names as they don’t exist in the OMNS; to remove the names for these types of objects, you must use a system call to explicitly delete them.</samp></p>
</aside>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h5 class="H3" id="sec10"><span id="h3-2"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Handle Duplication</samp></h5>
<p class="TNI1">You can duplicate handles using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtDuplicateObject</samp> system call. The primary reason you might want to do this is to allow a process to take an additional reference to a kernel object. The kernel object won’t be destroyed until all handles to it are closed, so creating a new handle maintains the kernel object.</p>
<p class="TX">Handle duplication can additionally be used to transfer handles between processes if the source and destination process handles have <samp class="SANS_TheSansMonoCd_W5Regular_11">DupHandle</samp> access. You can also use handle duplication to reduce the access rights on a handle. For example, when you pass a file handle to a new process, you could grant the duplicated handle only read access, preventing the new process from writing to the object. However, you should not rely on this approach for reducing the handle’s granted access; if the process with the handle has access to the resource, it can just reopen it to get write access.</p>
<p class="TX"><a href="chapter2.xhtml#Lis2-17">Listing 2-17</a> shows some examples of using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy-NtObject</samp> command, which wraps <samp class="SANS_TheSansMonoCd_W5Regular_11">NtDuplicateObject</samp>, to perform some duplication in the same process. We’ll come back to handle duplication and security checks in <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span>.</p>
<span id="Lis2-17"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$mut = New-NtMutant "\BaseNamedObjects\ABC"</b>
PS&gt; <b>$mut.GrantedAccess</b>
ModifyState, Delete, ReadControl, WriteDac, WriteOwner, Synchronize

<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>Use-NtObject($dup = Copy-NtObject $mut) {</b>
    <b>$mut</b>
    <b>$dup</b>
    <b>Compare-NtObject $mut $dup</b>
<b>}</b>
Handle Name NtTypeName Inherit ProtectFromClose
------ ---- ---------- ------- ----------------
1616   ABC  Mutant     False   False
2212   ABC  Mutant     False   False
True

<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>$mask = Get-NtAccessMask -MutantAccess ModifyState</b>
PS&gt; <b>Use-NtObject($dup = Copy-NtObject $mut -DesiredAccessMask $mask) {</b>
<span aria-label=" Page 42. " epub:type="pagebreak" id="pg_42" role="doc-pagebreak"></span>    <b>$dup.GrantedAccess</b>
    <b>Compare-NtObject $mut $dup</b>
<b>}</b>
ModifyState
True
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-17: Using Copy-NtObject to duplicate handles</span></p>
<p class="TX">First, we create a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> object to test handle duplication and extract the current granted access, which shows six access rights <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. For the initial duplication, we’ll keep the same granted access <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. You can see in the first column of the output that the handles are different. However, our call to <samp class="SANS_TheSansMonoCd_W5Regular_11">Compare-NtObject</samp> to determine whether the two handles refer to the same underlying kernel object returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>. Next, we get an access mask for <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant ModifyState</samp> access and duplicate the handle, requesting that access <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. We can see in the output that the granted access is now only <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState</samp>. However, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Compare-NtObject</samp> return value still indicates the handles refer to the same object.</p>
<p class="TX">Also relevant to handle duplication are the handle attributes <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherit</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ProtectFromClose</samp>. Setting <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherit</samp> allows a new process to inherit the handle when it’s created. This allows you to pass handles to a new process to perform tasks such as redirecting console output text to a file.</p>
<p class="TX">Setting <samp class="SANS_TheSansMonoCd_W5Regular_11">ProtectFromClose</samp> protects the handle from being closed. You can set this attribute by setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">ProtectFromClose</samp> property on the object, which will set the attribute on the native handle. <a href="chapter2.xhtml#Lis2-18">Listing 2-18</a> shows an example of its use.</p>
<span id="Lis2-18"></span><pre><code>PS&gt; <b>$mut = New-NtMutant</b>
PS&gt; <b>$mut.ProtectFromClose = $true</b>
PS&gt; <b>Close-NtObject -SafeHandle $mut.Handle -CurrentProcess</b>
STATUS_HANDLE_NOT_CLOSABLE
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-18: Testing the ProtectFromClose handle attribute</span></p>
<p class="TX">Any attempt to close the handle will fail with a <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_HANDLE_NOT_CLOSABLE</samp> status code, and the handle will stay open.</p>
</section>
</section>
<section aria-labelledby="sec11" epub:type="division">
<h4 class="H2" id="sec11"><span id="h2-13"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Query and Set Information System Calls</samp></h4>
<p class="TNI1">A kernel object typically stores information about its state. For example, a <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> object stores a timestamp of when it was created. To allow us to retrieve this information, the kernel could have implemented a specific “get process creation time” system call. However, due to the volume of information stored for the various types of objects, this approach would quickly become unworkable.</p>
<p class="TX">Instead, the kernel implements generic <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Set</samp> information system calls whose parameters follow a common pattern for all kernel object types. <a href="chapter2.xhtml#Lis2-19">Listing 2-19</a> shows the <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp> information system call’s pattern, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> type as an example; for other types, just replace <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> with the name of the kernel type.</p>
<span id="Lis2-19"></span><pre><code><span aria-label=" Page 43. " epub:type="pagebreak" id="pg_43" role="doc-pagebreak"></span>NTSTATUS NtQueryInformationProcess(
    HANDLE                    Handle,
    PROCESS_INFORMATION_CLASS InformationClass,
    PVOID                     Information,
    ULONG                     InformationLength,
    PULONG                    ReturnLength
)
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-19: An example Query information system call for the Process type</span></p>
<p class="TX">All <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp> information system calls take an object handle as the first parameter. The second parameter, <samp class="SANS_TheSansMonoCd_W5Regular_11">InformationClass</samp>, describes the type of process information to query. The information class is an enumerated value; the SDK specifies the names of the information classes, which we can extract and implement in PowerShell. Querying certain kinds of information might require special privileges or administrator access.</p>
<p class="TX">For every information class, we need to specify an opaque buffer to receive the queried information, as well as the length of the buffer. The system call also returns a length value, which serves two purposes: it indicates how much of the buffer was populated if the system call was successful, and if the system call failed, it indicates how big the buffer needs to be with <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_INFO_LENGTH_MISMATCH</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_BUFFER_TOO_SMALL</samp>.</p>
<p class="TX">You should be careful about relying on the returned length to determine how big a buffer to pass to the query, however. Some information classes and types do not correctly set the length needed if you supply a buffer that is too small. This makes it difficult to query data without knowing its format in advance. Unfortunately, even the SDK rarely documents the exact sizes required.</p>
<p class="TX">As shown in <a href="chapter2.xhtml#Lis2-20">Listing 2-20</a>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Set</samp> information call follows a similar pattern. The main differences are that there’s no return length parameter, and in this case the buffer is an input to the system call rather than an output.</p>
<span id="Lis2-20"></span><pre><code>NTSTATUS NtSetInformationProcess(
    HANDLE                    Handle,
    PROCESS_INFORMATION_CLASS InformationClass,
    PVOID                     Information,
    ULONG                     InformationLength
)
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-20: An example Set information system call for the Process type</span></p>
<p class="TX">In the PowerShell module, you can query a type’s information class names using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtObjectInformationClass</samp> command, as shown in <a href="chapter2.xhtml#Lis2-21">Listing 2-21</a>. Bear in mind that some information class names might be missing from the list, as Microsoft doesn’t always document them.</p>
<span id="Lis2-21"></span><pre><code>PS&gt; <b>Get-NtObjectInformationClass Process</b>
Key                     Value
---                     -----
ProcessBasicInformation     0
ProcessQuotaLimits          1
<span aria-label=" Page 44. " epub:type="pagebreak" id="pg_44" role="doc-pagebreak"></span>ProcessIoCounters           2
ProcessVmCounters           3
ProcessTimes                4
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-21: Listing the information classes for the Process type</span></p>
<p class="TX">To call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp> information system call, use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtObjectInformation</samp>, specifying an open object handle and the information class. To call <samp class="SANS_TheSansMonoCd_W5Regular_11">SetInformation</samp>, use <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtObjectInformation</samp>. <a href="chapter2.xhtml#Lis2-22">Listing 2-22</a> shows an example of how to use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtObjectInformation</samp>.</p>
<span id="Lis2-22"></span><pre><code>PS&gt; <b>$proc = Get-NtProcess -Current</b>
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>Get-NtObjectInformation $proc ProcessTimes</b>
Get-NtObjectInformation : (0xC0000023) - {Buffer Too Small}
The buffer is too small to contain the entry. No information has been written to the buffer.
<var>--snip--</var>

<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>Get-NtObjectInformation $proc ProcessTimes -Length 32</b>
43
231
39
138
<var>--snip--</var>

<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>Get-NtObjectInformation $proc ProcessTimes -AsObject</b>
CreateTime         ExitTime KernelTime UserTime
----------         -------- ---------- --------
132480295787554603 0        35937500   85312500
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-22: Querying a Process object for basic information</span></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> type doesn’t set the return length for the <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessTimes</samp> information class, so if you don’t specify any length, the operation generates a <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_BUFFER_TOO_SMALL</samp> error <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. However, through inspection or brute force, you can discover that the length of the data is 32 bytes. Specifying this value using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Length</samp> parameter <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> allows the query to succeed and return the data as an array of bytes.</p>
<p class="TX">For many information classes, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtObjectInformation</samp> command knows the size and structure of the query data. If you specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">AsObject</samp> parameter <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>, you can get a preformatted object rather than an array of bytes.</p>
<p class="TX">Also, for many information classes the handle object already exposes properties and methods to set or query values. The values will be decoded into a usage format; for example, in <a href="chapter2.xhtml#Lis2-22">Listing 2-22</a>, the times are in an internal format. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CreationTime</samp> property on the object will take this internal format and convert it to a human-readable date and time.</p>
<p class="TX">You can easily inspect properties by accessing them on the object or using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-List</samp> command. For example, <a href="chapter2.xhtml#Lis2-23">Listing 2-23</a> lists all the properties on a <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> object, then queries for the formatted <samp class="SANS_TheSansMonoCd_W5Regular_11">CreationTime</samp>.</p>
<span id="Lis2-23"></span><pre><code><span aria-label=" Page 45. " epub:type="pagebreak" id="pg_45" role="doc-pagebreak"></span>PS&gt; <b>$proc | Format-List</b>
SessionId       : 2
ProcessId       : 5484
ParentProcessId : 8108
PebAddress      : 46725963776
<var>--snip--</var>

PS&gt; <b>$proc.CreationTime</b>
Saturday, October 24, 17:12:58
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-23: Querying a handle object for properties and inspecting the CreationTime</span></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryInformation</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">SetInformation</samp> classes for a type typically have the same enumerated values. The kernel can restrict the information class’s enumerated values to one type of operation, returning the <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_INVALID _INFO_CLASS</samp> status code if it’s not a valid value. For some types, such as registry keys, the information class differs between querying and setting, as you can see in <a href="chapter2.xhtml#Lis2-24">Listing 2-24</a>.</p>
<span id="Lis2-24"></span><pre><code>PS&gt; <b>Get-NtObjectInformationClass Key</b>
Key                     Value
---                     -----
KeyBasicInformation         0
<var>--snip--</var>

PS&gt; <b>Get-NtObjectInformationClass Key -Set</b>
Key                     Value
---                     -----
KeyWriteTimeInformation     0
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-24: Inspecting the QueryInformation and SetInformation classes for the Key type</span></p>
<p class="TX">Calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtObjectInformationClass</samp> with just the type name returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryInformation</samp> class. If you specify the type name and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Set</samp> parameter, you get the <samp class="SANS_TheSansMonoCd_W5Regular_11">SetInformation</samp> class. Notice how the two entries shown have different names and therefore represent different information.</p>
</section>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h3 class="H1" id="sec12"><span id="h1-13"></span><samp class="SANS_Futura_Std_Bold_B_11">The Input/Output Manager</samp></h3>
<p class="TNI1">The input/output (I/O) manager provides access to I/O devices through <i>device drivers</i>. The primary purpose of these drivers is to implement a filesystem. For example, when you open a document on your computer, the file is made available through a filesystem driver. The I/O manager supports other kinds of drivers, for devices such as keyboards and video cards, but these other drivers are really just filesystem drivers in disguise.</p>
<p class="TX">You can manually load a new driver through the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtLoadDriver</samp> system call or do so automatically using the Plug and Play (PnP) manager. For every driver, the I/O manager creates an entry in the <i>Driver</i> directory. You can list the contents of this directory only if you’re an administrator. Fortunately, <span aria-label=" Page 46. " epub:type="pagebreak" id="pg_46" role="doc-pagebreak"></span>as a normal user, you don’t need to access anything in the <i>Driver</i> directory. Instead, you can interact with the driver through a <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp> object, normally created in the <i>Device</i> directory.</p>
<p class="TX">Drivers are responsible for creating new <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp> objects using the <samp class="SANS_TheSansMonoCd_W5Regular_11">IoCreateDevice</samp> API. A driver can have more than one <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp> object associated with it; it may also have zero associated <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp> objects if it doesn’t require user interaction. As <a href="chapter2.xhtml#Lis2-25">Listing 2-25</a> shows, we can list the contents of the <i>Device</i> directory as a normal user through the OMNS.</p>
<span id="Lis2-25"></span><pre><code>PS&gt; <b>ls NtObject:\Device</b>
Name                                     TypeName
----                                     --------
_HID00000034                             Device
DBUtil_2_3                               Device
000000c7                                 Device
000000b3                                 Device
UMDFCtrlDev-0f8ff736-55d7-11ea-b5d8-2... Device
0000006a                                 Device
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-25: Displaying the Device objects</span></p>
<p class="TX">In the output, we can see that the objects’ type names are all <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp>. However, if you go looking for a system call with <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp> in the name, you’ll come up empty. That’s because we don’t interact with the I/O manager using dedicated system calls; rather, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp> object system calls such as <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>. We can access these system calls through <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtFile</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtFile</samp>, which create and open files, respectively, as shown in <a href="chapter2.xhtml#Lis2-26">Listing 2-26</a>.</p>
<span id="Lis2-26"></span><pre><code>PS&gt; <b>Use-NtObject($f = Get-NtFile "\SystemRoot\notepad.exe") {</b>
    <b>$f | Select-Object FullPath, NtTypeName</b>
<b>}</b>
FullPath                                    NtTypeName
--------                                    ----------
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> \Device\HarddiskVolume3\Windows\notepad.exe File

PS&gt; <b>Get-Item NtObject:\Device\HarddiskVolume3</b>
Name            TypeName
----            --------
HarddiskVolume3 Device
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-26: Opening a device object and displaying its volume path</span></p>
<p class="TX">In this example, we open <i>notepad.exe</i> from the <i>Windows</i> directory. The <i>SystemRoot</i> symbolic link points to the <i>Windows</i> directory on the system drive. As the <i>SystemRoot</i> symbolic link is part of the OMNS, the OMNS initially handles file access. With an open handle, we can select the full path to the file and the type name.</p>
<p class="TX">Looking at the result, we can see that the full path starts with <i>Device\HarddiskVolume3\</i>, followed by <i>Windows\notepad.exe</i> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. If we try to display the device, we find it’s of type <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp>. Once the object manager finds the <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp> <span aria-label=" Page 47. " epub:type="pagebreak" id="pg_47" role="doc-pagebreak"></span>object, it hands off responsibility for the rest of the path to the I/O manager, which calls an appropriate method inside the kernel driver.</p>
<p class="TX">We can list the drivers loaded into the kernel using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtKernelModule</samp> command (<a href="chapter2.xhtml#Lis2-27">Listing 2-27</a>).</p>
<span id="Lis2-27"></span><pre><code>PS&gt; <b>Get-NtKernelModule</b>
Name         ImageBase        ImageSize
----         ---------        ---------
ntoskrnl.exe FFFFF8053BEAA000 11231232
hal.dll      FFFFF8053BE07000 667648
kd.dll       FFFFF8053B42E000 45056
msrpc.sys    FFFFF8053B48E000 393216
ksecdd.sys   FFFFF8053B45E000 172032
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-27: Enumerating all loaded kernel drivers</span></p>
<p class="TX">Unlike other operating systems, such as Linux, Windows does not implement core network protocols like TCP/IP using built-in system calls. Instead, Windows has an I/O manager driver, the <i>Ancillary Function Driver (AFD)</i>, which provides access to networking services for an application. You don’t need to deal with the driver directly; Win32 provides a BSD sockets-style API, called <i>WinSock</i>, to handle access to it. In addition to the standard internet protocol suite, such as TCP/IP, AFD also implements other network socket types, such as Unix sockets and bespoke Hyper-V sockets for communication with virtual machines.</p>
<p class="TX">That’s all we’ll say for now about the I/O manager. Next, let’s turn to another important subsystem, the process and thread manager.</p>
</section>
<section aria-labelledby="sec13" epub:type="division">
<h3 class="H1" id="sec13"><span id="h1-14"></span><samp class="SANS_Futura_Std_Bold_B_11">The Process and Thread Manager</samp></h3>
<p class="TNI1">All user-mode code lives in the context of a <i>process</i>, each of which has one or more <i>threads</i> that control the execution of the code. Processes and threads are both securable resources. This makes sense: if you could access a process, you could modify its code and execute it in the context of a different user identity. So, unlike most other kernel objects, you can’t open a process or thread by name. Instead, you must open them via a unique, numeric <i>process ID (PID)</i> or <i>thread ID (TID)</i>.</p>
<p class="TX">To get a list of running processes and threads you could brute-force the ID space by calling the open system call with every possible ID, but that would take a while. Fortunately, the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySystemInformation</samp> system call provides the <samp class="SANS_TheSansMonoCd_W5Regular_11">SystemProcessInformation</samp> information class, which lets us enumerate processes and threads without having access to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> object.</p>
<p class="TX">We can access the list of processes and threads by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtProcess</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtThread</samp> commands and passing them the <samp class="SANS_TheSansMonoCd_W5Regular_11">InfoOnly</samp> parameter, as shown in <a href="chapter2.xhtml#Lis2-28">Listing 2-28</a>. We can also use the built-in <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Process</samp> command to produce a similar output. Each of the returned objects has a <samp class="SANS_TheSansMonoCd_W5Regular_11">Threads</samp> property that we can query for the thread information.</p>
<span id="Lis2-28"></span><pre><code><span aria-label=" Page 48. " epub:type="pagebreak" id="pg_48" role="doc-pagebreak"></span>PS&gt; <b>Get-NtProcess -InfoOnly</b>
PID PPID Name          SessionId
--- ---- ----          ---------
0   0    Idle          0
4   0    System        0
128 4    Secure System 0
192 4    Registry      0
812 4    smss.exe      0
920 892  csrss.exe     0
<var>--snip--</var>

PS&gt; <b>Get-NtThread -InfoOnly</b>
TID PID ProcessName StartAddress
--- --- ----------- ------------
0   0   Idle        FFFFF8004C9CAFD0
0   0   Idle        FFFFF8004C9CAFD0
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-28: Displaying processes and threads without high privilege</span></p>
<p class="TX">The first two processes listed in the output are special. The first is the <samp class="SANS_TheSansMonoCd_W5Regular_11">Idle</samp> process, with PID <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>. This process contains threads that execute when the operating system is idle, hence its name. It’s not a process you’ll need to deal with regularly. The <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp> process, with PID <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, is important because it runs entirely in kernel mode. When the kernel or a driver needs to execute a background thread, the thread is associated with the <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp> process.</p>
<p class="TX">To open a process or thread, we can pass <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtProcess</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtThread</samp> the PID or TID we want to open. The command will return a <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Thread</samp> object that we can then interact with. For example, <a href="chapter2.xhtml#Lis2-29">Listing 2-29</a> shows how to query the command line and executable path of the current process.</p>
<span id="Lis2-29"></span><pre><code>PS&gt; <b>$proc = Get-NtProcess -ProcessId $pid</b>
PS&gt; <b>$proc.CommandLine</b>
"C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe"

PS&gt; <b>$proc.Win32ImagePath</b>
C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-29: Opening the current process by its process ID</span></p>
<p class="TX">When you open a <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Thread</samp> object using its ID, you’ll receive a handle. For convenience, the kernel also supports two <i>pseudo handles</i> that refer to the current process and the current thread. The current process’s pseudo handle is the value <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp> converted to a handle, and for the current thread, it’s <samp class="SANS_TheSansMonoCd_W5Regular_11">-2</samp>. You can access these pseudo handles by passing the <samp class="SANS_TheSansMonoCd_W5Regular_11">Current</samp> parameter instead of an ID to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtProcess</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtThread</samp> commands.</p>
<p class="TX">Note that the security of a process and its threads is independent. If you know the ID of a thread, it’s possible to access the thread handle inside a process even if you can’t access the process itself.</p>
</section>
<section aria-labelledby="sec14" epub:type="division">
<h3 class="H1" id="sec14"><span id="h1-15"></span><span aria-label=" Page 49. " epub:type="pagebreak" id="pg_49" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_B_11">The Memory Manager</samp></h3>
<p class="TNI1">Every process has its own virtual memory address space for a developer to use as they see fit. A 32-bit process can access up to 2GB of virtual memory address space (4GB on 64-bit Windows), while a 64-bit process can access up to 128TB. The kernel’s <i>memory manager</i> subsystem controls the allocation of this address space.</p>
<p class="TX">You’re unlikely to have 128TB of physical memory in your computer, but the memory manager has ways of making it look like you have more physical memory than you do. For example, it can use a dedicated file on your filesystem, called a <i>pagefile</i>, to temporarily store memory when it’s not currently needed. As your filesystem’s available storage space is much larger than your computer’s physical memory, this can provide the appearance of a large amount of memory.</p>
<p class="TX">The virtual memory space is shared by memory allocations, and it stores each process’s running state as well as its executable code. Each memory allocation can have a range of protection states, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadOnly</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadWrite</samp>, which must be set according to the memory’s purpose. For example, for code to be executed, the memory must have a protection state of <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecuteRead</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecuteReadWrite</samp>.</p>
<p class="TX">You can query all memory status information for a process by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryVirtualMemory</samp>, if you have the <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryLimitedInformation</samp> access right on the process handle. However, reading and writing the memory data requires the <samp class="SANS_TheSansMonoCd_W5Regular_11">VmRead</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">VmWrite</samp> access rights, respectively, and a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadVirtualMemory</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">NtWriteVirtualMemory</samp>.</p>
<p class="TX">It’s possible to allocate new memory and free memory in a process using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">NtFreeVirtualMemory</samp>, which both require the <samp class="SANS_TheSansMonoCd_W5Regular_11">VmOperation</samp> access right. Finally, you can change the protection on memory using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtProtectVirtualMemory</samp>, which also requires <samp class="SANS_TheSansMonoCd_W5Regular_11">VmOperation</samp> access.</p>
<section aria-labelledby="sec15" epub:type="division">
<h4 class="H2" id="sec15"><span id="h2-14"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">NtVirtualMemory Commands</samp></h4>
<p class="TNI1">PowerShell wraps these system calls using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Read-</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Write-</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtVirtualMemory</samp> commands. Note that these commands all accept an optional <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> parameter that lets you access memory in a different process from the current one. <a href="chapter2.xhtml#Lis2-30">Listing 2-30</a> shows the commands in action.</p>
<span id="Lis2-30"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>Get-NtVirtualMemory</b>
Address          Size   Protect          Type    State   Name
-------          ----   -------          ----    -----   ----
000000007FFE0000 4096   ReadOnly         Private Commit
000000007FFEF000 4096   ReadOnly         Private Commit
000000E706390000 241664 None             Private Reserve
000000E7063CB000 12288  ReadWrite, Guard Private Commit
000000E7063CE000 8192   ReadWrite        Private Commit
000000F6583F0000 12288  ReadOnly         Mapped  Commit  powershell.exe.mui
<var>--snip--</var>

<span aria-label=" Page 50. " epub:type="pagebreak" id="pg_50" role="doc-pagebreak"></span><span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>$addr = Add-NtVirtualMemory -Size 1000 -Protection ReadWrite</b>
PS&gt; <b>Get-NtVirtualMemory -Address $addr</b>
Address          Size   Protect          Type    State   Name
-------          ----   -------          ----    -----   ----
000002624A440000 4096   ReadWrite        Private Commit

<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>Read-NtVirtualMemory -Address $addr -Size 4 | Out-HexDump</b>
00 00 00 00

<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> PS&gt; <b>Write-NtVirtualMemory -Address $addr -Data @(1,2,3,4)</b>
4

<span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> PS&gt; <b>Read-NtVirtualMemory -Address $addr -Size 4 | Out-HexDump</b>
01 02 03 04

<span aria-label="annotation6" class="CodeAnnotationHang1">❻</span> PS&gt; <b>Set-NtVirtualMemory -Address $addr -Protection ExecuteRead -Size 4</b>
ReadWrite

<span aria-label="annotation7" class="CodeAnnotationHang1">❼</span> PS&gt; <b>Get-NtVirtualMemory -Address $addr</b>
Address          Size   Protect          Type    State   Name
-------          ----   -------          ----    -----   ----
000002624A440000 4096   ExecuteRead      Private Commit

<span aria-label="annotation8" class="CodeAnnotationHang1">❽</span> PS&gt; <b>Remove-NtVirtualMemory -Address $addr</b>
PS&gt; <b>Get-NtVirtualMemory -Address $addr</b>
Address          Size   Protect          Type    State   Name
-------          ----   -------          ----    -----   ----
000002624A440000 196608 NoAccess         None    Free
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-30: Performing various memory operations on a process</span></p>
<p class="TX">Here, we perform several operations. First we use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtVirtualMemory</samp> to list all the memory regions being used by the current process <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. The returned list will be large, but the excerpt shown here should give you a rough idea of how the information is presented. It includes the address of the memory region, its size, its protection, and its state. There are three possible state values:</p>
<p class="RunInPara1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Commit  </samp>Indicates that the virtual memory region is allocated and available for use.</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reserve  </samp>Indicates that the virtual memory region has been allocated but there is currently no backing memory. Using a reserved memory region will cause a crash.</p>
<p class="RunInPara2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Free  </samp>Indicates that the virtual memory region is unused. Using a free memory region will cause a crash.</p>
<p class="TX">You may wonder what the difference is between <samp class="SANS_TheSansMonoCd_W5Regular_11">Reserve</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Free</samp>, if using both reserved and free memory regions will cause a crash. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Reserve</samp> state allows you to reserve virtual memory regions for later use so that nothing else can allocate memory within that range of memory addresses. You can later convert the <samp class="SANS_TheSansMonoCd_W5Regular_11">Reserve</samp> state to <samp class="SANS_TheSansMonoCd_W5Regular_11">Commit</samp> by re-calling <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Free</samp> state indicates regions freely available for <span aria-label=" Page 51. " epub:type="pagebreak" id="pg_51" role="doc-pagebreak"></span>allocation. We’ll cover what the <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp> columns indicate later in this section.</p>
<p class="TX">Next, we allocate a 1,000-byte read/write region and capture the address in a variable <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. Passing the address to <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtVirtualMemory</samp> allows us to query only that specific virtual memory region. You might notice that although we requested a 1,000-byte region, the size of the region returned is 4,096 bytes. This is because all virtual memory allocations on Windows have a minimum allocation size; on the system I’m using, the minimum is 4,096 bytes. It’s therefore not possible to allocate a smaller region. For this reason, these system calls are not particularly useful for general program allocations; rather, they’re primitives on which “heap” memory managers are built, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> from the C library.</p>
<p class="TX">Next, we read and write to the memory region we just allocated. First we use <samp class="SANS_TheSansMonoCd_W5Regular_11">Read-NtVirtualMemory</samp> to read out 4 bytes of the memory region and find that the bytes are all zeros <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. Next, we write the bytes 1, 2, 3, and 4 to the memory region using <samp class="SANS_TheSansMonoCd_W5Regular_11">Write-NtVirtualMemory</samp> <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. We read the bytes to confirm that the write operation succeeded <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>; the two values should match, as shown in the output.</p>
<p class="TX">With the memory allocated, we can change the protection using <samp class="SANS_TheSansMonoCd_W5Regular_11">Set -NtVirtualMemory</samp>. In this case, we make the allocated memory executable by specifying the protection as <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecuteRead</samp> <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>. Querying the current state of the memory region using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtVirtualMemory</samp> command <span aria-label="annotation7" class="CodeAnnotationCode">❼</span> shows that the protection has changed from <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadWrite</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecuteRead</samp>. Also notice that although we requested to change the protection of only 4 bytes, the entire 4,096-byte region is now executable. This is again due to the minimum memory allocation size.</p>
<p class="TX">Finally, we free the memory using <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtVirtualMemory</samp> and verify that the memory is now in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Free</samp> state <span aria-label="annotation8" class="CodeAnnotationCode">❽</span>. Memory allocated using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp> is considered private, as indicated by the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp> property shown in <a href="chapter2.xhtml#Lis2-30">Listing 2-30</a>.</p>
</section>
<section aria-labelledby="sec16" epub:type="division">
<h4 class="H2" id="sec16"><span id="h2-15"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Section Objects</samp></h4>
<p class="TNI1">Another way of allocating virtual memory is through <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> objects. A <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object is a kernel type that implements memory-mapped files. We can use <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> objects for two related purposes:</p>
<ul class="ul">
<li class="ListBullet">Reading or writing a file as if it were all read into memory</li>
<li class="ListBullet">Sharing memory between processes so that the modification in one process is reflected in the other</li>
</ul>
<p class="TX">We can create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object via the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateSection</samp> system call or the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtSection</samp> PowerShell command. We must specify the size of the mapping, the protection for the memory, and an optional file handle; in return, we get a handle to the section.</p>
<p class="TX">However, creating a section doesn’t automatically allow us to access the memory; we first need to map it into the virtual memory address space using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtMapViewOfSection</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtSection</samp>. <a href="chapter2.xhtml#Lis2-31">Listing 2-31</a> provides an example in which we create an anonymous section and map it into memory.</p>
<span id="Lis2-31"></span><pre><code><span aria-label=" Page 52. " epub:type="pagebreak" id="pg_52" role="doc-pagebreak"></span><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$s = New-NtSection -Size 4096 -Protection ReadWrite</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>$m = Add-NtSection -Section $s -Protection ReadWrite</b>
PS&gt; <b>Get-NtVirtualMemory $m.BaseAddress</b>
Address          Size Protect   Type   State  Name
-------          ---- -------   ----   -----  ----
000001C3DD0E0000 4096 ReadWrite Mapped Commit

<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>Remove-NtSection -Mapping $m</b>
PS&gt; <b>Get-NtVirtualMemory -Address 0x1C3DD0E0000</b>
Address          Size Protect   Type   State  Name
-------          ---- -------   ----   -----  ----
000001C3DD0E0000 4096 NoAccess  None   Free

<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> PS&gt; <b>Add-NtSection -Section $s -Protection ExecuteRead</b>
Exception calling "Map" with "9" argument(s):
  "(0xC000004E) - A view to a section specifies a protection which is
   incompatible with the initial view's protection."
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-31: Creating a section and mapping it into memory</span></p>
<p class="TX">To start, we create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object with a size of 4,096 bytes and protection of <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadWrite</samp> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. We don’t specify a <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp> parameter, which means it’s anonymous and not backed by any file. If we gave the <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object an OMNS path, the anonymous memory it represents could be shared with other processes.</p>
<p class="TX">We then map the section into memory using <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtSection</samp>, specifying the protection we want for the memory, and query the mapped address to verify that the operation succeeded <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. Note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp> is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">Mapped</samp>. When we’re done with the mapping, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtSection</samp> to unmap the section and then verify that it’s now free <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>.</p>
<p class="TX">Finally, we demonstrate that we can’t map a section with different protection than that granted when we created the <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. When we try to map the section with read and execute permissions, which aren’t compatible, we see an exception.</p>
<p class="TX">The protection you’re allowed to use to map a <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object into memory depends on two things. The first is the protection specified when the <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object was created. For example, if the section was created with <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadOnly</samp> protection, you can never map it to be writable.</p>
<p class="TX">The second dependency is the access granted to the section handle you’re mapping. If you want to map the section as readable, then the handle must have <samp class="SANS_TheSansMonoCd_W5Regular_11">MapRead</samp> access. To map it to be writable, you need both <samp class="SANS_TheSansMonoCd_W5Regular_11">MapRead</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">MapWrite</samp> access. (And, of course, having just <samp class="SANS_TheSansMonoCd_W5Regular_11">MapWrite</samp> access isn’t sufficient to map the section as writable if the original <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object was not specified with a writable protection.)</p>
<p class="TX">It’s possible to map a section into another process by specifying a process handle to <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtSection</samp>. We don’t need to specify the process to <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtSection</samp>, as the mapping object knows what process it was mapped in. In the memory information output, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp> column would be populated by the name of the backing file, if it exists.</p>
<p class="TX"><span aria-label=" Page 53. " epub:type="pagebreak" id="pg_53" role="doc-pagebreak"></span>The section we created was anonymous, so we don’t see anything in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp> column, but we can perform a query to find mapped sections that are backed by files using the command shown in <a href="chapter2.xhtml#Lis2-32">Listing 2-32</a>.</p>
<span id="Lis2-32"></span><pre><code>PS&gt; <b>Get-NtVirtualMemory -Type Mapped | Where-Object Name -ne ""</b>
Address          Size    Protect  Type   State  Name
-------          ----    -------  ----   -----  ----
000001760DB90000 815104  ReadOnly Mapped Commit locale.nls
000001760DC60000 12288   ReadOnly Mapped Commit powershell.exe.mui
000001760DEE0000 20480   ReadOnly Mapped Commit winnlsres.dll
000001760F720000 3371008 ReadOnly Mapped Commit SortDefault.nls
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-32: Listing mapped files with names</span></p>
<p class="TX">In addition to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Anonymous</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Mapped</samp> types, there is a third section type, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Image</samp> type. When provided with a file handle to a Windows executable, the kernel will automatically parse the format and generate multiple subsections that represent the various components of the executable. To create a mapped image from a file, we need only <samp class="SANS_TheSansMonoCd_W5Regular_11">Execute</samp> access on the file handle; the file doesn’t need to be readable for us.</p>
<p class="TX">Windows uses image sections extensively to simplify the mapping of executables into memory. We can specify an image section by passing the <samp class="SANS_TheSansMonoCd_W5Regular_11">Image</samp> flag when creating the <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object or by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtSectionImage</samp> command, as shown in <a href="chapter2.xhtml#Lis2-33">Listing 2-33</a>.</p>
<span id="Lis2-33"></span><pre><code>PS&gt; <b>$sect = New-NtSectionImage -Win32Path "C:\Windows\notepad.exe"</b>
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$map = Add-NtSection -Section $sect -Protection ReadOnly</b>
PS&gt; <b>Get-NtVirtualMemory -Address $map.BaseAddress</b>
Address          Size   Protect     Type  State  Name
-------          ----   -------     ----  -----  ----
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> 00007FF667150000 4096   ReadOnly    Image Commit notepad.exe

<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>Get-NtVirtualMemory -Type Image -Name "notepad.exe"</b>
Address          Size   Protect     Type  State  Name
-------          ----   -------     ----  -----  ----
00007FF667150000 4096   ReadOnly    Image Commit notepad.exe
00007FF667151000 135168 ExecuteRead Image Commit notepad.exe
00007FF667172000 36864  ReadOnly    Image Commit notepad.exe
00007FF66717B000 12288  WriteCopy   Image Commit notepad.exe
00007FF66717E000 4096   ReadOnly    Image Commit notepad.exe
00007FF66717F000 4096   WriteCopy   Image Commit notepad.exe
00007FF667180000 8192   ReadOnly    Image Commit notepad.exe

<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> PS&gt; <b>Out-HexDump -Buffer $map -ShowAscii -Length 128</b>
4D 5A 90 00 03 00 00 00 04 00 00 00 FF FF 00 00  - MZ..............
B8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00  - ........@.......
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  - ................
00 00 00 00 00 00 00 00 00 00 00 00 F8 00 00 00  - ................
0E 1F BA 0E 00 B4 09 CD 21 B8 01 4C CD 21 54 68  - ........!..L.!Th
69 73 20 70 72 6F 67 72 61 6D 20 63 61 6E 6E 6F  - is program canno
<span aria-label=" Page 54. " epub:type="pagebreak" id="pg_54" role="doc-pagebreak"></span>74 20 62 65 20 72 75 6E 20 69 6E 20 44 4F 53 20  - t be run in DOS
6D 6F 64 65 2E 0D 0D 0A 24 00 00 00 00 00 00 00  - mode....$.......
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-33: Mapping</span> <samp class="SANS_Futura_Std_Book_11">notepad.exe</samp> <span class="Futura_Std_Book_Oblique_I_11">and viewing the loaded image</span></p>
<p class="TX">As you can see, we don’t need to specify <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecuteRead</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecuteReadWrite</samp> protection when mapping the image section. Any protection, including <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadOnly</samp>, will work <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. When we get the memory information for a map-based address, we see that there is no executable memory there and that the allocation is only 4,096 bytes <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, which seems far too small for <i>notepad.exe</i>. This is because the section is made up of multiple smaller mapped regions. If we filter out the memory information for the mapped name <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>, we can see the executable memory. Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Out-HexDump</samp> command, we can print the contents of the mapped file buffer <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>.</p>
</section>
</section>
<section aria-labelledby="sec17" epub:type="division">
<h3 class="H1" id="sec17"><span id="h1-16"></span><samp class="SANS_Futura_Std_Bold_B_11">Code Integrity</samp></h3>
<p class="TNI1">One important security task is ensuring that the code running on your computer is the same code the manufacturer intended you to run. If a malicious user has modified operating system files, you might encounter security issues such as the leaking of private data.</p>
<p class="TX">Microsoft considers the integrity of code running on Windows to be so important that there is an entire subsystem to deal with it. This <i>code integrity</i> subsystem verifies and restricts what files can execute in the kernel, and optionally in user mode, by checking the code’s integrity. The memory manager can consult with the code integrity subsystem when it loads an image file if it needs to check whether the executable is correctly signed.</p>
<p class="TX">Almost every executable on a default Windows installation is signed using a mechanism called <i>Authenticode</i>. This mechanism allows a cryptographic signature to be embedded in the executable file or collected inside a catalog file. The code integrity subsystem can read this signature, verify that it’s valid, and make trust decisions based on it.</p>
<p class="TX">We can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AuthenticodeSignature</samp> command to query the signing status of an executable, as shown in <a href="chapter2.xhtml#Lis2-34">Listing 2-34</a>.</p>
<span id="Lis2-34"></span><pre><code>PS&gt; <b>Get-AuthenticodeSignature "$env:WinDir\system32\notepad.exe" | Format-List</b>
SignerCertificate : [Subject]
    CN=Microsoft Windows, O=Microsoft Corporation, L=Redmond, S=Washington, C=US
<var>--snip--</var>
Status            : Valid
StatusMessage     : Signature verified.
Path              : C:\WINDOWS\system32\notepad.exe
SignatureType     : Catalog
IsOSBinary        : True
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-34: Displaying the Authenticode signature for a kernel driver</span></p>
<p class="TX">Here, we query the signing status of the <i>notepad.exe</i> executable file, formatting the command’s output as a list. The output starts with information <span aria-label=" Page 55. " epub:type="pagebreak" id="pg_55" role="doc-pagebreak"></span>about the signer’s X.509 certificate. Here, I’ve shown only the subject name, which clearly indicates that this file is signed by Microsoft.</p>
<p class="TX">Next is the status of the signature; in this case, the status indicates that the file is valid and that the signature has been verified. It’s possible to have a signed file whose signature is invalid; for example, when the certificate has been revoked. In that case, the status is likely to show an error, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">NotSigned</samp>.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">SignatureType</samp> property shows that this signature was based on a catalog file rather than being embedded in the file. We can also see that this file is an operating system binary, as determined by information embedded in the signature.</p>
<p class="TX">The most common trust decision the code integrity subsystem makes is checking whether a kernel driver can load. Each driver file must have a signature that derives its trust from a Microsoft-issued key. If the signature is invalid or doesn’t derive from a Microsoft-issued key, then the kernel can block loading of the driver to preserve system integrity.</p>
</section>
<section aria-labelledby="sec18" epub:type="division">
<h3 class="H1" id="sec18"><span id="h1-17"></span><samp class="SANS_Futura_Std_Bold_B_11">Advanced Local Procedure Call</samp></h3>
<p class="TNI1">The <i>advanced local procedure call (ALPC)</i> subsystem implements local, cross-process communication. To use ALPC, you must first create a server ALPC port using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateAlpcPort</samp> system call and specify a name for it inside the OMNS. A client can then use this name by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtConnectAlpcPort</samp> system call to connect to the server port.</p>
<p class="TX">At a basic level, the ALPC port allows the secure transmission of discrete messages between a server and a client. ALPC provides the underlying transport for local remote procedure call APIs implemented in Windows.</p>
</section>
<section aria-labelledby="sec19" epub:type="division">
<h3 class="H1" id="sec19"><span id="h1-18"></span><samp class="SANS_Futura_Std_Bold_B_11">The Configuration Manager</samp></h3>
<p class="TNI1">The <i>configuration manager</i>, known more commonly as the <i>registry</i>, is an important component for configuring the operating system. It stores a variety of configuration information, ranging from the system-critical list of available I/O manager device drivers to the (less critical) last position on the screen of your text editor’s window.</p>
<p class="TX">You can think of the registry as a filesystem in which <i>keys</i> are like folders and <i>values</i> are like files. You can access it through the OMNS, although you must use registry-specific system calls. The root of the registry is the OMNS path <i>REGISTRY</i>. You can list the registry in PowerShell using the <i>NtObject</i> drive, as shown in <a href="chapter2.xhtml#Lis2-35">Listing 2-35</a>.</p>
<span id="Lis2-35"></span><pre><code>PS&gt; <b>ls NtObject:\REGISTRY</b>
Name    TypeName
----    --------
A       Key
MACHINE Key
<span aria-label=" Page 56. " epub:type="pagebreak" id="pg_56" role="doc-pagebreak"></span>USER    Key
WC      Key
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-35: Enumerating the registry root key</span></p>
<p class="TX">You can replace <samp class="SANS_TheSansMonoCd_W5Regular_11">NtObject:\REGISTRY</samp> in <a href="chapter2.xhtml#Lis2-35">Listing 2-35</a> with <samp class="SANS_TheSansMonoCd_W5Regular_11">NtKey:\</samp> to make accessing the registry simpler.</p>
<p class="TX">The kernel pre-creates the four keys shown here when it initializes. Each of the keys is a special <i>attachment point</i> at which you can attach a registry hive. A <i>hive</i> is a hierarchy of <samp class="SANS_TheSansMonoCd_W5Regular_11">Key</samp> objects underneath a single root key. An administrator can load new hives from a file and attach them to these preexisting keys.</p>
<p class="TX">Note that PowerShell already comes with a drive provider that you can use to access the registry. However, this drive provider exposes only the Win32 view of the registry, which hides the internal details about the registry from view. We’ll cover the Win32 view of the registry separately in <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>.</p>
<p class="TX">You can interact with the registry directly, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtKey</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtKey</samp> commands to open and create <samp class="SANS_TheSansMonoCd_W5Regular_11">Key</samp> objects, respectively. You can also use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtKeyValue</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtKeyValue</samp> to get and set key values. To remove keys or values, use <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtKey</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtKeyValue</samp>. <a href="chapter2.xhtml#Lis2-36">Listing 2-36</a> shows a few of these commands in action.</p>
<span id="Lis2-36"></span><pre><code>PS&gt; <b>$key = Get-NtKey \Registry\Machine\SOFTWARE\Microsoft\.NETFramework</b>
PS&gt; <b>Get-NtKeyValue -Key $key</b>
Name                     Type   DataObject
----                     ----   ----------
Enable64Bit              Dword  1
InstallRoot              String C:\Windows\Microsoft.NET\Framework64\
UseRyuJIT                Dword  1
DbgManagedDebugger       String "C:\Windows\system32\vsjitdebugger.exe"...
DbgJITDebugLaunchSetting Dword  16
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-36: Opening a registry key and querying its values</span></p>
<p class="TX">We open a <samp class="SANS_TheSansMonoCd_W5Regular_11">Key</samp> object using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtKey</samp> command. We can then query the values stored in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Key</samp> object using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtKeyValue</samp> command. Each entry in the output shows the name of the value, the type of data stored, and a string representation of the data.</p>
</section>
<section aria-labelledby="sec20" epub:type="division">
<h3 class="H1" id="sec20"><span id="h1-19"></span><samp class="SANS_Futura_Std_Bold_B_11">Worked Examples</samp></h3>
<p class="TNI1">Using PowerShell, you can easily change this book’s example scripts to do many different things. To encourage experimentation, each chapter wraps up with a set of worked examples repurposing the various commands you’ve learned.</p>
<p class="TX">In these examples, I’ll also highlight times where I’ve discovered security vulnerabilities using this tooling. This should give you a clear indication of what to look for in Microsoft or third-party applications if you’re a security researcher; likewise, for developers, it will help you avoid certain pitfalls.</p>
<section aria-labelledby="sec21" epub:type="division">
<h4 class="H2" id="sec21"><span id="h2-16"></span><span aria-label=" Page 57. " epub:type="pagebreak" id="pg_57" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding Open Handles by Name</samp></h4>
<p class="TNI1">The objects returned by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtHandle</samp> command have additional properties that allow you to query the object’s name and security descriptor. These properties are not shown by default, as they’re expensive to look up; doing so requires opening the process containing the handle for <samp class="SANS_TheSansMonoCd_W5Regular_11">DupHandle</samp> access, duplicating the handle back to the calling PowerShell instance, and finally querying the property.</p>
<p class="TX">If performance doesn’t matter to you, then you can use the code in <a href="chapter2.xhtml#Lis2-37">Listing 2-37</a> to find all open files matching a specific filename.</p>
<span id="Lis2-37"></span><pre><code>PS&gt; <b>$hs = Get-NtHandle -ObjectType File | Where-Object Name -Match Windows</b>
PS&gt; <b>$hs | Select-Object ProcessId, Handle, Name</b>
ProcessId Handle Name
--------- ------ ----
     3140     64 \Device\HarddiskVolume3\Windows\System32
     3140   1628 \Device\HarddiskVolume3\Windows\System32\en-US\KernelBase.dll.mui
     3428     72 \Device\HarddiskVolume3\Windows\System3
     3428    304 \Device\HarddiskVolume3\Windows\System32\en-US\svchost.exe.mui
     3428    840 \Device\HarddiskVolume3\Windows\System32\en-US\crypt32.dll.mui
     3428   1604 \Device\HarddiskVolume3\Windows\System32\en-US\winnlsres.dll.mui
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-37: Finding File object handles that match a specific name</span></p>
<p class="TX">This script queries for all <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp> object handles and filters them to only the ones with the string <samp class="SANS_TheSansMonoCd_W5Regular_11">Windows</samp> in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp> property, which represents the filepath. Once the <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp> property has been queried, it’s cached so you can then display it to the console with a custom selection.</p>
<p class="TX">Note that because it duplicates the handle from the process, this script can only show handles in processes the caller can open. To get the best results, run it as an administrator user who can open the maximum number of processes.</p>
</section>
<section aria-labelledby="sec22" epub:type="division">
<h4 class="H2" id="sec22"><span id="h2-17"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding Shared Objects</samp></h4>
<p class="TNI1">When you query the list of handles using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtHandle</samp> command, you also get the address of the object in kernel memory. When you open the same kernel object, you’ll get different handles, but they will still point to the same kernel object address.</p>
<p class="TX">You can use the object address to find processes that share handles. This can be interesting for security in cases where an object is shared between two processes with different privileges. The lower-privileged process might be able to modify the properties of the object to bypass security checks in the higher-privileged process, enabling it to gain additional privileges.</p>
<p class="TX">In fact, I used this technique to find security issue CVE-2019-0943 in Windows. At the root of the issue was a privileged process, the Windows Font Cache, that shared section handles with a low-privileged process. The <span aria-label=" Page 58. " epub:type="pagebreak" id="pg_58" role="doc-pagebreak"></span>low-privileged process could map the shared section to be writable and modify contents that the privileged process assumed couldn’t be modified. This effectively allowed the low-privileged process to modify arbitrary memory in the privileged process, resulting in privileged code execution.</p>
<p class="TX"><a href="chapter2.xhtml#Lis2-38">Listing 2-38</a> gives an example of finding writable <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> objects shared between two processes.</p>
<span id="Lis2-38"></span><pre><code>PS&gt; <b>$ss = Get-NtHandle -ObjectType Section -GroupByAddress |</b>
<b>Where-Object ShareCount -eq 2</b>
PS&gt; <b>$mask = Get-NtAccessMask -SectionAccess MapWrite</b>
PS&gt; <b>$ss = $ss | Where-Object {Test-NtAccessMask $_.AccessIntersection $mask}</b>
PS&gt; <b>foreach($s in $ss) {</b>
    <b>$count = ($s.ProcessIds | Where-Object {</b>
        <b>Test-NtProcess -ProcessId $_ -Access DupHandle</b>
    <b>}).Count</b>
    <b>if ($count -eq 1) {</b>
        <b>$s.Handles | Select ProcessId, ProcessName, Handle</b>
    <b>}</b>
<b>}</b>
ProcessId ProcessName Handle
--------- ----------- ------
     9100 Chrome.exe    4400
     4072 audiodg.exe   2560
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-38: Finding shared Section handles</span></p>
<p class="TX">We first get the handles, specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">GroupByAddress</samp> parameter. This returns a list of groups organized based on the kernel object address, instead of a list of handles. You can also group handles using the built-in <samp class="SANS_TheSansMonoCd_W5Regular_11">Group-Object</samp> command; however, the groups returned by <samp class="SANS_TheSansMonoCd_W5Regular_11">GroupByAddress</samp> have additional properties, including <samp class="SANS_TheSansMonoCd_W5Regular_11">ShareCount</samp>, which indicates the number of unique processes an object is shared with. Here, we filter to include only handles that are shared between two processes.</p>
<p class="TX">Next, we want to find <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> objects that can be mapped as writable. We first check that all the handles have <samp class="SANS_TheSansMonoCd_W5Regular_11">MapWrite</samp> access. As mentioned earlier, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object’s protection must also be writable for us to be able to map it as writable. Oddly, we can’t query for the original protection that was assigned when the <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object was created, but checking for <samp class="SANS_TheSansMonoCd_W5Regular_11">MapWrite</samp> access is a simple proxy. We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessIntersection</samp> property, which contains the granted access rights shared among all the handles.</p>
<p class="TX">Now that we have potential candidates for shared sections, we need to work out which meet the criterion that we can access only one of the processes containing the section handle. We’re making another assumption here: if we can open only one of the two processes that share the handle for <samp class="SANS_TheSansMonoCd_W5Regular_11">DupHandle</samp> access, then we’ve got a section shared between a privileged and a low-privileged process. After all, if you had <samp class="SANS_TheSansMonoCd_W5Regular_11">DupHandle</samp> access to both processes, you could already compromise the processes by stealing all <span aria-label=" Page 59. " epub:type="pagebreak" id="pg_59" role="doc-pagebreak"></span>their handles or duplicating their process handles, and if you couldn’t get <samp class="SANS_TheSansMonoCd_W5Regular_11">DupHandle</samp> access to either process, then you couldn’t get access to the section handle at all.</p>
<p class="TX">The result shown in <a href="chapter2.xhtml#Lis2-38">Listing 2-38</a> is a section shared between Chrome and the Audio Device Graph process. The shared section is used to play audio from the browser, and it’s probably not a security issue. However, if you run the script on your own system, you might find shared sections that are.</p>
<p class="TX">Note that once the <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object is mapped into memory, the handle is no longer required. Therefore, you might miss some shared sections that were mapped when the original handle closed. It’s also highly likely you’ll get false positives, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> objects that are intentionally writable by everyone. The goal here is to find a potential attack surface on Windows. You must then go and inspect the handles to see if sharing them has introduced a security issue.</p>
</section>
<section aria-labelledby="sec23" epub:type="division">
<h4 class="H2" id="sec23"><span id="h2-18"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Modifying a Mapped Section</samp></h4>
<p class="TNI1">If you find an interesting <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object to modify, you can map it into memory using <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtSection</samp>. But how do you modify the mapped memory? The simplest approach from the command line is to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Write-NtVirtualMemory</samp> command, which supports passing a mapped section and an array of bytes to write. <a href="chapter2.xhtml#Lis2-39">Listing 2-39</a> demonstrates this technique by assuming you have a handle of interest in the <samp class="SANS_TheSansMonoCd_W5Regular_11">$handle</samp> variable.</p>
<span id="Lis2-39"></span><pre><code>PS&gt; <b>$sect = $handle.GetObject()</b>
PS&gt; <b>$map = Add-NtSection -Section $sect -Protection ReadWrite</b>
PS&gt; <b>$random = Get-RandomByte -Size $map.Length</b>
PS&gt; <b>Write-NtVirtualMemory -Mapping $map -Data $random</b>
4096

PS&gt; <b>Out-HexDump -Buffer $map -Length 16 -ShowAddress -ShowHeader</b>
                  00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
-----------------------------------------------------------------
000001811C860000: DF 24 04 E1 AB 2A E1 76 EB 19 00 8D 79 28 9C BA
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-39: Mapping and modifying a Section object</span></p>
<p class="TX">We first call the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetObject</samp> method on the handle to duplicate it into the current process and return a <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object. For this to succeed, the process in which we’re running this command must be able to access the process with the handle. We then map the handle as <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadWrite</samp> into the current process’s memory.</p>
<p class="TX">We can now create a random array of bytes up to the size of the mapped section and write them to the memory region using <samp class="SANS_TheSansMonoCd_W5Regular_11">Write-NtVirtualMemory</samp>. This is a quick and dirty fuzzer for the shared memory. The hope is that by modifying the memory, the privileged process will mishandle the contents of the memory region. If the privileged process crashes, we should investigate to determine whether we can control the crash using a more targeted modification of the shared memory.</p>
<p class="TX"><span aria-label=" Page 60. " epub:type="pagebreak" id="pg_60" role="doc-pagebreak"></span>We can display the memory using <samp class="SANS_TheSansMonoCd_W5Regular_11">Out-HexDump</samp>. One of the useful features of this command over the built-in <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-Hex</samp> is that it’ll print the address in memory based on the mapped file, whereas <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-Hex</samp> just prints an offset starting at <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.</p>
<p class="TX">You can also create a GUI hex editor with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Show-NtSection</samp> command, specifying a <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object to edit. As the section can be mapped into any process, writing it in the GUI hex editor will also modify all other mappings of that section. Here is the command to display the hex editor:</p>
<pre><code>PS&gt; <b>Show-NtSection -Section $sect</b>
</code></pre>
<p class="TX"><a href="chapter2.xhtml#fig2-6">Figure 2-6</a> shows an example of the editor generated by running the previous command.</p>
<figure class="IMG"><img alt="" class="img1" height="779" id="fig2-6" src="../images/Figure2-6.jpg" width="1388"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-6: The section editor GUI</samp></p></figcaption>
</figure>
<p class="TX">The GUI shown in <a href="chapter2.xhtml#fig2-6">Figure 2-6</a> maps the section into memory and then displays it in a hex editor form. If the section is writable, you can modify the contents of the memory through the editor.</p>
</section>
<section aria-labelledby="sec24" epub:type="division">
<h4 class="H2" id="sec24"><span id="h2-19"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding Writable and Executable Memory</samp></h4>
<p class="TNI1">In Windows, for a process to execute instructions, the memory must be marked as executable. However, it’s also possible to map the memory as both writable and executable. Malware sometimes uses this combination of permissions to inject shell code into a process and run malicious code using the host process’s identity.</p>
<p class="TX"><a href="chapter2.xhtml#Lis2-40">Listing 2-40</a> shows how to check for memory in a process that is both writable and executable. Finding such memory might indicate that something malicious is going on, although in most cases this memory will be benign. For example, the .NET runtime creates writable and executable <span aria-label=" Page 61. " epub:type="pagebreak" id="pg_61" role="doc-pagebreak"></span>memory to perform just-in-time (JIT) compilation of the .NET byte code into native instructions.</p>
<span id="Lis2-40"></span><pre><code>PS&gt; <b>$proc = Get-NtProcess -ProcessId $pid -Access QueryLimitedInformation</b>
PS&gt; <b>Get-NtVirtualMemory -Process $proc | Where-Object {</b>
    <b>$_.Protect -band "ExecuteReadWrite"</b>
<b>}</b>
Address          Size  Protect          Type    State  Name
-------          ----  -------          ----    -----  ----
0000018176450000 4096  ExecuteReadWrite Private Commit
0000018176490000 8192  ExecuteReadWrite Private Commit
0000018176F60000 61440 ExecuteReadWrite Private Commit
<var>--snip--</var>

PS&gt; <b>$proc.Close()</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 2-40: Finding executable and writable memory in a process</span></p>
<p class="TX">We start by opening a process for <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryLimitedInformation</samp> access, which is all we need to enumerate the virtual memory regions. Here, we’re opening the current PowerShell process; as PowerShell is .NET, we know it will have some writable and executable memory regions, but the process you open can be anything you want to check.</p>
<p class="TX">We then enumerate all the memory regions using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtVirtualMemory</samp> and filter on the <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecuteReadWrite</samp> protection type. We need to use a bitwise AND operation as there are additional flags that can be added to the protection, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Guard</samp>, which creates a guard page that prevents doing a direct equality check.</p>
</section>
</section>
<section aria-labelledby="sec25" epub:type="division">
<h3 class="H1" id="sec25"><span id="h1-20"></span><samp class="SANS_Futura_Std_Bold_B_11">Wrapping Up</samp></h3>
<p class="TNI1">This chapter provided a tour through the Windows kernel and its internals. The kernel consists of many separate subsystems, such as the Security Reference Monitor, the object manager, the configuration manager (or registry), the I/O manager, and the process and thread manager.</p>
<p class="TX">You learned about how the object manager manages kernel resources and types, how to access kernel resources through system calls, and how handles are allocated with specific access rights. You also accessed object manager resources through the <i>NtObject</i> drive provider as well as through individual commands.</p>
<p class="TX">I then discussed the basics of process and thread creation and demonstrated the use of commands such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtProcess</samp> to query for process information on the system. I explained how to inspect the virtual memory of a process, as well as some of the individual memory types.</p>
<p class="TX">A user doesn’t directly interact with the kernel; instead, user-mode applications power the user experience. In the next chapter, we’ll discuss the user-mode components in more detail.</p>
</section>
</section>
</div></body>
</html>