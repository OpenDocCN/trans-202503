["```\ninclude gmsl\n```", "```\nMakefile:1: gmsl: No such file or directory\n```", "```\n# Try to determine where this file is located. If the caller did\n# include /foo/gmsl then extract the /foo/ so that __gmsl gets\n# included transparently\n\n__gmsl_root := $(word $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST))\n\n# If there are any spaces in the path in __gmsl_root then give up\n\nifeq (1,$(words $(__gmsl_root)))\n__gmsl_root := $(patsubst %gmsl,%,$(__gmsl_root))\nelse\n__gmsl_root :=\nendif\n\ninclude $(__gmsl_root)__gmsl\n```", "```\nlast = $(if $1,$(word $(words $1),$1))\n```", "```\n$(call last,1 2 3)\n```", "```\n$(if $(true),It's true!,Totally false)\n\nifeq ($(true),$(true))\n--*snip*--\n*endif*\n```", "```\n$(call gmsl_compatible,1 1 2)\n```", "```\n$(call gmsl_compatible,2 0 0)\n```", "```\n$(call assert,$(call gmsl_compatible,1 0 0),Wrong GMSL version)\n```", "```\nifcase = $(call seq,$(call lc,$1),$(call lc,$2))\n```", "```\nCPPFLAGS += $(if $(call ifcase,$(DEBUG),yes),-DDEBUG,)\n```", "```\nfindpath = $(call first,$(call map,wildcard,$(call addsuffix,/$1,$(call split,:,$(PATH)))))\n```", "```\nMakefile:8: split(':', '/home/jgc/bin:/usr/local/bin:/usr/bin:/usr/X11R6/bin:/\nbin:/usr/games:/opt/gnome/bin:/opt/kde3/bin:/usr/lib/java/jre/bin')\nMakefile:8: map('wildcard',' /home/jgc/bin/make /usr/local/bin/make /usr/bin/\nmake /usr/X11R6/bin/make /bin/make /usr/games/make /opt/gnome/bin/make /opt/\nkde3/bin/make /usr/lib/java/jre/bin/make')\nMakefile:8: first(' /usr/bin/make')\n```", "```\n$(call assert,$(OUTDIR),Must set OUTDIR)\n$(call assert_exists,$(OUTDIR),Must set OUTDIR)\n$(call assert,$(if $(call seq,$(DEBUG),yes),$(true),$(call seq,$(DEBUG),no)),DEBUG must be yes or no)\n$(call assert,$(call findstring,Linux,$(ARCH)),ARCH must be Linux)\n```", "```\nMakefile:3: *** GNU Make Standard Library: Assertion failure: Must set OUTDIR.\nStop.\n```", "```\n$(call assert,$(wildcard $(OUTDIR)/.),OUTDIR must be a directory)\n```", "```\ninclude gmsl\n\ndebug_needed := $(call or,$(call seq,$(DEBUG),Y),$(call seq,$(DEBUG),y))\n```", "```\ninclude gmsl\n\ndebug_needed := $(call seq,$(call lc,$(DEBUG)),y)\n```", "```\ninclude gmsl\n\ndebug_needed := $(call or,$(call seq,$(call lc,$(DEBUG)),y),$(call seq,$(call lc,$(DEBUG)),yes))\n```", "```\ninclude gmsl\n\n$(call assert,$(call or,$(call seq,$(DEBUG),Y),$(call seq,$(DEBUG),N)),DEBUG must be Y or N)\n```", "```\n$ **make DEBUG=Oui**\nMakefile:1: *** GNU Make Standard Library: Assertion failure: DEBUG must be Y or N.\nStop.\n```", "```\nifeq ($(DEBUG),$(filter $(DEBUG),Y Yes))\n--*snip*--\nendif\n```", "```\nifeq (x$(DEBUG)x,$(filter x$(DEBUG)x,xYx xYesx))\n--*snip*--\nendif\n```", "```\ninclude gmsl\n\nifeq ($(true),$(call or,$(call seq,$(DEBUG),Y),$(call seq,$(DEBUG),Yes)))\n--*snip*--\nendif\n```", "```\ninclude gmsl\n\nsimple-path := $(call merge,:,$(call uniq,$(call split,:,$(PATH))))\n```", "```\nchar * ver = \"1.0.0\";\n```", "```\n   VERSION_C := version.c\n   VERSION := $(shell cat $(VERSION_C))\n\n   space :=\n   space +=\n\n   PARTS := $(call split,\",$(subst $(space),,$(VERSION)))\n\n   VERSION_NUMBER := $(call split,.,$(word 2,$(PARTS)))\n   MAJOR := $(word 1,$(VERSION_NUMBER))\n   MINOR := $(word 2,$(VERSION_NUMBER))\n   DOT := $(word 3,$(VERSION_NUMBER))\n   major-release minor-release dot-release:\n➊ → @$(eval increment_name := $(call uc,$(subst -release,,$@)))\n➋ → @$(eval $(increment_name) := $(call inc,$($(increment_name))))\n➌ → @echo 'char * ver = \"$(MAJOR).$(MINOR).$(DOT)\";' > $(VERSION_C)\n```", "```\n$ **make -n major-release**\necho 'char * ver = \"2.0.0\";' > version.c\n$ **make -n minor-release**\necho 'char * ver = \"1.1.0\";' > version.c\n$ **make -n dot-release**\necho 'char * ver = \"1.0.1\";' > version.c\n```", "```\n$(call or,$(wildcard /tmp/foo),$(wildcard /tmp/bar))\n```", "```\nmake-bool = $(if $(strip $1),$(true),$(false))\n```", "```\njanuary-now := $(call make-bool,$(filter Jan,$(shell date)))\n```", "```\ncontains-word = $(call make-bool,$(filter $1,$2))\njanuary-now := $(call contains-word,Jan,$(shell date))\n```", "```\n**not**\n\nArgument: A single boolean value\nReturns:  $(true) if the boolean is $(false) and vice versa\n```", "```\n**and**\n\nArguments: Two boolean values\nReturns:   $(true) if both of the arguments are $(true)\n```", "```\n**or**\n\nArguments: Two boolean values\nReturns:   $(true) if either of the arguments is $(true)\n```", "```\n**xor**\n\nArguments: Two boolean values\nReturns:   $(true) if exactly one of the booleans is true\n```", "```\n**nand**\n\nArguments: Two boolean values\nReturns:   Value of 'not and'\n```", "```\n**nor**\n\nArguments: Two boolean values\nReturns:   Value of 'not or'\n```", "```\n**xnor**\n\nArguments: Two boolean values\nReturns:   Value of 'not xor'\n```", "```\n**int_decode**\n\nArguments: 1: A number in x-representation\nReturns:   The integer for human consumption that is represented\n           by the string of x's\n```", "```\n**int_encode**\n\nArguments: 1: A number in human-readable integer form\nReturns:   The integer encoded as a string of x's\n```", "```\n**int_plus**\n\nArguments: 1: A number in x-representation\n           2: Another number in x-representation\nReturns:   The sum of the two numbers in x-representation\n```", "```\n**plus** (wrapped version of int_plus)\n\nArguments: 1: An integer\n           2: Another integer\nReturns:   The sum of the two integers\n```", "```\n**int_subtract**\n\nArguments: 1: A number in x-representation\n           2: Another number in x-representation\nReturns:   The difference of the two numbers in x-representation,\n           or outputs an error on a numeric underflow\n```", "```\n**subtract** (wrapped version of int_subtract)\n\nArguments: 1: An integer\n           2: Another integer\nReturns:   The difference of the two integers, or outputs an error on a\n           numeric underflow\n```", "```\n**int_multiply**\n\nArguments: 1: A number in x-representation\n           2: Another number in x-representation\nReturns:   The product of the two numbers in x-representation\n```", "```\n**multiply** (wrapped version of int_multiply)\n\nArguments: 1: An integer\n           2: Another integer\nReturns:   The product of the two integers\n```", "```\n**int_divide**\nArguments: 1: A number in x-representation\n           2: Another number in x-representation\nReturns:   The result of integer division of argument 1 divided\n           by argument 2 in x-representation\n```", "```\n**divide** (wrapped version of int_divide)\n\nArguments: 1: An integer\n           2: Another integer\nReturns:   The integer division of the first argument by the second\n```", "```\n**int_max**, **int_min**\n\nArguments: 1: A number in x-representation\n           2: Another number in x-representation\nReturns:   The maximum or minimum of its arguments in x-representation\n```", "```\n**max**, **min**\n\nArguments: 1: An integer\n           2: Another integer\nReturns:   The maximum or minimum of its integer arguments\n```", "```\n**int_inc**\n\nArguments: 1: A number in x-representation\nReturns:   The number incremented by 1 in x-representation\n```", "```\n**inc**\n\nArguments: 1: An integer\nReturns:   The argument incremented by 1\n```", "```\n**int_dec**\n\nArguments: 1: A number in x-representation\nReturns:   The number decremented by 1 in x-representation\n```", "```\n**dec**\n\nArguments: 1: An integer\nReturns:   The argument decremented by 1\n```", "```\n**int_double**\n\nArguments: 1: A number in x-representation\nReturns:   The number doubled (* 2) and returned in x-representation\n```", "```\n**double**\n\nArguments: 1: An integer\nReturns:   The integer times 2\n```", "```\n**int_halve**\n\nArguments: 1: A number in x-representation\nReturns:   The number halved (/ 2) and returned in x-representation\n```", "```\n**halve**\n\nArguments: 1: An integer\nReturns:   The integer divided by 2\n```", "```\n**int_gt**, **int_gte**, **int_lt**, **int_lte**, **int_eq**, **int_ne**\n\nArguments: Two x-representation numbers to be compared\nReturns:   $(true) or $(false)\n\nint_gt  First argument is greater than second argument\nint_gte First argument is greater than or equal to second argument\nint_lt  First argument is less than second argument\nint_lte First argument is less than or equal to second argument\nint_eq  First argument is numerically equal to the second argument\nint_ne  First argument is not numerically equal to the second argument\n```", "```\n**gt**, **gte**, **lt**, **lte**, **eq**, **ne**\n\nArguments: Two integers to be compared\nReturns:   $(true) or $(false)\n\nint_gt  First argument is greater than second argument\nint_gte First argument is greater than or equal to second argument\nint_lt  First argument is less than second argument\nint_lte First argument is less than or equal to second argument\nint_eq  First argument is numerically equal to the second argument\nint_ne  First argument is not numerically equal to the second argument\n```", "```\n**sequence**\n\nArguments: 1: An integer\n           2: An integer\nReturns:   The sequence [arg1 arg2] if arg1 >= arg2 or [arg2 arg1] if arg2 > arg1\n```", "```\n**dec2hex**, **dec2bin**, **dec2oct**\n\nArguments: 1: An integer\nReturns:   The decimal argument converted to hexadecimal, binary or octal\n```", "```\n__repeat = $(if $2,$(call $0,$1,$(call rest,$2),$1$3),$3)\n\nrepeat = $(call __repeat,$1,$(call int_encode,$2),)\n```", "```\npad = $(call repeat,$1,$(call subtract,$2,$(call strlen,$3)))$3\n\npaddeddec2hex = $(call pad,0,$2,$(call dec2hex,$1))\n```", "```\nSRCS := src/FOO.c src/SUBMODULE/bar.c src/foo.c\nNORMALIZED := $(call uniq,$(call map,lc,$(SRCS)))\n```", "```\nsize = $(firstword $(shell wc -c $1))\n\nSOURCE_SIZES := $(call map,size,$(SRCS))\n```", "```\nreduce = $(if $2,$(call $0,$1,$(call rest,$2),$(call $1,$3,$(firstword $2))),$3)\n```", "```\nsum-list = $(call reduce,plus,$1,0)\n```", "```\n$(call plus,1,0) which returns 1\n$(call plus,1,2) which returns 3\n$(call plus,3,3) which returns 6\n$(call plus,6,4) which returns 10\n$(call plus,10,5) which returns 15\n```", "```\nTOTAL_SIZE := $(call sum-list,$(SOURCE_SIZES))\n```", "```\nzip = $1:$2\n\nSOURCES_WITH_SIZES := $(call pairmap,zip,$(SRCS),$(SOURCE_SIZES))\n```", "```\n**first**\n\nArguments: 1: A list\nReturns:   Returns the first element of a list\n```", "```\n**last**\n\nArguments: 1: A list\nReturns:   The last element of a list\n```", "```\n**rest**\n\nArguments: 1: A list\nReturns:   The list with the first element removed\n```", "```\n**chop**\n\nArguments: 1: A list\nReturns:   The list with the last element removed\n```", "```\n**map**\nArguments: 1: Name of function to $(call) for each element of list\n           2: List to iterate over calling the function in 1\nReturns:   The list after calling the function on each element\n```", "```\n**pairmap**\n\nArguments: 1: Name of function to $(call) for each pair of elements\n           2: List to iterate over calling the function in 1\n           3: Second list to iterate over calling the function in 1\nReturns:   The list after calling the function on each pair of elements\n```", "```\n**leq**\n\nArguments: 1: A list to compare against...\n           2: ...this list\nReturns:   $(true) if the two lists are identical\n```", "```\n**lne**\n\nArguments: 1: A list to compare against...\n           2: ...this list\nReturns:   $(true) if the two lists are different\n```", "```\n**reverse**\n\nArguments: 1: A list to reverse\nReturns:   The list with its elements in reverse order\n```", "```\n**uniq**\n\nArguments: 1: A list to deduplicate\nReturns:   The list with elements in the original order but without duplicates\n```", "```\n**length**\n\nArguments: 1: A list\nReturns:   The number of elements in the list\n```", "```\n# space contains the space character\n\nspace :=\nspace +=\n\n# tab contains a tab\n\ntab :=→  # needed to protect the tab character\n\n$(info $(call seq,White Space,White Space))\n$(info $(call seq,White$(space)Space,White Space))\n$(info $(call sne,White$(space)Space,White$(tab)Space))\n$(info $(call seq,$(tab),$(tab)))\n$(info $(call sne,$(tab),$(space)))\n```", "```\nCSV_LINE := src/foo.c,gcc,-Wall\n\ncomma := ,\nFIELDS := $(call split,$(comma),$(CSV_LINE))\n\n$(info Compile '$(word 1,$(FIELDS))' using compiler '$(word 2,$(FIELDS))' with \\\noptions '$(word 3,$(FIELDS))')\n```", "```\nDIRS := /usr/bin /usr/sbin /usr/local/bin /home/me/bin\n\nlist-to-path = $(call merge,:,$1)\n\n$(info $(call list-to-path,$(DIRS)))\n```", "```\nleet = $(call tr,A E I O L T,4 3 1 0 1 7,$1)\n\n$(info $(call leet,I AM AN ELITE GNU MAKE HAXOR))\n```", "```\n**seq**\n\nArguments: 1: A string to compare against...\n           2: ...this string\nReturns:   $(true) if the two strings are identical\n```", "```\n**sne**\n\nArguments: 1: A string to compare against...\n           2: ...this string\nReturns:   $(true) if the two strings are not the same\n```", "```\n**strlen**\n\nArguments: 1: A string\nReturns:   The length of the string\n```", "```\n**substr**\n\nArguments: 1: A string\n           2: Starting offset (first character is 1)\n           3: Ending offset (inclusive)\nReturns:   A substring\n```", "```\n**split**\n\nArguments: 1: The character to split on\n           2: A string to split\nReturns:   A list separated by spaces at the split character in the\n           first argument\n```", "```\n**merge**\n\nArguments: 1: The character to put between fields\n           2: A list to merge into a string\nReturns:   A single string, list elements are separated by the character in\n           the first argument\n```", "```\n**tr**\n\nArguments: 1: The list of characters to translate from \n           2: The list of characters to translate to\n           3: The text to translate\nReturns:   The text after translating characters\n```", "```\n**uc**\n\nArguments: 1: Text to uppercase\nReturns:   The text in uppercase\n```", "```\n**lc**\n\nArguments: 1: Text to lowercase\nReturns:   The text in lowercase\n```", "```\nMADE_DIRS := $(empty_set)\n\nmarker = $1.f\nmake_dir = $(eval $1.f: ; @$$(eval MADE_DIRS := $$(call      \\\nset_insert,$$(dir $$@),$$(MADE_DIRS))) mkdir -p $$(dir $$@); \\\ntouch $$@)\n\nall: $(call marker,/tmp/foo/) $(call marker,/tmp/bar/)\n→  @echo Directories made: $(MADE_DIRS)\n\n$(call make_dir,/tmp/foo/)\n$(call make_dir,/tmp/bar/)\n```", "```\n**set_create**\n\nArguments: 1: A list of set elements\nReturns:   The newly created set\n```", "```\n**set_insert**\n\nArguments: 1: A single element to add to a set\n           2: A set\nReturns:   The set with the element added\n```", "```\n**set_remove**\n\nArguments: 1: A single element to remove from a set\n           2: A set\nReturns:   The set with the element removed\n```", "```\n**set_is_member**\n\nArguments: 1: A single element\n           2: A set\nReturns:   $(true) if the element is in the set\n```", "```\n**set_union**\n\nArguments: 1: A set\n           2: Another set\nReturns:   The union of the two sets\n```", "```\n**set_intersection**\n\nArguments: 1: A set\n           2: Another set\nReturns:   The intersection of the two sets\n```", "```\n**set_is_subset**\n\nArguments: 1: A set\n           2: Another set\nReturns:   $(true) if the first set is a subset of the second\n```", "```\n**set_equal**\n\nArguments: 1: A set\n           2: Another set\nReturns:   $(true) if the two sets are identical\n```", "```\nC_FILES := $(wildcard *.c)\n\nget-size = $(call first,$(shell wc -c $1))\n$(foreach c,$(C_FILES),$(call set,c_files,$c,$(call get-size,$c)))\n\n$(info All the C files: $(call keys,c_files))\n$(info foo.c has size $(call get,c_files,foo.c))\n```", "```\n$ **make**\nAll the C files: bar.c foo.c foo.c\nhas size 551\n```", "```\n**set**\n\nArguments: 1: Name of associative array\n           2: The key value to associate\n           3: The value associated with the key\nReturns:   Nothing\n```", "```\n**get**\n\nArguments: 1: Name of associative array\n           2: The key to retrieve\nReturns:   The value stored in the array for that key\n```", "```\n**keys**\n\nArguments: 1: Name of associative array\nReturns:   A list of all defined keys in the array\n```", "```\n**defined**\n\nArguments: 1: Name of associative array\n           2: The key to test\nReturns:   $(true) if the key is defined (i.e., not empty)\n```", "```\ntraverse-tree = $(foreach d,$(patsubst %/.,%,$(wildcard $1/*/.)),  \\\n$(call push,dirs,$d)$(call traverse-tree,$d))\n\n$(call traverse-tree,sources)\n\ndump-tree = $(if $(call sne,$(call depth,dirs),0),$(call pop,dirs) \\\n$(call dump-tree))\n\n$(info $(call dump-tree))\n```", "```\n$ **ls -R sources**\nsources:\nbar  foo\n\nsources/bar:\nbarsub\nsources/bar/barsub:\n\nsources/foo:\nsubdir  subdir2\n\nsources/foo/subdir:\nsubsubdir\n\nsources/foo/subdir/subsubdir:\n\nsources/foo/subdir2:\n```", "```\nsources/foo sources/foo/subdir2 sources/foo/subdir sources/foo/subdir/\nsubsubdir sources/bar sources/bar/barsub\n```", "```\n__dfs = $(if $(call sne,$(call depth,work),0),$(call push,dirs,$(call    \\\npeek,work)$(foreach d,$(patsubst %/.,%,$(wildcard $(call                 \\\npop,work)/*/.)),$(call push,work,$d)))$(call __dfs))\n\ndfs = $(call push,work,$1)$(call __dfs)\n\n$(call dfs,sources)\n\ndump-tree = $(if $(call sne,$(call depth,dirs),0),$(call pop,dirs) $(call \\\ndump-tree))\n\n$(info $(call dump-tree,dirs))\n```", "```\nsources/bar/barsub sources/bar sources/foo/subdir/subsubdir sources/foo/subdir\nsources/foo/subdir2 sources/foo sources.\n```", "```\n**push**\n\nArguments: 1: Name of stack\n           2: Value to push onto the top of the stack (must not contain\n           a space)\nReturns:   None\n```", "```\n**pop**\n\nArguments: 1: Name of stack\nReturns:   Top element from the stack after removing it\n```", "```\n**peek**\n\nArguments: 1: Name of stack\nReturns:   Top element from the stack without removing it\n```", "```\n**depth**\n\nArguments: 1: Name of stack\nReturns:   Number of items on the stack\n```", "```\nmd5 = $(shell md5sum $1)\n```", "```\nmd5once = $(call memoize,md5,$1)\n```", "```\n$(info $(call md5once,/etc/passwd))\n$(info $(call md5once,/etc/passwd))\n```", "```\n**memoize**\n\nArguments: 1: Name of function to memoize\n           2: String argument for the function\nReturns:   Result of $1 applied to $2 but only calls $1 once for each unique $2\n```", "```\n**gmsl_compatible**\n\nArguments: List containing the desired library version number (major minor\n           revision)\nReturns:   $(true) if the current version of the library is compatible\n           with the requested version number, otherwise $(false)\n```", "```\ninclude gmsl\n\nFOO := foo bar baz\nall:\n```", "```\n**gmsl-print-%** (target not a function)\n\nArguments: The % should be replaced by the name of a variable that you\n           wish to print\nAction:    Echoes the name of the variable that matches the % and its value\n```", "```\n**assert**\n\nArguments: 1: A boolean that must be true or the assertion will fail\n           2: The message to print with the assertion\nReturns:   None\n```", "```\n**assert_exists**\n\nArguments: 1: Name of file that must exist, if it is missing an assertion\n           will be generated\nReturns:   None\n```", "```\ninclude gmsl\n\n$(call assert,$(false),Always fail)\n\nall:\n```", "```\n$ **make**\nMakefile:5: *** GNU Make Standard Library: Assertion failure: Always fail.\nStop.\n$ **make GMSL_NO_ERRORS=1**\nmake: Nothing to be done for `all'.\n```"]