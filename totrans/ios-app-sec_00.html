<html><head></head><body>
<h2 class="h2" id="intro"><a id="page_xxiii"/><strong>INTRODUCTION</strong></h2>
<p class="noindent">Much has been written regarding iOS’s security model, jailbreaking, finding code execution vulnerabilities in the base OS, and other security-related characteristics. Other work has focused on examining iOS from a forensic perspective, including how to extract data from physical devices or backups as part of criminal investigations. That information is all useful, but this book aims to fill the biggest gaps in the iOS literature: applications.</p>
<p class="indent">Little public attention has been given to actually writing secure applications for iOS or for performing security evaluations of iOS applications. As a consequence, embarrassing security flaws in iOS applications have allowed for exposure of sensitive data, circumvention of authentication mechanisms, and abuse of user privacy (both intentional and accidental). People are using iOS applications for more and more crucial tasks and entrusting them with a lot of sensitive information, and iOS application security needs to mature in response.</p>
<p class="indent"><a id="page_xxiv"/>As such, my goal is for this book is to be as close as possible to the canonical work on the secure development of iOS applications in particular. iOS is a rapidly moving target, of course, but I’ve tried to make things as accurate as possible and give you the tools to inspect and adapt to future API changes.</p>
<p class="indent">Different versions of iOS also have different flaws. Since Apple has “end-of-lifed” certain devices that developers may still want their applications to run on (like the iPad 1), this book covers flaws present in iOS versions 5.<em>x</em> to 9.0 (the latest at the time of writing) and, where applicable, discusses risks and mitigations specific to each version.</p>
<h3 class="h3" id="introlev1sec01"><strong>Who This Book Is For</strong></h3>
<p class="noindent">First, this is a book about security. If you’re a developer or security specialist looking for a guide to the common ways iOS applications fail at protecting their users (and the options available to you or a client for patching those holes), you’re in the right place.</p>
<p class="indent">You’ll get the most out of this book if you have at least a little experience with iOS development or a passing familiarity with how iOS applications work under the hood. But even without that knowledge, as long as you’re an experienced programmer or penetration tester who’s not afraid to dig in to Apple’s documentation as needed, you should be fine. I give a whirlwind tour of Objective-C and its most commonly used API, Cocoa Touch, in <a href="ch02.html#ch02">Chapter 2</a>, so if you need some high-level basics or a refresher on the language, start there.</p>
<h3 class="h3" id="introlev1sec02"><strong>What’s in This Book</strong></h3>
<p class="noindent">I’ve been performing a wide variety of iOS application security reviews and penetration tests since about 2008, and I’ve collected a lot of knowledge on the pitfalls and mistakes real-world developers encounter when writing iOS applications. This book boils down that knowledge to appeal both to iOS developers looking to learn the practice of secure development and to security specialists wanting to learn how to spot problems in iOS security.</p>
<h4 class="h4" id="introlev2sec01"><em><strong>How This Book Is Structured</strong></em></h4>
<p class="noindentb">In <strong><a href="part01.html#part01">Part I: iOS Fundamentals</a></strong>, you’ll dig in to the background of iOS, its security history, and its basic application structure.</p>
<p class="bull">• <strong><a href="ch01.html#ch01">Chapter 1: The iOS Security Model</a></strong> briefly examines the iOS security model to give you an idea of the platform’s fundamental security protections and what they can and cannot provide.</p>
<p class="bull">• <strong><a href="ch02.html#ch02">Chapter 2: Objective-C for the Lazy</a></strong> explains how Objective-C differs from other programming languages and gives a quick overview of its terminology and design patterns. For seasoned Objective-C programmers, <a id="page_xxv"/>this may not be new information, but it should be valuable to beginners and others dabbling in iOS for the first time.</p>
<p class="bull">• <strong><a href="ch03.html#ch03">Chapter 3: iOS Application Anatomy</a></strong> outlines how iOS applications are structured and bundled and investigates the local storage mechanisms that can leak sensitive information.</p>
<p class="indenttb">In <strong><a href="part02.html#part02">Part II: Security Testing</a></strong>, you’ll see how to set up your security testing environment, for use either in development or in penetration testing. I’ll also share some tips for setting up your Xcode projects to get the most out of the available security mechanisms.</p>
<p class="bull">• <strong><a href="ch04.html#ch04">Chapter 4: Building Your Test Platform</a></strong> gives you all the information that you need to get started with tools and configurations to help you audit and test iOS applications. This includes information on using the Simulator, configuring proxies, bypassing TLS validation, and analyzing application behavior.</p>
<p class="bull">• <strong><a href="ch05.html#ch05">Chapter 5: Debugging with lldb and Friends</a></strong> goes deeper into monitoring application behavior and bending it to your will using lldb and Xcode’s built-in tools. This will help you analyze more complex problems in your code, as well as give you a test harness to do things like fault injection.</p>
<p class="bull">• <strong><a href="ch06.html#ch06">Chapter 6: Black-Box Testing</a></strong> delves into the tools and techniques that you’ll need to successfully analyze applications that you don’t have source code for. This includes basic reverse engineering, binary modification, copying programs around, and debugging on the device with a remote instance of lldb.</p>
<p class="indenttb">In <strong><a href="part03.html#part03">Part III: Security Quirks of the Cocoa API</a></strong>, you’ll look at common security pitfalls in the Cocoa Touch API.</p>
<p class="bull">• <strong><a href="ch07.html#ch07">Chapter 7: iOS Networking</a></strong> discusses how networking and Transport Layer Security work in iOS, including information on authentication, certificate pinning, and mistakes in TLS connection handling.</p>
<p class="bull">• <strong><a href="ch08.html#ch08">Chapter 8: Interprocess Communication</a></strong> covers interprocess communication mechanisms, including URL schemes and the newer Universal Links mechanism.</p>
<p class="bull">• <strong><a href="ch09.html#ch09">Chapter 9: iOS-Targeted Web Apps</a></strong> covers how web applications are integrated with iOS native apps, including working with web views or using JavaScript/Cocoa bridges such as Cordova.</p>
<p class="bull">• <strong><a href="ch10.html#ch10">Chapter 10: Data Leakage</a></strong> discusses the myriad ways that sensitive data can unintentionally leak onto local storage, to other applications, or over the network.</p>
<p class="bull">• <strong><a href="ch11.html#ch11">Chapter 11: Legacy Issues and Baggage from C</a></strong> gives an overview of C flaws that persist in iOS applications: stack and heap corruption, format string flaws, use-after-free, and some Objective-C variants of these classic flaws.</p>
<p class="bull"><a id="page_xxvi"/>• <strong><a href="ch12.html#ch12">Chapter 12: Injection Attacks</a></strong> covers attacks such as SQL injection, cross-site scripting, XML injection, and predicate injection, as they relate to iOS applications.</p>
<p class="indenttb">Finally, <strong><a href="part04.html#part04">Part IV: Keeping Data Safe</a></strong> covers issues relating to privacy and encryption.</p>
<p class="bull">• <strong><a href="ch13.html#ch13">Chapter 13: Encryption and Authentication</a></strong> looks at encryption best practices, including how to properly use the Keychain, the Data Protection API, and other cryptographic primitives provided by the CommonCrypto framework.</p>
<p class="bull">• <strong><a href="ch14.html#ch14">Chapter 14: Mobile Privacy Concerns</a></strong> ends the book with a discussion of user privacy, including what collecting more data than needed can mean for both application creators and users.</p>
<p class="indentt">By the end of this book, you should be well equipped to grab an application, with or without source code, and quickly pinpoint security bugs. You should also be able to write safe and secure applications for use in the wider world.</p>
<h4 class="h4" id="introlev2sec02"><em><strong>Conventions This Book Follows</strong></em></h4>
<p class="noindent">Because Objective-C is a rather verbose language with many extremely long class and method names, I’ve wrapped lines in source code listings to maximize clarity. This may not reflect the way you’d actually want to format your code. In some cases, the results are unavoidably ugly—if wrapping makes the code seem less clear, try pasting it into Xcode and allowing Xcode to reformat it.</p>
<p class="indent">As I will detail in <a href="ch02.html#ch02">Chapter 2</a>, I favor the traditional Objective-C infix notation instead of dot notation. I also put curly braces on the same line as method declarations for similar reasons: I’m old.</p>
<p class="indent">Objective-C class and method names will appear in <span class="literal">monospaced</span> font. C functions will appear in <span class="literal">monospaced</span> font as well. For brevity and cleanliness, the path <em>/Users/&lt;your username&gt;/Library/Developer/CoreSimulator/</em> will be referred to as <em>$SIMPATH</em>.</p>
<h4 class="h4" id="introlev2sec03"><em><strong>A Note on Swift</strong></em></h4>
<p class="noindent">There’s been much interest in the relatively new Swift language, but you’ll find I don’t cover it in this book. There are a few reasons why.</p>
<p class="indent">First, I have yet to actually come across a production application written in Swift. Objective-C is still far and away the most popular language for iOS applications, and we’ll be dealing with code written in it for many years to come.</p>
<p class="indent">Second, Swift just has fewer problems. Since it’s not based on C, it’s easier to write safer code, and it doesn’t introduce any new security flaws (as far as anyone knows).</p>
<p class="indent">Third, because Swift uses the same APIs as Objective-C, the security pitfalls in the Cocoa Touch API that you may run into will be basically the <a id="page_xxvii"/>same in either language. The things you learn in this book will almost all apply to both Objective-C and Swift.</p>
<p class="indent">Also, Swift doesn’t use infix notation and square brackets, which makes me sad and confused.</p>
<h3 class="h3" id="introlev1sec03"><strong>Mobile Security Promises and Threats</strong></h3>
<p class="noindent">When I first started working with mobile applications, I honestly questioned the need for a separate mobile application security category. I considered mobile applications to be the same as desktop applications when it came to bugs: stack and heap overflows, format string bugs, use-after-free, and other code execution issues. While these are still possible in iOS, the security focus for mobile devices has expanded to include privacy, data theft, and malicious interprocess communication.</p>
<p class="indent">As you read about the iOS security specifics I cover in this book, keep in mind that users expect apps to avoid doing certain things that will put their security at risk. Even if an app avoids overtly risky behaviors, there are still several threats to consider as you fortify that app’s defenses. This section discusses both security promises an app makes to its users and the types of attacks that can force an app to break them.</p>
<h4 class="h4" id="introlev2sec04"><em><strong>What Mobile Apps Shouldn’t Be Able to Do</strong></em></h4>
<p class="noindent">Learning from the design mistakes of earlier desktop operating systems, the major mobile operating systems were designed with application segregation in mind. This is different from desktop applications, where any application a user runs more or less has access to all that user’s data, if not control of the entire machine.</p>
<p class="indent">As a result of increased focus on segregation and general improvements in the mobile OS arena, user expectations have expanded. In general, mobile applications (including yours) should be unable to do a few key things.</p>
<h5 class="h5" id="introlev3sec01"><strong>Cause Another Application to Misbehave</strong></h5>
<p class="noindent">Applications shouldn’t be able to crash or meddle with other applications. In the bad old days, not only could other applications generally read, modify, or destroy data, they could take down the entire OS with that data. As time went on, desktop process segregation improved but primarily with the goal of increasing stability, rather than addressing security or privacy concerns.</p>
<p class="indent">Mobile operating systems improve upon this, but total process segregation is not possible while fulfilling users’ interoperability needs. The boundary between applications will always be somewhat porous. It’s up to developers to ensure that their applications don’t misbehave and to take all prudent measures to safeguard data and prevent interference from malicious applications.</p>
<h5 class="h5" id="introlev3sec02"><a id="page_xxviii"/><strong>Deny Service to a User</strong></h5>
<p class="noindent">Given that iOS has historically been used primarily on phones, it’s crucial that an application not be able to do something that would prevent the user from making an emergency call. In many places, this is a legal requirement, and it’s the reason for protective measures that keep attackers (and users) from tampering with the underlying OS.</p>
<h5 class="h5" id="introlev3sec03"><strong>Steal a User’s Data</strong></h5>
<p class="noindent">An application should not be able to read data from other applications or the base OS and deliver it to a third party. It should also not be able to access sensitive user data without the permission of the user. The OS should keep applications from reading data directly from other application’s data stores, but preventing theft via other channels requires developers to pay attention to what IPC mechanisms an application sends or receives data on.</p>
<h5 class="h5" id="introlev3sec04"><strong>Cost the User Unexpected Money</strong></h5>
<p class="noindent">Apps shouldn’t be able to incur charges without the user’s approval. Much of the mobile malware that has been found in the wild has used the ability to send SMS messages to subscribe the user to third-party services, which pass charges through to the user’s phone provider. Purchases made within the application should be clear to the user and require explicit approval.</p>
<h4 class="h4" id="introlev2sec05"><em><strong>Classifying Mobile Security Threats in This Book</strong></em></h4>
<p class="noindent">To help understand mobile device security threats and their mitigations, it’s also useful to keep a few attack types in mind. This keeps our analysis of threats realistic and helps to analyze the true impact of various attacks and their defenses.</p>
<h5 class="h5" id="introlev3sec05"><strong>Forensic Attacks</strong></h5>
<p class="noindent">Forensic attackers come into possession of a device or its backups, intending to extract its secrets. Most often, this involves examination of the physical storage on the device. Because phone or tablet theft is relatively easy and common compared to stealing other computing devices, much more attention is placed on forensics.</p>
<p class="indent">Forensic attacks can be performed by either an opportunistic attacker or a skilled attacker targeting a specific individual. For opportunistic attackers, extracting information can be as simple as stealing a phone without any PIN protection; this allows them to steal images, notes, and any other data normally accessible on the phone. It can also assist an attacker in compromising services that use two-factor authentication in conjunction with a phonebased token or SMS.</p>
<p class="indent">A skilled forensic attacker could be a rogue employee, corporation, government, law enforcement official, or perhaps really motivated extortionist. This kind of attacker knows the techniques to perform a temporary jailbreak, crack simple PINs, and examine data throughout the device’s filesystem, including system-level and application-level data. This can provide <a id="page_xxix"/>an attacker with not just data presented through the UI but the underlying cache information, which can include screenshots, keystrokes, sensitive information cached in web requests, and so forth.</p>
<p class="indent">I’ll cover much of the data of interest to forensic attackers in <a href="ch10.html#ch10">Chapter 10</a>, as well as some further protective measures in <a href="ch13.html#ch13">Chapter 13</a>.</p>
<h5 class="h5" id="introlev3sec06"><strong>Code Execution Attacks</strong></h5>
<p class="noindent">Remote code execution attacks involve compromising the device or its data by execution of code on the device, without having physical possession of the device. This can happen via many different channels: the network, QR codes or NFC, parsing of maliciously crafted files, or even hostile hardware peripherals. Note that after gaining code execution on a device, many of the forensic attacks used to expose user secrets are now possible. There are a few basic subtypes of code execution attacks that frequently result from lower-level programming flaws, which I’ll discuss in <a href="ch11.html#ch11">Chapter 11</a>.</p>
<h5 class="h5" id="introlev3sec07"><strong>Web-Based Attacks</strong></h5>
<p class="noindent">Web-based remote code execution attacks primarily use maliciously crafted HTML and JavaScript to mislead the user or steal data. A remote attacker either operates a malicious website, has taken over a legitimate website, or simply posts maliciously crafted content to a public forum.</p>
<p class="indent">These attacks can be used to steal data from local data stores such as HTML5 database storage or localStorage, alter or steal data stored in SQLite databases, read session cookies, or plant a fake login form to steal a user’s credentials. I’ll talk more about web application–related issues in <a href="ch09.html#ch09">Chapter 9</a> and <a href="ch12.html#ch12">Chapter 12</a>.</p>
<h5 class="h5" id="introlev3sec08"><strong>Network-Based Attacks</strong></h5>
<p class="noindent">Network-based code execution attacks attempt to gain control over an application or the entire system by injecting executable code of some type over the network. This can be either modification of network traffic coming into the device or exploitation of a system service or the kernel with a code execution exploit. If the exploit targets a process with a high degree of privilege, the attacker can gain access not only to the data of a specific application but to data all over the device’s storage. They can also monitor the device’s activity and plant backdoors that will allow later access. I’ll talk specifically about network-related APIs in <a href="ch07.html#ch07">Chapter 7</a>.</p>
<h5 class="h5" id="introlev3sec09"><strong>Attacks That Rely on Physical Proximity</strong></h5>
<p class="noindent">Physical code execution attacks tend to be exploits that target devices using communications such as NFC or the USB interface. These types of attacks have been used for jailbreaking in the past but can also be used to compromise the device using brief physical interaction. Many of these attacks are on the OS itself, but I’ll discuss some issues relating to physical proximity in <a href="ch14.html#ch14">Chapter 14</a>.</p>
<h3 class="h3" id="introlev1sec04"><a id="page_xxx"/><strong>Some Notes for iOS Security Testers</strong></h3>
<p class="noindent">It’s my strong belief that penetration tests should be performed with source code if at all possible. While this is not representative of the position of most external attackers, it does maximize the ability to find important bugs within a limited time frame. Real-world attackers have as much time as they care to spend on analyzing your application, and Objective-C lends well to reverse engineering. They’ll figure it out, given the time. However, most penetration tests are limited by time and money, so simulating a real-world attacker should not usually be the goal.</p>
<p class="indent">I cover both white-box (that is, source-assisted) and black-box methodologies in this book, but the focus will be on source-assisted penetration tests because this finds more bugs faster and helps with learning the standard Cocoa library. Many techniques I describe in this book lend well to either approach.</p>
<p class="indent">All that said, iOS developers come from many different disciplines, and each person’s skill set affects the types of security issues that slip into an app unnoticed. Whether you’re testing someone else’s application or trying to poke holes in your own, keep in mind a few different development backgrounds as you test.</p>
<p class="indent">Some iOS developers come from a C or C++ background, and since we all tend to use what we know, you’ll find their codebases often use C/C++ APIs rather than Cocoa equivalents. If you know an application under test was created by former C/C++ programmers, you may find <a href="ch11.html#ch11">Chapter 11</a> to be useful reading because it discusses issues commonly found in straight C/C++ code.</p>
<p class="indent">For some new programmers, Objective-C is actually their first programming language. They often haven’t learned that many vanilla C APIs, so ideally, you’ll find fewer of those issues. There’s also the rare wizened NeXTStep programmer who’s made the move to OS X or iOS, with a library of collected wisdom regarding NeXTStep/Cocoa APIs but less mobile experience. If either sounds like you or your client, you’ll find the chapters in <a href="part03.html#part03">Part III</a> most helpful.</p>
<p class="indent">Programmers with Java backgrounds might try to force Java design patterns onto an application, endlessly abstracting functionality. Web developers who have been drafted into writing a mobile application, on the other hand, may try to wrap as much code as possible into a web app, writing minimal applications that rely on WebKit to view application content. Check out <a href="ch09.html#ch09">Chapter 9</a> for some WebKit-related pitfalls.</p>
<p class="indent">Developers with the last few skill sets I mentioned are less likely to use low-level APIs, which can prevent classic C flaws. They are, however, unlikely to spot mistakes when using those low-level APIs, so you’ll want to pay close attention if they use them.</p>
<p class="indent"><a id="page_xxxi"/>Of course, none of these backgrounds is necessarily better suited to secure development than the others—both high-level and low-level APIs can be abused. But when you know how existing skills can affect the writing of iOS applications, you’re a step closer to finding and solving security issues.</p>
<p class="indent">My own background is that of a penetration tester, which I consider akin to being an art critic: I <em>can</em> write code, but the vast majority of my time is spent looking at other people’s code and telling them what’s wrong with it. And like in the art world, the majority of that code is rather crap. Unlike the art world, however, code problems can often be fixed with a patch. My hope is that at the end of this book, you’ll be able to spot bad iOS code and know how to start plugging the holes.<a id="page_xxxii"/></p>
</body></html>