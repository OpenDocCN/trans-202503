<html><head></head><body>
<section epub:type="backmatter" aria-labelledby="answer">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_487" aria-label="487"/>&#13;
<hgroup>&#13;
&#13;
<h1 class="BMH" id="answer"><span class="SANS_Dogma_OT_Bold_B_11">ANSWER KEY</span></h1>&#13;
</hgroup>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h2 class="H1" id="sec1"><span id="h1-102"/><span class="SANS_Futura_Std_Bold_B_11">Chapter 2</span></h2>&#13;
<p class="ListHead"><b>2.1  Pure or Impure?</b></p>&#13;
<p class="ListPlainFirst">From a purely formal point of view, this function is impure since it uses something that wasn’t provided as an argument. Given that <span class="SANS_TheSansMonoCd_W5Regular_11">PI</span> is a constant, you could possibly stretch things a bit and accept it; after all, nobody will be able to modify <span class="SANS_TheSansMonoCd_W5Regular_11">PI</span> because of the <span class="SANS_TheSansMonoCd_W5Regular_11">const</span> definition. The best solution would be to use <span class="SANS_TheSansMonoCd_W5Regular_11">Math.PI</span> with no external variable, constant or not.</p>&#13;
<p class="ListHead"><b>2.2  Prepare for Failure</b></p>&#13;
<p class="ListPlainFirst">You must use <span class="SANS_TheSansMonoCd_W5Regular_11">try</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">catch</span>; the following is a possible solution:</p>&#13;
<pre class="pre" id="pre-365"><code><span class="listcodeannotated_CodeAnnotation" aria-label="annotation1">❶</span><span class="SANS_TheSansMonoCd_W5Regular_11"> const addLogging = (fn) =&gt; (...args) =&gt; {</span>&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation2">❷</span> console.log(`Entering ${fn.name}: ${args}`);&#13;
  try {&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation3">❸</span> const valueToReturn = fn(...args);&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation4">❹</span> console.log(`Exiting ${fn.name} returning ${valueToReturn}`);&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation5">❺</span> return valueToReturn;&#13;
  } catch (thrownError) {&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation6">❻</span> console.log(`Exiting ${fn.name} throwing ${thrownError}`);&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation7">❼</span> throw thrownError;&#13;
  }&#13;
};</code></pre>&#13;
<p class="ListBody"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_488" aria-label="488"/>The <span class="SANS_TheSansMonoCd_W5Regular_11">addLogging()</span> higher-order function takes a function as a parameter <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span> and returns a new function. If the original function throws an exception, catch it and output a proper message. Upon entry <span class="listbody_CodeAnnotation" aria-label="annotation2">❷</span>, log the function’s name and the arguments it was called with. Then try to call the original function <span class="listbody_CodeAnnotation" aria-label="annotation3">❸</span>, and if there’s no problem, log the returned value <span class="listbody_CodeAnnotation" aria-label="annotation4">❹</span> and return it back to the caller <span class="listbody_CodeAnnotation" aria-label="annotation5">❺</span>. If an exception was thrown, log it <span class="listbody_CodeAnnotation" aria-label="annotation6">❻</span> and throw it again for the caller to process <span class="listbody_CodeAnnotation" aria-label="annotation7">❼</span>.</p>&#13;
<p class="ListHead"><b>2.3  You Got Time?</b></p>&#13;
<p class="ListPlainFirst">The following function does what you need; you should note several similarities with the logging function in the previous question.</p>&#13;
<pre class="pre" id="pre-366"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span><span class="SANS_TheSansMonoCd_W5Regular_11"> const {performance} = require("perf_hooks");</span>&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> const addTiming = (fn) =&gt; (...args) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> const output = (text, name, tStart, tEnd) =&gt;&#13;
    console.log(`${name} - ${text} - Time: ${tEnd - tStart} ms`);&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> const tStart = performance.now();&#13;
  try {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> const valueToReturn = fn(...args);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> output("normal exit", fn.name, tStart, performance.now());&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> return valueToReturn;&#13;
  } catch (thrownError) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation8">❽</span> output("exception thrown", fn.name, tStart, performance.now());&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation9">❾</span> throw thrownError;&#13;
  }&#13;
};</code></pre>&#13;
<p class="ListBody">In Node.js <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span> you need to import the performance object; in a browser it’s directly available. (See <i><a href="https://nodejs.org/api/perf_hooks.html">https://nodejs.org/api/perf_hooks.html</a></i> and <i><a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance">https://developer.mozilla.org/en-US/docs/Web/API/Performance</a></i> for more information.) The <span class="SANS_TheSansMonoCd_W5Regular_11">addTiming()</span> function <span class="listbody_CodeAnnotation" aria-label="annotation2">❷</span> will get a function as a parameter and return a new function. You’ll use an auxiliary function <span class="listbody_CodeAnnotation" aria-label="annotation3">❸</span> to output the timing data. Before calling the original function <span class="listbody_CodeAnnotation" aria-label="annotation4">❹</span>, store the start time; if the call succeeds <span class="listbody_CodeAnnotation" aria-label="annotation5">❺</span> with no problem, just output the original time and the current one <span class="listbody_CodeAnnotation" aria-label="annotation6">❻</span>, returning the original returned value <span class="listbody_CodeAnnotation" aria-label="annotation7">❼</span>. If any errors occur, output a different message <span class="listbody_CodeAnnotation" aria-label="annotation8">❽</span> and throw the same exception again <span class="listbody_CodeAnnotation" aria-label="annotation9">❾</span> so the timed function will behave exactly as the original one.</p>&#13;
<p class="ListHead"><b>2.4  Parsing Problem</b></p>&#13;
<p class="ListPlainFirst">The problem is that <span class="SANS_TheSansMonoCd_W5Regular_11">.map()</span> passes three arguments to your mapping function: the current element of the array, its index, and the whole array. (See <i><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map</a></i> for more on this.) On the other hand, <span class="SANS_TheSansMonoCd_W5Regular_11">parseInt()</span> receives two parameters: the value to parse and an optional radix (10 is the default value if nothing is passed). In this case, <span class="SANS_TheSansMonoCd_W5Regular_11">parseInt()</span> is getting passed three arguments: it ignores the third extra one, but it uses the array index as the radix. For instance,<span class="SANS_TheSansMonoCd_W5Regular_11">"8"</span> is parsed as a base 3 number, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_489" aria-label="489"/>producing an error, since base 3 uses only digits 0, 1, and 2, and <span class="SANS_TheSansMonoCd_W5Regular_11">"32"</span> is parsed as a base 5 number, which is equivalent to 17.</p>&#13;
<p class="ListHead"><b>2.5  Deny Everything</b></p>&#13;
<p class="ListPlainFirst">A one-liner is enough:</p>&#13;
<pre class="pre" id="pre-367"><code>const negate = (fn) =&gt; (...args) =&gt; !fn(...args);</code></pre>&#13;
<p class="ListHead"><b>2.6  Every, Some ... None?</b></p>&#13;
<p class="ListPlainFirst">Just an example as a tip to get you started: if you want to check whether nobody in a group was an adult, you could equivalently check whether everybody wasn’t an adult, so <span class="SANS_TheSansMonoCd_W5Regular_11">people.none(isAdult)</span> could be tested as <span class="SANS_TheSansMonoCd_W5Regular_11">people.every(negate(isAdult))</span> using the previous answer.</p>&#13;
<p class="ListHead"><b>2.7  No Some, No Every</b></p>&#13;
<p class="ListPlainFirst">A hint for <span class="SANS_TheSansMonoCd_W5Regular_11">some()</span>: use <span class="SANS_TheSansMonoCd_W5Regular_11">findIndex()</span> to see whether any element satisfies the predicate; if it doesn’t return <span class="SANS_TheSansMonoCd_W5Regular_11">-1</span>, it means that at least one element fulfills your condition. For <span class="SANS_TheSansMonoCd_W5Regular_11">every()</span>, you want to see whether <span class="SANS_TheSansMonoCd_W5Regular_11">findIndex()</span> cannot find any element that satisfies <span class="SANS_TheSansMonoCd_W5Regular_11">negate(your predicate)</span>, in the same manner as in the previous question; if none is found, it means that every element fulfills your condition.</p>&#13;
<p class="ListHead"><b>2.8  What Does It Do?</b></p>&#13;
<p class="ListPlainFirst">Writing <span class="SANS_TheSansMonoCd_W5Regular_11">Boolean(someValue)</span> checks whether the given argument is “truthy” or “falsy,” returning true or false accordingly. In this case, <span class="SANS_TheSansMonoCd_W5Regular_11">"James Bond"</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">7</span> are truthy values and <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> is falsy, so the result is <span class="SANS_TheSansMonoCd_W5Regular_11">[true, false, false, true]</span>. See <i><a href="https://developer.mozilla.org/en-US/docs/Glossary/">https://developer.mozilla.org/en-US/docs/Glossary/</a></i> for the conversion rules involved.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h2 class="H1" id="sec2"><span id="h1-103"/><span class="SANS_Futura_Std_Bold_B_11">Chapter 3</span></h2>&#13;
<p class="ListHead"><b>3.1  Chaining Calls</b></p>&#13;
<p class="ListPlainFirst">The <span class="SANS_TheSansMonoCd_W5Regular_11">add()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">remove()</span> methods should just end with <span class="SANS_TheSansMonoCd_W5Regular_11">return this</span> to allow for chaining, and that’s it.</p>&#13;
<p class="ListHead"><b>3.2  Arrays, Not Objects</b></p>&#13;
<p class="ListPlainFirst">The following is a possible implementation:</p>&#13;
<pre class="pre" id="pre-368"><code><span class="listcodeannotated_CodeAnnotation" aria-label="annotation1">❶</span><span class="SANS_TheSansMonoCd_W5Regular_11"> const newBag = () =&gt; [];</span>&#13;
&#13;
<span class="listcodeannotated_CodeAnnotation" aria-label="annotation2">❷</span> const isEmpty = (bag) =&gt; bag.length === 0;&#13;
&#13;
<span class="listcodeannotated_CodeAnnotation" aria-label="annotation3">❸</span> const find = (bag, value) =&gt; bag.includes(value);&#13;
&#13;
<span class="listcodeannotated_CodeAnnotation" aria-label="annotation4">❹</span> const greatest = (bag) =&gt; isEmpty(bag) ? undefined : bag[bag.length - 1];&#13;
&#13;
<span class="listcodeannotated_CodeAnnotation" aria-label="annotation5">❺</span> const add = (bag, value) =&gt; {&#13;
  bag.push(value);&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_490" aria-label="490"/>  bag.sort();&#13;
  return bag;&#13;
};&#13;
&#13;
<span class="listcodeannotated_CodeAnnotation" aria-label="annotation6">❻</span> const remove = (bag, value) =&gt; {&#13;
  const pos = bag.indexOf(value);&#13;
  if (pos !== -1) {&#13;
    bag.splice(pos);&#13;
  }&#13;
  return bag;&#13;
};</code></pre>&#13;
<p class="ListBody1">Creating a bag <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span> is just a matter of creating an empty array, and checking whether the array’s length is zero <span class="listbody_CodeAnnotation" aria-label="annotation2">❷</span> is a way to test whether it’s empty. To find a value in the bag <span class="listbody_CodeAnnotation" aria-label="annotation3">❸</span>, use JavaScript’s own <span class="SANS_TheSansMonoCd_W5Regular_11">.includes()</span> method. You’ll keep the array in order, so implementing <span class="SANS_TheSansMonoCd_W5Regular_11">greatest</span> <span class="listbody_CodeAnnotation" aria-label="annotation4">❹</span> is simply a matter of checking whether the bag is empty (in which case, it returns <span class="SANS_TheSansMonoCd_W5Regular_11">undefined</span>, or else it returns the array’s last element). To add a value to the bag <span class="listbody_CodeAnnotation" aria-label="annotation5">❺</span>, push the value into the array and then sort the updated array. Finally, to see whether a value can be removed <span class="listbody_CodeAnnotation" aria-label="annotation6">❻</span>, use JavaScript’s <span class="SANS_TheSansMonoCd_W5Regular_11">.find()</span>method, and if the value is in the array, use <span class="SANS_TheSansMonoCd_W5Regular_11">.splice()</span> to remove it.</p>&#13;
<p class="ListHead"><b>3.3  Extra Operations</b></p>&#13;
<p class="ListPlainFirst">Many possibilities exist, but keep in mind that you’d ask for these operations only if you actually required them for a specific problem. The following table provides a few, although this list could be extended.</p>&#13;
<table class="table1">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Signature</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Count all</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">bag</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">integer</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Given a bag, return how many values it contains.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Count value</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">bag × value</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">integer</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Given a bag and a value, return how many times it’s in the bag.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Add many</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">bag × value × integer</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">bag</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Given a new value and a count, add so many copies of the value to the bag.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Remove all</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">bag × value</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">bag</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Given a bag and a value, remove all the value’s instances from the bag.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Find next</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">bag × value</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">value | undefined</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Given a bag and value, find the closest higher value to the value in the bag.</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="ListHead"><b>3.4  Wrong Operations</b></p>&#13;
<p class="ListPlainFirst">If you want to return special values, you can do so as with the <span class="SANS_TheSansMonoCd_W5Regular_11">greatest()</span> operation, where you returned <span class="SANS_TheSansMonoCd_W5Regular_11">undefined</span> for an empty bag. If you throw an exception, you can also specify it as a new return value (<span class="SANS_TheSansMonoCd_W5Regular_11">exception</span>), albeit one that’s received in a different way (<span class="SANS_TheSansMonoCd_W5Regular_11">try/catch</span>), and that would work as well.</p>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_491" aria-label="491"/><b>3.5  Ready, Set ...</b></p>&#13;
<p class="ListPlainFirst">We’ll consider this in <span class="listbody_Xref">Chapter 13</span>, so please skip ahead!</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h2 class="H1" id="sec3"><span id="h1-104"/><span class="SANS_Futura_Std_Bold_B_11">Chapter 4</span></h2>&#13;
<p class="ListHead"><b>4.1  How Fast Did You Say?</b></p>&#13;
<p class="ListPlainFirst">That cannot be; for large enough <i>n</i>, <i>f</i>(<i>n</i>) becomes negative.</p>&#13;
<p class="ListHead"><b>4.2  Weird Bound?</b></p>&#13;
<p class="ListPlainFirst">Yes, <i>n</i> = <i>O</i>(<i>n</i><sup>2</sup>) and (more properly, since we prefer tighter bounds) also <i>o</i>(<i>n</i><sup>2</sup>), because <i>n</i><sup>2</sup> grows faster. The lower bound orders, big and small omega, don’t apply.</p>&#13;
<p class="ListHead"><b>4.3  Of Big</b> <b><i>O</i></b><b>s and Omegas</b></p>&#13;
<p class="ListPlainFirst">In that case (and only in that case), <i>f</i>(<i>n</i>) = <span class="greek_alt"><span xml:lang="el" lang="el">Θ</span></span>(<i>g</i>(<i>n</i>)).</p>&#13;
<p class="ListHead"><b>4.4  Transitivity?</b></p>&#13;
<p class="ListPlainFirst">If <i>f</i>(<i>n</i>) = <i>O</i>(<i>g</i>(<i>n</i>)) and <i>g</i>(<i>n</i>) = <i>O</i>(<i>h</i>(<i>n</i>)), then <i>f</i>(<i>n</i>) = <i>O</i>(<i>h</i>(<i>n</i>)). We can prove this mathematically, but intuitively, the first equality means that <i>f</i> and <i>g</i> grow proportionally, and the second means that <i>g</i> and <i>h</i> also grow proportionally, and that means that <i>f</i> and <i>h</i> also grow proportionally. If you consider any other order, transitivity still applies; for example, <i>f</i>(<i>n</i>) = <span class="listplain_greek"><span xml:lang="el" lang="el">Ω</span></span>(<i>g</i>(<i>n</i>)) and <i>g</i>(<i>n</i>) = <span class="listplain_greek"><span xml:lang="el" lang="el">Ω</span></span>(<i>h</i>(<i>n</i>)) implies <i>f</i>(<i>n</i>) = <span class="listplain_greek"><span xml:lang="el" lang="el">Ω</span></span>(<i>h</i>(<i>n</i>)).</p>&#13;
<p class="ListHead"><b>4.5  A Bit of Reflexion</b></p>&#13;
<p class="ListPlainFirst">We can also say <i>f</i>(<i>n</i>) = <i>O</i>(<i>f</i>(<i>n</i>)) and <i>f(n)</i> = <span class="listplain_greek"><span xml:lang="el" lang="el">Ω</span></span>(<i>f</i>(<i>n</i>)), but not for small omega or small <i>o</i>.</p>&#13;
<p class="ListHead"><b>4.6  Going at It Backward</b></p>&#13;
<p class="ListPlainFirst">If <i>f(n)</i> = <i>O</i>(<i>g</i>(<i>n</i>)), then <i>g</i>(<i>n</i>) = <span class="listplain_greek"><span xml:lang="el" lang="el">Ω</span></span>(<i>f</i>(<i>n</i>)), and if <i>f</i>(<i>n</i>) = <i>o</i>(<i>g</i>(<i>n</i>)), then <i>g</i>(<i>n</i>) = <span class="greek_alt"><span xml:lang="el" lang="el">ω</span></span>(<i>f</i>(<i>n</i>)). Note the symmetry: big <i>O</i> implies big omega, and small <i>o</i> implies small omega.</p>&#13;
<p class="ListHead"><b>4.7  One After the Other</b></p>&#13;
<p class="ListPlainFirst">When <i>n</i> grows, the growth of the <i>O</i>(<i>n</i><sup>2</sup>) part will be greater than the growth of the <i>O</i>(<i>n</i> log <i>n</i>) part, so that’s the order of the whole process. In general, the order of a sequence will be that of the greatest order.</p>&#13;
<p class="ListHead"><b>4.8  Loop the Loop</b></p>&#13;
<p class="ListPlainFirst">In this case, the result is <i>O</i>(<i>n</i><sup>3</sup>). The order of the whole “loop within a loop” is derived from the product of both orders.</p>&#13;
<p class="ListHead"><b>4.9  Almost a Power ...</b></p>&#13;
<p class="ListPlainFirst">A formal proof would require applying induction, but consider how you’d frame it. You want to end with a single element, so 1 is a valid size. At the previous step, the array had two 1-sized parts, separated by a single element: the previous size was then 3. Before that, the array had two 3-sized parts, separated by one element: its size was 7. Going backward in this fashion, if you had an <i>s</i>-sized array, at the previous step, the array had to be of size (2<i>s +</i> 1). Starting at <i>s</i> = 1, it can be formally <span role="doc-pagebreak" epub:type="pagebreak" id="pg_492" aria-label="492"/>proved that sizes are always one less than a power of 2 from the fact that 2(2<i><sup>k</sup></i> – 1) + 1 equals 2<i><sup>k</sup></i> <sup>+1</sup> – 1.</p>&#13;
<p class="ListHead"><b>4.10  It Was the Best of Times; It Was the Worst of Times</b></p>&#13;
<p class="ListPlainFirst">In that case (and in that case only), we can deduce that the running time is <span class="greek_alt"><span xml:lang="el" lang="el">Θ</span></span>(<i>f</i>(<i>n</i>)).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h2 class="H1" id="sec4"><span id="h1-105"/><span class="SANS_Futura_Std_Bold_B_11">Chapter 5</span></h2>&#13;
<p class="ListHead"><b>5.1  Factorial in One</b></p>&#13;
<p class="ListPlainFirst">You can use this one-liner:</p>&#13;
<pre class="pre" id="pre-369"><code>const factorial = (n) =&gt; (n === 0 ? 1 : n * factorial(n – 1));</code></pre>&#13;
<p class="ListHead"><b>5.2  Hanoi by Hand</b></p>&#13;
<p class="ListPlainFirst">On odd steps, always move the smallest disk cyclically (from A to B, from B to C, and from C to A), and on even steps, make the only possible move that doesn’t involve the smallest disk. This method works for an even number of disks; for an odd number of disks, the smallest disk needs to do the cycle in the opposite direction: A to C, C to A, A to B.</p>&#13;
<p class="ListHead"><b>5.3  Archery Backtracking</b></p>&#13;
<p class="ListPlainFirst">The key to this problem is not to drop an option immediately after choosing it, but rather to try it again first. The following code is basically the same as the <span class="SANS_TheSansMonoCd_W5Regular_11">solve()</span> function from the section <span class="listplain_Xref">“Solving the Squarest Game on the Beach Puzzle”</span> on page <span class="listplain_Xref">70</span>, with an addition:</p>&#13;
<pre class="pre" id="pre-370"><code><span class="listcodeannotated_CodeAnnotation" aria-label="annotation1">❶</span><span class="SANS_TheSansMonoCd_W5Regular_11"> const solve = (goal, rings, score = 0, hit = []) =&gt; {</span>&#13;
  if (score === goal) {&#13;
    return hit;&#13;
  } else if (score &gt; goal || rings.length === 0) {&#13;
    return null;&#13;
  } else {&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation2">❷</span> const again = solve(goal, rings, score + rings[0], [      ...hit,       rings[0],     ]);&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation3">❸</span> if (again) {&#13;
     return again;&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation4">❹</span>} else {&#13;
     const chosen = rings[0];&#13;
     const others = rings.slice(1);&#13;
     return (&#13;
        solve(goal, others, score + chosen, [...hit, chosen]) ||&#13;
        solve(goal, others, score, hit)&#13;
      );&#13;
    }&#13;
  }&#13;
};&#13;
&#13;
console.log(solve(100, [40, 39, 24, 23, 17, 16]));</code></pre>&#13;
<p class="ListBody"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_493" aria-label="493"/>The parameters were renamed to better match the current puzzle <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span>, so it’s <span class="SANS_TheSansMonoCd_W5Regular_11">rings</span> instead of <span class="SANS_TheSansMonoCd_W5Regular_11">dolls</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">hit</span> instead of <span class="SANS_TheSansMonoCd_W5Regular_11">dropped</span>. The additional code tries reusing the first ring <span class="listbody_CodeAnnotation" aria-label="annotation2">❷</span>, and if it succeeds <span class="listbody_CodeAnnotation" aria-label="annotation3">❸</span>, you’re done. If trying the same ring again fails <span class="listbody_CodeAnnotation" aria-label="annotation4">❹</span>, drop it and continue with the search as earlier.</p>&#13;
<p class="ListBody">For the second question, you can indeed reuse the original <span class="SANS_TheSansMonoCd_W5Regular_11">solve()</span> algorithm, but you need a change, because you may hit a ring more than once, so rings must appear several times. For example, 40 and 39 should both be considered twice as an option; hitting any of those three or more times would exceed 100. Similarly, 23 and 24 could appear up to four times, 17 five times, and 16 six times. This code finds the solution:</p>&#13;
<pre class="pre" id="pre-371"><code>console.log(&#13;
  solve(100, [&#13;
    40, 40,&#13;
    39, 39,&#13;
    24, 24, 24, 24,&#13;
    23, 23, 23, 23,&#13;
    17, 17, 17, 17, 17,&#13;
    16, 16, 16, 16, 16, 16&#13;
  ])&#13;
);</code></pre>&#13;
<p class="ListBody">By the way, if you don’t run the code, the answer is 16, 16, 17, 17, 17, and 17!</p>&#13;
<p class="ListHead"><b>5.4  Counting Calls</b></p>&#13;
<p class="ListPlainFirst">To calculate the <i>n</i>th Fibonacci number, you need one call for that, plus <i>C</i>(<i>n</i>  – 1) calls for the (<i>n</i> – 1)th number, plus <i>C</i>(<i>n</i> – 2) calls for the (<i>n</i> – 2)th one, so <i>C</i>(<i>n</i>) = <i>C</i>(<i>n</i> – 1) + <i>C</i>(<i>n</i> – 2) + 1. The solution to this is <i>C</i>(<i>n</i>) = 2Fibo(<i>n</i> + 1) – 1.</p>&#13;
<p class="ListHead"><b>5.5  Avoid More Work</b></p>&#13;
<p class="ListPlainFirst">Simply add a test at the beginning of the loop of the <span class="SANS_TheSansMonoCd_W5Regular_11">costOfFragment(...)</span> function, as follows:</p>&#13;
<pre class="pre" id="pre-372"><code>const costOfFragment = memoize((p, q) =&gt; {&#13;
  ...&#13;
  let optimum = Infinity;&#13;
  let split = [];&#13;
  for (let r = p; r &lt; q; r++) {&#13;
    <b>if (totalWidth(p, r) &gt; MW) {</b>&#13;
<b>      break;</b>&#13;
<b>    }</b>&#13;
    ...&#13;
  }&#13;
  return [optimum, split];&#13;
});</code></pre>&#13;
<p class="ListBody"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_494" aria-label="494"/>As soon as the width of blocks from <span class="SANS_TheSansMonoCd_W5Regular_11">p</span> through <span class="SANS_TheSansMonoCd_W5Regular_11">r</span> exceeds <span class="SANS_TheSansMonoCd_W5Regular_11">MW</span>, you can stop the loop; all upcoming total widths will be even greater.</p>&#13;
<p class="ListHead"><b>5.6  Reduce for Clarity</b></p>&#13;
<p class="ListPlainFirst">The following is a single-line way to calculate the partial values:</p>&#13;
<pre class="pre" id="pre-373"><code>const partial = blocks.reduce((a, c, i) =&gt; ((a[i + 1] = a[i] + c), a), [0]);</code></pre>&#13;
<p class="ListBody">Note that the accumulator in this case is an array that you initialize with a single 0 and that will become <span class="SANS_TheSansMonoCd_W5Regular_11">partial[0]</span>.</p>&#13;
<p class="ListHead"><b>5.7  Got GOUT?</b></p>&#13;
<p class="ListPlainFirst">Use the <span class="SANS_TheSansMonoCd_W5Regular_11">solve()</span> function from the section <span class="listplain_Xref">“Solving Cryptarithmetic Puzzles”</span> on page <span class="listplain_Xref">83</span> as follows. The style of the code is exactly the same as for the SEND + MORE = MONEY puzzle:</p>&#13;
<pre class="pre" id="pre-374"><code>const {solve} = require("../send_more_money_puzzle");&#13;
&#13;
const toGoOut = (g, o, u, t) =&gt; {&#13;
  if (t === 0 || g === 0 || o === 0) {&#13;
    return false;&#13;
  } else {&#13;
    const TO = Number(`${t}${o}`);&#13;
    const GO = Number(`${g}${o}`);&#13;
    const OUT = Number(`${o}${u}${t}`);&#13;
    return TO + GO === OUT;&#13;
  }&#13;
};&#13;
&#13;
solve(toGoOut);</code></pre>&#13;
<p class="ListBody">The maximum sum of two 2-digit numbers is 99 + 99 = 198, so O = 1, and there was a carry-over from the center column to the leftmost one. At the rightmost column, O + O = T, so T = 2, and there’s no carry-over to the center column. Finally, looking at the center column, T + G = 10 + U, but as T = 1, the only way T + G is at least 10 is if G = 9 and then U = 0; the value of GOUT is then 9102, exactly as <span class="SANS_TheSansMonoCd_W5Regular_11">solve()</span> discovers!</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h2 class="H1" id="sec5"><span id="h1-106"/><span class="SANS_Futura_Std_Bold_B_11">Chapter 6</span></h2>&#13;
<p class="ListHead"><b>6.1  Forced Reversal</b></p>&#13;
<p class="ListPlainFirst">Change the signs of all the numbers. Next, sort them in ascending order, and then change the signs back. For instance, to sort [22, 60, 9], first change them to [–22, –60, –9], then sort them, and you’ll get [–60, –22, –9]. Finally, change the signs again [60, 22, 9], and they’ll be in the desired descending order.</p>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_495" aria-label="495"/><b>6.2  Only Lower</b></p>&#13;
<p class="ListPlainFirst">Given <span class="SANS_TheSansMonoCd_W5Regular_11">lower(a,b)</span>, you can implement <span class="SANS_TheSansMonoCd_W5Regular_11">higher(a,b)</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">equal(a,b)</span> as follows:</p>&#13;
<pre class="pre" id="pre-375"><code><span class="listcodeannotated_CodeAnnotation" aria-label="annotation1">❶</span><span class="SANS_TheSansMonoCd_W5Regular_11"> const higher = (a, b) =&gt; lower(b, a);</span>&#13;
<span class="listcodeannotated_CodeAnnotation" aria-label="annotation2">❷</span> const equal = (a, b) =&gt; !lower(a, b) &amp;&amp; !higher(a, b);</code></pre>&#13;
<p class="ListBody">Basically it’s just like applying math: <span class="SANS_TheSansMonoCd_W5Regular_11">a &gt; b</span> if <span class="SANS_TheSansMonoCd_W5Regular_11">b &lt; a</span> <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">a</span> is equal to <span class="SANS_TheSansMonoCd_W5Regular_11">b</span>, if and only if neither <span class="SANS_TheSansMonoCd_W5Regular_11">a &lt; b</span> nor <span class="SANS_TheSansMonoCd_W5Regular_11">a &gt; b</span> <span class="listbody_CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="ListHead"><b>6.3  Testing a Sort Algorithm</b></p>&#13;
<p class="ListPlainFirst">Sort a copy of the data with some other method and use <span class="SANS_TheSansMonoCd_W5Regular_11">JSON.stringify(...)</span> to get a version of the result as a string. Then, sort the data with your new method, use <span class="SANS_TheSansMonoCd_W5Regular_11">JSON.stringify(...)</span> on its output, and compare both JSON strings; they should match.</p>&#13;
<p class="ListHead"><b>6.4  Missing ID</b></p>&#13;
<p class="ListPlainFirst">This problem has two solutions. You could sort the series of numbers, and then a sequential run through the ordered series would detect missing numbers whenever the gap between consecutive numbers is greater than one. A more specific solution would be to initialize an array of size 1,000,000 with <span class="SANS_TheSansMonoCd_W5Regular_11">false</span>, and for every number in the series, set the corresponding array entry to <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>. You can then run through the array, and entries that are still <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> represent missing IDs.</p>&#13;
<p class="ListHead"><b>6.5  Unmatched One</b></p>&#13;
<p class="ListPlainFirst">Like the previous question, this problem also has two solutions. You could sort the whole series, and then a quick run through the sorted numbers would find the number that’s used only once. The second, trickier solution is to apply the bitwise XOR (<span class="SANS_TheSansMonoCd_W5Regular_11">^</span>) to all the numbers. If you XOR a number with itself, the result is zero, and if you XOR a number with zero, the result is the number. If you XOR the whole series, the result will be the unmatched number. However, this solution works only if there is a single unpaired number; if there were two or more, it would fail.</p>&#13;
<p class="ListHead"><b>6.6  Sinking Sort</b></p>&#13;
<p class="ListPlainFirst">The logic is similar to bubble sort’s; you need to change only how indices behave:</p>&#13;
<pre class="pre" id="pre-376"><code>const sinkingSort = (arr, from = 0, to = arr.length - 1) =&gt; {&#13;
  for (let j = from; j &lt; to; j++) {&#13;
    for (let i = to - 1; i &gt;= j; i--) {&#13;
      if (arr[i] &gt; arr[i + 1]) {&#13;
        [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];&#13;
      }&#13;
    }&#13;
  }&#13;
  return arr;&#13;
};</code></pre>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_496" aria-label="496"/><b>6.7  Bubble Swap Checking</b></p>&#13;
<p class="ListPlainFirst">The following logic implements the idea:</p>&#13;
<pre class="pre" id="pre-377"><code>const bubbleSort = (arr, from = 0, to = arr.length - 1) =&gt; {&#13;
  for (let j = to; j &gt; from; j--) {&#13;
<b>    let swaps = false;</b>&#13;
    for (let i = from; i &lt; j; i++) {&#13;
      if (arr[i] &gt; arr[i + 1]) {&#13;
        [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];&#13;
<b>        swaps = true;</b>&#13;
      }&#13;
    }&#13;
<b>    if (!swaps) {</b>&#13;
<b>      break;</b>&#13;
<b>    }</b>&#13;
  }&#13;
  return arr;&#13;
};</code></pre>&#13;
<p class="ListHead"><b>6.8  Inserting Recursively</b></p>&#13;
<p class="ListPlainFirst">The description is enough to write the code: to sort <i>n</i> numbers, first sort the initial (<i>n</i> – 1) ones and then insert the <i>n</i>th number in the sorted list:</p>&#13;
<pre class="pre" id="pre-378"><code>const insertionSort = (arr, from = 0, to = arr.length - 1) =&gt; {&#13;
  if (to &gt; from) {&#13;
    insertionSort(arr, from, to - 1);&#13;
    const temp = arr[to];&#13;
    let j;&#13;
    for (j = to; j &gt; from &amp;&amp; arr[j - 1] &gt; temp; j--) {&#13;
      arr[j] = arr[j - 1];&#13;
    }&#13;
    arr[j] = temp;&#13;
  }&#13;
  return arr;&#13;
};</code></pre>&#13;
<p class="ListHead"><b>6.9  Stable Shell?</b></p>&#13;
<p class="ListPlainFirst">No, Shell sort isn’t stable, because the first stages (for gaps larger than one) may disrupt the relative order of equal keys.</p>&#13;
<p class="ListHead"><b>6.10  A Dutch Enhancement</b></p>&#13;
<p class="ListPlainFirst">The following implementation works:</p>&#13;
<pre class="pre" id="pre-379"><code>const quickSort = (arr, left = 0, right = arr.length - 1) =&gt; {&#13;
  if (left &lt; right) {&#13;
    const pivot = arr[right];&#13;
&#13;
    let p = left;&#13;
    for (let j = left; j &lt; right; j++) {&#13;
      if (pivot &gt; arr[j]) {&#13;
        [arr[p], arr[j]] = [arr[j], arr[p]];&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_497" aria-label="497"/>        p++;&#13;
      }&#13;
    }&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation1">❶</span> [arr[p], arr[right]] = [arr[right], arr[p]];&#13;
&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation2">❷</span> let pl = p;&#13;
    for (let i = p - 1; i &gt;= left; i--) {&#13;
      if (arr[i] === pivot) {&#13;
        pl--;&#13;
        [arr[i], arr[pl]] = [arr[pl], arr[i]];&#13;
      }&#13;
    }&#13;
&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation3">❸</span> let pr = p;&#13;
    for (let j = p + 1; j &lt;= right; j++) {&#13;
      if (arr[j] === pivot) {&#13;
        pr++;&#13;
        [arr[j], arr[pr]] = [arr[pr], arr[j]];&#13;
      }&#13;
    }&#13;
&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation4">❹</span> quickSort(arr, left, pl – 1);&#13;
    quickSort(arr, pr + 1, right);&#13;
  }&#13;
&#13;
  return arr;&#13;
};</code></pre>&#13;
<p class="ListBody">All the code is the same up to the point where the pivot is at <span class="SANS_TheSansMonoCd_W5Regular_11">arr[p]</span> <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span>. You then do a loop to the left of the pivot position <span class="listbody_CodeAnnotation" aria-label="annotation2">❷</span>, and if you find elements equal to the pivot, you swap; the leftmost position equal to the pivot is always at <span class="SANS_TheSansMonoCd_W5Regular_11">pl</span>. After this pass, you repeat the process with a similar logic <span class="listbody_CodeAnnotation" aria-label="annotation3">❸</span> but from the pivot position to the right. The rightmost position with a value equal to the pivot is <span class="SANS_TheSansMonoCd_W5Regular_11">pr</span>. After these added loops, all values from <span class="SANS_TheSansMonoCd_W5Regular_11">pl</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">pr</span> are equal to the pivot, so you sort the rest <span class="listbody_CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
<p class="ListHead"><b>6.11  Simpler Merging?</b></p>&#13;
<p class="ListPlainFirst">If you made that change, merge sort wouldn’t be stable. When you have equal values in the first and second lists, you want to choose from the former.</p>&#13;
<p class="ListHead"><b>6.12  Try Not to Be Negative</b></p>&#13;
<p class="ListPlainFirst">With negative numbers, you’d get a crash when <span class="SANS_TheSansMonoCd_W5Regular_11">digit</span> becomes negative. And for noninteger numbers, the algorithm disregards the fractional part, so numbers with equal integer parts may end up not sorted correctly. As an extra question, think of ways to solve these problems.</p>&#13;
<p class="ListHead"><b>6.13  Fill It Up!</b></p>&#13;
<p class="ListPlainFirst">The first option would fill all the elements of <span class="SANS_TheSansMonoCd_W5Regular_11">bucket</span> with a reference to the same array; instead of 10 different arrays, you’d get a single one, common to all buckets. The second option wouldn’t do anything, because <span class="SANS_TheSansMonoCd_W5Regular_11">.map(...)</span> skips undefined positions.</p>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_498" aria-label="498"/><b>6.14  What About Letters?</b></p>&#13;
<p class="ListPlainFirst">In that case, you’d require more buckets, one for each possible symbol. You might have to do some fancy work if you want to have accented letters (such as <span class="listplain_accent">á</span> or <span class="listplain_accent">ü</span>) sorted together with their nonaccented versions.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h2 class="H1" id="sec6"><span id="h1-107"/><span class="SANS_Futura_Std_Bold_B_11">Chapter 7</span></h2>&#13;
<p class="ListHead"><b>7.1  Tennis Sudden Death</b></p>&#13;
<p class="ListPlainFirst">The number of matches is easy to find: each match discards one player, and to find the champion, you must discard 110 other players, so the answer is 110, and for <i>n</i> players, <i>n</i> – 1. The second best could be any of the players that the first defeated—even possibly in the first round. This tournament had seven rounds, so you may need up to seven extra matches. In general terms, the number of rounds is the logarithm of <i>n</i> in base 2, rounded up, so the total number of comparisons to learn the two minimum values of an array is <i>n</i> –1 + log<sub>2</sub> <i>n</i>.</p>&#13;
<p class="ListHead"><b>7.2  Take Five</b></p>&#13;
<p class="ListPlainFirst">You can do it with six comparisons, as follows:</p>&#13;
<pre class="pre" id="pre-380"><code>const medianOf5 = (a, b, c, d, e) =&gt; {&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation1">❶</span> if (a &gt; b) {&#13;
    [a, b] = [b, a];&#13;
  }&#13;
&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation2">❷</span> if (c &gt; d) {&#13;
    [c, d] = [d, c];&#13;
  }&#13;
&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation3">❸</span> if (a &gt; c) {&#13;
    [a, c] = [c, a];&#13;
    [b, d] = [d, b];&#13;
  }&#13;
&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation4">❹</span> if (b &gt; e) {&#13;
    [b, e] = [e, b];&#13;
  }&#13;
&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation5">❺</span> if (c &gt; b) {&#13;
   // b &lt; c &lt; d and b &lt; e: b isn't the median, and d isn't either&#13;
   return e &gt; c ? c : e;&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation6">❻</span>} else {&#13;
   return d &gt; b ? b : d;&#13;
  }&#13;
};</code></pre>&#13;
<p class="ListBody">To understand the code, follow what happens to the variables. After the first test, you know for sure that <span class="SANS_TheSansMonoCd_W5Regular_11">a &lt; b</span> <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and with the next test you know that <span class="SANS_TheSansMonoCd_W5Regular_11">c &lt; d</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. You can say that <span class="SANS_TheSansMonoCd_W5Regular_11">a &lt; b &amp;&amp; a &lt; c &lt; d</span> <span class="CodeAnnotation" aria-label="annotation3">❸</span>, so <span class="SANS_TheSansMonoCd_W5Regular_11">a</span> cannot <span role="doc-pagebreak" epub:type="pagebreak" id="pg_499" aria-label="499"/>be the median. After <span class="CodeAnnotation" aria-label="annotation4">❹</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">b &lt; e &amp;&amp; c &lt; d</span>, so whichever is lowest of <span class="SANS_TheSansMonoCd_W5Regular_11">b</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">c</span> cannot be the median either. At <span class="CodeAnnotation" aria-label="annotation5">❺</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">b &lt; c &lt; d &amp;&amp; b &lt; e</span>, so neither <span class="SANS_TheSansMonoCd_W5Regular_11">b</span> nor <span class="SANS_TheSansMonoCd_W5Regular_11">d</span> can be the median, which is the smallest of <span class="SANS_TheSansMonoCd_W5Regular_11">c</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">e</span>. Similarly, at <span class="CodeAnnotation" aria-label="annotation6">❻</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">c &lt; b &lt; e &amp;&amp; c &lt; d</span>, so neither <span class="SANS_TheSansMonoCd_W5Regular_11">c</span> nor <span class="SANS_TheSansMonoCd_W5Regular_11">e</span> is the median; the smallest of <span class="SANS_TheSansMonoCd_W5Regular_11">b</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">d</span> is it.</p>&#13;
<p class="ListBodyLast">Just for completeness, here’s an equivalent version of <span class="SANS_TheSansMonoCd_W5Regular_11">median5(...)</span> that works with an array of five independent values and returns the position of the found median. The code is parallel to the previous code:</p>&#13;
<pre class="pre" id="pre-381"><code>const swapper = (arr, i, j) =&gt; ([arr[i], arr[j]] = [arr[j], arr[i]]);&#13;
&#13;
const medianOf5 = (arr5) =&gt; {&#13;
  if (arr5[0] &gt; arr5[1]) {&#13;
    swapper(arr5, 0, 1);&#13;
  }&#13;
&#13;
  if (arr5[2] &gt; arr5[3]) {&#13;
    swapper(arr5, 2, 3);&#13;
  }&#13;
&#13;
  if (arr5[0] &gt; arr5[2]) {&#13;
    swapper(arr5, 0, 2);&#13;
    swapper(arr5, 1, 3);&#13;
  }&#13;
&#13;
  if (arr5[1] &gt; arr5[4]) {&#13;
    swapper(arr5, 1, 4);&#13;
  }&#13;
&#13;
  if (arr5[2] &gt; arr5[1]) {&#13;
    return arr5[4] &gt; arr5[2] ? 2 : 4;&#13;
  } else {&#13;
    return arr5[3] &gt; arr5[1] ? 1 : 3;&#13;
  }&#13;
};</code></pre>&#13;
<p class="ListHead"><b>7.3  Top to Bottom</b></p>&#13;
<p class="ListPlainFirst">There are two solutions. You could change the algorithm so instead of selecting minimums and going from 0 to <i>n</i> – 1, it could work by selecting maximums and going down from <i>n</i> – 1 to 0. To get an efficient algorithm, you should start by comparing <i>k</i> to <i>n</i>/2 and going up (as originally shown in the text) or down (as described here) depending on that comparison, whichever takes the least work.</p>&#13;
<p class="ListBody">In the particular case in which the values are numeric, you can do a trick: change the sign of all numbers to the opposite, use the algorithm to find the value at <i>n</i> – <i>k</i>, and change its sign; can you see why that works?</p>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_500" aria-label="500"/><b>7.4  Just Iterate</b></p>&#13;
<p class="ListPlainFirst">Instead of recursion, you can use a loop that will exit when the code has managed to put the <i>k</i>th value of the array in place:</p>&#13;
<pre class="pre" id="pre-382"><code>const quickSelect = (arr, k, left = 0, right = arr.length - 1) =&gt; {&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation1">❶</span><b> while (left &lt; right) {</b>&#13;
    const pick = left + Math.floor((right - left) * Math.random());&#13;
    if (pick !== right) {&#13;
      [arr[pick], arr[right]] = [arr[right], arr[pick]];&#13;
    }&#13;
    const pivot = arr[right];&#13;
&#13;
    let p = left;&#13;
    for (let j = left; j &lt; right; j++) {&#13;
      if (pivot &gt; arr[j]) {&#13;
        [arr[p], arr[j]] = [arr[j], arr[p]];&#13;
        p++;&#13;
      }&#13;
    }&#13;
    [arr[p], arr[right]] = [arr[right], arr[p]];&#13;
&#13;
<b>  </b><span class="listcode_CodeAnnotation" aria-label="annotation2">❷</span><b> if (p === k) {</b>&#13;
<b>      left = right = k;</b>&#13;
<b>    } else if (p &gt; k) {</b>&#13;
<b>      right = p - 1;</b>&#13;
<b>    } else {</b>&#13;
<b>      left = p + 1;</b>&#13;
<b>    }</b>&#13;
<b>  }</b>&#13;
};</code></pre>&#13;
<p class="ListBody">Set up a loop <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span> that continues as long as <span class="SANS_TheSansMonoCd_W5Regular_11">left</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">right</span> haven’t reached the same place (<span class="SANS_TheSansMonoCd_W5Regular_11">k</span>). At the end, instead of recursion or returning early, just manipulate <span class="SANS_TheSansMonoCd_W5Regular_11">left</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">right</span> properly <span class="listbody_CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="ListHead"><b>7.5  Select Without Changing</b></p>&#13;
<p class="ListPlainFirst">Simply make a copy of the input array, as follows:</p>&#13;
<pre class="pre" id="pre-383"><code>const qSelect = (arr, k, left = 0, right = arr.length - 1) =&gt; {&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation1">❶</span> const copy = [...arr];&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation2">❷</span> quickSelect(copy, k, left, right);&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation3">❸</span> return copy[k];&#13;
};</code></pre>&#13;
<p class="ListBody">Make a copy of the array <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span>, then partition it <span class="listbody_CodeAnnotation" aria-label="annotation2">❷</span>, and finally return the <i>k</i>th value from the copied and repartitioned array <span class="listbody_CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="ListHead"><b>7.6  The Sicilian Way</b></p>&#13;
<p class="ListPlainFirst">The following algorithm does the trick. You can find a different implementation (changing how elements are swapped) in “An Efficient Algorithm for the Approximate Median Selection Problem,” by S. Battiato et al., available at <i><a href="https://web.cs.wpi.edu/~hofri/medsel.pdf">https://web.cs.wpi.edu/~hofri/medsel.pdf</a></i>. We’ll <span role="doc-pagebreak" epub:type="pagebreak" id="pg_501" aria-label="501"/>highlight the only differences with previous code, but we’ve also implemented some methods in a new way just for variety, and we used iteration instead of recursion (as in question 7.4) for the same reason.</p>&#13;
<pre class="pre" id="pre-384"><code><span class="listcodeannotated_CodeAnnotation" aria-label="annotation1">❶</span><span class="SANS_TheSansMonoCd_W5Regular_11"> const swapIfNeeded = (arr, i, j) =&gt; {</span>&#13;
  if (i !== j) {&#13;
    [arr[i], arr[j]] = [arr[j], arr[i]];&#13;
  }&#13;
};&#13;
&#13;
<span class="listcodeannotated_CodeAnnotation" aria-label="annotation2">❷</span> const medianOf3 = (arr, left, right) =&gt; {&#13;
  if (right - left === 2) {&#13;
    const c01 = arr[left] &gt; arr[left + 1];&#13;
    const c12 = arr[left + 1] &gt; arr[left + 2];&#13;
    if (c01 === c12) {&#13;
      return left + 1;&#13;
    } else {&#13;
      const c20 = arr[left + 2] &gt; arr[left];&#13;
      return c20 === c01 ? left : left + 2;&#13;
    }&#13;
  } else {&#13;
    return left;&#13;
  }&#13;
};&#13;
&#13;
const quickSelect = (arr, k, left = 0, right = arr.length - 1) =&gt; {&#13;
  while (left &lt; right) {&#13;
<b>  </b><span class="listcode_CodeAnnotation" aria-label="annotation3">❸</span><b> let rr = right;</b>&#13;
<b>  </b><span class="listcode_CodeAnnotation" aria-label="annotation4">❹</span><b> while (rr - left &gt;= 3) {</b>&#13;
<b>      let ll = left - 1;</b>&#13;
<b>    </b><span class="listcode_CodeAnnotation" aria-label="annotation5">❺</span><b> for (let i = left; i &lt;= rr; i += 3) {</b>&#13;
<b>        const m3 = medianOf3(arr, i, Math.min(i + 2, rr));</b>&#13;
<b>        swapIfNeeded(arr, ++ll, m3);</b>&#13;
<b>      }</b>&#13;
<b>    </b><span class="listcode_CodeAnnotation" aria-label="annotation6">❻</span><b> rr = ll;</b>&#13;
<b>    }</b>&#13;
<b>    const m3 = medianOf3(arr, left, rr);</b>&#13;
<b>    swapIfNeeded(arr, right, m3);</b>&#13;
&#13;
    const pivot = arr[right];&#13;
&#13;
    let p = left;&#13;
    for (let j = left; j &lt; right; j++) {&#13;
      if (pivot &gt; arr[j]) {&#13;
        swapIfNeeded(arr, p, j);&#13;
        p++;&#13;
      }&#13;
    }&#13;
    swapIfNeeded(arr, p, right);&#13;
&#13;
    if (p === k) {&#13;
      left = right = p;&#13;
    } else if (p &gt; k) {&#13;
      right = p - 1;&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_502" aria-label="502"/>    } else {&#13;
      left = p + 1;&#13;
    }&#13;
  }&#13;
};&#13;
&#13;
const sicilianSelect = (arr, k, left = 0, right = arr.length - 1) =&gt; {&#13;
  quickSelect(arr, k, left, right);&#13;
  return arr[k];&#13;
};</code></pre>&#13;
<p class="ListBody">You’ll need to do lots of swapping, but the <span class="SANS_TheSansMonoCd_W5Regular_11">swapIfNeeded(...)</span> function <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span> avoids some unnecessary calls by checking whether there’s actually any need to swap. Since you’ll always be finding the median of up to three values, it makes sense to have a specific function instead of using a generic sort <span class="listbody_CodeAnnotation" aria-label="annotation2">❷</span>; <span class="SANS_TheSansMonoCd_W5Regular_11">medianOf3(...)</span> returns the position of the median using up to three comparisons with no swapping. In quickselect the only part that changed are the lines in bold. You’ll find the medians in ever-shortening parts of the array; the <span class="SANS_TheSansMonoCd_W5Regular_11">rr</span> variable marks the right limit of the array you’re processing <span class="listbody_CodeAnnotation" aria-label="annotation3">❸</span>, while the <span class="SANS_TheSansMonoCd_W5Regular_11">left</span> variable always points at its left limit. As long as the array has more than three elements <span class="listbody_CodeAnnotation" aria-label="annotation4">❹</span>, you’ll do a pass of choosing medians of 3 <span class="listbody_CodeAnnotation" aria-label="annotation5">❺</span> and packing them to the left of the array, as shown in the repeated step algorithm; the difference is that after each pass <span class="listbody_CodeAnnotation" aria-label="annotation6">❻</span> you’ll shorten the array and loop again to find medians of 3. When the set of medians (of medians of medians of ..., and so on) is short enough, you’ll just choose its last element as the next pivot.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h2 class="H1" id="sec7"><span id="h1-108"/><span class="SANS_Futura_Std_Bold_B_11">Chapter 8</span></h2>&#13;
<p class="ListHead"><b>8.1  Good Enough Shuffling</b></p>&#13;
<p class="ListPlainFirst">This is the code I used when testing the functions for the book:</p>&#13;
<pre class="pre" id="pre-385"><code><span class="listcodeannotated_CodeAnnotation" aria-label="annotation1">❶</span><span class="SANS_TheSansMonoCd_W5Regular_11"> const logResults = (fn, from = 0, to = 10, n = to, times = 4000) =&gt; {</span>&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation2">❷</span> const bar = (len, val, max) =&gt;&#13;
    "#".repeat(Math.round((len * val) / max));&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation3">❸</span> const result = {};&#13;
  const compare = (a, b) =&gt; (a &lt; b ? -1 : 1);&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation4">❹</span> let max = 0;&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation5">❺</span> for (let i = 1; i &lt;= times; i++) {&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation6">❻</span> const arr = Array(n)&#13;
      .fill(0)&#13;
      .map((v, i) =&gt;&#13;
        i &lt; from || i &gt; to ? i : String.fromCharCode(65 + i),&#13;
      );&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation7">❼</span> const x = fn(arr, from, to).join(“-”);&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation8">❽</span> result[x] = x in result ? result[x] + 1 : 1;&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation9">❾</span> max = Math.max(max, result[x]);&#13;
  }&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_503" aria-label="503"/><span class="listcode_CodeAnnotation" aria-label="annotation10">❿</span> let count = 0;&#13;
  for (const [key, val] of Object.entries(result).sort(compare)) {&#13;
    count++;&#13;
    console.log(&#13;
      `${key}: ${String(val).padStart(5)} ${bar(50, val, max)}`,&#13;
    );&#13;
  }&#13;
  console.log("COUNT=", count);&#13;
};</code></pre>&#13;
<p class="ListBody">The parameters for this logging are the shuffling function <span class="SANS_TheSansMonoCd_W5Regular_11">fn</span>, the portion of the array to be shuffled (<span class="SANS_TheSansMonoCd_W5Regular_11">from</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">to</span>), the size of the input array to use (<span class="SANS_TheSansMonoCd_W5Regular_11">n</span>), and how many <span class="SANS_TheSansMonoCd_W5Regular_11">times</span> to run the test <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span>. An auxiliary function <span class="SANS_TheSansMonoCd_W5Regular_11">bar(...)</span> <span class="listbody_CodeAnnotation" aria-label="annotation2">❷</span> draws a bar of pound characters: the maximum length is <span class="SANS_TheSansMonoCd_W5Regular_11">len</span> for a <span class="SANS_TheSansMonoCd_W5Regular_11">val</span> value that equals a maximum <span class="SANS_TheSansMonoCd_W5Regular_11">max</span> value; smaller values get proportionally shorter bars. Use an object, <span class="SANS_TheSansMonoCd_W5Regular_11">result</span>, to count how many times each permutation occurred <span class="listbody_CodeAnnotation" aria-label="annotation3">❸</span> (you could also use a JavaScript <span class="SANS_TheSansMonoCd_W5Regular_11">map</span>). The <span class="SANS_TheSansMonoCd_W5Regular_11">max</span> variable <span class="listbody_CodeAnnotation" aria-label="annotation4">❹</span> tracks the maximum number of times that any permutation appeared. You loop <span class="SANS_TheSansMonoCd_W5Regular_11">n</span> times <span class="listbody_CodeAnnotation" aria-label="annotation5">❺</span>, each time initializing an array to shuffle <span class="listbody_CodeAnnotation" aria-label="annotation6">❻</span>. Use <span class="SANS_TheSansMonoCd_W5Regular_11">fn</span> to shuffle the array, creating a string key out of the result <span class="listbody_CodeAnnotation" aria-label="annotation7">❼</span>, and update the counts <span class="listbody_CodeAnnotation" aria-label="annotation8">❽</span> and maximum <span class="listbody_CodeAnnotation" aria-label="annotation9">❾</span> observed frequencies. The last step <span class="listbody_CodeAnnotation" aria-label="annotation10">❿</span> returns the results in tabular form, with permutations ordered alphabetically for clarity.</p>&#13;
<p class="ListHead"><b>8.2  Random Three or Six</b></p>&#13;
<p class="ListPlainFirst">Tossing two coins produces four combinations. You can assign numbers to those combinations, and if a combination numbered 1 to 3 occurs, accept it; if you get a 4, redo the throw:</p>&#13;
<pre class="pre" id="pre-386"><code><span class="listcodeannotated_CodeAnnotation" aria-label="annotation1">❶</span><span class="SANS_TheSansMonoCd_W5Regular_11"> const random01 = () =&gt; (randomBit() ? 0 : 1);</span>&#13;
&#13;
const random3 = () =&gt; {&#13;
  let num = 0;&#13;
  do {&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation2">❷</span> num = 2 * random01() + random01();&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation3">❸</span>} while (num &gt; 2);&#13;
&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation4">❹</span> return ["3-hi", "2-md", "1-lo"][num];&#13;
};</code></pre>&#13;
<p class="ListBody">This assigns numbers to combinations of coins using the binary system, calling heads a 0 and tails a 1. Use the <span class="SANS_TheSansMonoCd_W5Regular_11">randomBit()</span> function to produce bits <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span>. You “throw” the die twice, and assign a number to the resulting combination <span class="listbody_CodeAnnotation" aria-label="annotation2">❷</span>. Loop until you get a number from 0 to 2 <span class="listbody_CodeAnnotation" aria-label="annotation3">❸</span>, and after getting it, map it to a result <span class="listbody_CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
<p class="ListBody">To simulate a die, you’ll need three coin tosses, but the logic is quite similar:</p>&#13;
<pre class="pre" id="pre-387"><code>const randomDie = () =&gt; {&#13;
  let num = 0;&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_504" aria-label="504"/>  do {&#13;
    num = 4 * random01() + 2 * random01() + random01();&#13;
  } while (num &gt; 5);&#13;
  return num + 1;&#13;
};</code></pre>&#13;
<p class="ListBody">Finally, simulating a 1 to 20 throw is trickier. You could use 5 bits, getting a result from 0 to 31 and discarding the 12 last values, but that would probably require several attempts; after all, a failure rate of 12 out of 32 is high. A better solution would be using 6 bits for a result of 0 to 63, discarding the last 4 (so, 0–59) and dividing the result by 3 to get a 0 to 19 result, with small odds (4 in 64) of needing a new attempt.</p>&#13;
<p class="ListHead"><b>8.3  Not-So-Random Shuffling</b></p>&#13;
<p class="ListPlainFirst">If this algorithm produced uniform shuffles, you’d expect each value in the original array to appear the same number of times at each position of the shuffled array. For the initial value to end at the last position, you need all <span class="SANS_TheSansMonoCd_W5Regular_11">randomBit()</span> calls to come up true, so it’s far more likely that the initial value will end up not far from its starting position and only rarely appear in the last places.</p>&#13;
<p class="ListHead"><b>8.4  Bad Swapping Shuffle</b></p>&#13;
<p class="ListPlainFirst">The problem is that this code doesn’t generate every possible permutation with the same frequencies. You can see a hint of that by noticing that this code loops <i>n</i> times, choosing a random number with <i>n</i> possible values each time, so it has <i>n</i><sup>1</sup> ways to run. However, a permutation generation algorithm should run in <i>n</i>! ways only. If you want to verify this by hand, try the algorithm for just three elements and simulate all 27 possible sequences of random numbers: from (0,0,0), which would shuffle ABC into CBA; (0,0,1), which shuffles ABC into BCA; and so on, up to (2,2,2), which produces CBA. Count how many times each possible permutation occurs, and you’ll see that some are more favored than others. The algorithm doesn’t produce an even distribution of shuffles.</p>&#13;
<p class="ListHead"><b>8.5  Robson’s Top?</b></p>&#13;
<p class="ListPlainFirst">The question is equivalent to finding out the largest factorial that can be calculated without losing precision. Using normal precision, this turns out to be 18; 19! is too long:</p>&#13;
<pre class="pre" id="pre-388"><code><span class="listcodeannotated_CodeAnnotation" aria-label="annotation1">❶</span><span class="SANS_TheSansMonoCd_W5Regular_11"> for (let num = 1, fact = 1; fact &lt; fact + 1; num++) {</span>&#13;
  fact *= num;&#13;
  console.log(`${num}=${fact}`);&#13;
}</code></pre>&#13;
<p class="ListBody">You can test whether precision is lost by adding 1 and checking whether the result is changed; if you get the same result, it means that JavaScript hasn’t enough digits to accommodate your large number <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span>.</p>&#13;
<p class="ListBody">However, you could use <span class="SANS_TheSansMonoCd_W5Regular_11">BigInt</span> values, and then you’d be able to work with much higher values—as long as the size of a factorial doesn’t <span role="doc-pagebreak" epub:type="pagebreak" id="pg_505" aria-label="505"/>exceed the allowed memory. The following program will happily go past 19 until something crashes:</p>&#13;
<pre class="pre" id="pre-389"><code>for (let num = 1n, fact = 1n; fact &lt; fact + 1n; num++) {&#13;
  fact *= num;&#13;
  console.log(`${num}=${fact}`);&#13;
}</code></pre>&#13;
<p class="ListBody">The only difference here is that it’s using <span class="SANS_TheSansMonoCd_W5Regular_11">BigInt</span> numbers: <span class="SANS_TheSansMonoCd_W5Regular_11">1n</span> is such a number.</p>&#13;
<p class="ListHead"><b>8.6  Sampling Testing</b></p>&#13;
<p class="ListPlainFirst">The solution is quite similar to what we used for shuffling, with a special detail related to whether you’re doing sampling with or without repetition:</p>&#13;
<pre class="pre" id="pre-390"><code><span class="listcodeannotated_CodeAnnotation" aria-label="annotation1">❶</span><span class="SANS_TheSansMonoCd_W5Regular_11"> const logResults = (fn, k, n = 10, times = 60000, noReps = true) =&gt; {</span>&#13;
  const bar = (len, val, max) =&gt;&#13;
    "#".repeat(Math.round((len * val) / max));&#13;
&#13;
  const result = {};&#13;
&#13;
  const compare = (a, b) =&gt; (a &lt; b ? -1 : 1);&#13;
&#13;
  let max = 0;&#13;
  for (let i = 1; i &lt; times; i++) {&#13;
    const arr = Array(n)&#13;
      .fill(0)&#13;
      .map((v, i) =&gt; String.fromCharCode(65 + i));&#13;
&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation2">❷</span><span class="SANS_Futura_Std_Book_Oblique_11"> </span><span class="SANS_TheSansMonoCd_W5Regular_11">const x = noReps</span>&#13;
&#13;
      ? fn(arr, k).sort().join(“-”)&#13;
      : fn(arr, k).join(“-”);&#13;
    result[x] = x in result ? result[x] + 1 : 1;&#13;
    max = Math.max(max, result[x]);&#13;
  }&#13;
  let count = 0;&#13;
  for (const [key, val] of Object.entries(result).sort(compare)) {&#13;
    count++;&#13;
    console.log(&#13;
      `${key}: ${String(val).padStart(5)} ${bar(50, val, max)}`,&#13;
    );&#13;
  }&#13;
  console.log("COUNT=", count);&#13;
};</code></pre>&#13;
<p class="ListBody">When sampling without repetition, sample B-C-A is the same as sample C-A-B, so you sort the elements to get a unique key A-B-C. However, when sampling with repetition, the two results are different. The added parameter <span class="SANS_TheSansMonoCd_W5Regular_11">noReps</span> <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span> solves this; when counting the sample, you sort values (or not) depending on it <span class="listbody_CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_506" aria-label="506"/><b>8.7  Single-Line Repeater</b></p>&#13;
<p class="ListPlainFirst">The following is a single statement but is shown here on several lines for clarity. You generate an array of the right size and use <span class="SANS_TheSansMonoCd_W5Regular_11">.map(...)</span> to fill it with randomly chosen values:</p>&#13;
<pre class="pre" id="pre-391"><code>const repeatedPick = (arr, k) =&gt;&#13;
  Array(k)&#13;
    .fill(0)&#13;
    .map(() =&gt; arr[randomInt(0, arr.length)]);</code></pre>&#13;
<p class="ListBody">The tricky part is that you need to use <span class="SANS_TheSansMonoCd_W5Regular_11">.fill(0)</span> to put values in the array. If you don’t do this, <span class="SANS_TheSansMonoCd_W5Regular_11">.map(...)</span> won’t do anything, because it skips uninitialized array locations.</p>&#13;
<p class="ListHead"><b>8.8  Sort to Sample</b></p>&#13;
<p class="ListPlainFirst">The following logic does the work:</p>&#13;
<pre class="pre" id="pre-392"><code>const sortingSample = (arr, k) =&gt; {&#13;
<span class="listcodeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const rand = arr.map((v) =&gt; ({val: v, key: Math.random()}));&#13;
&#13;
<span class="listcodeannotated_CodeAnnotation" aria-label="annotation2">❷</span> for (let i = 0; i &lt; k; i++) {&#13;
    let m = i;&#13;
    for (let j = i + 1; j &lt; arr.length; j++) {&#13;
      if (rand[m].key &gt; rand[j].key) {&#13;
        m = j;&#13;
      }&#13;
    }&#13;
    if (m !== i) {&#13;
      [rand[i], rand[m]] = [rand[m], rand[i]];&#13;
    }&#13;
  }&#13;
&#13;
<span class="listcodeannotated_CodeAnnotation" aria-label="annotation3">❸</span> return rand.slice(0, k).map((obj) =&gt; obj.val);&#13;
};</code></pre>&#13;
<p class="ListBody">This method of assigning random keys comes directly from the section “<span class="listbody_Xref">Shuffling by Sorting</span>” on page <span class="listbody_Xref">139</span> <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span>. The logic that follows is a slight modification of the logic in “<span class="listbody_Xref">Selecting with Comparisons</span>” on page <span class="listbody_Xref">124</span> <span class="listbody_CodeAnnotation" aria-label="annotation2">❷</span>, and the final code to leave just the original values is again from “<span class="listbody_Xref">Shuffling by Sorting</span>” <span class="listbody_CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="ListHead"><b>8.9  Iterate, Don’t Recurse</b></p>&#13;
<p class="ListPlainFirst">To understand why this works, consider what the calls to <span class="SANS_TheSansMonoCd_W5Regular_11">other(...)</span> will be and with which arguments. Applying the conversion to the factorial function produces the well-known equivalent:</p>&#13;
<pre class="pre" id="pre-393"><code>const factorial = (p) =&gt; {&#13;
  let result = 1;&#13;
  for (let i=1; i &lt;= p; i++) {&#13;
    result = result * i&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_507" aria-label="507"/>  }&#13;
  return result;&#13;
}</code></pre>&#13;
<p class="ListBody">Applying the conversion to Floyd’s algorithm is a bit trickier, because the function has two arguments (<span class="SANS_TheSansMonoCd_W5Regular_11">k</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">n</span>), but since their difference is constant because they decrease in parallel, you can achieve the conversion. You’ll need to rename some variables to avoid confusion; for example, we’re already using <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> with another meaning in Floyd’s code.</p>&#13;
<p class="ListHead"><b>8.10  No Limits?</b></p>&#13;
<p class="ListPlainFirst">The check isn’t needed; initially <span class="SANS_TheSansMonoCd_W5Regular_11">toSelect</span> is not greater than <span class="SANS_TheSansMonoCd_W5Regular_11">toConsider</span>. If they ever become equal, from that point onward, all elements will be chosen, because the test <span class="SANS_TheSansMonoCd_W5Regular_11">Math.random() &lt; toSelect / toConsider</span> will always succeed for all random values less than 1, and <span class="SANS_TheSansMonoCd_W5Regular_11">toSelect</span> will eventually become 0.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h2 class="H1" id="sec8"><span id="h1-109"/><span class="SANS_Futura_Std_Bold_B_11">Chapter 9</span></h2>&#13;
<p class="ListHead"><b>9.1  Searching Right</b></p>&#13;
<p class="ListPlainFirst">This is the code I used. The <span class="SANS_TheSansMonoCd_W5Regular_11">checkSearch(...)</span> higher-order function takes a searching function to test and a boolean flag to indicate whether to use it with sorted or unsorted data. The actual files with data are called <span class="SANS_TheSansMonoCd_W5Regular_11">data32</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">data_sorted_32</span>:</p>&#13;
<pre class="pre" id="pre-394"><code>const checkSearch = (fn, sorted = false) =&gt; {&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation1">❶</span> const data32 = sorted ? require("../data_sorted_32") : require("../data32");&#13;
&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation2">❷</span> const verify = (v, i, f) =&gt; {&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation3">❸</span> if (i !== f) {&#13;
      throw new Error(`Failure searching v=${v} i=${i} fn=${f}`);&#13;
    }&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation4">❹</span> if (i !== -1) {&#13;
      console.log("Searching v=", v, " i=", i);&#13;
    }&#13;
  };&#13;
&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation5">❺</span> data32.forEach((v, i) =&gt; {&#13;
    const f = fn([...data32], v);&#13;
    verify(v, i, f);&#13;
  });&#13;
&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation6">❻</span> const m1 = Math.min(...data32);&#13;
  const m2 = Math.max(...data32);&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation7">❼</span> for (let i = m1 - 3; i &lt;= m2 + 3; i++) {&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation8">❽</span> if (!data32.includes(i)) {&#13;
    <span class="listcode_CodeAnnotation" aria-label="annotation9">❾</span> verify(i, -1, fn([...data32], i));&#13;
    }&#13;
  }&#13;
};</code></pre>&#13;
<p class="ListContinued"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_508" aria-label="508"/>You use a sorted or unsorted set of data <span class="listplain_CodeAnnotation" aria-label="annotation1">❶</span> depending on the kind of algorithm. An auxiliary <span class="SANS_TheSansMonoCd_W5Regular_11">verify(...)</span> function <span class="listplain_CodeAnnotation" aria-label="annotation2">❷</span> allows shorter code: the function tests whether the result matches what you expected <span class="listplain_CodeAnnotation" aria-label="annotation3">❸</span>, throwing an error if not. For successful searches <span class="listplain_CodeAnnotation" aria-label="annotation4">❹</span>, it displays the input and output. You try searching for every value in the input array <span class="listplain_CodeAnnotation" aria-label="annotation5">❺</span>. You then find the minimum (<span class="SANS_TheSansMonoCd_W5Regular_11">m1</span>) and maximum (<span class="SANS_TheSansMonoCd_W5Regular_11">m2</span>) values of the array <span class="listplain_CodeAnnotation" aria-label="annotation6">❻</span> and then try all possible (invalid) searches <span class="listplain_CodeAnnotation" aria-label="annotation7">❼</span> from <span class="SANS_TheSansMonoCd_W5Regular_11">m1 - 3</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">m2</span> <span class="SANS_TheSansMonoCd_W5Regular_11">+</span> <span class="SANS_TheSansMonoCd_W5Regular_11">3</span>; whenever a value isn’t included in the array <span class="listplain_CodeAnnotation" aria-label="annotation8">❽</span>, you specifically try to find it, expecting to receive <span class="SANS_TheSansMonoCd_W5Regular_11">-1</span> as result <span class="listplain_CodeAnnotation" aria-label="annotation9">❾</span>.</p>&#13;
<p class="ListHead"><b>9.2  JavaScript’s Own</b></p>&#13;
<p class="ListPlainFirst">The simplest solution would be <span class="SANS_TheSansMonoCd_W5Regular_11">array.findIndex(x</span> <span class="SANS_TheSansMonoCd_W5Regular_11">=&gt; x</span> <span class="SANS_TheSansMonoCd_W5Regular_11">===</span> <span class="SANS_TheSansMonoCd_W5Regular_11">key)</span>.</p>&#13;
<p class="ListHead"><b>9.3  Infinite Search Levels?</b></p>&#13;
<p class="ListPlainFirst">If levels tends to infinity, <span class="SANS_TheSansMonoCd_W5Regular_11">b</span> will always become 2, and that means you split the search area in half at each step. You’ve rediscovered binary search! Roughly speaking, <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> takes the place of <span class="SANS_TheSansMonoCd_W5Regular_11">l</span> in the iterative binary search code, and <span class="SANS_TheSansMonoCd_W5Regular_11">m</span> is the difference between <span class="SANS_TheSansMonoCd_W5Regular_11">l</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">r</span>.</p>&#13;
<p class="ListHead"><b>9.4  Exactly How Much?</b></p>&#13;
<p class="ListPlainFirst">You can calculate the average number of tests by finding the sum of 1 × 1 + 2 × 2 + 4 × 3 + 8 × 4 and so on, up to 2<i><sup>n–</sup></i><sup>1</sup> found in <i>n</i> questions, and dividing by the total number of searches, 2<i><sup>n</sup></i> – 1. We worked this out in section “<span class="Xref">Analysis of Algorithms in Practice</span>” on page <span class="Xref">55</span>, and the sum equals (<i>n</i> + 1)2<i><sup>n</sup></i> –  (2<i><sup>n</sup></i><sup>+1</sup> – 1)). Dividing, you get the average you wanted, which for large values of <i>n</i> is close to <i>n</i> – 1, so for any array length <i>k</i>, the answer is approximately log<sub>2</sub><i>k</i> – 1.</p>&#13;
<p class="ListHead"><b>9.5  Three Tops Two?</b></p>&#13;
<p class="ListPlainFirst">When trying to decide in which third to keep searching, if the key is in the first third, you’ll be able to decide by asking a single question, and if it’s in the other two thirds, you’ll need to ask a second question: on average, you need 1 × 1/3 + 2 × 2/3 = 5/3 questions. Dividing the array by 3, you’ll have log<sub>3</sub> <i>n</i> search steps, compared to log<sub>2</sub> <i>n</i> steps with binary search. Given that log<sub>3</sub> <i>n</i> is approximately 0.631 log<sub>2</sub> <i>n</i>, the performance of ternary search is about 5/3 × 0.631, which equals 1.052 times that of binary search, which is practically the same.</p>&#13;
<p class="ListHead"><b>9.6  Binary First</b></p>&#13;
<p class="ListPlainFirst">The idea is if you find the key, instead of returning it, note the position and keep searching to the left:</p>&#13;
<pre class="pre" id="pre-395"><code>const binaryFindFirst = (arr, key, l = 0, r = arr.length - 1) =&gt; {&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation1">❶</span> let result = -1;&#13;
  while (l &lt;= r) {&#13;
    const m = (l + r) &gt;&gt; 1;&#13;
    if (arr[m] === key) {&#13;
    <span class="listcode_CodeAnnotation" aria-label="annotation2">❷</span> result = m;&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_509" aria-label="509"/>    <span class="listcode_CodeAnnotation" aria-label="annotation3">❸</span> r = m – 1;&#13;
    } else if (arr[m] &gt; key) {&#13;
      r = m - 1;&#13;
    } else {&#13;
      l = m + 1;&#13;
    }&#13;
  }&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation4">❹</span> return result;&#13;
};</code></pre>&#13;
<p class="ListBody">The code is the same as for binary search, with four differences. Initialize a <span class="SANS_TheSansMonoCd_W5Regular_11">result</span> variable <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span> with the value that you’ll return at the end <span class="listbody_CodeAnnotation" aria-label="annotation4">❹</span>. When you find the key, update this variable <span class="listbody_CodeAnnotation" aria-label="annotation2">❷</span>, but instead of returning, keep searching to the left <span class="listbody_CodeAnnotation" aria-label="annotation3">❸</span> just in case the key occurs again.</p>&#13;
<p class="ListBody">To find the last position of <span class="SANS_TheSansMonoCd_W5Regular_11">key</span> in <span class="SANS_TheSansMonoCd_W5Regular_11">arr</span> <span class="listbody_CodeAnnotation" aria-label="annotation3">❸</span>, write <span class="SANS_TheSansMonoCd_W5Regular_11">l</span> <span class="SANS_TheSansMonoCd_W5Regular_11">=</span> <span class="SANS_TheSansMonoCd_W5Regular_11">m</span> <span class="SANS_TheSansMonoCd_W5Regular_11">+</span> <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> to keep searching but to the right.</p>&#13;
<p class="ListHead"><b>9.7  Count Faster</b></p>&#13;
<p class="ListPlainFirst">Use the solutions to the previous problem to find the first and last positions of the key in the array. Of course, if the first search returns <span class="SANS_TheSansMonoCd_W5Regular_11">-1</span>, the count is 0 and you don’t have to do the second search.</p>&#13;
<p class="ListHead"><b>9.8  Rotation Finding</b></p>&#13;
<p class="ListPlainFirst">You can use a variant of binary search for this, but it’s not exactly the same; there’s a careful detail to pay attention to:</p>&#13;
<pre class="pre" id="pre-396"><code>const rotationFind = (arr) =&gt; {&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation1">❶</span> let l = 0;&#13;
  let r = arr.length - 1;&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation2">❷</span> while (arr[l] &gt; arr[r]) {&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation3">❸</span> const m = (l + r) &gt;&gt; 1;&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation4">❹</span> if (arr[m] &gt; arr[r]) {&#13;
      l = m + 1;&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation5">❺</span>} else {&#13;
      r = m;&#13;
    }&#13;
  }&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation6">❻</span> return l;&#13;
};</code></pre>&#13;
<p class="ListBody">You set up <span class="SANS_TheSansMonoCd_W5Regular_11">l</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">r</span> as for binary search <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span>. You’ll stop searching whenever you find that the value at <span class="SANS_TheSansMonoCd_W5Regular_11">l</span> isn’t greater than the value at <span class="SANS_TheSansMonoCd_W5Regular_11">r</span> <span class="listbody_CodeAnnotation" aria-label="annotation2">❷</span>, and while that isn’t true, you’ll search in a half of the array. As in binary search <span class="listbody_CodeAnnotation" aria-label="annotation3">❸</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">m</span> is the middle of the array. If the value at <span class="SANS_TheSansMonoCd_W5Regular_11">m</span> is greater than the value at <span class="SANS_TheSansMonoCd_W5Regular_11">r</span> <span class="listbody_CodeAnnotation" aria-label="annotation4">❹</span>, the rotation is in the right part of the array, and the minimum must be at least at <span class="SANS_TheSansMonoCd_W5Regular_11">m</span> <span class="SANS_TheSansMonoCd_W5Regular_11">+</span> <span class="SANS_TheSansMonoCd_W5Regular_11">1</span>. Otherwise, the value at <span class="SANS_TheSansMonoCd_W5Regular_11">l</span> must be greater than the value at <span class="SANS_TheSansMonoCd_W5Regular_11">m</span> <span class="listbody_CodeAnnotation" aria-label="annotation5">❺</span>, and here you must be very careful because the place of the rotation could be <span class="SANS_TheSansMonoCd_W5Regular_11">m</span> itself! So, when the rotation is on the left, you don’t set <span class="SANS_TheSansMonoCd_W5Regular_11">r</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">m - 1</span>, as in binary search, but rather to <span class="SANS_TheSansMonoCd_W5Regular_11">m</span>. When you find that the value at <span class="SANS_TheSansMonoCd_W5Regular_11">l</span> isn’t greater than the value at <span class="SANS_TheSansMonoCd_W5Regular_11">r</span> <span class="listbody_CodeAnnotation" aria-label="annotation6">❻</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">l</span> is the position you’re looking for.</p>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_510" aria-label="510"/><b>9.9  Special First</b></p>&#13;
<p class="ListPlainFirst">No, you don’t need to. Assume that <span class="SANS_TheSansMonoCd_W5Regular_11">arr[0]</span> <span class="SANS_TheSansMonoCd_W5Regular_11">===</span> <span class="SANS_TheSansMonoCd_W5Regular_11">key</span>:</p>&#13;
<pre class="pre" id="pre-397"><code>const exponentialSearch = (arr, key) =&gt; {&#13;
  const n = arr.length;&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation1">❶</span> let i = 1;&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation2">❷</span> while (i &lt; n &amp;&amp; key &gt; arr[i]) {&#13;
    i = i &lt;&lt; 1;&#13;
  }&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation3">❸</span> return binarySearch(arr, key, i &gt;&gt; 1, Math.min(i, n – 1));&#13;
};</code></pre>&#13;
<p class="ListBody">In the logic, <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> starts at <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span>; the loop exits immediately <span class="listbody_CodeAnnotation" aria-label="annotation2">❷</span> because <span class="SANS_TheSansMonoCd_W5Regular_11">key</span> (<span class="SANS_TheSansMonoCd_W5Regular_11">arr[0]</span>) cannot be greater than <span class="SANS_TheSansMonoCd_W5Regular_11">arr[1]</span>. The final binary search <span class="listbody_CodeAnnotation" aria-label="annotation3">❸</span> is done between 0 and 1 and succeeds.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h2 class="H1" id="sec9"><span id="h1-110"/><span class="SANS_Futura_Std_Bold_B_11">Chapter 10</span></h2>&#13;
<p class="ListHead"><b>10.1  Iterating Through Lists</b></p>&#13;
<p class="ListPlainFirst">To find the size of a list, initialize a pointer to the first element and follow the <span class="SANS_TheSansMonoCd_W5Regular_11">next</span> pointers until you get to the end, counting each node you visit:</p>&#13;
<pre class="pre" id="pre-398"><code>const size = (list) =&gt; {&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation1">❶</span> let count = 0;&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation2">❷</span> for (let ptr = list; ptr !== null; ptr = ptr.next) {&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation3">❸</span> count++;&#13;
  }&#13;
  return count;&#13;
};</code></pre>&#13;
<p class="ListBody">The <span class="SANS_TheSansMonoCd_W5Regular_11">count</span> variable <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span> keeps a count of the elements. You’ll do a loop, starting at the head and advancing until reaching the end <span class="listbody_CodeAnnotation" aria-label="annotation2">❷</span>, and you’ll update the count for each node <span class="listbody_CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="ListBody">Similar code is used to find whether a given value is found in a list:</p>&#13;
<pre class="pre" id="pre-399"><code>const find = (list, value) =&gt; {&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation1">❶</span> for (let ptr = list; ptr !== null; ptr = ptr.next) {&#13;
    if (ptr.value === value) {&#13;
    <span class="listcode_CodeAnnotation" aria-label="annotation2">❷</span> return true;&#13;
    }&#13;
  }&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation3">❸</span> return false;&#13;
};</code></pre>&#13;
<p class="ListBody">The logic of going down the list is the same as for <span class="SANS_TheSansMonoCd_W5Regular_11">count(...)</span> <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span>, and for each element you test whether it matches the desired value. If so, you return <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> <span class="listbody_CodeAnnotation" aria-label="annotation2">❷</span>, and if you reach the end of the list without a match, you return <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> <span class="listbody_CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="ListBody"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_511" aria-label="511"/>Adding an element is also a matter of advancing down the list until reaching either the end or the desired position:</p>&#13;
<pre class="pre" id="pre-400"><code>const add = (list, position, value) =&gt; {&#13;
  if (position === 0) {&#13;
    list = {value, next: list};&#13;
  } else {&#13;
    let ptr;&#13;
    for (&#13;
      ptr = list;&#13;
      ptr.next !== null &amp;&amp; position !== 1;&#13;
      ptr = ptr.next&#13;
    ) {&#13;
      position--;&#13;
    }&#13;
    ptr = {value, next: ptr.next};&#13;
  }&#13;
};</code></pre>&#13;
<p class="ListBody">Finally, removing a given element also works with similar logic: go down the list until you reach the end of the list or the position you want to remove:</p>&#13;
<pre class="pre" id="pre-401"><code>const remove = (list, position) =&gt; {&#13;
  if (!isEmpty(list)) {&#13;
    if (position === 0) {&#13;
      list.first = list.next;&#13;
    } else {&#13;
      let ptr;&#13;
      for (&#13;
        ptr = list;&#13;
        ptr.next !== null &amp;&amp; position !== 1;&#13;
        ptr = ptr.next&#13;
      ) {&#13;
        position--;&#13;
      }&#13;
      if (ptr.next !== null) {&#13;
        ptr.next = ptr.next.next;&#13;
      }&#13;
    }&#13;
  }&#13;
  return list;&#13;
};</code></pre>&#13;
<p class="ListHead"><b>10.2  Going the Other Way</b></p>&#13;
<p class="ListPlainFirst">The idea is that you go through the list, pushing each value into a stack, and the final list will be reversed:</p>&#13;
<pre class="pre" id="pre-402"><code>const reverse = (list) =&gt; {&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation1">❶</span> let newList = null;&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation2">❷</span> while (list !== null) {&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_512" aria-label="512"/>  <span class="listcode_CodeAnnotation" aria-label="annotation3">❸</span> [list.next, newList, list] = [newList, list, list.next];&#13;
  }&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation4">❹</span> return newList;&#13;
};</code></pre>&#13;
<p class="ListBody">Create the reversed list as a stack with <span class="SANS_TheSansMonoCd_W5Regular_11">newList</span> as its pointer <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span>, and use <span class="SANS_TheSansMonoCd_W5Regular_11">list</span> to go element by element <span class="listbody_CodeAnnotation" aria-label="annotation2">❷</span> pushing it into the <span class="SANS_TheSansMonoCd_W5Regular_11">newList</span> stack; you may want to draw a diagram of the pointer juggling that’s going on here <span class="listbody_CodeAnnotation" aria-label="annotation3">❸</span>. At the end, return the reversed list <span class="listbody_CodeAnnotation" aria-label="annotation4">❹</span>. A question for you: Does this algorithm also work for null lists?</p>&#13;
<p class="ListHead"><b>10.3  Joining Forces</b></p>&#13;
<p class="ListPlainFirst">The idea is to look for the last element of the first list and link it to the head of the second list:</p>&#13;
<pre class="pre" id="pre-403"><code>const append = (list1, list2) =&gt; {&#13;
  if (list1 === null) {&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation1">❶</span> list1 = list2;&#13;
  } else {&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation2">❷</span> let ptr = list1;&#13;
    while (ptr.next !== null) {&#13;
    <span class="listcode_CodeAnnotation" aria-label="annotation3">❸</span> ptr = ptr.next;&#13;
    }&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation4">❹</span> ptr.next = list2;&#13;
  }&#13;
  return list1;&#13;
};</code></pre>&#13;
<p class="ListBody">An interesting case is if the first list is empty <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span>, the result of the operation is the second list. Otherwise, use <span class="SANS_TheSansMonoCd_W5Regular_11">ptr</span> to go down the first list <span class="listbody_CodeAnnotation" aria-label="annotation2">❷</span>, advancing while the end hasn’t been reached <span class="listbody_CodeAnnotation" aria-label="annotation3">❸</span>. When reaching the end <span class="listbody_CodeAnnotation" aria-label="annotation4">❹</span>, just modify its <span class="SANS_TheSansMonoCd_W5Regular_11">next</span> pointer to point at the second list.</p>&#13;
<p class="ListHead"><b>10.4  Unloop the Loop</b></p>&#13;
<p class="ListPlainFirst">You don’t need to store anything; just use two pointers. The idea is to advance down the list with two pointers, one a node at a time, and one at twice the speed. If the list doesn’t have a loop, the second will reach the end and you’re done. If the list has a loop, however, the two pointers will eventually meet (because the second moves faster than the first), and that means there’s a loop:</p>&#13;
<pre class="pre" id="pre-404"><code>const hasALoop = (list) =&gt; {&#13;
  if (list === null) {&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation1">❶</span> return false;&#13;
  } else {&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation2">❷</span> let ptr1 = list;&#13;
    let ptr2 = list.next;&#13;
&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation3">❸</span> while (ptr2 !== null &amp;&amp; ptr2 !== ptr1) {&#13;
    <span class="listcode_CodeAnnotation" aria-label="annotation4">❹</span> ptr1 = ptr1.next;&#13;
    <span class="listcode_CodeAnnotation" aria-label="annotation5">❺</span> ptr2 = ptr2.next ? ptr2.next.next : null;&#13;
    }&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_513" aria-label="513"/>  <span class="listcode_CodeAnnotation" aria-label="annotation6">❻</span> return ptr2 === ptr1;&#13;
  }&#13;
};</code></pre>&#13;
<p class="ListBody">If the list is empty <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span>, then for certain there’s no loop. Otherwise, <span class="SANS_TheSansMonoCd_W5Regular_11">ptr1</span> goes down the list a node at a time, and <span class="SANS_TheSansMonoCd_W5Regular_11">ptr2</span> advances two nodes at a time <span class="listbody_CodeAnnotation" aria-label="annotation2">❷</span>. You’ll keep working unless <span class="SANS_TheSansMonoCd_W5Regular_11">ptr2</span> reaches the end or <span class="SANS_TheSansMonoCd_W5Regular_11">ptr2</span> reaches <span class="SANS_TheSansMonoCd_W5Regular_11">ptr1</span> <span class="listbody_CodeAnnotation" aria-label="annotation3">❸</span>. During the iteration, <span class="SANS_TheSansMonoCd_W5Regular_11">ptr1</span> advances one node <span class="listbody_CodeAnnotation" aria-label="annotation4">❹</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">ptr2</span> advances twice <span class="listbody_CodeAnnotation" aria-label="annotation5">❺</span> unless it reached the end. At the end, if <span class="SANS_TheSansMonoCd_W5Regular_11">ptr2</span> had reached <span class="SANS_TheSansMonoCd_W5Regular_11">ptr1</span>, there’s a loop; otherwise, there isn’t.</p>&#13;
<p class="ListHead"><b>10.5  Arrays for Stacks</b></p>&#13;
<p class="ListPlainFirst">Given the <span class="SANS_TheSansMonoCd_W5Regular_11">.pop(...)</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">.push(...)</span> methods, implementing a stack is straightforward:</p>&#13;
<pre class="pre" id="pre-405"><code><span class="listcodeannotated_CodeAnnotation" aria-label="annotation1">❶</span><span class="SANS_TheSansMonoCd_W5Regular_11"> const newStack = () =&gt; [];</span>&#13;
&#13;
<span class="listcodeannotated_CodeAnnotation" aria-label="annotation2">❷</span> const isEmpty = (stack) =&gt; stack.length === 0;&#13;
&#13;
const push = (stack, value) =&gt; {&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation3">❸</span> stack.push(value);&#13;
  return stack;&#13;
};&#13;
&#13;
const pop = (stack) =&gt; {&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation4">❹</span> if (!isEmpty(stack)) {&#13;
    stack.pop();&#13;
  }&#13;
  return stack;&#13;
};&#13;
<span class="listcodeannotated_CodeAnnotation" aria-label="annotation5">❺</span> const top = (stack) =&gt;   isEmpty(stack) ? undefined : stack[stack.length – 1];</code></pre>&#13;
<p class="ListBody">A new stack is just an empty array <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span>, and to check for an empty stack, you just see whether the array’s length is zero <span class="listbody_CodeAnnotation" aria-label="annotation2">❷</span>. To push a new value <span class="listbody_CodeAnnotation" aria-label="annotation3">❸</span>, use <span class="SANS_TheSansMonoCd_W5Regular_11">.push(...)</span> and use <span class="SANS_TheSansMonoCd_W5Regular_11">.pop()</span> <span class="listbody_CodeAnnotation" aria-label="annotation4">❹</span> to pop with a check for an empty stack. Finally, getting to the top of the stack is just a matter of looking at the last element of the array <span class="listbody_CodeAnnotation" aria-label="annotation5">❺</span>.</p>&#13;
<p class="ListHead"><b>10.6  Stack Printing</b></p>&#13;
<p class="ListPlainFirst">Given the implementations of <span class="SANS_TheSansMonoCd_W5Regular_11">size(...)</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">find(...)</span> in the first question for this chapter, you shouldn’t need further explanation for this:</p>&#13;
<pre class="pre" id="pre-406"><code>const print = (list) =&gt; {&#13;
  for (let ptr = list; ptr !== null; ptr = ptr.next) {&#13;
    console.log(ptr.value);&#13;
  }&#13;
};</code></pre>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_514" aria-label="514"/><b>10.7  Height of a Stack</b></p>&#13;
<p class="ListPlainFirst">You could implement this in <i>O</i>(<i>n</i>) time by using code similar to the code in the previous question, but a simpler solution is to add a <span class="SANS_TheSansMonoCd_W5Regular_11">height</span> field to the stack definition initialized to zero and update that field appropriately when pushing or popping values. A stack would now be something more similar to a queue, in that an object is used instead of just a pointer:</p>&#13;
<pre class="pre" id="pre-407"><code>const newStack = () =&gt; ({first: null, height: 0});</code></pre>&#13;
<p class="ListHead"><b>10.8  Maximum Stack</b></p>&#13;
<p class="ListPlainFirst">The idea is to push entries with two pieces of data: not only the value that’s being pushed, but also the current maximum, which depends on the value being pushed and the previous maximum, which was at the top of the stack before the push. To find the minimum, you’d push three pieces of data: the value to be pushed, the maximum at that time, and the minimum at the same time. This allows knowing the maximum or minimum at any moment, in <i>O</i>(1) time.</p>&#13;
<p class="ListHead"><b>10.9  Queued Arrays</b></p>&#13;
<p class="ListPlainFirst">This operation essentially requires the same implementation as for stacks, except that for entering a queue, use <span class="SANS_TheSansMonoCd_W5Regular_11">.unshift(...)</span> instead of <span class="SANS_TheSansMonoCd_W5Regular_11">push(...)</span>, so new values are added at the beginning of the array instead of at the end.</p>&#13;
<p class="ListHead"><b>10.10  Queue Length</b></p>&#13;
<p class="ListPlainFirst">Trick question! Just apply the same logic as for question 10.9.</p>&#13;
<p class="ListHead"><b>10.11  Queueing for Sorting</b></p>&#13;
<p class="ListPlainFirst">The following code does the work; it just rewrites the <span class="SANS_TheSansMonoCd_W5Regular_11">_radixSort(arr)</span> function from the “<span class="listplain_Xref">Radix Sort</span>” section on page <span class="listplain_Xref">115</span>, which sorts an input array:</p>&#13;
<pre class="pre" id="pre-408"><code>const _radixSort = (arr) =&gt; {&#13;
  const ML = Math.max(...arr.map((x) =&gt; String(x).length));&#13;
&#13;
  for (let i = 0, div = 1; i &lt; ML; i++, div *= 10) {&#13;
    const buckets = Array(10)&#13;
      .fill(0)&#13;
    <span class="listcode_CodeAnnotation" aria-label="annotation1">❶</span> .map(() =&gt; ({first: null, last: null}));&#13;
&#13;
    arr.forEach((v) =&gt; {&#13;
    <span class="listcode_CodeAnnotation" aria-label="annotation2">❷</span> const digit = Math.floor(v / div) % 10;&#13;
    <span class="listcode_CodeAnnotation" aria-label="annotation3">❸</span> const newNode = {v, next: null};&#13;
      if (buckets[digit].first === null) {&#13;
        buckets[digit].first = newNode;&#13;
      } else {&#13;
        buckets[digit].last.next = newNode;&#13;
      }&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_515" aria-label="515"/>      buckets[digit].last = newNode;&#13;
    });&#13;
&#13;
    arr = [];&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation4">❹</span> buckets.forEach((b) =&gt; {&#13;
      for (let ptr = b.first; ptr; ptr = ptr.next) {&#13;
        arr.push(ptr.v);&#13;
      }&#13;
    });&#13;
  }&#13;
&#13;
  return arr;&#13;
};</code></pre>&#13;
<p class="ListBody">The differences in the code from that in <span class="listbody_Xref">Chapter 6</span> are highlighted. Instead of creating arrays for each bucket, set up queues <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span>. For each value, after deciding which bucket it will go in <span class="listbody_CodeAnnotation" aria-label="annotation2">❷</span>, make it enter the corresponding queue <span class="listbody_CodeAnnotation" aria-label="annotation3">❸</span>. After distributing values into queues, go through each of them <span class="listbody_CodeAnnotation" aria-label="annotation4">❹</span> to generate an array.</p>&#13;
<p class="ListHead"><b>10.12  Stacked Queues</b></p>&#13;
<p class="ListPlainFirst">As suggested, the idea is to use two stacks: say IN and OUT. Push the new value to the IN stack to enter the queue. Pop the OUT stack to exit the queue, but if it was empty, first pop all values from the IN stack, one at the time, and push them to OUT, before finally doing the pop. Every value that enters the queue will go through two pushes (first to IN and at a later time to OUT) and two pops (at some later time from IN and eventually from OUT), so the amortized cost of the operation is <i>O</i>(1). Obviously, some exit operations (those that find an empty OUT stack) will require more time.</p>&#13;
<p class="ListHead"><b>10.13  Palindrome Detection</b></p>&#13;
<p class="ListPlainFirst">The idea is to split the string into separate characters and enter all the letters into a deque. When you’re done, repeatedly check whether the front element is the same as the last element, and exit them both. If you get down to zero elements (<span class="SANS_TheSansMonoCd_W5Regular_11">first</span> is null) or just one (<span class="SANS_TheSansMonoCd_W5Regular_11">first</span> equals <span class="SANS_TheSansMonoCd_W5Regular_11">last</span>), the string was a palindrome.</p>&#13;
<p class="ListHead"><b>10.14  Circular Listing</b></p>&#13;
<p class="ListPlainFirst">The following logic does the job:</p>&#13;
<pre class="pre" id="pre-409"><code>const print = (circ) =&gt; {&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation1">❶</span> if (!isEmpty(circ)) {&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation2">❷</span> let ptr = circ;&#13;
    do {&#13;
    <span class="listcode_CodeAnnotation" aria-label="annotation3">❸</span> console.log(ptr.value);&#13;
    <span class="listcode_CodeAnnotation" aria-label="annotation4">❹</span> ptr = ptr.next;&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation5">❺</span>} while (ptr !== circ);&#13;
  }&#13;
};</code></pre>&#13;
<p class="ListBody"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_516" aria-label="516"/>First check for an empty circular list; if so, you don’t have to do anything <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span>. Use <span class="SANS_TheSansMonoCd_W5Regular_11">ptr</span> to go around the list <span class="listbody_CodeAnnotation" aria-label="annotation2">❷</span>, printing each visited node <span class="listbody_CodeAnnotation" aria-label="annotation3">❸</span>, advancing to the next <span class="listbody_CodeAnnotation" aria-label="annotation4">❹</span>, and exiting the loop when reaching the initial node again <span class="listbody_CodeAnnotation" aria-label="annotation5">❺</span>.</p>&#13;
<p class="ListHead"><b>10.15  Joining Circles</b></p>&#13;
<p class="ListPlainFirst">Manipulating links isn’t hard, but you have to be careful. Initially, you’ll have this scenario:</p>&#13;
<figure class="IMG"><img class="img7" src="../images/pg516-1.jpg" alt=""/></figure>&#13;
<p class="ListBody">And you’ll want to get to this situation:</p>&#13;
<figure class="IMG"><img class="img7" src="../images/pg516-2.jpg" alt=""/></figure>&#13;
<p class="ListBody">Assuming that both <span class="SANS_TheSansMonoCd_W5Regular_11">circ1</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">circ2</span> are not null, you need four lines of code:</p>&#13;
<pre class="pre" id="pre-410"><code><span class="listcodeannotated_CodeAnnotation" aria-label="annotation1">❶</span><span class="SANS_TheSansMonoCd_W5Regular_11"> circ2.prev.next = circ1.next;</span>&#13;
<span class="listcodeannotated_CodeAnnotation" aria-label="annotation2">❷</span> circ1.next.prev = circ2.prev;&#13;
<span class="listcodeannotated_CodeAnnotation" aria-label="annotation3">❸</span> circ1.next = circ2;&#13;
<span class="listcodeannotated_CodeAnnotation" aria-label="annotation4">❹</span> circ2.prev = circ1;</code></pre>&#13;
<p class="ListBody">First, B follows N <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span>. Set B so that N precedes it <span class="listbody_CodeAnnotation" aria-label="annotation2">❷</span>. Similarly, J follows A <span class="listbody_CodeAnnotation" aria-label="annotation3">❸</span>, and A precedes J <span class="listbody_CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h2 class="H1" id="sec10"><span id="h1-111"/><span class="SANS_Futura_Std_Bold_B_11">Chapter 11</span></h2>&#13;
<p class="ListHead"><b>11.1  Sentinels for Searches</b></p>&#13;
<p class="ListPlainFirst">If an ordered list includes a final +<span class="SANS_TheSansMonoCd_W5Regular_11">Infinity</span> value, you can simplify the search because you know you’ll never get past the end:</p>&#13;
<pre class="pre" id="pre-411"><code>const find = (list, valueToFind) =&gt; {&#13;
  if <b>(valueToFind &lt; list.value)</b> {&#13;
    return false;&#13;
  } else if (valueToFind === list.value) {&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_517" aria-label="517"/>    return true;&#13;
  } else {&#13;
    // valueToRemove &gt; list.value&#13;
    return find(list.next, valueToFind);&#13;
  }&#13;
};</code></pre>&#13;
<p class="ListBody">Compare this code to the code in the section “<span class="Xref">Searching for a Value</span><i>”</i> on page <span class="listbody_Xref">183</span>; the first <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> is now simpler. (I agree that the speed gain may be minimal, but the technique is commonly used and worth knowing.)</p>&#13;
<p class="ListHead"><b>11.2  More Sentinels?</b></p>&#13;
<p class="ListPlainFirst">An initial <span class="SANS_TheSansMonoCd_W5Regular_11">-Infinity</span> value means that you’ll never add a new value at the beginning of the list, so essentially that makes the pointer to the head a constant. This extra sentinel makes iterative code simpler; you can check it out yourself.</p>&#13;
<p class="ListHead"><b>11.3  A Simpler Search?</b></p>&#13;
<p class="ListPlainFirst">You could change the function to return either <span class="SANS_TheSansMonoCd_W5Regular_11">null</span> (if the value wasn’t found) or a pointer to the value—which will just be the first in the list.</p>&#13;
<p class="ListHead"><b>11.4  Re-skipping Lists</b></p>&#13;
<p class="ListPlainFirst">Start by deleting all pointers at levels other than the bottom one. Then, create level 1 by going through level 0 and choosing all elements at even positions; level 1 will end with about half the elements of level 0. Redo this process to create level 2 based on elements at even positions in level 1; then, create level 3 based on even positions in level 2, and so on. Stop when the topmost list has only one element.</p>&#13;
<p class="ListHead"><b>11.5  Skip to an Index</b></p>&#13;
<p class="ListPlainFirst">You want to be able to produce, say, the 229th value of a list without having to go one by one past the previous 228 values. To sketch the solution, you’ll define the “width” of a link as the number of values at the next level that are encompassed by the link. (In other words, how many nodes do you jump over by following the link?) You can create and update the widths when adding or removing values. All widths at the bottom level are 1. At any level, if a link goes from node A to node B, the width of the link is the sum of all the widths from A (inclusive) to B (exclusive).</p>&#13;
<p class="ListBody">Knowing these widths makes it easy to find any given position. You start at the topmost level, going horizontally as long as the sum of widths doesn’t exceed the index you want. When this sum surpasses the index you want, you go down to the next level and keep going horizontally.</p>&#13;
<figure class="IMG"><img class="img1" src="../images/pg517.jpg" alt=""/></figure>&#13;
<p class="ListBody"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_518" aria-label="518"/>For instance, in the diagram provided, say you want to find the 11th element of the list (the widths of links are in parentheses below each link). At the first level, the first three links cover 2 + 4 + 2 = 8 elements, so by following them in three steps, you’re already at the 8th element of the list. The next link is 4, so that would go past the 11th, and you’d go down. The widths of the links there are all 1, so you advance a couple more times and find 40, the 11th value.</p>&#13;
<p class="ListHead"><b>11.6  Simpler Filling</b></p>&#13;
<p class="ListPlainFirst">It would fill the array with a reference to the <i>same</i> list, instead of references to 100 distinct lists.</p>&#13;
<p class="ListHead"><b>11.7  A Hashed Set</b></p>&#13;
<p class="ListPlainFirst">For searches and removals, there’s no change whatsoever. For additions, the key is to keep searching until you either find the value (in which case you wouldn’t add it again) or reach an empty space. For efficiency, should you find an available slot during the search, make a note of it, and instead of adding the new value at the empty space, put it into the available slot.</p>&#13;
<p class="ListHead"><b>11.8  Wrong Seating</b></p>&#13;
<p class="ListPlainFirst">The key is to look at the problem in a different way. Instead of thinking that a person upon finding their seat occupied moves to some other random seat, imagine that <i>they</i> sit down and the previous occupant of the seat is the one who moves away. (In other words, the one who originally sat down in the wrong place.) By the time the 100th person enters, 98 people will be in their assigned seats, and the first person who entered the theater will be either in their seat or in the 100th person’s seat—it depends on how the previous person moved with only two possible seats to choose: their seat or the 100th person’s seat. (If they had chosen any other seat, they would have had to move again when the rightful occupant of the seat appeared.) The answer is 50 percent.</p>&#13;
<p class="ListHead"><b>11.9  Progressive Resizing</b></p>&#13;
<p class="ListPlainFirst">The idea is to work with both tables at the same time, gradually removing values from the old one and inserting them in the new one. After you decide you need to resize, create a new, larger table, and from then on, all insertions will go to the new table. Whenever you want to search for a value, look in both tables; a value in the old table may have already been moved to the new table. (The same applies to removals.) Every time you do an operation (add, remove, or search), remove some values from the old table and insert them into the new one. When every value has been removed from the old table, just work with the new one.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h2 class="H1" id="sec11"><span id="h1-112"/><span class="SANS_Futura_Std_Bold_B_11">Chapter 12</span></h2>&#13;
<p class="ListHead"><b>12.1  A Matter of Levels</b></p>&#13;
<p class="ListPlainFirst">The height of a tree would be the highest level of its nodes.</p>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_519" aria-label="519"/><b>12.2  Breaking the Rules</b></p>&#13;
<p class="ListPlainFirst">Symbolic links (symlinks) may point to any file or directory, so they allow you to break the tree structure.</p>&#13;
<p class="ListHead"><b>12.3  What’s in a Name?</b></p>&#13;
<p class="ListPlainFirst">A <i>perfect tree</i> is complete and full. A <i>complete tree</i> isn’t necessarily perfect (the bottom need not be complete), and it may not be full either, because a node may have only one child—for example, a tree with just two nodes. Finally, a <i>full tree</i> may be neither complete nor perfect; see <span class="listplain_Xref">Chapter 13</span> for an example of this.</p>&#13;
<p class="ListHead"><b>12.4  A</b> <b>find()</b> <b>One-Liner</b></p>&#13;
<p class="ListPlainFirst">Using the ternary operator, you can make do as follows:</p>&#13;
<pre class="pre" id="pre-412"><code>const find = (tree, keyToFind) =&gt;&#13;
  !isEmpty(tree) &amp;&amp;&#13;
  (keyToFind === tree.key ||&#13;
    find(&#13;
      tree[keyToFind &lt; tree.key ? "left" : "right"],&#13;
      keyToFind,&#13;
    ));</code></pre>&#13;
<p class="ListBody">Because of space restrictions, this appears as several lines of text, but it’s a single statement in any case.</p>&#13;
<p class="ListHead"><b>12.5  Sizing a Tree</b></p>&#13;
<p class="ListPlainFirst">Given the definition that an empty tree has size 0 and that, otherwise, the size of a tree is 1 (for the root) plus the sizes of both subtrees, you can write a one-liner solution for this:</p>&#13;
<pre class="pre" id="pre-413"><code>const {&#13;
  isEmpty,&#13;
} = require("../binary_search_tree.js");&#13;
&#13;
const calcSize = (tree) =&gt;&#13;
<b>  isEmpty(tree)</b>&#13;
<b>    ? 0</b>&#13;
<b>    : 1 + getSize(tree.left) + getSize(tree.right);</b></code></pre>&#13;
<p class="ListHead"><b>12.6  Tall as a Tree</b></p>&#13;
<p class="ListPlainFirst">The height of a tree is the maximum length of a path from the root to a leaf. So, if you know the heights of both subtrees of the root, the height of the complete tree will be one more than the height of the highest subtree. You can program this very simply using recursion:</p>&#13;
<pre class="pre" id="pre-414"><code>const {isEmpty} = require("../binary_search_tree.js");&#13;
&#13;
const calcHeight = (tree) =&gt;&#13;
  isEmpty(tree)&#13;
    ? 0&#13;
    : <b>1 + Math.max(getHeight(tree.left), getHeight(tree.right))</b>;</code></pre>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_520" aria-label="520"/><b>12.7  Copy a Tree</b></p>&#13;
<p class="ListPlainFirst">Recursion is the best solution: a copy of an empty tree is just an empty tree, and a copy of a nonempty tree is built out of the tree’s root, plus copies of its left and right subtrees:</p>&#13;
<pre class="pre" id="pre-415"><code>const {newNode, isEmpty} = require("../binary_search_tree.js");&#13;
&#13;
const makeCopy = (tree) =&gt;&#13;
  isEmpty(tree)&#13;
    ? tree&#13;
    : <b>newNode(tree.key, makeCopy(tree.left), makeCopy(tree.right))</b>;</code></pre>&#13;
<p class="ListBody">You can also build a copy another way, which should remind you of a postorder traversal:</p>&#13;
<pre class="pre" id="pre-416"><code>const makeCopy2 = (tree) =&gt; {&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation1">❶</span> if (isEmpty(tree)) {&#13;
    return tree;&#13;
  } else {&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation2">❷</span> const newLeft = makeCopy2(tree.left);&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation3">❸</span> const newRight = makeCopy2(tree.right);&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation4">❹</span> return newNode(tree.key, newLeft, newRight);&#13;
  }&#13;
};</code></pre>&#13;
<p class="ListBody">If the tree to copy is null <span class="CodeAnnotation" aria-label="annotation1">❶</span>, nothing needs to be done. Otherwise, first make a copy of the left subtree <span class="CodeAnnotation" aria-label="annotation2">❷</span>, then a copy of the right subtree <span class="CodeAnnotation" aria-label="annotation3">❸</span>, and finally, build a tree out of the tree’s key plus the two newly created trees <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
<p class="ListHead"><b>12.8  Do the Math</b></p>&#13;
<p class="ListPlainFirst">You need a postorder traversal for this, because before applying any operator, you need to know the value of its left and right subexpressions. You can do this with a function, since a whole class would be overkill:</p>&#13;
<pre class="pre" id="pre-417"><code>const evaluate = (tree) =&gt; {&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation1">❶</span> if (!tree) {&#13;
   return 0;&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation2">❷</span>} else if (typeof tree.key === "number") {&#13;
   return tree.key;&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation3">❸</span>} else if (tree.key === "+") {&#13;
   return evaluate(tree.left) + evaluate(tree.right);&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation4">❹</span>} else if (tree.key === "-") {&#13;
   return evaluate(tree.left) - evaluate(tree.right);&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation5">❺</span>} else if (tree.key === "*") {&#13;
   return evaluate(tree.left) * evaluate(tree.right);&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation6">❻</span>} else if (tree.key === "/") {&#13;
   return evaluate(tree.left) / evaluate(tree.right);&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation7">❼</span>} else {&#13;
   throw new Error("Don't know what to do with ", tree.key);&#13;
  }&#13;
};</code></pre>&#13;
<p class="ListBody"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_521" aria-label="521"/>If the tree is empty <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span>, you return 0, a reasonable value. Otherwise, if the root is a number <span class="listbody_CodeAnnotation" aria-label="annotation2">❷</span>, just return that number, and if the root is an operator <span class="listbody_CodeAnnotation" aria-label="annotation3">❸</span> <span class="listbody_CodeAnnotation" aria-label="annotation4">❹</span> <span class="listbody_CodeAnnotation" aria-label="annotation5">❺</span> <span class="listbody_CodeAnnotation" aria-label="annotation6">❻</span>, use recursion to evaluate both sides of the expression and return the calculated value. You also add a “catch-all” for any unexpected input <span class="listbody_CodeAnnotation" aria-label="annotation7">❼</span>.</p>&#13;
<p class="ListBody">A simple example shows this at work:</p>&#13;
<pre class="pre" id="pre-418"><code>const exampleInBook = {&#13;
  key: "*",&#13;
  left: {&#13;
    key: "+",&#13;
    left: {key: 2},&#13;
    right: {key: 3}&#13;
  },&#13;
  right: {&#13;
    key: 6&#13;
  }&#13;
};</code></pre>&#13;
<p class="ListBody">This code returns <span class="SANS_TheSansMonoCd_W5Regular_11">30</span>, as expected. Can you figure out why I didn’t include null pointers?</p>&#13;
<p class="ListHead"><b>12.9  Making It Bad</b></p>&#13;
<p class="ListPlainFirst">You never want to have a node with two children, so the root must be either the minimum or the maximum of the set of keys. After that, the following key must also have a single child, so it must be either the minimum or the maximum of the remaining set of keys. If you follow this logic to the end, you have two options for the first key, times two options for the second key, times two options for the third key, and so on, up until the (<i>n</i> – 1) key, after which a single option is left. The number of linear trees you can produce out of <i>n</i> keys is then 2<i><sup>n</sup></i> <sup>–1</sup>.</p>&#13;
<p class="ListHead"><b>12.10  Rebuild the Tree</b></p>&#13;
<p class="ListPlainFirst">Given the preorder and inorder lists, it’s clear that the root of the tree must be the first value in the preorder. If you look for that value in the inorder list, all keys preceding it will come from the root’s left subtree and all keys after it will be from the right subtree. Separate the preorder list in two, and you’ll have the preorder and inorder listings for both subtrees; apply recursion, and you’ll build the tree.</p>&#13;
<p class="ListHead"><b>12.11  More Rebuilding?</b></p>&#13;
<p class="ListPlainFirst">Working with inorder and postorder would be possible; the only difference is that you’d find the root at the end of the postorder listing instead of at the beginning of the preorder listing. However, working with preorder and postorder isn’t possible—and an example should suffice to show why. If I tell you that the preorder listing was “1, 2” and the postorder listing was “2, 1”, two possible binary search trees produce those listings. Can you find them?</p>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_522" aria-label="522"/><b>12.12  Equal Traversals</b></p>&#13;
<p class="ListPlainFirst">Preorder and inorder would be the same if there were no left trees, so the first answer is “trees with only right subtrees”; for inorder and postorder, the answer would similarly be “trees with only left subtrees.” Finally, for preorder and postorder, the answer is “trees with no more than one key.”</p>&#13;
<p class="ListHead"><b>12.13  Sorting by Traversing</b></p>&#13;
<p class="ListPlainFirst">First, add all the keys into a binary search tree, create an empty array, and then do an inorder traversal providing a <span class="SANS_TheSansMonoCd_W5Regular_11">visit</span> function that will push the key value into the array. (You’ll use this technique later in question 12.26.)</p>&#13;
<p class="ListHead"><b>12.14  Generic Order</b></p>&#13;
<p class="ListPlainFirst">The following code will do. Note the two recursive calls mixed with the three possible <span class="SANS_TheSansMonoCd_W5Regular_11">visit()</span> calls:</p>&#13;
<pre class="pre" id="pre-419"><code>const {isEmpty} = require("../binary_search_tree.js");&#13;
&#13;
const anyOrder = (tree, order, visit = (x) =&gt; console.log(x)) =&gt; {&#13;
  if (!isEmpty(tree)) {&#13;
    order === "PRE" &amp;&amp; visit(tree.key);&#13;
    anyOrder(tree.left, order, visit);&#13;
    order === "IN" &amp;&amp; visit(tree.key);&#13;
    anyOrder(tree.right, order, visit);&#13;
    order === "POST" &amp;&amp; visit(tree.key);&#13;
  }&#13;
};</code></pre>&#13;
<p class="ListHead"><b>12.15  No Recursion Traversal</b></p>&#13;
<p class="ListPlainFirst">Use a stack from <span class="listplain_Xref">Chapter 11</span>. You could do specific solutions for each of the traversals, but let’s go with a generic solution (actually implementing the <span class="SANS_TheSansMonoCd_W5Regular_11">anyOrder()</span> function from earlier) to highlight how a stack makes avoiding recursion easy.</p>&#13;
<p class="ListBody">The idea is that you’ll push into the stack the pending operations, which can be of two types: visit a key (type <span class="SANS_TheSansMonoCd_W5Regular_11">"K"</span>) or traverse a tree (type <span class="SANS_TheSansMonoCd_W5Regular_11">"T"</span>). You’ll push these operations, and the main code will be a loop that will pop an operation and do it, which may imply visiting or traversing, and the latter will cause more operations to be pushed in:</p>&#13;
<pre class="pre" id="pre-420"><code>const anyOrder = (tree, order, visit = (x) =&gt; console.log(x)) =&gt; {&#13;
  let pending = newStack();&#13;
  let type = "";&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation1">❶</span> pending = push(pending, {tree, type: "T"});&#13;
&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation2">❷</span> while (!isEmptyStack(pending)) {&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation3">❸</span> [pending, {tree, type}] = pop(pending);&#13;
&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation4">❹</span> if (!isEmptyTree(tree)) {&#13;
    <span class="listcode_CodeAnnotation" aria-label="annotation5">❺</span> if (type === "K") {&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_523" aria-label="523"/>       visit(tree.key);&#13;
    <span class="listcode_CodeAnnotation" aria-label="annotation6">❻</span>} else {&#13;
       if (order === "POST") {&#13;
       pending = push(pending, {tree, type: "K"});&#13;
       }&#13;
       pending = push(pending, {tree: tree.right, type: "T"});&#13;
       if (order === "IN") {&#13;
         pending = push(pending, {tree, type: "K"});&#13;
       }&#13;
       pending = push(pending, {tree: tree.left, type: "T"});&#13;
       if (order === "PRE") {&#13;
         pending = push(pending, {tree, type: "K"});&#13;
        }&#13;
      }&#13;
    }&#13;
  }&#13;
};</code></pre>&#13;
<p class="ListBody">Start by creating a stack and pushing the tree you want to traverse <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span>. While there are pending operations <span class="listbody_CodeAnnotation" aria-label="annotation2">❷</span>, you’ll pop the top one <span class="listbody_CodeAnnotation" aria-label="annotation3">❸</span>, and if it doesn’t point to an empty tree <span class="listbody_CodeAnnotation" aria-label="annotation4">❹</span>, you’ll execute whatever is needed. If the operation was a <span class="SANS_TheSansMonoCd_W5Regular_11">"K"</span>, just visit the node <span class="listbody_CodeAnnotation" aria-label="annotation5">❺</span>, and if it was a <span class="SANS_TheSansMonoCd_W5Regular_11">"T"</span> <span class="listbody_CodeAnnotation" aria-label="annotation6">❻</span>, you’ll have to push two operations (traverse the left and right subtrees) and a visit (for the root). The key point is to make sure to push them in backward order, so the operations will be popped in the right sequence; study this carefully. For instance, if you are doing a postorder traversal, you’ll first push the root visit, then the right subtree traversal, and finally the left subtree traversal—and when you do those operations in reverse order, everything will come out right.</p>&#13;
<p class="ListHead"><b>12.16  No Duplicates Allowed</b></p>&#13;
<p class="ListPlainFirst">Basically, you just have to check whether you have arrived at the value you were thinking of adding:</p>&#13;
<pre class="pre" id="pre-421"><code>const add = (tree, keyToAdd) =&gt; {&#13;
  if (isEmpty(tree)) {&#13;
    return newNode(keyToAdd);&#13;
 <span class="listcode_CodeAnnotation" aria-label="annotation1">❶</span><b>} else if (keyToAdd === tree.key) {</b>&#13;
<b>    throw new Error("No duplicate keys allowed");</b>&#13;
  } else {&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation2">❷</span> const side = keyToAdd &lt; tree.key ? "left" : "right";&#13;
    tree[side] = add(tree[side], keyToAdd);&#13;
    return tree;&#13;
  }&#13;
};</code></pre>&#13;
<p class="ListBody">You add a test for equality before continuing the search <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span>, and the other minor change is that you don’t test for “less-than-or-equal-to” <span class="listbody_CodeAnnotation" aria-label="annotation2">❷</span>, because the key can never be equal.</p>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_524" aria-label="524"/><b>12.17  Get and Delete</b></p>&#13;
<p class="ListPlainFirst">You can manage to get the minimum and remove it at the same time, if after finding the minimum value in the (not empty) tree, you copy its right subtree to the node; see the following diagram for an example:</p>&#13;
<figure class="IMG"><img class="img7" src="../images/pg524.jpg" alt=""/></figure>&#13;
<p class="ListBody">Here’s how to implement this algorithm:</p>&#13;
<pre class="pre" id="pre-422"><code>const _removeMinFromTree = (tree) =&gt; {// not empty tree assumed&#13;
  if (isEmpty(tree.left)) {&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation1">❶</span> return [tree.right, tree.key];&#13;
  } else {&#13;
    let min;&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation2">❷</span> [tree.left, min] = _removeMin(tree.left);&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation3">❸</span> return [tree, min];&#13;
  }&#13;
};</code></pre>&#13;
<p class="ListBody">Assuming that the tree isn’t empty, if you cannot go to the left, return the right tree and the node’s key, and you’re done <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span>. Otherwise, recursively get and remove the minimum key from the left subtree <span class="listbody_CodeAnnotation" aria-label="annotation2">❷</span> and return the updated tree node and the found key <span class="listbody_CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="ListBody">How do you use it? The change in <span class="SANS_TheSansMonoCd_W5Regular_11">remove()</span> is small, affecting only one line: instead of first finding the minimum key and then removing it, make a single call to <span class="SANS_TheSansMonoCd_W5Regular_11">_removeMin()</span>:</p>&#13;
<pre class="pre" id="pre-423"><code>const remove = (tree, keyToRemove) =&gt; {&#13;
  if (isEmpty(tree)) {&#13;
    // nothing to do&#13;
  } else if (keyToRemove &lt; tree.key) {&#13;
    tree.left = remove(tree.left, keyToRemove);&#13;
  } else if (keyToRemove &gt; tree.key) {&#13;
    tree.right = remove(tree.right, keyToRemove);&#13;
  } else if (isEmpty(tree.left) &amp;&amp; isEmpty(tree.right)) {&#13;
    tree = null;&#13;
  } else if (isEmpty(tree.left)) {&#13;
    tree = tree.right;&#13;
  } else if (isEmpty(tree.right)) {&#13;
    tree = tree.left;&#13;
  } else {&#13;
    <b>[tree.right, tree.key] = _removeMin(tree.right);</b>&#13;
  }&#13;
  return tree;&#13;
};</code></pre>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_525" aria-label="525"/><b>12.18  AVL Worst</b></p>&#13;
<p class="ListPlainFirst">Suppose H<i>n</i> is the number of nodes in the worst possible AVL tree of height <i>n</i>. The first few such trees are the following:</p>&#13;
<figure class="IMG"><img class="img7" src="../images/pg525.jpg" alt=""/></figure>&#13;
<p class="ListBody">Build the next worst tree out of the previous two (plus a root), so H<sub><i>n</i></sub> equals H<sub><i>n–</i></sub><sub>1</sub> + H<sub><i>n–</i></sub><sub>2</sub> + 1: the sequence is 0, 1, 2, 4, 7, 12, 20, . . . , which is one less than the Fibonacci sequence 1, 2, 3, 5, 8, 13, 21, . . .</p>&#13;
<p class="ListHead"><b>12.19  Singles Only</b></p>&#13;
<p class="ListPlainFirst">Given the structure restrictions of AVL trees, only a leaf can be a single child. Since every single child has one parent and there may be more (not single) nodes in the tree, single children cannot be more than 50 percent of all nodes.</p>&#13;
<p class="ListHead"><b>12.20  Why One?</b></p>&#13;
<p class="ListPlainFirst">If the subtrees have sizes <i>p</i> and <i>q</i>, the tree’s size is <i>p</i> + <i>q</i> + 1, so the fractions are (<i>p</i> + 1) / (<i>p</i> + <i>q</i> + 2) and (<i>q</i> + 1) / (<i>p</i> + <i>q</i> + 2), and adding the numerators together produces exactly (<i>p</i> + <i>q</i> + 2), which is the denominator.</p>&#13;
<p class="ListHead"><b>12.21  Easier Randomizing?</b></p>&#13;
<p class="ListPlainFirst">The developer is correct in that an ordered sequence of keys would become disordered, but a disordered sequence of keys would also exist that would become ordered after hashing, so while solving the problem of ordered additions, this technique wouldn’t completely solve the worst-case problem.</p>&#13;
<p class="ListHead"><b>12.22  Why Not Decrement?</b></p>&#13;
<p class="ListPlainFirst">If the key you want to delete isn’t in the tree, you’d still (wrongly) decrement the node size.</p>&#13;
<p class="ListHead"><b>12.23  Bad Splay?</b></p>&#13;
<p class="ListPlainFirst">If you only add keys, you’ll get the same linear structure as for common binary search trees. However, after a few removals, the height of the tree is considerably lowered (and the tree becomes more “bushy”), while for common binary search trees, the shape would still be linear.</p>&#13;
<p class="ListHead"><b>12.24  What Left Subtree?</b></p>&#13;
<p class="ListPlainFirst">It should be <span class="SANS_TheSansMonoCd_W5Regular_11">null</span>. The minimum key in a tree has no left subtree; otherwise, it wouldn’t be the minimum.</p>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_526" aria-label="526"/><b>12.25  Code Transformation</b></p>&#13;
<p class="ListPlainFirst">When you splay the tree with reference to a key, you end with a tree that has at its root the closest value to the given key, so if the key is <span class="SANS_TheSansMonoCd_W5Regular_11">-Infinity</span> (assuming keys are numeric; an empty string would do for alphabetic keys), you can deduce that <span class="SANS_TheSansMonoCd_W5Regular_11">_splay(tree, -Infinity)</span> produces the same result as <span class="SANS_TheSansMonoCd_W5Regular_11">_splayMinimum(tree)</span>.</p>&#13;
<p class="ListBody">But you can go further. Take the <span class="SANS_TheSansMonoCd_W5Regular_11">_splay()</span> code and assume <span class="SANS_TheSansMonoCd_W5Regular_11">keyToUp</span> is <span class="SANS_TheSansMonoCd_W5Regular_11">-Infinity</span>, a value that cannot be in the tree and that is smaller than all current keys. The highlighted parts in the code that follows can then be omitted, either because the result is already known or because it’s unreachable code:</p>&#13;
<pre class="pre" id="pre-424"><code><span class="listcodeannotated_CodeAnnotation" aria-label="annotation1">❶</span><span class="SANS_TheSansMonoCd_W5Regular_11"> const _splay = (tree</span><b>, keyToUp</b><span class="SANS_TheSansMonoCd_W5Regular_11">) =&gt; {</span>&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation2">❷</span> if (isEmpty(tree)<b> || keyToUp === tree.key</b>) {&#13;
    return tree;&#13;
  } else {&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation3">❸</span> const side = <b>keyToUp &lt; tree.key ?</b> "left" <b>: "right"</b>;&#13;
    if (isEmpty(tree[side])) {&#13;
     return tree;&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation4">❹</span><b>} else if (keyToUp === tree[side].key) {</b>&#13;
<b>     return _rotate(tree, side);</b>&#13;
   } else {&#13;
<b>   </b><span class="listcode_CodeAnnotation" aria-label="annotation5">❺</span><b> if (keyToUp &lt;= tree[side].key === keyToUp &lt;= tree.key) {</b>&#13;
     <span class="listcode_CodeAnnotation" aria-label="annotation6">❻</span> tree[side][side] = _splay(tree[side][side]<b>, keyToUp</b>);&#13;
       tree = _rotate(tree, side);&#13;
<b>   </b><span class="listcode_CodeAnnotation" aria-label="annotation7">❼</span><b>} else {</b>&#13;
<b>      const other = side === "left" ? "right" : "left";</b>&#13;
<b>      tree[side][other] = _splay(tree[side][other], keyToUp);</b>&#13;
<b>      if (!isEmpty(tree[side][other])) {</b>&#13;
<b>        tree[side] = _rotate(tree[side], other);</b>&#13;
<b>      }</b>&#13;
<b>    }</b>&#13;
    return isEmpty(tree[side]) ? tree : _rotate(tree, side);&#13;
   }&#13;
 }&#13;
};</code></pre>&#13;
<p class="ListBody">The <span class="SANS_TheSansMonoCd_W5Regular_11">keyToUp</span> parameter isn’t needed <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span> <span class="listbody_CodeAnnotation" aria-label="annotation6">❻</span>, since you are assuming its value. Tests for equality will always fail <span class="listbody_CodeAnnotation" aria-label="annotation2">❷</span> <span class="listbody_CodeAnnotation" aria-label="annotation4">❹</span>. Since <span class="SANS_TheSansMonoCd_W5Regular_11">keyToUp</span> is smaller than any key, the <span class="SANS_TheSansMonoCd_W5Regular_11">side</span> variable will always end with <span class="SANS_TheSansMonoCd_W5Regular_11">"left"</span> <span class="listbody_CodeAnnotation" aria-label="annotation3">❸</span>, and the test at <span class="listbody_CodeAnnotation" aria-label="annotation5">❺</span> will always succeed, making some code <span class="listbody_CodeAnnotation" aria-label="annotation7">❼</span> unreachable.</p>&#13;
<p class="ListBody">After these simplifications, renaming <span class="SANS_TheSansMonoCd_W5Regular_11">_splay</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">_splayMin</span> and changing <span class="SANS_TheSansMonoCd_W5Regular_11">tree[side]</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">tree.left</span> leaves the following code:</p>&#13;
<pre class="pre" id="pre-425"><code>const _splayMin = (tree) =&gt; {&#13;
  if (isEmpty(tree)) {&#13;
    return tree;&#13;
  } else {&#13;
    if (isEmpty(tree.left)) {&#13;
      return tree;&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_527" aria-label="527"/>    } else {&#13;
      tree.left.left = _splayMin(tree.left.left);&#13;
      tree = _rotate(tree, "left");&#13;
      return isEmpty(tree.left) ? tree : _rotate(tree, "left");&#13;
    }&#13;
  }&#13;
};</code></pre>&#13;
<p class="ListBody">Transforming this code to <span class="SANS_TheSansMonoCd_W5Regular_11">_splayMinimum()</span> is easy now: join the two <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statements into one by combining their tests, and you’re done.</p>&#13;
<p class="ListHead"><b>12.26  Full Rebalance</b></p>&#13;
<p class="ListPlainFirst">The idea is to get all the keys using the technique suggested in question 12.13 and produce a well-balanced tree, splitting the array in the middle. The key there will be the root for the balanced tree, the keys to its left will be used to produce the left subtree, and likewise for the keys to its right:</p>&#13;
<pre class="pre" id="pre-426"><code>const {&#13;
  newBinaryTree,&#13;
  newNode,&#13;
  inOrder&#13;
} = require("../binary_search_tree.js");&#13;
&#13;
<span class="listcodeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const _buildPerfect = (keys) =&gt; {&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation2">❷</span> if (keys.length === 0) {&#13;
    return newBinaryTree();&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation3">❸</span>} else {&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation4">❹</span> const m = Math.floor(keys.length / 2);&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation5">❺</span> return newNode(&#13;
      keys[m],&#13;
      _buildPerfect(keys.slice(0, m)),&#13;
      _buildPerfect(keys.slice(m + 1))&#13;
    );&#13;
  }&#13;
};&#13;
&#13;
<span class="listcodeannotated_CodeAnnotation" aria-label="annotation6">❻</span> const restructure = (tree) =&gt; {&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation7">❼</span> const keys = [];&#13;
  inOrder(tree, (x) =&gt; keys.push(x));&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation8">❽</span> return _buildPerfect(keys);&#13;
};</code></pre>&#13;
<p class="ListBody">Start with the rebalancing code, <span class="SANS_TheSansMonoCd_W5Regular_11">_buildPerfect()</span> <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span>. Given an array of keys, if the array is empty <span class="listbody_CodeAnnotation" aria-label="annotation2">❷</span>, a null tree is returned. Otherwise <span class="listbody_CodeAnnotation" aria-label="annotation3">❸</span>, find the array’s middle point <span class="listbody_CodeAnnotation" aria-label="annotation4">❹</span> and return a node as described earlier <span class="listbody_CodeAnnotation" aria-label="annotation5">❺</span>; use recursion to build its balanced subtrees. The <span class="SANS_TheSansMonoCd_W5Regular_11">restructure()</span> function <span class="listbody_CodeAnnotation" aria-label="annotation6">❻</span> is then quite short: generate an ordered list of keys using <span class="SANS_TheSansMonoCd_W5Regular_11">inOrder()</span> <span class="listbody_CodeAnnotation" aria-label="annotation7">❼</span> and pass it to the <span class="SANS_TheSansMonoCd_W5Regular_11">_buildPerfect()</span> function to produce the final output <span class="listbody_CodeAnnotation" aria-label="annotation8">❽</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_528" aria-label="528"/>&#13;
<h2 class="H1" id="sec12"><span id="h1-113"/><span class="SANS_Futura_Std_Bold_B_11">Chapter 13</span></h2>&#13;
<p class="ListHead"><b>13.1  Missing Test?</b></p>&#13;
<p class="ListPlainFirst">No need; <span class="SANS_TheSansMonoCd_W5Regular_11">addChild()</span> already does it.</p>&#13;
<p class="ListHead"><b>13.2  Traversing General Trees</b></p>&#13;
<p class="ListPlainFirst">Implementation is not complex. If the tree is represented using arrays of children, preorder traversal for a nonempty tree entails visiting the root and then sequentially traversing each child. For a tree represented in a left-child, right-sibling style, the logic starts by visiting the root and then, starting at the first child, traversing it and moving to the next sibling until no more siblings are left. In both cases, postorder traversal first starts with the children and visits the root only after that.</p>&#13;
<p class="ListHead"><b>13.3  Nonrecursive Visiting</b></p>&#13;
<p class="ListPlainFirst">The solution is quite similar to the breadth-first queue version:</p>&#13;
<pre class="pre" id="pre-427"><code>depthFirstNonRecursive(visit = (x) =&gt; console.log(x)) {&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation1">❶</span> if (!isEmptyTree(tree)) {&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation2">❷</span> const s = new Stack();&#13;
    s = push(s, tree);&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation3">❸</span> while (isEmptyStack(s)) {**DZ missing ! operator**&#13;
      let t;&#13;
    <span class="listcode_CodeAnnotation" aria-label="annotation4">❹</span> [s, t] = s.pop();&#13;
      visit(t.key);&#13;
    <span class="listcode_CodeAnnotation" aria-label="annotation5">❺</span> [...t.childNodes].reverse().forEach((v) =&gt; {s = push(s, v);});&#13;
    }&#13;
  }&#13;
}</code></pre>&#13;
<p class="ListBody">As in other traversals, if the tree is empty, you don’t do anything <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span>. Otherwise, you create a stack and push the tree’s root into it <span class="listbody_CodeAnnotation" aria-label="annotation2">❷</span>. Then, you do a loop. While the stack isn’t empty <span class="listbody_CodeAnnotation" aria-label="annotation3">❸</span>, pop the stack top <span class="listbody_CodeAnnotation" aria-label="annotation4">❹</span> and visit it, and then finish with this tricky detail: you must push all the children in <i>reverse</i> order (the rightmost first, the leftmost last), so the first child is visited first <span class="listbody_CodeAnnotation" aria-label="annotation5">❺</span>. Be careful using <span class="SANS_TheSansMonoCd_W5Regular_11">reverse()</span> because it modifies the array, so build a copy using destructuring.</p>&#13;
<p class="ListHead"><b>13.4  Tree Equality</b></p>&#13;
<p class="ListBody">You could do some recursive logic to compare trees, but a simpler solution exists: use <span class="SANS_TheSansMonoCd_W5Regular_11">JSON.stringify()</span> to produce string versions of both trees and compare them.</p>&#13;
<p class="ListHead"><b>13.5  Measuring Trees</b></p>&#13;
<p class="ListPlainFirst">The code is similar to what was used for binary trees in <span class="listplain_Xref">Chapter 12</span>:</p>&#13;
<pre class="pre" id="pre-428"><code>const {Tree} = require("../tree.class.js");&#13;
&#13;
class TreeWithMeasuring extends Tree {&#13;
  calcSize() {&#13;
    return this.isEmpty()&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_529" aria-label="529"/>    <span class="listcode_CodeAnnotation" aria-label="annotation1">❶</span> ? 0&#13;
    <span class="listcode_CodeAnnotation" aria-label="annotation2">❷</span> : 1 + this._children.reduce((a, v) =&gt; a + v.calcSize(), 0);&#13;
  }&#13;
&#13;
  calcHeight() {&#13;
    if (this.isEmpty()) {&#13;
    <span class="listcode_CodeAnnotation" aria-label="annotation3">❸</span> return 0;&#13;
    } else if (this._children.length === 0) {&#13;
    <span class="listcode_CodeAnnotation" aria-label="annotation4">❹</span> return 1;&#13;
    } else {&#13;
    <span class="listcode_CodeAnnotation" aria-label="annotation5">❺</span> return 1 + Math.max(...this._children.map((v) =&gt; v.calcHeight()));&#13;
    }&#13;
  }&#13;
}</code></pre>&#13;
<p class="ListBody">An empty tree has size 0 <span class="CodeAnnotation" aria-label="annotation1">❶</span>; otherwise, its size is 1 (for the root itself) plus the sum of the sizes of all its subtrees <span class="CodeAnnotation" aria-label="annotation2">❷</span>, which you can calculate using <span class="SANS_TheSansMonoCd_W5Regular_11">.reduce()</span>. Then, for height, an empty tree has height 0 <span class="CodeAnnotation" aria-label="annotation3">❸</span>, a leaf has height 1 <span class="CodeAnnotation" aria-label="annotation4">❹</span>, and other trees have height 1 (for the root) plus the tallest height of any of its subtrees <span class="CodeAnnotation" aria-label="annotation5">❺</span>.</p>&#13;
<p class="ListHead"><b>13.6  Sharing More</b></p>&#13;
<p class="ListPlainFirst">In the implementation, since we borrowed only a single key from a sibling, we made do with simple code. To share half and half, you should set up an array with all the keys from the left sibling, plus the key of the parent, plus all the keys in the right sibling, and divide it. The key at the middle position will go into the parent, all the keys to its left to the left sibling, and all the keys to its right to the right sibling—and a similar procedure will apply to the pointers in the nodes.</p>&#13;
<p class="ListHead"><b>13.7  Faster Node Searching</b></p>&#13;
<p class="ListPlainFirst">The binary search algorithm from <span class="listplain_Xref">Chapter 9</span> ends, upon a search failure, with the left index pointing at the link you should follow; check this out. Here’s the code:</p>&#13;
<pre class="pre" id="pre-429"><code>const _findIndex = (tree, key) =&gt; {&#13;
  let l = 0;&#13;
  let r = tree.keys.length - 1;&#13;
&#13;
  while (l &lt;= r) {&#13;
    const m = Math.floor((l + r) / 2);&#13;
    if (tree.keys[m] === key) {&#13;
      return m;&#13;
    } else if (tree.keys[m] &gt; key) {&#13;
      r = m - 1;&#13;
    } else {&#13;
      l = m + 1;&#13;
    }&#13;
  }&#13;
<b>  return l;</b>&#13;
};</code></pre>&#13;
<p class="ListBody"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_530" aria-label="530"/>The algorithm is the standard one you already saw; the difference is that if the search fails, it returns the left pointer. As to the effect on the B-tree performance, the search in the node sped up by a constant factor (if the order of the B-tree is <i>p</i>, instead of <i>p</i> tests, we do log <i>p</i> tests), but the general order of algorithms remains <i>O</i>(log <i>n</i>).</p>&#13;
<p class="ListHead"><b>13.8  Lowest Order</b></p>&#13;
<p class="ListPlainFirst">Nodes other than the root in a B-tree of order 2 should have one key and thus two children, so that implies a full binary tree since all leaves must be at the same level. So, yes, you already knew about B-trees of order 2!</p>&#13;
<p class="ListHead"><b>13.9  Many Orders of Trees</b></p>&#13;
<p class="ListPlainFirst">By default, modules are singletons, which means that the code is imported only once, so all trees that you create would share the same <span class="SANS_TheSansMonoCd_W5Regular_11">ORDER</span> variable. If you want to have different variables, instead of exporting an object with many properties (in <span class="SANS_TheSansMonoCd_W5Regular_11">module.exports</span>), you need to export a function that, when invoked, returns the desired object. You can see some examples of this transformation in Iain Collins’s “How (Not) to Create a Singleton in Node.js” at <i><a href="https://medium.com/@iaincollins/how-not-to-create-a-singleton-in-node-js-bd7fde5361f5">https://medium.com/@iaincollins/how-not-to-create-a-singleton-in-node-js-bd7fde5361f5</a></i>.</p>&#13;
<p class="ListHead"><b>13.10  Safe to Delete?</b></p>&#13;
<p class="ListPlainFirst">When you get to delete a node with no right child, the root was red, implying it would have no left child. If the root had been black (the other possibility, considering the invariant), its left child would have been red, and you would have rotated <i>it</i> right, so it wouldn’t then have an empty right child.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h2 class="H1" id="sec13"><span id="h1-114"/><span class="SANS_Futura_Std_Bold_B_11">Chapter 14</span></h2>&#13;
<p class="ListHead"><b>14.1  Is It a Heap?</b></p>&#13;
<p class="ListPlainFirst">Simply loop through all the elements except the root and check that each is not greater than its parent. A first implementation could be:</p>&#13;
<pre class="pre" id="pre-430"><code>function isHeap1(v) {&#13;
  for (let i = 1; i &lt; v.length; i++) {&#13;
    if (v[i] &gt; v[Math.floor((i - 1) / 2)]) {&#13;
      return false;&#13;
    }&#13;
  }&#13;
  return true;&#13;
}</code></pre>&#13;
<p class="ListBody">You can also use <span class="SANS_TheSansMonoCd_W5Regular_11">.every()</span> to shorten the code and make it more declarative:</p>&#13;
<pre class="pre" id="pre-431"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_531" aria-label="531"/>function isHeap2(heap) {&#13;
  return heap.every(    (v, i) =&gt; i === 0 || v &lt;= heap[Math.floor((i - 1) / 2)],&#13;
  );</code></pre>&#13;
<p class="ListHead"><b>14.2  Making Do with Queues</b></p>&#13;
<p class="ListPlainFirst">If you assign monotonically ascending values to the elements you enter in a priority queue, it will behave like a stack in a last-in, first-out (LIFO) way. Similarly, if you assign monotonically descending values to elements, the priority queue will emulate a common queue.</p>&#13;
<p class="ListHead"><b>14.3  Max to Min</b></p>&#13;
<p class="ListPlainFirst">This is a trick question! Using Floyd’s enhanced heap-building code, you can transform <i>any</i> array into a min heap in linear time, so you obviously can convert a max heap into a min heap in this time.</p>&#13;
<p class="ListHead"><b>14.4  Max or Min</b></p>&#13;
<p class="ListPlainFirst">Only three code changes are needed: one in the <span class="SANS_TheSansMonoCd_W5Regular_11">_bubbleUp()</span> function and two in the <span class="SANS_TheSansMonoCd_W5Regular_11">_sinkDown()</span> function. Invert the current comparisons from <span class="SANS_TheSansMonoCd_W5Regular_11">heap[a] &gt; heap[b]</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">heap[a] &lt; heap[b]</span> and you’re done.</p>&#13;
<p class="ListHead"><b>14.5  Merge Away!</b></p>&#13;
<p class="ListPlainFirst">The needed algorithm works as follows. Create a min heap whose nodes will be nodes from the lists. Initialize the heap by taking the first element of each list. Initialize an empty output list. Repeatedly, while the heap isn’t empty, pick the node corresponding to the root of the heap and remove it from the heap. Add the selected node to the output list. If the selected node had a next node, add it to the heap.</p>&#13;
<p class="ListBody">Assuming the nodes have <span class="SANS_TheSansMonoCd_W5Regular_11">key</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">next</span> fields, the code (based on the heap developed in this chapter, but inverting some comparisons to produce a min heap as in question 14.4) could be as follows:</p>&#13;
<pre class="pre" id="pre-432"><code>function merge_away(lists) {&#13;
  const heap = [];&#13;
&#13;
  const add = (node) =&gt; {&#13;
    const _bubbleUp = (i) =&gt; {&#13;
      // Bubble up heap[i] comparing by heap[i].key&#13;
      // (you'll have to modify the bubbling code we&#13;
      // saw a bit for this).&#13;
    };&#13;
&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation1">❶</span> if (node) {&#13;
      heap.push(node);&#13;
      _bubbleUp(heap.length - 1);&#13;
    }&#13;
&#13;
    const remove = () =&gt; {&#13;
      const _sinkDown = (i, h) =&gt; {&#13;
        // sink down heap[i] comparing by heap[i].key&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_532" aria-label="532"/>      };&#13;
    };&#13;
&#13;
    const node = heap[0];&#13;
    heap[0] = heap[heap.length - 1];&#13;
    heap.pop();&#13;
    _sinkDown(0, heap.length);&#13;
    return node;&#13;
  };&#13;
&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation2">❷</span> lists.forEach((list) =&gt; add(list));&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation3">❸</span> const first = {next: null};&#13;
  let last = first;&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation4">❹</span> while (heap.length &gt; 0) {&#13;
    const node = remove();&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation5">❺</span> add(node.next);&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation6">❻</span> last.next = node;&#13;
    last = node;&#13;
    node.next = null;&#13;
  }&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation7">❼</span> return first.next;&#13;
}</code></pre>&#13;
<p class="ListBody">The <span class="SANS_TheSansMonoCd_W5Regular_11">add()</span> method pushes a node into the stack (unless it’s null) and bubbles it up <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span>. The complete logic requires setting up the heap with the first element of each list <span class="listbody_CodeAnnotation" aria-label="annotation2">❷</span> to then do the merging. Adding an empty initial value for the output list <span class="listbody_CodeAnnotation" aria-label="annotation3">❸</span> simplifies the code a bit; remember to skip this extra node when returning the merged list <span class="listbody_CodeAnnotation" aria-label="annotation7">❼</span>. While there still are any nodes in the heap <span class="listbody_CodeAnnotation" aria-label="annotation4">❹</span> (meaning there still is some merging to do), remove the top element, add the next node of the corresponding list into the heap <span class="listbody_CodeAnnotation" aria-label="annotation5">❺</span>, and add the removed element at the end of the list <span class="listbody_CodeAnnotation" aria-label="annotation6">❻</span>; the dummy node avoided the need to test for an empty list. The final step just returns the list, without the extra initial node <span class="listbody_CodeAnnotation" aria-label="annotation7">❼</span>.</p>&#13;
<p class="ListBody">You can test this code easily. The following outputs a few Fibonacci numbers starting at 1:</p>&#13;
<pre class="pre" id="pre-433"><code>const list1 = {&#13;
  key: 2,&#13;
  next: {key: 3, next: {key: 8, next: null}},&#13;
};&#13;
&#13;
const list2 = {&#13;
  key: 1,&#13;
  next: {key: 13, next: {key: 55, next: null}},&#13;
};&#13;
&#13;
const list3 = null;&#13;
&#13;
const list4 = {key: 21, next: null};&#13;
&#13;
const list5 = {key: 5, next: {key: 34, next: null}};&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_533" aria-label="533"/>const merged = merge_away([list1, list2, list3, list4, list5]);&#13;
&#13;
let p = merged;&#13;
while (p) {&#13;
  console.log(p.key);&#13;
  p = p.next;&#13;
}</code></pre>&#13;
<p class="ListHead"><b>14.6  Searching a Heap</b></p>&#13;
<p class="ListPlainFirst">You could write a recursive function, but because the array is basically unordered, given any node in the heap, you’d have to search in both its left and right subtrees, so you will eventually have to look through the whole tree in an <i>O</i>(<i>n</i>) procedure. It would be better simply to use <span class="SANS_TheSansMonoCd_W5Regular_11">heap.find()</span>.</p>&#13;
<p class="ListHead"><b>14.7  Removing from the Middle of a Heap</b></p>&#13;
<p class="ListPlainFirst">Changing a key in the heap is a bit similar to removing a key:</p>&#13;
<pre class="pre" id="pre-434"><code>const removeMiddle = (heap, k) =&gt; {&#13;
<span class="listcode_CodeAnnotation1" aria-label="annotation1">❶</span> if (isEmpty(heap)) {&#13;
    throw new Error("Empty heap; cannot remove");&#13;
<span class="listcode_CodeAnnotation1" aria-label="annotation2">❷</span>} else if (k &lt; 0 || k &gt;= heap.length) {&#13;
    throw new Error("Not valid argument for removeMiddle");&#13;
  } else {&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation3">❸</span> [heap[k], heap[heap.length - 1]] = [heap[heap.length - 1], heap[k]];&#13;
    heap.pop();&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation4">❹</span> _bubbleUp(heap, k);&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation5">❺</span> _sinkDown(heap, k, heap.length);&#13;
  }&#13;
  return heap;&#13;
};</code></pre>&#13;
<p class="ListBody">After a couple of checks to see whether the removal can be done <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span> <span class="listbody_CodeAnnotation" aria-label="annotation2">❷</span>, moving the last value of the heap to the place of the removed value <span class="listbody_CodeAnnotation" aria-label="annotation3">❸</span> restores the structure property. The problem is that the value now at index <span class="SANS_TheSansMonoCd_W5Regular_11">k</span> may not be placed correctly, violating the heap property. The simplest way to ensure that this is satisfied is to apply <span class="SANS_TheSansMonoCd_W5Regular_11">_bubbleUp()</span> <span class="listbody_CodeAnnotation" aria-label="annotation4">❹</span> first and then <span class="SANS_TheSansMonoCd_W5Regular_11">sinkDown()</span> <span class="listbody_CodeAnnotation" aria-label="annotation5">❺</span>. At most, only one of those functions will do anything, and you’ll end up with a fully compliant heap.</p>&#13;
<p class="ListHead"><b>14.8  Faster Build</b></p>&#13;
<p class="ListPlainFirst">The changes to the <span class="SANS_TheSansMonoCd_W5Regular_11">newHeap()</span> function are as follows:</p>&#13;
<pre class="pre" id="pre-435"><code>const newHeap = (values = []) =&gt; {&#13;
  const newH = [];&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation1">❶</span> values.forEach((v) =&gt; newH.push(v));&#13;
  for (let i = Math.floor((newH.length - 1) / 2); i &gt;= 0; i--) {&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation2">❷</span> _sinkDown(newH, i, newH.length);&#13;
  }&#13;
  return newH;&#13;
};</code></pre>&#13;
<p class="ListPlain"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_534" aria-label="534"/>This starts with an empty array and copies the values (if any) into it <span class="listplain_CodeAnnotation" aria-label="annotation1">❶</span>; then it uses <span class="SANS_TheSansMonoCd_W5Regular_11">_sinkDown()</span> to build the heap <span class="listplain_CodeAnnotation" aria-label="annotation2">❷</span> that is returned.</p>&#13;
<p class="ListHead"><b>14.9  Another Way of Looping</b></p>&#13;
<p class="ListPlainFirst">You could use <span class="SANS_TheSansMonoCd_W5Regular_11">forEach()</span> in the following way (only the <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> parameter matters here):</p>&#13;
<pre class="pre" id="pre-436"><code>v.forEach((_, i) =&gt; _bubbleUp(v, i));</code></pre>&#13;
<p class="ListHead"><b>14.10  Extra Looping?</b></p>&#13;
<p class="ListPlainFirst">It would work the same way (it would just be a tad slower), because the <span class="SANS_TheSansMonoCd_W5Regular_11">_sinkDown()</span> procedure won’t do anything for elements with no children.</p>&#13;
<p class="ListHead"><b>14.11  Maximum Equality</b></p>&#13;
<p class="ListPlainFirst">It would be <i>O</i>(<i>n</i>). Neither <span class="SANS_TheSansMonoCd_W5Regular_11">_sinkDown()</span> nor <span class="SANS_TheSansMonoCd_W5Regular_11">_bubbleUp()</span> would do any work, so they are <i>O</i>(1), and there are <i>n</i> calls to those functions.</p>&#13;
<p class="ListHead"><b>14.12  Unstable Heap?</b></p>&#13;
<p class="ListPlainFirst">A simple array works for both versions of the heapsort code: <span class="SANS_TheSansMonoCd_W5Regular_11">[1, 1]</span>. The first 1 will end at the last place of the sorted array.</p>&#13;
<p class="ListHead"><b>14.13  Trimmed Selection</b></p>&#13;
<p class="ListPlainFirst">If you find a value at level <i>i</i> of a heap, you know for sure that there are at least (<i>i</i> – 1) values greater than it, because of the heap property. Thus, if you are looking for the <i>k</i> greatest values of a heap, they cannot be at levels (<i>k</i> + 1) or beyond. If the heap has more than <i>k</i> levels, you can discard all beyond the <i>k</i>th level, and the selection process will be a bit faster. A heap with <i>k</i> complete levels has 2<i><sup>k</sup></i> – 1 nodes, so if the heap has more nodes than that, you can shorten it:</p>&#13;
<pre class="pre" id="pre-437"><code>function selection(k, values) {&#13;
  const heap = [];&#13;
&#13;
  const _sinkDown = // ...omitted here...&#13;
&#13;
  // Build heap out of values.&#13;
  values.forEach((v) =&gt; heap.push(v));&#13;
  for (let i = Math.floor((heap.length - 1) / 2); i &gt;= 0; i--) {&#13;
    _sinkDown(i, heap.length);&#13;
  }&#13;
&#13;
  // Trim the heap, if possible.&#13;
<b>  const maxPlace = 2 ** k - 1;</b>&#13;
<b>  if (heap.length &gt; maxPlace) {</b>&#13;
<b>  </b><span class="listcode_CodeAnnotation" aria-label="annotation1">❶</span><b> heap.length = maxPlace;</b>&#13;
<b>  }</b>&#13;
&#13;
  // Do the selection.&#13;
  for (let i = heap.length - 1; i &gt;= heap.length - k; i--) {&#13;
    [heap[i], heap[0]] = [heap[0], heap[i]];&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_535" aria-label="535"/>    _sinkDown(0, i);&#13;
  }&#13;
&#13;
  return heap.slice(heap.length - k);&#13;
}</code></pre>&#13;
<p class="ListBody">You could use <span class="SANS_TheSansMonoCd_W5Regular_11">.slice()</span> to shorten the <span class="SANS_TheSansMonoCd_W5Regular_11">heap</span> array, but JavaScript allows you to modify its <span class="SANS_TheSansMonoCd_W5Regular_11">.length</span> property directly <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span>.</p>&#13;
<p class="ListHead"><b>14.14  Is It a Treap?</b></p>&#13;
<p class="ListPlainFirst">You can produce an interesting recursive solution with functional aspects. What is a valid treap? If it’s empty, it’s obviously okay; otherwise, its children should be treaps too:</p>&#13;
<pre class="pre" id="pre-438"><code>function isTreap(tr, valid = () =&gt; true) {&#13;
  return (&#13;
    tr === null ||&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation1">❶</span> (valid(tr) &amp;&amp;&#13;
    <span class="listcode_CodeAnnotation" aria-label="annotation2">❷</span> isTreap(&#13;
        tr.left,&#13;
        (t) =&gt; t.key &lt;= tr.key &amp;&amp; t.priority &lt;= tr.priority,&#13;
      ) &amp;&amp;&#13;
    <span class="listcode_CodeAnnotation" aria-label="annotation3">❸</span> isTreap(&#13;
        tr.right,&#13;
        (t) =&gt; t.key &gt;= tr.key &amp;&amp; t.priority &lt;= tr.priority,&#13;
      ))&#13;
  );&#13;
}</code></pre>&#13;
<p class="ListBody">This checks a basic condition having to do with its key and priority compared to those of its parent <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span>, but notice that the first time, for the root, a trivial validation is provided because obviously the root has no parent with which to compare! Then, this recursively checks that both children are also treaps, each fulfilling a specific different new condition: the left subtree should have smaller keys and priorities than its parent <span class="listbody_CodeAnnotation" aria-label="annotation2">❷</span>, and the right subtree should have greater keys but lower priorities <span class="listbody_CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="ListHead"><b>14.15  Treap Splitting</b></p>&#13;
<p class="ListPlainFirst">Add the limit value to the treap with an <span class="SANS_TheSansMonoCd_W5Regular_11">Infinity</span> priority: because of the high priority, this limit will become the new root of the treap, and because of the binary search tree structure, all keys smaller than the limit will be in the root’s left subtree and greater keys will be in its right subtree, providing the desired partitioning.</p>&#13;
<p class="ListHead"><b>14.16  Rejoining Two Treaps</b></p>&#13;
<p class="ListPlainFirst">To create a single treap out of two separate ones, create a dummy node with any random key and priority and then assign the first treap as its left subtree, assign the second treap as its right subtree, and finish by deleting the root dummy node.</p>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_536" aria-label="536"/><b>14.17  Removing from a Treap</b></p>&#13;
<p class="ListPlainFirst">This would work the same way, but it would be just a bit slower, because it would do a series of <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statements before going down <span class="SANS_TheSansMonoCd_W5Regular_11">tree[other]</span>.</p>&#13;
<p class="ListHead"><b>14.18  Trees as Heaps</b></p>&#13;
<p class="ListPlainFirst">Using a balanced binary search tree would ensure logarithmic performance for all three operations, as you’ve seen earlier. However, you can do better by including a separate attribute for the maximum seen so far. You’d update it in <i>O</i>(1) time after each addition by simply comparing the current maximum to the new key, and when removing the top, you could find the new maximum also in logarithmic time, so <span class="SANS_TheSansMonoCd_W5Regular_11">top()</span> itself would become <i>O</i>(1).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h2 class="H1" id="sec14"><span id="h1-115"/><span class="SANS_Futura_Std_Bold_B_11">Chapter 15</span></h2>&#13;
<p class="ListHead"><b>15.1  Intuitive but Worse</b></p>&#13;
<p class="ListPlainFirst">That would be <i>O</i>(<i>m</i> log <i>n</i>), since there would be <i>m</i> insertions, each <i>O</i>(log <i>n</i>).</p>&#13;
<p class="ListHead"><b>15.2  Sequential Cases</b></p>&#13;
<p class="ListPlainFirst">When inserting keys in descending order (the highest first), you get a badly shaped heap, but each <span class="SANS_TheSansMonoCd_W5Regular_11">add()</span> takes constant time. Can you see why? And if you insert them in ascending order, you can achieve a full binary tree; see both cases shown next for keys from 1 to 7:</p>&#13;
<figure class="IMG"><img class="img5" src="../images/pg536.jpg" alt=""/></figure>&#13;
<p class="ListHead"><b>15.3  No Recursion Needed</b></p>&#13;
<p class="ListPlainFirst">You could just write the merge as follows; the bold lines show the changes:</p>&#13;
<pre class="pre" id="pre-439"><code>const merge = (heap1, heap2) =&gt; {&#13;
  if (isEmpty(heap2)) {&#13;
    return heap1;&#13;
  } else if (isEmpty(heap1)) {&#13;
    return heap2;&#13;
  } else if (goesHigher(heap1.key, heap2.key)) {&#13;
    [heap1.left, heap1.right] = [merge(heap2, heap1.right), heap1.left];&#13;
    return heap1;&#13;
  } else {&#13;
<b>    [heap2.left, heap2.right] = [merge(heap1, heap2.right), heap2.left];</b>&#13;
<b>    return heap2;</b>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_537" aria-label="537"/>  }&#13;
};</code></pre>&#13;
<p class="ListContinued">The new lines are the same as in the previous case (when the first heap has the greatest key), except they exchange <span class="SANS_TheSansMonoCd_W5Regular_11">heap1</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">heap2</span> throughout.</p>&#13;
<p class="ListHead"><b>15.4  Change Needed</b></p>&#13;
<p class="ListPlainFirst">The <span class="SANS_TheSansMonoCd_W5Regular_11">change()</span> method for a skew heap requires being able to remove a key and, after changing it, inserting it again. Given a reference to the node with the key, removing it requires a link to the parent (from which you must disconnect it), so an <span class="SANS_TheSansMonoCd_W5Regular_11">up</span> pointer to a node’s parent should be added. You could alternatively use <span class="SANS_TheSansMonoCd_W5Regular_11">bubbleUp()</span>, but it would also need a link to the parent.</p>&#13;
<p class="ListHead"><b>15.5  Just Adding</b></p>&#13;
<p class="ListPlainFirst">You initially have just a single tree with eight nodes. The following table shows which heaps you’d have at each stage and how many merges are needed after adding a value; cell items in bold represent merges. For example, adding the 9th value requires no merges, but adding the 10th produces two heaps of size 1, so a merge is needed to replace them with a heap of size 2. Similarly, adding the 11th value requires no merges, but the 12th needs two: first to merge two heaps of size 1 and then to merge two heaps of size 2.</p>&#13;
<table class="table1">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Values</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">1</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">2</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">4</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">8</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">16</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">8</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">9</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">10</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Heavy_11">0</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">11</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">12</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Heavy_11">0</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Heavy_11">0</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">13</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">14</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Heavy_11">0</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">15</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">16</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Heavy_11">0</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Heavy_11">0</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Heavy_11">0</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Heavy_11">0</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="ListBody">You had an initial heap with <i>n</i> = 8 values; after adding the other eight values, the total number of merges (in bold) was exactly eight, so on average, each addition required one merge. This is not a formal proof, of course, but the result can be proven mathematically for all binomial heaps.</p>&#13;
<p class="ListHead"><b>15.6  Faster Binomial Top</b></p>&#13;
<p class="ListPlainFirst">You can add a variable like <span class="SANS_TheSansMonoCd_W5Regular_11">_heapTop</span> in lazy binomial heaps to get the top value of the heap.</p>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_538" aria-label="538"/><b>15.7  Easier Bubbling Up?</b></p>&#13;
<p class="ListPlainFirst">The problem is you are working with an addressable heap, and if you change keys around, old references to nodes won’t be valid any longer and will point to different values.</p>&#13;
<p class="ListHead"><b>15.8  Searching a Heap</b></p>&#13;
<p class="ListPlainFirst">This algorithm is obviously <i>O</i>(<i>n</i>) and certainly <i>not</i> the kind of thing you do with heaps, but let’s do it anyway. The only problem is to notice when to stop traversing the circular list of siblings:</p>&#13;
<pre class="pre" id="pre-440"><code><span class="listcodeannotated_CodeAnnotation" aria-label="annotation1">❶</span><span class="SANS_TheSansMonoCd_W5Regular_11"> _findInTree(tree, keyToFind, stopT = null) {</span>&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation2">❷</span> let node = null;&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation3">❸</span> if (tree &amp;&amp; tree !== stopT) {&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation4">❹</span> if (tree.key === keyToFind) {&#13;
      node = tree;&#13;
    } else {&#13;
      node =&#13;
      <span class="listcode_CodeAnnotation" aria-label="annotation5">❺</span> this._findInTree(tree.down, keyToFind) ||&#13;
      <span class="listcode_CodeAnnotation" aria-label="annotation6">❻</span> this._findInTree(tree.right, keyToFind, stopT || tree);&#13;
    }&#13;
  }&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation7">❼</span> return node;&#13;
}</code></pre>&#13;
<p class="ListContinued">This is a depth-first traversal. The <span class="SANS_TheSansMonoCd_W5Regular_11">stopT</span> parameter remembers where you started in the list of siblings to avoid a loop <span class="listplain_CodeAnnotation" aria-label="annotation1">❶</span>. Use <span class="SANS_TheSansMonoCd_W5Regular_11">node</span> to store either a <span class="SANS_TheSansMonoCd_W5Regular_11">null</span> value (if you don’t find the key) or the found node otherwise <span class="listplain_CodeAnnotation" aria-label="annotation2">❷</span>. If the tree you’re looking at is neither null nor the stop point for the list <span class="listplain_CodeAnnotation" aria-label="annotation3">❸</span>, check whether you found the key you were looking for at the root <span class="listplain_CodeAnnotation" aria-label="annotation4">❹</span>; if so, save it to return it later <span class="listplain_CodeAnnotation" aria-label="annotation7">❼</span>. If the root didn’t match, search downward <span class="listplain_CodeAnnotation" aria-label="annotation5">❺</span>, and if that returns a null, search to the right, providing the starting point as the stop value <span class="listplain_CodeAnnotation" aria-label="annotation6">❻</span>. Using <span class="SANS_TheSansMonoCd_W5Regular_11">xxx || yyy</span> is typical of JavaScript; if the value of the <span class="SANS_TheSansMonoCd_W5Regular_11">xxx</span> expression isn’t “falsy,” it is returned; otherwise, the value of the <span class="SANS_TheSansMonoCd_W5Regular_11">yyy</span> expression is returned.</p>&#13;
<p class="ListHead"><b>15.9  Two in One</b></p>&#13;
<p class="ListPlainFirst">In <span class="SANS_TheSansMonoCd_W5Regular_11">_mergeA2B()</span>, you could write:</p>&#13;
<pre class="pre" id="pre-441"><code>if (high._down) {&#13;
  low.right = high.down;&#13;
  low.left = high.down.left;&#13;
  <b>high.down.left.right = high.down.left </b>= low;&#13;
}</code></pre>&#13;
<p class="ListContinued">In <span class="SANS_TheSansMonoCd_W5Regular_11">add()</span>, you could join two assignments:</p>&#13;
<pre class="pre" id="pre-442"><code><b>newTree.left = newTree.right</b> = newTree;</code></pre>&#13;
<p class="ListContinued"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_539" aria-label="539"/>In <span class="SANS_TheSansMonoCd_W5Regular_11">remove()</span>, you’d do something similar:</p>&#13;
<pre class="pre" id="pre-443"><code><b>bt.right = bt.left</b> = bt;</code></pre>&#13;
<p class="ListContinued">And that would also apply in <span class="SANS_TheSansMonoCd_W5Regular_11">_separate()</span>:</p>&#13;
<pre class="pre" id="pre-444"><code><b>node.left = node.right</b> = node;</code></pre>&#13;
<p class="ListContinued">Is it worth it? Four lines saved versus the possibility of misreading or misunderstanding the code; it’s your call!</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h2 class="H1" id="sec15"><span id="h1-116"/><span class="SANS_Futura_Std_Bold_B_11">Chapter 16</span></h2>&#13;
<p class="ListHead"><b>16.1  Maps for Tries</b></p>&#13;
<p class="ListPlainFirst">The needed changes with regard to object-based tries are as follows; I leave comments up to you, but the modified lines are in bold. Creating a trie requires the following:</p>&#13;
<pre class="pre" id="pre-445"><code>const newNode = () =&gt; <b>({links: new Map()})</b>;</code></pre>&#13;
<p class="ListBody">Finding a key just changes the way you access links:</p>&#13;
<pre class="pre" id="pre-446"><code>const _find = (trie, [first, . . .rest]) =&gt; {&#13;
  if (isEmpty(trie)) {&#13;
    return null;&#13;
  } else if (first === EOW) {&#13;
    return isEmpty(trie.links.get(first))&#13;
      ? null&#13;
      : trie.links.get(first).data;&#13;
  } else {&#13;
    return _find(<b>trie.links.get(first)</b>, rest);&#13;
  }&#13;
};</code></pre>&#13;
<p class="ListBody">Make the same kind of change when adding a new key:</p>&#13;
<pre class="pre" id="pre-447"><code>const _add = (trie, [first, . . .rest], data) =&gt; {&#13;
  if (first) {&#13;
    if (isEmpty(trie)) {&#13;
      trie = newNode();&#13;
    }&#13;
    if (first === EOW) {&#13;
      <b>trie.links.set(first, {data})</b>;&#13;
    } else {&#13;
      <b>trie.links.set(first, _add(trie.links.get(first)</b>, rest, data));&#13;
    }&#13;
  }&#13;
  return trie;&#13;
};</code></pre>&#13;
<p class="ListBody"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_540" aria-label="540"/>And the same happens when removing a key:</p>&#13;
<pre class="pre" id="pre-448"><code>const _remove = (trie, [first, . . .rest]) =&gt; {&#13;
  if (isEmpty(trie)) {&#13;
    // nothing to do&#13;
  } else if (!first) {&#13;
    trie = null;&#13;
  } else {&#13;
    <b>trie.links.set(first</b>, _remove(<b>trie.links.get(first)</b>, rest));&#13;
    if (isEmpty(<b>trie.links.get(first))</b>) {&#13;
      <b>trie.links.delete(first)</b>;&#13;
      if (<b>trie.links.size</b> === 0) {&#13;
        trie = null;&#13;
      }&#13;
    }&#13;
  }&#13;
  return trie;&#13;
};</code></pre>&#13;
<p class="ListHead"><b>16.2  Ever Empty?</b></p>&#13;
<p class="ListPlainFirst">The answer is yes in case you attempt to add a key that was already in the trie.</p>&#13;
<p class="ListHead"><b>16.3  Rotate Your Tries</b></p>&#13;
<p class="ListPlainFirst">Yes, you can apply rotations to a trie. You would work with the left and right links only and never affect the middle links.</p>&#13;
<p class="ListHead"><b>16.4  Empty Middle?</b></p>&#13;
<p class="ListPlainFirst">True, unless you didn’t want to store any data, in which case, the middle link of the EOW characters would be null.</p>&#13;
<p class="ListHead"><b>16.5  Four-Letter Trie?</b></p>&#13;
<p class="ListPlainFirst">The longest path (the trie’s height) would be from the root to the EOW for ZZZZ: 104 steps. The number of characters in the keys would be 4, and the alphabet is 26 letters, which means the height is the following: 4 × 26 = 104.</p>&#13;
<p class="ListHead"><b>16.6  How Do They Look?</b></p>&#13;
<p class="ListPlainFirst">Both an array-based trie and an object-based trie would be a list of nodes, one for each letter. A radix tree would have a single node, with the ALGORITHM word in it. Finally, a ternary tree would be a vertical column of nodes, with a letter at each level.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h2 class="H1" id="sec16"><span id="h1-117"/><span class="SANS_Futura_Std_Bold_B_11">Chapter 17</span></h2>&#13;
<p class="ListHead"><b>17.1  Where’s the Path?</b></p>&#13;
<p class="ListPlainFirst">Add a <span class="SANS_TheSansMonoCd_W5Regular_11">next[i][j]</span> matrix that tells you where to go if you are at <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> and want to get to <span class="SANS_TheSansMonoCd_W5Regular_11">j</span>. Whenever you update <span class="SANS_TheSansMonoCd_W5Regular_11">dist[i][j]</span> you’ll also update <span class="SANS_TheSansMonoCd_W5Regular_11">next</span>. Here’s the updated algorithm:</p>&#13;
<pre class="pre" id="pre-449"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_541" aria-label="541"/>const distances = (graph) =&gt; {&#13;
  const n = graph.length;&#13;
&#13;
  const distance = [];&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation1">❶</span> const next = [];&#13;
  for (let i = 0; i &lt; n; i++) {&#13;
    distance[i] = Array(n).fill(+Infinity);&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation2">❷</span> next[i] = Array(n).fill(null);&#13;
  }&#13;
&#13;
  graph.forEach((r, i) =&gt; {&#13;
    distance[i][i] = 0;&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation3">❸</span> next[i][i] = i;&#13;
    r.forEach((c, j) =&gt; {&#13;
      if (c &gt; 0) {&#13;
        distance[i][j] = graph[i][j];&#13;
      <span class="listcode_CodeAnnotation" aria-label="annotation4">❹</span> next[i][j] = j;&#13;
      }&#13;
    });&#13;
  });&#13;
&#13;
  for (let k = 0; k &lt; n; k++) {&#13;
    for (let i = 0; i &lt; n; i++) {&#13;
      for (let j = 0; j &lt; n; j++) {&#13;
        <span class="listcode_CodeAnnotation" aria-label="annotation5">❺</span> if (distance[i][j] &gt; distance[i][k] + distance[k][j]) {&#13;
          distance[i][j] = distance[i][k] + distance[k][j];&#13;
          next[i][j] = next[i][k];&#13;
        }&#13;
      }&#13;
    }&#13;
  }&#13;
&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation6">❻</span> return [distance, next];&#13;
};</code></pre>&#13;
<p class="ListBody">Define the next matrix <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span> and fill it with null values as the default <span class="listbody_CodeAnnotation" aria-label="annotation2">❷</span>. Mark that to go from a point to itself, the path obviously passes through that point <span class="listbody_CodeAnnotation" aria-label="annotation3">❸</span>, and whenever there’s an edge between two points, mark that too <span class="listbody_CodeAnnotation" aria-label="annotation4">❹</span>. Whenever you find a better path between two points <span class="listbody_CodeAnnotation" aria-label="annotation5">❺</span>, update not only <span class="SANS_TheSansMonoCd_W5Regular_11">dist</span> but <span class="SANS_TheSansMonoCd_W5Regular_11">next</span> as well. At the end, you must return the <span class="SANS_TheSansMonoCd_W5Regular_11">next</span> matrix <span class="listbody_CodeAnnotation" aria-label="annotation6">❻</span>, which you’ll use in the following path-finding algorithm:</p>&#13;
<pre class="pre" id="pre-450"><code>const path = (next, u, v) =&gt; {&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation1">❶</span> const sequence = [];&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation2">❷</span> if (next[u][v] !== null) {&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation3">❸</span> sequence.push(u);&#13;
  <span class="listcode_CodeAnnotation" aria-label="annotation4">❹</span> while (u !== v) {&#13;
     <span class="listcode_CodeAnnotation" aria-label="annotation5">❺</span> u = next[u][v];&#13;
     <span class="listcode_CodeAnnotation" aria-label="annotation6">❻</span> sequence.push(u);&#13;
    }&#13;
  }&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation7">❼</span> return sequence;&#13;
};</code></pre>&#13;
<p class="ListBody"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_542" aria-label="542"/>Create a <span class="SANS_TheSansMonoCd_W5Regular_11">sequence</span> array <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span> that will have all intermediate steps. If there is some way of going from the first point to the last <span class="listbody_CodeAnnotation" aria-label="annotation2">❷</span>, push the initial point <span class="listbody_CodeAnnotation" aria-label="annotation3">❸</span>, and if you haven’t reached the destination <span class="listbody_CodeAnnotation" aria-label="annotation4">❹</span>, advance to the next point <span class="listbody_CodeAnnotation" aria-label="annotation5">❺</span> and push it <span class="listbody_CodeAnnotation" aria-label="annotation6">❻</span>. At the end, just return the <span class="SANS_TheSansMonoCd_W5Regular_11">sequence</span> <span class="listbody_CodeAnnotation" aria-label="annotation7">❼</span> that includes all steps.</p>&#13;
<p class="ListHead"><b>17.2  Stop Searching Sooner</b></p>&#13;
<p class="ListPlainFirst">Make sure to check whether there were any changes in any pass. The main loop of the algorithm changes as follows:</p>&#13;
<pre class="pre" id="pre-451"><code>for (let i = 0; i &lt; n - 1; i++) {&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation1">❶</span> let changes = false;&#13;
  edges.forEach((v) =&gt; {&#13;
    const w = v.dist;&#13;
    if (distance[v.from] + w &lt; distance[v.to]) {&#13;
      distance[v.to] = distance[v.from] + w;&#13;
      previous[v.to] = v.from;&#13;
    <span class="listcode_CodeAnnotation" aria-label="annotation2">❷</span> changes = true;&#13;
    }&#13;
  });&#13;
<span class="listcode_CodeAnnotation" aria-label="annotation3">❸</span> if (!changes) {&#13;
    break;&#13;
  }&#13;
}</code></pre>&#13;
<p class="ListBody">At the beginning of each pass, set the <span class="SANS_TheSansMonoCd_W5Regular_11">changes</span> variable to <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span>, but if you change any distance, set it to <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> <span class="listbody_CodeAnnotation" aria-label="annotation2">❷</span>. After going through all the edges <span class="listbody_CodeAnnotation" aria-label="annotation3">❸</span>, if there were no changes, you don’t need to repeat the loops and can exit.</p>&#13;
<p class="ListHead"><b>17.3  Just One Will Do</b></p>&#13;
<p class="ListPlainFirst">You have to modify the signature of the function to receive three arguments (<span class="SANS_TheSansMonoCd_W5Regular_11">graph</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">from</span>, and the added <span class="SANS_TheSansMonoCd_W5Regular_11">to</span>) and change the main loop to see whether the top of the heap is the destination <span class="SANS_TheSansMonoCd_W5Regular_11">to</span> point; in that case, you stop:</p>&#13;
<pre class="pre" id="pre-452"><code>while (heap.length<b> &amp;&amp; heap[0] !== to</b>) {</code></pre>&#13;
<p class="ListHead"><b>17.4  The Wrong Way</b></p>&#13;
<p class="ListPlainFirst">The output is a topological sort of the original graph, but in reverse order: the first nodes that appear are those that were the last nodes in the previous graph.</p>&#13;
<p class="ListHead"><b>17.5  Joining Sets Faster</b></p>&#13;
<p class="ListPlainFirst">There will be two changes. First, all the nodes in the forest will include a <span class="SANS_TheSansMonoCd_W5Regular_11">size</span> attribute, initially set to 1:</p>&#13;
<pre class="pre" id="pre-453"><code>const groups = Array(n)&#13;
  .fill(0)&#13;
  .map(() =&gt; ({ptr: null, <b>size: 1</b>}));</code></pre>&#13;
<p class="ListBody"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_543" aria-label="543"/>The other change appears when merging two sets into a single set. The main loop of the <span class="SANS_TheSansMonoCd_W5Regular_11">isConnected(...)</span> code changes as follows:</p>&#13;
<pre class="pre" id="pre-454"><code>for (let i = 0; i &lt; n; i++) {&#13;
  for (let j = i + 1; j &lt; n; j++) {&#13;
    if (graph[i][j]) {&#13;
      const pf = findParent(groups[i]);&#13;
      const pt = findParent(groups[j]);&#13;
&#13;
      if (pf !== pt) {&#13;
        count--;&#13;
<b>        if (pf.size &lt; pt.size) {</b>&#13;
<b>          pt.size += pf.size;</b>&#13;
<b>          pf.ptr = pt;</b>&#13;
<b>        } else {</b>&#13;
<b>          pf.size += pt.size;</b>&#13;
<b>          pt.ptr = pf;</b>&#13;
<b>        }</b>&#13;
      }&#13;
    }&#13;
  }&#13;
}</code></pre>&#13;
<p class="ListBody">The code in bold marks the change. If you find two different roots, check which has the smallest size and link it to the other root. Don’t forget to update its size to account for the added subset.</p>&#13;
<p class="ListHead"><b>17.6  Take a Shortcut</b></p>&#13;
<p class="ListPlainFirst">The following modified <span class="SANS_TheSansMonoCd_W5Regular_11">findParent(...)</span> routine creates the shortcuts as described; can you see how it works?</p>&#13;
<pre class="pre" id="pre-455"><code>const findParent = (x) =&gt; {&#13;
  if (x.ptr !== null) {&#13;
    x.ptr = findParent(x.ptr);&#13;
    return x.ptr;&#13;
  } else {&#13;
    return x;&#13;
  }&#13;
};</code></pre>&#13;
<p class="ListHead"><b>17.7  A Spanning Tree for a Tree?</b></p>&#13;
<p class="ListPlainFirst">The exact same graph is produced: in a tree there is only one way to get from any point to another, so there are no alternatives for a different spanning tree.</p>&#13;
<p class="ListHead"><b>17.8  A Heap of Edges</b></p>&#13;
<p class="ListPlainFirst">I’ll leave this up to you, but I chose heapsort because of its assured performance.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_544" aria-label="544"/>&#13;
<h2 class="H1" id="sec17"><span id="h1-118"/><span class="SANS_Futura_Std_Bold_B_11">Chapter 18</span></h2>&#13;
<p class="ListHead"><b>18.1  Getting Here</b></p>&#13;
<p class="ListPlainFirst">The front list isn’t empty, which means someone exited the queue. A possible sequence could be as follows: X enters, then A enters, then B enters, then X exits (now the back list is empty and the front list consists of A and B), followed by C, D, and E entering in that order.</p>&#13;
<p class="ListHead"><b>18.2  With Apologies to Abbott and Costello, Who’s on Front?</b></p>&#13;
<p class="ListPlainFirst">The following logic solves the problem:</p>&#13;
<pre class="pre" id="pre-456"><code>const front = (queue) =&gt; {&#13;
<span class="listcode_CodeAnnotation1" aria-label="annotation1">❶</span> if (isEmpty(queue)) {&#13;
    return undefined;&#13;
<span class="listcode_CodeAnnotation1" aria-label="annotation2">❷</span>} else if (queue.frontPart !== null) {&#13;
    return queue.frontPart.value;&#13;
<span class="listcode_CodeAnnotation1" aria-label="annotation3">❸</span>} else {&#13;
    let ptr = queue.backPart;&#13;
    while (ptr.next !== null) {&#13;
      ptr = ptr.next;&#13;
    }&#13;
    return ptr.value;&#13;
  }&#13;
};</code></pre>&#13;
<p class="ListBody">If the queue is empty <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span>, there’s no front element; return <span class="SANS_TheSansMonoCd_W5Regular_11">undefined</span>, throw an exception, or perform other similar actions. If the front part isn’t empty <span class="listbody_CodeAnnotation" aria-label="annotation2">❷</span>, its top element is simply the front of the queue. But if the front part is empty <span class="listbody_CodeAnnotation" aria-label="annotation3">❸</span>, go through the back part until its end, because that’s the front of the queue.</p>&#13;
<p class="ListHead"><b>18.3  No Change Needed</b></p>&#13;
<p class="ListPlainFirst">There are many possibilities, but the simplest is to throw an exception if the key isn’t found and wrap the tree search algorithm in a <span class="SANS_TheSansMonoCd_W5Regular_11">try...catch</span> structure, so if the exception is thrown, just return the original tree.</p>&#13;
<p class="ListHead"><b>18.4  A New Minimum</b></p>&#13;
<p class="ListPlainFirst">Remember that you apply this function to find the minimum value of a nonempty binary search tree:</p>&#13;
<pre class="pre" id="pre-457"><code>const minKey = (tree) =&gt;   isEmpty(tree.left) ? tree.key : minKey(tree.left);</code></pre>&#13;
<p class="ListBody">If the root has no left child, the root’s value is the minimum. Otherwise, the minimum value of the tree will be the minimum of the root’s left child, because all values in that subtree are smaller than the root’s value.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>