<html><head></head><body>
<div id="sbo-rt-content"><section aria-labelledby="ch20" epub:type="chapter" role="doc-chapter">
<span aria-label="381" epub:type="pagebreak" id="pg_381" role="doc-pagebreak"/>
<hgroup>
<h2 class="CHAPTER" id="ch20">
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">20</span></span>
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">MANAGING CLASSES AND NAMESPACES WITH COMPOSER</span></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener" height="380" src="../images/opener.jpg" width="380"/>
</figure>
<p class="INTRO">As your PHP projects grow larger and more complex, you increasingly run the risk of encountering a <i>naming collision</i>, or having two classes with the same name. In this chapter, you’ll learn about <i>namespaces</i>, the solution provided by object-oriented languages to avoid naming collisions. In addition, you’ll learn to use the helpful Composer command line tool, which automates the process of loading class- and function-declaration files and simplifies work with namespaces. Almost every modern object-oriented PHP project uses Composer, and we’ll use it throughout the remainder of the book.</p>
<p class="TX">You might think that a naming collision would be unlikely; after all, up until now we’ve been writing class declarations in PHP files with the same <span aria-label="382" epub:type="pagebreak" id="pg_382" role="doc-pagebreak"/>name as the class, and we’ve been placing these class declaration files in the project’s <i>src</i> directory. Since PHP doesn’t allow two files with the same name in the same directory, surely we couldn’t end up with two classes of the same name?</p>
<p class="TX">In fact, naming collisions can occur in several cases. First, you might try to declare a class with the same name as one of the built-in classes of the PHP language, such as <span class="SANS_TheSansMonoCd_W5Regular_11">Error</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">Directory</span>, or <span class="SANS_TheSansMonoCd_W5Regular_11">Generator</span>. Second, you might declare two classes in different directories (for example, different subdirectories of <i>src</i>). Third, you might combine your own classes with classes from third-party libraries.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="H1" id="sec1"><span id="toc-link_278"/><span class="SANS_Futura_Std_Bold_B_11">Namespaces</span></h3>
<p class="TNI1"><i>Namespaces</i> can be thought of as a virtual hierarchy of directories for classes, used to prevent class name collisions. Classes are organized within namespaces and sub-namespaces, much as computer files are organized within directories and subdirectories. Just as you need to state the directory location of a computer file on a hard disk, using namespaced classes requires you to specify both the name of the class and its namespace to uniquely identify a particular class.</p>
<p class="TX">A backslash character (<span class="SANS_TheSansMonoCd_W5Regular_11">\</span>) separates namespaces, sub-namespaces (if any), and the class name. For example, <span class="SANS_TheSansMonoCd_W5Regular_11">\MyNamespace\MySubNamespace\MyClass</span> refers to a class called <span class="SANS_TheSansMonoCd_W5Regular_11">MyClass</span> in the sub-namespace <span class="SANS_TheSansMonoCd_W5Regular_11">MySubNamespace</span>, which is part of the larger <span class="SANS_TheSansMonoCd_W5Regular_11">MyNamespace</span> namespace. Identifying <span class="SANS_TheSansMonoCd_W5Regular_11">MyClass</span> with a namespace and sub-namespace prevents it from colliding with another <span class="SANS_TheSansMonoCd_W5Regular_11">MyClass</span> class in a different namespace, such as <span class="SANS_TheSansMonoCd_W5Regular_11">\YourNamespace\MyClass</span>. By convention, the first letter of a namespace or sub-namespace is capitalized, just like class names. Other letters in the namespace or sub-namespace can be capitalized as well.</p>
<p class="TX">Classes that are built into the PHP language are considered to be in the <i>root namespace</i>, which is identified with just a single backslash character. For example, you can write <span class="SANS_TheSansMonoCd_W5Regular_11">\DateTime</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">\Exception</span> to explicitly refer to PHP’s built-in <span class="SANS_TheSansMonoCd_W5Regular_11">DateTime</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">Exception</span> classes. So far in this book, we’ve been omitting the backslash before built-in class names, since we haven’t been using namespaces when writing our own classes. Including the backslash makes it unambiguous that we’re referring to a PHP class in the root namespace.</p>
<p class="TX">In the examples that follow, I’ll use the namespace <span class="SANS_TheSansMonoCd_W5Regular_11">Mattsmithdev</span>. It’s the namespace I use for all the classes I write, along with a sub-namespace for each project I work on. You may want to make up your own namespace, such as <span class="SANS_TheSansMonoCd_W5Regular_11">Supercoder</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">DublinDevelopers</span>, and use it when following these chapters and writing your own classes. We’ll also encounter other namespaces in <span class="Xref">“Adding Third-Party Libraries to a Project” on <a href="#pg_390">page 390</a></span>.</p>
<section aria-labelledby="sec2" epub:type="division">
<h4 class="H2" id="sec2"><span id="toc-link_279"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Declaring a Class’s Namespace</span></h4>
<p class="TNI1">To declare the namespace of a class, use the <span class="SANS_TheSansMonoCd_W5Regular_11">namespace</span> keyword followed by the namespace’s name. This should be the first line of PHP code in the <span aria-label="383" epub:type="pagebreak" id="pg_383" role="doc-pagebreak"/>class-declaration file. To demonstrate, we’ll declare a class called <span class="SANS_TheSansMonoCd_W5Regular_11">Shirt</span> and make it part of the <span class="SANS_TheSansMonoCd_W5Regular_11">Mattsmithdev</span> namespace. Start a new project, create a file called <i>src/Shirt.php</i>, and enter the code from <a href="#lis20-1">Listing 20-1</a>.</p>
<span id="lis20-1"/>
<pre><code>&lt;?php&#13;
namespace Mattsmithdev;&#13;
&#13;
&#13;
class Shirt&#13;
{&#13;
    private string $type ='t-shirt';&#13;
&#13;
    public function getType(): string&#13;
    {&#13;
        return $this-&gt;type;&#13;
    }&#13;
&#13;
    public function setType(string $type): void&#13;
    {&#13;
        $this-&gt;type = $type;&#13;
    }&#13;
}</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 20-1: The</span> <span class="TheSansMonoCd_W5Regular_Italic_11">Shirt</span> <span class="SANS_Futura_Std_Book_Oblique_11">class in the</span> <span class="TheSansMonoCd_W5Regular_Italic_11">Mattsmithdev</span> <span class="SANS_Futura_Std_Book_Oblique_11">namespace</span></p>
<p class="TX">Immediately after the opening PHP tag, we use <span class="SANS_TheSansMonoCd_W5Regular_11">namespace Mattsmithdev</span> to make the class we’re about to declare part of the <span class="SANS_TheSansMonoCd_W5Regular_11">Mattsmithdev</span> namespace. We follow the namespace statement with two blank lines, which is recommended by the PHP coding standards. Then we proceed with the class declaration as usual. In this case, the <span class="SANS_TheSansMonoCd_W5Regular_11">Shirt</span> class has a private <span class="SANS_TheSansMonoCd_W5Regular_11">type</span> property with a default value of <span class="SANS_TheSansMonoCd_W5Regular_11">'t-shirt'</span>, as well as public getter and setter methods for this property.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h4 class="H2" id="sec3"><span id="toc-link_280"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Using a Namespaced Class</span></h4>
<p class="TNI1">Once a class is declared to be within a namespace, you need to unambiguously inform the PHP engine that it’s the class you want to use. You can do this in two ways.</p>
<p class="TX">The first option is to always include the namespace when referencing the class; this is called using the <i>fully qualified name</i> of the class. For example, to create a new <span class="SANS_TheSansMonoCd_W5Regular_11">Shirt</span> object, you would write <span class="SANS_TheSansMonoCd_W5Regular_11">new \Mattsmithdev\Shirt()</span>. Let’s try that now. Add a <i>public/index.php</i> file to your project and enter the code from <a href="#lis20-2">Listing 20-2</a>.</p>
<span id="lis20-2"/>
<pre><code>&lt;?php&#13;
require_once __DIR__ . '/../src/Shirt.php';&#13;
&#13;
$shirt1 = new \Mattsmithdev\Shirt();&#13;
$shirt2 = new \Mattsmithdev\Shirt();&#13;
&#13;
print "shirt 1 type = {$shirt1-&gt;getType()}";</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 20-2: Creating objects of the</span> <span class="TheSansMonoCd_W5Regular_Italic_11">\Mattsmithdev\Shirt</span> <span class="SANS_Futura_Std_Book_Oblique_11">class in</span> <span class="SANS_Futura_Std_Book_11">index.php</span></p>
<p class="TX"><span aria-label="384" epub:type="pagebreak" id="pg_384" role="doc-pagebreak"/>After reading in the class-declaration file, we create two objects of the <span class="SANS_TheSansMonoCd_W5Regular_11">Shirt</span> class, using the class’s fully qualified name. Run the project at the command line with <span class="SANS_TheSansMonoCd_W7Bold_11">php public/index.php</span> and you should see the following:</p>
<pre><code>shirt 1 type = t-shirt</code></pre>
<p class="BodyContinued">The message indicates that a <span class="SANS_TheSansMonoCd_W5Regular_11">Shirt</span> object has been successfully created via the class’s fully qualified name.</p>
<p class="TX">The second way to unambiguously reference a class from a particular namespace is to include a <span class="SANS_TheSansMonoCd_W5Regular_11">use</span> statement before invoking the class. For example, <span class="SANS_TheSansMonoCd_W5Regular_11">use Mattsmithdev\Shirt</span> tells the PHP engine that any subsequent references to the <span class="SANS_TheSansMonoCd_W5Regular_11">Shirt</span> class are specifically to the one in the <span class="SANS_TheSansMonoCd_W5Regular_11">Mattsmithdev</span> namespace. To see how <span class="SANS_TheSansMonoCd_W5Regular_11">use</span> statements work, update your <i>public/index.php</i> file to match <a href="#lis20-3">Listing 20-3</a>.</p>
<span id="lis20-3"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">require_once __DIR__ . '/../src/Shirt.php';</span>&#13;
&#13;
use Mattsmithdev\Shirt;&#13;
&#13;
$shirt1 = new Shirt();&#13;
$shirt2 = new Shirt();&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">print "shirt 1 type = {$shirt1-&gt;getType()}";</span></code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 20-3: Referencing the</span> <span class="TheSansMonoCd_W5Regular_Italic_11">Shirt</span> <span class="SANS_Futura_Std_Book_Oblique_11">class with a</span> <span class="TheSansMonoCd_W5Regular_Italic_11">use</span> <span class="SANS_Futura_Std_Book_Oblique_11">statement in</span> <span class="SANS_Futura_Std_Book_11">index.php</span></p>
<p class="TX">We include a <span class="SANS_TheSansMonoCd_W5Regular_11">use</span> statement after reading in the class declaration to ensure that <span class="SANS_TheSansMonoCd_W5Regular_11">Shirt</span> later in the code will refer to <span class="SANS_TheSansMonoCd_W5Regular_11">Mattsmithdev\Shirt</span>. Notice that we don’t include a backslash before the namespace in a <span class="SANS_TheSansMonoCd_W5Regular_11">use</span> statement. This kind of class identifier, without the initial backslash, is called a <i>qualified name</i>, as opposed to a <i>fully qualified name</i> that includes the initial backslash. We then create the two <span class="SANS_TheSansMonoCd_W5Regular_11">Shirt</span> objects simply with <span class="SANS_TheSansMonoCd_W5Regular_11">new Shirt()</span>, since the PHP engine knows which class we’re referencing, thanks to the <span class="SANS_TheSansMonoCd_W5Regular_11">use</span> statement. Run the index script again and you should see that the output hasn’t changed. We’ve still successfully created some <span class="SANS_TheSansMonoCd_W5Regular_11">Shirt</span> objects.</p>
<p class="TX">If you need to differentiate between two classes with the same name but different namespaces in the same section of code, you can either refer to both with their fully qualified names (for example, <span class="SANS_TheSansMonoCd_W5Regular_11">\Mattsmithdev\Shirt</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">\OtherNamespace\Shirt</span>) or provide a <span class="SANS_TheSansMonoCd_W5Regular_11">use</span> statement for one of the classes and qualify the other.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h4 class="H2" id="sec4"><span id="toc-link_281"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Referencing Namespaces in Class Declarations</span></h4>
<p class="TNI1">Say you’re writing code in the class-declaration file for a namespaced class (as opposed to in a general script like <i>index.php</i>) and you want to refer to a class from a different namespace. If you haven’t written a <span class="SANS_TheSansMonoCd_W5Regular_11">use</span> statement, you must use the fully qualified name of the other class, starting with a backslash. For example, if you were writing code for a class declared in the <span class="SANS_TheSansMonoCd_W5Regular_11">Mattsmithdev</span> namespace and you wanted to refer to PHP’s built-in <span class="SANS_TheSansMonoCd_W5Regular_11">DateTime</span> <span aria-label="385" epub:type="pagebreak" id="pg_385" role="doc-pagebreak"/>class, you’d have to write it as <span class="SANS_TheSansMonoCd_W5Regular_11">\DateTime</span> to indicate that it’s part of the root namespace. Likewise, if you wanted to refer to a third-party class, you’d write a backslash, then the third-party namespace, then another backslash, and then the class name, such as <span class="SANS_TheSansMonoCd_W5Regular_11">\MathPHP\Algebra</span>.</p>
<p class="TX">Without the initial backslash, PHP will assume you’re referring to a class or sub-namespace of the current namespace. For example, in a class in the <span class="SANS_TheSansMonoCd_W5Regular_11">Mattsmithdev</span> namespace, a reference to <span class="SANS_TheSansMonoCd_W5Regular_11">DateTime()</span> without an initial backslash is assumed to be a reference to <span class="SANS_TheSansMonoCd_W5Regular_11">Mattsmithdev\DateTime</span>, meaning a <span class="SANS_TheSansMonoCd_W5Regular_11">DateTime</span> class in the <span class="SANS_TheSansMonoCd_W5Regular_11">Mattsmithdev</span> namespace. Similarly, a reference to <span class="SANS_TheSansMonoCd_W5Regular_11">MathPHP\Algebra</span> without an initial backslash is assumed to be a reference to <span class="SANS_TheSansMonoCd_W5Regular_11">Mattsmithdev\MathPHP\Algebra</span>, meaning <span class="SANS_TheSansMonoCd_W5Regular_11">MathPHP</span> is assumed to be a sub-namespace of <span class="SANS_TheSansMonoCd_W5Regular_11">Mattsmithdev</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">Algebra</span> is assumed to be a class in that sub-namespace. Writing a fully qualified namespace beginning with the backslash ensures that the PHP engine will understand the namespace of the class you’re referencing.</p>
<p class="TX">On the other hand, if you <i>are</i> referring to a class or sub-namespace of the current namespace, you shouldn’t include a backslash before the class or sub-namespace. For example, if you’re working on a class in the <span class="SANS_TheSansMonoCd_W5Regular_11">Mattsmithdev</span> namespace, <span class="SANS_TheSansMonoCd_W5Regular_11">Shirt()</span> is understood to refer to the <span class="SANS_TheSansMonoCd_W5Regular_11">Shirt</span> class in the <span class="SANS_TheSansMonoCd_W5Regular_11">Mattsmithdev</span> namespace, and <span class="SANS_TheSansMonoCd_W5Regular_11">SubNamespace\Example</span> is understood to refer to the class <span class="SANS_TheSansMonoCd_W5Regular_11">Mattsmithdev\SubNamespace\Example</span>.</p>
<p class="TX">If you’re using a class from another namespace only once, it might make sense to just write the class’s fully qualified name, including the initial backslash. If you’ll need to refer to the class several times, however, writing a <span class="SANS_TheSansMonoCd_W5Regular_11">use</span> statement for it at the beginning of the class declaration is more efficient. In this case, no initial backslash is needed. As you look at and write more PHP code, you’ll often see many <span class="SANS_TheSansMonoCd_W5Regular_11">use</span> statements at the beginning of a class declaration when the code uses classes declared in other namespaces, as illustrated in <a href="#lis20-4">Listing 20-4</a>.</p>
<span id="lis20-4"/>
<pre><code>&lt;?php&#13;
&#13;
namespace App\Controller;&#13;
&#13;
use App\Entity\ChessGame;&#13;
use App\Entity\Comment;&#13;
use App\Form\ChessGameType;&#13;
use App\Repository\ChessGameRepository;&#13;
use App\Repository\CommonRepository;&#13;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;&#13;
use Symfony\Component\HttpFoundation\Request;&#13;
use Symfony\Component\HttpFoundation\Response;&#13;
use Symfony\Component\Routing\Annotation\Route;&#13;
use Symfony\Component\HttpFoundation\Session\SessionInterface;&#13;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\IsGranted;&#13;
&#13;
/**&#13;
* @Route("/chessgame")&#13;
*/&#13;
<span aria-label="386" epub:type="pagebreak" id="pg_386" role="doc-pagebreak"/>class ChessGameController extends AbstractController&#13;
{&#13;
    private $session;&#13;
&#13;
    public function __construct(SessionInterface $session)&#13;
    {&#13;
<span class="TheSansMonoCd_W5Regular_Italic_11">--snip--</span></code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 20-4: A class declaration with many</span> <span class="TheSansMonoCd_W5Regular_Italic_11">use</span> <span class="SANS_Futura_Std_Book_Oblique_11">statements</span></p>
<p class="TX">This code snippet is the start of a class declaration from one of my PHP Symfony web framework chess projects. It has a whopping 11 <span class="SANS_TheSansMonoCd_W5Regular_11">use</span> statements, drawing on classes from a variety of namespaces and sub-namespaces. The <span class="SANS_TheSansMonoCd_W5Regular_11">use</span> statements help keep them all straight, but if juggling all those classes still seems overwhelming, don’t worry: we’re about to discuss a tool for managing all the classes in a project.</p>
</section>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h3 class="H1" id="sec5"><span id="toc-link_282"/><span class="SANS_Futura_Std_Bold_B_11">Composer</span></h3>
<p class="TNI1">Composer is a command line tool to support object-oriented PHP programming. It helps with loading class and function declaration files (your own and those from third-party libraries), and it facilitates working with classes from different namespaces. It’s an essential, easy-to-use tool for professional web application projects. In this section, you’ll set up Composer and learn how to use it to create command line aliases, load class-declaration files automatically, and manage a project’s third-party dependencies.</p>
<blockquote>
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>
</blockquote>
<p class="NOTE-TXT"><i>SymfonyCasts has a great free video introducing the Composer tool at</i> <span class="note_LinkURL"><a href="https://symfonycasts.com/screencast/composer">https://symfonycasts.com/screencast/composer</a></span><i>.</i></p>
<section aria-labelledby="sec6" epub:type="division">
<h4 class="H2" id="sec6"><span id="toc-link_283"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Installing and Testing Composer</span></h4>
<p class="TNI1">For Windows, Composer offers a simple installer that can be found at <i><a href="https://getcomposer.org/Composer-Setup.exe">https://getcomposer.org/Composer-Setup.exe</a></i>. For macOS, you can install Composer with Homebrew, as discussed in <span class="Xref"><a href="appendix-a.xhtml">Appendix A</a></span>. For Linux, you need to execute several command line statements to download and run the <i>composer.php</i> script. You can find details at <i><a href="https://getcomposer.org/download/">https://getcomposer.org/download/</a></i>. If you’re using Replit to follow along with this book, see <span class="Xref"><a href="appendix-c.xhtml">Appendix C</a></span> for how to integrate Composer into your projects.</p>
<p class="TX">Once you’ve installed Composer, test it by opening a new command line terminal application and entering <span class="SANS_TheSansMonoCd_W7Bold_11">composer</span>. This launches the Composer tool, bringing up a nice ASCII art logo, the version number, and a list of the command line options.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h4 class="H2" id="sec7"><span id="toc-link_284"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Creating the composer.json Configuration File</span></h4>
<p class="TNI1">To use the Composer command line tool with a project, you need to create a <i>composer.json</i> file to house all the information Composer needs to know about the project. (See the following <span class="Xref">“JSON File Format”</span> box for a refresher on this type of file.) For example, the <i>composer.json</i> file features <span aria-label="387" epub:type="pagebreak" id="pg_387" role="doc-pagebreak"/>records of the namespaces and class locations for your own code, as well as of the third-party packages that the project depends on. In addition, you can declare command line <i>aliases</i> in the <i>composer.json</i> file, shortcuts that can save you from typing long commands at the command line. We’ll begin our exploration of the <i>composer.json</i> file by declaring a simple alias.</p>
<aside aria-labelledby="box-14" class="box">
<h5 class="BoxTitle" id="box-14"><span class="SANS_Dogma_OT_Bold_B_11">THE JSON FILE FORMAT</span></h5>
<p class="BoxBodyFirst"><span class="SANS_Futura_Std_Book_Oblique_11">JavaScript Object Notation (JSON)</span> <span class="SANS_Futura_Std_Book_11">is a popular text file format for storing and exchanging data. Originally, JSON was just part of JavaScript programs, but it caught on quickly as a general-purpose format for sharing data between computer programs and is now independent of the JavaScript language.</span></p>
<p class="BoxBody"><span class="SANS_Futura_Std_Book_11">JSON documents have two types of structures: objects and arrays. A</span> <span class="SANS_Futura_Std_Book_Oblique_11">JSON object</span> <span class="SANS_Futura_Std_Book_11">is declared within curly brackets and has a comma-separated list of name/value pairs, as shown here:</span></p>
<pre><code>{id: 1, name: "hammer"}</code></pre>
<p class="BoxBodyContinued"><span class="SANS_Futura_Std_Book_11">This object has two items, one with a name of</span> <span class="SANS_TheSansMonoCd_W5Regular_11">id</span> <span class="SANS_Futura_Std_Book_11">and a value of</span> <span class="SANS_TheSansMonoCd_W5Regular_11">1</span><span class="SANS_Futura_Std_Book_11">, and the other with a name of</span> <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> <span class="SANS_Futura_Std_Book_11">and a value of</span> <span class="SANS_TheSansMonoCd_W5Regular_11">"hammer"</span><span class="SANS_Futura_Std_Book_11">. Objects are typically used to store multiple properties or pieces of information about the same entity, which is why the name/value pairs in an object are often called</span> <span class="SANS_Futura_Std_Book_Oblique_11">properties</span><span class="SANS_Futura_Std_Book_11">.</span></p>
<p class="BoxBody"><span class="SANS_Futura_Std_Book_11">A</span> <span class="SANS_Futura_Std_Book_Oblique_11">JSON array</span> <span class="SANS_Futura_Std_Book_11">is declared within square brackets and is a comma-separated list of values. The values in an array can be simple ones (such as strings and numbers), or they can be other arrays or objects, as in this example:</span></p>
<pre><code>[{id: 1, name: "hammer"}, {id: 2, name: "bucket"}]</code></pre>
<p class="BoxBodyContinued"><span class="SANS_Futura_Std_Book_11">This array has two values, and each is a JSON object.</span></p>
<p class="BoxBodyLast"><span class="SANS_Futura_Std_Book_11">Beyond recognizing the difference between an object and an array, you don’t need to know much about JSON to be able to configure the</span> <span class="SANS_Futura_Std_Book_Oblique_11">composer .json</span> <span class="SANS_Futura_Std_Book_11">file for your projects. That said, you can learn more about JSON at the official site for this international file format:</span> <span class="SANS_Futura_Std_Book_Oblique_11"><a href="https://www.json.org">https://www.json.org</a></span><span class="SANS_Futura_Std_Book_11">.</span></p>
</aside>
<p class="TX">The <i>composer.json</i> text file must be located at the top level of your PHP project directory, not inside a subfolder like <i>src</i> or <i>public</i>. Continuing with this chapter’s project, create <i>composer.json</i>, save it at the top level of the project directory, and then enter the contents of <a href="#lis20-5">Listing 20-5</a>. This code creates an alias called <span class="SANS_TheSansMonoCd_W5Regular_11">hello</span> that will stand in for the command <span class="SANS_TheSansMonoCd_W5Regular_11">echo Hello World</span>.</p>
<span id="lis20-5"/>
<pre><code>{&#13;
    "scripts": {&#13;
        "hello": "echo Hello World"&#13;
    }&#13;
}</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 20-5: Declaring an alias in the</span> <span class="SANS_Futura_Std_Book_11">composer.json</span> <span class="SANS_Futura_Std_Book_Oblique_11">file</span></p>
<p class="TX"><span aria-label="388" epub:type="pagebreak" id="pg_388" role="doc-pagebreak"/>The content of <i>composer.json</i> is always a JSON object and so will always begin and end with a pair of curly brackets. Inside the object, we declare a <span class="SANS_TheSansMonoCd_W5Regular_11">"scripts"</span> property with a value that itself is an object. Within the sub-object, we declare a property named <span class="SANS_TheSansMonoCd_W5Regular_11">"hello"</span> (the name of our alias) with a value of <span class="SANS_TheSansMonoCd_W5Regular_11">"echo Hello, world!"</span> (the code that will be replaced by the shortcut alias).</p>
<p class="TX">We now have a simple but valid <i>composer.json</i> file telling Composer that there’s a command line alias named <span class="SANS_TheSansMonoCd_W5Regular_11">"hello"</span>. To see whether this has worked, enter <span class="SANS_TheSansMonoCd_W7Bold_11">composer hello</span> at the terminal. You should see <span class="SANS_TheSansMonoCd_W5Regular_11">Hello, world!</span> as a result:</p>
<pre><code>$ <b>composer hello</b>&#13;
&gt; echo Hello, world!&#13;
Hello, world!</code></pre>
<p class="TX">In this case, we’ve written more characters to declare the alias than we would need to write out the <span class="SANS_TheSansMonoCd_W5Regular_11">echo</span> statement in full at the command line. However, sometimes these script aliases can be handy. For example, here’s an alias I use in some projects to output a report of how much code in the <i>/src</i> folder needs fixing to match the PHP programming standards (although the alias appears on two lines here for space reasons, it would be all one line in the file):</p>
<pre><code>"reportfixsrc":"php php-cs-fixer.phar fix --level=psr2&#13;
--dry-run --diff ./src &gt; ./tests/fixerReport.txt"</code></pre>
<p class="BodyContinued">This alias lets me enter <span class="SANS_TheSansMonoCd_W5Regular_11">composer reportfixsrc</span> at the command line rather than a long PHP command to run a PHP Archive (<i>.phar</i>) file with lots of parameters.</p>
<p class="TX">As you’ll soon see, Composer can do a lot more than just keep track of command line aliases. For now, we’ve successfully created the <i>composer.json</i> file for our project, an essential first step in using this powerful tool.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h4 class="H2" id="sec8"><span id="toc-link_285"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Creating an Autoloader</span></h4>
<p class="TNI1">An <i>autoloader</i> is a system that automatically retrieves class-declaration files whenever they’re needed, so you don’t have to load them all into an <i>index.php</i> file yourself. Autoloaders become useful as object-oriented PHP projects grow in size and complexity, involving many classes in many namespaces. If you had to write <span class="SANS_TheSansMonoCd_W5Regular_11">require_once</span> statements for each class in your <i>index.php</i> front controller, not only would it be a lot of work, but it would also be easy to miss one or two, particularly as the project continues to evolve. This would lead to errors and would force you to keep going back to update the list of files to require. An autoloader handles the process for you, provided the classes are correctly namespaced and correctly located according to the autoloading rules.</p>
<p class="TX">One of the most powerful features of the Composer tool is its autoloader. It conforms to PSR-4, PHP’s recommended set of rules for autoloading. According to PSR-4, you must specify the base directory containing the classes of each namespace. For example, you may want to declare that classes in the <span class="SANS_TheSansMonoCd_W5Regular_11">Mattsmithdev</span> namespace can be found in the <i>src</i> directory. <span aria-label="389" epub:type="pagebreak" id="pg_389" role="doc-pagebreak"/>Further, PSR-4 stipulates that any sub-namespaces will be assumed to have corresponding subdirectories within the declared base directory of the namespace. For example, the class <span class="SANS_TheSansMonoCd_W5Regular_11">Mattsmithdev\Trigonometry\Angles.php</span> should be located in <i>src/Trigonometry</i>, the class <span class="SANS_TheSansMonoCd_W5Regular_11">Mattsmithdev\Utility\Security.php</span> should be located in <i>src/Utility</i>, and so on. As long as the subdirectory has the same name as the sub-namespace, you don’t need to tell the autoloader where to find the sub-namespaced classes.</p>
<p class="TX">Getting the Composer autoloader to work requires three steps:</p>
<p class="ListNumber">1.   Declare the base directory for each namespace in the project’s <i>composer .json</i> file.</p>
<p class="ListNumber">2.   Tell Composer to create or update its autoloader script.</p>
<p class="ListNumber">3.   Add a <span class="SANS_TheSansMonoCd_W5Regular_11">require_once</span> statement for the autoloader script at the beginning of the project’s <i>public/index.php</i> front controller. This single <span class="SANS_TheSansMonoCd_W5Regular_11">require_once</span> statement replaces the separate <span class="SANS_TheSansMonoCd_W5Regular_11">require_once</span> statements for each individual class.</p>
<p class="TX">We’ll walk through the process of setting up the Composer autoloader to load our <span class="SANS_TheSansMonoCd_W5Regular_11">Mattsmithdev\Shirt</span> class. First, <a href="#lis20-6">Listing 20-6</a> shows what to write in the <i>composer.json</i> file to declare that classes in the <span class="SANS_TheSansMonoCd_W5Regular_11">Mattsmithdev</span> namespace can be found in the <i>src</i> directory.</p>
<span id="lis20-6"/>
<pre><code>{&#13;
    "autoload": {&#13;
        "psr-4": {&#13;
            "Mattsmithdev\\": "src"&#13;
        }&#13;
    }&#13;
}</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 20-6: Setting up the autoloader in the</span> <span class="SANS_Futura_Std_Book_11">composer.json</span> <span class="SANS_Futura_Std_Book_Oblique_11">file</span></p>
<p class="TX">We declare an <span class="SANS_TheSansMonoCd_W5Regular_11">"autoload"</span> property, whose value is an object. Within that object, we declare the <span class="SANS_TheSansMonoCd_W5Regular_11">"psr-4"</span> property, whose value is another object. It contains a <span class="SANS_TheSansMonoCd_W5Regular_11">"Mattsmithdev\\"</span> property whose value is <span class="SANS_TheSansMonoCd_W5Regular_11">"src"</span>. This tells Composer that class files in the <span class="SANS_TheSansMonoCd_W5Regular_11">Mattsmithdev</span> namespace are located in the <i>src</i> directory. Notice the two backslash characters (<span class="SANS_TheSansMonoCd_W5Regular_11">\\</span>) after the namespace. This is a requirement of the PSR-4.</p>
<p class="TX">For the projects we’ll work on in the next few chapters, the <i>composer.json</i> files will be essentially the same as <a href="#lis20-6">Listing 20-6</a>. The only potential difference from project to project will be the actual namespace(s) and location(s) declared within the <span class="SANS_TheSansMonoCd_W5Regular_11">"psr-4"</span> object.</p>
<blockquote>
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>
</blockquote>
<p class="NOTE-TXT"><i>The Composer autoloader has some additional subtleties. If you want to learn more, consult the Composer documentation at</i> <span class="note_LinkURL"><a href="https://getcomposer.org/doc/04-schema.md#psr-4">https://getcomposer.org/doc/04-schema.md#psr-4</a></span><i>.</i></p>
<p class="TX">Now that we’ve declared the base directory for the <span class="SANS_TheSansMonoCd_W5Regular_11">Mattsmithdev</span> namespace in the <i>composer.json</i> file, we can tell Composer to generate a class autoloader <span aria-label="390" epub:type="pagebreak" id="pg_390" role="doc-pagebreak"/>for us. Enter the following at the command line for the current project’s working directory:</p>
<pre><code>$ <b>composer dump-autoload</b></code></pre>
<p class="TX">This command creates a new folder in the project called <i>vendor</i>, if it doesn’t exist already, and generates or updates several files within that folder. This <i>vendor</i> folder is where Composer keeps its working files for the project. You can look inside it, but you shouldn’t change its contents. You can also delete the folder and ask Composer to rebuild it anytime, so you can safely omit this folder whenever you back up a project.</p>
<p class="TX">Inside <i>vendor</i>, you should see a <i>vendor/autoload.php</i> file as well as a <i>vendor/composer</i> folder containing several more scripts, including <i>autoload_psr4.php</i>, which encodes our PSR-4-compliant declaration. This file contains statements to return the location (<i>src/</i>) of classes in the <span class="SANS_TheSansMonoCd_W5Regular_11">Mattsmithdev</span> namespace.</p>
<p class="TX">Now that we’ve generated the autoloader, we can update the <i>public/index.php</i> script to require just this one <i>autoload.php</i> file, no matter how many classes we need to refer to in our project. As long as the base directories for the namespaces have been declared in the <i>composer.json</i> file and the autoloader has been updated with the <span class="SANS_TheSansMonoCd_W5Regular_11">composer dump-autoload</span> command, then whenever we write a <span class="SANS_TheSansMonoCd_W5Regular_11">use</span> statement for a namespaced class, the PHP engine will load its declaration, ready for our code. <a href="#lis20-7">Listing 20-7</a> shows how to update <i>index.php</i>.</p>
<span id="lis20-7"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
require_once __DIR__ . '/../vendor/autoload.php';&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">use Mattsmithdev\Shirt;</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">$shirt1 = new Shirt();</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">$shirt2 = new Shirt();</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">print "shirt 1 type = {$shirt1-&gt;getType()}";</span></code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 20-7: Reading the Composer-generated autoloader script into</span> <span class="SANS_Futura_Std_Book_11">index.php</span></p>
<p class="TX">We change the <span class="SANS_TheSansMonoCd_W5Regular_11">require_once</span> statement to read in and execute the Composer-generated autoloader script from the <i>vendor</i> directory. When you run the project, the output will be just as before, but now we’re using the Composer autoloader to automatically read in the declaration for the <span class="SANS_TheSansMonoCd_W5Regular_11">Mattsmithdev\Shirt</span> class from the <i>src</i> folder, instead of reading it in manually. While this may not seem to make much of a difference for our one-class project, the autoloader is a big time-saver for projects with many classes.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h4 class="H2" id="sec9"><span id="toc-link_286"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Adding Third-Party Libraries to a Project</span></h4>
<p class="TNI1">Another powerful feature of Composer is its capability to add third-party libraries to a project and maintain a record of these dependencies in the <i>composer.json</i> file. Thousands of open source libraries are available, many kept up-to-date by multiple experienced software developers; in many cases, <span aria-label="391" epub:type="pagebreak" id="pg_391" role="doc-pagebreak"/>a few minutes of searching can offer up a ready-made library that does all or most of what you want. Well-maintained open source projects have been tested thoroughly and refactored to implement best practices, so careful use of third-party libraries can reduce your workload while helping to maintain the quality of a software project.</p>
<p class="TX">Without Composer’s package-dependency features, you’d have to download the code for third-party libraries from websites or Git repositories, copy it to an appropriate location such as a <i>lib</i> folder, and update the <i>composer.json</i> file with the namespaces and locations of these library classes. Instead, you can simply tell Composer that you need a third-party library in your project, and it will do all the hard work for you. It will automatically download the code, create and copy the files to an appropriate subdirectory in <i>vendor</i>, update the autoloader, and record the dependency (and its version) in the <i>composer.json</i> file. All you need to know is the name of the package you want and the vendor supplying it.</p>
<p class="TX">To see how this works, we’ll tell Composer to add the <span class="SANS_TheSansMonoCd_W5Regular_11">math-php</span> package from the vendor <span class="SANS_TheSansMonoCd_W5Regular_11">markrogoyski</span> to our chapter project. This is a great package offering many useful mathematics operations. At the command line for the current project’s working directory, enter the following:</p>
<pre><code>$ <b>composer require markrogoyski/math-php</b></code></pre>
<p class="TX">This <span class="SANS_TheSansMonoCd_W5Regular_11">require</span> command triggers Composer to perform a series of actions. First, if you check your project’s <i>vendor</i> folder, you should see that Composer has created a new subfolder matching the package’s vendor name (in this case, <i>vendor/markrogoyski</i>). Inside, you’ll find a folder for the <span class="SANS_TheSansMonoCd_W5Regular_11">math-php</span> package, containing all the necessary code.</p>
<p class="TX">Keep in mind that the vendor name (<span class="SANS_TheSansMonoCd_W5Regular_11">markrogoyski</span>) and package name (<span class="SANS_TheSansMonoCd_W5Regular_11">math-php</span>) are <i>not</i> namespaces. They’re simply names that Composer uses to identify and locate the third-party scripts to be added to the project. Composer will automatically determine the namespaces for all the open source library classes, and so the contents of <i>vendor/composer</i> will be updated for all these classes that have been added to the <i>vendor</i> folder. In particular, <i>autoload_psr4.php</i> will likely be updated with the base directory for the namespaced third-party classes, since most open source libraries use the PSR-4 autoloading standard. Meanwhile, you’ll need to read the package’s documentation to find out the namespaces of the third-party classes so you can reference them correctly in your code.</p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">require</span> command also prompts Composer to update the <i>composer .json</i> file with information about the <span class="SANS_TheSansMonoCd_W5Regular_11">markrogoyski/math-php</span> package. If you check the file, you should now see something like <a href="#lis20-8">Listing 20-8</a>.</p>
<span id="lis20-8"/>
<pre><code>{&#13;
    "autoload": {&#13;
        "psr-4": {&#13;
            "Mattsmithdev\\": "src"&#13;
        }&#13;
    },&#13;
    "require": {&#13;
<span aria-label="392" epub:type="pagebreak" id="pg_392" role="doc-pagebreak"/>        "markrogoyski/math-php": "^2.10"&#13;
    }&#13;
}</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 20-8: The</span> <span class="SANS_Futura_Std_Book_11">composer.json</span> <span class="SANS_Futura_Std_Book_Oblique_11">file’s record of the</span> <span class="TheSansMonoCd_W5Regular_Italic_11">math-php</span> <span class="SANS_Futura_Std_Book_Oblique_11">library dependency</span></p>
<p class="TX">In addition to the <span class="SANS_TheSansMonoCd_W5Regular_11">"autoload"</span> property we wrote earlier, the main object in <i>composer.json</i> now has a <span class="SANS_TheSansMonoCd_W5Regular_11">"require"</span> property that Composer automatically generated. Its value is an object with entries for all the packages required for the project. In this case, there’s an entry of <span class="SANS_TheSansMonoCd_W5Regular_11">"markrogoyski/math-php"</span>. Its value, <span class="SANS_TheSansMonoCd_W5Regular_11">"^2.10"</span>, indicates the acceptable versions of the package. The caret symbol (<span class="SANS_TheSansMonoCd_W5Regular_11">^</span>) means we’re happy to use newer versions with the same main version number (2.10.1, 2.11, 2.2, and so on) but not version 3.<i>x</i> or later, since that might break backward compatibility.</p>
<p class="TX">Now that Composer has integrated the <span class="SANS_TheSansMonoCd_W5Regular_11">markrogoyski/math-php</span> package into our project, we can try using it. Specifically, we’ll draw on the package’s <span class="SANS_TheSansMonoCd_W5Regular_11">Average</span> class to compute the average of a series of numbers. Update the contents of <i>public/index.php</i> with the code in <a href="#lis20-9">Listing 20-9</a>.</p>
<span id="lis20-9"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">require_once __DIR__ . '/../vendor/autoload.php';</span>&#13;
&#13;
use MathPHP\Statistics\Average;&#13;
&#13;
$numbers = [13, 18, 13, 14, 13, 16, 14, 21, 13];&#13;
$numbersString = implode(', ', $numbers);&#13;
$mean = Average::mean($numbers);&#13;
print "average of [$numbersString] = $mean";</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 20-9: Calculating the average of an array of integers</span></p>
<p class="TX">We start with a <span class="SANS_TheSansMonoCd_W5Regular_11">use</span> statement telling the PHP engine that <span class="SANS_TheSansMonoCd_W5Regular_11">Average</span> refers to the namespaced class <span class="SANS_TheSansMonoCd_W5Regular_11">MathPHP\Statistics\Average</span>. Notice that the namespace for this class is different from the vendor and package name we used earlier in the <span class="SANS_TheSansMonoCd_W5Regular_11">require</span> statement to Composer. Then we declare a <span class="SANS_TheSansMonoCd_W5Regular_11">$numbers</span> array and use the built-in <span class="SANS_TheSansMonoCd_W5Regular_11">implode()</span> function to create a string version of it for user-friendly output. Next, we invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">mean()</span> method from the <span class="SANS_TheSansMonoCd_W5Regular_11">Average</span> class, storing the result in <span class="SANS_TheSansMonoCd_W5Regular_11">$mean</span>. We then print out the list of numbers and the calculated mean value.</p>
<p class="TX">Notice that we’ve invoked the <span class="SANS_TheSansMonoCd_W5Regular_11">mean()</span> method without actually having to create an object of the <span class="SANS_TheSansMonoCd_W5Regular_11">Average</span> class. This is because <span class="SANS_TheSansMonoCd_W5Regular_11">mean()</span> is a <i>static method</i>. We’ll explore this OOP concept in detail in <span class="Xref"><a href="chapter25.xhtml">Chapter 25</a></span>.</p>
</section>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h3 class="H1" id="sec10"><span id="toc-link_287"/><span class="SANS_Futura_Std_Bold_B_11">Where to Find PHP Libraries</span></h3>
<p class="TNI1">You may be wondering how the Composer tool knew where to go on the internet to download the <span class="SANS_TheSansMonoCd_W5Regular_11">markrogoyski/math-php</span> package files for our project. The answer is Packagist (<i><a href="https://packagist.org">https://packagist.org</a></i>), a website for publishing open source PHP packages. Vendors can register with the site (I’m <span class="SANS_TheSansMonoCd_W5Regular_11">mattsmithdev</span> <span aria-label="393" epub:type="pagebreak" id="pg_393" role="doc-pagebreak"/>on Packagist, for example) and then publish PHP packages for anyone to install via Composer.</p>
<p class="TX">When publishing a package, the vendor must provide information including the GitHub (or other repository) location of the package’s publicly downloadable files. For example, the Packagist page for the <span class="SANS_TheSansMonoCd_W5Regular_11">markrogoyski/math-php</span> package lists a GitHub address of <i><a href="https://github.com/markrogoyski/math-php">https://github.com/markrogoyski/math-php</a></i>. This is where Composer goes to get the package files. Each page on Packagist also lists the exact <span class="SANS_TheSansMonoCd_W5Regular_11">require</span> command you need in order to make Composer add that package to your project.</p>
</section>
<section aria-labelledby="sec11" epub:type="division">
<h3 class="H1" id="sec11"><span id="toc-link_288"/><span class="SANS_Futura_Std_Bold_B_11">Summary</span></h3>
<p class="TNI1">In this chapter, you learned to unambiguously differentiate between classes of the same name by using namespaces. You also learned to use the powerful Composer command line tool to support object-oriented PHP programming. The time spent learning how to maintain the <i>composer.json</i> file and how to use Composer to autoload classes and incorporate third-party libraries into your projects will save you countless hours of tedious manual work.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h3 class="H1" id="sec12"><span id="toc-link_289"/><span class="SANS_Futura_Std_Bold_B_11">Exercises</span></h3>
<p class="ListNumber">1.   Start a new project and create a Composer script alias for a command to display the message <span class="SANS_TheSansMonoCd_W5Regular_11">Hello</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">name</span>, replacing <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">name</span> with your name. Then use Composer to execute your command.</p>
<p class="ListBody">Hint: Declare a script alias in <i>composer.json</i>, then run it at the command line with <span class="SANS_TheSansMonoCd_W5Regular_11">composer</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">alias</span>.</p>
<p class="ListNumber">2.   Start a new project and create a <i>src/Product.php</i> file declaring a <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> class with the private properties <span class="SANS_TheSansMonoCd_W5Regular_11">$id</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">$description</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">$price</span>, and public getters and setters for each property. Declare the class to be in the <span class="SANS_TheSansMonoCd_W5Regular_11">Mattsmithdev</span> namespace. Add a <i>composer.json</i> file to the root folder of your project, declaring that classes in the <span class="SANS_TheSansMonoCd_W5Regular_11">Mattsmithdev</span> namespace can be found in the <i>src</i> directory. Then use Composer to generate an autoloader.</p>
<p class="ListBody">Write a <i>public/index.php</i> file that does the following:</p>
<p class="ListLetterSub">a.   Reads in and executes the Composer autoloader in <i>vendor/ autoload.php</i></p>
<p class="ListLetterSub">b.   Creates a new <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> object, <span class="SANS_TheSansMonoCd_W5Regular_11">$p1</span>, with an <span class="SANS_TheSansMonoCd_W5Regular_11">id</span> of <span class="SANS_TheSansMonoCd_W5Regular_11">7</span>, a <span class="SANS_TheSansMonoCd_W5Regular_11">description</span> of <span class="SANS_TheSansMonoCd_W5Regular_11">'hammer'</span>, and a <span class="SANS_TheSansMonoCd_W5Regular_11">price</span> of <span class="SANS_TheSansMonoCd_W5Regular_11">9.99</span></p>
<p class="ListLetterSub">c.   Uses <span class="SANS_TheSansMonoCd_W5Regular_11">var_dump()</span> to output the details of <span class="SANS_TheSansMonoCd_W5Regular_11">$p1</span></p>
<p class="ListBody">When you run your code, you should see something like this:</p>
<pre><code>object(Mattsmithdev\Product)#4 (3) {&#13;
  ["id":"Mattsmithdev\Product":private]=&gt;&#13;
  int(7)&#13;
  ["description":"Mattsmithdev\Product":private]=&gt;&#13;
  string(6) "hammer"&#13;
<span aria-label="394" epub:type="pagebreak" id="pg_394" role="doc-pagebreak"/>  ["price":"Mattsmithdev\Product":private]=&gt;&#13;
  float(9.99)&#13;
}</code></pre>
<p class="ListNumber">3.   Go to the Packagist website at <i><a href="https://packagist.org">https://packagist.org</a></i> and search for the <span class="SANS_TheSansMonoCd_W5Regular_11">mattsmithdev/faker-small-english</span> package. Look at the documentation, then use Composer to require the <span class="SANS_TheSansMonoCd_W5Regular_11">mattsmithdev/faker-small-english</span> package for a new project. Write a <i>public/index.php</i> file that loops 10 times to display 10 random names from a <span class="SANS_TheSansMonoCd_W5Regular_11">FakerSmallEnglish</span> object.</p>
</section>
</section>
</div></body></html>