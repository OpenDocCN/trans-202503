<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2" id="app04"><span epub:type="pagebreak" id="page_309"/><strong>D  More Invasive Attacks</strong></h2>&#13;
<h3 class="h3" id="app04_1"><strong>D.1 Atmega, AT90 Backside FIB</strong></h3>&#13;
<p class="noindent">Helfmeier et al. (2013) describes backside probing attacks against the Atmega328P and AT90SC3232. These two chips use the same AVR core, but the Atmega uses shallow trench isolation (STI) to separate transistors for preventing current leakage, while the AT90 has a security mesh across its top two metal layers.</p>&#13;
<p class="indent">In both chips, the authors were able to dig a trench through the backside of the IC to expose the fuse bits, then set or clear a fuse by tampering it with a focused ion beam (FIB). Changing the bits related to readout protection then allowed the chip to be read externally.</p>&#13;
<p class="indent">Fuse locations are documented in the paper, as well as notes about how the STI feature impacts the difficulty of the FIB trenching work. You can find the approximate fuse locations in <a href="app04.xhtml#chDfig1">Figure D.1</a>.</p>&#13;
<h3 class="h3" id="app04_2"><strong>D.2 GD32F130 QSPI Sniffing, Injection</strong></h3>&#13;
<p class="noindent">The GD32F103, GD32F130, and some other clones of the STM32 are dual-die devices with a flash memory die stacked on top of the CPU, connected by a QSPI bus. In <a href="app04.xhtml#chDfig2">Figure D.2</a>, you can see that the two dice are wire-bonded directly to one another. The little one on top is the memory chip, and the big one on the bottom is the CPU.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_310"/><img id="chDfig1" src="../images/f0310-01.jpg" alt="Image" width="777" height="768"/></div>&#13;
<p class="figcap">Figure D.1: Atmega328P Fuses from Helfmeier et al. (2013)</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_311"/><img id="chDfig2" src="../images/f0311-01.jpg" alt="Image" width="777" height="718"/></div>&#13;
<p class="figcap">Figure D.2: GD32F130 bonded to QSPI Flash</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_312"/>Obermaier, Schink, and Moczek (2020) documents sanding away the packaging to expose the bond wires connecting the two dice, sniffing the 4MHz bus traffic with a logic analyzer, reverse engineering some address and data scrambling, and then reconstructing the firmware image. Additionally, they were able to inject data faults into the bus to force a downgrade from RDP Level 2 to Level 1 by introducing a single bit error. A downgrade all the way to Level 0 can be caused by flipping two bits of the address.</p>&#13;
<h3 class="h3" id="app04_3"><strong>D.3 STM32 Ultraviolet Downgrade</strong></h3>&#13;
<p class="noindent">Most of Obermaier and Tatschner (2017) concerns a delightful bug in the JTAG debugging of the STM32F0 family from <a href="ch10.xhtml#ch10">Chapter 10</a>, which allows firmware to be extracted from RDP in Level 1 with a custom JTAG debugger. Many of these chips are locked in RDP Level 2, and the paper also considers ways to downgrade the chip using live decapsulation and ultraviolet light. Garb and Obermaier (2020) extends this, with concrete notes on the layout of flash memory for laser fault injection on the STM32F0 series.</p>&#13;
<p class="indent">To recap what’s explained in many different chapters of this book, RDP Level 0 is entirely unlocked and Level 2 is entirely locked, allowing no debugging. Level 1 is a middle ground, in which a debugger is allowed but attaching the debugger disables access to flash memory. Because debugger access can be so handy to an attacker, such as for placing shellcode or for exploiting loopholes in the protection, a downgrade from Level 2 is a very valuable thing to have.</p>&#13;
<p class="indent">The protection level is stored in option bytes as a pair of 16-bit words named <span class="literal">RDP</span> and <span class="literal">nRDP</span>. These words have a fixed value for Level 0 and a fixed value for Level 2, with <em>all</em> other values being Level 1. So while we need a very specific value to drop to Level 0, flipping any single bit is sufficient to drop to Level 1.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_313"/><img id="chDfig3" src="../images/f0313-01.jpg" alt="Image" width="545" height="551"/></div>&#13;
<p class="figcap">Figure D.3: STM32F051 Top Metal</p>&#13;
<div class="image"><img id="chDfig4" src="../images/f0313-02.jpg" alt="Image" width="778" height="473"/></div>&#13;
<p class="figcap">Figure D.4: STM32F051 Flash Layout</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_314"/>Knowing that ultraviolet light can raise flash memory bits from 0 to 1, Obermaier functionally decapsulated an STM32F051 and aimed UV-C light at it while repeatedly attempting to attach a debugger. After a few hours, the debugger connected and a single 0 bit of the <span class="literal">RDP</span>/<span class="literal">nRDP</span> option bytes had flipped to a 1. Unfortunately, other bits of memory had also flipped, so masking was necessary for an unlock with minimal damage to the rest of memory. As with the PIC16 in <a href="ch19.xhtml#ch19">Chapter 19</a>, the mask might be made by painting the die directly with nail polish.</p>&#13;
<p class="indent">The obvious solution to bit damage is to mask off memory, but first we need to know which physical region holds the option bytes. They filled all of flash memory in an unlocked chip with zeroes, then repeatedly re-read memory with a debugger as ultraviolet light spilled in past a plastic mask. In effect, this turned the chip into an image sensor, and all of the 1 bits indicated places of memory that were outside of the masked area.</p>&#13;
<p class="indent">This revealed that the flash memory of the STM32F051 in <a href="app04.xhtml#chDfig3">Figure D.3</a> has 1024-bit lines and 512-word lines, organized into 32-bit columns of 32-bit lines. Bit lines are perpendicular to the nearest edge of the chip, with the most significant bits on the left side and the least on the right side. The option bytes exist beneath wordline 0, with <span class="literal">RDP</span> and <span class="literal">nRDP</span> on the right half of the flash cell region, as they are the lower halves of 32-bit words. <a href="app04.xhtml#chDfig4">Figure D.4</a> shows an approximate layout of the flash bit columns and the RDP word location.</p>&#13;
<p class="indent">Their best solution was a moving plastic mask that would expose just the bottom right edge of the flash memory. This achieved a few unlocks with no damage to firmware and many unlocks with only a few hundred firmware bits damaged, and a bitwise <span class="literal">AND</span> of two damaged firmware images is often sufficient to make one clean accurate image.</p>&#13;
<h3 class="h3" id="app04_4"><span epub:type="pagebreak" id="page_315"/><strong>D.4 MT1335WE Kamikaze</strong></h3>&#13;
<p class="noindent">The MC13224 from <a href="ch14.xhtml#ch14">Chapter 14</a> isn’t the only system-in-package (SiP) that combines a CPU chip without non-volatile memory with a standard SPI flash chip.</p>&#13;
<p class="indent">MediaTek’s MT1335WE can be found in DVD-ROM drives for the XBox 360, where its firmware is responsible for distinguishing between commercial discs and DVD-R discs that are made by a consumer DVD burner. Pirates figured out that these could be patched to accept burned discs, <em>but only if</em> the SPI flash of the MT1335WE were rewritten with patched firmware. The complication is that the SPI flash chip is bonded internally to the MT1335WE’s package, so there are no external pins to tap or packages to replace.</p>&#13;
<p class="indent">Write protection is implemented through the chip’s !WP pin, just as if it were in a separate package. To bypass this control, we might tap the SPI flash chip’s !WP pin through its bond wire. This is described in sQuallen (2012), which cites Geremia and Carranzaf as collaborating on the discovery.</p>&#13;
<p class="indent">The idea is that the bond wires shown in <a href="app04.xhtml#chDfig6">Figure D.6</a> are consistently placed the same across chips, even if the silk-screen labeling drifts a bit. It’s therefore possible to accurately hit a bond wire with a drill using the positioning shown in <a href="app04.xhtml#chDfig5">Figure D.5</a>, knowing that the bit will eventually collide with the bond wire. If you look closely at the second bond wire on the right side of the SPI flash, you’ll see that it has been cleanly cut in half by the drill.</p>&#13;
<p class="indent">To perform the unlock, the drill bit is loosely attached through a pull-up resistor to the 3.3V pin. Early instructions suggested drawing a line over the package five pins from the east side and eight pins down from the north side, which is usually just southeast of the letter K in “Mediatek.” Later kits used a flex PCB as a stencil, with a small hold to place the drill bit.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_316"/><img id="chDfig5" src="../images/f0316-01.jpg" alt="Image" width="475" height="443"/></div>&#13;
<p class="figcap">Figure D.5: MT1335WE Drilling Point</p>&#13;
<div class="image"><img id="chDfig6" src="../images/f0316-02.jpg" alt="Image" width="777" height="586"/></div>&#13;
<p class="figcap">Figure D.6: MT1335WE Bond Wires</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_317"/>Slowly spinning the bit without much pressure will dig through the packaging until the bond wire is reached, while in the background a PC repeatedly attempts to rewrite the SPI flash contents. This process fails at first, of course, because the drill hasn’t yet pulled the !WP line high, but eventually the drill reaches the wire and the SPI flash is unlocked!</p>&#13;
<p class="indent">sQuallen also mentions an attack with the piezo-electric spark of a grill lighter placed near the bond wire. As best I can tell, this is not to perform the initial unlock but to sort of “drift” the high-impedance input pin back to a high-voltage state. That allows a reprogramming after the bond wire is cut, but without further drilling.</p>&#13;
<h3 class="h3" id="app04_5"><strong>D.5 Xilinx XCKU040 Backside Laser Injection</strong></h3>&#13;
<p class="noindent">Lohrke et al. (2018) describes an infrared laser stimulation attack against the flip-chip packaged Xilinx XCKU040-1FBVA676, an FPGA with encrypted bitstreams.</p>&#13;
<p class="indent">This 20 nm chip has its backside exposed on the package, and the substrate of the chip is transparent to infrared light. This means that photography of the chip die can be performed from <em>outside</em> the package, <em>non-invasively</em>! See Huang (2022) for an equipment list if you’d like to make your own backside photographs without decapsulation.</p>&#13;
<p class="indent">The XCKU040 is an FPGA whose bitstream is loaded at boot time from an external memory chip. To protect this bitstream from duplication or reverse engineering, it’s encrypted with a key that is held either in battery-backed SRAM (BBRAM) or in eFuses. BBRAM has the disadvantage of requiring a backup battery, but it offers some extra security in that invasive attacks <span epub:type="pagebreak" id="page_318"/> that break the backup power supply will also destroy the key, preventing its recovery.</p>&#13;
<p class="indent">So, realizing that the silicon backside is exposed and transparent to infrared light, Lohrke used an infrared laser to strike SRAM cells in the battery-backed region, graphing the power consumption at each point. Sure enough, CMOS power leakage highlighted each bit cell in one orientation for a 1 and the opposite orientation for a 0, revealing the key!</p>&#13;
</div>
</div>
</body></html>