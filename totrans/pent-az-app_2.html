<html><head></head><body>
<h2 class="h2b" id="ch03"><span epub:type="pagebreak" id="page_35" class="calibre1"/><strong class="calibre2"><span class="big">3</span></strong><br class="calibre9"/><strong class="calibre2">RECONNAISSANCE</strong></h2>
<div class="image"><img src="../images/00015.jpeg" alt="image" class="calibre3"/></div>
<p class="noindent">In this chapter, I show you how to search subscriptions for useful data, such as what storage accounts it uses, its SQL databases, the virtual machines it contains, and any network firewalls in place.</p>
<p class="indent">Like other large cloud service providers, Azure offers a growing list of services, ranging from web hosting to databases, secret key storage, and machine learning. With so many offerings, it can be hard to determine which services and features a given customer is taking advantage of, and if any of them are configured in a vulnerable way.</p>
<p class="indent">In this chapter, I will demonstrate how Azure’s PowerShell cmdlets and command line tools can be used to quickly examine the contents of a subscription. We start by authenticating to Azure in the console. Next, we enumerate a subscription’s web services, followed by its virtual machines. We then get a list of the subscription’s storage accounts and their access keys, followed by any internet-facing network ports and firewalls. Then we look at SQL servers and databases.</p>
<p class="indent">By enumerating these services, you’ll be able to include all of your client’s resources in your pentest, ensuring that nothing is overlooked. <span epub:type="pagebreak" id="page_36"/>This is crucial because when requesting an assessment, customers may focus on production services but forget to mention test resources where security controls may be lax. Similarly, documenting the contents of storage accounts can help clients determine if they are following proper data classification and storage practices.</p>
<p class="indent">After reviewing some powerful individual commands for commonly used Azure services, I present scripts that are ideal for scanning any new subscription you compromise.</p>
<h3 class="h1" id="lev47"><strong class="calibre2">Installing PowerShell and the Azure PowerShell Module</strong></h3>
<p class="noindent">Before you begin, you need to install a few free tools from Microsoft. On Windows, PowerShell and the Azure PowerShell module are the most straightforward tools for gathering subscription information. Another option are the Azure Command Line Interface (CLI) tools, which are offered for Windows, Linux, and macOS.</p>
<h4 class="h2" id="lev48"><strong class="calibre2"><em class="calibre10">On Windows</em></strong></h4>
<p class="noindent">You have two ways to install these tools on Windows. If you’d like both the PowerShell cmdlets and the command line interface, along with the ability to update the tools whenever new versions are released, use the Microsoft Web Platform Installer (WebPI). This small package manager makes it easy to install a number of Microsoft tools, including those used to manage Azure. WebPI also checks for missing dependencies, so if you don’t already have PowerShell installed, it will take care of that for you.</p>
<p class="indent">To use WebPI, simply download the installer from <em class="calibre7"><a href="https://www.microsoft.com/web/downloads/platform.aspx" class="calibre6">https://www.microsoft.com/web/downloads/platform.aspx</a></em> and run it. Once it’s installed, search for Web Platform Installer in the Start menu and launch the application.</p>
<p class="indent">You can use WebPI’s search box to find Microsoft Azure PowerShell and Microsoft Azure Cross-platform Command Line Tools (see <a href="part0012.html#ch03fig1" class="calibre6">Figure 3-1</a>). Then click <strong class="calibre4">Add</strong> to download and install the tools. If multiple versions of a tool are returned, choose the most recent release. (You can launch WebPI again to check for updates to the packages.)</p>
<p class="indent">After running the installer, close any open PowerShell and command line windows to be sure that the tools are recognized.</p>
<h4 class="h2" id="lev49"><strong class="calibre2"><em class="calibre10">On Linux or macOS</em></strong></h4>
<p class="noindent">If you are running Linux or macOS, you’ll need to install the Azure Command Line Cross-platform Tools package. There are two versions of this package—one written in Node.js and one in Python. I use the Node.js versions in my examples, but both versions use similar syntax, so feel free to use either one. You’ll find installer packages for the Node.js version in DMG format for macOS and TAR format for Linux at <em class="calibre7"><a href="https://github.com/azure/azure-xplat-cli/" class="calibre6">https://github.com/azure/azure-xplat-cli/</a></em>. The Python version can be downloaded from <em class="calibre7"><a href="https://github.com/azure/azure-cli/" class="calibre6">https://github.com/azure/azure-cli/</a></em>. Install these as you would any other package on your platform.</p>
<div class="image1"><span epub:type="pagebreak" id="page_37"/><a id="ch03fig1" class="calibre6"/><img src="../images/00019.jpeg" alt="image" class="calibre3"/></div>
<p class="figcap"><em class="calibre7">Figure 3-1: Using Microsoft’s Web Platform Installer to locate and install Azure tools</em></p>
<h4 class="h2" id="lev50"><strong class="calibre2"><em class="calibre10">Running Your Tools</em></strong></h4>
<p class="noindent">Once you’ve installed your tools, launch them. For the PowerShell module, open a PowerShell window and at the prompt, run <span class="codestrong">Import-Module Azure</span>. For the command line tools, open a terminal window and enter <span class="codestrong">azure</span> (or <span class="codestrong">az</span> if using the Python version). If the command line tools are properly installed, you should see a help message like the one shown in <a href="part0012.html#ch03fig2" class="calibre6">Figure 3-2</a>.</p>
<div class="image1"><a id="ch03fig2" class="calibre6"/><img src="../images/00020.jpeg" alt="image" class="calibre3"/></div>
<p class="figcap"><em class="calibre7">Figure 3-2: The help message for the Azure command line tools</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_38"/>At this point, you should have everything you need to begin connecting to Azure. Let’s start gathering information about our target subscriptions and their services.</p>
<h3 class="h1" id="lev51"><strong class="calibre2">Service Models</strong></h3>
<p class="noindent">Recall from <a href="part0011.html#ch02" class="calibre6">Chapter 2</a> that Microsoft uses two different service models in Azure, each with its own set of commands to view or change services. For every service discussed in this chapter, I provide the syntax for querying both Azure Resource Manager (ARM) and Azure Service Management (ASM), unless a service is exclusive to just one model.</p>
<p class="indent">The PowerShell module includes both ARM and ASM cmdlets. To help keep things organized, commands for ASM services are typically named <em class="calibre7">Verb</em>-Azure<em class="calibre7">Noun</em>, such as <span class="literal">Get-AzureVM</span>, whereas ARM commands are <em class="calibre7">Verb</em>-Azure<strong class="calibre4">Rm</strong><em class="calibre7">Noun</em>, such as <span class="literal">Get-AzureRmVM</span>.</p>
<p class="indent">The command line tools take a different approach. Instead of using different commands for each service model, you can place the <span class="literal">azure</span> executable into either ARM or ASM mode, and it will stay in that state until the mode is switched.</p>
<p class="indent">To determine the currently selected mode, view the last line of output when <span class="literal">azure</span> is run with no other options. To switch modes, run <span class="codestrong">azure config mode asm</span> to target the ASM model or run <span class="codestrong">azure config mode arm</span> to target the ARM model. <a href="part0012.html#ch03list1" class="calibre6">Listing 3-1</a> shows the output of Azure CLI when switching modes, as well as the last line of the Azure command to confirm the current mode.</p>
<p class="programs">C:\&gt;<span class="codestrong1">azure config mode asm</span><br class="calibre5"/>info:    Executing command config mode<br class="calibre5"/>info:    New mode is asm<br class="calibre5"/>info:    config mode command OK<br class="calibre5"/><br class="calibre5"/>C:\&gt;<span class="codestrong1">azure</span><br class="calibre5"/>--<span class="codeitalic">snip</span>--<br class="calibre5"/>help:    Current Mode: asm (Azure Service Management)<br class="calibre5"/><br class="calibre5"/>C:\&gt;<span class="codestrong1">azure config mode arm</span><br class="calibre5"/>info:    Executing command config mode<br class="calibre5"/>info:    New mode is arm<br class="calibre5"/>info:    config mode command OK<br class="calibre5"/><br class="calibre5"/>C:\&gt;<span class="codestrong1">azure</span><br class="calibre5"/>--<span class="codeitalic">snip</span>--<br class="calibre5"/>help:    Current Mode: arm (Azure Resource Management)</p>
<p class="listing" id="ch03list1"><em class="calibre7">Listing 3-1: Switching and verifying modes in Azure CLI</em></p>
<h3 class="h1" id="lev52"><span epub:type="pagebreak" id="page_39" class="calibre1"/><strong class="calibre2">Best Practices: PowerShell Security</strong></h3>
<p class="noindent">Since its official release in 2006, PowerShell has grown in popularity, capability, and maturity. Originally a scripting language to perform basic Windows management, PowerShell is now the de facto way to manage a wide variety of Microsoft products and services, which of course includes Azure. Because it offers so many features, PowerShell has also been attractive for hackers. As a system administrator or defender, you need to be aware of a number of settings to ensure that PowerShell remains secure on your systems. As we’ve already seen, a compromised workstation could lead to Azure subscription access, so securing endpoints is important!</p>
<p class="indent">First, enable PowerShell logging, and make sure this data is forwarded to your security auditing solution. Not only will this increase the speed of detecting an attacker leveraging PowerShell in your environment, it will give the defenders a clear picture of what actions were taken by the attacker. Forwarding events also makes it harder for an attacker to tamper with event logs.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre7">Microsoft’s Lee Holmes published an excellent article on all the ways in which the PowerShell team has engineered blue team capabilities into PowerShell. You can find it at</em> <a href="https://blogs.msdn.microsoft.com/powershell/2015/06/09/powershell-the-blue-team/" class="calibre6">https://blogs.msdn.microsoft.com/powershell/2015/06/09/powershell-the-blue-team/</a><em class="calibre7">.</em></p>
</div>
<p class="indent">Second, be aware that PowerShell supports remote sessions and remote command execution, using the WS-Management protocol on TCP ports 5985 and 5986. Additionally, now that PowerShell has been ported to Linux, remote PowerShell commands can also be executed over SSH (TCP port 22). PowerShell remoting is typically enabled by default on Windows Server installations but disabled on workstations. All forms of PowerShell remoting require authentication, and usually an account with membership in the administrators group is required to connect. Although remote PowerShell makes management of large quantities of remote systems easier, it can also lead to illegitimate access if administrator accounts aren’t closely guarded or if remoting permissions are made too broad. A discussion of PowerShell remoting security can be found at <em class="calibre7"><a href="https://docs.microsoft.com/en-us/powershell/scripting/setup/winrmsecurity/" class="calibre6">https://docs.microsoft.com/en-us/powershell/scripting/setup/winrmsecurity/</a></em>.</p>
<p class="indent">Finally, consider using PowerShell security features such as constrained language mode. When in use, constrained language mode greatly reduces the ability to arbitrarily run some of the more powerful operations in PowerShell, without impairing the ability to run properly signed scripts. This way, if an attacker does gain access to a PowerShell session on a system, they won’t be able to utilize many of the tools or scripts they’d like to run. A great introduction to constrained language mode is available at <em class="calibre7"><a href="https://blogs.msdn.microsoft.com/powershell/2017/11/02/powershell-constrained-language-mode/" class="calibre6">https://blogs.msdn.microsoft.com/powershell/2017/11/02/powershell-constrained-language-mode/</a></em>.</p>
<h3 class="h1" id="lev53"><span epub:type="pagebreak" id="page_40" class="calibre1"/><strong class="calibre2">Authenticating with the PowerShell Module and CLI</strong></h3>
<p class="noindent">To gather details about any services in Azure, you first need to authenticate. The authentication process varies depending on the type of credential (username and password, service principal, or management certificate), the service model, and the tool being used (Azure CLI or PowerShell). <a href="part0012.html#ch03tab1" class="calibre6">Table 3-1</a> shows, for each credential type, which service model/tool pairs you can use to authenticate. Note that not every combination of these options is possible.</p>
<p class="tabcap" id="ch03tab1"><strong class="calibre4">Table 3-1:</strong> Supported Authentication Methods by Service Model and Tool</p>
<table class="topbot-d">
<thead class="calibre12">
<tr class="calibre13">
<td class="table-h"><p class="tab_th"><strong class="calibre4">Tool/interface</strong></p></td>
<td class="table-h"><p class="tab_th"><strong class="calibre4">Username and password</strong></p></td>
<td class="table-h"><p class="tab_th"><strong class="calibre4">Management certificate</strong></p></td>
<td class="table-h"><p class="tab_th"><strong class="calibre4">Service principal with password</strong></p></td>
<td class="table-h"><p class="tab_th"><strong class="calibre4">Service principal with certificate</strong></p></td>
</tr>
</thead>
<tbody class="calibre14">
<tr class="calibre13">
<td class="table-a"><p class="taba">Azure CLI – ASM mode</p></td>
<td class="table-a"><p class="taba">Supported</p></td>
<td class="table-a"><p class="taba">Partially supported</p></td>
<td class="table-a"><p class="taba">Not supported</p></td>
<td class="table-a"><p class="taba">Not supported</p></td>
</tr>
<tr class="calibre13">
<td class="table-b"><p class="taba">Azure CLI – ARM mode</p></td>
<td class="table-b"><p class="taba">Supported</p></td>
<td class="table-b"><p class="taba">Not supported</p></td>
<td class="table-b"><p class="taba">Supported</p></td>
<td class="table-b"><p class="taba">Supported</p></td>
</tr>
<tr class="calibre13">
<td class="table-a"><p class="taba">Azure PowerShell ASM cmdlets</p></td>
<td class="table-a"><p class="taba">Supported</p></td>
<td class="table-a"><p class="taba">Supported</p></td>
<td class="table-a"><p class="taba">Not supported</p></td>
<td class="table-a"><p class="taba">Not supported</p></td>
</tr>
<tr class="calibre13">
<td class="table-b"><p class="taba">Azure PowerShell ARM cmdlets</p></td>
<td class="table-b"><p class="taba">Supported</p></td>
<td class="table-b"><p class="taba">Not supported</p></td>
<td class="table-b"><p class="taba">Supported</p></td>
<td class="table-b"><p class="taba">Supported</p></td>
</tr>
<tr class="calibre13">
<td class="table-a"><p class="taba"><em class="calibre7"><a href="http://portal.azure.com/" class="calibre15">http://portal.azure.com/</a></em></p></td>
<td class="table-a"><p class="taba">Supported</p></td>
<td class="table-a"><p class="taba">Not supported</p></td>
<td class="table-a"><p class="taba">Not supported</p></td>
<td class="table-a"><p class="taba">Not supported</p></td>
</tr>
<tr class="calibre13">
<td class="table-ba"><p class="taba"><em class="calibre7"><a href="http://manage.windowsazure.com/" class="calibre6">http://manage.windowsazure.com/</a></em></p></td>
<td class="table-ba"><p class="taba">Supported</p></td>
<td class="table-ba"><p class="taba">Not supported</p></td>
<td class="table-ba"><p class="taba">Not supported</p></td>
<td class="table-ba"><p class="taba">Not supported</p></td>
</tr>
</tbody>
</table>
<p class="indent">As you can see, a username and password pair is accepted by each Azure management interface. Authenticating with a username and password pair has a few other advantages as well. For one, once authenticated, you probably won’t need to know what subscriptions a given user has access to, because you can use their password to sign in to either of the Azure web interfaces to see a list of their subscriptions. In contrast, the command line interfaces expect you to specify the target subscription when executing a command.</p>
<p class="indent">Usernames and passwords are easier to use than management certificates and service principals. Each tool will present a login prompt that accepts a password. If the user doesn’t have multi-factor authentication enabled, you’re good to go. Authentication with management certificates or service principals might require a series of commands. Let’s take a look at how to authenticate with them.</p>
<h3 class="h1" id="lev54"><strong class="calibre2">Authenticating with Management Certificates</strong></h3>
<p class="noindent">When authenticating with management certificates, you need to know the subscription ID you plan to target. As you know from the scoping discussion in <a href="part0010.html#ch01" class="calibre6">Chapter 1</a>, this shouldn’t be a problem.</p>
<p class="indent">Of course, your certificate needs to be in the management certificate list for the target subscription for authentication to succeed. The best way to determine where a given certificate can be used is through educated <span epub:type="pagebreak" id="page_41"/>guessing and trial and error. In other words, if a certificate came from a developer’s machine who owns one subscription, or if the certificate is checked into a code repository for a service that you know runs in your target subscription, there’s a very good chance it will work. Luckily, trying a certificate and finding it doesn’t work doesn’t really have a downside. Although the failed connection attempt may be logged somewhere, I’ve yet to encounter such a log, and in practice, no subscription owner has ever detected my attempts to penetrate their subscription because I tried the wrong certificate.</p>
<h4 class="h2" id="lev55"><strong class="calibre2"><em class="calibre10">Installing the Certificate</em></strong></h4>
<p class="noindent">In order to use the certificate, you first need to install it into your computer’s certificate store. To do so, double-click the certificate file and walk through the wizard. The certificate location doesn’t matter, but if you choose to place it in the Local Machine store, you need to run subsequent commands with administrative (User Account Control–elevated) rights.</p>
<h4 class="h2" id="lev56"><strong class="calibre2"><em class="calibre10">Authenticating</em></strong></h4>
<p class="noindent">The PowerShell script shown in <a href="part0012.html#ch03list2" class="calibre6">Listing 3-2</a> authenticates to a subscription using a certificate. This allows you to run subsequent commands against the subscription, using this certificate as your credential.</p>
<p class="programs"><span class="ent">➊</span> PS C:\&gt; <span class="codestrong1">$storeName = "My"</span><br class="calibre5"/><span class="ent">➋</span> PS C:\&gt; <span class="codestrong1">$storeLocation = "LocalMachine"</span><br class="calibre5"/><span class="ent">➌</span> PS C:\&gt; <span class="codestrong1">$certs = Get-ChildItem Cert:\$storeLocation\$storeName</span><br class="calibre5"/><span class="ent">➍</span> PS C:\&gt; <span class="codestrong1">$certs</span><br class="calibre5"/>   Thumbprint                                Subject<br class="calibre5"/>   ----------                                -------<br class="calibre5"/>   8D94450FB8C24B89BA04E917588766C61F1981D3  CN=AzureCert<br class="calibre5"/><br class="calibre5"/><span class="ent">➎</span> PS C:\&gt; <span class="codestrong1">$</span> <span class="codestrong1">azureCert = Get-Item Cert:\$storeLocation\$storeName\</span><br class="calibre5"/>       <span class="codestrong1">8D94450FB8C24B89BA04E917588766C61F1981D3</span><br class="calibre5"/><span class="ent">➏</span> PS C:\&gt; <span class="codestrong1">$azureCert</span><br class="calibre5"/>   Thumbprint                                Subject<br class="calibre5"/>   ----------                                -------<br class="calibre5"/>   8D94450FB8C24B89BA04E917588766C61F1981D3  CN=AzureCert<br class="calibre5"/><br class="calibre5"/><span class="ent">➐</span> PS C:\&gt; <span class="codestrong1">$azureCert.HasPrivateKey</span><br class="calibre5"/>   True<br class="calibre5"/><br class="calibre5"/><span class="ent">➑</span> PS C:\&gt; <span class="codestrong1">Set-AzureSubscription -SubscriptionName 'Target' -SubscriptionId</span><br class="calibre5"/>       <span class="codestrongitalic">Subscription_ID</span> <span class="codestrong1">-Certificate $azureCert</span><br class="calibre5"/>   PS C:\&gt; <span class="codestrong1">Select-AzureSubscription -SubscriptionName 'Target'</span><br class="calibre5"/><br class="calibre5"/><span class="ent">➒</span> PS C:\&gt; <span class="codestrong1">Get-AzureAccount</span><br class="calibre5"/>   Id                                         Type Subscriptions<br class="calibre5"/>   --                                         ---- -------------<br class="calibre5"/>   8D94450FB8C24B89BA04E91758...       Certificate <span class="codeitalic">Subscription_IDs</span></p>
<p class="listing" id="ch03list2"><em class="calibre7">Listing 3-2: Authenticating to Azure using management certificates in PowerShell</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_42"/>Here’s what’s happening in <a href="part0012.html#ch03list2" class="calibre6">Listing 3-2</a>, step by step:</p>
<ol class="calibre16">
<li class="noindent1" value="1">To authenticate with a management certificate, we need to retrieve it from the certificate store. We first specify that the certificate is installed in the <em class="calibre7">Personal</em> directory (<em class="calibre7">My</em>) <span class="ent">➊</span>, within the <span class="literal">LocalMachine</span> store <span class="ent">➋</span> (as opposed to the <span class="literal">CurrentUser</span> store). If you installed it elsewhere, be sure to use the programmatic name for that location, which you can find on Microsoft’s website at <em class="calibre7"><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa388136(v=vs.85).aspx" class="calibre6">https://msdn.microsoft.com/en-us/library/windows/desktop/aa388136(v=vs.85).aspx</a></em>.</li>
<li class="noindent1" value="2">We then request a list of certificates in that location and place it into the variable <span class="literal">$certs</span> <span class="ent">➌</span>.</li>
<li class="noindent1" value="3">To see the list of certificates available, we execute the variable as a command <span class="ent">➍</span>. The output tells us that the only certificate installed is <em class="calibre7">AzureCert</em>, and it lists the certificate’s <em class="calibre7">thumbprint</em> as well (“8D9 . . . 1D3”). The thumbprint uniquely identifies a certificate.</li>
<li class="noindent1" value="4">Next, we get a reference to the certificate object with the <span class="literal">Get-Item</span> cmdlet, using the thumbprint to select the correct certificate <span class="ent">➎</span>.</li>
<li class="noindent1" value="5">To see if you have a usable certificate, issue the certificate variable name as a command to ensure that a certificate was retrieved, as shown at <span class="ent">➏</span>. If you see an empty response, something went wrong with the <span class="literal">Get-Item</span> command and you should double-check that you entered the values at <span class="ent">➎</span> correctly.</li>
<li class="noindent1" value="6">Finally, we see if the certificate we’ve found has the associated private key with <span class="literal">HasPrivateKey</span> <span class="ent">➐</span>. Without the private key, you won’t be able to use it to connect to the subscription.</li>
</ol>
<h4 class="h2" id="lev57"><strong class="calibre2"><em class="calibre10">Connecting and Validating Access</em></strong></h4>
<p class="noindent">With the certificate ready to use, try to connect to the subscription. You can do so by using two commands: <span class="literal">Set-AzureSubscription</span> followed by <span class="literal">Select-AzureSubscription</span>. In the former command, you specify the name of the subscription, subscription ID, and the certificate variable <span class="ent">➑</span>. If you don’t know the name of the subscription, just make something up. Now, because you may have access to numerous subscriptions, use the <span class="literal">Select-AzureSubscription</span> cmdlet to specify the subscription that PowerShell should run subsequent commands against. Note that the name here must match the one specified in the set command.</p>
<p class="indent">At this point, if the certificate was valid for that subscription, you should have access. To confirm, run <span class="codestrong">Get-AzureAccount</span> <span class="ent">➒</span>. If the subscription is listed, you should now be able to run any other Azure ASM commands against the subscription to view and interact with its ASM resources.</p>
<p class="indent">Azure CLI technically supports management certificates in its ASM mode, but it fails in practice to properly load certificates. The workaround is to use a <em class="calibre7">.publishsettings</em> file instead of a certificate.</p>
<p class="indent"><span epub:type="pagebreak" id="page_43"/>Because <em class="calibre7">.publishsettings</em> files are just XML documents embedded with base64-encoded management certificates and subscription IDs (as discussed in <a href="part0011.html#ch02" class="calibre6">Chapter 2</a>), you can manually create one given the certificate and subscription ID. The steps to do so are a bit lengthy; fortunately, software developer and Microsoft MVP Gaurav Mantri has posted sample code to automate the process: <em class="calibre7"><a href="http://gauravmantri.com/2012/09/14/about-windows-azure-publish-settings-file-and-how-to-create-your-own-publish-settings-file/" class="calibre6">http://gauravmantri.com/2012/09/14/about-windows-azure-publish-settings-file-and-how-to-create-your-own-publish-settings-file/</a></em>.</p>
<p class="indent">Once you have a <em class="calibre7">.publishsettings</em> file, run the following to add the credential to Azure CLI:</p>
<p class="programs">C:\&gt;<span class="codestrong1">azure account import "</span><span class="codestrongitalic">Path_to_.publishsettings_File</span><span class="codestrong1">"</span></p>
<p class="indent">Next, run a command to verify that the credential works, such as <span class="literal">azure vm list</span>. If you see the error <span class="literal">We don't have a valid access token</span>, the credential did not work. Upon successful authentication, you should see <span class="literal">info: vm list command OK</span>, even if the subscription contains no virtual machines.</p>
<h3 class="h1" id="lev58"><strong class="calibre2">Best Practices: Service Principals</strong></h3>
<p class="noindent">Service principals replace management certificates as the preferred way for apps, scripts, and services to programmatically access and manage Azure resources. There are several security advantages to using service principals over management certificates.</p>
<p class="indent">The most notable improvement with service principals is their ability to have a limited scope of permissions. By default, a service principal is created for use with a single application and can be granted the specific rights it needs to perform its function. Following the principle of least privilege, test which rights are actually needed for your application; don’t just give it access to everything, as this would allow an attacker to wreak havoc if the service principal was compromised.</p>
<p class="indent">Also, service principals can be created with either a long, automatically generated password (referred to as its <em class="calibre7">client secret</em>) or a certificate for authentication. When you create a service principal with a password, the client secret value is displayed only once, and you cannot view it again after navigating away from that page in the portal. (It can be regenerated if needed, though.) As such, the page encourages you to record the value. Be sure that this value is stored in a secure place, such as Key Vault or a password manager. Avoid storing it in a source control repository, as this makes it hard to control or track who has access as well as who has viewed it, and it’s difficult to remove from version history. Secrets stored in source code are a common source of breaches. Likewise, never store such secrets in a plaintext file, even temporarily.</p>
<p class="indent">Lastly, be sure to document the purpose of all service principals you create and periodically review the service principals with permissions to your resources. As applications are retired, it’s easy to forget to remove old service principals; cleaning up old accounts reduces the attack surface of the subscription and its resources.</p>
<h3 class="h1" id="lev59"><span epub:type="pagebreak" id="page_44" class="calibre1"/><strong class="calibre2">Authenticating with Service Principals</strong></h3>
<p class="noindent">Recall from <a href="part0011.html#ch02" class="calibre6">Chapter 2</a> that service principals are the Azure-based equivalent of service accounts found in most companies’ domains. Just as in on-premises environments, these accounts are used when a service needs to run regularly—that is, independent of a particular administrator’s account.</p>
<p class="indent">Azure provides two authentication options for these accounts: passwords and certificates. However, service principals are more restrictive than regular accounts or management certificates. Because service principals are tied to a particular application, they usually only have rights to what that application needs to access. Additionally, service principals check for password expiration or certificate validity (depending on the authentication method you use), so a captured credential can’t be used indefinitely.</p>
<div class="sidebar">
<p class="sidebart"><strong class="calibre4">DEFENDER’S TIP</strong></p>
<p class="spara">Because service principals can’t use multi-factor authentication, they may pose a greater risk than standard user accounts that use a second factor during authentication. Although service principals do have long, auto-generated passwords or strong certificate-based keys, which help to mitigate the risk of brute-forcing and password-guessing attacks, to be safe, you should make sure your service principals only have the minimum amount of privileges needed to perform their duties. Additionally, it’s far better to use several service principals, each dedicated to performing a specific task with a small set of rights, than to have one service principal with full control over everything in a subscription. Sure, the initial setup will be a bit more complex, but the security benefits are worth it.</p>
</div>
<h4 class="h2" id="lev60"><strong class="calibre2"><em class="calibre10">Using Service Principals with Passwords</em></strong></h4>
<p class="noindent">To connect as a service principal with a password, you’ll need the service principal’s GUID (usually referred to as a client ID or application ID), its password (also called a <em class="calibre7">key</em> in the Azure portal), and the tenant ID of the Azure Active Directory instance where that service principal is defined (another GUID). You’ll most likely find the tenant ID where you discovered the client ID and password, since any program using the service principal would also need this value. Once you have these values, you should be able to authenticate in PowerShell or Azure CLI, as discussed next.</p>
<h5 class="h3" id="lev61"><strong class="calibre2">PowerShell</strong></h5>
<p class="noindent">In PowerShell, run the following commands:</p>
<p class="programs"><span class="ent">➊</span> PS C:\&gt; <span class="codestrong1">$key = Get-Credential</span><br class="calibre5"/><span class="ent">➋</span> PS C:\&gt; <span class="codestrong1">$tenant =</span> <span class="codestrongitalic">Tenant_ID</span><br class="calibre5"/><span class="ent">➌</span> PS C:\&gt; <span class="codestrong1">Add-AzureRmAccount</span> <span class="codestrong1">-Credential $key -ServicePrincipal -TenantId $tenant</span><br class="calibre5"/><br class="calibre5"/>   <span epub:type="pagebreak" id="page_45"/>Environment           : AzureCloud<br class="calibre5"/>   Account               : <span class="codeitalic">Service_Principal_ID</span><br class="calibre5"/>   TenantId              : <span class="codeitalic">Tenant_ID</span><br class="calibre5"/>   SubscriptionId        :<br class="calibre5"/>   SubscriptionName      :<br class="calibre5"/>   CurrentStorageAccount :</p>
<p class="indent">The <span class="literal">Get-Credential</span> cmdlet should open a dialog with space for you to enter a username and password. Enter the application ID value as the username and the key as the password <span class="ent">➊</span>. On the next line, save the tenant ID as a variable <span class="ent">➋</span> and then pass both values into <span class="literal">Add-AzureRmAccount</span> <span class="ent">➌</span>. If you have it, you can also specify a subscription using the <span class="literal">-SubscriptionID</span> parameter of <span class="literal">Add-AzureRmAccount</span>, though this will return an error if the service principal doesn’t have rights to any resources in the subscription.</p>
<h5 class="h3" id="lev62"><strong class="calibre2">Azure CLI</strong></h5>
<p class="noindent">To authenticate in Azure CLI with a password-based service principal, make sure Azure CLI is in ARM mode and then run the following command:</p>
<p class="programs">C:\&gt;<span class="codestrong1">azure login --service-principal --username "</span><span class="codestrongitalic">Client_ID</span><span class="codestrong1">"</span><br class="calibre5"/>    <span class="codestrong1">--password "</span><span class="codestrongitalic">Key</span><span class="codestrong1">" --tenant "</span><span class="codestrongitalic">Tenant_ID</span><span class="codestrong1">"</span></p>
<p class="indent">This command will not display any output, so use <span class="codestrong">azure resource list</span> to see if it worked and to show existing resources. If the credential doesn’t work, it should display an error.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre7">Generally, I surround argument values passed in to various commands with double quotes, such as the username and password values here. This isn’t required if the input provided doesn’t contain spaces; however, because Azure allows spaces in many of its fields, such as service names, it’s safer to assume that the input has a space and to wrap it in double quotes.</em></p>
</div>
<h4 class="h2" id="lev63"><strong class="calibre2"><em class="calibre10">Authenticating with X.509 Certificates</em></strong></h4>
<p class="noindent">Service principals can also be authenticated with X.509 certificates. To do this in PowerShell, run the following commands:</p>
<p class="programs"><span class="ent">➊</span> PS C:\&gt; <span class="codestrong1">$thumbprint =</span> <span class="codestrongitalic">Certificate_Thumbprint</span><br class="calibre5"/><span class="ent">➋</span> PS C:\&gt; <span class="codestrong1">$appId =</span> <span class="codestrongitalic">Service_Principal_ID</span><br class="calibre5"/><span class="ent">➌</span> PS C:\&gt; <span class="codestrong1">$tenant =</span> <span class="codestrongitalic">Tenant_ID</span><br class="calibre5"/><span class="ent">➍</span> PS C:\&gt; <span class="codestrong1">Add-AzureRmAccount -ServicePrincipal -TenantId $tenant</span><br class="calibre5"/>       <span class="codestrong1">-CertificateThumbprint $thumbprint -ApplicationId $appId</span><br class="calibre5"/><br class="calibre5"/>   Environment           : AzureCloud<br class="calibre5"/>   Account               : <span class="codeitalic">Application_ID</span><br class="calibre5"/>   TenantId              : <span class="codeitalic">Tenant_ID</span><br class="calibre5"/>   SubscriptionId        : <span class="codeitalic">Subscription_ID</span><br class="calibre5"/>   SubscriptionName      :<br class="calibre5"/>   CurrentStorageAccount :</p>
<p class="indent"><span epub:type="pagebreak" id="page_46"/>Be sure to specify the thumbprint of the certificate you plan to use <span class="ent">➊</span>, instead of a password, and enter the service principal ID (application ID) on the command line <span class="ent">➋</span> because there will be no prompt for a credential. The tenant ID <span class="ent">➌</span> is the same as in password-based authentication. For the <span class="literal">Add-AzureRMAccount</span> command, replace the <span class="literal">-Credential</span> switch with the <span class="literal">-CertificateThumbprint</span> switch <span class="ent">➍</span>.</p>
<h3 class="h1" id="lev64"><strong class="calibre2">Best Practices: Subscription Security</strong></h3>
<p class="noindent">Subscription owners can take a number of steps to reduce the attack surface of their subscription and increase their awareness of changes in it. This includes keeping the number of highly privileged users in the subscription to a minimum, limiting the rights of nonhuman accounts, enabling auditing, limiting the scope of services in each subscription, and using JIT and Azure PIM (as described in “<a href="part0011.html#lev37" class="calibre6">Best Practices: Protecting Privileged Accounts</a>” on <a href="part0011.html#page_26" class="calibre6">page 26</a>) to protect the remaining accounts.</p>
<p class="indent">First, a subscription is only as secure as its weakest administrator. Therefore, it is crucial to require users to select strong passwords and enforce multi-factor authentication on all subscription user accounts. Limiting the number of users with access to the subscription also reduces the odds of compromised user accounts or computers being used for successful attacks against a subscription.</p>
<p class="indent">Next, look at the number of nonhuman accounts with access to the subscription, including management certificates, service accounts, and service principals. Administrators often feel less accountability for these accounts, particularly if they are shared among multiple people.</p>
<p class="indent">Additionally, auditing plays a key role in tracking access to subscriptions, identifying anomalies, and providing accountability for actions taken against the subscription. Without audit logs, defenders will have a very difficult time determining how an adversary gained access and what actions they took in the event of a breach. Microsoft has thorough documentation describing the types of logging available in Azure, and how to enable it, at <em class="calibre7"><a href="https://docs.microsoft.com/en-us/azure/monitoring-and-diagnostics/monitoring-overview-activity-logs/" class="calibre6">https://docs.microsoft.com/en-us/azure/monitoring-and-diagnostics/monitoring-overview-activity-logs/</a></em>.</p>
<p class="indent">Another consideration is the scope of services running within a subscription. Some companies are tempted to provision just a few subscriptions and put multiple workloads in each, but this can exacerbate the too-many-administrators issue. It can also lead to the creation of confusing security permissions to keep everyone limited to their own resources (or worse, permissions that give everyone free rein over everything in the subscription). I suggest using a separate subscription for each major project, and potentially different subscriptions for development, pre-production, and production deployments. For particularly sensitive resources, such as a Key Vault hosting critical secrets, it might make sense to place them in their own subscription.</p>
<p class="indent"><span epub:type="pagebreak" id="page_47"/>To assist in making these changes and ensuring that a subscription does not slip back into insecurity over time, Microsoft has released a subscription and resource security automation toolkit known as the Secure DevOps Kit. We’ll cover this in depth in <a href="part0017.html#ch08" class="calibre6">Chapter 8</a>.</p>
<p class="indent">Finally, consider using Azure PIM, so accounts only have administrative rights in the subscription when those privileges are needed. PIM also allows for additional auditing when those rights are used. For more details, see “<a href="part0011.html#lev37" class="calibre6">Best Practices: Protecting Privileged Accounts</a>” on <a href="part0011.html#page_26" class="calibre6">page 26</a>.</p>
<h3 class="h1" id="lev65"><strong class="calibre2">Gathering Subscription Information</strong></h3>
<p class="noindent">Once you’re signed in, you can begin gathering information about the subscription and its services. The data you gather will help determine where to perform deeper investigation. The first thing to gather from any subscription is data about the subscription itself, such as the name of the subscription and what accounts have access to it. This information often allows you to determine what a subscription is used for, and you can get some clues as to how best to pivot into other subscriptions.</p>
<p class="indent">When gathering this data, begin by listing the currently selected subscription. That listing should provide you with the name of the current subscription and its subscription ID. The subscription name is often quite informative. For example, it may contain a team or project name, such as “Human Resources – Production Site” or “E-Commerce Test Environment.” Additionally, confirm that the subscription ID is one you were expecting and that it is in scope for your assessment.</p>
<p class="indent">To list the current ASM subscription in PowerShell, run the following command:</p>
<p class="programs">PS C:\&gt; <span class="codestrong1">Get-AzureSubscription</span> <span class="codestrong1">-Current</span><br class="calibre5"/><br class="calibre5"/>SubscriptionId            : d72ad5c5-835a-4908-8f79-b4f44e833760<br class="calibre5"/>SubscriptionName          : Visitor Sign-In Production<br class="calibre5"/>Environment               : AzureCloud<br class="calibre5"/>DefaultAccount            : admin@burrough.com<br class="calibre5"/>IsDefault                 : True<br class="calibre5"/>IsCurrent                 : True<br class="calibre5"/>TenantId                  : 7eb504c7-c387-4fb1-940e-64f733532be2<br class="calibre5"/>CurrentStorageAccountName :</p>
<p class="indent">This command should return a <span class="literal">PSAzureSubscription</span> object and display the subscription name, subscription ID, the Azure Active Directory tenant ID, and the account you are connected with. It should also display the environment, which is the type of Azure cloud where this subscription is hosted. For example, AzureCloud is the default commercial version of Azure, whereas AzureUSGovernment is a separate instance of Azure just for US government use.</p>
<div class="note">
<p class="notet"><span epub:type="pagebreak" id="page_48" class="calibre1"/><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre7">Some countries with unique privacy and data laws, like Germany and China, have their own clouds. You can find a list of cloud environments and their management URLs by running</em> <span class="codeitalic1">Get-AzureEnvironment</span><em class="calibre7">.</em></p>
</div>
<p class="indent">To view current subscription information for ARM subscriptions in PowerShell, you can run the <span class="literal">Get-AzureRmContext</span> cmdlet. This command should return a <span class="literal">PSAzureContext</span> object, which is a container that holds <span class="literal">PSAzureRmAccount</span>, <span class="literal">PSAzureEnvironment</span>, <span class="literal">PSAzureSubscription</span>, and <span class="literal">PSAzureTenant</span> objects. In other words, its output should let you drill into specific details of the tenant, subscription, and account you are using.</p>
<p class="indent">Put a variable name and an equals sign before the context command so its output will be saved into a variable you can reference later, like this:</p>
<p class="programs">PS C:\&gt; <span class="codestrong1">$context = Get-AzureRmContext</span></p>
<p class="indent">Next, enter the variable name again, followed by a dot, followed by the data you want to drill into (<span class="literal">Account</span>, <span class="literal">Environment</span>, <span class="literal">Subscription</span>, or <span class="literal">Tenant</span>) to return all the available information for that object. For example, you could run the following:</p>
<p class="programs">PS C:\&gt; <span class="codestrong1">$context.Account</span></p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre7">It can be tricky to remember what options you can use on a given object represented by a variable. Fortunately, PowerShell has autocomplete. Just type the variable name, followed by a dot, and then press <small class="calibre17">TAB</small> to show the first possible option. Keep pressing <small class="calibre17">TAB</small> to cycle through possible options. When you reach to the one you want, press <small class="calibre17">ENTER</small> to run it. Alternatively, you can use the</em> <span class="codeitalic1">Get-Member</span> <em class="calibre7">cmdlet to see all possible values.</em></p>
</div>
<p class="indent">Run this cmdlet to show which users have ARM access and their privileges:</p>
<p class="programs">PS C:\&gt; <span class="codestrong1">Get-AzureRmRoleAssignment</span></p>
<p class="indent">To view all possible ARM roles, run the following:</p>
<p class="programs">PS C:\&gt; <span class="codestrong1">Get-AzureRmRoleDefinition</span></p>
<p class="indent">If you’re using the Azure command line tools, run</p>
<p class="programs">C:\&gt;<span class="codestrong1">azure account show</span></p>
<p class="noindent">to see the current subscription. Although the CLI won’t display the current user account, it should show the subscription ID and name, as well as the environment and the tenant ID, if available. It should also show whether you’re connected using a certificate.</p>
<p class="indent"><span epub:type="pagebreak" id="page_49"/>You can use the CLI in ARM mode to display accounts that have access:</p>
<p class="programs">C:\&gt;<span class="codestrong1">azure role assignment list</span></p>
<p class="indent">You can also show all available roles, like so:</p>
<p class="programs">C:\&gt;<span class="codestrong1">azure role list</span></p>
<h4 class="h2" id="lev66"><strong class="calibre2"><em class="calibre10">Viewing Resource Groups</em></strong></h4>
<p class="noindent"><em class="calibre7">Resource groups</em> were added in ARM as a way to assemble a set of services into one package for easier management. For example, a website might consist of the web pages themselves, along with a SQL database to store user profiles, and an instance of Application Insights (a telemetry service for applications). In ASM, each of these items was managed separately, and it was often difficult to tell which services were related. Resource groups allow you to monitor all related services, see how much a given deployment costs to run, assign permissions to all services in a group at once, and even delete everything in a group in one place. (Resource groups also help with reconnaissance by giving you a jumpstart in understanding these relationships and evaluating the potential importance of a given service.)</p>
<p class="indent">Resource groups pose two challenges, however. The first is that some developers might not understand how to use resource groups and simply create a new group for each service, even for related ones. Because resource groups are a management convenience, and not a security boundary, nothing prevents services in different groups from interacting with one another.</p>
<p class="indent">Second, when you’re investigating a given service, the ARM PowerShell cmdlets usually have the resource group as a required parameter, as does Azure CLI when in ARM mode. This can be frustrating, because you may know the name of a resource but not in which resource group it resides. To determine this, you’ll need to use separate commands to enumerate the groups.</p>
<p class="indent">To view the resource groups for a subscription using PowerShell, run the following:</p>
<p class="programs">PS C:\&gt; <span class="codestrong1">Get-AzureRmResourceGroup</span></p>
<p class="indent">In Azure CLI, run this:</p>
<p class="programs">C:\&gt;<span class="codestrong1">azure group list</span></p>
<p class="indent">Each command will show all resource groups in a subscription, but not which services are in these groups. It can be tedious running the enumeration commands on a subscription with dozens or even hundreds of <span epub:type="pagebreak" id="page_50"/>groups. Fortunately, you can list all ARM resources in a subscription, along with their resource group and their service type, at a high level. To get the resource list in ARM PowerShell, run the following:</p>
<p class="programs">PS C:\&gt; <span class="codestrong1">Get-AzureRmResource</span></p>
<p class="indent">In Azure CLI, use this:</p>
<p class="programs">C:\&gt;<span class="codestrong1">azure resource list</span></p>
<p class="indent">The output of these commands can get pretty ugly, so put it in a spreadsheet and use it as a guide to make sure your investigation doesn’t miss anything.</p>
<h4 class="h2" id="lev67"><strong class="calibre2"><em class="calibre10">Viewing a Subscription’s App Services (Web Apps)</em></strong></h4>
<p class="noindent">When a company decides to move some of its services to the cloud, its website is often an easy first step. After all, most or all of that data is already public, so the confidentiality concerns often associated with storing data on remote servers are greatly reduced. Additionally, websites can take advantage of the auto-scaling features of Platform as a Service (PaaS) cloud providers to increase capacity during busy times such as new product launches and holiday shopping.</p>
<p class="indent">Microsoft initially called these sites <em class="calibre7">Web Apps</em> in the old management interface, but has moved their management entirely to the new portal and renamed them <em class="calibre7">App Services</em>. The new portal also offers a gallery of pre-built web service templates—everything from blogs to e-commerce platforms. One benefit of this migration is that even apps deployed under the ASM model are viewable from the ARM PowerShell cmdlets and the ARM mode of the CLI.</p>
<h5 class="h3" id="lev68"><strong class="calibre2">Using PowerShell</strong></h5>
<p class="noindent">To view the Web Apps in a subscription using PowerShell, run <span class="codestrong">Get-AzureRmWebApp</span> with no parameters. The legacy <span class="literal">Get-AzureWebsite</span> will return the site list. Both commands allow you to pass the name of a site as a parameter to get additional details. Try the ASM version of the command because it returns details that the ARM version leaves out on classic websites. <a href="part0012.html#ch03list3" class="calibre6">Listing 3-3</a> shows an example of this output.</p>
<p class="programs"><span class="ent">➊</span> PS C:\&gt; <span class="codestrong1">Get-AzureWebsite</span><br class="calibre5"/>   Name       : <span class="codeitalic">anazurewebsite</span><br class="calibre5"/>   State      : Running<br class="calibre5"/>   Host Names : {<span class="codeitalic">anazurewebsite.azurewebsites.net</span>}<br class="calibre5"/><br class="calibre5"/><span class="ent">➋</span> PS C:\&gt; <span class="codestrong1">Get-AzureWebsite -Name</span> <span class="codestrongitalic">anazurewebsite</span><br class="calibre5"/>   Instances                       : {d160 ... 0bb13}<br class="calibre5"/>   NumberOfWorkers                 : 1<br class="calibre5"/>   DefaultDocuments                : {Default.htm, Default.html, index.htm...}<br class="calibre5"/><span class="ent">➌</span> NetFrameworkVersion             : v4.0<br class="calibre5"/><span epub:type="pagebreak" id="page_51"/><span class="ent">➍</span> PhpVersion                      : 5.6<br class="calibre5"/>   RequestTracingEnabled           : False<br class="calibre5"/>   HttpLoggingEnabled              : False<br class="calibre5"/>   DetailedErrorLoggingEnabled     : False<br class="calibre5"/><span class="ent">➎</span> PublishingUsername              : $<span class="codeitalic">anazurewebsite</span><br class="calibre5"/><span class="ent">➏</span> PublishingPassword              : gIhh ... cLg8a<br class="calibre5"/>   --<span class="codeitalic">snip</span>--</p>
<p class="listing" id="ch03list3"><em class="calibre7">Listing 3-3: Output from the</em> <span class="codeitalic2">Get-AzureWebsite</span> <em class="calibre7">PowerShell cmdlet</em></p>
<p class="indent">After retrieving the names of any Azure websites and their URLs <span class="ent">➊</span>, pass the name of a site you are interested in to <span class="literal">Get-AzureWebsite</span> using <span class="literal">-Name</span> <span class="ent">➋</span>. Some of the details that <span class="literal">Get-AzureWebsite</span> provides but that <span class="literal">Get-AzureRmWebApp</span> omits are the version of .NET <span class="ent">➌</span> and PHP <span class="ent">➍</span> the site is running, as well as the username <span class="ent">➎</span> and password <span class="ent">➏</span> of the account used to publish site content. These values are clearly useful to an attacker because they can make it possible to look for known PHP and .NET exploits based on version. They also provide the ability to modify site content.</p>
<h5 class="h3" id="lev69"><strong class="calibre2">Using the CLI in ASM</strong></h5>
<p class="noindent">You can retrieve similar data using the CLI. In ASM mode, use the command <span class="codestrong">azure site list</span> to see a listing of all subscription websites, and then run</p>
<p class="programs">C:\&gt;<span class="codestrong1">azure site show "</span><span class="codestrongitalic">sitename</span><span class="codestrong1">"</span></p>
<p class="noindent">to see a given site’s details. The detailed output isn’t as thorough as the PowerShell cmdlet; instead, many of the details get their own command, such as</p>
<p class="programs">C:\&gt;<span class="codestrong1">azure site appsetting list "</span><span class="codestrongitalic">sitename</span><span class="codestrong1">"</span></p>
<p class="indent">To see all of these options, run <span class="codestrong">azure help site</span>.</p>
<h5 class="h3" id="lev70"><strong class="calibre2">Using the CLI in ARM</strong></h5>
<p class="noindent">In ARM mode, the CLI requires you to provide the resource group of the website in ARM mode, even if you simply want to enumerate a list of sites. Start with a list of resource groups, using <span class="codestrong">azure group list</span>. Then, once you have the list of groups, run <span class="codestrong">azure webapp list "</span><span class="codestrongitalic1">group_name</span><span class="codestrong">"</span> for each resource group. From there, run the following to see detailed information:</p>
<p class="programs">C:\&gt;<span class="codestrong1">azure webapp show "</span><span class="codestrongitalic">group_name</span><span class="codestrong1">" "</span><span class="codestrongitalic">app_name</span><span class="codestrong1">"</span></p>
<p class="indent">As with the ASM CLI, some details are hidden behind additional subcommands. To see these options, enter <span class="codestrong">azure help webapp</span>.</p>
<h4 class="h2" id="lev71"><strong class="calibre2"><em class="calibre10">Gathering Information on Virtual Machines</em></strong></h4>
<p class="noindent">As the quintessential <em class="calibre7">Infrastructure as a Service (IaaS)</em> role, virtual machines (VMs) are one of the most frequently encountered services in an Azure <span epub:type="pagebreak" id="page_52"/>subscription. In terms of management, Azure actually breaks down VMs into several components, which are all configured separately with different commands. I’ll discuss how to get information about the VM container itself and then show you how to get at the VM’s hard disk image and network settings.</p>
<h5 class="h3" id="lev72"><strong class="calibre2">Viewing a List of VMs</strong></h5>
<p class="noindent">Unlike App Services, virtual machines are segregated by service model, with classic VMs only appearing in the ASM cmdlets and ARM VMs appearing exclusively in the ARM cmdlets. Running <span class="literal">Get-AzureVM</span> in PowerShell returns a list of ASM-based VMs, including each VM’s service name, name, and status. For a detailed status report for a VM, use the service name parameter of the cmdlet:</p>
<p class="programs">PS C:\&gt; <span class="codestrong1">Get-AzureVM -ServiceName "</span><span class="codestrongitalic">service_name</span><span class="codestrong1">"</span></p>
<p class="indent">This report should include information like the VM’s IP address, DNS address, power state, and the “size” of the VM.</p>
<div class="sidebar">
<p class="sidebart"><strong class="calibre4">WHAT VM PRICING TIERS REVEAL ABOUT TARGETS</strong></p>
<p class="spara">VM sizes map to a particular set of hardware allowances for the VM and a monthly cost. For example, an A0 VM has 768MB of memory, 20GB of hard drive space, one CPU core, and one network interface, whereas a D14 VM has 112GB of memory, 800GB of SSD-based storage, 16 CPU cores, and up to eight network interfaces. The specifications for each tier can be found at <em class="calibre10"><a href="https://docs.microsoft.com/en-us/azure/virtual-machines/virtual-machines-windows-sizes/" class="calibre11">https://docs.microsoft.com/en-us/azure/virtual-machines/virtual-machines-windows-sizes/</a></em>, and current pricing is available from <em class="calibre10"><a href="https://azure.microsoft.com/en-us/pricing/details/cloud-services/" class="calibre11">https://azure.microsoft.com/en-us/pricing/details/cloud-services/</a></em>.</p>
<p class="spara1">These details can be critical because they provide some indication of the importance, workload, or value of the VM. Test VMs are often in the A0–A3 range, whereas production VMs are often in the higher-level D tier. Also, specialty tiers such as N provide dedicated hardware-based Nvidia graphics processors (GPUs) directly to the VM. These are used for computationally intensive work, such as rendering animations (or, for us penetration testers, cracking passwords).</p>
</div>
<h5 class="h3" id="lev73"><strong class="calibre2">Viewing a List of ARM VMs in PowerShell</strong></h5>
<p class="noindent">To get a list of ARM VMs in PowerShell, use the <span class="literal">Get-AzureRmVM</span> cmdlet with no parameters. This should return each VM in the subscription, along with its resource group’s name, region, and size.</p>
<p class="indent"><span epub:type="pagebreak" id="page_53"/><a href="part0012.html#ch03list4" class="calibre6">Listing 3-4</a> shows how to get the details of an ARM VM in PowerShell.</p>
<p class="programs"><span class="ent">➊</span> PS C:\&gt; <span class="codestrong1">$vm = Get-AzureRmVM -ResourceGroupName "</span><span class="codestrongitalic">resource_group</span><span class="codestrong1">" -Name "</span><span class="codestrongitalic">name</span><span class="codestrong1">"</span><br class="calibre5"/><span class="ent">➋</span> PS C:\&gt; <span class="codestrong1">$vm</span><br class="calibre5"/>   ResourceGroupName   : <span class="codeitalic">resource_group</span><br class="calibre5"/>   ...<br class="calibre5"/>   Name                : <span class="codeitalic">VM_name</span><br class="calibre5"/>   Location            : centralus<br class="calibre5"/>   --<span class="codeitalic">snip</span>--<br class="calibre5"/>   HardwareProfile     : {VmSize}<br class="calibre5"/>   NetworkProfile      : {NetworkInterfaces}<br class="calibre5"/>   OSProfile           : {ComputerName, AdminUsername, LinuxConfiguration, Secrets}<br class="calibre5"/>   ProvisioningState   : Succeeded<br class="calibre5"/>   StorageProfile      : {ImageReference, OsDisk, DataDisks}<br class="calibre5"/><span class="ent">➌</span> PS C:\&gt; <span class="codestrong1">$vm.HardwareProfile</span><br class="calibre5"/>   VmSize<br class="calibre5"/>   ------<br class="calibre5"/>   Basic_A0<br class="calibre5"/><span class="ent">➍</span> PS C:\&gt; <span class="codestrong1">$vm.OSProfile</span><br class="calibre5"/>   ComputerName         : <span class="codeitalic">VM_name</span><br class="calibre5"/>   AdminUsername        : <span class="codeitalic">Username</span><br class="calibre5"/>   AdminPassword        :<br class="calibre5"/>   CustomData           :<br class="calibre5"/>   WindowsConfiguration :<br class="calibre5"/>   LinuxConfiguration   : Microsoft.Azure.Management.Compute.Models.LinuxConfiguration<br class="calibre5"/>   Secrets              : {}<br class="calibre5"/><span class="ent">➎</span> PS C:\&gt; <span class="codestrong1">$vm.StorageProfile.ImageReference</span><br class="calibre5"/>   Publisher Offer        Sku       Version<br class="calibre5"/>   --------- -----        ---       -------<br class="calibre5"/>   Canonical UbuntuServer 16.04-LTS latest</p>
<p class="listing" id="ch03list4"><em class="calibre7">Listing 3-4: Obtaining details for an ARM VM in PowerShell</em></p>
<p class="indent">The first command gets the details of the VM and saves them into the variable <span class="literal">$vm</span> <span class="ent">➊</span>. Next, we dump the information stored in the variable <span class="ent">➋</span> and show the VM size <span class="ent">➌</span>. This information is available in the initial VM enumeration from <span class="literal">Get-AzureRmVM</span>, but it’s nice to have it inline with the rest of the details of the specific VM when reading the output later.</p>
<p class="indent">Now we dump the OS profile block <span class="ent">➍</span>, which includes the administrator’s username (sadly, the password is usually omitted). Finally, we display the image reference information from the storage profile <span class="ent">➎</span>. This tells us the base image of the VM, which often includes version details—in this case, Ubuntu Server version 16.04 Long Term Support (LTS) edition.</p>
<h5 class="h3" id="lev74"><strong class="calibre2">Collecting Information with the CLI</strong></h5>
<p class="noindent">To collect this information from the CLI in ASM mode, use <span class="codestrong">azure vm list</span> to enumerate the classic VMs in the subscription and then use <span class="codestrong">azure vm show "</span><span class="codestrongitalic1">name</span><span class="codestrong">"</span> on each VM to see its details.</p>
<p class="indent"><span epub:type="pagebreak" id="page_54"/>Using the CLI in ARM mode is almost identical for VMs—the enumeration command is also <span class="literal">azure vm list</span>. The only change is that, in order to show the details of a VM, ARM mode also requires the resource group:</p>
<p class="programs">C:\&gt;<span class="codestrong1">azure vm show "</span><span class="codestrongitalic">resource_group_name</span><span class="codestrong1">" "</span><span class="codestrongitalic">VM_name</span><span class="codestrong1">"</span></p>
<p class="indent">Unlike PowerShell, this will display all the details at once, including the username, VM size, and OS version.</p>
<h4 class="h2" id="lev75"><strong class="calibre2"><em class="calibre10">Finding Storage Accounts and Storage Account Keys</em></strong></h4>
<p class="noindent">Azure Storage is the primary place to store data in Microsoft’s cloud. Storage accounts offer four types of data storage, and any given storage account can have any or all of these types in use at a time. <em class="calibre7">Blob storage</em> is used to hold unstructured data, including files and large binary steams. <em class="calibre7">File storage</em> is just like blob storage, except that it offers direct Server Message Block (SMB) access to files. (This is convenient because blob storage has traditionally required the use of either complicated APIs or third-party tools to access its contents. I’ll cover how to use these tools to extract data in <a href="part0013.html#ch04" class="calibre6">Chapter 4</a>.) <em class="calibre7">Table storage</em> is a scalable, NoSQL tabular dataset container. Finally, <em class="calibre7">queues</em> hold transient messages for ordered, asynchronous processing.</p>
<p class="indent">Many other services rely on storage accounts to host their underlying data, including virtual machines. The Virtual Hard Disk (VHD) files used in VMs are stored here as blobs. Other services, such as Azure Websites, Machine Learning, and Activity Log, can use a storage account to hold their log files.</p>
<p class="indent">Your reconnaissance should answer two main questions about storage accounts:</p>
<ul class="calibre8">
<li class="noindent1">Which storage accounts are available in the target subscription?</li>
<li class="noindent1">What are their keys?</li>
</ul>
<p class="indent">Answering the first question is straightforward, as long as you remember that classic (ASM-based) storage accounts and ARM-based storage accounts are completely separate in Azure, so remember to look for both types. To check for classic storage accounts in PowerShell, use the <span class="literal">Get-AzureStorageAccount</span> cmdlet without any parameters to list all ASM storage accounts in the subscription. The equivalent command in Azure CLI is <span class="literal">azure storage account list</span>. Both commands will show the storage account name, its type (whether its data is redundant in one datacenter, one region, or multiple regions), and its location (the datacenter where the data is being stored, such as Central US). The PowerShell command also provides some additional details, such as the URLs used for the account, but this information can be obtained from the CLI with the <span class="literal">azure storage account show "</span><span class="codeitalic1">account_name</span><span class="literal">"</span> command.</p>
<p class="indent">Checking for ARM storage accounts is equally easy. In the CLI, the same commands you use for ASM work for ARM (once the CLI mode is switched). For PowerShell, the command is <span class="literal">Get-AzureRmStorageAccount</span>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_55"/>Next, you’ll need the storage account keys to access data within Azure Storage. Azure assigns two base64-encoded, 64-byte keys to each storage account. They’re labeled “primary” and “secondary,” but you can use either. Having two keys simultaneously allows administrators to rotate keys without bringing down their service by following these steps:</p>
<ol class="calibre16">
<li class="noindent1" value="1">Updating their service’s configuration to go from using the primary to the secondary key</li>
<li class="noindent1" value="2">Using the Azure portal to generate a new primary key</li>
<li class="noindent1" value="3">Updating their service to switch from the secondary to the new primary key</li>
</ol>
<p class="indent">You won’t have too much trouble obtaining these keys. Because the same key (or same two keys) is used for every service that accesses that storage account, administrators need a way to easily retrieve the key again and again, each time they add or update a service. Additionally, because the key is used everywhere and doesn’t expire unless a new key is generated, most administrators never change it, since following the preceding three steps for multiple services can be tedious.</p>
<div class="sidebar">
<p class="sidebart"><strong class="calibre4">DEFENDER’S TIP</strong></p>
<p class="spara">Knowing how to properly reset a leaked or otherwise compromised credential is critical to a speedy remediation if a security incident arises. Understanding authentication dependencies is equally important in order to minimize disruptions that could result from credential changes. It is therefore wise to practice resetting or “rolling” any type of credential used by your organization regularly, and to make optimizations as needed, so that you can reset credentials promptly and accurately during a real attack. Storage keys or SSL private keys are no different—practice switching between primary and secondary keys in all of your services during development and in production to make sure you’ve properly documented every place where the keys need to be replaced.</p>
</div>
<p class="indent">Because the keys need to be retrievable, Azure exposes them via the portal, PowerShell, and CLI. To get the both the primary and secondary keys for an ASM storage account in PowerShell, run</p>
<p class="programs">PS C:\&gt; <span class="codestrong1">Get-AzureStorageKey</span> <span class="codestrong1">-StorageAccountName "</span><span class="codestrongitalic">Storage_Account_Name</span><span class="codestrong1">"</span></p>
<p class="indent">To do the same in ARM PowerShell, use this:</p>
<p class="programs">PS C:\&gt; <span class="codestrong1">Get-AzureRmStorageAccountKey</span> <span class="codestrong1">-ResourceGroupName</span><br class="calibre5"/>    <span class="codestrong1">"</span><span class="codestrongitalic">Resource_Group_Name</span><span class="codestrong1">" -StorageAccountName</span><br class="calibre5"/>    <span class="codestrong1">"</span><span class="codestrongitalic">Storage_Account_Name</span><span class="codestrong1">"</span></p>
<p class="indent"><span epub:type="pagebreak" id="page_56"/>In the CLI, getting the ASM keys is easy; just execute the following:</p>
<p class="programs">C:\&gt;<span class="codestrong1">azure storage account keys list "</span><span class="codestrongitalic">account_name</span><span class="codestrong1">"</span></p>
<p class="indent">For some reason, the ARM CLI command to get the keys behaves differently from all other ARM CLI commands. It requires the resource group name of the storage account, but it doesn’t accept the group name as a parameter on the command line; therefore, as in ASM mode, you’ll need to run the following command:</p>
<p class="programs">C:\&gt;<span class="codestrong1">azure storage account keys list "</span><span class="codestrongitalic">account_name</span><span class="codestrong1">"</span></p>
<p class="indent">As soon as you run this command, you’ll be prompted to provide the resource group name. Enter it at the prompt and then the keys should be displayed.</p>
<h3 class="h1" id="lev76"><strong class="calibre2">Gathering Information on Networking</strong></h3>
<p class="noindent">Networking is one of the more complex parts of Azure because it involves IP address assignments, firewall rules, virtual networks, and virtual private networks (VPNs). It can even involve a dedicated circuit between a business and Azure, known as an ExpressRoute. An ExpressRoute connection is essentially a dedicated wide area network (WAN) link that allows a company to treat resources running in Azure as a part of its internal corporate network. During this phase of the operation, I focus on simply enumerating the commonly used networking features: network interfaces (IP addresses), endpoints (ports), and network security groups (firewalls). I cover more advanced topics in <a href="part0015.html#ch06" class="calibre6">Chapter 6</a>.</p>
<h4 class="h2" id="lev77"><strong class="calibre2"><em class="calibre10">Network Interfaces</em></strong></h4>
<p class="noindent"><em class="calibre7">Network interfaces</em> are the virtual network cards associated with ARM-based virtual machines. In classic VMs, they are just called <em class="calibre7">IP addresses</em>. Each VM usually has two IP addresses—an internal, non-internet-facing address for connecting to other services in the subscription, and an internet-facing public IP or virtual IP address. Obtaining these IPs directly from Azure is very beneficial for a penetration tester because having them allows for port scanning and other directed attacks against virtual machines, without having to scan an entire address range looking for devices. It also ensures that the scans stay in scope, because public IP addresses in Azure’s space can be dynamically reassigned to other Azure customers.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre7">If you already have Azure portal or API access, why would you need to perform external scans against the IP addresses of VMs? During a penetration test, customers usually want a number of attack vectors examined, from insider threats to internet-based “script kiddies.” Although an insider or nation state may be able to breach your client’s network and gain portal access, lesser-skilled attackers probably cannot, so it’s important to perform more traditional security assessments of anything exposed <span epub:type="pagebreak" id="page_57"/>to the internet. Additionally, Azure does not offer console-type access to VMs from the portal. All access to the VM must be made through its network interface using remote management services like Remote Desktop Protocol or SSH.</em></p>
</div>
<div class="sidebar">
<p class="sidebart"><strong class="calibre4">DEFENDER’S TIP</strong></p>
<p class="spara">All services on the internet are subject to near-constant port and vulnerability scanning, brute-force password guessing, and other attacks. There are even websites like Shodan (<em class="calibre10"><a href="https://www.shodan.io/" class="calibre11">https://www.shodan.io/</a></em>) that index port scan data and make it publicly searchable. Whenever possible, try to mitigate these attacks by turning off management services not in use, restricting access to them through IP restrictions, and keeping VMs on private VLANs, shielded from the internet.</p>
</div>
<h5 class="h3" id="lev78"><strong class="calibre2">Listing Internal IPs Used by Classic VMs</strong></h5>
<p class="noindent">To obtain a list of internal IPs used by classic VMs, simply run <span class="codestrong">Get-AzureVM</span> or <span class="codestrong">azure vm show</span>. The internal IP should be included in the ASM output of both of these commands. Conversely, ARM’s CLI <span class="literal">vm show</span> command will show only the public IP by default. <a href="part0012.html#ch03tab2" class="calibre6">Table 3-2</a> describes which IPs are displayed by the VM commands.</p>
<p class="tabcap" id="ch03tab2"><strong class="calibre4">Table 3-2:</strong> IP Addresses Displayed by Tool</p>
<table class="topbot-d">
<thead class="calibre12">
<tr class="calibre13">
<td class="table-h"><p class="tab_th"><strong class="calibre4">Command (mode)</strong></p></td>
<td class="table-h"><p class="tab_th"><strong class="calibre4">Internal IP</strong></p></td>
<td class="table-h"><p class="tab_th"><strong class="calibre4">Public IP</strong></p></td>
</tr>
</thead>
<tbody class="calibre14">
<tr class="calibre13">
<td class="table-a"><p class="taba"><span class="literal">azure vm show</span> (ASM)</p></td>
<td class="table-a"><p class="taba">Shown</p></td>
<td class="table-a"><p class="taba">Shown</p></td>
</tr>
<tr class="calibre13">
<td class="table-b"><p class="taba"><span class="literal">azure vm show</span> (ARM)</p></td>
<td class="table-b"><p class="taba">Not shown</p></td>
<td class="table-b"><p class="taba">Shown</p></td>
</tr>
<tr class="calibre13">
<td class="table-a"><p class="taba"><span class="literal">Get-AzureVM</span> (ASM)</p></td>
<td class="table-a"><p class="taba">Shown</p></td>
<td class="table-a"><p class="taba">Not shown</p></td>
</tr>
<tr class="calibre13">
<td class="table-ba"><p class="taba"><span class="literal">Get-AzureRmVM</span> (ARM)</p></td>
<td class="table-ba"><p class="taba">Not shown</p></td>
<td class="table-ba"><p class="taba">Not shown</p></td>
</tr>
</tbody>
</table>
<p class="indent">For ASM VMs, the CLI’s <span class="literal">azure vm show</span> command is a one-stop shop for obtaining IP addresses. To use the CLI in ARM mode to show a list of all network interfaces, enter <span class="codestrong">azure network nic list</span>. This should display the interface’s name, resource group, MAC address, and location. Here’s how to use it to display details for a specific NIC:</p>
<p class="programs">C:\&gt;<span class="codestrong1">azure network nic show "</span><span class="codestrongitalic">resource_group_name</span><span class="codestrong1">" "</span><span class="codestrongitalic">NIC_name</span><span class="codestrong1">"</span></p>
<p class="indent">The output should also display details such as the IP address, whether it is static or dynamic, and its associated VM or service.</p>
<p class="indent">In order to get dynamically assigned public IP information for a given VM from the ASM PowerShell cmdlets, you will need to list the VM’s endpoints, as discussed in the next section. That said, if the subscription has <span epub:type="pagebreak" id="page_58"/>any reserved (static) public IP addresses for ASM resources, the command <span class="literal">Get-AzureReservedIP</span> with no switches should list them, as well as the service to which they are tied.</p>
<p class="indent">And finally, to view IPs for ARM resources in PowerShell, use <span class="literal">Get-AzureRmNetworkInterface</span> to display all the NICs in use in the subscription for ARM resources, though this will display only private IPs. To view the public IPs, use the <span class="literal">Get-AzureRmPublicIpAddress</span> cmdlet, which should show any ARM resources using a public IP, the IP address, and whether the address is dynamically or statically assigned.</p>
<h5 class="h3" id="lev79"><strong class="calibre2">Querying Endpoints with Azure Management Tools</strong></h5>
<p class="noindent">Once you know the IP addresses within a subscription, you should determine the ports available at those IPs. In classic Azure VMs, a network port is referred to as an <em class="calibre7">endpoint</em>—a service running on a host. For ARM VMs, port management has been rolled into firewall management, but ASM maintains them separately. Let’s look at how to enumerate ASM endpoints.</p>
<p class="indent">Although you could run a port scanner such as Nmap to gather this information, doing so has several drawbacks:</p>
<ul class="calibre8">
<li class="noindent1">ASM-based VMs put Remote Desktop Protocol (RDP) on random, high-numbered ports, so you’d need to scan all 65,535 ports to be sure you find the right ones.</li>
<li class="noindent1">Because the scan would take place over the internet, it would be considerably slower than similar scans on a local network.</li>
<li class="noindent1">A subscription could have dozens, or even hundreds, of hosts.</li>
<li class="noindent1">You’d only find internet-facing ports allowed through the firewall, not any services that may be exposed only to other hosts in the subscription or within Azure.</li>
</ul>
<p class="indent">For these reasons, it’s faster and more thorough to query the ports directly using Azure management tools. To query endpoints in PowerShell, use <span class="literal">Get-AzureEndpoint</span>, as shown in <a href="part0012.html#ch03list5" class="calibre6">Listing 3-5</a>. You must run it for each classic VM and give it a PowerShell <span class="literal">IPersistentVM</span> object instead of the name of a virtual machine. The <span class="literal">Get-AzureVM</span> cmdlet returns an object of this type.</p>
<p class="programs"><span class="ent">➊</span> PS C:\&gt; <span class="codestrong1">$vm = Get-AzureVM -ServiceName</span> <span class="codestrongitalic">vmasmtest</span><br class="calibre5"/><span class="ent">➋</span> PS C:\&gt; <span class="codestrong1">Get-AzureEndpoint -VM $vm</span><br class="calibre5"/>   LBSetName                :<br class="calibre5"/>   LocalPort                : 22 <span class="ent">➌</span><br class="calibre5"/>   Name                     : SSH <span class="ent">➍</span><br class="calibre5"/>   Port                     : 22 <span class="ent">➎</span><br class="calibre5"/>   Protocol                 : tcp<br class="calibre5"/>   Vip                      : 52.176.10.12 <span class="ent">➏</span><br class="calibre5"/>   --<span class="codeitalic">snip</span>--</p>
<p class="listing" id="ch03list5"><em class="calibre7">Listing 3-5: Obtaining endpoints for an ASM VM in PowerShell</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_59"/>At <span class="ent">➊</span>, we obtain a VM object using the VM’s service name and store it in a variable. Next, we pass that object into the <span class="literal">Get-AzureEndpoint</span> cmdlet <span class="ent">➋</span>, which should return the port the server is listening on <span class="ent">➌</span>, the name of the endpoint <span class="ent">➍</span> (often the name of the service being used, such as SSH, RDP, or HTTP), the port exposed to the internet that is forwarded to the local port <span class="ent">➎</span>, and the endpoint’s virtual IP address <span class="ent">➏</span>. The VIP is the public IP address of the VM.</p>
<p class="indent">The Azure CLI also allows you to list endpoints in ASM mode. To get a listing of endpoints with a particular VM name, run the following command:</p>
<p class="programs">C:\&gt;<span class="codestrong1">azure vm endpoint list "</span><span class="codestrongitalic">VM_name</span><span class="codestrong1">"</span></p>
<p class="indent">You only need to run this command once for each VM to see all its endpoints.</p>
<h4 class="h2" id="lev80"><strong class="calibre2"><em class="calibre10">Obtaining Firewall Rules or Network Security Groups</em></strong></h4>
<p class="noindent">It can be really helpful to collect information on a VM’s network settings from Azure’s firewall rules because they dictate which ports for a given VM are accessible, and from where. These rules are separate from the VM’s operating system–based firewall and act like the port-forwarding settings on a router. Azure calls these firewall filters <em class="calibre7">Network Security Groups (NSG)</em> in ARM and <em class="calibre7">Network Security Groups (classic)</em> for ASM.</p>
<h5 class="h3" id="lev81"><strong class="calibre2">Viewing ASM-based NSGs with PowerShell</strong></h5>
<p class="noindent">For various reasons, classic VMs often don’t use NSGs. Nevertheless, it’s worth knowing how to list both classic and ARM-based NSGs, because knowing whether a firewall is in place can help avoid unnecessary port scanning, and you might even report a lack of firewalls in your findings to your client. In PowerShell, you can list classic NSG names and locations with <span class="literal">Get-AzureNetworkSecurityGroup</span> and no arguments. To view the rules inside a specific classic NSG, use the following command:</p>
<p class="programs">PS C:\&gt; <span class="codestrong1">Get-AzureNetworkSecurityGroup -Detailed -Name "</span><span class="codestrongitalic">NSG_Name</span><span class="codestrong1">"</span></p>
<p class="indent">To view the details of every classic NSG, run this:</p>
<p class="programs">PS C:\&gt; <span class="codestrong1">Get-AzureNetworkSecurityGroup -Detailed</span></p>
<p class="indent">Unfortunately, the output of this command won’t map the NSG back to a virtual machine. To do so, get the VM object for the target virtual machine and then run the following to display the NSG associated with that VM (you’ll see an error if the VM doesn’t use an NSG):</p>
<p class="programs">PS C:\&gt; <span class="codestrong1">Get-AzureNetworkSecurityGroupAssociation -VM $vm</span><br class="calibre5"/>    <span class="codestrong1">-ServiceName $vm.ServiceName</span></p>
<h5 class="h3" id="lev82"><span epub:type="pagebreak" id="page_60" class="calibre1"/><strong class="calibre2">Viewing ASM-based NSGs with the CLI</strong></h5>
<p class="noindent">Azure CLI can also show classic NSG settings. To see all classic NSGs in ASM mode, run the following command:</p>
<p class="programs">C:\&gt;<span class="codestrong1">azure network nsg list</span></p>
<p class="indent">To see the rules in an NSG, run the following:</p>
<p class="programs">C:\&gt;<span class="codestrong1">azure network nsg show "</span><span class="codestrongitalic">NSG_Name</span><span class="codestrong1">"</span></p>
<p class="indent">I have yet to find a way to map the association between an NSG and a virtual machine using the CLI.</p>
<h5 class="h3" id="lev83"><strong class="calibre2">Viewing ARM-based NSGs with PowerShell</strong></h5>
<p class="noindent">Run <span class="codestrong">Get-AzureRmNetworkSecurityGroup</span> to view ARM-based NSGs with PowerShell. This should return every ARM NSG’s name, resource group, region, and rules. This includes rules defined by the subscription administrator as well as rules that Azure automatically creates, such as “Allow outbound traffic from all VMs to internet.” It can be helpful to see all these rules (after all, the removal of the “allow outbound traffic to the internet” rule could block your command-and-control traffic on a compromised VM), but if you prefer, you can see only the custom rules for a particular NSG with <span class="literal">Get-AzureRmNetworkSecurityRuleConfig</span>.</p>
<p class="indent">In order to use PowerShell to get the mapping of an ARM virtual machine to an ARM NSG, you’ll need to find the interface for the desired VM and then look up the NSG for that interface. You could nest all of the following commands into one single line, but to improve readability and avoid mistakes, I usually break it into a series of commands, as shown in <a href="part0012.html#ch03list6" class="calibre6">Listing 3-6</a>.</p>
<p class="programs"><span class="ent">➊</span> PS C:\&gt; <span class="codestrong1">$vm = Get-AzureRmVM -ResourceGroupName "</span><span class="codestrongitalic">VM_Resource_Group_Name</span><span class="codestrong1">"</span><br class="calibre5"/>       <span class="codestrong1">-Name "</span><span class="codestrongitalic">VM_Name</span><span class="codestrong1">"</span><br class="calibre5"/><span class="ent">➋</span> PS C:\&gt; <span class="codestrong1">$ni = Get-AzureRmNetworkInterface | where { $_.Id -eq</span><br class="calibre5"/>       <span class="codestrong1">$vm.NetworkInterfaceIDs }</span><br class="calibre5"/><span class="ent">➌</span> PS C:\&gt; <span class="codestrong1">Get-AzureRmNetworkSecurityGroup | where { $_.Id -eq</span><br class="calibre5"/>       <span class="codestrong1">$ni.NetworkSecurityGroup.Id }</span><br class="calibre5"/>   Name                 : <span class="codeitalic">NSG_Name</span><br class="calibre5"/>   ResourceGroupName    : <span class="codeitalic">NSG_Resource_Group_Name</span><br class="calibre5"/>   Location             : centralus<br class="calibre5"/>   . . .<br class="calibre5"/>   SecurityRules        : [<br class="calibre5"/>                            {<br class="calibre5"/>                              "Name": "default-allow-ssh",<br class="calibre5"/>   --<span class="codeitalic">snip</span>--</p>
<p class="listing" id="ch03list6"><em class="calibre7">Listing 3-6: Finding a Network Security Group for a given VM in PowerShell</em></p>
<p class="indent">At <span class="ent">➊</span>, we get the VM object and put it in a variable. At <span class="ent">➋</span>, we perform a lookup to obtain the Network Interface object for that VM, using the VM’s Network Interface ID property. Finally, we display the NSG using the <span epub:type="pagebreak" id="page_61"/>Network Security Group identifier stored in the Network Interface object <span class="ent">➌</span>. Aside from replacing the VM resource group and name on the first line, you can run everything else exactly as shown here.</p>
<h5 class="h3" id="lev84"><strong class="calibre2">Viewing ARM-based NSGs with the CLI</strong></h5>
<p class="noindent">The CLI commands for viewing NSGs in ARM mode are almost identical to those for ASM. The only difference is that the ARM command to show a specific NSG requires the resource group name: <span class="literal">azure network nsg show "</span><span class="codeitalic1">Resource_Group_Name</span><span class="literal">" "</span><span class="codeitalic1">NSG_Name</span><span class="literal">"</span>.</p>
<h4 class="h2" id="lev85"><strong class="calibre2"><em class="calibre10">Viewing Azure SQL Databases and Servers</em></strong></h4>
<p class="noindent">SQL is frequently found in Azure, not only because many websites based in Azure require it, but because installing SQL on an on-premises server can be slow and has dozens of potentially confusing configuration options. However, it takes only minutes to set up Azure SQL (the name of Microsoft’s cloud-based SQL solution).</p>
<p class="indent">Azure SQL is separated into SQL servers and SQL databases. Although a database lives within an Azure SQL server instance, the two items are managed individually—a separation that might surprise experienced SQL administrators.</p>
<h5 class="h3" id="lev86"><strong class="calibre2">Listing Azure SQL Servers</strong></h5>
<p class="noindent">To list the SQL servers in a subscription (including database server name, location, username of the administrator account, and version), run <span class="codestrong">Get-AzureSqlDatabaseServer</span> with no parameters. Once you have the server information, run</p>
<p class="programs">PS C:\&gt; <span class="codestrong1">Get-AzureSqlDatabase</span> <span class="codestrong1">-ServerName "</span><span class="codestrongitalic">Server_Name</span><span class="codestrong1">"</span></p>
<p class="noindent">to see the names, sizes, and creation dates of every database within that server.</p>
<h5 class="h3" id="lev87"><strong class="calibre2">Viewing Azure SQL Firewall Rules</strong></h5>
<p class="noindent">To view any firewall rules applied to Azure SQL, run the following command:</p>
<p class="programs">PS C:\&gt; <span class="codestrong1">Get-AzureSqlDatabaseServerFirewallRule</span> <span class="codestrong1">-ServerName "</span><span class="codestrongitalic">Server_Name</span><span class="codestrong1">"</span></p>
<p class="indent">By default, Azure prevents access to Azure SQL servers, except from other Azure services. Although this is great for security, it frustrates developers who want to connect to databases from their workstations. In fact, this was such a hassle that SQL Server Management Studio (the tool used to manage SQL databases) added a prompt during sign-on to Azure SQL servers that offers to automatically add the user’s current IP address to the firewall rules. Not surprisingly, this annoys developers whose IP addresses change frequently, so you will often find firewall rules in Azure SQL that <span epub:type="pagebreak" id="page_62"/>allow connections from any IP address in the world, or at least anywhere within a company’s network. Check the firewall to see what hosts you can use to bypass the firewall and target the SQL server directly.</p>
<h5 class="h3" id="lev88"><strong class="calibre2">SQL ARM PowerShell Cmdlets</strong></h5>
<p class="noindent">The ARM PowerShell extension has dozens more SQL-related commands than ASM PowerShell does, though most deal with less common features or are simply not relevant to a penetration tester. Perhaps the biggest hurdle with ARM, though, is that the resource group field of the <span class="literal">Get-AzureRmSqlServer</span> cmdlet is required. Fortunately, although this would normally mean that in order to see all the SQL servers you would need to run the command for each resource group in the subscription, PowerShell provides a shortcut. Simply pipe the output of <span class="literal">Get-AzureRmResourceGroup</span> to <span class="literal">Get-AzureRmSqlServer</span>, and you should see all the SQL servers, as shown in <a href="part0012.html#ch03list7" class="calibre6">Listing 3-7</a>.</p>
<p class="programs">PS C:\&gt; <span class="codestrong1">Get-AzureRmResourceGroup | Get-AzureRmSqlServer</span><br class="calibre5"/><br class="calibre5"/>ResourceGroupName        : <span class="codeitalic">Resource Group Name</span><br class="calibre5"/>ServerName               : <span class="codeitalic">Server Name</span><br class="calibre5"/>Location                 : Central US<br class="calibre5"/>SqlAdministratorLogin    : dba<br class="calibre5"/>SqlAdministratorPassword :<br class="calibre5"/>ServerVersion            : 12.0<br class="calibre5"/>Tags                     : {}</p>
<p class="listing" id="ch03list7"><em class="calibre7">Listing 3-7: Finding ARM-based SQL servers in PowerShell</em></p>
<h5 class="h3" id="lev89"><strong class="calibre2">Listing Databases in a Server</strong></h5>
<p class="noindent">PowerShell provides an ARM command to show all the databases within a SQL server, including the size, creation date, and region. To list the databases in a server, run the following command:</p>
<p class="programs">PS C:\&gt; <span class="codestrong1">Get-AzureRmSqlDatabase</span> <span class="codestrong1">-ServerName "</span><span class="codestrongitalic">Server_Name</span><span class="codestrong1">"</span><br class="calibre5"/>    <span class="codestrong1">-ResourceGroupName "</span><span class="codestrongitalic">Server_Resource_Group_Name</span><span class="codestrong1">"</span></p>
<p class="indent">To view SQL firewall rules for ARM, as well as the starting and ending IP addresses for each rule and its name, run this command:</p>
<p class="programs">PS C:\&gt; <span class="codestrong1">Get-AzureRmSqlServerFirewallRule</span> <span class="codestrong1">-ServerName "</span><span class="codestrongitalic">Server_Name</span><span class="codestrong1">"</span><br class="calibre5"/>    <span class="codestrong1">-ResourceGroupName "</span><span class="codestrongitalic">Server_Resource_Group_Name</span><span class="codestrong1">"</span></p>
<p class="indent">Finally, consider running the following to see if Azure’s threat detection tool is in operation:</p>
<p class="programs">PS C:\&gt; <span class="codestrong1">Get-AzureRmSqlServerThreatDetectionPolicy</span> <span class="codestrong1">-ServerName "</span><span class="codestrongitalic">Server_Name</span><span class="codestrong1">"</span><br class="calibre5"/>    <span class="codestrong1">-ResourceGroupName "</span><span class="codestrongitalic">Server_Resource_Group_Name</span><span class="codestrong1">"</span></p>
<p class="indent"><span epub:type="pagebreak" id="page_63"/>This tool monitors for attacks such as SQL injection. You will want to know if it’s running before launching a test that might trigger alerts.</p>
<div class="sidebar">
<p class="sidebart"><strong class="calibre4">DEFENDER’S TIP</strong></p>
<p class="spara">Be sure to take advantage of Azure’s security features. Regularly check to make sure that no one has added an allow-all rule to your SQL firewall, and enable new security features when they are added, such as SQL Threat Detection (<em class="calibre10"><a href="https://docs.microsoft.com/en-us/azure/sql-database/sql-database-threat-detection/" class="calibre11">https://docs.microsoft.com/en-us/azure/sql-database/sql-database-threat-detection/</a></em> ). Although no feature can guarantee the complete security of your system, each added control provides another layer of protection and makes an attack against your services that much harder. Make it hard enough that the attacker decides to go target someone else.</p>
</div>
<h5 class="h3" id="lev90"><strong class="calibre2">Using the CLI for Azure SQL</strong></h5>
<p class="noindent">You can use the CLI to gather information on Azure SQL, but keep in mind that it only offers SQL commands when in ASM mode. Also, the command to list databases within a SQL server instance requires the database account credentials, and there is no command to view the state of SQL Threat Detection (or any of the advanced SQL commands available in ARM PowerShell).</p>
<p class="indent">To use CLI to view SQL servers within a subscription, including the database name and the datacenter where it is hosted, run <span class="codestrong">azure sql server list</span>. Then run</p>
<p class="programs">C:\&gt;<span class="codestrong1">azure sql server show "</span><span class="codestrongitalic">Server_Name</span><span class="codestrong1">"</span></p>
<p class="noindent">to view additional details such as the database administrator username and server version. Finally, to check the firewall rules, enter <span class="codestrong">azure sql firewallrule list</span>. You can display a specific firewall rule with the following command:</p>
<p class="programs">C:\&gt;<span class="codestrong1">azure sql firewallrule show "</span><span class="codestrongitalic">Server_Name</span><span class="codestrong1">" "</span><span class="codestrongitalic">Rule_Name</span><span class="codestrong1">"</span></p>
<h3 class="h1" id="lev91"><strong class="calibre2">Consolidated PowerShell Scripts</strong></h3>
<p class="noindent">During a penetration test, I often have limited time to gather data, either because I have dozens of subscriptions to review or because I’m using a legitimate user’s system or credentials and the longer I use it, the greater the chance of my being detected. Therefore, I like having all the commands I need in one place in easy-to-run scripts.</p>
<p class="indent">In the sections that follow, I present scripts for both ASM PowerShell and ARM PowerShell. It’s important to have both handy because credentials <span epub:type="pagebreak" id="page_64"/>that work in one subscription model might not work in the other. Also, not all systems will have the ARM cmdlets installed. When not constrained by either limitation, I usually run both scripts. There’s always some duplication, but it’s better to get more information than to miss something.</p>
<p class="indent">I haven’t provided a script for the CLI tools because the PowerShell output is much easier to work with in scripting form. Also, you’re far less likely to be detected when penetration testing if you’re using the same tools your target uses. Most developers will have the Azure PowerShell extensions installed; far fewer will install the CLI.</p>
<p class="indent">You can download both scripts from the book’s website at <em class="calibre7"><a href="https://nostarch.com/azure/" class="calibre6">https://nostarch.com/azure/</a></em>. You may, of course, need to customize them for your particular scenario, adding authentication and such. (I find it’s easiest to launch a PowerShell window, authenticate with the credentials I have obtained, and then kick off the script.) You may also need to run the <span class="literal">Set-ExecutionPolicy -Scope Process Unrestricted</span> command so the system can run unsigned scripts, if you haven’t done so already in this PowerShell window.</p>
<h4 class="h2" id="lev92"><strong class="calibre2"><em class="calibre10">ASM Script</em></strong></h4>
<p class="noindent">The script shown in <a href="part0012.html#ch03list8" class="calibre6">Listing 3-8</a> iterates over the common ASM resources in a subscription and then displays information about those services. It uses all the ASM PowerShell commands discussed in this chapter.</p>
<p class="programs"># Requires the Azure PowerShell cmdlets be installed.<br class="calibre5"/># See https://github.com/Azure/azure-powershell/ for details.<br class="calibre5"/><br class="calibre5"/># Before running the script:<br class="calibre5"/>#   * Run: Import-Module Azure<br class="calibre5"/>#   * Authenticate to Azure in PowerShell<br class="calibre5"/>#   * You may also need to run: Set-ExecutionPolicy -Scope Process Unrestricted<br class="calibre5"/><br class="calibre5"/># Show subscription metadata<br class="calibre5"/>Write-Output (" Subscription ","==============")<br class="calibre5"/>Write-Output ("Get-AzureSubscription -Current")<br class="calibre5"/>Get-AzureSubscription -Current<br class="calibre5"/><br class="calibre5"/># Display websites<br class="calibre5"/>Write-Output ("", " Websites ","==========")<br class="calibre5"/>$sites = Get-AzureWebsite<br class="calibre5"/>Write-Output ("Get-AzureWebsite")<br class="calibre5"/>$sites<br class="calibre5"/>foreach ($site in $sites)<br class="calibre5"/>{<br class="calibre5"/>    Write-Output ("Get-AzureWebsite -Name " + $site.Name)<br class="calibre5"/>    Get-AzureWebsite -Name $site.Name<br class="calibre5"/>}<br class="calibre5"/><br class="calibre5"/># View virtual machines<br class="calibre5"/>Write-Output ("", " VMs ","=====")<br class="calibre5"/>$vms = Get-AzureVM<br class="calibre5"/>Write-Output ("Get-AzureVM")<br class="calibre5"/><span epub:type="pagebreak" id="page_65"/>$vms<br class="calibre5"/>foreach ($vm in $vms)<br class="calibre5"/>{<br class="calibre5"/>    Write-Output ("Get-AzureVM -ServiceName " + $vm.ServiceName)<br class="calibre5"/>    Get-AzureVM -ServiceName $vm.ServiceName<br class="calibre5"/>}<br class="calibre5"/><br class="calibre5"/># Enumerate Azure Storage<br class="calibre5"/>Write-Output ("", " Storage ","=========")<br class="calibre5"/>$SAs = Get-AzureStorageAccount<br class="calibre5"/>Write-Output ("Get-AzureStorageAccount")<br class="calibre5"/>$SAs<br class="calibre5"/>foreach ($sa in $SAs)<br class="calibre5"/>{<br class="calibre5"/>    Write-Output ("Get-AzureStorageKey -StorageAccountName" + $sa.StorageAccountName)<br class="calibre5"/>    Get-AzureStorageKey -StorageAccountName $sa.StorageAccountName<br class="calibre5"/>}<br class="calibre5"/><br class="calibre5"/># Get networking settings<br class="calibre5"/>Write-Output ("", " Networking ","============")<br class="calibre5"/>Write-Output ("Get-AzureReservedIP")<br class="calibre5"/>Get-AzureReservedIP<br class="calibre5"/><br class="calibre5"/>Write-Output ("", " Endpoints ","===========")<br class="calibre5"/># Show network endpoints for each VM<br class="calibre5"/>foreach ($vm in $vms)<br class="calibre5"/>{<br class="calibre5"/>    Write-Output ("Get-AzureEndpoint " + $vm.ServiceName)<br class="calibre5"/>    Get-AzureEndpoint -VM $vm<br class="calibre5"/>}<br class="calibre5"/><br class="calibre5"/># Dump NSGs<br class="calibre5"/>Write-Output ("", " NSGs ","======")<br class="calibre5"/>foreach ($vm in $vms)<br class="calibre5"/>{<br class="calibre5"/>    Write-Output ("NSG for " + $vm.ServiceName + ":")<br class="calibre5"/>    Get-AzureNetworkSecurityGroupAssociation -VM $vm -ServiceName $vm.ServiceName<br class="calibre5"/>}<br class="calibre5"/><br class="calibre5"/># Display SQL information<br class="calibre5"/>Write-Output ("", " SQL ","=====")<br class="calibre5"/>$sqlServers = Get-AzureSqlDatabaseServer<br class="calibre5"/>Write-Output ("Get-AzureSqlDatabaseServer")<br class="calibre5"/>$sqlServers<br class="calibre5"/>foreach ($ss in $sqlServers)<br class="calibre5"/>{<br class="calibre5"/>    Write-Output ("Get-AzureSqlDatabase -ServerName " + $ss.ServerName)<br class="calibre5"/>    Get-AzureSqlDatabase -ServerName $ss.ServerName<br class="calibre5"/>    Write-Output ("Get-AzureSqlDatabaseServerFirewallRule -ServerName " + $ss.ServerName)<br class="calibre5"/>    Get-AzureSqlDatabaseServerFirewallRule -ServerName $ss.ServerName<br class="calibre5"/>}</p>
<p class="listing" id="ch03list8"><em class="calibre7">Listing 3-8: Consolidated ASM PowerShell reconnaissance script</em></p>
<h4 class="h2" id="lev93"><span epub:type="pagebreak" id="page_66" class="calibre1"/><strong class="calibre2"><em class="calibre10">ARM Script</em></strong></h4>
<p class="noindent"><a href="part0012.html#ch03list9" class="calibre6">Listing 3-9</a> shows the ARM version of <a href="part0012.html#ch03list8" class="calibre6">Listing 3-8</a>. It’s slightly longer than the ASM version because it gathers more details about the subscription, VMs, and network interfaces.</p>
<p class="programs"># Requires the Azure PowerShell cmdlets be installed.<br class="calibre5"/># See https://github.com/Azure/azure-powershell/ for details.<br class="calibre5"/><br class="calibre5"/># Before running the script:<br class="calibre5"/>#   * Run: Import-Module Azure<br class="calibre5"/>#   * Authenticate to Azure in PowerShell<br class="calibre5"/>#   * You may also need to run Set-ExecutionPolicy -Scope Process Unrestricted<br class="calibre5"/><br class="calibre5"/># Show details of the current Azure subscription<br class="calibre5"/>Write-Output (" Subscription ","==============")<br class="calibre5"/>Write-Output ("Get-AzureRmContext")<br class="calibre5"/>$context = Get-AzureRmContext<br class="calibre5"/>$context<br class="calibre5"/>$context.Account<br class="calibre5"/>$context.Tenant<br class="calibre5"/>$context.Subscription<br class="calibre5"/><br class="calibre5"/>Write-Output ("Get-AzureRmRoleAssignment")<br class="calibre5"/>Get-AzureRmRoleAssignment<br class="calibre5"/><br class="calibre5"/>Write-Output ("", " Resources ","===========")<br class="calibre5"/># Show the subscription's resource groups and a list of its resources<br class="calibre5"/>Write-Output ("Get-AzureRmResourceGroup")<br class="calibre5"/>Get-AzureRmResourceGroup | Format-Table ResourceGroupName,Location,ProvisioningState<br class="calibre5"/>Write-Output ("Get-AzureRmResource")<br class="calibre5"/>Get-AzureRmResource | Format-Table Name,ResourceType,ResourceGroupName<br class="calibre5"/><br class="calibre5"/># Display Web Apps<br class="calibre5"/>Write-Output ("", " Web Apps ","==========")<br class="calibre5"/>Write-Output ("Get-AzureRmWebApp")<br class="calibre5"/>Get-AzureRmWebApp<br class="calibre5"/><br class="calibre5"/># List virtual machines<br class="calibre5"/>Write-Output ("", " VMs ","=====")<br class="calibre5"/>$vms = Get-AzureRmVM<br class="calibre5"/>Write-Output ("Get-AzureRmVM")<br class="calibre5"/>$vms<br class="calibre5"/>foreach ($vm in $vms)<br class="calibre5"/>{<br class="calibre5"/>    Write-Output ("Get-AzureRmVM -ResourceGroupName " + $vm.ResourceGroupName +<br class="calibre5"/>        "-Name " + $vm.Name)<br class="calibre5"/>    Get-AzureRmVM -ResourceGroupName $vm.ResourceGroupName -Name $vm.Name<br class="calibre5"/>    Write-Output ("HardwareProfile:")<br class="calibre5"/>    $vm.HardwareProfile<br class="calibre5"/>    Write-Output ("OSProfile:")<br class="calibre5"/>    $vm.OSProfile<br class="calibre5"/><span epub:type="pagebreak" id="page_67"/>    Write-Output ("ImageReference:")<br class="calibre5"/>    $vm.StorageProfile.ImageReference<br class="calibre5"/>}<br class="calibre5"/><br class="calibre5"/># Show Azure Storage<br class="calibre5"/>Write-Output ("", " Storage ","=========")<br class="calibre5"/>$SAs = Get-AzureRmStorageAccount<br class="calibre5"/>Write-Output ("Get-AzureRmStorageAccount")<br class="calibre5"/>$SAs<br class="calibre5"/>foreach ($sa in $SAs)<br class="calibre5"/>{<br class="calibre5"/>    Write-Output ("Get-AzureRmStorageAccountKey -ResourceGroupName " + $sa.ResourceGroupName +<br class="calibre5"/>        " -StorageAccountName" + $sa.StorageAccountName)<br class="calibre5"/>    Get-AzureRmStorageAccountKey -ResourceGroupName $sa.ResourceGroupName -StorageAccountName<br class="calibre5"/>        $sa.StorageAccountName<br class="calibre5"/>}<br class="calibre5"/><br class="calibre5"/># Get networking settings<br class="calibre5"/>Write-Output ("", " Networking ","============")<br class="calibre5"/>Write-Output ("Get-AzureRmNetworkInterface")<br class="calibre5"/>Get-AzureRmNetworkInterface<br class="calibre5"/>Write-Output ("Get-AzureRmPublicIpAddress")<br class="calibre5"/>Get-AzureRmPublicIpAddress<br class="calibre5"/><br class="calibre5"/># NSGs<br class="calibre5"/>Write-Output ("", " NSGs ","======")<br class="calibre5"/>foreach ($vm in $vms)<br class="calibre5"/>{<br class="calibre5"/>    $ni = Get-AzureRmNetworkInterface | where { $_.Id -eq $vm.NetworkInterfaceIDs }<br class="calibre5"/>    Write-Output ("Get-AzureRmNetworkSecurityGroup for " + $vm.Name + ":")<br class="calibre5"/>    Get-AzureRmNetworkSecurityGroup | where { $_.Id -eq $ni.NetworkSecurityGroup.Id }<br class="calibre5"/>}<br class="calibre5"/><br class="calibre5"/># Show SQL information<br class="calibre5"/>Write-Output ("", " SQL ","=====")<br class="calibre5"/>foreach ($rg in Get-AzureRmResourceGroup)<br class="calibre5"/>{<br class="calibre5"/>    foreach($ss in Get-AzureRmSqlServer -ResourceGroupName $rg.ResourceGroupName)<br class="calibre5"/>    {<br class="calibre5"/>        Write-Output ("Get-AzureRmSqlServer -ServerName" + $ss.ServerName +<br class="calibre5"/>            " -ResourceGroupName " + $rg.ResourceGroupName)<br class="calibre5"/>        Get-AzureRmSqlServer -ServerName $ss.ServerName -ResourceGroupName<br class="calibre5"/>            $rg.ResourceGroupName<br class="calibre5"/><br class="calibre5"/>        Write-Output ("Get-AzureRmSqlDatabase -ServerName" + $ss.ServerName +<br class="calibre5"/>            " -ResourceGroupName " + $rg.ResourceGroupName)<br class="calibre5"/>        Get-AzureRmSqlDatabase -ServerName $ss.ServerName -ResourceGroupName<br class="calibre5"/>            $rg.ResourceGroupName<br class="calibre5"/><br class="calibre5"/>        Write-Output ("Get-AzureRmSqlServerFirewallRule -ServerName" + $ss.ServerName +<br class="calibre5"/>            " -ResourceGroupName " + $rg.ResourceGroupName)<br class="calibre5"/>        Get-AzureRmSqlServerFirewallRule -ServerName $ss.ServerName -ResourceGroupName<br class="calibre5"/>            $rg.ResourceGroupName<br class="calibre5"/><br class="calibre5"/><span epub:type="pagebreak" id="page_68"/>        Write-Output ("Get-AzureRmSqlServerThreatDetectionPolicy -ServerName" +<br class="calibre5"/>            $ss.ServerName + " -ResourceGroupName " + $rg.ResourceGroupName)<br class="calibre5"/>        Get-AzureRmSqlServerThreatDetectionPolicy -ServerName<br class="calibre5"/>            $ss.ServerName -ResourceGroupName $rg.ResourceGroupName<br class="calibre5"/>    }<br class="calibre5"/>}</p>
<p class="listing" id="ch03list9"><em class="calibre7">Listing 3-9: Consolidated ARM PowerShell reconnaissance script</em></p>
<p class="noindent">Be sure to check the book’s website (<em class="calibre7"><a href="https://nostarch.com/azure/" class="calibre6">https://nostarch.com/azure/</a></em>) for updated versions of these scripts.</p>
<h3 class="h1" id="lev94"><strong class="calibre2">Summary</strong></h3>
<p class="noindent">I’ve covered a wide range of commands that you can use to understand how an Azure subscription is being used. I explained where to obtain Azure’s PowerShell and command line tools. I discussed various authentication methods to be used based on the type of credential you have captured. I showed how to discover websites, virtual machines, storage accounts, network settings, and SQL databases in a subscription. Finally, I provided you with scripts you can use to quickly query these services.</p>
<p class="indent">I see these techniques as indispensable for any thorough penetration test, as they help to draw a better picture of your client’s overall attack surface: non-production systems can often be used as a foothold to access production resources, yet they are often ignored in risk assessments. By including the entire subscription in your test, and not just those resources that are deemed most critical, you can significantly improve the value provided to your client.</p>
<p class="indent">In the next chapter, I’ll demonstrate some useful techniques for exploiting Azure Storage accounts.</p>
</body></html>