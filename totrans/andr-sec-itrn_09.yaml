- en: Chapter 9. Enterprise Security
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章. 企业安全
- en: Initial Android versions were mostly consumer-oriented, with limited enterprise
    features. However, as the platform has grown in popularity, Android devices have
    entered the workplace and are increasingly used to access corporate email, customer
    information, and other company data. As a result of this trend, the need for increased
    platform security and tools that allow effective management of employee devices
    has steadily grown. While Android’s primary focus remains general-purpose consumer
    devices, recent versions have introduced numerous enterprise features and Android
    will likely become even more enterprise-friendly as it develops.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 最初的 Android 版本主要面向消费者，企业功能有限。然而，随着该平台的普及，Android 设备已进入职场，并越来越多地用于访问公司电子邮件、客户信息及其他公司数据。由于这一趋势，平台安全性需求以及允许有效管理员工设备的工具也稳步增长。虽然
    Android 的主要焦点仍是通用消费类设备，但最近的版本已引入了许多企业功能，随着发展，Android 很可能会变得更加适合企业使用。
- en: In this chapter, we discuss Android’s major enterprise-oriented features and
    demonstrate how they can be used to both increase device security and provide
    centralized device policy management. We’ll begin with device administration,
    and show how it can be integrated into third-party applications. We then look
    into Android’s VPN support and describe the APIs that allow new VPN solutions
    to be developed as third-party, user-installed applications. Next we show how
    Android implements different authentication methods supported by the EAP authentication
    framework and describe how it manages credentials. Finally, we demonstrate how
    to add an EAP profile programmatically using the extended Wi-Fi management APIs
    added in Android 4.3.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论 Android 的主要企业导向功能，并展示如何使用它们来提高设备安全性并提供集中式设备策略管理。我们将从设备管理开始，展示如何将其集成到第三方应用程序中。然后，我们将探讨
    Android 对 VPN 的支持，并描述允许开发新的 VPN 解决方案作为第三方用户安装应用程序的 API。接着，我们展示 Android 如何实现 EAP
    认证框架支持的不同认证方法，并描述它是如何管理凭证的。最后，我们将演示如何使用 Android 4.3 中新增的扩展 Wi-Fi 管理 API 编程添加 EAP
    配置文件。
- en: Device Administration
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备管理
- en: Android 2.2 introduced support for a Device Administration API, which makes
    it possible to develop applications that can both enforce a systemwide security
    policy and dynamically adapt their features based on the device’s current security
    level. Such applications are called *device administrators*. Device administrators
    must be explicitly enabled in the device’s security settings and cannot be uninstalled
    if they are active. When enabled, they’re granted special privileges that allow
    them to lock the device, change the lockscreen password, and even wipe the device
    (delete all user data). Device administrators are often coupled with a specific
    type of enterprise account (such as a Microsoft Exchange or Google Apps account),
    which allows enterprise administrators to control access to corporate data by
    allowing access only to devices that conform to the required security policy.
    Security policies can be static and built into the device administrator application,
    or they can be configured on the server side and sent to the device as part of
    a provisioning or synchronization protocol.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Android 2.2 引入了设备管理 API，允许开发可以执行系统范围安全策略并根据设备当前的安全级别动态调整其功能的应用程序。这类应用程序称为*设备管理员*。设备管理员必须在设备的安全设置中显式启用，并且如果它们处于活动状态，无法卸载。启用后，它们将获得特殊权限，允许它们锁定设备、修改锁屏密码，甚至清除设备（删除所有用户数据）。设备管理员通常与特定类型的企业账户（如
    Microsoft Exchange 或 Google Apps 账户）配合使用，允许企业管理员通过仅允许符合所需安全策略的设备访问企业数据，从而控制对公司数据的访问。安全策略可以是静态的，内置在设备管理员应用程序中，或者可以在服务器端配置，并作为配置或同步协议的一部分发送到设备。
- en: As of version 4.4, Android supports the policy types listed in [Table 9-1](ch09.html#supported_device_administration_policies
    "Table 9-1. Supported Device Administration Policies"). The policy constants are
    defined in the `DeviceAdminInfo` class.^([[87](#ftn.ch09fn01)])
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 4.4 开始，Android 支持在[表 9-1](ch09.html#supported_device_administration_policies
    "Table 9-1. Supported Device Administration Policies")中列出的策略类型。策略常量在`DeviceAdminInfo`类中定义。^([[87](#ftn.ch09fn01)])
- en: Table 9-1. Supported Device Administration Policies
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9-1. 支持的设备管理策略
- en: '| Policy Constant/XML Tag | Value (bit to set) | Description | API Level |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| 策略常量/XML 标签 | 值（设置位） | 描述 | API 级别 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `USES_POLICY_LIMIT_PASSWORD <limit-password>` | 0 | Limit the passwords that
    the user can select by setting a minimum length or complexity. | 8 |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| `USES_POLICY_LIMIT_PASSWORD <limit-password>` | 0 | 通过设置最小长度或复杂度来限制用户可选择的密码。
    | 8 |'
- en: '| `USES_POLICY_WATCH_LOGIN <watch-login>` | 1 | Watch login attempts by a user.
    | 8 |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| `USES_POLICY_WATCH_LOGIN <watch-login>` | 1 | 监视用户的登录尝试。 | 8 |'
- en: '| `USES_POLICY_RESET_PASSWORD <reset-password>` | 2 | Reset a user’s password.
    | 8 |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| `USES_POLICY_RESET_PASSWORD <reset-password>` | 2 | 重置用户的密码。 | 8 |'
- en: '| `USES_POLICY_FORCE_LOCK <force-lock>` | 3 | Force the device to lock, or
    limit the maximum lock timeout. | 8 |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| `USES_POLICY_FORCE_LOCK <force-lock>` | 3 | 强制设备锁定，或限制最大锁定超时。 | 8 |'
- en: '| `USES_POLICY_WIPE_DATA <wipe-data>` | 4 | Factory reset the device, erasing
    all user data. | 8 |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `USES_POLICY_WIPE_DATA <wipe-data>` | 4 | 恢复出厂设置，擦除所有用户数据。 | 8 |'
- en: '| `USES_POLICY_SETS_GLOBAL_PROXY <set-global-proxy>` | 5 | Specify the device
    global proxy. (This is hidden from SDK applications.) | 9 |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `USES_POLICY_SETS_GLOBAL_PROXY <set-global-proxy>` | 5 | 指定设备的全局代理。（此项对 SDK
    应用隐藏。） | 9 |'
- en: '| `USES_POLICY_EXPIRE_PASSWORD <expire-password>` | 6 | Force the user to change
    their password after an administrator-defined time limit. | 11 |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `USES_POLICY_EXPIRE_PASSWORD <expire-password>` | 6 | 强制用户在管理员定义的时间限制后更改密码。
    | 11 |'
- en: '| `USES_ENCRYPTED_STORAGE <encrypted-storage>` | 7 | Require stored data to
    be encrypted. | 11 |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `USES_ENCRYPTED_STORAGE <encrypted-storage>` | 7 | 要求存储的数据进行加密。 | 11 |'
- en: '| `USES_POLICY_DISABLE_CAMERA <disable-camera>` | 8 | Disable the use of all
    device cameras. | 14 |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `USES_POLICY_DISABLE_CAMERA <disable-camera>` | 8 | 禁用所有设备相机的使用。 | 14 |'
- en: '| `USES_POLICY_DISABLE_KEYGUARD_FEATURES <disable-keyguard-features>` | 9 |
    Disable the use of keyguard features such as lockscreen widgets or camera support.
    | 17 |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `USES_POLICY_DISABLE_KEYGUARD_FEATURES <disable-keyguard-features>` | 9 |
    禁用锁屏功能，例如锁屏小部件或相机支持。 | 17 |'
- en: Each device administration application must list the policies it intends to
    use in a metadata file (see “[Privilege Management](ch09.html#privilege_management
    "Privilege Management")” for details). The list of supported policies is displayed
    to the user when they activate the administrator app, as shown in [Figure 9-1](ch09.html#device_administrator_activation_screen
    "Figure 9-1. Device administrator activation screen").
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每个设备管理应用必须在元数据文件中列出其打算使用的策略（有关详细信息，请参见“[权限管理](ch09.html#privilege_management
    "权限管理")”）。当用户激活管理员应用时，支持的策略列表将显示给用户，如[图 9-1](ch09.html#device_administrator_activation_screen
    "图 9-1. 设备管理员激活屏幕")所示。
- en: Implementation
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: Now that we know which policies can be enforced with the Device Administration
    API, let’s look at the internal implementation. Like most public Android APIs,
    a manager class called `DevicePolicyManager`^([[88](#ftn.ch09fn02)]) exposes part
    of the functionality of the underlying system service, `DevicePolicyManagerService`.
    However, because the `DevicePolicyManager` facade class defines constants and
    translates service exceptions to return codes but otherwise adds little functionality,
    we’ll focus on the `DevicePolicyManagerService` class.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道哪些策略可以通过设备管理 API 强制执行，接下来让我们看看内部实现。像大多数公共 Android API 一样，一个名为`DevicePolicyManager`^([[88](#ftn.ch09fn02)])的管理类暴露了底层系统服务`DevicePolicyManagerService`的一部分功能。然而，由于`DevicePolicyManager`外观类定义了常量并将服务异常转换为返回码，但除此之外增加的功能不多，因此我们将重点关注`DevicePolicyManagerService`类。
- en: '![Device administrator activation screen](figs/web/09fig01.png.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![设备管理员激活屏幕](figs/web/09fig01.png.jpg)'
- en: Figure 9-1. Device administrator activation screen
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-1. 设备管理员激活屏幕
- en: Like most system services, `DevicePolicyManagerService` is started by and runs
    within the *system_server* process as the *system* user, and thus can execute
    almost all Android privileged actions. Unlike most system services, it can grant
    access to certain privileged actions (such as changing the lockscreen password)
    to third-party applications, which do not need to hold any special system permissions.
    This makes it possible for users to enable and disable device administrators on
    demand, and guarantees that device administrators can only enforce policies that
    they have explicitly declared. However, this level of flexibility cannot be easily
    implemented with standard Android permissions that are only granted at install
    time and cannot be revoked (with some exceptions, as discussed in [Chapter 2](ch02.html
    "Chapter 2. Permissions")). Therefore, `DevicePolicyManagerService` employs a
    different method for privilege management.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 和大多数系统服务一样，`DevicePolicyManagerService`由*system_server*进程启动并运行，且以*system*用户身份运行，因此可以执行几乎所有Android特权操作。与大多数系统服务不同，它可以将某些特权操作（例如更改锁屏密码）的访问权限授予第三方应用程序，而这些应用程序无需持有任何特殊的系统权限。这使得用户能够按需启用和禁用设备管理员，并保证设备管理员只能执行他们明确声明的策略。然而，这种灵活性无法通过标准的Android权限轻松实现，因为这些权限仅在安装时授予，且无法撤销（有些例外，详见[第2章](ch02.html
    "第2章. 权限")）。因此，`DevicePolicyManagerService`采用了一种不同的特权管理方法。
- en: Another interesting aspect of Android’s device administration implementation
    relates to how policies are managed and enforced. We describe device administrator
    privilege management and policy enforcement in detail next.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Android设备管理实现的另一个有趣方面与策略的管理和执行有关。接下来，我们将详细描述设备管理员特权管理和策略执行。
- en: Privilege Management
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特权管理
- en: At runtime, the `DevicePolicyManagerService` keeps an internal, on-memory list
    of policy structures for each device user. (Policies are also persisted on disk
    in an XML file, as described in the next section.)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，`DevicePolicyManagerService`会为每个设备用户保持一个内部的、内存中的策略结构列表。（策略也会保存在磁盘上的XML文件中，具体细节见下一节。）
- en: Each policy structure contains the currently effective policy for a certain
    user and a list of metadata about each active device administrator. Because each
    user can enable more than one application with device administrator functionality,
    the currently active policy is calculated by selecting the strictest defined policy
    among all administrators. The metadata about each active device administrator
    contains information about the declaring application, and a list of declared policies
    (represented by a bitmask).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个策略结构包含当前某个用户的有效策略和关于每个活动设备管理员的元数据列表。由于每个用户可以启用多个具有设备管理员功能的应用程序，因此当前的活动策略是通过在所有管理员中选择定义最严格的策略来计算的。关于每个活动设备管理员的元数据包含有关声明应用程序的信息，以及声明的策略列表（由位掩码表示）。
- en: 'The `DevicePolicyManagerService` decides whether to grant access to privileged
    operations to a calling application based on its internal list of active policies:
    if the calling application is currently an active device administrator, and it
    has requested the policy that corresponds to the current request (API call), only
    then is the request granted and the operation executed. In order to confirm that
    an active administrator component really belongs to the calling application, `DevicePolicyManagerService`
    compares the UID of the calling process (returned by `Binder.getCallingUid()`)
    with the UID associated with the target administrator component. For example,
    an application that calls the `resetPassword()` needs to be an active device administrator,
    have the same UID as the registered administrator component, and have requested
    the `USES_POLICY_RESET_PASSWORD` policy in order for the call to succeed.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`DevicePolicyManagerService`根据其内部活动策略列表来决定是否授予调用应用程序特权操作的访问权限：只有当调用应用程序当前是一个活动设备管理员，且请求的策略与当前请求（API调用）相对应时，请求才会被授予，操作才会执行。为了确认一个活动管理员组件确实属于调用应用程序，`DevicePolicyManagerService`将调用进程的UID（由`Binder.getCallingUid()`返回）与目标管理员组件的UID进行比较。例如，调用`resetPassword()`的应用程序需要是一个活动设备管理员，且其UID与注册的管理员组件相同，并已请求`USES_POLICY_RESET_PASSWORD`策略，才能使调用成功。'
- en: Policies are requested by adding an XML resource file that lists all policies
    that a device administrator application wants to use as children of the `<uses-policies>`
    tag. Before a device administrator is activated, the system parses the XML file
    and displays a dialog similar to the one in [Figure 9-1](ch09.html#device_administrator_activation_screen
    "Figure 9-1. Device administrator activation screen"), allowing the user to review
    the requested policies before enabling the administrator. Much like Android permissions,
    administrator policies are granted on an all-or-nothing basis, and there is no
    way to selectively enable only certain policies. A resource file that requests
    all policies might look like [Example 9-1](ch09.html#declaring_policies_in_a_device_administr
    "Example 9-1. Declaring policies in a device administrator application") (for
    the policy corresponding to each tag, see the first column of [Table 9-1](ch09.html#supported_device_administration_policies
    "Table 9-1. Supported Device Administration Policies")). You can find more details
    about adding this file to a device administrator application in “[Adding a Device
    Administrator](ch09.html#adding_a_device_administrator "Adding a Device Administrator")”.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加一个列出设备管理员应用希望使用的所有策略的 XML 资源文件，并将其作为`<uses-policies>`标签的子项，来请求策略。在激活设备管理员之前，系统会解析
    XML 文件并显示一个类似于[图 9-1](ch09.html#device_administrator_activation_screen "图 9-1.
    设备管理员激活屏幕")的对话框，允许用户在启用管理员之前审查请求的策略。与 Android 权限类似，管理员策略是全选或全不选的，无法选择性地启用某些策略。请求所有策略的资源文件可能类似于[示例
    9-1](ch09.html#declaring_policies_in_a_device_administr "示例 9-1. 在设备管理员应用中声明策略")（每个标签对应的策略，请参见[表
    9-1](ch09.html#supported_device_administration_policies "表 9-1. 支持的设备管理策略")的第一列）。你可以在“[添加设备管理员](ch09.html#adding_a_device_administrator
    "添加设备管理员")”中找到更多关于将此文件添加到设备管理员应用的详细信息。
- en: Example 9-1. Declaring policies in a device administrator application
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-1. 在设备管理员应用中声明策略
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In order to be notified about policy-related system events and to be allowed
    access to the Device Administration API, device administrators must be activated
    first. This is achieved by calling the `setActiveAdmin()` method of the `DevicePolicyManagerService`.
    Because this method requires the `MANAGE_DEVICE_ADMINS` permission, which is a
    system signature permission, only system applications can add a device administrator
    without user interaction.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了接收与策略相关的系统事件通知，并允许访问设备管理 API，设备管理员必须首先被激活。这是通过调用`DevicePolicyManagerService`的`setActiveAdmin()`方法实现的。由于此方法需要`MANAGE_DEVICE_ADMINS`权限，而该权限是系统签名权限，因此只有系统应用可以在没有用户交互的情况下添加设备管理员。
- en: User-installed device administrator applications can only request to be activated
    by starting the `ACTION_ADD_DEVICE_ADMIN` implicit intent with code similar to
    [Example 9-2](ch09.html#requesting_device_administrator_activati "Example 9-2. Requesting
    device administrator activation"). The only handler for this intent is the system
    Settings application, which holds the `MANAGE_DEVICE_ADMINS` permission. Upon
    receiving the intent, the Settings applications checks whether the requesting
    application is a valid device administrator, extracts the requested policies,
    and builds the confirmation dialog shown in [Figure 9-1](ch09.html#device_administrator_activation_screen
    "Figure 9-1. Device administrator activation screen"). The user pressing the Activate
    button calls the `setActiveAdmin()` method, which adds the application to the
    list of active administrators for the current device user.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 用户安装的设备管理员应用只能通过启动`ACTION_ADD_DEVICE_ADMIN`隐式意图来请求激活，代码类似于[示例 9-2](ch09.html#requesting_device_administrator_activati
    "示例 9-2. 请求设备管理员激活")。唯一处理此意图的应用是系统设置应用，它拥有`MANAGE_DEVICE_ADMINS`权限。在接收到意图后，设置应用检查请求的应用是否是有效的设备管理员，提取请求的策略，并构建[图
    9-1](ch09.html#device_administrator_activation_screen "图 9-1. 设备管理员激活屏幕")中显示的确认对话框。用户点击激活按钮后，调用`setActiveAdmin()`方法，将该应用添加到当前设备用户的活动管理员列表中。
- en: Example 9-2. Requesting device administrator activation
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-2. 请求设备管理员激活
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Policy Persistence
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 策略持久化
- en: When a device administrator is activated, deactivated, or its policies are updated,
    changes are written to the *device_policies.xml* file for the target user. For
    the owner user, that file is stored under */data/system/*, and for all other users
    it’s written to the user’s system directory (*/data/users/<user-ID>/*). The file
    is owned by and only modifiable by the *system* user (file permissions 0600).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当设备管理员被激活、停用或其策略更新时，变更会被写入目标用户的 *device_policies.xml* 文件。对于所有者用户，该文件存储在 */data/system/*
    下，对于其他用户，则写入到该用户的系统目录（*/data/users/<user-ID>/*）。该文件由 *system* 用户拥有，并且只能由 *system*
    用户修改（文件权限为 0600）。
- en: The *device_policies.xml* file contains information about each active administrator
    and its policies, as well some global information about the current lockscreen
    password. The file might look like [Example 9-3](ch09.html#contents_of_the_devicesunderscorepolicie
    "Example 9-3. Contents of the devices_policies.xml file").
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*device_policies.xml* 文件包含有关每个活动管理员及其策略的信息，以及有关当前锁屏密码的一些全局信息。该文件可能类似于 [示例 9-3](ch09.html#contents_of_the_devicesunderscorepolicie
    "示例 9-3. devices_policies.xml 文件内容")。'
- en: Example 9-3. Contents of the devices_policies.xml file
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-3. devices_policies.xml 文件内容
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This example has three active device administrators, each represented by an
    `<admin>` element (➊, ➋, and ➎). The policies of each administrator app are stored
    in the `flags` attribute of the `<policies>` tag ➌.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例有三个活动设备管理员，每个管理员都由一个 `<admin>` 元素表示（➊、➋ 和 ➎）。每个管理员应用程序的策略存储在 `<policies>`
    标签的 `flags` 属性中 ➌。
- en: A policy is considered enabled if its corresponding bit is set (see the Value
    column of [Table 9-1](ch09.html#supported_device_administration_policies "Table 9-1. Supported
    Device Administration Policies")). For example, because the *DeviceAdminSample*
    application has requested all currently available policies, its `flags` attribute
    has the value 1023 (0x3FF, or 1111111111 in binary).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果相应的位被设置，则认为该策略已启用（参见 [表 9-1](ch09.html#supported_device_administration_policies
    "表 9-1. 支持的设备管理策略") 的值列）。例如，由于 *DeviceAdminSample* 应用程序请求了所有当前可用的策略，其 `flags`
    属性的值为 1023 (0x3FF，或 1111111111 的二进制表示)。
- en: If the administrator defines password quality restrictions (for example, alphanumeric
    or complex), they are persisted as the `value` attribute of the `<password-quality>`
    tag ➍. In this example, the value 327680 (0x50000) corresponds to `PASSWORD_QUALITY_ALPHANUMERIC`.
    (Password quality constants are defined in the `DevicePolicyManager` class.)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果管理员定义了密码质量限制（例如，字母数字或复杂），它们会作为 `<password-quality>` 标签的 `value` 属性被保存 ➍。在此示例中，值
    327680 (0x50000) 对应于 `PASSWORD_QUALITY_ALPHANUMERIC`。（密码质量常量在 `DevicePolicyManager`
    类中定义。）
- en: The values of other policy requirements, such as password length and device
    encryption, are also stored as children of each `<admin>` element. If the password
    has been set programmatically by using the `resetPassword()` method, *device_policies.xml*
    contains a `<password-owner>` tag that stores the UID of the application that
    sets the password in its `value` attribute ➏. Finally, the `<active-password>`
    tag contains details about the complexity of the current password ➐.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 其他策略要求的值，如密码长度和设备加密，也作为每个 `<admin>` 元素的子元素进行存储。如果密码是通过使用 `resetPassword()` 方法编程设置的，*device_policies.xml*
    会包含一个 `<password-owner>` 标签，其 `value` 属性存储设置密码的应用程序的 UID ➏。最后，`<active-password>`
    标签包含有关当前密码复杂性的详细信息 ➐。
- en: Policy Enforcement
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 策略强制执行
- en: Device administrator policies have different granularity and can be enforced
    either for the current user or for all users on a device. Some policies are not
    enforced by the system at all—the system only notifies the declaring administration
    application, which is then responsible for taking an appropriate action. In this
    section, we describe how each type of policy is implemented and enforced.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 设备管理员策略具有不同的粒度，可以对当前用户或设备上的所有用户强制执行。有些策略根本没有被系统强制执行——系统只会通知声明的管理应用程序，由其负责采取适当的行动。在本节中，我们将描述每种类型的策略是如何实现和强制执行的。
- en: '**`USES_POLICY_LIMIT_PASSWORD`**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**`USES_POLICY_LIMIT_PASSWORD`**'
- en: After one or more password restrictions have been set, users cannot enter a
    password that does not fulfill the current policy. However, the system does not
    require passwords to be changed immediately, so the current password remains in
    effect until changed. Administrator applications can prompt the user for a new
    password by starting an implicit intent with the `DevicePolicyManager.ACTION_SET_NEW_PASSWORD`
    action.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个或多个密码限制后，用户不能输入不符合当前策略的密码。然而，系统并不要求立即更改密码，因此当前密码将在更改之前继续有效。管理员应用程序可以通过启动一个隐式意图，并使用`DevicePolicyManager.ACTION_SET_NEW_PASSWORD`操作来提示用户设置新密码。
- en: Because each device user has a separate unlock password, password quality policies
    are applied per-user. When password quality is set, unlock methods that do not
    allow for a password of the desired quality are disabled. For example, setting
    password quality to `PASSWORD_ QUALITY_ALPHANUMERIC` disables the Pattern and
    PIN unlock methods, as shown in [Figure 9-2](ch09.html#setting_a_password_quality_policy_disabl
    "Figure 9-2. Setting a password quality policy disables incompatible unlock methods").
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个设备用户都有单独的解锁密码，密码质量策略是按用户应用的。当设置密码质量时，不允许设置所需密码质量的解锁方法将被禁用。例如，将密码质量设置为`PASSWORD_QUALITY_ALPHANUMERIC`会禁用图案和PIN解锁方法，如[图
    9-2](ch09.html#setting_a_password_quality_policy_disabl "图 9-2. 设置密码质量策略禁用不兼容的解锁方法")所示。
- en: '![Setting a password quality policy disables incompatible unlock methods](figs/web/09fig02.png.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![设置密码质量策略禁用不兼容的解锁方法](figs/web/09fig02.png.jpg)'
- en: Figure 9-2. Setting a password quality policy disables incompatible unlock methods
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-2. 设置密码质量策略禁用不兼容的解锁方法
- en: '**`USES_POLICY_WATCH_LOGIN`**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**`USES_POLICY_WATCH_LOGIN`**'
- en: This policy enables device administrators to receive notifications about the
    outcome of login attempts. Notifications are sent with the `ACTION_PASSWORD_FAILED`
    and `ACTION_PASSWORD_SUCCEEDED` broadcasts. Broadcast receivers that derive from
    `DeviceAdminReceiver` are automatically notified via the `onPasswordFailed()`
    and `onPasswordSucceeded()` methods.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此策略允许设备管理员接收关于登录尝试结果的通知。通知通过`ACTION_PASSWORD_FAILED`和`ACTION_PASSWORD_SUCCEEDED`广播发送。继承自`DeviceAdminReceiver`的广播接收器会通过`onPasswordFailed()`和`onPasswordSucceeded()`方法自动接收通知。
- en: '**`USES_POLICY_RESET_PASSWORD`**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**`USES_POLICY_RESET_PASSWORD`**'
- en: This policy enables administrator applications to set the current user’s password
    via the `resetPassword()` API. The specified password must satisfy the current
    password quality requirements and takes effect immediately. Note that if the device
    is encrypted, setting the lockscreen password for the owner user also changes
    the device encryption password. ([Chapter 10](ch10.html "Chapter 10. Device Security")
    provides more detail on device encryption.)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此策略允许管理员应用程序通过`resetPassword()` API 设置当前用户的密码。指定的密码必须满足当前密码质量要求，并立即生效。请注意，如果设备已加密，为拥有者用户设置锁屏密码时也会更改设备加密密码。（[第10章](ch10.html
    "第10章. 设备安全")提供了关于设备加密的更多详细信息。）
- en: '**`USES_POLICY_FORCE_LOCK`**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**`USES_POLICY_FORCE_LOCK`**'
- en: This policy allows administrators to lock the device immediately by calling
    the `lockNow()` method, or to specify the maximum time for user inactivity until
    the device locks automatically via `setMaximumTimeToLock()`. Setting the maximum
    time to lock takes effect immediately and limits the inactivity sleep time that
    users can set via the system Display settings.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此策略允许管理员通过调用`lockNow()`方法立即锁定设备，或通过`setMaximumTimeToLock()`指定用户不活动的最大时间，直到设备自动锁定。设置最大锁定时间立即生效，并限制用户可以通过系统显示设置调整的不活动睡眠时间。
- en: '**`USES_POLICY_WIPE_DATA`**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**`USES_POLICY_WIPE_DATA`**'
- en: This policy allows device administrators to wipe user data by calling the `wipeData()`
    API. Applications that also request the `USES_POLICY_WATCH_LOGIN` policy can set
    the number of failed login attempts before the device is wiped automatically via
    the `setMaximumFailedPasswordsForWipe()` API. When the number of failed passwords
    is set to a value greater than zero, the lockscreen implementation notifies the
    `DevicePolicyManagerService` and displays a warning dialog after each failed attempt,
    and triggers a data wipe once the threshold is reached. If the wipe is triggered
    by an unsuccessful login attempt by the owner user, a full device wipe is performed.
    If, on the other hand, the wipe is triggered by a secondary user, only that user
    (and any associated data) is deleted and the device switches to the owner user.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 该政策允许设备管理员通过调用`wipeData()` API来擦除用户数据。申请了`USES_POLICY_WATCH_LOGIN`政策的应用程序可以通过`setMaximumFailedPasswordsForWipe()`
    API设置设备在自动擦除数据前允许的最大登录失败次数。当设置的登录失败次数大于零时，锁屏实现会在每次登录失败后通知`DevicePolicyManagerService`并显示警告对话框，一旦达到阈值就触发数据擦除。如果擦除是由于所有者用户的登录失败触发的，则会执行完全擦除。如果擦除是由次要用户的登录失败触发的，则只会删除该用户及其相关数据，设备会切换回所有者用户。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: '*Full device wipe is not immediate, but is implemented by writing a `wipe_data`
    command in the* cache *partition and rebooting into recovery mode. The recovery
    OS is responsible for executing the actual device wipe. Therefore, if the device
    has a custom recovery image that ignores the wipe command, or if the user manages
    to boot into a custom recovery and delete or modify the command file, the device
    wipe might not be executed. ([Chapter 10](ch10.html "Chapter 10. Device Security")
    and [Chapter 13](ch13.html "Chapter 13. System Updates and Root Access") discuss
    recovery images in more detail.)*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*完全擦除设备数据并非即时进行，而是通过在* 缓存 *分区写入`wipe_data`命令并重启进入恢复模式来实现的。恢复操作系统负责执行实际的设备数据擦除。因此，如果设备有一个自定义恢复镜像忽略了擦除命令，或者用户设法进入自定义恢复模式并删除或修改了命令文件，设备擦除可能不会执行。（[第10章](ch10.html
    "第10章. 设备安全")和[第13章](ch13.html "第13章. 系统更新与root访问")更详细地讨论了恢复镜像。）*'
- en: '**`USES_POLICY_SETS_GLOBAL_PROXY`**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**`USES_POLICY_SETS_GLOBAL_PROXY`**'
- en: As of Android 4.4, this policy is not available to third-party applications.
    It allows device administrators to set the global proxy server host (`Settings.Global.GLOBAL_HTTP_PROXY_HOST`),
    port (`GLOBAL_HTTP_PROXY_PORT`), and the list of excluded hosts (`GLOBAL_HTTP_PROXY_EXCLUSION_LIST`)
    by writing to the global system settings provider. Only the device owner is allowed
    to set global proxy settings.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从Android 4.4开始，这项政策不适用于第三方应用程序。它允许设备管理员通过写入全局系统设置提供者来设置全局代理服务器主机（`Settings.Global.GLOBAL_HTTP_PROXY_HOST`）、端口（`GLOBAL_HTTP_PROXY_PORT`）和排除的主机列表（`GLOBAL_HTTP_PROXY_EXCLUSION_LIST`）。只有设备所有者才能设置全局代理设置。
- en: '**`USES_POLICY_EXPIRE_PASSWORD`**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**`USES_POLICY_EXPIRE_PASSWORD`**'
- en: This policy allows administrators to set the password expiration timeout via
    the `setPasswordExpirationTimeout()` API. If an expiration timeout is set, the
    system registers a daily alarm that checks for password expiration. If the password
    has already expired, `DevicePolicyManagerService` posts daily password change
    notifications until it is changed. Device administrators are notified about password
    expiration status via the `Dev iceAdminReceiver.onPasswordExpiring()` method.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 该政策允许管理员通过`setPasswordExpirationTimeout()` API设置密码过期超时。如果设置了过期超时，系统会注册一个每日闹钟以检查密码是否过期。如果密码已经过期，`DevicePolicyManagerService`会每天发布密码更改通知，直到密码被更改。设备管理员会通过`DeviceAdminReceiver.onPasswordExpiring()`方法收到密码过期状态的通知。
- en: '**`USES_ENCRYPTED_STORAGE`**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**`USES_ENCRYPTED_STORAGE`**'
- en: This policy allows administrators to request that device storage be encrypted
    via the `setStorageEncryption()` API. Only the owner user can request storage
    encryption. Requesting storage encryption does not automatically start the device
    encryption process if the device is not encrypted; device administrators must
    check the current storage status by using the `getStorageEncryptionStatus()` API
    (which checks the *ro.crypto.state* read-only system property), and start the
    encryption process. Device encryption can be kicked off by starting the associated
    system activity with the `ACTION_START_ENCRYPTION` implicit intent.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此政策允许管理员请求通过`setStorageEncryption()` API加密设备存储。只有所有者用户才能请求存储加密。如果设备尚未加密，请求存储加密不会自动启动设备加密过程；设备管理员必须使用`getStorageEncryptionStatus()`
    API（该API检查*ro.crypto.state*只读系统属性）检查当前存储状态，并启动加密过程。可以通过启动相关的系统活动并带上`ACTION_START_ENCRYPTION`隐式意图来启动设备加密。
- en: '**`USES_POLICY_DISABLE_CAMERA`**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**`USES_POLICY_DISABLE_CAMERA`**'
- en: This policy allows device administrators to disable all cameras on the device
    via the `setCameraDisabled()` API. Camera is disabled by setting the *sys.secpolicy.camera.disabled*
    system property to 1\. The native system `CameraService` checks this property
    and disallows all connections if it is set to 1, effectively disabling the camera
    for all users of the device.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此政策允许设备管理员通过`setCameraDisabled()` API禁用设备上的所有摄像头。通过将*sys.secpolicy.camera.disabled*系统属性设置为1来禁用摄像头。原生系统`CameraService`会检查此属性，并在其值为1时禁止所有连接，从而有效地禁用设备上所有用户的摄像头。
- en: '**`USES_POLICY_DISABLE_KEYGUARD_FEATURES`**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**`USES_POLICY_DISABLE_KEYGUARD_FEATURES`**'
- en: This policy allows administrators to disable keyguard customizations such as
    lockscreen widgets by calling the `setKeyguardDisabledFeatures()` method. The
    system keyguard implementation checks if this policy is in effect and disables
    the corresponding features for the target user.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此政策允许管理员通过调用`setKeyguardDisabledFeatures()`方法禁用锁屏小部件等键盘保护定制功能。系统键盘保护实现会检查此政策是否生效，并为目标用户禁用相应功能。
- en: Adding a Device Administrator
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加设备管理员
- en: As with other applications, device administrators can either be included in
    the system image or they can be installed by users. If an administrator is part
    of the system image, it can be set as the *device owner app* in Android 4.4 and
    later, which is a special kind of device admin that cannot be disabled by the
    user and cannot be uninstalled. In this section, we’ll show how to implement a
    device admin app and then demonstrate how a system app can be set as the device
    owner.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他应用一样，设备管理员可以包含在系统镜像中，也可以由用户安装。如果管理员是系统镜像的一部分，它可以在Android 4.4及更高版本中设置为*设备所有者应用*，这是一种特殊的设备管理员，用户无法禁用且无法卸载。在本节中，我们将展示如何实现一个设备管理员应用，并演示如何将系统应用设置为设备所有者。
- en: Implementing a Device Administrator
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现设备管理员
- en: A device administrator application needs to declare a broadcast receiver that
    requires the `BIND_DEVICE_ADMIN` permission (➊ in [Example 9-4](ch09.html#device_administrator_broadcast_receiver
    "Example 9-4. Device administrator broadcast receiver declaration")), declares
    an XML resource file that lists the policies it uses ➋, and responds to the `ACTION_DEVICE_ADMIN_ENABLED`
    intent ➌. [Example 9-1](ch09.html#declaring_policies_in_a_device_administr "Example 9-1. Declaring
    policies in a device administrator application") shows a sample policy declaration.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 设备管理员应用需要声明一个广播接收器，并要求`BIND_DEVICE_ADMIN`权限（➊ 在[示例 9-4](ch09.html#device_administrator_broadcast_receiver
    "示例 9-4. 设备管理员广播接收器声明")中），声明一个列出其使用的政策的XML资源文件 ➋，并响应`ACTION_DEVICE_ADMIN_ENABLED`意图
    ➌。[示例 9-1](ch09.html#declaring_policies_in_a_device_administr "示例 9-1. 在设备管理员应用中声明政策")展示了一个示例政策声明。
- en: Example 9-4. Device administrator broadcast receiver declaration
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-4. 设备管理员广播接收器声明
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The Android SDK provides a base class that you can derive your receiver from,
    namely `android.app.admin.DeviceAdminReceiver`. This class defines a number of
    callback methods that you can override in order to handle the device policy-related
    broadcasts sent by the system. The default implementations are empty, but at a
    minimum you should override the `onEnabled()` and `onDisabled()` methods in order
    to be notified when the administrator is enabled or disabled. Device administrators
    cannot use any privileged APIs before `onEnabled()` is called or after `onDisabled()`
    is called.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `isAdminActive()` API at any time to see if an application is
    currently an active device administrator. As mentioned in “[Privilege Management](ch09.html#privilege_management
    "Privilege Management")”, an administrator cannot activate itself automatically,
    but must start a system activity to prompt for user confirmation with code similar
    to [Example 9-2](ch09.html#requesting_device_administrator_activati "Example 9-2. Requesting
    device administrator activation"). However, when already active, an administrator
    can deactivate itself by calling the `removeActiveAdmin()` method.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*See the official Device Administration API guide*^([[89](#ftn.ch09fn03)])
    *for more details and a full working example application.*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Setting the Device Owner
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A device administrator application that’s part of the system image (that is,
    its APK file is installed on the *system* partition) can be set as the device
    owner by calling the `setDeviceOwner(String packageName, String ownerName)` method
    (not visible in the public SDK API). The first parameter in this method specifies
    the package name of the target application, and the second specifies the name
    of the owner to be displayed in the UI. While this method requires no special
    permissions, it can only be called before a device is provisioned (that is, if
    the global setting `Settings.Global.DEVICE_PROVISIONED` is set to 0), which means
    that it can only be called by system applications that execute as part of device
    initialization.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: A successful call to this method writes a *device_owner.xml* file (like the
    one in [Example 9-5](ch09.html#contents_of_the_deviceunderscoreownerdot "Example 9-5. Contents
    of the device_owner.xml file")) to */data/system/*. Information about the current
    device owner can be obtained using the `getDeviceOwner()`, `isDeviceOwner()` (which
    is exposed as `isDeviceOwnerApp()` in the Android SDK API) and `getDeviceOwnerName()`
    methods.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-5. Contents of the device_owner.xml file
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When a device owner is activated, either as part of the provisioning process
    or by the user, it cannot be disabled and uninstalled, as shown in [Figure 9-3](ch09.html#device_owner_administrator_cannot_be_dis
    "Figure 9-3. A device owner administrator cannot be disabled.").
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '![A device owner administrator cannot be disabled.](figs/web/09fig03.png.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: Figure 9-3. A device owner administrator cannot be disabled.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Managed Devices
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A device with an owner administrator installed is called a *managed device*,
    and it reacts differently to configuration changes that affect device security
    than unmanaged devices. As discussed in [Chapter 6](ch06.html "Chapter 6. Network
    Security and PKI") and [Chapter 7](ch07.html "Chapter 7. Credential Storage"),
    Android allows users to install certificates in the system trust store either
    via the system Settings application, or by using third-party applications that
    call the `KeyChain` API. If there are user-installed certificates in the system
    trust store, as of version 4.4 Android shows a warning (see [Figure 6-6](ch06.html#network_monitoring_warning_in_android_4d
    "Figure 6-6. Network monitoring warning in Android 4.4")) notifying users that
    their communications can be monitored.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Enterprise networks often require trusted certificates (for example, the root
    certificate of a corporate PKI) to be installed in order to access enterprise
    services. Such certificates can be silently installed or removed by device administrators
    that hold the `MANAGE_CA_ CERTIFICATES` system permissions via the `installCaCert()`
    and `uninstallCaCert()` methods of the `DevicePolicyManager` class (these methods
    are reserved for system applications and aren’t visible in the public SDK API).
    If an additional trusted certificate is installed on a managed device, the network
    monitoring warning changes to a less scary information message, as shown in [Figure 9-4](ch09.html#network_monitoring_information_message_s
    "Figure 9-4. Network monitoring information message shown on managed devices").
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Enterprise Account Integration
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned in “[Device Administration](ch09.html#device_administration "Device
    Administration")”, device administrator applications are often coupled with enterprise
    accounts, in order to allow some control over devices that access company data.
    In this section, we’ll discuss two such implementations: one in the stock Email
    application, which works with Microsoft Exchange ActiveSync accounts, and the
    other in the dedicated Google Apps Device Policy application, which works with
    corporate Google accounts.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '![Network monitoring information message shown on managed devices](figs/web/09fig04.png.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
- en: Figure 9-4. Network monitoring information message shown on managed devices
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Exchange ActiveSync
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Microsoft Exchange ActiveSync* (usually abbreviated as *EAS*) is a protocol
    that supports email, contacts, calendar, and task synchronization from a groupware
    server to a mobile device. It’s supported both by Microsoft’s own Exchange Server,
    and by most competing products, including Google Apps.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: The Email application included in Android supports ActiveSync accounts and data
    synchronization via dedicated account authenticators (see [Chapter 8](ch08.html
    "Chapter 8. Online Account Management")) and sync adapters. In order to allow
    enterprise administrators to enforce a security policy on devices that access
    email and other corporate data, the Email application doesn’t allow synchronization
    until the built-in device administrator is enabled by the user. The administrator
    can set lockscreen password rules, erase all data, require storage encryption,
    and disable device cameras, as shown in [Figure 9-5](ch09.html#device_administrator_policies_required_f
    "Figure 9-5. Device administrator policies required for using an EAS account").
    However, the policies are not built into the app but fetched from the service
    using the EAS Provision protocol.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![Device administrator policies required for using an EAS account](figs/web/09fig05.png.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: Figure 9-5. Device administrator policies required for using an EAS account
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Google Apps
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The corporate version of Google’s Gmail service, Google Apps, also supports
    setting mobile device security policies. If the feature is enabled by the domain
    administrator, Google Apps account holders can also remotely locate, ring, lock,
    or wipe their Android devices. Domain administrators can also selectively delete
    a Google Apps account and all of its associated content from a managed device,
    without performing a full wipe. Both security policy enforcement and remote device
    management are implemented in the dedicated Google Apps Device Policy application
    (see ➎ in [Example 9-3](ch09.html#contents_of_the_devicesunderscorepolicie "Example 9-3. Contents
    of the devices_policies.xml file")).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: When first started, the application requests that the user enable the built-in
    device administrator and displays the current domain policy settings as shown
    in [Figure 9-6](ch09.html#policy_enforcement_confirmation_in_the_g "Figure 9-6. Policy
    enforcement confirmation in the Google Apps Device Policy application").
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Domain administrators define policies in the Google Apps admin console (see
    [Figure 9-7](ch09.html#google_apps_device_policy_management_ui "Figure 9-7. Google
    Apps device policy management UI")), and policy settings are pushed to devices
    using Google’s proprietary sync protocol.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: While free Google accounts do not support setting a device policy, Google experience
    devices can use the basic device administrator built into Google Play Services
    (see ➊ in [Example 9-3](ch09.html#contents_of_the_devicesunderscorepolicie "Example 9-3. Contents
    of the devices_policies.xml file")). This administrator allows Google account
    holders to remotely locate or wipe their devices using the Android Device Manager
    website or the associated Android application.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '![Policy enforcement confirmation in the Google Apps Device Policy application](figs/web/09fig06.png.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
- en: Figure 9-6. Policy enforcement confirmation in the Google Apps Device Policy
    application
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '![Google Apps device policy management UI](figs/web/09fig07.png.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
- en: Figure 9-7. Google Apps device policy management UI
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: VPN Support
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *Virtual Private Network (VPN)* allows a private network to be extended across
    a public network without requiring a dedicated physical connection, thus enabling
    all connected devices to send and receive data as if colocated and physically
    connected to the same private network. When a VPN is used to allow individual
    devices to connect to a target private network, it’s referred to as a *remote
    access VPN*, and when used to connect two remote networks, as a *site-to-site
    VPN*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Remote-access VPNs can connect fixed devices with a static IP address, such
    as a computer in a remote office, but configurations where mobile clients use
    variable network connections and dynamic addresses are much more common. Such
    a configuration is often called a *road warrior* configuration and is the configuration
    most commonly used with Android VPN clients.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: In order to ensure that data transmitted over a VPN remains private, VPNs typically
    authenticate remote clients and provide data confidentiality and integrity by
    using a secure tunneling protocol. VPN protocols are complex because they work
    at multiple network layers simultaneously and often involve multiple levels of
    encapsulation in order to be compatible with various network configurations. A
    thorough discussion of them is beyond the scope of his book, but in the following
    sections you’ll find a brief overview of the major types of VPN protocols, with
    a focus on the ones available on Android.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: PPTP
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Point-to-Point Tunneling Protocol (PPTP)* uses a TCP control channel to
    establish connections and the Generic Routing Encapsulation (GRE) tunneling protocol
    to encapsulate Point-to-Point Protocol (PPP) packets. Several authentication methods
    such as Password Authentication Protocol (PAP), Challenge-Handshake Authentication
    Protocol (CHAP), and its Microsoft extension MS-CHAP v1/v2, as well as EAP-TLS,
    are supported, but only EAP-TLS is currently considered secure.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: The PPP payload can be encrypted using the Microsoft Point-to-Point Encryption
    (MPPE) protocol, which uses the RC4 stream cipher. Because MPPE does not employ
    any form of ciphertext authentication, it is vulnerable to bit-flipping attacks.
    In addition, multiple problems with the RC4 cipher have been uncovered in recent
    years, which further reduces the security of MMPE and PPTP.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: L2TP/IPSec
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Layer 2 Tunneling Protocol (L2TP)* is similar to PPTP and exists at the
    data link layer (Layer 2 in the OSI model). Because L2TP provides no encryption
    or confidentiality of its own (it relies on the tunneled protocol to implement
    these features), an L2TP VPN is typically implemented using a combination of L2TP
    and the Internet Protocol Security (IPSec) protocol suite, which adds authentication,
    confidentiality, and integrity.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: In an L2TP/IPSec configuration, a secure channel is first established using
    IPSec, and an L2TP tunnel is then established over the secure channel. L2TP packets
    are always wrapped inside IPSec packets and are therefore secure. An IPSec connection
    requires establishing a *Security Association (SA)*, which is a combination of
    cryptographic algorithm and mode, encryption key, and other parameters required
    to establish a secure channel.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: SAs are established using the Internet Security Association and Key Management
    Protocol (ISAKMP). ISAKMP does not define a particular key exchange method and
    is typically implemented either by manual configuration of pre-shared secrets,
    or by using the Internet Key Exchange (IKE and IKEv2) protocol. IKE uses X.509
    certificates for peer authentication (much like SSL), and a Diffie-Hellman key
    exchange in order to establish a shared secret, which is used to derive the actual
    session encryption keys.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: IPSec Xauth
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*IPSec Extended Authentication (Xauth)* extends IKE to include additional user
    authentication exchanges. This allows an existing user database or a RADIUS infrastructure
    to be used to authenticate remote access clients, and makes it possible to integrate
    two-factor authentication.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '*Mode-configuration (Modecfg)* is another IPSec extension that is often used
    in a remote access scenario. Modecfg allows VPN servers to push network configuration
    information such as the private IP address and DNS server addresses to clients.
    When used in combination, Xauth and Modecfg make it possible to create a pure-IPSec
    VPN solution, which doesn’t rely on additional protocols for authentication and
    tunneling.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: SSL-Based VPNs
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SSL-based VPNs use SSL or TLS (see [Chapter 6](ch06.html "Chapter 6. Network
    Security and PKI")) to establish a secure connection and tunnel network traffic.
    No single standard defines SSL-based VPNs, and different implementations use different
    strategies in order to establish a secure channel and encapsulate packets.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: OpenVPN is a popular open source application that uses SSL for authentication
    and key exchange (preconfigured shared static keys are also supported), and a
    custom encryption protocol^([[90](#ftn.ch09fn04)]) to encrypt and authenticate
    packets. OpenVPN multiplexes the SSL session used for authentication and key exchange,
    and the encrypted packets stream over a single UDP (or TCP) port. The multiplexing
    protocol provides a reliable transport layer for SSL on top of UDP, but it tunnels
    encrypted IP packets over UDP without adding reliability. Reliability is provided
    by the tunneled protocol itself, which is usually TCP.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: The main advantages of OpenVPN over IPSec are that it is much simpler and can
    be implemented entirely in userspace. IPSec, on the other hand, requires kernel-level
    support and implementation of multiple interoperating protocols. Additionally,
    it’s easier to get OpenVPN traffic through firewalls, NAT, and proxies because
    it uses the common network protocols TCP and UDP and can multiplex tunneled traffic
    over a single port.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: The following sections examine Android’s built-in VPN support and the APIs it
    provides for applications that want to implement additional VPN solutions. We’ll
    also review the components that make up Android’s VPN infrastructure and show
    how it protects VPN credentials.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Legacy VPN
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Prior to Android 4.0, VPN support was entirely built into the platform and wasn’t
    extensible. Support for new VPN types could only be added as part of platform
    updates. To distinguish it from application-based implementations, built-in VPN
    support is referred to as *legacy VPN*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Early Android versions supported different VPN configurations based on PPTP
    and L2TP/IPsec, with support for “pure-IPSec” VPNs using IPSec Xauth added in
    version 4.0\. In addition to new built-in VPN configurations, Android 4.0 also
    introduced application-based VPNs by supplying the base platform class `VpnService`,
    which applications could extend in order to implement a new VPN solution.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Legacy VPN is controlled via the system Settings application and is only available
    to the owner (also called the primary user) on multi-user devices. [Figure 9-8](ch09.html#legacy_vpn_profile_definition_dialog
    "Figure 9-8. Legacy VPN profile definition dialog") shows the dialog for adding
    a new IPSec legacy VPN profile.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![Legacy VPN profile definition dialog](figs/web/09fig08.png.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: Figure 9-8. Legacy VPN profile definition dialog
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Legacy VPNs are implemented using a combination of kernel drivers as well as
    native daemons, commands, and system services. The lower-level implementation
    of PPTP and L2TP tunneling uses an Android-specific PPP daemon called *mtpd* and
    the PPPoPNS and PPPoLAC (only available in Android kernels) kernel drivers.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Because legacy VPNs support only a single VPN connection per device, *mtpd*
    can create only a single session. IPSec VPNs leverage the built-in kernel support
    for IPSec and a modified *racoon* IKE key management daemon (part of the IPSec-Tools^([[91](#ftn.ch09fn05)])
    utilities package that complements the Linux kernel IPSec implementation; *racoon*
    supports only IKEv1). [Example 9-6](ch09.html#racoon_and_mtpd_definition_in_initdotrc
    "Example 9-6. racoon and mtpd definition in init.rc") shows how these two daemons
    are defined in *init.rc*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-6. racoon and mtpd definition in init.rc
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Both *racoon* ➊ and *mtpd* ➍ create control sockets (➋ and ➎), which are only
    accessible by the *system* user and are not started by default. Both daemons have
    *vpn*, *net_admin* (mapped by the kernel to the `CAP_NET_ADMIN` Linux capability),
    and *inet* added to their supplementary groups (➌ and ➏), which allow them to
    create sockets and control network interface devices. The *mtpd* daemon also receives
    the *net_raw* group (mapped to the `CAP_NET_RAW` Linux capability), which allows
    it to create GRE sockets (used by PPTP).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: When a VPN is started via the system Settings app, Android starts the *racoon*
    and *mtpd* daemons and sends them control commands via their local sockets in
    order to establish the configured connection. The daemons create the requested
    VPN tunnel, and then create and configure a tunnel network interface with the
    received IP address and network mask. While *mtpd* performs interface configuration
    internally, *racoon* uses the helper command `ip-up-vpn` to bring up the tunnel
    interface, which is usually *tun0*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: In order to communicate connection parameters back to the framework, VPN daemons
    write a *state* file in */data/misc/vpn/* as shown in [Example 9-7](ch09.html#contents_of_the_vpn_state_file
    "Example 9-7. Contents of the VPN state file").
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-7. Contents of the VPN state file
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The file contains the tunnel interface name ➊, its IP address and mask ➋, configured
    routes ➌, DNS servers ➍, and search domains ➎, with each on a new line.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: After the VPN daemons start running, the framework parses the *state* file and
    calls the system `ConnectivityService` in order to configure routing, DNS servers,
    and search domains for the newly established VPN connection. In turn, `ConnectivityService`
    sends control commands via the local control socket of the *netd* daemon, which
    can modify the kernel’s packet filtering and routing tables because it runs as
    root. Traffic from all applications started by the owner user and restricted profiles
    is routed through the VPN interface by adding a firewall rule that matches the
    application UID and corresponding routing rules. (We discuss per-application traffic
    routing and multi-user support in detail in “[Multi-User Support](ch09.html#multi-user_support-id00019
    "Multi-User Support")”).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Profile and Credential Storage
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each VPN configuration created via the Settings app is called a *VPN profile*
    and is saved on disk in encrypted form. Encryption is performed by the Android
    credential storage daemon *keystore*, with a device-specific key. (See [Chapter 7](ch07.html
    "Chapter 7. Credential Storage") for more on credential storage implementation.)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'VPN profiles are serialized by concatenating all configured properties, which
    are delimited by a *NUL* character (*\0*) in a single profile string that is saved
    to the system keystore as a binary blob. VPN profile filenames are generated by
    appending the current time in milliseconds (in hexadecimal format) to the *VPN_*
    prefix. For example, [Example 9-8](ch09.html#contents_of_the_keystore_directory_when
    "Example 9-8. Contents of the keystore directory when VPN profiles are configured")
    shows the *keystore* directory of a user with three configured VPN profiles (file
    timestamps omitted):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-8. Contents of the `keystore` directory when VPN profiles are configured
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The three VPN profiles are stored in the *1000_VPN_144965b85a6* ➎, *1000_VPN_145635c88c8*
    ➏, and *1000_VPN_14569512c80* ➐ files. The *1000_* prefix represents the owner
    user, which is *system* (UID 1000). Because VPN profiles are owned by the *system*
    user, only system applications can retrieve and decrypt profile contents.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 9-9](ch09.html#contents_of_vpn_profile_files "Example 9-9. Contents
    of VPN profile files") shows the decrypted contents of the three VPN profile files.
    (The *NUL* character has been replaced with vertical bar [`|`] for readability.)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-9. Contents of VPN profile files
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The profile files contain all fields shown in the VPN profile edit dialog (see
    [Figure 9-8](ch09.html#legacy_vpn_profile_definition_dialog "Figure 9-8. Legacy
    VPN profile definition dialog")), with missing properties represented by an empty
    string. The first five fields represent the name of the VPN, the type of VPN,
    the VPN gateway host, the username, and the password, respectively. In [Example 9-9](ch09.html#contents_of_vpn_profile_files
    "Example 9-9. Contents of VPN profile files"), the first VPN profile ➊ is for
    an L2TP/IPsec VPN with pre-shared key (type 1); the second profile ➋ is for a
    PPTP VPN (type 0), and the last one ➌ is for a IPSec VPN that uses certificates
    and Xauth authentication (type 4).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the username and password, VPN profile files also contain all
    other credentials required to connect to the VPN. In the case of the first VPN
    profile ➊ in [Example 9-9](ch09.html#contents_of_vpn_profile_files "Example 9-9. Contents
    of VPN profile files"), the additional credential is the pre-shared key required
    to establish an IPSec secure connection (represented by the *PSK* string in this
    example). In the case of the third profile ➌, the additional credentials are the
    user’s private key and certificate. However, as you can see in the listing, the
    full key and certificate are not included; instead, the profile contains only
    the alias (*vpnclient*) of the key and certificate (both share a common alias).
    The private key and certificate are stored in the system credential store, and
    the alias included in the VPN profile serves only as an identifier, which is used
    to access or retrieve the key and certificate.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Credentials
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *racoon* daemon, which originally used keys and certificates stored in PEM
    files, was modified to use Android’s *keystore* OpenSSL engine. As discussed in
    [Chapter 7](ch07.html "Chapter 7. Credential Storage"), the *keystore* engine
    is a gateway to the system credential store, which can take advantage of hardware-backed
    credential store implementations when available. When passed a key alias, it uses
    the corresponding private key to sign authentication packets, without extracting
    the key from the keystore.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: The VPN profile ➌ in [Example 9-9](ch09.html#contents_of_vpn_profile_files "Example 9-9. Contents
    of VPN profile files") also contains the alias of the CA certificate (*cacert*),
    which is used as a trust anchor when validating the server’s certificate. At runtime,
    the framework retrieves the client certificate (➌ in [Example 9-8](ch09.html#contents_of_the_keystore_directory_when
    "Example 9-8. Contents of the keystore directory when VPN profiles are configured"))
    and the CA certificate (➊ in [Example 9-8](ch09.html#contents_of_the_keystore_directory_when
    "Example 9-8. Contents of the keystore directory when VPN profiles are configured"))
    from the system keystore and passes them to *racoon* via the control socket, along
    with other connection parameters. The private key blob (➍ in [Example 9-8](ch09.html#contents_of_the_keystore_directory_when
    "Example 9-8. Contents of the keystore directory when VPN profiles are configured"))
    is never directly passed to the *racoon* daemon, only its alias (*vpnclient*).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*While private keys are protected by hardware on devices with a hardware-backed
    keystore, pre-shared keys or passwords stored in a VPN profile content are not.
    The reason for this is that as of this writing, Android doesn’t support importing
    symmetric keys in the hardware-backed keystore; it only supports asymmetric keys
    (RSA, DSA, and EC). As a result, credentials for VPNs that use pre-shared keys
    are stored in the VPN profile in plaintext form and can be extracted from devices
    that allow root access after the profile is decrypted on memory.*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Always-On VPN
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android 4.2 and later supports an *always-on* VPN configuration, which blocks
    all network connections from applications until a connection to the specified
    VPN profile is established. This prevents applications from sending data across
    insecure channels, such as public Wi-Fi networks.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an always-on VPN requires setting up a VPN profile that specifies
    the VPN gateway as an IP address, and specifies an explicit DNS server IP address.
    This explicit configuration is required in order to make sure that DNS traffic
    isn’t sent to the locally configured DNS server, which is blocked when an always-on
    VPN is in effect. The VPN profile selection dialog is shown in [Figure 9-9](ch09.html#always-on_vpn_profile_selection_dialog
    "Figure 9-9. Always-on VPN profile selection dialog").
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: The profile selection is saved with other VPN profiles in the encrypted file
    *LOCKDOWN_VPN* (➋ in [Example 9-8](ch09.html#contents_of_the_keystore_directory_when
    "Example 9-8. Contents of the keystore directory when VPN profiles are configured"))
    which contains only the name of the selected profile; in our example, *144965b85a6*.
    If the *LOCKDOWN_VPN* file is present, the system automatically connects to the
    specified VPN when the device boots. If the underlying network connection reconnects
    or changes (for example, when switching Wi-Fi hotspots), the VPN is automatically
    restarted.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '![Always-on VPN profile selection dialog](figs/web/09fig09.png.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
- en: Figure 9-9. Always-on VPN profile selection dialog
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: An always-on VPN guarantees that all traffic goes through the VPN by installing
    firewall rules that block all packets except those which go through the VPN interface.
    The rules are installed by the `LockdownVpnTracker` class (always-on VPN is referred
    to as *lockdown VPN* in Android source code), which monitors VPN state and adjusts
    the current firewall state by sending commands to the *netd* daemon, which in
    turn executes the `iptables` utility in order to modify the kernels packet filtering
    tables. For example, when an always-on L2TP/IPSec VPN has connected to a VPN server
    with IP address 11.22.33.44 and has created a tunnel interface *tun0* with IP
    address 10.1.1.1, the installed firewall rules (as reported by `iptables`; some
    columns have been omitted for brevity) might look like [Example 9-10](ch09.html#always-on_vpn_firewall_rules
    "Example 9-10. Always-on VPN firewall rules").
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-10. Always-on VPN firewall rules
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see in the listing, all traffic to and from the VPN network is allowed
    (➊ and ➎), as is all traffic on the tunnel interface (➋ and ➏). Traffic to and
    from the VPN server (➌ and ➐) is allowed only on the ports used by IPSec (500
    and 4500) and L2TP (1701). All other incoming traffic is dropped ➍, and all other
    outgoing traffic is rejected ➑.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Application-Based VPNs
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android 4.0 added a `VpnService` public API^([[92](#ftn.ch09fn06)]) that third-party
    applications can use to build VPN solutions that are neither built into the OS
    nor require system-level permissions. The `VpnService` and associated `Builder`
    class let applications specify network parameters such as interface IP address
    and routes, which the system uses to create and configure a virtual network interface.
    Applications receive a file descriptor associated with that network interface
    and can tunnel network traffic by reading from or writing to the file descriptor
    of the interface.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Each read retrieves an outgoing IP packet, and each write injects an incoming
    IP packet. Because raw access to network packets effectively lets applications
    intercept and modify network traffic, application-based VPNs cannot be started
    automatically and always require user interaction. Additionally, an ongoing notification
    is shown while a VPN is connected. The connection warning dialog for an application-based
    VPN might look like [Figure 9-10](ch09.html#application-based_vpn_connection_warning
    "Figure 9-10. Application-based VPN connection warning dialog").
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![Application-based VPN connection warning dialog](figs/web/09fig10.png.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: Figure 9-10. Application-based VPN connection warning dialog
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a VPN
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An application-based VPN is implemented by creating a service component that
    extends the `VpnService` base class and registering it in the application manifest,
    as shown in [Example 9-11](ch09.html#registering_a_vpn_service_in_the_applica
    "Example 9-11. Registering a VPN service in the application manifest").
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-11. Registering a VPN service in the application manifest
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The service must have an intent filter that matches the *android.net.VpnService*
    intent action ➋ so that the system can bind to the service and control it. In
    addition, the service must require the `BIND_VPN_SERVICE` system signature permission
    ➊, which guarantees that only system applications can bind to it.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the VPN
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To register a new VPN connection with the system, the application first calls
    `VpnService.prepare()` in order to be granted permission to run, and then calls
    the `establish()` method in order to create a network tunnel (discussed in the
    next section). The `prepare()` method returns an intent that’s used to start the
    warning dialog shown in [Figure 9-10](ch09.html#application-based_vpn_connection_warning
    "Figure 9-10. Application-based VPN connection warning dialog"). The dialog serves
    to obtain the user’s permission and ensure that only one VPN connection per user
    is running at any time. If `prepare()` is called while a VPN connection created
    by another application is running, that connection is terminated. The `prepare()`
    method saves the package name of the calling application, and only that application
    is allowed to start a VPN connection until the method is called again, or the
    system tears down the VPN connection (for example, if the VPN app’s process crashes).
    When a VPN connection is deactivated for any reason, the system calls the `onRevoke()`
    method of the current VPN application’s `VpnService` implementation.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Establishing a VPN Connection
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After a VPN application has been prepared and granted permission to run, it
    can start its `VpnService` component, which would then typically create a tunnel
    to the VPN gateway and negotiate the network parameters for the VPN connection.
    Next, it sets up the `VpnService.Builder` class using those parameters and calls
    `VpnService.establish()` in order to receive a file descriptor to read and write
    packets. The `establish()` method first ensures that it’s being called by the
    application currently granted permission to establish a VPN connection by comparing
    the UID of the caller to the granted application’s UID. `establish()` then checks
    whether the current Android user is allowed to create VPN connections, and verifies
    that the service requires the `BIND_VPN_SERVICE` permission; if the service doesn’t
    require that permission, it’s considered insecure and a `SecurityException` is
    thrown. Next, the `establish()` method creates and configures a tunnel interface
    using native code, and sets up routing and DNS servers.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Notifying the User About the VPN Connection
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last step in establishing a VPN connection is to show an ongoing notification
    that tells the user that network traffic is been tunneled through a VPN, which
    allows them to monitor and control the connection via the associated control dialog.
    The dialog for the OpenVPN for Android application is shown in [Figure 9-11](ch09.html#application-based_vpn_management_dialog
    "Figure 9-11. Application-based VPN management dialog").
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: This dialog is part of the dedicated package `com.android.vpndialogs`, which
    is the only package explicitly allowed to manage application-based VPN connections,
    other than the *system* user. This ensures that a VPN connection can only be started
    and managed via the system-mandated UI.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Using the application-based VPN framework, applications are free to implement
    network tunneling, with any required authentication and encryption methods. Because
    all packets the device sends or receives pass through the VPN application, it
    can be used not only for tunneling but also for traffic logging, filtering, or
    modification (such as removing advertisements).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*For a full-featured implementation of an application-based VPN that takes
    advantage of Android’s credential store to manage authentication keys and certificates,
    see the source code for OpenVPN for Android.*^([[93](#ftn.ch09fn07)]) *This application
    implements an SSL VPN client that is fully compatible with the OpenVPN server.*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Multi-User Support
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, on multi-user devices, legacy VPNs can be controlled only
    by the owner user. However, with its introduction of multi-user support, Android
    4.2 and higher allows all secondary users (with the exception of restricted profiles,
    which must share the primary user’s VPN connection) to start application-based
    VPNs. While this change technically allowed each user to start their own VPN,
    because only one application-based VPN could be activated at a time, traffic for
    all device users was routed through the currently active VPN regardless of who
    started it. Android 4.4 finally brought full multi-user VPN support by introducing
    *per-user VPN*, which allows traffic from any user to be routed through their
    VPN, thus isolating it from other users’ traffic.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Linux Advanced Routing
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![Application-based VPN management dialog](figs/web/09fig11.png.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
- en: Figure 9-11. Application-based VPN management dialog
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Android uses several advanced packet filtering and routing features of the Linux
    kernel in order to implement per-user VPNs. These features (implemented by the
    *netfilter* kernel framework) include the *owner* module of the Linux *iptables*
    tool, which allows matching of locally generated packets based on the UID, GID,
    or PID of the process that created them. For example, the command shown at ➊ in
    [Example 9-12](ch09.html#using_owner_matching_and_packet_marking "Example 9-12. Using
    owner matching and packet marking with iptables") creates a packet-filtering rule
    that drops all outgoing packets generated by the user with UID 1234.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-12. Using owner matching and packet marking with iptables
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Another important netfilter feature is the ability to mark packets that match
    a certain selector with a specified number (called a *mark*). For example, the
    rule at ➋ marks all packets destined for port 80 (which is typically used by a
    web server) with the mark 0x1\. This mark can then be matched in later filtering
    or routing rules in order to, for example, send marked packets through a particular
    interface by adding a routing rule that sends marked packets to a predefined routing
    table, which is *web* in our example ➌. Finally, a route that sends packets matching
    the *web* table to the *em3* interface can be added with the command shown at
    ➍.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Multi-User VPN Implementation
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android uses these packet filtering and routing features to mark packets originating
    from all apps of a particular Android user and send them through the tunneling
    interface created by the VPN app started by that user. When the owner user starts
    a VPN, that VPN is shared with any restricted profiles on the device that cannot
    start their own VPNs by matching all packets originating from restricted profiles
    and routing them through the owner’s VPN tunnel.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: This split-routing is implemented at the framework level by the `NetworkManagementService`,
    which provides APIs to manage package matching and routing by UID or UID range.
    `NetworkManagementService` implements those APIs by sending commands to the native
    *netd* daemon which runs as root, and thus can modify the kernel’s packet filtering
    and routing tables. *netd* manipulates the kernel’s filtering and routing configuration
    by calling the *iptables* and *ip* userland utilities.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Let’s illustrate Android’s per-user VPN routing with an example as shown in
    [Example 9-13](ch09.html#packet_matching_rules_for_vpns_started_b "Example 9-13. Packet
    matching rules for VPNs started by two different device users"). The primary user
    (user ID 0) and the first secondary user (user ID 10) have each started an application-based
    VPN. The owner user’s VPN is assigned the *tun0* tunneling interface, and the
    secondary user’s VPN is assigned the *tun1* interface. The device also has a restricted
    profile with user ID 13\. [Example 9-13](ch09.html#packet_matching_rules_for_vpns_started_b
    "Example 9-13. Packet matching rules for VPNs started by two different device
    users") shows the state of the kernel’s packet filtering tables when both VPNs
    are connected (with some details omitted).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-13. Packet matching rules for VPNs started by two different device
    users
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Outgoing packets are first sent to the *st_mangle_OUTPUT* chain, which is responsible
    for matching and marking packets. Packets exempt from peruser routing (those already
    marked with 0x1 ➊), and packets originating from legacy VPNs (UID 1016 ➋, assigned
    to the built-in *vpn* user, which both *mtd* and *racoon* run as) pass without
    modification.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, packets created by processes running with UIDs between 0 and 99999 (the
    range of UIDs assigned to apps started by the primary user, as discussed in [Chapter 4](ch04.html
    "Chapter 4. User Management")) are matched and sent to the *st_mangle_tun0_ OUTPUT*
    chain ➌. Packets originating from UIDs 1300000–1399999, the range assigned to
    our restricted profile (user ID 13), are sent to the same chain ➍. Thus, traffic
    originating from the owner user and the restricted profile is treated the same
    way. Packets originating from the first secondary user (user ID 10, UID range
    1000000-1099999) are, however, sent to a different chain, *st_mangle_tun1_OUTPUT*
    ➎. The target chains themselves are simple: *st_mangle_tun0_OUTPUT* first clears
    the packet mark and then marks them with *0x3c* ➏; *st_mangle_tun1_OUTPUT* does
    the same but uses the mark *0x3d* ➐. After packets have been marked, the marks
    are used to implement and match different routing rules, as shown in [Example 9-14](ch09.html#routing_rules_for_vpns_started_by_two_di
    "Example 9-14. Routing rules for VPNs started by two different device users").'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-14. Routing rules for VPNs started by two different device users
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that two rules that match each mark have been created, and that they’re
    associated with different routing tables. Packets marked with *0x3c* go to routing
    table 60 (0x3c in hexadecimal ➊), while those marked with *0x3d* go to table 61
    (0x3d in hexadecimal ➋). Table 60 routes everything through the *tun0* tunneling
    interface ➌, which was created by the owner user, and table 61 routes everything
    through the *tun1* interface ➍, created by the secondary user.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*While the VPN traffic routing method introduced in Android 4.4 offers greater
    flexibility and allows user VPN traffic to be isolated, as of this writing the
    implementation appears to have some problems, especially related to switching
    between different physical networks (for example, mobile to Wi-Fi or vice versa).
    Those problems should be addressed in future versions, possibly by modifying how
    packet filtering chains are associated with interfaces, but the basic implementation
    strategy is likely to remain the same.*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Wi-Fi EAP
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android supports different wireless network protocols, including Wi-Fi Protected
    Access (WPA) and Wi-Fi Protected Access II (WPA2), which are currently deployed
    on most wireless devices. Both protocols support a simple *pre-shared key (PSK)*
    mode, also referred to as *Personal mode*, in which all devices that access the
    network must be configured with the same 256-bit authentication key.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Devices can be configured either with the raw key bytes or with an ASCII passphrase
    that’s used to derive the authentication key using the PBKDF2 key derivation algorithm.
    While the PSK mode is simple, it doesn’t scale as the number of network users
    increases. If access for a certain user needs to be revoked, for example, the
    only way to cancel their network credentials is to change the shared passphrase,
    which would force all other users to reconfigure their devices. Additionally,
    as there is no practical way to distinguish users and devices, it is difficult
    to implement flexible access rules or accounting.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: To address this problem, both WPA and WPA2 support the IEEE 802.1X network access
    control standard, which offers an encapsulation of the Extensible Authentication
    Protocol (EAP). Authentication in a wireless network that uses 802.1X and involves
    a supplicant, an authenticator, and an authentication server is shown in [Figure 9-12](ch09.html#eight02dot1x_authentication_participants
    "Figure 9-12. 802.1X authentication participants").
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '![802.1X authentication participants](figs/web/09fig12.png.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
- en: Figure 9-12. 802.1X authentication participants
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: The *supplicant* is a wireless device such as an Android phone that wants to
    connect to the network, and the *authenticator* is the gateway to the network
    that validates the supplicant’s identity and provides authorization. In a typical
    Wi-Fi configuration, the authenticator is the wireless access point (AP). The
    *authentication server*, typically a RADIUS server, verifies client credentials
    and decides whether they should be granted access based on a preconfigured access
    policy.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Authentication is implemented by exchanging EAP messages between the three
    nodes. These are encapsulated in a format suitable for the medium connecting each
    two nodes: EAP over LAN (EAPOL) between the supplicant and the authenticator,
    and RADIUS between the authenticator and the authentication server.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Because EAP is an authentication framework that supports different concrete
    authentication types and not a concrete authentication mechanism, the supplicant
    and authentication server (with the help of the authenticator) need to negotiate
    a commonly supported authentication method before authentication can be performed.
    There are various standard and proprietary EAP authentication methods, and current
    Android versions support most of the methods used in wireless networks.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: The sections below offer a brief overview of the EAP authentication methods
    that Android supports, and show how it protects credentials for each method. We’ll
    also demonstrate how to configure access to a Wi-Fi network that uses EAP for
    authentication using Android’s wireless network management APIs.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: EAP Authentication Methods
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As of version 4.4, Android supports the PEAP, EAP-TLS, EAP-TTLS, and EAP-PWD
    authentication methods. Before exploring how Android stores credentials for each
    authentication method, let’s briefly discuss how each one works.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '**PEAP**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: The Protected Extensible Authentication Protocol (PEAP) transmits EAP messages
    through an SSL connection in order to provide confidentiality and integrity. It
    uses PKI and a server certificate to authenticate the server and establish an
    SSL connection (Phase 1), but does not mandate how clients are authenticated.
    Clients are authenticated using a second, inner (Phase 2) authentication method,
    which is transmitted inside the SSL tunnel. Android supports the MSCHAPv2 (specified
    in PEAPv0^([[94](#ftn.ch09fn08)])) and Generic Token Card (GTC, specified in PEAPv2^([[95](#ftn.ch09fn09)]))
    methods for Phase 2 authentication.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '**EAP-TLS**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: The EAP-Transport Layer Security (EAP-TLS) method^([[96](#ftn.ch09fn10)]) uses
    TLS for mutual authentication and was formerly the only EAP method certified for
    use with WPA Enterprise. EAP-TLS uses both a server certificate to authenticate
    the server to supplicants, and a client certificate that the authentication server
    verifies in order to establish supplicant identity. Granting network access requires
    issuing and distributing X.509 client certificates, and thus maintaining a public
    key infrastructure. Existing clients can be blocked from accessing the network
    by revoking their supplicant certificates. Android supports EAP-TLS and manages
    client keys and certificates using the system credential store.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '**EAP-TTLS**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Like EAP-TLS, the EAP-Tunneled Transport Layer Security (EAP-TTLS) protocol^([[97](#ftn.ch09fn11)])
    is based on TLS. However, EAP-TTLS does not require client authentication using
    X.509 certificates. Clients can be authenticated either using a certificate during
    the handshake phase (Phase 1), or with another protocol during the tunnel phase
    (Phase 2). Android does not support authentication during Phase 1, but supports
    the PAP, MSCHAP, MSCHAPv2, and GTC protocols for Phase 2.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '**EAP-PWD**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: The EAP-PWD authentication method^([[98](#ftn.ch09fn12)]) uses a shared password
    for authentication. Unlike legacy schemes that rely on a simple challenge-response
    mechanism, EAP-PWD is designed to be resistant to passive attacks, active attacks,
    and dictionary attacks. The protocol also provides forward secrecy and guarantees
    that even if a password is compromised, earlier sessions cannot be decrypted.
    EAP-PWD is based on discrete logarithm cryptography and can be implemented using
    either finite fields or elliptic curves.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Android Wi-Fi Architecture
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like most hardware support in Android, Android’s Wi-Fi architecture consists
    of a kernel layer (WLAN adapter driver modules), native daemon (*wpa_supplicant*),
    a Hardware Abstraction Layer (HAL), system services, and a system UI. Wi-Fi adapter
    kernel drivers are usually specific to the system on a chip (SoC) that an Android
    device is built upon, and are typically closed source and loaded as kernel modules.
    The *wpa_supplicant*^([[99](#ftn.ch09fn13)]) is a WPA supplicant daemon that implements
    key negotiation with a WPA authenticator and controls 802.1X association of the
    WLAN driver. However, Android devices rarely include the original *wpa_supplicant*
    code; the included implementation is often modified for better compatibility with
    the underlying SoC.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: The HAL is implemented in the *libharware_legacy* native library and is responsible
    for relaying commands from the framework to *wpa_supplicant* via its control socket.
    The system service that controls Wi-Fi connectivity is `WifiService`, which offers
    a public interface via the `WifiManager` facade class. The `WifiService` delegates
    Wi-Fi state management to a rather complex `WifiStateMachine` class, which can
    go through more than a dozen states while connecting to a wireless network.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: WLAN connectivity is controlled via the Wi-Fi screen of the system Settings
    app, and connectivity status is displayed in the status bar and Quick Settings,
    both of which are part of the SystemUI package.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Android stores Wi-Fi-related configuration files in the */data/misc/wifi/* directory
    because wireless connectivity daemons persist configuration changes directly to
    disk and thus need a writable directory. The directory is owned by the *wifi*
    user (UID 1010), which is also the user that the *wpa_supplicant* runs as. Configurations
    files, including *wpa_supplicant.conf*, have permissions set to 0660 and are owned
    by the *system* user, and their group is set to *wifi*. This ensures that both
    system applications and the supplicant daemon can read and modify configurations
    files, but they are not accessible to other applications. The *wpa_supplicant.conf*
    file contains configuration parameters formatted as key-value pairs, both global
    and specific to a particular network. Network-specific parameters are enclosed
    in network blocks, which may look like [Example 9-15](ch09.html#psk_network_configuration_block_in_wpaun
    "Example 9-15. PSK network configuration block in wpa_supplicant.conf") for a
    PSK configuration.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-15. PSK network configuration block in wpa_supplicant.conf
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, the `network` block specifies the network SSID ➊, authentication
    key management protocol ➋, the pre-shared key itself ➌, and a priority value ➍.
    The PSK is saved in plaintext, and while the *wpa_supplicant.conf* access bits
    disallow non-system applications from accessing it, it can be easily extracted
    from devices that allow root access.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: EAP Credentials Management
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we’ll examine how Android manages Wi-Fi credentials for each
    of the supported EAP authentication methods and discuss the Android-specific *wpa_supplicant*
    changes that allow the supplicant daemon to take advantage of Android’s system
    credential store.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 9-16](ch09.html#peap_network_configuration_block_in_wpau "Example 9-16. PEAP
    network configuration block in wpa_supplicant.conf") shows the network block in
    *wpa_supplicant.conf* for a network configured to use PEAP.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-16. PEAP network configuration block in wpa_supplicant.conf
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, the key management mode is set to *WPA-EAP IEEE8021X* ➊, the EAP method
    to *PEAP* ➋, and Phase 2 authentication to MSCHAPv2 ➏. Credentials, namely the
    identity ➌ and password ➍, are stored in plaintext in the configuration file,
    as they are in PSK mode.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: One notable difference from a general-purpose *wpa_supplicant.conf* is the format
    of the CA certificate path ➎. The CA certificate path (*ca_cert*) is used when
    validating the server certificate, and in Android *ca_cert* is in a URI-like format
    with the *keystore* scheme. This Android-specific extension allows the *wpa_supplicant*
    daemon to retrieve certificates from the system credential store. When the daemon
    encounters a certificate path that starts with *keystore://*, it connects to the
    `IKeystoreService` remote interface of the native *keystore* service and retrieves
    the certificate bytes using the URI path as the key.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: EAP-TLS configuration is similar to the PEAP one, as shown in [Example 9-17](ch09.html#eap-tls_network_configuration_block_in_w
    "Example 9-17. EAP-TLS network configuration block in wpa_supplicant.conf").
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-17. EAP-TLS network configuration block in wpa_supplicant.conf
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: New here is the addition of a client certificate URI ➊, an engine ID ➋, and
    a key ID ➌. The client certificate is retrieved from the system credential store,
    just like the CA certificate. The engine ID refers to the OpenSSL engine that
    should be used for cryptographic operations when connecting to the SSID configured
    in the `network` block. The *wpa_supplicant* has native support for configurable
    OpenSSL engines, and is often used with an PKCS#11 engine in order to use keys
    stored in a smart card or other hardware device.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in [Chapter 7](ch07.html "Chapter 7. Credential Storage"), Android’s
    *keystore* engine uses keys stored in the system credential store. If a device
    supports hardware-backed credential storage, the *keystore* engine can transparently
    take advantage of it by virtue of the intermediate *keymaster* HAL module. The
    key ID in [Example 9-17](ch09.html#eap-tls_network_configuration_block_in_w "Example 9-17. EAP-TLS
    network configuration block in wpa_supplicant.conf") references the alias of the
    private key to use for authentication.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: As of version 4.3, Android allows you to select the owner of private keys and
    certificates when importing them. Previously, all imported keys were owned by
    the *system* user, but if you set the Credential use parameter to Wi-Fi in the
    import dialog (see [Figure 9-13](ch09.html#setting_the_credential_owner_to_wi-fi_in
    "Figure 9-13. Setting the credential owner to Wi-Fi in the PKCS#12 import dialog")),
    the key owner is set to the *wifi* user (UID 1010), and the key can only be accessed
    by system components that run as the *wifi* user, like *wpa_supplicant*.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting the credential owner to Wi-Fi in the PKCS#12 import dialog](figs/web/09fig13.png.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
- en: Figure 9-13. Setting the credential owner to Wi-Fi in the PKCS#12 import dialog
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Because Android does not support client authentication when using the EAP-TTLS
    authentication method, the configuration only contains a CA certificate reference
    ➋, as shown in [Example 9-18](ch09.html#eap-ttls_network_configuration_block_in
    "Example 9-18. EAP-TTLS network configuration block in wpa_supplicant.conf").
    The password ➊ is stored in plaintext.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-18. EAP-TTLS network configuration block in wpa_supplicant.conf
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The EAP-PWD method does not depend on TLS to establish a secure channel and
    thus requires no certificate configuration, as shown in [Example 9-19](ch09.html#eap-pwd_network_configuration_block_in_w
    "Example 9-19. EAP-PWD network configuration block in wpa_supplicant.conf"). Credentials
    are stored in plaintext (➊ and ➋), as with other configurations that use passwords.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-19. EAP-PWD network configuration block in wpa_supplicant.conf
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To sum up, configurations for all EAP methods that use a password for authentication
    store credential information in plaintext in the *wpa_supplicant.conf* file. When
    using EAP-TLS, which relies on client authentication, the client key is stored
    in the system keystore, and thus offers the highest level of credential protection.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Adding an EAP Network with WifiManager
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While Android supports a number of WPA Enterprise authentication methods, setting
    them up properly might challenge some users because of the number of parameters
    that need to be configured and the need to install and select authentication certificates.
    Because Android’s official API for managing Wi-Fi networks, called `WifiManager`,
    did not support EAP configurations prior to Android 4.3, the only way to set up
    an EAP network was to add it via the system Settings app and configure it manually.
    Android 4.3 (API level 18) extended the `WifiManager` API to allow for programmatic
    EAP configuration, thus enabling automatic network provisioning in enterprise
    environments. In this section, we’ll show how to use `WifiManager` to add an EAP-TLS
    network and discuss the underlying implementation.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '`WifiManager` allows an app that holds the `CHANGE_WIFI_STATE` permission (protection
    level *dangerous*) to add a Wi-Fi network by initializing a `WifiConfiguration`
    instance with the network’s SSID, authentication algorithms, and credentials,
    and pass it to the `addNetwork()` method of `WifiManager`. Android 4.3 extends
    this API by adding an `enterpriseConfig` field of type `WifiEnterpriseConfig`
    to the `WifiConfiguration` class, which allows you to configure the EAP authentication
    method to use, client and CA certificates, the Phase 2 authentication method (if
    any), and additional credentials such as username and password. [Example 9-20](ch09.html#adding_an_eap-tls_network_using_wifimana
    "Example 9-20. Adding an EAP-TLS network using WifiManager") shows how to use
    this API to add a network that uses EAP-TLS for authentication.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-20. Adding an EAP-TLS network using `WifiManager`
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In order to set up EAP-TLS authentication, we first need to obtain the CA certificate
    used to verify the server’s identity, and the client’s private key and certificate.
    Because these are typically distributed as a PKCS#12 file, we can use a `KeyStore`
    of type *PKCS12* to extract them (not shown). (Android will automatically import
    the specified keys and certificates into the system keystore when you add an EAP
    profile that uses them, so you don’t need to import the PKCS#12 file.) After we
    have the CA certificate and client credentials, we set them to our `WifiEnterpriseConfig`
    instance using the `setCaCertificate()` ➊ and `setClientKeyEntry()` ➋ methods.
    We then set the EAP method to `Eap.TLS` ➌ and the Phase 2 method to `NONE` ➍,
    as EAP-TLS authenticates users as part of establishing an SSL connection (Phase
    1). Android also requires us to set the identity ➎ even though it might not be
    used by the authentication server. After we’ve configured the `WifiEnterpriseConfig`
    object, we can add it to the main `WifiConfiguration` instance ➏. The set of key
    management protocols also needs to be configured (➐ and ➑) because it defaults
    to WPA PSK. Finally, we can add the network ➒ and save the configuration ➓, which
    updates the *wpa_supplicant.conf* file to include the newly configured network.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Android automatically generates aliases for the configured private key and certificates,
    and then imports the PKI credentials into the system keystore. The aliases are
    based on the AP name, key management scheme, and EAP authentication method. A
    programmatically configured network is automatically shown in the Wi-Fi screen
    of the system Settings application, and might look like [Figure 9-14](ch09.html#eap-tls_network_added_using_wifimanager
    "Figure 9-14. An EAP-TLS network added using WifiManager") for the example shown
    in [Example 9-20](ch09.html#adding_an_eap-tls_network_using_wifimana "Example 9-20. Adding
    an EAP-TLS network using WifiManager").
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '![An EAP-TLS network added using WifiManager](figs/web/09fig14.png.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
- en: Figure 9-14. An EAP-TLS network added using `WifiManager`
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android supports a Device Administration API that allows device administration
    apps to configure a security policy, which can include requirements for lockscreen
    password complexity, device encryption, and camera usage. Device administrators
    are often used with corporate accounts, such as those for Microsoft Exchange and
    Google Apps, in order to limit access to corporate data based on the policy and
    device settings. The Device Administration API also provides features that enable
    remote device locking and data wipe.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Android devices can connect to various types of VPNs, including PPTP, L2TP/IPSec,
    and SSL-based VPNs. Support for PPTP and L2TP/IPSec is built into the platform
    and can only be extended through OS updates. Android 4.0 adds support for application-based
    VPNs, which allows third-party applications to implement custom VPN solutions.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the widely used pre-shared key Wi-Fi authentication mode, Android
    supports various WPA Enterprise configurations, namely PEAP, EAP-TLS, EAP-TTLS,
    and EAP-PWD. Certificates and private keys for EAP authentication methods that
    use SSL to establish a secure channel or authenticate users are stored in the
    system keystore and can use hardware protection when available. Wi-Fi networks
    that use EAP for authentication can be automatically provisioned using the `WifiManager`
    API in recent Android versions, beginning with Android 4.3.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: ^([[87](#ch09fn01)]) Google, *Android APIs Reference*, “DeviceAdminInfo,” *[https://developer.android.com/reference/android/app/admin/DeviceAdminInfo.html](https://developer.android.com/reference/android/app/admin/DeviceAdminInfo.html)*
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: ^([[88](#ch09fn02)]) Google, *Android APIs Reference*, “DevicePolicyManager,”
    *[https://developer.android.com/reference/android/app/admin/DevicePolicyManager.html](https://developer.android.com/reference/android/app/admin/DevicePolicyManager.html)*
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: ^([[89](#ch09fn03)]) Google, *API Guides*, “Device Administration,” *[https://developer.android.com/guide/topics/admin/device-admin.html](https://developer.android.com/guide/topics/admin/device-admin.html)*
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: ^([[90](#ch09fn04)]) OpenVPN Technologies, Inc, “OpenVPN Security Overview,”
    *[http://openvpn.net/index.php/open-source/documentation/security-overview.html](http://openvpn.net/index.php/open-source/documentation/security-overview.html)*
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: ^([[91](#ch09fn05)]) IPSec-Tools, *[http://ipsec-tools.sourceforge.net/](http://ipsec-tools.sourceforge.net/)*
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: ^([[92](#ch09fn06)]) Google, *Android APIs Reference*, “VpnService,” *[https://developer.android.com/reference/android/net/VpnService.html](https://developer.android.com/reference/android/net/VpnService.html)*
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: ^([[93](#ch09fn07)]) Arne Schwabe, “Openvpn for Android 4.0+,” *[https://code.google.com/p/ics-openvpn/](https://code.google.com/p/ics-openvpn/)*
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: ^([[94](#ch09fn08)]) Vivek Kamath, Ashwin Palekar, and Mark Woodrich, *Microsoft’s
    PEAP version 0 (Implementation in Windows XP SP1)*, *[https://tools.ietf.org/html/draft-kamath-pppext-peapv0-00/](https://tools.ietf.org/html/draft-kamath-pppext-peapv0-00/)*
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: ^([[95](#ch09fn09)]) Ashwin Palekar et al., *Protected EAP Protocol (PEAP) Version
    2*, *[https://tools.ietf.org/html/draft-josefsson-pppext-eap-tls-eap-10/](https://tools.ietf.org/html/draft-josefsson-pppext-eap-tls-eap-10/)*
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: ^([[96](#ch09fn10)]) D. Simon, B. Aboba, and R. Hurst, *The EAP-TLS Authentication
    Protocol, [http://tools.ietf.org/html/rfc5216/](http://tools.ietf.org/html/rfc5216/)*
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: ^([[97](#ch09fn11)]) P. Funk and S. Blake-Wilson, *Extensible Authentication
    Protocol Tunneled Transport Layer Security Authenticated Protocol Version 0 (EAP-TTLSv0)*,
    *[https://tools.ietf.org/html/rfc5281/](https://tools.ietf.org/html/rfc5281/)*
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: ^([[98](#ch09fn12)]) D. Harkins and G. Zorn, *Extensible Authentication Protocol
    (EAP) Authentication Using Only a Password*, *[https://tools.ietf.org/html/rfc5931/](https://tools.ietf.org/html/rfc5931/)*
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: ^([[99](#ch09fn13)]) Jouni Malinen, *Linux WPA/WPA2/IEEE 802.1X Supplicant*,
    *[http://hostap.epitest.fi/wpa_supplicant/](http://hostap.epitest.fi/wpa_supplicant/)*
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
