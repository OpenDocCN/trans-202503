["```\n   1\n\n   5\n   4\n➊ 12\n   9\n   1 2 12\n   1 3 6\n   2 1 26\n   1 4 45\n   1 5 7\n   3 2 2\n   2 4 9\n   4 3 8\n   5 2 21\n```", "```\n#define MAX_CELLS 100\n\ntypedef struct edge {\n int to_cell, length;\n  struct edge *next;\n} edge;\n```", "```\nint main(void) {\n  static edge *adj_list[MAX_CELLS + 1];\n  int num_cases, case_num, i;\n  int num_cells, exit_cell, time_limit, num_edges;\n  int from_cell, to_cell, length;\n  int total, min_time;\n  edge *e;\n\n  scanf(\"%d\", &num_cases);\n  for (case_num = 1; case_num <= num_cases; case_num++) {\n    scanf(\"%d%d%d\", &num_cells, &exit_cell, &time_limit);\n    scanf(\"%d\", &num_edges);\n➊ for (i = 1; i <= num_cells; i++)\n    adj_list[i] = NULL;\n  for (i = 0; i < num_edges; i++) {\n    scanf(\"%d%d%d\", &from_cell, &to_cell, &length);\n    e = malloc(sizeof(edge));\n    if (e == NULL) {\n      fprintf(stderr, \"malloc error\\n\");\n      exit(1);\n    }\n    e->to_cell = to_cell;\n    e->length = length;\n    e->next = adj_list[from_cell];\n  ➋ adj_list[from_cell] = e;\n  }\n\n  total = 0;\n  for (i = 1; i <= num_cells; i++) {\n  ➌ min_time = find_time(adj_list, num_cells, i, exit_cell);\n  ➍ if (min_time >= 0 && min_time <= time_limit)\n       total++;\n  }\n  printf(\"%d\\n\", total);\n  if (case_num < num_cases)\n    printf(\"\\n\");\n }\n return 0;\n}\n```", "```\nint find_time(edge *adj_list[], int num_cells,\n              int from_cell, int exit_cell)\n```", "```\nint find_time(edge *adj_list[], int num_cells,\n              int from_cell, int exit_cell) {\n  static int done[MAX_CELLS + 1];\n  static int min_times[MAX_CELLS + 1];\n int i, j, found;\n   int min_time, min_time_index, old_time;\n   edge *e;\n➊ for (i = 1; i <= num_cells; i++) {\n     done[i] = 0;\n     min_times[i] = -1;\n   }\n➋ min_times[from_cell] = 0;\n\n   for (i = 0; i < num_cells; i++) {\n     min_time = -1;\n   ➌ found = 0;\n   ➍ for (j = 1; j <= num_cells; j++) {\n     ➎ if (!done[j] && min_times[j] >= 0) {\n       ➏ if (min_time == -1 || min_times[j] < min_time) {\n            min_time = min_times[j];\n            min_time_index = j;\n            found = 1;\n          }\n        }\n      }\n   ❼ if (!found)\n        break;\n      done[min_time_index] = 1;\n\n      e = adj_list[min_time_index];\n      while (e) {\n        old_time = min_times[e->to_cell];\n     ➑ if (old_time == -1 || old_time > min_time + e->length)\n          min_times[e->to_cell] = min_time + e->length;\n        e = e->next;\n     }\n   }\n➒ return min_times[exit_cell];\n}\n```", "```\n      e->to_cell = to_cell;\n      e->length = length;\n      e->next = adj_list[from_cell];\n      adj_list[from_cell] = e;\n```", "```\n      e->to_cell = from_cell;\n      e->length = length;\n      e->next = adj_list[to_cell];\n      adj_list[to_cell] = e;\n```", "```\n1 2 12\n```", "```\n4\n0 3 8 2\n3 0 2 1\n8 2 0 5\n2 1 5 0\n1\n2\n```", "```\n0 3 8 2\n```", "```\n3 0 2 1\n```", "```\n#define MAX_TOWNS 700\n\ntypedef struct edge {\n  int to_town, length;\n  struct edge *next;\n} edge;\n```", "```\nint main(void) {\n  static edge *adj_list[MAX_TOWNS + 1] = {NULL};\n  int i, num_towns, from_town, to_town, length;\n  int num_stores, store_num;\n  static int store[MAX_TOWNS + 1] = {0};\n  edge *e;\n scanf(\"%d\", &num_towns);\n➊ for (from_town = 1; from_town <= num_towns; from_town++)\n     for (to_town = 1; to_town <= num_towns; to_town++) {\n       scanf(\"%d\", &length);\n    ➋ if (from_town != to_town) {\n         e = malloc(sizeof(edge));\n         if (e == NULL) {\n           fprintf(stderr, \"malloc error\\n\");\n           exit(1);\n         }\n         e->to_town = to_town;\n         e->length = length;\n         e->next = adj_list[from_town];\n         adj_list[from_town] = e;\n       }\n     }\n\n➌ scanf(\"%d\", &num_stores);\n   for (i = 1; i <= num_stores; i++) {\n     scanf(\"%d\", &store_num);\n     store[store_num] = 1;\n   }\n   solve(adj_list, num_towns, store);\n   return 0;\n}\n```", "```\nvoid solve(edge *adj_list[], int num_towns, int store[])\n```", "```\nvoid solve(edge *adj_list[], int num_towns, int store[]) {\n  static int done[MAX_TOWNS + 1][2];\n  static int min_distances[MAX_TOWNS + 1][2];\n  int i, j, state, found;\n  int min_distance, min_town_index, min_state_index, old_distance;\n  edge *e;\n\n➊ for (state = 0; state <= 1; state++)\n    for (i = 1; i <= num_towns; i++) {\n      done[i][state] = 0;\n      min_distances[i][state] = -1;\n    }\n➋ min_distances[1][0] = 0;\n\n➌ for (i = 0; i < num_towns * 2; i++) {\n    min_distance = -1;\n    found = 0;\n    for (state = 0; state <= 1; state++)\n      for (j = 1; j <= num_towns; j++) {\n        if (!done[j][state] && min_distances[j][state] >= 0) {\n          if (min_distance == -1 || min_distances[j][state] < min_distance) {\n            min_distance = min_distances[j][state];\n            min_town_index = j;\n            min_state_index = state;\n            found = 1;\n          }\n        }\n      }\n    if (!found)\n      break;\n ➍ done[min_town_index][min_state_index] = 1;\n\n ➎ if (min_state_index == 0 && store[min_town_index]) {\n      old_distance = min_distances[min_town_index][1];\n      if (old_distance == -1 || old_distance > min_distance)\n        min_distances[min_town_index][1] = min_distance;\n    } else {\n   ➏ e = adj_list[min_town_index];\n      while (e) {\n        old_distance = min_distances[e->to_town][min_state_index];\n if (old_distance == -1 || old_distance > min_distance + e->length)\n          min_distances[e->to_town][min_state_index] = min_distance +\n                                                       e->length;\n        e = e->next;\n      }\n    }\n  }\n❼ printf(\"%d\\n\", min_distances[num_towns][1]);\n}\n```", "```\n#define MOD 1000000\n\nvoid solve(edge *adj_list[], int num_towns, int store[]) {\n  static int done[MAX_TOWNS + 1][2];\n  static int min_distances[MAX_TOWNS + 1][2];\n➊ static int num_paths[MAX_TOWNS + 1][2];\n  int i, j, state, found;\n  int min_distance, min_town_index, min_state_index, old_distance;\n  edge *e;\n\n  for (state = 0; state <= 1; state++)\n    for (i = 1; i <= num_towns; i++) {\n      done[i][state] = 0;\n      min_distances[i][state] = -1;\n    ➋ num_paths[i][state] = 0;\n  }\n  min_distances[1][0] = 0;\n➌ num_paths[1][0] = 1;\n\n  for (i = 0; i < num_towns * 2; i++) {\n    min_distance = -1;\n    found = 0;\n    for (state = 0; state <= 1; state++)\n      for (j = 1; j <= num_towns; j++) {\n        if (!done[j][state] && min_distances[j][state] >= 0) {\n          if (min_distance == -1 || min_distances[j][state] < min_distance) {\n            min_distance = min_distances[j][state];\n            min_town_index = j;\n            min_state_index = state;\n            found = 1;\n          }\n        }\n      }\n    if (!found)\n      break;\n    done[min_town_index][min_state_index] = 1;\n\n    if (min_state_index == 0 && store[min_town_index]) {\n      old_distance = min_distances[min_town_index][1];\n   ➍ if (old_distance == -1 || old_distance >= min_distance) {\n        min_distances[min_town_index][1] = min_distance;\n      ➎ if (old_distance == min_distance)\n          num_paths[min_town_index][1] += num_paths[min_town_index][0];\n        else\n          num_paths[min_town_index][1] = num_paths[min_town_index][0];\n      ➏ num_paths[min_town_index][1] %= MOD;\n       }\n     } else {\n       e = adj_list[min_town_index];\n       while (e) {\n         old_distance = min_distances[e->to_town][min_state_index];\n         if (old_distance == -1 ||\n             old_distance >= min_distance + e->length) {\n           min_distances[e->to_town][min_state_index] = min_distance +\n                                                        e->length;\n        ❼ if (old_distance == min_distance + e->length)\n             num_paths[e->to_town][min_state_index] +=\n                 num_paths[min_town_index][min_state_index];\n           else\n             num_paths[e->to_town][min_state_index] =\n                 num_paths[min_town_index][min_state_index];\n        ➑ num_paths[e->to_town][min_state_index] %= MOD;\n        }\n e = e->next;\n      }\n    }\n  }\n➒ printf(\"%d %d\\n\", min_distances[num_towns][1], num_paths[num_towns][1]);\n}\n```", "```\nif (old_distance == -1 || old_distance > min_distance) {\n```", "```\nif (old_distance == -1 || old_distance >= min_distance) {\n```", "```\n4\n0 3 1 2\n3 0 2 1\n1 2 0 5\n2 1 5 0\n2\n2 3\n```"]