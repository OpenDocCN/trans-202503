["```\nwhile ( ❶ a > 0)\n    a = a / 2;\n```", "```\ndo\n    a = a + 1;\nwhile (a < 100);\n```", "```\ndo {\n    int a = a + 1;\n} while (a < 100);\n```", "```\nint a;\nfor ( ❶ a = 0; ❷ a < 5; ❸ a = a + 1)\n    b = b * 2;\n```", "```\nfor (int a = 0; a < 5; a = a + 1)\n    b = b * 2;\n```", "```\nint a = 5;\nfor (int a = 0; a < 5; a = a + 1)\n    b = b + a;\n```", "```\n❶ int a = 5;\nfor ( ❷ int a = 0; a < 5; a = a + 1) {\n  ❸ int a = 1;\n    b = b + a;\n}\n```", "```\nwhile ((a = a + 1) < 10)\n    ;\n```", "```\nwhile (1) {\n    a = a - 1;\n    if (a < 0)\n        break;\n}\nreturn a;\n```", "```\nwhile (b > 0) {\n    do {\n        a = a - 1;\n        if (a < 0)\n            break;\n    } while (1);\n    b = b * a;\n}\nreturn b;\n```", "```\nwhile (a > 0) {\n    a = a * b;\n    if (b > 0)\n        continue;\n    b = b + 1;\n    return b;\n❶}\n```", "```\nfor (int i = 0; i < 5; ❶ i = i + 1) {\n    a = a * i;\n    if (b > 0)\n        continue;\n    b = b + 1;\n❷}\n```", "```\nint main(void) {\n    break;\n}\n```", "```\nwhile (1) {\n    if (a > 4) {\n        b = b * 2;\n        return a + b;\n    } else {\n        int c = a ? b : 5;\n        {\n            int d = c;\n            break;\n        }\n    }\n    return 0;\n}\nreturn 1;\n```", "```\nfor (int i = 0; i < 10; i = i + 1) {\n    if (i % 2 == 0)\n        continue;\n    if (x > y)\n        continue;\n    break;\n}\n```", "```\nstatement = Return(exp)\n          | Expression(exp)\n          | If(exp condition, statement then, statement? else)\n| Compound(block)\n **| Break**\n **| Continue**\n **| While(exp condition, statement body)**\n **| DoWhile(statement body, exp condition)**\n **| For(for_init init, exp? condition, exp? post, statement body)**\n          | Null\n```", "```\nfor_init = InitDecl(declaration) | InitExp(exp?)\n```", "```\nprogram = Program(function_definition)\nfunction_definition = Function(identifier name, block body)\nblock_item = S(statement) | D(declaration)\nblock = Block(block_item*)\ndeclaration = Declaration(identifier name, exp? init)\n**for_init = InitDecl(declaration) | InitExp(exp?)**\nstatement = Return(exp)\n          | Expression(exp)\n          | If(exp condition, statement then, statement? else)\n| Compound(block)\n **| Break**\n **| Continue**\n **| While(exp condition, statement body)**\n **| DoWhile(statement body, exp condition)**\n **| For(for_init init, exp? condition, exp? post, statement body)**\n          | Null\nexp = Constant(int)\n| Var(identifier)\n    | Unary(unary_operator, exp)\n    | Binary(binary_operator, exp, exp)\n| Assignment(exp, exp)\n| Conditional(exp condition, exp, exp)\nunary_operator = Complement | Negate | Not\nbinary_operator = Add | Subtract | Multiply | Divide | Remainder | And | Or\n                | Equal | NotEqual | LessThan|LessOrEqual\n                | GreaterThan | GreaterOrEqual\n```", "```\nstatement = `--snip--`\n          | Break(**identifier label**)\n          | Continue(**identifier label**)\n          | While(exp condition, statement body, **identifier label**)\n          | DoWhile(statement body, exp condition, **identifier label**)\n          | For(for_init init, exp? condition, exp? post, statement body, **identifier label**)\n```", "```\n<program> ::= <function>\n<function> ::= \"int\" <identifier> \"(\" \"void\" \")\" <block>\n<block> ::= \"{\" {<block-item>} \"}\"\n<block-item> ::= <statement> | <declaration>\n<declaration> ::= \"int\" <identifier> [\"=\" <exp>] \";\"\n**<for-init> ::= <declaration> | [<exp>] \";\"**\n<statement> ::= \"return\" <exp> \";\"\n              | <exp> \";\"\n| \"if\" \"(\" <exp> \")\" <statement> [\"else\" <statement>]\n              | <block>\n              **| \"break\" \";\"**\n **| \"continue\" \";\"**\n **| \"while\" \"(\" <exp> \")\" <statement>**\n **| \"do\" <statement> \"while\" \"(\" <exp> \")\" \";\"**\n **| \"for\" \"(\" <for-init> [<exp>] \";\" [<exp>] \")\" <statement>**\n              | \";\"\n<exp> ::= <factor> | <exp> <binop> <exp> | <exp> \"?\" <exp> \":\" <exp>\n<factor> ::= <int> | <identifier> | <unop> <factor> | \"(\" <exp> \")\"\n<unop> ::= \"-\" | \"~\" | \"!\"\n<binop> ::= \"-\" | \"+\" | \"*\" | \"/\" | \"%\" | \"&&\" | \"||\"\n          | \"==\" | \"!=\" | \"<\" | \"<=\" | \">\" | \">=\" | \"=\"\n<identifier> ::= ? An identifier token ?\n<int> ::= ? A constant token ?\n```", "```\nresolve_statement(statement, variable_map):\n    match statement with\n  | `--snip--`\n    | For(init, condition, post, body) ->\n        new_variable_map = copy_variable_map(variable_map)\n        init = resolve_for_init(init, new_variable_map)\n        condition = resolve_optional_exp(condition, new_variable_map)\n        post = resolve_optional_exp(post, new_variable_map)\n        body = resolve_statement(body, new_variable_map)\n        return For(init, condition, post, body)\n```", "```\nresolve_for_init(init, variable_map):\n    match init with\n    | InitExp(e) -> return InitExp(resolve_optional_exp(e, variable_map))\n    | InitDecl(d) -> return InitDecl(resolve_declaration(d, variable_map))\n```", "```\n❶ while (1) {\n    a = a - 1;\n    if (a < 0)\n      ❶ break;\n}\n\n❷ for (int b = 0; b < 100; b = b + 1) {\n    if (b % 2 == 0)\n      ❷ continue;\n    a = a * b;\n}\nreturn a;\n```", "```\n❶ for (int i = 0; i < 10; i = i + 1) {\n    if (i % 2 == 0)\n      ❶ continue;\n    if (x > y)\n      ❶ continue;\n  ❶ break;\n}\n```", "```\n❶ while (a > 0) {\n  ❷ for (int i = 0; i < 10; i = i + 1) {\n        if (i % 2 == 0)\n          ❷ continue;\n        a = a / 2;\n    }\n    if (a == b)\n      ❶ break;\n}\n```", "```\nlabel_statement(statement, current_label):\n    match statement with\n    | Break ->\n        if current_label is null:\n            fail(\"break statement outside of loop\")\n        return ❶ annotate(Break, current_label)\n    | Continue ->\n        if current_label is null:\n            fail(\"continue statement outside of loop\")\n        return ❷ annotate(Continue, current_label)\n    | While(condition, body) ->\n        new_label = ❸ make_label()\n        labeled_body = label_statement(body, new_label)\n        labeled_statement = While(condition, labeled_body)\n        return ❹ annotate(labeled_statement, new_label)\n    | `--snip--`\n```", "```\nJump(\"break_loop0\")\n```", "```\nJump(\"continue_loop0\")\n```", "```\nLabel(start)\n`<instructions for body>`\n`<instructions for condition>`\nv = `<result of condition>`\nJumpIfNotZero(v, start)\n```", "```\nLabel(start)\n`<instructions for body>`\n**Label(continue_label)**\n`<instructions for condition>`\nv = `<result of condition>`\nJumpIfNotZero(v, start)\n**Label(break_label)**\n```", "```\nLabel(start)\n`<instructions for condition>`\nv = `<result of condition>`\nJumpIfZero(v, end)\n`<instructions for body>`\n❶ Jump(start)\nLabel(end)\n```", "```\nLabel(**continue_label**)\n`<instructions for condition>`\nv = `<result of condition>`\nJumpIfZero(v, **break_label**)\n`<instructions for body>`\nJump(**continue_label**)\nLabel(**break_label**)\n```", "```\n`<instructions for init>`\nLabel(start)\n`<instructions for condition>`\nv = `<result of condition>`\nJumpIfZero(v, break_label)\n`<instructions for body>`\nLabel(continue_label)\n`<instructions for post>`\nJump(start)\nLabel(break_label)\n```", "```\nJumpIfZero(Const(1), break_label)\n```", "```\n$ **./test_compiler** `**/path/to/your_compiler**` **--chapter 8 --switch**\n```"]