<html><head></head><body>
<h2 class="h2" id="ch04"><span epub:type="pagebreak" id="page_69"/><span class="big"><strong>4</strong></span><br/><strong>PLANNING AND PREPARATION</strong></h2>&#13;
<div class="imagef"><img src="../images/common-01.jpg" alt="image"/></div>&#13;
<p class="noindent">This chapter describes the preparatory steps performed prior to imaging a disk or storage medium. These include setting up an audit trail of investigator activity, saving output for reports, and deciding on naming conventions. In addition, I describe various logistical challenges involved in the forensic acquisition of storage media and how to establish a protected write-blocking environment.</p>&#13;
<p class="indent">The subject of forensic readiness overlaps somewhat with the sections in this chapter. However, forensic readiness is a broader topic that includes general planning, budgeting, lab infrastructure, staff training, hardware and software purchasing, and so on. If you consider the preceding requirements needed as “macro” forensic readiness, you can consider the information in this chapter as “micro” forensic readiness. The focus is narrower and includes setting up a forensic examiner’s workstation environment and the tools and individual tasks needed to analyze a disk or storage media.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_70"/>It is worth noting that forensic readiness in a private sector organization (in a corporate forensic lab, for example) is different from forensic readiness in some public sector organizations, such as law enforcement agencies. Private sector organizations, especially large corporate IT environments, can dictate how their IT infrastructure is built and operated. Forensic readiness in this controlled environment can be built into the IT infrastructure, providing advantages for a forensic examiner in the event of an investigation or incident. This chapter focuses on preparatory forensic tasks, which the private sector and public sector have in common.</p>&#13;
<h3 class="h3" id="ch04lev1sec01"><strong>Maintain an Audit Trail</strong></h3>&#13;
<p class="noindent">An audit trail or log maintains a historical record of actions, events, and tasks. It can have various levels of detail and can be either manual or automated. This section covers several command line methods for manually tracking tasks as well as automated logging of command line activity.</p>&#13;
<h4 class="h4" id="ch04lev2sec01"><em><strong>Task Management</strong></em></h4>&#13;
<p class="noindenta">During a forensic examination, it’s beneficial to keep a high-level log of pending and completed activity. Pending tasks turn into completed tasks, and completed tasks make up the examination’s historical record. Often while working, you’ll think of a task that you need to address sometime in the future or a task you’ve completed and should note. Making quick notes and more comprehensive task lists becomes increasingly valuable as the length of the examination grows (possibly to many hours, days, or longer) or when more than one examiner is involved.</p>&#13;
<p class="indentb">Maintaining a list of pending and completed tasks during an examination is important for a number of reasons:</p>&#13;
<p class="bull">• Helps ensure nothing was forgotten</p>&#13;
<p class="bull">• Avoids duplicating work already done</p>&#13;
<p class="bull">• Improves collaboration and coordination when working in teams</p>&#13;
<p class="bull">• Shows compliance with policies and procedures</p>&#13;
<p class="bull">• Facilitates accounting, including billing</p>&#13;
<p class="bull">• Helps produce documentation and reports (formal incident reports or forensic reports)</p>&#13;
<p class="bull">• Allows for post-incident review to identify lessons learned and support process optimization</p>&#13;
<p class="bull">• Helps to maintain a longer-term historical record of completed activity</p>&#13;
<p class="bull">• Supports learning and education for new team members</p>&#13;
<p class="bull">• Serves as a guide to remember complex procedures</p>&#13;
<p class="bull">• Provides information for troubleshooting problems and getting support</p>&#13;
<p class="bull">• Maintains a record of work done by external and third-party examiners</p>&#13;
<p class="indentt"><span epub:type="pagebreak" id="page_71"/>Many commercial task managers and investigation management tools are available, but the focus in this section is on simple task management that you can do from the command line. Using the command line permits you to quickly track tasks and activity without leaving the terminal to access some other graphical or web-based application.</p>&#13;
<p class="indent">Many open source command line task managers are available and can be used to manage a forensic examiner’s activity. The most important criteria include reliable task recording and a detailed timestamp (not just dates).</p>&#13;
<h5 class="h5" id="ch04lev3sec01"><strong>Taskwarrior</strong></h5>&#13;
<p class="noindenta">Taskwarrior is a popular task manager with many features for managing large task lists in a quick and efficient manner. You’ll find more information about Taskwarrior at <em><a href="http://taskwarrior.org/">http://taskwarrior.org/</a></em>. The following examples show Taskwarrior commands in practical use in a forensic lab context.</p>&#13;
<p class="indent">To add several pending tasks:</p>&#13;
<pre>$ <strong>task add acquire PC disk and transfer to evidence safe due:friday</strong><br/>Created task 1.<br/>$ <strong>task add have a meeting with investigation team to plan analysis</strong><br/>Created task 2.</pre>&#13;
<p class="indent">To list the current task list (<code>task info</code> will show times and more detailed information):</p>&#13;
<pre>$ <strong>task list</strong><br/><br/>ID Due        Age Description<br/> 1 2015-06-05 1m  acquire PC disk and transfer to evidence safe<br/> 2            3s  have a meeting with investigation team to plan analysis<br/><br/>2 tasks</pre>&#13;
<p class="indent">To complete a task on the task list:</p>&#13;
<pre>$ <strong>task 2 done</strong><br/>Completed task 2 'have a meeting with investigation team to plan analysis'.<br/>Completed 1 task.</pre>&#13;
<p class="indent">To log a completed task without placing it on the task list:</p>&#13;
<pre>$ <strong>task log requested history of PC use at the firm</strong><br/>Logged task.</pre>&#13;
<p class="indent">Taskwarrior is useful for managing large numbers of tasks. It provides reports, searching, sorting, and various levels of customizable detail. Taskwarrior maintains timestamps and unique identifiers (UUID) for each task, manages prioritization of pending tasks, and keeps a history <span epub:type="pagebreak" id="page_72"/>of completed tasks. The ability to create user-defined attributes makes it customizable for specific settings, such as a forensics lab or examination process.</p>&#13;
<h5 class="h5" id="ch04lev3sec02"><strong>Todo.txt</strong></h5>&#13;
<p class="noindenta">You can also maintain a list of completed tasks and pending work by editing a simple text file. An example is the <em>todo.txt</em> file format by Gina Trapani (see <em><a href="http://todotxt.com/">http://todotxt.com/</a></em> for more information). The <em>todo.txt</em> system defines a file format for task creation and completion dates, priorities, projects, and contexts. It also provides a shell script to manage the <em>todo.txt</em> file. Although the <code>todo.sh</code> script performs all the necessary operations on the <em>todo.txt</em> task list, the file format can be managed using a regular text editor. The notation indicates priority with parentheses (<code>(A)</code>, <code>(B)</code>, and so on), context keywords with <code>@</code>, and project keywords with <code>+</code>. Completed tasks are prefixed with an <code>x</code>. Here is an example <em>todo.txt</em> file:</p>&#13;
<pre>(A) Sign chain of custody forms @reception<br/>(B) Start forensic acquisition +Disk_A @imagingstation<br/>Discuss analysis approach with investigation team @meetingroom<br/>x 2015-05-30 08:45 upgrade ram in imaging PC @imagingstation</pre>&#13;
<p class="indent">The <em>todo.txt</em> apps don’t use timestamps, only dates. If you use this system, you must manually include the time with the completed task.</p>&#13;
<h5 class="h5" id="ch04lev3sec03"><strong>Shell Alias</strong></h5>&#13;
<p class="noindenta">You can also maintain an examiner activity log of completed tasks without the use of task management software. For example, here is a simple shell alias that redirects a short description into a file with a timestamp:</p>&#13;
<pre>$ <strong>alias log="echo $2 \`date +%FT%R\` &gt;&gt; ~/examiner.log"</strong></pre>&#13;
<p class="indent">You can customize the log filename and date format as desired. Making a quick note of activity or viewing past activity takes a simple one-line command, which you can enter anytime during the examination process. When something significant or notable occurs, enter <code><span class="codestrong">log</code></span> followed by the short description of the action taken. For example:</p>&#13;
<pre>$ <strong>log removed hdd from PC and attached to examiner machine</strong><br/>...<br/>$ <strong>log started forensic acquisition of the disk</strong><br/>...<br/>$ <strong>log acquisition completed, disk sealed in evidence bag</strong><br/>...<br/>$ <strong>cat ~/examiner.log</strong><br/>2015-05-30T09:14 informed that seized PC was enroute to forensic lab<br/>2015-05-30T10:25 PC arrived, chain of custody forms signed<br/>2015-05-30T10:47 removed hdd from PC and attached to examiner machine<br/>2015-05-30T10:55 started forensic acquisition of the disk<br/>2015-05-30T15:17 acquisition completed, disk sealed in evidence bag<br/>2015-05-30T16:09 disk transferred to evidence safe for storage</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_73"/>Simple systems for managing tasks are useful for staff who spend much of their time working on the command line. They are also advantageous for remotely working on systems with secure shell (ssh).</p>&#13;
<h4 class="h4" id="ch04lev2sec02"><em><strong>Shell History</strong></em></h4>&#13;
<p class="noindenta">This section discusses how to set up automated logging of shell commands entered by the examiner on the command line. Ideally, this command logging should not increase complexity or interfere with the forensic work in progress. Using various tools, you can log the examiner’s command line activity with automated background processes. This approach is completely transparent to the examiner during the course of a forensic investigation.</p>&#13;
<p class="indent">The Unix/Linux shell was not originally designed with logging or audit trails in mind. In the past, patches have been created to augment the history mechanism, hacks have attempted to capture commands as the shell is used, and commercial products have performed various enterprise logging. Developing a robust auditing and compliance system to log all commands with timestamps, including shell builtins as well as executed programs and pipelines, is beyond the scope of this book.</p>&#13;
<p class="indentb">The Bash shell history can be configured to satisfy the following basic requirements:</p>&#13;
<p class="bull">• Record the command entered by the examiner</p>&#13;
<p class="bull">• Record a timestamp for each command entered</p>&#13;
<p class="bull">• Record all commands, including duplicates, comments, and space-prefixed commands</p>&#13;
<p class="bull">• Avoid truncating or overwriting history files</p>&#13;
<p class="bull">• Avoid conflicts when using multiple terminal windows on the same system</p>&#13;
<p class="bull">• Include root and non-root command history</p>&#13;
<p class="indentt">Using basic Bash shell history as an audit trail is rudimentary. Important information, such as the command completion time, the working directory where the command was executed, and the return code, are not logged. The Bash history is also not a tamper-resistant system: the examiner can easily modify or delete the history. Creating a secure and tamper-resistant audit environment with restricted access is beyond the scope of this book.</p>&#13;
<p class="indent">Some shells, such as zsh, have additional history features that allow for the logging of elapsed time. Other proposed solutions to improve shell logging include the use of <code>PS1</code>, <code>PROMPT_COMMAND</code>, <code>trap</code> and <code>DEBUG</code>, and <code>key</code> bindings to modify a command before executing. Using <code>sudo</code> logging; <code>auditd</code> logging; or special scripts, such as <code>preexec.sh</code>, can also increase command line logging. A useful tutorial at <em><a href="http://www.pointsoftware.ch/en/howto-bash-audit-command-logger/">http://www.pointsoftware.ch/en/howto-bash-audit-command-logger/</a></em> discusses this problem at length and <span epub:type="pagebreak" id="page_74"/>proposes a solution. The command line audit trail should be tailored to particular lab policies or expectations.</p>&#13;
<p class="indent">For basic shell command logging, the built-in shell history functionality can be configured to record command line activity. Bash provides some useful functionality, including the ability to enable the time stamping of the commands entered. You can add the following commands to the Linux startup scripts (<code>.bashrc</code> and so on) to enable the basic requirements outlined in the previous list:</p>&#13;
<pre>set -o history<br/>shopt -s histappend<br/>export HISTCONTROL=<br/>export HISTIGNORE=<br/>export HISTFILE=~/.bash_history<br/>export HISTFILESIZE=-1<br/>export HISTSIZE=-1<br/>export HISTTIMEFORMAT="%F-%R "</pre>&#13;
<p class="indent">These commands ensure that history is enabled and in append mode (as opposed to overwriting with each new login). The two variables <code>HISTCONTROL</code> and <code>HISTIGNORE</code> control which commands are saved to the history file. A common default setting is to ignore duplicates and commands beginning with a space. To ensure complete logging of all commands, the <code>HISTCONTROL</code> and <code>HISTIGNORE</code> variables are explicitly set to null. The <code>HISTFILE</code> variable is explicitly set to ensure command history held in memory is saved when a shell exits. <code>HISTFILESIZE</code> and <code>HISTSIZE</code> are set to <code>-1</code> to ensure history is not truncated or overwritten. The <code>HISTTIMEFORMAT</code> variable enables timestamps to be written to the history file and allows you to set a time format. The format can include regional settings and should include a timestamp, not just the date.</p>&#13;
<p class="indent">At the end of the examination, the history can be saved to a text file and included in the examination’s supporting data files. The history can then be reset and made ready for the next examination by using the following commands:</p>&#13;
<pre>$ <strong>history &gt; examiner_bash_history.txt</strong><br/>$ <strong>history -c; history -w</strong></pre>&#13;
<p class="indent">Synchronizing the history across multiple shell instances can be tricky because each shell keeps its history in memory and writes it to the history file only on exit. Setting the variable <code>PROMPT_COMMAND='history -a; history -r'</code> will write (append) and read new commands from the Bash history file every time the command prompt is displayed.</p>&#13;
<p class="indent">A command logger that is actively developed is Snoopy: it provides a number of features, including logging the commands to syslog. Snoopy is a preloaded library that functions as a wrapper around the <code>execv()</code> and <code>execve()</code> system calls. It is transparent to users, and you can enable and <span epub:type="pagebreak" id="page_75"/>configure it by adding the Snoopy library to <em>/etc/ld.so.preload</em> and editing the <em>/etc/snoopy.ini</em> file. For example, suppose the following series of commands are entered on the Bash command prompt:</p>&#13;
<pre># <strong>fls -p -r /dev/sda1 | grep -i "\.doc$" |wc -l</strong><br/>10</pre>&#13;
<p class="indent">These commands are individually logged to syslog with various details:</p>&#13;
<pre>Jun  5 10:47:05 lab-pc snoopy[1521]: [uid:0 sid:1256 tty:(none) cwd:/ filename:<br/>    /bin/grep]: grep -i \.doc$<br/>Jun  5 10:47:05 lab-pc snoopy[1522]: [uid:0 sid:1256 tty:(none) cwd:/ filename:<br/>    /usr/bin/wc]: wc -l<br/>Jun  5 10:47:05 lab-pc snoopy[1520]: [uid:0 sid:1256 tty:/dev/pts/0 cwd:/ filename:<br/>    /usr/bin/fls]: fls -p -r /dev/sda1</pre>&#13;
<p class="indent">You’ll find more information and the latest release of Snoopy at <em><a href="https://github.com/a2o/snoopy/">https://github.com/a2o/snoopy/</a></em>.</p>&#13;
<h4 class="h4" id="ch04lev2sec03"><em><strong>Terminal Recorders</strong></em></h4>&#13;
<p class="noindenta">In some cases, it might be useful to show the work done in the terminal, complete with command output (<code>stdout</code>), error messages (<code>stderr</code>), and other messages or activity visible in a terminal session. Several tools exist to capture session activity and even provide playback of the session.</p>&#13;
<p class="indent">The most well-known tool is script. In this example, script is started and the output appended to a file together with timing data for replay. After running <code>script</code>, you can execute any normal shell commands, and they’ll be saved for later viewing.</p>&#13;
<pre>$ <strong>script -a -tscript.timing script.output</strong><br/>Script started, file is script.output</pre>&#13;
<p class="indent">When the recorded session is finished, enter <code>exit</code> or press <small>CTRL</small>-D. You can view the recording using the <code>scriptreplay</code> command as follows:</p>&#13;
<pre>$ <strong>scriptreplay -m1 -tscript.timing script.output</strong><br/>...[session plays back here]...</pre>&#13;
<p class="indent">Common issues that make this method challenging are the handling of control characters and events such as terminal resizing. Other TTY recorders and sniffers, such as ttyrec and termrec, are available with similar functionality and features.</p>&#13;
<p class="indent">Terminal multiplexers, such as tmux and GNU screen, also provide some level of logging that can be useful in certain situations. With screen, you can set up logging for a detached session from within a session <span epub:type="pagebreak" id="page_76"/>(<small>CTRL</small>-A followed by H). The tmux terminal multiplexer now supports logging by using the <code>pipe-pane</code> option, as shown here:</p>&#13;
<pre>$ <strong>tmux pipe-pane -o -t session_index:window_index.pane_index 'cat &gt;&gt; ~/output</strong><br/>    <strong>.window_index-pane_index.txt'</strong></pre>&#13;
<h4 class="h4" id="ch04lev2sec04"><em><strong>Linux Auditing</strong></em></h4>&#13;
<p class="noindenta">Professional labs might want to implement more robust logging or an audit trail to satisfy stricter organizational policies or regulatory requirements. One possibility to achieve this is through auditd, a Linux audit package. Typically, this involves running the <code>auditd</code> daemon with <em>pam_tty_audit.so</em> configured as a pam module. You can review audit trail activity using the <code>aureport</code> command.</p>&#13;
<p class="indent">Using auditd provides several security advantages, especially when used with granular access control, such as <code>sudo</code>. Audit trails, in particular those logging to a central log host, can be made relatively tamper resistant, ensuring an increased level of integrity when recording examination work.</p>&#13;
<p class="indent">Comprehensive audit trails can record all TTY activity (including keystrokes), as well as monitor file access and many other events on a system. Setting up auditing and audit reporting can be a complex process, one beyond the scope of this book.</p>&#13;
<p class="indent">You’ll find discussions of other solutions and hacks in various places, including <em><a href="http://www.pointsoftware.ch/en/howto-bash-audit-command-logger/">http://www.pointsoftware.ch/en/howto-bash-audit-command-logger/</a></em> and <em><a href="http://whmcr.com/2011/10/14/auditd-logging-all-commands/">http://whmcr.com/2011/10/14/auditd-logging-all-commands/</a></em>.</p>&#13;
<p class="indent">As of Bash version 4.1, a new feature allowing command history logging to syslog has been added (it may require recompilation to enable).</p>&#13;
<h3 class="h3" id="ch04lev1sec02"><strong>Organize Collected Evidence and Command Output</strong></h3>&#13;
<p class="noindent">When conducting a forensic examination on the command line, it’s common to save command output from various tools and utilities to files for future reference and reporting. You can do this by redirecting the output of commands to text files. Those files can be saved with the rest of the examination data collected. During the process of collecting and saving large amounts of evidence data, it is important to keep your file and directory structure organized and understandable. This section talks about various strategies to achieve this goal.</p>&#13;
<h4 class="h4" id="ch04lev2sec05"><em><strong>Naming Conventions for Files and Directories</strong></em></h4>&#13;
<p class="noindenta">To reduce confusion among all the files, directories, mount points, images, and other saved data collected during an examination, it’s best to follow a naming convention. Make it descriptive enough to be intuitive, but avoid redundancy in the wording and file extensions. Most important, make naming conventions consistent throughout an investigation or incident and across multiple incidents.</p>&#13;
<p class="indentb"><span epub:type="pagebreak" id="page_77"/>Certain unique identifiers are associated with systems, storage media devices, and removable media. Such identifiers can be useful when deciding on a naming convention:</p>&#13;
<p class="bull">• Company asset tag or inventory number for PCs</p>&#13;
<p class="bull">• Manufacturer serial number for disk drives</p>&#13;
<p class="bull">• 64-bit World Wide Name (WWN) for disk drives</p>&#13;
<p class="bull">• Block device UUID for filesystems and RAIDs</p>&#13;
<p class="bull">• Forensic hash value for disk drive images</p>&#13;
<p class="bull">• 48-bit MAC address for network interface cards (NICs)</p>&#13;
<p class="bull">• Forensic lab evidence number (possibly a sticker or tag on the drive)</p>&#13;
<p class="bull">• Forensic lab evidence bag number (evidence bag containing the disc)</p>&#13;
<p class="indentt">Wherever sensible, start all numbering with 1, not 0. Programmers and engineers have a tendency to start at 0, but people who read and review the examination reports may not have a technical background (lawyers, judges, managers, and so on) and expect numbering to start with 1.</p>&#13;
<p class="indent">Raw image files use the extension <em>*.raw</em> throughout this book. The commonly used <em>*.dd</em> extension implies that a dd tool was used, which might not be the case. The <em>*.raw</em> extension describes the file accurately without associating it with the particular tool used to acquire the image.</p>&#13;
<p class="indent">Ideally, a raw image’s filename should link a forensic image to a unique attribute of the physical object. If a forensic format is used, this unique information can be embedded as metadata in the forensic image file. This allows you to associate a lone physical disk with an image and associate a lone image with a physical disk. The disk and the image then remain linked without any dependencies on surrounding context (directory names, evidence shelves, and so on). This establishes a chain of custody link between the physical and digital worlds.</p>&#13;
<p class="indent">If large numbers of disks are under analysis, possibly include a serial number in the image filename. You can include varying levels of detail in a filename. Although the filename <em>server12-slot3-seagate-3.5in-disk-500gb -SN12345ACBDEE.raw</em> is very descriptive, it might be too detailed and cumbersome to work with. A practical naming convention for many basic incidents could simply be the storage media type with a number, for example, <em>disk1</em>, <em>tape1</em>, <em>ssd1</em>, <em>stick1</em>, <em>card1</em>, <em>cdrom1</em>, <em>dvd1</em>, <em>bluray1</em>, <em>floppy1</em>, and so on. In some cases, using a short description of the disk and the serial number might be the most suitable approach, for example, <em>crucial-ssd -15030E69A241.raw</em>. Often, it’s helpful to create image names that exam-iners can easily discuss in conversation, such as, “We found the file on disk1.” Terms used in conversations, raw examination output, and final reports should have a consistent nomenclature.</p>&#13;
<p class="indent">When you’re extracting files from disk images, archive files, or other compound images, add an underscore to the filename to indicate it has been extracted. This will prevent you and others from accidentally opening <span epub:type="pagebreak" id="page_78"/>malware, HTML pages with tracking bugs, macros in Office documents, or other executables and scripts that might execute on opening. Some examples are shown here:</p>&#13;
<pre>$ <strong>icat image.raw 68 &gt; photo.jpg_</strong><br/>$ <strong>icat image.raw 34 &gt; customerlist.xls_</strong><br/>$ <strong>icat image.raw 267 &gt; super-updater57.exe_</strong></pre>&#13;
<p class="indent">If an extracted file already ends with an underscore, add another one. An appended underscore make it obvious that a file has been extracted as evidence from a suspect drive.</p>&#13;
<p class="indent">When you’re analyzing an extracted file, saving tool output, or making manual notes, create a text file with the original name and append <em>_.txt</em> to it. For example:</p>&#13;
<pre>$ <strong>exif photo.jpg_ &gt; photo.jpg_.txt</strong><br/>$ <strong>vi customerlist.xls_.txt</strong><br/>$ <strong>objdump -x super-updater57.exe_ &gt; super-updater57.exe_.txt</strong></pre>&#13;
<p class="indent">The <em>_.txt</em> extension signifies that the text file contains notes, tool output, and results of forensic analysis work about the extracted file. The filename is associated with the file originally extracted from the image. The text file may contain bookmarks and examiner annotations that can be searched. Unless it’s otherwise clear where an extracted file came from (which disk, partition, and so on), it’s good practice to have such corresponding text files; they can also indicate why it was chosen for extraction.</p>&#13;
<p class="indentb">A file extension should always indicate the format of the content. For example:</p>&#13;
<p class="bull">• <em>*.txt</em> can be opened and read using a text editor.</p>&#13;
<p class="bull">• <em>*.raw</em> is a raw data dump (disk, memory, and so on).</p>&#13;
<p class="bull">• <em>*.pcap</em> is captured network traffic.</p>&#13;
<p class="bull">• <em>*.db</em> is a database (possibly a Sleuth Kit file list).</p>&#13;
<p class="bull">• <em>*.sfs</em> is a SquashFS evidence container.</p>&#13;
<p class="bull">• <em>*.e01</em> and <em>*.aff</em> are forensic formats.</p>&#13;
<p class="indentt">Each case, incident, or investigation will have an associated physical storage media. Storage media will have a corresponding forensic image and associated output from various programs (hdparm, smartctl, and so on). Each forensic image will have associated output from various programs (mmls, fls, and so on), and each extracted file may have associated output from various programs (exif, objdump, and so on). A naming convention will help keep everything organized and allow the organizing system to scale as the investigation data grows.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_79"/>How much information should be embedded into filenames and directory names? When is it more sensible to have a corresponding description text file with additional information? How should the corresponding file be associated with an image? Consider the following examples of two representations of the same incident.</p>&#13;
<p class="indent">An example of information embedded into filenames looks like this:</p>&#13;
<pre>case42.txt<br/>image6.case42.raw<br/>image6.case42.raw.txt<br/>mmls.image6.case42.txt<br/>fls.part1.image6.case42.txt</pre>&#13;
<p class="indent">An example of that same information embedded into a directory structure looks like this:</p>&#13;
<pre>./case42/case.txt<br/>./case42/image6/image.raw<br/>./case42/image6/image.raw.txt<br/>./case42/image6/mmls.txt<br/>./case42/image6/part1/fls.txt</pre>&#13;
<p class="indent">For manually written notes, further descriptions, caveats, issues, and other random comments within a certain context, storing the information in simple <em>notes.txt</em> or <em>readme.txt</em> files within working directories can be useful. They can provide reminders, hints, or warnings for you or other examiners to read at a later date.</p>&#13;
<p class="indent">When you’re noting web URLs that might pose a risk if opened, replace <em>http</em> with <em>hxxp</em> to prevent others from accidentally clicking them. Such links might take the user to malware, personal sites monitored by a suspect, sites with tracking bugs, or other content that should not be accessed without understanding the consequences.</p>&#13;
<h4 class="h4" id="ch04lev2sec06"><em><strong>Scalable Examination Directory Structure</strong></em></h4>&#13;
<p class="noindenta">Each incident, case, or investigation should have a single unique directory (for example, <em>case42</em>). All collected evidence, images, and analysis work should be contained within a hierarchy under that one root directory. As investigations scale, a well-planned directory structure can scale with it. Having a single directory is also practical when multiple forensic examiners are working on the same incident and sharing the directory structure. Be prepared to reorganize the directory structure if an incident grows in complexity. If a large number of files are being extracted for individual analysis, consider having an <em>export</em> directory (similar to EnCase).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_80"/>Examinations often scale unexpectedly, and a forensic examination that starts with a single disk under suspicion might expand into a larger examination involving multiple PCs with many disks. For example, suppose someone reports strange or suspicious behavior of a PC or employee. A single disk is seized for examination. Preliminary examination results find a USB stick is also involved. It is found and examined, and a second PC is linked to the incident. That PC has two internal hard disks and DVD burner. Further search reveals a box of DVDs full of data hidden in a closet. Then it turns out that an external USB hard disk and a spare notebook in another building are also involved in the incident. The collected evidence has grown from a single hard disk to 16 storage media items. This hypothetical incident is not uncommon in large organizations. When preparing for an examination, expanded coverage should be anticipated. The naming convention should be designed to scale as the size of an investigation grows.</p>&#13;
<p class="indent">Some PCs are used by multiple people, and some people use multiple PCs. Notebooks are not necessarily bound to a physical location. Removable media can be shared and attached to multiple PCs and notebooks. Over long periods of time, PC hardware will change, offices may change, departments will experience staff turnover, and organizational restructuring may occur. Be sure to design file and directory names to accommodate these changes.</p>&#13;
<p class="indent">As an examination progresses, the number of output files will grow as more collected data is analyzed and output is produced. A good practice is to create a directory structure to separate the files and organize the output of the examination. As with filenames, the directory name should indicate the contents without revealing confidential information. Creating a separate directory for each disk or image analyzed segregates files and allows an investigation to scale up.</p>&#13;
<p class="indent">The smallest examination usually consists of a single disk. A slightly larger examination might consist of a PC containing multiple disks; consider the following example directory structure:</p>&#13;
<div class="image3"><img src="../images/f0080-01.jpg" alt="image"/></div>&#13;
<p class="indent">As another example, consider the examination of an entire workplace that consists of a desktop PC (possibly with multiple disks), a notebook, several USB drives, multiple CD-ROMs and DVDs, and an external disk pack. A convenient directory structure would organize each piece of storage media where the command output files are stored, allowing an examination to easily scale further. Consider a larger investigation consisting of multiple workplaces, across multiple office buildings, spread out across multiple countries. In large global organizations, such investigations can occur; therefore, having a well-thought-out naming convention will maintain the organization of the examination process.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_81"/>It’s advantageous to rely on a directory structure to separate command output from different disks, PCs, users, and locations. As a result, you won’t need to embed this information into the output filenames. For example:</p>&#13;
<div class="image3"><img src="../images/f0081-01.jpg" alt="image"/></div>&#13;
<p class="indent">In this example, two office locations are US123 and UK567, in the United States and the United Kingdom, respectively. The US office is divided by user workplaces, and a directory is used for each piece of storage media under examination. The UK office PC is not associated with any particular user (possibly located in a meeting room), and this is reflected in the directory structure.</p>&#13;
<p class="indent">Instead of using an employee identifier for the storage media, an organization’s IT inventory number can be used for the storage media in the directory structure. This unique identifier will likely have additional information associated with it (date of purchase, department, office location, user details, software installed, history of use, and so on). Confidentiality reasons might require you to omit information from the filenames and directory structure. For example, names of suspected or targeted individuals should not be embedded into filenames. Rather, you should use an identifier, initials, or an employee number. Code names for investigations might also be used. They provide a minimal level of protection if the information is lost, stolen, or otherwise accessed at a later date.</p>&#13;
<h4 class="h4" id="ch04lev2sec07"><em><strong>Save Command Output with Redirection</strong></em></h4>&#13;
<p class="noindenta">After creating the directory structure to store the analysis results from various items under examination, typical shell command output is redirected into files from stdout as shown here:</p>&#13;
<pre># <strong>fls /dev/sda1 &gt; fls-part1.txt</strong><br/># <strong>fls /dev/sda2 &gt; fls-part2.txt</strong></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_82"/>To include regular output and error messages, you need to redirect stdout and stderr file descriptors to the file. Newer versions of Bash provide an easy-to-remember method by adding an ampersand to the redirection (this also applies when piping to another program):</p>&#13;
<pre># <strong>fls /dev/sda &amp;&gt; fls-part1.txt</strong></pre>&#13;
<p class="indent">Other shells and earlier Bash versions might require <code>2&gt;&amp;1</code> notation for combining stderr and stdin. For example:</p>&#13;
<pre># <strong>fls /dev/sda &gt; fls-part1.txt 2&gt;&amp;1</strong></pre>&#13;
<p class="indent">When a text file already exists and you need to add additional information to it, you can use the <code>&gt;&gt;</code> notation to specify an append operation. For example:</p>&#13;
<pre># <strong>grep clientnames.xls fls-part1.txt &gt;&gt; notes.txt</strong></pre>&#13;
<p class="indent">Here, all instances of a known filename are added to the end of the <em>notes.txt</em> file.<sup><a id="fn_17" href="footnote.xhtml#fn17">1</a></sup> If <em>notes.txt</em> doesn’t exist, it will be created.</p>&#13;
<p class="indent">Many forensic tasks performed on the command line are time-consuming and may take many hours to complete (disk imaging, performing operations on very large files, and so on). Having a timestamp indicating the duration of the command can be useful. The <code>time</code> command provides this functionality. There are two common implementations of the <code>time</code> command: one is a shell builtin with rudimentary features, and the other is a GNU utility with additional features. The primary advantage of the shell builtin <code>time</code> version is that it will time an entire pipeline of commands, whereas GNU <code>time</code> will only time the first command in a pipeline.</p>&#13;
<p class="indent">Here is an example of using the <code>time</code> command to run a disk-imaging program:</p>&#13;
<pre># <strong>time dcfldd if=/dev/sdc of=./ssd-image.raw</strong><br/>3907328 blocks (122104Mb) written.<br/>3907338+1 records in<br/>3907338+1 records out<br/><br/>real    28m5.176s<br/>user    0m11.652s<br/>sys     2m23.652s</pre>&#13;
<p class="indent">The zsh shell can log the elapsed time of a command as part of the history file. This functionality is currently not available in Bash.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_83"/>Another useful command for some situations is the timestamp output command <code>ts</code>. Any output piped into <code>ts</code> will have a timestamp appended to each line of output.</p>&#13;
<pre># <strong>(ls -l image.raw; cp -v image.raw /exam/image.raw; md5sum /exam/image.raw) |ts</strong><br/>May 15 07:45:28 -rw-r----- 1 root root 7918845952 May 15 07:40 image.raw<br/>May 15 07:45:40 'image.raw' -&gt; '/exam/image.raw'<br/>May 15 07:45:53 4f12fa07601d02e7ae78c2d687403c7c  /exam/image.raw</pre>&#13;
<p class="indent">In this example, three commands were executed (grouped together with parentheses) and the command outputs were sent to <code>ts</code>, creating a timeline.</p>&#13;
<h3 class="h3" id="ch04lev1sec03"><strong>Assess Acquisition Infrastructure Logistics</strong></h3>&#13;
<p class="noindent">Various logistical issues are important when performing forensic acquisition of storage media. Managing large acquired forensic images is not a trivial task and so requires planning and forethought. Factors such as disk capacity, time duration, performance, and environmental issues need to be considered.</p>&#13;
<h4 class="h4" id="ch04lev2sec08"><em><strong>Image Sizes and Disk Space Requirements</strong></em></h4>&#13;
<p class="noindenta">Forensic images of storage media are orders of magnitude larger than the small file sizes a PC typically handles. Managing disk image files of this size takes additional thought and planning. You also need to consider certain logistical factors when you’re preparing an examination system. Careful preparation and planning for an examination will save you time and effort, as well as help you avoid problems that might disrupt the process.</p>&#13;
<p class="indent">When creating a forensic image of a disk (hundreds of gigabytes or tera-bytes), it is not files that are copied, but the individual disk sectors. If a 1TB disk has only a single 20K Microsoft Word document on it, an uncompressed forensic image will still be 1TB. As of this writing, 10TB disks are now on the market, increasing the challenge for performing forensic acquisition.</p>&#13;
<p class="indentb">When managing disk images, the examiner’s time and the examiner host’s disk capacity are the main logistical factors that need to be considered. Before beginning a forensic acquisition of a subject disk or storage media, you need to ask a number of questions:</p>&#13;
<p class="bull">• Can the attached storage be analyzed <em>in place</em> without taking a forensic image?</p>&#13;
<p class="bull">• What is the size of the subject disk?</p>&#13;
<p class="bull">• What is the available space on the examiner’s machine?</p>&#13;
<p class="bull"><span epub:type="pagebreak" id="page_84"/>• What is the potential for image compression?</p>&#13;
<p class="bull">• How much space do forensic tools need for processing and temporary files?</p>&#13;
<p class="bull">• What is the estimated number of files to be extracted for further analysis?</p>&#13;
<p class="bull">• How much memory and swap space is available on the examiner’s machine?</p>&#13;
<p class="bull">• Is there a possibility of more subject disks being added to the same case or incident?</p>&#13;
<p class="bull">• Is there an expectation to separately extract all slack or unallocated disk space?</p>&#13;
<p class="bull">• Are there plans to extract individual partitions (possibly including swap)?</p>&#13;
<p class="bull">• Is there a potential need to convert from one forensic format to another?</p>&#13;
<p class="bull">• Do disk images need to be prepared for transport to another location?</p>&#13;
<p class="bull">• Do subject disks contain virtual machine images to separately extract and analyze?</p>&#13;
<p class="bull">• Do subject disks contain large numbers of compressed and archive files?</p>&#13;
<p class="bull">• Are subject disks using full-disk encryption?</p>&#13;
<p class="bull">• Is there a need to burn images to another disk or DVDs for storage or transport?</p>&#13;
<p class="bull">• Is there a need to carve files from a damaged or partially overwritten filesystem?</p>&#13;
<p class="bull">• How are backups of the examiner host performed?</p>&#13;
<p class="indentt">In some situations, it may not be necessary to image a disk. When certain triage or cursory searching is conducted, it may be enough to attach the disk to an examiner host and operate on the live subject disk. Depending on the triage or search findings, you can decide whether or not to take a forensic image. In a corporate environment, this approach could translate into downtime for an employee, because they must wait for a seized disk to be reviewed or analyzed. Corporate environments typically have a standard end-user PC build, which is designed without local user data (all data is saved to servers or clouds). It could be more economical simply to swap the original disk with a new disk. End-user PC disks are cheap, and replacing a subject disk with a new one could be a cost-saving alternative when factoring in the cost of employee downtime and the time needed to image a disk in the field.</p>&#13;
<h4 class="h4" id="ch04lev2sec09"><span epub:type="pagebreak" id="page_85"/><em><strong>File Compression</strong></em></h4>&#13;
<p class="noindenta">Using compression solves a number of the capacity challenges faced by a forensic examiner. You can use a compressed forensic format to store the resulting acquired image, but the effectiveness depends on a number of factors.</p>&#13;
<p class="indent">The compression algorithms you choose will have some effect on the size and time needed to compress a subject disk. A better compression ratio will take more time to compress (and subsequently uncompress).</p>&#13;
<p class="indent">A relatively new PC disk that contains a large number of untouched disk sectors (original manufacturer’s zeroed contents) will compress better than an older disk containing significant amounts of residual data in the unallocated sectors.</p>&#13;
<p class="indent">Disks that contain large amounts of compressed files (<em>*.mp3</em>, <em>*.avi</em>, and so on) will not compress much further, and as a result, forensic imaging tools will benefit less from added compression.</p>&#13;
<p class="indent">Encrypted subject disks or disks with large numbers of encrypted files will not compress as well as unencrypted content due to the data’s higher entropy level.</p>&#13;
<h4 class="h4" id="ch04lev2sec10"><em><strong>Sparse Files</strong></em></h4>&#13;
<p class="noindenta">Sparse files are worth mentioning because they have some advantages; however, they can also be problematic when calculating disk capacity. Some filesystems use metadata to represent a sequence of zeros in a file instead of actually writing all the zeros to the disk. Sparse files contain “holes” where a sequence of zeros is known to exist. To illustrate, a new drive containing mostly zeroed sectors is acquired with GNU dd,<sup><a id="fn_18" href="footnote.xhtml#fn18">2</a></sup> first as a regular raw file and then as a sparse file.</p>&#13;
<pre># <strong>dd if=/dev/sde of=image.raw</strong><br/>15466496+0 records in<br/>15466496+0 records out<br/>7918845952 bytes (7.9 GB, 7.4 GiB) copied, 112.315 s, 70.5 MB/s<br/><br/># <strong>dd if=/dev/sde of=sparse-image.raw conv=sparse</strong><br/>15466496+0 records in<br/>15466496+0 records out<br/>7918845952 bytes (7.9 GB, 7.4 GiB) copied, 106.622 s, 74.3 MB/s</pre>&#13;
<p class="indent">The GNU <code>dd</code> command provides a <code>conv=sparse</code> flag that creates a sparse destination file. In these dd examples, you can see the number of blocks transferred is the same for both the normal and sparse files. In the following <span epub:type="pagebreak" id="page_86"/>output, the file size and the MD5 hash are also identical. However, notice how the block size used on the filesystem is very different (7733252 blocks versus 2600 blocks):</p>&#13;
<pre># <strong>ls -ls image.raw sparse-image.raw</strong><br/>7733252 -rw-r----- 1 root root 7918845952 May 15 08:28 image.raw<br/>   2600 -rw-r----- 1 root root 7918845952 May 15 08:30 sparse-image.raw<br/><br/># <strong>md5sum image.raw sparse-image.raw</strong><br/>325383b1b51754def26c2c29bcd049ae  image.raw<br/>325383b1b51754def26c2c29bcd049ae  sparse-image.raw</pre>&#13;
<p class="indent">Although the sparse file requires much less space, the full byte size is still reported as the file size. This can cause confusion when calculating the real available disk capacity. Sparse files are often used by VM images and can become an issue when extracted for analysis.</p>&#13;
<p class="indent">You can also use sparse files as a method of compacting image files, but using compressed forensic formats or SquashFS containers is preferred and recommended. Not all programs and utilities can handle sparse files correctly, and the files can become problematic when moved between filesystems and platforms. Some programs may even expand sparse files when reading them.</p>&#13;
<h4 class="h4" id="ch04lev2sec11"><em><strong>Reported File and Image Sizes</strong></em></h4>&#13;
<p class="noindenta">Reporting data sizes is an important concept to grasp. When you’re working with forensic tools, size can refer to bytes, disk sectors, filesystem blocks, or other units of measurement. The notation for bytes can be prefixed with a multiplier (such as kilobytes, megabytes, gigabytes, terabytes, and so on), and the multiplier can refer to multiples of either 1000 or 1024. Disk sectors could represent sector sizes of either 512 bytes or 4096 bytes. The filesystem block size depends on the type of filesystem and the parameters used during creation. When you’re documenting sizes in a forensic context, it’s important to always include descriptive units.</p>&#13;
<p class="indent">Many Linux tools support the <code>-h</code> flag to report file sizes in a human readable form. For example, you can use <code>ls -lh</code>, <code>df -h</code>, and <code>du -h</code> to more easily view the size of files and partitions. An example <code>ls</code> output with several file sizes is shown here:</p>&#13;
<pre># <strong>ls -l</strong><br/>total 4<br/>-rw-r----- 1 root root 2621440000 Jan 29 14:44 big.file<br/>-rw-r----- 1 root root  104857600 Jan 29 14:41 medium.file<br/>-rw-r----- 1 root root      51200 Jan 29 14:42 small.file<br/>-rw-r----- 1 root root         56 Jan 29 14:44 tiny.file<br/># <strong>ls -lh</strong><br/>total 4.0K<br/>-rw-r----- 1 root root 2.5G Jan 29 14:44 big.file<br/>-rw-r----- 1 root root 100M Jan 29 14:41 medium.file<br/>-rw-r----- 1 root root  50K Jan 29 14:42 small.file<br/>-rw-r----- 1 root root   56 Jan 29 14:44 tiny.file</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_87"/>The sizes in the second command’s output are much easier to read and understand.</p>&#13;
<h4 class="h4" id="ch04lev2sec12"><em><strong>Moving and Copying Forensic Images</strong></em></h4>&#13;
<p class="noindenta">Moving and copying forensic disk images from one place to another requires planning and foresight. Don’t think of image files in the same way as typical end-user files (even though technically they’re the same).</p>&#13;
<p class="indentb">Acquiring, copying, and moving large disk images may take many hours or even days depending on the size and speed of the source disk and other performance factors. Consider the following list of typical file and disk image sizes and the average amount of time needed to copy the file from one disk to another disk:<sup><a id="fn_19" href="footnote.xhtml#fn19">3</a></sup></p>&#13;
<p class="bull">• 5KB simple ASCII text email: less than 1 second</p>&#13;
<p class="bull">• 5MB typical MP3 music file: less than 1 second</p>&#13;
<p class="bull">• 650MB CD ISO image: about 5 seconds</p>&#13;
<p class="bull">• 5–6GB typical DVD or iTunes movie download: about 1 minute</p>&#13;
<p class="bull">• 64GB common mobile phone image: about 10 minutes</p>&#13;
<p class="bull">• 250GB common notebook disk image: 30-40 minutes</p>&#13;
<p class="bull">• 1TB typical desktop PC image: more than 2 hours</p>&#13;
<p class="bull">• 2TB typical external USB disk image: more than 4 hours</p>&#13;
<p class="bull">• 8TB internal disk image: more than 16 hours</p>&#13;
<p class="indentt">Once a copy or move process has been started, disrupting it could leave the data in an incomplete state or require additional time to revert to the original state. A copy or move operation could create temporary files or result in two copies of the images existing temporarily.</p>&#13;
<p class="indent">In general, think carefully beforehand about the copying and moving of large data sets, and don’t interrupt the process once it has started.</p>&#13;
<h4 class="h4" id="ch04lev2sec13"><em><strong>Estimate Task Completion Times</strong></em></h4>&#13;
<p class="noindenta">The forensic acquisition process takes time to complete. During this time, people and other processes may be waiting. Therefore, it’s important to calculate and estimate the completion time needed for various processes. Also, determine whether you need to report estimated completion times to other parties, such as management, legal teams, law enforcement, or other investigators. It is important to manage expectations with regard to the time needed for completion.</p>&#13;
<p class="indentb"><span epub:type="pagebreak" id="page_88"/>Some important questions to consider include:</p>&#13;
<p class="bull">• Can the acquisition be safely left running overnight while nobody is around?</p>&#13;
<p class="bull">• Is the examiner machine unusable during the acquisition process (for performance reasons or other reasons)?</p>&#13;
<p class="bull">• Can other examination work be done while the forensic image is being acquired?</p>&#13;
<p class="bull">• When can several tasks be completed in parallel?</p>&#13;
<p class="bull">• Are there certain tasks or processes that can only be done sequentially?</p>&#13;
<p class="bull">• Are there tasks that will block other tasks until they’re completed?</p>&#13;
<p class="bull">• Can the workload be shared, delegated, or distributed across multiple examiners?</p>&#13;
<p class="indentt">You can calculate an estimated completion time for an acquisition. From previous work and processes, you should know the approximate initial setup time. This includes factors such as completing paperwork, creating necessary directory structure, documenting the hardware, attaching suspect drives to the examiner host, deciding on the approach for acquisition, and so on. This will give you a time estimate for the preacquisition phase.</p>&#13;
<p class="indent">You can calculate the expected storage media acquisition time based on the amount of data (known) passing through the slowest component in the system (the bottleneck).</p>&#13;
<h4 class="h4" id="ch04lev2sec14"><em><strong>Performance and Bottlenecks</strong></em></h4>&#13;
<p class="noindenta">To improve the efficiency of a forensic acquisition, you can optimally tune the examiner host and assess the bottlenecks.</p>&#13;
<p class="indent">A performance bottleneck always occurs; this is simply the slowest component in the system, which all other components must wait for. In a forensic setting, the bottleneck should ideally be the subject disk. This is the evidence source and is the only performance variable that you can’t (or shouldn’t) modify.</p>&#13;
<p class="indent">You can assess the performance of various system components by reading the vendor specifications, querying the system with various tools, or running various benchmarking and measurement tests.</p>&#13;
<p class="indent">Useful tools to check the speed of various components include dmidecode, lshw, hdparm, and lsusb. Several command line examples are shown here.</p>&#13;
<p class="indent">To check the CPU family and model, current and maximum speed, number of cores and threads, and other flags and characteristics, use this command:</p>&#13;
<pre># <strong>dmidecode -t processor</strong></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_89"/>Here is a command to view the CPU’s cache (L1, L2, and L3):</p>&#13;
<pre># <strong>dmidecode -t cache</strong></pre>&#13;
<p class="indent">To view the memory, including slots used, size, data width, speed, and other details, use this command:</p>&#13;
<pre># <strong>dmidecode -t memory</strong></pre>&#13;
<p class="indent">Here is a command to view the number of PCI slots, usage, designation, and type:</p>&#13;
<pre># <strong>dmidecode -t slot</strong></pre>&#13;
<p class="indent">A command to view the storage interfaces, type (SATA, NVME, SCSI, and so on), and speed:</p>&#13;
<pre># <strong>lshw -class storage</strong></pre>&#13;
<p class="indent">To view the speed, interface, cache, rotation, and other information about the attached disks (using device <em>/dev/sda</em> in this example), use this:</p>&#13;
<pre># <strong>hdparm -I /dev/sda</strong></pre>&#13;
<p class="indent">To view the speed of the external USB interfaces (and possibly an attached write blocker), use this command:</p>&#13;
<pre># <strong>lsusb -v</strong></pre>&#13;
<div class="note">&#13;
<p class="notet"><strong>NOTE</strong></p>&#13;
<p class="notep"><em>There are many different methods and commands to get this information. The commands shown here each present one example of getting the desired performance information. Providing an exhaustive list of all possible tools and techniques is beyond the scope of this book.</em></p>&#13;
</div>&#13;
<p class="indent">Reading the vendor documentation and querying a system will identify the speeds of various components. To get an accurate measurement, it’s best to use tools for hardware benchmarking and software profiling. Some tools for benchmarking include mbw for memory and bonnie++ for disk I/O.</p>&#13;
<p class="indent">The health and tuning of the OS is also a performance factor. Monitoring the logs (syslog, dmesg) of the examiner hardware can reveal error messages, misconfiguration, and other inefficiency indicators. Tools to monitor the performance and load of the live state of an examiner machine include htop, iostat, vmstat, free, or nmon.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_90"/>You can also optimize the OS by ensuring minimal processes are running in the background (including scheduled processes via cron), tuning the kernel (<code>sysctl -a</code>), tuning the examiner host’s filesystems (<code>tunefs</code>), and managing disk swap and caching. In addition, ensure that the examiner OS is running on native hardware, not as a virtual machine.</p>&#13;
<p class="indentb">When you’re looking for bottlenecks or optimizing, it’s helpful to imagine the flow of data from the subject disk to the examiner host’s disk. During an acquisition, the data flows through the following hardware interfaces and components:</p>&#13;
<p class="bull">• Subject disk platters/media (rotation speed? latency?)</p>&#13;
<p class="bull">• Subject disk interface (SATA-X?)</p>&#13;
<p class="bull">• Write blocker logic (added latency?)</p>&#13;
<p class="bull">• Write blocker examiner host interface (USB3 with UASP?)</p>&#13;
<p class="bull">• Examiner host interface (USB3 sharing a bus with other devices? bridged?)</p>&#13;
<p class="bull">• PCI bus (PCI Express? speed?)</p>&#13;
<p class="bull">• CPU/memory and OS kernel (speed? DMA? data width?)</p>&#13;
<p class="indentt">These components will be traversed twice, once between the subject disk and the examiner host, and again between the host and the examiner disk where the acquired image is being saved.</p>&#13;
<p class="indent">Ensure that the data flow between the subject disk and the CPU/memory is not using the same path as for the data flow between the CPU/memory and the destination disk on the examiner host. For example, if a field imaging system has a write blocker and an external disk for the acquired image, and both are connected to local USB ports, it is possible they’re sharing a single bus. As a result, the available bandwidth will be split between the two disks, causing suboptimal performance.</p>&#13;
<p class="indent">For network performance tuning, the speed of the underlying network becomes a primary factor, and performance enhancements include the use of jumbo Ethernet frames and TCP checksum offloading with a high-performance network interface card. It is also beneficial to assess when various programs are accessing the network and for what reason (automatic updates, network backups, and so on).</p>&#13;
<p class="indent">To summarize, have an overall plan or strategy for the acquisition actions you intend to take. Have well-tested processes and infrastructure in place. Ensure that the right capacity planning and optimizing has been done. Be able to monitor the activity while it’s in progress.</p>&#13;
<p class="indent">The most common bus speeds relevant for a forensic examination host (in bytes/second) are listed in <a href="ch04.xhtml#ch4table1">Table 4-1</a> for comparison. You’ll find a good reference of the bit rates for various interfaces and buses at <em><a href="https://en.wikipedia.org/wiki/List_of_device_bit_rates">https://en.wikipedia.org/wiki/List_of_device_bit_rates</a></em>.</p>&#13;
<p class="tablecap"><span epub:type="pagebreak" id="page_91"/><a id="ch4table1"/><strong>Table 4-1:</strong> Common Bus/Interface Speeds</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="tableth"><p class="table"><strong>Bus/interface</strong></p></td>&#13;
<td style="vertical-align: top;" class="tableth"><p class="table"><strong>Speed</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="table">Internal buses</p></td>&#13;
<td style="vertical-align: top;"><p class="table"> </p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tablei">PCI Express 3.0 x16</p></td>&#13;
<td style="vertical-align: top;"><p class="table">15750 MB/s</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tablei">PCI Express 3.0 x8</p></td>&#13;
<td style="vertical-align: top;"><p class="table">7880 MB/s</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tablei">PCI Express 3.0 x4</p></td>&#13;
<td style="vertical-align: top;"><p class="table">3934 MB/s</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tablei">PCI 64-bit/133MHz</p></td>&#13;
<td style="vertical-align: top;"><p class="table">1067 MB/s</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="table">Storage drives</p></td>&#13;
<td style="vertical-align: top;"><p class="table"> </p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tablei">SAS4</p></td>&#13;
<td style="vertical-align: top;"><p class="table">2400 MB/s</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tablei">SAS3</p></td>&#13;
<td style="vertical-align: top;"><p class="table">1200 MB/s</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tablei">SATA3</p></td>&#13;
<td style="vertical-align: top;"><p class="table">600 MB/s</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tablei">SATA2</p></td>&#13;
<td style="vertical-align: top;"><p class="table">300 MB/s</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tablei">SATA1</p></td>&#13;
<td style="vertical-align: top;"><p class="table">150 MB/s</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="table">External interfaces</p></td>&#13;
<td style="vertical-align: top;"><p class="table"> </p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tablei">Thunderbolt3</p></td>&#13;
<td style="vertical-align: top;"><p class="table">5000 MB/s</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tablei">Thunderbolt2</p></td>&#13;
<td style="vertical-align: top;"><p class="table">2500 MB/s</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tablei">USB3.1</p></td>&#13;
<td style="vertical-align: top;"><p class="table">1250 MB/s</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tablei">USB3.0</p></td>&#13;
<td style="vertical-align: top;"><p class="table">625 MB/s</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tablei">GB Ethernet</p></td>&#13;
<td style="vertical-align: top;"><p class="table">125 MB/s</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tablei">FW800</p></td>&#13;
<td style="vertical-align: top;"><p class="table">98 MB/s</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tablei">USB2</p></td>&#13;
<td style="vertical-align: top;"><p class="table">60 MB/s</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch04lev2sec15"><em><strong>Heat and Environmental Factors</strong></em></h4>&#13;
<p class="noindenta">During a forensic disk acquisition, every accessible sector on the disk is being read, and the reading of the disk is sustained and uninterrupted, often for many hours. As a result, disk operating temperatures can increase and cause issues. When disks become too hot, the risk of failure increases, especially with older disks. Researchers at Google have produced an informative paper on hard disk failure at <em><a href="http://research.google.com/archive/disk_failures.pdf">http://research.google.com/archive/disk_failures.pdf</a></em>.</p>&#13;
<p class="indent">To reduce the risk of read errors, bad blocks, or total disk failure, it’s worthwhile to monitor the disk temperature while a disk is being acquired. Most disk vendors publish the normal operating temperatures for their drives, including the maximum acceptable operating temperature.</p>&#13;
<p class="indent">You can also use several tools to manually query the temperature of a drive. A simple tool that queries the SMART interface for a drive’s temperature is hddtemp, as shown here:</p>&#13;
<pre># <strong>hddtemp /dev/sdb</strong><br/>/dev/sdb: SAMSUNG HD160JJ: 46C</pre>&#13;
<p class="indent">The hddtemp tool can be run as a daemon and periodically log to syslog, where you can monitor it for certain thresholds.</p>&#13;
<p class="indent">For more detailed output on a disk’s temperature, and in some cases a temperature history, use the smartctl tool. Here is an example:</p>&#13;
<pre># <strong>smartctl -x /dev/sdb</strong><br/>...<br/>Vendor Specific SMART Attributes with Thresholds:<br/>ID# ATTRIBUTE_NAME          FLAGS    VALUE WORST THRESH FAIL RAW_VALUE<br/>...<br/>190 Airflow_Temperature_Cel -O---K   100   055   000    -    46<br/>194 Temperature_Celsius     -O---K   100   055   000    -    46<br/>...<br/>Current Temperature:                 46 Celsius<br/>Power Cycle Max Temperature:         46 Celsius<br/>Lifetime    Max Temperature:         55 Celsius<br/><br/>SCT Temperature History Version:     2<br/>Temperature Sampling Period:         1 minute<br/>Temperature Logging Interval:        1 minute<br/>Min/Max recommended Temperature:     10/55 Celsius<br/>Min/Max Temperature Limit:            5/60 Celsius<br/>Temperature History Size (Index):    128 (55)<br/><br/>Index    Estimated Time   Temperature Celsius<br/>  56    2015-06-07 19:56    50  *******************************<br/>...<br/>  62    2015-06-07 20:02    55  ************************************<br/>  63    2015-06-07 20:03    55  ************************************<br/>  64    2015-06-07 20:04    51  ********************************<br/>...<br/>  55    2015-06-07 22:03    46  ***************************</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_92"/>If a disk begins to overheat during a disk acquisition, take action to reduce the temperature. As an immediate step, temporarily suspend the acquisition process and continue it when the disk has cooled. Depending on the acquisition method you use, this could be a simple matter of sending a signal to the Linux process by pressing <small>CTRL</small>-Z or entering <code>kill -SIGTSTP</code> followed by a process id. When the temperature decreases to an acceptable level, the acquisition process can be resumed from the same place it was suspended.</p>&#13;
<p class="indent">Suspending and resuming a process in this way should not affect the forensic soundness of the acquisition. The process is suspended with its operational state intact (current sector, destination file, environment variables, and so on). An example of suspending and resuming an imaging process on the shell by pressing <small>CTRL</small>-Z looks like this:</p>&#13;
<pre># <strong>dcfldd if=/dev/sdb of=./image.raw</strong><br/>39424 blocks (1232Mb) written.^Z<br/>[1]+  Stopped                 dcfldd if=/dev/sdb of=./image.raw<br/># <strong>fg</strong><br/>dcfldd if=/dev/sdb of=./image.raw<br/>53760 blocks (1680Mb) written.<br/>...</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_93"/>Here an executing <code>dcfldd</code> command is suspended by pressing <small>CTRL</small>-Z on the keyboard. Resume the process by using the <code>fg</code> command (foreground). The process can also be resumed with a <code>kill -SIGCONT</code> command. See the Bash documentation and the SIGNAL(7) manual page for more about job control and signals.</p>&#13;
<p class="indent">Using tools such as Nagios, Icinga, or other infrastructure-monitoring systems, you can automate temperature monitoring and alerting. Such systems monitor various environmental variables and provide alerts when critical thresholds are approached or exceeded.</p>&#13;
<p class="indent">Many forensic labs use heat sinks or disk coolers when imaging to reduce the problem of overheating subject disks. This is recommended during long acquisition sessions, especially when you’re working with older drives.</p>&#13;
<p class="indent">If you attempt to use certain power management techniques to reduce heat, they will be of little use. These methods work by spinning down the drive after a period of idle time; however, during a sustained imaging operation, there is little or no idle time.</p>&#13;
<h3 class="h3" id="ch04lev1sec04"><strong>Establish Forensic Write-Blocking Protection</strong></h3>&#13;
<p class="noindent">A fundamental component of digital evidence collection is performing a forensically sound acquisition of storage media. You can achieve part of this goal<sup><a id="fn_20" href="footnote.xhtml#fn20">4</a></sup> by ensuring that a write-blocking mechanism is in place before you attach the disk to the forensic acquisition host.</p>&#13;
<p class="indent">When you attach a disk to a PC running a modern OS, automated processes significantly increase the risk of data modification (and therefore evidence destruction). Attempts to automatically mount partitions, generate thumbnail images for display in graphical file managers, index for local search databases, scan with antivirus software, and more all put an attached drive at risk of modification. Timestamps might be updated, destroying potential evidence. Deleted files in unallocated parts of the disk might be overwritten, also destroying evidence. Discovered malware or viruses (the very evidence an investigator might be looking for) could be purged. Journaling filesystems could have queued changes in the journal log written to disk. There may be attempts to repair a broken filesystem or assemble/synchronize RAID components.</p>&#13;
<p class="indent">In addition to automated potential destruction of evidence, human error poses another significant risk. People might accidentally copy or delete files; browse around the filesystem (and update last-accessed time-stamps); or mistakenly choose the wrong device, resulting in a destructive action.</p>&#13;
<p class="indent">Write blockers were designed to protect against unwanted data modification on storage media. Requiring the use of write blockers in a forensic lab’s standard processes and procedures demonstrates due diligence. It satisfies industry best practice for handling storage media as evidence in a digital <span epub:type="pagebreak" id="page_94"/>forensic setting. Write blockers guarantee a read-only method of attaching storage media to an examiner’s workstation.</p>&#13;
<p class="indentb">NIST Computer Forensic Tool Testing (CFTT) provides formal requirements for write blockers. The Hardware Write Block (HWB) Device Specification, Version 2.0 is available at <em><a href="http://www.cftt.nist.gov/hardware_write_block.htm">http://www.cftt.nist.gov/hardware_write_block.htm</a></em>. This specification identifies the following top-level tool requirements:</p>&#13;
<p class="bull">• An HWB device shall not transmit a command to a protected storage device that modifies the data on the storage device.</p>&#13;
<p class="bull">• An HWB device shall return the data requested by a read operation.</p>&#13;
<p class="bull">• An HWB device shall return without modification any access-significant information requested from the drive.</p>&#13;
<p class="bull">• Any error condition reported by the storage device to the HWB device shall be reported to the host.</p>&#13;
<p class="indentt">Both hardware and software write blockers are available, as stand-alone hardware, installable software packages, or bootable forensic CDs. In some cases, media might have built-in read-only functionality.</p>&#13;
<h4 class="h4" id="ch04lev2sec16"><em><strong>Hardware Write Blockers</strong></em></h4>&#13;
<p class="noindenta">The preferred method of write blocking uses hardware devices situated between a subject disk and an examiner’s workstation. A hardware write blocker intercepts drive commands sent to the disk that might modify the data. A photograph of a portable write-blocking device protecting a SATA drive (Tableau by Guidance Software) is shown in <a href="ch04.xhtml#ch4fig1">Figure 4-1</a>.</p>&#13;
<div class="image"><img src="../images/f04-01.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch4fig1"/><em>Figure 4-1: Portable SATA write blocker</em></p>&#13;
<p class="indent">Hardware write blockers usually have a switch or LED to indicate whether write blocking functionality is in operation. A photograph of a multifunctional write-blocking device designed to be built directly into the examiner workstation (Tableau by Guidance Software) is shown in <a href="ch04.xhtml#ch4fig2">Figure 4-2</a>. It can protect SATA, SAS, IDE, FireWire, and USB drives.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_95"/><img src="../images/f04-02.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch4fig2"/><em>Figure 4-2: Multifunction drive bay write blocker</em></p>&#13;
<p class="indent">Write blockers can provide status information to the acquisition host system. An example is the tableau-parm tool (<em><a href="https://github.com/ecbftw/tableau-parm/">https://github.com/ecbftw/tableau-parm/</a></em>), which can query the Tableau hardware write blocker for information. You can use this open source tool to verify the write-blocking status of a disk attached with a Tableau write blocker. For example:</p>&#13;
<pre>$ <strong>sudo tableau-parm /dev/sdg</strong><br/>WARN: Requested 255 bytes but got 152 bytes)<br/>## Bridge Information ##<br/>chan_index: 0x00<br/>chan_type: SATA<br/>writes_permitted: FALSE<br/>declare_write_blocked: TRUE<br/>declare_write_errors: TRUE<br/>bridge_serial: 000ECC550035F055<br/>bridge_vendor: Tableau<br/>bridge_model: T35u-R2<br/>firmware_date: May 23 2014<br/>firmware_time: 09:43:37<br/><br/>## Drive Information ##<br/>drive_vendor: %00%00%00%00%00%00%00%00<br/>drive_model: INTEL SSDSA2CW300G3<br/>drive_serial: CVPR124600ET300EGN<br/>drive_revision: 4PC10302<br/><br/>## Drive HPA/DCO/Security Information ##<br/>security_in_use: FALSE<br/>security_support: TRUE<br/>hpa_in_use: FALSE<br/>hpa_support: TRUE<br/>dco_in_use: FALSE<br/>dco_support: TRUE<br/>drive_capacity: 586072368<br/>hpa_capacity: 586072368<br/>dco_capacity: 586072368</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_96"/>According to Tableau’s documentation, the <code>drive_vendor</code> field may not contain any information for some drives.<sup><a id="fn_21" href="footnote.xhtml#fn21">5</a></sup></p>&#13;
<p class="indent">During the final stages of editing this book, the first PCI Express write blockers appeared on the market. An example is shown here from Tableau. Attaching an NVME drive using a PCI Express write blocker produces the following dmesg output:</p>&#13;
<pre>[194238.882053] usb 2-6: new SuperSpeed USB device number 5 using xhci_hcd<br/>[194238.898642] usb 2-6: New USB device found, idVendor=13d7, idProduct=001e<br/>[194238.898650] usb 2-6: New USB device strings: Mfr=1, Product=2, SerialNumber=3<br/>[194238.898654] usb 2-6: Product: T356789u<br/>[194238.898658] usb 2-6: Manufacturer: Tableau<br/>[194238.898662] usb 2-6: SerialNumber: 0xecc3500671076<br/>[194238.899830] usb-storage 2-6:1.0: USB Mass Storage device detected<br/>[194238.901608] scsi host7: usb-storage 2-6:1.0<br/>[194239.902816] scsi 7:0:0:0: Direct-Access     NVMe     INTEL SSDPEDMW40 0174<br/>    PQ: 0 ANSI: 6<br/>[194239.903611] sd 7:0:0:0: Attached scsi generic sg2 type 0<br/>[194240.013810] sd 7:0:0:0: [sdc] 781422768 512-byte logical blocks: (400 GB/<br/>    373 GiB)<br/>[194240.123456] sd 7:0:0:0: [sdc] Write Protect is on<br/>[194240.123466] sd 7:0:0:0: [sdc] Mode Sense: 17 00 80 00<br/>[194240.233497] sd 7:0:0:0: [sdc] Write cache: disabled, read cache: enabled,<br/>    doesn't support DPO or FUA<br/>[194240.454298]  sdc: sdc1<br/>[194240.673411] sd 7:0:0:0: [sdc] Attached SCSI disk</pre>&#13;
<p class="indent">The write blocker operates as a USB3 bridge and makes the NVME drive available as a SCSI device. This particular write blocker supports PCI Express drives using both AHCI and NVME standards. The hardware interfaces supported are regular PCI Express slots (<a href="ch04.xhtml#ch4fig3">Figure 4-3</a>) and M.2 (<a href="ch04.xhtml#ch4fig4">Figure 4-4</a>). Standard adapters from mini-SAS to PCI Express or M.2 can be used to attach U.2 (SFF-8639) NVME drives. PCI write blockers with NVME support are also available from Wiebetech.</p>&#13;
<p class="indent">The primary advantage of hardware-based write blockers is their OS independence. They operate transparently and separately from the acquisition host, eliminating the need to maintain drivers or OS compatibility. This makes them ideal for use in a Linux acquisition environment.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_97"/><img src="../images/f04-03.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch4fig3"/><em>Figure 4-3: Write blocker dock for PCI Express slot drives</em></p>&#13;
<div class="image"><img src="../images/f04-04.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch4fig4"/><em>Figure 4-4: Multifunction write blocker and dock for PCI Express M.2 drives</em></p>&#13;
<p class="indent">Special thanks to Arina AG in Switzerland for providing the write blocker equipment used for test purposes in this book.</p>&#13;
<h4 class="h4" id="ch04lev2sec17"><em><strong>Software Write Blockers</strong></em></h4>&#13;
<p class="noindenta">Software write blockers have a somewhat controversial history. They’ve become increasingly difficult to develop and maintain with modern OSes. System updates by the OS vendor, configuration tweaks by the examiner, and additionally installed software all create a risk of disabling, overwriting, bypassing, or causing the failure of write-blocking functionality implemented in software.</p>&#13;
<p class="indent">Software write blockers are difficult to implement. Simply mounting a disk as read-only (<code>mount -o ro</code>) will <em>not</em> guarantee that the disk won’t be modified. The <em>read-only</em> property in this context refers to the filesystem, not the disk device. The kernel may still write to the disk for various reasons. Software write blocking must be implemented in the kernel, below the <span epub:type="pagebreak" id="page_98"/>virtual filesystem layer and even below the other device drivers that implement a particular drive interface (AHCI for example). Several low-level software write-blocking methods have been used under Linux but with limited success.</p>&#13;
<p class="indent">Tools such as hdparm and blockdev can set a disk to read-only by setting a kernel flag. For example:</p>&#13;
<pre># <strong>hdparm -r1 /dev/sdk</strong><br/><br/>/dev/sdk:<br/> setting readonly to 1 (on)<br/> readonly      =  1 (on)</pre>&#13;
<p class="indent">The same flag can be set with blockdev, like this:</p>&#13;
<pre># <strong>blockdev --setro /dev/sdk</strong></pre>&#13;
<p class="indent">The method of setting kernel flags is dependent on properly configuring udev to make newly attached drives read-only before any other process has a chance to modify them.</p>&#13;
<p class="indent">A kernel patch has also been written to specifically implement forensic write-blocking functionality. You’ll find more information about it at <em><a href="https://github.com/msuhanov/Linux-write-blocker/">https://github.com/msuhanov/Linux-write-blocker/</a></em>. Several forensic boot CDs use Maxim Suhanov’s write-blocking kernel patch. The following helper script manages software write blocking on the DEFT Linux forensic boot CD:</p>&#13;
<pre>% <strong>cat /usr/sbin/wrtblk</strong><br/>#!/bin/sh<br/><br/># Mark a specified block device as read-only<br/>[ $# -eq 1 ] || exit<br/>[ ! -z "$1" ] || exit<br/>bdev="$1"<br/>[ -b "/dev/$bdev" ] || exit<br/>[ ! -z $bdev##loop*$ ] || exit<br/>blockdev --setro "/dev/$bdev" || logger "wrtblk: blockdev --setro /dev/$bdev<br/>    failed!"<br/><br/># Mark a parent block device as read-only<br/>syspath=$(echo /sys/block/*/"$bdev")<br/>[ "$syspath" = "/sys/block/*/$bdev" ] &amp;&amp; exit<br/>dir=$syspath%/*$<br/>parent=$dir##*/$<br/>[ -b "/dev/$parent" ] || exit<br/>blockdev --setro "/dev/$parent" || logger "wrtblk: blockdev --setro /dev/$parent<br/>    failed!"</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_99"/>The patch is implemented in the kernel and is turned on (and off) using helper scripts. The helper scripts simply use the <code>blockdev</code> command to mark the device as read-only.</p>&#13;
<p class="indent">NIST CFTT has performed software write blocker tool tests, which you’ll find at <em><a href="http://www.cftt.nist.gov/software_write_block.htm">http://www.cftt.nist.gov/software_write_block.htm</a></em>.</p>&#13;
<p class="indent">Hardware write blockers are still the safest and recommended method of protecting storage media during forensic acquisition.</p>&#13;
<h4 class="h4" id="ch04lev2sec18"><em><strong>Linux Forensic Boot CDs</strong></em></h4>&#13;
<p class="noindenta">The need to perform incident response and triage in the field has led to the development of bootable Linux CDs that contain the required software to perform such tasks. These CDs can boot a subject PC and access the locally attached storage using various forensic tools. Forensic boot CDs are designed to write protect discovered storage in the event it needs to be forensically imaged. You can make an attached disk writable by using a command (like <code>wrtblk</code> shown in the previous example), which is useful in acquiring an image when you attach an external destination disk. Forensic boot CDs also have network functionality and enable remote analysis and acquisition.</p>&#13;
<p class="indentb">Forensic boot CDs are useful when:</p>&#13;
<p class="bull">• A PC is examined without opening it to remove a disk.</p>&#13;
<p class="bull">• A write blocker is not available.</p>&#13;
<p class="bull">• PCs need to be quickly checked during triage for a certain piece of evidence before deciding to image.</p>&#13;
<p class="bull">• Linux-based tools (Sleuth Kit, Foremost, and so on) are needed but not otherwise available.</p>&#13;
<p class="bull">• A forensic technician needs to remotely perform work via ssh.</p>&#13;
<p class="indenttb">Several popular forensic boot CDs that are currently maintained include:</p>&#13;
<p class="bull">• Kali Linux (formerly BackTrack), which is based on Debian: <em><a href="https://www.kali.org/">https://www.kali.org/</a></em></p>&#13;
<p class="bull">• Digital Evidence &amp; Forensics Toolkit (DEFT), which is based on Ubuntu Linux: <em><a href="http://www.deftlinux.net/">http://www.deftlinux.net/</a></em></p>&#13;
<p class="bull">• Pentoo, a forensic CD based on Gentoo Linux: <em><a href="http://pentoo.ch/">http://pentoo.ch/</a></em></p>&#13;
<p class="bull">• C.A.I.N.E, Computer Forensics Linux Live Distro, which is based on Ubuntu Linux: <em><a href="http://www.caine-live.net/">http://www.caine-live.net/</a></em></p>&#13;
<p class="indentt">Forensic boot CDs require a lot of work to maintain and test. Many other forensic boot CDs have been available in the past. Because of the changing landscape of forensic boot CDs, be sure to research and use the latest functional and maintained versions.</p>&#13;
<h4 class="h4" id="ch04lev2sec19"><span epub:type="pagebreak" id="page_100"/><em><strong>Media with Physical Read-Only Modes</strong></em></h4>&#13;
<p class="noindenta">Some storage media have a write-protect mechanism that can be useful in a forensic context. For example, most tapes have a sliding switch or tab that instructs the tape drive to treat them as read-only, as shown on the left of <a href="ch04.xhtml#ch4fig5">Figure 4-5</a>. On the LTO-5 tape (bottom left), a closed tab indicates it is write protected; on the DAT160 tape (top left), an open tab indicates it is write protected.</p>&#13;
<p class="indent">SD memory cards have a <em>lock</em> switch that write protects the memory card, as shown on the right of <a href="ch04.xhtml#ch4fig5">Figure 4-5</a>.</p>&#13;
<div class="image"><img src="../images/f04-05.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch4fig5"/><em>Figure 4-5: Write-protect tabs on tapes and SD cards</em></p>&#13;
<p class="indent">Older USB thumb drives may have a write-protect switch. Some very old IDE hard disks have a jumper that you can set to make the drive electronics treat the drive as read-only.</p>&#13;
<p class="indent">CD-ROMs, DVDs, and Blu-ray discs do not need a write blocker, because they are read-only by default. The simple act of accessing a rewritable disc will not make modifications to timestamps or other data on the disc; changes to these optical media must be explicitly burned to the disc.</p>&#13;
<h3 class="h3" id="ch04lev1sec05"><strong>Closing Thoughts</strong></h3>&#13;
<p class="noindent">In this chapter, you learned how to set up basic auditing, activity logging, and task management. I covered topics such as naming conventions and scalable directory structures, as well as various challenges with image sizes, drive capacity planning, and performance and environmental issues. Finally, this chapter discussed the crucial component of forensic write blocking. You are now ready to attach a subject drive to the acquisition host in preparation for executing the forensic acquisition process.</p>&#13;
</body></html>