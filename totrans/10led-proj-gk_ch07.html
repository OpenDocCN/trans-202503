<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en">
  <head>
    <title>Project 7: Starfield Light Effect Box by Adam Wolf</title>
    <link href="../styles/9781593278472.css" rel="stylesheet" type="text/css"/>
    <link href="../68851547a55f.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <div id="sbo-rt-content"><h2 class="h2" id="ch07"><span epub:type="pagebreak" id="page_132"/><span class="big">7</span><br/>Starfield Light Effect Box by Adam Wolf</h2>
<p class="ch-sub"><span epub:type="pagebreak" id="page_133"/>In this project, you’ll make a decorative display box with a starfield light effect.</p>
<div class="image"><img src="../images/f0133-01.jpg" alt="image"/></div>
<p class="noindent"><span epub:type="pagebreak" id="page_134"/>The starfield effect is one of the earliest computer effects demos: stars are rendered on a screen and blurred to make it look like you’re flying through them. Stars far away move slowly, and those close to you zoom by. Many people know of this effect from the Windows 3.1 screensaver, but it’s been around since at least the late ’70s. In this project, we’ll create a starfield demo using a 32 × 32 LED matrix, with a SmartMatrix SD Shield to act as intermediate hardware between the microcontroller and the LEDs. This shield microcontroller handles most of the complexity involved in driving all those LEDs.</p>
<p class="indent">I’ve mounted the matrix in a shadow box with a black diffuser. I call it a Bowman Box, after Dave Bowman from <em>2001: A Space Odyssey</em>.</p>
<h3 class="h3" id="lev93"><strong>GET THE PARTS</strong></h3>
<p class="noindent">I’ve done my best to make the code and explanation for this project easy to adapt to any LED matrix, but you’ll find this project easiest if you use the SmartMatrix SD Shield and a SmartMatrix SD Shield–compatible LED matrix.</p>
<h4 class="h4" id="lev94"><strong>Components</strong></h4>
<div class="note">
<p class="notet"><strong>NOTE</strong></p>
<p class="notep"><em>If you change the project to have more of the LEDs on at once, you’ll have to either find a switch rated for more current or plug the power supply into the board directly.</em></p>
</div>
<ul>
<li class="noindent">32 × 32 RGB LED matrix (Adafruit P/N 1484 or SparkFun P/N 12584; must be compatible with the SmartMatrix SD Shield that plugs directly into a Hub75 connector)</li>
<li class="noindent">5 V 4A+ wall power adapter (Adafruit P/N 1466; must have the standard 2.1 mm center-positive connector)</li>
<li class="noindent">SmartMatrix SD Shield (available from the manufacturer or Adafruit P/N 1902; v3 is the latest version as of this writing)</li>
<li class="noindent">Teensy 3.1 or 3.2 (Adafruit P/N 2756; this is a small, inexpensive, and really powerful microcontroller board)</li>
<li class="noindent">MicroUSB cable</li>
<li class="noindent">Inline power switch with 2.1 mm connectors (Adafruit P/N 1125 or SparkFun P/N 11705)</li>
<li class="noindent">Shadow box (8 × 8 inches)</li>
<li class="noindent"><span epub:type="pagebreak" id="page_135"/>Diffuser (a piece of translucent material that can help diffuse the light, filling in the gap between LEDs; I used a piece of thin black felt, but you could use tissue paper, plastic, or even something smeared on the glass)</li>
<li class="noindent">(Optional) Cardboard (to get everything to fit snugly in the shadow box)</li>
</ul>
<h4 class="h4" id="lev95"><strong>Tools</strong></h4>
<ul>
<li class="noindent">Soldering iron and solder</li>
<li class="noindent">Diagonal cutters</li>
<li class="noindent">Wire strippers</li>
<li class="noindent">Small screwdriver</li>
<li class="noindent">Scissors</li>
<li class="noindent">Handsaw, drill, or file</li>
<li class="noindent">Black marker</li>
</ul>
<h3 class="h3" id="lev96"><strong>BUILD IT</strong></h3>
<p class="noindent">First, you’ll assemble the SmartMatrix SD Shield according to the manufacturer’s instructions and connect it to the LED matrix. You’ll then need to sandwich the diffuser between the LED display and the shadow box glass. After checking that everything fits nicely into the shadow box, you’ll take the box’s back off again, cut a small notch for the power cord, upload the program, and reassemble everything.</p>
<div class="note">
<p class="notet"><strong>NOTE</strong></p>
<p class="notep"><em>If you need instructions on soldering, see the appendix.</em></p>
</div>
<ol>
<li class="noindent"><p class="list"><strong>Assemble the SmartMatrix SD Shield.</strong> Go to the manufacturer’s site at <em><a href="http://docs.pixelmatix.com/">http://docs.pixelmatix.com/</a></em> and navigate to the SmartMatrix Shield section. Find the SmartMatrix SD v3 section, and click <strong>Kit Assembly</strong> in the menu on the left. This should take you to your shield’s assembly instructions. Read and carefully follow the manufacturer’s instructions—this requires a lot of soldering—and then double-check your work.</p>
<p class="indent">With your shield finished, plug it into the LED panel, in the input connector, as shown in <a href="ch07.xhtml#ch07fig1">Figure 7-1</a>.</p>
<div class="image"><span epub:type="pagebreak" id="page_136"/><a id="ch07fig1"/><img src="../images/f0136-01.jpg" alt="image"/></div>
<p class="figcap"><strong>FIGURE 7-1:</strong> An assembled SmartMatrix SD Shield plugged into an LED display</p>
<p class="indent">The Smart Matrix SD Shield uses a Teensy 3.1 or 3.2 microcontroller board. We’ll program the Teensy in Arduino, which works on Windows, macOS, and Linux.</p></li>
<li class="noindent"><p class="list"><strong>Set up the Teensy.</strong> Download the latest version of the Arduino IDE from <em><a href="https://www.arduino.cc/">https://www.arduino.cc/</a></em>, install Teensyduino from <em><a href="https://www.pjrc.com/teensy/teensyduino.html">https://www.pjrc.com/teensy/teensyduino.html</a></em>, and then install the SmartMatrix3 library from the IDE’s Library Manager. Connect the Teensy to your computer with a microUSB cable and connect the display to power. Go to <strong>Tools</strong> <span class="ent">▸</span> <strong>Board</strong> and choose <strong>Teensy 3.2/3.1</strong>.</p></li>
<li class="noindent"><p class="list"><strong>Test the Teensy.</strong> Load the <em>FeatureDemo</em> example by going to <strong>File</strong> <span class="ent">▸</span> <strong>Examples</strong> <span class="ent">▸</span> <strong>SmartMatrix3</strong> <span class="ent">▸</span> <strong>FeatureDemo</strong>. Upload the sketch to the Teensy, and you should see the Teensyduino Uploader appear and send the sketch to the Teensy. If you’ve never used a Teensy before, you may notice that it looks different from the standard Arduino IDE, but the Teensy part all happens automatically so you don’t need to do anything extra.</p>
<p class="indent"><span epub:type="pagebreak" id="page_137"/>If you have everything working, you should see a demo play out on the Teensy that goes through all the different features of the SmartMatrix3 library. You’ll see different colors, moving shapes, and scrolling text. This indicates that the computer, the LED panel, the SmartMatrix SD Shield, and the Teensy are all working. Now let’s finish the enclosure.</p></li>
<li class="noindent"><p class="list"><strong>Cut the diffuser.</strong> Take the back off the shadow box and measure the inner dimensions. Use scissors to cut your diffuser material, as shown in <a href="ch07.xhtml#ch07fig2">Figure 7-2</a>. You can match the inner dimensions of your shadow box exactly, or you can cut them slightly bigger so you can glue the edges to the sides of the box.</p>
<div class="image"><a id="ch07fig2"/><img src="../images/f0137-01.jpg" alt="image"/></div>
<p class="figcap"><strong>FIGURE 7-2:</strong> Cutting the diffuser</p>
<p class="indent">If you’re a little off, it’s probably okay! The rest of the inside of the box will be black, so any gaps won’t be noticeable.</p></li>
<li class="noindent"><p class="list"><strong>Test-fit the display into the shadow box.</strong> Clean any smudges off the glass of the shadow box and then, with the glass side of the box facing down on a table, place the diffuser in the box and against the glass. Then place the display, LEDs down, on the diffuser. Screw the little magnetic screws into the corners of the LED panel, if you have them. Check to make sure that the back of the shadow box still fits on, as shown in <a href="ch07.xhtml#ch07fig3">Figure 7-3</a>.</p>
<p class="indent">If the fit is too tight, try removing any black velvety material on the back of the shadow box or taking the magnetic screws off the LED panel frame. If the fit is too loose, you can use some cardboard as a shim to keep everything in place.</p>
<div class="image"><span epub:type="pagebreak" id="page_138"/><a id="ch07fig3"/><img src="../images/f0138-01.jpg" alt="image"/></div>
<p class="figcap"><strong>FIGURE 7-3:</strong> Testing how everything fits in the shadow box</p></li>
<li class="noindent"><p class="list"><strong>Cut a notch in the back of the shadow box.</strong> Remove the back of the shadow box again. Plug the 2.1 mm inline switch power plug into the DC power connector of the SmartMatrix SD Shield. The cable should just reach outside of the box. Cut a small notch, about 3/4 inch deep by 1/4 inch wide, in the back of the shadow box to feed the power cord through, as shown in <a href="ch07.xhtml#ch07fig4">Figure 7-4</a>. I suggest you cut the notch in the middle of an edge or at a corner. You can make this notch with many different tools, like a handsaw, a drill, a file, or even needle-nose pliers.</p>
<div class="image"><a id="ch07fig4"/><img src="../images/f0138-02.jpg" alt="image"/></div>
<p class="figcap"><strong>FIGURE 7-4:</strong> The back of the shadow box with the notch cut out for the power cord</p>
<p class="indent">If your shadow box has a velvety backing, you’ll need to cut a slit in that, too, and be sure it aligns with the notch you cut in the back. Finally, touch up any scuff marks with a black marker.</p></li>
<li class="noindent"><p class="list"><span epub:type="pagebreak" id="page_139"/><strong>Assemble it.</strong> Now reattach the back of your shadow box. Everything should be nice and snug. If not, use some cardboard as shims and spacers. Any minor cosmetic issues will be easy to ignore once you get the stars zooming past. On that note, take the back off again so we can access the Teensy for programming!</p></li>
</ol>
<p class="indent">If you’d like to go directly to the next step, skip ahead to “<a href="ch07.xhtml#lev97">Code It</a>” on <a href="ch07.xhtml#page_140">page 140</a>. If you’re curious about how the starfield effect works, read on.</p>
<div class="sidebar">
<p class="sidebart"><strong>GENERATING THE STARFIELD EFFECT</strong></p>
<p class="spara">We need to create the effect of zooming through a bunch of stars. The stars that are close should be brighter and move faster than the stars that are far away. All of the stars should move radially out from the center.</p>
<p class="spara1">To make the starfield effect in software, we’ll create a list of stars and randomly distribute them as points in 3D space with a coordinate system. We’ll represent each point as three coordinate values, like (<em>x</em>, <em>y</em>, <em>z</em>), where <em>x</em> represents the horizontal axis, <em>y</em> represents the vertical axis, and <em>z</em> represents depth. You can imagine <em>z</em> as the distance from you—the higher the <em>z</em> value, the farther away the point will appear. Our <em>eye</em>, the default point in the 3D space, is at the origin, or (0, 0, 0).</p>
<p class="spara1">Once we’ve completed our list of randomly placed stars, we have to overcome the problem of drawing a point in 3D space on a 2D display. Imagine drawing a region of space as a four-sided pyramid with the top and bottom cut off. This is called a <em>view frustum</em> and is illustrated here.</p>
<div class="imagec"><img src="../images/f0139-01.jpg" alt="image"/></div>
<p class="spara1"><span epub:type="pagebreak" id="page_140"/>The yellow square represents our display, with one LED per unit in <em>x</em> and <em>y</em>. This means that a point at (0, 0, 0) is in the middle of the display, a point at (–8, –8, 0) is in the middle of the lower-left corner, and a point at (8, 8, 0) is in the middle of the top-right corner of the LED panel.</p>
<p class="spara1">We also need to account for the <em>z</em> distance. A point at (8, 8, 100) shouldn’t be drawn in the middle of the top-right corner of our LED panel. It should be closer to the middle of the display than the point (8, 8, 0), because it is farther away from the camera. In other words, the x- and y-coordinates need to move closer to the eye as the z-coordinate gets bigger.</p>
<p class="spara1">To translate from 3D coordinates to our 2D coordinates, we divide each of the x- and y-coordinates by <em>z</em>. Try thinking about the 2D coordinates as percentages of the total frame size at that particular depth (or <em>z</em>). Dividing the x- and y-coordinates by <em>z</em> gets us a 45-degree angle on our frustum edges, so that for every step in <em>z</em>, we can see an additional step in <em>x</em> and <em>y</em>. We can experiment with different factors, like dividing by double <em>z</em>, or dividing by half of <em>z</em>, and that changes the slope of the edges of our view frustum.</p>
<p class="spara1">In my Bowman Box, stars at any distance are drawn by a single LED, but the brightness of the LED is relative to the distance: the stars that are the farthest away from us are at the minimum brightness, and the stars that are at the front of the frustum in the very center are at the maximum brightness. To make it simpler in the program, we scale based only on the z-value.</p>
<p class="spara1">Phew! The programming is much shorter than the explanation! Now that we know how to draw the stars on our display, we need to move! We want to fly through the stars, but instead of moving the eye forward in <em>z</em>, we’re going to move all the stars toward the eye in <em>z</em>. It makes the programming easier. Once a star advances past our eye, we certainly can’t see it anymore, so we’ll recreate it back at the maximum distance away from us.</p>
</div>
<h3 class="h3" id="lev97"><strong>CODE IT</strong></h3>
<p class="noindent">If you want to skip past all the explanation of the code and how it works, you can simply download the code at <em><a href="https://nostarch.com/LEDHandbook/">https://nostarch.com/LEDHandbook/</a></em> and upload it to your project. The full code is shown in <a href="ch07.xhtml#ch07list1">Listing 7-1</a>.</p>
<p class="listing" id="ch07list1"><strong>LISTING 7-1:</strong> The starfield effect code</p>
<pre><span epub:type="pagebreak" id="page_141"/>  <span class="gray">/* StarfieldEffect.ino</span><br/>    <span class="gray">by Adam Wolf</span><br/><br/>    <span class="gray">Uses a SmartMatrix SD Shield, a 32 by 32 RGB LED display,</span><br/>    <span class="gray">and a Teensy to show a starfield effect.</span><br/>  <span class="gray">*/</span><br/><br/><span class="ent">➊</span> <span class="green">#include</span> &lt;SmartMatrix3.h&gt;<br/>  <span class="green">#define</span> COLOR_DEPTH 24<br/>  <span class="light-teal">const uint8_t</span> kMatrixWidth = 32;<br/>  <span class="light-teal">const uint8_t</span> kMatrixHeight = 32;<br/>  <span class="light-teal">const uint8_t</span> kRefreshDepth = 36;<br/>  <span class="light-teal">const uint8_t</span> kDmaBufferRows = 4;<br/>  <span class="light-teal">const uint8_t</span> kPanelType = SMARTMATRIX_HUB75_32ROW_MOD16SCAN;<br/>  <span class="light-teal">const uint8_t</span> kMatrixOptions = (SMARTMATRIX_OPTIONS_NONE);<br/>  <span class="light-teal">const uint8_t</span> kBackgroundLayerOptions =<br/>   (SM_BACKGROUND_OPTIONS_NONE);<br/>  <span class="light-teal">const uint8_t</span> kScrollingLayerOptions =<br/>   (SM_SCROLLING_OPTIONS_NONE);<br/>  <span class="light-teal">const uint8_t</span> kIndexedLayerOptions = (SM_INDEXED_OPTIONS_NONE);<br/>  SMARTMATRIX_ALLOCATE_BUFFERS(matrix, kMatrixWidth,<br/>   kMatrixHeight, kRefreshDepth, kDmaBufferRows, <br/>   kPanelType, kMatrixOptions);<br/>  SMARTMATRIX_ALLOCATE_BACKGROUND_LAYER(backgroundLayer,<br/>   kMatrixWidth, kMatrixHeight, COLOR_DEPTH, <br/>   kBackgroundLayerOptions);<br/>  SMARTMATRIX_ALLOCATE_SCROLLING_LAYER(scrollingLayer,<br/>   kMatrixWidth, kMatrixHeight, COLOR_DEPTH, <br/>   kScrollingLayerOptions);<br/>  SMARTMATRIX_ALLOCATE_INDEXED_LAYER(indexedLayer, kMatrixWidth,<br/>   kMatrixHeight, COLOR_DEPTH, kIndexedLayerOptions);<br/><br/>  <span class="light-teal">struct</span> Star {<br/>    <span class="light-teal">int16_t</span> x;<br/>    <span class="light-teal">int16_t</span> y;<br/>    <span class="light-teal">float</span> z;<br/>  };<br/><br/>  <span class="green">#define</span> NUM_STARS 32<br/>  <span class="light-teal">struct</span> Star stars[NUM_STARS];<br/><br/>  <span class="light-teal">const int</span> X_RANGE = 400;<br/>  <span class="light-teal">const int</span> Y_RANGE = 400;<br/>  <span class="light-teal">const int</span> HALF_X_RANGE = X_RANGE / 2;<br/>  <span class="light-teal">const int</span> HALF_Y_RANGE = Y_RANGE / 2;<br/>  <span class="light-teal">const int</span> MAX_Z = 16;<br/><br/>  <span class="light-teal">const uint8_t</span> SCREEN_WIDTH = 32;<br/>  <span class="light-teal">const uint8_t</span> SCREEN_HEIGHT = 32;<br/>  <span epub:type="pagebreak" id="page_142"/><span class="light-teal">const uint8_t</span> HALF_SCREEN_WIDTH = SCREEN_WIDTH / 2;<br/>  <span class="light-teal">const uint8_t</span> HALF_SCREEN_HEIGHT = SCREEN_HEIGHT / 2;<br/><br/>  <span class="light-teal">const float</span> SPEED = 0.1;<br/><br/><span class="ent">➋</span> <span class="light-teal">void</span> randomizeStarPosition(<span class="light-teal">struct</span> Star* s) {<br/>    s-&gt;x = <span class="orange">random</span>(-HALF_X_RANGE, HALF_X_RANGE);<br/>    s-&gt;y = <span class="orange">random</span>(-HALF_Y_RANGE, HALF_Y_RANGE);<br/>    s-&gt;z = MAX_Z; <span class="gray">// Put the star in the back.</span><br/>  }<br/><br/>  <span class="light-teal">void</span> drawStar(<span class="light-teal">struct</span> Star* s) {<br/>    <span class="light-teal">uint8_t</span> display_x = (<span class="light-teal">int</span>) (s-&gt;x / s-&gt;z);<br/>    <span class="light-teal">uint8_t</span> display_y = (<span class="light-teal">int</span>) (s-&gt;y / s-&gt;z);<br/><br/><span class="ent">➌</span>  display_x = display_x + HALF_SCREEN_WIDTH;<br/>    display_y = display_y + HALF_SCREEN_HEIGHT;<br/><br/>    <span class="gray">// Let's check if our calculated point should be displayed.</span><br/>    <span class="green">if</span> (display_x &gt;= 0 &amp;&amp;<br/>      display_y &gt;= 0 &amp;&amp; <br/>      display_x &lt; SCREEN_WIDTH &amp;&amp;<br/>      display_y &lt; SCREEN_HEIGHT) {<br/>      <span class="light-teal">uint8_t</span> brightness = <span class="orange">map</span>(s-&gt;z, 0, MAX_Z, 255, 0);<br/>      drawPoint(display_x, display_y, brightness); <span class="gray">// It fits,</span><br/>    <span class="gray">                                               // so draw it!</span><br/>    } <span class="green">else</span> {<br/>      randomizeStarPosition(s);  <span class="gray">// It does not fit,</span><br/>    <span class="gray">                             // so make a new star.</span><br/>    }<br/>  }<br/><br/>  <span class="light-teal">void</span> advanceStar(<span class="light-teal">struct</span> Star* s) {<br/>    s-&gt;z -= SPEED;<br/><br/>    <span class="green">if</span> (s-&gt;z &lt;= 0) {<br/>      randomizeStarPosition(s);  <span class="gray">// If the star has passed us,</span><br/>    <span class="gray">                             // make a new one.</span><br/>    }<br/>  }<br/><br/>  <span class="light-teal">void</span> <span class="green">setup</span>() {<br/><span class="ent">➍</span>   <span class="orange">randomSeed</span>(<span class="orange">analogRead</span>(A1));<br/><br/>    <span class="green">for</span> (<span class="light-teal">int</span> i = 0; i &lt; NUM_STARS; i++) {<br/>      Star* current_star = &amp;stars[i];<br/>      randomizeStarPosition(current_star);<br/><span class="ent">➎</span>    current_star-&gt;z = <span class="orange">random</span>(0, MAX_Z);<br/>    }<br/>  <span epub:type="pagebreak" id="page_143"/><br/>    setupDisplay();<br/>  }<br/><br/>  <span class="light-teal">void</span> <span class="green">loop</span>() {<br/>    clearDisplay();<br/><br/>  <span class="green">  for</span> (<span class="light-teal">int</span> i = 0; i &lt; NUM_STARS; i++) {<br/>      drawStar(&amp;stars[i]);<br/>    }<br/>    paintDisplay();<br/>    <span class="green">for</span> (<span class="light-teal">int</span> i = 0; i &lt; NUM_STARS; i++) {<br/>      advanceStar(&amp;stars[i]);<br/>    }<br/>  }<br/><br/>  <span class="light-teal">uint16_t</span> distanceToStar(<span class="light-teal">struct</span> Star* s) {      <span class="gray">// distance</span><br/>    <span class="green">return</span> <span class="orange">sqrt</span>(<span class="orange">sq</span>(s-&gt;x) + <span class="orange">sq</span>(s-&gt;y) + <span class="orange">sq</span>(s-&gt;z)); <span class="gray">// from (0, 0, 0)</span><br/>  }<br/><br/>  <span class="light-teal">void</span> clearDisplay() {<br/>    backgroundLayer.fillScreen({0x00, 0x00, 0x00});<br/>  }<br/><br/>  <span class="light-teal">void</span> drawPoint(<span class="light-teal">uint8_t</span> x, <span class="light-teal">uint8_t</span> y, <span class="light-teal">uint8_t</span> brightness) {<br/>    <span class="gray">// Note this doesn't actually show it on the display.</span><br/>    backgroundLayer.drawPixel(x, y, <br/>     {brightness, brightness, brightness});<br/>  }<br/><br/>  <span class="light-teal">void</span> paintDisplay() {<br/>    <span class="gray">// Send the image we've built up to the screen.</span><br/>    backgroundLayer.swapBuffers(<span class="light-teal">false</span>);<br/>  }<br/><br/><span class="ent">➏</span> <span class="light-teal">void</span> setupDisplay() {<br/>    matrix.addLayer(&amp;backgroundLayer);<br/>    matrix.addLayer(&amp;scrollingLayer);<br/>    matrix.addLayer(&amp;indexedLayer);<br/>    matrix.<span class="orange">begin</span>();<br/><br/>    backgroundLayer.enableColorCorrection(<span class="light-teal">true</span>);<br/>  }</pre>
<p class="indent"><span epub:type="pagebreak" id="page_144"/>As you’re reading this sketch, there are a few things to notice. Arduino sketches run the <code>setup()</code> function first, and then repeatedly run the <code>loop()</code> function.</p>
<p class="indent">The blocks of code at <span class="ent">➊</span> and <span class="ent">➏</span> are taken directly from the SmartMatrix examples that come with the IDE, and are used to set up the SmartMatrix library.</p>
<p class="indent">We’ve used a <em>struct</em>, which is a grouping of variables to store some of the information in our sketch. Structs can make it easier to see the intent of your code by grouping related information together. We make a bunch of star structs at the beginning of the program. When a star has advanced behind our eye or outside our viewing range, we randomize that star’s coordinates and then set it far away from us so we can encounter it again <span class="ent">➋</span>. This lets us reuse the structs rather than needing an infinite quantity.</p>
<p class="indent">We want the origin of the stars to be in the middle of the display, but the SmartMatrix library sets the origin at the bottom-left corner, so next we adjust for that when we display the stars <span class="ent">➌</span>.</p>
<p class="indent">We also need a random-number generator to place the stars in random positions. The Arduino doesn’t have a real random-number generator, so we initialize the system by reading a disconnected pin at <span class="ent">➍</span> to get different pseudorandom numbers each time. Reading a disconnected pin is not a very good “random seed,” so if you run it multiple times you may see it start up the same way. There are ways to make this more random, but we’ve kept it simple for clarity.</p>
<p class="indent">Because normally new stars show up only at the back, when we first initialize the position of the stars, we scatter them throughout the z-axis <span class="ent">➎</span>.</p>
<p class="indent">Make sure you’ve connected the power supply to the power switch, and then turn the switch on. Upload the code to your Teensy, make sure everything uploaded properly, and reattach the back on your shadow box.</p>
<h3 class="h3" id="lev98"><strong>SUMMARY</strong></h3>
<p class="noindent">Congratulations! You should now have a beautiful LED matrix mounted in a nice box. You can improve and expand this project in many ways. But remember that in our project, the majority of the LEDs are off at any time. If you change the project and turn a lot more LEDs on at the same time, you’ll need to be careful with power. The inline switch is not rated to carry enough current to <span epub:type="pagebreak" id="page_145"/>light the whole screen on full brightness, but you can remove it and plug the power supply into the board directly.</p>
<p class="indent">As a further upgrade, I’ve considered adding an accelerometer so I can steer by moving the frame, changing the angle and the speed as I fly through the stars. I might even add colored stars—not bright rainbow ones, but slightly red and slightly blue stars, to represent planets and nebulas. The sky’s the limit! Try a few things out and see which effect suits you best.</p>
</div>
  </body>
</html>
