<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="backmatter" aria-labelledby="next-steps">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_671" aria-label="671"/>&#13;
<hgroup>&#13;
&#13;
<h1 class="BMH" id="next-steps"><samp class="SANS_Dogma_OT_Bold_B_11">NEXT STEPS</samp></h1>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener-img.jpg" alt="" width="407" height="405"/></figure>&#13;
<p class="ChapterIntro">The world of programming languages is wide, and there’s a lot more for you to explore. Extending your compiler on your own is a great way to keep learning about the topics you’re most interested in.</p>&#13;
<p class="TX">I’ll leave you with a few ideas to get you started.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h2 class="H1" id="sec1"><span id="h1-194"/><samp class="SANS_Futura_Std_Bold_B_11">Add Some Missing Features</samp></h2>&#13;
<p class="TNI">The most obvious next step is to implement the major parts of C that this book didn’t cover. If you already have a list of features you’re particularly excited to add, start with those. Then, if you want to keep going, pick a real-world C program—think something small, not the Linux kernel—and build out your compiler until it can compile that program successfully. You can choose another program and repeat this process until you’re satisfied with how much of the language you’ve implemented. Make sure to add new language features one at a time, testing each one thoroughly before moving on to the next one.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_672" aria-label="672"/>&#13;
<h2 class="H1" id="sec2"><span id="h1-195"/><samp class="SANS_Futura_Std_Bold_B_11">Handle Undefined Behavior Safely</samp></h2>&#13;
<p class="TNI">We’ve seen that C compilers can deal with undefined behavior however they like. But just because you <i>can</i> do something doesn’t mean you <i>should</i>. There are huge benefits to dealing with undefined behavior in a clean, predictable way: it makes C programs more secure, easier to debug, and less terrifying in general. For example, you could guarantee that signed integer overflow always wraps around (this is what the <samp class="SANS_TheSansMonoCd_W5Regular_11">-fwrapv</samp> compiler option does). Or you could have the program raise an error and exit when it encounters undefined behavior; Clang and GCC both have a feature called UndefinedBehaviorSanitizer that supports this sort of error handling (<i><a href="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html">https://<wbr/>clang<wbr/>.llvm<wbr/>.org<wbr/>/docs<wbr/>/UndefinedBehaviorSanitizer<wbr/>.html</a></i>).</p>&#13;
<p class="TX">Think about a few examples of undefined behavior that we discussed in this book. How do you think your compiler should handle them? How would that impact any optimizations you’ve implemented? Some types of undefined behavior are tricky to detect, but others aren’t too difficult to deal with; choose one that seems manageable and see if you can handle it cleanly.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h2 class="H1" id="sec3"><span id="h1-196"/><samp class="SANS_Futura_Std_Bold_B_11">Write More TACKY Optimizations</samp></h2>&#13;
<p class="TNI"><span class="Xref-1"><a href="chapter19.xhtml">Chapter 19</a></span> covered just a few of the IR optimizations you’d find in a production compiler. If you like, you can implement more on your own. Do some research on common compiler optimizations and pick the ones that sound most interesting. If you go this route, you may want to convert your TACKY code into <i>static single assignment (SSA) form</i>, where every variable is defined exactly once. SSA form is widely used in real-world compilers, including Clang and GCC, because it makes many optimizations easier to implement.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h2 class="H1" id="sec4"><span id="h1-197"/><samp class="SANS_Futura_Std_Bold_B_11">Support Another Target Architecture</samp></h2>&#13;
<p class="TNI">Most production compilers have several different backends to support different target architectures.</p>&#13;
<p class="TX">You can use the same strategy, converting TACKY into different assembly code depending on which system you’re targeting. If you use a Windows or ARM system and needed a virtualization or emulation layer to complete this project, a new backend would let you compile code that runs natively on your machine.</p>&#13;
<p class="TX">If you add support for Windows, you’ll be able to reuse most of your existing code generation pass. Only the ABI will be different. Adding an ARM backend is a more ambitious project; you’ll need to learn a completely new instruction set.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_673" aria-label="673"/>&#13;
<h2 class="H1" id="sec5"><span id="h1-198"/><samp class="SANS_Futura_Std_Bold_B_11">Contribute to an Open Source Programming Language Project</samp></h2>&#13;
<p class="TNI">Improving your own compiler is a great way to learn, but consider branching out and working on other projects too. Many widely used compilers are open source and welcome new contributors. The same goes for a whole range of related projects, like interpreters, linters, and static analysis tools. Pick one that you like, and find out how to get involved. This is a great way to put your new skills to work and maybe even make your favorite programming language a little faster, safer, more usable, or easier to learn.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h2 class="H1" id="sec6"><span id="h1-199"/><samp class="SANS_Futura_Std_Bold_B_11">That’s a Wrap!</samp></h2>&#13;
<p class="TNI">I hope this book has laid the foundation for you to keep building compilers and programming languages. I also hope it’s changed your perspective on the programming languages you use day to day. You’ll now be better able to appreciate the care, effort, and ingenuity that went into creating those languages, and when things go wrong, you won’t be afraid to dig into the language internals to figure out what’s really happening. Compilers will stop seeming like magic and start to look like something much more interesting: ordinary software.</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>