<html><head></head><body><div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="69" id="Page_69"/>4</span><br/>
<span class="ChapterTitle">Low-Level Bit Manipulation</span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="190" height="190"/>
</figure>
<p class="ChapterIntro">This chapter discusses some bit manipulation techniques for WebAssembly applications, which we’ll apply to projects in later chapters to improve application performance. This topic can be challenging for readers not familiar with low-level programming, so if working with binary data isn’t in your interest, you can continue on to the next chapter and simply refer back to this one as needed.  </p>
<p>Before exploring bit manipulation techniques, we’ll go over a few essential topics, which include the three different numeric bases—decimal, hexadecimal, and binary; the details of integer and floating-point arithmetic; and 2s complement as well as big-endian and little-endian byte order. Additionally, we’ll examine high-order and low-order bits, bit masking, bit shifting, and bit rotation.</p>
<p>WebAssembly allows you to get as close to the metal as possible from within a web browser. If you want to write WebAssembly that executes at lightning speed, understanding how to manipulate your data at the level <span epub:type="pagebreak" title="70" id="Page_70"/>of bits is very useful. Bit manipulation is also essential to comprehend the data types WebAssembly works with, how they perform, and their limitations. WAT can manipulate data at the level of bits in a way that’s similar to assembly languages. Low-level coding is a tricky subject, and if you’re not already familiar with some of the concepts in this chapter, you might not grasp them all immediately. The good news is you don’t need to know all of these low-level concepts to work with WebAssembly, but understanding low-level WebAssembly can help you write fast, high-performance code for the web. Many times, code a compiler optimizes will generate code that performs bit manipulation, so knowledge of how these bit manipulation operations work is also important when you’re disassembling a WebAssembly binary to WAT code.</p>
<h2 id="h1-501737c04-0001">Binary, Decimal, and Hexadecimal</h2>
<p class="BodyFirst">The <em>hexadecimal system</em> is a common numbering system in computer programming that uses base-16 instead of the base-10 decimal numbering system you’ve been using since you were two years old. Computer programmers work with hexadecimal (hex) because computers natively use binary, and hex more cleanly translates into binary than decimal. You won’t learn how to convert from decimal to hex manually, because I’ll assume you’re either familiar with how to do it or have access to a calculator; most calculator apps offer a programmer mode that will do this conversion for you, like the one shown in <a href="#figure4-1" id="figureanchor4-1">Figure 4-1</a>.</p>
<figure>
<img src="Images/f04001.png" alt="f04001" width="349" height="508"/>
<figcaption><p><a id="figure4-1">Figure 4-1</a>: Microsoft Windows Calculator app in Programmer mode</p></figcaption></figure>
<p><span epub:type="pagebreak" title="71" id="Page_71"/>I also provide a simple decimal to hex conversion tool at <a href="https://wasmbook.com/hex" class="LinkURL">https://wasmbook.com/hex</a>, as well as an online calculator written in WAT at <a href="https://wasmbook.com/calculator.html" class="LinkURL">https://wasmbook.com/calculator.html</a>. Keep in mind that if you want to embed numeric data into a string in WAT, you need to use two-digit hex numbers, not decimals.</p>
<h2 id="h1-501737c04-0002">Integers and Floating-Point Arithmetic</h2>
<p class="BodyFirst">Before discussing how we can use bit manipulation on types, we need to discuss the details of the types that WebAssembly supports. The two primary data types in WebAssembly are integers and floating-point numbers. These types are assigned to all local and global variables when they’re declared, and you should use them for all parameters in function declarations. Integers represent whole numbers and can represent negative as well as positive numbers. However, using negative integer numbers requires a little more effort than negative floating-point numbers.</p>
<p>You can store integers and floating-point numbers in variables and in linear memory. If you’re familiar with JavaScript, linear memory is like a typed, unsigned-integer array. We’ll discuss linear memory more in <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	If you’re familiar with low-level assembly languages, you can think of linear memory as similar to a memory heap. If you’re not familiar with low-level languages, just ignore this note.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>In this section, we’ll look at how integer and floating-point variables work, the different types of floating-point and integer variables, and how to do some basic binary manipulation on them. Let’s first briefly discuss the four primary data types that WebAssembly supports. There are two integer data types (<code>i32</code> and <code>i64</code>) as well as two floating-point data types (<code>f32</code> and <code>f64</code>). </p>
<h3 id="h2-501737c04-0001">Integers</h3>
<p class="BodyFirst">Integer arithmetic is usually faster than floating-point arithmetic for most math operations. WebAssembly currently supports 32-bit and 64-bit integers but, unfortunately, cannot share 64-bit integers with JavaScript as easily as the other data types.</p>
<h4 id="h3-501737c04-0001">i32 (32-Bit Integers)</h4>
<p class="BodyFirst">The <code>i32</code> data type is fast, small, and easily moved between WebAssembly and JavaScript. It can represent between 0 and 4,294,967,295 as unsigned data and between –2,147,483,648 to 2,147,483,647 for signed integers. If you’re dealing with numbers that you know will be less than a billion in value and you don’t need fractional numbers, using <code>i32</code> is a great choice. Working with signed or unsigned values has more to do with the functions you perform <span epub:type="pagebreak" title="72" id="Page_72"/>on the data rather than the data in the variable. The <code>i32</code> data type represents negative numbers using 2s complement.</p>
<h4 id="h3-501737c04-0002">2s Complement</h4>
<p class="BodyFirst">The 2s complement is a widely used technique for representing negative numbers in a binary format. Computers only work in binary so only have memory with 1s and 0s. Binary can be translated into decimal fairly easily, but it’s less obvious how to represent a negative number with only 1s and 0s. It’s important to note that floating-point numbers have a dedicated sign bit and therefore don’t use 2s complement. </p>
<p>To understand how 2s complement works, let’s digress into a metaphorical comparison. Imagine you have a push button tally counter and each time you press a button, it advances a little number dial by one (<a href="#figure4-2" id="figureanchor4-2">Figure 4-2</a>). This particular counter only has a single decimal digit display, so it starts at 0 and counts to 9, but when you click it a tenth time, it rolls back to 0. From your counter’s perspective, adding 10 is the equivalent of adding 0, because your counter ends up in the same location as it started. Apropos of that, pressing the button 9 times is functionally the same as subtracting 1 for all numbers except 0.</p>
<figure>
<img src="Images/f04002.png" alt="f04002" width="675" height="326"/>
<figcaption><p><a id="figure4-2">Figure 4-2</a>: Nine rolls over to 0 when 1 is added.</p></figcaption></figure>
<p>Using the high-value numbers as negatives is only useful if you know that your numbers will be in a range that doesn’t include the chosen negative numbers. If you declare that 9 is equivalent to –1, but you need to count up to 9 with your counter, this number system won’t work. The rolling-over system is the reason that a signed 8-bit integer supports numbers from –128 to 127. The unsigned 8-bit encoding of the number 255 (eight 1s) is the same as the signed 8-bit representation of –1 because adding 255 to any number causes the bits to roll over like an odometer and subtract one. The largest numbers become negative because they result in the bits rolling over. The code that performs a 2s complement conversion <span epub:type="pagebreak" title="73" id="Page_73"/>on binary digits uses a binary XOR to flip all of the bits and then adds the number 1 to the result, which results in the negative of the number. You’ll see the code to this function when we look at XOR and bit flipping later in this chapter.</p>
<h4 id="h3-501737c04-0003">i64 (64-Bit Integers)</h4>
<p class="BodyFirst">The <code>i64</code> data type can represent positive integer numbers between 0 and 18,446,744,073,709,551,615 for unsigned integers and between –9,223,372,036,854,775,808 and 9,223,372,036,854,775,807 for signed integers. The <code>i64</code> data type in WAT doesn’t specify whether it’s signed or unsigned when the variable is declared. Instead, WAT has to choose operations to perform on that data based on whether the user wants to treat the number as signed or unsigned. Not all operations require you to make that choice: for example, <code>i64.add</code>, <code>i64.sub</code>, and <code>i64.mul</code> all work the same whether the integers are signed or not. In contrast are the division functions, such as <code>i64.div_s</code> and <code>i64.div_u</code>. The division operation must treat the numbers differently if they’re signed or unsigned and so must have the <code>_s</code> and <code>_u</code> suffix appended to the different versions of the operation. </p>
<p>As mentioned earlier, one problem with <code>i64</code> data types is that you cannot directly move 64-bit integers back and forth between WebAssembly and JavaScript. JavaScript only uses 64-bit floating-point numbers, but 64-bit floats can accommodate 32-bit integers and 32-bit floating-point numbers. The bottom line is that transferring 64-bit integers to the JavaScript portion of your app can be a pain.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	At the time of this writing, WebAssembly support for JavaScript BigInt objects is in the final stages of development. When support is complete, it will be easier to pass 64-bit integers into JavaScript from WebAssembly and vice versa.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-501737c04-0002">Floating-Point Numbers</h3>
<p class="BodyFirst">A floating-point number contains three parts in binary: a sign bit, followed by a series of bits to represent the exponent, and then the bits that represent the significant digits (sometimes called the <em>mantissa</em> or <em>significand</em>). Remember, there is no decimal point in binary; computer scientists had to invent a system for representing decimal points inside a binary number. The sign bit indicates whether the number is positive or negative. The exponent signifies how many positions to move a decimal point (left or right), and the significant digits are simply the numbers for your floating-point number. Let’s look at how you could create floating-point numbers using base 10 by first using the exponent to raise a number: if you take a number like 345, and multiply it by 10 raised to a power of 2, it appends two zeros to the end of your number, as shown in <a href="#figure4-3" id="figureanchor4-3">Figure 4-3</a>. This is effectively moving the decimal place two positions to the right.</p>
<span epub:type="pagebreak" title="74" id="Page_74"/><figure>
<img src="Images/f04003.png" alt="f04003" width="675" height="640"/>
<figcaption><p><a id="figure4-3">Figure 4-3</a>: Shift the decimal point right with a positive exponent.</p></figcaption></figure>
<p>Using only base 10 numbers, you would say that you have an exponent of 2 followed by 3 decimal digits, so 2345 would be the number 34,500, or 345 × 10<sup>2</sup> depicted in <a href="#figure4-4" id="figureanchor4-4">Figure 4-4</a>. </p>
<figure>
<img src="Images/f04004.png" alt="f04004" width="518" height="345"/>
<figcaption><p><a id="figure4-4">Figure 4-4</a>: Using a decimal exponent</p></figcaption></figure>
<p><span epub:type="pagebreak" title="75" id="Page_75"/>To get a fractional value, we need an exponent that is negative rather than positive, as shown in <a href="#figure4-5" id="figureanchor4-5">Figure 4-5</a>: a negative exponent moves the decimal point to the left.</p>
<figure>
<img src="Images/f04005.png" alt="f04005" width="675" height="640"/>
<figcaption><p><a id="figure4-5">Figure 4-5</a>: Shift the decimal point left with a negative exponent.</p></figcaption></figure>
<p>An exponent of negative 2 turns 345 into 3.45, resulting in a fractional value. Notice the problem with this system: so far we have no method for representing the negative nature of the first exponent bit. We said we could use 2345 to represent 345 × 10<sup>2</sup>, but we didn’t represent the minus sign. We can choose from one of two approaches: 2s complement and biased exponent. First, we could use a method like 2s complement and assign the higher digit values negative numbers, so 8345 could represent 345 × 10<sup>–2</sup> because 10 – 2 = 8. But this isn’t the method the designers of floating-point numbers chose. Instead, they use a <em>biased exponent</em> where they simply subtract a particular chosen value from the exponent to give us the negative exponent. For example, if we decide to always subtract 5 from our exponent digit, 3345 would represent 345 × 10<sup>–2</sup> because 3 – 5 = –2.</p>
<p>Real floating-point numbers are binary, not decimal, but the basic principles are the same. In binary floating-point numbers, the most significant bit is a sign bit, which is 0 if the number is positive and 1 if it’s negative. The eight bits that follow the sign bit represent the exponent. The mantissa <span epub:type="pagebreak" title="76" id="Page_76"/>represents a fractional number value between one and two. The leftmost bit represents a value of 0.5, followed by 0.25, 0.125, 0.0625, and so on, halving each time. Because the minimum value of the mantissa is 1, the actual value of the mantissa is always one greater than the sum of all these fraction bits. The layout of these bits is shown in <a href="#figure4-6" id="figureanchor4-6">Figure 4-6</a>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	The exponent portion of a floating-point number doesn’t use 2s complement, as integer numbers do. Instead, 127 is subtracted from the unsigned value in these eight bits to give the real exponent. This is also known as a <em>biased exponent</em>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<figure>
<img src="Images/f04006.png" alt="f04006" width="851" height="209"/>
<figcaption><p><a id="figure4-6">Figure 4-6</a>: 32-bit floating-point bits</p></figcaption></figure>
<p>The fact that the mantissa has a minimum value of 1 creates a problem for the number 0. Raising a non-zero value to any power can never result in a value of 0. To compensate for this, the exponent has two special values that allow for the representation of 0 and infinite values in the floating-point number. If all the bits in the exponent and mantissa are 0, then the number represented is 0, even though 0<sup>0</sup> is 1. Interestingly, floating-point numbers can represent 0 and –0 depending on the value in the sign bit. Infinity and –Infinity are values that have all of the exponent bits set to 1 and all of the mantissa bits set to 0. If the mantissa bits aren’t 0, the floating-point is a NaN (not a number). </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	If you want to see what floating-point numbers look like in binary, I have a simple web app that allows you to enter binary values in the sign, mantissa, and exponent bits to see the floating-point value that results. You can also enter a floating-point value to see the bits that are set. You can find the app at <a href="https://wasmbook.com/binary_float.html" class="LinkURL">https://wasmbook.com/binary_float.html</a>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h4 id="h3-501737c04-0004">Subnormal Numbers</h4>
<p class="BodyFirst"><em>Subnormal numbers</em> (sometimes called <em>denormalized numbers</em>) are another floating-point edge case in the IEEE-754 specification for floating-point numbers. Subnormal numbers are an edge case where the exponent bits are all 0. In the situation in which all the exponent bits are 0, the mantissa value no longer adds 1 to the value represented. This allows for even smaller decimal point values. We won’t use subnormal numbers in this book, but you should at least be aware of their existence.</p>
<h4 id="h3-501737c04-0005"><span epub:type="pagebreak" title="77" id="Page_77"/>f64/number</h4>
<p class="BodyFirst">The <code>f64</code> data type is a double-precision 64-bit floating-point number. An <code>f64</code> has 52 bits that represent the significant digits, an 11-bit exponent, and a sign bit. This data type allows for high precision but on most hardware executes more slowly than integers or smaller floating-point numbers. One of its benefits is that it’s the same data type JavaScript uses for all of its numbers, making it a convenient data type for numbers that must be moved back and forth between JavaScript and WebAssembly.</p>
<h4 id="h3-501737c04-0006">f32</h4>
<p class="BodyFirst">The <code>f32</code> data type is smaller and faster than <code>f64</code> but has far less precision, giving you fewer significant digits to work with. The <code>f64</code> data type has roughly 16 decimal significant digits for you to play with where an <code>f32</code> has only about seven. Because binary digits represent the significand, it doesn’t line up perfectly with decimal digits. The number of significant decimal digits is only an approximation, but it does give you a sense of each type’s limitations.</p>
<h2 id="h1-501737c04-0003">High- and Low-Order Bits</h2>
<p class="BodyFirst">In this section, we’ll look at bit significance. The low-order bit is the least significant bit of a binary number; significance simply means <em>representing the largest value</em>. In <a href="#figure4-7" id="figureanchor4-7">Figure 4-7</a>, in the number 128, the digit 1 is the most significant digit and 8 is the least significant.</p>
<figure>
<img src="Images/f04007.png" alt="f04007" width="675" height="461"/>
<figcaption><p><a id="figure4-7">Figure 4-7</a>: Most significant and least significant digits</p></figcaption></figure>
<p><span epub:type="pagebreak" title="78" id="Page_78"/>The digit representing the largest numeric value is the most significant. Here, 1 is the most significant digit because it’s in the 100th place, and there are no digits representing numbers in a higher position. The sad little 8 in the illustration is the least significant digit because it represents the 1s place.</p>
<p>Binary numbers also have higher-order digits. On a computer, one byte is always eight binary digits; even if the number is 00000001, the left seven binary digits are still in the byte. For example, the number 37 is 100101 in binary, but in computer memory, the value in the byte is 00100101. The most significant bit (high-order bit) in this byte is the leftmost 0, as shown in <a href="#figure4-8" id="figureanchor4-8">Figure 4-8</a>.</p>
<figure>
<img src="Images/f04008.png" alt="f04008" width="675" height="321"/>
<figcaption><p><a id="figure4-8">Figure 4-8</a>: High-order and low-order bit</p></figcaption></figure>
<p>The low-order bit in this byte is the 1 on the far right, and the high-order bit is the 0 on the far left.</p>
<p>Looking at just the high-order and low-order bits of a variable can reveal some information about a byte. The low-order bit in an integer indicates whether that integer has an even (0) or odd (1) value. The high-order bit of a signed integer determines whether that number is positive (0) or negative (1). </p>
<h2 id="h1-501737c04-0004">Bit Operations</h2>
<p class="BodyFirst">WebAssembly offers data manipulation at a low level of abstraction. If you’re willing to put in the work, you can frequently provide better code performance by manipulating data at the level of bits. Understanding how these operations work can also be useful when you’re trying to improve your code’s performance, even in high-level languages. We’ll use many of the operations in this chapter in applications we write later in the book, so refer back to this chapter as needed. These operations are very general purpose, so it’s difficult to give an example of when we would use them. However, as situations arise, it will be obvious which operation is suitable. </p>
<h3 id="h2-501737c04-0003"><span epub:type="pagebreak" title="79" id="Page_79"/>Shifting and Rotating Bits</h3>
<p class="BodyFirst">In this section, we’ll cover shifting and rotating bits. These are fundamental bit manipulation operations that we’ll use from time to time in this book. A single byte of data is made up of eight bits and can hold a number from 0 to 255 in decimal, which is the same as 0 to FF in hexadecimal. Did you know that four bits are called a <em>nibble</em>? Single hexadecimal digits are made up of a single nibble (half a byte) and can be a value from 0 to 15 in decimal and 0 to F in hexadecimal.</p>
<p>The fact that four bits can store a single hexadecimal digit makes it relatively easy to work with hexadecimal numbers in WAT, especially when it comes to <em>shifting</em>. Shifting is a generic operation that’s a building block for the optimizations we’ll discuss in later chapters. Shifting is somewhat like pushing bits off a cliff and replacing them with 0s (or 1s for some signed right shifts). You can shift by any number of bits and in either the left or right direction. For example, the binary 1110 1001 is E9 in hexadecimal (and 233 in decimal). If we shift that number 4 bits to the right using the <code>(i32.shr_u</code><code>)</code> expression, it returns the binary 0000 1110 or 0E in hexadecimal. <a href="#figure4-9" id="figureanchor4-9">Figure 4-9</a> shows a dramatization of a four-bit shift of E9.</p>
<figure>
<img src="Images/f04009.png" alt="f04009" width="675" height="489"/>
<figcaption><p><a id="figure4-9">Figure 4-9</a>: Shifting hexadecimal E9 four bits to the right results in 0E.</p></figcaption></figure>
<p>Shifting data to the right can be a useful trick. Every bit you shift to the right is the functional equivalent of dividing by 2. Similarly, every bit you shift to the left is the functional equivalent of multiplying by 2. You can use shifting in combination with masking to isolate sections of binary data.</p>
<p>Left-shifting in WebAssembly is sign-independent, but to right-shift we use a signed or an unsigned shift operation. When you right-shift or <span epub:type="pagebreak" title="80" id="Page_80"/>left-shift a binary number, the bits shifted off are usually replaced on the opposite side of the integer with 0s. However, with a negative number, if you sign-shift to the right, 1s will be sign-shifted in from the left side to preserve the integer’s sign. Sign-shifting a 2s complement representation preserves the sign (negativeness).</p>
<p><em>Bit rotation</em>, unlike a shift, flips bits back around to the other side of the variable. If you rotate a bit to the right, the least significant bit is transferred to the front and ends up as the most significant bit, and all the other bits shift to the right. WAT does bit rotation with the <code>rotl</code> (rotate left) or <code>rotr</code> (rotate right) commands, depicted in <a href="#figure4-10" id="figureanchor4-10">Figure 4-10</a>.</p>
<figure>
<img src="Images/f04010.png" alt="f04010" width="675" height="353"/>
<figcaption><p><a id="figure4-10">Figure 4-10</a>: Rotating a bit to the right</p></figcaption></figure>
<h3 id="h2-501737c04-0004">Masking Bits with AND and OR</h3>
<p class="BodyFirst"><em>Bit masking</em><em> </em>is a method used to set some specified bits in an integer to 1 or 0, depending on the kind of mask we use, to isolate or override them. This can be very helpful when writing high-performance applications. Also, it’s important to know that WebAssembly doesn’t have the concept of boolean values. Comparisons in WebAssembly usually return a value of 1 for true and 0 for false. You must use the <code>i32.and</code> and <code>i32.or</code> when, in many languages, you would use boolean logic. In this section, we’ll use the <code>i32.and</code> and <code>i32.or</code> to isolate or override bit values with bit masking.</p>
<p>When you mask with a bitwise AND, the 0 bits in your integer win the battle of the bits. The 0 bits in the mask act like masking tape that covers up any other bit in the integer, replacing them with 0s. The 1 bits in the mask allow the original value to show through. <a href="#figure4-11" id="figureanchor4-11">Figure 4-11</a> shows what it looks like to mask binary 1011 1110 (190) with 0000 0111 (7).</p>
<p>As you can see in <a href="#figure4-11">Figure 4-11</a>, all of the bits of our original value are covered by the 0s in the AND mask. When a bitwise AND operation is performed on two different integers, the 0 bit wins (<a href="#figure4-12" id="figureanchor4-12">Figure 4-12</a>).</p>
<span epub:type="pagebreak" title="81" id="Page_81"/><figure>
<img src="Images/f04011.png" alt="f04011" width="608" height="509"/>
<figcaption><p><a id="figure4-11">Figure 4-11</a>: Masking bits with bitwise AND</p></figcaption></figure>
<figure>
<img src="Images/f04012.png" alt="f04012" width="608" height="583"/>
<figcaption><p><a id="figure4-12">Figure 4-12</a>: Bitwise AND 0 wins the battle of the bits.</p></figcaption></figure>
<p><span epub:type="pagebreak" title="82" id="Page_82"/>When you mask with OR, using an <code>i32/i64.or</code>, the results would be the exact opposite: 1 bits cover up any bits with 1s. You cannot use the OR mask to isolate bits as with an AND. Instead, you use it to set specific bits to 1. <a href="#figure4-13" id="figureanchor4-13">Figure 4-13</a> shows masking with OR.</p>
<figure>
<img src="Images/f04013.png" alt="f04013" width="540" height="429"/>
<figcaption><p><a id="figure4-13">Figure 4-13</a>: Masking with a bitwise OR</p></figcaption></figure>
<p>As you can see in <a href="#figure4-13">Figure 4-13</a>, when you use a bitwise OR, the 1 bits in your mask cover any bits in your initial integer value. So in a bitwise OR situation, the 1 bit wins over the 0 bit (<a href="#figure4-14" id="figureanchor4-14">Figure 4-14</a>).</p>
<figure>
<img src="Images/f04014.png" alt="f04014" width="540" height="461"/>
<figcaption><p><a id="figure4-14">Figure 4-14</a>: In a bitwise OR, the 1 bit always wins.</p></figcaption></figure>
<h3 id="h2-501737c04-0005"><span epub:type="pagebreak" title="83" id="Page_83"/>XOR Bit Flip</h3>
<p class="BodyFirst">The last binary operation we’ll cover is XOR. With AND and OR, the results of a mask are clear. The XOR <code>i32/i64.xor</code> operation is a little different. If a 0 masks a 0, a 1 masks a 0, or a 0 masks a 1, the XOR operates just like a typical <code>i32/i64.or</code>. The weirdness occurs when you have two 1s, which results in the XOR setting the resulting bit to 0. This feature is handy for <em>bit flipping</em>, where you invert each bit to its opposite. Certain operations require you to change every 1 bit in an integer to a 0 and every 0 bit to a 1. <a href="#figure4-15" id="figureanchor4-15">Figure 4-15</a> shows how to flip every bit in a nibble with an XOR.</p>
<figure>
<img src="Images/f04015.png" alt="f04015" width="540" height="535"/>
<figcaption><p><a id="figure4-15">Figure 4-15</a>: XOR bit flip</p></figcaption></figure>
<p>In our 2s complement discussion earlier, we noted that if you want to find the negative of any number, you can do so by flipping every bit and adding the number 1. You can flip all the bits using an <code>XOR</code> against an integer that has every bit set to 1. Let’s write a short app that converts an integer value to its negative using 2s complement and bit flipping. Create a file named <em>twos_complement.wat</em> and add the code in <a href="#listing4-1" id="listinganchor4-1">Listing 4-1</a>.</p>
<p class="CodeLabel"><b>twos_complement.wat</b></p>
<pre><code>(module
  (func $twos_complement (export "twos_complement")
  (param $number i32)
  (result i32)
    local.get $number
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> i32.const 0xffffffff  <span class="LiteralGray">;; all binary 1s to flip the bits</span>
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> i32.xor               <span class="LiteralGray">;; flip all the bits</span>
    i32.const 1
<span epub:type="pagebreak" title="84" id="Page_84"/>  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> i32.add             <span class="LiteralGray">;; add one after flipping all bits for 2s complement</span>
  )
)</code></pre>
<p class="CodeListingCaption"><a id="listing4-1">Listing 4-1</a>: 2s complement function</p>
<p>This is a very simple module that takes an <code>i32</code> parameter called <code>$number</code>. We push the <code>i32</code> onto the stack, followed by a 32-bit number where all the bits are 1 <span class="CodeAnnotation" aria-label="annotation1">1</span>. When we call <code>i32.xor</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>, all of the bits from the original number are flipped. Every 1 is turned into a 0 and every 0 into a 1. We then call <code>i32.add</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> to add a value of 1 to this number to get 2s complement, resulting in the negative number. This code works well as a demonstration of how 2s complement works; however, it would perform better if we just subtracted <code>$number</code> from <code>0</code> to negate it. </p>
<h3 id="h2-501737c04-0006">Big-Endian vs. Little-Endian</h3>
<p class="BodyFirst">All numbers you’re familiar with are arranged in a <em>big-endian</em><em> </em>format, meaning the highest-order digits are on the left side and the lowest-order digits are on the right side. Most computer hardware uses <em>little-endian</em>, where the lowest-order digit is on the left and the high-order digit is on the right, so one hundred twenty-eight would be written as 821 instead. Keep in mind that endianness is about byte order, not digit order, so my little-endian decimal 821 example is an oversimplification that can’t be directly translated to binary. Little-endian hardware orders the bytes in reverse of what is typical. The number 168,496,141 written in big-endian hex is 0A0B0C0D. The high-order byte is 0A, and the low-order byte is 0D because each hex digit is represented by a nibble or half a byte. If we order the bytes in little-endian order, they’re arranged as 0D0C0B0A, as illustrated in <a href="#figure4-16" id="figureanchor4-16">Figure 4-16</a>.</p>
<figure>
<img src="Images/f04016.png" alt="f04016" width="540" height="454"/>
<figcaption><p><a id="figure4-16">Figure 4-16</a>: Big-endian versus little-endian byte order</p></figcaption></figure>
<p><span epub:type="pagebreak" title="85" id="Page_85"/>Most hardware today arranges bytes in little-endian order for performance reasons. WebAssembly uses little-endian byte order regardless of the hardware. When you’re initializing data using the <code>(data</code><code>)</code> statement in WebAssembly, it’s important to keep the byte order in mind.</p>
<h2 id="h1-501737c04-0005">Summary</h2>
<p class="BodyFirst">This chapter covered a lot of low-level programming concepts. We looked at the different numeric bases (decimal, hexadecimal, and binary) used in low-level programming. We examined the details of integer and floating-point arithmetic, and touched on 2s complement as well as big-endian and little-endian byte order. We talked about bit manipulation, including discussions of high-order and low-order bits, bit masking, bit shifting, and bit rotation. These low-level options will become useful for applications in later chapters that enhance performance by manipulating bits.</p>
<p>In the next chapter, you’ll learn several methods for managing strings as data structures, including null-terminated strings and length-prefixed strings. We’ll also explore copying strings and converting numeric data into strings in decimal, hexadecimal, and binary formats.</p>
</section>
</div></body></html>