<html><head></head><body><div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="223" id="Page_223"/>10</span><br/>
<span class="ChapterTitle">Debugging WebAssembly</span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="190" height="190"/>
</figure>
<p class="ChapterIntro">In this chapter, you’ll learn several techniques to debug your WAT code. We’ll discuss logging to the console and using alerts, as well as how to log stack traces to the console. We’ll cover using the debugger in Firefox and Chrome, the differences between them, and the limitations of each debugger.</p>
<p>A <em>source map</em><em> </em>maps code running in the browser to the original precompiled source code. It allows a developer writing in languages like TypeScript or frameworks, such as React, to step through their original code to debug it. WebAssembly toolchains, such as Emscripten, map the generated WebAssembly binary back to the original C++ source code. At the time of this writing, <em>wat2wasm</em> doesn’t generate source maps for WAT code converted to the WebAssembly binary format. This doesn’t render debugging WAT code useless, but it does mean that any names for local or global variables are lost when it is converted to binary. Therefore, the code you write in WAT doesn’t look exactly like what you see in your debugger. <span epub:type="pagebreak" title="224" id="Page_224"/>You have to manually map the specific names you give variables to the generic names assigned by your browser debugger. Later in this chapter, you’ll learn how to understand this mapping. Once you’ve learned to debug your WebAssembly code, you’ll have the tools to step through any WebAssembly code you find on the web, even when you don’t have the source code.</p>
<h2 id="h1-501737c10-0001">Debugging from the Console</h2>
<p class="BodyFirst">The simplest way to start debugging your WebAssembly code is by logging statements to the browser console. As you learned earlier, WebAssembly must rely on JavaScript to do this. In this chapter, we’ll use a JavaScript function to create debugging logs. Let’s create a simple WebAssembly function to calculate the distance between two points using the Pythagorean theorem. We’ll introduce an error in the code and use it as code to debug. Create a new file named <em>pythagoras.wat</em> and add the code in <a href="#listing10-1" id="listinganchor10-1">Listing 10-1</a>.</p>
<p class="CodeLabel"><b>pythagoras.wat</b></p>
<pre><code>(module
  (import "js" "log_f64" (func $log_f64(param i32 f64)))

  (func $distance (export "distance")
    (param $x1 f64) (param $y1 f64) (param $x2 f64) (param $y2 f64)
    (result f64)
    (local $x_dist f64)
    (local $y_dist f64)

    local.get $x1
    local.get $x2
    f64.sub             <span class="LiteralGray">;; $x1 - $x2</span>
    local.tee $x_dist   <span class="LiteralGray">;; $x_dist = $x1 - $x2</span>
    local.get $x_dist
    f64.mul             <span class="LiteralGray">;; $x_dist * $x_dist on stack</span>

    local.get $y1
    local.get $y2
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> f64.add             <span class="LiteralGray">;; should be $y1 - $y2</span>
    local.tee $y_dist   <span class="LiteralGray">;; $y_dist = $y1 - $y2</span>
    local.get $y_dist
    f64.mul             <span class="LiteralGray">;; $y_dist * $y_dist on stack</span>
    f64.add             <span class="LiteralGray">;; $x_dist * $x_dist + $y_dist * $y_dist on stack</span>

    f64.sqrt            <span class="LiteralGray">;; take the square root of x squared plus y squared</span>
  )
)</code></pre>
<p class="CodeListingCaption"><a id="listing10-1">Listing 10-1</a>: Using the Pythagorean theorem to find the distance between two points</p>
<p>To use the Pythagorean theorem, we make a right triangle on the x-axis and y-axis between the two points. The length on the x-axis is the distance between the two <code>x</code> values. We can find the distance on the y-axis the same way. We can find the distance between the two points by squaring these two values, adding them, and then taking the square root (<a href="#figure10-1" id="figureanchor10-1">Figure 10-1</a>). </p>
<span epub:type="pagebreak" title="225" id="Page_225"/><figure>
<img src="Images/f10001.png" alt="f10001" width="559" height="439"/>
<figcaption><p><a id="figure10-1">Figure 10-1</a>: Calculating the distance between game objects using the Pythagorean theorem</p></figcaption>
</figure>
<p>The math in this example isn’t terribly important. The important detail is that we’ve introduced a bug into this code by adding the values of <code>$y1</code> and <code>$y2</code> instead of subtracting them <span class="CodeAnnotation" aria-label="annotation1">1</span> to get the distance between the two y-coordinates. Compile <em>pythagoras.wat</em> into <em>pythagoras.wasm</em> and create a new file named <em>pythagoras.html</em>. Then add the code in <a href="#listing10-2" id="listinganchor10-2">Listing 10-2</a> to <em>pythagoras.html</em>.</p>
<p class="CodeLabel"><b>pythagoras.html</b></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> X1: &lt;input type="number" id="x1" value="0"&gt;
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> Y1: &lt;input type="number" id="y1" value="0"&gt;
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> X2: &lt;input type="number" id="x2" value="4"&gt;
  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> Y2: &lt;input type="number" id="y2" value="3"&gt;
    &lt;br&gt;&lt;br&gt;
  <span class="CodeAnnotationCode" aria-label="annotation5">5</span> DISTANCE: &lt;span id="dist_out"&gt;??&lt;/span&gt;
    &lt;script&gt;
      var distance = null;
      let importObject = {
        js: {
        <span class="CodeAnnotationCode" aria-label="annotation6">6</span> log_f64: function(message_index, value) {
            console.log(`message #${message_index} value=${value}`);
          }
        }
      };

      ( async () =&gt; {
        let obj = await WebAssembly.instantiateStreaming(
                            fetch('pythagoras.wasm'), importObject );
        distance = obj.instance.exports.distance;
<span epub:type="pagebreak" title="226" id="Page_226"/>      })();

      <span class="CodeAnnotationCode" aria-label="annotation7">7</span> function set_distance() {
        <span class="CodeAnnotationCode" aria-label="annotation8">8</span> let dist_out = document.getElementById('dist_out');
          let x1 = document.getElementById('x1');
          let x2 = document.getElementById('x2');
          let y1 = document.getElementById('y1');
          let y2 = document.getElementById('y2');

        <span class="CodeAnnotationCode" aria-label="annotation9">9</span> let dist = distance(x1.value, y1.value, x2.value, y2.value);
          dist_out.innerHTML = dist;
      }
    &lt;/script&gt;
    &lt;br&gt;
    &lt;br&gt;
  <span class="CodeAnnotationCode" aria-label="annotationa">a</span> &lt;button onmousedown="set_distance()"&gt;Find Distance&lt;/button&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p class="CodeListingCaption"><a id="listing10-2">Listing 10-2</a>: A web application that calls the WebAssembly distance function</p>
<p>Inside the <code>body</code> tag, we set up the user interface by adding number type input tags for <code>x1</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>, <code>y1</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>, <code>x2</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>, and <code>y2</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> coordinates. We add a <code>span</code><code> </code>tag that will hold the distance <span class="CodeAnnotation" aria-label="annotation5">5</span> between the two points after the WebAssembly function runs. </p>
<p>Inside the <code>script</code> tag, the <code>importObject</code> contains a <code>log_f64</code> <span class="CodeAnnotation" aria-label="annotation6">6</span> function that takes as its parameters a message index and a value. This function logs these two values to the browser console. WebAssembly cannot directly pass strings back and forth to JavaScript (it must pass an index into linear memory), so it’s frequently easier to use a message code and define the strings you want to log from within JavaScript. This function uses the template string <code>`message #${message_index} value=${value}`</code> to log the <code>message_index</code> and value to the console. Alternatively, you could choose from other template strings based on the <code>message_index</code> variable. The function <code>set_distance</code> <span class="CodeAnnotation" aria-label="annotation7">7</span> executes when the user clicks the Find Distance button <span class="CodeAnnotation" aria-label="annotationa">a</span>. This function will get the element ids for the <code>dist_out </code><span class="CodeAnnotation" aria-label="annotation8">8</span> <code>span</code> tag, as well as the <code>x1</code>, <code>x2</code>, <code>y1</code>, and <code>y2</code> input fields. It then executes the WebAssembly <code>distance</code> <span class="CodeAnnotation" aria-label="annotation9">9</span> function using the values in those input fields. </p>
<p>Run a web server and load the <em>pythagoras.html</em> page into a browser; you should see something like <a href="#figure10-2" id="figureanchor10-2">Figure 10-2</a>.</p>
<figure>
<img src="Images/f10002.png" alt="f10002" width="694" height="99"/>
<figcaption><p><a id="figure10-2">Figure 10-2</a>: The <em>pythagoras.html</em> web page screenshot</p></figcaption>
</figure>
<p>The values you see in <a href="#figure10-2">Figure 10-2</a> are the default values populated in the form. The distance is listed as “??” below where the user can enter the coordinates. When we click <b>Find Distance</b>, the distance should be 5. We’re <span epub:type="pagebreak" title="227" id="Page_227"/>using a 3-4-5 triangle to test this distance calculator. As long as the distance on the x-axis is 3 and the distance on the y-axis is 4, the distance between the two points will be 5 because 3<sup>2</sup> + 4<sup>2</sup> = 5<sup>2</sup>, as shown in <a href="#figure10-3" id="figureanchor10-3">Figure 10-3</a>.</p>
<figure>
<img src="Images/f10003.png" alt="f10003" width="498" height="433"/>
<figcaption><p><a id="figure10-3">Figure 10-3</a>: Using a 3-4-5 triangle</p></figcaption>
</figure>
<p>When you click the <b>Find Distance</b> button on the app, you will see the DISTANCE field populated with the value 5 as in <a href="#figure10-4" id="figureanchor10-4">Figure 10-4</a>.</p>
<figure>
<img src="Images/f10004.png" alt="f10004" width="694" height="99"/>
<figcaption><p><a id="figure10-4">Figure 10-4</a>: Distance calculated for a 3-4-5 triangle</p></figcaption>
</figure>
<p>When we change both X and Y values by the same amount, the distance between the two points should remain the same. However, because of a bug we introduced intentionally, adding 1 to both Y1 and Y2 results in the wrong value displayed in the DISTANCE field (<a href="#figure10-5" id="figureanchor10-5">Figure 10-5</a>).</p>
<figure>
<img src="Images/f10005.png" alt="f10005" width="694" height="99"/>
<figcaption><p><a id="figure10-5">Figure 10-5</a>: A bug in the calculated distance</p></figcaption>
</figure>
<p>We should still see 5 in the DISTANCE field, but it’s a different number entirely. We need to track down what went wrong; the first step is to add <code>log</code> statements at several points in our <code>distance</code> function.</p>
<p><span epub:type="pagebreak" title="228" id="Page_228"/>As we know, dealing with strings directly in WAT isn’t a simple task. Therefore, to step through and debug this code, we use a message id along with a value passed to the JavaScript from the WebAssembly module. Using <a href="#listing10-3" id="listinganchor10-3">Listing 10-3</a>, modify the <em>pythagoras.wat</em> file to call <code>$log_f64</code> from within the <code>$distance</code> function.</p>
<p class="CodeLabel"><b>pythagoras.wat</b></p>
<pre><code>...
(func $distance (export "distance")
  (param $x1 f64) (param $y1 f64) (param $x2 f64) (param $y2 f64) (result f64)
  (local $x_dist f64)
  (local $y_dist f64)
  (local $temp_f64 f64)

  local.get $x1
  local.get $x2
  f64.sub             <span class="LiteralGray">;; $x1 - $x2</span>

  local.tee $x_dist   <span class="LiteralGray">;; $x_dist = $x1 - $x2</span>

<span class="CodeAnnotationCode" aria-label="annotation1">1</span> (call $log_f64 (i32.const 1) (local.get $x_dist))

  local.get $x_dist
  f64.mul             <span class="LiteralGray">;; $x_dist * $x_dist on stack</span>

<span class="CodeAnnotationCode" aria-label="annotation2">2</span> local.tee $temp_f64 <span class="LiteralGray">;; used to hold top of the stack without changing it</span>
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> (call $log_f64 (i32.const 2) (local.get $temp_f64))

  local.get $y1
  local.get $y2
  f64.add             <span class="LiteralGray">;; should be $y1 - $y2</span>
  local.tee $y_dist   <span class="LiteralGray">;; $y_dist = $y1 - $y2</span>

<span class="CodeAnnotationCode" aria-label="annotation4">4</span> (call $log_f64 (i32.const 3) (local.get $y_dist))

  local.get $y_dist
  f64.mul             <span class="LiteralGray">;; $y_dist * $y_dist on stack</span>

<span class="CodeAnnotationCode" aria-label="annotation5">5</span> local.tee $temp_f64 <span class="LiteralGray">;; used to hold top of the stack without changing it</span>
<span class="CodeAnnotationCode" aria-label="annotation6">6</span> (call $log_f64 (i32.const 4) (local.get $temp_f64))

  f64.add             <span class="LiteralGray">;; $x_dist * $x_dist + $y_dist * $y_dist on stack</span>

<span class="CodeAnnotationCode" aria-label="annotation7">7</span> local.tee $temp_f64 <span class="LiteralGray">;; used to hold top of the stack without changing it</span>
<span class="CodeAnnotationCode" aria-label="annotation8">8</span> (call $log_f64 (i32.const 5) (local.get $temp_f64))

  f64.sqrt            <span class="LiteralGray">;; take the square root of x squared plus y squared</span>

<span class="CodeAnnotationCode" aria-label="annotation9">9</span> local.tee $temp_f64 <span class="LiteralGray">;; used to hold top of the stack without changing it</span>
<span class="CodeAnnotationCode" aria-label="annotationa">a</span> (call $log_f64 (i32.const 6) (local.get $temp_f64))
)
...</code></pre>
<p class="CodeListingCaption"><a id="listing10-3">Listing 10-3</a>: The<em> </em><em>pythagoras.wat</em><em> </em>file updated with JavaScript function calls to log f64 variables</p>
<p><span epub:type="pagebreak" title="229" id="Page_229"/>We’ve added calls to the <code>$log_f64</code> function in several places here (<span class="CodeAnnotation" aria-label="annotation13468a">13468a</span>). The first parameter in <code>$log_f64</code> is the message id, which will be an integer we’ll use as the unique id for this message. Later we use this id to output a specific message from the JavaScript.</p>
<p>The second parameter is a 64-bit floating-point value, which can show us the value at several different stages of our distance calculation. In a number of these calls, we want to log the value on the top of the stack but <em>not </em>take it off, so we use <code>local.tee</code> (<span class="CodeAnnotation" aria-label="annotation2579">2579</span>) to set the value of <code>$temp_f64</code>, which will set the value but not remove it from the stack. We then use the value in <code>$temp_f64</code> in the call to <code>$log_f64</code> (<span class="CodeAnnotation" aria-label="annotation368a">368a</span>).</p>
<h3 id="h2-501737c10-0001">Logging Messages to the Console</h3>
<p class="BodyFirst">As mentioned earlier, WebAssembly modules cannot directly log messages to the browser’s console, and WAT has no native string manipulation libraries. The <code>log_f64</code> function we’ve used so far is imported from JavaScript by the WebAssembly module. So, in <a href="#listing10-4" id="listinganchor10-4">Listing 10-4</a>, we’ll implement this function in the JavaScript.</p>
<p class="CodeLabel"><b>pythagoras.html</b></p>
<pre><code>log_f64: function(message_index, value) {
  console.log(`message #${message_index} value=${value}`);
}</code></pre>
<p class="CodeListingCaption"><a id="listing10-4">Listing 10-4</a>: The JavaScript function called by <em>pythagoras.wat</em></p>
<p>This is a pretty straightforward version that logs the message index and the value but doesn’t customize the message for any of the <code>message_index</code> values. To see the console in Chrome, we’ll open Developer tools. Go to the browser menu and click <b>More tools</b> (<a href="#figure10-6" id="figureanchor10-6">Figure 10-6</a>).</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Updates to the Chrome or Firefox debugger might mean that what you see in your browser is slightly different than the screenshots shown in this chapter.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<figure>
<img src="Images/f10006.png" alt="f10006" width="421" height="383"/>
<figcaption><p><a id="figure10-6">Figure 10-6</a>: Opening the Chrome Developer tools</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="230" id="Page_230"/>Click <b>Developer tools</b>, and then click the <b>Console</b> tab to see the console, as shown in <a href="#figure10-7" id="figureanchor10-7">Figure 10-7</a>.</p>
<figure>
<img src="Images/f10007.png" alt="f10007" width="692" height="303"/>
<figcaption><p><a id="figure10-7">Figure 10-7</a>: Opening the Chrome console</p></figcaption>
</figure>
<p>To open the console inside Firefox, click the <b>Web Developer</b> submenu from within the Firefox browser menu, as shown in <a href="#figure10-8" id="figureanchor10-8">Figure 10-8</a>.</p>
<figure>
<img src="Images/f10008.png" alt="f10008" width="506" height="654"/>
<figcaption><p><a id="figure10-8">Figure 10-8</a>: Opening the Firefox Web Developer menu</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="231" id="Page_231"/>Click <b>Web Console</b>, as shown in <a href="#figure10-9" id="figureanchor10-9">Figure 10-9</a>.</p>
<figure>
<img src="Images/f10009.png" alt="f10009" width="506" height="491"/>
<figcaption><p><a id="figure10-9">Figure 10-9</a>: Opening the Firefox Web Console</p></figcaption>
</figure>
<p>Your Firefox screen should look similar to <a href="#figure10-10" id="figureanchor10-10">Figure 10-10</a>.</p>
<figure>
<img src="Images/f10010.png" alt="f10010" width="844" height="189"/>
<figcaption><p><a id="figure10-10">Figure 10-10</a>: Displaying messages in the Web Console</p></figcaption>
</figure>
<p>All messages begin with <code>message #</code> followed by the message id.</p>
<p>This sort of messaging is frequently all you need, but we’ll make a modification to the function to log more specific messages. For example, you might want the messages to be more specific to the issue if you’re having trouble keeping track of what each message means. You could do it this way, as in <a href="#listing10-5" id="listinganchor10-5">Listing 10-5</a>, or you could have a series of different log functions for different circumstances.</p>
<p class="CodeLabel"><b>pythagoras.html</b></p>
<pre><code>log_f64: function(message_index, value) {
  switch( message_index ) {
    case 1:
      console.log(`$x_dist=${value}`);
      break;
<span epub:type="pagebreak" title="232" id="Page_232"/>    case 2:
      console.log(`$x_dist*$x_dist=${value}`);
      break;
     case 3:
       console.log(`$y_dist=${value}`);
       break;
     case 4:
       console.log(`$y_dist*$y_dist=${value}`);
       break;
     case 5:
       console.log(`$y_dist*$y_dist + $x_dist*$x_dist=${value}`);
       break;
     case 6:
       console.log(`dist=${value}`);
       break;
     default:
       console.log(`message #${message_index} value=${value}`);
     }
   }</code></pre>
<p class="CodeListingCaption"><a id="listing10-5">Listing 10-5</a>: Updated<em> </em><em>pythagoras.html</em><em> </em>to have a more detailed message</p>
<p>There are six messages, so we create a switch on the <code>message_index</code> parameter, which prints a different message to the console for each value of <code>message_index</code>. The switch has a default that displays the original message in case an unexpected value for <code>message_index</code> is logged. With these messages changed, the console output should look similar to <a href="#figure10-11" id="figureanchor10-11">Figure 10-11</a>.</p>
<figure>
<img src="Images/f10011.png" alt="f10011" width="844" height="189"/>
<figcaption><p><a id="figure10-11">Figure 10-11</a>: Descriptive messages logged to the console</p></figcaption>
</figure>
<h2 id="h1-501737c10-0002">Using Alerts</h2>
<p class="BodyFirst">Next, we’ll use JavaScript alerts to pause code execution to give you time to look at the logged messages. For this task, we’ll use the <code>alert</code> function, which opens a dialog with the error text. Know that overusing alerts can make checking the logs time-consuming, so it’s best to use them sparingly.</p>
<p> In the earlier <code>log_f64</code> example, you might want to alert the user immediately if a certain case executes. An <code>alert</code> stops code execution and creates a pop-up window to notify the user. You only want to use a call to <code>alert</code> <span epub:type="pagebreak" title="233" id="Page_233"/>for unusual circumstances that require immediate attention when you’re debugging. In <a href="#listing10-6" id="listinganchor10-6">Listing 10-6</a>, we change the <code>case 1:</code> code to output an alert in a pop-up window instead of to the console. Change the beginning of the <code>log_f64</code> function to look like <a href="#listing10-6">Listing 10-6</a>.</p>
<p class="CodeLabel"><b>pythagoras.html</b></p>
<pre><code>log_f64: function(message_index, value) {
  switch( message_index ) {
    case 1:
    <span class="CodeAnnotationCode" aria-label="annotation1">1</span> alert(`$x_dist=${value}`);
      break;</code></pre>
<p class="CodeListingCaption"><a id="listing10-6">Listing 10-6</a>: Update the <em>pythagoras.html </em>file<em> </em>to call an alert from <code>log_f64</code>.</p>
<p>We changed the <code>console.log</code> function call to <code>alert</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> to display the alert box when the <code>message_index</code> is 1. The result, shown in <a href="#figure10-12" id="figureanchor10-12">Figure 10-12</a>, should display in the browser.</p>
<figure>
<img src="Images/f10012.png" alt="f10012" width="450" height="134"/>
<figcaption><p><a id="figure10-12">Figure 10-12</a>: Displaying the alert box</p></figcaption>
</figure>
<h2 id="h1-501737c10-0003">Stack Trace</h2>
<p class="BodyFirst">A <em>stack trace</em><em> </em>displays a list of the functions that have been called to get to the current point in the code. For example, if function A calls function B, which calls function C, which then executes a stack trace, the stack trace will show the functions C, B, and A as well as the lines that called those functions. WebAssembly doesn’t offer this feature directly, so as with logging to the console, we call the stack trace from JavaScript. The trail of the functions called should look similar to <a href="#figure10-13" id="figureanchor10-13">Figure 10-13</a>.</p>
<p>We display the stack trace with a call to the JavaScript <code>console.trace</code> function. Firefox and Chrome currently offer stack traces that look quite different from each other. Using <code>console.trace</code> in Firefox currently gives you more useful information about the WAT file than you get using the Chrome browser. The Firefox browser converts the WebAssembly binary into a WAT file and provides you with a stack trace that references the line in that disassembled WAT file. Chrome, on the other hand, gives you a reference to a function index, which can appear quite cryptic if you’re not familiar with it.</p>
<span epub:type="pagebreak" title="234" id="Page_234"/><figure>
<img src="Images/f10013.png" alt="f10013" width="559" height="631"/>
<figcaption><p><a id="figure10-13">Figure 10-13</a>: Function 1 calls function 2, which calls function 3, which calls function 4 in stack trace</p></figcaption>
</figure>
<p>Create a file named <em>stack_trace.wat</em> and add the code in <a href="#listing10-7" id="listinganchor10-7">Listing 10-7</a> to it.</p>
<p class="CodeLabel"><b>stack_trace.wat</b></p>
<pre><code>(module

<span class="CodeAnnotationCode" aria-label="annotation1">1</span> (import "js" "log_stack_trace" (func $log_stack_trace (param i32)))

<span class="CodeAnnotationCode" aria-label="annotation2">2</span> (func $call_level_1 (param $level i32)
    local.get $level
    call $log_stack_trace
  )

<span class="CodeAnnotationCode" aria-label="annotation3">3</span> (func $call_level_2 (param $level i32)
    local.get $level
    call $call_level_1
  )

<span class="CodeAnnotationCode" aria-label="annotation4">4</span> (func $call_level_3 (param $level i32)
    local.get $level
    call $call_level_2
  )

<span class="CodeAnnotationCode" aria-label="annotation5">5</span> (func $call_stack_trace (export "call_stack_trace")
<span epub:type="pagebreak" title="235" id="Page_235"/>  <span class="CodeAnnotationCode" aria-label="annotation6">6</span> (call $log_stack_trace (i32.const 0))
    (call $call_level_1 (i32.const 1))
    (call $call_level_2 (i32.const 2))
    (call $call_level_3 (i32.const 3)) 
  )
)</code></pre>
<p class="CodeListingCaption"><a id="listing10-7">Listing 10-7</a>: WebAssembly module demonstrating calls to stack trace</p>
<p>This WebAssembly module imports the <code>log_stack_trace</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> function from JavaScript that will call <code>console.trace</code> from the embedding JavaScript. We define four more functions that demonstrate how each browser logs the WebAssembly call stack. The imported function <code>$log_stack_trace</code> is called by <code>$call_stack_trace</code> and <code>$call_level_1 </code><span class="CodeAnnotation" aria-label="annotation2">2</span>. The function <code>$call_level_1</code> is called by <code>$call_stack_trace</code> and <code>$call_level_2 </code><span class="CodeAnnotation" aria-label="annotation3">3</span>. The function <code>$call_level_2</code> is called by <code>$call_stack_trace</code> and <code>$call_level_3 </code><span class="CodeAnnotation" aria-label="annotation4">4</span>. Finally, <code>$call_level_3</code> is called by <code>$call_stack_trace</code>. We nest these function calls to demonstrate how stack traces look when called from different function levels. </p>
<p>Notice that <code>$call_stack_trace</code> <span class="CodeAnnotation" aria-label="annotation5">5</span> calls each of the other functions. First, it calls <code>$log_stack_trace</code> directly, passing in a constant <code>0</code>. Next, it calls <code>$call_level_1</code>, which calls <code>$log_stack_trace</code>, passing it a constant value of <code>1</code>. When the stack trace is logged, it should show <code>$call_level_1</code>, <code>$log_stack_trace</code> <span class="CodeAnnotation" aria-label="annotation6">6</span>, and <code>$call_stack_trace</code> in the call stack. The <code>$call_level_2</code> and <code>$call_level_3 </code>functions each add additional layers that will display in the stack trace. </p>
<p>Now create a new file named <em>stack_trace.html</em> and add the code in <a href="#listing10-8" id="listinganchor10-8">Listing 10-8</a>.</p>
<p class="CodeLabel"><b>stack_trace.html</b></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;
    &lt;h1&gt;Stack Trace&lt;/h1&gt;
    &lt;script&gt;
      let importObject = {
        js: {
          <span class="CodeAnnotationCode" aria-label="annotation1">1</span> log_stack_trace: function( level ) {
                console.trace(`level=${level}`);
          }
        }
      };

      ( async () =&gt; {
        let obj =
          await WebAssembly.instantiateStreaming( fetch('stack_trace.wasm'),
                                                  importObject );
       obj.instance.exports.call_stack_trace();

      })();
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p class="CodeListingCaption"><a id="listing10-8">Listing 10-8</a>: HTML file with JavaScript calls to stack trace</p>
<p><span epub:type="pagebreak" title="236" id="Page_236"/>This is a very basic HTML file, similar to <em>pythagoras.html</em>. The primary code is the <code>log_stack_trace</code> function <span class="CodeAnnotation" aria-label="annotation1">1</span> defined inside <code>importObject</code>, which calls the JavaScript function <code>console.trace</code>, passing in a string that prints to the console before the stack trace. Once you’ve saved this HTML file, open it in the Firefox browser; you should see similar console logs to <a href="#figure10-14" id="figureanchor10-14">Figure 10-14</a>.</p>
<figure>
<img src="Images/f10014.png" alt="f10014" width="694" height="496"/>
<figcaption><p><a id="figure10-14">Figure 10-14</a>: Displaying stack traces in Firefox</p></figcaption>
</figure>
<p>As you can see, the first stack trace was logged with <code>level=0</code> because we had passed a value of <code>0</code> directly into the first call to <code>$log_stack_trace</code> in the WAT code. That was a direct call from the WebAssembly function <code>$call_stack_trace</code> to the imported JavaScript function. Because that first call was direct to <code>$log_stack_trace</code>, there is only one stack frame logged for the <em>stack_trace.wasm</em> file in this first stack trace. This log indicates that the stack trace was executed from line 98 of <em>stack_trace.wasm</em>. This isn’t necessarily line 98 in your WAT file; you’ll need to look at the WAT inside the browser to see which line it’s referring to. Each trace adds an additional function call in the WebAssembly file because we added an additional function layer to each call to <code>$log_stack_trace</code> in the WAT. Notice that in each stack trace an additional line is inside <em>stack_trace.wasm</em> that appears in the trace.</p>
<p>Click one of these lines; Firefox opens the <em>stack_trace.wasm</em> file to the location in the code where the function call occurred. </p>
<p>If you haven’t yet opened <em>stack_trace.wasm</em> in the Firefox debugger, you might be prompted to refresh your browser page to view the contents as disassembled WAT. When <em>stack_trace.wasm</em> opens to byte 98, you should see something like <a href="#figure10-15" id="figureanchor10-15">Figure 10-15</a> in your Firefox debugger console. </p>
<span epub:type="pagebreak" title="237" id="Page_237"/><figure>
<img src="Images/f10015.png" alt="f10015" width="584" height="357"/>
<figcaption><p><a id="figure10-15">Figure 10-15</a>: Clicking a location in <em>stack_trace.wasm </em>displays the WAT code</p></figcaption>
</figure>
<p>The line that makes the call is temporarily highlighted in gray. Notice that the byte number on the left (62) is in hexadecimal, unlike the console log, where the byte is the decimal number 98. </p>
<p>Chrome doesn’t display the byte number inside the WAT file for each stack trace; rather, it looks like <a href="#figure10-16" id="figureanchor10-16">Figure 10-16</a>.</p>
<figure>
<img src="Images/f10016.png" alt="f10016" width="441" height="597"/>
<figcaption><p><a id="figure10-16">Figure 10-16</a>: Displaying stack traces in Chrome</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="238" id="Page_238"/>In the Chrome browser, the line number is always 1. However, when you click the link in the console, Chrome opens a disassembled version of that specific function. All WebAssembly functions begin with the <code>wasm-</code> prefix and end with an index for the function followed by <code>:1</code>. <a href="#figure10-17" id="figureanchor10-17">Figure 10-17</a> shows what it should look like when you click the first WebAssembly function that appears in a stack trace.</p>
<figure>
<img src="Images/f10017.png" alt="f10017" width="675" height="463"/>
<figcaption><p><a id="figure10-17">Figure 10-17</a>: Clicking the stack trace in Chrome displays the WebAssembly function.</p></figcaption>
</figure>
<p>The disassembled function is different in Chrome than in Firefox. We’ll cover these differences in more detail beginning in the next section. For now, notice that Chrome uses variable and function indexes rather than labels for disassembly, which are more challenging to read.</p>
<p>Stack traces can be beneficial when you’re trying to figure out how certain functions execute. When you’re unsure of how a function is called, stack traces can be a lifesaver. Now let’s look at the code in the debuggers for Firefox and Chrome.</p>
<h2 id="h1-501737c10-0004">The Firefox Debugger</h2>
<p class="BodyFirst">In this section, we’ll write some code we can step through in our debugger. First, take a moment to review the <em>pythagoras.html</em> and <em>pythagoras.wat</em> files. We intentionally introduced a bug so we could track it in the debugger. We’ll modify <em>pythagoras.wat</em> by removing calls to log output to JavaScript so we can step through it using the debugger. Create a file named <em>debugger.wat</em> and add the code in <a href="#listing10-9" id="listinganchor10-9">Listing 10-9</a>, or simply remove the log calls from <em>pythagoras.wat </em>and resave the file.</p>
<span epub:type="pagebreak" title="239" id="Page_239"/>
<p class="CodeLabel"><b>debugger.wat</b></p>
<pre><code>(module
  (func $distance (export "distance")
    (param $x1 f64) (param $y1 f64) (param $x2 f64) (param $y2 f64)
    (result f64)
    (local $x_dist f64)
    (local $y_dist f64)

    local.get $x1
    local.get $x2
    f64.sub             <span class="LiteralGray">;; $x1 - $x2</span>
    local.tee $x_dist   <span class="LiteralGray">;; $x_dist = $x1 - $x2</span>    local.get $x_dist
    f64.mul             <span class="LiteralGray">;; $x_dist * $x_dist on stack</span>
    local.get $y1
    local.get $y2
  <b> </b> f64.add             <span class="LiteralGray">;; Should be $y1 - $y2</span>    local.tee $y_dist   <span class="LiteralGray">;; $y_dist = $y1 - $y2</span>
    local.get $y_dist
    f64.mul             <span class="LiteralGray">;; $y_dist * $y_dist on stack</span>
    f64.add             <span class="LiteralGray">;; $x_dist * $x_dist + $y_dist * $y_dist on stack</span>
    f64.sqrt            <span class="LiteralGray">;; take the square root of x squared plus y squared</span>
  )
)</code></pre>
<p class="CodeListingCaption"><a id="listing10-9">Listing 10-9</a>: We modify <em>pythagoras.wat </em>by removing the log calls.</p>
<p>Earlier, we introduced a bug to sometimes give an incorrect result by adding <code>$y1</code> to <code>$y2</code> instead of subtracting them. Copy <em>pythagoras.html</em> to a new file named <em>debugger.html</em>, and change the JavaScript code inside the <code>&lt;script</code><code>&gt;</code> tags to instead fetch <em>debugger.wasm</em>. Then remove the <code>importObject</code> to make it look like the code in <a href="#listing10-10" id="listinganchor10-10">Listing 10-10</a>.</p>
<p class="CodeLabel"><b>pythagoras.html</b></p>
<pre><code>...
&lt;script&gt;
  var distance = null;

  ( async () =&gt; {
    let obj = await WebAssembly.instantiateStreaming( fetch(<b>'debugger.wasm'</b>) );

    distance = obj.instance.exports.distance;

  })();
  function set_distance() {
    let dist_out = document.getElementById('dist_out');
    let x1 = document.getElementById('x1');
    let x2 = document.getElementById('x2');
    let y1 = document.getElementById('y1');
<span epub:type="pagebreak" title="240" id="Page_240"/>    let y2 = document.getElementById('y2');

    let dist = distance(x1.value, y1.value, x2.value, y2.value);
    dist_out.innerHTML = dist;
  }
&lt;/script&gt;
...</code></pre>
<p class="CodeListingCaption"><a id="listing10-10">Listing 10-10</a>: HTML file to test <em>debugger.wasm</em></p>
<p>Load <em>debugger.html </em>into Firefox and open the console; then click the <b>Debugger</b> tab to access the Firefox debugger. From the <b>Sources</b> tab on the left, select <em>debugger.wasm </em>to see the disassembled version of your WAT code, which should look like <a href="#figure10-18" id="figureanchor10-18">Figure 10-18</a>.</p>
<figure>
<img src="Images/f10018.png" alt="f10018" width="844" height="412"/>
<figcaption><p><a id="figure10-18">Figure 10-18</a>: WAT code in the Firefox debugger</p></figcaption>
</figure>
<p>This code is a disassembly of the WebAssembly binary, so now the names of functions and variables are no longer available. This result is similar to what you’d see if you disassembled a binary you found on the web. Because source maps aren’t yet available in <em>wat2wasm, </em>we can’t step through the original source code in the debugger. Instead, you need to do a side-by-side comparison of the original code and the disassembled code. <a href="#listing10-11" id="listinganchor10-11">Listing 10-11</a> shows what that disassembled code looks like.</p>
<pre><code>(module

  (type $type0 (func (param f64 f64 f64 f64) (result f64)))
  (export "distance" (func $func0))
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> (func $func0
    (param <span class="CodeAnnotationCode" aria-label="annotation2">2</span>$var0 f64)(param <span class="CodeAnnotationCode" aria-label="annotation3">3</span>$var1 f64)(param <span class="CodeAnnotationCode" aria-label="annotation4">4</span>$var2 f64)(param <span class="CodeAnnotationCode" aria-label="annotation5">5</span>$var3 f64)
    (result f64)
    (local <span class="CodeAnnotationCode" aria-label="annotation6">6</span>$var4 f64) (local <span class="CodeAnnotationCode" aria-label="annotation7">7</span>$var5 f64)
    local.get $var0
<span epub:type="pagebreak" title="241" id="Page_241"/>    local.get $var2
    f64.sub
    local.tee $var4
    local.get $var4
    f64.mul
    local.get $var1
    local.get $var3
    f64.add
    local.tee $var5
    local.get $var5
    f64.mul
    f64.add
    f64.sqrt
  )
)</code></pre>
<p class="CodeListingCaption"><a id="listing10-11">Listing 10-11</a>: WAT code generated by Firefox disassembly</p>
<p>This code was disassembled from the WebAssembly binary file and has no awareness of the labels we’ve given variables or functions. It’s also unaware of any comments in the code. If you look back at the original WAT code (<a href="#listing10-9">Listing 10-9</a>), you can see that the function <code>$distance</code> has become <code>$func0</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>. The parameter variables <code>$x1</code>, <code>$y1</code>, <code>$x2</code>, and <code>$y2</code> have become <code>$var0</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>, <code>$var1</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>, <code>$var2</code> <span class="CodeAnnotation" aria-label="annotation4">4</span>, and <code>$var3</code> <span class="CodeAnnotation" aria-label="annotation5">5</span>, respectively. The local variables <code>$x_dist</code> and <code>$y_dist</code> have become <code>$var4</code> <span class="CodeAnnotation" aria-label="annotation6">6</span> and <code>$var5</code> <span class="CodeAnnotation" aria-label="annotation7">7</span>. Once you know which of the original variables corresponds to which of the disassembly variables, you can step through the code knowing the variable used. To watch the values in these variables, you can enter them into the Watch expressions window on the right without the <code>$</code>. In the Watch window you can watch the <code>$var0</code> variable by entering <code class="bold">var0</code>. I use a simple trick to keep track of which variable is which. I add a JavaScript comment along with my watch expression, labeling the variable with its original name. For example, I might enter <code>$var0</code> into Watch expressions as <code>var0 // $x1</code>. <a href="#figure10-19" id="figureanchor10-19">Figure 10-19</a> shows what that looks like in Watch expressions.</p>
<figure>
<img src="Images/f10019.png" alt="f10019" width="356" height="264"/>
<figcaption><p><a id="figure10-19">Figure 10-19</a>: Watch expressions in Firefox using comments</p></figcaption>
</figure>
<p>To step through the WAT code, make sure the WebAssembly file is selected. We need to create a breakpoint, which is the point at which the debugger stops executing the code to allow you to step through one line <span epub:type="pagebreak" title="242" id="Page_242"/>at a time. To set a breakpoint, click the byte number on the left side of the WAT code. You can watch how the variables change in your Watch expressions window on the right. With the breakpoint set, execute the WebAssembly code by clicking <b>Find Distance</b> (<a href="#figure10-20" id="figureanchor10-20">Figure 10-20</a>).</p>
<figure>
<img src="Images/f10020.png" alt="f10020" width="693" height="300"/>
<figcaption><p><a id="figure10-20">Figure 10-20</a>: Setting a breakpoint in the Firefox debugger</p></figcaption>
</figure>
<p>When execution reaches the breakpoint, click the <b>Step over</b> button <span class="GraphicInline"><img src="Images/i10001.png" alt="i10001" width="26" height="20"/></span> located above Watch expressions. That allows you to step through your code one line at a time. To step into a function instead of executing it, click the <b>Step into</b> button <span class="GraphicInline"><img src="Images/i10002.png" alt="i10002" width="24" height="23"/></span> located next to the Step over button. To the right of the Step into button, click the <b>Step out</b> button <span class="GraphicInline"><img src="Images/i10003.png" alt="i10003" width="28" height="25"/></span> if you want to step out of the current function you’re in. Click the<b> Resume</b> button <span class="GraphicInline"><img src="Images/i10004.png" alt="i10004" width="17" height="23"/></span>, which looks like a play button, to tell the debugger to execute until it reaches another breakpoint.</p>
<p>To locate the error in the code, click the <b>Step over</b> button until you reach line 3D. At this point, <code>var5</code> is set, and we can see the value inside the Watch expressions window, as shown in <a href="#figure10-21" id="figureanchor10-21">Figure 10-21</a>.</p>
<figure>
<img src="Images/f10021.png" alt="f10021" width="694" height="207"/>
<figcaption><p><a id="figure10-21">Figure 10-21</a>: Stepping through the code in the Firefox debugger</p></figcaption>
</figure>
<p>Notice that <code>$y_dist</code> is set to a value of <code>5</code> when <code>Y1</code> was set to <code>1</code> and <code>Y2</code> was set to <code>4</code>. That means that <code>$y_dist</code> should have been <code>3</code>. Earlier, we changed the line numbered 3A from <code>f64.sub</code> to <code>f64.add</code> to introduce this error. Stepping through our code a line at a time in the debugger helped us track down the problem. </p>
<h2 id="h1-501737c10-0005"><span epub:type="pagebreak" title="243" id="Page_243"/>The Chrome Debugger</h2>
<p class="BodyFirst">Debugging WebAssembly in Chrome is somewhat different from debugging the same code in Firefox. The WAT code isn’t broken down by the WebAssembly file; rather, Chrome groups the WAT code by functions. The number at the end of the WebAssembly function is an index number based on where you defined the function in your code. </p>
<p>To get to the debugger, open the Chrome <b>Developer tools</b> and click the <b>Sources</b> tab. Located in a section labeled Page, you should see a cloud icon labeled wasm. Expand this branch to see a page for each function defined in your WebAssembly module. Because we’ve only defined one function in this module, only one function exists. Click that function to bring up the function’s code in the window on the right. In that window, set a breakpoint on line 3 that contains the code <code>local.get</code><code> 0</code> (<a href="#figure10-22" id="figureanchor10-22">Figure 10-22</a>). </p>
<figure>
<img src="Images/f10022.png" alt="f10022" width="615" height="783"/>
<figcaption><p><a id="figure10-22">Figure 10-22</a>: Setting a breakpoint in the Chrome debugger</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="244" id="Page_244"/>Notice that <code>local.get</code> is getting a number instead of a variable name. The reason is that following <code>local.get</code> with a number gets the local variable based on an index instead of a name. Using <code>local.get 0</code> is the equivalent to <code>local.get</code><code> $var0</code> in the Firefox browser. As in Firefox, you can look at the code and match it with the code in your function. <a href="#listing10-12" id="listinganchor10-12">Listing 10-12</a> shows the code as it appears in the Chrome debugger.</p>
<pre><code><span class="CodeAnnotationCode" aria-label="annotation1">1</span> func (param f64 f64 f64 f64) (result f64)
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> (local f64 f64)
  local.get 0
  local.get 2
  f64.sub
  local.tee 4
  local.get 4
  f64.mul
  local.get 1
  local.get 3
  f64.add
  local.tee 5
  local.get 5
  f64.mul
  f64.add
  f64.sqrt
end</code></pre>
<p class="CodeListingCaption"><a id="listing10-12">Listing 10-12</a>: Chrome WAT disassembly in the debugger</p>
<p>Notice that Chrome uses indexes for local variables, parameters, and functions. The function <span class="CodeAnnotation" aria-label="annotation1">1</span> doesn’t have a name associated with it, nor do any of its parameters or local variables <span class="CodeAnnotation" aria-label="annotation2">2</span>. The same is true for globals and types. If we were using global variables, we would use <code>global.get</code> and <code>global.set</code>, passing in an index number that corresponds to the order in which the variables were defined.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	As of Chrome v86, the debugger shows function names.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>One nice feature of the Chrome debugging functionality is that you have access to the stack in the Scope window. As you step through the code, you can watch values get pushed onto and popped off the stack. One of the downsides is that the Watch window is much less useful than it is in Firefox, because Chrome doesn’t make variables available as if they were JavaScript variables. </p>
<p>As in Firefox, Chrome has a Resume button <span class="GraphicInline"><img src="Images/i10005.png" alt="i10005" width="18" height="14"/></span>, a Step over button <span class="GraphicInline"><img src="Images/i10006.png" alt="i10006" width="25" height="14"/></span>, a Step into button <span class="GraphicInline"><img src="Images/i10007.png" alt="i10007" width="10" height="18"/></span>, and a Step out button <span class="GraphicInline"><img src="Images/i10008.png" alt="i10008" width="10" height="18"/></span>, as highlighted in <a href="#figure10-23" id="figureanchor10-23">Figure 10-23</a>.</p>
<span epub:type="pagebreak" title="245" id="Page_245"/><figure>
<img src="Images/f10023.png" alt="f10023" width="675" height="859"/>
<figcaption><p><a id="figure10-23">Figure 10-23</a>: Viewing the stack in the Chrome debugger</p></figcaption>
</figure>
<h2 id="h1-501737c10-0006">Summary</h2>
<p class="BodyFirst">In this chapter, we debugged WAT code using a variety of different techniques in Chrome and in Firefox. We looked at logging to the console in more depth than we had in earlier chapters. We then used the JavaScript <code>alert</code> function to stop execution and wait for user instruction. We also <span epub:type="pagebreak" title="246" id="Page_246"/>explored using <em>console.trace</em> to log a stack trace and discussed the differences between the way the stack trace works in Chrome and Firefox. Finally, we used the built-in debuggers in Chrome and Firefox. </p>
<p>Many options are available for debugging WebAssembly. Some of the options, such as using the Chrome or Firefox debuggers, are still being developed. Which tools you decide to use will depend on the code and your goal when debugging. In the next chapter, we’ll use WebAssembly to build Node.js modules.</p>
<aside class="endnote" epub:type="rearnote">
</aside>

</section>
</div></body></html>