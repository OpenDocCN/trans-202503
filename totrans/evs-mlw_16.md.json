["```\nOpenProcess(\n  DWORD dwDesiredAccess, // Access rights requested.\n  BOOL bInheritHandle,   // If true, processes created by this process inherit this process's handle.\n  DWORD dwProcessId      // Process ID of the target process\n);\n```", "```\nVirtualAlloc(\n  LPVOID lpAddress,       // Start address of region of memory to be allocated\n  SIZE_T dwSize,          // Size of memory allocation\n  DWORD flAllocationType, // Memory type to be allocated\n  DWORD flProtect         // Memory protection to be assigned to this region\n);\n```", "```\nWriteProcessMemory(\n  HANDLE hProcess,              // Handle of process being written to\n  LPVOID lpBaseAddress,         // Base address where data will be written\n  LPCVOID lpBuffer,             // Contains the data to be written\n  SIZE_T nSize,                 // Size of data to be written\n  SIZE_T lpNumberOfBytesWritten // Optional parameter; pointer to a variable that receives\n                  the number of bytes that were written\n);\n```", "```\nCreateRemoteThread(\n  HANDLE hProcess,                          // Handle to the process in which to create the\n                        thread\n  LPSECURITY_ATTRIBUTES lpThreadAttributes, // Pointer to a security attributes structure;\n                        pertains to security and access control\n  SIZE_T dwStackSize,                       // Initial size of the stack for the new thread\n  LPTHREAD_START_ROUTINE lpStartAddress,    // Starting address of the new thread\n  LPVOID lpParameter,                       // Pointer to a variable that will be passed to\n                        the thread's function\n  DWORD dwCreationFlags,                    // Creation flags for the thread (such as\n                        CREATE_SUSPENDED)\n  LPDWORD lpThreadId                        // Pointer to a variable that receives the new\n                        Thread ID\n);\n```", "```\n`--snip--`\npush ebp\nmov  ebp, esp\nadd  esp, 0FFFFFFF4h\nmov  eax, [ebp+8]\nmov  edx, [eax]\nmov  [ebp-0Ch], edx\nmov  edx, [eax+4]\nmov  [ebp-8], edx\nmov  edx, [eax+8]\nmov  [ebp-4], edx\npush dword ptr [ebp-8]\ncall dword ptr [ebp-0Ch]\n`--snip--`\n```", "```\nWriteProcessMemory(victimProcess, `lpBaseAddress`, maliciousDllName, `nSize`,\n`lpNumberOfBytesWritten`);\nhModule = GetModuleHandle(\"Kernel32.dll\");\nGetProcAddress(`hModule`, \"LoadLibraryA\");\nCreateRemoteThread(victimProcess, `lpThreadAttributes`, `dwStackSize`,\naddressOfLoadLibraryA, maliciousDllName, `dwCreationFlags`, `lpThreadId`);\n```", "```\nC:\\> sdbinst.exe firefox.sdb\n```", "```\nhmod = LoadLibrary(\"evil.dll\");\nlpfn = GetProcAddress(hmod, \"Function_1\");\nidHook = \"WH_MOUSE_LL\";\ndwThreadId = 0;\nHHOOK hook = SetWindowsHookEx(idHook, lpfn, hmod, dwThreadId);\n```", "```\n`--snip--`\nmov  r10, rcx\nmov  eax, 55\ntest byte ptr ds:[7FFE0308], 1\njne  ntdll.7FFC61D3CB65\n`--snip--`\n```", "```\n`--snip--`\njmp  hooked_code ; Jump to hooking code.\nmov  eax, 55\ntest byte ptr ds:[7FFE0308], 1\njne  ntdll.7FFC61D3CB65\n`--snip--`\n```", "```\n`--snip--`\npush address_of_hooked_code ; Push the address of the hooked code to the stack.\nret                         ; Return (jump) to the hooked code.\n`--snip--`\n```"]