- en: '**3**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**A BRIEF INTRODUCTION TO DYNAMIC ANALYSIS**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 2](ch02.xhtml#ch02), you learned advanced static analysis techniques
    to disassemble the assembly code recovered from malware. Although static analysis
    can be an efficient way to gain useful information about malware by studying its
    different components on disk, it doesn’t allow us to observe malware behavior.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn about the basics of dynamic malware analysis.
    Unlike static analysis, which focuses on what malware looks like in file form,
    dynamic analysis consists of running malware in a safe, contained environment
    to see how it behaves. This is like introducing a dangerous bacterial strain into
    a sealed environment to see its effects on other cells.
  prefs: []
  type: TYPE_NORMAL
- en: Using dynamic analysis, we can get around common static analysis hurdles, such
    as packing and obfuscation, as well as gain more direct insight into the purpose
    of a given malware sample. We begin by exploring basic dynamic analysis techniques,
    their relevance to malware data science, and their applications. We use open source
    tools like *[malwr.com](http://malwr.com)* to study examples of dynamic analysis
    in action. Note that this is a condensed survey of the topic and is not intended
    to be comprehensive. For a more complete introduction, check out *Practical Malware
    Analysis* (No Starch Press, 2012).
  prefs: []
  type: TYPE_NORMAL
- en: '**Why Use Dynamic Analysis?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To understand why dynamic analysis matters, let’s consider the problem of packed
    malware. Recall that packing malware refers to compressing or obfuscating a malware’s
    x86 assembly code to hide the malicious nature of the program. A packed malware
    sample unpacks itself when it infects a target machine so that the code can execute.
  prefs: []
  type: TYPE_NORMAL
- en: We could try to disassemble a packed or obfuscated malware sample using the
    static analysis tools discussed in [Chapter 2](ch02.xhtml#ch02), but this is a
    laborious process. For example, with static analysis we’d first have to find the
    location of the obfuscated code in the malware file. Then we’d have to find the
    location of the deobfuscation subroutines that deobfuscate this code so that it
    can run. After locating the subroutines, we’d have to figure out how this deobfuscation
    procedure works in order to perform it on the code. Only then could we begin the
    actual process of reverse engineering the malicious code.
  prefs: []
  type: TYPE_NORMAL
- en: A simple yet clever alternative to this process is to execute the malware in
    a safe, contained environment called a *sandbox*. Running malware in a sandbox
    allows it to unpack itself as it would when infecting a real target. By simply
    running malware, we can find out what servers a particular malware binary connects
    to, what system configuration parameters it changes, and what device I/O (input/output)
    it attempts to perform.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dynamic Analysis for Malware Data Science**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dynamic analysis is useful not only for malware reverse engineering but also
    for malware data science. Because dynamic analysis reveals what a malware sample
    *does*, we can compare its actions to those of other malware samples. For example,
    because dynamic analysis shows what files malware samples write to disk, we can
    use this data to connect those malware samples that write similar filenames to
    disk. These kinds of clues help us categorize malware samples based on common
    traits. They can even help us identify malware samples that were authored by the
    same groups or are part of the same campaigns.
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, dynamic analysis is useful for building machine learning–based
    malware detectors. We can train a detector to distinguish between malicious and
    benign binaries by observing their behaviors during dynamic analysis. For example,
    after observing thousands of dynamic analysis logs from both malware and benign
    files, a machine learning system can learn that when *msword.exe* launches a process
    named *powershell.exe*, this action is malicious, but that when *msword.exe* launches
    Internet Explorer, this is probably harmless. [Chapter 8](ch08.xhtml#ch08) will
    go into more detail about how we can build malware detectors using data based
    on both static and dynamic analysis. But before we create sophisticated malware
    detectors, let’s look at some basic tools for dynamic analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic Tools for Dynamic Analysis**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find a number of free, open source tools for dynamic analysis online.
    This section focuses on *[malwr.com](http://malwr.com)* and CuckooBox. The *[malwr.com](http://malwr.com)*
    site has a web interface that allows you to submit binaries for dynamic analysis
    for free*.* CuckooBox is a software platform that lets you set up your own dynamic
    analysis environment so that you can analyze binaries locally. The creators of
    the CuckooBox platform also operate *[malwr.com](http://malwr.com)*, and *[malwr.com](http://malwr.com)*
    runs CuckooBox behind the scenes. Therefore, learning how to analyze results on
    *[malwr.com](http://malwr.com)* will allow you to understand CuckooBox results.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*At print time,* [malwr.com](http://malwr.com)’*s CuckooBox interface was down
    for maintenance. Hopefully by the time you read this section the site will be
    back up. If not, the information provided in this chapter can be applied to output
    from your own CuckooBox instance, which you can set up by following the instructions
    at* [https://cuckoosandbox.org/](https://cuckoosandbox.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: '***Typical Malware Behaviors***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following are the major categories of actions a malware sample may take
    upon execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modifying the file system** For example, writing a device driver to disk,
    changing system configuration files, adding new programs to the file system, and
    modifying registry keys to ensure the program auto-starts'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modifying the Windows registry to change the system configuration** For example,
    changing firewall settings'
  prefs: []
  type: TYPE_NORMAL
- en: '**Loading device drivers** For example, loading a device driver that records
    user keystrokes'
  prefs: []
  type: TYPE_NORMAL
- en: '**Network actions** For example, resolving domain names and making HTTP requests'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll examine these behaviors in more detail using a malware sample and analyzing
    its report on *[malwr.com](http://malwr.com)*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Loading a File on [malwr.com](http://malwr.com)***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To run a malware sample through *[malwr.com](http://malwr.com)*, navigate to
    *[https://malwr.com/](https://malwr.com/)* and then click the **Submit** button
    to upload and submit a binary for analysis. We’ll use a binary whose SHA256 hash
    starts with the characters *d676d95*, which you can find in the data directory
    accompanying this chapter. I encourage you to submit this binary to *[malwr.com](http://malwr.com)*
    and inspect the results yourself as we go. The submit page is shown in [Figure
    3-1](ch03.xhtml#ch03fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0028-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: The malware sample submission page*'
  prefs: []
  type: TYPE_NORMAL
- en: After you submit your sample through this form, the site should prompt you to
    wait for analysis to complete, which typically takes about five minutes. When
    the results load, you can inspect them to understand what the executable did when
    it was run in the dynamic analysis environment.
  prefs: []
  type: TYPE_NORMAL
- en: '***Analyzing Results on [malwr.com](http://malwr.com)***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The results page for our sample should look something like [Figure 3-2](ch03.xhtml#ch03fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0028-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-2: The top of the results page for a malware sample on* [malwr.com](http://malwr.com)'
  prefs: []
  type: TYPE_NORMAL
- en: The results for this file illustrate some key aspects of dynamic analysis, which
    we’ll explore next.
  prefs: []
  type: TYPE_NORMAL
- en: '**Signatures Panel**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The first two panels you’ll see on the results page are Analysis and File Details.
    These contain the time the file was run and other static details about the file.
    The panel I will focus on here is the Signatures panel, shown in [Figure 3-3](ch03.xhtml#ch03fig3).
    This panel contains high-level information derived from the file itself and its
    behavior when it was run in the dynamic analysis environment. Let’s discuss what
    each of these signatures means.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0029-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-3: The* [malwr.com](http://malwr.com) *signatures that match the
    behavior of our malware sample*'
  prefs: []
  type: TYPE_NORMAL
- en: The first three signatures shown in the figure result from static analysis (that
    is, these are results from the properties of the malware file itself, not its
    actions). The first signature simply tells us that a number of antivirus engines
    on the popular antivirus aggregator *[VirusTotal.com](http://VirusTotal.com)*
    marked this file as malware. The second indicates that the binary contains compressed
    or encrypted data, a common sign of obfuscation. The third tells us that this
    binary was compressed with the popular UPX packer. Although these static indicators
    on their own don’t tell us what this file does, they do tell us that it’s likely
    malicious. (Note that the color doesn’t correspond to static versus dynamic categories;
    instead, it represents the severity of each rule, with red—the darker gray here—being
    more suspicious than yellow.)
  prefs: []
  type: TYPE_NORMAL
- en: The next three signatures result from dynamic analysis of the file. The first
    signature indicates that the program attempts to identify the system’s hardware
    and operating system. The second indicates that the program uses a pernicious
    feature of Windows known as *Alternate Data Streams (ADS)*, which allows malware
    to hide data on disk such that it’s invisible when using standard file system
    browsing tools. The third signature indicates that the file changes the Windows
    registry so that when the system reboots, a program that it specified will automatically
    execute. This would restart the malware whenever the user reboots their system.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, even at the level of these automatically triggered signatures,
    dynamic analysis adds significantly to our knowledge of the file’s intended behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '**Screenshots Panel**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Beneath the Signatures panel is the Screenshots panel. This panel shows a screenshot
    of the dynamic analysis environment desktop as the malware is running. [Figure
    3-4](ch03.xhtml#ch03fig4) shows an example of what this looks like.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0030-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-4: A screen capture of our malware sample’s dynamic behavior*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the malware we’re dealing with is *ransomware*, which is a
    type of malware that encrypts a target’s files and forces them to pay up if they
    want to get their data back. By simply running our malware, we were able to uncover
    its purpose without resorting to reverse engineering.
  prefs: []
  type: TYPE_NORMAL
- en: '**Modified System Objects Panel**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A row of headings under Screenshots shows the malware sample’s network activity.
    Our binary did not engage in any network communications, but if it had, we would
    see the hosts it contacted here. [Figure 3-5](ch03.xhtml#ch03fig5) shows the Summary
    panel.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0031-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-5: The Files tab of the Summary pane, showing which files our malware
    sample modified*'
  prefs: []
  type: TYPE_NORMAL
- en: This shows which system objects, like files, registry keys, and mutexes, the
    malware has modified.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the Files tab in [Figure 3-6](ch03.xhtml#ch03fig6), it’s clear that
    this ransomware malware has indeed encrypted the user files on disk.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0031-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-6: File paths in the Files tab of the Summary pane, suggesting that
    our sample is ransomware*'
  prefs: []
  type: TYPE_NORMAL
- en: After each file path is a file with a *.locked* extension, which we can infer
    is the encrypted version of the file it has replaced.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at the Registry Keys tab, shown in [Figure 3-7](ch03.xhtml#ch03fig7).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0031-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-7: The Registry Keys tab of the Summary pane, showing which registry
    keys our malware sample modified*'
  prefs: []
  type: TYPE_NORMAL
- en: The registry is a database that Windows uses to store configuration information.
    Configuration parameters are stored as registry keys, and these keys have associated
    values. Similar to file paths on the Windows file system, registry keys are backslash
    delimited. *[Malwr.com](http://Malwr.com)* shows us what registry keys our malware
    modified. Although this isn’t shown in [Figure 3-7](ch03.xhtml#ch03fig7), if you
    view the complete report on *[malwr.com](http://malwr.com)*, you should see that
    one notable registry key our malware changed is `HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run`,
    which is a registry key that tells Windows to run programs each time a user logs
    on. It’s very likely that our malware modifies this registry to tell Windows to
    restart the malware every time the system boots up, which ensures that the malware
    infection persists from reboot to reboot.
  prefs: []
  type: TYPE_NORMAL
- en: The Mutexes tab in the *[malwr.com](http://malwr.com)* report contains the names
    of the mutexes the malware created, as shown in [Figure 3-8](ch03.xhtml#ch03fig8).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0032-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-8: The Mutexes tab of the Summary pane, showing which mutexes our
    malware sample created*'
  prefs: []
  type: TYPE_NORMAL
- en: Mutexes are lock files that signal that a program has taken possession of some
    resource. Malware often uses mutexes to prevent itself from infecting a system
    twice. It turns out that at least one mutex created (*CTF.TimListCache.FMPDefaultS-1-5-21-1547161642-507921405-839522115-1004MUTEX.DefaultS-1-5-21-1547161642-507921405-839522115-1004
    ShimCacheMutex*) is known by the security community to be associated with malware
    and may be serving this purpose here.
  prefs: []
  type: TYPE_NORMAL
- en: '**API Call Analysis**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Clicking the Behavioral Analysis tab on the left panel of the *[malwr.com](http://malwr.com)*
    UI, as shown in [Figure 3-9](ch03.xhtml#ch03fig9), should bring up detailed information
    about our malware binary’s behavior.
  prefs: []
  type: TYPE_NORMAL
- en: This shows what API calls were made by each process launched by the malware,
    along with their arguments and return values. Perusing this information is time
    consuming and requires expert knowledge of Windows APIs. Although a detailed discussion
    of malware API call analysis is beyond the scope of this book, if you’re interested
    in learning more, you can look up individual API calls to discover their effects.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0033-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-9: The Behavioral Analysis pane of the* [malwr.com](http://malwr.com)
    *report for our malware sample, showing when API calls were made during the dynamic
    execution*'
  prefs: []
  type: TYPE_NORMAL
- en: Although *[malwr.com](http://malwr.com)* is a great resource for dynamically
    analyzing individual malware samples, it isn’t great for performing dynamic analysis
    on large numbers of samples. Executing large numbers of samples in a dynamic environment
    is important for machine learning and data analysis because it identifies relationships
    between malware samples’ dynamic execution patterns. Creating machine learning
    systems that can detect instances of malware based on their dynamic execution
    patterns requires running thousands of malware samples.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this limitation, *[malwr.com](http://malwr.com)* doesn’t provide
    malware analysis results in machine-parseable formats like XML or JSON. To address
    these issues you must set up and run your own CuckooBox. Fortunately, CuckooBox
    is free and open source. It also comes with step-by-step instructions for setting
    up your very own dynamic analysis environment. I encourage you to do so by going
    to *[http://cuckoosandbox.org/](http://cuckoosandbox.org/)*. Now that you understand
    how to interpret dynamic malware results from *[malwr.com](http://malwr.com)*,
    which uses CuckooBox behind the scenes, you’ll also know how to analyze CuckooBox
    results once you have CuckooBox up and running.
  prefs: []
  type: TYPE_NORMAL
- en: '**Limitations of Basic Dynamic Analysis**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dynamic analysis is a powerful tool, but it is no malware analysis panacea.
    In fact, it has serious limitations. One limitation is that malware authors are
    aware of CuckooBox and other dynamic analysis frameworks and attempt to circumvent
    them by making their malware fail to execute when it detects that it’s running
    in CuckooBox. The CuckooBox maintainers are aware that malware authors try to
    do this, so they try to get around attempts by malware to circumvent CuckooBox.
    This cat-and-mouse game plays out continuously such that some malware samples
    will inevitably detect that they are running in dynamic analysis environments
    and fail to execute when we try to run them.
  prefs: []
  type: TYPE_NORMAL
- en: Another limitation is that even without any circumvention attempts, dynamic
    analysis might not reveal important malware behaviors. Consider the case of a
    malware binary that connects back to a remote server upon execution and waits
    for commands to be issued. These commands may, for example, tell the malware sample
    to look for certain kinds of files on the victim host, to log keystrokes, or turn
    on the webcam. In this case, if the remote server sends no commands, or is no
    longer up, none of these malicious behaviors will be revealed. Because of these
    limitations, dynamic analysis is not a fix-all for malware analysis. In fact,
    professional malware analysts combine dynamic and static analysis to achieve the
    best possible results.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you ran dynamic analysis on a ransomware malware sample with
    *[malwr.com](http://malwr.com)* to analyze the results. You also learned about
    the advantages and shortcomings of dynamic analysis. Now that you’ve learned how
    to conduct basic dynamic analysis, you’re ready to dive into malware data science.
  prefs: []
  type: TYPE_NORMAL
- en: The remainder of this book focuses on performing malware data science on static
    analysis–based malware data. I’ll focus on static analysis because it’s simpler
    and easier to get good results with compared to dynamic analysis, making it a
    good starting place for getting your hands dirty with malware data science. However,
    in each subsequent chapter I’ll also explain how you can apply data science methods
    to dynamic analysis–based data.
  prefs: []
  type: TYPE_NORMAL
