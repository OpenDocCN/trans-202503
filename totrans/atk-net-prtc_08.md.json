["```\n$ tshark -i INTNAME -w capture.pcap tcp port 12345\n```", "```\n$ tshark -r capture.pcap -z conv,tcp\n ➊ 1 0 192.168.56.1 → 192.168.56.100 TCP 66 26082 → 12345 [SYN]\n    2 0.000037695 192.168.56.100 → 192.168.56.1 TCP 66 12345 → 26082 [SYN, ACK]\n    3 0.000239814 192.168.56.1 → 192.168.56.100 TCP 60 26082 → 12345 [ACK]\n    4 0.007160883 192.168.56.1 → 192.168.56.100 TCP 60 26082 → 12345 [PSH, ACK]\n    5 0.007225155 192.168.56.100 → 192.168.56.1 TCP 54 12345 → 26082 [ACK]\n--snip--\n ================================================================================\nTCP Conversations\nFilter:<No Filter>\n                                              |       <-      | |       ->      |\n                                              | Frames  Bytes | | Frames  Bytes |\n192.168.56.1:26082 <-> 192.168.56.100:12345➋   17      1020➌     28      1733➍\n================================================================================\n```", "```\n$ tshark -r capture.pcap -T fields -e data 'tcp.srcport==26082' > outbound.txt\n```", "```\n$ cat outbound.txt\n42494e58\n0000000d\n00000347\n00\n057573657231044f4e595800\n--snip--\n```", "```\n $ xxd -p -r outbound.txt > outbound.bin\n$ xxd outbound.bin\n00000000: 4249 4e58 0000 000d 0000 0347 0005 7573  BINX.......G..us\n00000010: 6572 3104 4f4e 5958 0000 0000 1c00 0009  er1.ONYX........\n00000020: 7b03 0575 7365 7231 1462 6164 6765 7220  {..user1.badger\n--snip--\n```", "```\n$ netcat HOSTNAME 12345 < outbound.bin > inbound.bin\n```", "```\n$ netcat -l 12345 < inbound.bin > new_outbound.bin\n```", "```\ntshark -i INTNAME -w udp_capture.pcap udp port 12345\n```", "```\ntshark -T fields -e data -r udp_capture.pcap --disable-protocol gvsp/\n  \"udp.dstport==12345\" > udp_outbound.txt\n```", "```\nimport sys\nimport binascii\nfrom socket import socket, AF_INET, SOCK_DGRAM\n\nif len(sys.argv) < 3:\n    print(\"Specify destination host and port\")\n    exit(1)\n\n# Create a UDP socket with a 1sec receive timeout\nsock = socket(AF_INET, SOCK_DGRAM)\nsock.settimeout(1)\naddr = (sys.argv[1], int(sys.argv[2]))\n\nfor line in sys.stdin:\n    msg = binascii.a2b_hex(line.strip())\n    sock.sendto(msg, addr)\n\n    try:\n        data, server = sock.recvfrom(1024)\n        print(binascii.b2a_hex(data))\n    except:\n        pass\n```", "```\npython udp_client.py HOSTNAME 12345 < udp_outbound.txt\n```", "```\n   #load \"parser.csx\"\n   using static System.Console;\n   using static CANAPE.Cli.ConsoleUtils;\n\n   var template = new FixedProxyTemplate();\n   // Local port of 4444, destination 127.0.0.1:12345\n   template.LocalPort = 4444;\n   template.Host = \"127.0.0.1\";\n   template.Port = 12345;\n➊ template.AddLayer<Parser>();\n\n   var service = template.Create();\n   service.Start();\n   WriteLine(\"Created {0}\", service);\n   WriteLine(\"Press Enter to exit...\");\n   ReadLine();\n   service.Stop();\n\n   WriteLine(\"Writing Outbound Packets to packets.bin\");\n➋ service.Packets.WriteToFile(\"packets.bin\", \"Out\");\n```", "```\n   #load \"parser.csx\"\n\n   using static System.Console;\n   using static CANAPE.Cli.ConsoleUtils;\n\n➊ if (args.Length < 1) {\n       WriteLine(\"Please Specify a Capture File\");\n       return;\n   }\n➋ var template = new NetClientTemplate();\n   template.Port = 12345;\n   template.Host = \"127.0.0.1\";\n   template.AddLayer<Parser>();\n➌ template.InitialData = new byte[] { 0x42, 0x49, 0x4E, 0x58 };\n\n➍ var packets = LogPacketCollection.ReadFromFile(args[0]);\n\n➎ using(var adapter = template.Connect()) {\n       WriteLine(\"Connected\");\n       // Write packets to adapter\n    ➏ foreach(var packet in packets.GetPacketsForTag(\"Out\")) {\n           adapter.Write(packet.Frame);\n       }\n\n       // Set a 1000ms timeout on read so we disconnect\n       adapter.ReadTimeout = 1000;\n    ➐ DataFrame frame = adapter.Read();\n       while(frame != null) {\n           WritePacket(frame);\n           frame = adapter.Read();\n       }\n   }\n```", "```\n➊ string data = packet.Frame.ToDataString();\n➋ data = data.Replace(\"\\u0005user1\", \"\\u0008bobsmith\");\n   adapter.Write(data.ToDataFrame());\n```", "```\n   using CANAPE.Nodes;\n   using CANAPE.DataAdapters;\n   using CANAPE.Net.Templates;\n\n➊ class ChatServerConfig {\n       public LogPacketCollection Packets { get; private set; }\n       public ChatServerConfig() {\n           Packets = new LogPacketCollection();\n       }\n   }\n\n➋ class ChatServer : BaseDataEndpoint<ChatServerConfig> {\n       public override void Run(IDataAdapter adapter, ChatServerConfig config) {\n           Console.WriteLine(\"New Connection\");\n        ➌ DataFrame frame = adapter.Read();\n           // Wait for the client to send us the first packet\n           if (frame != null) {\n // Write all packets to client\n            ➍ foreach(var packet in config.Packets) {\n                   adapter.Write(packet.Frame);\n               }\n           }\n           frame = adapter.Read();\n       }\n   }\n```", "```\n➊ #load \"chat_server.csx\"\n   #load \"parser.csx\"\n   using static System.Console;\n\n   if (args.Length < 1) {\n       WriteLine(\"Please Specify a Capture File\");\n       return;\n   }\n➋ var template = new NetServerTemplate<ChatServer, ChatServerConfig>();\n   template.LocalPort = 12345;\n   template.AddLayer<Parser>();\n➌ var packets = LogPacketCollection.ReadFromFile(args[0])\n                                    .GetPacketsForTag(\"In\");\n   template.ServerFactoryConfig.Packets.AddRange(packets);\n\n➍ var service = template.Create();\n   service.Start();\n   WriteLine(\"Created {0}\", service);\n   WriteLine(\"Press Enter to exit...\");\n   ReadLine();\n   service.Stop();\n```", "```\n➊ public class PublicClass\n   {\n     private class PrivateClass\n     {\n    ➋ public PrivatePublicMethod() {}\n     }\n     internal class InternalClass\n     {\n    ➌ public void InternalPublicMethod() {}\n     }\n     private void PrivateMethod() {}\n     internal void InternalMethod() {}\n   ➍ public void PublicMethod() {}\n   }\n```", "```\nAssembly asm = Assembly.LoadFrom(@\"c:\\path\\to\\assembly.exe\");\nType type = asm.GetType(\"ChatProgram.Connection\");\n```", "```\ninternal class Connection\n{\n  internal Connection() {}\n\n  public void Connect(string hostname)\n  {\n    Connect(hostname, 12345);\n  }\n\n  private void Connect(string hostname, int port)\n  {\n    // Implementation...\n  }\n\n  public void Send(byte[] packet)\n  {\n    // Implementation...\n  }\n\n  public void Send(string packet)\n  {\n    // Implementation...\n  }\n\n  public byte[] Receive()\n  {\n    // Implementation...\n  }\n}\n```", "```\nType type = asm.GetType(\"ChatProgram.Connection\");\nobject conn = Activator.CreateInstance(type, true);\n```", "```\nMethodInfo connect_method = type.GetMethod(\"Connect\");\nconnect_method.Invoke(conn, new object[] { \"host.badgers.com\" });\n```", "```\nMethodInfo connect_method = type.GetMethod(\"Connect\",\n                                   BindingFlags.NonPublic | BindingFlags.Instance);\nconnect_method.Invoke(conn, new object[] { \"host.badgers.com\", 9999 });\n```", "```\nSystem.Reflection.AmbiguousMatchException: Ambiguous match found.\n   at System.RuntimeType.GetMethodImpl(...)\n at System.Type.GetMethod(String name)\n   at Program.Main(String[] args)\n```", "```\nMethodInfo send_method = type.GetMethod(\"Send\", new Type[] { typeof(string) });\nsend_method.Invoke(conn, new object[] { \"data\" });\n```", "```\nMethodInfo recv_method = type.GetMethod(\"Receive\");\nbyte[] packet = (byte[])recv_method.Invoke(conn, null);\n```", "```\n // Package-private (PackageClass.java)\npackage com.example;\n\nclass PackageClass {\n    PackageClass() {\n    }\n\n    PackageClass(String arg) {\n    }\n\n    @Override\n    public String toString() {\n        return \"In Package\";\n    }\n}\n\n// Bridge class (BridgeClass.java)\npackage com.example;\n\npublic class BridgeClass {\n    public static Object create() {\n        return new PackageClass();\n    }\n}\n```", "```\n Class c = Class.forName(\"com.example.PackageClass\");\nSystem.out.println(c);\n```", "```\n   Constructor con = c.getDeclaredConstructor(String.class);\n➊ con.setAccessible(true);\n   Object obj = con.newInstance(\"Hello\");\n```", "```\n#include <stdio.h>\n#include <wchar.h>\n\nvoid say_hello(void) {\n  printf(\"Hello\\n\");\n}\n\nvoid say_string(const char* str) {\n  printf(\"%s\\n\", str);\n}\n\nvoid say_unicode_string(const wchar_t* ustr) {\n  printf(\"%ls\\n\", ustr);\n}\n\nconst char* get_hello(void) {\n  return \"Hello from C\";\n}\n\nint add_numbers(int a, int b) {\n  return a + b;\n}\n\nlong add_longs(long a, long b) {\n  return a + b;\n}\n\nvoid add_numbers_result(int a, int b, int* c) {\n  *c = a + b;\n}\n\nstruct SimpleStruct\n{\n  const char* str;\n  int num;\n};\n\nvoid say_struct(const struct SimpleStruct* s) {\n  printf(\"%s %d\\n\", s->str, s->num);\n}\n```", "```\ngcc -shared -fPIC -o lib.so lib.c\n```", "```\nfrom ctypes import *\n\n# On Linux\nlib = cdll.LoadLibrary(\"./lib.so\")\n# On macOS\n#lib = cdll.LoadLibrary(\"lib.dylib\")\n# On Windows\n#lib = cdll.LoadLibrary(\"lib.dll\")\n# Or we can do the following on Windows\n#lib = cdll.lib\n\nlib.say_hello()\n>>> Hello\n```", "```\nprint lib.add_numbers(1, 2)\n>>> 3\n lib.say_string(\"Hello from Python\");\n>>> Hello from Python\n```", "```\n# Before setting return type\nprint lib.get_hello()\n>>> -1686370079\n\n# After setting return type\nlib.get_hello.restype = c_char_p\nprint lib.get_hello()\n>>> Hello from C\n```", "```\n# Before argtypes\nlib.add_longs.restype = c_long\nprint lib.add_longs(0x100000000, 1)\n>>> 1\n\n# After argtypes\nlib.add_longs.argtypes = [c_long, c_long]\n print lib.add_longs(0x100000000, 1)\n>>> 4294967297\n```", "```\ni = c_int()\nlib.add_numbers_result(1, 2, byref(i))\nprint i.value\n>>> 3\n```", "```\nclass SimpleStruct(Structure):\n  _fields_ = [(\"str\", c_char_p),\n              (\"num\", c_int)]\n\ns = SimpleStruct()\ns.str = \"Hello from Struct\"\ns.num = 100\nlib.say_struct(byref(s))\n>>> Hello from Struct 100\n```", "```\n$ ChatServer  --server_cert ChatServer/server.pfx\nChatServer (c) 2017 James Forshaw\nWARNING: Don't use this for a real chat system!!!\nLoaded certificate, Subject=CN=ExampleChatServer➊\nRunning server on port 12345 Global Bind False\nRunning TLS server on port 12346➋ Global Bind False\n```", "```\n   $ ChatClient -–tls user1 127.0.0.1\n   Connecting to 127.0.0.1:12346\n➊ TLS Protocol: TLS v1.2\n➋ TLS KeyEx   : RsaKeyX\n➌ TLS Cipher  : Aes256\n➍ TLS Hash    : Sha384\n➎ Cert Subject: CN=ExampleChatServer\n➏ Cert Issuer : CN=ExampleChatServer\n```", "```\n   var template = new FixedProxyTemplate();\n   // Local port of 4445, destination 127.0.0.1:12346\n➊ template.LocalPort = 4445;\n   template.Host = \"127.0.0.1\";\n   template.Port = 12346;\n\n   var tls = new TlsNetworkLayerFactory();\n➋ template.AddLayer(tls);\n   template.AddLayer<Parser>();\n```", "```\n   C:\\> ChatClient user1 127.0.0.1 --port 4444 -l\n   Connecting to 127.0.0.1:4445\n➊ TLS Protocol: TLS v1.0\n➋ TLS KeyEx   : ECDH\n   TLS Cipher  : Aes256\n   TLS Hash    : Sha1\n   Cert Subject: CN=ExampleChatServer\n➌ Cert Issuer : CN=BrokenCA_PleaseFix\n```", "```\ntls.Config.ServerProtocol = System.Security.Authentication.SslProtocols.Tls12;\n```", "```\nusing System.IO;\n\n// Generate a 4096 bit RSA key with SHA512 hash\nvar ca = CertificateUtils.GenerateCACert(\"CN=MyTestCA\",\n    4096, CertificateHashAlgorithm.Sha512);\n// Export to PFX with no password\nFile.WriteAllBytes(\"ca.pfx\", ca.ExportToPFX());\n // Export public certificate to a PEM file\nFile.WriteAllText(\"ca.crt\", ca.ExportToPEM());\n```", "```\nCertificateManager.SetRootCert(\"ca.pfx\");\n```", "```\nSSL Policy Errors: RemoteCertificateNameMismatch\nError: The remote certificate is invalid according to the validation procedure.\n```", "```\ntls.Config.SpecifyServerCert = true;\ntls.Config.ServerCertificateSubject = \"CN=127.0.0.1\";\n```"]