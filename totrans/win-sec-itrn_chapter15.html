<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" xml:lang="en" lang="en">
<head>
<title>15. Negotiate Authentication and Other Security Packages</title>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="sbo-rt-content"><section aria-labelledby="ch15" epub:type="chapter" role="doc-chapter">
<hgroup>
<h2 class="CHAPTER" id="ch15">
<span class="CN"><span aria-label=" Page 499. " epub:type="pagebreak" id="pg_499" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">15</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">NEGOTIATE AUTHENTICATION AND OTHER SECURITY PACKAGES</samp></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener" height="386" src="../images/chapter.jpg" width="386"/></figure>
<p class="ChapterIntro">The two previous chapters covered the two main network authentication protocols in Windows, NTLM and Kerberos. However, Windows supports several more packages for performing authentication. In this chapter, we’ll briefly cover some of these other security packages.</p>
<p class="TX">I’ll begin by providing more detail about how applications and security packages can use buffers to pass data back and forth using the SSPI APIs. This will help you understand some of the packages’ quirks. Then we’ll examine the Negotiate security package, as well as the less common secure channel and CredSSP packages. I’ll give a quick overview of some additional configuration options you have when setting up a network authentication context and finish up with a description of what happens when you want to use network authentication inside a process with a lowbox token.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="H1" id="sec1"><span id="h1-111"></span><span aria-label=" Page 500. " epub:type="pagebreak" id="pg_500" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_B_11">Security Buffers</samp></h3>
<p class="TNI1">So far, I’ve implied that using the SSPI APIs is simple: you generate a client authentication token, pass it to the server application, update the server authentication context, receive a token in response, and repeat the process until the authentication is complete. However, because of the complexity of the supported network authentication protocols, these APIs can accept and return more than just an authentication token.</p>
<p class="TX">The authentication context, encryption, and signature APIs accept arrays of generic <i>security buffer</i> structures as parameters. This security buffer structure, called <samp class="SANS_TheSansMonoCd_W5Regular_11">SecBuffer</samp> in the native SDK, is wrapped by the <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityBuffer</samp> class in the PowerShell module. Each security buffer structure contains a field that determines what type of data the buffer represents and a sized memory buffer for the contents. You can create a buffer using the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaSecurityBuffer</samp> PowerShell command, specifying the type and contents of the buffer:</p>
<pre><code>PS&gt; <b>$buf = New-LsaSecurityBuffer -Type Data -Byte @(0, 1, 2, 3)</b>
</code></pre>
<p class="TX">You can specify either a byte array or a string when initializing the data. You also specify a type for the buffer. The following is a short list of the most important buffer types you’ll encounter:</p>
<p class="RunInPara1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Empty  </samp>Contains no data; sometimes used as a placeholder for a return value</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Data  </samp>Contains initialized data; used to pass and return data, such as a message to encrypt</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Token  </samp>Contains a token; used to pass and return authentication tokens and signatures</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">PkgParams  </samp>Contains additional configuration parameters for the security package</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">StreamHeader  </samp>Contains the header of a streaming protocol</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">StreamTrailer  </samp>Contains the trailer of a streaming protocol</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Stream  </samp>Contains the data of a streaming protocol</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Extra  </samp>Contains extra data generated by the security package</p>
<p class="RunInPara2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">ChannelBindings  </samp>Contains the channel binding data</p>
<p class="TX">You can use security buffers as either input or output, depending on the security package’s requirements and the API used. If you want to define an output-only buffer, you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Size</samp> parameter when creating the buffer:</p>
<pre><code>PS&gt; <b>$buf = New-LsaSecurityBuffer -Type Data -Size 1000</b>
</code></pre>
<p class="TX">Sometimes you may want to pass an initialized buffer whose contents the package shouldn’t modify. To indicate this, the APIs specify two additional flags you can add to the type:</p>
<p class="RunInPara1"><span aria-label=" Page 501. " epub:type="pagebreak" id="pg_501" role="doc-pagebreak"></span><samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadOnly  </samp>The buffer is read-only but is not part of the signature.</p>
<p class="RunInPara2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadOnlyWithChecksum  </samp>The buffer is read-only and should be part of the signature.</p>
<p class="TX">You specify these additional flags using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadOnly</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadOnlyWithChecksum</samp> parameter when creating a buffer, as in the following example:</p>
<pre><code>PS&gt; <b>$buf = New-LsaSecurityBuffer -Type Data -Byte @(0, 1, 2, 3) -ReadOnly</b>
</code></pre>
<p class="TX">Whether the difference between the two read-only flags is honored depends on the security package. For example, NTLM ignores the difference and always adds a read-only buffer to the signature, while Kerberos adds the buffer as part of the signature only if the buffer you supply has the <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadOnlyWithChecksum</samp> flag.</p>
<section aria-labelledby="sec2" epub:type="division">
<h4 class="H2" id="sec2"><span id="h2-159"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Buffers with an Authentication Context</samp></h4>
<p class="TNI1">The SSPI APIs used by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Update-LsaClientContext</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Update-LsaServerContext</samp> PowerShell commands take two lists of security buffers: one to use as input to the API and one to use as output. You can specify the list of these buffers using the <samp class="SANS_TheSansMonoCd_W5Regular_11">InputBuffer</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">OutputBuffer</samp> parameters, as shown in <a href="chapter15.xhtml#Lis15-1">Listing 15-1</a>.</p>
<span id="Lis15-1"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$in_buf = New-LsaSecurityBuffer -Type PkgParams -String "AuthParam"</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>$out_buf = New-LsaSecurityBuffer -Type Data -Size 100</b>
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>Update-LsaClientContext -Client $client -Token $token -InputBuffer $in_buf</b>
<b>-OutputBuffer $out_buf</b>
PS&gt;<b> $out_buf.Type</b>
Extra

PS&gt; <b>ConvertFrom-LsaSecurityBuffer $out_buf | Out-HexDump</b>
00 11 22 33
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 15-1: Using input and output buffers with an authentication context</span></p>
<p class="TX">This listing shows a hypothetical use of input and output buffers during authentication. (You’ll see actual examples over the course of this chapter.) This example assumes you’ve already set up a client authentication context as <samp class="SANS_TheSansMonoCd_W5Regular_11">$client</samp> and a server authentication token as <samp class="SANS_TheSansMonoCd_W5Regular_11">$token</samp>.</p>
<p class="TX">We first create one input buffer of type <samp class="SANS_TheSansMonoCd_W5Regular_11">PkgParams</samp> containing a string <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. The contents of the buffer depend on the package you’re using; normally, the API’s documentation will tell you what you need to specify. Next, we create an output buffer of type <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>, allocating a maximum buffer size of 100 bytes <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. We then update the client context, passing it the server authentication token and the input and output buffers <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>.</p>
<p class="TX">The command will add the token as a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> type buffer to the start of the input list, and will also append any channel bindings specified when creating the context. Therefore, the input buffer list passed in this case would contain the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> buffer followed by the <samp class="SANS_TheSansMonoCd_W5Regular_11">PkgParams</samp> buffer. Sometimes <span aria-label=" Page 502. " epub:type="pagebreak" id="pg_502" role="doc-pagebreak"></span>the package doesn’t want you to include the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> buffer; in that case, you can specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">NoToken</samp> parameter to exclude it from the input list.</p>
<p class="TX">The command also automatically adds the output <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> buffer for the new authentication token to the output list. If the API call succeeds, it will assign the contents of this buffer to the context’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> property. It’s not normally necessary to exclude that buffer from the output, so the command doesn’t give you that option.</p>
<p class="TX">After a successful call, we check the output buffer, which has been updated. Certain packages might change an output buffer’s type, size, and contents. For instance, the type in this example has been changed from <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">Extra</samp>. We can convert the buffer back to a byte array using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ConvertFrom-LsaSecurityBuffer</samp> command. Displaying the output shows that the 100-byte buffer we’ve created now has only 4 valid bytes. The security package initialized these 4 bytes and updated the structure’s length accordingly.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h4 class="H2" id="sec3"><span id="h2-160"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Buffers with Signing and Sealing</samp></h4>
<p class="TNI1">Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Buffer</samp> parameter, you can specify buffers during signing and sealing operations when calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaContextSignature</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-LsaContextSignature</samp> PowerShell commands, as well as <samp class="SANS_TheSansMonoCd_W5Regular_11">Protect-LsaContextMessage</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Unprotect-LsaContextMessage</samp>. The underlying APIs take only a single list of buffers to use for both the input and output. In <a href="chapter15.xhtml#Lis15-2">Listing 15-2</a>, we encrypt a buffer containing an additional header.</p>
<span id="Lis15-2"></span><pre><code>PS&gt; <b>$header = New-LsaSecurityBuffer -Type Data -Byte @(0, 1, 3, 4)</b>
<b>-ReadOnlyWithChecksum</b>
PS&gt; <b>$data = New-LsaSecurityBuffer -Type Data -String "HELLO"</b>
PS&gt; <b>$sig = Protect-LsaContextMessage -Context $client -Buffer $header, $data</b>
PS&gt; <b>ConvertFrom-LsaSecurityBuffer -Buffer $header | Out-HexDump</b>
00 01 03 04

PS&gt; <b>ConvertFrom-LsaSecurityBuffer -Buffer $data | Out-HexDump</b>
D5 05 4F 40 22 5A 9F F9 49 66

PS&gt; <b>Unprotect-LsaContextMessage -Context $server -Buffer $header, $data</b>
<b>-Signature $sig</b>
PS&gt; <b>ConvertFrom-LsaSecurityBuffer -Buffer $data -AsString</b>
HELLO
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 15-2: Encrypting a message with buffers</span></p>
<p class="TX">We first create the header buffer, marking it as read-only with a checksum. By marking it as read-only, we ensure that the contents won’t be encrypted but will still be included in the signature. Next, we create the data buffer from a string.</p>
<p class="TX">We then pass the buffers to <samp class="SANS_TheSansMonoCd_W5Regular_11">Protect-LsaContextMessage</samp>. This command returns the signature for the encryption operation and updates the encrypted data in place. When dumping the buffers, we can see that the header is still unencrypted even though the data buffer has been encrypted.</p>
<p class="TX"><span aria-label=" Page 503. " epub:type="pagebreak" id="pg_503" role="doc-pagebreak"></span>We can decrypt the buffer using <samp class="SANS_TheSansMonoCd_W5Regular_11">Unprotect-LsaContextMessage</samp> in a manner similar to how we encrypted the buffer: by passing the buffers and the signature to the command. Once the buffer is decrypted, we can convert it back to a string. If the signature for the buffers isn’t valid, the command will throw an error.</p>
<p class="TX">Now that you know how to use security buffers for the SSPI APIs, let’s look at the Negotiate protocol, which allows Windows to automatically select the best authentication protocol to use based on what credentials are available to the caller.</p>
</section>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h3 class="H1" id="sec4"><span id="h1-112"></span><samp class="SANS_Futura_Std_Bold_B_11">The Negotiate Protocol</samp></h3>
<p class="TNI1">What happens if you don’t know what types of network authentication the server supports? You might first try using Kerberos and then, if it isn’t supported, switch to NTLM. But that’s not a very efficient use of resources. Also, if Microsoft were to later introduce a new, more secure authentication protocol, you’d have to update your application to support it. The <i>Negotiate</i> protocol solves both problems by allowing a client and server to negotiate the best available network authentication protocol. Microsoft’s implementation of Negotiate is based on the <i>Simple and Protected Negotiation Mechanism (SPNEGO)</i> protocol, defined in RFC4178.</p>
<p class="TX">To select the Negotiate protocol, use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Negotiate</samp> package in both the client and the server authentication context. The first token generated by a client authentication context contains a list of the authentication protocols the client supports. In its ASN.1 structure, it can also embed the first authentication token for whichever of the supported authentication protocols the client would prefer to use. For example, it might embed an <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM NEGOTIATE</samp> token. In <a href="chapter15.xhtml#Lis15-3">Listing 15-3</a>, we initialize the Negotiate client authentication context.</p>
<span id="Lis15-3"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$credout = New-LsaCredentialHandle -Package "Negotiate" -UseFlag Outbound</b>
PS&gt; <b>$client = New-LsaClientContext -CredHandle $credout</b>
PS&gt; <b>Format-LsaAuthToken -Token $client.Token</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> &lt;SPNEGO Init&gt;
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> Mechanism List    :
1.3.6.1.4.1.311.2.2.10         - NTLM
1.2.840.48018.1.2.2            - Microsoft Kerberos
1.2.840.113554.1.2.2           - Kerberos
1.3.6.1.4.1.311.2.2.30         - Microsoft Negotiate Extended
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> &lt;SPNEGO Token&gt;
&lt;NTLM NEGOTIATE&gt;
Flags: Unicode, Oem, RequestTarget, Signing, LMKey, NTLM,...
Domain: MINERAL
Workstation: GRAPHITE
Version: 10.0.18362.15
&lt;/SPNEGO Token&gt;
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 15-3: Initializing the Negotiate client authentication</span></p>
<p class="TX"><span aria-label=" Page 504. " epub:type="pagebreak" id="pg_504" role="doc-pagebreak"></span>We specify the credentials for using the Negotiate security package <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, then continue as normal by creating the context. In the formatted token, we first see <samp class="SANS_TheSansMonoCd_W5Regular_11">SPNEGO Init</samp>, which indicates that this is an initialization token <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. Following the header is the list of supported authentication protocols, or <i>security mechanisms</i> <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. The list is sorted in descending order of preference, so in this case, the client prefers NTLM over Kerberos. You won’t see Kerberos in the list unless you’re on a domain-joined system.</p>
<p class="TX">You might notice the mechanism list contains two types of Kerberos. The presence of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Microsoft Kerberos</samp> identifier is due to a bug in Windows 2000: the value <samp class="SANS_TheSansMonoCd_W5Regular_11">113554</samp> in the identifier, or <samp class="SANS_TheSansMonoCd_W5Regular_11">0x1BB92</samp> in hexadecimal, was truncated to 16 bits, resulting in the value <samp class="SANS_TheSansMonoCd_W5Regular_11">0xBB92</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">48018</samp>. Microsoft has left this mistake for backward compatibility reasons, and the two values represent the same Kerberos authentication protocol. Microsoft also defines an extended negotiation protocol, the fourth mechanism in this list, but we won’t discuss it here.</p>
<p class="TX">Following the list of supported protocols is an authentication token <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. In this case, the client has chosen to send the initial <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM NEGOTIATE</samp> token.</p>
<p class="TX">The server authentication context can select the most appropriate authentication protocol it supports. Most commonly, it will use the protocol that is the client’s preferred choice, determined by the ordering of the list of supported authentication protocols. However, it can also ignore the client’s preference and request a different authentication protocol if desired. It sends the selected authentication protocol and any further authentication tokens to the client. This authentication exchange process continues until either an error occurs or the process is complete. <a href="chapter15.xhtml#Lis15-4">Listing 15-4</a> shows how the server responds to the client’s request.</p>
<span id="Lis15-4"></span><pre><code>PS&gt; <b>$credin = New-LsaCredentialHandle -Package "Negotiate" -UseFlag Inbound</b>
PS&gt; <b>$server = New-LsaServerContext -CredHandle $credin</b>
PS&gt; <b>Update-LsaServerContext -Server $server -Token $client.Token</b>
PS&gt; <b>Format-LsaAuthToken -Token $server.Token</b>
&lt;SPNEGO Response&gt;
Supported Mech    : 1.3.6.1.4.1.311.2.2.10 - NTLM
State             : Incomplete
&lt;SPNEGO Token&gt;
&lt;NTLM CHALLENGE&gt;
Flags     : Unicode, RequestTarget, Signing, NTLM, LocalCall, AlwaysSign,...
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 15-4: Continuing the Negotiate authentication on the server</span></p>
<p class="TX">We first pass the client authentication token to the server authentication context that we create. In the formatted output, we can see that it’s an <samp class="SANS_TheSansMonoCd_W5Regular_11">SPNEGO Response</samp>, and that the server has opted to use NTLM. The response has a <samp class="SANS_TheSansMonoCd_W5Regular_11">State</samp> flag, which indicates that the negotiation is currently incomplete. Following that is the authentication token, which, as expected, is now an <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM CHALLENGE</samp> token.</p>
<p class="TX">In <a href="chapter15.xhtml#Lis15-5">Listing 15-5</a>, we complete the authentication.</p>
<span id="Lis15-5"></span><pre><code><span aria-label=" Page 505. " epub:type="pagebreak" id="pg_505" role="doc-pagebreak"></span>PS&gt; <b>Update-LsaClientContext -Client $client -Token $server.Token</b>
PS&gt; <b>Format-LsaAuthToken -Token $client.Token</b>
&lt;SPNEGO Response&gt;
State             : Incomplete
&lt;SPNEGO Token&gt;
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> &lt;NTLM AUTHENTICATE&gt;
Flags      : Unicode, RequestTarget, Signing, NTLM, LocalCall, AlwaysSign,...
<var>--snip--</var>

PS&gt; <b>Update-LsaServerContext -Server $server -Token $client.Token</b>
PS&gt; <b>Format-LsaAuthToken -Token $server.Token</b>
&lt;SPNEGO Response&gt;
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> State            : Completed

<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>Update-LsaClientContext -Client $client -Token $server.Token</b>
PS&gt;<b> $client.PackageName</b>
NTLM
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 15-5: Completing the Negotiate authentication</span></p>
<p class="TX">The next client authentication token sent is the <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM AUTHENTICATE</samp> token <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. Note that the supported authentication protocol field is not present. This is only required in the initial server token, and it’s omitted from subsequent tokens.</p>
<p class="TX">In normal NTLM authentication, the authentication would typically complete at this point. However, in Negotiate authentication, the client’s state is considered <samp class="SANS_TheSansMonoCd_W5Regular_11">Incomplete</samp> until we generate a final server token and update the client with this token, which then marks the state as <samp class="SANS_TheSansMonoCd_W5Regular_11">Completed</samp> <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. We can then query the final package using the <samp class="SANS_TheSansMonoCd_W5Regular_11">PackageName</samp> property <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>, which shows that we negotiated NTLM.</p>
<p class="TX">To negotiate the use of Kerberos, the protocol acts in a similar manner. But as Kerberos needs an SPN to function, you must specify the target name using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Target</samp> parameter when creating the client authentication context; otherwise, the protocol will select NTLM. The output of the Kerberos authentication will replace the NTLM tokens with Kerberos AP-REQ and AP-REP tokens.</p>
<p class="TX">Now that we’ve covered the Negotiate protocol, let’s discuss a few less common security packages that you might encounter during an analysis of a Windows system.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h3 class="H1" id="sec5"><span id="h1-113"></span><samp class="SANS_Futura_Std_Bold_B_11">Less Common Security Packages</samp></h3>
<p class="TNI1">We’ve covered the three main security packages you’re most likely to use on Windows: NTLM, Kerberos, and Negotiate. But there are a few other security packages that have important functions, even if you’re less likely to use them directly. We won’t spend very much time discussing these, but I’ll give you a quick example of each so that you understand their purpose and function.</p>
<section aria-labelledby="sec6" epub:type="division">
<h4 class="H2" id="sec6"><span id="h2-161"></span><span aria-label=" Page 506. " epub:type="pagebreak" id="pg_506" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Secure Channel</samp></h4>
<p class="TNI1">Sending sensitive information (like user credentials) unencrypted over the internet is generally considered a bad idea. Several network protocols can encrypt network traffic, but by far the most common is <i>Transport Layer Security (TLS)</i>, which was once called <i>Secure Sockets Layer (SSL)</i> and was originally developed by Netscape in the mid-1990s to secure HTTP connections. A variant of TLS, the <i>Datagram Transport Layer Security (DTLS)</i> protocol, can encrypt traffic from unreliable protocols, such as the <i>User Datagram Protocol (UDP)</i>.</p>
<p class="TX"><i>Secure channel</i> is an implementation of TLS provided as a security package, and you can access it through the <samp class="SANS_TheSansMonoCd_W5Regular_11">Schannel</samp> package using the same SSPI APIs as for other network authentication protocols. While you can use secure channel as a TLS or DTLS encryption layer for network traffic, you can also use it to provide client authentication facilities to a server through client certificates.</p>
<p class="TX">Let’s walk through a simple example of how to use the package. <a href="chapter15.xhtml#Lis15-6">Listing 15-6</a> starts by setting up the client credentials handle and the client authentication context.</p>
<span id="Lis15-6"></span><pre><code>PS&gt; <b>$credout = New-LsaCredentialHandle -Package "Schannel" -UseFlag Outbound</b>
PS&gt; <b>$name = "NotReallyReal.com"</b>
PS&gt; <b>$client = New-LsaClientContext -CredHandle $credout -Target $name</b>
<b>-RequestAttribute ManualCredValidation</b>
PS&gt; <b>Format-LsaAuthToken -Token $client.Token</b>
SChannel Record 0
Type   : Handshake
Version: 3.3
Data    :
          00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F  - 0123456789ABCDEF
-----------------------------------------------------------------------------
00000000: 01 00 00 AA 03 03 60 35 C2 44 30 A9 CE C7 8B 81  - ......`5.D0.....
00000010: EB 67 EC F3 9A E3 FD 71 05 70 6C BB 92 19 31 C9  - .g.....q.pl...1.
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 15-6: Setting up the secure channel client authentication context</span></p>
<p class="TX">When setting up the context, you need to specify a target name, which is typically the DNS name of the server. The protocol uses this target name to verify that the server has a valid certificate for that name. TLS connections can also be cached, so the protocol can check whether an existing cache entry exists for the target name. In this case, the name won’t matter because we specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">ManualCredValidation</samp> request attribute, which disables the server certificate checks so that we can use a self-signed certificate for the server.</p>
<p class="TX">We then format the authentication token, which displays the TLS protocol’s simple record structure (shown in <a href="chapter15.xhtml#fig15-1">Figure 15-1</a>).</p>
<span aria-label=" Page 507. " epub:type="pagebreak" id="pg_507" role="doc-pagebreak"></span>
<figure class="IMG"><img alt="" class="img1" height="389" id="fig15-1" src="../images/Figure15-1.jpg" width="1374"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-1: The TLS record structure</samp></p></figcaption>
</figure>
<p class="TX">The record structure contains a 5-byte header consisting of a record type, the major and minor versions of the protocol, and a data length. The header is followed by a list of bytes whose interpretation depends on the record type. In <a href="chapter15.xhtml#Lis15-6">Listing 15-6</a>, the type is <samp class="SANS_TheSansMonoCd_W5Regular_11">Handshake</samp>, a record used during the connection setup to negotiate the encryption protocol to use, exchange certificates, and communicate the encryption keys. Its version is 3.3, which corresponds to TLS 1.2. (The designers of the protocol considered TLS to be a minor addition to SSL 3.0, so they increased only its minor version number.)</p>
<p class="TX">In <a href="chapter15.xhtml#Lis15-7">Listing 15-7</a>, we generate an X.509 certificate and finish setting up the server side of the secure channel authentication.</p>
<span id="Lis15-7"></span><pre><code>PS&gt; <b>$store = "Cert:\CurrentUser\My"</b>
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$cert = Get-ChildItem $store | Where-Object Subject -Match $name</b>
PS&gt; <b>if ($null -eq $cert) {</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span>     <b>$cert = New-SelfSignedCertificate -DnsName $name -CertStoreLocation $store</b>
<b>}</b>
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>$server_cred = Get-LsaSchannelCredential -Certificate $cert</b>
PS&gt; <b>$credin = New-LsaCredentialHandle -Package "Schannel" -UseFlag Inbound</b>
<b>-Credential $server_cred</b>
PS&gt; <b>$server = New-LsaServerContext -CredHandle $credin</b>
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> PS&gt; <b>while(!(Test-LsaContext $client) -and !(Test-LsaContext $server)) {</b>
    <b>Update-LsaServerContext -Server $server -Client $client</b>
    <b>Update-LsaClientContext -Client $client -Server $server</b>
<b>}</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 15-7: Initializing a security channel server context and completing authentication</span></p>
<p class="TX">We start by checking whether we have a certificate whose subject name is the DNS name we specified when creating the client authentication context <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. PowerShell exposes the system’s certificate store via the <i>Cert</i> drive provider. In this case, we check only the current user’s personal certificate store for a matching certificate.</p>
<p class="TX">If the certificate doesn’t already exist, we create a new one using the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-SelfSignedCertificate</samp> command with the DNS name as the subject, storing it in the current user’s personal store <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. This certificate isn’t trusted for the TLS certificate chain. You could add the new certificate to <i>Cert:\CurrentUser\Root</i>, which would make it trusted; however, it’s safer to just disable the certificate checking in the client for this example.</p>
<p class="TX"><span aria-label=" Page 508. " epub:type="pagebreak" id="pg_508" role="doc-pagebreak"></span>To use the certificate for the server, we need to create a set of secure channel credentials, specifying the certificate for use by the server <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. Note that the certificate must have an associated private key for the server to use. If you pick a certificate without the private key, this line of code will generate an error. We can use the credentials to create a handle and, from that, the server authentication context.</p>
<p class="TX">Finally, we exchange tokens between the server and client authentication context until the authentication completes <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. Of course, in a real application this process would exchange the tokens over a network connection, but for the sake of simplicity, we ignore the network entirely here.</p>
<p class="TX">Before we do anything else, we can inspect the negotiated security information, as shown in <a href="chapter15.xhtml#Lis15-8">Listing 15-8</a>.</p>
<span id="Lis15-8"></span><pre><code>PS&gt; <b>$client.ConnectionInfo</b>
Protocol      Cipher  Hash    Exchange
--------      ------  ----    --------
TLS1_2_CLIENT AES_256 SHA_384 ECDH_EPHEM

PS&gt; <b>$client.RemoteCertificate</b>
Thumbprint                                Subject
----------                                -------
2AB144A50D93FE86BA45C4A1F17046459D175176  CN=NotReallyReal.com

PS&gt; <b>$server.ConnectionInfo</b>
Protocol      Cipher  Hash    Exchange
--------      ------  ----    --------
TLS1_2_SERVER AES_256 SHA_384 ECDH_EPHEM
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 15-8: Inspecting the connection information</span></p>
<p class="TX">Note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">ConnectionInfo</samp> property returns the negotiated protocol and encryption algorithms. In this case, we’ve negotiated TLS 1.2 using the AES256 encryption algorithm, SHA384 for integrity, and elliptic curve Diffie-Hellman to exchange an ephemeral encryption key.</p>
<p class="TX">We can also query the server’s certificate. This should match the one we used in the server’s credentials. As we specified manual credential validation, we can check whether the certificate is valid; if we hadn’t requested manual validation, the handshake process would have generated an error. Finally, we can also query the server’s connection information to double-check that it’s the same as the client’s.</p>
<p class="TX">At this point, we’ve set up the connection, but we have yet to transfer a single byte of user data to the server. <a href="chapter15.xhtml#Lis15-9">Listing 15-9</a> shows how to encrypt and decrypt application data sent over the network connection.</p>
<span id="Lis15-9"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$header = New-LsaSecurityBuffer -Type StreamHeader</b>
<b>-Size $client.StreamHeaderSize</b>
PS&gt; <b>$data = New-LsaSecurityBuffer -Type Data -Byte 0, 1, 2, 3</b>
PS&gt; <b>$trailer = New-LsaSecurityBuffer -Type StreamTrailer</b>
<b>-Size $client.StreamTrailerSize</b>
PS&gt; <b>$empty = New-LsaSecurityBuffer -Empty</b>
PS&gt; <b>$bufs = $header, $data, $trailer, $empty</b>
<span aria-label=" Page 509. " epub:type="pagebreak" id="pg_509" role="doc-pagebreak"></span><span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>Protect-LsaContextMessage -Context $client -Buffer $bufs -NoSignature</b>
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>$msg = $header, $data, $trailer | ConvertFrom-LsaSecurityBuffer</b>
PS&gt; <b>$msg_token = Get-LsaAuthToken -Context $client -Token $msg</b>
PS&gt; <b>Format-LsaAuthToken $msg_token</b>
SChannel Record 0
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> Type    : ApplicationData
Version : 3.3
Data    :
          00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F  - 0123456789ABCDEF
-----------------------------------------------------------------------------
00000000: 00 00 00 00 00 00 00 01 C7 3F 1B B9 3A 5E 40 7E  - .........?..:^@~
00000010: B0 6C 39 6F EC DA E7 CC CC 33 C2 95              - .l9o.....3..

<span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> PS&gt; <b>$header = New-LsaSecurityBuffer -Type Data -Byte $msg</b>
PS&gt; <b>$data = New-LsaSecurityBuffer -Empty</b>
PS&gt; <b>$trailer = New-LsaSecurityBuffer -Empty</b>
PS&gt; <b>$empty = New-LsaSecurityBuffer -Empty</b>
PS&gt; <b>$bufs = $header, $data, $trailer, $empty</b>
<span aria-label="annotation6" class="CodeAnnotationHang1">❻</span> PS&gt; <b>Unprotect-LsaContextMessage -Context $server -Buffer $bufs -NoSignature</b>
PS&gt; <b>ConvertFrom-LsaSecurityBuffer $data | Out-HexDump</b>
00 01 02 03
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 15-9: Encrypting and decrypting application data</span></p>
<p class="TX">Secure channel requires passing four buffers to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Protect-LsaContextMessage</samp> command <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. The first buffer is for the TLS record header. It needs to be of type <samp class="SANS_TheSansMonoCd_W5Regular_11">StreamHeader</samp> and should be of a size queried from the context using the <samp class="SANS_TheSansMonoCd_W5Regular_11">StreamHeaderSize</samp> property.</p>
<p class="TX">The second buffer is for the data to encrypt and must be of type <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>. There is a maximum allowed size for this buffer, which you can query using the <samp class="SANS_TheSansMonoCd_W5Regular_11">StreamMaxMessageSize</samp> property. The maximum size is typically 16KB, so the 4 bytes we use here should fall well within the limit. If the application data to encrypt is larger than the maximum size, you’ll need to fragment the data into smaller parts.</p>
<p class="TX">The third buffer will contain the stream trailer, which must be of type <samp class="SANS_TheSansMonoCd_W5Regular_11">StreamTrailer</samp> and of size <samp class="SANS_TheSansMonoCd_W5Regular_11">StreamTrailerSize</samp>. The final buffer is an empty one. The secure channel package doesn’t seem to use the buffer to store anything, but you must pass it, or the call will fail.</p>
<p class="TX">We can now encrypt the data by passing all four buffers to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Protect-LsaContextMessage</samp> command <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. One important thing to note is that you should also pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">NoSignature</samp> parameter. Any generated signature will be part of the generated protocol data, not returned separately, so there is no need for the command to automatically handle the signature.</p>
<p class="TX">The result of the encryption is that the header, data, and trailer buffers are populated with the data required to transmit the application data to the server. We need to concatenate the buffers together using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ConvertFrom-LsaSecurityBuffer</samp> command <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. In this case, we already know that the data generated is a TLS record, so we can use the authentication context commands to inspect its structure. We can see that the record type is now <samp class="SANS_TheSansMonoCd_W5Regular_11">ApplicationData</samp> <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>, whereas in <a href="chapter15.xhtml#Lis15-6">Listing 15-6</a> the record type was <span aria-label=" Page 510. " epub:type="pagebreak" id="pg_510" role="doc-pagebreak"></span><samp class="SANS_TheSansMonoCd_W5Regular_11">Handshake</samp>. The use of <samp class="SANS_TheSansMonoCd_W5Regular_11">ApplicationData</samp> indicates that this is an encrypted data record.</p>
<p class="TX">Now we need to decrypt the data on the server. To do so, we again need four buffers; however, their configuration is slightly different. For decryption, we must place the entire TLS record in the first buffer as a <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> type <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>. The next three buffers can be empty; they’ll be populated during decryption with the appropriate parts of the message.</p>
<p class="TX">We pass the buffers to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Unprotect-LsaContextMessage</samp> command, again specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">NoSignature</samp> parameter, as the signature is part of the protocol <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>. When checking the data buffer, which was originally empty, we now find it’s populated with the original unencrypted data.</p>
<p class="TX">I’ve made secure channel look easy to use, but it’s much more complex than shown here. For example, you’ll have to deal with out-of-band alerts, which indicate problems with the connection. I recommend that you use an existing class (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">SslStream</samp>, which comes with .NET) to add TLS support to your application unless there’s a niche feature not exposed that you need to use.</p>
<p class="TX">By default, the TLS protocol verifies only the server in the secure channel connection, using the X.509 certificate; however, the server can request that the client also present a valid certificate for verification purposes. To require the client to send a certificate, specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">MutualAuth</samp> request attribute when creating the server authentication context. By default, secure channel will try to find a suitable certificate for the user on the client, but you can override this search by setting an explicit certificate when generating the client’s credentials.</p>
<p class="TX">The server can query for the client’s certificate using the same <samp class="SANS_TheSansMonoCd_W5Regular_11">RemoteCertificate</samp> property on the server authentication context. Note that secure channel doesn’t validate the contents of the client certificate by default; doing so is up to the server application. The only thing secure channel guarantees is that the client can prove they have the corresponding private key for the certificate. If the server is part of an enterprise network, it’s possible to add an identity certificate to Active Directory so that the client certificate can be mapped to a user account and a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object can be queried for the user’s identity without any further authentication.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h4 class="H2" id="sec7"><span id="h2-162"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">CredSSP</samp></h4>
<p class="TNI1">The final security package we’ll look at is <i>CredSSP</i>, an authentication protocol developed by Microsoft to improve the security of remote desktop connections to Windows machines. <a href="chapter15.xhtml#fig15-2">Figure 15-2</a> shows the original remote desktop implementation.</p>
<span aria-label=" Page 511. " epub:type="pagebreak" id="pg_511" role="doc-pagebreak"></span>
<figure class="IMG"><img alt="" class="img1" height="570" id="fig15-2" src="../images/Figure15-2.jpg" width="1356"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-2: The original remote desktop implementation</samp></p></figcaption>
</figure>
<p class="TX">In the original implementation, a client would connect to the server using a client application <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. The RDP server would then create a LogonUI for the user that displayed the normal Windows logon user interface and replicate this LogonUI over RDP, so the user would get the same UI on their client machine. The user could then enter their username and password into the LogonUI <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, which would follow the interactive authentication process outlined in <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span> to verify the user’s credentials <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> and create their desktop.</p>
<p class="TX">This approach to implementing a remote desktop has several security problems. First, it performs no verification of the client; this allows anyone to connect, then try to guess a user’s password or exploit some bug in the LogonUI to get access to the server. Second, starting up a desktop session for the user interface is quite an expensive operation; it’s easy to make enough connections to a remote desktop server to exhaust the machine’s resources and cause a denial-of-service condition. Finally, there is a risk of the user having their credentials phished by providing them to a malicious remote server they were tricked into connecting to.</p>
<p class="TX">Microsoft’s solution to these problems is <i>Network Level Authentication (NLA)</i>. NLA is available in Windows Vista onward, and it is the default authentication mechanism used when enabling remote desktop connections. NLA avoids the previously discussed problems by integrating authentication into the Remote Desktop Protocol and verifying that the user has valid credentials before starting a desktop session. This confirms the identity of the client, prevents the expensive operation of setting up the desktop until authentication succeeds, and allows the user to avoid disclosing their credentials to the server.</p>
<p class="TX">The CredSSP package implements NLA. It provides TLS for network-level encryption (based on secure channel), and a separate <i>TS Service Security Package (TSSSP)</i> that uses the Negotiate protocol to authenticate the user, as well as to derive a session key to encrypt the user’s credentials when sending them to the server. <a href="chapter15.xhtml#fig15-3">Figure 15-3</a> shows an overview of using NLA to connect to a remote desktop server.</p>
<span aria-label=" Page 512. " epub:type="pagebreak" id="pg_512" role="doc-pagebreak"></span>
<figure class="IMG"><img alt="" class="img1" height="582" id="fig15-3" src="../images/Figure15-3.jpg" width="1372"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-3: A remote desktop connection using Network Level Authentication</samp></p></figcaption>
</figure>
<p class="TX">First, instead of immediately making a connection, the user provides their credentials to the remote desktop client <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. This typically consists of their username and password for the remote server.</p>
<p class="TX">The client then makes a connection to the remote server, using the CredSSP package to protect the network traffic with TLS <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. The server sets up a corresponding CredSSP authentication context to implement this communication. Next, its CredSSP context uses the TSSSP package to verify the client based on an existing network authentication protocol, such as NTLM or Kerberos <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. If this verification step fails, the server can close the connection before creating an expensive desktop.</p>
<p class="TX">You might expect the server to create the user’s desktop immediately once the network authentication is complete, but there’s an additional wrinkle introduced when connecting to a remote desktop. Normally, when you use a network authentication protocol such as NTLM or Kerberos, the created logon session on the server can access only local resources, as the user’s credentials are stored on the client computer only. This is the double hop problem I mentioned in <span class="Xref"><a href="chapter13.xhtml">Chapter 13</a></span> when discussing NTLM domain network authentication.</p>
<p class="TX">This behavior is fine if the remote desktop user is accessing a resource locally on the server. But when using a remote desktop, users typically expect to be able to perform single sign-on to other machines on the network to continue to work from that remote desktop session. To solve the single sign-on problem, the client’s CredSSP context delegates the user’s credentials to the server <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. It encrypts these credentials using the negotiated session key from the network authentication.</p>
<p class="TX">Because the session key for the authentication is derived from the password, a malicious server can’t use NTLM relay or forward a Kerberos ticket and then capture the credentials, as they won’t be able to decrypt them. Once the LSA has a copy of the credentials, the remote user can use them to connect to other network services as if they have authenticated interactively.</p>
<p class="TX">While CredSSP was designed for use with remote desktop connections, you’ll also find it’s used for other purposes that require credential <span aria-label=" Page 513. " epub:type="pagebreak" id="pg_513" role="doc-pagebreak"></span>delegation. For example, in PowerShell, it’s possible to use CredSSP over the WinRM protocol, used for PowerShell remoting. This allows you to create a remote PowerShell session that has the client’s credentials and can connect to other systems on the network.</p>
<p class="TX">I won’t provide an example of using CredSSP, as for the most part it looks like the TLS connection you saw when testing secure channel. Instead, let’s cover a few final authentication topics I haven’t yet mentioned.</p>
</section>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h3 class="H1" id="sec8"><span id="h1-114"></span><samp class="SANS_Futura_Std_Bold_B_11">Remote Credential Guard and Restricted Admin Mode</samp></h3>
<p class="TNI1">You might notice a problem with delegating your credentials to the remote desktop server. With NLA, you can be confident that the server can verify your credentials, but if an attacker has compromised the server, they could harvest the credentials once they’re decrypted during the authentication process. Perhaps an attacker is waiting for you to connect to the server with your privileged domain administrator credentials. Also, there’s a chance that the server will leave your credentials lying around in the LSASS process’s memory even after you’ve logged off the system, meaning a malicious attacker can pick them up later.</p>
<p class="TX">Windows provides two optional features to mitigate the risk of a compromised server. The first is <i>Remote Credential Guard</i>, which works with Kerberos authentication to avoid directly delegating the user’s credentials. Using Remote Credential Guard, the client can generate new Kerberos tickets on demand to access resources. This allows the client to connect to other systems from a remote desktop as if they had delegated their credentials.</p>
<p class="TX">Importantly for security, this channel to create new tickets exists only while the client is connected to the server. If they disconnect, the server can no longer create new tickets, although any client that is already authenticated will likely stay that way. This means the machine must be actively compromised while the privileged user is authenticated to be useful.</p>
<p class="TX">You need to perform some setup steps in your domain to enable Remote Credential Guard. The setup is out of scope for this section, but if the feature has been enabled, you can use it with the remote desktop client by running the following command line:</p>
<pre><code>PS&gt; <b>mstsc.exe /remoteGuard</b>
</code></pre>
<p class="TX">The second security feature is <i>Restricted Admin mode</i>. Its big difference from Remote Credential Guard is that when a user authenticates to a server, it creates the logon session without the user’s network credentials. Instead, the session is assigned network credentials for the computer account on the server. Therefore, the logon session is primarily useful only if the user wants to perform tasks locally; they won’t be able to connect to network resources as themselves unless they explicitly provide their credentials to the remote server. However, this feature ensures that there are no privileged credentials to steal if the server is compromised.</p>
<p class="TX"><span aria-label=" Page 514. " epub:type="pagebreak" id="pg_514" role="doc-pagebreak"></span>To enable Restricted Admin mode, first add a DWORD registry key value named <samp class="SANS_TheSansMonoCd_W5Regular_11">DisableRestrictedAdmin</samp> to <i>HKLM\System\CurrentControlSet\Control\Lsa</i> and set it to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>. Then you can enable the mode when executing the client with the following command line:</p>
<pre><code>PS&gt; <b>Mstsc.exe /RestrictedAdmin</b>
</code></pre>
<p class="TX">One advantage of these two security features (above and beyond the restrictions they place on credential delegation) is that they allow the remote desktop client to use single sign-on authentication based on the current user’s credentials stored in the LSA logon session. This is because neither feature requires the plaintext credentials.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h3 class="H1" id="sec9"><span id="h1-115"></span><samp class="SANS_Futura_Std_Bold_B_11">The Credential Manager</samp></h3>
<p class="TNI1">One annoyance of using a remote desktop connection is having to enter your password every time you want to connect. This seems unavoidable, as you must provide the account password to the server to allow single sign-on to function from the remote desktop server. However, the LSA supports a feature to save the account password for subsequent authentication to save you typing it in again. One place where this feature is used is when you type in your credentials; you’ll see a “Remember me” checkbox in the dialog, as shown in <a href="chapter15.xhtml#fig15-4">Figure 15-4</a>.</p>
<figure class="IMG"><img alt="" class="img7" height="975" id="fig15-4" src="../images/Figure15-4.jpg" width="1250"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-4: Entering and saving your credentials</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 515. " epub:type="pagebreak" id="pg_515" role="doc-pagebreak"></span>If you check the box and successfully authenticate, the dialog in which to enter the server’s name should change slightly the next time you open it (<a href="chapter15.xhtml#fig15-5">Figure 15-5</a>).</p>
<figure class="IMG"><img alt="" class="img7" height="716" id="fig15-5" src="../images/Figure15-5.jpg" width="1201"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-5: Connection dialog with saved credentials</samp></p></figcaption>
</figure>
<p class="TX">Now you can see that the dialog gives you the option to edit or delete saved credentials for this server.</p>
<p class="TX">It would be easy for the client to store the user’s password directly to a file on disk, but that wouldn’t be very secure. Instead, it uses a service provided by the LSA known as the <i>credential manager</i>. The service can store domain passwords for easy reuse, although Microsoft doesn’t recommend this practice. To demonstrate how credentials get stored, <a href="chapter15.xhtml#Lis15-10">Listing 15-10</a> first uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Win32Credential</samp> PowerShell command, which calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">CredRead</samp> Win32 API, to read the credentials for the remote desktop client.</p>
<span id="Lis15-10"></span><pre><code>PS&gt; <b>Get-Win32Credential "TERMSRV/primarydc.domain.local" DomainPassword |</b>
<b>Format-Table UserName, Password</b>
UserName                 Password
--------                 --------
MINERAL\Administrator
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 15-10: Getting the credentials for a remote desktop client</span></p>
<p class="TX">The credentials are stored by target name, which for domain credentials is the SPN for the service (in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">TERMSRV/primarydc.domain.local</samp>). When looking up credentials you also need to specify the type, which in this case is <samp class="SANS_TheSansMonoCd_W5Regular_11">DomainPassword</samp>.</p>
<p class="TX">Here, we’ve formatted the output to show only the username and password. However, you might notice a problem: the password column is empty. This is an intentional behavior of the service. If the credentials represent a domain password, the password won’t be returned unless the caller is running within the LSA process.</p>
<p class="TX"><span aria-label=" Page 516. " epub:type="pagebreak" id="pg_516" role="doc-pagebreak"></span>This behavior is fine for its intended purpose: to use in security packages that are running inside the LSA. For example, CredSSP can check whether the user has a credential for the target remote desktop service based on its SPN and use it to read the user’s password to automatically authenticate. The service stores the credentials in individual files in the user’s profile, as illustrated in <a href="chapter15.xhtml#Lis15-11">Listing 15-11</a>.</p>
<span id="Lis15-11"></span><pre><code>PS&gt; <b>ls "$env:LOCALAPPDATA\Microsoft\Credentials" -Hidden</b>
    Directory: C:\Users\alice\AppData\Local\Microsoft\Credentials
Mode    LastWriteTime         Length Name
----    -------------        <b> </b>------ ----
-a-hs-  5/17      10:15 PM    4076   806C9533269FB8C19A759596441A2ECF
-a-hs-  5/17       9:49 PM    420    B5E4F2A09B2613B8305BA6A43DC15D1F
-a-hs-  5/6        6:33 PM    11396  DFBE70A7E5CC19A398EBF1B96859CE5D
-a-hs-  5/17       3:56 PM    1124   E05DBE15D38053457F3523A375594044
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 15-11: Viewing the user’s credential files</span></p>
<p class="TX">Each file is encrypted using a per-user key through the Data Protection API (DPAPI), which I mentioned in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>. This means we should be able to decrypt our own credential files using the DPAPI, through the .NET <samp class="SANS_TheSansMonoCd_W5Regular_11">ProtectedData</samp> class. <a href="chapter15.xhtml#Lis15-12">Listing 15-12</a> enumerates the current user’s credential files and tries to decrypt each one using <samp class="SANS_TheSansMonoCd_W5Regular_11">ProtectedData</samp>.</p>
<span id="Lis15-12"></span><pre><code>PS&gt; <b>Add-Type -AssemblyName "System.Security"</b>
PS&gt; <b>ls "$env:LOCALAPPDATA\Microsoft\Credentials" -h | ForEach-Object {</b>
<b>    $ba = Get-Content -Path $_.FullName -Encoding Byte</b>
<b>    [Security.Cryptography.ProtectedData]::Unprotect($ba,$null,"CurrentUser")</b>
<b>}</b>
Exception calling "Unprotect" with "3" argument(s): "The data is invalid."
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 15-12: Attempting to decrypt the user’s credential files</span></p>
<p class="TX">Unfortunately, every file returns the same error: <samp class="SANS_TheSansMonoCd_W5Regular_11">The data is invalid</samp>. While it is encrypted using the user’s DPAPI key, the LSA sets a special flag in the binary data that indicates that only code running in the LSA can decrypt it.</p>
<p class="TX">There are many ways to decrypt the files successfully: for example, you could inject code into the LSA process and decrypt them from there, or you could derive the DPAPI key using the user’s password and the values from the SECURITY database registry key and decrypt them yourself. If you want to go down the latter route, I’d suggest checking out existing tooling such as Mimikatz, which already implements this functionality.</p>
<p class="TX">Another approach to decrypting the files was introduced in Windows Vista. A special token privilege, <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTrustedCredmanAccessPrivilege</samp>, allows a process to be considered trusted by the LSA when accessing select credential manager APIs. The most interesting of these select APIs is <samp class="SANS_TheSansMonoCd_W5Regular_11">CredBackupCredentials</samp>, which will back up all of a user’s credentials into a file that can later be used to restore the credentials if needed. The backup also contains any protected password values.</p>
<p class="TX"><span aria-label=" Page 517. " epub:type="pagebreak" id="pg_517" role="doc-pagebreak"></span><a href="chapter15.xhtml#Lis15-13">Listing 15-13</a> shows how to back up a user’s credentials from the credential manager. You must run these commands as an administrator, as you need to access a privileged process to get a token with <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTrustedCredmanAccessPrivilege</samp>, which is only granted to select process types.</p>
<span id="Lis15-13"></span><pre><code>PS&gt; <b>Enable-NtTokenPrivilege SeDebugPrivilege</b>
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$token = Use-NtObject($ps = Get-NtProcess -Name "winlogon.exe"</b>
<b>-Access QueryLimitedInformation) {</b>
<b>    $p = $ps | Select-Object -First 1</b>
<b>    Get-NtToken -Process $p -Duplicate</b>
<b>}</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>$user_token = Get-NtToken</b>
PS&gt; <b>$ba = Invoke-NtToken -Token $token {</b>
<b>  </b><span aria-label="annotation3" class="CodeAnnotationCode2">❸</span><b> Enable-NtTokenPrivilege SeTrustedCredmanAccessPrivilege</b>
<b>    Backup-Win32Credential -Token $user_token</b>
<b>}</b>
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> PS&gt; <b>Select-BinaryString -Byte $ba -Type Unicode |</b>
<b>Select-String "^Domain:" -Context 0, 2</b>
&gt; Domain:target=TERMSRV/primarydc.mineral.local
<b>  </b>MINERAL\Administrator
<b>  </b>Passw0rd10
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 15-13: Backing up a user’s credentials from the credential manager</span></p>
<p class="TX">We first open the privileged Winlogon process and take a copy of its primary token <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. Next, we get a copy of the user token we want to back up, which in this case is the current process token <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. We can then impersonate the token we duplicated from Winlogon <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>, enable <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTrustedCredmanAccessPrivilege</samp>, and call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Backup-Win32Credential</samp> PowerShell command, which calls the underlying <samp class="SANS_TheSansMonoCd_W5Regular_11">CredBackupCredentials</samp> API.</p>
<p class="TX">The command returns a byte array containing the backup. The byte array is in a proprietary format, so we select all its Unicode strings and look for any that start with the string <samp class="SANS_TheSansMonoCd_W5Regular_11">Domain:</samp> <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. We can see the stored remote desktop service credentials, including the name and password.</p>
<p class="TX">The credential manager is a better place than a user-accessible file to store credentials for use by LSA security packages such as NTLM, Kerberos, and CredSSP. However, that doesn’t mean you should use it. While disclosing the credentials takes some work, like any protection mechanism, it must at some point provide the unencrypted values, which an attacker can then extract.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h3 class="H1" id="sec10"><span id="h1-116"></span><samp class="SANS_Futura_Std_Bold_B_11">Additional Request Attribute Flags</samp></h3>
<p class="TNI1">When you create a client or server authentication context, you can specify a set of request attribute flags to change the behavior of the authentication. We’ve already seen support for signing and sealing, as well as delegation and mutual authentication, in the previous chapters. Still, it’s worth highlighting a few other flags that Kerberos and NTLM support.</p>
<section aria-labelledby="sec11" epub:type="division">
<h4 class="H2" id="sec11"><span id="h2-163"></span><span aria-label=" Page 518. " epub:type="pagebreak" id="pg_518" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Anonymous Sessions</samp></h4>
<p class="TNI1">What if you don’t know a user account on the target server? SSPI supports the concept of an <i>anonymous session</i>, also referred to as a <i>NULL session</i>. In an anonymous session, the authenticating user doesn’t need any credentials to generate the authentication tokens. The server will process the authentication as usual, but it will generate a token for the <i>ANONYMOUS LOGON</i> user. This allows a network protocol to always require authentication, simplifying the protocol, and to then enforce access based on the identity of the authenticated user. You can specify an anonymous session by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NullSession</samp> request attribute flag when creating the client authentication context, as in <a href="chapter15.xhtml#Lis15-14">Listing 15-14</a>.</p>
<span id="Lis15-14"></span><pre><code>PS&gt; <b>$client = New-LsaClientContext -CredHandle $credout</b>
<b>-RequestAttribute NullSession</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 15-14: Adding the NullSession request attribute flag</span></p>
<p class="TX">If you then perform local NTLM network authentication, you should notice a change in the <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM AUTHENTICATE</samp> token, shown in <a href="chapter15.xhtml#Lis15-15">Listing 15-15</a>.</p>
<span id="Lis15-15"></span><pre><code>&lt;NTLM AUTHENTICATE&gt;
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> Flags<b>      </b>: Unicode, RequestTarget, NTLM, Anonymous,...
Workstation: GRAPHITE
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> LM Response: 00
NT Response:
Version<b>    </b>: 10.0.18362.15
MIC        : 3780F9F6EC815DD34BA8A643162DC5FC

PS&gt; <b>Format-NtToken -Token $token</b>
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> NT AUTHORITY\ANONYMOUS LOGON
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 15-15: The NTLM AUTHENTICATE token in an anonymous session</span></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token has the <samp class="SANS_TheSansMonoCd_W5Regular_11">Anonymous</samp> flag set <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. Also, the LM response is a single zero byte, and the NT response is missing <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. Querying the process’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object shows that it’s the anonymous user’s <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>.</p>
<p class="TX">In Kerberos, the anonymous authentication token looks like that for NTLM, as shown in <a href="chapter15.xhtml#Lis15-16">Listing 15-16</a>.</p>
<span id="Lis15-16"></span><pre><code>&lt;KerberosV5 KRB_AP_REQ&gt;
Options<b>         </b>: None
&lt;Ticket&gt;
Ticket Version  : 0
ServerName      : UNKNOWN -
Realm           :
Encryption Type : NULL
Key Version    <b> </b>: 0
Cipher Text     :
00000000: 00
&lt;Authenticator&gt;
Encryption Type : NULL
<span aria-label=" Page 519. " epub:type="pagebreak" id="pg_519" role="doc-pagebreak"></span>Key Version<b>     </b>: 0
Cipher Text<b>     </b>:
00000000: 00
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 15-16: Sending an anonymous Kerberos AP-REQ message</span></p>
<p class="TX">The client sends an AP-REQ message with a ticket and authenticator containing empty values. If you see this message in a network capture, you can be certain the client is establishing an anonymous session.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h4 class="H2" id="sec12"><span id="h2-164"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Identity Tokens</samp></h4>
<p class="TNI1">When you perform a network authentication, the final <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object is an Impersonation-level token. If the server can pass the impersonation checks described in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>, it can now access that user’s resources. What if we don’t want the server to be able to use our identity to access resources? In this case, we can specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Identify</samp> request attribute flag, as shown in <a href="chapter15.xhtml#Lis15-17">Listing 15-17</a>, to allow the server to receive only an Identification-level impersonation token, rather than a full Impersonation-level token.</p>
<span id="Lis15-17"></span><pre><code>PS&gt; <b>$client = New-LsaClientContext -CredHandle $credout -RequestAttribute Identify</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 15-17: Adding the Identify request attribute flag</span></p>
<p class="TX">This will prevent the server from using our identity to access resources, but still allow it to check who has authenticated. If we then rerun the authentication, we should notice a change in the <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM AUTHENTICATE</samp> token, as shown in <a href="chapter15.xhtml#Lis15-18">Listing 15-18</a>.</p>
<span id="Lis15-18"></span><pre><code>&lt;NTLM AUTHENTICATE&gt;
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> Flags      : Unicode, RequestTarget, NTLM, Identity,...
<var>--snip--</var>

PS&gt; <b>Format-NtToken -Token $token -Information</b>
TOKEN INFORMATION
-----------------
Type       : Impersonation
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> Imp Level  : Identification
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 15-18: Examining the flags in the NTLM AUTHENTICATE token and displaying the created token’s impersonation level</span></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token’s flags now include an <samp class="SANS_TheSansMonoCd_W5Regular_11">Identity</samp> flag <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. This indicates to the server that the client wants to allow the use of an Identification-level token only. When we get the token from the server authentication context and format it, we can see that the impersonation level is indeed set to Identification <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>.</p>
<p class="TX">As with <samp class="SANS_TheSansMonoCd_W5Regular_11">NullSession</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Identify</samp> request attribute flag will work with Kerberos as well. <a href="chapter15.xhtml#Lis15-19">Listing 15-19</a> shows that specifying this flag results in an <samp class="SANS_TheSansMonoCd_W5Regular_11">Identity</samp> flag being set in the AP-REQ authenticator’s GSSAPI <samp class="SANS_TheSansMonoCd_W5Regular_11">Checksum</samp> field.</p>
<span id="Lis15-19"></span><pre><code><span aria-label=" Page 520. " epub:type="pagebreak" id="pg_520" role="doc-pagebreak"></span>&lt;Authenticator&gt;
<var>--snip--</var>
Checksum        : GSSAPI
Channel Binding : 00000000000000000000000000000000
Context Flags   : Identity
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 15-19: The Identity flag in an AP-REQ GSSAPI checksum</span></p>
</section>
</section>
<section aria-labelledby="sec13" epub:type="division">
<h3 class="H1" id="sec13"><span id="h1-117"></span><samp class="SANS_Futura_Std_Bold_B_11">Network Authentication with a Lowbox Token</samp></h3>
<p class="TNI1">When a process is running with a lowbox token (described in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>), the LSA enforces restrictions on the use of network authentication. This is to make it harder for the sandbox application to abuse network authentication to get access to the user’s logon session credentials and, through them, access their resources.</p>
<p class="TX">If the lowbox process can create a client authentication context, however, it can generate authentication tokens in only the following three scenarios:</p>
<ul class="ul">
<li class="ListBullet">Using logon session credentials with the Enterprise Authentication capability</li>
<li class="ListBullet">Using logon session credentials to a known web proxy</li>
<li class="ListBullet">Using explicit credentials, such as a username and password</li>
</ul>
<p class="TX">Let’s discuss each of these scenarios.</p>
<section aria-labelledby="sec14" epub:type="division">
<h4 class="H2" id="sec14"><span id="h2-165"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Authentication with the Enterprise Authentication Capability</samp></h4>
<p class="TNI1">The <i>enterprise authentication capability</i>, represented by the SID <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-8</samp>, can be granted when a lowbox token is created. With this capability, the lowbox process can use the user’s logon session credentials to generate any supported network authentication tokens, such as those for NTLM or Kerberos, without restriction.</p>
<p class="TX">The enterprise authentication capability is designed for enterprises to use in their internal applications. Outside of enterprises, the primary means of deploying lowbox processes is via the Microsoft App Store, which has restricted the use of this capability in the application submission guidelines. If you apply to the Microsoft store with an application that uses the enterprise authentication capability, it must pass an extra review and might be rejected. However, if you’re creating the lowbox token outside of a store application for testing purposes, there is no restriction, as demonstrated in <a href="chapter15.xhtml#Lis15-20">Listing 15-20</a>.</p>
<span id="Lis15-20"></span><pre><code>PS&gt; <b>$cred = New-LsaCredentialHandle -Package "Negotiate" -UseFlag Outbound</b>
PS&gt; <b>$sid = Get-NtSid -PackageName "network_auth_test"</b>
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>Use-NtObject($token = Get-NtToken -LowBox -PackageSid $sid) {</b>
    <b>Invoke-NtToken $token {New-LsaClientContext -CredHandle $cred}</b>
<b>}</b>
<span aria-label=" Page 521. " epub:type="pagebreak" id="pg_521" role="doc-pagebreak"></span><span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> Exception calling ".ctor" with "5" argument(s): "(0x80090304) - The Local
Security Authority cannot be contacted"

PS&gt; <b>$cap = Get-NtSid -KnownSid CapabilityEnterpriseAuthentication</b>
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>Use-NtObject($token = Get-NtToken -LowBox -PackageSid $sid</b>
<b>-CapabilitySid $cap) {</b>
  <span aria-label="annotation4" class="CodeAnnotationCode2">❹</span> <b>$auth = Invoke-NtToken $token {New-LsaClientContext -CredHandle $cred}</b>
    <b>Format-LsaAuthToken $auth</b>
<b>}</b>
&lt;SPNEGO Init&gt;
Mechanism List    :
1.3.6.1.4.1.311.2.2.10         - NTLM
1.2.840.48018.1.2.2            - Microsoft Kerberos
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 15-20: Testing the lowbox enterprise authentication capability</span></p>
<p class="TX">We first create a lowbox <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object without the capability <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. When we create the client authentication context using <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaClientContext</samp>, we get an error <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. This error comes from the <samp class="SANS_TheSansMonoCd_W5Regular_11">InitializeSecurityContext</samp> API, which PowerShell calls behind the scenes. Next, we create the lowbox token with the capability <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. This time, we can successfully create a client authentication context and format the client authentication token <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>.</p>
</section>
<section aria-labelledby="sec15" epub:type="division">
<h4 class="H2" id="sec15"><span id="h2-166"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Authentication to a Known Web Proxy</samp></h4>
<p class="TNI1">The lowbox process can generate tokens for authentication to web proxies, which commonly require that a domain user can access the internet. To support this use case, you can perform network authentication with the user’s logon session credentials if the target name is set to the address of an approved proxy server.</p>
<p class="TX">For example, say the target name is <samp class="SANS_TheSansMonoCd_W5Regular_11">HTTP/proxy.mineral.local</samp>. The system administrator must configure the proxy address either through the group policy or by using a <i>Proxy Auto-Configuration (PAC)</i> script, which makes sure that a web request with an arbitrary proxy configuration won’t pass the LSA’s checks. <a href="chapter15.xhtml#Lis15-21">Listing 15-21</a> demonstrates the use of a web proxy target name to allow network authentication. You must have configured a system web proxy for this script to work.</p>
<span id="Lis15-21"></span><pre><code>PS&gt; <b>$cred = New-LsaCredentialHandle -Package "NTLM" -UseFlag Outbound</b>
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$client = New-Object System.Net.WebClient</b>
PS&gt; <b>$proxy = $client.Proxy.GetProxy("http://www.microsoft.com").Authority</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>$target = "HTTP/$proxy"</b>
PS&gt; <b>$target | Write-Output</b>
HTTP/192.168.0.10:1234

PS&gt; <b>$sid = Get-NtSid -PackageName "network_auth_test"</b>
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>Use-NtObject($token = Get-NtToken -LowBox -PackageSid $sid) {</b>
  <span aria-label="annotation4" class="CodeAnnotationCode2">❹</span> <b>$client = Invoke-NtToken $token {</b>
        <b>New-LsaClientContext -CredHandle $cred -Target $target</b>
    <b>}</b>
<span aria-label=" Page 522. " epub:type="pagebreak" id="pg_522" role="doc-pagebreak"></span>    <b>Format-LsaAuthToken $client</b>
<b>}</b>
&lt;NTLM NEGOTIATE&gt;
Flags: Unicode, Oem, RequestTarget, NTLM, AlwaysSign,...
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 15-21: Testing lowbox web proxy authentication</span></p>
<p class="TX">First, we query for the proxy setting using the <samp class="SANS_TheSansMonoCd_W5Regular_11">WebClient</samp> .NET class <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. We then build the target SPN with an HTTP service class and the proxy address <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>.</p>
<p class="TX">Next, we create the lowbox token <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. Notice that we haven’t specified the enterprise authentication capability. We create the client authentication context and use the target SPN <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. The initial authentication succeeds, and we can perform the client authentication to the target proxy.</p>
<p class="TX">This proxy authentication is considered secure because the service should check the target name before permitting the authentication. If the lowbox process generates the authentication for the proxy SPN but then sends it to an SMB server, the authentication process should fail. For Kerberos authentication, the SPN selects the key to use for the ticket, so an incorrect SPN should make the ticket fail to decrypt if sent to the wrong service.</p>
</section>
<section aria-labelledby="sec16" epub:type="division">
<h4 class="H2" id="sec16"><span id="h2-167"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Authentication with Explicit Credentials</samp></h4>
<p class="TNI1">The final option, shown in <a href="chapter15.xhtml#Lis15-22">Listing 15-22</a>, is to specify explicit credentials when creating the credentials handle provided to the client authentication context.</p>
<span id="Lis15-22"></span><pre><code>PS&gt; <b>$cred = New-LsaCredentialHandle -Package "Negotiate" -UseFlag Outbound</b>
<b>-ReadCredential</b>
UserName: <b>user</b>
Domain: <b>GRAPHITE</b>
Password: <b>********</b>

PS&gt; <b>$sid = Get-NtSid -PackageName "network_auth_test"</b>
PS&gt; <b>Use-NtObject($token = Get-NtToken -LowBox -PackageSid $sid) {</b>
<b>    Invoke-NtToken $token {</b>
<b>    </b><span aria-label="annotation1" class="CodeAnnotationCode2">❶</span><b> $c = New-LsaClientContext -CredHandle $cred -Target "CIFS/localhost"</b>
<b>      Format-LsaAuthToken $c</b>
<b>    }</b>
<b>}</b>
&lt;NTLM NEGOTIATE&gt;
Flags: Unicode, Oem, RequestTarget, NTLM, AlwaysSign,...
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 15-22: Initializing the client authentication context with explicit credentials</span></p>
<p class="TX">To initialize the client authentication context, you still need to provide a target SPN <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. However, you don’t need to specify a known proxy, as the target can be any service or host. In this case, we specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">CIFS/ localhost</samp> SPN.</p>
<p class="TX">When in a lowbox token sandbox, you can act as a server for network authentication, as it’s possible to get a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object for a different user. <span aria-label=" Page 523. " epub:type="pagebreak" id="pg_523" role="doc-pagebreak"></span>However, unless the token’s user exactly matches the caller’s user and lowbox package SID, the returned token is set to the Identification level, which prevents it from being abused to elevate privileges. The restriction on the impersonation level applies even if the lowbox token has the enterprise authentication capability, as this grants access to the client authentication context only.</p>
<aside aria-label="box-9" class="box">
<p class="BoxTitle" id="box-9"><samp class="SANS_Dogma_OT_Bold_B_11">BYPASSING THE PROXY CHECK</samp></p>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">Microsoft very poorly documents these bypasses of the capability requirement for proxy authentication. The problem with security features for which there is little to no official documentation is that few developers know they exist, so they don’t get tested as rigorously as they should, especially for unusual edge cases. In a utopian world, Microsoft would have implemented comprehensive security tests for the proxy check feature, but sadly, we don’t live in such a world.</samp></p>
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">While researching the proxy check for this book, I reverse engineered its implementation in the LSA and noticed that if the target name isn’t a proxy, the authentication process continues, but the LSA sets a flag for the security package that indicates it must use explicitly provided credentials. As we saw when we covered NTLM in <a href="chapter13.xhtml">Chapter 13</a>, it’s possible to provide the username and domain for the current user but leave the password empty; in that case, the security package will use the password from the logon credentials.</samp></p>
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">If you specify just the username and domain, the NTLM security package will consider them to be explicit credentials, satisfying the flag set by the LSA even though the authentication will use default credentials. This bypasses all the checks and grants a lowbox process access to the default user, which an attacker could abuse to access network resources accessible by that user. You can learn more about this issue in CVE-2020-1509.</samp></p>
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">Even after Microsoft implemented a fix, I was still able to bypass the check, as during my research I also noticed that the check for the target name wasn’t implemented correctly. Recall from <a href="chapter13.xhtml">Chapter 13</a> that a target name is an SPN composed of three parts, separated by forward slashes: the service class, the instance name, and the service name. The parsing and checking code in the LSA had two problems:</samp></p>
<ul class="ul">
<li class="BoxListBullet"><samp class="SANS_Futura_Std_Book_11">It didn’t verify that the service class was HTTP or HTTPS.</samp></li>
<li class="BoxListBullet"><samp class="SANS_Futura_Std_Book_11">It checked the service name for the proxy address, not the instance name.</samp></li>
</ul>
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">Not verifying the service class allowed the target name to refer to other services, such as CIFS, to use for authenticating to an SMB server. This let me construct a target name of the form</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">CIFS/fileserver.domain.com/proxy.domain.com</samp><samp class="SANS_Futura_Std_Book_11">. If</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">proxy.domain.com</samp> <samp class="SANS_Futura_Std_Book_11">was a registered proxy, this target name would pass the proxy check; however, the SMB server would care only about the service class and the instance name (here,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">fileserver.domain.com</samp><samp class="SANS_Futura_Std_Book_11">), and once again would allow access to the user’s default credentials. Microsoft fixed this issue as well, although without assigning it a CVE number.</samp></p>
<p class="BoxBody"><span aria-label=" Page 524. " epub:type="pagebreak" id="pg_524" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Book_11">The main root cause of the service name problem was that the API Microsoft used to parse the SPN would set the service name component to match the instance name component if no service name were provided. For example,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">HTTP/proxy.domain.com</samp> <samp class="SANS_Futura_Std_Book_11">would set both the instance name and the service name to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">proxy.domain.com</samp><samp class="SANS_Futura_Std_Book_11">. Therefore, this code worked in Microsoft’s limited testing, but broke when someone decided to test the feature’s edge cases. I mentioned the target name parsing bypass to Microsoft when reporting the original issue, but for some reason, it wasn’t fixed at the same time. In addition to supporting my previous statement about undocumented features often not being very well tested, this example demonstrates why you should always verify any changes a developer makes to ensure they’ve implemented a comprehensive fix.</samp></p>
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">That said, Microsoft recommends disabling automatic authentication to HTTP proxy servers when it’s not required by adding the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">AllowUnprivilegedProxyAuth</samp> <samp class="SANS_Futura_Std_Book_11">registry key value to</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Lsa</samp> <samp class="SANS_Futura_Std_Book_11">and setting its value to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp><samp class="SANS_Futura_Std_Book_11">. If the value doesn’t exist, Windows enables this authentication by default if targeting a proxy.</samp></p>
</aside>
</section>
</section>
<section aria-labelledby="sec17" epub:type="division">
<h3 class="H1" id="sec17"><span id="h1-118"></span><samp class="SANS_Futura_Std_Bold_B_11">The Authentication Audit Event Log</samp></h3>
<p class="TNI1">Let’s wrap up our discussion of authentication with an overview of the auditing data generated during interactive and network authentication. When you’re monitoring an enterprise network, you might want to know which users have attempted to authenticate to the Windows system. By analyzing the audit log, you can identify their successful and unsuccessful authentication attempts to a machine.</p>
<p class="TX">You can find the authentication audit log records in the same security event log we inspected in <span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span> when discussing object audit events. We can use a similar technique of filtering the log by event ID to get the events we’re interested in. Here are some event IDs for important authentication events:</p>
<p class="RunInPara1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">4624  </samp>An account logged on successfully.</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">4625  </samp>An account failed to log on.</p>
<p class="RunInPara2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">4634</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">  </samp>An account logged off.</p>
<p class="TX">Let’s look at the information these events provide. <a href="chapter15.xhtml#Lis15-23">Listing 15-23</a> starts by querying the security event log for the successful logon event, <samp class="SANS_TheSansMonoCd_W5Regular_11">4624</samp>. Run this command as an administrator.</p>
<span id="Lis15-23"></span><pre><code>PS&gt; <b>Get-WinEvent -FilterHashtable @{logname='Security';id=@(4624)} |</b>
<b>Select-Object -ExpandProperty Message</b>
An account was successfully logged on.

<span aria-label=" Page 525. " epub:type="pagebreak" id="pg_525" role="doc-pagebreak"></span>Subject:
        Security ID:            S-1-5-18
        Account Name:           GRAPHITE$
        Account Domain:         MINERAL
        Logon ID:               0x3E7

Logon Information:
        Logon Type:             2
        Restricted Admin Mode:  No
        Virtual Account:        No
        Elevated Token:         Yes

Impersonation Level:            Impersonation

New Logon:
        Security ID:            S-1-5-21-1195776225-522706947-2538775957-1110
        Account Name:           alice
        Account Domain:         MINERAL
        Logon ID:              <b> </b>0x15CB183
        Linked Logon ID:        0x15CB1B6
        Network Account Name:   -
        Network Account Domain: -
        Logon GUID:             {d406e311-85e0-3932-dff5-99bf5d834535}

Process Information:
        Process ID:             0x630
        Process Name:           C:\Windows\System32\winlogon.exe

Network Information:
        Workstation Name:       GRAPHITE
        Source Network Address: 127.0.0.1
        Source Port:            0

Detailed Authentication Information:
        Logon Process:            User32
        Authentication Package:   Negotiate
        Transited Services:       -
        Package Name (NTLM only): -
        Key Length:               0
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 15-23: A log record for a successful interactive authentication event</span></p>
<p class="TX">This listing shows an example entry for a successful authentication event. On a frequently used system there are likely to be many such entries, so pick just one to inspect.</p>
<p class="TX">The event records contain a lot of information, some of which might not be populated for certain logon types. Each entry starts with information about the user account that has made the authentication request. For an interactive authentication, you’ll likely find this to be a privileged account, such as the <i>SYSTEM</i> computer account. Next comes information about the logon, including the logon type. The <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> indicates interactive. Some other logon types are network (<samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>), batch (<samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>), service (<samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>), and remote interactive (<samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>). This section also indicates whether Restricted Admin <span aria-label=" Page 526. " epub:type="pagebreak" id="pg_526" role="doc-pagebreak"></span>mode was used for the authentication and whether the session the event represents is elevated. It’s followed by an indication of the token’s impersonation level.</p>
<p class="TX">The following section contains the details of the logon session created for the successful authentication, including the user’s SID, name, and domain. As this is an elevated interactive authentication, we see two logon IDs: one for the session itself and one for the linked, non-elevated logon session created for UAC.</p>
<p class="TX">Next come the details of the process making the authentication request. In this example, it’s the process that called <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>. The final two sections contain network authentication information and additional details that didn’t fit into other categories. Part of the detailed authentication information is the security package used for the authentication. In this case, Negotiate was used, so it will have chosen the best authentication protocol for the user.</p>
<p class="TX">You’ll see the same type of event record generated regardless of whether authentication occurred through <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> or through network authentication. For example, if the event is for an NTLM network authentication, you should see something like <a href="chapter15.xhtml#Lis15-24">Listing 15-24</a> in the detailed authentication information section.</p>
<span id="Lis15-24"></span><pre><code>Detailed Authentication Information:
  Logon Process:             NtLmSsp
  Authentication Package:    NTLM
  Transited Services:        -
  Package Name (NTLM only):  NTLM V2
  Key Length:                128
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 15-24: The detailed information for a successful NTLM network authentication</span></p>
<p class="TX">Let’s now look at a failed authentication event. <a href="chapter15.xhtml#Lis15-25">Listing 15-25</a> queries for events with an ID of <samp class="SANS_TheSansMonoCd_W5Regular_11">4625</samp>, as an administrator.</p>
<span id="Lis15-25"></span><pre><code>PS&gt; <b>Get-WinEvent -FilterHashtable @{logname='Security';id=@(4625)} |</b>
<b>Select-Object -ExpandProperty Message</b>
An account failed to log on.
<var>--snip--</var>
Account For Which Logon Failed:
    Security ID:        S-1-0-0
    Account Name:       alice
    Account Domain:     MINERAL

Failure Information:
    Failure Reason:     Unknown user name or bad password.
    Status:             0xC000006D
    Sub Status:         0xC000006A
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 15-25: A failed authentication event log record</span></p>
<p class="TX"><span aria-label=" Page 527. " epub:type="pagebreak" id="pg_527" role="doc-pagebreak"></span>In the output, I’ve highlighted just one record. It has many of the same sections as for a successful authentication, so I’ve removed anything that appears in both types of record.</p>
<p class="TX">The first of the sections shown here contains details on the user account that failed to authenticate. The SID entry isn’t guaranteed to be valid; for example, in this case, the SID does not represent the <i>alice</i> user. Next, we get more details about the failure, starting with a text version of the error, followed by the status, which here is an NT status code of <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_LOGON_FAILURE</samp>. The sub-status code provides more detail; in this case, it’s <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_WRONG_PASSWORD</samp>, which indicates that the user did not provide a valid password. Other sub-status codes you might encounter include <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_NO_SUCH_USER</samp>, if the user doesn’t exist, and <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_ACCOUNT_DISABLED</samp>, if the user’s account has been disabled.</p>
<p class="TX">Finally, we’ll look at a log-off event, generated when a logon session is deleted. This typically occurs when no <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> objects that reference the logon session remain. Run the command in <a href="chapter15.xhtml#Lis15-26">Listing 15-26</a> as an administrator.</p>
<span id="Lis15-26"></span><pre><code>PS&gt; <b>Get-WinEvent -FilterHashtable @{logname='Security';id=@(4634)} |</b>
<b>Select-Object -ExpandProperty Message</b>
An account was logged off.

Subject:
    Security ID:    S-1-5-21-1195776225-522706947-2538775957-1110
    Account Name:   alice
    Account Domain: MINERAL
    Logon ID:       0x15CB183

Logon Type:        2
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 15-26: A log-off authentication event log record</span></p>
<p class="TX">This event log record is much simpler than those for successful or failed authentication. It contains just the subject information, including the username and domain. To match a successful authentication event to the corresponding log-off event, you can compare the logon IDs.</p>
</section>
<section aria-labelledby="sec18" epub:type="division">
<h3 class="H1" id="sec18"><span id="h1-119"></span><samp class="SANS_Futura_Std_Bold_B_11">Worked Examples</samp></h3>
<p class="TNI1">Let’s finish with some worked examples using the commands you’ve learned about in this chapter.</p>
<section aria-labelledby="sec19" epub:type="division">
<h4 class="H2" id="sec19"><span id="h2-168"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Identifying the Reason for an Authentication Failure</samp></h4>
<p class="TNI1">I noted in the previous section that you’ll see two status codes in the event log when an authentication process fails: there’s the main status, typically <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_LOGON_FAILURE</samp>, and a sub-status, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_WRONG_PASSWORD</samp>. Unfortunately, the event log automatically converts only the main status code to a string, then typically generates a generic “The username or password is incorrect” message that isn’t very helpful in diagnosing <span aria-label=" Page 528. " epub:type="pagebreak" id="pg_528" role="doc-pagebreak"></span>authentication failures. Let’s write a quick script to analyze the event log records and convert the sub-status codes to messages automatically.</p>
<p class="TX">One immediate problem we must solve is how to get the sub-status code from the event log record. You could try to manually parse it from the text message. However, you’ll see different messages for different languages, and you might not be able to rely on the presence of a text string such as <samp class="SANS_TheSansMonoCd_W5Regular_11">SubStatus</samp>. The event log record, however, does contain all its important information as separate properties, and you can query for these using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Properties</samp> property on the event log record object. <a href="chapter15.xhtml#Lis15-27">Listing 15-27</a> shows the output generated by such a query.</p>
<span id="Lis15-27"></span><pre><code>PS&gt; <b>$record = Get-WinEvent -FilterHashtable @{logname='Security';id=@(4634)} | Select -First 1</b>
PS&gt; <b>$record.Properties</b>
Value
-----
S-1-5-21-1195776225-522706947-2538775957-1110
alice
MINERAL
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 15-27: Displaying an event log’s record properties</span></p>
<p class="TX">Unfortunately, the list of properties contains only the values, with no indication of the properties’ names. We want the property with the name <samp class="SANS_TheSansMonoCd_W5Regular_11">SubStatus</samp>, which might always be at the same index in the properties list, but there is no guarantee that will always be the case. So, to get this information we must manually inspect the XML that stores the event log’s properties. We can request this by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ToXml</samp> method on the record. <a href="chapter15.xhtml#Lis15-28">Listing 15-28</a> shows how to extract named properties from an event log record.</p>
<span id="Lis15-28"></span><pre><code>PS&gt; <b>function Get-EventLogProperty {</b>
    <b>[CmdletBinding()]</b>
    <b>param(</b>
        <b>[parameter(Mandatory, Position = 0, ValueFromPipeLine)]</b>
        <b>[System.Diagnostics.Eventing.Reader.EventRecord]$Record</b>
    <b>)</b>

    <b>PROCESS {</b>
      <span aria-label="annotation1" class="CodeAnnotationCode2">❶</span><b> $xml = [xml]$Record.ToXml()</b>
        <b>$ht = @{</b>
            <b>TimeCreated = $Record.TimeCreated</b>
            <b>Id = $Record.Id</b>
        <b>}</b>
<b>      </b><span aria-label="annotation2" class="CodeAnnotationCode2">❷</span><b> foreach($ent in $xml.Event.EventData.data) {</b>
<b>            $ht.Add($ent.Name, $ent."#text")</b>
<b>        }</b>
<b>        [PSCustomObject]$ht</b>
<b>    }</b>
<b>}</b>
PS&gt;<b> Get-EventLogProperty $record</b>
SubjectUserName<b>           </b>: alice
TimeCreated<b>               </b>: 2/24 1:15:06 PM
<span aria-label=" Page 529. " epub:type="pagebreak" id="pg_529" role="doc-pagebreak"></span>IpPort                    : -
SubjectLogonId            : 0x54541
KeyLength                 : 0
LogonProcessName          : Advapi
IpAddress                 : -
LmPackageName             : -
TransmittedServices       : -
WorkstationName           : GRAPHITE
SubjectUserSid            : S-1-5-21-1195776225-522706947-2538775957-1110
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span><b> </b>SubStatus                 : 0xc000006a
AuthenticationPackageName : Negotiate
SubjectDomainName         : MINERAL
ProcessName               : C:\Program<b> </b>Files\PowerShell\7\pwsh.exe
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span><b> </b>FailureReason             : %%2313
LogonType                 : 3
Id                        : 4625
Status                    : 0xc000006d
TargetUserSid             : S-1-0-0
TargetDomainName          : mineral.local
ProcessId                 : 0xe48
TargetUserName            : alice
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 15-28: Extracting the named event log record properties</span></p>
<p class="TX">We start by defining the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-EventLogProperty</samp> function, which will convert each record to a new object. We need to extract an event log record’s XML and then parse it into an XML document <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">EventData</samp> XML element stores the properties, so we use the object model PowerShell provides to extract each element and build a hash table from the property name and body text <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. We then convert the hash table to a custom PowerShell object to make it easier to query.</p>
<p class="TX">When inspecting the new object’s properties, we find that the <samp class="SANS_TheSansMonoCd_W5Regular_11">SubStatus</samp> property is now easily accessible <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. There are some limitations with our approach; for example, we haven’t converted the failure reason from a resource identifier to a string <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. However, we don’t need the failure reason, as we can get the message from the status code if we want it.</p>
<p class="TX">Now let’s expand our code to extract the sub-status for authentication failures (<a href="chapter15.xhtml#Lis15-29">Listing 15-29</a>).</p>
<span id="Lis15-29"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>function Get-AuthFailureStatus {</b>
    <b>[CmdletBinding()]</b>
    <b>param(</b>
        <b>[parameter(Mandatory, Position = 0, ValueFromPipeLine)]</b>
        <b>$Record</b>
    <b>)</b>

    <b>PROCESS {</b>
        <b>[PSCustomObject]@{</b>
            <b>TimeCreated = $Record.TimeCreated</b>
            <b>UserName = $Record.TargetUserName</b>
            <b>DomainName = $Record.TargetDomainName</b>
          <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span><b> SubStatus = (Get-NtStatus -Status $Record.SubStatus).StatusName</b>
<span aria-label=" Page 530. " epub:type="pagebreak" id="pg_530" role="doc-pagebreak"></span>        <b>}</b>
    <b>}</b>
<b>}</b>

<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>Get-NtToken -Logon -User $env:USERNAME -Domain $env:USERDOMAIN</b>
<b>-Password "InvalidPassword"</b>
PS&gt; <b>Get-NtToken -Logon -User "NotARealUser" -Domain $env:USERDOMAIN -Password "pwd"</b>
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> PS&gt; <b>Get-WinEvent -FilterHashtable @{logname='Security';id=@(4625)} |</b>
<b>Select-Object -First 2 | Get-EventLogProperty | Get-AuthFailureStatus</b>
TimeCreated           UserName      DomainName  SubStatus
-----------           --------      ----------  ---------
2/24     <b> </b>1:15:06 PM  alice         MINERAL     STATUS_WRONG_PASSWORD
2/24/     1:14:45 PM  NotARealUser  MINERAL     STATUS_NO_SUCH_USER
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 15-29: Parsing authentication failure properties and converting their sub-status codes</span></p>
<p class="TX">We start by defining a function that converts the record properties into a simpler authentication failure object <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. We pull out only the timestamp, the username, and the domain name, and then convert the <samp class="SANS_TheSansMonoCd_W5Regular_11">SubStatus</samp> property to its NT status name <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>.</p>
<p class="TX">We then perform two failed authentications to generate some entries in the event log <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. We filter the log to return only authentication failure records, then convert the records in the pipeline <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. In the generated output, we can see two entries. The first has <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_WRONG_PASSWORD</samp> as the sub-status, indicating that the user was valid but the password was not. The second has <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_NO_SUCH_USER</samp>, which indicates that the user doesn’t exist.</p>
</section>
<section aria-labelledby="sec20" epub:type="division">
<h4 class="H2" id="sec20"><span id="h2-169"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using a Secure Channel to Extract a Server’s TLS Certificate</samp></h4>
<p class="TNI1">Next, let’s walk through a simple example of how to use the secure channel authentication protocol. We’ll make a TCP connection to a secure web server and extract its server certificate, then use it to retrieve details about the organization that might own the server and whether the certificate is valid.</p>
<p class="TX">Note that there are likely much better ways of getting the server’s certificate than the approach taken in this example. For example, most web browsers will allow you to display and export the certificate by browsing to the server. However, that wouldn’t help you learn much about how secure channel works. To get started, copy the contents of <a href="chapter15.xhtml#Lis15-30">Listing 15-30</a> into the script file <i>get_server_cert.ps1</i>.</p>
<span id="Lis15-30"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> param(
    [Parameter(Mandatory, Position = 0)]
    [string]$Hostname,
    [int]$Port = 443
)

$ErrorActionPreference = "Stop"

<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> function Get-SocketClient {
    param(
        [Parameter(Mandatory)]
<span aria-label=" Page 531. " epub:type="pagebreak" id="pg_531" role="doc-pagebreak"></span>        $Socket
    )

    $Socket.ReceiveTimeout = 1000
    $Socket.Client.NoDelay = $true
    $stream = $Socket.GetStream()
    return @{
        Reader = [System.IO.BinaryReader]::new($stream)
        Writer = [System.IO.BinaryWriter]::new($stream)
    }
}

<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> function Read-TlsRecordToken {
    param(
        [Parameter(Mandatory)]
        $Client
    )
    $reader = $Client.Reader
    $header = $reader.ReadBytes(5)
    $length = ([int]$header[3] -shl 8) -bor ($header[4])
    $data = @()
  <span aria-label="annotation4" class="CodeAnnotationCode2">❹</span> while($length -gt 0) {
        $next = $reader.ReadBytes($length)
        if ($next.Length -eq 0) {
            throw "End of stream."
        }
        $data += $next
        $length -= $next.Length
    }

    Get-LsaAuthToken -Token ($header+$data)
}

<span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> Use-NtObject($socket = [System.Net.Sockets.TcpClient]::new($Hostname, 443)) {
    $tcp_client = Get-SocketClient $socket

  <span aria-label="annotation6" class="CodeAnnotationCode2">❻</span> $credout = New-LsaCredentialHandle -Package "Schannel" -UseFlag Outbound
    $client = New-LsaClientContext -CredHandle $credout -Target $Hostname
-RequestAttribute ManualCredValidation

  <span aria-label="annotation7" class="CodeAnnotationCode2">❼</span> while(!(Test-LsaContext -Context $client)) {
      <span aria-label="annotation8" class="CodeAnnotationCode2">❽</span> if ($client.Token.Length -gt 0) {
            $tcp_client.Writer.Write($client.Token.ToArray())
        }

      <span aria-label="annotation9" class="CodeAnnotationCode2">❾</span> $record = Read-TlsRecordToken -Client $tcp_client
        Update-LsaClientContext -Client $client -Token $record
    }

  <span aria-label="annotation10" class="CodeAnnotationCode2">❿</span> $client.RemoteCertificate
}
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 15-30: A script for reading a TLS server certificate</span></p>
<p class="TX"><span aria-label=" Page 532. " epub:type="pagebreak" id="pg_532" role="doc-pagebreak"></span>We first define a couple of parameters, for the hostname of the server and the optional TCP port <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. HTTPS uses the well-known port 443; however, TLS is not restricted to only that port, so you can change it if you want to target a different service.</p>
<p class="TX">We then define a couple of functions. The first one, <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SocketClient</samp>, converts a TCP client object to a <samp class="SANS_TheSansMonoCd_W5Regular_11">BinaryReader</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">BinaryWriter</samp> <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. The TLS protocol has a relatively simple binary record structure, so using these classes makes it easier to parse the network traffic.</p>
<p class="TX">The second function, <samp class="SANS_TheSansMonoCd_W5Regular_11">Read-TlsRecordToken</samp>, reads a single TLS record from the server and returns it as an authentication token <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. We first read the 5-byte header from the record and extract the data’s length, then we read the data from the stream. Because TCP is a streaming protocol, there is no guarantee that all the required data will be returned in a single read, so you’ll have to perform the read in a loop until you’ve received everything you need <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>.</p>
<p class="TX">We now enter the body of the script. We start by making a TCP connection to the hostname and TCP port provided as arguments to the script <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>. We then convert the socket to the reader and writer objects. Next, we create the <samp class="SANS_TheSansMonoCd_W5Regular_11">Schannel</samp> credentials and client context <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>, setting the client context target to the hostname and enabling manual credential validation, as we don’t really care if the server certificate is invalid for the purposes of this example.</p>
<p class="TX">We can now loop until the client context has completed authentication <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>. If there is a token to send to the server, we convert it to bytes and write it to the TCP socket <span aria-label="annotation8" class="CodeAnnotationCode">❽</span>. As we saw earlier, the TLS client and server can generate more than one TLS record, which the context must handle before generating a new token.</p>
<p class="TX">Once we’ve sent the client authentication token, we can read the next TLS record from the server and update the client <span aria-label="annotation9" class="CodeAnnotationCode">❾</span>. This loop will carry on until either the authentication completes successfully or an exception stops the script. Finally, we can return the server’s certificate from the script <span aria-label="annotation10" class="CodeAnnotationCode">❿</span>.</p>
<p class="TX"><a href="chapter15.xhtml#Lis15-31">Listing 15-31</a> shows how to use the script we wrote.</p>
<span id="Lis15-31"></span><pre><code>PS&gt; <b>$cert = .\get_server_cert.ps1 -Hostname www.microsoft.com</b>
PS&gt; <b>$cert</b>
Thumbprint                                Subject
----------                                -------
9B2B8AE65169AA477C5783D6480F296EF48CF14D  CN=www.microsoft.com,...

PS&gt; <b>$cert | Export-Certificate -FilePath output.cer</b>
    Directory: C:\demo
Mode               LastWriteTime           Length Name
----               -------------           ------ ----
-a----             02-21   17:10           2173   output.cer
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 15-31: Getting the server certificate for</span> <samp class="SANS_Futura_Std_Book_11">www.microsoft.com</samp> <span class="Futura_Std_Book_Oblique_I_11">and exporting it to a file</span></p>
<p class="TX">You call the script by providing the hostname of the server. Optionally, you could specify the TCP port, but in this case, we use port 443, better <span aria-label=" Page 533. " epub:type="pagebreak" id="pg_533" role="doc-pagebreak"></span>known as HTTPS, which is the script’s default. The returned certificate is an object you can inspect using PowerShell. You can also export the certificate to a file using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Export-Certificate</samp> command.</p>
</section>
</section>
<section aria-labelledby="sec21" epub:type="division">
<h3 class="H1" id="sec21"><span id="h1-120"></span><samp class="SANS_Futura_Std_Bold_B_11">Wrapping Up</samp></h3>
<p class="TNI1">This chapter began by describing security buffers and how they’re used to pass information back and forth with the SSPI APIs during network authentication and the encryption and signing processes. It then provided an overview of the Negotiate authentication protocol, which allows network authentication to take place when both parties aren’t sure ahead of time what authentication protocol to use.</p>
<p class="TX">Next, we looked at some less commonly used security packages, secure channel and CredSSP. These have specific niches but also more complex usage compared to NTLM or Kerberos. We also discussed anonymous and identity network authentication in NTLM and Kerberos and covered network authentication inside a lowbox token sandbox (and I described how I circumvented this authentication multiple times).</p>
<p class="TX">The chapter finished with an overview of the security audit events generated when a user authenticates. You learned about the different event types used to describe whether a user’s authentication succeeded or failed, and saw how to use these to figure out which users have attempted to authenticate to a workstation.</p>
</section>
<section aria-labelledby="sec22" epub:type="division">
<h3 class="H1" id="sec22"><span id="h1-121"></span><samp class="SANS_Futura_Std_Bold_B_11">Final Thoughts</samp></h3>
<p class="TNI1">As we wrap up this final chapter, I hope you’ll apply the information you’ve learned here about the internals of Windows security to your own endeavors. I’ve covered many areas in detail, ranging from the Security Reference Monitor and tokens to access checking and authentication, providing examples to demonstrate important topics.</p>
<p class="TX">However, I wasn’t able to provide scripts to demonstrate every permutation of the features we discussed. For that reason, I recommend checking the help feature for the various commands provided with the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtObjectManager</samp> module and experimenting with their use. If you perform tests against a Windows virtual machine, there is little you can damage. (In fact, if your system develops a blue screen of death while you’re experimenting, it might be a good idea to dig into why, as you might have found a security vulnerability.)</p>
<p class="TX">Following this chapter are some additional reference materials: <a href="appendix-A.xhtml">Appendix A</a> contains a walkthrough for setting up a domain network for testing, and <a href="appendix-B.xhtml">Appendix B</a> contains a list of SDDL aliases.</p>
</section>
</section>
</div></body>
</html>