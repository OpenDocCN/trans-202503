<html><head></head><body>
<h2 class="h2" id="ch07"><span epub:type="pagebreak" id="page_159"/><strong><span class="big">7</span><br/>COMPOSITE DATA TYPES AND MEMORY OBJECTS</strong></h2>&#13;
<div class="image1"><img alt="Image" src="../images/comm1.jpg"/></div>&#13;
<p class="noindents">Composite data types are composed of other, more primitive, types. Examples include pointers, arrays, records or structures, tuples, and unions. Many high-level languages (HLLs) provide syntactical abstractions for these composite data types that make them easy to declare and use, while hiding their underlying complexities.</p>&#13;
<p class="indent">Though the costs of using these composite data types are not terrible, a programmer who doesn’t understand them can easily introduce inefficiencies into an application. This chapter provides an overview of those costs to better enable you to write great code.</p>&#13;
<h3 class="h3" id="sec7_1"><strong>7.1 Pointer Types</strong></h3>&#13;
<p class="noindent">A <em><a href="gloss01.xhtml#gloss01_194">pointer</a></em> is a variable whose value refers to some other object. High-level languages like Pascal and C/C++ hide the simplicity of pointers behind a wall of abstraction. This added complexity can be intimidating if you don’t <span epub:type="pagebreak" id="page_160"/>understand what’s going on behind the scenes. However, a little knowledge will go a long way toward easing your mind.</p>&#13;
<p class="indent">Let’s start with something simple: an array. Consider the following array declaration in Pascal:</p>&#13;
<p class="programs">M: array [0..1023] of integer;</p>&#13;
<p class="indent"><span class="literal">M</span> is an array with 1,024 integers in it, indexed from <span class="literal">M[0]</span> to <span class="literal">M[1023]</span>. Each array element can hold an integer value that is independent of the others. In other words, this array gives you 1,024 different integer variables, each of which you access via array index rather than by name.</p>&#13;
<p class="indent">The statement <span class="literal">M[0]:=100</span> stores the value <span class="literal">100</span> into the first element of the array <span class="literal">M</span>. Now consider the following two statements:</p>&#13;
<p class="programs">i := 0; (* assume i is an integer variable *)<br/>&#13;
M [i] := 100;</p>&#13;
<p class="indent">These two statements do the same thing as <span class="literal">M[0]:=100;</span>. You can use any integer expression in the range <span class="literal">0</span> through <span class="literal">1023</span> as an index of this array. The following statements <em>still</em> perform the same operation as the earlier statement:</p>&#13;
<p class="programs">i := 5;      (* assume all variables are integers*)<br/>&#13;
j := 10;<br/>&#13;
k := 50;<br/>&#13;
m [i * j - k] := 100;</p>&#13;
<p class="indent">But how about the following?</p>&#13;
<p class="programs">M [1] := 0;<br/>&#13;
M [ M [1] ] := 100;</p>&#13;
<p class="indent">Whoa! Now that takes a few moments to digest. However, if you take it slowly, you’ll realize that these two instructions perform the same operation as before. The first statement stores <span class="literal">0</span> into array element <span class="literal">M[1]</span>. The second statement fetches the value of <span class="literal">M[1]</span>, which is <span class="literal">0</span>, and uses that value to determine where it stores the value <span class="literal">100</span>.</p>&#13;
<p class="indent">If you’re willing to accept this example as reasonable—perhaps bizarre, but usable nonetheless—then you’ll have no problems with pointers, because <span class="literal">M[1]</span> is a pointer! Well, not really, but if you were to change <span class="literal">M</span> to “memory” and treat each element of this array as a separate memory location, then this meets the definition of a pointer—that is, a memory variable whose value is the address of some other memory object.</p>&#13;
<h4 class="h4" id="sec7_1_1"><strong><em>7.1.1 Pointer Implementation</em></strong></h4>&#13;
<p class="noindent">Although most languages implement pointers using memory addresses, a pointer is actually an abstraction of a memory address. Therefore, a language could define a pointer using any mechanism that maps the value <span epub:type="pagebreak" id="page_161"/>of the pointer to the address of some object in memory. Some implementations of Pascal, for example, use offsets from some fixed memory address as pointer values. Some languages (including dynamic languages like LISP) implement pointers by using <em>double indirection</em>; that is, the pointer object contains the address of some memory variable whose value is the address of the object to be accessed. This approach may seem convoluted, but it offers certain advantages in a complex memory management system. However, for simplicity’s sake, this chapter will assume that, as defined earlier, a pointer is a variable whose value is the address of some other object in memory.</p>&#13;
<p class="indent">As you’ve seen in examples from previous chapters, you can indirectly access an object using a pointer with two 32-bit 80x86 machine instructions (or with a similar sequence on other CPUs), as follows:</p>&#13;
<p class="programs">mov( PointerVariable, ebx );   // Load the pointer variable into a register.<br/>&#13;
mov( [ebx], eax );             // Use register indirect mode to access data.</p>&#13;
<p class="indent">Access to data via double indirection is less efficient than the straight pointer implementation because it takes an extra machine instruction to fetch the data from memory. This isn’t obvious in an HLL like C/C++ or Pascal, where you’d use double indirection as follows:</p>&#13;
<p class="programs">i = **cDblPtr;            // C/C++<br/>&#13;
i := ^^pDblPtr;           (* Pascal *)</p>&#13;
<p class="indent">This looks very similar to single indirection. In assembly language, however, you’ll see the extra work involved:</p>&#13;
<p class="programs">mov( hDblPtr, ebx );  // Get the pointer to a pointer.<br/>&#13;
mov( [ebx], ebx );    // Get the pointer to the value.<br/>&#13;
mov( [ebx], eax );    // Get the value.</p>&#13;
<p class="indent">Contrast this with the two earlier assembly instructions needed to access an object using single indirection. Because double indirection requires 50 percent more code than single indirection, many languages implement pointers using single indirection.</p>&#13;
<h4 class="h4" id="sec7_1_2"><strong><em>7.1.2 Pointers and Dynamic Memory Allocation</em></strong></h4>&#13;
<p class="noindent">Pointers typically reference anonymous variables that you allocate on the <em><a href="gloss01.xhtml#gloss01_109">heap</a></em> (a region in memory reserved for dynamic storage allocation) using memory allocation/deallocation functions like <span class="literal">malloc()</span>/<span class="literal">free()</span> in C, <span class="literal">new()</span>/<span class="literal">dispose()</span> in Pascal, and <span class="literal">new()</span>/<span class="literal">delete()</span> in C++ (note, however, that C++11 and later prefer <span class="literal">std::unique_ptr</span> and <span class="literal">std_shared_ptr</span> for memory allocation, with automatic memory deallocation). Java, Swift, C++11 (and later) and other more modern languages only provide a function equivalent to <span class="literal">new()</span>. These languages handle deallocation automatically via garbage collection.</p>&#13;
<p class="indent">Objects you allocate on the heap are known as <em><a href="gloss01.xhtml#gloss01_12">anonymous variables</a></em> because you refer to them by their address rather than by a name. And because the allocation functions return the address of an object on the heap, you <span epub:type="pagebreak" id="page_162"/>typically store the function’s return result into a pointer variable. While the pointer variable may have a name, that name applies to the pointer’s data (an address), not the object referenced by this address.</p>&#13;
<h4 class="h4" id="sec7_1_3"><strong><em>7.1.3 Pointer Operations and Pointer Arithmetic</em></strong></h4>&#13;
<p class="noindent">Most languages that provide the pointer data type let you assign addresses to pointer variables, compare pointer values for equality or inequality, and indirectly reference an object via a pointer. Some languages allow additional operations, as you’ll see in this section.</p>&#13;
<p class="indent">Many languages enable you to do limited arithmetic with pointers. At the very least, these languages provide the ability to add an integer constant to, or subtract one from, a pointer. To understand the purpose of these two arithmetic operations, note the syntax of the <span class="literal">malloc()</span> function in the C standard library:</p>&#13;
<p class="programs">ptrVar = malloc( <span class="EmpItalic1">bytes_to_allocate</span> );</p>&#13;
<p class="indent">The parameter you pass <span class="literal">malloc()</span> specifies the number of bytes of storage to allocate. A good C programmer generally supplies an expression like <span class="literal">sizeof(int)</span> as this parameter. The <span class="literal">sizeof()</span> function returns the number of bytes needed by its single parameter. Therefore, <span class="literal">sizeof(int)</span> tells <span class="literal">malloc()</span> to allocate at least enough storage for an <span class="literal">int</span> variable. Now consider the following call to <span class="literal">malloc()</span>:</p>&#13;
<p class="programs">ptrVar = malloc( sizeof( int ) * 8 );</p>&#13;
<p class="indent">If the size of an integer is 4 bytes, this call to <span class="literal">malloc()</span> will allocate storage for 32 bytes, at consecutive addresses in memory (see <a href="ch07.xhtml#ch07fig01">Figure 7-1</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/07fig01.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig01"/><em>Figure 7-1: Memory allocation with <span class="literal">malloc(sizeof(int) * 8)</span></em></p>&#13;
<p class="indent">The pointer that <span class="literal">malloc()</span> returns contains the address of the first integer in this set, so the C program can directly access only the very first of these eight integers. To access the individual addresses of the other seven integers, you need to add an integer offset to that <em>base</em> address. On machines that support byte-addressable memory (such as the 80x86), the address of each successive integer in memory is the address of the previous integer plus the integer’s size. For example, if a call to the C standard library <span class="literal">malloc()</span> routine returns the memory address <span class="literal">$0300_1000</span>, then the eight integers that <span class="literal">malloc()</span> allocates will reside at the memory addresses shown in <a href="ch07.xhtml#ch07tab01">Table 7-1</a>.</p>&#13;
<p class="tabcap"><span epub:type="pagebreak" id="page_163"/><a id="ch07tab01"/><strong>Table 7-1:</strong> Integer Addresses Allocated for Base Address <span class="literal">$0300_1000</span></p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Integer</strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Memory addresses</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">0</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">$0300_1000..$0300_1003</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">1</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">$0300_1004..$0300_1007</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">2</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">$0300_1008..$0300_100b</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">3</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">$0300_100c..$0300_100f</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">4</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">$0300_1010..$0300_1013</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">5</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">$0300_1014..$0300_1017</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">6</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">$0300_1018..$0300_101b</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">7</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">$0300_101c..$0300_101f</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h5 class="h5" id="sec7_1_3_1"><strong>7.1.3.1 Adding an Integer to a Pointer</strong></h5>&#13;
<p class="noindent">Because these integers described in the preceding section are exactly 4 bytes apart, we add 4 to the address of the first integer to obtain the address of the second integer; add 4 to the address of the second integer to get the address of the third integer; and so on. In assembly language, we could access these eight integers using the following code:</p>&#13;
<p class="programs">malloc( @size( int32 ) * 8 );  // Returns storage for eight int32 objects.<br/>&#13;
                               // EAX points at this storage.<br/>&#13;
mov( 0, ecx );<br/>&#13;
mov( ecx, [eax] );             // Zero out the 32 bytes (4 bytes<br/>&#13;
mov( ecx, [eax+4] );           // at a time).<br/>&#13;
mov( ecx, [eax+8] );<br/>&#13;
mov( ecx, [eax+12] );<br/>&#13;
mov( ecx, [eax+16] );<br/>&#13;
mov( ecx, [eax+20] );<br/>&#13;
mov( ecx, [eax+24] );<br/>&#13;
mov( ecx, [eax+28] );</p>&#13;
<p class="indent">Notice the use of the 80x86 indexed addressing mode to access the eight integers that <span class="literal">malloc()</span> allocates. The EAX register maintains the base (first) address of the eight integers that this code allocates, and the constant in the addressing mode of the <span class="literal">mov()</span> instructions selects the offset of the specific integer from this base address.</p>&#13;
<p class="indent">Most CPUs use byte addresses for memory objects. Therefore, when a program allocates multiple copies of some <em>n</em>-byte object in memory, the objects won’t begin at consecutive memory addresses; instead, they’ll appear in memory at addresses that are <em>n</em> bytes apart. Some machines, however, don’t allow a program to access memory at an arbitrary address in memory; rather, they require it to access data on address boundaries that are a multiple of a word, a double word, or even a quad word. Any attempt to access memory on some other boundary will raise an exception and potentially halt the application. If an HLL supports pointer arithmetic, it must account for this fact and provide a generic pointer arithmetic scheme that’s portable across many different CPU architectures. The most common <span epub:type="pagebreak" id="page_164"/>solution that HLLs use when adding an integer offset to a pointer is to multiply that offset by the size of the object that the pointer references. That is, if you’ve got a pointer <span class="literal">p</span> to a 16-byte object in memory, then <span class="literal">p + 1</span> points 16 bytes beyond the address where <span class="literal">p</span> points. Likewise, <span class="literal">p + 2</span> points 32 bytes beyond that address. As long as the size of the data object is a multiple of the required alignment size (which the compiler can enforce by adding padding bytes, if necessary), this scheme avoids problems on those architectures that require aligned data access.</p>&#13;
<p class="indent">Note that the addition operator only makes sense between a pointer and an integer value. For example, in C/C++ you can indirectly access objects in memory using an expression like <span class="literal">*(p + i)</span> (where <span class="literal">p</span> is a pointer to an object and <span class="literal">i</span> is an integer value). It doesn’t make sense to add two pointers together, or to add other data types to a pointer. For example, adding a floating-point value to a pointer isn’t logical. (What would it mean to reference the data at some base address plus 1.5612?) Integers—signed and unsigned—are the only reasonable values to add to a pointer.</p>&#13;
<p class="indent">On the other hand, not only can you add an integer to a pointer, but you can also add a pointer to an integer and the result is still a pointer (both <span class="literal">p</span> <span class="literal">+</span> <span class="literal">i</span> and <span class="literal">i</span> <span class="literal">+</span> <span class="literal">p</span> are legal). This is because addition is <em><a href="gloss01.xhtml#gloss01_55">commutative</a></em>—the order of the operands does not affect the result.</p>&#13;
<h5 class="h5" id="sec7_1_3_2"><strong>7.1.3.2 Subtracting an Integer from a Pointer</strong></h5>&#13;
<p class="noindent">Subtracting an integer from a pointer references a memory location immediately before the address held in the pointer. However, subtraction is not commutative, and subtracting a pointer from an integer is not a legal operation (<span class="literal">p</span> <span class="literal">-</span> <span class="literal">i</span> is legal, but <span class="literal">i</span> <span class="literal">-</span> <span class="literal">p</span> is not).</p>&#13;
<p class="indent">In C/C++ <span class="literal">*(p</span> <span class="literal">-</span> <span class="literal">i)</span> accesses the <span class="literal">ith</span><sup/> object immediately before the object at which <span class="literal">p</span> points. In 80x86 assembly language, as in assembly on many processors, you can also specify a negative constant offset when using an indexed addressing mode. For example:</p>&#13;
<p class="programs">mov( [ebx-4], eax );</p>&#13;
<p class="indent">Keep in mind that 80x86 assembly language uses byte offsets, not object offsets (as C/C++ does). Therefore, this statement loads into EAX the double word in memory immediately preceding the memory address in EBX.</p>&#13;
<h5 class="h5" id="sec7_1_3_3"><strong>7.1.3.3 Subtracting a Pointer from a Pointer</strong></h5>&#13;
<p class="noindent">In contrast to addition, it makes sense to subtract the value of one pointer variable from another. Consider the following C/C++ code, which proceeds through a string of characters looking for the first <span class="literal">e</span> character that follows the first <span class="literal">a</span> that it finds:</p>&#13;
<p class="programs">int distance;<br/>&#13;
char *aPtr;<br/>&#13;
char *ePtr;<br/>&#13;
    . . .<br/>&#13;
<span epub:type="pagebreak" id="page_165"/>aPtr = someString;    // Get ptr to start of string in aPtr.<br/><br/>&#13;
// While we're not at the end of the string and the current<br/>&#13;
// char isn't 'a':<br/><br/>&#13;
while( *aPtr != '\0' &amp;&amp; *aPtr != 'a' )<br/>&#13;
{<br/>&#13;
    aPtr = aPtr + 1;  // Move on to the next character pointed<br/>&#13;
                      // at by aPtr.<br/>&#13;
}<br/><br/>&#13;
// While we're not at the end of the string and the current <br/>&#13;
// character isn't 'e':<br/>&#13;
ePtr = aPtr;          // Start at the 'a' char (or end of string <br/>&#13;
                      // if no 'a').<br/>&#13;
while( *ePtr != '\0' &amp;&amp; *ePtr != 'a' )<br/>&#13;
{<br/>&#13;
    ePtr = ePtr + 1;  // Move on to the next character pointed at by aPtr.<br/>&#13;
}<br/><br/>&#13;
// Now compute the number of characters between the 'a' and the 'e' <br/>&#13;
// (counting the 'a' but not counting the 'e'):<br/><br/>&#13;
distance = (ePtr - aPtr);</p>&#13;
<p class="indent">Subtracting one pointer from the other produces the number of data objects that exist between them (in this case, <span class="literal">ePtr</span> and <span class="literal">aPtr</span> point at characters, so the subtraction result produces the number of characters, or bytes, between the two pointers).</p>&#13;
<p class="indent">The subtraction of two pointer values makes sense only if they both reference the same data structure (for example, pointing at characters within the same string, as in this C/C++ example) in memory. Although C/C++ (and certainly assembly language) will allow you to subtract two pointers that point at completely different objects in memory, the result will probably have very little meaning.</p>&#13;
<p class="indent">For pointer subtraction in C/C++, the base types of the two pointers must be identical (that is, the two pointers must contain the addresses of two objects whose types are identical). This restriction exists because pointer subtraction in C/C++ produces the number of objects, not the number of bytes, between the two pointers. It wouldn’t make any sense to compute the number of objects between a byte in memory and a double word in memory; would you be counting the number of bytes or the number of double words? In assembly language you can get away with this (and the result is always the number of bytes between the two pointers), but it still doesn’t make much sense semantically.</p>&#13;
<p class="indent">The subtraction of two pointers could return a negative number if the left pointer operand is at a lower memory address than the right pointer operand. Depending on your language and its implementation, you may need to take the absolute value of the result if you’re interested only in the distance between the two pointers and you don’t care which pointer contains the greater address.</p>&#13;
<h5 class="h5" id="sec7_1_3_4"><span epub:type="pagebreak" id="page_166"/><strong>7.1.3.4 Comparing Pointers</strong></h5>&#13;
<p class="noindent">Almost every language that supports pointers will let you compare two pointers to see whether or not they are equal. Comparing two pointers will tell you whether they reference the same object in memory. Some languages (such as assembly and C/C++) will also let you compare two pointers to see if one pointer is less than or greater than the other. Such a comparison only makes sense, however, if both pointers have the same base type and contain the address of some object within the same data structure (such as an array, string, or record). If you find that one pointer is less than the other, this tells you that it references an object within the data structure that appears before the object referenced by the second pointer. The converse is true for the greater-than comparison.</p>&#13;
<h3 class="h3" id="sec7_2"><strong>7.2 Arrays</strong></h3>&#13;
<p class="noindent">After strings, arrays are probably the most common composite (or <em>aggregate</em>) data type. Abstractly, an array is an aggregate data type whose members (elements) are all of the same type. You select a member from the array by specifying its array index with an integer (or with some value whose underlying representation is an integer, such as character, enumerated, and Boolean types). In this chapter, we’ll assume that the integer indices of an array are numerically contiguous (though this is not required). That is, if both <span class="literal">x</span> and <span class="literal">y</span> are valid indices of the array, and if <span class="literal">x</span> <span class="literal">&lt;</span> <span class="literal">y</span>, then all <span class="literal">i</span> such that <span class="literal">x</span> <span class="literal">&lt;</span> <span class="literal">i</span> <span class="literal">&lt;</span> <span class="literal">y</span> are also valid indices. We’ll also assume that array elements occupy contiguous locations in memory. Therefore, an array with five elements will appear in memory as shown in <a href="ch07.xhtml#ch07fig02">Figure 7-2</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/07fig02.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig02"/><em>Figure 7-2: Array layout in memory</em></p>&#13;
<p class="indent">The <em>base address</em> of an array is the address of its first element and occupies the lowest memory location. The second array element directly follows the first in memory, the third element follows the second, and so on. There is no requirement that the indices start at <span class="literal">0</span>; they can start with any number as long as they’re contiguous. However, we’ll begin arrays at index <span class="literal">0</span> unless there’s a good reason to do otherwise.</p>&#13;
<p class="indent">Whenever you apply the indexing operator to an array, the result is the array element specified by that index. For example, <span class="literal">A[i]</span> chooses the <span class="literal">i</span>th element from array <span class="literal">A</span>.</p>&#13;
<h4 class="h4" id="sec7_2_1"><span epub:type="pagebreak" id="page_167"/><strong><em>7.2.1 Array Declarations</em></strong></h4>&#13;
<p class="noindent">Array declarations are very similar across many HLLs. C, C++, and Java all let you declare an array by specifying the total number of elements in it. The syntax for an array declaration in these languages is as follows:</p>&#13;
<p class="programs"><span class="EmpItalic1">data_type</span>  <span class="EmpItalic1">array_name</span> [ <span class="EmpItalic1">number_of_elements</span> ];</p>&#13;
<p class="indent">Here are some sample C/C++ array declarations:</p>&#13;
<p class="programs">char CharArray[ 128 ];<br/>&#13;
int intArray[ 8 ];<br/>&#13;
unsigned char ByteArray[ 10 ];<br/>&#13;
int *PtrArray[ 4 ];</p>&#13;
<p class="indent">If you declare these arrays as automatic variables, then C/C++ “initializes” them with whatever bit patterns exist in memory. If, on the other hand, you declare these arrays as static objects, then C/C++ zeros out each array element. If you want to initialize an array yourself, you can use the following C/C++ syntax:</p>&#13;
<p class="programs"><span class="EmpItalic1">data_type</span> <span class="EmpItalic1">array_name</span>[ <span class="EmpItalic1">number_of_elements</span> ] = {<span class="EmpItalic1">element_list</span>};</p>&#13;
<p class="indent">Here’s a typical example:</p>&#13;
<p class="programs">int intArray[8] = {0,1,2,3,4,5,6,7};</p>&#13;
<p class="indent">Swift array declarations are a bit different from other C-based languages. Swift array declarations take one of the following two (equivalent) forms:</p>&#13;
<p class="programs">var <span class="EmpItalic1">array_name</span> = Array&lt;<span class="EmpItalic1">element_type</span>&gt;()<br/>&#13;
var <span class="EmpItalic1">array_name</span> = [<span class="EmpItalic1">element_type</span>]()</p>&#13;
<p class="indent">Unlike other languages, arrays in Swift are purely dynamic. You don’t normally specify the number of elements when you first create the array; instead, you add elements to the array as needed using functions like <span class="literal">append()</span> or <span class="literal">insert()</span>. If you want to predeclare an array with some number of elements, you use this special array constructor form:</p>&#13;
<p class="programs">var <span class="EmpItalic1">array_name</span> = Array&lt;<span class="EmpItalic1">element_type</span>&gt;( repeating: <span class="EmpItalic1">initial_value</span>, count: <span class="EmpItalic1">elements</span>)</p>&#13;
<p class="indent">In this example, <span class="EmpItalic">initial_value</span> is a value of type <span class="EmpItalic">element_type</span> and <span class="EmpItalic">elements</span> is the number of array elements to create in the array. For example, the following Swift code creates two arrays of 100 <span class="literal">Int</span> values, each initialized to <span class="literal">0</span>:</p>&#13;
<p class="programs">var intArray = Array&lt;Int&gt;( repeating: 0, count: 100)<br/>&#13;
var intArray2 = [Int]( repeating: 0, count: 100)</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_168"/>You can still extend the size of this array (for example, by using the <span class="literal">append()</span> function); because Swift arrays are dynamic, their size can grow or shrink at runtime.</p>&#13;
<p class="indent">Swift arrays can be created with initial values, as these examples demonstrate:</p>&#13;
<p class="programs">var intArray = [1, 2, 3]<br/>&#13;
var strArray = ["str1", "str2", "str3"]</p>&#13;
<p class="indent">C# arrays are also dynamic objects; though their syntax is slightly different from Swift, the concept is the same:</p>&#13;
<p class="programs"><span class="EmpItalic1">type</span>[ ] <span class="EmpItalic1">array_name</span> = new <span class="EmpItalic1">type</span>[<span class="EmpItalic1">elements</span>];</p>&#13;
<p class="indent">Here, <span class="EmpItalic">type</span> is the data type (for example, <span class="literal">double</span> or <span class="literal">int</span>), <span class="EmpItalic">array_name</span> is the array variable name, and <span class="EmpItalic">elements</span> is the number of elements to allocate in the array.</p>&#13;
<p class="indent">You can also initialize C# arrays in a declaration as follows (other syntaxes are possible; this is just a simple example):</p>&#13;
<p class="programs">int[ ] intArray = {1, 2, 3};<br/>&#13;
string[ ] strArray = {"str1", "str2", "str3"};</p>&#13;
<p class="indent">The array declaration syntax in HLA (High-Level Assembly) takes the following form, which is semantically equivalent to the C/C++ declaration:</p>&#13;
<p class="programs"><span class="EmpItalic1">array_name</span> : <span class="EmpItalic1">data_type</span> [ <span class="EmpItalic1">number_of_elements</span> ];</p>&#13;
<p class="indent">Here are some examples of HLA array declarations that allocate storage for uninitialized arrays (the second example assumes that you have defined the <span class="literal">integer</span> data type in a <span class="literal">type</span> section of the HLA program):</p>&#13;
<p class="programs">static<br/><br/>&#13;
    CharArray: char[128];         // Character array with elements<br/>&#13;
                                  //  0..127.<br/>&#13;
    IntArray: integer[8];         // Integer array with elements 0..7.<br/>&#13;
    ByteArray: byte[10];          // Byte array with elements 0..9.<br/>&#13;
    PtrArray: dword[4];           // Double-word array with elements 0..3.</p>&#13;
<p class="indent">You can also initialize the array elements using declarations like the following:</p>&#13;
<p class="programs">RealArray: real32[8] := [ 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0 ];<br/>&#13;
IntegerAry: integer[8] := [ 8, 9, 10, 11, 12, 13, 14, 15 ];</p>&#13;
<p class="indent">Both of these definitions create arrays with eight elements. The first definition initializes each 4-byte <span class="literal">real32</span> array element with one of the values in the range <span class="literal">0.0</span> through <span class="literal">7.0</span>. The second declaration initializes each <span class="literal">integer</span> array element with one of the values in the range <span class="literal">8</span> through <span class="literal">15</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_169"/>Pascal/Delphi uses the following syntax to declare an array:</p>&#13;
<p class="programs"><span class="EmpItalic1">array_name</span> : array[ <span class="EmpItalic1">lower_bound</span>..<span class="EmpItalic1">upper_bound</span> ] of <span class="EmpItalic1">data_type</span>;</p>&#13;
<p class="indent">As in the previous examples, <span class="EmpItalic">array_name</span> is the identifier, and <span class="EmpItalic">data_type</span> is the type of each element in this array. Unlike C/C++, Java, Swift, and HLA, in Free Pascal/Delphi you specify the upper and lower bounds of the array rather than the array’s size. The following are typical array declarations in Pascal:</p>&#13;
<p class="programs">type<br/>&#13;
    ptrToChar = ^char;<br/>&#13;
var<br/>&#13;
    CharArray: array[0..127] of char;          // 128 elements<br/>&#13;
    IntArray: array[ 0..7 ] of integer;        // 8 elements<br/>&#13;
    ByteArray: array[0..9] of char;            // 10 elements<br/>&#13;
    PtrArray: array[0..3] of ptrToChar;        // 4 elements</p>&#13;
<p class="indent">Although these Pascal examples start their indices at <span class="literal">0</span>, Pascal does not require it. The following Pascal array declaration is also perfectly valid:</p>&#13;
<p class="programs">var<br/>&#13;
     ProfitsByYear : array[ 1998..2039 ] of real;  // 42 elements</p>&#13;
<p class="indent">The program that declares this array would use indices <span class="literal">1998</span> through <span class="literal">2039</span> when accessing elements of this array, not <span class="literal">0</span> through <span class="literal">41</span>.</p>&#13;
<p class="indent">Many Pascal compilers provide a very useful feature to help you locate defects in your programs. Whenever you access an element of an array, these compilers automatically insert code that will verify that the array index is within the bounds specified by the declaration. This extra code will stop the program if the index is out of range. For example, if an index into <span class="literal">Profits</span><span class="literal">ByYear</span> is outside the range <span class="literal">1998</span> through <span class="literal">2039</span>, the program will abort with an error.<sup><a href="footnotes.xhtml#fn7_1a" id="fn7_1">1</a></sup></p>&#13;
<p class="indent">Generally, array indices are integer values, though some languages allow other <em>ordinal types</em> (data types that use an underlying integer representation). For example, Pascal allows <span class="literal">char</span> and <span class="literal">boolean</span> array indices. In Pascal, it’s perfectly reasonable and useful to declare an array as follows:</p>&#13;
<p class="programs">alphaCnt : array[ 'A'..'Z' ] of integer;</p>&#13;
<p class="indent">You access elements of <span class="literal">alphaCnt</span> using a character expression as the array index. For example, consider the following Pascal code, which initializes each element of <span class="literal">alphaCnt</span> to <span class="literal">0</span> (assuming <span class="literal">ch:char</span> appears in the <span class="literal">var</span> section):</p>&#13;
<p class="programs">for ch := 'A' to 'Z' do<br/>&#13;
    alphaCnt[ ch ] := 0;</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_170"/>Assembly language and C/C++ treat most ordinal values as special instances of integer values, so they are legal array indices. Most implementations of BASIC allow a floating-point number as an array index, though BASIC always truncates the value to an integer before using it as an index.<sup><a href="footnotes.xhtml#fn7_2a" id="fn7_2">2</a></sup></p>&#13;
<h4 class="h4" id="sec7_2_2"><strong><em>7.2.2 Array Representation in Memory</em></strong></h4>&#13;
<p class="noindent">Abstractly, an array is a collection of variables that you access using an index. Semantically, we can define an array any way we please, as long as it maps distinct indices to distinct objects in memory and always maps the same index to the same object. In practice, however, most languages use a few common algorithms that provide efficient access to the array data.</p>&#13;
<p class="indent">The number of bytes of storage an array consumes is the product of the number of elements multiplied by the number of bytes per element in the array. Many languages also add a few bytes of padding at the end of the array so that the total length of the array is an even multiple of a nice value like 4 or 8 (on a 32- or 64-bit machine, a compiler may append bytes to the array in order to extend its length to some multiple of the machine’s word size). However, a program must <em>not</em> depend on these extra padding bytes, because they may or may not be present. Some compilers always put them in, some never do, and still others put them in depending on the type of object that immediately follows the array in memory.</p>&#13;
<p class="indent">Many optimizing compilers attempt to start an array at a memory address that is an even multiple of some common size like 2, 4, or 8 bytes. Effectively, this adds padding bytes before the beginning of the array or, if you prefer to think of it this way, after the previous object in memory (see <a href="ch07.xhtml#ch07fig03">Figure 7-3</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/07fig03.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig03"/><em>Figure 7-3: Adding padding bytes before an array</em></p>&#13;
<p class="indent">On machines that do not support byte-addressable memory, compilers that attempt to place the first element of an array on an easily accessed boundary will allocate storage for an array on whatever boundary the <span epub:type="pagebreak" id="page_171"/>machine supports. If the size of each array element is less than the minimum size memory object the CPU supports, the compiler implementer has two options:</p>&#13;
<ul>&#13;
<li class="noindent">Allocate the smallest accessible memory object for each element of the array.</li>&#13;
<li class="noindent">Pack multiple array elements into a single memory cell.</li>&#13;
</ul>&#13;
<p class="indent">The first option has the advantage of being fast, but it wastes memory because each array element carries along some extra storage that it doesn’t need. The second option is compact but slower, as it requires extra instructions to pack and unpack data when accessing array elements. Compilers on such machines often let you specify whether you want the data packed or unpacked so you can choose between space and speed.</p>&#13;
<p class="indent">If you’re working on a byte-addressable machine (like the 80x86), you probably don’t have to worry about this issue. However, if you’re using an HLL and your code might wind up running on a different machine in the future, you should choose an array organization that is efficient on all machines.</p>&#13;
<h4 class="h4" id="sec7_2_3"><strong><em>7.2.3 Accessing Elements of an Array</em></strong></h4>&#13;
<p class="noindent">If you allocate all the storage for an array in contiguous memory locations, and the first index of the array is <span class="literal">0</span>, then accessing an element of a one-dimensional array is simple. You can compute the address of any given element of an array using the following formula:</p>&#13;
<p class="programs"><span class="EmpItalic1">Element_Address</span> = <span class="EmpItalic1">Base_Address</span> + <span class="EmpItalic1">index</span> * <span class="EmpItalic1">Element_Size</span></p>&#13;
<p class="indent"><span class="EmpItalic">Element_Size</span> is the number of bytes that each array element occupies. Thus, if each array element is of type <span class="literal">byte</span>, the <span class="EmpItalic">Element_Size</span> field is <span class="literal">1</span> and the computation is very simple. If each element is a <span class="literal">word</span> (or another 2-byte type), then <span class="EmpItalic">Element_Size</span> is <span class="literal">2</span>, and so on.</p>&#13;
<p class="indent">Consider the following Pascal array declaration:</p>&#13;
<p class="programs">var  SixteenInts : array[ 0..15 ] of integer;</p>&#13;
<p class="indent">To access an element of the <span class="literal">SixteenInts</span> on a byte-addressable machine, assuming 4-byte integers, you’d use this calculation:</p>&#13;
<p class="programs"><span class="EmpItalic1">Element_Address</span> = AddressOf( SixteenInts ) + index * 4</p>&#13;
<p class="indent">In assembly language (where you would actually have to do this calculation manually rather than having the compiler do it for you), you’d use code like the following to access array element <span class="literal">SixteenInts[index]</span>:</p>&#13;
<p class="programs">mov( index, ebx );<br/>&#13;
mov( SixteenInts[ ebx*4 ], eax );</p>&#13;
<h4 class="h4" id="sec7_2_4"><span epub:type="pagebreak" id="page_172"/><strong><em>7.2.4 Multidimensional Arrays</em></strong></h4>&#13;
<p class="noindent">Most CPUs can easily handle one-dimensional arrays. Unfortunately, though, there’s no magic addressing mode that lets you easily access elements of multidimensional arrays. That takes some work and several machine instructions.</p>&#13;
<p class="indent">Before discussing how to declare or access multidimensional arrays, let’s look at how to implement them in memory. The first challenge is figuring out how to store a multidimensional object in a one-dimensional memory space.</p>&#13;
<p class="indent">Consider for a moment a Pascal array of the following form:</p>&#13;
<p class="programs">A:array[0..3,0..3] of char;</p>&#13;
<p class="indent">This array contains 16 bytes organized as four rows of four characters. We need to map each of the 16 bytes in this array to each of the 16 contiguous bytes in main memory. <a href="ch07.xhtml#ch07fig04">Figure 7-4</a> shows one way to do this.</p>&#13;
<div class="image"><img alt="image" src="../images/07fig04.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig04"/><em>Figure 7-4: Mapping a 4×4 array to sequential memory locations</em></p>&#13;
<p class="indent">The actual mapping is not important as long as it adheres to two rules:</p>&#13;
<ul>&#13;
<li class="noindent">No two entries in the array can occupy the same memory location(s).</li>&#13;
<li class="noindent">Each element in the array must always map to the same memory location.</li>&#13;
</ul>&#13;
<p class="indent">Therefore, you need a function with two input parameters—one for a row and one for a column value—that produces an offset into a contiguous block of 16 memory locations. Any function that satisfies these two constraints will work fine. However, what you really want is a mapping function that computes efficiently at runtime and works for arrays with any <span epub:type="pagebreak" id="page_173"/>number of dimensions and any bounds on those dimensions. While there are numerous functions that fit this bill, there are two categories that most HLLs use: <em><a href="gloss01.xhtml#gloss01_218">row-major ordering</a></em> and <em><a href="gloss01.xhtml#gloss01_54">column-major ordering</a></em>.</p>&#13;
<p class="indent">Before I actually describe row- and column-major ordering, let’s go over some terminology. The term <em>row index</em> describes a numeric index into a row; that is, if a single row were treated as a one-dimensional array, the row index would be the index into that array. <em>Column index</em> has a similar meaning; if a single column were treated as a one-dimensional array, the column index would be the index into that array. If you look back at <a href="ch07.xhtml#ch07fig04">Figure 7-4</a>, the numbers 0, 1, 2, and 3 above each column are the <em>column numbers</em>, and those same values to the left of the rows are the <em>row numbers</em>. It’s easy to get confused with this terminology because <em>the column number is the same value as the row index</em>; that is, the column number is equivalent to an index into any one of the four rows. Similarly, <em>a row number is the same value as a column index</em>. This book uses the terms <em>row index</em> and <em>column index</em>, but note that other authors may use the terms <em>row</em> and <em>column</em> to mean row number and column number.</p>&#13;
<h5 class="h5" id="sec7_2_4_1"><strong>7.2.4.1 Row-Major Ordering</strong></h5>&#13;
<p class="noindent">Row-major ordering assigns array elements to successive memory locations by moving across a row and then down the columns. <a href="ch07.xhtml#ch07fig05">Figure 7-5</a> demonstrates this mapping.</p>&#13;
<div class="image"><img alt="image" src="../images/07fig05.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig05"/><em>Figure 7-5: Row-major ordering</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_174"/>Row-major ordering is the method employed by most high-level programming languages, including Pascal, C/C++, Java, C#, Ada, and Modula-2. This organization is very easy to implement and easy to use in machine language. The conversion from a two-dimensional structure to a linear sequence is very intuitive. <a href="ch07.xhtml#ch07fig06">Figure 7-6</a> provides another view of the ordering of a 4×4 array.</p>&#13;
<div class="image"><img alt="image" src="../images/07fig06.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig06"/><em>Figure 7-6: Another view of row-major ordering for a 4×4 array</em></p>&#13;
<p class="indent">The function that converts the set of multidimensional array indices into a single offset is a slight modification of the formula for computing the address of an element of a one-dimensional array. The formula to compute the offset for a 4×4 two-dimensional row-major-ordered array given an access of this form:</p>&#13;
<p class="programs">A[ <span class="EmpItalic1">colindex</span> ][ <span class="EmpItalic1">rowindex</span> ]</p>&#13;
<p class="noindent">is as follows:</p>&#13;
<p class="programs"><span class="EmpItalic1">Element_Address</span> = <span class="EmpItalic1">Base_Address</span> + (<span class="EmpItalic1">colindex</span> * <span class="EmpItalic1">row_size</span> + <span class="EmpItalic1">rowindex</span>) * <span class="EmpItalic1">Element_Size</span></p>&#13;
<p class="indent">As usual, <span class="EmpItalic">Base_Address</span> is the address of the array’s first element (<span class="literal">A[0][0]</span> in this case) and <span class="EmpItalic">Element_Size</span> is the size of an individual element of the array, in bytes. <span class="EmpItalic">row_size</span> is the number of elements in one row of the array (<span class="literal">4</span>, in this case, because each row has four elements). Assuming <span class="EmpItalic">Element_Size</span> is <span class="literal">1</span>, this formula computes the offsets shown in <a href="ch07.xhtml#ch07tab02">Table 7-2</a> from the base address.</p>&#13;
<p class="tabcap"><span epub:type="pagebreak" id="page_175"/><a id="ch07tab02"/><strong>Table 7-2:</strong> Offsets for Two-Dimensional Row-Major-Ordered Array</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:35%"/>&#13;
<col style="width:35%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="tab_th"><strong>Column index</strong></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="tab_th"><strong>Row index</strong></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="tab_th"><strong>Offset into array</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">0</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">0</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">0</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">0</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">1</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">1</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">0</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">2</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">2</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">0</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">3</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">3</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">1</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">0</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">4</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">1</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">1</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">5</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">1</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">2</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">6</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">1</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">3</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">7</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">2</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">0</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">8</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">2</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">1</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">9</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">2</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">2</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">10</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">2</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">3</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">11</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">3</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">0</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">12</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">3</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">1</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">13</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">3</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">2</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">14</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">3</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">3</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">15</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The following C/C++ code access sequential memory locations in a row-major-ordered array:</p>&#13;
<p class="programs">for( int col=0; col &lt; 4; ++col )<br/>&#13;
{<br/>&#13;
    for( int row=0; row &lt; 4; ++row )<br/>&#13;
    {<br/>&#13;
        A[ col ][ row ] = 0;<br/>&#13;
    }<br/>&#13;
}</p>&#13;
<p class="indent">For a three-dimensional array, the formula to compute the offset into memory is only slightly more complex. Consider the following C/C++ array declaration:</p>&#13;
<p class="programs"><span class="EmpItalic1">someType</span> A[<span class="EmpItalic1">depth_size</span>][<span class="EmpItalic1">col_size</span>][<span class="EmpItalic1">row_size</span>];</p>&#13;
<p class="indent">If you have an array access similar to <span class="literal">A[</span><span class="EmpItalic">depth_index</span><span class="literal">][</span><span class="EmpItalic">col_index</span><span class="literal">][</span><span class="EmpItalic">row_index</span><span class="literal">]</span>, then the computation that yields the offset into memory is:</p>&#13;
<p class="programs">Address = <br/>&#13;
Base + ((<span class="EmpItalic1">depth_index</span> * <span class="EmpItalic1">col_size</span> + <span class="EmpItalic1">col_index</span>) * <span class="EmpItalic1">row_size</span> + <span class="EmpItalic1">row_index</span>) * <span class="EmpItalic1">Element_Size</span></p>&#13;
<p class="noindent">Again, <span class="EmpItalic">Element_Size</span> is the size, in bytes, of a single array element.</p>&#13;
<p class="indent">If you’ve got an <em>n</em>-dimensional array declared in C/C++ as follows:</p>&#13;
<p class="programs"><span class="EmpItalic1">dataType</span> A[bn-1][bn-2]...[b0];</p>&#13;
<p class="noindent">and you wish to access the following element of this array:</p>&#13;
<p class="programs">A[an-1][an-2]...[a1][a0]</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_176"/>then you can compute the address of a particular array element using the following algorithm:</p>&#13;
<p class="programs">Address := an-1<br/>&#13;
for i := n-2 downto 0 do<br/>&#13;
    Address := Address * bi + ai<br/>&#13;
Address := <span class="EmpItalic1">Base_Address</span> + <span class="EmpItalic1">Address</span> * <span class="EmpItalic1">Element_Size</span></p>&#13;
<h5 class="h5" id="sec7_2_4_2"><strong>7.2.4.2 Column-Major Ordering</strong></h5>&#13;
<p class="noindent">Column-major ordering, the other common array element address function, is used by FORTRAN and various dialects of BASIC (such as older versions of Microsoft BASIC) to index arrays. A column-major-ordered array is organized as shown in <a href="ch07.xhtml#ch07fig07">Figure 7-7</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/07fig07.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig07"/><em>Figure 7-7: Column-major ordering</em></p>&#13;
<p class="indent">The formula for computing the address of an array element when using column-major ordering is very similar to that for row-major ordering. The difference is that you reverse the order of the index and size variables in the computation. That is, rather than working from the leftmost index to the rightmost, you operate from right to left.</p>&#13;
<p class="indent">For a two-dimensional column-major array, the formula is as follows:</p>&#13;
<p class="programs"><span class="EmpItalic1">Element_Address</span> = <br/>&#13;
   <span class="EmpItalic1">Base_Address</span> + (<span class="EmpItalic1">rowindex</span> * <span class="EmpItalic1">col_size</span> + <span class="EmpItalic1">colindex</span>) * <span class="EmpItalic1">Element_Size</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_177"/>For a three-dimensional column-major array, the formula is the following:</p>&#13;
<p class="programs"><span class="EmpItalic1">Element_Address</span> = <br/>&#13;
   <span class="EmpItalic1">Base_Address</span> + <br/>&#13;
       ((<span class="EmpItalic1">rowindex</span> * <span class="EmpItalic1">col_size</span> + <span class="EmpItalic1">colindex</span>) * <span class="EmpItalic1">depth_size</span> + <span class="EmpItalic1">depthindex</span>) * <span class="EmpItalic1">Element_Size</span></p>&#13;
<p class="indent">And so on. Other than using these new formulas, accessing elements of an array using column-major ordering is identical to accessing arrays using row-major ordering.</p>&#13;
<h5 class="h5" id="sec7_2_4_3"><strong>7.2.4.3 Declaring Multidimensional Arrays</strong></h5>&#13;
<p class="noindent">An “<em>m</em> × <em>n</em>” array has <span class="literal">m</span> × <span class="literal">n</span> elements and requires <span class="literal">m</span> × <span class="literal">n</span> × <span class="EmpItalic">Element_Size</span> bytes of storage. To allocate storage for an array, you must reserve this amount of memory. With one-dimensional arrays, the syntax is very similar among the different HLLs. However, their syntax starts to diverge with multidimensional arrays.</p>&#13;
<p class="indent">In C, C++, and Java, you use the following syntax to declare a multidimensional array:</p>&#13;
<p class="programs"><span class="EmpItalic1">data_type</span> <span class="EmpItalic1">array_name</span> [dim1][dim2] . . . [dimn];</p>&#13;
<p class="indent">For example, here’s a three-dimensional array declaration in C/C++:</p>&#13;
<p class="programs">int threeDInts[ 4 ][ 2 ][ 8 ];</p>&#13;
<p class="indent">This example creates an array with 64 elements organized with a depth of 4 by 2 rows by 8 columns. Assuming each <span class="literal">int</span> object requires 4 bytes, this array consumes 256 bytes of storage.</p>&#13;
<p class="indent">Pascal’s syntax supports two equivalent ways of declaring multidimensional arrays:</p>&#13;
<p class="programs">var<br/>&#13;
        threeDInts  : array[0..3] of array[0..1] of array[0..7] of integer;<br/>&#13;
        threeDInts2 : array[0..3, 0..1, 0..7] of integer;</p>&#13;
<p class="indent">C# uses the following syntax to define multidimensional arrays:</p>&#13;
<p class="programs"><span class="EmpItalic1">type</span> [,]<span class="EmpItalic1">array_name</span> = new <span class="EmpItalic1">type</span> [dim1,dim2] ;<br/>&#13;
<span class="EmpItalic1">type</span> [,,]<span class="EmpItalic1">array_name</span> = new <span class="EmpItalic1">type</span> [dim1,dim2,dim3] ;<br/>&#13;
<span class="EmpItalic1">type</span> [,,,]<span class="EmpItalic1">array_name</span> = new <span class="EmpItalic1">type</span> [dim1,dim2,dim3,dim4] ;<br/>&#13;
etc.</p>&#13;
<p class="indent">Semantically, there are only two major differences among different languages. The first is whether the array declaration specifies the overall size of each array dimension or the upper and lower bounds. The second is whether the starting index is <span class="literal">0</span>, <span class="literal">1</span>, or a user-specified value.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_178"/>Swift doesn’t really support multidimensional arrays in the traditional sense. It allows you to create arrays of arrays (of arrays . . .), which can provide the same functionality as multidimensional arrays, but behave in subtly different ways. See “<a href="#sec7_2_4_5">Swift Array Implementation</a>” on page <a href="#sec7_2_4_5">179</a> for more details.</p>&#13;
<h5 class="h5" id="sec7_2_4_4"><strong>7.2.4.4 Accessing Elements of a Multidimensional Array</strong></h5>&#13;
<p class="noindent">It’s so easy to access an element of a multidimensional array in an HLL that many programmers do so without considering the associated costs. In this section, to give you a clearer picture of those costs, we’ll look at some of the assembly language sequences you’ll need to access elements of a multidimensional array.</p>&#13;
<p class="indent">Consider again the C/C++ declaration of the <span class="literal">ThreeDInts</span> array from the previous section:</p>&#13;
<p class="programs">int ThreeDInts[ 4 ][ 2 ][ 8 ];</p>&#13;
<p class="indent">In C/C++, if you wanted to set element <span class="literal">[i][j][k]</span> of this array to <span class="literal">n</span>, you’d probably use the following statement:</p>&#13;
<p class="programs">ThreeDInts[i][j][k] = n;</p>&#13;
<p class="indent">This statement, however, hides a great deal of complexity. Recall the formula needed to access an element of a three-dimensional array:</p>&#13;
<p class="programs"><span class="EmpItalic1">Element_Address</span> = <br/>&#13;
   <span class="EmpItalic1">Base_Address</span> + <br/>&#13;
      ((<span class="EmpItalic1">rowindex</span> * <span class="EmpItalic1">col_size</span> + <span class="EmpItalic1">colindex</span>) * <span class="EmpItalic1">depth_size</span> + <span class="EmpItalic1">depthindex</span>) * <br/>&#13;
          <span class="EmpItalic1">Element_Size</span></p>&#13;
<p class="indent">The <span class="literal">ThreeDInts</span> example does not avoid this calculation, it only hides it from you. The machine code that the C/C++ compiler generates is similar to the following:</p>&#13;
<p class="programs">intmul( 2, i, ebx );            // EBX = 2 * i<br/>&#13;
add( j, ebx );                  // EBX = 2 * i + j<br/>&#13;
intmul( 8, ebx );               // EBX = (2 * i + j) * 8<br/>&#13;
add( k, ebx );                  // EBX = (2 * i + j) * 8 + k<br/>&#13;
mov( n, eax );<br/>&#13;
mov( eax, ThreeDInts[ebx*4] );  // ThreeDInts[i][j][k] = n</p>&#13;
<p class="indent">Actually, <span class="literal">ThreeDInts</span> is special. The sizes of all the array dimensions are nice powers of 2. This means that the CPU can use shifts instead of multiplication instructions to multiply EBX by 2 and by 4 in this example. Because shifts are often faster than multiplication, a decent C/C++ compiler will generate the following code:</p>&#13;
<p class="programs">mov( i, ebx );<br/>&#13;
shl( 1, ebx );                  // EBX = 2 * i<br/>&#13;
add( j, ebx );                  // EBX = 2 * i + j<br/>&#13;
<span epub:type="pagebreak" id="page_179"/>shl( 3, ebx );                  // EBX = (2 * i + j) * 8<br/>&#13;
add( k, ebx );                  // EBX = (2 * i + j) * 8 + k<br/>&#13;
mov( n, eax );<br/>&#13;
mov( eax, ThreeDInts[ebx*4] );  // ThreeDInts[i][j][k] = n</p>&#13;
<p class="indent">Note that a compiler can use this faster code only if an array dimension is a power of 2; this is why many programmers attempt to declare arrays with those dimensions. Of course, if you must declare extra elements in the array to achieve this goal, you may wind up wasting space (especially with higher-dimensional arrays) to achieve only a small increase in speed.</p>&#13;
<p class="indent">For example, if you need a 10×10 array and you’re using row-major ordering, you could create a 10×16 array to allow the use of a shift (by 4) instruction rather than a multiply (by 10) instruction. When using column-major ordering, you’d probably want to declare a 16×10 array to achieve the same effect, since row-major calculation doesn’t use the size of the first dimension when calculating an offset into an array, and column-major calculation doesn’t use the size of the second dimension when calculating an offset. In either case, however, the array would wind up having 160 elements instead of 100 elements. Only you can decide if this extra space is worth the minor improvement in speed.</p>&#13;
<h5 class="h5" id="sec7_2_4_5"><strong>7.2.4.5 Swift Array Implementation</strong></h5>&#13;
<p class="noindent">Swift arrays are different from those found in many other languages. First of all, Swift arrays are an opaque type based on <span class="literal">struct</span> objects (rather than just a collection of elements in memory). Swift doesn’t guarantee that array elements appear in continuous memory locations. However, the language provides the following <span class="literal">ContiguousArray</span> type specification, which guarantees they’ll appear in contiguous memory locations (as in C/C++ and other languages):</p>&#13;
<p class="programs">var <span class="EmpItalic1">array_name</span> = ContiguousArray&lt;<span class="EmpItalic1">element_type</span>&gt;()</p>&#13;
<p class="indent">So far, so good. With contiguous arrays, the storage of the actual array data matches other languages. However, when you start declaring multidimensional arrays, the similarity ends. As noted earlier, Swift doesn’t actually have multidimensional arrays; instead, it supports <em>arrays of arrays</em>.</p>&#13;
<p class="indent">For most programming languages, where an array object is strictly the sequence of array elements in memory, an array of arrays and a multidimensional array are the same thing. However, Swift uses descriptor (<span class="literal">struct</span>-based) objects to specify an array. Like string descriptors, Swift arrays consist of a data structure containing various fields (like the current number of array elements and one or more pointers to the actual array data).</p>&#13;
<p class="indent">When you create an array of arrays, you’re actually creating an array of these descriptors, with each pointing at a subarray. Consider the following two (equivalent) Swift array-of-arrays declarations (<span class="literal">a1</span> and <span class="literal">a2</span>) and sample program:</p>&#13;
<p class="programs">import Foundation<br/><br/>&#13;
var a1 = [[Int]]()<br/><br/>&#13;
<span epub:type="pagebreak" id="page_180"/>var a2 = ContiguousArray&lt;Array&lt;Int&gt;&gt;()<br/>&#13;
a1.append( [1,2,3] )<br/>&#13;
a1.append( [4,5,6] )<br/>&#13;
a2.append( [1,2,3] )<br/>&#13;
a2.append( [4,5,6] )<br/><br/>&#13;
print( a1 )<br/>&#13;
print( a2 )<br/>&#13;
print( a1[0] )<br/>&#13;
print( a1[0][1] )</p>&#13;
<p class="indent">Running this program produces the following output:</p>&#13;
<p class="programs">[[1, 2, 3], [4, 5, 6]]<br/>&#13;
[[1, 2, 3], [4, 5, 6]]<br/>&#13;
[1, 2, 3]<br/>&#13;
2</p>&#13;
<p class="indent">For two-dimensional arrays you would expect this type of output. However, internally, <span class="literal">a1</span> and <span class="literal">a2</span> are one-dimensional arrays with two elements each. Those two elements are array descriptors that themselves point at arrays, each containing three elements.</p>&#13;
<p class="indent">It is unlikely that the six array elements associated with <span class="literal">a2</span> will appear in contiguous memory locations, even though <span class="literal">a2</span> is a <span class="literal">ContiguousArray</span> type. The two array descriptors held in <span class="literal">a2</span> may appear in contiguous memory locations, but that doesn’t necessarily carry over to the six data elements at which they collectively point.</p>&#13;
<p class="indent">Because Swift allocates arrays dynamically, the rows in a two-dimensional array could have differing element counts. Consider the following modification to the previous Swift program:</p>&#13;
<p class="programs">import Foundation<br/><br/>&#13;
var a2 = ContiguousArray&lt;Array&lt;Int&gt;&gt;()<br/>&#13;
a2.append( [1,2,3] )<br/>&#13;
a2.append( [4,5] )<br/><br/>&#13;
print( a2 )<br/>&#13;
print( a2[0] )<br/>&#13;
print( a2[0][1] )</p>&#13;
<p class="indent">Running this program produces the following output:</p>&#13;
<p class="programs">[[[1, 2, 3], [4, 5]]<br/>&#13;
[1, 2, 3]<br/>&#13;
2</p>&#13;
<p class="indent">The two rows in the <span class="literal">a2</span> array have differing sizes. This could be useful or a source of defects, depending on what you’re trying to accomplish.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_181"/>One way to get standard multidimensional array storage in Swift is to declare a one-dimensional <span class="literal">ContiguousArray</span> with sufficient elements for all the elements of the multidimensional array. Then use the row-major (or column-major) functionality, without the element size operand, to compute the index into the array.</p>&#13;
<h3 class="h3" id="sec7_3"><strong>7.3 Records/Structures</strong></h3>&#13;
<p class="noindent">Another major composite data structure is the Pascal <em><a href="gloss01.xhtml#gloss01_213">record</a></em> or C/C++ <em>structure</em>. The Pascal terminology is probably better, as it avoids confusion with the term <em>data structure</em>, so we’ll generally use <em>record</em> here.</p>&#13;
<p class="indent">An array is <em>homogeneous</em>, meaning that its elements are all of the same type. A record, on the other hand, is <em>heterogeneous</em>—its elements can have differing types. The purpose of a record is to let you encapsulate logically related values into a single object.</p>&#13;
<p class="indent">Arrays let you select a particular element via an integer index. With records, you must select an element, known as a <em><a href="gloss01.xhtml#gloss01_96">field</a></em>, by the field’s name. Each of the field names within the record must be unique; that is, you can’t use the same field name two or more times in the same record. However, all field names are local to their record, and you can reuse those names elsewhere in the program.</p>&#13;
<h4 class="h4" id="sec7_3_1"><strong><em>7.3.1 Records in Pascal/Delphi</em></strong></h4>&#13;
<p class="noindent">Here’s a typical record declaration for a <span class="literal">Student</span> data type in Pascal/Delphi:</p>&#13;
<p class="programs">type<br/>&#13;
    Student = <br/>&#13;
        record<br/>&#13;
            Name:     string (64);<br/>&#13;
            Major:    smallint;    // 2-byte integer in Delphi<br/>&#13;
            SSN:      string (11);<br/>&#13;
            Mid1:     smallint;<br/>&#13;
            Midt:     smallint;<br/>&#13;
            Final:    smallint;<br/>&#13;
            Homework: smallint;<br/>&#13;
            Projects: smallint;<br/>&#13;
        end;</p>&#13;
<p class="indent">Many Pascal compilers allocate all of the fields in contiguous memory locations. This means that Pascal will reserve the first 65 bytes for the name,<sup><a href="footnotes.xhtml#fn7_3a" id="fn7_3">3</a></sup> the next 2 bytes for the major code, the next 12 bytes for the Social Security number, and so on.</p>&#13;
<h4 class="h4" id="sec7_3_2"><span epub:type="pagebreak" id="page_182"/><strong><em>7.3.2 Records in C/C++</em></strong></h4>&#13;
<p class="noindent">Here’s the same declaration in C/C++:</p>&#13;
<p class="programs">typedef<br/>&#13;
    struct <br/>&#13;
    {<br/>&#13;
        char Name[65]; // Room for a 64-character zero-terminated string.<br/>&#13;
        short Major;   // Typically a 2-byte integer in C/C++<br/>&#13;
        char SSN[12];  // Room for an 11-character zero-terminated string.<br/>&#13;
        short Mid1;<br/>&#13;
        short Mid2;<br/>&#13;
        short Final;<br/>&#13;
        short Homework;<br/>&#13;
        short Projects<br/>&#13;
    } Student;</p>&#13;
<p class="indent">Because C++ structures are actually a specialized form of the class declaration, they behave differently from C structures and may include extra data in memory that is not present in the C variant. (This is why the memory storage for structures in C++ may be different; see “<a href="#sec7_3_5">Memory Storage of Records</a>” on page <a href="#sec7_3_5">184</a>). There are also differences in namespaces and other minor distinctions between C and C++ structures.</p>&#13;
<p class="indent">As it turns out, though, you can tell C++ to compile a true C <span class="literal">struct</span> definition using the <span class="literal">extern</span> <span class="literal">"C"</span> block as follows:</p>&#13;
<p class="programs">extern "C"<br/>&#13;
{<br/>&#13;
    struct <br/>&#13;
    {<br/>&#13;
        char Name[65]; // Room for a 64-character zero-terminated string.<br/>&#13;
        short Major;   // Typically a 2-byte integer in C/C++<br/>&#13;
        char SSN[12];  // Room for an 11-character zero-terminated string.<br/>&#13;
        short Mid1;<br/>&#13;
        short Mid2;<br/>&#13;
        short Final;<br/>&#13;
        short Homework;<br/>&#13;
        short Projects;<br/>&#13;
    } Student;<br/>&#13;
}</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Java doesn’t support anything corresponding to the C <span class="literal">struct</span>—it supports only classes (see “<a href="#sec7_5">Classes</a>” on page <a href="#sec7_5">192</a>).</em></p>&#13;
</div>&#13;
<h4 class="h4" id="sec7_3_3"><span epub:type="pagebreak" id="page_183"/><strong><em>7.3.3 Records in HLA</em></strong></h4>&#13;
<p class="noindent">In HLA, you can also create structure types using the <span class="literal">record</span>/<span class="literal">endrecord</span> declaration. For example, you would encode the record from the previous sections as follows:</p>&#13;
<p class="programs">type<br/>&#13;
    Student:<br/>&#13;
        record<br/>&#13;
            Name:     char[65];    // Room for a 64-character<br/>&#13;
                                   // zero-terminated string.<br/>&#13;
            Major:    int16;<br/>&#13;
            SSN:      char[12];    // Room for an 11-character<br/>&#13;
                                   // zero-terminated string.<br/>&#13;
            Mid1:     int16;<br/>&#13;
            Mid2:     int16;<br/>&#13;
            Final:    int16;<br/>&#13;
            Homework: int16;<br/>&#13;
            Projects: int16;<br/>&#13;
        endrecord;</p>&#13;
<p class="indent">As you can see, the HLA declaration is very similar to the Pascal declaration. To stay consistent with the Pascal declaration, this example uses character arrays rather than strings for the <span class="literal">Name</span> and <span class="literal">SSN</span> (Social Security number) fields. In a typical HLA record declaration, you’d probably use a <span class="literal">string</span> type for at least the <span class="literal">Name</span> field (keeping in mind that a string variable is a 4-byte pointer).</p>&#13;
<h4 class="h4" id="sec7_3_4"><strong><em>7.3.4 Records (Tuples) in Swift</em></strong></h4>&#13;
<p class="noindent">Although Swift doesn’t support the concept of a record, you can simulate one using a Swift <em><a href="gloss01.xhtml#gloss01_247">tuple</a></em>. While Swift does not store record (tuple) elements in memory in the same way as other programming languages (see “<a href="#sec7_3_5">Memory Storage of Records</a>” on page <a href="#sec7_3_5">184</a>), tuples are a useful construct if you want to create a composite/aggregate data type without the overhead of a class.</p>&#13;
<p class="indent">A Swift tuple is simply a list of values in the following form:</p>&#13;
<p class="programs">( <span class="EmpItalic1">value</span>1, <span class="EmpItalic1">value</span>2, ..., <span class="EmpItalic1">value</span>n )</p>&#13;
<p class="indent">The types of the values within the tuple don’t need to be identical.</p>&#13;
<p class="indent">Swift typically uses tuples to return multiple values from functions. Consider the following short Swift code fragment:</p>&#13;
<p class="programs">func returns3Ints()-&gt;(Int, Int, Int )<br/>&#13;
{<br/>&#13;
    return(1, 2, 3)<br/>&#13;
}<br/>&#13;
var (r1, r2, r3) = returns3Ints();<br/>&#13;
print( r1, r2, r3 )</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_184"/>The <span class="literal">returns3Ints()</span> function returns three values (<span class="literal">1</span>, <span class="literal">2</span>, and <span class="literal">3</span>). The following statement stores those three integer values into <span class="literal">r1</span>, <span class="literal">r2</span>, and <span class="literal">r3</span>, respectively:</p>&#13;
<p class="programs">var (r1, r2, r3) = returns3Ints();</p>&#13;
<p class="indent">You can also assign tuples to a single variable and access “fields” of the tuple using integer indices as the field names:</p>&#13;
<p class="programs">let rTuple = ( "a", "b", "c" )<br/>&#13;
print( rTuple.0, rTuple.1, rTuple.2 ) // Prints "a b c"</p>&#13;
<p class="indent">Of course, using field names like <span class="literal">.0</span> results in very hard-to-maintain code. While you could create records out of tuples, referring to the fields by an integer index is rarely suitable in real-world programs.</p>&#13;
<p class="indent">Fortunately, Swift allows you to assign each tuple field a label, which you can then use instead of an integer index to refer to the field. Consider the following Swift code fragment:</p>&#13;
<p class="programs">typealias record = ( field1:Int, field2:Int, field3:Float64 )<br/><br/>&#13;
var r = record(1, 2, 3.0 )<br/>&#13;
print( r.field1, r.field2, r.field3 )  // prints "1 2 3.0"</p>&#13;
<p class="indent">Using Swift tuples this way is the syntactical equivalent of using a Pascal or HLA record (or a C structure). Keep in mind, however, that the storage of the tuple in memory might not map to the same layout as a record or structure in these other languages. Like arrays in Swift, tuples are an opaque type, without a guaranteed definition for how Swift will store them in memory.</p>&#13;
<h4 class="h4" id="sec7_3_5"><strong><em>7.3.5 Memory Storage of Records</em></strong></h4>&#13;
<p class="noindent">The following Pascal example demonstrates a typical <span class="literal">Student</span> variable declaration:</p>&#13;
<p class="programs">var<br/>&#13;
     John: Student;</p>&#13;
<p class="indent">Given the earlier declaration for the Pascal <span class="literal">Student</span> data type, this allocates 81 bytes of storage laid out in memory as shown in <a href="ch07.xhtml#ch07fig08">Figure 7-8</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/07fig08.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig08"/><em>Figure 7-8: Student data structure storage in memory</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_185"/>If the label <span class="literal">John</span> corresponds to the <em>base address</em> of this record, then the <span class="literal">Name</span> field is at offset <span class="literal">John+0</span>, the <span class="literal">Major</span> field is at offset <span class="literal">John+65</span>, the <span class="literal">SSN</span> field is at offset <span class="literal">John+67</span>, and so on.</p>&#13;
<p class="indent">Most programming languages let you refer to a record field by its name rather than by its numeric offset into the record. The typical syntax for field access uses the <em>dot operator</em> to select a field from a record variable. Given the variable <span class="literal">John</span> from the previous example, here’s how you could access various fields in this record:</p>&#13;
<p class="programs">John.Mid1 = 80;              // C/C++ example<br/>&#13;
John.Final := 93;            (* Pascal example *)<br/>&#13;
mov( 75, John.Projects );    // HLA example</p>&#13;
<p class="indent"><a href="ch07.xhtml#ch07fig08">Figure 7-8</a> suggests that all fields of a record appear in memory in the order of their declaration, and this is usually the case in practice. In theory, though, a compiler can freely place the fields anywhere in memory that it chooses. The first field usually appears at the lowest address in the record, the second field appears at the next highest address, the third field follows the second field in memory, and so on.</p>&#13;
<p class="indent"><a href="ch07.xhtml#ch07fig08">Figure 7-8</a> also suggests that compilers pack the fields into adjacent memory locations with no gaps between them. While this is true for many languages, it’s certainly not the most common memory organization for a record. For performance reasons, most compilers actually align the fields of a record on appropriate memory boundaries. The exact details vary by language, compiler implementation, and CPU, but a typical compiler places fields at an offset within the record’s storage area that is “natural” for that particular field’s data type. On the 80x86, for example, compilers that follow the Intel ABI (application binary interface) allocate 1-byte objects at any offset within the record, words only at even offsets, and double-word or larger objects on double-word boundaries. Although not all 80x86 compilers support the Intel ABI, most do, which allows records to be shared among functions and procedures written in different languages on the 80x86. Other CPU manufacturers provide their own ABI for their processors, and programs that adhere to an ABI can share binary data at runtime with other programs that adhere to the same ABI.</p>&#13;
<p class="indent">In addition to aligning the fields of a record at reasonable offset boundaries, most compilers also ensure that the length of the entire record is a multiple of 2, 4, 8, or even 16 bytes. As mentioned earlier in the chapter, they accomplish this by appending padding bytes to fill out the record’s size. This ensures that the record’s length is an even multiple of the size of the largest scalar (noncomposite data type) object in the record or the CPU’s optimal alignment size, whichever is smaller. For example, if a record has fields whose lengths are 1, 2, 4, 8, and 10 bytes, then an 80x86 compiler generally will pad the record’s length so that it is an even multiple of 8. This allows you to create an array of records and be assured that each record in the array starts at a reasonable address in memory.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_186"/>Although some CPUs don’t allow access to objects in memory at misaligned addresses, many compilers allow you to disable the automatic alignment of fields within a record. Generally, the compiler has an option you can use to globally disable this feature. Many compilers also provide a <span class="literal">pragma</span> or a <span class="literal">packed</span> keyword that lets you turn off field alignment on a record-by-record basis. Disabling the automatic field alignment feature may save some memory by eliminating the padding bytes between the fields and at the end of the record (again, provided that field misalignment is acceptable on your CPU). However, the program may run a little bit slower when it needs to access misaligned values in memory.</p>&#13;
<p class="indent">One reason to use a packed record is to gain manual control over the alignment of the record’s fields. For example, suppose you have a couple of functions written in two different languages, and both functions need to access some data in a record. Suppose also that the two compilers for these functions do not use the same field alignment algorithm. A record declaration like the following (in Pascal) may not be compatible with the way both functions access the record data:</p>&#13;
<p class="programs">type<br/>&#13;
    aRecord: record<br/>&#13;
        bField : byte;  (* assume Pascal compiler supports a byte type *)<br/>&#13;
        wField : word;  (* assume Pascal compiler supports a word type *)<br/>&#13;
        dField : dword; (* assume Pascal compiler supports a double-word type *)<br/>&#13;
    end; (* record *)</p>&#13;
<p class="indent">The problem here is that the first compiler could use the offsets 0, 2, and 4 for the <span class="literal">bField</span>, <span class="literal">wField</span>, and <span class="literal">dField</span> fields, respectively, while the second compiler might use offsets 0, 4, and 8.</p>&#13;
<p class="indent">Suppose, however, that the first compiler allows you to specify the <span class="literal">packed</span> keyword before the <span class="literal">record</span> keyword, causing the compiler to store each field immediately following the previous one. Although using the <span class="literal">packed</span> keyword doesn’t make the records compatible with both functions, it does allow you to manually add padding fields to the record declaration, as follows:</p>&#13;
<p class="programs">type<br/>&#13;
    aRecord: packed record<br/>&#13;
        bField   :byte;<br/>&#13;
        padding0 :array[0..2] of byte; (* add padding to dword align wField *)<br/>&#13;
        wField   :word;<br/>&#13;
        padding1 :word;                (* add padding to dword align dField *)<br/>&#13;
        dField   :dword; <br/>&#13;
    end; (* record *)</p>&#13;
<p class="indent">Adding padding manually can make code maintenance a real chore. However, if incompatible compilers need to share data, it’s a trick worth knowing. For the exact details on packed records, consult your language’s reference manual.</p>&#13;
<h3 class="h3" id="sec7_4"><span epub:type="pagebreak" id="page_187"/><strong>7.4 Discriminant Unions</strong></h3>&#13;
<p class="noindent">A discriminant union (or just <em><a href="gloss01.xhtml#gloss01_252">union</a></em>) is very similar to a record. Like records, unions have fields that you access using dot notation. In many languages, the only syntactical difference between records and unions is the use of the keyword <span class="literal">union</span> rather than <span class="literal">record</span>. Semantically, however, there’s a big difference between them. In a record, each field has its own offset from the base address of the record, and the fields do not overlap. In a union, however, all fields have the same offset, 0, and all the fields of the union overlap. As a result, the size of a record is the sum of the sizes of all the fields (plus, possibly, some padding bytes), whereas a union’s size is the size of its largest field (plus, possibly, some padding bytes at the end).</p>&#13;
<p class="indent">Because the fields of a union overlap, you might think it’s of little use in a real-world program. After all, if the fields all overlap, then changing the value of one field changes the values of all the others as well. This means that union fields are <em>mutually exclusive</em>—that is, you can use only one at a time. While it’s true that this makes unions less generally applicable than records, they still have many uses.</p>&#13;
<h4 class="h4" id="sec7_4_1"><strong><em>7.4.1 Unions in C/C++</em></strong></h4>&#13;
<p class="noindent">Here’s an example of a union declaration in C/C++:</p>&#13;
<p class="programs">typedef union<br/>&#13;
{<br/>&#13;
      unsigned int  i;<br/>&#13;
      float         r;<br/>&#13;
      unsigned char c[4];<br/><br/>&#13;
} unionType;</p>&#13;
<p class="indent">Assuming the C/C++ compiler allocates 4 bytes for unsigned integers, the size of a <span class="literal">unionType</span> object will be 4 bytes (because all three fields are 4-byte objects).</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Unfortunately, Java doesn’t support discriminant unions due to the safety issues involved. You can implement some features of discriminant unions using subclassing, but Java does not support explicitly sharing memory locations among different variables.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="sec7_4_2"><strong><em>7.4.2 Unions in Pascal/Delphi</em></strong></h4>&#13;
<p class="noindent">Pascal/Delphi use <em>case-variant records</em> to create a discriminant union. The syntax for a case-variant record is as follows:</p>&#13;
<p class="programs">type<br/>&#13;
    <span class="EmpItalic1">typeName</span> = <br/>&#13;
       record<br/>&#13;
            &lt;&lt;nonvariant/union record fields go here&gt;&gt;<br/>&#13;
<span epub:type="pagebreak" id="page_188"/>            case <span class="EmpItalic1">tag</span> of<br/>&#13;
                <span class="EmpItalic1">const1</span>:( <span class="EmpItalic1">field_declaration</span> );<br/>&#13;
                <span class="EmpItalic1">const2</span>:( <span class="EmpItalic1">field_declaration</span> );<br/>&#13;
                    .<br/>&#13;
                    .<br/>&#13;
                    .<br/>&#13;
                <span class="EmpItalic1">constn</span>:( <span class="EmpItalic1">field_declaration</span> )  (* no semicolon follows<br/>&#13;
                                            the last field *)<br/><br/>&#13;
        end;</p>&#13;
<p class="indent">In this example, <span class="EmpItalic">tag</span> is either a type identifier (such as <span class="literal">boolean</span>, <span class="literal">char</span>, or some user-defined type) or a field declaration of the form <span class="EmpItalic">identifier</span><span class="literal">:</span><span class="EmpItalic">type</span>. If the <span class="EmpItalic">tag</span> item takes this latter form, then <span class="EmpItalic">identifier</span> becomes another field of the record, not a member of the <em>variant section</em> (those declarations following the <span class="literal">case</span>), and has the specified <span class="EmpItalic">type</span>. In addition, the Pascal compiler could generate code that raises an exception whenever the application attempts to access any of the variant fields except the one specified by the value of the <span class="EmpItalic">tag</span> field. In practice, though, almost no Pascal compilers do this check. Still, keep in mind that the Pascal language standard suggests that compilers should do it, so some compilers out there might.</p>&#13;
<p class="indent">Here’s an example of two different case-variant record declarations in Pascal:</p>&#13;
<p class="programs">type<br/>&#13;
    noTagRecord=<br/>&#13;
        record<br/>&#13;
            someField: integer;<br/>&#13;
            case boolean of<br/>&#13;
                true:( i:integer );<br/>&#13;
                false:( b:array[0..3] of char)<br/>&#13;
        end; (* record *)<br/><br/>&#13;
    hasTagRecord=<br/>&#13;
        record<br/>&#13;
            case which:0..2 of<br/>&#13;
                0:( i:integer );<br/>&#13;
                1:( r:real );<br/>&#13;
                2:( c:array[0..3] of char )<br/>&#13;
        end; (* record *)</p>&#13;
<p class="indent">As you can see in the <span class="literal">hasTagRecord</span> union, a Pascal case-variant record does not require any normal record fields. This is true even if you do not have a tag field.</p>&#13;
<h4 class="h4" id="sec7_4_3"><span epub:type="pagebreak" id="page_189"/><strong><em>7.4.3 Unions in Swift</em></strong></h4>&#13;
<p class="noindent">Swift does not directly support the concept of a discriminant union. Unlike Java, however, Swift does provide an alternative—equivalent to Pascal’s case-variant record—that supports the safe use of unions: enumerated data types.</p>&#13;
<p class="indent">Consider the following Swift enumeration definition:</p>&#13;
<p class="programs">enum EnumType<br/>&#13;
{<br/>&#13;
    case a<br/>&#13;
    case b<br/>&#13;
    case c<br/>&#13;
}<br/><br/>&#13;
let et = EnumType.b<br/>&#13;
print( et )  // prints "b" on standard output</p>&#13;
<p class="indent">So far, this is just an enumerated data type that has nothing to do with unions. However, we can attach a value (actually, a tuple of values) to each case in an enumerated data type. Consider the following Swift program, which demonstrates <span class="literal">enum</span> <em><a href="gloss01.xhtml#gloss01_17">associated values</a></em>:</p>&#13;
<p class="programs">import Foundation<br/><br/>&#13;
enum EnumType<br/>&#13;
{<br/>&#13;
    case isInt( Int )<br/>&#13;
    case isReal( Double )<br/>&#13;
    case isString( String )<br/>&#13;
}<br/><br/>&#13;
func printEnumType( _ et:EnumType )<br/>&#13;
{<br/>&#13;
    switch( et )<br/>&#13;
    {<br/>&#13;
        case .isInt( let i ):<br/>&#13;
            print( i )<br/>&#13;
        case .isReal( let r ):<br/>&#13;
            print( r )<br/>&#13;
        case .isString( let s ):<br/>&#13;
            print( s )<br/>&#13;
    }<br/>&#13;
}<br/><br/>&#13;
let etI = EnumType.isInt( 5 )<br/>&#13;
let etF = EnumType.isReal( 5.0 )<br/>&#13;
let etS = EnumType.isString( "Five" )<br/><br/>&#13;
print( etI, etF, etS )<br/>&#13;
printEnumType( etI )<br/>&#13;
printEnumType( etF )<br/>&#13;
printEnumType( etS )</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_190"/>This program produces the following output:</p>&#13;
<p class="programs">isInt(5) isReal(5.0) isString("Five")<br/>&#13;
5<br/>&#13;
5.0<br/>&#13;
Five</p>&#13;
<p class="indent">A variable of type <span class="literal">EnumType</span> takes on one of the enumeration values <span class="literal">isInt</span>, <span class="literal">isReal</span>, or <span class="literal">isString</span> (these are the three constants of type <span class="literal">EnumType</span>). In addition to whatever internal encoding Swift chooses for these three constants (probably <span class="literal">0</span>, <span class="literal">1</span>, and <span class="literal">2</span>, though their actual values are irrelevant), Swift associates an integer value with <span class="literal">isInt</span>, a 64-bit double-precision floating-point value with <span class="literal">isReal</span>, and a string value with <span class="literal">isString</span>. The three <span class="literal">let</span> statements assign the appropriate values to <span class="literal">EnumType</span> variables; as you can see, to assign the value you include it in parentheses after the constant’s name. You can then extract the value using a <span class="literal">switch</span> statement.</p>&#13;
<h4 class="h4" id="sec7_4_4"><strong><em>7.4.4 Unions in HLA</em></strong></h4>&#13;
<p class="noindent">HLA supports unions as well; here’s a typical union declaration:</p>&#13;
<p class="programs">type<br/>&#13;
    unionType:<br/>&#13;
        union<br/>&#13;
            i: int32;<br/>&#13;
            r: real32;<br/>&#13;
            c: char[4];<br/>&#13;
        endunion;</p>&#13;
<h4 class="h4" id="sec7_4_5"><strong><em>7.4.5 Memory Storage of Unions</em></strong></h4>&#13;
<p class="noindent">As noted previously, the big difference between a union and a record is the fact that records allocate storage for each field at different offsets, whereas unions overlay all of the fields at the same offset in memory. For example, consider the following HLA record and union declarations:</p>&#13;
<p class="programs">type<br/>&#13;
    numericRec:<br/>&#13;
        record<br/>&#13;
            i: int32;<br/>&#13;
            u: uns32;<br/>&#13;
            r: real64;<br/>&#13;
        endrecord;<br/>&#13;
    numericUnion:<br/>&#13;
        union<br/>&#13;
            i: int32;<br/>&#13;
            u: uns32;<br/>&#13;
            r: real64;<br/>&#13;
        endunion;</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_191"/>If you declare a variable, <span class="literal">n</span>, of type <span class="literal">numericRec</span>, you access the fields as <span class="literal">n.i</span>, <span class="literal">n.u</span>, and <span class="literal">n.r</span>, exactly as though you had declared the <span class="literal">n</span> variable to be type <span class="literal">numericUnion</span>. However, the size of a <span class="literal">numericRec</span> object is 16 bytes, because the record contains two double-word fields and a quad-word (<span class="literal">real64</span>) field. The size of a <span class="literal">numericUnion</span> variable, though, is 8 bytes. <a href="ch07.xhtml#ch07fig09">Figure 7-9</a> shows the memory arrangement of the <span class="literal">i</span>, <span class="literal">u</span>, and <span class="literal">r</span> fields in both the record and union.</p>&#13;
<div class="image"><img alt="image" src="../images/07fig09.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig09"/><em>Figure 7-9: Layout of a union versus a record variable</em></p>&#13;
<p class="indent">Note that Swift <span class="literal">enum</span> types are opaque. They may not store the associated values from each enumeration case in the same memory address—and even if they currently do, there’s no guarantee they will in future versions of Swift.</p>&#13;
<h4 class="h4" id="sec7_4_6"><strong><em>7.4.6 Other Uses of Unions</em></strong></h4>&#13;
<p class="noindent">In addition to conserving memory, another common reason why programmers use unions is to create aliases in their code. An <em>alias</em> is a second name for some memory object. Although aliases are often a source of confusion in a program and should be used sparingly, sometimes it’s convenient to use them. For example, in some section of your program you might need to constantly use type coercion to refer to a particular object. To avoid this, you could use a union variable with each field representing one of the different types you want to use for the object. Consider the following HLA code fragment:</p>&#13;
<p class="programs">type<br/>&#13;
    CharOrUns:<br/>&#13;
        union<br/>&#13;
            c:char;<br/>&#13;
            u:uns32;<br/>&#13;
            endunion;<br/><br/>&#13;
static<br/>&#13;
    v:CharOrUns;</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_192"/>With a declaration like this, you can manipulate an <span class="literal">uns32</span> object by accessing <span class="literal">v.u</span>. If, at some point, you need to treat the LO byte of this <span class="literal">uns32</span> variable as a character, you can do so by simply accessing the <span class="literal">v.c</span> variable as follows:</p>&#13;
<p class="programs">mov( eax, v.u );<br/>&#13;
stdout.put( "v, as a character, is '", v.c, "'" nl );</p>&#13;
<p class="indent">Another common practice is to use unions to disassemble a larger object into its constituent bytes. Consider the following C/C++ code fragment:</p>&#13;
<p class="programs">typedef union<br/>&#13;
{<br/>&#13;
    unsigned int u;<br/>&#13;
    unsigned char bytes[4];<br/>&#13;
} asBytes;<br/><br/>&#13;
asBytes composite;<br/>&#13;
        .<br/>&#13;
        .<br/>&#13;
        .<br/>&#13;
    composite.u = 1234567890;<br/>&#13;
    printf<br/>&#13;
    ( <br/>&#13;
        "HO byte of composite.u is %u, LO byte is %u\n",<br/>&#13;
        composite.u[3],<br/>&#13;
        composite.u[0]<br/>&#13;
    );</p>&#13;
<p class="indent">Although composing and decomposing data types this way is a useful trick to employ every now and then, keep in mind that this code isn’t portable. The HO and LO bytes of a multibyte object appear at different addresses on big-endian versus little-endian machines. As a result, this code fragment works fine on little-endian machines, but fails to display the correct bytes on big-endian CPUs. Any time you use unions to decompose larger objects, you should be aware of this limitation. Still, this trick is usually much more efficient than using shift lefts, shift rights, and AND operations, so you’ll see it used quite a bit.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Swift’s type safety system does not allow you to access a collection of bits as different types using discriminant unions. If you really want to convert one type to another by raw bit assignment, you can use the Swift <span class="literal">unsafeBitCast()</span> function. See the Swift standard library documentation for more details.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="sec7_5"><strong>7.5 Classes</strong></h3>&#13;
<p class="noindent">At first glance, classes in a programming language like C++, Object Pascal, or Swift look like they are simple extensions to records (or structures) and should have a similar memory organization. Indeed, most programming <span epub:type="pagebreak" id="page_193"/>languages do organize class data fields in memory very similarly to records and structures. The compiler lays out the fields in sequential memory locations as it encounters them in a class declaration. However, classes have several additional features that you won’t find in pure record and structures; specifically, member functions (functions declared inside a class), inheritance, and polymorphism have a big impact on how compilers implement class objects in memory.</p>&#13;
<p class="indent">Consider the following HLA structure and HLA class declarations:</p>&#13;
<p class="programs">type<br/>&#13;
     student: record <br/>&#13;
          sName:    char[65]; <br/>&#13;
          Major:    int16; <br/>&#13;
          SSN:      char[12]; <br/>&#13;
          Midterm1: int16; <br/>&#13;
          Midterm2: int16; <br/>&#13;
          Final:    int16; <br/>&#13;
          Homework: int16; <br/>&#13;
          Projects: int16;  <br/>&#13;
     endrecord; <br/><br/>&#13;
     student2: class <br/>&#13;
          var <br/>&#13;
               sName:    char[65]; <br/>&#13;
               Major:    int16; <br/>&#13;
               SSN:      char[12]; <br/>&#13;
               Midterm1: int16; <br/>&#13;
               Midterm2: int16; <br/>&#13;
               Final:    int16; <br/>&#13;
               Homework: int16; <br/>&#13;
               Projects: int16;<br/><br/>&#13;
          method setName( source:string );<br/>&#13;
          method getName( dest:string );<br/>&#13;
          procedure create;  // Constructor for class<br/>&#13;
     endclass;</p>&#13;
<p class="indent">As with records, HLA allocates storage for all <span class="literal">var</span> fields in a class sequentially. Indeed, if a class consists only of <span class="literal">var</span> data fields, its memory representation is nearly identical to that of a corresponding record declaration (see <a href="ch07.xhtml#ch07fig10">Figures 7-10</a> and <a href="ch07.xhtml#ch07fig11">7-11</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/07fig10.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig10"/><em>Figure 7-10: Layout of the HLA <span class="literal">student</span> record</em></p>&#13;
<div class="image"><img alt="image" src="../images/07fig11.jpg"/></div>&#13;
<p class="figcap"><span epub:type="pagebreak" id="page_194"/><a id="ch07fig11"/><em>Figure 7-11: Layout of the HLA <span class="literal">student2</span> class</em></p>&#13;
<p class="indent">As you can see from these figures, the difference is the presence of the VMT pointer field at the beginning of the <span class="literal">student2</span> class data. <em><a href="gloss01.xhtml#gloss01_259">VMT</a></em>, which stands for <em><a href="gloss01.xhtml#gloss01_257">virtual method table</a></em>, is a pointer to an array of pointers to the methods (functions) associated with the class.<sup><a href="footnotes.xhtml#fn7_4a" id="fn7_4">4</a></sup> In the <span class="literal">student2</span> example, the VMT field would point at a table containing two 32-bit pointers—one pointing at the <span class="literal">setName()</span> method and one pointing at the <span class="literal">getName()</span> method. When a program calls one of the virtual methods <span class="literal">setName()</span> or <span class="literal">getName()</span> in this class, it does not call them directly at their address in memory. Instead, it fetches the address of the VMT from the object in memory, uses that pointer to fetch the specific method address (<span class="literal">setName()</span> will likely be at the first index into the VMT and <span class="literal">getName()</span> at the second), and then use the fetched address to call the method indirectly.</p>&#13;
<h4 class="h4" id="sec7_5_1"><strong><em>7.5.1 Inheritance</em></strong></h4>&#13;
<p class="noindent">Obtaining the method address from the VMT is a lot of work. Why would the compiled code do this rather than calling the method directly? The reason is because of a pair of magical features that classes and objects support: inheritance and polymorphism. Consider the following HLA class declaration:</p>&#13;
<p class="programs">type<br/>&#13;
        student3: class  inherits( student2 )<br/>&#13;
            var<br/>&#13;
                extraTime: int16; // Extra time allotted for exams<br/>&#13;
            override method setName;<br/>&#13;
            override procedure create;<br/>&#13;
     endclass;</p>&#13;
<p class="indent">The <span class="literal">student3</span> class inherits all the data fields and methods from the <span class="literal">student2</span> class (as specified by the <span class="literal">inherits</span> clause in the class declaration) and then defines a new data field, <span class="literal">extraTime</span>, that allots extra time, in minutes, for the student during examinations. The <span class="literal">student3</span> declaration also defines a new method, <span class="literal">setName()</span>, that replaces the original <span class="literal">setName()</span> method in the <span class="literal">student2</span> class (it also defines an overridden <span class="literal">create</span> procedure, but we’ll ignore this for now). The memory layout for a <span class="literal">student3</span> object appears in <a href="ch07.xhtml#ch07fig12">Figure 7-12</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/07fig12.jpg"/></div>&#13;
<p class="figcap"><span epub:type="pagebreak" id="page_195"/><a id="ch07fig12"/><em>Figure 7-12: Layout of the HLA <span class="literal">student3</span> class</em></p>&#13;
<p class="indent">In memory, the difference between the <span class="literal">student2</span> and <span class="literal">student3</span> objects is the extra 2 bytes at the end of the <span class="literal">student3</span> data structure and the value held by the VMT field. For <span class="literal">student2</span> objects the VMT field points at the VMT for the <span class="literal">student2</span> class (there is only one actual <span class="literal">student2</span> VMT in memory, and all <span class="literal">student2</span> objects contain a pointer to it). If we have a pair of <span class="literal">student2</span> objects named <span class="literal">John</span> and <span class="literal">Joan</span>, their VMT fields will both contain the address of the same VMT in memory, which has the information shown in <a href="ch07.xhtml#ch07tab03">Table 7-3</a>.</p>&#13;
<p class="tabcap"><a id="ch07tab03"/><strong>Table 7-3:</strong> VMT Entries for <span class="literal">student2</span> VMT</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Offset<sup><a href="footnotes.xhtml#fn7_5a" id="fn7_5">5</a></sup></strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Entry</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0 (bytes)</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">Pointer to the (<span class="literal">student2</span>) <span class="literal">setName()</span> method</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">4 (bytes)</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">Pointer to the <span class="literal">getName()</span> method</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Now consider the case where we have a <span class="literal">student3</span> object in memory (let’s name it <span class="literal">Jenny</span>). The memory layout for <span class="literal">Jenny</span> is similar to that of <span class="literal">John</span> and <span class="literal">Joan</span> (see <a href="ch07.xhtml#ch07fig11">Figures 7-11</a> and <a href="ch07.xhtml#ch07fig12">7-12</a>). However, whereas the VMT fields in <span class="literal">John</span> and <span class="literal">Joan</span> both contain the same value (a pointer to the <span class="literal">student2</span> VMT), the VMT field for the <span class="literal">Jenny</span> object will point at the <span class="literal">student3</span> VMT (see <a href="ch07.xhtml#ch07tab04">Table 7-4</a>).</p>&#13;
<p class="tabcap"><a id="ch07tab04"/><strong>Table 7-4:</strong> VMT Entries for <span class="literal">student3</span> VMT</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Offset</strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Entry</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0 (bytes)</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">Pointer to the (<span class="literal">student3</span>) <span class="literal">setName()</span> method</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">4 (bytes)</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">Pointer to the <span class="literal">getName()</span> method</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Although the <span class="literal">student3</span> VMT looks almost identical to the <span class="literal">student2</span> VMT, there is one critical difference: the first entry in <a href="ch07.xhtml#ch07tab03">Table 7-3</a> points at the <span class="literal">student2</span> <span class="literal">setName()</span> method, whereas the first entry in <a href="ch07.xhtml#ch07tab04">Table 7-4</a> points at the <span class="literal">student3</span> <span class="literal">setName()</span> method.</p>&#13;
<p class="indent">Adding fields inherited from a <em><a href="gloss01.xhtml#gloss01_23">base class</a></em> to another class must be done carefully. Remember, an important attribute of a class that inherits fields from a base class is that you can use a pointer to the base class to access <span epub:type="pagebreak" id="page_196"/>its fields, even if the pointer contains the address of some other class (that inherits the fields from the base class). Consider the following classes:</p>&#13;
<p class="programs">type  <br/>&#13;
     tBaseClass: class<br/>&#13;
          var<br/>&#13;
               i:uns32;<br/>&#13;
               j:uns32;<br/>&#13;
               r:real32;<br/><br/>&#13;
          method mBase;<br/>&#13;
     endclass;<br/><br/>&#13;
     tChildClassA: class inherits( tBaseClass )<br/>&#13;
          var<br/>&#13;
               c:char;<br/>&#13;
               b:boolean;<br/>&#13;
               w:word;<br/><br/>&#13;
          method mA;<br/>&#13;
     endclass;<br/><br/>&#13;
     tChildClassB: class inherits( tBaseClass )<br/>&#13;
          var<br/>&#13;
               d:dword;<br/>&#13;
               c:char;<br/>&#13;
               a:byte[3];<br/><br/>&#13;
     endclass;</p>&#13;
<p class="indent">Because both <span class="literal">tChildClassA</span> and <span class="literal">tChildClassB</span> inherit the fields of <span class="literal">tBaseClass</span>, these two child classes include the <span class="literal">i</span>, <span class="literal">j</span>, and <span class="literal">r</span> fields as well as their own specific fields.</p>&#13;
<p class="indent">For inheritance to work properly, the <span class="literal">i</span>, <span class="literal">j</span>, and <span class="literal">r</span> fields must appear at the same offsets in all child classes as they do in <span class="literal">tBaseClass</span>. This way, an instruction of the form <span class="literal">mov((type tBaseClass [ebx]).i, eax);</span> will correctly access the <span class="literal">i</span> field even if EBX points at an object of type <span class="literal">tChildClassA</span> or <span class="literal">tChildClassB</span>. <a href="ch07.xhtml#ch07fig13">Figure 7-13</a> shows the layout of the child and base classes.</p>&#13;
<p class="indent">Note that the new fields in the two child classes bear no relation to one another, even if they have the same name (for example, the <span class="literal">c</span> fields in the two child classes do not lie at the same offset). Although the two child classes share the fields they inherit from their common base class, any new fields they add are unique and separate. Two fields in different classes share the same offset only by coincidence if those fields are not inherited from a common base class.</p>&#13;
<p class="indent">All classes (even those that aren’t related to one another) place the pointer to the VMT at the same offset within the object (typically offset 0). There is a single VMT associated with each class in a program; even when classes inherit fields from some base class, their VMT (generally) differs from the base class’s VMT. <a href="ch07.xhtml#ch07fig14">Figure 7-14</a> shows how objects of type <span class="literal">tBaseClass</span>, <span class="literal">tChildClassA</span>, and <span class="literal">tChildClassB</span> point at their specific VMTs.</p>&#13;
<div class="image"><img alt="image" src="../images/07fig13.jpg"/></div>&#13;
<p class="figcap"><span epub:type="pagebreak" id="page_197"/><a id="ch07fig13"/><em>Figure 7-13: Layout of base and child classes in memory</em></p>&#13;
<div class="image"><img alt="image" src="../images/07fig14.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig14"/><em>Figure 7-14: VMT references from objects</em></p>&#13;
<p class="indent">Whenever a child class inherits fields from some base class, the child class’s VMT also inherits entries from the base class’s VMT. For example, the VMT for the class <span class="literal">tBaseClass</span> contains only a single entry—a pointer to the method <span class="literal">tBaseClass.mBase()</span>. The VMT for the class <span class="literal">tChildClassA</span> contains <span epub:type="pagebreak" id="page_198"/>two entries: pointers to <span class="literal">tBaseClass.mBase()</span> and <span class="literal">tChildClassA.mA()</span>. Because <span class="literal">tChildClassB</span> doesn’t define any new methods or iterators, its VMT contains only a single entry: a pointer to the <span class="literal">tBaseClass.mBase()</span> method. Note that <span class="literal">tChildClassB</span>’s VMT is identical to <span class="literal">tBaseclass</span>’s table. Nevertheless, HLA produces two distinct VMTs. <a href="ch07.xhtml#ch07fig15">Figure 7-15</a> shows this relationship.</p>&#13;
<div class="image"><img alt="image" src="../images/07fig15.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig15"/><em>Figure 7-15: Layout of base and child classes in memory</em></p>&#13;
<h4 class="h4" id="sec7_5_2"><strong><em>7.5.2 Class Constructors</em></strong></h4>&#13;
<p class="noindent">Before you can actually call any methods in a VMT, you have to make sure that the table is actually present in memory (holding the addresses of the methods defined in a class), and you also have to initialize the VMT pointer field in every class you create. If you’re using an HLL (such as C++, C#, Java, or Swift), the compiler will automatically generate the VMTs for you when you compile the class definitions. As for initializing the VMT pointer field in the object itself, that’s usually handled by the default constructor (object initialization function) for each class. All this work is hidden from an HLL programmer. That’s why these class examples are using HLA—in assembly language (even a high-level assembly language), very little is hidden from you. With HLA examples, then, you get to see exactly how objects work and the cost of using them.</p>&#13;
<p class="indent">To begin with, HLA does not automatically create the VMTs for you. You must explicitly declare them in your code for each class you define. For the <span class="literal">student2</span> and <span class="literal">student3</span> examples, you can declare them as follows:</p>&#13;
<p class="programs">readonly<br/>&#13;
      VMT( student2 );<br/>&#13;
      VMT( student3 );</p>&#13;
<p class="indent">Technically, these don’t have to appear in a <span class="literal">readonly</span> section (they could also appear in an HLA <span class="literal">static</span> section); however, you’ll never change the VMT values, so this section is a good place to declare them.</p>&#13;
<p class="indent">The <span class="literal">VMT</span> declarations in this example define two symbols you can access in the HLA program: <span class="literal">student2._VMT_</span> and <span class="literal">student3._VMT_</span>. These symbols correspond to the address of the first entry in each VMT. Somewhere in your code (typically in the constructor procedure), you need to initialize the VMT field of the object with the address of the VMT for the associated class. The HLA convention for the class constructors appears in the following code:</p>&#13;
<p class="programs">procedure student2.create; @noframe;<br/>&#13;
begin create;<br/>&#13;
<span epub:type="pagebreak" id="page_199"/>    push( eax );<br/><br/>&#13;
    // ESI will contain NULL if this is called as "student2.create();"<br/>&#13;
    // ESI will not be NULL if you call create from an object reference,<br/>&#13;
    // such as "John.create();" (in which case ESI will point at the object,<br/>&#13;
    // John in this case).<br/><br/>&#13;
    if( esi == NULL ) then<br/>&#13;
<br/>&#13;
        // If a class call, allocate storage for the object<br/>&#13;
        // on the heap.<br/><br/>&#13;
        mov( malloc( @size( student2 )), esi );<br/>&#13;
<br/>&#13;
    endif;<br/>&#13;
    mov( &amp;student2._VMT_, this._pVMT_ );<br/><br/>&#13;
    // If you're going to initialize other fields of the class, do that here.<br/><br/>&#13;
    pop( eax );<br/>&#13;
    ret();<br/>&#13;
<br/>&#13;
end create;<br/><br/>&#13;
procedure student3.create; @noframe;<br/>&#13;
begin create;<br/><br/>&#13;
    push( eax );<br/>&#13;
    if( esi == NULL ) then<br/>&#13;
<br/>&#13;
        mov( malloc( @size( student3 )), esi );<br/>&#13;
<br/>&#13;
    endif;<br/><br/>&#13;
    // Must call the base constructor to do any class initialization<br/>&#13;
    // it requires.<br/><br/>&#13;
    (type student2 [esi]).create();  // Must call the base class constructor.<br/><br/>&#13;
    // Might want to initialize any student3-specific fields (such <br/>&#13;
    // as extra time) here:<br/><br/>&#13;
    // student2.create filled in the VMT pointer with the address of the<br/>&#13;
    // student2 VMT. It really needs to point at the student3 VMT.<br/>&#13;
    // Fix that here.<br/><br/>&#13;
    mov( &amp;student3._VMT_, this._pVMT_ );<br/>&#13;
    pop( eax );<br/>&#13;
    ret();<br/>&#13;
<br/>&#13;
end create;</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_200"/><span class="literal">student2.create()</span> and <span class="literal">student3.create()</span> are <em>class procedures</em> (also known as <em>static class methods</em> or <em>functions</em> in some languages). The main point to class procedures is that the code calls them directly, not indirectly (that is, through the VMT). So, if you call <span class="literal">John.create()</span> or <span class="literal">Joan.create()</span>, you’re always going to call the <span class="literal">student2.create()</span> class procedure. Likewise, if you call <span class="literal">Jenny.create()</span>—or any <span class="literal">student3</span> variable’s <span class="literal">create</span> constructor—you’ll always be calling the <span class="literal">student3.create()</span> procedure.</p>&#13;
<p class="indent">The two statements:</p>&#13;
<p class="programs">mov( &amp;student2._VMT_, this._pVMT_ );<br/>&#13;
 <br/>&#13;
mov( &amp;student3._VMT_, this._pVMT_ );</p>&#13;
<p class="noindent">copy the address of the VMT (for the given class) into the VMT pointer field (<span class="literal">this._pVMT_</span>) in the objects being created.</p>&#13;
<p class="indent">Note the following statement in the <span class="literal">student3.create()</span> constructor:</p>&#13;
<p class="programs">(type student2 [esi]).create();  // Must call the base class constructor.</p>&#13;
<p class="noindent">Upon arriving at this point, the 80x86 ESI register contains a pointer to a <span class="literal">student3</span> object. The text <span class="literal">(type student2 [esi])</span> typecasts this to a <span class="literal">student2</span> pointer. This winds up calling the parent class’s constructor (in order to initialize any fields in the base class).</p>&#13;
<p class="indent">Finally, consider the following code:</p>&#13;
<p class="programs">var<br/>&#13;
    John        :pointer to student2;<br/>&#13;
    Joan        :pointer to student2;<br/>&#13;
    Jenny       :pointer to student3;<br/>&#13;
        .<br/>&#13;
        .<br/>&#13;
        .<br/>&#13;
    student2.create(); // Equivalent to calling "new student2"<br/>&#13;
                       // in other languages.<br/>&#13;
    mov( esi, John );  // Save pointer to new student2<br/>&#13;
                       // object in John<br/>&#13;
    student2.create();<br/>&#13;
    mov( esi, Joan );<br/>&#13;
    student3.create();<br/>&#13;
    mov( esi, Jenny );</p>&#13;
<p class="indent">If you look at the <span class="literal">_pVMT_</span> entries in the <span class="literal">John</span> and <span class="literal">Joan</span> objects, you’ll find that they contain the address of the VMT for the <span class="literal">student2</span> class. Likewise, the <span class="literal">_pVMT_</span> field of the <span class="literal">Jenny</span> object contains the address of the VMT for the <span class="literal">student3</span> class.</p>&#13;
<h4 class="h4" id="sec7_5_3"><span epub:type="pagebreak" id="page_201"/><strong><em>7.5.3 Polymorphism</em></strong></h4>&#13;
<p class="noindent">If you have an HLA <span class="literal">student2</span> variable (that is, a variable that contains a pointer to a <span class="literal">student2</span> object in memory), you can call the <span class="literal">setName()</span> method for that object using the following HLA code:</p>&#13;
<p class="programs">John.setName("John");<br/>&#13;
Joan.setName("Joan");</p>&#13;
<p class="indent">These particular calls are examples of high-level activity taking place in HLA. The machine code that the HLA compiler emits for the first of these statements looks something like the following:</p>&#13;
<p class="programs">mov( John, esi );<br/>&#13;
mov( (type student2 [esi])._pVMT_, edi );<br/>&#13;
call( [edi+0] );        // Note: the offset of the setName method in the VMT is 0.</p>&#13;
<p class="indent">Here’s what this code is doing:</p>&#13;
<ol>&#13;
<li class="noindent">The first line copies the address held in the <span class="literal">John</span> pointer into the ESI register. This is because most indirect accesses on the 80x86 take place in a register, not in memory variables.</li>&#13;
<li class="noindent">The VMT pointer is a field in the <span class="literal">student2</span> object structure. The code needs to obtain the pointer to the <span class="literal">setName()</span> method, held in the VMT. The <span class="literal">_pVMT_</span> field of the object (which is in memory) holds the address of the VMT. Once again, we must load this into a register to access that data indirectly. The program copies the VMT pointer into the 80x86 EDI register.</li>&#13;
<li class="noindent">The VMT (at which EDI now points) contains two entries. The first entry (offset 0) contains the address of the <span class="literal">student2.setName()</span> method; the second entry (offset 4) contains the address of the <span class="literal">student2.getName()</span> method. Because we want to call the <span class="literal">student2.setName()</span> method, the third instruction in this sequence calls the method at the address held in the memory location pointed at by <span class="literal">[edi+0]</span>.</li></ol>&#13;
<p class="indent">As you can see, this is quite a bit more work than calling <span class="literal">student.</span><span class="literal">setName()</span> directly. Why do we go through all this effort? After all, we know that <span class="literal">John</span> and <span class="literal">Joan</span> are both <span class="literal">student2</span> objects. We also know that <span class="literal">Jenny</span> is a <span class="literal">student3</span> object. So, we ought to be able to call the <span class="literal">student2.setName()</span> or <span class="literal">student3.setName()</span> methods directly. That would take only one machine instruction, which is both faster and shorter.</p>&#13;
<p class="indent">The reason for all this extra work is to support polymorphism. Suppose we declare a generic <span class="literal">student2</span> object:</p>&#13;
<p class="programs">var student:pointer to student2;</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_202"/>What happens when we assign the value of <span class="literal">Jenny</span> to <span class="literal">student</span> and call <span class="literal">student.setName()</span>? Well, the code sequence is identical to that for the call for <span class="literal">John</span> given earlier. That is, the code loads the pointer held in <span class="literal">student</span> into the ESI register, copies the <span class="literal">_pVMT_</span> field into the EDI register, and then jumps indirectly through the first entry of the VMT (which points at the <span class="literal">setName()</span> method). There is, however, one major difference between this example and the previous: in this case, <span class="literal">student</span> is pointing at a <span class="literal">student3</span> object in memory. So, when the code loads the address of the VMT into the EDI register, EDI is actually pointing at the <span class="literal">student3</span> VMT, not the <span class="literal">student2</span> VMT (as was the case when we used the <span class="literal">John</span> pointer). Therefore, when the program calls the <span class="literal">setName()</span> method, it’s actually calling the <span class="literal">student3.setName()</span> method, not the <span class="literal">student2.setName()</span> method. This behavior is the basis for polymorphism in modern object-oriented programming languages.</p>&#13;
<h4 class="h4" id="sec7_5_4"><strong><em>7.5.4 Abstract Methods and Abstract Base Classes</em></strong></h4>&#13;
<p class="noindent">An <em><a href="gloss01.xhtml#gloss01_2">abstract base class</a></em> exists solely to supply a set of common fields to its derived classes. You never declare variables whose type is an abstract base class; you always use one of the derived classes. An abstract base class is a template for creating other classes, nothing more.</p>&#13;
<p class="indent">The only difference in syntax between a standard base class and an abstract base class is the presence of at least one abstract method declaration. An <em><a href="gloss01.xhtml#gloss01_3">abstract method</a></em> is a special method that does not have an actual implementation in the abstract base class. Any attempt to call that method will raise an exception. If you’re wondering what possible good an abstract method could be, keep reading.</p>&#13;
<p class="indent">Suppose you want to create a set of classes to hold numeric values. One class could represent unsigned integers, another class could represent signed integers, a third could implement BCD values, and a fourth could support <span class="literal">real64</span> values. While you could create four separate classes that function independently of one another, doing so passes up an opportunity to make this set of classes more convenient to use. To understand why, consider the following HLA class declarations:</p>&#13;
<p class="programs">type  <br/>&#13;
     uint: class <br/>&#13;
          var <br/>&#13;
               TheValue: dword;<br/><br/>&#13;
          method put; <br/>&#13;
          &lt;&lt; Other methods for this class &gt;&gt;  <br/>&#13;
     endclass;<br/><br/>&#13;
     sint: class<br/>&#13;
          var<br/>&#13;
               TheValue: dword;<br/><br/>&#13;
          method put; <br/>&#13;
          &lt;&lt; Other methods for this class &gt;&gt;  <br/>&#13;
     endclass;<br/><br/>&#13;
<span epub:type="pagebreak" id="page_203"/>     r64: class<br/>&#13;
          var<br/>&#13;
               TheValue: real64;<br/><br/>&#13;
          method put; <br/>&#13;
          &lt;&lt; Other methods for this class &gt;&gt;  <br/>&#13;
     endclass;</p>&#13;
<p class="indent">The implementation of these classes is not unreasonable. They have fields for the data, and they have a <span class="literal">put()</span> method that, presumably, writes the data to the standard output device. They probably have other methods and procedures to implement various operations on the data. There are, however, two problems with these classes, one minor and one major, both occurring because these classes do not inherit any fields from a common base class.</p>&#13;
<p class="indent">The minor problem is that you have to repeat the declaration of several common fields in these classes. For example, the <span class="literal">put()</span> method is declared in each class.<sup><a href="footnotes.xhtml#fn7_6a" id="fn7_6">6</a></sup> The major problem is that this approach is not generic—that is, you can’t create a generic pointer to a “numeric” object and perform operations like addition, subtraction, and output on that value (regardless of the underlying numeric representation).</p>&#13;
<p class="indent">We can easily solve these two problems by turning the previous class declarations into a set of derived classes. The following code demonstrates an easy way to do this:</p>&#13;
<p class="programs">type<br/>&#13;
     numeric: class<br/>&#13;
          method put;<br/>&#13;
          &lt;&lt; Other common methods shared by all the classes &gt;&gt;<br/>&#13;
     endclass;<br/><br/>&#13;
     uint: class inherits( numeric )<br/>&#13;
          var<br/>&#13;
               TheValue: dword;<br/><br/>&#13;
          override method put;<br/>&#13;
          &lt;&lt; Other methods for this class &gt;&gt;<br/>&#13;
     endclass;<br/><br/>&#13;
     sint: class inherits( numeric )<br/>&#13;
          var<br/>&#13;
               TheValue: dword;<br/><br/>&#13;
          override method put;<br/>&#13;
          &lt;&lt; Other methods for this class &gt;&gt;<br/>&#13;
     endclass;<br/><br/>&#13;
     r64: class inherits( numeric )<br/>&#13;
          var<br/>&#13;
<span epub:type="pagebreak" id="page_204"/>               TheValue: real64;<br/><br/>&#13;
          override method put;<br/>&#13;
          &lt;&lt; Other methods for this class &gt;&gt;  <br/>&#13;
endclass;</p>&#13;
<p class="indent">First, by making the <span class="literal">put()</span> method inherit from <span class="literal">numeric</span>, this code encourages the derived classes to always use the name <span class="literal">put()</span>, which makes the program easier to maintain. Second, because this example uses derived classes, it’s possible to create a pointer to the <span class="literal">numeric</span> type and load that pointer with the address of a <span class="literal">uint</span>, <span class="literal">sint</span>, or <span class="literal">r64</span> object. The pointer can invoke the methods found in the <span class="literal">numeric</span> class to do functions like addition, subtraction, or numeric output. Therefore, the application that uses this pointer doesn’t need to know the exact data type; it deals with numeric values only in a generic fashion.</p>&#13;
<p class="indent">One problem with this scheme is that it’s possible to declare and use variables of type <span class="literal">numeric</span>. Unfortunately, such numeric variables aren’t capable of representing any type of number (notice that the data storage for the numeric fields actually appears in the derived classes). Worse, because you’ve declared the <span class="literal">put()</span> method in the <span class="literal">numeric</span> class, you actually have to write some code to implement that method even though you should never really call it; the actual implementation should occur only in the derived classes. While you could write a dummy method that prints an error message (or, better yet, raises an exception), you shouldn’t have to resort to that. Fortunately, there’s no reason to do so—if you use <em>abstract</em> methods.</p>&#13;
<p class="indent">The HLA <span class="literal">abstract</span> keyword, when it follows a method declaration, tells HLA that you aren’t going to provide an implementation of the method for this class. Instead, all derived classes are responsible for providing a concrete implementation for the abstract method. HLA will raise an exception if you attempt to call an abstract method directly. The following code modifies the <span class="literal">numeric</span> class to convert <span class="literal">put()</span> to an abstract method:</p>&#13;
<p class="programs">type<br/>&#13;
     numeric: class<br/>&#13;
          method put; abstract;<br/>&#13;
          &lt;&lt; Other common methods shared by all the classes &gt;&gt;<br/>&#13;
     endclass;</p>&#13;
<p class="indent">An abstract base class has at least one abstract method. But you don’t have to make <em>all</em> methods abstract in an abstract base class; it’s perfectly legal to declare some standard methods (and, of course, provide their implementation) within it.</p>&#13;
<p class="indent">Abstract method declarations provide a mechanism by which a base class can specify some generic methods that the derived classes must implement. If the derived classes don’t provide concrete implementations of all abstract methods, that makes them abstract base classes themselves.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_205"/>A little earlier, you read that you should never create variables whose type is an abstract base class. Remember, if you attempt to execute an abstract method, the program will immediately raise an exception to complain about this illegal method call.</p>&#13;
<h3 class="h3" id="sec7_6"><strong>7.6 Classes in C++</strong></h3>&#13;
<p class="noindent">Up to this point, all the examples of classes and objects have used HLA. That made sense because the discussion concerned the low-level implementation of classes, which is something HLA illustrates well. However, you may not ever use HLA in a program you write. So now we’ll look at how high-level languages implement classes and objects. As C++ was one of the earliest HLLs to support classes, we’ll start with it.</p>&#13;
<p class="indent">Here’s a variant of the <span class="literal">student2</span> class in C++:</p>&#13;
<p class="programs">class student2<br/>&#13;
{<br/>&#13;
    private:<br/>&#13;
        char    Name[65];<br/>&#13;
        short   Major;<br/>&#13;
        char    SSN[12];<br/>&#13;
        short   Midterm1;<br/>&#13;
        short   Midterm2;<br/>&#13;
        short   Final;<br/>&#13;
        short   Homework;<br/>&#13;
        short   Projects;<br/><br/>&#13;
    protected:<br/>&#13;
        virtual void clearGrades();<br/><br/>&#13;
    public:<br/>&#13;
        student2();<br/>&#13;
        ~student2();<br/><br/>&#13;
        virtual void getName(char *name_p, int maxLen);<br/>&#13;
        virtual void setName(const char *name_p);<br/>&#13;
};</p>&#13;
<p class="indent">The first major difference from HLA’s classes is the presence of the <span class="literal">private</span>, <span class="literal">protected</span>, and <span class="literal">public</span> keywords. C++ and other HLLs make a concerted effort to support <em>encapsulation</em> (information hiding), and these three keywords are one of the main tools C++ uses to enforce it. Scope, privacy, and encapsulation are syntactical issues that are useful for software engineering constructs, but they really don’t impact the <em>implementation</em> of classes and objects in memory. Thus, since this book’s focus is implementation, we’ll leave further discussion of encapsulation for <em><a href="gloss01.xhtml#gloss01_266">WGC4</a></em> and <em><a href="gloss01.xhtml#gloss01_267">WGC5</a></em>.</p>&#13;
<p class="indent">The layout of the C++ <span class="literal">student2</span> object in memory will be very similar to the HLA variant (of course, different compilers could lay things out differently, but the basic idea of data fields and the VMT still applies).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_206"/>Here’s an example of inheritance in C++:</p>&#13;
<p class="programs">class student3 : public student2<br/>&#13;
{<br/>&#13;
    public:<br/>&#13;
        short extraTime;<br/>&#13;
        virtual void setName(char *name_p, int maxLen);<br/>&#13;
        student3();<br/>&#13;
        ~student3();<br/>&#13;
};</p>&#13;
<p class="indent">Structures and classes are almost identical in C++. The main difference between the two is that the default visibility at the beginning of a class is <span class="literal">private</span>, whereas the default visibility for <span class="literal">struct</span> is <span class="literal">public</span>. So, we could rewrite the <span class="literal">student3</span> class as follows:</p>&#13;
<p class="programs">struct student3 : public student2<br/>&#13;
{<br/>&#13;
        short extraTime;<br/>&#13;
        virtual void setName(char *name_p, int maxLen);<br/>&#13;
        student3();<br/>&#13;
        ~student3();<br/>&#13;
};</p>&#13;
<h4 class="h4" id="sec7_6_1"><strong><em>7.6.1 Abstract Member Functions and Classes in C++</em></strong></h4>&#13;
<p class="noindent">C++ has an especially weird way of declaring abstract member functions—you place “<span class="literal">= 0;</span>” after the function definition in the class, like so:</p>&#13;
<p class="programs">struct absClass<br/>&#13;
{<br/>&#13;
        int someDataField;<br/>&#13;
        virtual void absFunc( void ) = 0;<br/>&#13;
 };</p>&#13;
<p class="indent">As with HLA, if a class contains at least one abstract function, the class is an abstract class. Note that abstract functions must also be virtual, as they must be overridden in some derived class to be useful.</p>&#13;
<h4 class="h4" id="sec7_6_2"><strong><em>7.6.2 Multiple Inheritance in C++</em></strong></h4>&#13;
<p class="noindent">C++ is one of the few modern programming languages that supports <em><a href="gloss01.xhtml#gloss01_168">multiple inheritance</a></em>; that is, a class can inherit the data and member functions from multiple classes. Consider the following C++ code fragment:</p>&#13;
<p class="programs">class a<br/>&#13;
{<br/>&#13;
    public:<br/>&#13;
        int i;<br/>&#13;
        virtual void setI(int i) { this-&gt;i = i; }<br/>&#13;
};<br/><br/>&#13;
<span epub:type="pagebreak" id="page_207"/>class b<br/>&#13;
{<br/>&#13;
    public:<br/>&#13;
        int j;<br/>&#13;
        virtual void setJ(int j) { this-&gt;j = j; }<br/>&#13;
};<br/><br/>&#13;
class c : public a, public b<br/>&#13;
{<br/>&#13;
    public:<br/>&#13;
        int k;<br/>&#13;
        virtual void setK(int k) { this-&gt;k = k; }<br/>&#13;
};</p>&#13;
<p class="indent">In this example, class <span class="literal">c</span> inherits all the information from classes <span class="literal">a</span> and <span class="literal">b</span>. In memory, a typical C++ compiler will create an object like that shown in <a href="ch07.xhtml#ch07fig16">Figure 7-16</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/07fig16.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig16"/><em>Figure 7-16: Multiple inheritance memory layout</em></p>&#13;
<p class="indent">The <span class="literal">VMT</span> pointer entry points at a typical VMT containing the addresses of the <span class="literal">setI()</span>, <span class="literal">setJ()</span>, and <span class="literal">setK()</span> methods (as shown in <a href="ch07.xhtml#ch07fig17">Figure 7-17</a>). If you call the <span class="literal">setI()</span> method, the compiler will generate code that loads the <span class="literal">this</span> pointer with the address of the <span class="literal">VMT</span> pointer entry in the object (the base address of the <span class="literal">c</span> object in <a href="ch07.xhtml#ch07fig16">Figure 7-16</a>). Upon entry into <span class="literal">setI()</span>, the system believes that <span class="literal">this</span> is pointing at an object of type <span class="literal">a</span>. In particular, the <span class="literal">this.VM</span><span class="literal">T</span> field points at a VMT whose first (and, as far as type <span class="literal">a</span> is concerned, only) entry is the address of the <span class="literal">setI()</span> method. Likewise, at offset <span class="literal">(this+4</span>) in memory (as the <span class="literal">VMT</span> pointer is 4 bytes), the <span class="literal">setI()</span> method will find the <span class="literal">i</span> data value. As far as the <span class="literal">setI()</span> method is concerned, <span class="literal">this</span> is pointing at a class type <span class="literal">a</span> object (even though it’s actually pointing at a type <span class="literal">c</span> object).</p>&#13;
<div class="image"><img alt="image" src="../images/07fig17.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig17"/><em>Figure 7-17: Multiple inheritance <span class="literal">this</span> values</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_208"/>When you call the <span class="literal">setK()</span> method, the system also passes the base address of the <span class="literal">c</span> object. Of course, <span class="literal">setK()</span> is expecting a type <span class="literal">c</span> object and <span class="literal">this</span> is pointing at a type <span class="literal">c</span> object, so all the offsets into the object are exactly as <span class="literal">setK()</span> expects. Note that objects of type <span class="literal">c</span> (and methods in the <span class="literal">c</span> class) will normally ignore the <span class="literal">VMT2</span> pointer field in the <span class="literal">c</span> object.</p>&#13;
<p class="indent">The problem occurs when the program attempts to call the <span class="literal">setJ()</span> method. Because <span class="literal">setJ()</span> belongs to class <span class="literal">b</span>, it expects <span class="literal">this</span> to hold the address of a VMT pointer pointing at a VMT for class <span class="literal">b</span>. It also expects to find data field <span class="literal">j</span> at offset (<span class="literal">this+4</span>). Were we to pass the <span class="literal">c</span> object’s <span class="literal">this</span> pointer to <span class="literal">setJ()</span>, accessing (<span class="literal">this+4</span>) would reference the <span class="literal">i</span> data field, not <span class="literal">j</span>. Furthermore, were a class <span class="literal">b</span> method to make a call to another method in class <span class="literal">b</span> (such as <span class="literal">setJ()</span> making a recursive call to itself), the VMT pointer would be wrong—it points at a VMT with a pointer to <span class="literal">setI()</span> at offset 0, whereas class <span class="literal">b</span> expects it to point at a VMT with a pointer to <span class="literal">setJ()</span> at offset 0. To resolve this issue, a typical C++ compiler will insert an extra VMT pointer into the <span class="literal">c</span> object immediately prior to the <span class="literal">j</span> data field. It will initialize this second VMT field to point into the <span class="literal">c</span> VMT at the location where the class <span class="literal">b</span> method pointers begin (see <a href="ch07.xhtml#ch07fig17">Figure 7-17</a>). When calling a method in class <span class="literal">b</span>, the compiler will emit code that initializes the <span class="literal">this</span> pointer with the address of this second VMT pointer (rather than pointing at the beginning of <span class="literal">c</span>-type object in memory). Now, upon entry to a class <span class="literal">b</span> method—such as <span class="literal">setJ()</span>—<span class="literal">this</span> will point at a legitimate VMT pointer for class <span class="literal">b</span>, and the <span class="literal">j</span> data field will appear at the offset (<span class="literal">this+4</span>) that class <span class="literal">b</span> methods expect.</p>&#13;
<h3 class="h3" id="sec7_7"><strong>7.7 Classes in Java</strong></h3>&#13;
<p class="noindent">Java, as a C-based language, has class definitions that are somewhat similar to C++ (though Java doesn’t support multiple inheritance and has a more rational way of declaring abstract methods). Here’s a sample set of Java class declarations to give you a sense of how they work:</p>&#13;
<p class="programs">public abstract class a<br/>&#13;
{<br/>&#13;
        int i;<br/>&#13;
        abstract void setI(int i);<br/>&#13;
};<br/><br/>&#13;
public class b extends a<br/>&#13;
{<br/>&#13;
    int j;<br/>&#13;
    void setI( int i )<br/>&#13;
    {<br/>&#13;
        this.i = i;<br/>&#13;
    }<br/><br/>&#13;
    void setJ(int j)<br/>&#13;
    {<br/>&#13;
        this.j = j; <br/>&#13;
    }<br/>&#13;
};</p>&#13;
<h3 class="h3" id="sec7_8"><span epub:type="pagebreak" id="page_209"/><strong>7.8 Classes in Swift</strong></h3>&#13;
<p class="noindent">Swift is also a member of the C language tree. Like C++, Swift allows you to declare classes using the <span class="literal">class</span> or <span class="literal">struct</span> keyword. Unlike C++, Swift structures and classes are different things. A Swift structure is somewhat like a C++ class variable, whereas a Swift class is similar to a C++ pointer to an object. In Swift terminology, structures are <em>value</em> objects and classes are <em>reference</em> objects. Basically, when you create a structure object, Swift allocates sufficient memory for the entire object and binds that storage to the variable.<sup><a href="footnotes.xhtml#fn7_7a" id="fn7_7">7</a></sup> Like Java, Swift doesn’t support multiple inheritance; only single inheritance is legal. Also note that Swift doesn’t support abstract member functions or classes. Here’s an example of a pair of Swift classes:</p>&#13;
<p class="programs">class a<br/>&#13;
{<br/>&#13;
    var i: Int;<br/>&#13;
    init( i:Int )<br/>&#13;
    {<br/>&#13;
        self.i = i;<br/>&#13;
    }<br/>&#13;
    func setI( i :Int )<br/>&#13;
    {<br/>&#13;
        self.i = i;<br/>&#13;
    }<br/>&#13;
};<br/><br/>&#13;
class b : a<br/>&#13;
{<br/>&#13;
    var j: Int = 0;<br/>&#13;
    override func setI( i :Int )<br/>&#13;
    {<br/>&#13;
    self.i = I;<br/>&#13;
    }<br/>&#13;
    func setJ( j:Int)<br/>&#13;
    {<br/>&#13;
        self.j = j;<br/>&#13;
    }<br/>&#13;
};</p>&#13;
<p class="indent">In Swift, all member functions are virtual by default. Also, the <span class="literal">init()</span> function is Swift’s constructor. Destructors have the name <span class="literal">deinit()</span>.</p>&#13;
<h3 class="h3" id="sec7_9"><span epub:type="pagebreak" id="page_210"/><strong>7.9 Protocols and Interfaces</strong></h3>&#13;
<p class="noindent">Java and Swift don’t support multiple inheritance, because it has some logical problems. The classic example is the “diamond lattice” data structure. This occurs when two classes (say, <span class="literal">b</span> and <span class="literal">c</span>) both inherit information from the same class (say, <span class="literal">a</span>) and then a fourth class (say, <span class="literal">d</span>) inherits from both <span class="literal">b</span> and <span class="literal">c</span>. As a result, <span class="literal">d</span> inherits the data from <span class="literal">a</span> twice—once through <span class="literal">b</span> and once through <span class="literal">c</span>.</p>&#13;
<p class="indent">Although multiple inheritance can lead to some weird problems like this, there’s no question that being able to inherit from multiple locations is often useful. Thus, the solution in languages such as Java and Swift is to allow a class to inherit methods or functions from multiple sources but to inherit data fields from only a single ancestor class. This avoids most of the problems with multiple inheritance (specifically, an ambiguous choice of inherited data fields) while allowing programmers to include methods from various sources. Java calls such extensions <em>interfaces</em>, and Swift calls them <em>protocols</em>.</p>&#13;
<p class="indent">Here’s an example of a couple of Swift protocol declarations and a class supporting that protocol:</p>&#13;
<p class="programs">protocol someProtocol<br/>&#13;
{<br/>&#13;
    func doSomething()-&gt;Void;<br/>&#13;
    func doSomethingElse() -&gt;Void;<br/>&#13;
}<br/>&#13;
protocol anotherProtocol<br/>&#13;
{<br/>&#13;
    func doThis()-&gt;Void;<br/>&#13;
    func doThat()-&gt;Void;<br/>&#13;
}<br/><br/>&#13;
class supportsProtocols: someProtocol, anotherProtocol<br/>&#13;
{<br/>&#13;
    var i:Int = 0;<br/>&#13;
    func doSomething()-&gt;Void<br/>&#13;
    {<br/>&#13;
        // appropriate function body<br/>&#13;
    }<br/>&#13;
    func doSomethingElse()-&gt;Void<br/>&#13;
    {<br/>&#13;
        // appropriate function body<br/>&#13;
    }<br/>&#13;
    func doThis()-&gt;Void<br/>&#13;
    {<br/>&#13;
        // appropriate function body<br/>&#13;
    }<br/>&#13;
    func doThat()-&gt;Void<br/>&#13;
    {<br/>&#13;
        // appropriate function body<br/>&#13;
    }}<br/>&#13;
}</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_211"/>Swift protocols don’t supply any functions. Instead, a class that supports a protocol promises to provide an implementation of the functions the protocol(s) specify. In the preceding example, the <span class="literal">supportsProtocols</span> class is responsible for supplying all functions required by the protocols it supports. Effectively, protocols are like abstract classes containing only abstract methods—the inheriting class must provide actual implementations for all the abstract methods.</p>&#13;
<p class="indent">Here’s the previous example coded in Java and demonstrating its comparable mechanism, the interface:</p>&#13;
<p class="programs">class InterfaceDemo {<br/>&#13;
    interface someInterface<br/>&#13;
    {<br/>&#13;
        public void doSomething();<br/>&#13;
        public void doSomethingElse();<br/>&#13;
    }<br/>&#13;
    interface anotherInterface<br/>&#13;
    {<br/>&#13;
        public void doThis();<br/>&#13;
        public void doThat();<br/>&#13;
    }<br/><br/>&#13;
    class supportsInterfaces implements someInterface, anotherInterface<br/>&#13;
    {<br/>&#13;
        int i;<br/>&#13;
        public void doSomething()<br/>&#13;
        {<br/>&#13;
                // appropriate function body<br/>&#13;
        }<br/>&#13;
        public void doSomethingElse()<br/>&#13;
        {<br/>&#13;
                // appropriate function body<br/>&#13;
        }<br/>&#13;
        public void doThis()<br/>&#13;
        {<br/>&#13;
                // appropriate function body<br/>&#13;
        }<br/>&#13;
        public void doThat()<br/>&#13;
        {<br/>&#13;
                // appropriate function body<br/>&#13;
        }<br/>&#13;
    }<br/><br/>&#13;
    public static void main(String[] args) {<br/>&#13;
    System.out.println("InterfaceDemo");<br/>&#13;
    }<br/>&#13;
}</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_212"/>Interfaces and protocols behave somewhat like base class types in Java and Swift. If you instantiate a class object and assign that instance to a variable that is an interface/protocol type, you can execute the supported member functions for that interface or protocol. Consider the following Java example:</p>&#13;
<p class="programs">someInterface some = new supportsInterfaces();<br/><br/>&#13;
// We can call the member functions defined for someInterface:<br/><br/>&#13;
some.doSomething();<br/>&#13;
some.doSomethingElse();<br/><br/>&#13;
// Note that it is illegal to try and call doThis <br/>&#13;
// or doThat (or access the i data field) using<br/>&#13;
// the "some" variable.</p>&#13;
<p class="indent">Here’s a comparable example in Swift:</p>&#13;
<p class="programs">import Foundation<br/><br/>&#13;
protocol a<br/>&#13;
{<br/>&#13;
    func b()-&gt;Void;<br/>&#13;
    func c()-&gt;Void;<br/>&#13;
}<br/><br/>&#13;
protocol d<br/>&#13;
{<br/>&#13;
    func e()-&gt;Void;<br/>&#13;
    func f()-&gt;Void;<br/>&#13;
}<br/>&#13;
class g : a, d<br/>&#13;
{<br/>&#13;
    var i:Int = 0;<br/><br/>&#13;
    func b()-&gt;Void {print("b")}<br/>&#13;
    func c()-&gt;Void {print("c")}<br/>&#13;
    func e()-&gt;Void {print("e")}<br/>&#13;
    func f()-&gt;Void {print("f")}<br/><br/>&#13;
    func local()-&gt;Void {print( "local to g" )}<br/>&#13;
}<br/><br/><br/>&#13;
var x:a = g()<br/>&#13;
x.b()<br/>&#13;
x.c()</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_213"/>You implement a protocol or interface using a pointer to a VMT that contains the addresses of the functions declared in that protocol or interface. So, the data structure for the Swift <span class="literal">g</span> class in the previous example would have three VMT pointers in it—one for protocol <span class="literal">a</span>, one for protocol <span class="literal">d</span>, and one for the class <span class="literal">g</span> (holding a pointer to the <span class="literal">local()</span> function).</p>&#13;
<p class="indent">When you create a variable whose type is a protocol/interface (<span class="literal">x</span> in the previous example), the variable holds the VMT pointer for that protocol. In the current example, the assignment of <span class="literal">g()</span> to the <span class="literal">x</span> variable actually just copies the VMT pointer for protocol <span class="literal">a</span> into <span class="literal">x</span>. Then, when the code executes <span class="literal">x.b</span> and <span class="literal">x.c</span>, it obtains the addresses of the actual functions from the VMT.</p>&#13;
<h3 class="h3" id="sec7_10"><strong>7.10 Generics and Templates</strong></h3>&#13;
<p class="noindent">Although classes and objects allow software engineers to extend their systems in ways that aren’t possible without object-oriented programming, objects don’t provide a completely generic solution. <em>Generics</em>, first introduced by the ML programming language in 1973 and popularized by the Ada programming language, provide the key missing feature to extensibility that plain object-oriented programming was missing. Today, most modern programming languages—C++ (templates), Swift, Java, HLA (via macros), and Delphi—support some form of generic programming. In the generic programming style, you develop algorithms that operate on arbitrary data types to be defined in the future, and supply the actual data type immediately prior to using the generic type.</p>&#13;
<p class="indent">The classic example is a linked list. It’s very easy to write a simple, singly linked list class—say, to manage a list of integers. However, after creating your list of integers, you decide you need a list of doubles. A quick copy-and-paste operation (plus changing the node type from <span class="literal">int</span> to <span class="literal">double</span>), and you’ve got a class that handles linked lists of double values. Oh wait, now you want a list of strings? Another cut-and-paste operation, and you’ve got lists of strings. Now you need a list of objects? Okay, yet another cut-and-paste. . . . You get the idea. Before too long, you’ve created a half-dozen different list classes and, whoops, you discover a bug in the original implementation. Now you get to go back and correct that bug in every list class you’ve created. Good luck with that, if you’ve used the list implementation in several different projects (you’ve just discovered why “cut and paste” programming is not considered great code).</p>&#13;
<p class="indent">Generics (C++ templates) come to the rescue. With a generic class definition, you specify only the algorithms (methods/member functions) that manipulate the list; you don’t worry about the node type. You fill in the node type when you declare an object of the generic class type. To create integer, double, string, or object lists, you simply provide the type you want to the generic list class, and that’s it. Should you discover a bug in the original (generic) implementation, all you do is fix the defect once and recompile your code; everywhere you’ve used the generic type, the compilation applies the correction.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_214"/>Here’s a C++ node and list definition:</p>&#13;
<p class="programs">template&lt; class T &gt;<br/>&#13;
class node {<br/>&#13;
  public:<br/>&#13;
    T data;<br/>&#13;
  private:<br/>&#13;
    node&lt; T &gt; *next;<br/>&#13;
};<br/><br/>&#13;
template&lt; class T &gt;<br/>&#13;
class list {<br/>&#13;
  public:<br/>&#13;
    int  isEmpty();<br/>&#13;
    void append( T data );<br/>&#13;
    T    remove();<br/>&#13;
    list() { <br/>&#13;
      listEnd = new node&lt; T &gt;(); <br/>&#13;
      listEnd-&gt;next = listEnd; <br/>&#13;
    }<br/>&#13;
  private:<br/>&#13;
    node&lt; T &gt;* listEnd;<br/>&#13;
};</p>&#13;
<p class="indent">The <span class="literal">&lt;T&gt;</span> sequence in this C++ code is a <em><a href="gloss01.xhtml#gloss01_190">parameterized type</a></em>. This means that you’ll supply a type and the compiler will substitute that type everywhere it sees <span class="literal">T</span> in the template. So, in the preceding code, if you supply <span class="literal">int</span> as the parameter type, the C++ compiler will substitute <span class="literal">int</span> for every instance of <span class="literal">T</span>. To create a list of integers and doubles, you could use the following C++ code:</p>&#13;
<p class="programs">#include &lt;iostream&gt;<br/>&#13;
#include &lt;list&gt;<br/>&#13;
using namespace std;<br/><br/>&#13;
int main(void) {<br/>&#13;
    list&lt; int &gt; integerList;<br/>&#13;
    list&lt; double &gt; doubleList;<br/>&#13;
<br/>&#13;
    integerList.push_back( 25 );<br/>&#13;
    integerList.push_back( 0 );<br/>&#13;
    doubleList.push_back( 1.2 );<br/>&#13;
    doubleList.push_back( 3.14 );<br/><br/>&#13;
    cout &lt;&lt; "integerList.size() " &lt;&lt; integerList.size() &lt;&lt; endl;<br/>&#13;
    cout &lt;&lt; "doubleList.size()  " &lt;&lt; doubleList.size()  &lt;&lt; endl;<br/><br/>&#13;
    return 0;<br/>&#13;
}<br/>&#13;
    doubleList.add( 3.14 );</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_215"/>The easiest way to implement generics is by using macros. When a compiler sees a declaration such as <span class="literal">list &lt;int&gt; integerList;</span> it expands the associated template code, substituting <span class="literal">int</span> for <span class="literal">T</span> throughout the expansion.</p>&#13;
<p class="indent">Because template expansion can generate a massive amount of code, modern compilers try to optimize the process wherever possible. For example, if you declare two variables like so:</p>&#13;
<p class="programs">list &lt;int&gt; iList1;<br/>&#13;
list &lt;int&gt; iList2;</p>&#13;
<p class="noindent">there’s really no need to create two separate <span class="literal">list</span> classes, both of type <span class="literal">int</span>. Clearly, the template expansions would be identical, so any decent compiler would use the same class definition for both declarations.</p>&#13;
<p class="indent">Even smarter compilers would recognize that some functions, like <span class="literal">remove()</span>, don’t really care about the underlying node data type. The basic removal operation is the same for all data types; as the list data type uses a pointer for the node data, there’s no reason to generate different <span class="literal">remove()</span> functions for each type. With polymorphism, a single <span class="literal">remove()</span> member function would work fine. Recognizing this requires a little more sophistication on the compiler’s part, but it’s certainly doable.</p>&#13;
<p class="indent">Ultimately, however, template/generic expansion is a macro expansion process. Anything else that happens is simply an optimization by the compiler.</p>&#13;
<h3 class="h3" id="sec7_11"><strong>7.11 For More Information</strong></h3>&#13;
<p class="ref">Hyde, Randall. <em>The Art of Assembly Language</em>. 2nd ed. San Francisco: No Starch Press, 2010.</p>&#13;
<p class="ref">Knuth, Donald. <em>The Art of Computer Programming, Volume I: Fundamental Algorithms</em>. 3rd ed. Boston: Addison-Wesley Professional, 1997.<span epub:type="pagebreak" id="page_216"/></p>&#13;
</body></html>