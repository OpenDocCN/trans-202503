<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;MACROS AND THE HLA COMPILE-TIME LANGUAGE"><div class="titlepage"><div><div><h1 class="title"><a id="macros_and_the_hla_compile-time_language"/>Chapter 9. MACROS AND THE HLA COMPILE-TIME LANGUAGE</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject9_d1e45501"/><img alt="MACROS AND THE HLA COMPILE-TIME LANGUAGE" src="tagoreillycom20100401nostarchimages577853.png.jpg"/></div></div><p>This chapter discusses the HLA compile-time language. This discussion includes what is perhaps the most important component of the HLA compile-time language, <span class="emphasis"><em>macros</em></span>. Many people judge the power of an assembler by the power of its macro processing capabilities. If you happen to be one of these people, you'll probably agree that HLA is one of the more powerful assemblers on the planet after reading this chapter, because HLA has one of the most powerful macro processing facilities of any computer language processing system.<a class="indexterm" id="IDX-CHP-9-0001"/><a class="indexterm" id="IDX-CHP-9-0002"/><a class="indexterm" id="IDX-CHP-9-0003"/><a class="indexterm" id="IDX-CHP-9-0004"/></p><div class="sect1" title="9.1 Introduction to the Compile-Time Language (CTL)"><div class="titlepage"><div><div><h1 class="title"><a id="introduction_to_the_compile-time_languag"/>9.1 Introduction to the Compile-Time Language (CTL)</h1></div></div></div><p>HLA is actually two languages rolled into a single program. The <span class="emphasis"><em>runtime language</em></span> is the standard 80x86/HLA assembly language you've been reading about in all the previous chapters. This is called the runtime language because the programs you write execute when you run the executable file. HLA contains an interpreter for a second language, the HLA compile-time language (CTL), which executes programs while HLA is compiling a program. The source code for the CTL program is embedded in an HLA assembly language source file; that is, HLA source files contain instructions for both the HLA CTL and the runtime program. HLA executes the CTL program during compilation. Once HLA completes compilation, the CTL program terminates; the CTL application is not a part of the runtime executable that HLA emits, although the CTL application can <span class="emphasis"><em>write</em></span> part of the runtime program for you, and, in fact, this is the major purpose of the CTL (see <a class="xref" href="ch09.html#compile-time_versus_runtime_execution" title="Figure 9-1. Compile-time versus runtime execution">Figure 9-1</a>).</p><div class="figure"><a id="compile-time_versus_runtime_execution"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject9_d1e45543"/><img alt="Compile-time versus runtime execution" src="tagoreillycom20100401nostarchimages578063.png.jpg"/></div></div><p class="title">Figure 9-1. Compile-time versus runtime execution</p></div><p>It may seem confusing to have two separate languages built into the same compiler. Perhaps you're even questioning why anyone would need a compile-time language. To understand the benefits of a compile-time language, consider the following statement that you should be very comfortable with at this point:</p><a id="I_programlisting9_d1e45550"/><pre class="programlisting">stdout.put("i32=",i32," strVar=",strVar," charVar=",charVar,nl);</pre><p>This statement is neither a statement in the HLA language nor a call to some HLA Standard Library procedure. Instead, <code class="literal">stdout.put</code> is actually a statement in a CTL application provided by the HLA Standard Library. The <code class="literal">stdout.put</code> "application" processes the parameter list and generates calls to various other Standard Library procedures; it chooses the procedure to call based on the type of the parameter it is currently processing. For example, the <code class="literal">stdout.put</code> "application" above will emit the following statements to the runtime executable:</p><a id="I_programlisting9_d1e45563"/><pre class="programlisting">stdout.puts( "i32=" );
stdout.puti32( i32 );
stdout.puts( " strVar=" );
stdout.puts( strVar );
stdout.puts( " charVar=" );
stdout.putc( charVar );
stdout.newln();</pre><p>Clearly the <code class="literal">stdout.put</code> statement is much easier to read and write than the sequence of statements that <code class="literal">stdout.put</code> emits in response to its parameter list. This is one of the more powerful capabilities of the HLA programming language: the ability to modify the language to simplify common programming tasks. Printing different data objects in a sequential fashion is a common task; the <code class="literal">stdout.put</code> "application" greatly simplifies this process.<a class="indexterm" id="IDX-CHP-9-0005"/><a class="indexterm" id="IDX-CHP-9-0006"/><a class="indexterm" id="IDX-CHP-9-0007"/><a class="indexterm" id="IDX-CHP-9-0008"/><a class="indexterm" id="IDX-CHP-9-0009"/></p><p>The HLA Standard Library is <span class="emphasis"><em>loaded</em></span> with many HLA CTL examples. In addition to Standard Library usage, the HLA CTL is quite adept at handling "one-use" applications. A classic example is filling in the data for a lookup table. <a class="xref" href="ch08.html" title="Chapter 8. ADVANCED ARITHMETIC">Chapter 8</a> noted that it is possible to construct lookup tables using the HLA CTL. Not only is this possible, but it is often far less work to use the HLA CTL to construct these tables.</p><p>Although the CTL itself is relatively inefficient and you would not normally use it to write end-user applications, it does maximize the use of your time. By learning how to use the HLA CTL and applying it properly, you can develop assembly language applications as rapidly as high-level language applications (even faster because HLA's CTL lets you create very high-level-language constructs).</p></div></div>
<div class="sect1" title="9.2 The #print and #error Statements"><div class="titlepage"><div><div><h1 class="title"><a id="the_number_symble_print_and_number_symbl"/>9.2 The #print and #error Statements</h1></div></div></div><p>You may recall that <a class="xref" href="ch01.html" title="Chapter 1. HELLO, WORLD OF ASSEMBLY LANGUAGE">Chapter 1</a> began with the typical first program most people write when learning a new language, the "Hello, world!" program. It is only fitting for this chapter to present that same program when discussing the second language of this book. <a class="xref" href="ch09s02.html#the_ctl_quotation_mark_hello_comma_world" title="Example 9-1. The CTL &quot;Hello, world!&quot; program">Example 9-1</a> provides the basic "Hello, world!" program written in the HLA compile-time language.<a class="indexterm" id="IDX-CHP-9-0010"/></p><div class="example"><a id="the_ctl_quotation_mark_hello_comma_world"/><p class="title">Example 9-1. The CTL "Hello, world!" program</p><div class="example-contents"><pre class="programlisting">program ctlHelloWorld;
begin ctlHelloWorld;

    #print( "Hello, World of HLA/CTL" )

end ctlHelloWorld;</pre></div></div><p>The only CTL statement in this program is the <code class="literal">#print</code> statement. The remaining lines are needed just to keep the compiler happy (though we could have reduced the overhead to two lines by using a <code class="literal">unit</code> rather than a <code class="literal">program</code> declaration).</p><p>The <code class="literal">#print</code> statement displays the textual representation of its argument list during the compilation of an HLA program. Therefore, if you compile the program above with the command <code class="literal">hla ctlHW.hla</code>, the HLA compiler will immediately print the text:</p><a id="I_programlisting9_d1e45643"/><pre class="programlisting">Hello, World of HLA/CTL</pre><p>Note that there is a big difference between the following two statements in an HLA source file:<a class="indexterm" id="IDX-CHP-9-0011"/></p><a id="I_programlisting9_d1e45652"/><pre class="programlisting">#print( "Hello World" )
stdout.puts( "Hello World" nl );</pre><p>The first statement prints <code class="literal">Hello World</code> (and a new line) during the compilation process. This first statement does not have any effect on the executable program. The second line doesn't affect the compilation process (other than the emission of code to the executable file). However, when you run the executable file, the second statement prints the string <code class="literal">Hello World</code> followed by a newline sequence.</p><p>The HLA/CTL <code class="literal">#print</code> statement uses the following basic syntax:</p><a id="I_programlisting9_d1e45667"/><pre class="programlisting">#print( <em class="replaceable"><code>list_of_comma_separated_constants</code></em> )</pre><p>Note that a semicolon does not terminate this statement. Semicolons terminate runtime statements; they generally do not terminate compile-time statements (there is one big exception, as you will see a little later).</p><p>The <code class="literal">#print</code> statement must have at least one operand; if multiple operands appear in the parameter list, you must separate each operand with a comma ( just like <code class="literal">stdout.put</code>). If a particular operand is not a string constant, HLA will translate that constant to its corresponding string representation and print that string. Here's an example:</p><a id="I_programlisting9_d1e45683"/><pre class="programlisting">#print( "A string Constant ", 45, ' ', 54.9, ' ', true )</pre><p>You may specify named symbolic constants and constant expressions. However, all <code class="literal">#print</code> operands must be constants (either literal constants or constants you define in the <code class="literal">const</code> or <code class="literal">val</code> sections), and those constants must be defined before you use them in the <code class="literal">#print</code> statement. For example:</p><a id="I_programlisting9_d1e45699"/><pre class="programlisting">const
    pi := 3.14159;
    charConst := 'c';

#print( "PI = ", pi, "  CharVal=", charConst )</pre><p>The HLA <code class="literal">#print</code> statement is particularly invaluable for debugging CTL programs. This statement is also useful for displaying the progress of the compilation and displaying assumptions and default actions that take place during compilation. Other than displaying the text associated with the <code class="literal">#print</code> parameter list, the <code class="literal">#print</code> statement has no effect on the compilation of the program.<a class="indexterm" id="IDX-CHP-9-0012"/><a class="indexterm" id="IDX-CHP-9-0013"/></p><p>The <code class="literal">#error</code> statement allows a single-string constant operand. Like <code class="literal">#print</code>, this statement will display the string to the console during compilation. However, the <code class="literal">#error</code> statement treats the string as an error message and displays the string as part of an HLA error diagnostic. Further, the <code class="literal">#error</code> statement increments the error count, and this will cause HLA to stop the compilation (without assembling or linking) after processing the current source file. You would normally use the <code class="literal">#error</code> statement to display an error message during compilation if your CTL code discovers something that prevents it from creating valid code. For example:<a class="indexterm" id="IDX-CHP-9-0014"/><a class="indexterm" id="IDX-CHP-9-0015"/><a class="indexterm" id="IDX-CHP-9-0016"/></p><a id="I_programlisting9_d1e45753"/><pre class="programlisting">#error( "Statement must have exactly one operand" )</pre><p>Like the <code class="literal">#print</code> statement, the <code class="literal">#error</code> statement does not end with a semicolon. Although <code class="literal">#error</code> allows only a single-string operand, it's very easy to print other values by using the compile-time string concatenation operator and several of the HLA built-in compile-time functions. You'll learn about these a little later in this chapter.</p></div>
<div class="sect1" title="9.3 Compile-Time Constants and Variables"><div class="titlepage"><div><div><h1 class="title"><a id="compile-time_constants_and_variables"/>9.3 Compile-Time Constants and Variables</h1></div></div></div><p>Just as the runtime language does, the compile-time language supports constants and variables. You declare compile-time constants in the <code class="literal">const</code> section, just as you would with the runtime language. You declare compile-time variables in the <code class="literal">val</code> section. Objects you declare in the <code class="literal">val</code> section are constants to the runtime language, but remember that you can change the value of an object you declare in the <code class="literal">val</code> section throughout the source file. Hence the term "compile-time variable." See <a class="xref" href="ch04.html" title="Chapter 4. CONSTANTS, VARIABLES, AND DATA TYPES">Chapter 4</a> for more details.</p><p>The CTL assignment statement (<code class="literal">?</code>) computes the value of the constant expression to the right of the assignment operator (<code class="literal">:=</code>) and stores the result into the <code class="literal">val</code> object name appearing immediately to the left of the assignment operator.<sup>[<a class="footnote" href="#ftn.CHP-9-FN-1" id="CHP-9-FN-1">118</a>]</sup> This example code may appear anywhere in your HLA source file, not just in the <code class="literal">val</code> section of the program.<a class="indexterm" id="IDX-CHP-9-0017"/></p><a id="I_programlisting9_d1e45807"/><pre class="programlisting">?ConstToPrint := 25;
     #print( "ConstToPrint = ", ConstToPrint )
     ?ConstToPrint := ConstToPrint + 5;
     #print( "Now ConstToPrint = ", ConstToPrint )</pre><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-1" id="ftn.CHP-9-FN-1">118</a>] </sup>If the identifier to the left of the assignment operator is undefined, HLA will automatically declare this object at the current scope level.</p></div></div></div>
<div class="sect1" title="9.4 Compile-Time Expressions and Operators"><div class="titlepage"><div><div><h1 class="title"><a id="compile-time_expressions_and_operators"/>9.4 Compile-Time Expressions and Operators</h1></div></div></div><p>The HLA CTL supports constant expressions in the CTL assignment statement. Unlike the runtime language (where you have to translate algebraic notation into a sequence of machine instructions), the HLA CTL allows a full set of arithmetic operations using familiar expression syntax. This gives the HLA CTL considerable power, especially when combined with the built-in compile-time functions the next section discusses.</p><p><a class="xref" href="ch09s04.html#compile-time_operators" title="Table 9-1. Compile-Time Operators">Table 9-1</a> and <a class="xref" href="ch09s04.html#operator_precedence_and_associativity" title="Table 9-2. Operator Precedence and Associativity">Table 9-2</a> list operators that the HLA CTL supports in compile-time expressions.</p><div class="table"><a id="compile-time_operators"/><p class="title">Table 9-1. Compile-Time Operators</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Compile-Time Operators"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Operator(s)<a class="indexterm" id="IDX-CHP-9-0018"/></p></th><th style="text-align: left" valign="bottom"><p>Operand Types<sup>[<a class="footnote" href="#ftn.CHP-9-TFN-1" id="CHP-9-TFN-1">a</a>]</sup></p></th><th style="text-align: left" valign="bottom"><p>Description</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">-</code> (unary)</p></td><td style="text-align: left" valign="top"><p>numeric</p></td><td style="text-align: left" valign="top"><p>Negates the specific numeric value (int, uns, real).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>cset</p></td><td style="text-align: left" valign="top"><p>Returns the complement of the specified character set.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">!</code> (unary)</p></td><td style="text-align: left" valign="top"><p>integer</p></td><td style="text-align: left" valign="top"><p>Inverts all the bits in the operand (bitwise <code class="literal">not</code>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>boolean</p></td><td style="text-align: left" valign="top"><p>Boolean <code class="literal">not</code> of the operand.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">*</code></p></td><td style="text-align: left" valign="top"><p>numericL * numericR</p></td><td style="text-align: left" valign="top"><p>Multiplies the two operands.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>csetL * csetR</p></td><td style="text-align: left" valign="top"><p>Computes the intersection of the two sets.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">div</code></p></td><td style="text-align: left" valign="top"><p>integerL divintegerR</p></td><td style="text-align: left" valign="top"><p>Computes the integer quotient of the two integer (int/uns/dword) operands.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">mod</code></p></td><td style="text-align: left" valign="top"><p>integerL modintegerR</p></td><td style="text-align: left" valign="top"><p>Computes the remainder of the division of the two integer (int/uns/dword) operands.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">/</code></p></td><td style="text-align: left" valign="top"><p>numericL / numericR</p></td><td style="text-align: left" valign="top"><p>Computes the real quotient of the two numeric operands. Returns a real result even if both operands are integers.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">&lt;&lt;</code></p></td><td style="text-align: left" valign="top"><p>integerL &lt;&lt; integerR</p></td><td style="text-align: left" valign="top"><p>Shifts integerL operand to the left the number of bits specified by the integerR operand.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">&gt;&gt;</code></p></td><td style="text-align: left" valign="top"><p>integerL &gt;&gt; integerR</p></td><td style="text-align: left" valign="top"><p>Shifts integerL operand to the right the number of bits specified by the integerR operand.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">+</code></p></td><td style="text-align: left" valign="top"><p>numericL + numericR</p></td><td style="text-align: left" valign="top"><p>Adds the two numeric operands.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>csetL + csetR</p></td><td style="text-align: left" valign="top"><p>Computes the union of the two sets.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>strL + strR</p></td><td style="text-align: left" valign="top"><p>Concatenates the two strings.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">-</code></p></td><td style="text-align: left" valign="top"><p>numericL numericR</p></td><td style="text-align: left" valign="top"><p>Computes the difference between numericL and numericR.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>csetL - csetR</p></td><td style="text-align: left" valign="top"><p>Computes the set difference of csetL - csetR.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">=</code> or <code class="literal">==</code></p></td><td style="text-align: left" valign="top"><p>numericL = numericR</p></td><td style="text-align: left" valign="top"><p>Returns true if the two operands have the same value.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>csetL = csetR</p></td><td style="text-align: left" valign="top"><p>Returns true if the two sets are equal.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>strL = strR</p></td><td style="text-align: left" valign="top"><p>Returns true if the two strings/chars are equal.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>typeL = typeR</p></td><td style="text-align: left" valign="top"><p>Returns true if the two values are equal. They must be the same type.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">&lt;&gt;</code> or <code class="literal">!=</code></p></td><td style="text-align: left" valign="top"><p>typeL &lt;&gt; typeR (sameas !=)</p></td><td style="text-align: left" valign="top"><p>Returns false if the two (compatible) operands are not equal to one another (numeric, cset, or string).</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">&lt;</code></p></td><td style="text-align: left" valign="top"><p>numericL &lt; numericR</p></td><td style="text-align: left" valign="top"><p>Returns true if numericL is less than numericR.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>csetL &lt; csetR</p></td><td style="text-align: left" valign="top"><p>Returns true if csetL is a proper subset of csetR.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>strL &lt; strR</p></td><td style="text-align: left" valign="top"><p>Returns true if strL is less than strR.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>booleanL &lt; booleanR</p></td><td style="text-align: left" valign="top"><p>Returns true if the left operand is less than the right operand (note: false &lt; true).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>enumL &lt; enumR</p></td><td style="text-align: left" valign="top"><p>Returns true if enumL appears in the same enumlist as enumR and enumL appears first.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">&lt;=</code><a class="indexterm" id="IDX-CHP-9-0019"/><a class="indexterm" id="IDX-CHP-9-0020"/></p></td><td style="text-align: left" valign="top"><p>Same as &lt;</p></td><td style="text-align: left" valign="top"><p>Returns true if the left operand is less than or equal to the right operand. For character sets, this means that the left operand is a subset of the right operand.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">&gt;</code></p></td><td style="text-align: left" valign="top"><p>Same as &lt;</p></td><td style="text-align: left" valign="top"><p>Returns true if the left operand is greater than the right operand. For character sets, this means that the left operand is a proper superset of the right operand.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">&gt;=</code></p></td><td style="text-align: left" valign="top"><p>Same as &lt;=</p></td><td style="text-align: left" valign="top"><p>Returns true if the left operand is greater than or equal to the right operand. For character sets, this means that the left operand is a superset of the right operand.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">&amp;</code></p></td><td style="text-align: left" valign="top"><p>integerL &amp; integerR</p></td><td style="text-align: left" valign="top"><p>Computes the bitwise <code class="literal">and</code> of the two operands.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>booleanL &amp; booleanR</p></td><td style="text-align: left" valign="top"><p>Computes the logical <code class="literal">and</code> of the two operands.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">|</code></p></td><td style="text-align: left" valign="top"><p>integerL | integerR</p></td><td style="text-align: left" valign="top"><p>Computes the bitwise <code class="literal">or</code> of the two operands.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>booleanL | booleanR</p></td><td style="text-align: left" valign="top"><p>Computes the logical <code class="literal">or</code> of the two operands.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">^</code></p></td><td style="text-align: left" valign="top"><p>integerL ^ integerR</p></td><td style="text-align: left" valign="top"><p>Computes the bitwise <code class="literal">xor</code> of the two operands.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>booleanL ^ booleanR</p></td><td style="text-align: left" valign="top"><p>Computes the logical <code class="literal">xor</code> of the two operands. Note that this is equivalent to <code class="literal">booleanL &lt;&gt; booleanR</code>.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">in</code></p></td><td style="text-align: left" valign="top"><p>charL in csetR</p></td><td style="text-align: left" valign="top"><p>Returns true if charL is a member of csetR.</p></td></tr></tbody><tbody class="footnotes"><tr><td colspan="3"><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-TFN-1" id="ftn.CHP-9-TFN-1">a</a>] </sup>Type numeric is {int<span class="emphasis"><em>XX</em></span>, uns<span class="emphasis"><em>XX</em></span>, byte, word, dword, and real<span class="emphasis"><em>XX</em></span>} values. Type cset is a character set operand. Type integer is {int<span class="emphasis"><em>XX</em></span>, uns<span class="emphasis"><em>XX</em></span>, byte, word, dword}. Type str is any string or character value. Type indicates an arbitrary HLA type. Other types specify an explicit HLA data type.</p></div></td></tr></tbody></table></div></div><div class="table"><a id="operator_precedence_and_associativity"/><p class="title">Table 9-2. Operator Precedence and Associativity</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Operator Precedence and Associativity"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Associativity</p></th><th style="text-align: left" valign="bottom"><p>Precedence (Highest to Lowest)</p></th><th style="text-align: left" valign="bottom"><p>Operator</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p>Right to left</p></td><td style="text-align: left" valign="top"><p>6</p></td><td style="text-align: left" valign="top"><p><code class="literal">!</code> (unary)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p><code class="literal">-</code> (unary)</p></td></tr><tr><td style="text-align: left" valign="top"><p>Left to right</p></td><td style="text-align: left" valign="top"><p>5</p></td><td style="text-align: left" valign="top"><p><code class="literal">*</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p><code class="literal">div</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p><code class="literal">mod</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p><code class="literal">/</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p><code class="literal">&gt;&gt;</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p><code class="literal">&lt;&lt;</code></p></td></tr><tr><td style="text-align: left" valign="top"><p>Left to right</p></td><td style="text-align: left" valign="top"><p>4</p></td><td style="text-align: left" valign="top"><p><code class="literal">+</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p><code class="literal">-</code></p></td></tr><tr><td style="text-align: left" valign="top"><p>Left to right</p></td><td style="text-align: left" valign="top"><p>3</p></td><td style="text-align: left" valign="top"><p><code class="literal">=</code> or <code class="literal">==</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p><code class="literal">&lt;&gt;</code> or <code class="literal">!=</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p><code class="literal">&lt;</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p><code class="literal">&lt;=</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p><code class="literal">&gt;</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p><code class="literal">&gt;=</code></p></td></tr><tr><td style="text-align: left" valign="top"><p>Left to right</p></td><td style="text-align: left" valign="top"><p>2</p></td><td style="text-align: left" valign="top"><p><code class="literal">&amp;</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p><code class="literal">|</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p><code class="literal">^</code></p></td></tr><tr><td style="text-align: left" valign="top"><p>Nonassociative</p></td><td style="text-align: left" valign="top"><p>1</p></td><td style="text-align: left" valign="top"><p><code class="literal">in</code></p></td></tr></tbody></table></div></div><p>Of course, you can always override the default precedence and associativity of an operator by using parentheses in an expression.</p></div>
<div class="sect1" title="9.5 Compile-Time Functions"><div class="titlepage"><div><div><h1 class="title"><a id="compile-time_functions"/>9.5 Compile-Time Functions</h1></div></div></div><p>HLA provides a wide range of compile-time functions you can use. These functions compute values during compilation the same way a high-level-language function computes values at runtime. The HLA compile-time language includes a wide variety of numeric, string, and symbol table functions that help you write sophisticated compile-time programs.<a class="indexterm" id="IDX-CHP-9-0021"/></p><p>Most of the names of the built-in compile-time functions begin with the special symbol <code class="literal">@</code> and have names like <code class="literal">@sin</code> or <code class="literal">@length</code>. The use of these special identifiers prevents conflicts with common names you might want to use in your own programs (like <code class="literal">length</code>). The remaining compile-time functions (those that do not begin with <code class="literal">@</code>) are typically data conversion functions that use type names like <code class="literal">int8</code> and <code class="literal">real64</code>. You can even create your own compile-time functions using macros (which is discussed in <a class="xref" href="ch09s08.html" title="9.8 Macros (Compile-Time Procedures)">9.8 Macros (Compile-Time Procedures)</a>).</p><p>HLA organizes the compile-time functions into various classes depending on the type of operation. For example, there are functions that convert constants from one form to another (such as string-to-integer conversion), there are many useful string functions, and HLA provides a full set of compile-time numeric functions.</p><p>The complete list of HLA compile-time functions is too lengthy to present here. Instead, a complete description of each of the compile-time objects and functions appears in the HLA reference manual (found at <a class="ulink" href="http://webster.cs.ucr.edu/">http://webster.cs.ucr.edu/</a> or <a class="ulink" href="http://www.artofasm.com/">http://www.artofasm.com/</a>); this section highlights a few of the functions in order to demonstrate their use. Later sections in this chapter, as well as future chapters, make extensive use of the various compile-time functions.</p><p>Perhaps the most important concept to understand about the compile-time functions is that they are equivalent to constants in your assembly language code (i.e., the runtime program). For example, the compile-time function invocation <code class="literal">@sin(3.1415265358979328)</code> is roughly equivalent to specifying 0.0 at that point in your program.<sup>[<a class="footnote" href="#ftn.CHP-9-FN-2" id="CHP-9-FN-2">119</a>]</sup> A function invocation like <code class="literal">@sin( x )</code> is legal only if <code class="literal">x</code> is a constant with a previous declaration at the point of the function call in the source file. In particular, <code class="literal">x</code> cannot be a runtime variable or other object whose value exists at runtime rather than compile time. Because HLA replaces compile-time function calls with their constant result, you may ask why you should even bother with compile-time functions. After all, it's probably more convenient to type <span class="emphasis"><em>0.0</em></span> than it is to type <span class="emphasis"><em>@sin(3.1415265358979328)</em></span> in your program. However, compile-time functions are handy for generating lookup tables and other mathematical results that may change whenever you change a <code class="literal">const</code> value in your program. <a class="xref" href="ch09s09.html" title="9.9 Writing Compile-Time &quot;Programs&quot;">9.9 Writing Compile-Time "Programs"</a> will explore this idea further.<a class="indexterm" id="IDX-CHP-9-0022"/><a class="indexterm" id="IDX-CHP-9-0023"/><a class="indexterm" id="IDX-CHP-9-0024"/><a class="indexterm" id="IDX-CHP-9-0025"/><a class="indexterm" id="IDX-CHP-9-0026"/><a class="indexterm" id="IDX-CHP-9-0027"/><a class="indexterm" id="IDX-CHP-9-0028"/><a class="indexterm" id="IDX-CHP-9-0029"/><a class="indexterm" id="IDX-CHP-9-0030"/><a class="indexterm" id="IDX-CHP-9-0031"/><a class="indexterm" id="IDX-CHP-9-0032"/><a class="indexterm" id="IDX-CHP-9-0033"/><a class="indexterm" id="IDX-CHP-9-0034"/><a class="indexterm" id="IDX-CHP-9-0035"/><a class="indexterm" id="IDX-CHP-9-0036"/><a class="indexterm" id="IDX-CHP-9-0037"/><a class="indexterm" id="IDX-CHP-9-0038"/><a class="indexterm" id="IDX-CHP-9-0039"/><a class="indexterm" id="IDX-CHP-9-0040"/><a class="indexterm" id="IDX-CHP-9-0041"/><a class="indexterm" id="IDX-CHP-9-0042"/></p><div class="sect2" title="9.5.1 Type-Conversion Compile-Time Functions"><div class="titlepage"><div><div><h2 class="title"><a id="type-conversion_compile-time_functions"/>9.5.1 Type-Conversion Compile-Time Functions</h2></div></div></div><p>Probably the most commonly used compile-time functions are the type-conversion functions. These functions take a single parameter of one type and convert that information to some specified type. These functions use several of the HLA built-in data type names as the function names. Functions in this category are the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">boolean</code></p></li><li class="listitem"><p><code class="literal">int8</code>, <code class="literal">int16</code>, <code class="literal">int32</code>, <code class="literal">int64</code>, and <code class="literal">int128</code><a class="indexterm" id="IDX-CHP-9-0043"/><a class="indexterm" id="IDX-CHP-9-0044"/><a class="indexterm" id="IDX-CHP-9-0045"/><a class="indexterm" id="IDX-CHP-9-0046"/><a class="indexterm" id="IDX-CHP-9-0047"/></p></li><li class="listitem"><p><code class="literal">uns8</code>, <code class="literal">uns16</code>, <code class="literal">uns32</code>, <code class="literal">uns64</code>, and <code class="literal">uns128</code><a class="indexterm" id="IDX-CHP-9-0048"/><a class="indexterm" id="IDX-CHP-9-0049"/><a class="indexterm" id="IDX-CHP-9-0050"/><a class="indexterm" id="IDX-CHP-9-0051"/><a class="indexterm" id="IDX-CHP-9-0052"/></p></li><li class="listitem"><p><code class="literal">byte</code>, <code class="literal">word</code>, <code class="literal">dword</code>, <code class="literal">qword</code>, and <code class="literal">lword</code> (these are effectively equivalent to <code class="literal">uns8</code>, <code class="literal">uns16</code>, <code class="literal">uns32</code>, <code class="literal">uns64</code>, and <code class="literal">uns128</code>, respectively)<a class="indexterm" id="IDX-CHP-9-0053"/><a class="indexterm" id="IDX-CHP-9-0054"/><a class="indexterm" id="IDX-CHP-9-0055"/><a class="indexterm" id="IDX-CHP-9-0056"/></p></li><li class="listitem"><p><code class="literal">real32</code>, <code class="literal">real64</code>, and <code class="literal">real80</code><a class="indexterm" id="IDX-CHP-9-0057"/><a class="indexterm" id="IDX-CHP-9-0058"/><a class="indexterm" id="IDX-CHP-9-0059"/></p></li><li class="listitem"><p><code class="literal">char</code><a class="indexterm" id="IDX-CHP-9-0060"/></p></li><li class="listitem"><p><code class="literal">string</code><a class="indexterm" id="IDX-CHP-9-0061"/></p></li><li class="listitem"><p><code class="literal">cset</code><a class="indexterm" id="IDX-CHP-9-0062"/></p></li><li class="listitem"><p><code class="literal">text</code><a class="indexterm" id="IDX-CHP-9-0063"/></p></li></ul></div><p>These functions accept a single constant expression parameter and, if at all reasonable, convert that expression's value to the type specified by the type name. For example, the following function call returns the value −128 because it converts the string constant to the corresponding integer value:</p><a id="I_programlisting9_d1e46814"/><pre class="programlisting">int8( "-128" )</pre><p>Certain conversions don't make sense or have restrictions associated with them. For example, the <code class="literal">boolean</code> function will accept a string parameter, but that string must be "true" or "false" or the function will generate a compile-time error. Likewise, the numeric conversion functions (e.g., <code class="literal">int8</code>) allow a string operand, but the string operand must represent a legal numeric value. Some conversions (for example, <code class="literal">int8</code> with a character set parameter) simply don't make sense and are always illegal.<a class="indexterm" id="IDX-CHP-9-0064"/><a class="indexterm" id="IDX-CHP-9-0065"/></p><p>One of the most useful functions in this category is the <code class="literal">string</code> function. This function accepts nearly all the constant expression types, and it generates a string that represents the parameter's data. For example, the invocation <code class="literal">string( 128 )</code> produces the string <code class="literal">128</code> as the return result. This function is handy when you have a value that you wish to use where HLA requires a string. For example, the <code class="literal">#error</code> compile-time statement allows only a single-string operand. You can use the string function and the string concatenation operator (<code class="literal">+</code>) to easily get around this limitation. For example:</p><a id="I_programlisting9_d1e46852"/><pre class="programlisting">#error( "theValue (" + string( theValue ) + ") is out of range" )</pre><p>Note that these type functions actually perform a conversion. This means that the bit pattern these functions return may be considerably different than the bit pattern you pass as an argument. For example, consider the following invocation of the <code class="literal">real32</code> function:</p><a id="I_programlisting9_d1e46859"/><pre class="programlisting">real32( $3F80_0000 )</pre><p>Now it turns out that $3F80_0000 is the hexadecimal equivalent of the <code class="literal">real32</code> value 1.0. However, the preceding function invocation does not return 1.0; instead it attempts to convert the integer value $3F80_0000 (1,065,353,216) to a <code class="literal">real32</code> value but fails because the value is too large to exactly represent using a <code class="literal">real32</code> object. Contrast this with the following constant function:</p><a id="I_programlisting9_d1e46873"/><pre class="programlisting">char( 65 )</pre><p>This CTL function invocation returns the character <code class="literal">A</code> (because 65 is the ASCII code for <code class="literal">A</code>). Notice how the <code class="literal">char</code> function simply uses the bit pattern of the integer argument you pass it as an ASCII code, whereas the <code class="literal">real32</code> function attempts to translate the integer argument to a floating-point value. Although the semantics are quite different between these two functions, the bottom line is that they tend to do the intuitive operation, even at the expense of consistency.</p><p>Sometimes, however, you might not want these functions to do the "intuitive" thing. For example, you might want the <code class="literal">real32</code> function to simply treat the bit pattern you pass it as a <code class="literal">real32</code> value. To handle this situation, HLA provides a second set of type functions, which are simply the type names with an <code class="literal">@</code> prefix that treat the argument as a bit pattern of the final type. So if you really want to produce 1.0 from $3F80_0000, then you could use the following function invocation:</p><a id="I_programlisting9_d1e46900"/><pre class="programlisting">@real32( $3F80_0000 )</pre><p>Generally, type coercion of this form is somewhat advanced in the compile-time language, so you'll probably not use it very often. However, when it is needed, it's nice to have around.<a class="indexterm" id="IDX-CHP-9-0066"/><a class="indexterm" id="IDX-CHP-9-0067"/><a class="indexterm" id="IDX-CHP-9-0068"/><a class="indexterm" id="IDX-CHP-9-0069"/><a class="indexterm" id="IDX-CHP-9-0070"/><a class="indexterm" id="IDX-CHP-9-0071"/><a class="indexterm" id="IDX-CHP-9-0072"/><a class="indexterm" id="IDX-CHP-9-0073"/><a class="indexterm" id="IDX-CHP-9-0074"/><a class="indexterm" id="IDX-CHP-9-0075"/><a class="indexterm" id="IDX-CHP-9-0076"/><a class="indexterm" id="IDX-CHP-9-0077"/><a class="indexterm" id="IDX-CHP-9-0078"/><a class="indexterm" id="IDX-CHP-9-0079"/><a class="indexterm" id="IDX-CHP-9-0080"/><a class="indexterm" id="IDX-CHP-9-0081"/><a class="indexterm" id="IDX-CHP-9-0082"/><a class="indexterm" id="IDX-CHP-9-0083"/><a class="indexterm" id="IDX-CHP-9-0084"/><a class="indexterm" id="IDX-CHP-9-0085"/><a class="indexterm" id="IDX-CHP-9-0086"/><a class="indexterm" id="IDX-CHP-9-0087"/><a class="indexterm" id="IDX-CHP-9-0088"/><a class="indexterm" id="IDX-CHP-9-0089"/><a class="indexterm" id="IDX-CHP-9-0090"/><a class="indexterm" id="IDX-CHP-9-0091"/><a class="indexterm" id="IDX-CHP-9-0092"/><a class="indexterm" id="IDX-CHP-9-0093"/><a class="indexterm" id="IDX-CHP-9-0094"/><a class="indexterm" id="IDX-CHP-9-0095"/><a class="indexterm" id="IDX-CHP-9-0096"/><a class="indexterm" id="IDX-CHP-9-0097"/><a class="indexterm" id="IDX-CHP-9-0098"/><a class="indexterm" id="IDX-CHP-9-0099"/><a class="indexterm" id="IDX-CHP-9-0100"/><a class="indexterm" id="IDX-CHP-9-0101"/><a class="indexterm" id="IDX-CHP-9-0102"/><a class="indexterm" id="IDX-CHP-9-0103"/><a class="indexterm" id="IDX-CHP-9-0104"/><a class="indexterm" id="IDX-CHP-9-0105"/><a class="indexterm" id="IDX-CHP-9-0106"/><a class="indexterm" id="IDX-CHP-9-0107"/><a class="indexterm" id="IDX-CHP-9-0108"/><a class="indexterm" id="IDX-CHP-9-0109"/><a class="indexterm" id="IDX-CHP-9-0110"/><a class="indexterm" id="IDX-CHP-9-0111"/><a class="indexterm" id="IDX-CHP-9-0112"/><a class="indexterm" id="IDX-CHP-9-0113"/><a class="indexterm" id="IDX-CHP-9-0114"/></p></div><div class="sect2" title="9.5.2 Numeric Compile-Time Functions"><div class="titlepage"><div><div><h2 class="title"><a id="numeric_compile-time_functions"/>9.5.2 Numeric Compile-Time Functions</h2></div></div></div><p>The functions in this category perform standard mathematical operations at compile time. These functions are handy for generating lookup tables and "parameterizing" your source code by recalculating functions on constants defined at the beginning of your program. Functions in this category include the following:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">@abs(</code> <em class="replaceable"><code>n</code></em> <code class="literal">)</code></p></li></ul></div>
</td><td style="text-align: left" valign="top"><p>Absolute value of numeric argument</p></td></tr><tr><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">@ceil(</code> <em class="replaceable"><code>r</code></em> <code class="literal">), @floor(</code> <em class="replaceable"><code>r</code></em> <code class="literal">)</code></p></li></ul></div>
</td><td style="text-align: left" valign="top"><p>Extract integer component of floating-point value</p></td></tr><tr><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">@sin(</code> <em class="replaceable"><code>r</code></em> <code class="literal">)</code>, <code class="literal">@cos(</code> <em class="replaceable"><code>r</code></em> <code class="literal">)</code>, <code class="literal">@tan(</code> <em class="replaceable"><code>r</code></em> <code class="literal">)</code></p></li></ul></div>
</td><td style="text-align: left" valign="top"><p>Standard trig functions</p></td></tr><tr><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">@exp(</code> <em class="replaceable"><code>r</code></em> <code class="literal">)</code>, <code class="literal">@log(</code> <em class="replaceable"><code>r</code></em> <code class="literal">)</code>, <code class="literal">@log10(</code> <em class="replaceable"><code>r</code></em> <code class="literal">)</code></p></li></ul></div>
</td><td style="text-align: left" valign="top"><p>Standard log/exponent functions</p></td></tr><tr><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">@min(</code> <em class="replaceable"><code>list</code></em> <code class="literal">)</code>, <code class="literal">@max(</code> <em class="replaceable"><code>list</code></em> <code class="literal">)</code></p></li></ul></div>
</td><td style="text-align: left" valign="top"><p>Return min/max value from a list of values</p></td></tr><tr><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">@random</code>, <code class="literal">@randomize</code></p></li></ul></div>
</td><td style="text-align: left" valign="top"><p>Return a pseudo-random <code class="literal">int32</code> value</p></td></tr><tr><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">@sqrt(</code> <em class="replaceable"><code>n</code></em> <code class="literal">)</code></p></li></ul></div>
</td><td style="text-align: left" valign="top"><p>Computes the square root of its numeric argument (real result)</p></td></tr></tbody></table></div><p>See the HLA reference manual at <a class="ulink" href="http://webster.cs.ucr.edu/">http://webster.cs.ucr.edu/</a> or <a class="ulink" href="http://www.artofasm.com/">http://www.artofasm.com/</a> for more details on these functions.</p></div><div class="sect2" title="9.5.3 Character-Classification Compile-Time Functions"><div class="titlepage"><div><div><h2 class="title"><a id="character-classification_compile-time_fu"/>9.5.3 Character-Classification Compile-Time Functions</h2></div></div></div><p>The functions in this group all return a boolean result. They test a character (or all the characters in a string) to see if it belongs to a certain class of characters. The functions in this category include the following:<a class="indexterm" id="IDX-CHP-9-0115"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">@isAlpha(</code> <em class="replaceable"><code>c</code></em> <code class="literal">)</code>, <code class="literal">@isAlphanum(</code> <em class="replaceable"><code>c</code></em> <code class="literal">)</code></p></li><li class="listitem"><p><code class="literal">@isDigit(</code> <em class="replaceable"><code>c</code></em> <code class="literal">)</code>, <code class="literal">@isxDigit(</code> <em class="replaceable"><code>c</code></em> <code class="literal">)</code></p></li><li class="listitem"><p><code class="literal">@isLower(</code> <em class="replaceable"><code>c</code></em> <code class="literal">)</code>, <code class="literal">@isUpper(</code> <em class="replaceable"><code>c</code></em> <code class="literal">)</code></p></li><li class="listitem"><p><code class="literal">@isSpace(</code> <em class="replaceable"><code>c</code></em> <code class="literal">)</code></p></li></ul></div><p>In addition to these character-classification functions, the HLA language provides a set of pattern-matching functions that you can also use to classify character and string data. See the HLA reference manual at for the discussion of these routines.</p></div><div class="sect2" title="9.5.4 Compile-Time String Functions"><div class="titlepage"><div><div><h2 class="title"><a id="compile-time_string_functions"/>9.5.4 Compile-Time String Functions</h2></div></div></div><p>The functions in this category operate on string parameters. Most return a string result, although a few (for example, <code class="literal">@length</code> and <code class="literal">@index</code>) return integer results. These functions do not directly affect the values of their parameters; instead, they return an appropriate result that you can assign back to the parameter if you wish to do so.<a class="indexterm" id="IDX-CHP-9-0116"/><a class="indexterm" id="IDX-CHP-9-0117"/><a class="indexterm" id="IDX-CHP-9-0118"/><a class="indexterm" id="IDX-CHP-9-0119"/><a class="indexterm" id="IDX-CHP-9-0120"/><a class="indexterm" id="IDX-CHP-9-0121"/><a class="indexterm" id="IDX-CHP-9-0122"/><a class="indexterm" id="IDX-CHP-9-0123"/><a class="indexterm" id="IDX-CHP-9-0124"/><a class="indexterm" id="IDX-CHP-9-0125"/><a class="indexterm" id="IDX-CHP-9-0126"/><a class="indexterm" id="IDX-CHP-9-0127"/><a class="indexterm" id="IDX-CHP-9-0128"/><a class="indexterm" id="IDX-CHP-9-0129"/><a class="indexterm" id="IDX-CHP-9-0130"/><a class="indexterm" id="IDX-CHP-9-0131"/><a class="indexterm" id="IDX-CHP-9-0132"/><a class="indexterm" id="IDX-CHP-9-0133"/><a class="indexterm" id="IDX-CHP-9-0134"/><a class="indexterm" id="IDX-CHP-9-0135"/><a class="indexterm" id="IDX-CHP-9-0136"/><a class="indexterm" id="IDX-CHP-9-0137"/><a class="indexterm" id="IDX-CHP-9-0138"/><a class="indexterm" id="IDX-CHP-9-0139"/><a class="indexterm" id="IDX-CHP-9-0140"/><a class="indexterm" id="IDX-CHP-9-0141"/><a class="indexterm" id="IDX-CHP-9-0142"/><a class="indexterm" id="IDX-CHP-9-0143"/><a class="indexterm" id="IDX-CHP-9-0144"/><a class="indexterm" id="IDX-CHP-9-0145"/><a class="indexterm" id="IDX-CHP-9-0146"/><a class="indexterm" id="IDX-CHP-9-0147"/><a class="indexterm" id="IDX-CHP-9-0148"/><a class="indexterm" id="IDX-CHP-9-0149"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">@delete</code>, <code class="literal">@insert</code></p></li><li class="listitem"><p><code class="literal">@index</code>, <code class="literal">@rindex</code><a class="indexterm" id="IDX-CHP-9-0150"/></p></li><li class="listitem"><p><code class="literal">@length</code><a class="indexterm" id="IDX-CHP-9-0151"/></p></li><li class="listitem"><p><code class="literal">@lowercase</code>, <code class="literal">@uppercase</code></p></li><li class="listitem"><p><code class="literal">@strbrk</code>, <code class="literal">@strspan</code></p></li><li class="listitem"><p><code class="literal">@strset</code></p></li><li class="listitem"><p><code class="literal">@substr</code>, <code class="literal">@tokenize</code>, <code class="literal">@trim</code></p></li></ul></div><p>For specific details concerning these functions, their parameters, and their types, see the HLA reference manual. Note that these are the compile-time equivalents of many of the string functions found in the HLA Standard Library.</p><p>The <code class="literal">@length</code> function deserves a special discussion because it is probably the most popular function in this category. It returns an <code class="literal">uns32</code> constant specifying the number of characters found in its string parameter. The syntax is the following:</p><a id="I_programlisting9_d1e47595"/><pre class="programlisting">@length( <em class="replaceable"><code>string_expression</code></em> )</pre><p>where <em class="replaceable"><code>string_expression</code></em> represents any compile-time string expression. As noted, this function returns the length, in characters, of the specified expression.</p></div><div class="sect2" title="9.5.5 Compile-Time Symbol Information"><div class="titlepage"><div><div><h2 class="title"><a id="compile-time_symbol_information"/>9.5.5 Compile-Time Symbol Information</h2></div></div></div><p>During compilation HLA maintains an internal database known as the <span class="emphasis"><em>symbol table</em></span>. The symbol table contains lots of useful information concerning all the identifiers you've defined up to a given point in the program. In order to generate machine code output, HLA needs to query this database to determine how to treat certain symbols. In your compile-time programs, it is often necessary to query the symbol table to determine how to handle an identifier or expression in your code. The HLA compile-time symbol-information functions handle this task.</p><p>Many of the compile-time symbol-information functions are well beyond the scope of this text. This chapter will present a few of the functions. For a complete list of the compile-time symbol-table functions, see the HLA reference manual. The functions we will consider in this chapter include the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">@size</code></p></li><li class="listitem"><p><code class="literal">@defined</code></p></li><li class="listitem"><p><code class="literal">@typeName</code></p></li><li class="listitem"><p><code class="literal">@elements</code></p></li><li class="listitem"><p><code class="literal">@elementSize</code></p></li></ul></div><p>Without question, the <code class="literal">@size</code> function is probably the most important function in this group. Indeed, previous chapters have made use of this function already. The <code class="literal">@size</code> function requires a single HLA identifier or constant expression as a parameter. It returns the size, in bytes, of the data type of that object (or expression). If you supply an identifier, it can be a constant, type, or variable identifier. As you've seen in previous chapters, this function is invaluable for allocating storage via <code class="literal">mem.alloc</code> and allocating storage for arrays.<a class="indexterm" id="IDX-CHP-9-0152"/><a class="indexterm" id="IDX-CHP-9-0153"/><a class="indexterm" id="IDX-CHP-9-0154"/><a class="indexterm" id="IDX-CHP-9-0155"/><a class="indexterm" id="IDX-CHP-9-0156"/><a class="indexterm" id="IDX-CHP-9-0157"/></p><p>Another very useful function in this group is the <code class="literal">@defined</code> function. This function accepts a single HLA identifier as a parameter. For example:</p><a id="I_programlisting9_d1e47677"/><pre class="programlisting">@defined( <em class="replaceable"><code>MyIdentifier</code></em> )</pre><p>This function returns true if the identifier is defined at that point in the program; it returns false otherwise.</p><p>The <code class="literal">@typeName</code> function returns a string specifying the type name of the identifier or expression you supply as a parameter. For example, if <code class="literal">i32</code> is an <code class="literal">int32</code> object, then <code class="literal">@typeName( i32 )</code> returns the string <code class="literal">int32</code>. This function is useful for testing the types of objects you are processing in your compile-time programs.</p><p>The <code class="literal">@elements</code> function requires an array identifier or expression. It returns the total number of array elements as the function result. Note that for multidimensional arrays this function returns the product of all the array dimensions.<sup>[<a class="footnote" href="#ftn.CHP-9-FN-3" id="CHP-9-FN-3">120</a>]</sup></p><p>The <code class="literal">@elementSize</code> function returns the size, in bytes, of an element of an array whose name you pass as a parameter. This function is extremely valuable for computing indices into an array (that is, this function computes the <code class="literal">element_size</code> component of the array index calculation; see <a class="xref" href="ch04.html" title="Chapter 4. CONSTANTS, VARIABLES, AND DATA TYPES">Chapter 4</a> for more details).</p></div><div class="sect2" title="9.5.6 Miscellaneous Compile-Time Functions"><div class="titlepage"><div><div><h2 class="title"><a id="miscellaneous_compile-time_functions"/>9.5.6 Miscellaneous Compile-Time Functions</h2></div></div></div><p>The HLA compile-time language contains several additional functions that don't fall into one of the categories above. Some of the more useful miscellaneous functions include the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">@odd</code></p></li><li class="listitem"><p><code class="literal">@lineNumber</code></p></li><li class="listitem"><p><code class="literal">@text</code></p></li></ul></div><p>The <code class="literal">@odd</code> function takes an ordinal value (i.e., nonreal numeric or character) as a parameter and returns true if the value is odd, false if it is even. The <code class="literal">@lineNumber</code> function requires no parameters; it returns the current line number in the source file. This function is quite useful for debugging compile-time (and runtime!) programs.</p><p>The <code class="literal">@text</code> function is probably the most useful function in this group. It requires a single-string parameter. It expands that string as text in place of the <code class="literal">@text</code> function call. This function is quite useful in conjunction with the compile-time string-processing functions. You can build an instruction (or a portion of an instruction) using the string-manipulation functions and then convert that string to program source code using the <code class="literal">@text</code> function. The following is a trivial example of this function in operation:<a class="indexterm" id="IDX-CHP-9-0158"/><a class="indexterm" id="IDX-CHP-9-0159"/><a class="indexterm" id="IDX-CHP-9-0160"/><a class="indexterm" id="IDX-CHP-9-0161"/><a class="indexterm" id="IDX-CHP-9-0162"/><a class="indexterm" id="IDX-CHP-9-0163"/><a class="indexterm" id="IDX-CHP-9-0164"/><a class="indexterm" id="IDX-CHP-9-0165"/><a class="indexterm" id="IDX-CHP-9-0166"/></p><a id="I_programlisting9_d1e47802"/><pre class="programlisting">?id1:string := "eax";
?id2:string := "i32";
@text( "mov( " + id1 + ", " + id2 + ");" )</pre><p>The preceding sequence compiles to</p><a id="I_programlisting9_d1e47806"/><pre class="programlisting">mov( eax, i32 );</pre></div><div class="sect2" title="9.5.7 Compile-Time Type Conversions of Text Objects"><div class="titlepage"><div><div><h2 class="title"><a id="compile-time_type_conversions_of_text_ob"/>9.5.7 Compile-Time Type Conversions of Text Objects</h2></div></div></div><p>Once you create a text constant in your program, it's difficult to manipulate that object. The following example demonstrates a programmer's desire to change the definition of a text symbol within a program:</p><a id="I_programlisting9_d1e47813"/><pre class="programlisting">val
     t:text := "stdout.put";
          .
          .
          .
     ?t:text := "fileio.put";</pre><p>The basic idea in this example is that the symbol <code class="literal">t</code> expands to <code class="literal">stdout.put</code> in the first half of the code, and it expands to <code class="literal">fileio.put</code> in the second half of the program. Unfortunately, this simple example will not work. The problem is that HLA will expand a text symbol in place almost anywhere it finds that symbol. This includes occurrences of <code class="literal">t</code> within a <code class="literal">?</code> statement. Therefore, the previous code expands to the following (incorrect) text:</p><a id="I_programlisting9_d1e47832"/><pre class="programlisting">val
     t:text := "stdout.put";
          .
          .
          .
     ?stdout.put:text := "fileio.put";</pre><p>HLA doesn't know how to deal with this <code class="literal">?</code> statement, so it generates a syntax error.</p><p>At times you may not want HLA to expand a text object. Your code may want to process the string data held by the text object. HLA provides a couple of ways to deal with these two problems:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">@string(</code> <em class="replaceable"><code>identifier</code></em> <code class="literal">)</code></p></li><li class="listitem"><p><code class="literal">@toString:</code><em class="replaceable"><code>identifier</code></em></p></li></ul></div><p>For <code class="literal">@string(</code> <em class="replaceable"><code>identifier</code></em> <code class="literal">)</code>, HLA returns a string constant corresponding to the text data associated with the text object. In other words, this operator lets you treat a text object as though it were a string constant within an expression.<a class="indexterm" id="IDX-CHP-9-0167"/><a class="indexterm" id="IDX-CHP-9-0168"/></p><p>Unfortunately, the <code class="literal">@string</code> function converts a text object to a string constant, not a string identifier. Therefore, you cannot say something like</p><a id="I_programlisting9_d1e47882"/><pre class="programlisting">?@string(t) := "Hello"</pre><p>This doesn't work because <code class="literal">@string(t)</code> replaces itself with the string constant associated with the text object <code class="literal">t</code>. Given the former assignment to <code class="literal">t</code>, this statement expands to</p><a id="I_programlisting9_d1e47896"/><pre class="programlisting">?"stdout.put" := "Hello";</pre><p>This statement is still illegal.</p><p>The <code class="literal">@toString:</code><em class="replaceable"><code>identifier</code></em> operator comes to the rescue in this case. The <code class="literal">@toString:</code> operator requires a text object as the associated identifier. It converts this text object to a string object (still maintaining the same string data) and then returns the identifier. Because the identifier is now a string object, you can assign a value to it (and change its type to something else, for example, <code class="literal">text</code>, if that's what you need). To achieve the original goal, therefore, you'd use code like the following:</p><a id="I_programlisting9_d1e47913"/><pre class="programlisting">val
     t:text := "stdout.put";
          .
          .
          .
     ?@toString:t : text := "fileio.put";</pre></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-2" id="ftn.CHP-9-FN-2">119</a>] </sup>Actually, because <code class="literal">@sin</code>'s parameter in this example is not exactly pi, you will get a small positive number instead of zero as the function result, but in theory you should get zero.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-3" id="ftn.CHP-9-FN-3">120</a>] </sup>There is an <code class="literal">@dim</code> function that returns an array specifying the bounds on each dimension of a multidimensional array. See the documentation at <a class="ulink" href="http://webster.cs.ucr.edu/">http://webster.cs.ucr.edu/</a> or <a class="ulink" href="http://www.artofasm.com/">http://www.artofasm.com/</a> for more details if you're interested in this function.</p></div></div></div>
<div class="sect1" title="9.6 Conditional Compilation (Compile-Time Decisions)"><div class="titlepage"><div><div><h1 class="title"><a id="conditional_compilation_open_parenthesis"/>9.6 Conditional Compilation (Compile-Time Decisions)</h1></div></div></div><p>HLA's compile-time language provides an if statement, <code class="literal">#if</code>, that lets you make decisions at compile time. The <code class="literal">#if</code> statement has two main purposes: The traditional use of <code class="literal">#if</code> is to support <span class="emphasis"><em>conditional compilation</em></span> (or <span class="emphasis"><em>conditional assembly</em></span>), allowing you to include or exclude code during a compilation depending on the status of various symbols or constant values in your program. The second use of this statement is to support the standard if statement decision-making process in the HLA compile-time language. This section discusses these two uses for the HLA <code class="literal">#if</code> statement.<a class="indexterm" id="IDX-CHP-9-0169"/><a class="indexterm" id="IDX-CHP-9-0170"/><a class="indexterm" id="IDX-CHP-9-0171"/></p><p>The simplest form of the HLA compile-time <code class="literal">#if</code> statement uses the following syntax:</p><a id="I_programlisting9_d1e47957"/><pre class="programlisting">#if( <em class="replaceable"><code>constant_boolean_expression</code></em> )
     &lt;&lt; text &gt;&gt;
#endif</pre><p>Note that you do not place semicolons after the <code class="literal">#endif</code> clause. If you place a semicolon after the <code class="literal">#endif</code>, it becomes part of the source code, and this would be identical to inserting that semicolon immediately before the next item in the program.<a class="indexterm" id="IDX-CHP-9-0172"/><a class="indexterm" id="IDX-CHP-9-0173"/><a class="indexterm" id="IDX-CHP-9-0174"/><a class="indexterm" id="IDX-CHP-9-0175"/><a class="indexterm" id="IDX-CHP-9-0176"/><a class="indexterm" id="IDX-CHP-9-0177"/><a class="indexterm" id="IDX-CHP-9-0178"/></p><p>At compile time, HLA evaluates the expression in the parentheses after the <code class="literal">#if</code>. This must be a constant expression, and its type must be boolean. If the expression evaluates true, HLA continues to process the text in the source file as though the <code class="literal">#if</code> statement was not present. However, if the expression evaluates false, HLA treats all the text between the <code class="literal">#if</code> and the corresponding <code class="literal">#endif</code> clause as though it were a comment (that is, it ignores this text), as shown in <a class="xref" href="ch09s06.html#operation_of_an_hla_compile-time_number" title="Figure 9-2. Operation of an HLA compile-time #if statement">Figure 9-2</a>.</p><div class="figure"><a id="operation_of_an_hla_compile-time_number"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject9_d1e48020"/><img alt="Operation of an HLA compile-time #if statement" src="tagoreillycom20100401nostarchimages578065.png"/></div></div><p class="title">Figure 9-2. Operation of an HLA compile-time <code class="literal">#if</code> statement</p></div><p>Keep in mind that HLA's constant expressions support a full expression syntax like you'd find in a high-level language like C or Pascal. The <code class="literal">#if</code> expression syntax is not limited to the syntax allowed by expressions in the HLA <code class="literal">if</code> statement. Therefore, it is perfectly reasonable to write fancy expressions like the following:</p><a id="I_programlisting9_d1e48033"/><pre class="programlisting">#if( @length( someStrConst ) &lt; 10*i &amp; ( (MaxItems*2 + 2) &lt; 100 | MinItems-5 &lt; 10 ))
     &lt;&lt; text &gt;&gt;
#endif</pre><p>Also keep in mind that the identifiers in a compile-time expression must all be <code class="literal">const</code> or <code class="literal">val</code> identifiers or an HLA compile-time function call (with appropriate parameters). In particular, remember that HLA evaluates these expressions at compile time so they cannot contain runtime variables.<sup>[<a class="footnote" href="#ftn.CHP-9-FN-4" id="CHP-9-FN-4">121</a>]</sup> HLA's compile-time language uses complete boolean evaluation, so any side effects that occur in the expression may produce undesired results.</p><p>The HLA <code class="literal">#if</code> statement supports optional <code class="literal">#elseif</code> and <code class="literal">#else</code> clauses that behave in the intuitive fashion. The complete syntax for the <code class="literal">#if</code> statement looks like the following:</p><a id="I_programlisting9_d1e48068"/><pre class="programlisting">#if( <em class="replaceable"><code>constant_boolean_expression_1</code></em> )
     &lt;&lt; text &gt;&gt;
#elseif( <em class="replaceable"><code>constant_boolean_expression_2</code></em> )
     &lt;&lt; text &gt;&gt;
#else
     &lt;&lt; text &gt;&gt;
#endif</pre><p>If the first boolean expression evaluates true, then HLA processes the text up to the <code class="literal">#elseif</code> clause. It then skips all text (that is, treats it like a comment) until it encounters the <code class="literal">#endif</code> clause. HLA continues processing the text after the <code class="literal">#endif</code> clause in the normal fashion.<a class="indexterm" id="IDX-CHP-9-0179"/><a class="indexterm" id="IDX-CHP-9-0180"/><a class="indexterm" id="IDX-CHP-9-0181"/><a class="indexterm" id="IDX-CHP-9-0182"/></p><p>If the first boolean expression above evaluates false, then HLA skips all the text until it encounters a <code class="literal">#elseif</code>, <code class="literal">#else</code>, or <code class="literal">#endif</code> clause. If it encounters a <code class="literal">#elseif</code> clause (as above), then HLA evaluates the boolean expression associated with that clause. If it evaluates true, HLA processes the text between the <code class="literal">#elseif</code> and the <code class="literal">#else</code> clauses (or to the <code class="literal">#endif</code> clause if the <code class="literal">#else</code> clause is not present). If, during the processing of this text, HLA encounters another <code class="literal">#elseif</code> or, as above, a <code class="literal">#else</code> clause, then HLA ignores all further text until it finds the corresponding <code class="literal">#endif</code>.</p><p>If both the first and second boolean expressions in the previous example evaluate false, HLA skips their associated text and begins processing the text in the <code class="literal">#else</code> clause. As you can see, the <code class="literal">#if</code> statement behaves in a relatively intuitive fashion once you understand how HLA "executes" the body of these statements; the <code class="literal">#if</code> statement processes the text or treats it as a comment, depending on the state of the boolean expression. Of course, you can create a nearly infinite variety of different <code class="literal">#if</code> statement sequences by including zero or more <code class="literal">#elseif</code> clauses and optionally supplying the <code class="literal">#else</code> clause. Because the construction is identical to the HLA <code class="literal">if..then..elseif..else..endif</code> statement, there is no need to elaborate further here.</p><p>A very traditional use of conditional compilation is to develop software that you can easily configure for several different environments. For example, the <code class="literal">fcomip</code> instruction makes floating-point comparisons very easy, but this instruction is available only on Pentium Pro and later processors. If you want to use this instruction on the processors that support it and fall back to the standard floating-point comparison on the older processors, you would normally have to write two versions of the program—one with the <code class="literal">fcomip</code> instruction and one with the traditional floating-point comparison sequence. Unfortunately, maintaining two different source files (one for newer processors and one for older processors) is very difficult. Most engineers prefer to use conditional compilation to embed the separate sequences in the same source file. The following example demonstrates how to do this:</p><a id="I_programlisting9_d1e48171"/><pre class="programlisting">const
    // Set true to use FCOMIxx instrs.
    PentProOrLater: boolean := false;
          .
          .
          .
    #if( PentProOrLater )

          fcomip();      // Compare st1 to st0 and set flags.
     #else
          fcomp();       // Compare st1 to st0.
          fstsw( ax );   // Move the FPU condition code bits
          sahf();        // into the flags register.

     #endif</pre><p>As currently written, this code fragment will compile the three-instruction sequence in the <code class="literal">#else</code> clause and ignore the code between the <code class="literal">#if</code> and <code class="literal">#else</code> clauses (because the constant <code class="literal">PentProOrLater</code> is false). By changing the value of <code class="literal">PentProOrLater</code> to true, you can tell HLA to compile the single <code class="literal">fcomip</code> instruction rather than the three-instruction sequence. Of course, you can use the <code class="literal">PentProOrLater</code> constant in other <code class="literal">#if</code> statements throughout your program to control how HLA compiles your code.<a class="indexterm" id="IDX-CHP-9-0183"/><a class="indexterm" id="IDX-CHP-9-0184"/><a class="indexterm" id="IDX-CHP-9-0185"/><a class="indexterm" id="IDX-CHP-9-0186"/></p><p>Note that conditional compilation does not let you create a single <span class="emphasis"><em>executable</em></span> that runs efficiently on all processors. When using this technique you will still have to create two executable programs (one for Pentium Pro and later processors, one for the earlier processors) by compiling your source file twice: During the first compilation you must set the <code class="literal">PentProOrLater</code> constant to false; during the second compilation you must set this constant to true. Although you must create two separate executables, you need only maintain a single source file.</p><p>If you are familiar with conditional compilation in other languages, such as the C/C++ language, you may be wondering if HLA supports a statement like C's <code class="literal">#ifdef</code> statement. The answer is no, it does not. However, you can use the HLA compile-time function <code class="literal">@defined</code> to easily test to see if a symbol has been defined earlier in the source file. Consider the following modification to the preceding code that uses this technique:</p><a id="I_programlisting9_d1e48232"/><pre class="programlisting">const
     // Note: Uncomment the following line if you are compiling this
     // code for a Pentium Pro or later CPU.

     // PentProOrLater :=0;  // Value and type are irrelevant.
          .
          .
          .
#if( @defined( PentProOrLater ) )

     fcomip();    // Compare st1 to st0 and set flags.

#else

     fcomp();     // Compare st1 to st0.
     fstsw( ax ); // Move the FPU condition code bits
     sahf();      // into the flags register.

#endif</pre><p>Another common use of conditional compilation is to introduce debugging and testing code into your programs. A typical debugging technique that many HLA programmers use is to insert "print" statements at strategic points throughout their code; this enables them to trace through their code and display important values at various checkpoints. A big problem with this technique, however, is that they must remove the debugging code prior to completing the project. The software's customer (or a student's instructor) probably doesn't want to see debugging output in the middle of a report the program produces. Therefore, programmers who use this technique tend to insert code temporarily and then remove the code once they run the program and determine what is wrong. There are at least two problems with this technique:<a class="indexterm" id="IDX-CHP-9-0187"/><a class="indexterm" id="IDX-CHP-9-0188"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Programmers often forget to remove some debugging statements, and this creates defects in the final program.</p></li><li class="listitem"><p>After removing a debugging statement, these programmers often discover that they need that same statement to debug some different problem at a later time. Hence they are constantly inserting and removing the same statements over and over again.</p></li></ul></div><p>Conditional compilation can provide a solution to this problem. By defining a symbol (say, <code class="literal">debug</code>) to control debug output in your program, you can easily activate or deactivate <span class="emphasis"><em>all</em></span> debugging output by simply modifying a single line of source code. The following code fragment demonstrates this:</p><a id="I_programlisting9_d1e48262"/><pre class="programlisting">const
     // Set to true to activate debug output.
     debug: boolean := false;
          .
          .
          .
     #if( debug )

          stdout.put( "At line ", @lineNumber, " i=", i, nl );

     #endif</pre><p>As long as you surround all debugging output statements with an #if statement like the preceding, you don't have to worry about debug output accidentally appearing in your final application. By setting the <code class="literal">debug</code> symbol to false, you can automatically disable all such output. Likewise, you don't have to remove all your debugging statements from your programs once they've served their immediate purpose. By using conditional compilation, you can leave these statements in your code because they are so easy to deactivate. Later, if you decide you need to view this same debugging information during a compilation, you won't have to reenter the debugging statement; you simply reactivate it by setting the <code class="literal">debug</code> symbol to true.</p><p>Although program configuration and debugging control are two of the more common, traditional uses for conditional compilation, don't forget that the <code class="literal">#if</code> statement provides the basic conditional statement in the HLA compile-time language. You will use the <code class="literal">#if</code> statement in your compile-time programs the same way you would use an <code class="literal">if</code> statement in HLA or some other language. Later sections in this text will present lots of examples of using the <code class="literal">#if</code> statement in this capacity.<a class="indexterm" id="IDX-CHP-9-0189"/><a class="indexterm" id="IDX-CHP-9-0190"/><a class="indexterm" id="IDX-CHP-9-0191"/><a class="indexterm" id="IDX-CHP-9-0192"/><a class="indexterm" id="IDX-CHP-9-0193"/><a class="indexterm" id="IDX-CHP-9-0194"/><a class="indexterm" id="IDX-CHP-9-0195"/><a class="indexterm" id="IDX-CHP-9-0196"/><a class="indexterm" id="IDX-CHP-9-0197"/><a class="indexterm" id="IDX-CHP-9-0198"/></p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-4" id="ftn.CHP-9-FN-4">121</a>] </sup>Except, of course, as parameters to certain HLA compile-time functions like <code class="literal">@size</code> or <code class="literal">@typeName</code>.</p></div></div></div>
<div class="sect1" title="9.7 Repetitive Compilation (Compile-Time Loops)"><div class="titlepage"><div><div><h1 class="title"><a id="repetitive_compilation_open_parenthesis"/>9.7 Repetitive Compilation (Compile-Time Loops)</h1></div></div></div><p>HLA's <code class="literal">#while..#endwhile</code> and <code class="literal">#for..#endfor</code> statements provide compile-time loop constructs. The <code class="literal">#while</code> statement tells HLA to process the same sequence of statements repetitively during compilation. This is very handy for constructing data tables as well as providing a traditional looping structure for compile-time programs. Although you will not employ the <code class="literal">#while</code> statement anywhere near as often as the <code class="literal">#if</code> statement, this compile-time control structure is very important when you write advanced HLA programs.</p><p>The <code class="literal">#while</code> statement uses the following syntax:</p><a id="I_programlisting9_d1e48352"/><pre class="programlisting">#while( <em class="replaceable"><code>constant_boolean_expression</code></em> )
     &lt;&lt; text &gt;&gt;
#endwhile</pre><p>When HLA encounters the <code class="literal">#while</code> statement during compilation, it will evaluate the constant boolean expression. If the expression evaluates false, HLA will skip over the text between the <code class="literal">#while</code> and the <code class="literal">#endwhile</code> clauses (the behavior is similar to the <code class="literal">#if</code> statement if the expression evaluates false). If the expression evaluates true, then HLA will process the statements between the <code class="literal">#while</code> and <code class="literal">#endwhile</code> clauses and then "jump back" to the start of the <code class="literal">#while</code> statement in the source file and repeat this process, as shown in <a class="xref" href="ch09s07.html#hla_compile-time_number_symble_while_sta" title="Figure 9-3. HLA compile-time #while statement operation">Figure 9-3</a>.</p><div class="figure"><a id="hla_compile-time_number_symble_while_sta"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject9_d1e48389"/><img alt="HLA compile-time #while statement operation" src="tagoreillycom20100401nostarchimages578067.png"/></div></div><p class="title">Figure 9-3. HLA compile-time <code class="literal">#while</code> statement operation</p></div><p>To understand how this process works, consider the program in <a class="xref" href="ch09s07.html#number_symble_while.._number_symble_endw" title="Example 9-2. #while..#endwhile demonstration">Example 9-2</a>.</p><div class="example"><a id="number_symble_while.._number_symble_endw"/><p class="title">Example 9-2. <code class="literal">#while..#endwhile</code> demonstration</p><div class="example-contents"><pre class="programlisting">program ctWhile;
#include( "stdlib.hhf" )

static
ary: uns32[5] := [ 2, 3, 5, 8, 13 ];

begin ctWhile;

     ?i := 0;
     #while( i &lt; 5 )

          stdout.put( "array[ ", i, " ] = ", ary[i*4], nl );
          ?i := i + 1;

     #endwhile

end ctWhile;</pre></div></div><p>As you can probably surmise, the output from this program is the following:</p><a id="I_programlisting9_d1e48407"/><pre class="programlisting">array[ 0 ] = 2
array[ 1 ] = 3
array[ 2 ] = 4
array[ 3 ] = 5
array[ 4 ] = 13</pre><p>What is not quite obvious is how this program generates this output. Remember, the <code class="literal">#while..#endwhile</code> construct is a compile-time language feature, not a runtime control construct. Therefore, the previous <code class="literal">#while</code> loop repeats five times during <span class="emphasis"><em>compilation</em></span>. On each repetition of the loop, the HLA compiler processes the statements between the <code class="literal">#while</code> and <code class="literal">#endwhile</code> clauses. Therefore, the preceding program is really equivalent to the code that is shown in <a class="xref" href="ch09s07.html#program_equivalent_to_the_code_in_listin" title="Example 9-3. Program equivalent to the code in Example 9-2">Example 9-3</a>.</p><div class="example"><a id="program_equivalent_to_the_code_in_listin"/><p class="title">Example 9-3. Program equivalent to the code in <a class="xref" href="ch09s07.html#number_symble_while.._number_symble_endw" title="Example 9-2. #while..#endwhile demonstration">Example 9-2</a></p><div class="example-contents"><pre class="programlisting">program ctWhile;
#include( "stdlib.hhf" )

static
     ary: uns32[5] := [ 2, 3, 5, 8, 13 ];

begin ctWhile;

     stdout.put( "array[ ", 0, " ] = ", ary[0*4], nl );
     stdout.put( "array[ ", 1, " ] = ", ary[1*4], nl );
     stdout.put( "array[ ", 2, " ] = ", ary[2*4], nl );
     stdout.put( "array[ ", 3, " ] = ", ary[3*4], nl );
     stdout.put( "array[ ", 4, " ] = ", ary[4*4], nl );

end ctWhile;</pre></div></div><p>As you can see in this example, the <code class="literal">#while</code> statement is very convenient for constructing repetitive-code sequences. This is especially invaluable for unrolling loops.<a class="indexterm" id="IDX-CHP-9-0199"/><a class="indexterm" id="IDX-CHP-9-0200"/><a class="indexterm" id="IDX-CHP-9-0201"/><a class="indexterm" id="IDX-CHP-9-0202"/></p><p>HLA provides three forms of the <code class="literal">#for..#endfor</code> loop. These three loops take the following general form:</p><div class="example"><a id="hla_number_symble_for_loops"/><p class="title">Example 9-4. HLA <code class="literal">#for</code> loops</p><div class="example-contents"><pre class="programlisting">#for( <em class="replaceable"><code>valObject</code></em> := <em class="replaceable"><code>startExpr</code></em> to <em class="replaceable"><code>endExpr</code></em> )

          .
          .
     #endfor

     #for( <em class="replaceable"><code>valObject</code></em> := <em class="replaceable"><code>startExpr</code></em> downto <em class="replaceable"><code>endExpr</code></em> )
          .
          .
          .
     #endfor

     #for( <em class="replaceable"><code>valObject</code></em> in <em class="replaceable"><code>composite_expr</code></em> )
          .
          .
          .
     #endfor</pre></div></div><p>As its name suggests, <em class="replaceable"><code>valObject</code></em> must be an object you've defined in a <code class="literal">val</code> declaration.</p><p>For the first two forms of the <code class="literal">#for</code> loop above, the <em class="replaceable"><code>startExpr</code></em> and <em class="replaceable"><code>endExpr</code></em> components can be any HLA constant expression that yields an integer value. The first of these <code class="literal">#for</code> loops is semantically equivalent to the following <code class="literal">#while</code> code:</p><a id="I_programlisting9_d1e48520"/><pre class="programlisting">?<em class="replaceable"><code>valObject</code></em> := <em class="replaceable"><code>startExpr</code></em>;
     #while( <em class="replaceable"><code>valObject</code></em> &lt;= <em class="replaceable"><code>endExpr</code></em> )
               .
               .
               .
          ?<em class="replaceable"><code>valObject</code></em> := <em class="replaceable"><code>valObject</code></em> + 1;
  #endwhile</pre><p>The second of these <code class="literal">#for</code> loops is semantically equivalent to the <code class="literal">#while</code> loop:</p><a id="I_programlisting9_d1e48549"/><pre class="programlisting">?<em class="replaceable"><code>valObject</code></em> := <em class="replaceable"><code>startExpr</code></em>;
     #while( <em class="replaceable"><code>valObject</code></em> &gt;= <em class="replaceable"><code>endExpr</code></em> )
               .
               .
               .
     ?<em class="replaceable"><code>valObject</code></em> := <em class="replaceable"><code>valObject</code></em> - 1;
  #endwhile</pre><p>The third of these <code class="literal">#for</code> loops (the one using the <code class="literal">in</code> keyword) is especially useful for processing individual items from some composite data type. This loop repeats once for each element, field, character, and so on of the composite value you specify for <em class="replaceable"><code>composite_expr</code></em>. This can be an array, string, record, or character set expression. For arrays, this <code class="literal">#for</code> loop repeats once for each element of the array and on each iteration of the loop; the loop control variable contains the current element's value. For example, the following compile-time loop displays the values 1, 10, 100, and 1,000:<a class="indexterm" id="IDX-CHP-9-0203"/></p><a id="I_programlisting9_d1e48587"/><pre class="programlisting">#for( i in [1, 10, 100, 1000])
          #print( i )
 #endfor</pre><p>If the <em class="replaceable"><code>composite_expr</code></em> constant is a string constant, the <code class="literal">#for</code> loop repeats once for each character in the string and sets the value of the loop control variable to the current character. If the <em class="replaceable"><code>composite_expr</code></em> constant expression is a record constant, then the loop will repeat once for each field of the record, and for each iteration the loop control variable will take on the <span class="emphasis"><em>type and value</em></span> of the current field. If the <em class="replaceable"><code>composite_expr</code></em> expression is a character set, the loop will repeat once for each character in the set, and the loop control variable will be assigned that character.</p><p>The <code class="literal">#for</code> loop actually turns out to be more useful than the <code class="literal">#while</code> loop because the larger number of compile-time loops you encounter repeat a fixed number of times (for example, processing a fixed number of array elements, macro parameters, and so on).</p></div>
<div class="sect1" title="9.8 Macros (Compile-Time Procedures)"><div class="titlepage"><div><div><h1 class="title"><a id="macros_open_parenthesis_compile-time_pro"/>9.8 Macros (Compile-Time Procedures)</h1></div></div></div><p>Macros are objects that a language processor replaces with other text during compilation. Macros are great devices for replacing long, repetitive sequences of text with much shorter sequences of text. In additional to the traditional role that macros play (e.g., <code class="literal">#define</code> in C/C++), HLA's macros also serve as the equivalent of a compile-time language procedure or function. Therefore, macros are very important in HLA's compile-time language—just as important as functions and procedures are in other high-level languages.<a class="indexterm" id="IDX-CHP-9-0204"/><a class="indexterm" id="IDX-CHP-9-0205"/></p><p>Although macros are nothing new, HLA's implementation of macros far exceeds the macro-processing capabilities of most other programming languages (high level or low level). The following sections explore HLA's macro-processing facilities and the relationship between macros and other HLA CTL control constructs.</p><div class="sect2" title="9.8.1 Standard Macros"><div class="titlepage"><div><div><h2 class="title"><a id="standard_macros"/>9.8.1 Standard Macros</h2></div></div></div><p>HLA supports a straightforward macro facility that lets you define macros in a manner that is similar to declaring a procedure. A typical, simple macro declaration takes the following form:<a class="indexterm" id="IDX-CHP-9-0206"/><a class="indexterm" id="IDX-CHP-9-0207"/><a class="indexterm" id="IDX-CHP-9-0208"/><a class="indexterm" id="IDX-CHP-9-0209"/><a class="indexterm" id="IDX-CHP-9-0210"/></p><a id="I_programlisting9_d1e48657"/><pre class="programlisting">#macro <em class="replaceable"><code>macroname</code></em>;
     &lt;&lt; Macro body &gt;&gt;
#endmacro</pre><p>Although macro and procedure declarations are similar, there are several immediate differences between the two that are obvious from this example. First, of course, macro declarations use the reserved word <code class="literal">#macro</code> rather than procedure. Second, you do not begin the body of the macro with a begin <em class="replaceable"><code>macroname</code></em><code class="literal">;</code> clause. Finally, you will note that macros end with the <code class="literal">#endmacro</code> clause rather than <code class="literal">end</code> <em class="replaceable"><code>macroname</code></em><code class="literal">;</code>. The following code is a concrete example of a macro declaration:</p><a id="I_programlisting9_d1e48684"/><pre class="programlisting">#macro neg64;

     neg( edx );
     neg( eax );
     sbb( 0, edx );

#endmacro</pre><p>Execution of this macro's code will compute the two's complement of the 64-bit value in EDX:EAX (see the description of extended-precision <code class="literal">neg</code> in <a class="xref" href="ch08.html#extended-precision_neg_operations" title="8.1.7 Extended-Precision neg Operations">8.1.7 Extended-Precision neg Operations</a>).</p><p>To execute the code associated with <code class="literal">neg64</code>, you simply specify the macro's name at the point you want to execute these instructions. For example:</p><a id="I_programlisting9_d1e48698"/><pre class="programlisting">mov( (type dword i64), eax );
     mov( (type dword i64[4]), edx );
     neg64;</pre><p>Note that you do <span class="emphasis"><em>not</em></span> follow the macro's name with a pair of empty parentheses as you would a procedure call (the reason for this will become clear a little later).</p><p>Other than the lack of parentheses following <code class="literal">neg64</code>'s invocation,<sup>[<a class="footnote" href="#ftn.CHP-9-FN-5" id="CHP-9-FN-5">122</a>]</sup> this looks just like a procedure call. You could implement this simple macro as a procedure using the following procedure declaration:</p><a id="I_programlisting9_d1e48720"/><pre class="programlisting">procedure neg64p;
begin neg64p;

     neg( edx );
     neg( eax );
     sbb( 0, edx );

end neg64p;</pre><p>Note that the following two statements will both negate the value in EDX:EAX:<a class="indexterm" id="IDX-CHP-9-0211"/></p><a id="I_programlisting9_d1e48728"/><pre class="programlisting">neg64;          neg64p();</pre><p>The difference between these two (the macro invocation versus the procedure call) is the fact that macros expand their text inline, whereas a procedure call emits a call to the corresponding procedure elsewhere in the text. That is, HLA replaces the invocation <code class="literal">neg64;</code> directly with the following text:</p><a id="I_programlisting9_d1e48735"/><pre class="programlisting">neg( edx );
     neg( eax );
     sbb( 0, edx );</pre><p>On the other hand, HLA replaces the procedure call <code class="literal">neg64p();</code> with the single call instruction:</p><a id="I_programlisting9_d1e48742"/><pre class="programlisting">call neg64p;</pre><p>Presumably, you've defined the <code class="literal">neg64p</code> procedure earlier in the program.</p><p>You should make the choice of macro versus procedure call on the basis of efficiency. Macros are slightly faster than procedure calls because you don't execute the <code class="literal">call</code> and corresponding <code class="literal">ret</code> instructions. On the other hand, the use of macros can make your program larger because a macro invocation expands to the text of the macro's body on each invocation. Procedure calls jump to a single instance of the procedure's body. Therefore, if the macro body is large and you invoke the macro several times throughout your program, it will make your final executable much larger. Also, if the body of your macro executes more than a few simple instructions, the overhead of a <code class="literal">call/ret</code> sequence has little impact on the overall execution time of the code, so the execution time savings are nearly negligible. On the other hand, if the body of a procedure is very short (like the <code class="literal">neg64</code> example above), you'll discover that the macro implementation is much faster and doesn't expand the size of your program by much. A good rule of thumb is:</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Use macros for short, time-critical program units. Use procedures for longer blocks of code and when execution time is not as critical.</p></div><p>Macros have many other disadvantages over procedures. Macros cannot have local (automatic) variables, macro parameters work differently than procedure parameters, macros don't support (runtime) recursion, and macros are a little more difficult to debug than procedures (just to name a few disadvantages). Therefore, you shouldn't really use macros as a substitute for procedures except in cases where performance is absolutely critical.<a class="indexterm" id="IDX-CHP-9-0212"/></p></div><div class="sect2" title="9.8.2 Macro Parameters"><div class="titlepage"><div><div><h2 class="title"><a id="macro_parameters"/>9.8.2 Macro Parameters</h2></div></div></div><p>Like procedures, macros allow you to define parameters that let you supply different data on each macro invocation. This lets you write generic macros whose behavior can vary depending on the parameters you supply. By processing these macro parameters at compile time, you can write very sophisticated macros.<a class="indexterm" id="IDX-CHP-9-0213"/></p><p>Macro parameter declaration syntax is very straightforward. You simply supply a list of parameter names within parentheses in a macro declaration:</p><a id="I_programlisting9_d1e48783"/><pre class="programlisting">#macro neg64( reg32HO, reg32LO );

     neg( reg32HO );
     neg( reg32LO );
     sbb( 0, reg32HO );

#endmacro;</pre><p>Note that you do not associate a data type with a macro parameter as you do for procedural parameters. This is because HLA macros are generally <code class="literal">text</code> objects.</p><p>When you invoke a macro, you simply supply the actual parameters the same way you would for a procedure call:</p><a id="I_programlisting9_d1e48792"/><pre class="programlisting">neg64( edx, eax );</pre><p>Note that a macro invocation that requires parameters expects you to enclose the parameter list within parentheses.</p><div class="sect3" title="9.8.2.1 Standard Macro Parameter Expansion"><div class="titlepage"><div><div><h3 class="title"><a id="standard_macro_parameter_expansion"/>9.8.2.1 Standard Macro Parameter Expansion</h3></div></div></div><p>As the previous section explains, HLA automatically associates the type <code class="literal">text</code> with macro parameters. This means that during a macro expansion, HLA substitutes the text you supply as the actual parameter everywhere the formal parameter name appears. The semantics of "pass by textual substitution" are a little different than "pass by value" or "pass by reference," so it is worthwhile exploring those differences here.</p><p>Consider the following macro invocations, using the <code class="literal">neg64</code> macro from the previous section:</p><a id="I_programlisting9_d1e48809"/><pre class="programlisting">neg64( edx, eax );
     neg64( ebx, ecx );</pre><p>These two invocations expand into the following code:</p><a id="I_programlisting9_d1e48813"/><pre class="programlisting">// neg64(edx, eax );

     neg( edx );
     neg( eax );
     sbb( 0, edx );

// neg64( ebx, ecx );

     neg( ebx );
     neg( ecx );
     sbb( 0, ebx );</pre><p>Note that macro invocations do not make a local copy of the parameters (as "pass by value" does), nor do they pass the address of the actual parameter to the macro. Instead, a macro invocation of the form <code class="literal">neg64( edx, eax );</code> is equivalent to the following:</p><a id="I_programlisting9_d1e48820"/><pre class="programlisting">?reg32HO: text := "edx";
  ?reg32LO: text := "eax";

  neg( reg32HO );
  neg( reg32LO );
  sbb( 0, reg32HO );</pre><p>Of course, the text objects immediately expand their string values inline, producing the former expansion for <code class="literal">neg64( edx, eax );</code>.</p><p>Note that macro parameters are not limited to memory, register, or constant operands as are instruction or procedure operands. Any text is fine as long as its expansion is legal wherever you use the formal parameter. Similarly, formal parameters may appear anywhere in the macro body, not just where memory, register, or constant operands are legal. Consider the following macro declaration and sample invocations:</p><a id="I_programlisting9_d1e48829"/><pre class="programlisting">#macro chkError( instr, jump, target );

     instr;
     jump target;

#endmacro;

     chkError( cmp( eax, 0 ), jnl, RangeError );       // Example 1
          ...
     chkError( test( 1, bl ), jnz, ParityError );      // Example 2

// Example 1 expands to

     cmp( eax, 0 );
     jnl RangeError;

// Example 2 expands to

     test( 1, bl );
     jnz ParityError;</pre><p>In general, HLA assumes that all text between commas constitutes a single macro parameter. If HLA encounters any opening bracketing symbols (left parentheses, left braces, or left brackets), then it will include all text up to the appropriate closing symbol, ignoring any commas that may appear within the bracketing symbols. This is why the <code class="literal">chkError</code> invocations above treat <code class="literal">cmp( eax, 0 )</code> and <code class="literal">test( 1, bl )</code> as single parameters rather than as a pair of parameters. Of course, HLA does not consider commas (and bracketing symbols) within a string constant as the end of an actual parameter. So the following macro and invocation are perfectly legal:<a class="indexterm" id="IDX-CHP-9-0214"/><a class="indexterm" id="IDX-CHP-9-0215"/><a class="indexterm" id="IDX-CHP-9-0216"/></p><a id="I_programlisting9_d1e48854"/><pre class="programlisting">#macro print( strToPrint );

     stdout.out( strToPrint );

#endmacro;
     .
     .
     .
     print( "Hello, world!" );</pre><p>HLA treats the string <code class="literal">Hello, world!</code> as a single parameter because the comma appears inside a literal string constant, just as your intuition suggests.</p><p>If you are unfamiliar with textual macro parameter expansion in other languages, you should be aware that there are some problems you can run into when HLA expands your actual macro parameters. Consider the following macro declaration and invocation:</p><a id="I_programlisting9_d1e48863"/><pre class="programlisting">#macro Echo2nTimes( n, theStr );
     #for( echoCnt := 1 to n*2 )
          #print( theStr )
     #endfor
#endmacro;

     .
     .
     .
Echo2nTimes( 3+1, "Hello" );</pre><p>This example displays <code class="literal">Hello</code> five times during compilation rather than the eight times you might intuitively expect. This is because the <code class="literal">#for</code> statement above expands to</p><a id="I_programlisting9_d1e48873"/><pre class="programlisting">#for( echoCnt := 1 to 3+1*2 )</pre><p>The actual parameter for <span class="emphasis"><em>n</em></span> is <code class="literal">3+1</code>; because HLA expands this text directly in place of <span class="emphasis"><em>n</em></span>, you get an erroneous text expansion. Of course, at compile time HLA computes <code class="literal">3+1*2</code> as the value 5 rather than as the value 8 (which you would get had HLA passed this parameter by value rather than by textual substitution).<a class="indexterm" id="IDX-CHP-9-0217"/></p><p>The common solution to this problem when passing numeric parameters that may contain compile-time expressions is to surround the formal parameter in the macro with parentheses; for example, you would rewrite the macro above as follows:<a class="indexterm" id="IDX-CHP-9-0218"/></p><a id="I_programlisting9_d1e48899"/><pre class="programlisting">#macro Echo2nTimes( n, theStr );

    #for( echoCnt := 1 to  (n)*2 )

        #print( theStr )

    #endfor

#endmacro;</pre><p>The earlier invocation would expand to the following code:</p><a id="I_programlisting9_d1e48904"/><pre class="programlisting">#for( echoCnt := 1 to (3+1)*2 )
         #print( theStr )
    #endfor</pre><p>This version of the macro produces the intuitive result.</p><p>If the number of actual parameters does not match the number of formal parameters, HLA will generate a diagnostic message during compilation. As with procedures, the number of actual parameters must agree with the number of formal parameters. If you would like to have optional macro parameters, then keep reading.</p></div><div class="sect3" title="9.8.2.2 Macros with a Variable Number of Parameters"><div class="titlepage"><div><div><h3 class="title"><a id="macros_with_a_variable_number_of_paramet"/>9.8.2.2 Macros with a Variable Number of Parameters</h3></div></div></div><p>You may have noticed by now that some HLA macros don't require a fixed number of parameters. For example, the <code class="literal">stdout.put</code> macro in the HLA Standard Library allows one or more actual parameters. HLA uses a special array syntax to tell the compiler that you wish to allow a variable number of parameters in a macro parameter list. If you follow the last macro parameter in the formal parameter list with <code class="literal">[ ]</code>, then HLA will allow a variable number of actual parameters (zero or more) in place of that formal parameter. For example:<a class="indexterm" id="IDX-CHP-9-0219"/></p><a id="I_programlisting9_d1e48924"/><pre class="programlisting">#macro varParms( varying[] );

     &lt;&lt; Macro body &gt;&gt;

#endmacro;
     .
     .
     .
     varParms( 1 );
     varParms( 1, 2 );
     varParms( 1, 2, 3 );
     varParms();</pre><p>Note the last invocation especially. If a macro has any formal parameters, you must supply parentheses with the macro list after the macro invocation. This is true even if you supply zero actual parameters to a macro with a varying parameter list. Keep in mind this important difference between a macro with no parameters and a macro with a varying parameter list but no actual parameters.</p><p>When HLA encounters a formal macro parameter with the <code class="literal">[ ]</code> suffix (which must be the last parameter in the formal parameter list), HLA creates a constant string array and initializes that array with the text associated with the remaining actual parameters in the macro invocation. You can determine the number of actual parameters assigned to this array using the <code class="literal">@elements</code> compile-time function. For example, <code class="literal">@elements( varying )</code> will return some value, 0 or greater, that specifies the total number of parameters associated with that parameter. The following declaration for <code class="literal">varParms</code> demonstrates how you might use this:</p><a id="I_programlisting9_d1e48942"/><pre class="programlisting">#macro varParms( varying[] );

     #for( vpCnt := 0 to @elements( varying ) - 1 )

          #print( varying[ vpCnt ] )

     #endfor

#endmacro;
     .
     .
     .
 varParms( 1 );        // Prints "1" during compilation.
 varParms( 1, 2 );     // Prints "1" and "2" on separate lines.
 varParms( 1, 2, 3 );  // Prints "1", "2", and "3" on separate lines.
 varParms();           // Doesn't print anything.</pre><p>Because HLA doesn't allow arrays of <code class="literal">text</code> objects, the varying parameter must be an array of strings. This, unfortunately, means you must treat the varying parameters differently than you handle standard macro parameters. If you want some element of the varying string array to expand as text within the macro body, you can always use the <code class="literal">@text</code> function to achieve this. Conversely, if you want to use a nonvarying formal parameter as a string object, you can always use the <code class="literal">@string</code>( <em class="replaceable"><code>name</code></em> ) function. The following example demonstrates this:<a class="indexterm" id="IDX-CHP-9-0220"/><a class="indexterm" id="IDX-CHP-9-0221"/><a class="indexterm" id="IDX-CHP-9-0222"/></p><a id="I_programlisting9_d1e48972"/><pre class="programlisting">#macro ReqAndOpt( Required, optional[] );
     ?@text( optional[0] ) := @string( ReqAndOpt );
     #print( @text( optional[0] ))

     #endmacro;
     .
     .
     .
     ReqAndOpt( i, j );

// The macro invocation above expands to

     ?@text( "j" ) := @string( i );
     #print( "j" )

// The above further expands to

     j := "i";
     #print( j )

// The above simply prints "i" during compilation.</pre><p>Of course, it would be a good idea, in a macro like the above, to verify that there are at least two parameters before attempting to reference element zero of the <code class="literal">optional</code> parameter. You can easily do this as follows:</p><a id="I_programlisting9_d1e48979"/><pre class="programlisting">#macro ReqAndOpt( Required, optional[] );

     #if( @elements( optional ) &gt; 0 )

          ?@text( optional[0] ) := @string( ReqAndOpt );
          #print( @text( optional[0] ))

     #else

          #error( "ReqAndOpt must have at least two parameters" )

     #endif

#endmacro;</pre></div><div class="sect3" title="9.8.2.3 Required vs. Optional Macro Parameters"><div class="titlepage"><div><div><h3 class="title"><a id="required_vs._optional_macro_parameters"/>9.8.2.3 Required vs. Optional Macro Parameters</h3></div></div></div><p>As the previous section notes, HLA requires exactly one actual parameter for each nonvarying formal macro parameter. If there is no varying macro parameter (and there can be at most one), then the number of actual parameters must exactly match the number of formal parameters. If a varying formal parameter is present, then there must be at least as many actual macro parameters as there are nonvarying (or required) formal macro parameters. If there is a single, varying actual parameter, then a macro invocation may have zero or more actual parameters.<a class="indexterm" id="IDX-CHP-9-0223"/><a class="indexterm" id="IDX-CHP-9-0224"/></p><p>There is one big difference between a macro invocation of a macro with no parameters and a macro invocation of a macro with a single, varying parameter that has no actual parameters: The macro with the varying parameter list must have an empty set of parentheses after it, while the macro invocation of the macro without any parameters does not allow this. You can use this fact to your advantage if you wish to write a macro that doesn't have any parameters but you want to follow the macro invocation with <code class="literal">( )</code> so that it matches the syntax of a procedure call with no parameters. Consider the following macro:</p><a id="I_programlisting9_d1e48999"/><pre class="programlisting">#macro neg64( JustForTheParens[] );

     #if( @elements( JustForTheParens ) = 0 )

          neg( edx );
          neg( eax );
          sbb( 0, edx );

     #else

          #error( "Unexpected operand(s)" )

     #endif

#endmacro;</pre><p>The preceding macro requires invocations of the form <code class="literal">neg64();</code> to use the same syntax you would use for a procedure call. This feature is useful if you want the syntax of your parameterless macro invocations to match the syntax of a parameterless procedure call. It's not a bad idea to do this, just in the off chance you need to convert the macro to a procedure at some point (or vice versa, for that matter).</p></div></div><div class="sect2" title="9.8.3 Local Symbols in a Macro"><div class="titlepage"><div><div><h2 class="title"><a id="local_symbols_in_a_macro"/>9.8.3 Local Symbols in a Macro</h2></div></div></div><p>Consider the following macro declaration:</p><a id="I_programlisting9_d1e49011"/><pre class="programlisting">macro JZC( target );

         jnz NotTarget;
         jc target;
     NotTarget:

endmacro;</pre><p>The purpose of this macro is to simulate an instruction that jumps to the specified target location if the zero flag is set <code class="literal">and</code> the carry flag is set. Conversely, if either the zero flag is clear or the carry flag is clear, this macro transfers control to the instruction immediately following the macro invocation.<a class="indexterm" id="IDX-CHP-9-0225"/></p><p>There is a serious problem with this macro. Consider what happens if you use this macro more than once in your program:</p><a id="I_programlisting9_d1e49023"/><pre class="programlisting">JZC( <em class="replaceable"><code>Dest1</code></em> );
          .
          .
          .
     JZC( <em class="replaceable"><code>Dest2</code></em> );
          .
          .
          .</pre><p>The preceding macro invocations expand to the following code:</p><a id="I_programlisting9_d1e49033"/><pre class="programlisting">jnz NotTarget;
    jc <em class="replaceable"><code>Dest1</code></em>;
NotTarget:
         .
         .
         .
    jnz NotTarget;
    jc <em class="replaceable"><code>Dest2</code></em>;
NotTarget:
         .
         .
         .</pre><p>The problem with the expansion of these two macro invocations is that they both emit the same label, <code class="literal">NotTarget</code>, during macro expansion. When HLA processes this code it will complain about a duplicate symbol definition. Therefore, you must take care when defining symbols inside a macro because multiple invocations of that macro may lead to multiple definitions of that symbol.</p><p>HLA's solution to this problem is to allow the use of <span class="emphasis"><em>local symbols</em></span> within a macro. Local macro symbols are unique to a specific invocation of a macro. For example, had <code class="literal">NotTarget</code> been a local symbol in the preceding <code class="literal">JZC</code> macro invocations, the program would have compiled properly because HLA treats each occurrence of <code class="literal">NotTarget</code> as a unique symbol.</p><p>HLA does not automatically make internal macro symbol definitions local to that macro.<sup>[<a class="footnote" href="#ftn.CHP-9-FN-6" id="CHP-9-FN-6">123</a>]</sup> Instead, you must explicitly tell HLA which symbols must be local. You do this in a macro declaration using the following generic syntax:<a class="indexterm" id="IDX-CHP-9-0226"/></p><a id="I_programlisting9_d1e49070"/><pre class="programlisting">#macro <em class="replaceable"><code>macroname</code></em>( <em class="replaceable"><code>optional_parameters</code></em> ):<em class="replaceable"><code>optional_list_of_local_names</code></em> ;
     &lt;&lt; Macro body &gt;&gt;
#endmacro;</pre><p>The list of local names is a sequence of one or more HLA identifiers separated by commas. Whenever HLA encounters this name in a particular macro invocation, it automatically substitutes some unique name for that identifier. For each macro invocation, HLA substitutes a different name for the local symbol.</p><p>You can correct the problem with the <code class="literal">JZC</code> macro by using the following macro code:</p><a id="I_programlisting9_d1e49088"/><pre class="programlisting">#macro JZC( target ):NotTarget;

         jnz NotTarget;
         jc target;
     NotTarget:

#endmacro;</pre><p>Now whenever HLA processes this macro it will automatically associate a unique symbol with each occurrence of <code class="literal">NotTarget</code>. This will prevent the duplicate-symbol error that occurs if you do not declare <code class="literal">NotTarget</code> as a local symbol.</p><p>HLA implements local symbols by substituting a symbol like <code class="literal">_</code><em class="replaceable"><code>nnnn</code></em><code class="literal">_</code> (where <em class="replaceable"><code>nnnn</code></em> is a four-digit hexadecimal number) wherever the local symbol appears in a macro invocation. For example, a macro invocation of the form <code class="literal">JZC(</code> <em class="replaceable"><code>SomeLabel</code></em> <code class="literal">);</code> might expand to</p><a id="I_programlisting9_d1e49120"/><pre class="programlisting">jnz _010A_;
      jc <em class="replaceable"><code>SomeLabel</code></em>;
_010A_:</pre><p>For each local symbol appearing within a macro expansion, HLA will generate a unique temporary identifier by simply incrementing this numeric value for each new local symbol it needs. As long as you do not explicitly create labels of the form <code class="literal">_</code><em class="replaceable"><code>nnnn</code></em><code class="literal">_</code><em class="replaceable"><code>Text</code></em><code class="literal">_</code> (where <em class="replaceable"><code>nnnn</code></em> is a hexadecimal value), there will never be a conflict in your program. HLA explicitly reserves all symbols that begin and end with a single underscore for its own private use (and for use by the HLA Standard Library). As long as you honor this restriction, there should be no conflicts between HLA local symbol generation and labels in your own programs because all HLA-generated symbols begin and end with a single underscore.</p><p>HLA implements local symbols by effectively converting that local symbol to a text constant that expands to the unique symbol HLA generates for the local label. That is, HLA effectively treats local symbol declarations as indicated by the following example:</p><a id="I_programlisting9_d1e49143"/><pre class="programlisting">#macro JZC( target );
     ?NotTarget:text := "_010A_<em class="replaceable"><code>Text</code></em>_";

         jnz NotTarget;
         jc target;

     NotTarget:

#endmacro;</pre><p>Whenever HLA expands this macro it will substitute <code class="literal">_010A_</code><em class="replaceable"><code>Text</code></em><code class="literal">_</code> for each occurrence of <code class="literal">NotTarget</code> it encounters in the expansion. This analogy isn't perfect because the text symbol <code class="literal">NotTarget</code> in this example is still accessible after the macro expansion, whereas this is not the case when defining local symbols within a macro. But this does give you an idea of how HLA implements local symbols.</p></div><div class="sect2" title="9.8.4 Macros as Compile-Time Procedures"><div class="titlepage"><div><div><h2 class="title"><a id="macros_as_compile-time_procedures"/>9.8.4 Macros as Compile-Time Procedures</h2></div></div></div><p>Although programmers typically use macros to expand to some sequence of machine instructions, there is absolutely no requirement that a macro body contain any executable instructions. Indeed, many macros contain only compile-time language statements (for example, <code class="literal">#if</code>, <code class="literal">#while</code>, <code class="literal">#for</code>, <code class="literal">?</code> assignments, and the like). By placing only compile-time language statements in the body of a macro, you can effectively write compile-time procedures and functions using macros.<a class="indexterm" id="IDX-CHP-9-0227"/></p><p>The following <code class="literal">unique</code> macro is a good example of a compile-time function that returns a string result. Consider the definition of this macro:</p><a id="I_programlisting9_d1e49190"/><pre class="programlisting">#macro unique:theSym;
     @string(theSym)
#endmacro;</pre><p>Whenever your code references this macro, HLA replaces the macro invocation with the text <code class="literal">@string(theSym)</code>, which, of course, expands to some string like <code class="literal">_021F_</code><em class="replaceable"><code>Text</code></em><code class="literal">_.</code> Therefore, you can think of this macro as a compile-time function that returns a string result.</p><p>Be careful that you don't take the function analogy too far. Remember, macros always expand to their body text at the point of invocation. Some expansions may not be legal at any arbitrary point in your programs. Fortunately, most compile-time statements are legal anywhere whitespace is legal in your programs. Therefore, macros behave as you would expect functions or procedures to behave during the execution of your compile-time programs.</p><p>Of course, the only difference between a procedure and a function is that a function returns some explicit value, while procedures simply do some activity. There is no special syntax for specifying a compile-time function return value. As the example above indicates, simply specifying the value you wish to return as a statement in the macro body suffices. A compile-time procedure, on the other hand, would not contain any non-compile-time language statements that expand into some sort of data during macro invocation.<a class="indexterm" id="IDX-CHP-9-0228"/><a class="indexterm" id="IDX-CHP-9-0229"/></p></div><div class="sect2" title="9.8.5 Simulating Function Overloading with Macros"><div class="titlepage"><div><div><h2 class="title"><a id="simulating_function_overloading_with_mac"/>9.8.5 Simulating Function Overloading with Macros</h2></div></div></div><p>The C++ language supports a nifty feature known as <span class="emphasis"><em>function overloading</em></span>. Function overloading lets you write several different functions or procedures that all have the same name. The difference between these functions is the types of their parameters or the number of parameters. A procedure declaration is unique in C++ if it has a different number of parameters than other functions with the same name or if the types of its parameters differ from other functions with the same name. HLA does not directly support procedure overloading, but you can use macros to achieve the same result. This section explains how to use HLA's macros and the compile-time language to achieve function/procedure overloading.</p><p>One good use for procedure overloading is to reduce the number of Standard Library routines you must remember how to use. For example, the HLA Standard Library provides five different "puti" routines that output an integer value: <code class="literal">stdout.puti128</code>, <code class="literal">stdout.puti64</code>, <code class="literal">stdout.puti32</code>, <code class="literal">stdout.puti16</code>, and <code class="literal">stdout.puti8</code>. The different routines, as their names suggest, output integer values according to the size of their integer parameter. In the C++ language (or another other language supporting procedure/function overloading) the engineer designing the input routines would probably have chosen to name them all <code class="literal">stdout.puti</code> and leave it up to the compiler to select the appropriate one based on the operand size.<sup>[<a class="footnote" href="#ftn.CHP-9-FN-7" id="CHP-9-FN-7">124</a>]</sup> The macro in <a class="xref" href="ch09s08.html#simple_procedure_overloading_based_on_op" title="Example 9-5. Simple procedure overloading based on operand size">Example 9-5</a> demonstrates how to do this in HLA using the compile-time language to figure out the size of the parameter operand.</p><div class="example"><a id="simple_procedure_overloading_based_on_op"/><p class="title">Example 9-5. Simple procedure overloading based on operand size</p><div class="example-contents"><pre class="programlisting">// Puti.hla
//
// This program demonstrates procedure overloading via macros.
//
// It defines a "puti" macro that calls stdout.puti8, stdout.puti16,
// stdout.puti32, or stdout.puti64, depending on the size of
// the operand.

program putiDemo;
#include( "stdlib.hhf" )


// puti-
//
// Automatically decides whether we have a 64-, 32-, 16-, or 8-bit
// operand and calls the appropriate stdout.putiX routine to
// output this value.

#macro puti( operand );

     // If we have an 8-byte operand, call puti64:

     #if( @size( operand ) = 8 )

          stdout.puti64( operand );


     // If we have a 5-byte operand, call puti32:

     #elseif( @size( operand ) = 4 )

          stdout.puti32( operand );


     // If we have a 2-byte operand, call puti16:

     #elseif( @size( operand ) = 2 )

          stdout.puti16( operand );


     // If we have a 1-byte operand, call puti8:

     #elseif( @size( operand ) = 1 )

          stdout.puti8( operand );


     // If it's not an 8-, 4-, 2-, or 1-byte operand,
     // then print an error message:

     #else

          #error( "Expected a 64-, 32-, 16-, or 8-bit operand" )

     #endif

#endmacro;


// Some sample variable declarations so we can test the macro above:

static
     i8:  int8    := −8;
     i16: int16   := −16;
     i32: int32   := −32;
     i64: qword;


begin putiDemo;

     // Initialize i64 because we can't do this in the static section.

     mov( −64, (type dword i64 ));
     mov( $FFFF_FFFF, (type dword i64[4]));

     // Demo the puti macro:

     puti( i8  ); stdout.newln();
     puti( i16 ); stdout.newln();
     puti( i32 ); stdout.newln();
     puti( i64 ); stdout.newln();

end putiDemo;</pre></div></div><p>The example above simply tests the size of the operand to determine which output routine to use. You can use other HLA compile-time functions, such as <code class="literal">@typename</code>, to do more sophisticated processing. Consider the program in <a class="xref" href="ch09s08.html#procedure_overloading_based_on_operand_t" title="Example 9-6. Procedure overloading based on operand type">Example 9-6</a>, which demonstrates a macro that overloads <code class="literal">stdout.puti32</code>, <code class="literal">stdout.putu32</code>, and <code class="literal">stdout.putd</code> depending on the type of the operand.<a class="indexterm" id="IDX-CHP-9-0230"/><a class="indexterm" id="IDX-CHP-9-0231"/></p><div class="example"><a id="procedure_overloading_based_on_operand_t"/><p class="title">Example 9-6. Procedure overloading based on operand type</p><div class="example-contents"><pre class="programlisting">// put32.hla
//
// This program demonstrates procedure overloading via macros.
//
// It defines a put32 macro that calls stdout.puti32, stdout.putu32,
// or stdout.putdw depending on the type of the operand.


program put32Demo;
#include( "stdlib.hhf" )


// put32-
//
// Automatically decides whether we have an int32, uns32, or dword
// operand and calls the appropriate stdout.putX routine to
// output this value.

#macro put32( operand );

// If we have an int32 operand, call puti32:

     #if( @typename( operand ) = "int32" )

          stdout.puti32( operand );


     // If we have an uns32 operand, call putu32:

     #elseif( @typename( operand ) = "uns32" )

          stdout.putu32( operand );


     // If we have a dword operand, call puth32:

     #elseif( @typename( operand ) = "dword" )

          stdout.puth32( operand );

     // If it's not a 32-bit integer value, report an error:

     #else

          #error( "Expected an int32, uns32, or dword operand" )

     #endif

#endmacro;


// Some sample variable declarations so we can test the macro above:

static
     i32: int32   := −32;
     u32: uns32   := 32;
     d32: dword   := $32;

begin put32Demo;


     // Demo the put32 macro:

     put32( d32 );  stdout.newln();
     put32( u32 );  stdout.newln();
     put32( i32 );  stdout.newln();

end put32Demo;</pre></div></div><p>You can easily extend this macro to output 8- and 16-bit operands as well as 32-bit operands. That is left as an exercise for the reader.</p><p>The number of actual parameters is another way to resolve which overloaded procedure to call. If you specify a variable number of macro parameters (using the <code class="literal">[ ]</code> syntax; see the discussion in <a class="xref" href="ch09s08.html#macros_with_a_variable_number_of_paramet" title="9.8.2.2 Macros with a Variable Number of Parameters">9.8.2.2 Macros with a Variable Number of Parameters</a>), you can use the <code class="literal">@elements</code> compile-time function to determine exactly how many parameters are present and call the appropriate routine. The sample in <a class="xref" href="ch09s08.html#using_the_number_of_parameters_to_resolv" title="Example 9-7. Using the number of parameters to resolve overloaded procedures">Example 9-7</a> uses this trick to determine whether it should call <code class="literal">stdout.puti32</code> or <code class="literal">stdout.puti32Size</code>.<a class="indexterm" id="IDX-CHP-9-0232"/><a class="indexterm" id="IDX-CHP-9-0233"/></p><div class="example"><a id="using_the_number_of_parameters_to_resolv"/><p class="title">Example 9-7. Using the number of parameters to resolve overloaded procedures</p><div class="example-contents"><pre class="programlisting">// puti32.hla
//
// This program demonstrates procedure overloading via macros.
//
// It defines a puti32 macro that calls
// stdout.puti32 or stdout.puti32size
// depending on the number of parameters present.


program puti32Demo;
#include( "stdlib.hhf" )


// puti32-
//
// Automatically decides whether we have an int32, uns32, or dword
// operand and calls the appropriate stdout.putX routine to
// output this value.

#macro puti32( operand[] );

     // If we have a single operand, call stdout.puti32:

     #if( @elements( operand ) = 1 )

          stdout.puti32( @text(operand[0]) );


     // If we have two operands, call stdout.puti32size and
     // supply a default value of ' ' for the padding character:

     #elseif( @elements( operand ) = 2 )

          stdout.puti32Size
          (
              @text(operand[0]),
              @text(operand[1]),
              ' '
           );


     // If we have three parameters, then pass all three of them
     // along to puti32size:

     #elseif( @elements( operand ) = 3 )

          stdout.puti32Size
           (
               @text(operand[0]),
               @text(operand[1]),
               @text(operand[2])
          );


     // If we don't have one, two, or three operands, report an error:

     #else

          #error( "Expected one, two, or three operands" )

     #endif

#endmacro;


// A sample variable declaration so we can test the macro above:

Static
     i32: int32 := −32;

begin puti32Demo;


          // Demo the put32 macro:

     puti32( i32 );  stdout.newln();
     puti32( i32, 5 );  stdout.newln();
     puti32( i32, 5, '*' );  stdout.newln();

end puti32Demo;</pre></div></div><p>All the examples up to this point provide procedure overloading for Standard Library routines (specifically, the integer output routines). Of course, you are not limited to overloading procedures in the HLA Standard Library. You can create your own overloaded procedures as well. All you have to do is write a set of procedures, all with unique names, and then use a single macro to decide which routine to actually call based on the macro's parameters. Rather than call the individual routines, invoke the common macro and let it decide which procedure to actually call.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-5" id="ftn.CHP-9-FN-5">122</a>] </sup>To differentiate between macros and procedures, this text will use the term <span class="emphasis"><em>invocation</em></span> when describing the use of a macro and <span class="emphasis"><em>call</em></span> when describing the use of a procedure.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-6" id="ftn.CHP-9-FN-6">123</a>] </sup>Sometimes you actually want the symbols to be global.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-7" id="ftn.CHP-9-FN-7">124</a>] </sup>By the way, the HLA Standard Library does this as well. Although it doesn't provide <code class="literal">stdout.puti</code>, it does provide <code class="literal">stdout.put</code>, which will choose an appropriate output routine based upon the parameter's type. This is a bit more flexible than a <code class="literal">puti</code> routine.</p></div></div></div>
<div class="sect1" title="9.9 Writing Compile-Time &quot;Programs&quot;"><div class="titlepage"><div><div><h1 class="title"><a id="writing_compile-time_quotation_mark_prog"/>9.9 Writing Compile-Time "Programs"</h1></div></div></div><p>The HLA compile-time language provides a powerful facility with which to write "programs" that execute while HLA is compiling your assembly language programs. Although it is possible to write some general-purpose programs using the HLA compile-time language, the real purpose of the HLA compile-time language is to allow you to write short programs <span class="emphasis"><em>that write other programs</em></span>. In particular, the primary purpose of the HLA compile-time language is to automate the creation of large or complex assembly language sequences. The following subsections provide some simple examples of such compile-time programs.<a class="indexterm" id="IDX-CHP-9-0234"/><a class="indexterm" id="IDX-CHP-9-0235"/><a class="indexterm" id="IDX-CHP-9-0236"/><a class="indexterm" id="IDX-CHP-9-0237"/><a class="indexterm" id="IDX-CHP-9-0238"/><a class="indexterm" id="IDX-CHP-9-0239"/></p><div class="sect2" title="9.9.1 Constructing Data Tables at Compile Time"><div class="titlepage"><div><div><h2 class="title"><a id="constructing_data_tables_at_compile_time"/>9.9.1 Constructing Data Tables at Compile Time</h2></div></div></div><p>Earlier, this book suggested that you could write programs to generate large, complex lookup tables for your assembly language programs (see the discussion of tables in <a class="xref" href="ch08s04.html#generating_tables" title="8.4.3 Generating Tables">8.4.3 Generating Tables</a>). <a class="xref" href="ch08.html" title="Chapter 8. ADVANCED ARITHMETIC">Chapter 8</a> provides examples in HLA but suggests that writing a separate program is unnecessary. This is true; you can generate most lookup tables you'll need using nothing more than the HLA compile-time language facilities. Indeed, filling in table entries is one of the principle uses of the HLA compile-time language. In this section we will take a look at using the HLA compile-time language to construct data tables during compilation.</p><p>In <a class="xref" href="ch08s04.html#generating_tables" title="8.4.3 Generating Tables">8.4.3 Generating Tables</a>, you saw an example of an HLA program that writes a text file containing a lookup table for the trigonometric sine function. The table contains 360 entries with the index into the table specifying an angle in degrees. Each <code class="literal">int32</code> entry in the table contains the value sin(<span class="emphasis"><em>angle</em></span> )*1,000 where <span class="emphasis"><em>angle</em></span> is equal to the index into the table. <a class="xref" href="ch08s04.html#generating_tables" title="8.4.3 Generating Tables">8.4.3 Generating Tables</a> suggests running this program and then including the text output from that program into the actual program that used the resulting table. You can avoid much of this work by using the compile-time language. The HLA program in <a class="xref" href="ch09s09.html#generating_a_sine_lookup_table_with_the" title="Example 9-8. Generating a sine lookup table with the compile-time language">Example 9-8</a> includes a short compile-time code fragment that constructs this table of sines directly.</p><div class="example"><a id="generating_a_sine_lookup_table_with_the"/><p class="title">Example 9-8. Generating a sine lookup table with the compile-time language</p><div class="example-contents"><pre class="programlisting">// demoSines.hla
//
// This program demonstrates how to create a lookup table
// of sine values using the HLA compile-time language.

program demoSines;
#include( "stdlib.hhf" )

const
     pi :real80 := 3.1415926535897;

readonly
     sines:  int32[ 360 ] :=
             [
               // The following compile-time program generates
               // 359 entries (out of 360). For each entry
               // it computes the sine of the index into the
               // table and multiplies this result by 1000
               // in order to get a reasonable integer value.

               ?angle := 0;
               #while( angle &lt; 359 )

                    // Note: HLA's @sin function expects angles
                    // in radians. radians = degrees*pi/180.
                    // The int32 function truncates its result,
                    // so this function adds 1/2 as a weak attempt
                    // to round the value up.

                    int32( @sin( angle * pi / 180.0 ) * 1000 + 0.5 ),
                    ?angle := angle + 1;

               #endwhile

               // Here's the 360th entry in the table. This code
               // handles the last entry specially because a comma
               // does not follow this entry in the table.

               int32( @sin( 359 * pi / 180.0 ) * 1000 + 0.5 )
          ];
begin demoSines;

     // Simple demo program that displays all the values in the table:

     for( mov( 0, ebx); ebx&lt;360; inc( ebx )) do

          mov( sines[ ebx*4 ], eax );
          stdout.put
           (
               "sin( ",
               (type uns32 ebx ),
               " )*1000 = ",
               (type int32 eax ),
               nl
           );

     endfor;


end demoSines;</pre></div></div><p>Another common use for the compile-time language is to build ASCII character lookup tables for use by the <code class="literal">xlat</code> instruction at runtime. Common examples include lookup tables for alphabetic case manipulation. The program in <a class="xref" href="ch09s09.html#generating_case-conversion_tables_with_t" title="Example 9-9. Generating case-conversion tables with the compile-time language">Example 9-9</a> demonstrates how to construct an uppercase conversion table and a lowercase conversion table.<sup>[<a class="footnote" href="#ftn.CHP-9-FN-8" id="CHP-9-FN-8">125</a>]</sup> Note the use of a macro as a compile-time procedure to reduce the complexity of the table-generating code:</p><div class="example"><a id="generating_case-conversion_tables_with_t"/><p class="title">Example 9-9. Generating case-conversion tables with the compile-time language</p><div class="example-contents"><pre class="programlisting">// demoCase.hla
//
// This program demonstrates how to create a lookup table
// of alphabetic case conversion values using the HLA
// compile-time language.

program demoCase;
#include( "stdlib.hhf" )

const

     // emitCharRange
     //
     // This macro emits a set of character entries
     // for an array of characters. It emits a list
     // of values (with a comma suffix on each value)
     // from the starting value up to, but not including,
     // the ending value.

     #macro emitCharRange( start, last ): index;

          ?index:uns8 := start;
          #while( index &lt; last )

               char( index ),
               ?index := index + 1;

          #endwhile

     #endmacro;

     readonly

    // toUC:
    // The entries in this table contain the value of the index
    // into the table except for indices #$61..#$7A (those entries
    // whose indices are the ASCII codes for the lowercase
    // characters). Those particular table entries contain the
    // codes for the corresponding uppercase alphabetic characters.
    // If you use an ASCII character as an index into this table and
    // fetch the specified byte at that location, you will effectively
    // translate lowercase characters to uppercase characters and
    // leave all other characters unaffected.

    toUC: char[ 256 ] :=
          [
              // The following compile-time program generates
              // 255 entries (out of 256). For each entry
              // it computes toupper( <em class="replaceable"><code>index</code></em> ) where <em class="replaceable"><code>index</code></em> is
              // the character whose ASCII code is an index
              // into the table.

              emitCharRange( 0, uns8('a') )

              // Okay, we've generated all the entries up to
              // the start of the lowercase characters. Output
              // uppercase characters in place of the lowercase
              // characters here.

              emitCharRange( uns8('A'), uns8('Z') + 1 )

              // Okay, emit the nonalphabetic characters
              // through to byte code #$FE:

              emitCharRange( uns8('z') + 1, $FF )

              // Here's the last entry in the table. This code
              // handles the last entry specially because a comma
              // does not follow this entry in the table.

              #$FF

         ];


     // The following table is very similar to the one above.
     // You would use this one, however, to translate uppercase
     // characters to lowercase while leaving everything else alone.
     // See the comments in the previous table for more details.

     TOlc: char[ 256 ] :=
           [

               emitCharRange( 0, uns8('A') )
               emitCharRange( uns8('a'), uns8('z') + 1 )
               emitCharRange( uns8('Z') + 1, $FF )

               #$FF
          ];


begin demoCase;
     for( mov( uns32( ' ' ), eax ); eax &lt;= $FF; inc( eax )) do

          mov( toUC[ eax ], bl );
          mov( TOlc[ eax ], bh );
          stdout.put
          (
               "toupper( '",
                (type char al),
                "' ) = '",
                (type char bl),
                "'  tolower( '",
                (type char al),
                "' ) = '",
                (type char bh),
                "'",
                nl
          );

     endfor;

end demoCase;</pre></div></div><p>One important thing to note about this example is the fact that a semicolon does not follow the <code class="literal">emitCharRange</code> macro invocations. Macro invocations do not require a closing semicolon. Often, it is legal to go ahead and add one to the end of the macro invocation because HLA is normally very forgiving about having extra semicolons inserted into the code. In this case, however, the extra semicolons are illegal because they would appear between adjacent entries in the <code class="literal">TOlc</code> and <code class="literal">toUC</code> tables. Keep in mind that macro invocations don't require a semicolon, especially when using macro invocations as compile-time procedures.<a class="indexterm" id="IDX-CHP-9-0240"/><a class="indexterm" id="IDX-CHP-9-0241"/><a class="indexterm" id="IDX-CHP-9-0242"/><a class="indexterm" id="IDX-CHP-9-0243"/><a class="indexterm" id="IDX-CHP-9-0244"/></p></div><div class="sect2" title="9.9.2 Unrolling Loops"><div class="titlepage"><div><div><h2 class="title"><a id="unrolling_loops"/>9.9.2 Unrolling Loops</h2></div></div></div><p>In the chapter on low-level control structures, this text points out that you can unravel loops to improve the performance of certain assembly language programs. One problem with unraveling, or unrolling, loops is that you may need to do a lot of extra typing, especially if there are many loop iterations. Fortunately, HLA's compile-time language facilities, especially the <code class="literal">#while</code> and <code class="literal">#for</code> loops, come to the rescue. With a small amount of extra typing plus one copy of the loop body, you can unroll a loop as many times as you please.</p><p>If you simply want to repeat the same exact code sequence some number of times, unrolling the code is especially trivial. All you have to do is wrap an HLA <code class="literal">#for..#endfor</code> loop around the sequence and count off a <code class="literal">val</code> object the specified number of times. For example, if you wanted to print <code class="literal">Hello World</code> 10 times, you could encode this as follows.</p><a id="I_programlisting9_d1e49469"/><pre class="programlisting">#for( count := 1 to 10 )
     stdout.put( "Hello World", nl );
#endfor</pre><p>Although the code above looks very similar to an HLA <code class="literal">for</code> loop you could write in your program, remember the fundamental difference: The preceding code simply consists of 10 straight <code class="literal">stdout.put</code> calls in the program. Were you to encode this using an HLA <code class="literal">for</code> loop, there would be only one call to <code class="literal">stdout.put</code> and lots of additional logic to loop back and execute that single call 10 times.</p><p>Unrolling loops becomes slightly more complicated if any instructions in that loop refer to the value of a loop control variable or another value, which changes with each iteration of the loop. A typical example is a loop that zeros the elements of an integer array:</p><a id="I_programlisting9_d1e49487"/><pre class="programlisting">mov( 0, eax );
for( mov( 0, ebx ); ebx &lt; 20; inc( ebx )) do

   mov( eax, array[ ebx*4 ] );

endfor;</pre><p>In this code fragment the loop uses the value of the loop control variable (in EBX) to index into array. Simply copying <code class="literal">mov( eax, array[ ebx*4 ]);</code> 20 times is not the proper way to unroll this loop. You must substitute an appropriate constant index in the range 0..76 (the corresponding loop indices, times 4) in place of <code class="literal">ebx*4</code> in this example. Correctly unrolling this loop should produce the following code sequence:</p><a id="I_programlisting9_d1e49497"/><pre class="programlisting">mov( eax, array[ 0*4 ] );
          mov( eax, array[ 1*4 ] );
          mov( eax, array[ 2*4 ] );
          mov( eax, array[ 3*4 ] );
          mov( eax, array[ 4*4 ] );
          mov( eax, array[ 5*4 ] );
          mov( eax, array[ 6*4 ] );
          mov( eax, array[ 7*4 ] );
          mov( eax, array[ 8*4 ] );
          mov( eax, array[ 9*4 ] );
          mov( eax, array[ 10*4 ] );
          mov( eax, array[ 11*4 ] );
          mov( eax, array[ 12*4 ] );
          mov( eax, array[ 13*4 ] );
          mov( eax, array[ 14*4 ] );
          mov( eax, array[ 15*4 ] );
          mov( eax, array[ 16*4 ] );
          mov( eax, array[ 17*4 ] );
          mov( eax, array[ 18*4 ] );
          mov( eax, array[ 19*4 ] );</pre><p>You can easily do this using the following compile-time code sequence:<a class="indexterm" id="IDX-CHP-9-0245"/></p><a id="I_programlisting9_d1e49506"/><pre class="programlisting">#for( iteration := 0 to 19 )
     mov( eax, array[ iteration*4 ] );
#endfor</pre><p>If the statements in a loop make use of the loop control variable's value, it is only possible to unroll such loops if those values are known at compile-time. You cannot unroll loops when user input (or other runtime information) controls the number of iterations.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-8" id="ftn.CHP-9-FN-8">125</a>] </sup>Note that on modern processors, using a lookup table is probably not the most efficient way to convert between alphabetic cases. However, this is just an example of filling in the table using the compile-time language. The principles are correct, even if the code is not exactly the best it could be.</p></div></div></div>
<div class="sect1" title="9.10 Using Macros in Different Source Files"><div class="titlepage"><div><div><h1 class="title"><a id="using_macros_in_different_source_files"/>9.10 Using Macros in Different Source Files</h1></div></div></div><p>Unlike procedures, macros do not have a fixed piece of code at some address in memory. Therefore, you cannot create external macros and link them with other modules in your program. However, it is very easy to share macros with different source files: Just put the macros you wish to reuse in a header file and include that file using the <code class="literal">#include</code> directive. You can make the macro available to any source file you choose using this simple trick.<a class="indexterm" id="IDX-CHP-9-0246"/></p></div>
<div class="sect1" title="9.11 For More Information"><div class="titlepage"><div><div><h1 class="title"><a id="for_more_information-id8"/>9.11 For More Information</h1></div></div></div><p>Although this chapter has spent a considerable amount of time describing various features of HLA's macro support and compile-time language features, the truth is this chapter has barely described what's possible with HLA. Indeed, this chapter made the claim that HLA's macro facilities are far more powerful than those provided by other assemblers; however, this chapter doesn't do HLA's macros justice. If you've ever used a language with decent macro facilities, you're probably wondering, "What's the big deal?" Well, the really sophisticated stuff is beyond the scope of this chapter. If you're interested in learning more about HLA's powerful macro facilities, please consult the HLA reference manual and the electronic editions of <span class="emphasis"><em>The Art of Assembly Language</em></span> at <a class="ulink" href="http://webster.cs.ucr.edu/">http://webster.cs.ucr.edu/</a> or <a class="ulink" href="http://www.artofasm.com/">http://www.artofasm.com/</a>. You'll discover that it's actually possible to create your own high-level languages using HLA's macro facilities. However, this chapter does not assume the reader has the prerequisite knowledge to do that type of programming (yet!), so this chapter defers that discussion to the material that you'll also find on the websites.</p></div></body></html>