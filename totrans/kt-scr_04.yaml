- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 3 VISUALIZING WITH JAVAFX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/icon.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Data visualization is the art of presenting complex data in a visually accessible
    format, allowing for quick and effective understanding. Through charts, graphs,
    maps, and other graphical representations, data visualization not only simplifies
    data interpretation but also uncovers patterns, trends, and insights that might
    otherwise be overlooked.
  prefs: []
  type: TYPE_NORMAL
- en: By transforming raw data into meaningful and actionable knowledge, visualization
    plays a pivotal role in decision-making across various domains, such as business
    analytics and scientific research. Another facet of data visualization involves
    the creation and presentation of intricate objects and patterns on a screen, often
    incorporating dynamic or moving elements within simulations or optimization processes.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll explore creating data visualization and other output
    with Kotlin code. We’ll focus on the JavaFX library, allowing us to build standard
    charts, free-form drawings, and even animations. The programming patterns we cover
    in this chapter will pay dividends in later chapters when we work on projects
    with more elaborate visual components.
  prefs: []
  type: TYPE_NORMAL
- en: Data Visualization Tools for Kotlin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Several data visualization tools, both commercial and free, are available to
    run with Kotlin on the JVM. These tools make it possible to create interactive
    plots and charts and, in some cases, free-form drawings and fully featured user
    interfaces (UIs). They offer a variety of features and customization options to
    suit your needs. Here’s an overview of some of the visualization tools available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lets-Plot**'
  prefs: []
  type: TYPE_NORMAL
- en: A multiplatform plotting library for Kotlin that can be used to create interactive
    plots and charts. It’s primarily used to access graphics features within a Jupyter
    Notebook, a web application that facilitates the creation and sharing of documents
    containing live code, narrative text, and visualizations. You can access Lets-Plot’s
    graphics library through application programming interface (API) calls with predefined
    syntax. Lets-Plot doesn’t have a free-form drawing or sketching tool comparable
    to Tkinter in Python or the Canvas class in JavaFX.
  prefs: []
  type: TYPE_NORMAL
- en: '**Plotly**'
  prefs: []
  type: TYPE_NORMAL
- en: Another tool for creating interactive plots and charts for Kotlin applications.
    Plotly works on various platforms, including the JVM, JavaScript, and Python.
    Plotly is user friendly, has a simple API, and offers many customization options.
    Like Lets-Plot, it lacks a free-form drawing tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**Jetpack Compose**'
  prefs: []
  type: TYPE_NORMAL
- en: A modern UI toolkit for building native Android, desktop, and web applications
    using a single codebase. While Jetpack Compose doesn’t have built-in support for
    charting, third-party libraries are available for creating interactive plots and
    charts. Jetpack Compose provides a canvas API that can be used to draw custom
    graphics and shapes.
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaFX**'
  prefs: []
  type: TYPE_NORMAL
- en: An open source framework that lets you use Java to create applications for desktop,
    mobile, and embedded systems. It results from a collaborative effort by many individuals
    and companies that aim to provide a modern, efficient, and fully featured toolkit
    for developing rich client applications. You can use JavaFX to create user interfaces
    and interactive visualizations, as well as various charts such as line charts,
    bar charts, pie charts, and scatterplots. JavaFX works well with Kotlin because
    of its compatibility with Java.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we’ll use JavaFX as the graphics library of choice. This is because
    it’s a mature and feature-rich library that’s well documented and can seamlessly
    integrate with both Java and Kotlin applications. Most important, it has built-in
    features for charting and free-form drawing, including pixel-level manipulation
    of the display screen. These features will be useful in some projects we’ll work
    on later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: An Overview of JavaFX
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JavaFX was first introduced by Sun Microsystems in 2007 as a modern replacement
    for the aging Java Swing framework. It marked a significant step forward in Java’s
    capabilities for creating GUIs and multimedia-rich applications. Initially, JavaFX
    was shipped as part of the Java Development Kit (JDK). However, Oracle, the company
    that acquired JavaFX from Sun Microsystems, announced in 2018 that JavaFX would
    be open sourced and moved to the OpenFX project. The same year, JavaFX 11 was
    released as a stand-alone framework, decoupled from the JDK.
  prefs: []
  type: TYPE_NORMAL
- en: JavaFX has evolved over the years, thanks to numerous updates and improvements
    from its developers. It continues to thrive as an open source project under the
    stewardship of the OpenJFX community and is included as a standard library in
    many Java distributions.
  prefs: []
  type: TYPE_NORMAL
- en: Key Functionalities
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'JavaFX is a comprehensive toolkit for building cross-platform applications.
    While this chapter focuses on its charting and drawing features, JavaFX offers
    many other features that you can use in your projects. Here’s a quick overview
    of its key functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: '**UI development**'
  prefs: []
  type: TYPE_NORMAL
- en: JavaFX enables the developer to simplify and enhance the development of visually
    rich and interactive user interfaces for desktop, web, and mobile applications.
    It provides a wide variety of UI controls, layouts, and styles, allowing the creation
    of visually appealing and highly customizable interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cross-platform compatibility**'
  prefs: []
  type: TYPE_NORMAL
- en: JavaFX is designed to create applications that can run on various platforms,
    including Windows, macOS, Linux, and mobile devices, without major modifications.
    This cross-platform compatibility reduces development effort and allows for broader
    application distribution.
  prefs: []
  type: TYPE_NORMAL
- en: '**Charts and data visualization**'
  prefs: []
  type: TYPE_NORMAL
- en: JavaFX includes built-in support for creating various charts and graphs, making
    it a preferred choice for data visualization applications.
  prefs: []
  type: TYPE_NORMAL
- en: '**3D graphics**'
  prefs: []
  type: TYPE_NORMAL
- en: JavaFX provides versatile 3D graphics capabilities for developing mathematical
    and scientific applications that require 3D visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Rich media support**'
  prefs: []
  type: TYPE_NORMAL
- en: JavaFX is known for its robust multimedia support, making it suitable for applications
    that require video, audio, animations, and 2D or 3D graphics.
  prefs: []
  type: TYPE_NORMAL
- en: '**High performance**'
  prefs: []
  type: TYPE_NORMAL
- en: JavaFX provides hardware acceleration and optimizations for improved rendering
    performance, making it suitable for applications demanding smooth animations and
    responsive interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: '**Integration with Java and Kotlin**'
  prefs: []
  type: TYPE_NORMAL
- en: JavaFX seamlessly integrates with the Java programming language, leveraging
    the robustness, security, and ecosystem of Java. Since Kotlin is fully interoperable
    with Java, JavaFX is a natural choice for developing desktop and web-based applications
    in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about JavaFX features, see the project website at [https://openjfx.io](https://openjfx.io).
  prefs: []
  type: TYPE_NORMAL
- en: Setup
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you’ve followed the steps for installing IntelliJ IDEA and the Azul Zulu
    JDK as described in the appendix, you’re all set to start using JavaFX with Kotlin.
    You can access JavaFX features just as you’ve been accessing Kotlin features from
    the IDE. While the support for Kotlin is integrated within the IDE itself, the
    access to JavaFX is gained through the installed JDK.
  prefs: []
  type: TYPE_NORMAL
- en: If you haven’t followed the instructions in the appendix, I recommend using
    a JDK with JavaFX prepackaged so you can avoid the extra steps needed to link
    the library to your code. For example, Azul JDK FX and Liberica Full JDK are well-known
    distributions with integrated JavaFX support. Alternatively, you can download
    and install JavaFX separately from the OpenJFX website. There you’ll find detailed
    instructions on how to set up JavaFX for various operating systems, such as Windows,
    macOS, and Linux, including how to access JavaFX from your IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Once both Kotlin and JavaFX are accessible from the IDE, you can focus on creating
    new JavaFX applications in Kotlin. The process is similar to creating regular
    Kotlin programs, except that you need to add some boilerplate JavaFX code, which
    I’ll explain in detail next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 3: Build “Hello, World!” in JavaFX'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this project, I’ll walk you through the process of building a simple “Hello,
    world!” application using JavaFX and Kotlin. This will serve as the foundation
    for constructing other applications that leverage JavaFX’s charting and visualization
    features. First, follow these steps to create a new JavaFX-enabled application
    from scratch:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Open IntelliJ IDEA and create a new Kotlin project by navigating to **File****New****Project**.
    You’ll be taken to the project setup window shown in [Figure 3-1](chapter3.xhtml#fig3-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-1: Configuration options for JavaFX-based Kotlin projects'
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Name the project HelloWorld and note its location. Then select **Kotlin**
    as the language and **Maven** as the build system and choose a JDK that includes
    integrated support for JavaFX. (If you’ve followed the instructions in the appendix,
    that’ll be the latest long-term support version of Azul Zulu JDK FX.) For all
    JavaFX-based projects covered in this book, we’ll use these same settings (apart
    from the project name), as they eliminate the need for additional steps, such
    as manually linking a separate JavaFX library to the project.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You may notice that the left-hand panel of IntelliJ IDEA has an option to
    autogenerate a new JavaFX project, complete with a default “Hello!” window. This
    preconfigured setup comes with objects and files that may not be necessary for
    each project, so I recommend creating a project from scratch and including only
    the required code and objects, as outlined here.*'
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Click **Create** to create a new project with the correct configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  In the project panel on the left side of the IDE, expand the project tree
    by navigating to **HelloWorld****src****main****kotlin**.
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Right-click the kotlin folder and choose **New****Kotlin Class/File**.
    Then choose **File** and enter **HelloWorld** as the name of the Kotlin file.
    (For other projects, you can choose any other meaningful name.) Note that including
    the file extension, .kt, is optional. At this stage, the project screen should
    look like [Figure 3-2](chapter3.xhtml#fig3-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-2: Creating the Kotlin file for a JavaFX application'
  prefs: []
  type: TYPE_NORMAL
- en: 6.  Once you’ve typed in the Kotlin filename, press ENTER to create the file,
    which also takes you to the code editor window.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we’re ready to start coding our basic JavaFX application. For more
    complex projects, you may have to create additional classes or files. You can
    do so by using the same method outlined here.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The center of any JavaFX project is the Application class, an abstract class
    built into JavaFX that provides a framework for managing a graphical application.
    It features an abstract start() method that serves as the application’s entry
    point, much like the main() function is the point of entry for a console-based
    program. The project must feature a new class—what we’ll call HelloWorld, in this
    case—that extends the Application class and overrides the start() method. In the
    overridden method, you write the code for setting up and configuring the graphics
    window for data visualization and other aspects of your application. The project
    still needs a separate main() function as well, but the sole purpose of that function
    is to call the built-in launch() method of the Application class, which in turn
    launches the JavaFX application and calls the start() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that in mind, here’s the code to create a simple graphical application
    that displays a “Hello, world!” message to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We first import several JavaFX classes, including Application, Pos, Stage, Scene,
    VBox, Font, and Text. These are required to create and manage the graphical elements
    for the “Hello, world!” application. Any JavaFX application will begin with a
    long import block like this, though the specifics will vary depending on the application’s
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we declare the HelloWorld class to inherit from the Application class,
    which, as mentioned, is standard practice in JavaFX applications. Inside the class,
    we override the start() method ❶ to define the entry point for the application
    that will be executed when the program is launched. The start() method takes an
    argument called primaryStage, an object of the JavaFX Stage class, representing
    the application’s primary viewing window. Within the method, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use primaryStage.title to set the title of the application window to "Primary
    Stage".
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a Text object named text containing the message "Hello, world!" with
    a custom font of Verdana size 20.0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a VBox object named vbx and add the text object to it. In JavaFX, a VBox
    is a layout container that arranges its contents (in this case, text) in a vertical
    column. We set its alignment property to Pos.CENTER to ensure the text will be
    centered within the window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a Scene object named scene with the vbx attached to it and a size of
    300.0×300.0 pixels. (The dimensions have to be given in the floating-point format
    as they’re of type Double.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assign the Scene object to the primaryStage parameter’s scene property, which
    adds the scene to the viewing window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call the show() method of the primaryStage object to display the JavaFX application
    window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll discuss the significance of these JavaFX constructs in more detail shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The final segment of the program is the main() function, which consists of just
    a single line of code ❷. As mentioned earlier, its sole purpose is to call the
    launch() method of the Application class, which activates the start() method of
    the HelloWorld application. The parameter inside the launch() method, HelloWorld::class.java,
    specifies the Java class corresponding to the HelloWorld Kotlin class that serves
    as the entry point for the JavaFX application.
  prefs: []
  type: TYPE_NORMAL
- en: '#### The Result'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the application in IntelliJ IDEA. The output window shown in [Figure
    3-3](chapter3.xhtml#fig3-3) should pop up.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-3: The minimal “Hello, world!” application in Kotlin and JavaFX'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s highlight a few details in this output. First, the window has a title,
    “Primary Stage,” which is what the title property of primaryStage was set to.
    Second, the text “Hello, world!” is neatly centered inside the window. This was
    achieved by setting the alignment property of vbx to Pos.CENTER so that its contents
    would be aligned centrally within its boundaries. Third, the initial size of the
    window was set by specifying the width and height of the scene. However, you can
    change the window size by dragging any of its boundaries. Finally, the application
    continues to run in the background as long as the display window is open. Once
    you close the window, the application terminates normally.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code will be the foundational template for all our JavaFX-based applications,
    requiring only minor modifications. For example, you’ll be replacing the Text
    object with a LineChart or a Canvas object to adapt the code for creating a graph
    or a free-form drawing, respectively. JavaFX is a feature-rich framework, and
    I highly recommend exploring the resources listed at the end of this chapter to
    gain a thorough understanding of its core components and their relationships.
    For now, I’ll provide a brief overview of key features that we’ll be using in
    our upcoming JavaFX-based projects.  ### The JavaFX Object Hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: JavaFX uses a hierarchy of objects to represent the structure of a GUI and the
    elements that make up a visual display. At the top of this hierarchy is the Stage,
    which serves as the primary window for an application. The Stage is a container
    for one or more Scene objects, and each Scene is a container for various graphical
    elements, including other layout containers, controls, and shapes. All these components
    are considered *nodes* in the JavaFX object hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve already worked with several of these objects in our “Hello, world!” application.
    Let’s now take a closer look at what they are and how they relate to each other.
    Understanding and manipulating JavaFX’s object hierarchy is fundamental to creating
    visually appealing and interactive applications.
  prefs: []
  type: TYPE_NORMAL
- en: The Stage
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Stage is the top-level container in a JavaFX application. It represents
    the application window, complete with its title bar, borders, and any native OS-level
    components. The Stage serves as the primary object for creating a graphical window.
    You create a Stage and set its properties, such as the window title and dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In JavaFX applications, at least one Stage object is essential. This primary
    Stage is created when you override the start() method. However, in this example,
    we’re explicitly creating an additional Stage object, which will appear as a second
    graphical window within our application. We achieve this by invoking the Stage()
    constructor and assigning it to a new class member, myStage.
  prefs: []
  type: TYPE_NORMAL
- en: Scenes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A Scene represents a single, self-contained GUI component within the Stage.
    It acts as a container for all the visible elements in a specific part of an application,
    such as the main menu, a settings screen, or a game level. Typically, the root
    node of a Scene is set to a *layout container*, such as a Group, Pane, VBox, or
    HBox object, which in turn contains other nodes, such as buttons, labels, or shapes.
    Here’s an example of creating a Scene and setting its root node at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We pass root as the first arguments to the Scene constructor. This mirrors how
    we assigned a VBox as the root node of our “Hello, world!” application’s Scene
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Layout Containers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Layout containers like Group and VBox often serve as the root or parent node
    for a Scene. They’re used to position and size other *child nodes* displayed in
    the application window. In this way, layout containers are essential for designing
    the structure and layout of a user interface in JavaFX. In upcoming projects,
    we’ll use a few of these containers, so it’s worth taking a closer look at their
    properties to see which is most appropriate for different applications. Sometimes
    more than one type can be equally suitable.
  prefs: []
  type: TYPE_NORMAL
- en: Group
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A Group is a container that groups other nodes together without providing any
    layout capabilities. This can be useful when you want to apply a transformation
    or effect to a set of shapes collectively. For example, you can group multiple
    shapes together and apply a rotation or scaling effect to the entire group.
  prefs: []
  type: TYPE_NORMAL
- en: Pane
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A Pane is a layout container that serves as a building block for organizing
    and positioning nodes in a user interface. It’s not specialized for a particular
    layout, which makes it a versatile choice for various UI design scenarios. JavaFX
    provides several subclasses of Pane that you can choose from based on the requirements
    of your application. These subclasses include:'
  prefs: []
  type: TYPE_NORMAL
- en: FlowPane A container for arranging nodes in a fluid manner, automatically wrapping
    when the container’s boundaries are reached. By default, a FlowPane is horizontal,
    meaning it lays out nodes in rows, starting from the left boundary. When the right
    boundary is reached, nodes wrap (move) to the next row.
  prefs: []
  type: TYPE_NORMAL
- en: StackPane A container for stacking nodes on top of one another, such that one
    node blocks another. This enables creative layering of elements. All child nodes
    are automatically centered both horizontally and vertically within the available
    space.
  prefs: []
  type: TYPE_NORMAL
- en: BorderPane A container for positioning nodes in a structured manner in the top,
    bottom, left, right, and center positions.
  prefs: []
  type: TYPE_NORMAL
- en: AnchorPane Similar to BorderPane, except it allows nodes to attach to the top,
    bottom, left, and right edges of the pane.
  prefs: []
  type: TYPE_NORMAL
- en: GridPane A container for arranging nodes in a grid of rows and columns.
  prefs: []
  type: TYPE_NORMAL
- en: Panes are essential components of JavaFX applications, as they provide the layout
    and structure for the user interface. By using panes, you can create flexible
    and responsive UIs that can adapt to different screen sizes and resolutions.
  prefs: []
  type: TYPE_NORMAL
- en: '##### VBox and HBox'
  prefs: []
  type: TYPE_NORMAL
- en: VBox and HBox are layout containers designed to organize their child nodes neatly.
    VBox arranges its children in a vertical column, while HBox places them in a horizontal
    line.
  prefs: []
  type: TYPE_NORMAL
- en: Child Nodes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Child nodes are the fundamental building blocks of a JavaFX application. They
    represent specific visual elements, including shapes (for example, rectangles
    or circles), images, text, and interactive controls like buttons or text fields.
    The different types of chart objects that we’ll soon create are also considered
    nodes in JavaFX. By adding, removing, and modifying nodes within the application’s
    hierarchy of objects, you can design intuitive and engaging user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add child nodes to parent nodes such as a Group, Pane, VBox, or HBox
    to create complex hierarchies of UI components. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a blue Rectangle object that’s 100×100 pixels. We then assign the
    rectangle as a child node of a Group object called root. In this case, we assign
    the child node by passing it as an argument to the parent node’s constructor,
    but children don’t always have to be assigned immediately upon the creation of
    the parent. You can also assign a child node to a parent later by using the children.add()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create a Button object (button) and a Pane object (pane).
    Then we add the button as a child node of the pane by using the children.add()
    method. This method takes a single node as an argument and appends it to the list
    of children of the pane. We could also add or pass multiple children to the pane
    by using the children.addAll() method.
  prefs: []
  type: TYPE_NORMAL
- en: Creating JavaFX Charts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaFX provides a set of built-in features for creating visually appealing
    charts. You can feed a dataset into a chart for visualization and customize the
    result by changing the colors, fonts, and other properties. Here are the basic
    steps for creating a chart with JavaFX and Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.  Create objects to represent the x-axis and y-axis of the chart. These can
    be of two types: NumberAxis and CategoryAxis. Use the former for visualizing numerical
    data and the latter for string-type data.'
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Create an instance of a class representing the type of chart you want to
    design, such as LineChart, BarChart, ScatterChart, PieChart, or BubbleChart. You
    pass the objects created in step 1 as arguments to the chart’s constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Create one or more Series objects to represent the data series you want
    to display in the chart.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Add data points to each series by using the data.add() method for a single
    data point or the data.addAll() method for several data points at once.
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Add each series to the chart also by using the data.add() method.
  prefs: []
  type: TYPE_NORMAL
- en: 6.  Create a new Scene object and add the chart to it. Although you can directly
    assign a chart object as the root of a scene, you may want to first assign the
    chart as a child of a layout container and make that container the root of the
    scene. This way, you can have better control over the result.
  prefs: []
  type: TYPE_NORMAL
- en: 7.  Assign the Scene to the Stage object where the chart should be displayed.
    Don’t forget to display the Stage by using its show() method!
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps are generic and can be used to create any of the chart types available
    in JavaFX. We’ll now look at two representative examples of creating different
    chart objects that use actual data: a bar chart and a line chart.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 4: Visualize Data as a Bar Chart'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, we’ll generate a bar chart to visualize the monthly sales data
    for a fictitious company named ABC & Co. over the first quarter of a year. The
    chart will feature the months of January through March along the x-axis, with
    vertical bars illustrating the sales total for each month along the y-axis. The
    code will follow the same general outline we used for the simple “Hello, world!”
    application, with modifications to implement the charting steps we discussed.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here’s the code for creating a bar chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We begin by importing the necessary JavaFX classes. In addition to the general
    Application, Scene, and Stage classes common to any JavaFX application, we import
    some classes specific to charting, such as Side, CategoryAxis, BarChart, NumberAxis,
    and XYChart. After the import block, we declare the BarChartExample class, which
    once again extends JavaFX’s abstract Application class. Much like the “Hello,
    world!” application, we override the start() method with a custom definition.
    This time we use the method to create a bar chart.
  prefs: []
  type: TYPE_NORMAL
- en: The start() method is organized into several blocks. In the first block, we
    set the title of primaryStage (the Stage object passed into the start() method)
    to "Bar Chart Example" ❶. In the second block ❷, we create two objects representing
    the chart’s x- and y-axes. We use the CategoryAxis class for the x-axis, where
    the data points will be months of the year (strings), and the NumberAxis class
    for the y-axis, where the data points will be numeric sales totals. We also use
    the label property of each axis object to give the axis a descriptive label. In
    the third block ❸, we create the BarChart object, passing the xAxis and yAxis
    objects as arguments. We also assign the chart a title and position its legend
    at the top of the chart. The legend explains the significance of the colors or
    patterns used to visualize the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the fourth code block ❹, we create a series called dataSeries of type XYChart.Series.
    Each data point of this series will have a pair of elements of type <String, Number>,
    representing a month and its corresponding sales total in thousands of dollars.
    We set the name for the series; this name will appear in the chart’s legend. Then,
    to keep the start() method itself concise, we call a custom getData() function
    ❺ to add data points to the series before adding the series to the BarChart object
    to plot the data on the chart. Here’s a look at the getData() function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This function’s sole job is to add the data points to the dataSeries object
    in bulk by using the data.addAll() method. Each data point is an instance of the
    XYChart.Data class, which encapsulates the x- and y-axis values of a data point
    together in one container. In particular, each data point has a string month abbreviation
    for the x-value and an integer sales total for the y-value. We could also provide
    the sales totals as floating-point values; JavaFX recognizes both forms as numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining part of the application class is standard JavaFX template code,
    virtually identical to that of our “Hello, world!” application. We construct a
    Scene object, assigning barChart as its root node. Then we assign the Scene object
    to primaryStage and call the latter’s show() method, which displays the bar chart
    we’ve created on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The Result
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you run this code, the resulting bar chart should look like [Figure 3-4](chapter3.xhtml#fig3-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-4: A bar chart drawn using JavaFX'
  prefs: []
  type: TYPE_NORMAL
- en: Notice how JavaFX has automatically generated a bar with the correct height
    for each data point, with the months spaced evenly along the x-axis and ticks
    labeled in increments of 25 along the y-axis, stopping just past the maximum value
    displayed in the chart. You can also verify that the chart correctly displays
    the properties we set explicitly, such as the title (“Monthly Sales”), the x-
    and y-axes labels (“Months” and “Sales in thousands of dollars”), and the legend
    (“Q1 Data for ABC & Co.”), which is positioned correctly at the top.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 5: Create a Multiseries Line Chart'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this next project, we’ll create a line chart in JavaFX that displays the
    average heights of males and females at different ages. In a line chart, both
    axes are numeric, and their properties can be adjusted—for example, by setting
    the tick intervals and bounds. We’ll visualize age on the x-axis and height (in
    inches) on the y-axis. A key feature of the chart is that it will have two datasets,
    one for males and one for females, each in its own Series object. JavaFX will
    automatically plot the datasets separately, giving each a different colored line.  ####
    The Code'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our code will follow the same structure as the code for the bar chart, with
    modifications to instead make a line chart with two series. The program can be
    easily extended to chart three or more series. Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We begin with a typical JavaFX import block, this time importing the LineChart
    class instead of BarChart. Then we declare an application class called LineChartExample
    and override its start() method as usual. Inside the method, we first set the
    primaryStage title to "Average Heights at Different Ages", create the x- and y-axes,
    and set their labels. We use the NumberAxis class for both axes, since ages and
    heights are both numerical data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next code block ❶, we further customize the axes. For both axes, we
    turn off the autoranging capability by setting the isAutoRanging property to false
    (this is necessary for the subsequent changes to take effect). Then we set the
    lower and upper bounds for the axes: ages 0.0 to 35.0 on the x-axis and heights
    20.0 to 75.0 on the y-axis. We also set a tick interval of 5.0 on the x-axis.
    We let JavaFX work out all these settings automatically for the bar chart, but
    here we exert more control to remove the unnecessary autogenerated space and better
    position the two series in the chart window. In particular, JavaFX defaults to
    a lower bound of 0.0 for any numeric axis (when x- and y-values are positive),
    which in this case would create a lot of extra space near the bottom of the chart
    since the lowest height in the dataset is 36.0.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next few blocks are very similar to the bar chart example. We create a
    LineChart object ❷, set its title, and set the position of the legend. Then we
    create two XYChart.Series objects, maleData and femaleData, and call two helper
    functions, getMaleData() ❸ and getFemaleData() ❹, to populate the series with
    data. Here are the definitions of those functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Much like the bar chart project, we use the data.addAll() method to add all
    the data points to each series in one go. As before, the x- and y-values for each
    data point are packaged into an XYChart.Data object.
  prefs: []
  type: TYPE_NORMAL
- en: Returning to the main code, once both series (maleData and femaleData) are populated,
    we add them to the lineChart object by using the data.addAll() method ❺. Finally,
    we assign lineChart to scene and scene to primaryStage, and call the primaryStage
    object’s show() method to display the line chart, following our normal pattern
    of displaying a JavaFX visualization.
  prefs: []
  type: TYPE_NORMAL
- en: The Result
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 3-5](chapter3.xhtml#fig3-5) shows the line chart that results from
    running the code.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-5: A multiseries line chart drawn using JavaFX'
  prefs: []
  type: TYPE_NORMAL
- en: The line chart displays the average heights for males and females of different
    age groups as a set of two series plotted on the same x- and y-axes. JavaFX uses
    the chart’s legend to distinguish one plot from the other. You can verify that
    the chart has been configured based on the properties we’ve set manually; for
    example, the y-axis has a lower bound of 20, and the x-axis ticks are labeled
    in increments of 5.
  prefs: []
  type: TYPE_NORMAL
- en: You can do a lot more customization beyond the basic settings we’ve adjusted
    in this project. I’ll leave it to you to explore other options based on your additional
    reading and experimentation with JavaFX.
  prefs: []
  type: TYPE_NORMAL
- en: '### Drawing with the Canvas'
  prefs: []
  type: TYPE_NORMAL
- en: In JavaFX, a *canvas* is a region that provides a drawing surface for rendering
    custom 2D graphics. Whereas JavaFX’s charting features handle much of the drawing
    automatically, a canvas allows you to write low-level code for drawing individual
    lines, shapes, text fields, and more. You create a canvas by instantiating the
    Canvas class. Then you draw to the canvas object by accessing its *graphics context*.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll look at a simple first example of working with a JavaFX
    canvas and explore some commonly used drawing methods. Then we’ll get better acquainted
    with the canvas through a more elaborate drawing project.
  prefs: []
  type: TYPE_NORMAL
- en: A Simple Shape
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s get started with the JavaFX Canvas class by using it to draw a simple
    shape. Here’s the code for an application that draws a rectangle to the canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Inside the application class’s start() method, we create an instance of the
    Canvas class with a size of 400×200 pixels and call it canvas ❶. Then we call
    the canvas object’s getGraphicsContext2D() method. It returns a reference to the
    canvas’s GraphicsContext object, which we store in the gc variable ❷. This object
    provides the interface for drawing to the canvas. We then follow the usual steps
    of assigning the canvas to a layout container (a Pane object), the container to
    a scene, and the scene to the primary stage, which we display with the show()
    method. We need the Pane since Canvas isn’t a parent-type node and thus can’t
    be passed directly to a scene. Also, by making the Canvas object a child node
    to a container such as a Pane or VBox, we can further customize its placement
    and size if needed.
  prefs: []
  type: TYPE_NORMAL
- en: To draw the rectangle, we call a custom drawRectangle() method ❸ that takes
    one argument, the graphics context. In the method’s definition, we use Kotlin’s
    with scope function to group the actions requiring access to the graphics content,
    gc ❹. This saves us from adding gc. to the start of each line of code, which is
    a big help in longer drawing methods. We set the stroke color of the graphics
    context to red (in computer graphics, a *stroke* is the outline of a geometric
    shape), then call JavaFX’s strokeRect() method to draw a rectangle. The first
    two arguments (100.0 and 50.0) set the x- and y-coordinates of the rectangle’s
    top-left corner, and the remaining arguments (200.0 and 100.0) define its width
    and height (in pixels). By default, the origin of the coordinate system (0.0,
    0.0) is positioned at the top-left corner of the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-6](chapter3.xhtml#fig3-6) shows the result of running this simple
    canvas application.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-6: A red-outlined rectangle (shown here in gray) on a canvas'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we’ve defined the drawRectangle() method within the CanvasExample_1
    class. Alternatively, we could have created it as an independent function, similar
    to the getData() functions in the bar chart and line chart examples. Both approaches
    are valid. When a function is generic and could be reused by other classes or
    modules, consider making it a stand-alone function. Otherwise, creating it as
    an internal method of a class enhances data encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: Common Graphics Context Methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The graphics context is an essential tool associated with any canvas that enables
    you to design 2D graphics in JavaFX. Before moving on to more advanced projects
    involving the canvas, let’s consider some of the key features and capabilities
    of the GraphicsContext class and how to apply them in Kotlin. The most commonly
    used features are listed in [Table 3-1](chapter3.xhtml#tab3-1) for ease of reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 3-1: Commonly Used Graphics Context Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| Feature | Description | Usage in Kotlin |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Drawing shapes | Draw various 2D shapes, such as lines, rectangles, circles,
    and polygons. | gc.strokeRect(x, y, width, height) gc.fillOval(x, y, radiusX,
    radiusY) gc.fillPolygon(x-array, y-array, n) |'
  prefs: []
  type: TYPE_TB
- en: '| Setting colors | Set stroke (outline) and fill colors for shapes. | gc.stroke
    = Color.RED gc.fill = Color.BLUE |'
  prefs: []
  type: TYPE_TB
- en: '| Line width | Set line width and line style. | gc.lineWidth = 2.0 gc.setLineDashes(dash,
    gap) |'
  prefs: []
  type: TYPE_TB
- en: '| Text rendering | Draw text on the canvas with specified fonts and sizes.
    | gc.font = Font("Arial", 14.0) gc.fillText("Hello, world!", x, y) |'
  prefs: []
  type: TYPE_TB
- en: '| Image rendering | Draw images on the canvas. | val image = Image("image.png")
    gc.drawImage(image, x, y) |'
  prefs: []
  type: TYPE_TB
- en: '| Transformations | Translate (move the origin of the coordinate system by
    the specified x- and y-values) and rotate (rotate the subsequent drawings by a
    specified angle). | gc.translate(x, y) gc.rotate(angle) |'
  prefs: []
  type: TYPE_TB
- en: '| Clearing canvas | Clear the entire canvas or a specific region. | gc.clearRect(0.0,
    0.0, canvas.width, canvas.height) gc.clearRect(x, y, width, height) |'
  prefs: []
  type: TYPE_TB
- en: '[Table 3-1](chapter3.xhtml#tab3-1) shows the rich set of capabilities that
    the graphics context provides. For example, we can draw and fill geometric shapes
    such as rectangles and ovals with different colors. We can also adjust the width
    and style of a line. We have many options for rendering text as well. Besides
    shapes, we can use images of various formats (for example, JPG, PNG, or GIF) and
    creatively place them on the canvas. Moreover, we can move the origin of the coordinate
    system and rotate objects drawn on the canvas, altering their orientation relative
    to the current coordinate system. And finally, we can wipe the entire canvas clean,
    providing a fresh starting point for dynamic simulations.'
  prefs: []
  type: TYPE_NORMAL
- en: In the projects to follow in this chapter and elsewhere in the book, we’ll use
    many of these features and see how they work in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 6: Draw a Spiral Seashell'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, we’ll dive deeper into the drawing capabilities of the JavaFX
    canvas and its 2D graphics context. We’ll create a complex figure with many circles
    of increasing sizes, arranged in a spiral around the center of the canvas. By
    changing the key parameters, we can produce various visual effects. Here we’ll
    use the parameters to make a figure that resembles a seashell with a spiral growth
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The Strategy
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before diving into the code, let’s strategize the approach required to generate
    a spiral pattern. A spiral resembles a circle, with one important difference:
    its leading edge never returns to the origin point. Instead, it continuously moves
    farther away from the center while encircling the initial starting point. To achieve
    this mathematically, we’ll employ a method involving a sequence of lines, as illustrated
    in [Figure 3-7](chapter3.xhtml#fig3-7).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-7: The strategy for making a spiral pattern'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each line has one end anchored at a specific point F, which we’ll set to the
    center of the canvas. The position of the other end of the line, C, is determined
    by two key factors: the length *r* of the line and an angle of rotation *θ* relative
    to the positive x-axis (or another fixed reference). Given the values of *r* and
    *θ*, we can use some basic trigonometry to calculate the coordinates of point
    C. By gradually increasing both the angle of rotation and the length of the line
    by preset amounts, the successive values of C will form a spiral as the points
    simultaneously circle around the fixed point F and grow more distant from it.
    We’ll repeat this until the spiral has achieved the desired number of turns (one
    turn equals 360 degrees).'
  prefs: []
  type: TYPE_NORMAL
- en: To create the spiral pattern, we’ll treat each point C as the center of a circle
    with a radius of length *r*. These circles will grow larger and move farther away
    from the starting point as we repeat the process.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here’s the general structure of the code that will be used to draw the seashell
    spiral:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We begin by importing the required graphics-related classes, as well as the
    cos() and sin() trigonometric functions from Kotlin’s math library. Then we declare
    the MultiTurnSpiral application class. Much like the rectangle example, we first
    create and set the graphics elements, then call a custom method, in this case
    drawMultiTurnSpiral(), to coordinate the actual drawing. This approach keeps the
    overridden start() method concise. Notice that we’ve condensed the creation of
    the necessary JavaFX nodes by setting the scene property of the primaryStage object
    to Scene(Pane(canvas)) ❶. Nested assignments like this can help eliminate a few
    lines of code when the intermediate objects aren’t needed for other purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond the start() method, the application class contains three methods that
    collectively define and render the spiral pattern. Among them, drawMultiTurnSpiral()
    is the primary method, while the other two, printParams() and drawCircle(), are
    helpers. We’ll look at each of these methods in detail, starting with drawMultiTurnSpiral().
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The drawMultiTurnSpiral() method takes three parameters: gc, width, and height,
    which are the graphics context and the width and height of the canvas, respectively.
    We first set some key parameters for the spiral ❶. The numCircles variable sets
    the number of circles we’ll draw and turns dictates the number of rotations we’ll
    make around the center of the spiral. Multiplying turns by 360 gives us the maximum
    angle of rotation we’ll achieve, and dividing that value by numCircles gives us
    rotationStep, the amount we’ll rotate between drawing each circle. Similarly,
    we set maxRadius, the radius of the largest circle, to one-tenth the width or
    height of the canvas (whichever is lower), then divide this by numCircles and
    multiply the result by spacingFactor to get radiusStep, the amount by which the
    radius will grow from one circle to the next. Dividing the minimum of the width
    and height by 10 gives us some space to play with, and varying the spacingFactor
    allows us to better utilize that space by adjusting the distance between the circles.
    I’ve used a spacingFactor of 2 to create a visually pleasing pattern, but feel
    free to experiment with the values to understand how they affect the final figure.'
  prefs: []
  type: TYPE_NORMAL
- en: With these parameters set, we call the printParams() method ❷, which prints
    some key parameter values to the canvas. (We’ll look at this method shortly.)
    Then we use a for loop ❸ to iterate over the desired number of circles and draw
    them on the canvas. For each circle, we multiply looping variable i by rotationStep
    to calculate the current angle of rotation relative to the positive x-direction,
    and we multiply i by radiusStep to get the circle’s radius. We then calculate
    the coordinates of the circle’s center (x, y) by using trigonometric functions,
    taking the center of the canvas as the fixed point at the center of the spiral.
    (See [Figure 3-7](chapter3.xhtml#fig3-7) for how these calculations are derived.)
    Note that the cos() and sin() functions expect angles measured in radians rather
    than degrees, so we call toRadians() on the angle. Finally, we pass along the
    circle’s parameters to the custom drawCircle() method to actually draw the circle,
    including its center ❹.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s look at the definitions of the two helper methods, printParams()
    and drawCircle():'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The printParams() method takes in the graphics context and two key parameters
    of the spiral: the radius step and the number of circles. We create two string
    templates by using these parameters in the msg1 and msg2 variables. In msg1, we
    format radiusStep, a floating-point number, to four decimal places. In msg2, the
    number of circles, numCircles, is an integer, so no formatting is needed. We then
    pass the messages along to the gc.fillText() method, which displays the text at
    a specified location on the canvas (we’re using coordinates near the bottom-left
    corner). This method offers a valuable alternative to using the println() function,
    which is limited to displaying text in the console. With fillText(), we have the
    capability to print text directly on the canvas, enhancing the visual representation
    of the program’s output.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The drawCircle() method draws an individual circle in the spiral in two ways:
    as a light blue outline of the full circle and as a smaller red dot to mark the
    center of the circle. The method takes in the graphics context, the x- and y-coordinates
    of the circle’s center, and the circle’s radius. There’s a catch, however: the
    canvas’s methods for drawing a circle, fillOval() and strokeOval(), position the
    circle not from its center but from the top-left corner of a rectangle that surrounds
    the circle. We therefore subtract the radius from x and y to get the coordinates
    for the top-left corner ❶. We also set pointSize, which defines the diameter of
    the small, filled circle marking the circle’s center.'
  prefs: []
  type: TYPE_NORMAL
- en: For the rest of the method, we use the scoping function with to access the properties
    and methods of the graphics context more easily. We set the line width and stroke
    color for the outlined circle and the fill color for the central circle. Then
    we draw the small central circle by using fillOval() ❷ and the larger outlined
    circle by using strokeOval() ❸. The first two arguments are the coordinates of
    the bounding rectangle’s top-left corner, and the remaining two are the desired
    width and height (which for a circle are both twice the radius).
  prefs: []
  type: TYPE_NORMAL
- en: '#### The Result'
  prefs: []
  type: TYPE_NORMAL
- en: We’re now ready to run the code. It should produce the output shown in [Figure
    3-8](chapter3.xhtml#fig3-8).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-8: A two-turn spiral created with circles of increasing radii'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a few moments to appreciate the spiral’s visual intricacy. By plotting
    the centers of the circles with a contrasting color, we can clearly see how the
    successive circles get bigger and farther away from the center of the canvas (recall
    that the radius was a linear function of radiusStep). Ignoring the trajectory
    of the central dots for a moment, the circles create a visual illusion of a spiral
    seashell. This is no coincidence: some real-life seashells grow in spirals based
    on precise mathematical rules.'
  prefs: []
  type: TYPE_NORMAL
- en: Animation in JavaFX
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Animation is a powerful tool for creating engaging and interactive applications.
    JavaFX offers various animation options, from simple transitions to complex sequences.
    You can animate onscreen objects in JavaFX in two main ways: by using the TranslateTransition
    class or by using the Timeline and KeyFrame classes. In the following projects,
    we’ll explore both of these methods through hands-on examples.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 7: Animate a Square'
  prefs: []
  type: TYPE_NORMAL
- en: Transition-based animation treats animation as a gradual shift from one state
    to another. You define the start and end states of a visual object, and JavaFX
    works out a way to smoothly transition between the two. With transitions, you
    can make objects move, rotate, scale, fade, and so on, creating simple effects
    such as sliding, bouncing, flipping, and fading in or out. Transitions are easy
    to use and require minimal coding, but they’re more limited than the timeline
    and keyframe approach we’ll consider in the next project.
  prefs: []
  type: TYPE_NORMAL
- en: To use a transition, you need to create an instance of a transition class, such
    as TranslateTransition to move an object or RotateTransition to make it spin.
    You pass the node you want to animate as an argument to the transition’s constructor.
    Then you set transition properties such as the duration, cycle count, and autoreverse.
    Finally, you call the transition object’s play() method to start the animation.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here’s a simple example that uses transitions to move a square back and forth
    from one side of the screen to the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We begin with the import block, which is now organized into imports related
    to graphics and imports related to animation. The application class, TransitionExample,
    has the same familiar structure we’ve seen throughout the chapter. I’ll highlight
    only the problem-specific parts.
  prefs: []
  type: TYPE_NORMAL
- en: To animate a square, we first create one by using the Rectangle class ❶. We
    set the side lengths of the square to 50 pixels and its color to red. By default,
    the square would be positioned at the top-left corner of the window, but we update
    the square’s y property to put it 100 pixels lower. We create a Pane layout, place
    the square inside it, and set it as the root node for a 300×300-pixel scene ❷.
  prefs: []
  type: TYPE_NORMAL
- en: To set the transitions, we create an instance of the TranslateTransition class
    named transition ❸. In the constructor, we set the duration of the animation to
    two seconds and assign the square object as the node to be animated. We then use
    with (transition) to set the properties controlling the movements of the square.
    We specify the starting x-position for animation by using the fromX property (we’ll
    move the square only from side to side) and the end position by using the toX
    property. For the latter, we use pane .width - square.width to ensure the square
    won’t move outside the scene’s boundaries. The transition will interpolate the
    value of the x-position of the square from the fromX value to the toX value over
    the duration of the animation. Since we set cycleCount to Transition.INDEFINITE
    and isAutoReverse to true, the transition will reverse direction when it ends
    and start interpolating back to the fromX value—it will continue repeating as
    long as the window remains open. Finally, we set the transition in motion by using
    its play() method ❹.
  prefs: []
  type: TYPE_NORMAL
- en: The Result
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you run this code, you should see a red square initially positioned next
    to the left boundary of the scene. It should start moving toward the right boundary,
    then reverse its course once it hits the right boundary. This back-and-forth movement
    should continue until you close the window to terminate the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 8: Animate a Bouncing Ball'
  prefs: []
  type: TYPE_NORMAL
- en: The timeline and keyframe approach to animation offers exceptional versatility
    and is ideal for creating complex and precisely controlled animations. Each KeyFrame
    object defines a specific point in time where you set the values of certain properties,
    while the Timeline class manages the progression between keyframes. In JavaFX,
    you can find two approaches to this animation method. One is to define the properties
    of each KeyFrame object explicitly. The other is to set the properties of each
    KeyFrame programmatically by using an *action event handler*, a block of code
    similar to a lambda expression. This block of code is called periodically and
    contains rules for updating the scene. In this project, we’ll look at examples
    of both methods.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Keyframes Explicitly
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the first example, we’ll create an animated circle that grows and shrinks
    continuously. We’ll explicitly define the starting and ending KeyFrame objects,
    representing the circle at its smallest and largest sizes. Then we’ll use the
    Timeline class to interpolate back and forth between the keyframes. Here’s the
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a blue Circle object with an initial radius of 50.0 pixels ❶ and
    attach it to a StackPane ❷, which automatically centers the node it contains.
    We manage the animation through a Timeline and two KeyFrame objects: startFrame
    and endFrame. For startFrame, we set the initial state of the circle’s radius
    property to 50.0 pixels at the start time of the animation (0 seconds). Notice
    how we set the radius through an instance of the KeyValue class, which we pass
    to the KeyFrame constructor. Any property of an object that should be animated
    between keyframes must be defined through a separate KeyValue object. The second
    keyframe, endFrame, sets the circle’s radius property to 250.0 pixels at the end
    time (five seconds) of the animation. We use the keyFrames.addAll() method to
    attach the two keyframes to the Timeline object ❸.'
  prefs: []
  type: TYPE_NORMAL
- en: In the final code block, inside the with scoping function, we configure the
    animation to keep repeating by setting the Timeline object’s cycleCount property
    to Timeline.INDEFINITE, and we turn on autoreversing so that the circle will start
    shrinking once it’s grown to its maximum size. Then we initiate the animation
    by invoking the play() method ❹.
  prefs: []
  type: TYPE_NORMAL
- en: If you run this code, an application window should open up where you’ll see
    a blue circle repeatedly grow and shrink, with each cycle lasting five seconds.
    The animation should continue indefinitely until you close the application window.
  prefs: []
  type: TYPE_NORMAL
- en: Using an Action Event Listener
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll now explore a second example of creating animations with a timeline and
    keyframes. Unlike the previous example, where we specified distinct starting and
    ending keyframes for each animation cycle, we’ll rely on an action event listener
    block to execute the animation code. Specifically, we’ll create a red ball that
    continually traverses the scene, bouncing off the window boundaries. We’ll use
    the action event listener to set general rules for how the ball should move and
    when it should bounce. We’ll also encapsulate all the animation-related code within
    a dedicated method instead of putting it all in start(). This is a more structured
    and efficient coding method, which is particularly useful if we want to animate
    multiple balls by using the same method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the code for animating a bouncing red ball:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Inside the start() method of the BouncingBall application class, we first instantiate
    a red ball (redBall) with a radius of 30 pixels, positioning it at coordinates
    (250, 200) relative to the top-left corner (0, 0) of the scene ❶. To prevent the
    ball from constantly occupying the center of the scene, we assign it to a Pane
    instead of a StackPane. The rest of the code up to calling the show() method of
    primaryStage is practically the same as in the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: Once we’re done with setting the graphics part of the application, we call the
    custom bouncyBall() method, passing redBall and scene as its arguments ❷. This
    method encapsulates the process of setting up the Timeline and KeyFrame objects
    and maneuvering the ball inside the scene. Inside the method, we first define
    two displacement parameters, dx and dy, which set the horizontal and vertical
    distance (in pixels) that the red ball should travel in each animation frame.
    We initialize these values to 2, but if you modify them, the speed of the ball
    will change. For example, using 4 would double the ball’s speed, but this adjustment
    might introduce a perceptible jitter in the ball’s motion.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create tl, an instance of the Timeline class ❸, and define a single
    KeyFrame object named moveBall ❹. We set the duration of the KeyFrame to 0.015
    seconds (you can play with this value to get a sense of what happens when the
    duration is increased or decreased). The rest of the code block, surrounded by
    braces, is the action event handler block. This block, which we pass as the second
    argument to the KeyFrame constructor, is executed each time the KeyFrame is visited
    along the timeline.
  prefs: []
  type: TYPE_NORMAL
- en: The first few lines inside the action event handler block get the ball’s minimum
    and maximum coordinates in the x- and y-directions based on its current position.
    This is done by checking the corresponding coordinates of the parent container
    (a square, in this case) that holds the child (the circular ball). We then use
    these values to check if the ball has crossed the boundary of the scene during
    the last update of its position. For example, if xMin < 0 is true, the leftmost
    edge of the ball will be outside the left boundary of the scene. Similarly, if
    xMax > scene.width is true, the rightmost edge of the ball will be beyond the
    right boundary of the scene. For any such situations, we reverse the ball’s direction
    of movement along the appropriate axis by negating the corresponding displacement
    parameter (dx or dy), which creates a bouncing effect. The last step inside the
    action event block is to update the ball’s position by adding the displacement
    parameters to the coordinates of the ball, which are accessed by using the redBall
    object’s translateX and translateY properties.
  prefs: []
  type: TYPE_NORMAL
- en: We conclude the bouncyBall() method by using the with scoping function to assign
    the moveBall keyframe to the timeline ❺, set the timeline to cycle indefinitely,
    and call the play() method ❻ to start moving the ball on its bouncy path. Although
    we can’t show the dynamic motion of the ball on the static page of a book, [Figure
    3-9](chapter3.xhtml#fig3-9) gives you a sense of what to expect when you run this
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-9: Animating a bouncing red ball (shown here in gray)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run this code several times and carefully observe the motion of the
    ball, you’ll notice that it actually follows the exact same path every time. In
    other words, its path is predetermined. Can you explain why that’s the case? What
    could we do to make its path less predictable?  ### Summary'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we explored how to integrate JavaFX with Kotlin to create data
    visualizations. We covered fundamental JavaFX components such as Stage, Scene,
    and various layout containers and nodes. We also discussed using the Canvas class
    and its graphics context to create free-form drawings, and how to implement animations
    by using transitions or the Timeline and KeyFrame classes. We practiced these
    concepts through projects drawing various charts, generating a seashell-like spiral
    pattern, and even animating a bouncing ball. Throughout the book, we’ll continue
    to draw on the basic JavaFX tools covered here to add visual components to our
    various projects.
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Balasubramanian, Anirudh. “Crash Course into JavaFX: The Best Way to Make GUI
    Apps.” (Free tutorial.) Accessed June 15, 2024\. *[https://<wbr>www<wbr>.udemy<wbr>.com](https://www.udemy.com)*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dea, Carl, Gerrit Grunwald, José Pereda, Sean Phillips, and Mark Heckler. *JavaFX
    9 by Example*. 3rd ed. New York: Apress, 2017.'
  prefs: []
  type: TYPE_NORMAL
- en: JavaFX. The Official Website for the Open JavaFX Project. Accessed June 15,
    2024\. *[https://openjfx.io](https://openjfx.io)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lowe, Doug. *JavaFX for Dummies*. Hoboken, NJ: John Wiley & Sons, 2015.'
  prefs: []
  type: TYPE_NORMAL
