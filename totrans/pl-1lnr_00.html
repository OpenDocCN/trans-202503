<html><head></head><body><section class="chapter" title="Chapter&#xA0;1.&#xA0;Introduction to Perl One-Liners" epub:type="chapter" id="introduction_to_perl_one-liners"><div class="titlepage"><div><div><h2 class="title">Chapter 1. Introduction to Perl One-Liners</h2></div></div></div><p>Perl one-liners are small and awesome Perl programs that fit in a single line of code. They do one thing really well—like changing line spacing, numbering lines, performing calculations, converting and substituting text, deleting and printing specific lines, parsing logs, editing files in-place, calculating statistics, carrying out system administration tasks, or updating a bunch of files at once. Perl one-liners will make you a shell warrior: what took you minutes (or even hours) to solve will now take you only seconds!</p><p>In this introductory chapter, I’ll show you what one-liners look like and give you a taste of what’s in the rest of the book. This book requires some Perl knowledge, but most of the one-liners can be tweaked and modified without knowing the language in depth.</p><p><a id="idx00075" class="indexterm"/><a id="idx00123" class="indexterm"/><a id="idx00128" class="indexterm"/><a id="idx00131" class="indexterm"/><a id="idx00141" class="indexterm"/><a id="idx00187" class="indexterm"/><a id="idx00238" class="indexterm"/><a id="idx00245" class="indexterm"/><a id="idx00310" class="indexterm"/><a id="idx00313" class="indexterm"/><a id="idx00476" class="indexterm"/><a id="idx00488" class="indexterm"/><a id="idx00541" class="indexterm"/><a id="idx00588" class="indexterm"/><a id="idx00594" class="indexterm"/>Let’s look at some examples. Here’s one:</p><a id="I_programlisting1_id300510"/><pre class="programlisting">perl -pi -e 's/<span class="emphasis"><em>you</em></span>/<span class="emphasis"><em>me</em></span>/g' <span class="emphasis"><em>file</em></span></pre><p>This one-liner replaces all occurrences of the text <code class="literal">you</code> with <code class="literal">me</code> in the file <code class="literal">file</code>. Very useful if you ask me. Imagine you’re on a remote server and you need to replace text in a file. You can either open the file in a text editor and execute find-replace or simply perform the replacement through the command line and, bam, be done with it.</p><p>This one-liner and others in this book work well in UNIX. I’m using Perl 5.8 to run them, but they also work in newer Perl versions, such as Perl 5.10 and later. If you’re on a Windows computer, you’ll need to change them a little. To make this one-liner work on Windows, swap the single quotes for double quotes. To learn more about using Perl one-liners on Windows, see <a class="xref" href="apb.html" title="Appendix B. Using Perl One-Liners On Windows">Appendix B</a>.</p><p>I’ll be using Perl’s <code class="literal">-e</code> command-line argument throughout the book. It allows you to use the command line to specify the Perl code to be executed. In the previous one-liner, the code says “do the substitution (<code class="literal">s/you/me/g</code> command) and replace <code class="literal">you</code> with <code class="literal">me</code> globally (<code class="literal">/g</code> flag).” The <code class="literal">-p</code> argument ensures that the code is executed on every line of input and that the line is printed after execution. The <code class="literal">-i</code> argument ensures that <code class="literal">file</code> is edited in-place. Editing <span class="emphasis"><em>in-place</em></span> means that Perl performs all the substitutions right in the file, overwriting the content you want to replace. I recommend that you always make a backup of the file you’re working with by specifying the backup extension to the <code class="literal">-i</code> argument, like this:</p><a id="I_programlisting1_id300558"/><pre class="programlisting">perl -pi.bak -e 's/<span class="emphasis"><em>you</em></span>/<span class="emphasis"><em>me</em></span>/g' <span class="emphasis"><em>file</em></span></pre><p>Now Perl creates a <code class="literal">file.bak</code> backup file first and only then changes the contents of <code class="literal">file</code>.</p><p>How about doing this same replacement in multiple files? Just specify the files on the command line:</p><a id="I_programlisting1_id300628"/><pre class="programlisting">perl -pi -e 's/<span class="emphasis"><em>you</em></span>/<span class="emphasis"><em>me</em></span>/g' <span class="emphasis"><em>file1 file2 file3</em></span></pre><p>Here, Perl first replaces <code class="literal">you</code> with <code class="literal">me</code> in <code class="literal">file1</code> and then does the same in <code class="literal">file2</code> and <code class="literal">file3</code>.</p><p>You can also perform the same replacement only on lines that match <code class="literal">we</code>, as simply as this:</p><a id="I_programlisting1_id300671"/><pre class="programlisting">perl -pi -e 's/<span class="emphasis"><em>you</em></span>/<span class="emphasis"><em>me</em></span>/g if /<span class="emphasis"><em>we</em></span>/' <span class="emphasis"><em>file</em></span></pre><p>Here, you use the conditional <code class="literal">if /we/</code> to ensure that <code class="literal">s/you/me/g</code> is executed only on lines that match the regular expression <code class="literal">/we/</code>.</p><p><a id="idx00138" class="indexterm"/><a id="idx00145" class="indexterm"/><a id="idx00163" class="indexterm"/><a id="idx00412" class="indexterm"/>The regular expression can be anything. Say you want to execute the substitution only on lines with digits in them. You could use the <code class="literal">/\d/</code> regular expression to match numbers:</p><a id="I_programlisting1_id300740"/><pre class="programlisting">perl -pi -e 's/<span class="emphasis"><em>you</em></span>/<span class="emphasis"><em>me</em></span>/g if /\d/' <span class="emphasis"><em>file</em></span></pre><p>How about finding all lines in a file that appear more than once?</p><a id="I_programlisting1_id300756"/><pre class="programlisting">perl -ne 'print if $a{$_}++' <span class="emphasis"><em>file</em></span></pre><p>This one-liner records the lines you’ve seen so far in the <code class="literal">%a</code> hash and counts the number of times it sees the lines. If it has already seen the line, the condition <code class="literal">$a{$_}++</code> is true, so it prints the line. Otherwise it “automagically” creates an element that contains the current line in the <code class="literal">%a</code> hash and increments its value. The <code class="literal">$_</code> special variable contains the current line. This one-liner also uses the <code class="literal">-n</code> command-line argument to loop over the input, but unlike <code class="literal">-p</code>, it doesn’t print the lines automatically. (Don’t worry about all the command-line arguments right now; you’ll learn about them as you work through this book!)</p><p>How about numbering lines? Super simple! Perl’s <code class="literal">$.</code> special variable maintains the current line number. Just print it together with the line:</p><a id="I_programlisting1_id300802"/><pre class="programlisting">perl -ne 'print "$. $_"' <span class="emphasis"><em>file</em></span></pre><p>You can do the same thing by using the <code class="literal">-p</code> argument and modifying the <code class="literal">$_</code> variable:</p><a id="I_programlisting1_id300819"/><pre class="programlisting">perl -pe '$_ = "$. $_"' <span class="emphasis"><em>file</em></span></pre><p>Here, each line is replaced by the string <code class="literal">"$. $_"</code>, which is equal to the current line number followed by the line itself. (See one-liner 3.1 on page 17 for a full explanation.)</p><p>If you omit the filename at the end of the one-liner, Perl reads data from standard input. From now on, I’ll assume the data comes from the standard input and drop the filename at the end. You can always put it back if you want to run one-liners on whole files.</p><p>You can also combine the previous two one-liners to create one that numbers only the repeated lines:</p><a id="I_programlisting1_id300844"/><pre class="programlisting">perl -ne 'print "$. $_" if $a{$_}++'</pre><p>Another thing you can do is sum the numbers in each line using the <code class="literal">sum</code> function from the <code class="literal">List::Util</code> CPAN module. CPAN (Comprehensive Perl Archive Network; <span class="emphasis"><em><a class="ulink" href="http://www.cpan.org/" target="_top">http://www.cpan.org/</a></em></span>) is an archive of over 100,000 reusable Perl modules. <code class="literal">List::Util</code> is one of the modules on CPAN, and it contains various list utility functions. You don’t need to install this module because it comes with Perl. (It’s in Perl core.)</p><a id="I_programlisting1_id300871"/><pre class="programlisting">perl -MList::Util=sum -alne 'print sum @F'</pre><p><a id="idx00134" class="indexterm"/><a id="idx00166" class="indexterm"/><a id="idx00332" class="indexterm"/><a id="idx00596" class="indexterm"/>The <code class="literal">-MList::Util</code> command-line argument imports the <code class="literal">List::Util</code> module. The <code class="literal">=sum</code> part of this one-liner imports the <code class="literal">sum</code> function from the <code class="literal">List::Util</code> module so that the program can use the function. Next, <code class="literal">-a</code> enables the automatic splitting of the current line into fields in the <code class="literal">@F</code> array. The splitting happens on the whitespace character by default. The <code class="literal">-l</code> argument ensures that <code class="literal">print</code> outputs a newline at the end of each line. Finally, <code class="literal">sum @F</code> sums all the elements in the <code class="literal">@F</code> list, and <code class="literal">print</code> prints the result followed by a newline (which I added with the <code class="literal">-l</code> argument). (See one-liner 4.2 on page 30 for a more detailed explanation.)</p><p>How about finding the date 1299 days ago? Try this:</p><a id="I_programlisting1_id300962"/><pre class="programlisting">perl -MPOSIX -le
  '@t = localtime; $t[3] -= 1299; print scalar localtime mktime @t'</pre><p>I explain this example in detail in one-liner 4.19 (page 41), but basically you modify the fourth element of the structure returned by <code class="literal">localtime</code>, which happens to be days. You simply subtract 1299 days from the current day and then reassemble the result into a new time with <code class="literal">localtime mktime @t</code> and print the result in the scalar context to display human-readable time.</p><p>How about generating an eight-letter password? Here you go:</p><a id="I_programlisting1_id300983"/><pre class="programlisting">perl -le 'print map { ("a".."z")[rand 26] } 1..8'</pre><p>The <code class="literal">"a".."z"</code> generates a list of letters from <span class="emphasis"><em>a</em></span> to <span class="emphasis"><em>z</em></span> (for a total of 26 letters). Then you randomly choose a letter eight times! (This example is explained in detail in one-liner 5.4 on page 51.)</p><p>Or suppose you want to find the decimal number that corresponds to an IP address. You can use <code class="literal">unpack</code> to find it really quickly:</p><a id="I_programlisting1_id301013"/><pre class="programlisting">perl -le 'print unpack("N", 127.0.0.1)'</pre><p>This one-liner uses a <span class="emphasis"><em>v-string</em></span>, which is a version literal. V-strings offer a way to compose a string with the specified ordinals. The IP address <code class="literal">127.0.0.1</code> is treated as a v-string, meaning the numbers <code class="literal">127</code>, <code class="literal">0</code>, <code class="literal">0</code>, <code class="literal">1</code> are concatenated together into a string of four characters, where the first character has ordinal value 127, the second and third characters have ordinal values 0, and the last character has ordinal value 1. Next, <code class="literal">unpack</code> unpacks them to a single decimal number in “network” (big-endian) order. (See one-liner 4.27 on page 45 for more.)</p><p><a id="idx00057" class="indexterm"/><a id="idx00104" class="indexterm"/><a id="idx00115" class="indexterm"/><a id="idx00182" class="indexterm"/><a id="idx00216" class="indexterm"/><a id="idx00233" class="indexterm"/><a id="idx00329" class="indexterm"/><a id="idx00490" class="indexterm"/><a id="idx00590" class="indexterm"/><a id="idx00622" class="indexterm"/>What about calculations? Let’s find the sum of the numbers in the first column in a table:</p><a id="I_programlisting1_id301129"/><pre class="programlisting">perl -lane '$sum += $F[0]; END { print $sum }'</pre><p>The lines are automatically split into fields with the <code class="literal">-a</code> argument, which can be accessed through the <code class="literal">@F</code> array. The first element of the array, <code class="literal">$F[0]</code>, is the first column, so you simply sum all the columns with <code class="literal">$sum += $F[0]</code>. When the Perl program finishes, it executes any code in the <code class="literal">END</code> block, which, in this case, prints the total sum. Easy!</p><p>Now let’s find out how many packets have passed through <code class="literal">iptables</code> rules:</p><a id="I_programlisting1_id301165"/><pre class="programlisting">iptables -L -nvx | perl -lane '$pkts += $F[0]; END { print $pkts }'</pre><p>The <code class="literal">iptables</code> program outputs the packets in the first column. All you have to do to find out how many packets have passed through the firewall rules is sum the numbers in the first column. Although <code class="literal">iptables</code> will output table headers as well, you can safely ignore these because Perl converts them to zero for the <code class="literal">+=</code> operation.</p><p>How about getting a list of all users on the system?</p><a id="I_programlisting1_id301191"/><pre class="programlisting">perl -a -F: -lne 'print $F[4]' /etc/passwd</pre><p>Combining <code class="literal">-a</code> with the <code class="literal">-F</code> argument lets you specify the character where lines should be split, which, by default, is whitespace. Here, you split lines on the colon character, the record separator of <code class="literal">/etc/passwd</code>. Next, you print the fifth field, <code class="literal">$F[4]</code>, which contains the user’s real name.</p><p>If you ever get lost with command-line arguments, remember that Perl comes with a fantastic documentation system called <span class="emphasis"><em>perldoc</em></span>. Type <code class="literal">perldoc perlrun</code> at the command line. This will display the documentation about how to run Perl and all the command-line arguments. It’s very useful when you suddenly forget which command-line argument does what and need to look it up quickly. You may also want to read <span class="emphasis"><em>perldoc perlvar</em></span>, which explains variables; <span class="emphasis"><em>perldoc perlop</em></span>, which explains operators; and <span class="emphasis"><em>perldoc perlfunc</em></span>, which explains functions.</p><p>Perl one-liners let you accomplish many tasks quickly. You’ll find over 130 one-liners in this book. Read them, try them, and soon enough you’ll be the local shell wizard. (Just don’t tell your friends—unless you want competition.)</p><p>Enjoy!</p></section></body></html>