<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;ADVANCED ARITHMETIC"><div class="titlepage"><div><div><h1 class="title"><a id="advanced_arithmetic"/>Chapter 8. ADVANCED ARITHMETIC</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject8_d1e41622"/><img alt="ADVANCED ARITHMETIC" src="tagoreillycom20100401nostarchimages577853.png.jpg"/></div></div><p>This chapter deals with those arithmetic operations for which assembly language is especially well suited. It covers four main topics: extended-precision arithmetic, arithmetic on operands whose sizes are different, decimal arithmetic, and computation via table lookup.<a class="indexterm" id="IDX-CHP-8-0001"/><a class="indexterm" id="IDX-CHP-8-0002"/><a class="indexterm" id="IDX-CHP-8-0003"/></p><p>By far, the most extensive subject this chapter covers is multiprecision arithmetic. By the conclusion of this chapter you will know how to apply arithmetic and logical operations to integer operands of any size. If you need to work with integer values outside the range ±2 billion (or with unsigned values beyond 4 billion), no sweat; this chapter shows you how to get the job done.</p><p>Different-size operands also present some special problems. For example, you may want to add a 64-bit unsigned integer to a 128-bit signed integer value. This chapter discusses how to convert these two operands to a compatible format.</p><p>This chapter also discusses decimal arithmetic using the 80x86 BCD (binary-coded decimal) instructions and the FPU (floating-point unit). This lets you use decimal arithmetic in those few applications that absolutely require base-10 operations.<a class="indexterm" id="IDX-CHP-8-0004"/><a class="indexterm" id="IDX-CHP-8-0005"/></p><p>Finally, this chapter concludes by discussing how to speed up complex computations using table lookups.<a class="indexterm" id="IDX-CHP-8-0006"/><a class="indexterm" id="IDX-CHP-8-0007"/><a class="indexterm" id="IDX-CHP-8-0008"/><a class="indexterm" id="IDX-CHP-8-0009"/></p><div class="sect1" title="8.1 Multiprecision Operations"><div class="titlepage"><div><div><h1 class="title"><a id="multiprecision_operations"/>8.1 Multiprecision Operations</h1></div></div></div><p>One big advantage of assembly language over high-level languages is that assembly language does not limit the size of integer operations. For example, the standard C programming language defines three different integer sizes: <code class="literal">short int</code>, <code class="literal">int</code>, and <code class="literal">long int</code>.<sup>[<a class="footnote" href="#ftn.CHP-8-FN-1" id="CHP-8-FN-1">111</a>]</sup> On the PC, these are often 16- and 32-bit integers. Although the 80x86 machine instructions limit you to processing 8-, 16-, or 32-bit integers with a single instruction, you can always use multiple instructions to process integers of any size. If you want to add 256-bit integer values together, no problem; it's relatively easy to accomplish this in assembly language. The following sections describe how to extend various arithmetic and logical operations from 16 or 32 bits to as many bits as you please.<a class="indexterm" id="IDX-CHP-8-0010"/><a class="indexterm" id="IDX-CHP-8-0011"/><a class="indexterm" id="IDX-CHP-8-0012"/></p><div class="sect2" title="8.1.1 HLA Standard Library Support for Extended-Precision Operations"><div class="titlepage"><div><div><h2 class="title"><a id="hla_standard_library_support_for_extende"/>8.1.1 HLA Standard Library Support for Extended-Precision Operations</h2></div></div></div><p>Although it is important for you to understand how to do extended-precision arithmetic yourself, you should note that the HLA Standard Library provides a full set of 64-bit and 128-bit arithmetic and logical functions that you can use. These routines are general purpose and very convenient to use. This section briefly describes the HLA Standard Library support for extended-precision arithmetic.</p><p>As noted in earlier chapters, the HLA compiler supports several different 64-bit and 128-bit data types. These extended data types are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">uns64</code>: 64-bit unsigned integers</p></li><li class="listitem"><p><code class="literal">int64</code>: 64-bit signed integers</p></li><li class="listitem"><p><code class="literal">qword</code>: 64-bit untyped values</p></li><li class="listitem"><p><code class="literal">uns128</code>: 128-bit unsigned integers</p></li><li class="listitem"><p><code class="literal">int128</code>: 128-bit signed integers</p></li><li class="listitem"><p><code class="literal">lword</code>: 128-bit untyped values</p></li></ul></div><p>HLA also provides a <code class="literal">tbyte</code> type, but we will not consider that here (see <a class="xref" href="ch08s02.html" title="8.2 Operating on Different-Size Operands">8.2 Operating on Different-Size Operands</a>).</p><p>HLA fully supports 64-bit and 128-bit literal constants and constant arithmetic. This allows you to initialize 64- and 128-bit static objects using standard decimal, hexadecimal, or binary notation. For example:</p><a id="I_programlisting8_d1e41756"/><pre class="programlisting">static
    u128    :uns128 := 123456789012345678901233567890;
    i64     :int64  := −12345678901234567890;
    lw      :lword  := $1234_5678_90ab_cdef_0000_ffff;</pre><p>In order to easily manipulate 64-bit and 128-bit values, the HLA Standard Library's <code class="literal">math.hhf</code> module provides a set of functions that handle most of the standard arithmetic and logical operations. You use these functions in a manner similar to the 32-bit arithmetic and logical instructions. For example, consider the <code class="literal">math.addq</code> (<code class="literal">qword</code>) and <code class="literal">math.addl</code> (<code class="literal">lword</code>) functions:<a class="indexterm" id="IDX-CHP-8-0013"/><a class="indexterm" id="IDX-CHP-8-0014"/><a class="indexterm" id="IDX-CHP-8-0015"/><a class="indexterm" id="IDX-CHP-8-0016"/><a class="indexterm" id="IDX-CHP-8-0017"/><a class="indexterm" id="IDX-CHP-8-0018"/><a class="indexterm" id="IDX-CHP-8-0019"/><a class="indexterm" id="IDX-CHP-8-0020"/><a class="indexterm" id="IDX-CHP-8-0021"/><a class="indexterm" id="IDX-CHP-8-0022"/><a class="indexterm" id="IDX-CHP-8-0023"/><a class="indexterm" id="IDX-CHP-8-0024"/><a class="indexterm" id="IDX-CHP-8-0025"/><a class="indexterm" id="IDX-CHP-8-0026"/><a class="indexterm" id="IDX-CHP-8-0027"/><a class="indexterm" id="IDX-CHP-8-0028"/><a class="indexterm" id="IDX-CHP-8-0029"/><a class="indexterm" id="IDX-CHP-8-0030"/><a class="indexterm" id="IDX-CHP-8-0031"/></p><a id="I_programlisting8_d1e41872"/><pre class="programlisting">math.addq( <em class="replaceable"><code>left64</code></em>, <em class="replaceable"><code>right64</code></em>, <em class="replaceable"><code>dest64</code></em> );
    math.addl( <em class="replaceable"><code>left128</code></em>, <em class="replaceable"><code>right128</code></em>, <em class="replaceable"><code>dest128</code></em> );</pre><p>These functions compute the following:</p><a id="I_programlisting8_d1e41895"/><pre class="programlisting"><em class="replaceable"><code>dest64</code></em> := <em class="replaceable"><code>left64</code></em> + <em class="replaceable"><code>right64</code></em>;    // <em class="replaceable"><code>dest64</code></em>, <em class="replaceable"><code>left64</code></em>, and <em class="replaceable"><code>right64</code></em>
                               // must be 8-byte operands
<em class="replaceable"><code>dest128</code></em> := <em class="replaceable"><code>left128</code></em> + <em class="replaceable"><code>right128</code></em>; // <em class="replaceable"><code>dest128</code></em>, <em class="replaceable"><code>left128</code></em>, and <em class="replaceable"><code>right128</code></em>
                               // must be 16-byte operands</pre><p>These functions set the 80x86 flags the same way you'd expect after the execution of an <code class="literal">add</code> instruction. Specifically, these functions set the zero flag if the (full) result is 0, they set the carry flag if there is a carry from the H.O. bit, they set the overflow flag if there is a signed overflow, and they set the sign flag if the H.O. bit of the result contains 1.</p><p>Most of the remaining arithmetic and logical routines use the same calling sequence as <code class="literal">math.addq</code> and <code class="literal">math.addl</code>. Briefly, here are those functions:</p><a id="I_programlisting8_d1e41947"/><pre class="programlisting">math.andq( <em class="replaceable"><code>left64</code></em>, <em class="replaceable"><code>right64</code></em>, <em class="replaceable"><code>dest64</code></em> );
    math.andl( <em class="replaceable"><code>left128</code></em>, <em class="replaceable"><code>right128</code></em>, <em class="replaceable"><code>dest128</code></em> );
    math.divq( <em class="replaceable"><code>left64</code></em>, <em class="replaceable"><code>right64</code></em>, <em class="replaceable"><code>dest64</code></em> );
    math.divl( <em class="replaceable"><code>left128</code></em>, <em class="replaceable"><code>right128</code></em>, <em class="replaceable"><code>dest128</code></em> );
    math.idivq( <em class="replaceable"><code>left64</code></em>, <em class="replaceable"><code>right64</code></em>, <em class="replaceable"><code>dest64</code></em> );
    math.idivl( <em class="replaceable"><code>left128</code></em>, <em class="replaceable"><code>right128</code></em>, <em class="replaceable"><code>dest128</code></em> );
    math.modq( <em class="replaceable"><code>left64</code></em>, <em class="replaceable"><code>right64</code></em>, <em class="replaceable"><code>dest64</code></em> );
    math.modl( <em class="replaceable"><code>left128</code></em>, <em class="replaceable"><code>right128</code></em>, <em class="replaceable"><code>dest128</code></em> );
    math.imodq( <em class="replaceable"><code>left64</code></em>, <em class="replaceable"><code>right64</code></em>, <em class="replaceable"><code>dest64</code></em> );
    math.imodl( <em class="replaceable"><code>left128</code></em>, <em class="replaceable"><code>right128</code></em>, <em class="replaceable"><code>dest128</code></em> );
    math.mulq( <em class="replaceable"><code>left64</code></em>, <em class="replaceable"><code>right64</code></em>, <em class="replaceable"><code>dest64</code></em> );
    math.mull( <em class="replaceable"><code>left128</code></em>, <em class="replaceable"><code>right128</code></em>, <em class="replaceable"><code>dest128</code></em> );
    math.imulq( <em class="replaceable"><code>left64</code></em>, <em class="replaceable"><code>right64</code></em>, <em class="replaceable"><code>dest64</code></em> );
    math.imull( <em class="replaceable"><code>left128</code></em>, <em class="replaceable"><code>right128</code></em>, <em class="replaceable"><code>dest128</code></em> );
    math.orq( <em class="replaceable"><code>left64</code></em>, <em class="replaceable"><code>right64</code></em>, <em class="replaceable"><code>dest64</code></em> );
    math.orl( <em class="replaceable"><code>left128</code></em>, <em class="replaceable"><code>right128</code></em>, <em class="replaceable"><code>dest128</code></em> );
    math.subq( <em class="replaceable"><code>left64</code></em>, <em class="replaceable"><code>right64</code></em>, <em class="replaceable"><code>dest64</code></em> );
    math.subl( <em class="replaceable"><code>left128</code></em>, <em class="replaceable"><code>right128</code></em>, <em class="replaceable"><code>dest128</code></em> );
    math.xorq( <em class="replaceable"><code>left64</code></em>, <em class="replaceable"><code>right64</code></em>, <em class="replaceable"><code>dest64</code></em> );
    math.xorl( <em class="replaceable"><code>left128</code></em>, <em class="replaceable"><code>right128</code></em>, <em class="replaceable"><code>dest128</code></em> );</pre><p>These functions set the flags the same way as the corresponding 32-bit machine instructions and, in the case of the division and remainder (modulo) functions, raise the same exceptions. Note that the multiplication functions do not produce an extended-precision result. The destination value is the same size as the source operands. These functions set the overflow and carry flags if the result does not fit into the destination operand. All of these functions compute the following:<a class="indexterm" id="IDX-CHP-8-0032"/><a class="indexterm" id="IDX-CHP-8-0033"/><a class="indexterm" id="IDX-CHP-8-0034"/><a class="indexterm" id="IDX-CHP-8-0035"/></p><a id="I_programlisting8_d1e42157"/><pre class="programlisting"><em class="replaceable"><code>dest64</code></em> := <em class="replaceable"><code>left64 op right64</code></em>;
<em class="replaceable"><code>dest128</code></em> := <em class="replaceable"><code>left128 op right128</code></em>;</pre><p>where <em class="replaceable"><code>op</code></em> represents the specific operation.</p><p>In addition to these functions, the HLA Standard Library's math module also provides a few additional functions whose syntax is slightly different from <code class="literal">math.addq</code> and <code class="literal">math.addl</code>. These functions include <code class="literal">math.negq</code>, <code class="literal">math.negl</code>, <code class="literal">math.notq</code>, <code class="literal">math.notl</code>, <code class="literal">math.shlq</code>, <code class="literal">math.shll</code>, <code class="literal">math.shrq</code>, and <code class="literal">math.shrl</code>. Note that there are no rotates or arithmetic shift-right functions. However, you'll soon see that these operations are easy to synthesize using standard instructions. Here are the prototypes for these additional functions:<a class="indexterm" id="IDX-CHP-8-0036"/><a class="indexterm" id="IDX-CHP-8-0037"/><a class="indexterm" id="IDX-CHP-8-0038"/><a class="indexterm" id="IDX-CHP-8-0039"/><a class="indexterm" id="IDX-CHP-8-0040"/><a class="indexterm" id="IDX-CHP-8-0041"/><a class="indexterm" id="IDX-CHP-8-0042"/><a class="indexterm" id="IDX-CHP-8-0043"/></p><a id="I_programlisting8_d1e42249"/><pre class="programlisting">math.negq( source:qword; var dest:qword );
math.negl( source:lword; var dest:lword );
math.notq( source:qword; var dest:qword );
math.notl( source:lword; var dest:lword );
math.shlq( count:uns32; source:qword; var dest:qword );
math.shll( count:uns32; source:lword; var dest:lword );
math.shrq( count:uns32; source:qword; var dest:qword );
math.shrl( count:uns32; source:lword; var dest:lword );</pre><p>Again, all these functions set the flags exactly the same way the corresponding machine instructions would set the flags were they to support 64-bit or 128-bit operands.</p><p>The HLA Standard Library also provides a full complement of I/O and conversion routines for 64-bit and 128-bit values. For example, you can use <code class="literal">stdout.put</code> to display 64- and 128-bit values, you may use <code class="literal">stdin.get</code> to read these values, and there is a set of routines in the HLA conversions module that convert between these values and their string equivalents. In general, anything you can do with a 32-bit value can be done with a 64-bit or 128-bit value as well. See the HLA Standard Library documentation for more details.</p></div><div class="sect2" title="8.1.2 Multiprecision Addition Operations"><div class="titlepage"><div><div><h2 class="title"><a id="multiprecision_addition_operations"/>8.1.2 Multiprecision Addition Operations</h2></div></div></div><p>The 80x86 <code class="literal">add</code> instruction adds two 8-, 16-, or 32- bit numbers. After the execution of the <code class="literal">add</code> instruction, the 80x86 carry flag is set if there is an overflow out of the H.O. bit of the sum. You can use this information to do multiprecision addition operations. Consider the way you manually perform a multidigit (multiprecision) addition operation:<a class="indexterm" id="IDX-CHP-8-0044"/></p><a id="I_programlisting8_d1e42275"/><pre class="programlisting">Step 1: Add the least significant digits together:

             289                      289
            +456    produces         +456
            ----                     ----
                                        5 with carry 1.

    Step 2: Add the next significant digits plus the carry:

               1 (previous carry)
             289                         289
            +456        produces        +456
            ----                        ----
               5                          45 with carry 1.

    Step 3: Add the most significant digits plus the carry:

                                       1 (previous carry)
             289                     289
            +456        produces    +456
            ----                    ----
              45                     745</pre><p>The 80x86 handles extended-precision arithmetic in an identical fashion, except instead of adding the numbers a digit at a time, it adds them together a byte, word, or double word at a time. Consider the three double-word (96-bit) addition operation in <a class="xref" href="ch08.html#adding_two_96-bit_objects_together" title="Figure 8-1. Adding two 96-bit objects together">Figure 8-1</a>.</p><div class="figure"><a id="adding_two_96-bit_objects_together"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject8_d1e42284"/><img alt="Adding two 96-bit objects together" src="tagoreillycom20100401nostarchimages578043.png"/></div></div><p class="title">Figure 8-1. Adding two 96-bit objects together</p></div><p>As you can see from this figure, the idea is to break up a larger operation into a sequence of smaller operations. Since the x86 processor family is capable of adding together, at most, 32 bits at a time, the operation must proceed in blocks of 32 bits or less. So the first step is to add the two L.O. double words together just as you would add the two L.O. digits of a decimal number together in the manual algorithm. There is nothing special about this operation; you can use the <code class="literal">add</code> instruction to achieve this.<a class="indexterm" id="IDX-CHP-8-0045"/><a class="indexterm" id="IDX-CHP-8-0046"/></p><p>The second step involves adding together the second pair of double words in the two 96-bit values. Note that in step 2, the calculation must also add in the carry out of the previous addition (if any). If there is a carry out of the L.O. addition, the <code class="literal">add</code> instruction sets the carry flag to 1; conversely, if there is no carry out of the L.O. addition, the earlier <code class="literal">add</code> instruction clears the carry flag. Therefore, in this second addition, we really need to compute the sum of the two double words plus the carry out of the first instruction. Fortunately, the x86 CPUs provide an instruction that does exactly this: the <code class="literal">adc</code> (add with carry) instruction. The <code class="literal">adc</code> instruction uses the same syntax as the <code class="literal">add</code> instruction and performs almost the same operation:</p><a id="I_programlisting8_d1e42319"/><pre class="programlisting">adc( <em class="replaceable"><code>source</code></em>, <em class="replaceable"><code>dest</code></em> );  // <em class="replaceable"><code>dest</code></em> := <em class="replaceable"><code>dest</code></em> + <em class="replaceable"><code>source</code></em> + C</pre><p>As you can see, the only difference between the <code class="literal">add</code> and <code class="literal">adc</code> instructions is that the <code class="literal">adc</code> instruction adds in the value of the carry flag along with the source and destination operands. It also sets the flags the same way the <code class="literal">add</code> instruction does (including setting the carry flag if there is an unsigned overflow). This is exactly what we need to add together the middle two double words of our 96-bit sum.</p><p>In step 3 of <a class="xref" href="ch08.html#adding_two_96-bit_objects_together" title="Figure 8-1. Adding two 96-bit objects together">Figure 8-1</a>, the algorithm adds together the H.O. double words of the 96-bit value. This addition operation must also incorporate the carry out of the sum of the middle two double words; hence the <code class="literal">adc</code> instruction is needed here as well. To sum it up, the <code class="literal">add</code> instruction adds the L.O. double words together. The <code class="literal">adc</code> (add with carry) instruction adds all other double word pairs together. At the end of the extended-precision addition sequence, the carry flag indicates unsigned overflow (if set), a set overflow flag indicates signed overflow, and the sign flag indicates the sign of the result. The zero flag doesn't have any real meaning at the end of the extended-precision addition (it simply means that the sum of the two H.O. double words is 0 and does not indicate that the whole result is 0). If you want to see how to check for an extended-precision zero result, see the source code for the HLA Standard Library <code class="literal">math.addq</code> or <code class="literal">math.addl</code> function.<a class="indexterm" id="IDX-CHP-8-0047"/><a class="indexterm" id="IDX-CHP-8-0048"/></p><p>For example, suppose that you have two 64-bit values you wish to add together, defined as follows:</p><a id="I_programlisting8_d1e42383"/><pre class="programlisting">static
    X: qword;
    Y: qword;</pre><p>Suppose also that you want to store the sum in a third variable, <code class="literal">Z</code>, which is also a <code class="literal">qword</code>. The following 80x86 code will accomplish this task:</p><a id="I_programlisting8_d1e42393"/><pre class="programlisting">mov( (type dword X), eax );          // Add together the L.O. 32 bits
    add( (type dword Y), eax );          // of the numbers and store the
    mov( eax, (type dword Z) );          // result into the L.O. dword of Z.

    mov( (type dword X[4]), eax );       // Add together (with carry) the
    adc( (type dword Y[4]), eax );       // H.O. 32 bits and store the result
    mov( eax, (type dword Z[4]) );       // into the H.O. dword of Z.</pre><p>Remember, these variables are <code class="literal">qword</code> objects. Therefore the compiler will not accept an instruction of the form <code class="literal">mov( X, eax );</code> because this instruction would attempt to load a 64-bit value into a 32-bit register. This code uses the coercion operator to coerce symbols <code class="literal">X</code>, <code class="literal">Y</code>, and <code class="literal">Z</code> to 32 bits. The first three instructions add the L.O. double words of <code class="literal">X</code> and <code class="literal">Y</code> together and store the result at the L.O. double word of <code class="literal">Z</code>. The last three instructions add the H.O. double words of <code class="literal">X</code> and <code class="literal">Y</code> together, along with the carry from the L.O. word, and store the result in the H.O. double word of <code class="literal">Z</code>. Remember, address expressions of the form <code class="literal">X[4]</code> access the H.O. double word of a 64-bit entity. This is because the x86 memory space addresses bytes, and it takes 4 consecutive bytes to form a double word.<a class="indexterm" id="IDX-CHP-8-0049"/></p><p>You can extend this to any number of bits by using the <code class="literal">adc</code> instruction to add in the higher-order values. For example, to add together two 128-bit values, you could use code like the following:</p><a id="I_programlisting8_d1e42445"/><pre class="programlisting">type
    tBig: dword[4];           // Storage for four dwords is 128 bits.

static
    BigVal1: tBig;
    BigVal2: tBig;
    BigVal3: tBig;
     .
     .
     .
    mov( BigVal1[0], eax );   // Note there is no need for (type dword BigValx)
    add( BigVal2[0], eax );   // because the base type of BitValx is dword.
    mov( eax, BigVal3[0] );

    mov( BigVal1[4], eax );
    adc( BigVal2[4], eax );
    mov( eax, BigVal3[4] );

    mov( BigVal1[8], eax );
    adc( BigVal2[8], eax );
    mov( eax, BigVal3[8] );

    mov( BigVal1[12], eax );
    adc( BigVal2[12], eax );
    mov( eax, BigVal3[12] );</pre></div><div class="sect2" title="8.1.3 Multiprecision Subtraction Operations"><div class="titlepage"><div><div><h2 class="title"><a id="multiprecision_subtraction_operations"/>8.1.3 Multiprecision Subtraction Operations</h2></div></div></div><p>The 80x86 performs multibyte subtraction, just as it does addition, the same way you would manually, except it subtracts whole bytes, words, or double words at a time rather than decimal digits. The mechanism is similar to that for the <code class="literal">add</code> operation. You use the <code class="literal">sub</code> instruction on the L.O. byte/word/double word and the <code class="literal">sbb</code> (subtract with borrow) instruction on the high-order values.<a class="indexterm" id="IDX-CHP-8-0050"/><a class="indexterm" id="IDX-CHP-8-0051"/><a class="indexterm" id="IDX-CHP-8-0052"/></p><p>The following example demonstrates a 64-bit subtraction using the 32-bit registers on the 80x86:</p><a id="I_programlisting8_d1e42474"/><pre class="programlisting">static
    Left:        qword;
    Right:       qword;
    Diff:        qword;
         .
         .
         .
    mov( (type dword Left), eax );
    sub( (type dword Right), eax );
    mov( eax, (type dword Diff) );

    mov( (type dword Left[4]), eax );
    sbb( (type dword Right[4]), eax );
    mov( (type dword Diff[4]), eax );</pre><p>The following example demonstrates a 128-bit subtraction:</p><a id="I_programlisting8_d1e42478"/><pre class="programlisting">type
    tBig: dword[4];  // Storage for four dwords is 128 bits.

static
    BigVal1: tBig;
    BigVal2: tBig;
    BigVal3: tBig;
     .
     .
     .

    // Compute BigVal3 := BigVal1 - BigVal2

    mov( BigVal1[0], eax ); // Note there is no need for (type dword BigValx)
    sub( BigVal2[0], eax ); // because the base type of BitValx is dword.
    mov( eax, BigVal3[0] );

    mov( BigVal1[4], eax );
    sbb( BigVal2[4], eax );
    mov( eax, BigVal3[4] );

    mov( BigVal1[8], eax );
    sbb( BigVal2[8], eax );
    mov( eax, BigVal3[8] );

    mov( BigVal1[12], eax );
    sbb( BigVal2[12], eax );
    mov( eax, BigVal3[12] );</pre></div><div class="sect2" title="8.1.4 Extended-Precision Comparisons"><div class="titlepage"><div><div><h2 class="title"><a id="extended-precision_comparisons"/>8.1.4 Extended-Precision Comparisons</h2></div></div></div><p>Unfortunately, there isn't a "compare with borrow" instruction that you can use to perform extended-precision comparisons. Since the <code class="literal">cmp</code> and <code class="literal">sub</code> instructions perform the same operation, at least as far as the flags are concerned, you'd probably guess that you could use the <code class="literal">sbb</code> instruction to synthesize an extended-precision comparison; however, that approach won't always work. Fortunately, there is a better solution.<a class="indexterm" id="IDX-CHP-8-0053"/><a class="indexterm" id="IDX-CHP-8-0054"/></p><p>Consider the two unsigned values $2157 and $1293. The L.O. bytes of these two values do not affect the outcome of the comparison. Simply comparing the H.O. bytes, $21 with $12, tells us that the first value is greater than the second. In fact, the only time you ever need to look at both bytes of these values is if the H.O. bytes are equal. In all other cases comparing the H.O. bytes tells you everything you need to know about the values. Of course, this is true for any number of bytes, not just 2. The following code compares two signed 64-bit integers by comparing their H.O. double words first and comparing their L.O. double words only if the H.O. double words are equal:</p><a id="I_programlisting8_d1e42506"/><pre class="programlisting">// This sequence transfers control to location "IsGreater" if
// QwordValue &gt; QwordValue2. It transfers control to "IsLess" if
// QwordValue &lt; QwordValue2. It falls through to the instruction
// following this sequence if QwordValue = QwordValue2. To test for
// inequality, change the "IsGreater" and "IsLess" operands to "NotEqual"
// in this code.

        mov( (type dword QWordValue[4]), eax );  // Get H.O. dword.
        cmp( eax, (type dword QWordValue2[4]));
        jg IsGreater;
        jl IsLess;

        mov( (type dword QWordValue[0]), eax );  // If H.O. dwords were equal,
        cmp( eax, (type dword QWordValue2[0]));  // then we must compare the
        jg IsGreater;                            // L.O. dwords.
        jl IsLess;

// Fall through to this point if the two values were equal.</pre><p>To compare unsigned values, simply use the <code class="literal">ja</code> and <code class="literal">jb</code> instructions in place of <code class="literal">jg</code> and <code class="literal">jl</code>.</p><p>You can easily synthesize any possible comparison from the preceding sequence. The following examples show how to do this. These examples demonstrate signed comparisons; just substitute <code class="literal">ja</code>, <code class="literal">jae</code>, <code class="literal">jb</code>, and <code class="literal">jbe</code> for <code class="literal">jg</code>, <code class="literal">jge</code>, <code class="literal">jl</code>, and <code class="literal">jle</code> (respectively) if you want unsigned comparisons. Each of the following examples assumes these declarations:</p><a id="I_programlisting8_d1e42549"/><pre class="programlisting">static
    QW1: qword;
    QW2: qword;

const
    QW1d: text := "(type dword QW1)";
    QW2d: text := "(type dword QW2)";</pre><p>The following code implements a 64-bit test to see if <code class="literal">QW1 &lt; QW2</code> (signed). Control transfers to <code class="literal">IsLess</code> label if <code class="literal">QW1 &lt; QW2</code>. Control falls through to the next statement if this is not true.</p><a id="I_programlisting8_d1e42562"/><pre class="programlisting">mov( QW1d[4], eax );   // Get H.O. dword.
    cmp( eax, QW2d[4] );
    jg NotLess;
    jl IsLess;

    mov( QW1d[0], eax );   // Fall through to here if the H.O. dwords are equal.
    cmp( eax, QW2d[0] );
    jl IsLess;
NotLess:</pre><p>Here is a 64-bit test to see if <code class="literal">QW1 &lt;= QW2</code> (signed). This code jumps to <code class="literal">IsLessEq</code> if the condition is true.</p><a id="I_programlisting8_d1e42572"/><pre class="programlisting">mov( QW1d[4], eax );   // Get H.O. dword.
    cmp( eax, QW2d[4] );
    jg NotLessEQ;
    jl IsLessEQ;

    mov( QW1d[0], eax );   // Fall through to here if the H.O. dwords are equal.
    cmp( eax, QW2d[0] );
    jle IsLessEQ;
NotLessEQ:</pre><p>This is a 64-bit test to see if <code class="literal">QW1 &gt; QW2</code> (signed). It jumps to <code class="literal">IsGtr</code> if this condition is true.</p><a id="I_programlisting8_d1e42583"/><pre class="programlisting">mov( QW1d[4], eax );   // Get H.O. dword.
    cmp( eax, QW2d[4] );
    jg IsGtr;
    jl NotGtr;

    mov( QW1d[0], eax );   // Fall through to here if the H.O. dwords are equal.
    cmp( eax, QW2d[0] );
    jg IsGtr;
NotGtr:</pre><p>The following is a 64-bit test to see if <code class="literal">QW1 &gt;= QW2</code> (signed). This code jumps to label <code class="literal">IsGtrEQ</code> if this is the case.</p><a id="I_programlisting8_d1e42593"/><pre class="programlisting">mov( QW1d[4], eax );   // Get H.O. dword.
    cmp( eax, QW2d[4] );
    jg IsGtrEQ;
    jl NotGtrEQ;

    mov( QW1d[0], eax );   // Fall through to here if the H.O. dwords are equal.
    cmp( eax, QW2d[0] );
    jge IsGtrEQ;
NotGtrEQ:</pre><p>Here is a 64-bit test to see if <code class="literal">QW1 = QW2</code> (signed or unsigned). This code branches to the label <code class="literal">IsEqual</code> if <code class="literal">QW1 = QW2</code>. It falls through to the next instruction if they are not equal.</p><a id="I_programlisting8_d1e42606"/><pre class="programlisting">mov( QW1d[4], eax );   // Get H.O. dword.
    cmp( eax, QW2d[4] );
    jne NotEqual;

    mov( QW1d[0], eax );   // Fall through to here if the H.O. dwords are equal.
    cmp( eax, QW2d[0] );
    je IsEqual;
NotEqual:</pre><p>The following is a 64-bit test to see if <code class="literal">QW1 &lt;&gt; QW2</code> (signed or unsigned). This code branches to the label <code class="literal">NotEqual</code> if <code class="literal">QW1 &lt;&gt; QW2</code>. It falls through to the next instruction if they are equal.</p><a id="I_programlisting8_d1e42619"/><pre class="programlisting">mov( QW1d[4], eax );   // Get H.O. dword.
    cmp( eax, QW2d[4] );
    jne IsNotEqual;

    mov( QW1d[0], eax );   // Fall through to here if the H.O. dwords are equal.
    cmp( eax, QW2d[0] );
    jne IsNotEqual;

// Fall through to this point if they are equal.</pre><p>You cannot directly use the HLA high-level control structures if you need to perform an extended-precision comparison. However, you may use the HLA hybrid control structures and bury the appropriate comparison in the boolean expression. Doing so may produce easier to read code. For example, the following <code class="literal">if..then..else..endif</code> statement checks to see if <code class="literal">QW1 &gt; QW2</code> using a 64-bit extended-precision unsigned comparison:</p><a id="I_programlisting8_d1e42629"/><pre class="programlisting">if
( #{
    mov( QW1d[4], eax );
    cmp( eax, QW2d[4] );
    jg true;

    mov( QW1d[0], eax );
    cmp( eax, QW2d[0] );
    jng false;
}# ) then

    &lt;&lt; Code to execute if QW1 &gt; QW2 &gt;&gt;

else

    &lt;&lt; Code to execute if QW1 &lt;= QW2 &gt;&gt;

endif;</pre><p>If you need to compare objects that are larger than 64 bits, it is very easy to generalize the code given above for 64-bit operands. Always start the comparison with the H.O. double words of the objects and work your way down to the L.O. double words of the objects as long as the corresponding double words are equal. The following example compares two 128-bit values to see if the first is less than or equal (unsigned) to the second:<a class="indexterm" id="IDX-CHP-8-0055"/><a class="indexterm" id="IDX-CHP-8-0056"/><a class="indexterm" id="IDX-CHP-8-0057"/><a class="indexterm" id="IDX-CHP-8-0058"/><a class="indexterm" id="IDX-CHP-8-0059"/><a class="indexterm" id="IDX-CHP-8-0060"/><a class="indexterm" id="IDX-CHP-8-0061"/><a class="indexterm" id="IDX-CHP-8-0062"/></p><a id="I_programlisting8_d1e42666"/><pre class="programlisting">static
    Big1: uns128;
    Big2: uns128;
     .
     .
     .
    if
    ( #{
        mov( Big1[12], eax );
        cmp( eax, Big2[12] );
        jb true;
        ja false;
        mov( Big1[8], eax );
        cmp( eax, Big2[8] );
        jb true;
        ja false;
        mov( Big1[4], eax );
        cmp( eax, Big2[4] );
        jb true;
        ja false;
        mov( Big1[0], eax );
        cmp( eax, Big2[0] );
        jnbe false;
    }# ) then

        &lt;&lt; Code to execute if Big1 &lt;= Big2 &gt;&gt;

    else

        &lt;&lt; Code to execute if Big1 &gt; Big2 &gt;&gt;

    endif;</pre></div><div class="sect2" title="8.1.5 Extended-Precision Multiplication"><div class="titlepage"><div><div><h2 class="title"><a id="extended-precision_multiplication"/>8.1.5 Extended-Precision Multiplication</h2></div></div></div><p>Although an 8×8-bit, 16×16-bit, or 32×32-bit multiplication is usually sufficient, there are times when you may want to multiply larger values. You will use the x86 single operand <code class="literal">mul</code> and <code class="literal">imul</code> instructions for extended-precision multiplication operations.<a class="indexterm" id="IDX-CHP-8-0063"/><a class="indexterm" id="IDX-CHP-8-0064"/></p><p>Not surprisingly (in view of how we achieved extended-precision addition using <code class="literal">adc</code> and <code class="literal">sbb</code>), you use the same techniques to perform extended-precision multiplication on the 80x86 that you employ when manually multiplying two values. Consider a simplified form of the way you perform multidigit multiplication by hand:</p><a id="I_programlisting8_d1e42695"/><pre class="programlisting">1) Multiply the first two              2) Multiply 5*2:
           digits together (5*3):

            123                                      123
             45                                       45
            ---                                      ---
             15                                       15
                                                      10


         3) Multiply 5*1:                       4) Multiply 4*3:

            123                                      123
             45                                       45
            ---                                      ---
             15                                       15
             10                                       10
              5                                        5
                                                      12


         5) Multiply 4*2:                       6) Multiply 4*1:

             123                                     123
              45                                      45
             ---                                     ---
              15                                      15
              10                                      10
               5                                       5
              12                                      12
               8                                       8
                                                       4

         7) Add all the partial products together:

             123
              45
             ---
              15
              10
               5
              12
               8
               4
          ------
            5535</pre><p>The 80x86 does extended-precision multiplication in the same manner except that it works with bytes, words, and double words rather than digits. <a class="xref" href="ch08.html#extended-precision_multiplication-id1" title="Figure 8-2. Extended-precision multiplication">Figure 8-2</a> shows how this works.</p><div class="figure"><a id="extended-precision_multiplication-id1"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject8_d1e42704"/><img alt="Extended-precision multiplication" src="tagoreillycom20100401nostarchimages578045.png"/></div></div><p class="title">Figure 8-2. Extended-precision multiplication</p></div><p>Probably the most important thing to remember when performing an extended-precision multiplication is that you must also perform a multiple-precision addition at the same time. Adding up all the partial products requires several additions that will produce the result. <a class="xref" href="ch08.html#extended-precision_multiplication-id2" title="Example 8-1. Extended-precision multiplication">Example 8-1</a> demonstrates the proper way to multiply two 64-bit values on a 32-bit processor.</p><div class="example"><a id="extended-precision_multiplication-id2"/><p class="title">Example 8-1. Extended-precision multiplication</p><div class="example-contents"><pre class="programlisting">program testMUL64;
#include( "stdlib.hhf" )


procedure MUL64( Multiplier:qword; Multiplicand:qword; var Product:lword );
const
    mp: text := "(type dword Multiplier)";
    mc: text := "(type dword Multiplicand)";
    prd:text := "(type dword [edi])";

begin MUL64;

    mov( Product, edi );

    // Multiply the L.O. dword of Multiplier times Multiplicand.

    mov( mp, eax );
    mul( mc, eax );     // Multiply L.O. dwords.
    mov( eax, prd );    // Save L.O. dword of product.
    mov( edx, ecx );    // Save H.O. dword of partial product result.

    mov( mp, eax );
    mul( mc[4], eax );  // Multiply mp(L.O.) * mc(H.O.)
    add( ecx, eax );    // Add to the partial product.
    adc( 0, edx );      // Don't forget the carry!
    mov( eax, ebx );    // Save partial product for now.
    mov( edx, ecx );

    // Multiply the H.O. word of Multiplier with Multiplicand.

    mov( mp[4], eax );  // Get H.O. dword of Multiplier.
    mul( mc, eax );     // Multiply by L.O. word of Multiplicand.
    add( ebx, eax );    // Add to the partial product.
    mov( eax, prd[4] ); // Save the partial product.
    adc( edx, ecx );    // Add in the carry!

    mov( mp[4], eax );  // Multiply the two H.O. dwords together.
    mul( mc[4], eax );
    add( ecx, eax );    // Add in partial product.
    adc( 0, edx );      // Don't forget the carry!
    mov( eax, prd[8] ); // Save the partial product.
    mov( edx, prd[12] );

end MUL64;

static
    op1: qword;
    op2: qword;
    rslt: lword;


begin testMUL64;

    // Initialize the qword values (note that static objects
    // are initialized with 0 bits).

    mov( 1234, (type dword op1 ));
    mov( 5678, (type dword op2 ));
    MUL64( op1, op2, rslt );

    // The following only prints the L.O. qword, but
    // we know the H.O. qword is 0 so this is okay.

    stdout.put( "rslt=" );
    stdout.putu64( (type qword rslt));

end testMUL64;</pre></div></div><p>One thing you must keep in mind concerning this code is that it works only for unsigned operands. To multiply two signed values you must note the signs of the operands before the multiplication, take the absolute value of the two operands, do an unsigned multiplication, and then adjust the sign of the resulting product based on the signs of the original operands. Multiplication of signed operands is left as an exercise to the reader (or you could just check out the source code in the HLA Standard Library).<a class="indexterm" id="IDX-CHP-8-0065"/><a class="indexterm" id="IDX-CHP-8-0066"/><a class="indexterm" id="IDX-CHP-8-0067"/><a class="indexterm" id="IDX-CHP-8-0068"/></p><p>The example in <a class="xref" href="ch08.html#extended-precision_multiplication-id2" title="Example 8-1. Extended-precision multiplication">Example 8-1</a> was fairly straightforward because it was possible to keep the partial products in various registers. If you need to multiply larger values together, you will need to maintain the partial products in temporary (memory) variables. Other than that, the algorithm that <a class="xref" href="ch08.html#extended-precision_multiplication-id2" title="Example 8-1. Extended-precision multiplication">Example 8-1</a> uses generalizes to any number of double words.</p></div><div class="sect2" title="8.1.6 Extended-Precision Division"><div class="titlepage"><div><div><h2 class="title"><a id="extended-precision_division"/>8.1.6 Extended-Precision Division</h2></div></div></div><p>You cannot synthesize a general <span class="emphasis"><em>n</em></span>-bit/<span class="emphasis"><em>m</em></span>-bit division operation using the <code class="literal">div</code> and <code class="literal">idiv</code> instructions. Extended-precision division requires a sequence of shift and subtract instructions and is extremely messy. However, a less-general operation, dividing an <span class="emphasis"><em>n</em></span>-bit quantity by a 32-bit quantity, is easily synthesized using the <code class="literal">div</code> instruction. This section presents both methods for extended-precision division.<a class="indexterm" id="IDX-CHP-8-0069"/></p><p>Before we describe how to perform a multiprecision division operation, you should note that some operations require an extended-precision division even though they may look calculable with a single <code class="literal">div</code> or <code class="literal">idiv</code> instruction. Dividing a 64-bit quantity by a 32-bit quantity is easy, as long as the resulting quotient fits into 32 bits. The <code class="literal">div</code> and <code class="literal">idiv</code> instructions will handle this directly. However, if the quotient does not fit into 32 bits, then you have to handle this problem as an extended-precision division. The trick here is to divide the (zero- or sign-extended) H.O. double word of the dividend by the divisor and then repeat the process with the remainder and the L.O. dword of the dividend. The following sequence demonstrates this.</p><a id="I_programlisting8_d1e42785"/><pre class="programlisting">static
    dividend: dword[2] := [$1234, 4];  // = $4_0000_1234.
    divisor:  dword := 2;              // dividend/divisor = $2_0000_091A
    quotient: dword[2];
    remainder:dword;
     .
     .
     .
    mov( divisor, ebx );
    mov( dividend[4], eax );
    xor( edx, edx );            // Zero extend for unsigned division.
    div( ebx, edx:eax );
    mov( eax, quotient[4] );    // Save H.O. dword of the quotient (2).
    mov( dividend[0], eax );    // Note that this code does *NOT* zero extend
    div( ebx, edx:eax );        // eax into edx before this div instr.
    mov( eax, quotient[0] );    // Save L.O. dword of the quotient ($91a).
    mov( edx, remainder );      // Save away the remainder.</pre><p>Since it is perfectly legal to divide a value by 1, it is possible that the resulting quotient could require as many bits as the dividend. That is why the <code class="literal">quotient</code> variable in this example is the same size (64 bits) as the <code class="literal">dividend</code> variable (note the use of an array of two double words rather than a <code class="literal">qword</code> type; this spares the code from having to coerce the operands to double words). Regardless of the size of the dividend and divisor operands, the remainder is always no larger than the size of the division operation (32 bits in this case). Hence the <code class="literal">remainder</code> variable in this example is just a double word.</p><p>Before analyzing this code to see how it works, let's take a brief look at why a single 64/32 division will not work for this particular example even though the <code class="literal">div</code> instruction does indeed calculate the result for a 64/32 division. The naive approach, assuming that the x86 were capable of this operation, would look something like the following:</p><a id="I_programlisting8_d1e42806"/><pre class="programlisting">// This code does *NOT* work!

    mov( dividend[0], eax );    // Get dividend into edx:eax
    mov( dividend[4], edx );
    div( divisor, edx:eax );    // Divide edx:eax by divisor.</pre><p>Although this code is syntactically correct and will compile, if you attempt to run this code it will raise an <code class="literal">ex.DivideError</code><sup>[<a class="footnote" href="#ftn.CHP-8-FN-2" id="CHP-8-FN-2">112</a>]</sup> exception. The reason is that the quotient must fit into 32 bits. Because the quotient turns out to be $2_0000_091A, it will not fit into the EAX register, hence the resulting exception.<a class="indexterm" id="IDX-CHP-8-0070"/></p><p>Now let's take another look at the former code that correctly computes the 64/32 quotient. This code begins by computing the 32/32 quotient of <code class="literal">dividend[4]/divisor</code>. The quotient from this division (2) becomes the H.O. double word of the final quotient. The remainder from this division (0) becomes the extension in EDX for the second half of the division operation. The second half of the code divides <code class="literal">edx:dividend[0]</code> by <code class="literal">divisor</code> to produce the L.O. double word of the quotient and the remainder from the division. Note that the code does not zero extend EAX into EDX prior to the second <code class="literal">div</code> instruction. EDX already contains valid bits, and this code must not disturb them.<a class="indexterm" id="IDX-CHP-8-0071"/></p><p>The 64/32 division operation above is actually just a special case of the general division operation that lets you divide an arbitrary size value by a 32-bit divisor. To achieve this, you begin by moving the H.O. double word of the dividend into EAX and zero extending this into EDX. Next, you divide this value by the divisor. Then, without modifying EDX along the way, you store away the partial quotients, load EAX with the next-lower double word in the dividend, and divide it by the divisor. You repeat this operation until you've processed all the double words in the dividend. At that time the EDX register will contain the remainder. The program in <a class="xref" href="ch08.html#unsigned_128_solidus_32-bit_extended-pre" title="Example 8-2. Unsigned 128/32-bit extended-precision division">Example 8-2</a> demonstrates how to divide a 128-bit quantity by a 32-bit divisor, producing a 128-bit quotient and a 32-bit remainder.</p><div class="example"><a id="unsigned_128_solidus_32-bit_extended-pre"/><p class="title">Example 8-2. Unsigned 128/32-bit extended-precision division</p><div class="example-contents"><pre class="programlisting">program testDiv128;
#include( "stdlib.hhf" )

procedure div128
(
        Dividend:   lword;
        Divisor:    dword;
    var QuotAdrs:   lword;
    var Remainder:  dword
);  @nodisplay;

const
    Quotient: text := "(type dword [edi])";

begin div128;

    push( eax );
    push( edx );
    push( edi );

    mov( QuotAdrs, edi );       // Pointer to quotient storage.

    mov( (type dword Dividend[12]), eax ); // Begin division with the H.O. dword.
    xor( edx, edx );            // Zero extend into edx.
    div( Divisor, edx:eax );    // Divide H.O. dword.
    mov( eax, Quotient[12] );   // Store away H.O. dword of quotient.

    mov( (type dword Dividend[8]), eax ); // Get dword #2 from the dividend.
    div( Divisor, edx:eax );    // Continue the division.
    mov( eax, Quotient[8] );    // Store away dword #2 of the quotient.

    mov( (type dword Dividend[4]), eax ); // Get dword #1 from the dividend.
    div( Divisor, edx:eax );    // Continue the division.
    mov( eax, Quotient[4] );    // Store away dword #1 of the quotient.

    mov( (type dword Dividend[0]), eax );    // Get the L.O. dword of the
                                             // dividend.
    div( Divisor, edx:eax );    // Finish the division.
    mov( eax, Quotient[0] );    // Store away the L.O. dword of the quotient.

    mov( Remainder, edi );      // Get the pointer to the remainder's value.
    mov( edx, [edi] );          // Store away the remainder value.

    pop( edi );
    pop( edx );
    pop( eax );

end div128;

static
    op1:    lword   := $8888_8888_6666_6666_4444_4444_2222_2221;
    op2:    dword   := 2;
    quo:    lword;
    rmndr:  dword;


begin testDiv128;

    div128( op1, op2, quo, rmndr );

    stdout.put
    (
        nl
        nl
        "After the division: " nl
        nl
        "Quotient = $",
        quo[12], "_",
        quo[8], "_",
        quo[4], "_",
        quo[0], nl

        "Remainder = ", (type uns32 rmndr )
    );

end testDiv128;</pre></div></div><p>You can extend this code to any number of bits by simply adding additional <code class="literal">mov</code>/<code class="literal">div</code>/<code class="literal">mov</code> instructions to the sequence. Like the extended-precision multiplication the previous section presents, this extended-precision division algorithm works only for unsigned operands. If you need to divide two signed quantities, you must note their signs, take their absolute values, do the unsigned division, and then set the sign of the result based on the signs of the operands.</p><p>If you need to use a divisor larger than 32 bits, you're going to have to implement the division using a shift-and-subtract strategy. Unfortunately, such algorithms are very slow. In this section we'll develop two division algorithms that operate on an arbitrary number of bits. The first is slow but easier to understand; the second is quite a bit faster (in the average case).</p><p>As for multiplication, the best way to understand how the computer performs division is to study how you were taught to do long division by hand. Consider the operation 3,456/12 and the steps you would take to manually perform this operation, as shown in <a class="xref" href="ch08.html#manual_digit-by-digit_division_operation" title="Figure 8-3. Manual digit-by-digit division operation">Figure 8-3</a>.</p><div class="figure"><a id="manual_digit-by-digit_division_operation"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject8_d1e42871"/><img alt="Manual digit-by-digit division operation" src="tagoreillycom20100401nostarchimages578047.png.jpg"/></div></div><p class="title">Figure 8-3. Manual digit-by-digit division operation</p></div><p>This algorithm is actually easier in binary because at each step you do not have to guess how many times 12 goes into the remainder, nor do you have to multiply 12 by your guess to obtain the amount to subtract. At each step in the binary algorithm the divisor goes into the remainder exactly zero or one times. As an example, consider the division of 27 (11011) by 3 (11) that is shown in <a class="xref" href="ch08.html#longhand_division_in_binary" title="Figure 8-4. Longhand division in binary">Figure 8-4</a>.</p><p>There is a novel way to implement this binary division algorithm that computes the quotient and the remainder at the same time. The algorithm is the following:</p><a id="I_programlisting8_d1e42882"/><pre class="programlisting">Quotient := Dividend;
Remainder := 0;
for i := 1 to NumberBits do

    Remainder:Quotient := Remainder:Quotient SHL 1;
    if Remainder &gt;= Divisor then

        Remainder := Remainder - Divisor;
        Quotient := Quotient + 1;

    endif
endfor</pre><div class="figure"><a id="longhand_division_in_binary"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject8_d1e42887"/><img alt="Longhand division in binary" src="tagoreillycom20100401nostarchimages578049.png"/></div></div><p class="title">Figure 8-4. Longhand division in binary</p></div><p><code class="literal">NumberBits</code> is the number of bits in the <code class="literal">Remainder</code>, <code class="literal">Quotient</code>, <code class="literal">Divisor</code>, and <code class="literal">Dividend</code> variables. Note that the <code class="literal">Quotient := Quotient + 1;</code> statement sets the L.O. bit of <code class="literal">Quotient</code> to 1 because this algorithm previously shifts <code class="literal">Quotient</code> 1 bit to the left. The program in <a class="xref" href="ch08.html#extended-precision_division-id1" title="Example 8-3. Extended-precision division">Example 8-3</a> implements this algorithm.</p><div class="example"><a id="extended-precision_division-id1"/><p class="title">Example 8-3. Extended-precision division</p><div class="example-contents"><pre class="programlisting">program testDiv128b;
#include( "stdlib.hhf" )



// div128-
//
// This procedure does a general 128/128 division operation using the
// following algorithm (all variables are assumed to be 128-bit objects):
//
// Quotient := Dividend;
// Remainder := 0;
// for i := 1 to NumberBits do
//
//  Remainder:Quotient := Remainder:Quotient SHL 1;
//  if Remainder &gt;= Divisor then
//
//      Remainder := Remainder - Divisor;
//      Quotient := Quotient + 1;
//
//  endif
// endfor
//

procedure div128
(
        Dividend:   lword;
        Divisor:    lword;
    var QuotAdrs:   lword;
    var RmndrAdrs:  lword
);  @nodisplay;

const
    Quotient: text := "Dividend";   // Use the Dividend as the Quotient.

var
    Remainder: lword;

begin div128;

    push( eax );
    push( ecx );
    push( edi );

    mov( 0, eax );                  // Set the remainder to 0.
    mov( eax, (type dword Remainder[0]) );
    mov( eax, (type dword Remainder[4]) );
    mov( eax, (type dword Remainder[8]) );
    mov( eax, (type dword Remainder[12]));

    mov( 128, ecx );                // Count off 128 bits in ecx.
    repeat

        // Compute Remainder:Quotient := Remainder:Quotient SHL 1:

        shl( 1, (type dword Dividend[0]) );  // See Section 8.1.12 to see
        rcl( 1, (type dword Dividend[4]) );  // how this code shifts 256
        rcl( 1, (type dword Dividend[8]) );  // bits to the left by 1 bit.
        rcl( 1, (type dword Dividend[12]));
        rcl( 1, (type dword Remainder[0]) );
        rcl( 1, (type dword Remainder[4]) );
        rcl( 1, (type dword Remainder[8]) );
        rcl( 1, (type dword Remainder[12]));

        // Do a 128-bit comparison to see if the remainder
        // is greater than or equal to the divisor.

        if
        ( #{
            mov( (type dword Remainder[12]), eax );
            cmp( eax, (type dword Divisor[12]) );
            ja true;
            jb false;

            mov( (type dword Remainder[8]), eax );
            cmp( eax, (type dword Divisor[8]) );
            ja true;
            jb false;

            mov( (type dword Remainder[4]), eax );
            cmp( eax, (type dword Divisor[4]) );
            ja true;
            jb false;

            mov( (type dword Remainder[0]), eax );
            cmp( eax, (type dword Divisor[0]) );
            jb false;
        }# ) then

            // Remainder := Remainder - Divisor

            mov( (type dword Divisor[0]), eax );
            sub( eax, (type dword Remainder[0]) );

            mov( (type dword Divisor[4]), eax );
            sbb( eax, (type dword Remainder[4]) );

            mov( (type dword Divisor[8]), eax );
            sbb( eax, (type dword Remainder[8]) );

            mov( (type dword Divisor[12]), eax );
            sbb( eax, (type dword Remainder[12]) );

            // Quotient := Quotient + 1;

            add( 1, (type dword Quotient[0]) );
            adc( 0, (type dword Quotient[4]) );
            adc( 0, (type dword Quotient[8]) );
            adc( 0, (type dword Quotient[12]) );

        endif;
        dec( ecx );

    until( @z );


    // Okay, copy the quotient (left in the Dividend variable)
    // and the remainder to their return locations.

    mov( QuotAdrs, edi );
    mov( (type dword Quotient[0]), eax );
    mov( eax, [edi] );
    mov( (type dword Quotient[4]), eax );
    mov( eax, [edi+4] );
    mov( (type dword Quotient[8]), eax );
    mov( eax, [edi+8] );
    mov( (type dword Quotient[12]), eax );
    mov( eax, [edi+12] );

    mov( RmndrAdrs, edi );
    mov( (type dword Remainder[0]), eax );
    mov( eax, [edi] );
    mov( (type dword Remainder[4]), eax );
    mov( eax, [edi+4] );
    mov( (type dword Remainder[8]), eax );
    mov( eax, [edi+8] );
    mov( (type dword Remainder[12]), eax );
    mov( eax, [edi+12] );


    pop( edi );
    pop( ecx );
    pop( eax );

end div128;



// Some simple code to test out the division operation:

static
    op1:    lword    := $8888_8888_6666_6666_4444_4444_2222_2221;
    op2:    lword    := 2;
    quo:    lword;
    rmndr:  lword;


begin testDiv128b;

    div128( op1, op2, quo, rmndr );

    stdout.put
    (
        nl
        nl
        "After the division: " nl
        nl
        "Quotient = $",
        (type dword quo[12]), "_",
        (type dword quo[8]), "_",
        (type dword quo[4]), "_",
        (type dword quo[0]), nl

        "Remainder = ", (type uns32 rmndr )
    );

end testDiv128b;</pre></div></div><p>This code looks simple but there are a few problems with it: It does not check for division by 0 (it will produce the value $FFFF_FFFF_FFFF_FFFF if you attempt to divide by 0), it handles only unsigned values, and it is very slow. Handling division by 0 is very simple; just check the divisor against 0 prior to running this code and return an appropriate error code if the divisor is 0 (or raise the <code class="literal">ex.DivisionError</code> exception). Dealing with signed values is the same as the earlier division algorithm: Note the signs, take the operands' absolute values, do the unsigned division, and then fix the sign afterward. The performance of this algorithm, however, leaves a lot to be desired. It's around an order of magnitude or two worse than the <code class="literal">div</code>/<code class="literal">idiv</code> instructions on the 80x86, and they are among the slowest instructions on the CPU.<a class="indexterm" id="IDX-CHP-8-0072"/><a class="indexterm" id="IDX-CHP-8-0073"/><a class="indexterm" id="IDX-CHP-8-0074"/><a class="indexterm" id="IDX-CHP-8-0075"/></p><p>There is a technique you can use to boost the performance of this division by a fair amount: Check to see if the divisor variable uses only 32 bits. Often, even though the divisor is a 128-bit variable, the value itself fits just fine into 32 bits (that is, the H.O. double words of <code class="literal">Divisor</code> are 0). In this special case, which occurs frequently, you can use the <code class="literal">div</code> instruction, which is much faster. The algorithm is a bit more complex because you have to first compare the H.O. double words for 0, but on the average it runs much faster while remaining capable of dividing any two pairs of values.</p></div><div class="sect2" title="8.1.7 Extended-Precision neg Operations"><div class="titlepage"><div><div><h2 class="title"><a id="extended-precision_neg_operations"/>8.1.7 Extended-Precision neg Operations</h2></div></div></div><p>Although there are several ways to negate an extended-precision value, the shortest way for smaller values (96 bits or less) is to use a combination of <code class="literal">neg</code> and <code class="literal">sbb</code> instructions. This technique uses the fact that <code class="literal">neg</code> subtracts its operand from 0. In particular, it sets the flags the same way the <code class="literal">sub</code> instruction would if you subtracted the destination value from 0. This code takes the following form (assuming you want to negate the 64-bit value in EDX:EAX):<a class="indexterm" id="IDX-CHP-8-0076"/><a class="indexterm" id="IDX-CHP-8-0077"/><a class="indexterm" id="IDX-CHP-8-0078"/></p><a id="I_programlisting8_d1e42992"/><pre class="programlisting">neg( edx );
    neg( eax );
    sbb( 0, edx );</pre><p>The <code class="literal">sbb</code> instruction decrements EDX if there is a borrow out of the L.O. word of the negation operation (which always occurs unless EAX is 0).</p><p>Extending this operation to additional bytes, words, or double words is easy; all you have to do is start with the H.O. memory location of the object you want to negate and work toward the L.O. byte. The following code computes a 128-bit negation.</p><a id="I_programlisting8_d1e43001"/><pre class="programlisting">static
    Value: dword[4];
     .
     .
     .
    neg( Value[12] );      // Negate the H.O. double word.
    neg( Value[8] );       // Neg previous dword in memory.
    sbb( 0, Value[12] );   // Adjust H.O. dword.

    neg( Value[4] );       // Negate the second dword in the object.
    sbb( 0, Value[8] );    // Adjust third dword in object.
    sbb( 0, Value[12] );   // Adjust the H.O. dword.

    neg( Value );          // Negate the L.O. dword.
    sbb( 0, Value[4] );    // Adjust second dword in object.
    sbb( 0, Value[8] );    // Adjust third dword in object.
    sbb( 0, Value[12] );   // Adjust the H.O. dword.</pre><p>Unfortunately, this code tends to get really large and slow because you need to propagate the carry through all the H.O. words after each negation operation. A simpler way to negate larger values is to simply subtract that value from 0:<a class="indexterm" id="IDX-CHP-8-0079"/></p><a id="I_programlisting8_d1e43010"/><pre class="programlisting">static
    Value: dword[5];   // 160-bit value.
     .
     .
     .
    mov( 0, eax );
    sub( Value, eax );
    mov( eax, Value );

    mov( 0, eax );
    sbb( Value[4], eax );
    mov( eax, Value[4] );

    mov( 0, eax );
    sbb( Value[8], eax );
    mov( eax, Value[8] );

    mov( 0, eax );
    sbb( Value[12], eax );
    mov( eax, Value[12] );

    mov( 0, eax );
    sbb( Value[16], eax );
    mov( eax, Value[16] );</pre></div><div class="sect2" title="8.1.8 Extended-Precision and Operations"><div class="titlepage"><div><div><h2 class="title"><a id="extended-precision_and_operations"/>8.1.8 Extended-Precision and Operations</h2></div></div></div><p>Performing an <span class="emphasis"><em>n</em></span>-byte <code class="literal">and</code> operation is very easy: Simply <code class="literal">and</code> the corresponding bytes between the two operands, saving the result. For example, to perform the <code class="literal">and</code> operation where all operands are 64 bits long, you could use the following code:<a class="indexterm" id="IDX-CHP-8-0080"/><a class="indexterm" id="IDX-CHP-8-0081"/><a class="indexterm" id="IDX-CHP-8-0082"/></p><a id="I_programlisting8_d1e43045"/><pre class="programlisting">mov( (type dword <em class="replaceable"><code>source1</code></em>), eax );
    and( (type dword <em class="replaceable"><code>source2</code></em>), eax );
    mov( eax, (type dword <em class="replaceable"><code>dest</code></em>) );

    mov( (type dword <em class="replaceable"><code>source1</code></em>[4]), eax );
    and( (type dword <em class="replaceable"><code>source2</code></em>[4]), eax );
    mov( eax, (type dword <em class="replaceable"><code>dest</code></em>[4]) );</pre><p>This technique easily extends to any number of words; all you need to do is logically <code class="literal">and</code> the corresponding bytes, words, or double words together in the operands. Note that this sequence sets the flags according to the value of the last <code class="literal">and</code> operation. If you <code class="literal">and</code> the H.O. double words last, this sets all but the zero flag correctly. If you need to test the zero flag after this sequence, you will need to logically <code class="literal">or</code> the two resulting double words together (or otherwise compare them both against 0).</p></div><div class="sect2" title="8.1.9 Extended-Precision or Operations"><div class="titlepage"><div><div><h2 class="title"><a id="extended-precision_or_operations"/>8.1.9 Extended-Precision or Operations</h2></div></div></div><p>Multibyte logical <code class="literal">or</code> operations are performed in the same way as multibyte <code class="literal">and</code> operations. You simply <code class="literal">or</code> the corresponding bytes in the two operands together. For example, to logically <code class="literal">or</code> two 96-bit values, use the following code:</p><a id="I_programlisting8_d1e43097"/><pre class="programlisting">mov( (type dword <em class="replaceable"><code>source1</code></em>), eax );
    or( (type dword <em class="replaceable"><code>source2</code></em>), eax );
    mov( eax, (type dword <em class="replaceable"><code>dest</code></em>) );

    mov( (type dword <em class="replaceable"><code>source1</code></em>[4]), eax );
    or( (type dword <em class="replaceable"><code>source2</code></em>[4]), eax );
    mov( eax, (type dword <em class="replaceable"><code>dest</code></em>[4]) );

    mov( (type dword <em class="replaceable"><code>source1</code></em>[8]), eax );
    or( (type dword <em class="replaceable"><code>source2</code></em>[8]), eax );
    mov( eax, (type dword <em class="replaceable"><code>dest</code></em>[8]) );</pre><p>As for the previous example, this does not set the zero flag properly for the entire operation. If you need to test the zero flag after a multiprecision <code class="literal">or</code>, you must logically <code class="literal">or</code> all the resulting double words together.</p></div><div class="sect2" title="8.1.10 Extended-Precision xor Operations"><div class="titlepage"><div><div><h2 class="title"><a id="extended-precision_xor_operations"/>8.1.10 Extended-Precision xor Operations</h2></div></div></div><p>Extended-precision <code class="literal">xor</code> operations are performed in a manner identical to <code class="literal">and</code>/<code class="literal">or</code>—simply <code class="literal">xor</code> the corresponding bytes in the two operands to obtain the extended-precision result. The following code sequence operates on two 64-bit operands, computes their exclusive-<code class="literal">or</code>, and stores the result into a 64-bit variable:<a class="indexterm" id="IDX-CHP-8-0083"/><a class="indexterm" id="IDX-CHP-8-0084"/></p><a id="I_programlisting8_d1e43167"/><pre class="programlisting">mov( (type dword <em class="replaceable"><code>source1</code></em>), eax );
    xor( (type dword <em class="replaceable"><code>source2</code></em>), eax );
    mov( eax, (type dword <em class="replaceable"><code>dest</code></em>) );

    mov( (type dword <em class="replaceable"><code>source1</code></em>[4]), eax );
    xor( (type dword <em class="replaceable"><code>source2</code></em>[4]), eax );
    mov( eax, (type dword <em class="replaceable"><code>dest</code></em>[4]) );</pre><p>The comment about the zero flag in the previous two sections applies here.</p></div><div class="sect2" title="8.1.11 Extended-Precision not Operations"><div class="titlepage"><div><div><h2 class="title"><a id="extended-precision_not_operations"/>8.1.11 Extended-Precision not Operations</h2></div></div></div><p>The <code class="literal">not</code> instruction inverts all the bits in the specified operand. An extended-precision <code class="literal">not</code> is performed by simply executing the <code class="literal">not</code> instruction on all the affected operands. For example, to perform a 64-bit <code class="literal">not</code> operation on the value in <code class="literal">(edx:eax)</code>, all you need to do is execute the following instructions:<a class="indexterm" id="IDX-CHP-8-0085"/></p><a id="I_programlisting8_d1e43216"/><pre class="programlisting">not( eax );
    not( edx );</pre><p>Keep in mind that if you execute the <code class="literal">not</code> instruction twice, you wind up with the <code class="literal">or</code>iginal value. Also note that exclusive-<code class="literal">or</code>ing a value with all 1s ($FF, $FFFF, or $FFFF_FFFF) performs the same operation as the <code class="literal">not</code> instruction.</p></div><div class="sect2" title="8.1.12 Extended-Precision Shift Operations"><div class="titlepage"><div><div><h2 class="title"><a id="extended-precision_shift_operations"/>8.1.12 Extended-Precision Shift Operations</h2></div></div></div><p>Extended-precision shift operations require a shift and a rotate instruction. Consider what must happen to implement a 64-bit <code class="literal">shl</code> using 32-bit operations (see <a class="xref" href="ch08.html#bit_shift-left_operation" title="Figure 8-5. 64-bit shift-left operation">Figure 8-5</a>):</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>A 0 must be shifted into bit 0.</p></li><li class="listitem"><p>Bits 0 through 30 are shifted into the next-higher bit.</p></li><li class="listitem"><p>Bit 31 is shifted into bit 32.</p></li><li class="listitem"><p>Bits 32 through 62 must be shifted into the next-higher bit.</p></li><li class="listitem"><p>Bit 63 is shifted into the carry flag.</p></li></ol></div><div class="figure"><a id="bit_shift-left_operation"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject8_d1e43261"/><img alt="64-bit shift-left operation" src="tagoreillycom20100401nostarchimages578051.png.jpg"/></div></div><p class="title">Figure 8-5. 64-bit shift-left operation</p></div><p>The two instructions you can use to implement this 64-bit shift are <code class="literal">shl</code> and <code class="literal">rcl</code>. For example, to shift the 64-bit quantity in (EDX:EAX) one position to the left, you'd use the following instructions:</p><a id="I_programlisting8_d1e43274"/><pre class="programlisting">shl( 1, eax );
    rcl( 1, eax );</pre><p>Note that using this technique you can shift an extended-precision value only 1 bit at a time. You cannot shift an extended-precision operand several bits using the CL register. Nor can you specify a constant value greater than 1 using this technique.</p><p>To understand how this instruction sequence works, consider the operation of the individual instructions. The <code class="literal">shl</code> instruction shifts a 0 into bit 0 of the 64-bit operand and shifts bit 31 into the carry flag. The <code class="literal">rcl</code> instruction then shifts the carry flag into bit 32 and then shifts bit 63 into the carry flag. The result is exactly what we want.</p><p>To perform a shift left on an operand larger than 64 bits, you simply use additional <code class="literal">rcl</code> instructions. An extended-precision shift-left operation always starts with the least-significant double word, and each succeeding <code class="literal">rcl</code> instruction operates on the next-most-significant double word. For example, to perform a 96-bit shift-left operation on a memory location, you could use the following instructions:</p><a id="I_programlisting8_d1e43294"/><pre class="programlisting">shl( 1, (type dword <em class="replaceable"><code>Operand</code></em>[0]) );
    rcl( 1, (type dword <em class="replaceable"><code>Operand</code></em>[4])  );
    rcl( 1, (type dword <em class="replaceable"><code>Operand</code></em>[8])  );</pre><p>If you need to shift your data by 2 or more bits, you can either repeat the above sequence the desired number of times (for a constant number of shifts) or you can place the instructions in a loop to repeat them some number of times. For example, the following code shifts the 96-bit value <em class="replaceable"><code>Operand</code></em> to the left the number of bits specified in ECX:</p><a id="I_programlisting8_d1e43311"/><pre class="programlisting">ShiftLoop:
    shl( 1, (type dword <em class="replaceable"><code>Operand</code></em>[0]) );
    rcl( 1, (type dword <em class="replaceable"><code>Operand</code></em>[4]) );
    rcl( 1, (type dword <em class="replaceable"><code>Operand</code></em>[8]) );
    dec( ecx );
    jnz ShiftLoop;</pre><p>You implement <code class="literal">shr</code> and <code class="literal">sar</code> in a similar way, except you must start at the H.O. word of the operand and work your way down to the L.O. word:<a class="indexterm" id="IDX-CHP-8-0086"/><a class="indexterm" id="IDX-CHP-8-0087"/><a class="indexterm" id="IDX-CHP-8-0088"/></p><a id="I_programlisting8_d1e43341"/><pre class="programlisting">// Extended-precision SAR:

    sar( 1, (type dword <em class="replaceable"><code>Operand</code></em>[8]) );
    rcr( 1, (type dword <em class="replaceable"><code>Operand</code></em>[4]) );
    rcr( 1, (type dword <em class="replaceable"><code>Operand</code></em>[0]) );

// Double-precision SHR:

    shr( 1, (type dword <em class="replaceable"><code>Operand</code></em>[8]) );
    rcr( 1, (type dword <em class="replaceable"><code>Operand</code></em>[4]) );
    rcr( 1, (type dword <em class="replaceable"><code>Operand</code></em>[0]) );</pre><p>There is one major difference between the extended-precision shifts described here and their 8/16/32-bit counterparts—the extended-precision shifts set the flags differently than the single-precision operations. This is because the rotate instructions affect the flags differently than the shift instructions. Fortunately, the carry flag is the one you'll test most often after a shift operation, and the extended-precision shift operations (i.e., rotate instructions) properly set this flag.</p><p>The <code class="literal">shld</code> and <code class="literal">shrd</code> instructions let you efficiently implement multiprecision shifts of several bits. These instructions have the following syntax:<a class="indexterm" id="IDX-CHP-8-0089"/><a class="indexterm" id="IDX-CHP-8-0090"/></p><a id="I_programlisting8_d1e43382"/><pre class="programlisting">shld( <em class="replaceable"><code>constant</code></em>, <em class="replaceable"><code>Operand1</code></em>, <em class="replaceable"><code>Operand2</code></em> );
    shld( cl, <em class="replaceable"><code>Operand1</code></em>, <em class="replaceable"><code>Operand2</code></em> );
    shrd( <em class="replaceable"><code>constant</code></em>, <em class="replaceable"><code>Operand1</code></em>, <em class="replaceable"><code>Operand2</code></em> );
    shrd( cl, <em class="replaceable"><code>Operand1</code></em>, <em class="replaceable"><code>Operand2</code></em> );</pre><p>The <code class="literal">shld</code> instruction works as shown in <a class="xref" href="ch08.html#shld_operation" title="Figure 8-6. shld operation">Figure 8-6</a>.</p><div class="figure"><a id="shld_operation"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject8_d1e43427"/><img alt="shld operation" src="tagoreillycom20100401nostarchimages578053.png.jpg"/></div></div><p class="title">Figure 8-6. <code class="literal">shld</code> operation</p></div><p><em class="replaceable"><code>Operand1</code></em> must be a 16- or 32-bit register. <em class="replaceable"><code>Operand2</code></em> can be a register or a memory location. Both operands must be the same size. The immediate operand can be a value in the range 0 through <span class="emphasis"><em>n</em></span>−1, where <span class="emphasis"><em>n</em></span> is the number of bits in the two operands; this operand specifies the number of bits to shift.</p><p>The <code class="literal">shld</code> instruction shifts bits in <em class="replaceable"><code>Operand2</code></em> to the left. The H.O. bits shift into the carry flag, and the H.O. bits of <em class="replaceable"><code>Operand1</code></em> shift into the L.O. bits of <em class="replaceable"><code>Operand2</code></em>. Note that this instruction does not modify the value of <em class="replaceable"><code>Operand1</code></em>; it uses a temporary copy of <em class="replaceable"><code>Operand1</code></em> during the shift. The immediate operand specifies the number of bits to shift. If the count is <span class="emphasis"><em>n</em></span>, then <code class="literal">shld</code> shifts bit <span class="emphasis"><em>n</em></span>−1 into the carry flag. It also shifts the H.O. <span class="emphasis"><em>n</em></span> bits of <em class="replaceable"><code>Operand1</code></em> into the L.O. <span class="emphasis"><em>n</em></span> bits of <em class="replaceable"><code>Operand2</code></em>. The <code class="literal">shld</code> instruction sets the flag bits as follows:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>If the shift count is 0, the <code class="literal">shld</code> instruction doesn't affect any flags.</p></li><li class="listitem"><p>The carry flag contains the last bit shifted out of the H.O. bit of the <em class="replaceable"><code>Operand2</code></em>.</p></li><li class="listitem"><p>If the shift count is 1, the overflow flag will contain 1 if the sign bit of <em class="replaceable"><code>Operand2</code></em> changes during the shift. If the count is not 1, the overflow flag is undefined.</p></li><li class="listitem"><p>The zero flag will be 1 if the shift produces a 0 result.</p></li><li class="listitem"><p>The sign flag will contain the H.O. bit of the result.</p></li></ol></div><p>The <code class="literal">shrd</code> instruction is similar to <code class="literal">shld</code> except, of course, it shifts its bits right rather than left. To get a clear picture of the <code class="literal">shrd</code> instruction, consider <a class="xref" href="ch08.html#shrd_operation" title="Figure 8-7. shrd operation">Figure 8-7</a>.</p><div class="figure"><a id="shrd_operation"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject8_d1e43535"/><img alt="shrd operation" src="tagoreillycom20100401nostarchimages578055.png.jpg"/></div></div><p class="title">Figure 8-7. <code class="literal">shrd</code> operation</p></div><p>The <code class="literal">shrd</code> instruction sets the flag bits as follows:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>If the shift count is 0, the <code class="literal">shrd</code> instruction doesn't affect any flags.</p></li><li class="listitem"><p>The carry flag contains the last bit shifted out of the L.O. bit of the <em class="replaceable"><code>Operand2</code></em>.</p></li><li class="listitem"><p>If the shift count is 1, the overflow flag will contain 1 if the H.O. bit of <em class="replaceable"><code>Operand2</code></em> changes. If the count is not 1, the overflow flag is undefined.</p></li><li class="listitem"><p>The zero flag will be 1 if the shift produces a 0 result.</p></li><li class="listitem"><p>The sign flag will contain the H.O. bit of the result.</p></li></ol></div><p>Consider the following code sequence:</p><a id="I_programlisting8_d1e43572"/><pre class="programlisting">static
    ShiftMe: dword[3] := [ $1234, $5678, $9012 ];
     .
     .
     .
    mov( ShiftMe[4], eax )
    shld( 6, eax, ShiftMe[8] );
    mov( ShiftMe[0], eax );
    shld( 6, eax, ShiftMe[4] );
    shl( 6, ShiftMe[0] );</pre><p>The first <code class="literal">shld</code> instruction above shifts the bits from <code class="literal">ShiftMe[4]</code> into <code class="literal">ShiftMe[8]</code> without affecting the value in <code class="literal">ShiftMe[4]</code>. The second <code class="literal">shld</code> instruction shifts the bits from <code class="literal">ShiftMe</code> into <code class="literal">ShiftMe[4]</code>. Finally, the <code class="literal">shl</code> instruction shifts the L.O. double word the appropriate amount. There are two important things to note about this code. First, unlike the other extended-precision shift-left operations, this sequence works from the H.O. double word down to the L.O. double word. Second, the carry flag does not contain the carry from the H.O. shift operation. If you need to preserve the carry flag at that point, you will need to push the flags after the first <code class="literal">shld</code> instruction and pop the flags after the <code class="literal">shl</code> instruction.<a class="indexterm" id="IDX-CHP-8-0091"/><a class="indexterm" id="IDX-CHP-8-0092"/></p><p>You can do an extended-precision shift-right operation using the <code class="literal">shrd</code> instruction. It works almost the same way as the code sequence above, except you work from the L.O. double word to the H.O. double word. The solution is left as an exercise for the reader.</p></div><div class="sect2" title="8.1.13 Extended-Precision Rotate Operations"><div class="titlepage"><div><div><h2 class="title"><a id="extended-precision_rotate_operations"/>8.1.13 Extended-Precision Rotate Operations</h2></div></div></div><p>The <code class="literal">rcl</code> and <code class="literal">rcr</code> operations extend in a manner almost identical to <code class="literal">shl</code> and <code class="literal">shr</code>. For example, to perform 96-bit <code class="literal">rcl</code> and <code class="literal">rcr</code> operations, use the following instructions:</p><a id="I_programlisting8_d1e43645"/><pre class="programlisting">rcl( 1, (type dword <em class="replaceable"><code>Operand</code></em>[0]) );
    rcl( 1, (type dword <em class="replaceable"><code>Operand</code></em>[4])  );
    rcl( 1, (type dword <em class="replaceable"><code>Operand</code></em>[8])  );

    rcr( 1, (type dword <em class="replaceable"><code>Operand</code></em>[8]) );
    rcr( 1, (type dword <em class="replaceable"><code>Operand</code></em>[4])  );
    rcr( 1, (type dword <em class="replaceable"><code>Operand</code></em>[0])  );</pre><p>The only difference between this code and the code for the extended-precision shift operations is that the first instruction is a <code class="literal">rcl</code> or <code class="literal">rcr</code> rather than a <code class="literal">shl</code> or <code class="literal">shr</code> instruction.</p><p>Performing an extended-precision <code class="literal">rol</code> or <code class="literal">ror</code> operation isn't quite as simple. You can use the <code class="literal">bt</code>, <code class="literal">shld</code>, and <code class="literal">shrd</code> instructions to implement an extended-precision <code class="literal">rol</code> or <code class="literal">ror</code> instruction. The following code shows how to use the <code class="literal">shld</code> instruction to do an extended-precision <code class="literal">rol</code>:</p><a id="I_programlisting8_d1e43710"/><pre class="programlisting">// Compute rol( 4, edx:eax );

        mov( edx, ebx );
        shld, 4, eax, edx );
        shld( 4, ebx, eax );
        bt( 0, eax );        // Set carry flag, if desired.</pre><p>An extended-precision <code class="literal">ror</code> instruction is similar; just keep in mind that you work on the L.O. end of the object first and the H.O. end last.<a class="indexterm" id="IDX-CHP-8-0093"/><a class="indexterm" id="IDX-CHP-8-0094"/></p></div><div class="sect2" title="8.1.14 Extended-Precision I/O"><div class="titlepage"><div><div><h2 class="title"><a id="extended-precision_i_solidus_o"/>8.1.14 Extended-Precision I/O</h2></div></div></div><p>Once you can do extended-precision arithmetic, the next problem is how to get those extended-precision values into your program and how to display their values to the user. HLA's Standard Library provides routines for unsigned decimal, signed decimal, and hexadecimal I/O for values that are 8, 16, 32, 64, or 128 bits in length. So as long as you're working with values whose size is less than or equal to 128 bits in length, you can use the Standard Library code. If you need to input or output values that are greater than 128 bits in length, you will need to write your own procedures to handle the operation. This section discusses the strategies you will need to write such routines.<a class="indexterm" id="IDX-CHP-8-0095"/></p><p>The examples in this section work specifically with 128-bit values. The algorithms are perfectly general and extend to any number of bits (indeed, the 128-bit algorithms in this section are really nothing more than the algorithms the HLA Standard Library uses for 128-bit values). Of course, if you need a set of 128-bit unsigned I/O routines, you can use the Standard Library code as is. If you need to handle larger values, simple modifications to the following code are all that should be necessary.</p><p>The sections that follow use a common set of 128-bit data types in order to avoid having to coerce <code class="literal">lword</code>/<code class="literal">uns128</code>/<code class="literal">int128</code> values in each instruction. Here are these types:</p><a id="I_programlisting8_d1e43748"/><pre class="programlisting">type
    h128        :dword[4];
    u128        :dword[4];
    i128        :dword[4];</pre><div class="sect3" title="8.1.14.1 Extended-Precision Hexadecimal Output"><div class="titlepage"><div><div><h3 class="title"><a id="extended-precision_hexadecimal_output"/>8.1.14.1 Extended-Precision Hexadecimal Output</h3></div></div></div><p>Extended-precision hexadecimal output is very easy. All you have to do is output each double-word component of the extended-precision value from the H.O. double word to the L.O. double word using a call to the <code class="literal">stdout.puth32</code> routine. The following procedure does exactly this to output an <code class="literal">lword</code> value:<a class="indexterm" id="IDX-CHP-8-0096"/></p><a id="I_programlisting8_d1e43766"/><pre class="programlisting">procedure puth128( b128: h128 ); @nodisplay;
begin puth128;

    stdout.puth32( b128[12] );
    stdout.puth32( b128[8] );
    stdout.puth32( b128[4] );
    stdout.puth32( b128[0] );

end puth128;</pre><p>Of course, the HLA Standard Library supplies a <code class="literal">stdout.puth128</code> procedure that directly writes <code class="literal">lword</code> values, so you can call <code class="literal">stdout.puth128</code> multiple times when outputting larger values (e.g., a 256-bit value). As it turns out, the implementation of the HLA <code class="literal">stdlib.puth128</code> routine is very similar to <code class="literal">puth128</code>, above.<a class="indexterm" id="IDX-CHP-8-0097"/><a class="indexterm" id="IDX-CHP-8-0098"/></p></div><div class="sect3" title="8.1.14.2 Extended-Precision Unsigned Decimal Output"><div class="titlepage"><div><div><h3 class="title"><a id="extended-precision_unsigned_decimal_outp"/>8.1.14.2 Extended-Precision Unsigned Decimal Output</h3></div></div></div><p>Decimal output is a little more complicated than hexadecimal output because the H.O. bits of a binary number affect the L.O. digits of the decimal representation (this was not true for hexadecimal values, which is why hexadecimal output is so easy). Therefore, we will have to create the decimal representation for a binary number by extracting one decimal digit at a time from the number.</p><p>The most common solution for unsigned decimal output is to successively divide the value by 10 until the result becomes 0. The remainder after the first division is a value in the range 0..9, and this value corresponds to the L.O. digit of the decimal number. Successive divisions by 10 (and their corresponding remainder) extract successive digits from the number.</p><p>Iterative solutions to this problem generally allocate storage for a string of characters large enough to hold the entire number. Then the code extracts the decimal digits in a loop and places them in the string one by one. At the end of the conversion process, the routine prints the characters in the string in reverse order (remember, the divide algorithm extracts the L.O. digits first and the H.O. digits last, the opposite of the way you need to print them).</p><p>In this section, we employ a recursive solution because it is a little more elegant. The recursive solution begins by dividing the value by 10 and saving the remainder in a local variable. If the quotient is not 0, the routine recursively calls itself to print any leading digits first. On return from the recursive call (which prints all the leading digits), the recursive algorithm prints the digit associated with the remainder to complete the operation. Here's how the operation works when printing the decimal value 789:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Divide 789 by 10. Quotient is 78, and remainder is 9.</p></li><li class="listitem"><p>Save the remainder (9) in a local variable and recursively call the routine with the quotient.</p></li><li class="listitem"><p>[Recursive entry 1] Divide 78 by 10. Quotient is 7, and remainder is 8.</p></li><li class="listitem"><p>Save the remainder (8) in a local variable and recursively call the routine with the quotient.</p></li><li class="listitem"><p>[Recursive entry 2] Divide 7 by 10. Quotient is 0, and remainder is 7.</p></li><li class="listitem"><p>Save the remainder (7) in a local variable. Because the quotient is 0, don't call the routine recursively.</p></li><li class="listitem"><p>Output the remainder value saved in the local variable (7). Return to the caller (recursive entry 1).</p></li><li class="listitem"><p>[Return to recursive entry 1] Output the remainder value saved in the local variable in recursive entry 1 (8). Return to the caller (original invocation of the procedure).</p></li><li class="listitem"><p>[Original invocation] Output the remainder value saved in the local variable in the original call (9). Return to the original caller of the output routine.</p></li></ol></div><p>The only operation that requires extended-precision calculation through this entire algorithm is the "divide by 10" statement. Everything else is simple and straightforwar. We are in luck with this algorithm, because we are dividing an extended-precision value by a value that easily fits into a double word, and we can use the fast (and easy) extended-precision division algorithm that uses the <code class="literal">div</code> instruction. The program in <a class="xref" href="ch08.html#bit_extended-precision_decimal_output_r" title="Example 8-4. 128-bit extended-precision decimal output routine">Example 8-4</a> implements a 128-bit decimal output routine utilizing this technique.</p><div class="example"><a id="bit_extended-precision_decimal_output_r"/><p class="title">Example 8-4. 128-bit extended-precision decimal output routine</p><div class="example-contents"><pre class="programlisting">program out128;

#include( "stdlib.hhf" );

// 128-bit unsigned integer data type:

type
    u128: dword[4];



// DivideBy10-
//
//  Divides "divisor" by 10 using fast
//  extended-precision division algorithm
//  that employs the div instruction.
//
//  Returns quotient in "quotient".
//  Returns remainder in eax.
//  Trashes ebx, edx, and edi.

procedure DivideBy10( dividend:u128; var quotient:u128 ); @nodisplay;
begin DivideBy10;

    mov( quotient, edi );
    xor( edx, edx );
    mov( dividend[12], eax );
    mov( 10, ebx );
    div( ebx, edx:eax );
    mov( eax, [edi+12] );

    mov( dividend[8], eax );
    div( ebx, edx:eax );
    mov( eax, [edi+8] );

    mov( dividend[4], eax );
    div( ebx, edx:eax );
    mov( eax, [edi+4] );

    mov( dividend[0], eax );
    div( ebx, edx:eax );
    mov( eax, [edi+0] );
    mov( edx, eax );

end DivideBy10;



// Recursive version of putu128.
// A separate "shell" procedure calls this so that
// this code does not have to preserve all the registers
// it uses (and DivideBy10 uses) on each recursive call.

procedure recursivePutu128( b128:u128 ); @nodisplay;
var
    remainder: byte;

begin recursivePutu128;

    // Divide by 10 and get the remainder (the char to print).

    DivideBy10( b128, b128 );
    mov( al, remainder );       // Save away the remainder (0..9).

    // If the quotient (left in b128) is not 0, recursively
    // call this routine to print the H.O. digits.

    mov( b128[0], eax );    // If we logically OR all the dwords
    or( b128[4], eax );     // together, the result is 0 if and
    or( b128[8], eax );     // only if the entire number is 0.
    or( b128[12], eax );
    if( @nz ) then

        recursivePutu128( b128 );

    endif;

    // Okay, now print the current digit.

    mov( remainder, al );
    or( '0', al );          // Converts 0..9 -&gt; '0'..'9'.
    stdout.putc( al );

end recursivePutu128;


// Nonrecursive shell to the above routine so we don't bother
// saving all the registers on each recursive call.

procedure putu128( b128:u128 ); @nodisplay;
begin putu128;

    push( eax );
    push( ebx );
    push( edx );
    push( edi );

    recursivePutu128( b128 );

    pop( edi );
    pop( edx );
    pop( ebx );
    pop( eax );

end putu128;



// Code to test the routines above:

static
    b0: u128 := [0, 0, 0, 0];             // decimal = 0
    b1: u128 := [1234567890, 0, 0, 0];    // decimal = 1234567890
    b2: u128 := [$8000_0000, 0, 0, 0];    // decimal = 2147483648
    b3: u128 := [0, 1, 0, 0 ];            // decimal = 4294967296

    // Largest uns128 value
    // (decimal=340,282,366,920,938,463,463,374,607,431,768,211,455):

    b4: u128 := [$FFFF_FFFF, $FFFF_FFFF, $FFFF_FFFF, $FFFF_FFFF ];

begin out128;

    stdout.put( "b0 = " );
    putu128( b0 );
    stdout.newln();

    stdout.put( "b1 = " );
    putu128( b1 );
    stdout.newln();

    stdout.put( "b2 = " );
    putu128( b2 );
    stdout.newln();

    stdout.put( "b3 = " );
    putu128( b3 );
    stdout.newln();

    stdout.put( "b4 = " );
    putu128( b4 );
    stdout.newln();

end out128;</pre></div></div></div><div class="sect3" title="8.1.14.3 Extended-Precision Signed Decimal Output"><div class="titlepage"><div><div><h3 class="title"><a id="extended-precision_signed_decimal_output"/>8.1.14.3 Extended-Precision Signed Decimal Output</h3></div></div></div><p>Once you have an extended-precision unsigned decimal output routine, writing an extended-precision signed decimal output routine is very easy. The basic algorithm takes the following form:<a class="indexterm" id="IDX-CHP-8-0099"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Check the sign of the number.</p></li><li class="listitem"><p>If it is positive, call the unsigned output routine to print it. If the number is negative, print a minus sign. Then negate the number and call the unsigned output routine to print it.</p></li></ol></div><p>To check the sign of an extended-precision integer, of course, you simply test the H.O. bit of the number. To negate a large value, the best solution is probably to subtract that value from 0. Here's a quick version of <code class="literal">puti128</code> that uses the <code class="literal">putu128</code> routine from the previous section:<a class="indexterm" id="IDX-CHP-8-0100"/><a class="indexterm" id="IDX-CHP-8-0101"/></p><a id="I_programlisting8_d1e43874"/><pre class="programlisting">procedure puti128( i128: u128 ); @nodisplay;
begin puti128;

    if( (type int32 i128[12]) &lt; 0 ) then

        stdout.put( '-' );

        // Extended-precision Negation:

        push( eax );
        mov( 0, eax );
        sub( i128[0], eax );
        mov( eax, i128[0] );

        mov( 0, eax );
        sbb( i128[4], eax );
        mov( eax, i128[4] );

        mov( 0, eax );
        sbb( i128[8], eax );
        mov( eax, i128[8] );

        mov( 0, eax );
        sbb( i128[12], eax );
        mov( eax, i128[12] );
        pop( eax );

    endif;
    putu128( i128 );

end puti128;</pre></div><div class="sect3" title="8.1.14.4 Extended-Precision Formatted Output"><div class="titlepage"><div><div><h3 class="title"><a id="extended-precision_formatted_output"/>8.1.14.4 Extended-Precision Formatted Output</h3></div></div></div><p>The code in the previous two sections prints signed and unsigned integers using the minimum number of necessary print positions. To create nicely formatted tables of values you will need the equivalent of a <code class="literal">puti128Size</code> or <code class="literal">putu128Size</code> routine. Once you have the "unformatted" versions of these routines, implementing the formatted versions is very easy.<a class="indexterm" id="IDX-CHP-8-0102"/><a class="indexterm" id="IDX-CHP-8-0103"/><a class="indexterm" id="IDX-CHP-8-0104"/><a class="indexterm" id="IDX-CHP-8-0105"/></p><p>The first step is to write <code class="literal">i128Size</code> and <code class="literal">u128Size</code> routines that compute the minimum number of digits needed to display the value. The algorithm to accomplish this is very similar to the numeric output routines. In fact, the only difference is that you initialize a counter to 0 upon entry into the routine (for example, the nonrecursive shell routine), and you increment this counter rather than outputting a digit on each recursive call. (Don't forget to increment the counter inside <code class="literal">i128Size</code> if the number is negative; you must allow for the output of the minus sign.) After the calculation is complete, these routines should return the size of the operand in the EAX register.</p><p>Once you have the <code class="literal">i128Size</code> and <code class="literal">u128Size</code> routines, writing the formatted output routines is easy. Upon initial entry into <code class="literal">puti128Size</code> or <code class="literal">putu128Size</code>, these routines call the corresponding <code class="literal">size</code> routine to determine the number of print positions for the number to display. If the value that the <code class="literal">size</code> routine returns is greater than the absolute value of the minimum size parameter (passed into <code class="literal">puti128Size</code> or <code class="literal">putu128Size</code>), all you need to do is call the <code class="literal">put</code> routine to print the value; no other formatting is necessary. If the absolute value of the parameter size is greater than the value <code class="literal">i128Size</code> or <code class="literal">u128Size</code> returns, then the program must compute the difference between these two values and print that many spaces (or other filler characters) before printing the number (if the parameter size value is positive) or after printing the number (if the parameter size value is negative). The actual implementation of these two routines is left as an exercise to the reader (or just check out the source code in the HLA Standard Library for the <code class="literal">stdout.putiSize128</code> and <code class="literal">stdout.putuSize128</code> routines).</p><p>The HLA Standard Library implements the <code class="literal">i128Size</code> and <code class="literal">u128Size</code> by doing a set of successive extended-precision comparisons to determine the number of digits in the values. Interested readers may want to look at the source code for these routines as well as the source code for the <code class="literal">stdout.puti128</code> and <code class="literal">stdout.putu128</code> procedures (this source code appears on Webster at <a class="ulink" href="http://webster.cs.ucr.edu/">http://webster.cs.ucr.edu/</a> or <a class="ulink" href="http://www.artofasm.com/">http://www.artofasm.com/</a>).<a class="indexterm" id="IDX-CHP-8-0106"/><a class="indexterm" id="IDX-CHP-8-0107"/></p></div><div class="sect3" title="8.1.14.5 Extended-Precision Input Routines"><div class="titlepage"><div><div><h3 class="title"><a id="extended-precision_input_routines"/>8.1.14.5 Extended-Precision Input Routines</h3></div></div></div><p>There are a couple of fundamental differences between the extended-precision output routines and the extended-precision input routines. First of all, numeric output generally occurs without possibility of error;<sup>[<a class="footnote" href="#ftn.CHP-8-FN-3" id="CHP-8-FN-3">113</a>]</sup> numeric input, on the other hand, must handle the very real possibility of an input error such as illegal characters and numeric overflow. Also, HLA's Standard Library and runtime system encourage a slightly different approach to input conversion. This section discusses those issues that differentiate input conversion from output conversion.<a class="indexterm" id="IDX-CHP-8-0108"/><a class="indexterm" id="IDX-CHP-8-0109"/></p><p>Perhaps the biggest difference between input and output conversion is the fact that output conversion is not bracketed. That is, when converting a numeric value to a string of characters for output, the output routine does not concern itself with characters preceding the output string, nor is it concerned with the characters following the numeric value in the output stream. Numeric output routines convert their data to a string and print that string without considering the context (that is, the characters before and after the string representation of the numeric value). Numeric input routines cannot be so cavalier; the contextual information surrounding the numeric string is very important.</p><p>A typical numeric input operation consists of reading a string of characters from the user and then translating this string of characters into an internal numeric representation. For example, a statement like <code class="literal">stdin.get(i32)</code>; typically reads a line of text from the user and converts a sequence of digits appearing at the beginning of that line of text into a 32-bit signed integer (assuming <code class="literal">i32</code> is an <code class="literal">int32</code> object). Note, however, that the <code class="literal">stdin.get</code> routine skips over certain characters in the string that may appear before the actual numeric characters. For example, <code class="literal">stdin.get</code> automatically skips any leading spaces in the string. Likewise, the input string may contain additional data beyond the end of the numeric input (for example, it is possible to read two integer values from the same input line), and therefore the input conversion routine must somehow determine where the numeric data ends in the input stream. Fortunately, HLA provides a simple mechanism that lets you easily determine the start and end of the input data: the <code class="literal">Delimiters</code> character set.<a class="indexterm" id="IDX-CHP-8-0110"/></p><p>The <code class="literal">Delimiters</code> character set is a variable, internal to the HLA Standard Library, that contains the set of legal characters that may precede or follow a legal numeric value. By default, this character set includes the end-of-string marker (a 0 byte), a tab character, a line-feed character, a carriage-return character, a space, a comma, a colon, and a semicolon. Therefore, HLA's numeric input routines will automatically ignore any characters in this set that occur on input before a numeric string. Likewise, characters from this set may legally follow a numeric string on input (conversely, if any non-delimiter character follows the numeric string, HLA will raise an <code class="literal">ex.ConversionError</code> exception).<a class="indexterm" id="IDX-CHP-8-0111"/></p><p>The <code class="literal">Delimiters</code> character set is a private variable inside the HLA Standard Library. Although you do not have direct access to this object, the HLA Standard Library does provide two accessor functions, <code class="literal">conv.setDelimiters</code> and <code class="literal">conv.getDelimiters</code>, that let you access and modify the value of this character set. These two functions have the following prototypes (found in the <span class="emphasis"><em>conv.hhf</em></span> header file):<a class="indexterm" id="IDX-CHP-8-0112"/><a class="indexterm" id="IDX-CHP-8-0113"/><a class="indexterm" id="IDX-CHP-8-0114"/></p><a id="I_programlisting8_d1e44070"/><pre class="programlisting">procedure conv.setDelimiters( Delims:cset );
procedure conv.getDelimiters( var Delims:cset );</pre><p>The <code class="literal">conv.setDelimiters</code> procedure will copy the value of the <code class="literal">Delims</code> parameter into the internal <code class="literal">Delimiters</code> character set. Therefore, you can use this procedure to change the character set if you want to use a different set of delimiters for numeric input. The <code class="literal">conv.getDelimiters</code> call returns a copy of the internal <code class="literal">Delimiters</code> character set in the variable you pass as a parameter to the <code class="literal">conv.getDelimiters</code> procedure. We will use the value returned by <code class="literal">conv.getDelimiters</code> to determine the end of numeric input when writing our own extended-precision numeric input routines.</p><p>When reading a numeric value from the user, the first step is to get a copy of the <code class="literal">Delimiters</code> character set. The second step is to read and discard input characters from the user as long as those characters are members of the <code class="literal">Delimiters</code> character set. Once a character is found that is not in the <code class="literal">Delimiters</code> set, the input routine must check this character and verify that it is a legal numeric character. If not, the program should raise an <code class="literal">ex.IllegalChar</code> exception if the character's value is outside the range $00..$7F, or it should raise the <code class="literal">ex.ConversionError</code> exception if the character is not a legal numeric character. Once the routine encounters a numeric character, it should continue reading characters as long as they are valid numeric characters; while reading the characters, the conversion routine should be translating them to the internal representation of the numeric data. If, during conversion, an overflow occurs, the procedure should raise the <code class="literal">ex.ValueOutOfRange</code> exception.<a class="indexterm" id="IDX-CHP-8-0115"/></p><p>Conversion to numeric representation should end when the procedure encounters the first delimiter character at the end of the string of digits. However, it is very important that the procedure does not consume the delimiter character that ends the string. That is, the following is incorrect:</p><a id="I_programlisting8_d1e44124"/><pre class="programlisting">static
    Delimiters: cset;
         .
         .
         .
    conv.getDelimiters( Delimiters );

    // Skip over leading delimiters in the string:

    while( stdin.getc() in Delimiters ) do  /* getc did the work */ endwhile;
    while( al in '0'..'9') do

        // Convert character in al to numeric representation and
        // accumulate result...

        stdin.getc();

    endwhile;
    if( al not in Delimiters ) then

        raise( ex.ConversionError );

    endif;</pre><p>The first <code class="literal">while</code> loop reads a sequence of delimiter characters. When this first <code class="literal">while</code> loop ends, the character in AL is not a delimiter character. The second <code class="literal">while</code> loop processes a sequence of decimal digits. First, it checks the character read in the previous <code class="literal">while</code> loop to see if it is a decimal digit; if so, it processes that digit and reads the next character. This process continues until the call to <code class="literal">stdin.getc</code> (at the bottom of the loop) reads a nondigit character. After the second <code class="literal">while</code> loop, the program checks the last character read to ensure that it is a legal delimiter character for a numeric input value.<a class="indexterm" id="IDX-CHP-8-0116"/></p><p>The problem with this algorithm is that it consumes the delimiter character after the numeric string. For example, the colon symbol is a legal delimiter in the default <code class="literal">Delimiters</code> character set. If the user types the input <strong class="userinput"><code>123:456</code></strong> and executes the code above, this code will properly convert <code class="literal">123</code> to the numeric value 123. However, the very next character read from the input stream will be the character 4, not the colon character (:). While this may be acceptable in certain circumstances, most programmers expect numeric input routines to consume only leading delimiter characters and the numeric digit characters. They do not expect the input routine to consume any trailing delimiter characters (for example, many programs will read the next character and expect a colon as input if presented with the string <code class="literal">123:456</code>). Because <code class="literal">stdin.getc</code> consumes an input character, and there is no way to put the character back onto the input stream, some other way of reading input characters from the user that doesn't consume those characters is needed.<sup>[<a class="footnote" href="#ftn.CHP-8-FN-4" id="CHP-8-FN-4">114</a>]</sup></p><p>The HLA Standard Library comes to the rescue by providing the <code class="literal">stdin.peekc</code> function. Like <code class="literal">stdin.getc</code>, the <code class="literal">stdin.peekc</code> routine reads the next input character from HLA's internal buffer. There are two major differences between <code class="literal">stdin.peekc</code> and <code class="literal">stdin.getc</code>. First, <code class="literal">stdin.peekc</code> will not force the input of a new line of text from the user if the current input line is empty (or you've already read all the text from the input line). Instead, <code class="literal">stdin.peekc</code> simply returns 0 in the AL register to indicate that there are no more characters on the input line. Because #0 (the NUL character) is (by default) a legal delimiter character for numeric values, and the end of line is certainly a legal way to terminate numeric input, this works out rather well. The second difference between <code class="literal">stdin.getc</code> and <code class="literal">stdin.peekc</code> is that <code class="literal">stdin.peekc</code> does not consume the character read from the input buffer. If you call <code class="literal">stdin.peekc</code> several times in a row, it will always return the same character; likewise, if you call <code class="literal">stdin.getc</code> immediately after <code class="literal">stdin.peekc</code>, the call to <code class="literal">stdin.getc</code> will generally return the same character as returned by <code class="literal">stdin.peekc</code> (the only exception being the end-of-line condition). So, although we cannot put characters back onto the input stream after we've read them with <code class="literal">stdin.getc</code>, we can peek ahead at the next character on the input stream and base our logic on that character's value. A corrected version of the previous algorithm might be the following:<a class="indexterm" id="IDX-CHP-8-0117"/><a class="indexterm" id="IDX-CHP-8-0118"/></p><a id="I_programlisting8_d1e44235"/><pre class="programlisting">static
    Delimiters: cset;
         .
         .
         .
        conv.getDelimiters( Delimiters );

    // Skip over leading delimiters in the string:

    while( stdin.peekc() in Delimiters ) do

        // If at the end of the input buffer, we must explicitly read a
        // new line of text from the user. stdin.peekc does not do this
        // for us.

        if( al = #0 ) then

            stdin.ReadLn();

        else

            stdin.getc();  // Remove delimiter from the input stream.

        endif;

    endwhile;
    while( stdin.peekc in '0'..'9') do

        stdin.getc();     // Remove the input character from the input stream.

        // Convert character in al to numeric representation and
        // accumulate result...

    endwhile;
    if( al not in Delimiters ) then

        raise( ex.ConversionError );

    endif;</pre><p>Note that the call to <code class="literal">stdin.peekc</code> in the second <code class="literal">while</code> does not consume the delimiter character when the expression evaluates false. Hence, the delimiter character will be the next character read after this algorithm finishes.<a class="indexterm" id="IDX-CHP-8-0119"/></p><p>The only remaining comment to make about numeric input is to point out that the HLA Standard Library input routines allow arbitrary underscores to appear within a numeric string. The input routines ignore these underscore characters. This allows the user to input strings like FFFF_F012 and 1_023_596, which are a little more readable than FFFFF012 and 1023596. Allowing underscores (or any other symbol you choose) within a numeric input routine is quite simple; just modify the second <code class="literal">while</code> loop above as follows:</p><a id="I_programlisting8_d1e44255"/><pre class="programlisting">while( stdin.peekc in {'0'..'9', '_'}) do

        stdin.getc();  // Read the character from the input stream.

        // Ignore underscores while processing numeric input.

        if( al &lt;&gt; '_' ) then

            // Convert character in al to numeric representation and
            // accumulate result...

        endif;

    endwhile;</pre></div><div class="sect3" title="8.1.14.6 Extended-Precision Hexadecimal Input"><div class="titlepage"><div><div><h3 class="title"><a id="extended-precision_hexadecimal_input"/>8.1.14.6 Extended-Precision Hexadecimal Input</h3></div></div></div><p>As was the case for numeric output, hexadecimal input is the easiest numeric input routine to write. The basic algorithm for hexadecimal-string-to-numeric conversion is the following:<a class="indexterm" id="IDX-CHP-8-0120"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Initialize the extended-precision value to 0.</p></li><li class="listitem"><p>For each input character that is a valid hexadecimal digit, do the following:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Convert the hexadecimal character to a value in the range 0..15 ($0..$F).</p></li><li class="listitem"><p>If the H.O. 4 bits of the extended-precision value are nonzero, raise an exception.</p></li><li class="listitem"><p>Multiply the current extended-precision value by 16 (i.e., shift left 4 bits).</p></li><li class="listitem"><p>Add the converted hexadecimal digit value to the accumulator.</p></li><li class="listitem"><p>Check the last input character to ensure it is a valid delimiter. Raise an exception if it is not.</p></li></ol></div></li></ol></div><p>The program in <a class="xref" href="ch08.html#extended-precision_hexadecimal_input-id1" title="Example 8-5. Extended-precision hexadecimal input">Example 8-5</a> implements this extended-precision hexadecimal input routine for 128-bit values.</p><div class="example"><a id="extended-precision_hexadecimal_input-id1"/><p class="title">Example 8-5. Extended-precision hexadecimal input</p><div class="example-contents"><pre class="programlisting">program Xin128;

#include( "stdlib.hhf" );

// 128-bit unsigned integer data type:

type
    b128: dword[4];




procedure getb128( var inValue:b128 ); @nodisplay;
const
    HexChars  := {'0'..'9', 'a'..'f', 'A'..'F', '_'};
var
    Delimiters: cset;
    LocalValue: b128;

begin getb128;

    push( eax );
    push( ebx );

    // Get a copy of the HLA standard numeric input delimiters:

    conv.getDelimiters( Delimiters );

    // Initialize the numeric input value to 0:

    xor( eax, eax );
    mov( eax, LocalValue[0] );
    mov( eax, LocalValue[4] );
    mov( eax, LocalValue[8] );
    mov( eax, LocalValue[12] );

    // By default, #0 is a member of the HLA Delimiters
    // character set. However, someone may have called
    // conv.setDelimiters and removed this character
    // from the internal Delimiters character set. This
    // algorithm depends upon #0 being in the Delimiters
    // character set, so let's add that character in
    // at this point just to be sure.

    cs.unionChar( #0, Delimiters );


    // If we're at the end of the current input
    // line (or the program has yet to read any input),
    // for the input of an actual character.

    if( stdin.peekc() = #0 ) then

        stdin.readLn();

    endif;



    // Skip the delimiters found on input. This code is
    // somewhat convoluted because stdin.peekc does not
    // force the input of a new line of text if the current
    // input buffer is empty. We have to force that input
    // ourselves in the event the input buffer is empty.

    while( stdin.peekc() in Delimiters ) do

        // If we're at the end of the line, read a new line
        // of text from the user; otherwise, remove the
        // delimiter character from the input stream.

        if( al = #0 ) then

            stdin.readLn(); // Force a new input line.

        else

            stdin.getc();   // Remove the delimiter from the input buffer.

        endif;

    endwhile;

    // Read the hexadecimal input characters and convert
    // them to the internal representation:

    while( stdin.peekc() in HexChars ) do

        // Actually read the character to remove it from the
        // input buffer.

        stdin.getc();

        // Ignore underscores, process everything else.

        if( al &lt;&gt; '_' ) then

            if( al in '0'..'9' ) then

                and( $f, al );  // '0'..'9' -&gt; 0..9

            else

                and( $f, al );  // 'a'/'A'..'f'/'F' -&gt; 1..6
                add( 9, al );   // 1..6 -&gt; 10..15

            endif;

            // Conversion algorithm is the following:
            //
            // (1) LocalValue := LocalValue * 16.
            // (2) LocalValue := LocalValue + al
            //
            // Note that "* 16" is easily accomplished by
            // shifting LocalValue to the left 4 bits.
            //
            // Overflow occurs if the H.O. 4 bits of LocalValue
            // contain a nonzero value prior to this operation.

            // First, check for overflow:

            test( $F0, (type byte LocalValue[15]));
            if( @nz ) then

                raise( ex.ValueOutOfRange );

            endif;

            // Now multiply LocalValue by 16 and add in
            // the current hexadecimal digit (in eax).

            mov( LocalValue[8], ebx );
            shld( 4, ebx, LocalValue[12] );
            mov( LocalValue[4], ebx );
            shld( 4, ebx, LocalValue[8] );
            mov( LocalValue[0], ebx );
            shld( 4, ebx, LocalValue[4] );
            shl( 4, ebx );
            add( eax, ebx );
            mov( ebx, LocalValue[0] );

        endif;

    endwhile;

    // Okay, we've encountered a non-hexadecimal character.
    // Let's make sure it's a valid delimiter character.
    // Raise the ex.ConversionError exception if it's invalid.

    if( al not in Delimiters ) then

        raise( ex.ConversionError );

    endif;

    // Okay, this conversion has been a success. Let's store
    // away the converted value into the output parameter.

    mov( inValue, ebx );
    mov( LocalValue[0], eax );
    mov( eax, [ebx] );

    mov( LocalValue[4], eax );
    mov( eax, [ebx+4] );

    mov( LocalValue[8], eax );
    mov( eax, [ebx+8] );

    mov( LocalValue[12], eax );
    mov( eax, [ebx+12] );

    pop( ebx );
    pop( eax );

end getb128;



// Code to test the routines above:

static
    b1:b128;

begin Xin128;

    stdout.put( "Input a 128-bit hexadecimal value: " );
    getb128( b1 );
    stdout.put
    (
        "The value is: $",
        b1[12], '_',
        b1[8],  '_',
        b1[4],  '_',
        b1[0],
        nl
    );

end Xin128;</pre></div></div><p>Extending this code to handle objects that are greater than 128 bits long is very easy. There are only three changes necessary: You must zero out the whole object at the beginning of the <code class="literal">getb128</code> routine; when checking for overflow (the <code class="literal">test( $F, (type byte LocalValue[15]) );</code> instruction), you must test the H.O. 4 bits of the new object you're processing; and you must modify the code that multiplies <code class="literal">LocalValue</code> by 16 (via <code class="literal">shld</code>) so that it multiplies your object by 16 (i.e., shifts it to the left 4 bits).</p></div><div class="sect3" title="8.1.14.7 Extended-Precision Unsigned Decimal Input"><div class="titlepage"><div><div><h3 class="title"><a id="extended-precision_unsigned_decimal_inpu"/>8.1.14.7 Extended-Precision Unsigned Decimal Input</h3></div></div></div><p>The algorithm for extended-precision unsigned decimal input is nearly identical to that for hexadecimal input. In fact, the only difference (beyond only accepting decimal digits) is that you multiply the extended-precision value by 10 rather than 16 for each input character (in general, the algorithm is the same for any base; just multiply the accumulating value by the input base). The code in <a class="xref" href="ch08.html#extended-precision_unsigned_decimal_-016" title="Example 8-6. Extended-precision unsigned decimal input">Example 8-6</a> demonstrates how to write a 128-bit unsigned decimal input routine.<a class="indexterm" id="IDX-CHP-8-0121"/><a class="indexterm" id="IDX-CHP-8-0122"/></p><div class="example"><a id="extended-precision_unsigned_decimal_-016"/><p class="title">Example 8-6. Extended-precision unsigned decimal input</p><div class="example-contents"><pre class="programlisting">program Uin128;

#include( "stdlib.hhf" );

// 128-bit unsigned integer data type:

type
    u128: dword[4];



procedure getu128( var inValue:u128 ); @nodisplay;
var
    Delimiters: cset;
    LocalValue: u128;
    PartialSum: u128;

begin getu128;

    push( eax );
    push( ebx );
    push( ecx );
    push( edx );

    // Get a copy of the HLA standard numeric input delimiters:

    conv.getDelimiters( Delimiters );

    // Initialize the numeric input value to 0:

    xor( eax, eax );
    mov( eax, LocalValue[0] );
    mov( eax, LocalValue[4] );
    mov( eax, LocalValue[8] );
    mov( eax, LocalValue[12] );

    // By default, #0 is a member of the HLA Delimiters
    // character set. However, someone may have called
    // conv.setDelimiters and removed this character
    // from the internal Delimiters character set. This
    // algorithm depends upon #0 being in the Delimiters
    // character set, so let's add that character in
    // at this point just to be sure.

    cs.unionChar( #0, Delimiters );


    // If we're at the end of the current input
    // line (or the program has yet to read any input),
    // wait for the input of an actual character.

    if( stdin.peekc() = #0 ) then

        stdin.readLn();

    endif;



    // Skip the delimiters found on input. This code is
    // somewhat convoluted because stdin.peekc does not
    // force the input of a new line of text if the current
    // input buffer is empty. We have to force that input
    // ourselves in the event the input buffer is empty.

    while( stdin.peekc() in Delimiters ) do

        // If we're at the end of the line, read a new line
        // of text from the user; otherwise, remove the
        // delimiter character from the input stream.

        if( al = #0 ) then

            stdin.readLn(); // Force a new input line.

        else

            stdin.getc();   // Remove the delimiter from the input buffer.

        endif;

    endwhile;

    // Read the decimal input characters and convert
    // them to the internal representation:

    while( stdin.peekc() in '0'..'9' ) do

        // Actually read the character to remove it from the
        // input buffer.

        stdin.getc();

        // Ignore underscores, process everything else.

        if( al &lt;&gt; '_' ) then

            and( $f, al );              // '0'..'9' -&gt; 0..9
            mov( eax, PartialSum[0] );  // Save to add in later.

            // Conversion algorithm is the following:
            //
            // (1) LocalValue := LocalValue * 10.
            // (2) LocalValue := LocalValue + al
            //
            // First, multiply LocalValue by 10:

            mov( 10, eax );
            mul( LocalValue[0], eax );
            mov( eax, LocalValue[0] );
            mov( edx, PartialSum[4] );

            mov( 10, eax );
            mul( LocalValue[4], eax );
            mov( eax, LocalValue[4] );
            mov( edx, PartialSum[8] );

            mov( 10, eax );
            mul( LocalValue[8], eax );
            mov( eax, LocalValue[8] );
            mov( edx, PartialSum[12] );

            mov( 10, eax );
            mul( LocalValue[12], eax );
            mov( eax, LocalValue[12] );

            // Check for overflow. This occurs if edx
            // contains a nonzero value.

            if( edx /* &lt;&gt; 0 */ ) then

                raise( ex.ValueOutOfRange );

            endif;

            // Add in the partial sums (including the
            // most recently converted character).

            mov( PartialSum[0], eax );
            add( eax, LocalValue[0] );

            mov( PartialSum[4], eax );
            adc( eax, LocalValue[4] );

            mov( PartialSum[8], eax );
            adc( eax, LocalValue[8] );

            mov( PartialSum[12], eax );
            adc( eax, LocalValue[12] );

            // Another check for overflow. If there
            // was a carry out of the extended-precision
            // addition above, we've got overflow.

            if( @c ) then

                raise( ex.ValueOutOfRange );

            endif;

        endif;

    endwhile;

    // Okay, we've encountered a non-decimal character.
    // Let's make sure it's a valid delimiter character.
    // Raise the ex.ConversionError exception if it's invalid.

    if( al not in Delimiters ) then

        raise( ex.ConversionError );

    endif;

    // Okay, this conversion has been a success. Let's store
    // away the converted value into the output parameter.

    mov( inValue, ebx );
    mov( LocalValue[0], eax );
    mov( eax, [ebx] );

    mov( LocalValue[4], eax );
    mov( eax, [ebx+4] );

    mov( LocalValue[8], eax );
    mov( eax, [ebx+8] );

    mov( LocalValue[12], eax );
    mov( eax, [ebx+12] );

    pop( edx );
    pop( ecx );
    pop( ebx );
    pop( eax );

end getu128;



// Code to test the routines above:

static
    b1:u128;

begin Uin128;

    stdout.put( "Input a 128-bit decimal value: " );
    getu128( b1 );
    stdout.put
    (
        "The value is: $",
        b1[12], '_',
        b1[8],  '_',
        b1[4],  '_',
        b1[0],
        nl
    );

end Uin128;</pre></div></div><p>As for hexadecimal input, extending this decimal input to some number of bits beyond 128 is fairly easy. All you need do is modify the code that zeros out the <code class="literal">LocalValue</code> variable and the code that multiplies <code class="literal">LocalValue</code> by 10 (overflow checking is done in this same code, so there are only two spots in this code that require modification).<a class="indexterm" id="IDX-CHP-8-0123"/></p></div><div class="sect3" title="8.1.14.8 Extended-Precision Signed Decimal Input"><div class="titlepage"><div><div><h3 class="title"><a id="extended-precision_signed_decimal_input"/>8.1.14.8 Extended-Precision Signed Decimal Input</h3></div></div></div><p>Once you have an unsigned decimal input routine, writing a signed decimal input routine is easy. The following algorithm describes how to accomplish this:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Consume any delimiter characters at the beginning of the input stream.</p></li><li class="listitem"><p>If the next input character is a minus sign, consume this character and set a flag noting that the number is negative.</p></li><li class="listitem"><p>Call the unsigned decimal input routine to convert the rest of the string to an integer.</p></li><li class="listitem"><p>Check the return result to make sure its H.O. bit is clear. Raise the <code class="literal">ex.ValueOutOfRange</code> exception if the H.O. bit of the result is set.<a class="indexterm" id="IDX-CHP-8-0124"/></p></li><li class="listitem"><p>If the code encountered a minus sign in step 2, negate the result.</p></li></ol></div><p>The actual code is left as a programming exercise for the reader (or see the conversion routines in the HLA Standard Library for concrete examples).</p></div></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-8-FN-1" id="ftn.CHP-8-FN-1">111</a>] </sup>Newer C standards also provide for a <code class="literal">long long int</code>, which is usually a 64-bit integer.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-8-FN-2" id="ftn.CHP-8-FN-2">112</a>] </sup>Windows may translate this to an <code class="literal">ex.IntoInstr</code> exception.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-8-FN-3" id="ftn.CHP-8-FN-3">113</a>] </sup>Technically speaking, this isn't entirely true. It is possible for a device error (e.g., disk full) to occur. The likelihood of this is so low that we can effectively ignore this possibility.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-8-FN-4" id="ftn.CHP-8-FN-4">114</a>] </sup>The HLA Standard Library routines actually buffer up input lines in a string and process characters out of the string. This makes it easy to "peek" ahead one character when looking for a delimiter to end the input value. Your code can also do this; however, the code in this chapter uses a different approach.</p></div></div></div>
<div class="sect1" title="8.2 Operating on Different-Size Operands"><div class="titlepage"><div><div><h1 class="title"><a id="operating_on_different-size_operands"/>8.2 Operating on Different-Size Operands</h1></div></div></div><p>Occasionally you may need to do some computation on a pair of operands that are not the same size. For example, you may need to add a word and a double word together or subtract a byte value from a word value. The solution is simple: just extend the smaller operand to the size of the larger operand and then do the operation on two similarly sized operands. For signed operands, you would sign extend the smaller operand to the same size as the larger operand; for unsigned values, you zero extend the smaller operand. This works for any operation, although the following examples demonstrate this for the addition operation.<a class="indexterm" id="IDX-CHP-8-0125"/><a class="indexterm" id="IDX-CHP-8-0126"/><a class="indexterm" id="IDX-CHP-8-0127"/></p><p>To extend the smaller operand to the size of the larger operand, use a sign extension or zero extension operation (depending upon whether you're adding signed or unsigned values). Once you've extended the smaller value to the size of the larger, the addition can proceed. Consider the following code that adds a byte value to a word value:</p><a id="I_programlisting8_d1e44392"/><pre class="programlisting">static
    var1: byte;
    var2: word;
         .
         .
         .
// Unsigned addition:

    movzx( var1, ax );
    add( var2, ax );

// Signed addition:

    movsx( var1, ax );
    add( var2, ax );</pre><p>In both cases, the byte variable was loaded into the AL register, extended to 16 bits, and then added to the word operand. This code works out really well if you can choose the order of the operations (for example, adding the 8-bit value to the 16-bit value). Sometimes, you cannot specify the order of the operations. Perhaps the 16-bit value is already in the AX register and you want to add an 8-bit value to it. For unsigned addition, you could use the following code:</p><a id="I_programlisting8_d1e44396"/><pre class="programlisting">mov( var2, ax );    // Load 16-bit value into ax.
    .                   // Do some other operations leaving
    .                   // a 16-bit quantity in ax.
    add( var1, al );    // Add in the 8-bit value.
    adc( 0, ah );       // Add carry into the H.O. word.</pre><p>The first <code class="literal">add</code> instruction in this example adds the byte at <code class="literal">var1</code> to the L.O. byte of the value in the accumulator. The <code class="literal">adc</code> instruction above adds the carry from the addition of the L.O. bytes into the H.O. byte of the accumulator. You must take care to ensure that this <code class="literal">adc</code> instruction is present. If you leave it out, you may not get the correct result.</p><p>Adding an 8-bit signed operand to a 16-bit signed value is a little more difficult. Unfortunately, you cannot add an immediate value (as above) to the H.O. word of AX. This is because the H.O. extension byte can be either $00 or $FF. If a register is available, the best thing to do is the following:</p><a id="I_programlisting8_d1e44414"/><pre class="programlisting">mov( ax, bx );           // bx is the available register.
    movsx( var1, ax );
    add( bx, ax );</pre><p>If an extra register is not available, you might try the following code:</p><a id="I_programlisting8_d1e44418"/><pre class="programlisting">push( ax );          // Save word value.
    movsx( var1, ax );   // Sign extend 8-bit operand to 16 bits.
    add( [esp], ax );    // Add in previous word value.
    add( 2, esp );       // Pop junk from stack.</pre><p>Another alternative is to store the 16-bit value in the accumulator into a memory location and then proceed as before:</p><a id="I_programlisting8_d1e44423"/><pre class="programlisting">mov( ax, temp );
    movsx( var1, ax );
    add( temp, ax );</pre><p>All the examples above added a byte value to a word value. By zero or sign extending the smaller operand to the size of the larger operand, you can easily add any two different-size variables together.</p><p>As a last example, consider adding an 8-bit signed value to a quadword (64-bit) value:</p><a id="I_programlisting8_d1e44429"/><pre class="programlisting">static
    QVal:qword;
    BVal:int8;
     .
     .
     .
    movsx( BVal, eax );
    cdq();
    add( (type dword QVal), eax );
    adc( (type dword QVal[4]), edx );</pre></div>
<div class="sect1" title="8.3 Decimal Arithmetic"><div class="titlepage"><div><div><h1 class="title"><a id="decimal_arithmetic"/>8.3 Decimal Arithmetic</h1></div></div></div><p>The 80x86 CPUs use the binary numbering system for their native internal representation. The binary numbering system is, by far, the most common numbering system in use in computer systems today. In the early days, however, there were computer systems that were based on the decimal (base 10) numbering system instead of the binary numbering system. Consequently, their arithmetic system was decimal based rather than binary. Such computer systems were very popular in systems targeted for business/commercial systems.<sup>[<a class="footnote" href="#ftn.CHP-8-FN-5" id="CHP-8-FN-5">115</a>]</sup> Although systems designers have discovered that binary arithmetic is almost always better than decimal arithmetic for general calculations, the myth still persists that decimal arithmetic is better for money calculations than binary arithmetic. Therefore, many software systems still specify the use of decimal arithmetic in their calculations (not to mention that there is lots of legacy code out there whose algorithms are stable only if they use decimal arithmetic). Therefore, despite the fact that decimal arithmetic is generally inferior to binary arithmetic, the need for decimal arithmetic persists.<a class="indexterm" id="IDX-CHP-8-0128"/><a class="indexterm" id="IDX-CHP-8-0129"/><a class="indexterm" id="IDX-CHP-8-0130"/><a class="indexterm" id="IDX-CHP-8-0131"/></p><p>Of course, the 80x86 is not a decimal computer; therefore, we have to play tricks in order to represent decimal numbers using the native binary format. The most common technique, even employed by most so-called decimal computers, is to use the binary-coded decimal, or BCD, representation. The BCD representation uses 4 bits to represent the 10 possible decimal digits (see <a class="xref" href="ch08s03.html#binary-coded_decimal_open_parenthesis_bc" title="Table 8-1. Binary-Coded Decimal (BCD) Representation">Table 8-1</a>). The binary value of those 4 bits is equal to the corresponding decimal value in the range 0..9. Of course, with 4 bits we can actually represent 16 different values; the BCD format ignores the remaining six bit combinations.<a class="indexterm" id="IDX-CHP-8-0132"/><a class="indexterm" id="IDX-CHP-8-0133"/></p><p>Because each BCD digit requires 4 bits, we can represent a 2-digit BCD value with a single byte. This means that we can represent the decimal values in the range 0..99 using a single byte (versus 0..255 if we treat the value as an unsigned binary number). Clearly it takes more memory to represent the same value in BCD than it does to represent the same value in binary. For example, with a 32-bit value you can represent BCD values in the range 0..99,999,999 (eight significant digits). However, you can represent values in the range 0..4,294,967,295 (more than nine significant digits) by using binary representation.</p><p>Not only does the BCD format waste memory on a binary computer (because it uses more bits to represent a given integer value), decimal arithmetic is also slower. For these reasons, you should avoid the use of decimal arithmetic unless it is absolutely mandated for a given application.</p><p>Binary-coded decimal representation does offer one big advantage over binary representation: It is fairly simple to convert between the string representation of a decimal number and the BCD representation. This feature is particularly beneficial when working with fractional values because fixed and floating-point binary representations cannot exactly represent many commonly used values between 0 and 1 (e.g., 1/10). Therefore, BCD operations can be efficient when reading from a BCD device, doing a simple arithmetic operation (for example, a single addition), and then writing the BCD value to some other device.</p><div class="table"><a id="binary-coded_decimal_open_parenthesis_bc"/><p class="title">Table 8-1. Binary-Coded Decimal (BCD) Representation</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Binary-Coded Decimal (BCD) Representation"><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>BCD Representation</p></th><th style="text-align: left" valign="bottom"><p>Decimal Equivalent</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p>0000</p></td><td style="text-align: left" valign="top"><p>0</p></td></tr><tr><td style="text-align: left" valign="top"><p>0001</p></td><td style="text-align: left" valign="top"><p>1</p></td></tr><tr><td style="text-align: left" valign="top"><p>0010</p></td><td style="text-align: left" valign="top"><p>2</p></td></tr><tr><td style="text-align: left" valign="top"><p>0011</p></td><td style="text-align: left" valign="top"><p>3</p></td></tr><tr><td style="text-align: left" valign="top"><p>0100</p></td><td style="text-align: left" valign="top"><p>4</p></td></tr><tr><td style="text-align: left" valign="top"><p>0101</p></td><td style="text-align: left" valign="top"><p>5</p></td></tr><tr><td style="text-align: left" valign="top"><p>0110</p></td><td style="text-align: left" valign="top"><p>6</p></td></tr><tr><td style="text-align: left" valign="top"><p>0111</p></td><td style="text-align: left" valign="top"><p>7</p></td></tr><tr><td style="text-align: left" valign="top"><p>1000</p></td><td style="text-align: left" valign="top"><p>8</p></td></tr><tr><td style="text-align: left" valign="top"><p>1001</p></td><td style="text-align: left" valign="top"><p>9</p></td></tr><tr><td style="text-align: left" valign="top"><p>1010</p></td><td style="text-align: left" valign="top"><p>Illegal</p></td></tr><tr><td style="text-align: left" valign="top"><p>1011</p></td><td style="text-align: left" valign="top"><p>Illegal</p></td></tr><tr><td style="text-align: left" valign="top"><p>1100</p></td><td style="text-align: left" valign="top"><p>Illegal</p></td></tr><tr><td style="text-align: left" valign="top"><p>1101</p></td><td style="text-align: left" valign="top"><p>Illegal</p></td></tr><tr><td style="text-align: left" valign="top"><p>1110</p></td><td style="text-align: left" valign="top"><p>Illegal</p></td></tr><tr><td style="text-align: left" valign="top"><p>1111</p></td><td style="text-align: left" valign="top"><p>Illegal</p></td></tr></tbody></table></div></div><div class="sect2" title="8.3.1 Literal BCD Constants"><div class="titlepage"><div><div><h2 class="title"><a id="literal_bcd_constants"/>8.3.1 Literal BCD Constants</h2></div></div></div><p>HLA does not provide, nor do you need, a special literal BCD constant. Because BCD is just a special form of hexadecimal notation that does not allow the values $A..$F, you can easily create BCD constants using HLA's hexadecimal notation. Of course, you must take care not to include the symbols A..F in a BCD constant because they are illegal BCD values. As an example, consider the following <code class="literal">mov</code> instruction that copies the BCD value 99 into the AL register:</p><a id="I_programlisting8_d1e44610"/><pre class="programlisting">mov( $99, al );</pre><p>The important thing to keep in mind is that you must not use HLA literal decimal constants for BCD values. That is, <code class="literal">mov( 95, al );</code> does not load the BCD representation for 95 into the AL register. Instead, it loads $5F into AL, and that's an illegal BCD value. Any computations you attempt with illegal BCD values will produce garbage results. Always remember that, even though it seems counterintuitive, you use hexadecimal literal constants to represent literal BCD values.</p></div><div class="sect2" title="8.3.2 The 80x86 daa and das Instructions"><div class="titlepage"><div><div><h2 class="title"><a id="the_80x86_daa_and_das_instructions"/>8.3.2 The 80x86 daa and das Instructions</h2></div></div></div><p>The integer unit on the 80x86 does not directly support BCD arithmetic. Instead, the 80x86 requires that you perform the computation using binary arithmetic and use some auxiliary instructions to convert the binary result to BCD. To support packed BCD addition and subtraction with two digits per byte, the 80x86 provides two instructions: decimal adjust after addition (<code class="literal">daa</code>) and decimal adjust after subtraction (<code class="literal">das</code>). You would execute these two instructions immediately after an <code class="literal">add</code>/<code class="literal">adc</code> or <code class="literal">sub</code>/<code class="literal">sbb</code> instruction to correct the binary result in the AL register.<a class="indexterm" id="IDX-CHP-8-0134"/><a class="indexterm" id="IDX-CHP-8-0135"/><a class="indexterm" id="IDX-CHP-8-0136"/><a class="indexterm" id="IDX-CHP-8-0137"/></p><p>To add a pair of two-digit (i.e., single-byte) BCD values together, you would use the following sequence:</p><a id="I_programlisting8_d1e44659"/><pre class="programlisting">mov( bcd_1, al );    // Assume that bcd_1 and bcd_2 both contain
    add( bcd_2, al );    // valid BCD values.
    daa();</pre><p>The first two instructions above add the 2-byte values together using standard binary arithmetic. This may not produce a correct BCD result. For example, if <code class="literal">bcd_1</code> contains $9 and <code class="literal">bcd_2</code> contains $1, then the first two instructions above will produce the binary sum $A instead of the correct BCD result $10. The <code class="literal">daa</code> instruction corrects this invalid result. It checks to see if there was a carry out of the low-order BCD digit and adjusts the value (by adding 6 to it) if there was an overflow. After adjusting for overflow out of the L.O. digit, the <code class="literal">daa</code> instruction repeats this process for the H.O. digit. <code class="literal">daa</code> sets the carry flag if there was a (decimal) carry out of the H.O. digit of the operation.</p><p>The <code class="literal">daa</code> instruction operates only on the AL register. It will not adjust (properly) for a decimal addition if you attempt to add a value to AX, EAX, or any other register. Specifically note that <code class="literal">daa</code> limits you to adding two decimal digits (a single byte) at a time. This means that for the purposes of computing decimal sums, you have to treat the 80x86 as though it were an 8-bit processor, capable of adding only 8 bits at a time. If you wish to add more than two digits together, you must treat this as a multiprecision operation. For example, to add four decimal digits together (using <code class="literal">daa</code>), you must execute a sequence like the following:</p><a id="I_programlisting8_d1e44689"/><pre class="programlisting">// Assume "bcd_1:byte[2];", "bcd_2:byte[2];", and "bcd_3:byte[2];"

    mov( bcd_1[0], al );
    add( bcd_2[0], al );
    daa();
    mov( al, bcd_3[0] );
    mov( bcd_1[1], al );
    adc( bcd_2[1], al );
    daa();
    mov( al, bcd_3[1], al );

// Carry is set at this point if there was unsigned overflow.</pre><p>Because a binary addition of two words (producing a word result) requires only three instructions, you can see that decimal arithmetic is expensive.<sup>[<a class="footnote" href="#ftn.CHP-8-FN-6" id="CHP-8-FN-6">116</a>]</sup><a class="indexterm" id="IDX-CHP-8-0138"/><a class="indexterm" id="IDX-CHP-8-0139"/><a class="indexterm" id="IDX-CHP-8-0140"/><a class="indexterm" id="IDX-CHP-8-0141"/><a class="indexterm" id="IDX-CHP-8-0142"/><a class="indexterm" id="IDX-CHP-8-0143"/><a class="indexterm" id="IDX-CHP-8-0144"/><a class="indexterm" id="IDX-CHP-8-0145"/><a class="indexterm" id="IDX-CHP-8-0146"/></p><p>The <code class="literal">das</code> (decimal adjust after subtraction) instruction adjusts the decimal result after a binary <code class="literal">sub</code> or <code class="literal">sbb</code> instruction. You use it the same way you use the <code class="literal">daa</code> instruction. Here are some examples:</p><a id="I_programlisting8_d1e44745"/><pre class="programlisting">// Two-digit (1-byte) decimal subtraction:

    mov( bcd_1, al );    // Assume that bcd_1 and bcd_2 both contain
    sub( bcd_2, al );    // valid BCD values.
    das();

// Four-digit (2-byte) decimal subtraction.
// Assume "bcd_1:byte[2];", "bcd_2:byte[2];", and "bcd_3:byte[2];"

    mov( bcd_1[0], al );
    sub( bcd_2[0], al );
    das();
    mov( al, bcd_3[0] );
    mov( bcd_1[1], al );
    sbb( bcd_2[1], al );
    das();
    mov( al, bcd_3[1], al );

// Carry is set at this point if there was unsigned overflow.</pre><p>Unfortunately, the 80x86 provides support only for addition and subtraction of packed BCD values using the <code class="literal">daa</code> and <code class="literal">das</code> instructions. It does not support multiplication, division, or any other arithmetic operations. Because decimal arithmetic using these instructions is so limited, you'll rarely see any programs use these instructions.</p></div><div class="sect2" title="8.3.3 The 80x86 aaa, aas, aam, and aad Instructions"><div class="titlepage"><div><div><h2 class="title"><a id="the_80x86_aaa_comma_aas_comma_aam_comma"/>8.3.3 The 80x86 aaa, aas, aam, and aad Instructions</h2></div></div></div><p>In addition to the packed decimal instructions (<code class="literal">daa</code> and <code class="literal">das</code>), the 80x86 CPUs support four unpacked decimal adjustment instructions. Unpacked decimal numbers store only one digit per 8-bit byte. As you can imagine, this data representation scheme wastes a considerable amount of memory. However, the unpacked decimal adjustment instructions support the multiplication and division operations, so they are marginally more useful.</p><p>The instruction mnemonics <code class="literal">aaa</code>, <code class="literal">aas</code>, <code class="literal">aam</code>, and <code class="literal">aad</code> stand for "ASCII adjust for Addition, Subtraction, Multiplication, and Division" (respectively). Despite their names, these instructions do not process ASCII characters. Instead, they support an unpacked decimal value in AL whose L.O. 4 bits contain the decimal digit and the H.O. 4 bits contain 0. Note, though, that you can easily convert an ASCII decimal digit character to an unpacked decimal number by simply <code class="literal">and</code>ing AL with the value $0F.</p><p>The <code class="literal">aaa</code> instruction adjusts the result of a binary addition of two unpacked decimal numbers. If the addition of those two values exceeds 10, then <code class="literal">aaa</code> will subtract 10 from AL and increment AH by 1 (as well as set the carry flag). <code class="literal">aaa</code> assumes that the two values you add together are legal unpacked decimal values. Other than the fact that <code class="literal">aaa</code> works with only one decimal digit at a time (rather than two), you use it the same way you use the <code class="literal">daa</code> instruction. Of course, if you need to add together a string of decimal digits, using unpacked decimal arithmetic will require twice as many operations and, therefore, twice the execution time.</p><p>You use the <code class="literal">aas</code> instruction the same way you use the <code class="literal">das</code> instruction except, of course, it operates on unpacked decimal values rather than packed decimal values. As for <code class="literal">aaa</code>, <code class="literal">aas</code> will require twice the number of operations to add the same number of decimal digits as the <code class="literal">das</code> instruction. If you're wondering why anyone would want to use the <code class="literal">aaa</code> or <code class="literal">aas</code> instruction, keep in mind that the unpacked format supports multiplication and division, while the packed format does not. Since packing and unpacking the data is usually more expensive than working on the data a digit at a time, the <code class="literal">aaa</code> and <code class="literal">aas</code> instructions are more efficient if you have to work with unpacked data (because of the need for multiplication and division).</p><p>The <code class="literal">aam</code> instruction modifies the result in the AX register to produce a correct unpacked decimal result after multiplying two unpacked decimal digits using the <code class="literal">mul</code> instruction. Because the largest product you may obtain is 81 (9 * 9 produces the largest possible product of two single-digit values), the result will fit in the AL register. <code class="literal">aam</code> unpacks the binary result by dividing it by 10, leaving the quotient (H.O. digit) in AH and the remainder (L.O. digit) in AL. Note that <code class="literal">aam</code> leaves the quotient and remainder in different registers than a standard 8-bit <code class="literal">div</code> operation.</p><p>Technically, you do not have to use the <code class="literal">aam</code> instruction for BCD multiplication operations. <code class="literal">aam</code> simply divides AL by 10 and leaves the quotient and remainder in AH and AL (respectively). If you have need of this particular operation, you may use the <code class="literal">aam</code> instruction for this purpose (indeed, that's about the only use for <code class="literal">aam</code> in most programs these days).</p><p>If you need to multiply more than two unpacked decimal digits together using <code class="literal">mul</code> and <code class="literal">aam</code>, you will need to devise a multiprecision multiplication that uses the manual algorithm from earlier in this chapter. Since that is a lot of work, this section will not present that algorithm. If you need a multiprecision decimal multiplication, see <a class="xref" href="ch08s03.html#packed_decimal_arithmetic_using_the_fpu" title="8.3.4 Packed Decimal Arithmetic Using the FPU">8.3.4 Packed Decimal Arithmetic Using the FPU</a>; it presents a better solution.</p><p>The <code class="literal">aad</code> instruction, as you might expect, adjusts a value for unpacked decimal division. The unusual thing about this instruction is that you must execute it before a <code class="literal">div</code> operation. It assumes that AL contains the least-significant digit of a two-digit value and AH contains the most-significant digit of a two-digit unpacked decimal value. It converts these two numbers to binary so that a standard <code class="literal">div</code> instruction will produce the correct unpacked decimal result. Like <code class="literal">aam</code>, this instruction is nearly useless for its intended purpose because extended-precision operations (for example, division of more than one or two digits) are extremely inefficient. However, this instruction is actually quite useful in its own right. It computes AX = AH * 10 + AL (assuming that AH and AL contain single-digit decimal values). You can use this instruction to convert a two-character string containing the ASCII representation of a value in the range 0..99 to a binary value. For example:<a class="indexterm" id="IDX-CHP-8-0147"/><a class="indexterm" id="IDX-CHP-8-0148"/><a class="indexterm" id="IDX-CHP-8-0149"/><a class="indexterm" id="IDX-CHP-8-0150"/><a class="indexterm" id="IDX-CHP-8-0151"/></p><a id="I_programlisting8_d1e44905"/><pre class="programlisting">mov( '9', al );
    mov( '9', ah );    // "99" is in ah:al.
    and( $0F0F, ax );  // Convert from ASCII to unpacked decimal.
    aad();             // After this, ax contains 99.</pre><p>The decimal and ASCII adjust instructions provide an extremely poor implementation of decimal arithmetic. To better support decimal arithmetic on 80x86 systems, Intel incorporated decimal operations into the FPU. The next section discusses how to use the FPU for this purpose. However, even with FPU support, decimal arithmetic is inefficient and less precise than binary arithmetic. Therefore, you should consider carefully if you really need to use decimal arithmetic before incorporating it into your programs.<a class="indexterm" id="IDX-CHP-8-0152"/></p></div><div class="sect2" title="8.3.4 Packed Decimal Arithmetic Using the FPU"><div class="titlepage"><div><div><h2 class="title"><a id="packed_decimal_arithmetic_using_the_fpu"/>8.3.4 Packed Decimal Arithmetic Using the FPU</h2></div></div></div><p>To improve the performance of applications that rely on decimal arithmetic, Intel incorporated support for decimal arithmetic directly into the FPU. Unlike the packed and unpacked decimal formats of the previous sections, the FPU easily supports values with up to 18 decimal digits of precision, all at FPU speeds. Furthermore, all the arithmetic capabilities of the FPU (for example, transcendental operations) are available in addition to addition, subtraction, multiplication, and division. Assuming you can live with only 18 digits of precision and a few other restrictions, decimal arithmetic on the FPU is the right way to go if you must use decimal arithmetic in your programs.</p><p>The first fact you must note when using the FPU is that it doesn't really support decimal arithmetic. Instead, the FPU provides two instructions, <code class="literal">fbld</code> and <code class="literal">fbstp</code>, that convert between packed decimal and binary floating-point formats when moving data to and from the FPU. The <code class="literal">fbld</code> (float/BCD load) instruction loads an 80-bit packed BCD value unto the top of the FPU stack after converting that BCD value to the IEEE binary floating-point format. Likewise, the <code class="literal">fbstp</code> (float/BCD store and pop) instruction pops the floating-point value off the top of stack, converts it to a packed BCD value, and stores the BCD value into the destination memory location.</p><p>Once you load a packed BCD value into the FPU, it is no longer BCD. It's just a floating-point value. This presents the first restriction on the use of the FPU as a decimal integer processor: Calculations are done using binary arithmetic. If you have an algorithm that absolutely positively depends on the use of decimal arithmetic, it may fail if you use the FPU to implement it.<sup>[<a class="footnote" href="#ftn.CHP-8-FN-7" id="CHP-8-FN-7">117</a>]</sup></p><p>The second limitation is that the FPU supports only one BCD data type: a 10-byte 18-digit packed decimal value. It will not support smaller values, nor will it support larger values. Since 18 digits are usually sufficient and memory is cheap, this isn't a big restriction.<a class="indexterm" id="IDX-CHP-8-0153"/></p><p>A third consideration is that the conversion between packed BCD and the floating-point format is not a cheap operation. The <code class="literal">fbld</code> and <code class="literal">fbstp</code> instructions can be quite slow (more than two orders of magnitude slower than <code class="literal">fld</code> and <code class="literal">fstp</code>, for example). Therefore, these instructions can be costly if you're doing simple additions or subtractions; the cost of conversion far outweighs the time spent adding the values a byte at a time using the <code class="literal">daa</code> and <code class="literal">das</code> instructions (multiplication and division, however, are going to be faster on the FPU).</p><p>You may be wondering why the FPU's packed decimal format supports only 18 digits. After all, with 10 bytes it should be possible to represent 20 BCD digits. As it turns out, the FPU's packed decimal format uses the first 9 bytes to hold the packed BCD value in a standard packed decimal format (the first byte contains the two L.O. digits and the ninth byte holds the two H.O. digits). The H.O. bit of the tenth byte holds the sign bit, and the FPU ignores the remaining bits in the tenth byte. If you're wondering why Intel didn't squeeze in one more digit (that is, use the L.O. 4 bits of the tenth byte to allow for 19 digits of precision), just keep in mind that doing so would create some possible BCD values that the FPU could not exactly represent in the native floating-point format. Hence, you have the limitation of 18 digits.</p><p>The FPU uses a one's complement notation for negative BCD values. That is, the sign bit contains a 1 if the number is negative or 0 and it contains a 0 if the number is positive or 0 (like the binary one's complement format, there are two distinct representations for 0).</p><p>HLA's <code class="literal">tbyte</code> type is the standard data type you would use to define packed BCD variables. The <code class="literal">fbld</code> and <code class="literal">fbstp</code> instructions require a <code class="literal">tbyte</code> operand (which you can initialize with a hexadecimal/BCD value).</p><p>Because the FPU converts packed decimal values to the internal floating-point format, you can mix packed decimal, floating point, and (binary) integer formats in the same calculation. The program in <a class="xref" href="ch08s03.html#mixed-mode_fpu_arithmetic" title="Example 8-7. Mixed-mode FPU arithmetic">Example 8-7</a> demonstrates how you might achieve this.</p><div class="example"><a id="mixed-mode_fpu_arithmetic"/><p class="title">Example 8-7. Mixed-mode FPU arithmetic</p><div class="example-contents"><pre class="programlisting">program MixedArithmetic;
#include( "stdlib.hhf" )

static
    tb: tbyte := $654321;

begin MixedArithmetic;

    fbld( tb );
    fmul( 2.0 );
    fiadd( 1 );
    fbstp( tb );
    stdout.put( "bcd value is " );
    stdout.puth80( tb );
    stdout.newln();

end MixedArithmetic;</pre></div></div><p>The FPU treats packed decimal values as integer values. Therefore, if your calculations produce fractional results, the <code class="literal">fbstp</code> instruction will round the result according to the current FPU rounding mode. If you need to work with fractional values, you need to stick with floating-point results.<a class="indexterm" id="IDX-CHP-8-0154"/><a class="indexterm" id="IDX-CHP-8-0155"/><a class="indexterm" id="IDX-CHP-8-0156"/><a class="indexterm" id="IDX-CHP-8-0157"/><a class="indexterm" id="IDX-CHP-8-0158"/><a class="indexterm" id="IDX-CHP-8-0159"/></p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-8-FN-5" id="ftn.CHP-8-FN-5">115</a>] </sup>In fact, until the release of the IBM 360 in the mid-1960s, most scientific computer systems were binary based, whereas most commercial/business systems were decimal based. IBM pushed its system\360 as a single-purpose solution for both business and scientific applications. Indeed, the model designation (360) was derived from the 360 degrees on a compass so as to suggest that the system\360 was suitable for computations "at all points of the compass" (i.e., business and scientific).</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-8-FN-6" id="ftn.CHP-8-FN-6">116</a>] </sup>You'll also soon see that it's rare to find decimal arithmetic done this way. So it hardly matters.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-8-FN-7" id="ftn.CHP-8-FN-7">117</a>] </sup>An example of such an algorithm might be a multiplication by 10 by shifting the number one digit to the left. However, such operations are not possible within the FPU itself, so algorithms that misbehave inside the FPU are actually quite rare.</p></div></div></div>
<div class="sect1" title="8.4 Tables"><div class="titlepage"><div><div><h1 class="title"><a id="tables"/>8.4 Tables</h1></div></div></div><p>The term <span class="emphasis"><em>table</em></span> has different meanings to different programmers. To most assembly language programmers, a table is nothing more than an array that is initialized with some data. The assembly language programmer often uses tables to compute complex or otherwise slow functions. Many very-high-level languages (for example, SNOBOL4 and Icon) directly support a <code class="literal">table</code> data type. Tables in these languages are essentially associative arrays whose elements you can access with a noninteger index (for example, <code class="literal">floating point</code>, <code class="literal">string</code>, or any other data type). HLA provides a <code class="literal">table</code> module that lets you index an array using a string. However, in this chapter we will adopt the assembly language programmer's view of tables.<a class="indexterm" id="IDX-CHP-8-0160"/><a class="indexterm" id="IDX-CHP-8-0161"/><a class="indexterm" id="IDX-CHP-8-0162"/></p><p>A table is an array containing initialized values that do not change during the execution of the program. In assembly language, you can use tables for a variety of purposes: computing functions, controlling program flow, or simply looking things up. In general, tables provide a fast mechanism for performing some operation at the expense of some space in your program (the extra space holds the tabular data). In the following sections we'll explore some of the many possible uses of tables in an assembly language program.</p><p>Note that because tables typically contain initialized data that does not change during program execution, the <code class="literal">readonly</code> section is a good place to put your table objects.</p><div class="sect2" title="8.4.1 Function Computation via Table Lookup"><div class="titlepage"><div><div><h2 class="title"><a id="function_computation_via_table_lookup"/>8.4.1 Function Computation via Table Lookup</h2></div></div></div><p>Tables can do all kinds of things in assembly language. In high-level languages like Pascal, it's easy to create a formula that computes some value. A simple-looking high-level-language arithmetic expression can be equivalent to a considerable amount of 80x86 assembly language code and, therefore, could be expensive to compute. Assembly language programmers often precompute many values and use a table lookup of those values to speed up their programs. This has the advantage of being easier, and it's often more efficient as well. Consider the following Pascal statement:</p><a id="I_programlisting8_d1e45065"/><pre class="programlisting">if (<em class="replaceable"><code>character</code></em> &gt;= 'a') and (<em class="replaceable"><code>character</code></em> &lt;= 'z') then <em class="replaceable"><code>character</code></em> :=
chr(ord(<em class="replaceable"><code>character</code></em>) - 32);</pre><p>This Pascal <code class="literal">if</code> statement converts the <code class="literal">character</code> variable's value from lowercase to uppercase if <em class="replaceable"><code>character</code></em> is in the range <code class="literal">a..z</code>. The HLA code that does the same thing follows:<a class="indexterm" id="IDX-CHP-8-0163"/></p><a id="I_programlisting8_d1e45096"/><pre class="programlisting">mov( <em class="replaceable"><code>character</code></em>, al );
        if( al in 'a'..'z' ) then

            and( $5f, al );        // Same as sub( 32, al ) in this code.

        endif;
        mov( al, <em class="replaceable"><code>character</code></em> );</pre><p>Note that HLA's high-level <code class="literal">if</code> statement translates into four machine instructions in this particular example. Hence, this code requires a total of seven machine instructions.</p><p>Had you buried this code in a nested loop, you'd be hard pressed to reduce the size of this code without using a table lookup. Using a table lookup, however, allows you to reduce this sequence of instructions to just four instructions:</p><a id="I_programlisting8_d1e45111"/><pre class="programlisting">mov( <em class="replaceable"><code>character</code></em>, al );
    lea( ebx, CnvrtLower );
    xlat
    mov( al, <em class="replaceable"><code>character</code></em> );</pre><p>You're probably wondering how this code works and asking, "What is this new instruction, <code class="literal">xlat</code>?" The <code class="literal">xlat</code>, or translate, instruction does the following:<a class="indexterm" id="IDX-CHP-8-0164"/></p><a id="I_programlisting8_d1e45132"/><pre class="programlisting">mov( [ebx+al*1], al );</pre><p>That is, it uses the current value of the AL register as an index into the array whose base address is found in EBX. It fetches the byte at that index in the array and copies that byte into the AL register. Intel calls this instruction <span class="emphasis"><em>translate</em></span> because programmers typically use it to translate characters from one form to another using a lookup table. That's exactly how we are using it here.</p><p>In the previous example, <code class="literal">CnvrtLower</code> is a 256-byte table that contains the values 0..$60 at indices 0..$60, $41..$5A at indices $61..$7A, and $7B..$FF at indices $7Bh..0FF. Therefore, if AL contains a value in the range $0..$60, the <code class="literal">xlat</code> instruction returns the value $0..$60, effectively leaving AL unchanged. However, if AL contains a value in the range $61..$7A (the ASCII codes for a..z), then the <code class="literal">xlat</code> instruction replaces the value in AL with a value in the range $41..$5A. The values $41..$5A just happen to be the ASCII codes for A..Z. Therefore, if AL originally contains a lowercase character ($61..$7A), the <code class="literal">xlat</code> instruction replaces the value in AL with a corresponding value in the range $61..$7A, effectively converting the original lowercase character ($61..$7A) to an uppercase character ($41..$5A). The remaining entries in the table, like entries $0..$60, simply contain the index into the table of their particular element. Therefore, if AL originally contains a value in the range $7A..$FF, the <code class="literal">xlat</code> instruction will return the corresponding table entry that also contains $7A..$FF.</p><p>As the complexity of the function increases, the performance benefits of the table lookup method increase dramatically. While you would almost never use a lookup table to convert lowercase to uppercase, consider what happens if you want to swap cases, for example, via computation:</p><a id="I_programlisting8_d1e45159"/><pre class="programlisting">mov( <em class="replaceable"><code>character</code></em>, al );
        if( al in 'a'..'z' ) then

            and( $5f, al );

        elseif( al in 'A'..'Z' ) then

            or( $20, al );

        endif;
        mov( al, <em class="replaceable"><code>character</code></em> ):</pre><p>The <code class="literal">if</code> and <code class="literal">elseif</code> statements generate 4 and 5 actual machine instructions, respectively, so this code is equivalent to 13 actual machine instructions.</p><p>The table lookup code to compute this same function is:</p><a id="I_programlisting8_d1e45177"/><pre class="programlisting">mov( <em class="replaceable"><code>character</code></em>, al );
        lea( ebx, SwapUL );
        xlat();
        mov( al, <em class="replaceable"><code>character</code></em> );</pre><p>As you can see, when using a table lookup to compute a function, only the table changes; the code remains the same.</p><p>Table lookups suffer from one major problem—functions computed via table lookup have a limited domain. The domain of a function is the set of possible input values (parameters) it will accept. For example, the uppercase/lowercase conversion functions above have the 256-character ASCII character set as their domain.<a class="indexterm" id="IDX-CHP-8-0165"/></p><p>A function such as <code class="literal">SIN</code> or <code class="literal">COS</code> accepts the set of real numbers as possible input values. Clearly the domain for <code class="literal">SIN</code> and <code class="literal">COS</code> is much larger than for the upper/lowercase conversion function. If you are going to do computations via table lookup, you must limit the domain of a function to a small set. This is because each element in the domain of a function requires an entry in the lookup table. You won't find it very practical to implement a function via table lookup whose domain is the set of real numbers.</p><p>Most lookup tables are quite small, usually 10 to 256 entries. Rarely do lookup tables grow beyond 1,000 entries. Most programmers don't have the patience to create (and verify the correctness) of a 1,000-entry table.</p><p>Another limitation of functions based on lookup tables is that the elements in the domain of the function must be fairly contiguous. Table lookups take the input value for a function, use this input value as an index into the table, and return the value at that entry in the table. If you do not pass a function any values other than 0, 100, 1,000, and 10,000, it would seem an ideal candidate for implementation via table lookup; its domain consists of only four items. However, the table would actually require 10,001 different elements due to the range of the input values. Therefore, you cannot efficiently create such a function via a table lookup. Throughout this section on tables, we'll assume that the domain of the function is a fairly contiguous set of values.<a class="indexterm" id="IDX-CHP-8-0166"/></p><p>The best functions you can implement via table lookups are those whose domain and range are always 0..255 (or some subset of this range). You can efficiently implement such functions on the 80x86 via the <code class="literal">xlat</code> instruction. The uppercase/lowercase conversion routines presented earlier are good examples of such a function. Any function in this class (those whose domain and range take on the values 0..255) can be computed using the same two instructions: <code class="literal">lea( table, ebx );</code> and <code class="literal">xlat();</code>. The only thing that ever changes is the lookup table.</p><p>You cannot (conveniently) use the <code class="literal">xlat</code> instruction to compute a function value once the range or domain of the function takes on values outside 0..255. There are three situations to consider:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The domain is outside 0..255 but the range is within 0..255.</p></li><li class="listitem"><p>The domain is inside 0..255 but the range is outside 0..255.</p></li><li class="listitem"><p>Both the domain and range of the function take on values outside 0..255.</p></li></ul></div><p>We will consider each of these cases separately.</p><p>If the domain of a function is outside 0..255, but the range of the function falls within this set of values, our lookup table will require more than 256 entries, but we can represent each entry with a single byte. Therefore, the lookup table can be an array of bytes. Other than those lookups that can use the <code class="literal">xlat</code> instruction, functions falling into this class are the most efficient. The following Pascal function invocation</p><a id="I_programlisting8_d1e45247"/><pre class="programlisting">B := Func(X);</pre><p>where <code class="literal">Func</code> is</p><a id="I_programlisting8_d1e45254"/><pre class="programlisting">function Func(X:dword):byte;</pre><p>is easily converted to the following HLA code:</p><a id="I_programlisting8_d1e45258"/><pre class="programlisting">mov( X, ebx );
        mov( FuncTable[ ebx ], al );
        mov( al, B );</pre><p>This code loads the function parameter into <code class="literal">ebx</code>, uses this value (in the range 0..??) as an index into the <code class="literal">FuncTable</code> table, fetches the byte at that location, and stores the result into <code class="literal">B</code>. Obviously, the table must contain a valid entry for each possible value of <code class="literal">X</code>. For example, suppose you wanted to map a cursor position on the video screen in the range 0..1,999 (there are 2,000 character positions on an 80×25 video display) to its <code class="literal">X</code> or <code class="literal">Y</code> coordinate on the screen. You could easily compute the <code class="literal">X</code> coordinate via the function</p><a id="I_programlisting8_d1e45285"/><pre class="programlisting">X := Posn mod 80</pre><p>and the <code class="literal">Y</code> coordinate with the formula</p><a id="I_programlisting8_d1e45292"/><pre class="programlisting">Y := Posn div 80</pre><p>(where <code class="literal">Posn</code> is the cursor position on the screen). This can be easily computed using the 80x86 code:</p><a id="I_programlisting8_d1e45299"/><pre class="programlisting">mov( Posn, ax );
        div( 80, ax );

// X is now in ah, Y is now in al</pre><p>However, the <code class="literal">div</code> instruction on the 80x86 is very slow. If you need to do this computation for every character you write to the screen, you will seriously degrade the speed of your video display code. The following code, which realizes these two functions via table lookup, may improve the performance of your code considerably:</p><a id="I_programlisting8_d1e45306"/><pre class="programlisting">movzx( Posn, ebx );            // Use a plain mov instr if Posn is
        mov( YCoord[ebx], al );        // uns32 rather than an uns16 value.
        mov( XCoord[ebx], ah );</pre><p>If the domain of a function is within 0..255 but the range is outside this set, the lookup table will contain 256 or fewer entries, but each entry will require 2 or more bytes. If both the range and domains of the function are outside 0..255, each entry will require 2 or more bytes and the table will contain more than 256 entries.</p><p>Recall from the chapter on arrays that the formula for indexing into a single-dimensional array (of which a <code class="literal">table</code> is a special case) is:</p><a id="I_programlisting8_d1e45315"/><pre class="programlisting">Address := Base + index * size</pre><p>If elements in the range of the function require 2 bytes, then you must multiply the index by 2 before indexing into the table. Likewise, if each entry requires 3, 4, or more bytes, the index must be multiplied by the size of each table entry before being used as an index into the table. For example, suppose you have a function, <code class="literal">F(x)</code>, defined by the following (pseudo) Pascal declaration:</p><a id="I_programlisting8_d1e45323"/><pre class="programlisting">function F(x:dword):word;</pre><p>You can easily create this function using the following 80x86 code (and, of course, the appropriate table named <code class="literal">F</code>):</p><a id="I_programlisting8_d1e45330"/><pre class="programlisting">mov( X, ebx );
        mov( F[ebx*2], ax );</pre><p>Any function whose domain is small and mostly contiguous is a good candidate for computation via table lookup. In some cases, noncontiguous domains are acceptable as well, as long as the domain can be coerced into an appropriate set of values. Such operations are called <span class="emphasis"><em>conditioning</em></span> and are the subject of the next section.</p></div><div class="sect2" title="8.4.2 Domain Conditioning"><div class="titlepage"><div><div><h2 class="title"><a id="domain_conditioning"/>8.4.2 Domain Conditioning</h2></div></div></div><p>Domain conditioning is taking a set of values in the domain of a function and massaging them so that they are more acceptable as inputs to that function. Consider the following function:<a class="indexterm" id="IDX-CHP-8-0167"/></p><div class="informalequation"><div class="mediaobject"><a id="I_mediaobject8_d1e45346"/><img alt="8.4.2 Domain Conditioning" src="tagoreillycom20100401nostarchimages578057.png"/></div></div><p>This says that the (computer) function <code class="literal">sin(x)</code> is equivalent to the (mathematical) function sin <span class="emphasis"><em>x</em></span> where</p><div class="informalequation"><div class="mediaobject"><a id="I_mediaobject8_d1e45360"/><img alt="8.4.2 Domain Conditioning" src="tagoreillycom20100401nostarchimages578059.png"/></div></div><p>As we all know, sine is a circular function, which will accept any real valued input. The formula used to compute sine, however, accepts only a small set of these values.</p><p>This range limitation doesn't present any real problems; by simply computing <code class="literal">sin(X mod (2*pi))</code> we can compute the sine of any input value. Modifying an input value so that we can easily compute a function is called <span class="emphasis"><em>conditioning the input</em></span>. In the example above we computed <code class="literal">X mod 2*pi</code> and used the result as the input to the <code class="literal">sin</code> function. This truncates <code class="literal">X</code> to the domain <code class="literal">sin</code> needs without affecting the result. We can apply input conditioning to table lookups as well. In fact, scaling the index to handle word entries is a form of input conditioning. Consider the following Pascal function:<a class="indexterm" id="IDX-CHP-8-0168"/></p><a id="I_programlisting8_d1e45391"/><pre class="programlisting">function val(x:word):word; begin
    case x of
        0: val := 1;
        1: val := 1;
        2: val := 4;
        3: val := 27;
        4: val := 256;
        otherwise val := 0;
    end;
end;</pre><p>This function computes some value for <code class="literal">x</code> in the range 0..4 and it returns 0 if <code class="literal">x</code> is outside this range. Since <code class="literal">x</code> can take on 65,536 different values (being a 16-bit word), creating a table containing 65,536 words where only the first five entries are nonzero seems to be quite wasteful. However, we can still compute this function using a table lookup if we use input conditioning. The following assembly language code presents this principle:<a class="indexterm" id="IDX-CHP-8-0169"/><a class="indexterm" id="IDX-CHP-8-0170"/></p><a id="I_programlisting8_d1e45410"/><pre class="programlisting">mov( 0, ax );            // ax = 0, assume x &gt; 4.
        movzx( x, ebx );         // Note that H.O. bits of ebx must be 0!
        if( bx &lt;= 4 ) then

            mov( val[ ebx*2 ], ax );

        endif;</pre><p>This code checks to see if <code class="literal">x</code> is outside the range 0..4. If so, it manually sets <code class="literal">AX</code> to 0; otherwise it looks up the function value through the <code class="literal">val</code> table. With input conditioning, you can implement several functions that would otherwise be impractical to do via table lookup.</p></div><div class="sect2" title="8.4.3 Generating Tables"><div class="titlepage"><div><div><h2 class="title"><a id="generating_tables"/>8.4.3 Generating Tables</h2></div></div></div><p>One big problem with using table lookups is creating the table in the first place. This is particularly true if there is a large number of entries in the table. Figuring out the data to place in the table, then laboriously entering the data, and, finally, checking that data to make sure it is valid is a very time-consuming and boring process. For many tables, there is no way around this process. For other tables, there is a better way—using the computer to generate the table for you. An example is probably the best way to describe this. Consider the following modification to the sine function:</p><div class="informalequation"><div class="mediaobject"><a id="I_mediaobject8_d1e45429"/><img alt="8.4.3 Generating Tables" src="tagoreillycom20100401nostarchimages578061.png"/></div></div><p>This states that <span class="emphasis"><em>x</em></span> is an integer in the range 0..359 and <span class="emphasis"><em>r</em></span> must be an integer. The computer can easily compute this with the following code:</p><a id="I_programlisting8_d1e45442"/><pre class="programlisting">movzx( x, ebx );
        mov( Sines[ ebx*2], eax );  // Get sin(X) * 1000
        imul( r, eax );             // Note that this extends eax into edx.
        idiv( 1000, edx:eax );      // Compute (r*(sin(X)*1000)) / 1000</pre><p>Note that integer multiplication and division are not associative. You cannot remove the multiplication by 1,000 and the division by 1,000 because they appear to cancel one another out. Furthermore, this code must compute this function in exactly this order. All that we need to complete this function is a table containing 360 different values corresponding to the sine of the angle (in degrees) times 1,000. Entering such a table into an assembly language program containing such values is extremely boring and you'd probably make several mistakes entering and verifying this data. However, you can have the program generate this table for you. Consider the HLA program in <a class="xref" href="ch08s04.html#an_hla_program_that_generates_a_table_of" title="Example 8-8. An HLA program that generates a table of sines">Example 8-8</a>.</p><div class="example"><a id="an_hla_program_that_generates_a_table_of"/><p class="title">Example 8-8. An HLA program that generates a table of sines</p><div class="example-contents"><pre class="programlisting">program GenerateSines;
#include( "stdlib.hhf" );

var
    outFile: dword;
    angle:   int32;
    r:       int32;

readonly
    RoundMode: uns16 := $23f;



begin GenerateSines;

    // Open the file:

    mov( fileio.openNew( "sines.hla" ), outFile );

    // Emit the initial part of the declaration to the output file:

    fileio.put
    (
        outFile,
        stdio.tab,
        "sines: int32[360] := " nl,
        stdio.tab, stdio.tab, stdio.tab, "[" nl );

    // Enable rounding control (round to the nearest integer).

    fldcw( RoundMode );

    // Emit the sines table:

    for( mov( 0, angle); angle &lt; 359; inc( angle )) do

        // Convert angle in degrees to an angle in radians using
        // radians := angle * 2.0 * pi / 360.0;

        fild( angle );
        fld( 2.0 );
        fmulp();
        fldpi();
        fmulp();
        fld( 360.0 );
        fdivp();

        // Okay, compute the sine of st0.

        fsin();

        // Multiply by 1000 and store the rounded result into
        // the integer variable r.

        fld( 1000.0 );
        fmulp();
        fistp( r );

        // Write out the integers eight per line to the source file.
        // Note: If (angle AND %111) is 0, then angle is evenly
        // divisible by 8 and we should output a newline first.

        test( %111, angle );
        if( @z ) then

            fileio.put
            (
                outFile,
                nl,
                stdio.tab,
                stdio.tab,
                stdio.tab,
                stdio.tab,
                r:5,
                ','
            );

        else

            fileio.put( outFile, r:5, ',' );

        endif;

    endfor;

    // Output sine(359) as a special case (no comma following it).
    // Note: This value was computed manually with a calculator.

    fileio.put
    (
        outFile,
        "  −17",
        nl,
        stdio.tab,
        stdio.tab,
        stdio.tab,
        "];",
        nl
    );
    fileio.close( outFile );

end GenerateSines;</pre></div></div><p>The program above produces the following output (truncated for brevity):</p><a id="I_programlisting8_d1e45455"/><pre class="programlisting">sines: int32[360] :=
            [

                    0,   17,   35,   52,   70,   87,  105,  122,
                  139,  156,  174,  191,  208,  225,  242,  259,
                  276,  292,  309,  326,  342,  358,  375,  391,
                  407,  423,  438,  454,  469,  485,  500,  515,
                  530,  545,  559,  574,  588,  602,  616,  629,
                  643,  656,  669,  682,  695,  707,  719,  731,
                                                               .
                                                               .
                                                               .
                 −643, −629, −616, −602, −588, −574, −559, −545,
                 −530, −515, −500, −485, −469, −454, −438, −423,
                 −407, −391, −375, −358, −342, −326, −309, −292,
                 −276, −259, −242, −225, −208, −191, −174, −156,
                 −139, −122, −105,  −87,  −70,  −52,  −35,  −17
            ];</pre><p>Obviously it's much easier to write the HLA program that generated this data than to enter (and verify) this data by hand. Of course, you don't even have to write the table-generation program in HLA. If you prefer, you might find it easier to write the program in Pascal/Delphi, C/C++, or some other high-level language. Because the program will only execute once, the performance of the table-generation program is not an issue. If it's easier to write the table-generation program in a high-level language, by all means do so. Note also that HLA has a built-in interpreter that allows you to easily create tables without having to use an external program. For more details, see <a class="xref" href="ch09.html" title="Chapter 9. MACROS AND THE HLA COMPILE-TIME LANGUAGE">Chapter 9</a>.</p><p>Once you run your table-generation program, all that remains to be done is to cut and paste the table from the file (<span class="emphasis"><em>sines.hla</em></span> in this example) into the program that will actually use the table.</p></div><div class="sect2" title="8.4.4 Table Lookup Performance"><div class="titlepage"><div><div><h2 class="title"><a id="table_lookup_performance"/>8.4.4 Table Lookup Performance</h2></div></div></div><p>In the early days of PCs, table lookups were a preferred way to do high-performance computations. However, as the speed of new CPUs vastly outpaces the speed of memory, the advantages of lookup tables have been waning. Today, it is not uncommon for a CPU to be 10 to 100 times faster than main memory. As a result, using a table lookup may not be faster than doing the same calculation with machine instructions. So it's worthwhile to briefly discuss when table lookups offer a big advantage.</p><p>Although the CPU is much faster than main memory, the on-chip CPU cache memory subsystems operate at near CPU speeds. Therefore, table lookups can be cost effective if your table resides in cache memory on the CPU. This means that the way to get good performance using table lookups is to use small tables (because there's only so much room on the cache) and use tables whose entries you reference frequently (so the tables stay in the cache). See <span class="emphasis"><em>Write Great Code, Volume 1</em></span> (No Starch Press) or the electronic version of <span class="emphasis"><em>The Art of Assembly Language</em></span> at <a class="ulink" href="http://webster.cs.ucr.edu/">http://webster.cs.ucr.edu/</a> or <a class="ulink" href="http://www.artofasm.com/">http://www.artofasm.com/</a> for details concerning the operation of cache memory and how you can optimize your use of cache memory.</p></div></div>
<div class="sect1" title="8.5 For More Information"><div class="titlepage"><div><div><h1 class="title"><a id="for_more_information-id7"/>8.5 For More Information</h1></div></div></div><p>The HLA Standard Library reference manual contains lots of information about the HLA Standard Library's extended-precision arithmetic capabilities. You'll also want to check out the source code for several of the HLA Standard Library routines to see how to do various extended-precision operations (that properly set the flags once the computation is complete). The HLA Standard Library source code also covers the extended-precision I/O operations that do not appear in this chapter.</p><p>Donald Knuth's <span class="emphasis"><em>The Art of Computer Programming</em></span>, <span class="emphasis"><em>Volume Two: Seminumerical Algorithms</em></span> contains a lot of useful information about decimal arithmetic and extended-precision arithmetic, though that text is generic and doesn't describe how to do this in x86 assembly language.</p></div></body></html>