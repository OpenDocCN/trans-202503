<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
	<head>
		<title>Chapter 14: Insecure Deserialization</title>
		<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:f533d35e-262b-449b-a78e-85650cfe86cd" name="Adept.expected.resource"/>
	</head>
	<body epub:type="bodymatter chapter">
		<section>
			<header>
				<h1 class="chapter"><span class="ChapterNumber"><span epub:type="pagebreak" id="Page_231" title="231"/>14</span><br/><span class="ChapterTitle">Insecure Deserialization</span></h1>
			</header>
			<figure class="opener">
				<img alt="" src="image_fi/book_art/chapterart.png"/>
			</figure>
			<p class="ChapterIntro"><em>Insecure deserialization</em> vulnerabilities happen when applications deserialize program objects without proper precaution. An attacker can then manipulate serialized objects to change the program’s behavior.</p>
			<p>Insecure deserialization bugs have always fascinated me. They’re hard to find and exploit, because they tend to look different depending on the programming language and libraries used to build the application. These bugs also require deep technical understanding and ingenuity to exploit. Although they can be a challenge to find, they are worth the effort. Countless write-ups describe how researchers used these bugs to achieve RCE on critical assets from companies such as Google and Facebook.</p>
			<p>In this chapter, I’ll talk about what insecure deserialization is, how insecure deserialization bugs happen in PHP and Java applications, and how you can exploit them.</p>
			<h2 id="h1-123456c14-0001"><span epub:type="pagebreak" id="Page_232" title="232"/>Mechanisms</h2>
			<p><em>Serialization</em> is the process by which some bit of data in a programming language gets converted into a format that allows it to be saved in a database or transferred over a network. <em>Deserialization</em> refers to the opposite process, whereby the program reads the serialized object from a file or the network and converts it back into an object.</p>
			<p>This is useful because some objects in programming languages are difficult to transfer through a network or to store in a database without corruption. Serialization and deserialization allow programming languages to reconstruct identical program objects in different computing environments. Many programming languages support the serialization and deserialization of objects, including Java, PHP, Python, and Ruby.</p>
			<p>
				Developers often trust user-supplied serialized data because it is difficult to read or unreadable to users. This trust assumption is what attackers can abuse. <em>Insecure deserialization</em> is a type of vulnerability that arises when an attacker can manipulate the serialized object to cause unintended consequences in the program. This can lead to authentication bypasses or even RCE. For example, if an application takes a serialized object from the user and uses the data contained in it to determine who is logged in, a malicious user might be able to tamper with that object and authenticate as someone else. If the application uses an unsafe deserialization operation, the malicious user might even be able to embed code snippets in the object and get it executed during deserialization.</p>
			<p>The best way to understand insecure deserialization is to learn how different programming languages implement serialization and deserialization. Since these processes look different in every language, we’ll explore how this vulnerability presents itself in PHP and Java. Before we continue, you’ll need to install PHP and Java if you want to test out the example code in this chapter.</p>
			<p>
				You can install PHP by following the instructions for your system on the PHP manual page (<a class="LinkURL" href="https://www.php.net/manual/en/install.php">https://www.php.net/manual/en/install.php</a>). You can then run PHP scripts by running <code>php </code><var>YOUR_PHP_SCRIPT.php</var> using the command line. Alternatively, you can use an online PHP tester like ExtendsClass (<a class="LinkURL" href="https://extendsclass.com/php.html">https://extendsclass.com/php.html</a>) to test the example scripts. Search <em>online PHP tester</em> for more options. Note that not all online PHP testers support serialization and deserialization, so make sure to choose one that does.</p>
			<p>
				Most computers should already have Java installed. If you run <code>java -version</code> at the command line and see a Java version number returned, you don’t have to install Java again. Otherwise, you can find the instructions to install Java at <a class="LinkURL" href="https://java.com/en/download/help/download_options.html">https://java.com/en/download/help/download_options.html</a>. You can also use an online Java compiler to test your code; Tutorials Point has one at <a class="LinkURL" href="https://www.tutorialspoint.com/compile_java_online.php">https://www.tutorialspoint.com/compile_java_online.php</a>.</p>
			<h3 id="h2-123456c14-0001">PHP</h3>
			<p>
				Although most deserialization bugs in the wild are caused by insecure deserialization in Java, I’ve also found PHP deserialization vulnerabilities to be extremely common. In my research project that studied publicly disclosed <span epub:type="pagebreak" id="Page_233" title="233"/>deserialization vulnerabilities on HackerOne, I discovered that half of all disclosed deserialization vulnerabilities were caused by insecure deserialization in PHP. I also found that most deserialization vulnerabilities are resolved as high-impact or critical-impact vulnerabilities; incredibly, most can be used to cause the execution of arbitrary code on the target server.</p>
			<p>
				When insecure deserialization vulnerabilities occur in PHP, we sometimes call them <em>PHP object injection vulnerabilities</em>. To understand PHP object injections, you first need to understand how PHP serializes and deserializes objects.</p>
			<p>
				When an application needs to store a PHP object or transfer it over the network, it calls the PHP function <code>serialize()</code> to pack it up. When the application needs to use that data, it calls <code>unserialize()</code> to unpack and get the underlying object.</p>
			<p>
				For example, this code snippet will serialize the object called <code>user</code>:</p>
			<pre><code>&lt;?php<span aria-label="annotation1" class="CodeAnnotationCode">1</span> class User{ public $username; public $status; }<span aria-label="annotation2" class="CodeAnnotationCode">2</span> $user = new User;<span aria-label="annotation3" class="CodeAnnotationCode">3</span> $user-&gt;username = 'vickie';<span aria-label="annotation4" class="CodeAnnotationCode">4</span> $user-&gt;status = 'not admin';<span aria-label="annotation5" class="CodeAnnotationCode">5</span> echo serialize($user);
?&gt;</code></pre>
			<p>
				This piece of PHP code declares a class called <code>User</code>. Each <code>User</code> object will contain a <code>$username</code> and a <code>$status</code> attribute <span aria-label="annotation1" class="CodeAnnotation">1</span>. It then creates a new <code>User</code> object called <code>$user</code> <span aria-label="annotation2" class="CodeAnnotation">2</span>. It sets the <code>$username</code> attribute of <code>$user</code> to <code>'vickie'</code> <span aria-label="annotation3" class="CodeAnnotation">3</span> and its <code>$status</code> attribute to <code>'not admin'</code> <span aria-label="annotation4" class="CodeAnnotation">4</span>. Then, it serializes the <code>$user</code> object and prints out the string representing the serialized object <span aria-label="annotation5" class="CodeAnnotation">5</span>.</p>
			<p>
				Store this code snippet as a file named <em>serialize_test.php</em> and run it using the command <code>php serialize_test.php</code>. You should get the serialized string that represents the <code>user</code> object:</p>
			<pre><code>O:4:"User":2:{s:8:"username";s:6:"vickie";s:6:"status";s:9:"not admin";}</code></pre>
			<p>
				Let’s break down this serialized string. The basic structure of a PHP serialized string is <var>data type</var><code>:</code><var>data</var>. In terms of data types, <code>b</code> represents a Boolean, <code>i</code> represents an integer, <code>d</code> represents a float, <code>s</code> represents a string, <code>a</code> represents an array, and <code>O</code> represents an object instance of a particular class. Some of these types get followed by additional information about the data, as described here:</p>
			<pre><code>b:<var>THE_BOOLEAN</var>;
i:<var>THE_INTEGER</var>;
d:<var>THE_FLOAT</var>;
s:<var>LENGTH_OF_STRING</var>:"<var>ACTUAL_STRING</var>";
a:<var>NUMBER_OF_ELEMENTS</var>:{<var>ELEMENTS</var>}
O:<var>LENGTH_OF_NAME</var>:"<var>CLASS_NAME</var>":<var>NUMBER_OF_PROPERTIES</var>:{<var>PROPERTIES</var>}</code></pre>
			<p><span epub:type="pagebreak" id="Page_234" title="234"/>Using this reference as a guide, we can see that our serialized string represents an object of the class <code>User</code>. It has two properties. The first property has the name <code>username</code> and the value <code>vickie</code>. The second property has the name <code>status</code> and the value <code>not admin</code>. The names and values are all strings.</p>
			<p>
				When you’re ready to operate on the object again, you can deserialize the string with <code>unserialize()</code>:</p>
			<pre><code>&lt;?php<span aria-label="annotation1" class="CodeAnnotationCode">1</span> class User{ public $username; public $status; } $user = new User; $user-&gt;username = 'vickie'; $user-&gt;status = 'not admin'; $serialized_string = serialize($user);<span aria-label="annotation2" class="CodeAnnotationCode">2</span> $unserialized_data = unserialize($serialized_string);<span aria-label="annotation3" class="CodeAnnotationCode">3</span> var_dump($unserialized_data); var_dump($unserialized_data["status"]);
?&gt;</code></pre>
			<p>
				The first few lines of this code snippet create a user object, serialize it, and store the serialized string into a variable called <code>$serialized_string</code> <span aria-label="annotation1" class="CodeAnnotation">1</span>. Then, it unserializes the string and stores the restored object into the variable <code>$unserialized_data</code> <span aria-label="annotation2" class="CodeAnnotation">2</span>. The <code>var_dump()</code> PHP function displays the value of a variable. The last two lines display the value of the unserialized object <code>$unserialized_data</code> and its status property <span aria-label="annotation3" class="CodeAnnotation">3</span>.</p>
			<p>Most object-oriented programming languages have similar interfaces for serializing and deserializing program objects, but the format of their serialized objects are different. Some programming languages also allow developers to serialize into other standardized formats, such as JSON and YAML.</p>
			<h4 id="h3-123456c14-0001">Controlling Variable Values</h4>
			<p>
				You might have already noticed something fishy here. If the serialized object isn’t encrypted or signed, can anyone create a <code>User</code> object? The answer is yes! This is a common way insecure deserialization endangers applications.</p>
			<p>One possible way of exploiting a PHP object injection vulnerability is by manipulating variables in the object. Some applications simply pass in a serialized object as a method of authentication without encrypting or signing it, thinking the serialization alone will stop users from tampering with the values. If that’s the case, you can mess with the values encoded in the serialized string:</p>
			<pre><code>&lt;?php class User{ public $username;<span epub:type="pagebreak" id="Page_235" title="235"/>    public $status; } $user = new User; $user-&gt;username = 'vickie';<span aria-label="annotation1" class="CodeAnnotationCode">1</span> $user-&gt;status = 'admin'; echo serialize($user);
?&gt;</code></pre>
			<p>
				In this example of the <code>User</code> object we created earlier, you change the <code>status</code> to <code>admin</code> by modifying your PHP script <span aria-label="annotation1" class="CodeAnnotation">1</span>. Then you can intercept the outgoing request in your proxy and insert the new object in place of the old one to see if the application grants you admin privileges.</p>
			<p>You can also change your serialized string directly:</p>
			<pre><code>O:4:"User":2:{s:8:"username";s:6:"vickie";s:6:"status";s:9:"<b>admin</b>";}</code></pre>
			<p>
				If you’re tampering with the serialized string directly, remember to change the string’s length marker as well, since the length of your <code>status</code> string has changed:</p>
			<pre><code>O:4:"User":2:{s:8:"username";s:6:"vickie";s:6:"status";<b>s:5</b>:"admin";}</code></pre>
			<h4 id="h3-123456c14-0002">unserialize() Under the Hood</h4>
			<p>
				To understand how <code>unserialize()</code> can<code> </code>lead to RCEs, let’s take a look at how PHP creates and destroys objects.</p>
			<p><em>PHP magic methods</em> are method names in PHP that have special properties. If the serialized object’s class implements any method with a magic name, these methods will have magic properties, such as being automatically run during certain points of execution, or when certain conditions are met. Two of these magic methods are <code>__wakeup()</code> and <code>__destruct()</code>.</p>
			<p>
				The <code>__wakeup() </code>method is used during instantiation when the program creates an instance of a class in memory, which is what <code>unserialize()</code> does; it takes the serialized string, which specifies the class and the properties of that object, and uses that data to create a copy of the originally serialized object. It then searches for the <code>__wakeup()</code> method and executes code in it. The <code>__wakeup()</code> method is usually used to reconstruct any resources that the object may have, reestablish any database connections that were lost during serialization, and perform other reinitialization tasks. It’s often useful during a PHP object injection attack because it provides a convenient entry point to the server’s database or other functions in the program.</p>
			<p>
				The program then operates on the object and uses it to perform other actions. When no references to the deserialized object exist, the program calls the <code>__destruct()</code> function to clean up the object. This method often contains useful code in terms of exploitation. For example, if a <code>__destruct()</code> method contains code that deletes and cleans up files associated with the object, the attacker might be able to mess with the integrity of the filesystem by controlling the input passed into those functions.</p>
			<h4 id="h3-123456c14-0003"><span epub:type="pagebreak" id="Page_236" title="236"/>Achieving RCE</h4>
			<p>
				When you control a serialized object passed into <code>unserialize()</code>, you control the properties of the created object. You might also be able to control the values passed into automatically executed methods like <code>__wakeup()</code> or <code>__destruct()</code>. If you can do that, you can potentially achieve RCE.</p>
			<p>
				For example, consider this vulnerable code example, taken from<em> </em><a class="LinkURL" href="https://www.owasp.org/index.php/PHP_Object_Injection">https://www.owasp.org/index.php/PHP_Object_Injection</a>:</p>
			<pre><code><span aria-label="annotation1" class="CodeAnnotationCode">1</span> class Example2 { private $hook; function __construct(){ // some PHP code... } function __wakeup(){ <span aria-label="annotation2" class="CodeAnnotationCode">2</span> if (isset($this-&gt;hook)) eval($this-&gt;hook); } } // some PHP code...<span aria-label="annotation3" class="CodeAnnotationCode">3</span> $user_data = unserialize($_COOKIE['data']);</code></pre>
			<p>
				The code declares a class called <code>Example2</code>. It has a <code>$hook</code> attribute and two methods: <code>__construct()</code> and <code>__wakeup()</code> <span aria-label="annotation1" class="CodeAnnotation">1</span>. The <code>__wakeup()</code> function executes the string stored in <code>$hook</code> as PHP code if <code>$hook</code> is not empty <span aria-label="annotation2" class="CodeAnnotation">2</span>. The PHP <code>eval()</code> function takes in a string and runs the content of the string as PHP code. Then, the program runs <code>unserialize()</code> on a user-supplied cookie named <code>data</code> <span aria-label="annotation3" class="CodeAnnotation">3</span>.</p>
			<p>
				Here, you can achieve RCE because the code passes a user-provided object into <code>unserialize()</code>, and there is an object class, <code>Example2</code>, with a magic method that automatically runs <code>eval()</code> on user-provided input when the object is instantiated.</p>
			<p>
				To exploit this RCE, you’d set your <code>data</code> cookie to a serialized <code>Example2</code> object, and the <code>hook</code> property to whatever PHP code you want to execute. You can generate the serialized object by using the following code snippet:</p>
			<pre><code>class Example2
{ private $hook = "phpinfo();";
}
print <span aria-label="annotation1" class="CodeAnnotationCode">1</span> urlencode(serialize(new Example2));</code></pre>
			<p>
				Before we print the object, we need to URL-encode it <span aria-label="annotation1" class="CodeAnnotation">1</span>, since we’ll be injecting the object via a cookie. Passing the string generated by this code into the <code>data</code> cookie will cause the server to execute the PHP code <code>phpinfo();</code>, which outputs information about PHP’s configuration on the server. The <span epub:type="pagebreak" id="Page_237" title="237"/>phpinfo() function is often used as a proof-of-concept function to run in bug reports to proof successful PHP command injection. The following is what happens in detail on the target server during this attack:</p>
			<ol class="decimal">
				<li value="1">The serialized <code>Example2</code> object is passed into the program as the <code>data</code> cookie.</li>
				<li value="2">The program calls <code>unserialize()</code> on the <code>data</code> cookie.</li>
				<li value="3">Because the <code>data</code> cookie is a serialized <code>Example2</code> object, <code>unserialize()</code> instantiates a new <code>Example2</code> object.</li>
				<li value="4">The <code>unserialize()</code> function sees that the <code>Example2</code> class has <code>__wakeup()</code> implemented, so <code>__wakeup()</code> is called.</li>
				<li value="5">The <code>__wakeup()</code> function looks for the object’s <code>$hook</code> property, and if it is not <code>NULL</code>, it runs <code>eval($hook)</code>.</li>
				<li value="6">The <code>$hook</code> property is not <code>NULL</code>, because it is set to <code>phpinfo();</code>, and so <code>eval("phpinfo();")</code> is run.</li>
				<li value="7">You’ve achieved RCE by executing the arbitrary PHP code you’ve placed in the <code>data </code>cookie.</li>
			</ol>
			<h4 id="h3-123456c14-0004">Using Other Magic Methods</h4>
			<p>
				So far, we’ve mentioned the magic methods <code>__wakeup()</code> and <code>__destruct()</code>. There are actually four magic methods you’ll find particularly useful when trying to exploit an <code>unserialize()</code> vulnerability: <code>__wakeup()</code>, <code>__destruct()</code>, <code>__toString()</code>, and <code>__call()</code>.</p>
			<p>
				Unlike <code>__wakeup()</code> and <code>__destruct()</code>, which always get executed if the object is created, the <code>__toString()</code> method is invoked only when the object is treated as a string. It allows a class to decide how it will react when one of its objects is treated as a string. For example, it can decide what to display if the object is passed into an <code>echo()</code> or <code>print()</code> function. You’ll see an example of using this method in a deserialization attack in <span class="xref" itemid="xref_target_“Using POP Chains” on page 238">“Using POP Chains” on page 238</span>.</p>
			<p>
				A program invokes the <code>__call()</code> method when an undefined method is called. For example, a call to <code>$object-&gt;undefined($args)</code> will turn into <code>$object-&gt;__call('undefined', $args)</code>. Again, the exploitability of this magic method varies wildly, depending on how it was implemented. Sometimes attackers can exploit this magic method when the application’s code contains a mistake or when users are allowed to define a method name to call themselves.</p>
			<p>
				You’ll typically find these four magic methods the most useful for exploitation, but many other methods exist. If the ones mentioned here aren’t exploitable, it might be worth checking out the class’s implementation of the other magic methods to see whether you can start an exploit from there. Read more about PHP’s magic methods at <a class="LinkURL" href="https://www.php.net/manual/en/language.oop5.magic.php">https://www.php.net/manual/en/language.oop5.magic.php</a>.</p>
			<h4 id="h3-123456c14-0005"><span epub:type="pagebreak" id="Page_238" title="238"/>Using POP Chains</h4>
			<p>
				So far, you know that when attackers control a serialized object passed into <code>unserialize()</code>, they can control the properties of the created object. This gives them the opportunity to hijack the flow of the application by choosing the values passed into magic methods like <code>__wakeup()</code>.</p>
			<p>This exploit works . . . sometimes. But this approach has a problem: what if the declared magic methods of the class don’t contain any useful code in terms of exploitation? For example, sometimes the available classes for object injections contain only a few methods, and none of them contain code injection opportunities. Then the unsafe deserialization is useless, and the exploit is a bust, right?</p>
			<p>
				We have another way of achieving RCE even in this scenario: POP chains. A <em>property-oriented programming (POP) chain</em> is a type of exploit whose name comes from the fact that the attacker controls all of the deserialized object’s properties. POP chains work by stringing bits of code together, called <em>gadgets</em>, to achieve the attacker’s ultimate goal. These gadgets are code snippets borrowed from the codebase. POP chains use magic methods as their initial gadget. Attackers can then use these methods to call other gadgets.</p>
			<p>
				If this seems abstract, consider the following example application code, taken from <a class="LinkURL" href="https://owasp.org/www-community/vulnerabilities/PHP_Object_Injection">https://owasp.org/www-community/vulnerabilities/PHP_Object_Injection</a>:</p>
			<pre><code>class Example
{<span aria-label="annotation1" class="CodeAnnotationCode">1</span> private $obj; function __construct() { // some PHP code... } function __wakeup() { <span aria-label="annotation2" class="CodeAnnotationCode">2</span> if (isset($this-&gt;obj)) return $this-&gt;obj-&gt;evaluate(); }
}
class CodeSnippet
{<span aria-label="annotation3" class="CodeAnnotationCode">3</span> private $code; <span aria-label="annotation4" class="CodeAnnotationCode">4</span> function evaluate() { eval($this-&gt;code); }
}
// some PHP code...<span aria-label="annotation5" class="CodeAnnotationHang">5</span> $user_data = unserialize($_POST['data']);
// some PHP code...</code></pre>
			<p><span epub:type="pagebreak" id="Page_239" title="239"/>In this application, the code defines two classes: <code>Example</code> and <code>CodeSnippet</code>. <code>Example</code> has a property named <code>obj</code> <span aria-label="annotation1" class="CodeAnnotation">1</span>, and when an <code>Example</code> object is deserialized, its <code>__wakeup()</code> function is called, which calls <code>obj</code>’s <code>evaluate()</code> method <span aria-label="annotation2" class="CodeAnnotation">2</span>.</p>
			<p>
				The <code>CodeSnippet</code> class has a property named <code>code</code> that contains the code string to be executed <span aria-label="annotation3" class="CodeAnnotation">3</span> and an <code>evaluate()</code> method <span aria-label="annotation4" class="CodeAnnotation">4</span>, which calls <code>eval()</code> on the <code>code</code> string.</p>
			<p>
				In another part of the code, the program accepts the POST parameter <code>data</code> from the user and calls <code>unserialize()</code> on it <span aria-label="annotation5" class="CodeAnnotation">5</span>.</p>
			<p>Since that last line contains an insecure deserialization vulnerability, an attacker can use the following code to generate a serialized object:</p>
			<pre><code>class CodeSnippet
{ private $code = "phpinfo();";
}
class Example
{ private $obj; function __construct() { $this-&gt;obj = new CodeSnippet; }
}
print urlencode(serialize(new Example));</code></pre>
			<p>
				This code snippet defines a class named <code>CodeSnippet</code> and set its <code>code</code> property to <code>phpinfo();</code>. Then it defines a class named <code>Example</code>, and sets its <code>obj</code> property to a new <code>CodeSnippet</code> instance on instantiation. Finally, it creates an <code>Example</code> instance, serializes it, and URL-encodes the serialized string. The attacker can then feed the generated string into the POST parameter <code>data</code>.</p>
			<p>
				Notice that the attacker’s serialized object uses class and property names found elsewhere in the application’s source code. As a result, the program will do the following when it receives the crafted <code>data</code> string.</p>
			<p>
				First, it will unserialize the object and create an <code>Example</code> instance. Then, since <code>Example</code> implements <code>__wakeup()</code>, the program will call <code>__wakeup()</code> and see that the <code>obj</code> property is set to a <code>CodeSnippet</code> instance. Finally, it will call the <code>evaluate()</code> method of the <code>obj</code>, which runs <code>eval("phpinfo();")</code>, since the attacker set the <code>code</code> property to <code>phpinfo()</code>. The attacker is able to execute any PHP code of their choosing.</p>
			<p>
				POP chains achieve RCE by chaining and reusing code found in the application’s codebase. Let’s look at another example of how to use POP chains to achieve SQL injection. This example is also taken from <a class="LinkURL" href="https://owasp.org/www-community/vulnerabilities/PHP_Object_Injection">https://owasp.org/www-community/vulnerabilities/PHP_Object_Injection</a>.</p>
			<p>
				Say an application defines a class called <code>Example3</code> somewhere in the code and deserializes unsanitized user input from the POST parameter <code>data</code>:</p>
			<pre><code>class Example3
{ protected $obj; function __construct() {<span epub:type="pagebreak" id="Page_240" title="240"/>    // some PHP code... }<span aria-label="annotation1" class="CodeAnnotationCode">1</span> function __toString() { if (isset($this-&gt;obj)) return $this-&gt;obj-&gt;getValue(); }
}
// some PHP code...
$user_data = unserialize($_POST['data']);
// some PHP code...</code></pre>
			<p>
				Notice that <code>Example3</code> implements the <code>__toString()</code> magic method <span aria-label="annotation1" class="CodeAnnotation">1</span>. In this case, when an <code>Example3</code> instance is treated as a string, it will return the result of the <code>getValue()</code> method run on its <code>$obj</code> property.</p>
			<p>
				Let’s also say that, somewhere in the application, the code defines the class <code>SQL_Row_Value</code>. It has a method named <code>getValue()</code>, which executes a SQL query. The SQL query takes input from the <code>$_table</code> property of the <code>SQL_Row_Value</code> instance:</p>
			<pre><code>class SQL_Row_Value
{ private $_table; // some PHP code... function getValue($id) { $sql = "SELECT * FROM {$this-&gt;_table} WHERE id = " . (int)$id; $result = mysql_query($sql, $DBFactory::getConnection()); $row = mysql_fetch_assoc($result);
return $row['value']; }
}</code></pre>
			<p>
				An attacker can achieve SQL injection by controlling the <code>$obj</code> in <code>Example3</code>. The following code will create an <code>Example3</code> instance with <code>$obj </code>set to a <code>SQL_Row_Value</code> instance, and with <code>$_table</code> set to the string <code>"SQL Injection"</code>:</p>
			<pre><code>class SQL_Row_Value
{ private $_table = "SQL Injection";
}
class Example3
{ protected $obj; function __construct() { $this-&gt;obj = new SQL_Row_Value; }
}
print urlencode(serialize(new Example3));</code></pre>
			<p><span epub:type="pagebreak" id="Page_241" title="241"/>As a result, whenever the attacker’s <code>Example3</code> instance is treated as a string, its <code>$obj</code>’s<code> get_Value()</code> method will be executed. This means the <code>SQL_Row_Value</code>’s <code>get_Value()</code> method will be executed with the <code>$_table</code> string set to <code>"SQL Injection"</code>.</p>
			<p>
				The attacker has achieved a limited SQL injection, since they can control the string passed into the SQL query <code>SELECT * FROM {$this-&gt;_table} WHERE id = " . (int)$id;</code>.</p>
			<p>
				POP chains are similar to <em>return-oriented programming (</em><em>ROP)</em> attacks, an interesting technique used in binary exploitation. You can read more about it on Wikipedia, at <a class="LinkURL" href="https://en.wikipedia.org/wiki/Return-oriented_programming">https://en.wikipedia.org/wiki/Return-oriented_programming</a><em>.</em></p>
			<h3 id="h2-123456c14-0002">Java</h3>
			<p>Now that you understand how insecure deserialization in PHP works, let’s explore another programming language prone to these vulnerabilities: Java. Java applications are prone to insecure deserialization vulnerabilities because many of them handle serialized objects. To understand how to exploit deserialization vulnerabilities in Java, let’s look at how serialization and deserialization work in Java.</p>
			<p>
				For Java objects to be serializable, their classes must implement the <code>java.io.Serializable</code> interface. These classes also implement special methods, <code>writeObject()</code> and <code>readObject()</code>, to handle the serialization and deserialization, respectively, of objects of that class. Let’s look at an example. Store this code in a file named <em>SerializeTest.java</em>:</p>
			<pre><code>import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.Serializable;
import java.io.IOException;<span aria-label="annotation1" class="CodeAnnotationHang">1</span> class User implements Serializable{<span aria-label="annotation2" class="CodeAnnotationCode">2</span> public String username;
}
public class SerializeTest{ public static void main(String args[]) throws Exception{ <span aria-label="annotation3" class="CodeAnnotationCode">3</span> User newUser = new User(); <span aria-label="annotation4" class="CodeAnnotationCode">4</span> newUser.username = "vickie"; FileOutputStream fos = new FileOutputStream("object.ser"); ObjectOutputStream os = new ObjectOutputStream(fos); <span aria-label="annotation5" class="CodeAnnotationCode">5</span> os.writeObject(newUser); os.close(); FileInputStream is = new FileInputStream("object.ser"); ObjectInputStream ois = new ObjectInputStream(is);<span epub:type="pagebreak" id="Page_242" title="242"/> <span aria-label="annotation6" class="CodeAnnotationCode">6</span> User storedUser = (User)ois.readObject(); System.out.println(storedUser.username); ois.close(); }
}</code></pre>
			<p>Then, in the directory where you stored the file, run these commands. They will compile the program and run the code:</p>
			<pre><code>$ javac SerializeTest.java
$ java SerializeTest</code></pre>
			<p>
				You should see the string <code>vickie</code> printed as the output. Let’s break down the program a bit. First, we define a class named <code>User</code> that implements <code>Serializable</code> <span aria-label="annotation1" class="CodeAnnotation">1</span>. Only classes that implement <code>Serializable</code> can be serialized and deserialized. The <code>User</code> class has a <code>username</code> attribute that is used to store the user’s username <span aria-label="annotation2" class="CodeAnnotation">2</span>.</p>
			<p>
				Then, we create a new <code>User</code> object <span aria-label="annotation3" class="CodeAnnotation">3</span> and set its username to the string <code>"vickie"</code> <span aria-label="annotation4" class="CodeAnnotation">4</span>. We write the serialized version of <code>newUser</code> and store it into the file <em>object.ser</em> <span aria-label="annotation5" class="CodeAnnotation">5</span>. Finally, we read the object from the file, deserialize it, and print out the user’s username <span aria-label="annotation6" class="CodeAnnotation">6</span>.</p>
			<p>To exploit Java applications via an insecure deserialization bug, we first have to find an entry point through which to insert the malicious serialized object. In Java applications, serializable objects are often used to transport data in HTTP headers, parameters, or cookies.</p>
			<p>Java serialized objects are not human readable like PHP serialized strings. They often contain non-printable characters as well. But they do have a couple signatures that can help you recognize them and find potential entry points for your exploits:</p>
			<ul>
				<li>
					Starts with <code>AC ED 00 05</code> in hex or <code>rO0</code> in base64. (You might see these within HTTP requests as cookies or parameters.)</li>
				<li>
					The <code>Content-Type</code> header of an HTTP message is set to <code>application/x-java-serialized-object</code>.</li>
			</ul>
			<p>Since Java serialized objects contain a lot of special characters, it’s common to encode them before transmission, so look out for differently encoded versions of these signatures as well.</p>
			<p>After you discover a user-supplied serialized object, the first thing you can try is to manipulate program logic by tampering with the information stored within the objects. For example, if the Java object is used as a cookie for access control, you can try changing the usernames, role names, and other identity markers that are present in the object, re-serialize it, and relay it back to the application. You can also try tampering with any sort of value in the object that is a filepath, file specifier, or control flow value to see if you can alter the program’s flow.</p>
			<p>
				Sometimes when the code doesn’t restrict which classes the application is allowed to deserialize, it can deserialize any serializable classes to which <span epub:type="pagebreak" id="Page_243" title="243"/>it has access. This means attackers can create their own objects of any class. A potential attacker can achieve RCE by constructing objects of the right classes that can lead to arbitrary commands.</p>
			<h4 id="h3-123456c14-0006">Achieving RCE</h4>
			<p>The path from a Java deserialization bug to RCE can be convoluted. To gain code execution, you often need to use a series of gadgets to reach the desired method for code execution. This works similarly to exploiting deserialization bugs using POP chains in PHP, so we won’t rehash the whole process here. In Java applications, you’ll find gadgets in the libraries loaded by the application. Using gadgets that are in the application’s scope, create a chain of method invocations that eventually leads to RCE.</p>
			<p>Finding and chaining gadgets to formulate an exploit can be time-consuming. You’re also limited to the classes available to the application, which can restrict what your exploits can do. To save time, try creating exploit chains by using gadgets in popular libraries, such as the Apache Commons-Collections, the Spring Framework, Apache Groovy, and Apache Commons FileUpload. You’ll find many of these published online.</p>
			<h4 id="h3-123456c14-0007">Automating the Exploitation by Using Ysoserial</h4>
			<p>
				Ysoserial (<a class="LinkURL" href="https://github.com/frohoff/ysoserial/">https://github.com/frohoff/ysoserial/</a>) is a tool that you can use to generate payloads that exploit Java insecure deserialization bugs, saving you tons of time by keeping you from having to develop gadget chains yourself.</p>
			<p>Ysoserial uses a collection of gadget chains discovered in common Java libraries to formulate exploit objects. With Ysoserial, you can create malicious Java serialized objects that use gadget chains from specified libraries with a single command:</p>
			<pre><code>$ java -jar ysoserial.jar <var>gadget_chain command_to_execute</var></code></pre>
			<p>For example, to create a payload that uses a gadget chain in the Commons-Collections library to open a calculator on the target host, execute this command:</p>
			<pre><code>$ java -jar ysoserial.jar CommonsCollections1 calc.exe</code></pre>
			<p>The gadget chains generated by Ysoserial all grant you the power to execute commands on the system. The program takes the command you specified and generates a serialized object that executes that command.</p>
			<p>Sometimes the library to use for your gadget chain will seem obvious, but often it’s a matter of trial and error, as you’ll have to discover which vulnerable libraries your target application implements. This is where good reconnaissance will help you.</p>
			<p>
				You can find more resources about exploiting Java deserialization on GitHub at <a class="LinkURL" href="https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet/">https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet/</a>.</p>
			<h2 id="h1-123456c14-0002"><span epub:type="pagebreak" id="Page_244" title="244"/>Prevention</h2>
			<p>Defending against deserialization vulnerabilities is difficult. The best way to protect an application against these vulnerabilities varies greatly based on the programming language, libraries, and serialization format used. No one-size-fits-all solution exists.</p>
			<p>You should make sure not to deserialize any data tainted by user input without proper checks. If deserialization is necessary, use an allowlist to restrict deserialization to a small number of allowed classes.</p>
			<p>You can also use simple data types, like strings and arrays, instead of objects that need to be serialized when being transported. And, to prevent the tampering of serialized cookies, you can keep track of the session state on the server instead of relying on user input for session information. Finally, you should keep an eye out for patches and make sure your dependencies are up-to-date to avoid introducing deserialization vulnerabilities via third-party code.</p>
			<p>Some developers try to mitigate deserialization vulnerabilities by identifying the commonly vulnerable classes and removing them from the application. This effectively restricts available gadgets attackers can use in gadget chains. However, this isn’t a reliable form of protection. Limiting gadgets can be a great layer of defense, but hackers are creative and can always find more gadgets in other libraries, coming up with creative ways to achieve the same results. It’s important to address the root cause of this vulnerability: the fact that the application deserializes user data insecurely.</p>
			<p>
				The OWASP Deserialization Cheat Sheet is an excellent resource for learning how to prevent deserialization flaws for your specific technology: <a class="LinkURL" href="https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html">https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html</a>.</p>
			<h2 id="h1-123456c14-0003">Hunting for Insecure Deserialization</h2>
			<p>
				Conducting a source code review is the most reliable way to detect deserialization vulnerabilities. From the examples in this chapter, you can see that the fastest way to find insecure deserialization vulnerabilities is by searching for deserialization functions in source code and checking if user input is being passed into it recklessly. For example, in a PHP application, look for <code>unserialize()</code>, and in a Java application, look for <code>readObject()</code>. In Python and Ruby applications, look for the functions <code>pickle.loads()</code> and <code>Marshall.load()</code>, respectively.</p>
			<p>But many bug bounty hunters have been able to find deserialization vulnerabilities without examining any code. Here are some strategies that you can use to find insecure deserialization without access to source code.</p>
			<p>
				Begin by paying close attention to the large blobs of data passed into an application. For example, the base64 string<code> Tzo0OiJVc2VyIjoyOntzOjg6InVzZXJuYW1lIjtzOjY6InZpY2tpZSI7czo2OiJzdGF0dXMiO3M6OToibm90IGFkbWluIjt9</code> is the base64-encoded version of the PHP serialized string <code>O:4:"User":2:{s:8:"username";s:6:"vickie";s:6:"status";s:9:"not admin";}</code>.</p>
			<p><span epub:type="pagebreak" id="Page_245" title="245"/>And this is the base64 representation of a serialized Python object of class <code>Person</code> with a name attribute of <code>vickie</code>: <code>gASVLgAAAAAAAACMCF9fbWFpbl9flIwGUGVyc29ulJOUKYGUfZSMBG5hbWWUjAZWaWNraWWUc2Iu</code>.</p>
			<p>
				These large data blobs could be serialized objects that represent object injection opportunities. If the data is encoded, try to decode it. Most encoded data passed into web applications is encoded with base64. For example, as mentioned earlier, Java serialized objects often start with the hex characters <code>AC ED 00 05</code> or the characters <code>rO0</code> in base64. Pay attention to the <code>Content-Type</code> header of an HTTP request or response as well. For example, a <code>Content-Type</code> set to <code>application/x-java-serialized-object</code> indicates that the application is passing information via Java serialized objects.</p>
			<p>Alternatively, you can start by seeking out features that are prone to deserialization flaws. Look for features that might have to deserialize objects supplied by the user, such as database inputs, authentication tokens, and HTML form parameters.</p>
			<p>Once you’ve found a user-supplied serialized object, you need to determine the type of serialized object it is. Is it a PHP object, a Python object, a Ruby object, or a Java object? Read each programming language’s documentation to familiarize yourself with the structure of its serialized objects.</p>
			<p>Finally, try tampering with the object by using one of the techniques I’ve mentioned. If the application uses the serialized object as an authentication mechanism, try to tamper with the fields to see if you can log in as someone else. You can also try to achieve RCE or SQL injection via a gadget chain.</p>
			<h2 id="h1-123456c14-0004">Escalating the Attack</h2>
			<p>This chapter has already described how insecure deserialization bugs often result in remote code execution, granting the attacker a wide range of capabilities with which to impact the application. For that reason, deserialization bugs are valuable and impactful vulnerabilities. Even when RCE isn’t possible, you might be able to achieve an authentication bypass or otherwise meddle with the logic flow of the application.</p>
			<p>However, the impact of insecure deserialization can be limited when the vulnerability relies on an obscure point of entry, or requires a certain level of application privilege to exploit, or if the vulnerable function isn’t available to unauthenticated users.</p>
			<p>
				When escalating deserialization flaws, take the scope and rules of the bounty program into account. Deserialization vulnerabilities can be dangerous, so make sure you don’t cause damage to the target application when trying to manipulate program logic or execute arbitrary code. Read <span class="xref" itemid="xref_target_Chapter 18">Chapter 18</span> for tips on how to create safe PoCs for an RCE.</p>
			<h2 id="h1-123456c14-0005"><span epub:type="pagebreak" id="Page_246" title="246"/>Finding Your First Insecure Deserialization!</h2>
			<p>Now it’s time to dive in and find your first insecure deserialization vulnerability. Follow the steps we covered to find one:</p>
			<ol class="decimal">
				<li value="1">If you can get access to an application’s source code, search for deserialization functions in source code that accept user input.</li>
				<li value="2">If you cannot get access to source code, look for large blobs of data passed into an application. These could indicate serialized objects that are encoded.</li>
				<li value="3">Alternatively, look for features that might have to deserialize objects supplied by the user, such as database inputs, authentication tokens, and HTML form parameters.</li>
				<li value="4">If the serialized object contains information about the identity of the user, try tampering with the serialized object found and see if you can achieve authentication bypass.</li>
				<li value="5">See if you can escalate the flaw into a SQL injection or remote code execution. Be extra careful not to cause damage to your target application or server.</li>
				<li value="6">Draft your first insecure deserialization report!</li>
			</ol>
		</section>
	</body>
</html>