<html><head></head><body>
<h2 class="h2" id="ch19"><span epub:type="pagebreak" id="page_639"/><strong><span class="big">19</span><br/>CONCURRENCY AND PARALLELISM</strong></h2>&#13;
<p class="quote"><em>The Senior Watchdog had her own watchwords: “Show me a completely smooth operation and I’ll show you someone who’s covering mistakes. Real boats rock.”<br/>—Frank Herbert,</em> Chapterhouse: Dune</p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">In programming, <em>concurrency</em> means two or more tasks running in a given time period. <em>Parallelism</em> means two or more tasks running at the same instant. Often, these terms are used interchangeably without negative consequence, because they’re so closely related. This chapter introduces the very basics of both concepts. Because concurrent and parallel programming are huge and complicated topics, thorough treatment requires an entire book. You’ll find such books in the “Further Reading” section at the end of this chapter.</p>&#13;
<p class="indent">In this chapter, you’ll learn about concurrent and parallel programming with futures. Next, you’ll learn how to share data safely with mutexes, condition variables, and atomics. Then the chapter illustrates how execution policies help to speed up your code but also contain hidden dangers.</p>&#13;
<h3 class="h3" id="ch19lev1sec1"><span epub:type="pagebreak" id="page_640"/><strong>Concurrent Programming</strong></h3>&#13;
<p class="noindent"><em>Concurrent programs</em> have multiple <em>threads of execution</em> (or simply <em>threads</em>), which are sequences of instructions. In most runtime environments, the operating system acts as a scheduler to determine when a thread executes its next instruction. Each process can have one or more threads, which typically share resources, such as memory, with each other. Because the scheduler determines when threads execute, the programmer can’t generally rely on their ordering. In exchange, programs can execute multiple tasks in the same time period (or at the same time), which often results in serious speedups. To observe any speedup from the serial to the concurrent version, your system will need concurrent hardware, for example, a multicore processor.</p>&#13;
<p class="indent">This section begins with asynchronous tasks, a high-level method for making your programs concurrent. Next, you’ll learn some basic methods for coordinating between these tasks when they’re handling shared mutable state. Then you’ll survey some low-level facilities available to you in the stdlib for unique situations in which the higher-level tools don’t have the performance characteristics you require.</p>&#13;
<h4 class="h4" id="ch19lev2sec1"><strong><em>Asynchronous Tasks</em></strong></h4>&#13;
<p class="noindent">One way to introduce concurrency into your program is by creating <em>asynchronous tasks</em>. An asynchronous task doesn’t immediately need a result. To launch an asynchronous task, you use the <code>std::async</code> function template in the <code>&lt;future&gt;</code> header.</p>&#13;
<h5 class="h5" id="ch19lev3sec1"><strong>async</strong></h5>&#13;
<p class="noindent">When you invoke <code>std::async</code>, the first argument is the launch policy <code>std::launch</code>, which takes one of two values: <code>std::launch::async</code> or <code>std::launch::deferred</code>. If you pass <code>launch::async</code>, the runtime creates a new thread to launch your task. If you pass <code>deferred</code>, the runtime waits until you need the task’s result before executing (a pattern sometimes called <em>lazy evaluation</em>). This first argument is optional and defaults to <code>async|deferred</code>, meaning it’s up to the implementation which strategy to employ. The second argument to <code>std::async</code> is a function object representing the task you want to execute. There are no restrictions on the number or type of arguments the function object accepts, and it might return any type. The <code>std::async</code> function is a variadic template with a function parameter pack. Any additional arguments you pass beyond the function object will be used to invoke the function object when the asynchronous task launches. Also, <code>std::async</code> returns an object called a <code>std::future</code>.</p>&#13;
<p class="indent">The following simplified <code>async</code> declaration helps to summarize:</p>&#13;
<pre>std::future&lt;FuncReturnType&gt; std::async([policy], func, Args&amp;&amp;... args);</pre>&#13;
<p class="indent">Now that you know how to invoke <code>async</code>, let’s look at how to interact with its return value.</p>&#13;
<h5 class="h5" id="ch19lev3sec2"><span epub:type="pagebreak" id="page_641"/><strong>Back to the future</strong></h5>&#13;
<p class="noindent">A <code>future</code> is a class template that holds the value of an asynchronous task. It has a single template parameter that corresponds with the type of the asynchronous task’s return value. For example, if you pass a function object that returns a <code>string</code>, <code>async</code> will return a <code>future&lt;string&gt;</code>. Given a <code>future</code>, you can interact with an asynchronous task in three ways.</p>&#13;
<p class="indent">First, you can query the <code>future</code> about its validity using the <code>valid</code> method. A valid <code>future</code> has a shared state associated with it. Asynchronous tasks have a shared state so they can communicate the results. Any <code>future</code> returned by <code>async</code> will be valid until you retrieve the asynchronous task’s return value, at which point the shared state’s lifetime ends, as <a href="ch19.xhtml#ch19ex01">Listing 19-1</a> illustrates.</p>&#13;
<pre>#include &lt;future&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
TEST_CASE("async returns valid future") {&#13;
  using namespace literals::string_literals;&#13;
  auto the_future = async([] { return "female"s; }); <span class="ent">➊</span>&#13;
  REQUIRE(the_future.valid()); <span class="ent">➋</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch19ex01"/><em>Listing 19-1: The <code>async</code> function returns a valid <code>future</code>.</em></p>&#13;
<p class="indent">You launch an asynchronous task that simply returns a <code>string</code> <span class="ent">➊</span>. Because <code>async</code> always returns a valid <code>future</code>, <code>valid</code> returns <code>true</code> <span class="ent">➋</span>.</p>&#13;
<p class="indent">If you default construct a <code>future</code>, it’s not associated with a shared state, so <code>valid</code> will return <code>false</code>, as <a href="ch19.xhtml#ch19ex02">Listing 19-2</a> illustrates.</p>&#13;
<pre>TEST_CASE("future invalid by default") {&#13;
  future&lt;bool&gt; default_future; <span class="ent">➊</span>&#13;
  REQUIRE_FALSE(default_future.valid()); <span class="ent">➋</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch19ex02"/><em>Listing 19-2: A default constructed <code>future</code> is invalid.</em></p>&#13;
<p class="indent">You default construct a <code>future</code> <span class="ent">➊</span>, and <code>valid</code> returns <code>false</code> <span class="ent">➋</span>.</p>&#13;
<p class="indent">Second, you can obtain the value from a valid <code>future</code> with its <code>get</code> method. If the asynchronous task hasn’t yet completed, the call to <code>get</code> will block the currently executed thread until the result is available. <a href="ch19.xhtml#ch19ex03">Listing 19-3</a> illustrates how to employ <code>get</code> to obtain return values.</p>&#13;
<pre>TEST_CASE("async returns the return value of the function object") {&#13;
  using namespace literals::string_literals;&#13;
  auto the_future = async([] { return "female"s; }); <span class="ent">➊</span>&#13;
  REQUIRE(the_future.get() == "female"); <span class="ent">➋</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch19ex03"/><em>Listing 19-3: The <code>async</code> function returns a valid <code>future</code>.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_642"/>You use <code>async</code> to launch an asynchronous task <span class="ent">➊</span> and then invoke the <code>get</code> method on the resulting <code>future</code>. As expected, the result is the return value of the function object you passed into <code>async</code> <span class="ent">➋</span>.</p>&#13;
<p class="indent">If an asynchronous task throws an exception, the <code>future</code> will collect that exception and throw it when you invoke <code>get</code>, as <a href="ch19.xhtml#ch19ex04">Listing 19-4</a> illustrates.</p>&#13;
<pre>TEST_CASE("get may throw ") {&#13;
  auto ghostrider = async(&#13;
                      [] { throw runtime_error{ "The pattern is full." }; }); <span class="ent">➊</span>&#13;
  REQUIRE_THROWS_AS(ghostrider.get(), runtime_error); <span class="ent">➋</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch19ex04"/><em>Listing 19-4: The <code>get</code> method will throw the exception thrown by an asynchronous task.</em></p>&#13;
<p class="indent">You pass a lambda to <code>async</code> that throws a <code>runtime_error</code> <span class="ent">➊</span>. When you invoke <code>get</code>, it throws the exception <span class="ent">➋</span>.</p>&#13;
<p class="indent">Third, you can check whether an asynchronous task has completed using either <code>std::wait_for</code> or <code>std::wait_until</code>. Which you choose depends on the sort of <code>chrono</code> object you want to pass. If you have a <code>duration</code> object, you’ll use <code>wait_for</code>. If you have a <code>time_point</code> object, you’ll use <code>wait_until</code>. Both return a <code>std::future_status</code>, which takes one of three values:</p>&#13;
<ul>&#13;
<li class="noindent"><code>future_status::deferred</code> signals that the asynchronous task will be evaluated lazily, so the task will execute once you call <code>get</code>.</li>&#13;
<li class="noindent"><code>future_status::ready</code> indicates that the task has completed and the result is ready.</li>&#13;
<li class="noindent"><code>future_status::timeout</code> indicates that the task isn’t ready.</li>&#13;
</ul>&#13;
<p class="indent">If the task completes before the specified waiting period, <code>async</code> will return early.</p>&#13;
<p class="indent"><a href="ch19.xhtml#ch19ex05">Listing 19-5</a> illustrates how to use <code>wait_for</code> to check an asynchronous task’s status.</p>&#13;
<pre>TEST_CASE("wait_for indicates whether a task is ready") {&#13;
  using namespace literals::chrono_literals;&#13;
  auto sleepy = async(launch::async, [] { this_thread::sleep_for(100ms); }); <span class="ent">➊</span>&#13;
  const auto not_ready_yet = sleepy.wait_for(25ms); <span class="ent">➋</span>&#13;
  REQUIRE(not_ready_yet == future_status::timeout); <span class="ent">➌</span>&#13;
  const auto totally_ready = sleepy.wait_for(100ms); <span class="ent">➍</span>&#13;
  REQUIRE(totally_ready == future_status::ready); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch19ex05"/><em>Listing 19-5: Checking an asynchronous task’s status using <code>wait_for</code></em></p>&#13;
<p class="indent">You first launch an asynchronous task with <code>async</code>, which simply waits for up to 100 milliseconds before returning <span class="ent">➊</span>. Next, you call <code>wait_for</code> with 25 milliseconds <span class="ent">➋</span>. Because the task is still sleeping (25 &lt; 100), <code>wait_for</code> returns <code>future_status::timeout</code> <span class="ent">➌</span>. You call <code>wait_for</code> again and wait for up to another 100 milliseconds <span class="ent">➍</span>. Because the second <code>wait_for</code> will finish after the <code>async</code> task finishes, the final <code>wait_for</code> will return a <code>future_status::ready</code> <span class="ent">➎</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><span epub:type="pagebreak" id="page_643"/><em>Technically, the assertions in <a href="ch19.xhtml#ch19ex05">Listing 19-5</a> aren’t guaranteed to pass. “Waiting” on <a href="ch12.xhtml#page_389">page 389</a> introduced <span class="codeitalic">this_thread::sleep_for</span>, which isn’t exact. The operating environment is responsible for scheduling threads, and it might schedule the sleeping thread later than the specified duration.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch19lev3sec3"><strong>An Example with Asynchronous Tasks</strong></h5>&#13;
<p class="noindent"><a href="ch19.xhtml#ch19ex06">Listing 19-6</a> contains the <code>factorize</code> function, which finds all of an integer’s factors.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The factorization algorithm in <a href="ch19.xhtml#ch19ex06">Listing 19-6</a> is woefully inefficient but is good enough for this example. For efficient integer factorization algorithms, refer to Dixon’s algorithm, the continued fraction factorization algorithm, or the quadratic sieve.</em></p>&#13;
</div>&#13;
<pre>#include &lt;set&gt;&#13;
&#13;
template &lt;typename T&gt;&#13;
std::multiset&lt;T&gt; factorize(T x) {&#13;
  std::multiset&lt;T&gt; result{ 1 }; <span class="ent">➊</span>&#13;
  for(T candidate{ 2 }; candidate &lt;= x; candidate++) { <span class="ent">➋</span>&#13;
    if (x % candidate == 0) { <span class="ent">➌</span>&#13;
      result.insert(candidate); <span class="ent">➍</span>&#13;
      x /= candidate; <span class="ent">➎</span>&#13;
      candidate = 1; <span class="ent">➏</span>&#13;
    }&#13;
  }&#13;
  return result;&#13;
}</pre>&#13;
<p class="listing"><a id="ch19ex06"/><em>Listing 19-6: A very simple integer factorization algorithm</em></p>&#13;
<p class="indent">The algorithm accepts a single argument <code>x</code> and begins by initializing a <code>set</code> containing 1 <span class="ent">➊</span>. Next, it iterates from 2 to <code>x</code> <span class="ent">➋</span>, checking whether modulo division with the <code>candidate</code> results in 0 <span class="ent">➌</span>. If it does, <code>candidate</code> is a factor, and you add it to the factor <code>set</code> <span class="ent">➍</span>. You divide <code>x</code> by the factor you just discovered <span class="ent">➎</span> and then restart your search by resetting the <code>candidate</code> to 1 <span class="ent">➏</span>.</p>&#13;
<p class="indent">Because integer factorization is a hard problem (and because <a href="ch19.xhtml#ch19ex06">Listing 19-6</a> is so inefficient), calls to <code>factorize</code> can take a long time relative to most of the functions you’ve encountered so far in the book. This makes it a prime candidate for asynchronous tasking. The <code>factor_task</code> function in <a href="ch19.xhtml#ch19ex07">Listing 19-7</a> uses the trusty <code>Stopwatch</code> from <a href="ch12.xhtml#ch12ex25">Listing 12-25</a> in <a href="ch12.xhtml#ch12">Chapter 12</a> to wrap <code>factorize</code> and returns a nicely formatted message.</p>&#13;
<pre>#include &lt;set&gt;&#13;
#include &lt;chrono&gt;&#13;
#include &lt;sstream&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
struct Stopwatch {&#13;
<span epub:type="pagebreak" id="page_644"/>--<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
template &lt;typename T&gt;&#13;
set&lt;T&gt; factorize(T x) {&#13;
--<span class="codeitalic1">snip</span>--&#13;
}&#13;
&#13;
string factor_task(unsigned long x) { <span class="ent">➊</span>&#13;
  chrono::nanoseconds elapsed_ns;&#13;
  set&lt;unsigned long long&gt; factors;&#13;
  {&#13;
    Stopwatch stopwatch{ elapsed_ns }; <span class="ent">➋</span>&#13;
    factors = factorize(x); <span class="ent">➌</span>&#13;
  }&#13;
  const auto elapsed_ms =&#13;
             chrono::duration_cast&lt;chrono::milliseconds&gt;(elapsed_ns).count(); <span class="ent">➍</span>&#13;
  stringstream ss;&#13;
  ss &lt;&lt; elapsed_ms &lt;&lt; " ms: Factoring " &lt;&lt; x &lt;&lt; " ( "; <span class="ent">➎</span>&#13;
  for(auto factor : factors) ss &lt;&lt; factor &lt;&lt; " "; <span class="ent">➏</span>&#13;
  ss &lt;&lt; ")\n";&#13;
  return ss.str(); <span class="ent">➐</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch19ex07"/><em>Listing 19-7: A <code>factor_task</code> function that wraps a call to <code>factorize</code> and returns a nicely formatted message</em></p>&#13;
<p class="indent">Like <code>factorize</code>, <code>factor_task</code> accepts a single argument <code>x</code> to factorize <span class="ent">➊</span>. (For simplicity, <code>factor_task</code> takes an <code>unsigned long</code> rather than a templated argument). Next, you initialize a <code>Stopwatch</code> within a nested scope <span class="ent">➋</span> and then invoke <code>factorize</code> with <code>x</code> <span class="ent">➌</span>. The result is that <code>elapsed_ns</code> contains the number of nanoseconds elapsed while <code>factorize</code> executed, and <code>factors</code> contains all the factors of <code>x</code>.</p>&#13;
<p class="indent">Next, you construct a nicely formatted string by first converting <code>elapsed_ns</code> to a count in milliseconds <span class="ent">➍</span>. You write this information into a <code>stringstream</code> object called <code>ss</code> <span class="ent">➎</span> followed by the factors of <code>x</code> <span class="ent">➏</span>. Then you return the resulting <code>string</code> <span class="ent">➐</span>.</p>&#13;
<p class="indent"><a href="ch19.xhtml#ch19ex08">Listing 19-8</a> employs <code>factor_task</code> to factor six different numbers and record the total elapsed program time.</p>&#13;
<pre>#include &lt;set&gt;&#13;
#include &lt;array&gt;&#13;
#include &lt;vector&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;limits&gt;&#13;
#include &lt;chrono&gt;&#13;
#include &lt;sstream&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
struct Stopwatch {&#13;
--<span class="codeitalic1">snip</span>--&#13;
<span epub:type="pagebreak" id="page_645"/>};&#13;
&#13;
template &lt;typename T&gt;&#13;
set&lt;T&gt; factorize(T x) {&#13;
--<span class="codeitalic1">snip</span>--&#13;
}&#13;
&#13;
string factor_task(unsigned long long x) {&#13;
--<span class="codeitalic1">snip</span>--&#13;
}&#13;
&#13;
array&lt;unsigned long long, 6&gt; numbers{ <span class="ent">➊</span>&#13;
        9'699'690,&#13;
        179'426'549,&#13;
        1'000'000'007,&#13;
        4'294'967'291,&#13;
        4'294'967'296,&#13;
        1'307'674'368'000&#13;
};&#13;
&#13;
int main() {&#13;
  chrono::nanoseconds elapsed_ns;&#13;
  {&#13;
    Stopwatch stopwatch{ elapsed_ns }; <span class="ent">➋</span>&#13;
    for(auto number : numbers) <span class="ent">➌</span>&#13;
      cout &lt;&lt; factor_task(number); <span class="ent">➍</span>&#13;
  }&#13;
  const auto elapsed_ms =&#13;
             chrono::duration_cast&lt;chrono::milliseconds&gt;(elapsed_ns).count(); <span class="ent">➎</span>&#13;
  cout &lt;&lt; elapsed_ms &lt;&lt; "ms: total program time\n"; <span class="ent">➏</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">0 ms: Factoring 9699690 ( 1 2 3 5 7 11 13 17 19 )</span>&#13;
<span class="color1">1274 ms: Factoring 179426549 ( 1 179426549 )</span>&#13;
<span class="color1">6804 ms: Factoring 1000000007 ( 1 1000000007 )</span>&#13;
<span class="color1">29035 ms: Factoring 4294967291 ( 1 4294967291 )</span>&#13;
<span class="color1">0 ms: Factoring 4294967296 ( 1 2 )</span>&#13;
<span class="color1">0 ms: Factoring 1307674368000 ( 1 2 3 5 7 11 13 )</span>&#13;
<span class="color1">37115ms: total program time</span></pre>&#13;
<p class="listing"><a id="ch19ex08"/><em>Listing 19-8: A program using <code>factor_task</code> to factorize six different numbers</em></p>&#13;
<p class="indent">You construct an array containing six <code>numbers</code> of varied size and primality <span class="ent">➊</span>. Next, you initialize a <code>Stopwatch</code> <span class="ent">➋</span>, iterate over each element in <code>numbers</code> <span class="ent">➌</span>, and invoke <code>factor_task</code> with them <span class="ent">➍</span>. You then determine the program’s runtime in milliseconds <span class="ent">➎</span> and print it <span class="ent">➏</span>.</p>&#13;
<p class="indent">The output shows that some numbers, such as 9,699,690, 4,294,967,296, and 1,307,674,368,000, factor almost immediately because they contain small factors. However, the prime numbers take quite a while. Note that because the program is single threaded, the runtime for the entire program roughly equals the sum of the times taken to factorize each number.</p>&#13;
<p class="indent">What if you treat each <code>factor_task</code> as an asynchronous task? <a href="ch19.xhtml#ch19ex09">Listing 19-9</a> illustrates how to do this with <code>async</code>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_646"/>#include &lt;set&gt;&#13;
#include &lt;vector&gt;&#13;
#include &lt;array&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;limits&gt;&#13;
#include &lt;chrono&gt;&#13;
#include &lt;future&gt;&#13;
#include &lt;sstream&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
struct Stopwatch {&#13;
--<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
template &lt;typename T&gt;&#13;
set&lt;T&gt; factorize(T x) {&#13;
--<span class="codeitalic1">snip</span>--&#13;
}&#13;
&#13;
string factor_task(unsigned long long x) {&#13;
--<span class="codeitalic1">snip</span>--&#13;
}&#13;
&#13;
array&lt;unsigned long long, 6&gt; numbers{&#13;
--<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
int main() {&#13;
  chrono::nanoseconds elapsed_ns;&#13;
  {&#13;
    Stopwatch stopwatch{ elapsed_ns }; <span class="ent">➊</span>&#13;
    vector&lt;future&lt;string&gt;&gt; factor_tasks; <span class="ent">➋</span>&#13;
    for(auto number : numbers) <span class="ent">➌</span>&#13;
      factor_tasks.emplace_back(async(launch::async, factor_task, number)); <span class="ent">➍</span>&#13;
    for(auto&amp; task : factor_tasks) <span class="ent">➎</span>&#13;
      cout &lt;&lt; task.get(); <span class="ent">➏</span>&#13;
  }&#13;
  const auto elapsed_ms =&#13;
             chrono::duration_cast&lt;chrono::milliseconds&gt;(elapsed_ns).count(); <span class="ent">➐</span>&#13;
  cout &lt;&lt; elapsed_ms &lt;&lt; " ms: total program time\n"; <span class="ent">➑</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">0 ms: Factoring 9699690 ( 1 2 3 5 7 11 13 17 19 )</span>&#13;
<span class="color1">1252 ms: Factoring 179426549 ( 1 179426549 )</span>&#13;
<span class="color1">6816 ms: Factoring 1000000007 ( 1 1000000007 )</span>&#13;
<span class="color1">28988 ms: Factoring 4294967291 ( 1 4294967291 )</span>&#13;
<span class="color1">0 ms: Factoring 4294967296 ( 1 2 )</span>&#13;
<span class="color1">0 ms: Factoring 1307674368000 ( 1 2 3 5 7 11 13 )</span>&#13;
<span class="color1">28989 ms: total program time</span></pre>&#13;
<p class="listing"><a id="ch19ex09"/><em>Listing 19-9: A program using <code>factor_task</code> to factorize six different numbers asynchronously</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_647"/>As in <a href="ch19.xhtml#ch19ex08">Listing 19-8</a>, you initialize a <code>Stopwatch</code> to keep track of how long the program executes <span class="ent">➊</span>. Next, you initialize a <code>vector</code> called <code>factor_tasks</code> that contains objects of type <code>future&lt;string&gt;</code> <span class="ent">➋</span>. You iterate over <code>numbers</code> <span class="ent">➌</span>, invoking <code>async</code> with the <code>launch::async</code> strategy, specifying <code>factor_task</code> as the function object, and passing a <code>number</code> as the task’s argument. You invoke <code>emplace_back</code> on each resulting <code>future</code> into <code>factor_tasks</code> <span class="ent">➍</span>. Now that <code>async</code> has launched each task, you iterate over each element of <code>factor_tasks</code> <span class="ent">➎</span>, invoke <code>get</code> on each <code>task</code>, and write it to <code>cout</code> <span class="ent">➏</span>. Once you’ve received values from all the futures, you determine the number of milliseconds it took to run all tasks <span class="ent">➐</span> and write it to <code>cout</code> <span class="ent">➑</span>.</p>&#13;
<p class="indent">Thanks to concurrency, the total program time of <a href="ch19.xhtml#ch19ex09">Listing 19-9</a> roughly equals the maximum task execution time (28,988 ms) rather than the sum of task execution times, as in <a href="ch19.xhtml#ch19ex08">Listing 19-8</a> (37,115 ms).</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The times in <a href="ch19.xhtml#ch19ex08">Listing 19-8</a> and <a href="ch19.xhtml#ch19ex09">Listing 19-9</a> will vary from run to run.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch19lev2sec2"><strong><em>Sharing and Coordinating</em></strong></h4>&#13;
<p class="noindent">Concurrent programming with asynchronous tasks is simple as long as the tasks don’t require synchronization and don’t involve sharing mutable data. For example, consider a simple situation in which two threads access the same integer. One thread will increment the integer while the other decrements it. To modify a variable, each thread must read the variable’s current value, perform an addition or subtraction operation, and then write the variable to memory. Without synchronization, the two threads will perform these operations in an undefined, interleaved order. Such situations are sometimes called <em>race conditions</em> because the result depends on which thread executes first. <a href="ch19.xhtml#ch19ex10">Listing 19-10</a> illustrates just how disastrous this situation is.</p>&#13;
<pre>#include &lt;future&gt;&#13;
#include &lt;iostream&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
void goat_rodeo() {&#13;
  const size_t iterations{ 1'000'000 };&#13;
  int tin_cans_available{}; <span class="ent">➊</span>&#13;
&#13;
  auto eat_cans = async(launch::async, [&amp;] { <span class="ent">➋</span>&#13;
    for(size_t i{}; i&lt;iterations; i++)&#13;
      tin_cans_available--; <span class="ent">➌</span>&#13;
  });&#13;
  auto deposit_cans = async(launch::async, [&amp;] { <span class="ent">➍</span>&#13;
    for(size_t i{}; i&lt;iterations; i++)&#13;
      tin_cans_available++; <span class="ent">➎</span>&#13;
  });&#13;
  eat_cans.get(); <span class="ent">➏</span>&#13;
  deposit_cans.get(); <span class="ent">➐</span>&#13;
  cout &lt;&lt; "Tin cans: " &lt;&lt; tin_cans_available &lt;&lt; "\n"; <span class="ent">➑</span>&#13;
}&#13;
<span epub:type="pagebreak" id="page_648"/>int main() {&#13;
  goat_rodeo();&#13;
  goat_rodeo();&#13;
  goat_rodeo();&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">Tin cans: -609780</span>&#13;
<span class="color1">Tin cans: 185380</span>&#13;
<span class="color1">Tin cans: 993137</span></pre>&#13;
<p class="listing"><a id="ch19ex10"/><em>Listing 19-10: An illustration of how disastrous unsynchronized, mutable, shared data access can be</em></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You’ll get different results on each run of the program in <a href="ch19.xhtml#ch19ex10">Listing 19-10</a> because the program has undefined behavior.</em></p>&#13;
</div>&#13;
<p class="indent"><a href="ch19.xhtml#ch19ex10">Listing 19-10</a> involves defining a function called <code>goat_rodeo</code>, which involves a catastrophic race condition, and a <code>main</code> that invokes <code>goat_rodeo</code> three times. Within <code>goat_rodeo</code>, you initialize the shared data <code>tin_cans_available</code> <span class="ent">➊</span>. Next, you launch an asynchronous task called <code>eat_cans</code> <span class="ent">➋</span> in which a trip of goats decrements the shared variable <code>tin_cans_available</code> one million times <span class="ent">➌</span>. Next, you launch another asynchronous task called <code>deposit_cans</code> <span class="ent">➍</span> in which you increment <code>tin_cans_available</code> <span class="ent">➎</span>. After launching the two tasks, you wait for them to complete by calling <code>get</code> (the order doesn’t matter) <span class="ent">➏</span><span class="ent">➐</span>. Once the tasks complete, you print the <code>tin_cans_available</code> variable <span class="ent">➑</span>.</p>&#13;
<p class="indent">Intuitively, you might expect <code>tin_cans_available</code> to equal zero after each task completes. After all, no matter how you order increments and decrements, if you perform them in equal number, they’ll cancel. You invoke <code>goat_rodeo</code> three times, and each invocation produces a wildly different result.</p>&#13;
<p class="indent"><a href="ch19.xhtml#ch19tab01">Table 19-1</a> illustrates one of the many ways the unsynchronized access in <a href="ch19.xhtml#ch19ex10">Listing 19-10</a> goes awry.</p>&#13;
<p class="tabcap" id="ch19tab01"><strong>Table 19-1:</strong> One Possible Schedule for <code>eat_cans</code> and <code>deposit_cans</code></p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:35%"/>&#13;
<col style="width:35%"/>&#13;
<col style="width:30%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>eat_cans</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>deposit_cans</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>cans_available</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Read <code>cans_available</code> (0)</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"/>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"/>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Read <code>cans_available</code> (0) <span class="ent">➊</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Compute <code>cans_available+1</code> (1)</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"/>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b "/>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Compute <code>cans_available-1</code> (-1) <span class="ent">➌</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Write <code>cans_available+1</code> (1) <span class="ent">➋</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"/>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"/>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Write <code>cans_available-1</code> (-1) <span class="ent">➍</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">-1</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><a href="ch19.xhtml#ch19tab01">Table 19-1</a> shows how interleaving reads and writes invites disaster. In this particular incarnation, the read by <code>deposit_cans</code> <span class="ent">➊</span> precedes the write from <code>eat_cans</code> <span class="ent">➋</span>, so <code>deposit_cans</code> computes a stale result <span class="ent">➌</span>. If this weren’t bad enough, it clobbers the write from <code>eat_cans</code> when it writes <span class="ent">➍</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_649"/>The fundamental problem with this data race is <em>unsynchronized access to mutable shared data</em>. You might wonder why <code>cans_available</code> doesn’t update immediately whenever a thread computes <code>cans_available+1</code> or <code>cans_available-1</code>. The answer lies in the fact that each of the rows in <a href="ch19.xhtml#ch19tab01">Table 19-1</a> represents a moment in time when some instruction completes execution, and the instructions for adding, subtracting, reading, and writing memory are all separate. Because the <code>cans_available</code> variable is shared and both threads write to it without synchronizing their actions, the instructions get interleaved in an undefined way at runtime (with catastrophic results). In the following subsections, you’ll learn three tools for dealing with such situations: <em>mutexes</em>, <em>condition variables</em>, and atomics.</p>&#13;
<h5 class="h5" id="ch19lev3sec4"><strong>Mutexes</strong></h5>&#13;
<p class="noindent">A <em>mutual exclusion algorithm</em> (<em>mutex</em>) is a mechanism for preventing multiple threads from accessing resources simultaneously. Mutexes are <em>synchronization primitives</em> that support two operations: lock and unlock. When a thread needs to access shared data, it locks the mutex. This operation can block depending on the nature of the mutex and whether another thread has the lock. When a thread no longer needs access, it unlocks the mutex.</p>&#13;
<p class="indent">The <code>&lt;mutex&gt;</code> header exposes several mutex options:</p>&#13;
<ul>&#13;
<li class="noindent"><code>std::mutex</code> provides basic mutual exclusion.</li>&#13;
<li class="noindent"><code>std::timed_mutex</code> provides mutual exclusion with a timeout.</li>&#13;
<li class="noindent"><code>std::recursive_mutex</code> provides mutual exclusion that allows recursive locking by the same thread.</li>&#13;
<li class="noindent"><code>std::recursive_timed_mutex</code> provides mutual exclusion that allows recursive locking by the same thread and a timeout.</li>&#13;
</ul>&#13;
<p class="indent">The <code>&lt;shared_mutex&gt;</code> header provides two additional options:</p>&#13;
<ul>&#13;
<li class="noindent"><code>std::shared_mutex</code> provides shared mutual exclusion facility, which means that several threads can own the mutex at once. This option is typically used in scenarios when multiple readers can access shared data but a writer needs exclusive access.</li>&#13;
<li class="noindent"><code>std::shared_timed_mutex</code> provides shared mutual exclusion facility and implements locking with a timeout.</li>&#13;
</ul>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>For simplicity, this chapter only covers <span class="codeitalic">mutex</span>. See [thread.mutex] for more information about the other options.</em></p>&#13;
</div>&#13;
<p class="indent">The <code>mutex</code> class defines only a single, default constructor. When you want to obtain mutual exclusion, you call one of two methods on a <code>mutex</code> object: <code>lock</code> or <code>try_lock</code>. If you call <code>lock</code>, which accepts no arguments and returns <code>void</code>, the calling thread blocks until the <code>mutex</code> becomes available. If you call <code>try_lock</code>, which accepts no arguments and returns a <code>bool</code>, it returns immediately. If the <code>try_lock</code> successfully obtained mutual exclusion, it returns <code>true</code> and the calling <span epub:type="pagebreak" id="page_650"/>thread now owns the lock. If <code>try_lock</code> was unsuccessful, it returns <code>false</code> and the calling thread doesn’t own the lock. To release a mutual exclusion lock, you simply call the method <code>unlock</code>, which accepts no arguments and returns <code>void</code>.</p>&#13;
<p class="indent"><a href="ch19.xhtml#ch19ex11">Listing 19-11</a> shows a lock-based way to solve the race condition in <a href="ch19.xhtml#ch19ex10">Listing 19-10</a>.</p>&#13;
<pre>#include &lt;future&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;mutex&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
void goat_rodeo() {&#13;
  const size_t iterations{ 1'000'000 };&#13;
  int tin_cans_available{};&#13;
  mutex tin_can_mutex; <span class="ent">➊</span>&#13;
&#13;
  auto eat_cans = async(launch::async, [&amp;] {&#13;
    for(size_t i{}; i&lt;iterations; i++) {&#13;
      tin_can_mutex.lock(); <span class="ent">➋</span>&#13;
      tin_cans_available--;&#13;
      tin_can_mutex.unlock(); <span class="ent">➌</span>&#13;
    }&#13;
  });&#13;
  auto deposit_cans = async(launch::async, [&amp;] {&#13;
    for(size_t i{}; i&lt;iterations; i++) {&#13;
      tin_can_mutex.lock(); <span class="ent">➍</span>&#13;
      tin_cans_available++;&#13;
      tin_can_mutex.unlock(); <span class="ent">➎</span>&#13;
    }&#13;
  });&#13;
  eat_cans.get();&#13;
  deposit_cans.get();&#13;
  cout &lt;&lt; "Tin cans: " &lt;&lt; tin_cans_available &lt;&lt; "\n";&#13;
}&#13;
&#13;
int main() {&#13;
  goat_rodeo(); <span class="ent">➏</span>&#13;
  goat_rodeo(); <span class="ent">➐</span>&#13;
  goat_rodeo(); <span class="ent">➑</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">Tin cans: 0 <span class="ent">➏</span></span>&#13;
<span class="color1">Tin cans: 0 <span class="ent">➐</span></span>&#13;
<span class="color1">Tin cans: 0 <span class="ent">➑</span></span></pre>&#13;
<p class="listing"><a id="ch19ex11"/><em>Listing 19-11: Using a <code>mutex</code> to resolve the race condition in <a href="ch19.xhtml#ch19ex10">Listing 19-10</a></em></p>&#13;
<p class="indent">You add a <code>mutex</code> into <code>goat_rodeo</code> <span class="ent">➊</span> called <code>tin_can_mutex</code>, which provides mutual exclusion on the <code>tin_cans_available</code>. Inside each asynchronous task, a thread acquires a lock <span class="ent">➋</span><span class="ent">➍</span> before modifying <code>tin_cans_available</code>. Once the thread is done modifying, it unlocks <span class="ent">➌</span><span class="ent">➎</span>. Notice that the resulting number of available tin cans at the end of each run is zero <span class="ent">➏</span><span class="ent">➐</span><span class="ent">➑</span>, reflecting that you’ve fixed your race condition.</p>&#13;
<div class="box5" id="bm03">&#13;
<p class="boxtitle-d"><strong>MUTEX IMPLEMENTATIONS</strong></p>&#13;
<p class="noindent">In practice, mutexes are implemented in a number of ways. Perhaps the simplest mutex is a <em>spin lock</em> in which a thread will execute a loop until the lock is released. This kind of lock usually minimizes the amount of time between a lock getting released by one thread and acquired by another. But it’s computationally expensive because a CPU is spending all of its time checking for lock availability when some other thread could be doing productive work. Typically, mutexes require atomic instructions, such as <code>compare-and-swap</code>, <code>fetch-and-add</code>, or <code>test-and-set</code>, so they can check for and acquire a lock in one operation.</p>&#13;
<p class="indent">Modern operating systems, like Windows, offer more efficient alternatives to spin locks. For example, mutexes based on <em>asynchronous procedure calls</em> allow threads to wait on a mutex and go into a <em>wait state</em>. Once the mutex becomes available, the operating system awakens the waiting thread and hands off ownership of the mutex. This allows other threads to do productive work on a CPU that would otherwise be occupied in a spin lock.</p>&#13;
<p class="indent">In general, you won’t need to worry about the details of how mutexes are implemented by your operating system unless they become a bottleneck in your program.</p>&#13;
</div>&#13;
<p class="indent">If you’re thinking that handling <code>mutex</code> locking is a perfect job for an RAII object, you’re right. Suppose you forgot to invoke <code>unlock</code> on a mutex, say because it threw an exception. When the next thread comes along and attempts to acquire the mutex with <code>lock</code>, your program will come to a screeching halt. For this reason, the stdlib provides RAII classes for handling mutexes in the <code>&lt;mutex&gt;</code> header. There you’ll find several class templates, all of which accept mutexes as constructor parameters and a template parameter corresponding to the class of the mutexes:</p>&#13;
<ul>&#13;
<li class="noindent"><code>std::lock_guard</code> is a non-copyable, non-moveable RAII wrapper that accepts a mutex object in its constructor, where it calls <code>lock</code>. It then calls <code>unlock</code> in the destructor.</li>&#13;
<li class="noindent"><code>std::scoped_lock</code> is a deadlock avoiding RAII wrapper for multiple mutexes.</li>&#13;
<li class="noindent"><code>std::unique_lock</code> implements a movable mutex ownership wrapper.</li>&#13;
<li class="noindent"><code>std::shared_lock</code> implements a movable shared mutex ownership wrapper.</li>&#13;
</ul>&#13;
<p class="indent">For brevity, this section focuses on <code>lock_guard</code>. <a href="ch19.xhtml#ch19ex12">Listing 19-12</a> shows how to refactor <a href="ch19.xhtml#ch19ex11">Listing 19-11</a> to use <code>lock_guard</code> instead of manual <code>mutex</code> manipulation.</p>&#13;
<pre>#include &lt;future&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;mutex&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
<span epub:type="pagebreak" id="page_651"/>void goat_rodeo() {&#13;
  const size_t iterations{ 1'000'000 };&#13;
  int tin_cans_available{};&#13;
  mutex tin_can_mutex;&#13;
  auto eat_cans = async(launch::async, [&amp;] {&#13;
    for(size_t i{}; i&lt;iterations; i++) {&#13;
      lock_guard&lt;mutex&gt; guard{ tin_can_mutex }; <span class="ent">➊</span>&#13;
      tin_cans_available--;&#13;
    }&#13;
  });&#13;
  auto deposit_cans = async(launch::async, [&amp;] {&#13;
    for(size_t i{}; i&lt;iterations; i++) {&#13;
      lock_guard&lt;mutex&gt; guard{ tin_can_mutex }; <span class="ent">➋</span>&#13;
      tin_cans_available++;&#13;
    }&#13;
  });&#13;
  eat_cans.get();&#13;
  deposit_cans.get();&#13;
  cout &lt;&lt; "Tin cans: " &lt;&lt; tin_cans_available &lt;&lt; "\n";&#13;
}&#13;
&#13;
int main() {&#13;
  goat_rodeo();&#13;
  goat_rodeo();&#13;
  goat_rodeo();&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">Tin cans: 0</span>&#13;
<span class="color1">Tin cans: 0</span>&#13;
<span class="color1">Tin cans: 0</span></pre>&#13;
<p class="listing"><a id="ch19ex12"/><em>Listing 19-12: Refactoring <a href="ch19.xhtml#ch19ex11">Listing 19-11</a> to use <code>lock_guard</code></em></p>&#13;
<p class="indent">Rather than using <code>lock</code> and <code>unlock</code> to manage mutual exclusion, you construct a <code>lock_guard</code> at the beginning of each scope where you need synchronization <span class="ent">➊</span><span class="ent">➋</span>. Because your mutual exclusion mechanism is a <code>mutex</code>, you specify it as your <code>lock_guard</code> template parameter. <a href="ch19.xhtml#ch19ex11">Listing 19-11</a> and <a href="ch19.xhtml#ch19ex12">Listing 19-12</a> have equivalent runtime behavior, including how long it takes the programs to execute. RAII objects don’t involve any additional runtime costs over programming releases and acquisitions by hand.</p>&#13;
<p class="indent">Unfortunately, mutual exclusion locks involve runtime costs. You might also have noticed that executing <a href="ch19.xhtml#ch19ex11">Listings 19-11</a> and <a href="ch19.xhtml#ch19ex12">19-12</a> took substantially longer than executing <a href="ch19.xhtml#ch19ex10">Listing 19-10</a>. The reason is that acquiring and releasing locks is a relatively expensive operation. In <a href="ch19.xhtml#ch19ex11">Listings 19-11</a> and <a href="ch19.xhtml#ch19ex12">19-12</a>, the <code>tin_can_mutex</code> gets acquired and then released two million times. Relative to incrementing or decrementing an integer, acquiring or releasing a lock takes substantially more time, so using a mutex to synchronize the asynchronous tasks is suboptimal. In certain situations, you can take a potentially more efficient approach by using atomics.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>For more information about asynchronous tasks and futures, refer to [futures.async].</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch19lev3sec5"><span epub:type="pagebreak" id="page_652"/><strong>Atomics</strong></h5>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_653"/>The word <em>atomic</em> comes from the Greek <em>átomos</em>, meaning “indivisible.” An operation is atomic if it occurs in an indivisible unit. Another thread cannot observe the operation halfway through. When you introduced locks into <a href="ch19.xhtml#ch19ex10">Listing 19-10</a> to produce <a href="ch19.xhtml#ch19ex11">Listing 19-11</a>, you made the increment and decrement operations atomic because the asynchronous tasks could no longer interleave read and write operations on <code>tin_cans_available</code>. As you experienced running this lock-based solution, this approach is very slow because acquiring locks is expensive.</p>&#13;
<p class="indent">Another approach is to use the <code>std::atomic</code> class template in the <code>&lt;atomic&gt;</code> header, which provides primitives often used in <em>lock-free concurrent programming</em>. Lock-free concurrent programming solves data race issues without involving locks. On many modern architectures, CPUs support atomic instructions. Using atomics, you might be able to avoid locks by leaning on atomic hardware instructions.</p>&#13;
<p class="indent">This chapter doesn’t discuss <code>std::atomic</code> or how to devise your own lock-free solutions in detail, because it’s incredibly difficult to do correctly and is best left to experts. However, in simple situations, such as in <a href="ch19.xhtml#ch19ex10">Listing 19-10</a>, you can employ a <code>std::atomic</code> to make sure that the increment or decrement operations cannot be divided. This neatly solves your data race problem.</p>&#13;
<p class="indent">The <code>std::atomic</code> template offers specializations for all fundamental types, as shown in <a href="ch19.xhtml#ch19tab02">Table 19-2</a>.</p>&#13;
<p class="tabcap" id="ch19tab02"><strong>Table 19-2:</strong> <code>std::atomic</code> Template Specializations for the Fundamental Types</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Template specialization</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Alias</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>std::atomic&lt;bool&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>std::atomic_bool</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>std::atomic&lt;char&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>std::atomic_char</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>std::atomic&lt;unsigned char&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>std::atomic_uchar</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>std::atomic&lt;short&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>std::atomic_short</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>std::atomic&lt;unsigned short&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>std::atomic_ushort</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>std::atomic&lt;int&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>std::atomic_int</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>std::atomic&lt;unsigned int&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>std::atomic_uint</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>std::atomic&lt;long&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>std::atomic_long</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>std::atomic&lt;unsigned long&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>std::atomic_ulong</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>std::atomic&lt;long long&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>std::atomic_llong</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>std::atomic&lt;unsigned long long&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>std::atomic_ullong</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>std::atomic&lt;char16_t&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>std::atomic_char16_t</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>std::atomic&lt;char32_t&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>std::atomic_char32_t</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><code>std::atomic&lt;wchar_t&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><code>std::atomic_wchar_t</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><a href="ch19.xhtml#ch19tab03">Table 19-3</a> lists some of the supported operations for <code>std::atomic</code>. The <code>std::atomic</code> template has no copy constructor.</p>&#13;
<p class="tabcap" id="ch19tab03"><span epub:type="pagebreak" id="page_654"/><strong>Table 19-3:</strong> Supported Operations for <code>std::atomic</code></p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">a</span><code>{}</code></p>&#13;
<p class="taba"><span class="codestrong">a</span><code>{ 123 }</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Default constructor.</p>&#13;
<p class="taba">Initializes value to 123.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">a</span><code>.is_lock_free()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns true if <span class="codestrong">a</span> is lock-free. (Depends on the CPU.)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">a</span><code>.store(123)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Stores the value 123 into <span class="codestrong">a</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">a</span><code>.load()</code></p>&#13;
<p class="taba"><span class="codestrong">a</span><code>()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns the stored value.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">a</span><code>.exchange(123)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Replaces the current value with 123 and returns the old value. This is a “read-modify-write” operation.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="codestrong">a</span><code>.compare_exchange_weak(10, 20)</code></p>&#13;
<p class="taba"><span class="codestrong">a</span><code>.compare_exchange_strong(10, 20)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">If the current value is 10, replaces with 20. Returns true if the value was replaced. See <code>[atomic]</code> for details on weak versus strong.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Specializations for the types in <span class="codeitalic">&lt;cstdint&gt;</span> are also available. See [atomics.syn] for details.</em></p>&#13;
</div>&#13;
<p class="indent">For the numeric types, the specializations offer additional operations, as listed in <a href="ch19.xhtml#ch19tab04">Table 19-4</a>.</p>&#13;
<p class="tabcap" id="ch19tab04"><strong>Table 19-4:</strong> Supported Operations for Numeric Specializations of a <code>std::atomic</code> <span class="codestrong">a</span></p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">a</span><code>.fetch_add(123)</code></p>&#13;
<p class="taba"><span class="codestrong">a</span><code>+=123</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Replaces the current value with the result of adding the argument to the current value. Returns the value before modification. This is a “read-modify-write” operation.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">a</span><code>.fetch_sub(123)</code></p>&#13;
<p class="taba"><span class="codestrong">a</span><code>-=123</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Replaces the current value with the result of subtracting the argument from the current value. Returns the value before modification. This is a “read-modify-write” operation.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">a</span><code>.fetch_and(123)</code></p>&#13;
<p class="taba"><span class="codestrong">a</span><code>&amp;=123</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Replaces the current value with the result of bitwise ANDing the argument with the current value. Returns the value before modification. This is a “read-modify-write” operation.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">a</span><code>.fetch_or(123)</code></p>&#13;
<p class="taba"><span class="codestrong">a</span><code>|=123</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Replaces the current value with the result of bitwise ORing the argument with the current value. Returns the value before modification. This is a “read-modify-write” operation.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">a</span><code>.fetch_xor(123)</code></p>&#13;
<p class="taba"><span class="codestrong">a</span><code>^=123</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Replaces the current value with the result of bitwise XORing the argument with the current value. Returns the value before modification. This is a “read-modify-write” operation.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="codestrong">a</span><code>++</code></p>&#13;
<p class="taba"><span class="codestrong">a</span><code>--</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Increments or decrements <span class="codestrong">a</span>.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Because <a href="ch19.xhtml#ch19ex12">Listing 19-12</a> is a prime candidate for a lock-free solution, you can replace the type of <code>tin_cans_available</code> with <code>atomic_int</code> and remove the <code>mutex</code>. This prevents race conditions like the one illustrated in <a href="ch19.xhtml#ch19tab01">Table 19-1</a>. <a href="ch19.xhtml#ch19ex13">Listing 19-13</a> implements this refactor.</p>&#13;
<pre><span epub:type="pagebreak" id="page_655"/>#include &lt;future&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;atomic&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
void goat_rodeo() {&#13;
  const size_t iterations{ 1'000'000 };&#13;
  atomic_int<span class="ent">➊</span> tin_cans_available{};&#13;
  auto eat_cans = async(launch::async, [&amp;] {&#13;
    for(size_t i{}; i&lt;iterations; i++)&#13;
      tin_cans_available--; <span class="ent">➋</span>&#13;
  });&#13;
  auto deposit_cans = async(launch::async, [&amp;] {&#13;
    for(size_t i{}; i&lt;iterations; i++)&#13;
      tin_cans_available++; <span class="ent">➌</span>&#13;
  });&#13;
  eat_cans.get();&#13;
  deposit_cans.get();&#13;
  cout &lt;&lt; "Tin cans: " &lt;&lt; tin_cans_available &lt;&lt; "\n";&#13;
}&#13;
&#13;
int main() {&#13;
  goat_rodeo();&#13;
  goat_rodeo();&#13;
  goat_rodeo();&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">Tin cans: 0</span>&#13;
<span class="color1">Tin cans: 0</span>&#13;
<span class="color1">Tin cans: 0</span></pre>&#13;
<p class="listing"><a id="ch19ex13"/><em>Listing 19-13: Resolving the race condition using <code>atomic_int</code> rather than <code>mutex</code></em></p>&#13;
<p class="indent">You replace <code>int</code> with <code>atomic_int</code> <span class="ent">➊</span> and remove the <code>mutex</code>. Because the decrement <span class="ent">➋</span> and increment <span class="ent">➌</span> operators are atomic, the race condition remains solved.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>For more information about atomics, refer to [atomics].</em></p>&#13;
</div>&#13;
<p class="indent">You also probably noticed a considerable performance boost from <a href="ch19.xhtml#ch19ex12">Listing 19-12</a> to <a href="ch19.xhtml#ch19ex12">19-13</a>. In general, using atomic operations will be much faster than acquiring a mutex.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">WARNING</span></strong></p>&#13;
<p class="notep"><em>Unless you have a very simple concurrent access problem, such as the one in this section, you really shouldn’t try to implement lock-free solutions on your own. Refer to the Boost Lockfree library for high-quality, thoroughly tested lock-free containers. As always, you must decide whether a lock-based or lock-free implementation is optimal.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch19lev3sec6"><span epub:type="pagebreak" id="page_656"/><strong>Condition Variables</strong></h5>&#13;
<p class="noindent">A <em>condition variable</em> is a synchronization primitive that blocks one or more threads until notified. Another thread can notify the condition variable. After notification, the condition variable can unblock one or more threads so they can make progress. A very popular condition variable pattern involves a thread performing the following actions:</p>&#13;
<ol>&#13;
<li class="noindent">Acquire some mutex shared with awaiting threads.</li>&#13;
<li class="noindent">Modify the shared state.</li>&#13;
<li class="noindent">Notify the condition variable.</li>&#13;
<li class="noindent">Release the mutex.</li>&#13;
</ol>&#13;
<p class="indent">Any threads waiting on the condition variable then perform the following actions:</p>&#13;
<ol>&#13;
<li class="noindent">Acquire the mutex.</li>&#13;
<li class="noindent">Wait on the condition variable (this releases the mutex).</li>&#13;
<li class="noindent">When another thread notifies the condition variable, this thread wakes up and can perform some work (this reacquires the mutex automatically).</li>&#13;
<li class="noindent">Release the mutex.</li>&#13;
</ol>&#13;
<p class="indent">Due to complications arising from the complexity of modern operating systems, sometimes threads can wake up spuriously. Therefore, it’s important to verify that a condition variable was in fact signaled once a waiting thread awakens.</p>&#13;
<p class="indent">The stdlib provides <code>std::condition_variable</code> in the <code>&lt;condition_variable&gt;</code> header, which supports several operations, including those in <a href="ch19.xhtml#ch19tab05">Table 19-5</a>. The <code>condition_variable</code> supports only default construction, and the copy constructor is deleted.</p>&#13;
<p class="tabcap" id="ch19tab05"><strong>Table 19-5:</strong> Supported Operations of a <code>std::condition_variable</code> <span class="codestrong">cv</span></p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">cv</span><code>.notify_one()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">If any threads are waiting on <span class="codestrong">cv</span>, this operation notifies one of them.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">cv</span><code>.notify_all()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">If any threads are waiting on <span class="codestrong">cv</span>, this operation notifies all of them.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">cv</span><code>.wait(</code><span class="codestrong">lock</span><code>, [</code><span class="codestrong">pred</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Given a <span class="codestrong">lock</span> on the mutex owned by the notifier, returns when awakened. If supplied, <span class="codestrong">pred</span> determines whether the notification is spurious (returns <code>false</code>) or real (returns <code>true</code>).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">cv</span><code>.wait_for(</code><span class="codestrong">lock</span><code>, [</code><span class="codestrong">durn</span><code>], [</code><span class="codestrong">pred</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Same as <span class="codestrong">cv</span><code>.wait</code> except <code>wait_for</code> only waits for <span class="codestrong">durn</span>. If timeout occurs and no <span class="codestrong">pred</span> is supplied, returns <code>std::cv_status::timeout</code>; otherwise, returns <code>std::cv_status::no_timeout</code>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="codestrong">cv</span><code>.wait_until(</code><span class="codestrong">lock</span><code>, [</code><span class="codestrong">time</span><code>], [</code><span class="codestrong">pred</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Same as <code>wait_for</code> except uses a <code>std::chrono::time_point</code> instead of a <code>std::chrono::duration</code>.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_657"/>For example, you can refactor <a href="ch19.xhtml#ch19ex12">Listing 19-12</a> so the <em>deposit cans</em> task completes before the <em>eat cans</em> task using a condition variable, as <a href="ch19.xhtml#ch19ex14">Listing 19-14</a> illustrates.</p>&#13;
<pre>#include &lt;future&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;mutex&gt;&#13;
#include &lt;condition_variable&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
void goat_rodeo() {&#13;
  mutex m; <span class="ent">➊</span>&#13;
  condition_variable cv; <span class="ent">➋</span>&#13;
  const size_t iterations{ 1'000'000 };&#13;
  int tin_cans_available{};&#13;
  auto eat_cans = async(launch::async, [&amp;] {&#13;
    unique_lock&lt;mutex&gt; lock{ m }; <span class="ent">➌</span>&#13;
    cv.wait(lock, [&amp;] { return tin_cans_available == 1'000'000; }); <span class="ent">➍</span>&#13;
    for(size_t i{}; i&lt;iterations; i++)&#13;
      tin_cans_available--;&#13;
  });&#13;
&#13;
  auto deposit_cans = async(launch::async, [&amp;] {&#13;
    scoped_lock&lt;mutex&gt; lock{ m }; <span class="ent">➎</span>&#13;
    for(size_t i{}; i&lt;iterations; i++)&#13;
      tin_cans_available++;&#13;
    cv.notify_all(); <span class="ent">➏</span>&#13;
  });&#13;
  eat_cans.get();&#13;
  deposit_cans.get();&#13;
  cout &lt;&lt; "Tin cans: " &lt;&lt; tin_cans_available &lt;&lt; "\n";&#13;
}&#13;
&#13;
int main() {&#13;
  goat_rodeo();&#13;
  goat_rodeo();&#13;
  goat_rodeo();&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">Tin cans: 0</span>&#13;
<span class="color1">Tin cans: 0</span>&#13;
<span class="color1">Tin cans: 0</span></pre>&#13;
<p class="listing"><a id="ch19ex14"/><em>Listing 19-14: Using condition variables to ensure all cans are deposited before they’re eaten</em></p>&#13;
<p class="indent">You declare a <code>mutex</code> <span class="ent">➊</span> and a <code>condition_variable</code> <span class="ent">➋</span> that you’ll use to coordinate the asynchronous tasks. Within the <em>eat cans</em> task, you acquire a <code>unique_lock</code> to the <code>mutex</code>, which you pass into <code>wait</code> along with a predicate that returns <code>true</code> if there are cans available <span class="ent">➌</span>. This method will release the mutex and then block until two conditions are met: the <code>condition_variable</code> awakens this thread and one million tin cans are available <span class="ent">➍</span> (recall that you must check that all the cans are available because of spurious wakeups). <span epub:type="pagebreak" id="page_658"/>Within the <em>deposit cans</em> task, you acquire a lock on the <code>mutex</code> <span class="ent">➎</span>, deposit the cans, and then notify all threads blocked on the <code>condition_variable</code> <span class="ent">➏</span>.</p>&#13;
<p class="indent">Note that, unlike with all the previous approaches, it’s impossible for <code>tin_cans_available</code> to be negative because the ordering of deposit cans and eat cans is guaranteed.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>For more information about condition variables, refer to <em>[thread.condition]</em>.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch19lev2sec3"><strong><em>Low-Level Concurrency Facilities</em></strong></h4>&#13;
<p class="noindent">The stdlib’s <code>&lt;thread&gt;</code> library contains low-level facilities for concurrent programming. The <code>std::thread</code> class, for example, models an operating system thread. However, it’s best not to use <code>thread</code> directly and instead design concurrency into your programs with higher-level abstractions, like tasks. Should you require low-level thread access, [thread] offers more information.</p>&#13;
<p class="indent">But the <code>&lt;thread&gt;</code> library does include several useful functions for manipulating the current thread:</p>&#13;
<ul>&#13;
<li class="noindent">The <code>std::this_thread::yield</code> function accepts no arguments and returns <code>void</code>. The exact behavior of <code>yield</code> depends on the environment, but in general it provides a hint that the operating system should give other threads a chance to run. This is useful when, for example, there’s high lock contention over a particular resource and you want to help all threads get a chance at access.</li>&#13;
<li class="noindent">The <code>std::this_thread::get_id</code> function accepts no arguments and returns an object of type <code>std::thread::id</code>, which is a lightweight thread that supports comparison operators and <code>operator&lt;&lt;</code>. Typically, it’s used as a key in associative containers.</li>&#13;
<li class="noindent">The <code>std::this_thread::sleep_for</code> function accepts a <code>std::chrono::duration</code> argument, blocks execution on the current thread until at least the specified duration passes, and returns <code>void</code>.</li>&#13;
<li class="noindent">The <code>std::this_thread::sleep_until</code> accepts a <code>std::chrono::time_point</code> and returns void. It is entirely analogous to <code>sleep_for</code> except it blocks the thread until at least the specified <code>time_point</code>.</li>&#13;
</ul>&#13;
<p class="indent">When you need these functions, they’re indispensable. Otherwise, you really shouldn’t need to interact with the <code>&lt;thread&gt;</code> header.</p>&#13;
<h3 class="h3" id="ch19lev1sec2"><strong>Parallel Algorithms</strong></h3>&#13;
<p class="noindent"><a href="ch18.xhtml">Chapter 18</a> introduced the stdlib’s algorithms, many of which take an optional first argument called its execution policy encoded by a <code>std::execution</code> value. In supported environments, there are three possible values: <code>seq</code>, <code>par</code>, and <code>par_unseq</code>. The latter two options indicate that you want to execute the algorithm in parallel.</p>&#13;
<h4 class="h4" id="ch19lev2sec4"><span epub:type="pagebreak" id="page_659"/><strong><em>An Example: Parallel sort</em></strong></h4>&#13;
<p class="noindent"><a href="ch19.xhtml#ch19ex15">Listing 19-15</a> illustrates how changing a single argument from <code>seq</code> to <code>par</code> can have a massive impact on a program’s runtime by sorting a billion numbers both ways.</p>&#13;
<pre>#include &lt;algorithm&gt;&#13;
#include &lt;vector&gt;&#13;
#include &lt;numeric&gt;&#13;
#include &lt;random&gt;&#13;
#include &lt;chrono&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;execution&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
// From <a href="ch12.xhtml#ch12ex25">Listing 12-25</a>:&#13;
struct Stopwatch {&#13;
--<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
vector&lt;long&gt; make_random_vector() { <span class="ent">➊</span>&#13;
  vector&lt;long&gt; numbers(1'000'000'000);&#13;
  iota(numbers.begin(), numbers.end(), 0);&#13;
  mt19937_64 urng{ 121216 };&#13;
  shuffle(numbers.begin(), numbers.end(), urng);&#13;
  return numbers;&#13;
}&#13;
&#13;
int main() {&#13;
  cout &lt;&lt; "Constructing random vectors...";&#13;
  auto numbers_a = make_random_vector(); <span class="ent">➋</span>&#13;
  auto numbers_b{ numbers_a }; <span class="ent">➌</span>&#13;
  chrono::nanoseconds time_to_sort;&#13;
  cout &lt;&lt; " " &lt;&lt; numbers_a.size() &lt;&lt; " elements.\n";&#13;
  cout &lt;&lt; "Sorting with execution::seq...";&#13;
  {&#13;
    Stopwatch stopwatch{ time_to_sort };&#13;
    sort(execution::seq, numbers_a.begin(), numbers_a.end()); <span class="ent">➍</span>&#13;
  }&#13;
  cout &lt;&lt; " took " &lt;&lt; time_to_sort.count() / 1.0E9 &lt;&lt; " sec.\n";&#13;
&#13;
  cout &lt;&lt; "Sorting with execution::par...";&#13;
  {&#13;
    Stopwatch stopwatch{ time_to_sort };&#13;
    sort(execution::par, numbers_b.begin(), numbers_b.end()); <span class="ent">➎</span>&#13;
  }&#13;
  cout &lt;&lt; " took " &lt;&lt; time_to_sort.count() / 1.0E9 &lt;&lt; " sec.\n";&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span epub:type="pagebreak" id="page_660"/><span class="color1">Constructing random vectors... 1000000000 elements.</span>&#13;
<span class="color1">Sorting with execution::seq... took 150.489 sec.</span>&#13;
<span class="color1">Sorting with execution::par... took 17.7305 sec.</span></pre>&#13;
<p class="listing"><a id="ch19ex15"/><em>Listing 19-15: Sorting a billion numbers using <code>std::sort</code> with <code>std::execution::seq</code> versus <code>std::execution::par</code>. (Results are from a Windows 10 x64 machine with two Intel Xeon E5-2620 v3 processors.)</em></p>&#13;
<p class="indent">The <code>make_random_vector</code> function <span class="ent">➊</span> produces a <code>vector</code> containing a billion unique numbers. You build two copies, <code>numbers_a</code> <span class="ent">➋</span> and <code>numbers_b</code> <span class="ent">➌</span>. You sort each <code>vector</code> separately. In the first case, you sort with a sequential execution policy <span class="ent">➍</span>, and <code>Stopwatch</code> indicates that the operation took about two and a half minutes (about 150 seconds). In the second case, you sort with a parallel execution policy <span class="ent">➎</span>. In contrast, <code>Stopwatch</code> indicates that the operation took about 18 seconds. The sequential execution took roughly 8.5 times as long.</p>&#13;
<h4 class="h4" id="ch19lev2sec5"><strong><em>Parallel Algorithms Are Not Magic</em></strong></h4>&#13;
<p class="noindent">Unfortunately, parallel algorithms aren’t magic. Although they work brilliantly in simple situations, such as with <code>sort</code> in <a href="ch19.xhtml#ch19ex15">Listing 19-15</a>, you must be careful when using them. Any time an algorithm produces side effects beyond the target sequence, you have to think hard about race conditions. A red flag is any algorithm that passes a function object to the algorithm. If the function object has shared mutable state, the executing threads will have shared access and you might have a race condition. For example, consider the parallel <code>transform</code> invocation in <a href="ch19.xhtml#ch19ex16">Listing 19-16</a>.</p>&#13;
<pre>#include &lt;algorithm&gt;&#13;
#include &lt;vector&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;numeric&gt;&#13;
#include &lt;execution&gt;&#13;
&#13;
int main() {&#13;
  std::vector&lt;long&gt; numbers{ 1'000'000 }, squares{ 1'000'000 }; <span class="ent">➊</span>&#13;
  std::iota(numbers.begin(), numbers.end(), 0); <span class="ent">➋</span>&#13;
  size_t n_transformed{}; <span class="ent">➌</span>&#13;
  std::transform(std::execution::par, numbers.begin(), numbers.end(), <span class="ent">➍</span>&#13;
                 squares.begin(), [&amp;n_transformed] (const auto x) {&#13;
                  ++n_transformed; <span class="ent">➎</span>&#13;
                  return x * x; <span class="ent">➏</span>&#13;
                });&#13;
  std::cout &lt;&lt; "n_transformed: " &lt;&lt; n_transformed &lt;&lt; std::endl; <span class="ent">➐</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">n_transformed: 187215 <span class="ent">➐</span></span></pre>&#13;
<p class="listing"><a id="ch19ex16"/><em>Listing 19-16: A program containing a race condition due to non-atomic access to <code>n_transformed</code></em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_661"/>You begin by initializing two <code>vector</code> objects, <code>numbers</code> and <code>squares</code>, which contain a million elements <span class="ent">➊</span>. Next, you fill one of them with numbers using <code>iota</code> <span class="ent">➋</span> and initialize the variable <code>n_transformed</code> to <code>0</code> <span class="ent">➌</span>. You then invoke <code>transform</code> with a parallel execution policy, <code>numbers</code> as your target sequence, <code>squares</code> as your result sequence, and a simple lambda <span class="ent">➍</span>. The lambda increments <code>n_transformed</code> <span class="ent">➎</span> and returns the square of the argument <code>x</code> <span class="ent">➏</span>. Because multiple threads execute this lambda, access to <code>n_transformed</code> must be synchronized <span class="ent">➐</span>.</p>&#13;
<p class="indent">The previous section introduced two ways to solve this problem, locks and atomics. In this scenario, it’s probably best to just use a <code>std::atomic_size_t</code> as a drop-in replacement for <code>size_t</code>.</p>&#13;
<h3 class="h3" id="ch19lev1sec3"><strong>Summary</strong></h3>&#13;
<p class="noindent">This chapter surveyed concurrency and parallelism at a very high level. In addition, you learned how to launch asynchronous tasks, which allow you to easily introduce multithreaded programming concepts into your code. Although introducing parallel and concurrent concepts into your programs can provide a significant performance boost, you must carefully avoid introducing race conditions that invite undefined behavior. You also learned several mechanisms for synchronizing access to mutable shared state: mutexes, condition variables, and atomics.</p>&#13;
<div class="box5" id="bm01">&#13;
<p class="boxtitle-d"><strong>EXERCISES</strong></p>&#13;
<p class="noindent"><strong>19-1.</strong> Write your own spin lock-based mutex called <code>SpinLock</code>. Expose a <code>lock</code>, a <code>try_lock</code>, and an <code>unlock</code> method. Your class should delete the copy constructor. Try using a <code>std::lock_guard&lt;SpinLock&gt;</code> with an instance of your class.</p>&#13;
<p class="noindent"><strong>19-2.</strong> Read about the infamous double-checked locking pattern (DCLP) and why you shouldn’t use it. (See the article by Scott Meyers and Andrei Alexandrescu mentioned in the following “Further Reading” section.) Then read about the appropriate way to ensure that a callable gets invoked exactly once using <code>std::call_once</code> in [thread.once.callonce].</p>&#13;
<p class="noindent"><strong>19-3.</strong> Create a thread-safe queue class. This class must expose an interface like <code>std::queue</code> (see [queue.defn]). Use a <code>std::queue</code> internally to store elements. Use a <code>std::mutex</code> to synchronize access to this internal <code>std::queue</code>.</p>&#13;
<p class="noindent"><strong>19-4.</strong> Add a <code>wait_and_pop</code> method and a <code>std::condition_variable</code> member to your thread-safe queue. When a user invokes <code>wait_and_pop</code> and the queue contains an element, it should pop the element off the queue and return it. If the queue is empty, the thread should block until an element becomes available and then proceed to pop an element.</p>&#13;
<p class="noindent"><strong>19-5.</strong> (Optional) Read the Boost Coroutine2 documentation, especially the “Overview,” “Introduction,” and “Motivation” sections.</p>&#13;
</div>&#13;
<div class="box6" id="bm02">&#13;
<p class="boxtitle-d"><span epub:type="pagebreak" id="page_662"/><strong>FURTHER READING</strong></p>&#13;
<ul>&#13;
<li class="noindent">“C++ and The Perils of Double-Checked Locking: <a href="part01.xhtml#part01">Part I</a>” by Scott Meyers and Andrei Alexandrescu (<a href="http://www.drdobbs.com/cpp/c-and-the-perils-of-double-checked-locki/184405726/"><em>http://www.drdobbs.com/cpp/c-and-the-perils-of-double-checked-locki/184405726/</em></a>)</li>&#13;
<li class="noindent"><em>ISO International Standard ISO/IEC (2017) — Programming Language C++</em> (International Organization for Standardization; Geneva, Switzerland; <em><a href="https://isocpp.org/std/the-standard/">https://isocpp.org/std/the-standard/</a></em>)</li>&#13;
<li class="noindent"><em>C++ Concurrency in Action</em>, 2nd Edition, by Anthony Williams (Manning, 2018)</li>&#13;
<li class="noindent">“Effective Concurrency: Know When to Use an Active Object Instead of a Mutex” by Herb Sutter (<a href="https://herbsutter.com/2010/09/24/effective-concurrency-know-when-to-use-an-active-object-instead-of-a-mutex/"><em>https://herbsutter.com/2010/09/24/effective-concurrency-know-when-to-use-an-active-object-instead-of-a-mutex/</em></a>)</li>&#13;
<li class="noindent"><em>Effective Modern C++: 42 Specific Ways to Improve Your Use of C++ 11 and C++ 14</em> by Scott Meyers (O’Reilly Media, 2014)</li>&#13;
<li class="noindent">“A Survey of Modern Integer Factorization Algorithms” by Peter L. Montgomery. <em>CWI Quarterly</em> 7.4 (1994): 337–365.</li>&#13;
</ul>&#13;
</div>&#13;
</body></html>