<html><head></head><body>
<h2 class="h2" id="ch19"><span epub:type="pagebreak" id="page_639"/><strong><span class="big">19</span><br/>CONCURRENCY AND PARALLELISM</strong></h2>&#13;
<p class="quote"><em>The Senior Watchdog had her own watchwords: “Show me a completely smooth operation and I’ll show you someone who’s covering mistakes. Real boats rock.”<br/>—Frank Herbert,</em> Chapterhouse: Dune</p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">In programming, <em>concurrency</em> means two or more tasks running in a given time period. <em>Parallelism</em> means two or more tasks running at the same instant. Often, these terms are used interchangeably without negative consequence, because they’re so closely related. This chapter introduces the very basics of both concepts. Because concurrent and parallel programming are huge and complicated topics, thorough treatment requires an entire book. You’ll find such books in the “Further Reading” section at the end of this chapter.</p>&#13;
<p class="indent">In this chapter, you’ll learn about concurrent and parallel programming with futures. Next, you’ll learn how to share data safely with mutexes, condition variables, and atomics. Then the chapter illustrates how execution policies help to speed up your code but also contain hidden dangers.</p>&#13;
<h3 class="h3" id="ch19lev1sec1"><span epub:type="pagebreak" id="page_640"/><strong>Concurrent Programming</strong></h3>&#13;
<p class="noindent"><em>Concurrent programs</em> have multiple <em>threads of execution</em> (or simply <em>threads</em>), which are sequences of instructions. In most runtime environments, the operating system acts as a scheduler to determine when a thread executes its next instruction. Each process can have one or more threads, which typically share resources, such as memory, with each other. Because the scheduler determines when threads execute, the programmer can’t generally rely on their ordering. In exchange, programs can execute multiple tasks in the same time period (or at the same time), which often results in serious speedups. To observe any speedup from the serial to the concurrent version, your system will need concurrent hardware, for example, a multicore processor.</p>&#13;
<p class="indent">This section begins with asynchronous tasks, a high-level method for making your programs concurrent. Next, you’ll learn some basic methods for coordinating between these tasks when they’re handling shared mutable state. Then you’ll survey some low-level facilities available to you in the stdlib for unique situations in which the higher-level tools don’t have the performance characteristics you require.</p>&#13;
<h4 class="h4" id="ch19lev2sec1"><strong><em>Asynchronous Tasks</em></strong></h4>&#13;
<p class="noindent">One way to introduce concurrency into your program is by creating <em>asynchronous tasks</em>. An asynchronous task doesn’t immediately need a result. To launch an asynchronous task, you use the <span class="literal">std::async</span> function template in the <span class="literal">&lt;future&gt;</span> header.</p>&#13;
<h5 class="h5" id="ch19lev3sec1"><strong>async</strong></h5>&#13;
<p class="noindent">When you invoke <span class="literal">std::async</span>, the first argument is the launch policy <span class="literal">std::launch</span>, which takes one of two values: <span class="literal">std::launch::async</span> or <span class="literal">std::launch::deferred</span>. If you pass <span class="literal">launch::async</span>, the runtime creates a new thread to launch your task. If you pass <span class="literal">deferred</span>, the runtime waits until you need the task’s result before executing (a pattern sometimes called <em>lazy evaluation</em>). This first argument is optional and defaults to <span class="literal">async|deferred</span>, meaning it’s up to the implementation which strategy to employ. The second argument to <span class="literal">std::async</span> is a function object representing the task you want to execute. There are no restrictions on the number or type of arguments the function object accepts, and it might return any type. The <span class="literal">std::async</span> function is a variadic template with a function parameter pack. Any additional arguments you pass beyond the function object will be used to invoke the function object when the asynchronous task launches. Also, <span class="literal">std::async</span> returns an object called a <span class="literal">std::future</span>.</p>&#13;
<p class="indent">The following simplified <span class="literal">async</span> declaration helps to summarize:</p>&#13;
<pre>std::future&lt;FuncReturnType&gt; std::async([policy], func, Args&amp;&amp;... args);</pre>&#13;
<p class="indent">Now that you know how to invoke <span class="literal">async</span>, let’s look at how to interact with its return value.</p>&#13;
<h5 class="h5" id="ch19lev3sec2"><span epub:type="pagebreak" id="page_641"/><strong>Back to the future</strong></h5>&#13;
<p class="noindent">A <span class="literal">future</span> is a class template that holds the value of an asynchronous task. It has a single template parameter that corresponds with the type of the asynchronous task’s return value. For example, if you pass a function object that returns a <span class="literal">string</span>, <span class="literal">async</span> will return a <span class="literal">future&lt;string&gt;</span>. Given a <span class="literal">future</span>, you can interact with an asynchronous task in three ways.</p>&#13;
<p class="indent">First, you can query the <span class="literal">future</span> about its validity using the <span class="literal">valid</span> method. A valid <span class="literal">future</span> has a shared state associated with it. Asynchronous tasks have a shared state so they can communicate the results. Any <span class="literal">future</span> returned by <span class="literal">async</span> will be valid until you retrieve the asynchronous task’s return value, at which point the shared state’s lifetime ends, as <a href="ch19.xhtml#ch19ex01">Listing 19-1</a> illustrates.</p>&#13;
<pre>#include &lt;future&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
TEST_CASE("async returns valid future") {&#13;
  using namespace literals::string_literals;&#13;
  auto the_future = async([] { return "female"s; }); <span class="ent">➊</span>&#13;
  REQUIRE(the_future.valid()); <span class="ent">➋</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch19ex01"/><em>Listing 19-1: The <span class="literal">async</span> function returns a valid <span class="literal">future</span>.</em></p>&#13;
<p class="indent">You launch an asynchronous task that simply returns a <span class="literal">string</span> <span class="ent">➊</span>. Because <span class="literal">async</span> always returns a valid <span class="literal">future</span>, <span class="literal">valid</span> returns <span class="literal">true</span> <span class="ent">➋</span>.</p>&#13;
<p class="indent">If you default construct a <span class="literal">future</span>, it’s not associated with a shared state, so <span class="literal">valid</span> will return <span class="literal">false</span>, as <a href="ch19.xhtml#ch19ex02">Listing 19-2</a> illustrates.</p>&#13;
<pre>TEST_CASE("future invalid by default") {&#13;
  future&lt;bool&gt; default_future; <span class="ent">➊</span>&#13;
  REQUIRE_FALSE(default_future.valid()); <span class="ent">➋</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch19ex02"/><em>Listing 19-2: A default constructed <span class="literal">future</span> is invalid.</em></p>&#13;
<p class="indent">You default construct a <span class="literal">future</span> <span class="ent">➊</span>, and <span class="literal">valid</span> returns <span class="literal">false</span> <span class="ent">➋</span>.</p>&#13;
<p class="indent">Second, you can obtain the value from a valid <span class="literal">future</span> with its <span class="literal">get</span> method. If the asynchronous task hasn’t yet completed, the call to <span class="literal">get</span> will block the currently executed thread until the result is available. <a href="ch19.xhtml#ch19ex03">Listing 19-3</a> illustrates how to employ <span class="literal">get</span> to obtain return values.</p>&#13;
<pre>TEST_CASE("async returns the return value of the function object") {&#13;
  using namespace literals::string_literals;&#13;
  auto the_future = async([] { return "female"s; }); <span class="ent">➊</span>&#13;
  REQUIRE(the_future.get() == "female"); <span class="ent">➋</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch19ex03"/><em>Listing 19-3: The <span class="literal">async</span> function returns a valid <span class="literal">future</span>.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_642"/>You use <span class="literal">async</span> to launch an asynchronous task <span class="ent">➊</span> and then invoke the <span class="literal">get</span> method on the resulting <span class="literal">future</span>. As expected, the result is the return value of the function object you passed into <span class="literal">async</span> <span class="ent">➋</span>.</p>&#13;
<p class="indent">If an asynchronous task throws an exception, the <span class="literal">future</span> will collect that exception and throw it when you invoke <span class="literal">get</span>, as <a href="ch19.xhtml#ch19ex04">Listing 19-4</a> illustrates.</p>&#13;
<pre>TEST_CASE("get may throw ") {&#13;
  auto ghostrider = async(&#13;
                      [] { throw runtime_error{ "The pattern is full." }; }); <span class="ent">➊</span>&#13;
  REQUIRE_THROWS_AS(ghostrider.get(), runtime_error); <span class="ent">➋</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch19ex04"/><em>Listing 19-4: The <span class="literal">get</span> method will throw the exception thrown by an asynchronous task.</em></p>&#13;
<p class="indent">You pass a lambda to <span class="literal">async</span> that throws a <span class="literal">runtime_error</span> <span class="ent">➊</span>. When you invoke <span class="literal">get</span>, it throws the exception <span class="ent">➋</span>.</p>&#13;
<p class="indent">Third, you can check whether an asynchronous task has completed using either <span class="literal">std::wait_for</span> or <span class="literal">std::wait_until</span>. Which you choose depends on the sort of <span class="literal">chrono</span> object you want to pass. If you have a <span class="literal">duration</span> object, you’ll use <span class="literal">wait_for</span>. If you have a <span class="literal">time_point</span> object, you’ll use <span class="literal">wait_until</span>. Both return a <span class="literal">std::future_status</span>, which takes one of three values:</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">future_status::deferred</span> signals that the asynchronous task will be evaluated lazily, so the task will execute once you call <span class="literal">get</span>.</li>&#13;
<li class="noindent"><span class="literal">future_status::ready</span> indicates that the task has completed and the result is ready.</li>&#13;
<li class="noindent"><span class="literal">future_status::timeout</span> indicates that the task isn’t ready.</li>&#13;
</ul>&#13;
<p class="indent">If the task completes before the specified waiting period, <span class="literal">async</span> will return early.</p>&#13;
<p class="indent"><a href="ch19.xhtml#ch19ex05">Listing 19-5</a> illustrates how to use <span class="literal">wait_for</span> to check an asynchronous task’s status.</p>&#13;
<pre>TEST_CASE("wait_for indicates whether a task is ready") {&#13;
  using namespace literals::chrono_literals;&#13;
  auto sleepy = async(launch::async, [] { this_thread::sleep_for(100ms); }); <span class="ent">➊</span>&#13;
  const auto not_ready_yet = sleepy.wait_for(25ms); <span class="ent">➋</span>&#13;
  REQUIRE(not_ready_yet == future_status::timeout); <span class="ent">➌</span>&#13;
  const auto totally_ready = sleepy.wait_for(100ms); <span class="ent">➍</span>&#13;
  REQUIRE(totally_ready == future_status::ready); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch19ex05"/><em>Listing 19-5: Checking an asynchronous task’s status using <span class="literal">wait_for</span></em></p>&#13;
<p class="indent">You first launch an asynchronous task with <span class="literal">async</span>, which simply waits for up to 100 milliseconds before returning <span class="ent">➊</span>. Next, you call <span class="literal">wait_for</span> with 25 milliseconds <span class="ent">➋</span>. Because the task is still sleeping (25 &lt; 100), <span class="literal">wait_for</span> returns <span class="literal">future_status::timeout</span> <span class="ent">➌</span>. You call <span class="literal">wait_for</span> again and wait for up to another 100 milliseconds <span class="ent">➍</span>. Because the second <span class="literal">wait_for</span> will finish after the <span class="literal">async</span> task finishes, the final <span class="literal">wait_for</span> will return a <span class="literal">future_status::ready</span> <span class="ent">➎</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><span epub:type="pagebreak" id="page_643"/><em>Technically, the assertions in <a href="ch19.xhtml#ch19ex05">Listing 19-5</a> aren’t guaranteed to pass. “Waiting” on <a href="ch12.xhtml#page_389">page 389</a> introduced <span class="codeitalic">this_thread::sleep_for</span>, which isn’t exact. The operating environment is responsible for scheduling threads, and it might schedule the sleeping thread later than the specified duration.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch19lev3sec3"><strong>An Example with Asynchronous Tasks</strong></h5>&#13;
<p class="noindent"><a href="ch19.xhtml#ch19ex06">Listing 19-6</a> contains the <span class="literal">factorize</span> function, which finds all of an integer’s factors.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The factorization algorithm in <a href="ch19.xhtml#ch19ex06">Listing 19-6</a> is woefully inefficient but is good enough for this example. For efficient integer factorization algorithms, refer to Dixon’s algorithm, the continued fraction factorization algorithm, or the quadratic sieve.</em></p>&#13;
</div>&#13;
<pre>#include &lt;set&gt;&#13;
&#13;
template &lt;typename T&gt;&#13;
std::multiset&lt;T&gt; factorize(T x) {&#13;
  std::multiset&lt;T&gt; result{ 1 }; <span class="ent">➊</span>&#13;
  for(T candidate{ 2 }; candidate &lt;= x; candidate++) { <span class="ent">➋</span>&#13;
    if (x % candidate == 0) { <span class="ent">➌</span>&#13;
      result.insert(candidate); <span class="ent">➍</span>&#13;
      x /= candidate; <span class="ent">➎</span>&#13;
      candidate = 1; <span class="ent">➏</span>&#13;
    }&#13;
  }&#13;
  return result;&#13;
}</pre>&#13;
<p class="listing"><a id="ch19ex06"/><em>Listing 19-6: A very simple integer factorization algorithm</em></p>&#13;
<p class="indent">The algorithm accepts a single argument <span class="literal">x</span> and begins by initializing a <span class="literal">set</span> containing 1 <span class="ent">➊</span>. Next, it iterates from 2 to <span class="literal">x</span> <span class="ent">➋</span>, checking whether modulo division with the <span class="literal">candidate</span> results in 0 <span class="ent">➌</span>. If it does, <span class="literal">candidate</span> is a factor, and you add it to the factor <span class="literal">set</span> <span class="ent">➍</span>. You divide <span class="literal">x</span> by the factor you just discovered <span class="ent">➎</span> and then restart your search by resetting the <span class="literal">candidate</span> to 1 <span class="ent">➏</span>.</p>&#13;
<p class="indent">Because integer factorization is a hard problem (and because <a href="ch19.xhtml#ch19ex06">Listing 19-6</a> is so inefficient), calls to <span class="literal">factorize</span> can take a long time relative to most of the functions you’ve encountered so far in the book. This makes it a prime candidate for asynchronous tasking. The <span class="literal">factor_task</span> function in <a href="ch19.xhtml#ch19ex07">Listing 19-7</a> uses the trusty <span class="literal">Stopwatch</span> from <a href="ch12.xhtml#ch12ex25">Listing 12-25</a> in <a href="ch12.xhtml#ch12">Chapter 12</a> to wrap <span class="literal">factorize</span> and returns a nicely formatted message.</p>&#13;
<pre>#include &lt;set&gt;&#13;
#include &lt;chrono&gt;&#13;
#include &lt;sstream&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
struct Stopwatch {&#13;
<span epub:type="pagebreak" id="page_644"/>--<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
template &lt;typename T&gt;&#13;
set&lt;T&gt; factorize(T x) {&#13;
--<span class="codeitalic1">snip</span>--&#13;
}&#13;
&#13;
string factor_task(unsigned long x) { <span class="ent">➊</span>&#13;
  chrono::nanoseconds elapsed_ns;&#13;
  set&lt;unsigned long long&gt; factors;&#13;
  {&#13;
    Stopwatch stopwatch{ elapsed_ns }; <span class="ent">➋</span>&#13;
    factors = factorize(x); <span class="ent">➌</span>&#13;
  }&#13;
  const auto elapsed_ms =&#13;
             chrono::duration_cast&lt;chrono::milliseconds&gt;(elapsed_ns).count(); <span class="ent">➍</span>&#13;
  stringstream ss;&#13;
  ss &lt;&lt; elapsed_ms &lt;&lt; " ms: Factoring " &lt;&lt; x &lt;&lt; " ( "; <span class="ent">➎</span>&#13;
  for(auto factor : factors) ss &lt;&lt; factor &lt;&lt; " "; <span class="ent">➏</span>&#13;
  ss &lt;&lt; ")\n";&#13;
  return ss.str(); <span class="ent">➐</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch19ex07"/><em>Listing 19-7: A <span class="literal">factor_task</span> function that wraps a call to <span class="literal">factorize</span> and returns a nicely formatted message</em></p>&#13;
<p class="indent">Like <span class="literal">factorize</span>, <span class="literal">factor_task</span> accepts a single argument <span class="literal">x</span> to factorize <span class="ent">➊</span>. (For simplicity, <span class="literal">factor_task</span> takes an <span class="literal">unsigned long</span> rather than a templated argument). Next, you initialize a <span class="literal">Stopwatch</span> within a nested scope <span class="ent">➋</span> and then invoke <span class="literal">factorize</span> with <span class="literal">x</span> <span class="ent">➌</span>. The result is that <span class="literal">elapsed_ns</span> contains the number of nanoseconds elapsed while <span class="literal">factorize</span> executed, and <span class="literal">factors</span> contains all the factors of <span class="literal">x</span>.</p>&#13;
<p class="indent">Next, you construct a nicely formatted string by first converting <span class="literal">elapsed_ns</span> to a count in milliseconds <span class="ent">➍</span>. You write this information into a <span class="literal">stringstream</span> object called <span class="literal">ss</span> <span class="ent">➎</span> followed by the factors of <span class="literal">x</span> <span class="ent">➏</span>. Then you return the resulting <span class="literal">string</span> <span class="ent">➐</span>.</p>&#13;
<p class="indent"><a href="ch19.xhtml#ch19ex08">Listing 19-8</a> employs <span class="literal">factor_task</span> to factor six different numbers and record the total elapsed program time.</p>&#13;
<pre>#include &lt;set&gt;&#13;
#include &lt;array&gt;&#13;
#include &lt;vector&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;limits&gt;&#13;
#include &lt;chrono&gt;&#13;
#include &lt;sstream&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
struct Stopwatch {&#13;
--<span class="codeitalic1">snip</span>--&#13;
<span epub:type="pagebreak" id="page_645"/>};&#13;
&#13;
template &lt;typename T&gt;&#13;
set&lt;T&gt; factorize(T x) {&#13;
--<span class="codeitalic1">snip</span>--&#13;
}&#13;
&#13;
string factor_task(unsigned long long x) {&#13;
--<span class="codeitalic1">snip</span>--&#13;
}&#13;
&#13;
array&lt;unsigned long long, 6&gt; numbers{ <span class="ent">➊</span>&#13;
        9'699'690,&#13;
        179'426'549,&#13;
        1'000'000'007,&#13;
        4'294'967'291,&#13;
        4'294'967'296,&#13;
        1'307'674'368'000&#13;
};&#13;
&#13;
int main() {&#13;
  chrono::nanoseconds elapsed_ns;&#13;
  {&#13;
    Stopwatch stopwatch{ elapsed_ns }; <span class="ent">➋</span>&#13;
    for(auto number : numbers) <span class="ent">➌</span>&#13;
      cout &lt;&lt; factor_task(number); <span class="ent">➍</span>&#13;
  }&#13;
  const auto elapsed_ms =&#13;
             chrono::duration_cast&lt;chrono::milliseconds&gt;(elapsed_ns).count(); <span class="ent">➎</span>&#13;
  cout &lt;&lt; elapsed_ms &lt;&lt; "ms: total program time\n"; <span class="ent">➏</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">0 ms: Factoring 9699690 ( 1 2 3 5 7 11 13 17 19 )</span>&#13;
<span class="color1">1274 ms: Factoring 179426549 ( 1 179426549 )</span>&#13;
<span class="color1">6804 ms: Factoring 1000000007 ( 1 1000000007 )</span>&#13;
<span class="color1">29035 ms: Factoring 4294967291 ( 1 4294967291 )</span>&#13;
<span class="color1">0 ms: Factoring 4294967296 ( 1 2 )</span>&#13;
<span class="color1">0 ms: Factoring 1307674368000 ( 1 2 3 5 7 11 13 )</span>&#13;
<span class="color1">37115ms: total program time</span></pre>&#13;
<p class="listing"><a id="ch19ex08"/><em>Listing 19-8: A program using <span class="literal">factor_task</span> to factorize six different numbers</em></p>&#13;
<p class="indent">You construct an array containing six <span class="literal">numbers</span> of varied size and primality <span class="ent">➊</span>. Next, you initialize a <span class="literal">Stopwatch</span> <span class="ent">➋</span>, iterate over each element in <span class="literal">numbers</span> <span class="ent">➌</span>, and invoke <span class="literal">factor_task</span> with them <span class="ent">➍</span>. You then determine the program’s runtime in milliseconds <span class="ent">➎</span> and print it <span class="ent">➏</span>.</p>&#13;
<p class="indent">The output shows that some numbers, such as 9,699,690, 4,294,967,296, and 1,307,674,368,000, factor almost immediately because they contain small factors. However, the prime numbers take quite a while. Note that because the program is single threaded, the runtime for the entire program roughly equals the sum of the times taken to factorize each number.</p>&#13;
<p class="indent">What if you treat each <span class="literal">factor_task</span> as an asynchronous task? <a href="ch19.xhtml#ch19ex09">Listing 19-9</a> illustrates how to do this with <span class="literal">async</span>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_646"/>#include &lt;set&gt;&#13;
#include &lt;vector&gt;&#13;
#include &lt;array&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;limits&gt;&#13;
#include &lt;chrono&gt;&#13;
#include &lt;future&gt;&#13;
#include &lt;sstream&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
struct Stopwatch {&#13;
--<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
template &lt;typename T&gt;&#13;
set&lt;T&gt; factorize(T x) {&#13;
--<span class="codeitalic1">snip</span>--&#13;
}&#13;
&#13;
string factor_task(unsigned long long x) {&#13;
--<span class="codeitalic1">snip</span>--&#13;
}&#13;
&#13;
array&lt;unsigned long long, 6&gt; numbers{&#13;
--<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
int main() {&#13;
  chrono::nanoseconds elapsed_ns;&#13;
  {&#13;
    Stopwatch stopwatch{ elapsed_ns }; <span class="ent">➊</span>&#13;
    vector&lt;future&lt;string&gt;&gt; factor_tasks; <span class="ent">➋</span>&#13;
    for(auto number : numbers) <span class="ent">➌</span>&#13;
      factor_tasks.emplace_back(async(launch::async, factor_task, number)); <span class="ent">➍</span>&#13;
    for(auto&amp; task : factor_tasks) <span class="ent">➎</span>&#13;
      cout &lt;&lt; task.get(); <span class="ent">➏</span>&#13;
  }&#13;
  const auto elapsed_ms =&#13;
             chrono::duration_cast&lt;chrono::milliseconds&gt;(elapsed_ns).count(); <span class="ent">➐</span>&#13;
  cout &lt;&lt; elapsed_ms &lt;&lt; " ms: total program time\n"; <span class="ent">➑</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">0 ms: Factoring 9699690 ( 1 2 3 5 7 11 13 17 19 )</span>&#13;
<span class="color1">1252 ms: Factoring 179426549 ( 1 179426549 )</span>&#13;
<span class="color1">6816 ms: Factoring 1000000007 ( 1 1000000007 )</span>&#13;
<span class="color1">28988 ms: Factoring 4294967291 ( 1 4294967291 )</span>&#13;
<span class="color1">0 ms: Factoring 4294967296 ( 1 2 )</span>&#13;
<span class="color1">0 ms: Factoring 1307674368000 ( 1 2 3 5 7 11 13 )</span>&#13;
<span class="color1">28989 ms: total program time</span></pre>&#13;
<p class="listing"><a id="ch19ex09"/><em>Listing 19-9: A program using <span class="literal">factor_task</span> to factorize six different numbers asynchronously</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_647"/>As in <a href="ch19.xhtml#ch19ex08">Listing 19-8</a>, you initialize a <span class="literal">Stopwatch</span> to keep track of how long the program executes <span class="ent">➊</span>. Next, you initialize a <span class="literal">vector</span> called <span class="literal">factor_tasks</span> that contains objects of type <span class="literal">future&lt;string&gt;</span> <span class="ent">➋</span>. You iterate over <span class="literal">numbers</span> <span class="ent">➌</span>, invoking <span class="literal">async</span> with the <span class="literal">launch::async</span> strategy, specifying <span class="literal">factor_task</span> as the function object, and passing a <span class="literal">number</span> as the task’s argument. You invoke <span class="literal">emplace_back</span> on each resulting <span class="literal">future</span> into <span class="literal">factor_tasks</span> <span class="ent">➍</span>. Now that <span class="literal">async</span> has launched each task, you iterate over each element of <span class="literal">factor_tasks</span> <span class="ent">➎</span>, invoke <span class="literal">get</span> on each <span class="literal">task</span>, and write it to <span class="literal">cout</span> <span class="ent">➏</span>. Once you’ve received values from all the futures, you determine the number of milliseconds it took to run all tasks <span class="ent">➐</span> and write it to <span class="literal">cout</span> <span class="ent">➑</span>.</p>&#13;
<p class="indent">Thanks to concurrency, the total program time of <a href="ch19.xhtml#ch19ex09">Listing 19-9</a> roughly equals the maximum task execution time (28,988 ms) rather than the sum of task execution times, as in <a href="ch19.xhtml#ch19ex08">Listing 19-8</a> (37,115 ms).</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The times in <a href="ch19.xhtml#ch19ex08">Listing 19-8</a> and <a href="ch19.xhtml#ch19ex09">Listing 19-9</a> will vary from run to run.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch19lev2sec2"><strong><em>Sharing and Coordinating</em></strong></h4>&#13;
<p class="noindent">Concurrent programming with asynchronous tasks is simple as long as the tasks don’t require synchronization and don’t involve sharing mutable data. For example, consider a simple situation in which two threads access the same integer. One thread will increment the integer while the other decrements it. To modify a variable, each thread must read the variable’s current value, perform an addition or subtraction operation, and then write the variable to memory. Without synchronization, the two threads will perform these operations in an undefined, interleaved order. Such situations are sometimes called <em>race conditions</em> because the result depends on which thread executes first. <a href="ch19.xhtml#ch19ex10">Listing 19-10</a> illustrates just how disastrous this situation is.</p>&#13;
<pre>#include &lt;future&gt;&#13;
#include &lt;iostream&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
void goat_rodeo() {&#13;
  const size_t iterations{ 1'000'000 };&#13;
  int tin_cans_available{}; <span class="ent">➊</span>&#13;
&#13;
  auto eat_cans = async(launch::async, [&amp;] { <span class="ent">➋</span>&#13;
    for(size_t i{}; i&lt;iterations; i++)&#13;
      tin_cans_available--; <span class="ent">➌</span>&#13;
  });&#13;
  auto deposit_cans = async(launch::async, [&amp;] { <span class="ent">➍</span>&#13;
    for(size_t i{}; i&lt;iterations; i++)&#13;
      tin_cans_available++; <span class="ent">➎</span>&#13;
  });&#13;
  eat_cans.get(); <span class="ent">➏</span>&#13;
  deposit_cans.get(); <span class="ent">➐</span>&#13;
  cout &lt;&lt; "Tin cans: " &lt;&lt; tin_cans_available &lt;&lt; "\n"; <span class="ent">➑</span>&#13;
}&#13;
<span epub:type="pagebreak" id="page_648"/>int main() {&#13;
  goat_rodeo();&#13;
  goat_rodeo();&#13;
  goat_rodeo();&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">Tin cans: -609780</span>&#13;
<span class="color1">Tin cans: 185380</span>&#13;
<span class="color1">Tin cans: 993137</span></pre>&#13;
<p class="listing"><a id="ch19ex10"/><em>Listing 19-10: An illustration of how disastrous unsynchronized, mutable, shared data access can be</em></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You’ll get different results on each run of the program in <a href="ch19.xhtml#ch19ex10">Listing 19-10</a> because the program has undefined behavior.</em></p>&#13;
</div>&#13;
<p class="indent"><a href="ch19.xhtml#ch19ex10">Listing 19-10</a> involves defining a function called <span class="literal">goat_rodeo</span>, which involves a catastrophic race condition, and a <span class="literal">main</span> that invokes <span class="literal">goat_rodeo</span> three times. Within <span class="literal">goat_rodeo</span>, you initialize the shared data <span class="literal">tin_cans_available</span> <span class="ent">➊</span>. Next, you launch an asynchronous task called <span class="literal">eat_cans</span> <span class="ent">➋</span> in which a trip of goats decrements the shared variable <span class="literal">tin_cans_available</span> one million times <span class="ent">➌</span>. Next, you launch another asynchronous task called <span class="literal">deposit_cans</span> <span class="ent">➍</span> in which you increment <span class="literal">tin_cans_available</span> <span class="ent">➎</span>. After launching the two tasks, you wait for them to complete by calling <span class="literal">get</span> (the order doesn’t matter) <span class="ent">➏</span><span class="ent">➐</span>. Once the tasks complete, you print the <span class="literal">tin_cans_available</span> variable <span class="ent">➑</span>.</p>&#13;
<p class="indent">Intuitively, you might expect <span class="literal">tin_cans_available</span> to equal zero after each task completes. After all, no matter how you order increments and decrements, if you perform them in equal number, they’ll cancel. You invoke <span class="literal">goat_rodeo</span> three times, and each invocation produces a wildly different result.</p>&#13;
<p class="indent"><a href="ch19.xhtml#ch19tab01">Table 19-1</a> illustrates one of the many ways the unsynchronized access in <a href="ch19.xhtml#ch19ex10">Listing 19-10</a> goes awry.</p>&#13;
<p class="tabcap" id="ch19tab01"><strong>Table 19-1:</strong> One Possible Schedule for <span class="literal">eat_cans</span> and <span class="literal">deposit_cans</span></p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:35%"/>&#13;
<col style="width:35%"/>&#13;
<col style="width:30%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>eat_cans</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>deposit_cans</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>cans_available</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Read <span class="literal">cans_available</span> (0)</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"/>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"/>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Read <span class="literal">cans_available</span> (0) <span class="ent">➊</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Compute <span class="literal">cans_available+1</span> (1)</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"/>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b "/>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Compute <span class="literal">cans_available-1</span> (-1) <span class="ent">➌</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Write <span class="literal">cans_available+1</span> (1) <span class="ent">➋</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"/>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"/>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Write <span class="literal">cans_available-1</span> (-1) <span class="ent">➍</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">-1</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><a href="ch19.xhtml#ch19tab01">Table 19-1</a> shows how interleaving reads and writes invites disaster. In this particular incarnation, the read by <span class="literal">deposit_cans</span> <span class="ent">➊</span> precedes the write from <span class="literal">eat_cans</span> <span class="ent">➋</span>, so <span class="literal">deposit_cans</span> computes a stale result <span class="ent">➌</span>. If this weren’t bad enough, it clobbers the write from <span class="literal">eat_cans</span> when it writes <span class="ent">➍</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_649"/>The fundamental problem with this data race is <em>unsynchronized access to mutable shared data</em>. You might wonder why <span class="literal">cans_available</span> doesn’t update immediately whenever a thread computes <span class="literal">cans_available+1</span> or <span class="literal">cans_available-1</span>. The answer lies in the fact that each of the rows in <a href="ch19.xhtml#ch19tab01">Table 19-1</a> represents a moment in time when some instruction completes execution, and the instructions for adding, subtracting, reading, and writing memory are all separate. Because the <span class="literal">cans_available</span> variable is shared and both threads write to it without synchronizing their actions, the instructions get interleaved in an undefined way at runtime (with catastrophic results). In the following subsections, you’ll learn three tools for dealing with such situations: <em>mutexes</em>, <em>condition variables</em>, and atomics.</p>&#13;
<h5 class="h5" id="ch19lev3sec4"><strong>Mutexes</strong></h5>&#13;
<p class="noindent">A <em>mutual exclusion algorithm</em> (<em>mutex</em>) is a mechanism for preventing multiple threads from accessing resources simultaneously. Mutexes are <em>synchronization primitives</em> that support two operations: lock and unlock. When a thread needs to access shared data, it locks the mutex. This operation can block depending on the nature of the mutex and whether another thread has the lock. When a thread no longer needs access, it unlocks the mutex.</p>&#13;
<p class="indent">The <span class="literal">&lt;mutex&gt;</span> header exposes several mutex options:</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">std::mutex</span> provides basic mutual exclusion.</li>&#13;
<li class="noindent"><span class="literal">std::timed_mutex</span> provides mutual exclusion with a timeout.</li>&#13;
<li class="noindent"><span class="literal">std::recursive_mutex</span> provides mutual exclusion that allows recursive locking by the same thread.</li>&#13;
<li class="noindent"><span class="literal">std::recursive_timed_mutex</span> provides mutual exclusion that allows recursive locking by the same thread and a timeout.</li>&#13;
</ul>&#13;
<p class="indent">The <span class="literal">&lt;shared_mutex&gt;</span> header provides two additional options:</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">std::shared_mutex</span> provides shared mutual exclusion facility, which means that several threads can own the mutex at once. This option is typically used in scenarios when multiple readers can access shared data but a writer needs exclusive access.</li>&#13;
<li class="noindent"><span class="literal">std::shared_timed_mutex</span> provides shared mutual exclusion facility and implements locking with a timeout.</li>&#13;
</ul>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>For simplicity, this chapter only covers <span class="codeitalic">mutex</span>. See [thread.mutex] for more information about the other options.</em></p>&#13;
</div>&#13;
<p class="indent">The <span class="literal">mutex</span> class defines only a single, default constructor. When you want to obtain mutual exclusion, you call one of two methods on a <span class="literal">mutex</span> object: <span class="literal">lock</span> or <span class="literal">try_lock</span>. If you call <span class="literal">lock</span>, which accepts no arguments and returns <span class="literal">void</span>, the calling thread blocks until the <span class="literal">mutex</span> becomes available. If you call <span class="literal">try_lock</span>, which accepts no arguments and returns a <span class="literal">bool</span>, it returns immediately. If the <span class="literal">try_lock</span> successfully obtained mutual exclusion, it returns <span class="literal">true</span> and the calling <span epub:type="pagebreak" id="page_650"/>thread now owns the lock. If <span class="literal">try_lock</span> was unsuccessful, it returns <span class="literal">false</span> and the calling thread doesn’t own the lock. To release a mutual exclusion lock, you simply call the method <span class="literal">unlock</span>, which accepts no arguments and returns <span class="literal">void</span>.</p>&#13;
<p class="indent"><a href="ch19.xhtml#ch19ex11">Listing 19-11</a> shows a lock-based way to solve the race condition in <a href="ch19.xhtml#ch19ex10">Listing 19-10</a>.</p>&#13;
<pre>#include &lt;future&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;mutex&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
void goat_rodeo() {&#13;
  const size_t iterations{ 1'000'000 };&#13;
  int tin_cans_available{};&#13;
  mutex tin_can_mutex; <span class="ent">➊</span>&#13;
&#13;
  auto eat_cans = async(launch::async, [&amp;] {&#13;
    for(size_t i{}; i&lt;iterations; i++) {&#13;
      tin_can_mutex.lock(); <span class="ent">➋</span>&#13;
      tin_cans_available--;&#13;
      tin_can_mutex.unlock(); <span class="ent">➌</span>&#13;
    }&#13;
  });&#13;
  auto deposit_cans = async(launch::async, [&amp;] {&#13;
    for(size_t i{}; i&lt;iterations; i++) {&#13;
      tin_can_mutex.lock(); <span class="ent">➍</span>&#13;
      tin_cans_available++;&#13;
      tin_can_mutex.unlock(); <span class="ent">➎</span>&#13;
    }&#13;
  });&#13;
  eat_cans.get();&#13;
  deposit_cans.get();&#13;
  cout &lt;&lt; "Tin cans: " &lt;&lt; tin_cans_available &lt;&lt; "\n";&#13;
}&#13;
&#13;
int main() {&#13;
  goat_rodeo(); <span class="ent">➏</span>&#13;
  goat_rodeo(); <span class="ent">➐</span>&#13;
  goat_rodeo(); <span class="ent">➑</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">Tin cans: 0 <span class="ent">➏</span></span>&#13;
<span class="color1">Tin cans: 0 <span class="ent">➐</span></span>&#13;
<span class="color1">Tin cans: 0 <span class="ent">➑</span></span></pre>&#13;
<p class="listing"><a id="ch19ex11"/><em>Listing 19-11: Using a <span class="literal">mutex</span> to resolve the race condition in <a href="ch19.xhtml#ch19ex10">Listing 19-10</a></em></p>&#13;
<p class="indent">You add a <span class="literal">mutex</span> into <span class="literal">goat_rodeo</span> <span class="ent">➊</span> called <span class="literal">tin_can_mutex</span>, which provides mutual exclusion on the <span class="literal">tin_cans_available</span>. Inside each asynchronous task, a thread acquires a lock <span class="ent">➋</span><span class="ent">➍</span> before modifying <span class="literal">tin_cans_available</span>. Once the thread is done modifying, it unlocks <span class="ent">➌</span><span class="ent">➎</span>. Notice that the resulting number of available tin cans at the end of each run is zero <span class="ent">➏</span><span class="ent">➐</span><span class="ent">➑</span>, reflecting that you’ve fixed your race condition.</p>&#13;
<div class="box5" id="bm03">&#13;
<p class="boxtitle-d"><strong>MUTEX IMPLEMENTATIONS</strong></p>&#13;
<p class="noindent">In practice, mutexes are implemented in a number of ways. Perhaps the simplest mutex is a <em>spin lock</em> in which a thread will execute a loop until the lock is released. This kind of lock usually minimizes the amount of time between a lock getting released by one thread and acquired by another. But it’s computationally expensive because a CPU is spending all of its time checking for lock availability when some other thread could be doing productive work. Typically, mutexes require atomic instructions, such as <span class="literal">compare-and-swap</span>, <span class="literal">fetch-and-add</span>, or <span class="literal">test-and-set</span>, so they can check for and acquire a lock in one operation.</p>&#13;
<p class="indent">Modern operating systems, like Windows, offer more efficient alternatives to spin locks. For example, mutexes based on <em>asynchronous procedure calls</em> allow threads to wait on a mutex and go into a <em>wait state</em>. Once the mutex becomes available, the operating system awakens the waiting thread and hands off ownership of the mutex. This allows other threads to do productive work on a CPU that would otherwise be occupied in a spin lock.</p>&#13;
<p class="indent">In general, you won’t need to worry about the details of how mutexes are implemented by your operating system unless they become a bottleneck in your program.</p>&#13;
</div>&#13;
<p class="indent">If you’re thinking that handling <span class="literal">mutex</span> locking is a perfect job for an RAII object, you’re right. Suppose you forgot to invoke <span class="literal">unlock</span> on a mutex, say because it threw an exception. When the next thread comes along and attempts to acquire the mutex with <span class="literal">lock</span>, your program will come to a screeching halt. For this reason, the stdlib provides RAII classes for handling mutexes in the <span class="literal">&lt;mutex&gt;</span> header. There you’ll find several class templates, all of which accept mutexes as constructor parameters and a template parameter corresponding to the class of the mutexes:</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">std::lock_guard</span> is a non-copyable, non-moveable RAII wrapper that accepts a mutex object in its constructor, where it calls <span class="literal">lock</span>. It then calls <span class="literal">unlock</span> in the destructor.</li>&#13;
<li class="noindent"><span class="literal">std::scoped_lock</span> is a deadlock avoiding RAII wrapper for multiple mutexes.</li>&#13;
<li class="noindent"><span class="literal">std::unique_lock</span> implements a movable mutex ownership wrapper.</li>&#13;
<li class="noindent"><span class="literal">std::shared_lock</span> implements a movable shared mutex ownership wrapper.</li>&#13;
</ul>&#13;
<p class="indent">For brevity, this section focuses on <span class="literal">lock_guard</span>. <a href="ch19.xhtml#ch19ex12">Listing 19-12</a> shows how to refactor <a href="ch19.xhtml#ch19ex11">Listing 19-11</a> to use <span class="literal">lock_guard</span> instead of manual <span class="literal">mutex</span> manipulation.</p>&#13;
<pre>#include &lt;future&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;mutex&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
<span epub:type="pagebreak" id="page_651"/>void goat_rodeo() {&#13;
  const size_t iterations{ 1'000'000 };&#13;
  int tin_cans_available{};&#13;
  mutex tin_can_mutex;&#13;
  auto eat_cans = async(launch::async, [&amp;] {&#13;
    for(size_t i{}; i&lt;iterations; i++) {&#13;
      lock_guard&lt;mutex&gt; guard{ tin_can_mutex }; <span class="ent">➊</span>&#13;
      tin_cans_available--;&#13;
    }&#13;
  });&#13;
  auto deposit_cans = async(launch::async, [&amp;] {&#13;
    for(size_t i{}; i&lt;iterations; i++) {&#13;
      lock_guard&lt;mutex&gt; guard{ tin_can_mutex }; <span class="ent">➋</span>&#13;
      tin_cans_available++;&#13;
    }&#13;
  });&#13;
  eat_cans.get();&#13;
  deposit_cans.get();&#13;
  cout &lt;&lt; "Tin cans: " &lt;&lt; tin_cans_available &lt;&lt; "\n";&#13;
}&#13;
&#13;
int main() {&#13;
  goat_rodeo();&#13;
  goat_rodeo();&#13;
  goat_rodeo();&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">Tin cans: 0</span>&#13;
<span class="color1">Tin cans: 0</span>&#13;
<span class="color1">Tin cans: 0</span></pre>&#13;
<p class="listing"><a id="ch19ex12"/><em>Listing 19-12: Refactoring <a href="ch19.xhtml#ch19ex11">Listing 19-11</a> to use <span class="literal">lock_guard</span></em></p>&#13;
<p class="indent">Rather than using <span class="literal">lock</span> and <span class="literal">unlock</span> to manage mutual exclusion, you construct a <span class="literal">lock_guard</span> at the beginning of each scope where you need synchronization <span class="ent">➊</span><span class="ent">➋</span>. Because your mutual exclusion mechanism is a <span class="literal">mutex</span>, you specify it as your <span class="literal">lock_guard</span> template parameter. <a href="ch19.xhtml#ch19ex11">Listing 19-11</a> and <a href="ch19.xhtml#ch19ex12">Listing 19-12</a> have equivalent runtime behavior, including how long it takes the programs to execute. RAII objects don’t involve any additional runtime costs over programming releases and acquisitions by hand.</p>&#13;
<p class="indent">Unfortunately, mutual exclusion locks involve runtime costs. You might also have noticed that executing <a href="ch19.xhtml#ch19ex11">Listings 19-11</a> and <a href="ch19.xhtml#ch19ex12">19-12</a> took substantially longer than executing <a href="ch19.xhtml#ch19ex10">Listing 19-10</a>. The reason is that acquiring and releasing locks is a relatively expensive operation. In <a href="ch19.xhtml#ch19ex11">Listings 19-11</a> and <a href="ch19.xhtml#ch19ex12">19-12</a>, the <span class="literal">tin_can_mutex</span> gets acquired and then released two million times. Relative to incrementing or decrementing an integer, acquiring or releasing a lock takes substantially more time, so using a mutex to synchronize the asynchronous tasks is suboptimal. In certain situations, you can take a potentially more efficient approach by using atomics.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>For more information about asynchronous tasks and futures, refer to [futures.async].</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch19lev3sec5"><span epub:type="pagebreak" id="page_652"/><strong>Atomics</strong></h5>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_653"/>The word <em>atomic</em> comes from the Greek <em>átomos</em>, meaning “indivisible.” An operation is atomic if it occurs in an indivisible unit. Another thread cannot observe the operation halfway through. When you introduced locks into <a href="ch19.xhtml#ch19ex10">Listing 19-10</a> to produce <a href="ch19.xhtml#ch19ex11">Listing 19-11</a>, you made the increment and decrement operations atomic because the asynchronous tasks could no longer interleave read and write operations on <span class="literal">tin_cans_available</span>. As you experienced running this lock-based solution, this approach is very slow because acquiring locks is expensive.</p>&#13;
<p class="indent">Another approach is to use the <span class="literal">std::atomic</span> class template in the <span class="literal">&lt;atomic&gt;</span> header, which provides primitives often used in <em>lock-free concurrent programming</em>. Lock-free concurrent programming solves data race issues without involving locks. On many modern architectures, CPUs support atomic instructions. Using atomics, you might be able to avoid locks by leaning on atomic hardware instructions.</p>&#13;
<p class="indent">This chapter doesn’t discuss <span class="literal">std::atomic</span> or how to devise your own lock-free solutions in detail, because it’s incredibly difficult to do correctly and is best left to experts. However, in simple situations, such as in <a href="ch19.xhtml#ch19ex10">Listing 19-10</a>, you can employ a <span class="literal">std::atomic</span> to make sure that the increment or decrement operations cannot be divided. This neatly solves your data race problem.</p>&#13;
<p class="indent">The <span class="literal">std::atomic</span> template offers specializations for all fundamental types, as shown in <a href="ch19.xhtml#ch19tab02">Table 19-2</a>.</p>&#13;
<p class="tabcap" id="ch19tab02"><strong>Table 19-2:</strong> <span class="literal">std::atomic</span> Template Specializations for the Fundamental Types</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Template specialization</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Alias</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">std::atomic&lt;bool&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">std::atomic_bool</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">std::atomic&lt;char&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">std::atomic_char</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">std::atomic&lt;unsigned char&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">std::atomic_uchar</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">std::atomic&lt;short&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">std::atomic_short</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">std::atomic&lt;unsigned short&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">std::atomic_ushort</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">std::atomic&lt;int&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">std::atomic_int</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">std::atomic&lt;unsigned int&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">std::atomic_uint</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">std::atomic&lt;long&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">std::atomic_long</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">std::atomic&lt;unsigned long&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">std::atomic_ulong</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">std::atomic&lt;long long&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">std::atomic_llong</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">std::atomic&lt;unsigned long long&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">std::atomic_ullong</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">std::atomic&lt;char16_t&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">std::atomic_char16_t</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">std::atomic&lt;char32_t&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">std::atomic_char32_t</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="literal">std::atomic&lt;wchar_t&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="literal">std::atomic_wchar_t</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><a href="ch19.xhtml#ch19tab03">Table 19-3</a> lists some of the supported operations for <span class="literal">std::atomic</span>. The <span class="literal">std::atomic</span> template has no copy constructor.</p>&#13;
<p class="tabcap" id="ch19tab03"><span epub:type="pagebreak" id="page_654"/><strong>Table 19-3:</strong> Supported Operations for <span class="literal">std::atomic</span></p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">a</span><span class="literal">{}</span></p>&#13;
<p class="taba"><span class="codestrong">a</span><span class="literal">{ 123 }</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Default constructor.</p>&#13;
<p class="taba">Initializes value to 123.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">a</span><span class="literal">.is_lock_free()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns true if <span class="codestrong">a</span> is lock-free. (Depends on the CPU.)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">a</span><span class="literal">.store(123)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Stores the value 123 into <span class="codestrong">a</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">a</span><span class="literal">.load()</span></p>&#13;
<p class="taba"><span class="codestrong">a</span><span class="literal">()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns the stored value.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">a</span><span class="literal">.exchange(123)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Replaces the current value with 123 and returns the old value. This is a “read-modify-write” operation.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="codestrong">a</span><span class="literal">.compare_exchange_weak(10, 20)</span></p>&#13;
<p class="taba"><span class="codestrong">a</span><span class="literal">.compare_exchange_strong(10, 20)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">If the current value is 10, replaces with 20. Returns true if the value was replaced. See <span class="literal">[atomic]</span> for details on weak versus strong.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Specializations for the types in <span class="codeitalic">&lt;cstdint&gt;</span> are also available. See [atomics.syn] for details.</em></p>&#13;
</div>&#13;
<p class="indent">For the numeric types, the specializations offer additional operations, as listed in <a href="ch19.xhtml#ch19tab04">Table 19-4</a>.</p>&#13;
<p class="tabcap" id="ch19tab04"><strong>Table 19-4:</strong> Supported Operations for Numeric Specializations of a <span class="literal">std::atomic</span> <span class="codestrong">a</span></p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">a</span><span class="literal">.fetch_add(123)</span></p>&#13;
<p class="taba"><span class="codestrong">a</span><span class="literal">+=123</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Replaces the current value with the result of adding the argument to the current value. Returns the value before modification. This is a “read-modify-write” operation.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">a</span><span class="literal">.fetch_sub(123)</span></p>&#13;
<p class="taba"><span class="codestrong">a</span><span class="literal">-=123</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Replaces the current value with the result of subtracting the argument from the current value. Returns the value before modification. This is a “read-modify-write” operation.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">a</span><span class="literal">.fetch_and(123)</span></p>&#13;
<p class="taba"><span class="codestrong">a</span><span class="literal">&amp;=123</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Replaces the current value with the result of bitwise ANDing the argument with the current value. Returns the value before modification. This is a “read-modify-write” operation.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">a</span><span class="literal">.fetch_or(123)</span></p>&#13;
<p class="taba"><span class="codestrong">a</span><span class="literal">|=123</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Replaces the current value with the result of bitwise ORing the argument with the current value. Returns the value before modification. This is a “read-modify-write” operation.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">a</span><span class="literal">.fetch_xor(123)</span></p>&#13;
<p class="taba"><span class="codestrong">a</span><span class="literal">^=123</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Replaces the current value with the result of bitwise XORing the argument with the current value. Returns the value before modification. This is a “read-modify-write” operation.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="codestrong">a</span><span class="literal">++</span></p>&#13;
<p class="taba"><span class="codestrong">a</span><span class="literal">--</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Increments or decrements <span class="codestrong">a</span>.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Because <a href="ch19.xhtml#ch19ex12">Listing 19-12</a> is a prime candidate for a lock-free solution, you can replace the type of <span class="literal">tin_cans_available</span> with <span class="literal">atomic_int</span> and remove the <span class="literal">mutex</span>. This prevents race conditions like the one illustrated in <a href="ch19.xhtml#ch19tab01">Table 19-1</a>. <a href="ch19.xhtml#ch19ex13">Listing 19-13</a> implements this refactor.</p>&#13;
<pre><span epub:type="pagebreak" id="page_655"/>#include &lt;future&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;atomic&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
void goat_rodeo() {&#13;
  const size_t iterations{ 1'000'000 };&#13;
  atomic_int<span class="ent">➊</span> tin_cans_available{};&#13;
  auto eat_cans = async(launch::async, [&amp;] {&#13;
    for(size_t i{}; i&lt;iterations; i++)&#13;
      tin_cans_available--; <span class="ent">➋</span>&#13;
  });&#13;
  auto deposit_cans = async(launch::async, [&amp;] {&#13;
    for(size_t i{}; i&lt;iterations; i++)&#13;
      tin_cans_available++; <span class="ent">➌</span>&#13;
  });&#13;
  eat_cans.get();&#13;
  deposit_cans.get();&#13;
  cout &lt;&lt; "Tin cans: " &lt;&lt; tin_cans_available &lt;&lt; "\n";&#13;
}&#13;
&#13;
int main() {&#13;
  goat_rodeo();&#13;
  goat_rodeo();&#13;
  goat_rodeo();&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">Tin cans: 0</span>&#13;
<span class="color1">Tin cans: 0</span>&#13;
<span class="color1">Tin cans: 0</span></pre>&#13;
<p class="listing"><a id="ch19ex13"/><em>Listing 19-13: Resolving the race condition using <span class="literal">atomic_int</span> rather than <span class="literal">mutex</span></em></p>&#13;
<p class="indent">You replace <span class="literal">int</span> with <span class="literal">atomic_int</span> <span class="ent">➊</span> and remove the <span class="literal">mutex</span>. Because the decrement <span class="ent">➋</span> and increment <span class="ent">➌</span> operators are atomic, the race condition remains solved.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>For more information about atomics, refer to [atomics].</em></p>&#13;
</div>&#13;
<p class="indent">You also probably noticed a considerable performance boost from <a href="ch19.xhtml#ch19ex12">Listing 19-12</a> to <a href="ch19.xhtml#ch19ex12">19-13</a>. In general, using atomic operations will be much faster than acquiring a mutex.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">WARNING</span></strong></p>&#13;
<p class="notep"><em>Unless you have a very simple concurrent access problem, such as the one in this section, you really shouldn’t try to implement lock-free solutions on your own. Refer to the Boost Lockfree library for high-quality, thoroughly tested lock-free containers. As always, you must decide whether a lock-based or lock-free implementation is optimal.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch19lev3sec6"><span epub:type="pagebreak" id="page_656"/><strong>Condition Variables</strong></h5>&#13;
<p class="noindent">A <em>condition variable</em> is a synchronization primitive that blocks one or more threads until notified. Another thread can notify the condition variable. After notification, the condition variable can unblock one or more threads so they can make progress. A very popular condition variable pattern involves a thread performing the following actions:</p>&#13;
<ol>&#13;
<li class="noindent">Acquire some mutex shared with awaiting threads.</li>&#13;
<li class="noindent">Modify the shared state.</li>&#13;
<li class="noindent">Notify the condition variable.</li>&#13;
<li class="noindent">Release the mutex.</li>&#13;
</ol>&#13;
<p class="indent">Any threads waiting on the condition variable then perform the following actions:</p>&#13;
<ol>&#13;
<li class="noindent">Acquire the mutex.</li>&#13;
<li class="noindent">Wait on the condition variable (this releases the mutex).</li>&#13;
<li class="noindent">When another thread notifies the condition variable, this thread wakes up and can perform some work (this reacquires the mutex automatically).</li>&#13;
<li class="noindent">Release the mutex.</li>&#13;
</ol>&#13;
<p class="indent">Due to complications arising from the complexity of modern operating systems, sometimes threads can wake up spuriously. Therefore, it’s important to verify that a condition variable was in fact signaled once a waiting thread awakens.</p>&#13;
<p class="indent">The stdlib provides <span class="literal">std::condition_variable</span> in the <span class="literal">&lt;condition_variable&gt;</span> header, which supports several operations, including those in <a href="ch19.xhtml#ch19tab05">Table 19-5</a>. The <span class="literal">condition_variable</span> supports only default construction, and the copy constructor is deleted.</p>&#13;
<p class="tabcap" id="ch19tab05"><strong>Table 19-5:</strong> Supported Operations of a <span class="literal">std::condition_variable</span> <span class="codestrong">cv</span></p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">cv</span><span class="literal">.notify_one()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">If any threads are waiting on <span class="codestrong">cv</span>, this operation notifies one of them.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">cv</span><span class="literal">.notify_all()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">If any threads are waiting on <span class="codestrong">cv</span>, this operation notifies all of them.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">cv</span><span class="literal">.wait(</span><span class="codestrong">lock</span><span class="literal">, [</span><span class="codestrong">pred</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Given a <span class="codestrong">lock</span> on the mutex owned by the notifier, returns when awakened. If supplied, <span class="codestrong">pred</span> determines whether the notification is spurious (returns <span class="literal">false</span>) or real (returns <span class="literal">true</span>).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">cv</span><span class="literal">.wait_for(</span><span class="codestrong">lock</span><span class="literal">, [</span><span class="codestrong">durn</span><span class="literal">], [</span><span class="codestrong">pred</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Same as <span class="codestrong">cv</span><span class="literal">.wait</span> except <span class="literal">wait_for</span> only waits for <span class="codestrong">durn</span>. If timeout occurs and no <span class="codestrong">pred</span> is supplied, returns <span class="literal">std::cv_status::timeout</span>; otherwise, returns <span class="literal">std::cv_status::no_timeout</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="codestrong">cv</span><span class="literal">.wait_until(</span><span class="codestrong">lock</span><span class="literal">, [</span><span class="codestrong">time</span><span class="literal">], [</span><span class="codestrong">pred</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Same as <span class="literal">wait_for</span> except uses a <span class="literal">std::chrono::time_point</span> instead of a <span class="literal">std::chrono::duration</span>.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_657"/>For example, you can refactor <a href="ch19.xhtml#ch19ex12">Listing 19-12</a> so the <em>deposit cans</em> task completes before the <em>eat cans</em> task using a condition variable, as <a href="ch19.xhtml#ch19ex14">Listing 19-14</a> illustrates.</p>&#13;
<pre>#include &lt;future&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;mutex&gt;&#13;
#include &lt;condition_variable&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
void goat_rodeo() {&#13;
  mutex m; <span class="ent">➊</span>&#13;
  condition_variable cv; <span class="ent">➋</span>&#13;
  const size_t iterations{ 1'000'000 };&#13;
  int tin_cans_available{};&#13;
  auto eat_cans = async(launch::async, [&amp;] {&#13;
    unique_lock&lt;mutex&gt; lock{ m }; <span class="ent">➌</span>&#13;
    cv.wait(lock, [&amp;] { return tin_cans_available == 1'000'000; }); <span class="ent">➍</span>&#13;
    for(size_t i{}; i&lt;iterations; i++)&#13;
      tin_cans_available--;&#13;
  });&#13;
&#13;
  auto deposit_cans = async(launch::async, [&amp;] {&#13;
    scoped_lock&lt;mutex&gt; lock{ m }; <span class="ent">➎</span>&#13;
    for(size_t i{}; i&lt;iterations; i++)&#13;
      tin_cans_available++;&#13;
    cv.notify_all(); <span class="ent">➏</span>&#13;
  });&#13;
  eat_cans.get();&#13;
  deposit_cans.get();&#13;
  cout &lt;&lt; "Tin cans: " &lt;&lt; tin_cans_available &lt;&lt; "\n";&#13;
}&#13;
&#13;
int main() {&#13;
  goat_rodeo();&#13;
  goat_rodeo();&#13;
  goat_rodeo();&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">Tin cans: 0</span>&#13;
<span class="color1">Tin cans: 0</span>&#13;
<span class="color1">Tin cans: 0</span></pre>&#13;
<p class="listing"><a id="ch19ex14"/><em>Listing 19-14: Using condition variables to ensure all cans are deposited before they’re eaten</em></p>&#13;
<p class="indent">You declare a <span class="literal">mutex</span> <span class="ent">➊</span> and a <span class="literal">condition_variable</span> <span class="ent">➋</span> that you’ll use to coordinate the asynchronous tasks. Within the <em>eat cans</em> task, you acquire a <span class="literal">unique_lock</span> to the <span class="literal">mutex</span>, which you pass into <span class="literal">wait</span> along with a predicate that returns <span class="literal">true</span> if there are cans available <span class="ent">➌</span>. This method will release the mutex and then block until two conditions are met: the <span class="literal">condition_variable</span> awakens this thread and one million tin cans are available <span class="ent">➍</span> (recall that you must check that all the cans are available because of spurious wakeups). <span epub:type="pagebreak" id="page_658"/>Within the <em>deposit cans</em> task, you acquire a lock on the <span class="literal">mutex</span> <span class="ent">➎</span>, deposit the cans, and then notify all threads blocked on the <span class="literal">condition_variable</span> <span class="ent">➏</span>.</p>&#13;
<p class="indent">Note that, unlike with all the previous approaches, it’s impossible for <span class="literal">tin_cans_available</span> to be negative because the ordering of deposit cans and eat cans is guaranteed.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>For more information about condition variables, refer to <em>[thread.condition]</em>.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch19lev2sec3"><strong><em>Low-Level Concurrency Facilities</em></strong></h4>&#13;
<p class="noindent">The stdlib’s <span class="literal">&lt;thread&gt;</span> library contains low-level facilities for concurrent programming. The <span class="literal">std::thread</span> class, for example, models an operating system thread. However, it’s best not to use <span class="literal">thread</span> directly and instead design concurrency into your programs with higher-level abstractions, like tasks. Should you require low-level thread access, [thread] offers more information.</p>&#13;
<p class="indent">But the <span class="literal">&lt;thread&gt;</span> library does include several useful functions for manipulating the current thread:</p>&#13;
<ul>&#13;
<li class="noindent">The <span class="literal">std::this_thread::yield</span> function accepts no arguments and returns <span class="literal">void</span>. The exact behavior of <span class="literal">yield</span> depends on the environment, but in general it provides a hint that the operating system should give other threads a chance to run. This is useful when, for example, there’s high lock contention over a particular resource and you want to help all threads get a chance at access.</li>&#13;
<li class="noindent">The <span class="literal">std::this_thread::get_id</span> function accepts no arguments and returns an object of type <span class="literal">std::thread::id</span>, which is a lightweight thread that supports comparison operators and <span class="literal">operator&lt;&lt;</span>. Typically, it’s used as a key in associative containers.</li>&#13;
<li class="noindent">The <span class="literal">std::this_thread::sleep_for</span> function accepts a <span class="literal">std::chrono::duration</span> argument, blocks execution on the current thread until at least the specified duration passes, and returns <span class="literal">void</span>.</li>&#13;
<li class="noindent">The <span class="literal">std::this_thread::sleep_until</span> accepts a <span class="literal">std::chrono::time_point</span> and returns void. It is entirely analogous to <span class="literal">sleep_for</span> except it blocks the thread until at least the specified <span class="literal">time_point</span>.</li>&#13;
</ul>&#13;
<p class="indent">When you need these functions, they’re indispensable. Otherwise, you really shouldn’t need to interact with the <span class="literal">&lt;thread&gt;</span> header.</p>&#13;
<h3 class="h3" id="ch19lev1sec2"><strong>Parallel Algorithms</strong></h3>&#13;
<p class="noindent"><a href="ch18.xhtml">Chapter 18</a> introduced the stdlib’s algorithms, many of which take an optional first argument called its execution policy encoded by a <span class="literal">std::execution</span> value. In supported environments, there are three possible values: <span class="literal">seq</span>, <span class="literal">par</span>, and <span class="literal">par_unseq</span>. The latter two options indicate that you want to execute the algorithm in parallel.</p>&#13;
<h4 class="h4" id="ch19lev2sec4"><span epub:type="pagebreak" id="page_659"/><strong><em>An Example: Parallel sort</em></strong></h4>&#13;
<p class="noindent"><a href="ch19.xhtml#ch19ex15">Listing 19-15</a> illustrates how changing a single argument from <span class="literal">seq</span> to <span class="literal">par</span> can have a massive impact on a program’s runtime by sorting a billion numbers both ways.</p>&#13;
<pre>#include &lt;algorithm&gt;&#13;
#include &lt;vector&gt;&#13;
#include &lt;numeric&gt;&#13;
#include &lt;random&gt;&#13;
#include &lt;chrono&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;execution&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
// From <a href="ch12.xhtml#ch12ex25">Listing 12-25</a>:&#13;
struct Stopwatch {&#13;
--<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
vector&lt;long&gt; make_random_vector() { <span class="ent">➊</span>&#13;
  vector&lt;long&gt; numbers(1'000'000'000);&#13;
  iota(numbers.begin(), numbers.end(), 0);&#13;
  mt19937_64 urng{ 121216 };&#13;
  shuffle(numbers.begin(), numbers.end(), urng);&#13;
  return numbers;&#13;
}&#13;
&#13;
int main() {&#13;
  cout &lt;&lt; "Constructing random vectors...";&#13;
  auto numbers_a = make_random_vector(); <span class="ent">➋</span>&#13;
  auto numbers_b{ numbers_a }; <span class="ent">➌</span>&#13;
  chrono::nanoseconds time_to_sort;&#13;
  cout &lt;&lt; " " &lt;&lt; numbers_a.size() &lt;&lt; " elements.\n";&#13;
  cout &lt;&lt; "Sorting with execution::seq...";&#13;
  {&#13;
    Stopwatch stopwatch{ time_to_sort };&#13;
    sort(execution::seq, numbers_a.begin(), numbers_a.end()); <span class="ent">➍</span>&#13;
  }&#13;
  cout &lt;&lt; " took " &lt;&lt; time_to_sort.count() / 1.0E9 &lt;&lt; " sec.\n";&#13;
&#13;
  cout &lt;&lt; "Sorting with execution::par...";&#13;
  {&#13;
    Stopwatch stopwatch{ time_to_sort };&#13;
    sort(execution::par, numbers_b.begin(), numbers_b.end()); <span class="ent">➎</span>&#13;
  }&#13;
  cout &lt;&lt; " took " &lt;&lt; time_to_sort.count() / 1.0E9 &lt;&lt; " sec.\n";&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span epub:type="pagebreak" id="page_660"/><span class="color1">Constructing random vectors... 1000000000 elements.</span>&#13;
<span class="color1">Sorting with execution::seq... took 150.489 sec.</span>&#13;
<span class="color1">Sorting with execution::par... took 17.7305 sec.</span></pre>&#13;
<p class="listing"><a id="ch19ex15"/><em>Listing 19-15: Sorting a billion numbers using <span class="literal">std::sort</span> with <span class="literal">std::execution::seq</span> versus <span class="literal">std::execution::par</span>. (Results are from a Windows 10 x64 machine with two Intel Xeon E5-2620 v3 processors.)</em></p>&#13;
<p class="indent">The <span class="literal">make_random_vector</span> function <span class="ent">➊</span> produces a <span class="literal">vector</span> containing a billion unique numbers. You build two copies, <span class="literal">numbers_a</span> <span class="ent">➋</span> and <span class="literal">numbers_b</span> <span class="ent">➌</span>. You sort each <span class="literal">vector</span> separately. In the first case, you sort with a sequential execution policy <span class="ent">➍</span>, and <span class="literal">Stopwatch</span> indicates that the operation took about two and a half minutes (about 150 seconds). In the second case, you sort with a parallel execution policy <span class="ent">➎</span>. In contrast, <span class="literal">Stopwatch</span> indicates that the operation took about 18 seconds. The sequential execution took roughly 8.5 times as long.</p>&#13;
<h4 class="h4" id="ch19lev2sec5"><strong><em>Parallel Algorithms Are Not Magic</em></strong></h4>&#13;
<p class="noindent">Unfortunately, parallel algorithms aren’t magic. Although they work brilliantly in simple situations, such as with <span class="literal">sort</span> in <a href="ch19.xhtml#ch19ex15">Listing 19-15</a>, you must be careful when using them. Any time an algorithm produces side effects beyond the target sequence, you have to think hard about race conditions. A red flag is any algorithm that passes a function object to the algorithm. If the function object has shared mutable state, the executing threads will have shared access and you might have a race condition. For example, consider the parallel <span class="literal">transform</span> invocation in <a href="ch19.xhtml#ch19ex16">Listing 19-16</a>.</p>&#13;
<pre>#include &lt;algorithm&gt;&#13;
#include &lt;vector&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;numeric&gt;&#13;
#include &lt;execution&gt;&#13;
&#13;
int main() {&#13;
  std::vector&lt;long&gt; numbers{ 1'000'000 }, squares{ 1'000'000 }; <span class="ent">➊</span>&#13;
  std::iota(numbers.begin(), numbers.end(), 0); <span class="ent">➋</span>&#13;
  size_t n_transformed{}; <span class="ent">➌</span>&#13;
  std::transform(std::execution::par, numbers.begin(), numbers.end(), <span class="ent">➍</span>&#13;
                 squares.begin(), [&amp;n_transformed] (const auto x) {&#13;
                  ++n_transformed; <span class="ent">➎</span>&#13;
                  return x * x; <span class="ent">➏</span>&#13;
                });&#13;
  std::cout &lt;&lt; "n_transformed: " &lt;&lt; n_transformed &lt;&lt; std::endl; <span class="ent">➐</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">n_transformed: 187215 <span class="ent">➐</span></span></pre>&#13;
<p class="listing"><a id="ch19ex16"/><em>Listing 19-16: A program containing a race condition due to non-atomic access to <span class="literal">n_transformed</span></em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_661"/>You begin by initializing two <span class="literal">vector</span> objects, <span class="literal">numbers</span> and <span class="literal">squares</span>, which contain a million elements <span class="ent">➊</span>. Next, you fill one of them with numbers using <span class="literal">iota</span> <span class="ent">➋</span> and initialize the variable <span class="literal">n_transformed</span> to <span class="literal">0</span> <span class="ent">➌</span>. You then invoke <span class="literal">transform</span> with a parallel execution policy, <span class="literal">numbers</span> as your target sequence, <span class="literal">squares</span> as your result sequence, and a simple lambda <span class="ent">➍</span>. The lambda increments <span class="literal">n_transformed</span> <span class="ent">➎</span> and returns the square of the argument <span class="literal">x</span> <span class="ent">➏</span>. Because multiple threads execute this lambda, access to <span class="literal">n_transformed</span> must be synchronized <span class="ent">➐</span>.</p>&#13;
<p class="indent">The previous section introduced two ways to solve this problem, locks and atomics. In this scenario, it’s probably best to just use a <span class="literal">std::atomic_size_t</span> as a drop-in replacement for <span class="literal">size_t</span>.</p>&#13;
<h3 class="h3" id="ch19lev1sec3"><strong>Summary</strong></h3>&#13;
<p class="noindent">This chapter surveyed concurrency and parallelism at a very high level. In addition, you learned how to launch asynchronous tasks, which allow you to easily introduce multithreaded programming concepts into your code. Although introducing parallel and concurrent concepts into your programs can provide a significant performance boost, you must carefully avoid introducing race conditions that invite undefined behavior. You also learned several mechanisms for synchronizing access to mutable shared state: mutexes, condition variables, and atomics.</p>&#13;
<div class="box5" id="bm01">&#13;
<p class="boxtitle-d"><strong>EXERCISES</strong></p>&#13;
<p class="noindent"><strong>19-1.</strong> Write your own spin lock-based mutex called <span class="literal">SpinLock</span>. Expose a <span class="literal">lock</span>, a <span class="literal">try_lock</span>, and an <span class="literal">unlock</span> method. Your class should delete the copy constructor. Try using a <span class="literal">std::lock_guard&lt;SpinLock&gt;</span> with an instance of your class.</p>&#13;
<p class="noindent"><strong>19-2.</strong> Read about the infamous double-checked locking pattern (DCLP) and why you shouldn’t use it. (See the article by Scott Meyers and Andrei Alexandrescu mentioned in the following “Further Reading” section.) Then read about the appropriate way to ensure that a callable gets invoked exactly once using <span class="literal">std::call_once</span> in [thread.once.callonce].</p>&#13;
<p class="noindent"><strong>19-3.</strong> Create a thread-safe queue class. This class must expose an interface like <span class="literal">std::queue</span> (see [queue.defn]). Use a <span class="literal">std::queue</span> internally to store elements. Use a <span class="literal">std::mutex</span> to synchronize access to this internal <span class="literal">std::queue</span>.</p>&#13;
<p class="noindent"><strong>19-4.</strong> Add a <span class="literal">wait_and_pop</span> method and a <span class="literal">std::condition_variable</span> member to your thread-safe queue. When a user invokes <span class="literal">wait_and_pop</span> and the queue contains an element, it should pop the element off the queue and return it. If the queue is empty, the thread should block until an element becomes available and then proceed to pop an element.</p>&#13;
<p class="noindent"><strong>19-5.</strong> (Optional) Read the Boost Coroutine2 documentation, especially the “Overview,” “Introduction,” and “Motivation” sections.</p>&#13;
</div>&#13;
<div class="box6" id="bm02">&#13;
<p class="boxtitle-d"><span epub:type="pagebreak" id="page_662"/><strong>FURTHER READING</strong></p>&#13;
<ul>&#13;
<li class="noindent">“C++ and The Perils of Double-Checked Locking: <a href="part01.xhtml#part01">Part I</a>” by Scott Meyers and Andrei Alexandrescu (<a href="http://www.drdobbs.com/cpp/c-and-the-perils-of-double-checked-locki/184405726/"><em>http://www.drdobbs.com/cpp/c-and-the-perils-of-double-checked-locki/184405726/</em></a>)</li>&#13;
<li class="noindent"><em>ISO International Standard ISO/IEC (2017) — Programming Language C++</em> (International Organization for Standardization; Geneva, Switzerland; <em><a href="https://isocpp.org/std/the-standard/">https://isocpp.org/std/the-standard/</a></em>)</li>&#13;
<li class="noindent"><em>C++ Concurrency in Action</em>, 2nd Edition, by Anthony Williams (Manning, 2018)</li>&#13;
<li class="noindent">“Effective Concurrency: Know When to Use an Active Object Instead of a Mutex” by Herb Sutter (<a href="https://herbsutter.com/2010/09/24/effective-concurrency-know-when-to-use-an-active-object-instead-of-a-mutex/"><em>https://herbsutter.com/2010/09/24/effective-concurrency-know-when-to-use-an-active-object-instead-of-a-mutex/</em></a>)</li>&#13;
<li class="noindent"><em>Effective Modern C++: 42 Specific Ways to Improve Your Use of C++ 11 and C++ 14</em> by Scott Meyers (O’Reilly Media, 2014)</li>&#13;
<li class="noindent">“A Survey of Modern Integer Factorization Algorithms” by Peter L. Montgomery. <em>CWI Quarterly</em> 7.4 (1994): 337–365.</li>&#13;
</ul>&#13;
</div>&#13;
</body></html>