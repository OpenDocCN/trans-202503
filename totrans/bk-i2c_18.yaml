- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ADS1015 and ADS1115 Analog-to-Digital Converters
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Although digital I/O is probably the most popular form of input/output on embedded
    computer systems, analog input is also popular. Converting a real-world analog
    signal (typically a voltage in the range 0 V to 3.3 V or 5 V) to numeric (digital)
    form allows an application to use real-world continuous measurements rather than
    the simple on or off from a digital input device. To perform such conversions,
    you’ll need an ADC.
  prefs: []
  type: TYPE_NORMAL
- en: Many types of ADCs are available. The vast majority of them convert an input
    voltage to an *n*-bit number, though some convert other physical measurements
    into numeric form. For the most part, real-world sensors produce a voltage output
    rather than producing a digital number directly. You would use an ADC to convert
    this voltage level to a digital value. Therefore, to read common sensor outputs,
    an ADC is a critical item in your toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter discusses two popular ADCs: the ADS1015 and the ADS1115\. Both
    devices convert voltages between 0.0 V and some upper bound (such as 4.095 V)
    into numeric form: the ADS1015 produces a 12-bit result, and the ADS1115 produces
    a 16-bit result. The ADS1015 is faster, supporting 3,300 samples per second versus
    the ADS1115 at 860 samples per second (a classic trade-off of bits for speed).
    Although other I²C ADCs are available, the ADS1*x*15 devices are popular because
    Adafruit has created a pair of breakout boards that support these two ICs. The
    original Adafruit designs were open hardware, and over time, low-cost clones of
    these boards have appeared on Amazon and other places. These devices are easy
    to interface to any system that has an I²C bus. Adafruit, for example, provides
    library code for Arduino and Raspberry Pi systems, though it’s easy enough to
    interface these devices to any RTOS or system. However, the purpose of this book
    is to teach you how to directly program I²C peripherals, so the next section provides
    the necessary background information on the ADS1*x*15 so you can program it.'
  prefs: []
  type: TYPE_NORMAL
- en: 14.1 Analog-to-Digital Converter Specifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ADCs have several important specifications that affect their use. [Table 14-1](#table14-1)
    lists some of the more common specifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 14-1: Typical ADC Features'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Feature** | **Units** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Resolution | Bits | The size of the integer value produced by the conversion
    |'
  prefs: []
  type: TYPE_TB
- en: '| Channels | Integer | Number of independent converters available on the device
    |'
  prefs: []
  type: TYPE_TB
- en: '| Polarity | Unipolar or bipolar | Determines whether an ADC supports negative
    voltages (bipolar or differential)^([*](#c14-footnote-001)) or only non-negative
    voltages (unipolar) |'
  prefs: []
  type: TYPE_TB
- en: '| Range | Volts | Supported voltage range for inputs to the ADC |'
  prefs: []
  type: TYPE_TB
- en: '| Input type | Differential or single-ended | Specifies whether the input(s)
    are differential or single-ended (common ground) |'
  prefs: []
  type: TYPE_TB
- en: '| Sample frequency | Hz | Number of readings per second the ADC is capable
    of making (also known as *samples per second* or *sps*) |'
  prefs: []
  type: TYPE_TB
- en: '| ^([*](#c14-footnoteref-001))The ADS1*x*15 devices do not accept actual negative
    voltages; rather, they accept a differential input where the difference between
    two positive voltage inputs is negative. See the discussion of differential inputs
    in section 14.1.5, “Differential vs. Single-Ended Modes,” later in this chapter.
    |'
  prefs: []
  type: TYPE_TB
- en: The following subsections will describe each of these items and discuss the
    actual ADC1*x*15 specifications.
  prefs: []
  type: TYPE_NORMAL
- en: 14.1.1 Analog-to-Digital Converter Resolution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The resolution of an ADC is the number of bits the ADC produces for a conversion.
    Low-end ADCs have an 8- or 10-bit resolution (10 bits is typical for the analog
    pins on a typical Arduino-class SBC), while mid-range ADCs commonly have 12-,
    14-, or 16-bit resolution. Higher-end ADCs support 20- or 24-bit resolution. For
    differential inputs, the ADS1015 device provides a 12-bit resolution, and the
    ADC1115 provides 16 bits of resolution. For single-ended applications on either
    device, you lose a bit (see section 14.1.5, “Differential vs. Single-Ended Modes,”
    for more details on differential versus single-ended mode).
  prefs: []
  type: TYPE_NORMAL
- en: The resolution determines the smallest difference between two voltages an ADC
    can detect. For example, in full-scale mode both the ADS1015 and ADS1115 ADCs
    support voltages in the range of 0 V to 4.095 V. The resolution of the device
    divides this range by the maximum value. A 12-bit resolution divides the input
    range into 4,096 steps, so in theory, the ADS1015 is capable of resolving a difference
    of 0.001 V. The ADS1115, being a 16-bit converter, breaks up the input range into
    65,536 steps. In theory, it’s capable of resolving a difference of 0.0000625 V—substantially
    better. The single-ended inputs have 11-bit and 15-bit resolution, respectively,
    producing 0.002-V and 0.000125-V steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a general rule, more is better when it comes to ADC resolution. The higher
    the resolution, the more accurate the reading will be. However, extra resolution
    comes at a cost: all other things equal, higher-resolution ADCs are generally
    more expensive and slower than lower-resolution ADCs. Using a higher-resolution
    ADC also does not guarantee that you’ll get more precise readings. System noise
    and other effects may render the extra resolution meaningless in actual applications.
    For most typical SBC applications, 12 bits are sufficient. The presence of 0.0001
    V of noise often completely obliterates the small readings possible with a 16-bit
    ADC.'
  prefs: []
  type: TYPE_NORMAL
- en: 14.1.2 Analog-to-Digital Converter Channel Count
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many ADC devices provide multiple analog inputs. This allows you to connect
    several analog sources to a single ADC device, thus reducing the count and cost
    of parts. The ADS1015 and ADS1115 devices, for example, provide four input channels.
    ADS1013, ADS1113, ADS1014, and ADS1114 devices provide fewer inputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having multiple input channels does not imply that the device has multiple
    ADCs on board. Instead, most multichannel ADCs have an analog multiplexer, a switch
    that connects a single input to the ADC at a time. This is an important distinction:
    if you have multiple ADCs, they can all convert an input from analog to digital
    concurrently, but a multiplexer switches between inputs, allowing only one conversion
    at a time. The ADS1015 and ADS1115 use internal multiplexers to feed a single
    ADC, so they must perform analog-to-digital conversions for each channel serially.'
  prefs: []
  type: TYPE_NORMAL
- en: 14.1.3 Analog-to-Digital Converter Polarity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ADCs can be unipolar or bipolar. *Unipolar* ADCs can convert only non-negative
    voltages to digital form. This is typical of the ADC found on common SBCs; for
    example, Arduino-class SBCs typically convert voltages in the range of 0 V to
    3.3 V or 5 V. Unipolar ADCs cannot handle negative voltages—in fact, a negative
    input voltage might damage the device. Bipolar ADCs can handle positive and negative
    input voltages.
  prefs: []
  type: TYPE_NORMAL
- en: '*Bipolar* ADCs are usually programmable to operate as a bipolar or unipolar
    device. The reason for operating a bipolar device in unipolar mode is resolution.
    Being able to handle positive and negative voltages eats up a bit of resolution.
    For example, if you operate a 16-bit ADC in bipolar mode, you get a 15-bit range
    for the negative voltages and a 15-bit range for the positive voltages. If you
    feed the device only positive voltages, you lose a bit of resolution. However,
    if you program the device for unipolar operation, you get the full 16 bits of
    resolution, allowing you to resolve smaller positive voltages.'
  prefs: []
  type: TYPE_NORMAL
- en: The ADS1*x*15 devices aren’t true bipolar ADCs. Pin input voltages must always
    be positive with respect to ground. See section 14.1.5, “Differential vs. Single-Ended
    Modes,” for details on how the ADS1*x*15 handle negative inputs.
  prefs: []
  type: TYPE_NORMAL
- en: 14.1.4 Analog-to-Digital Converter Range
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*ADC range* is the range of minimum and maximum voltages an ADC can handle.
    For example, a typical Arduino-class ADC will handle a range of 0 V to 3.3 V or
    0 V to 5 V. Other common ADCs can handle 3.3 V, 4.095 V, 5 V, or 10 V.'
  prefs: []
  type: TYPE_NORMAL
- en: A given ADC might have two different range specifications. One is the span of
    voltages over which the ADC will produce distinct readings—for example, 0 V to
    5 V. The other range is the maximum permissible voltage the inputs will accept
    without damaging the device, which might be –0.5 V to 5.5 V for a typical ADC
    that supports a normal range of 0 V to 5 V. Generally, though, when discussing
    the range of an ADC, I’m talking about the range of inputs that produce distinct
    readings. Voltages outside this range but still within the maximum permissible
    range tend to clip their readings to the minimum or maximum values.
  prefs: []
  type: TYPE_NORMAL
- en: Unipolar devices almost always have a range from 0 V to some maximum voltage
    *n* V. Bipolar devices typically have a range that is ±*n* V (*n* is typically
    some value such as 3.3 V, 5 V, or 10 V).
  prefs: []
  type: TYPE_NORMAL
- en: The ADS1015 and ADS1115 are unipolar in single-ended mode and bipolar in differential
    mode (see the next section for a discussion of differential versus single-ended
    operation). They have a programmable gain stage that limits the range to ±5 V
    (actually 6.144 V, though the pins are limited to 5-V inputs), ±4.095 V, ±2.047
    V, ±1.023 V, ±0.511 V, or ±0.255 V in differential/bipolar mode. For single-ended/unipolar
    mode, cut the range in half with a minimum voltage of 0 V.
  prefs: []
  type: TYPE_NORMAL
- en: 14.1.5 Differential vs. Single-Ended Modes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'ADCs commonly operate in one of two modes: differential or single-ended. Single-ended
    inputs are easier to wire, less complex, and compatible with just about any voltage
    source. Differential inputs may require special differential driver voltage sources
    and are therefore more complex to use.'
  prefs: []
  type: TYPE_NORMAL
- en: In *single-ended mode*, the ADC has a single input with a common ground (for
    all channels, if the ADC supports multiple input channels). Most Arduino-class
    analog inputs fall into this category, with the conversion measuring the voltage
    between the A*n* analog input pin and the common-to-all-analog-inputs analog ground
    pin.
  prefs: []
  type: TYPE_NORMAL
- en: In *differential mode*, an ADC conversion takes two inputs, generally labeled
    + and –, and computes the difference between the voltages on those inputs. It
    then converts this difference to digital form. Differential inputs are generally
    fed from *differential line drivers*, which typically put one half of a single-ended
    voltage on the + output and negative one half of that voltage on the – output.
    Measuring the voltage between the + and – lines gives you the original input voltage.
  prefs: []
  type: TYPE_NORMAL
- en: The main advantage to using differential inputs is that they reduce noise induced
    by the system. A voltage spike (noise) in the system is often summed onto input
    signal lines, such as the inputs to an ADC. On a single-ended input, that noise
    spike might produce a temporary increase or decrease of the input voltage, resulting
    in a momentary deviant reading from the ADC. That noise spike induces the same
    temporary voltage change on a set of differential inputs. However, the spike produces
    roughly the same increase or decrease on both of the differential inputs. When
    the differential input computes the difference between the two inputs, any value
    added to or subtracted from both differential inputs is eliminated from the conversion
    because the value added to the + line matches the value added to the – line. This
    means differential inputs are much less noisy than single-ended inputs, so you
    should use them whenever possible when working with high-resolution (16-bit or
    higher) ADCs.
  prefs: []
  type: TYPE_NORMAL
- en: There are two problems with differential inputs. First, most multichannel ADCs
    that support differential inputs use one channel for the + input and a second
    input channel for the – output. Therefore, using differential inputs cuts the
    number of available ADC channels in half. Differential inputs also require the
    added expense and complexity of special differential driver circuitry to convert
    a standard voltage (single-ended input) to differential form.
  prefs: []
  type: TYPE_NORMAL
- en: The ADS1*x*15 devices are programmable to operate in single-ended or differential
    mode. Differential mode uses two input channels for each differential input, so
    you wind up with two differential inputs per device (rather than four single-ended
    input channels). Nevertheless, if you’re using an ADS1115 with 16-bit precision,
    you really should operate it in differential mode to take advantage of that extra
    precision and not swamp the LO bits of the reading in noise.
  prefs: []
  type: TYPE_NORMAL
- en: The ADS1*x*15 devices do not allow negative voltages on their input pins, which
    affect their differential performance. If your differential line driver converts
    the single-ended input voltage to a positive and negative voltage pair, that negative
    voltage could damage the ADS1*x*15\. Instead, assuming you’re using the range
    of 0 V to 4.095 V, you must devise a differential driver circuit that puts out
    2.047 V on both pins when you want a zero reading. It drives the + pin above 2.047
    V and the – pin below 2.047 V for positive readings; for negative readings, it
    drives the + pin below 2.047 V and the – pin above 2.047 V. The ADS1*x*15 produces
    the maximum (positive or negative) reading when 0 V is on one pin and 4.095 V
    is on the other. If you’re using one of the other voltage ranges on the ADS1*x*15,
    then substitute one half the maximum voltage for 2.047 V and the maximum voltage
    for 4.095 V in this description.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that a range of 0 V to 4.095 V produces only a 15-bit result (0 V
    to 32,767 V). Although the ADS1115 allows only positive voltage on its input pins,
    it is a bipolar device and produces 16-bit signed integer conversions (–32,768
    to +32,767). The ADS1115 produces negative outputs when the – input has a higher
    voltage than the + input. For example, if the + input is at 0 V and the – input
    is at 4.095 V, then the ADS1115 produces –32,768 for the conversion.
  prefs: []
  type: TYPE_NORMAL
- en: 14.1.6 Sample Frequency
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Analog-to-digital conversion is not an instantaneous process. Some ADCs are
    relatively slow, while others are much speedier (and more expensive). Different
    ADCs also have different *sample frequencies*, or readings made per second.
  prefs: []
  type: TYPE_NORMAL
- en: An ADC’s sample frequency has a direct bearing on its applicability. The ADS1*x*15
    devices are not particularly fast. The ADS1115 is capable of 860 samples per second
    (sps) at most; the ADS1015 is a little better, at 3,300 sps. The famous *Nyquest
    theorem* states that you must be able to sample an analog signal at least twice
    its highest frequency in order to create a reasonable digital waveform. This means
    that the ADS1115 is capable of digitizing up to 430-Hz waveforms, while the ADS1015
    can capture 1,650-Hz waveforms. These devices definitely won’t allow you to capture
    digital audio, which requires at least a 40-kHz sample rate for 20-Hz to 20,000-Hz
    capture. Nevertheless, the ADS1*x*15 parts are perfectly acceptable for capturing
    slowly changing signals, like those from human-controlled potentiometers, thermocouples,
    resistive temperature detectors (RTDs), power supply measurement, light sensing
    circuitry, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In some respects, the ADS1*x*115’s slow sample speed isn’t a major problem—the
    I²C bus data transfers provide their own limit on how fast conversions can take
    place. However, these slow conversion rates can also impact the overall application
    performance, especially with Arduino single-thread code.
  prefs: []
  type: TYPE_NORMAL
- en: 14.1.7 Miscellaneous ADS1*x*15 Features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The ADS1*x*15 devices have the following unique built-in features:'
  prefs: []
  type: TYPE_NORMAL
- en: I²C bus speed The ADS1*x*15 devices fully support standard speed mode (100 kHz),
    fast mode (400 kHz), and high-speed mode (up to 3.4 MHz).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: General call support The ADS1*x*15 devices support the I²C general call-reset
    command, where the first byte is 00h and the second byte is 06h.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Programmable gain amplifier The ADS1*x*15 devices feature a programmable gain
    amplifier (PGA), which allows you to set the gain to one of six different levels.
    The gain is selected by 3 bits in the configuration register using the values
    appearing in [Table 14-5](#table14-5) in section 14.3.2.3, “Programmable Gain
    Amplifier Control Bits.” See section 14.3, “ADS1*x*15 Analog-to-Digital Converter
    Registers,” for information about programming the configuration register gain
    settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Programmable comparator The ADS1*x*15 devices provide two 16-bit comparator
    registers that automatically compare the current conversion against a low threshold
    value and a high threshold value. When active, the IC will assert the ALRT pin
    whenever the conversion value is less than the low or higher than the high threshold
    value (“windowed” mode) or whenever the conversion value is greater than the high
    threshold value (“traditional” mode).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continuous (one-shot) mode The ADS1*x*15 devices can be programmed to constantly
    perform ADC conversions or operate in a *one-shot mode* where they perform a conversion
    only in response to a command over the I²C bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 14.2 Analog Conditioning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ADC input ranges are often different from the signals you obtain in the real
    world. A range of 0 V to 5 V is common, both as an input to an ADC and as a single
    voltage in the real world. However, ADC ranges and input signals don’t often match.
    The ADS1*x*15 ADCs are a good example; in their full resolution mode, they support
    an input range of only 0 V to 4.095 V, something you rarely see in real life.
  prefs: []
  type: TYPE_NORMAL
- en: The most common voltage ranges of industrial equipment output are probably 0
    V to 5 V, ±5 V, 0 V to 10 V, or ±10 V. While some ADCs, such as the LTC1859 series,
    support these ranges, you will often need to translate the signal you have to
    a signal your ADC will accept. This—along with other activities such as converting
    currents to voltages—is known as *analog conditioning* (or *signal conditioning*).
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-1](#figure14-1) shows a schematic for an opamp circuit that provides
    two functions: signal amplification or reduction, and conversion from single-ended
    input to differential output. The top half of the figure (opamps at pins 1, 2,
    and 3, and 5, 6, and 7) is an amplifier circuit that will take a voltage in the
    range of ±10 V and translate it to some other voltage in the range of ±10 V. Two
    potentiometers, ZERO and SPAN, control the offset and gain of the amplifier. The
    ZERO (offset) pot adds a voltage in the range of –10 V to +10 V to the input,
    while the SPAN (gain) pot adjusts the amplification (gain) from around 0.05 to
    about 20, with a limit of ±10 V on the output.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c14/f14001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-1: Amplifier and differential driver for ADS1*x*115'
  prefs: []
  type: TYPE_NORMAL
- en: The bottom half of the circuit takes the output from the amplification stage
    and converts it to a differential signal. The top opamp in this differential driver
    is a noninverting amplifier with a gain of one, which simply outputs its input
    voltage as the + differential output. The bottom opamp in this circuit is an inverting
    amplifier, also with a gain of one (0 dB). If the VREF pot is set to 0 V (middle
    position), this amplifier inverts the input. Therefore, this circuit will produce
    the positive output from the top half of the circuit on the + output and the negative
    output from the top half of the circuit on the – output. Overall, this circuit
    has a gain of two (6 dB) because the difference between the + and – outputs is
    actually twice the output from the top half of the circuit. Correct for this by
    reducing the gain in the top amplifier circuit.
  prefs: []
  type: TYPE_NORMAL
- en: Some comments about the quality of the parts in the [Figure 14-1](#figure14-1)
    circuit are in order, because sticking inexpensive components into this circuit
    may produce less-than-desirable results.
  prefs: []
  type: TYPE_NORMAL
- en: First, if you care about long-term stability and lack of drift, you will want
    to use instrumentation-quality OPA4227 or OPA2227 opamps. These aren’t cheap,
    but they are very good. If you don’t mind recalibrating the circuit on a regular
    basis, you can use cheaper (jellybean) LM324 opamps.
  prefs: []
  type: TYPE_NORMAL
- en: Using high-precision, low-TCR resistors in this circuit will also help to ensure
    long-term stability and lack of drift. In particular, the 10-kΩ and 1-kΩ resistors
    should be 0.1 percent 15 PPM/C resistors, which I’ve found for less than $0.50
    each in batches of 100 (at the time this was written). The 20-kΩ pots should be
    10 percent and 50 PPM/C or less; these are not at all cheap, typically $15 to
    $20 each. If you don’t mind recalibrating the circuit on a regular basis, you
    can use cheap resistors and pots—it’s safer to use lower-TCR pots if you need
    to save money.
  prefs: []
  type: TYPE_NORMAL
- en: The two 1-kΩ resistors in this circuit are optional. They are there to prevent
    the gain from going crazy as the SPAN pot approaches one end or the other. Larger
    values like 4.7 kΩ will make gain adjustments smoother, at the expense of a more
    limited gain range. If you pick different resistors, make sure they are low-TCR
    (PPM/C) resistors. The precision isn’t as important because of the pot, but it’s
    usually going to be 0.1 percent for reasonably priced, low-TCR resistors.
  prefs: []
  type: TYPE_NORMAL
- en: The circuit’s 27-Ω resistors are also optional and exist just to prevent a complete
    meltdown if the opamp outputs are shorted. If you decide to install these resistors,
    use 1-percent, metal-film resistors. The 390-Ω resistor can also be a 1-percent,
    metal-film resistor; it’s not that important to the circuit.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if you are using single-ended inputs on your ADC, you can drop the
    bottom half of the circuit and feed the output from pin 1 on the OPA4227 directly
    into the ADC. Of course, given the cost, you should probably substitute an OPA2227
    dual opamp in place of the OPA4277 quad opamp if you do this.
  prefs: []
  type: TYPE_NORMAL
- en: Before using this circuit, you will need to calibrate it. The following steps
    describe the calibration for an ADS1*x*15 ADC device. You’ll need to modify this
    procedure by changing the output voltage the circuit produces when using a different
    ADC. *Do not connect this circuit to the ADS1*x*15 during calibration.* Doing
    so may damage the ADC.
  prefs: []
  type: TYPE_NORMAL
- en: Try to put all the pots in approximately their middle position. The position
    doesn’t have to be accurate, but you want the pot wipers away from either end
    of the terminals.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put 0 V on the single-ended input and apply power to the circuit (±12 V).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Measure the voltage on pin 7 of the OPA4277 and adjust the ZERO pot until the
    output is as close to zero as possible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, measure the voltage at pin 1 of the OPA4277 and, again, adjust the ZERO
    pot until the output voltage is as close to zero as possible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the input voltage to match the maximum voltage you’re going to allow
    (say, 5 V).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Measuring the voltage on pin 1 of the OPA4277, adjust the SPAN pot until you
    get an output as close to 4.095 V as possible. This assumes you will be using
    an ADS1*x*15 programmed to accept 0 V to 4.095 V. If using a different ADC or
    an ADS1*x*15 programmed for a different range, adjust this number accordingly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps 4 through 6 until you don’t have to make any changes to the ZERO
    or SPAN pots. Adjusting one may affect the other, so repeating this process fine-tunes
    the calibration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, you’ve calibrated the amplifier stage. If you’re not using a
    differential output, you’re done; you can feed pin 1 on the OPA4277 to the ADC
    input. If you’re using a differential output, further adjustment is necessary.
    The following steps will warp the calibration of the amplification stage; that’s
    okay, since calibrating the amplifier in steps 1 through 7 just verifies the circuit
    is behaving properly before calibrating the differential driver.
  prefs: []
  type: TYPE_NORMAL
- en: Measure the voltage on pin 10 of the OPA4277 and adjust the VREF pot to get
    the voltage as close to zero as possible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply 0 V to the single-ended input and measure the + differential output with
    respect to Gnd. You should see 0 V at this point. Otherwise, adjust the offset
    using the ZERO pot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While still applying 0 V to the single-ended input, measure the – differential
    output with respect to Gnd. You should see 0 V. Otherwise, adjust the offset using
    the VREF pot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the voltage on the single-ended input to the maximum value you expect
    (say, 5 V) and measure the + differential output with respect to Gnd. You should
    see 4.095 V at this point. Otherwise, adjust the gain using the SPAN pot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps 2 through 4 until further adjustments are unnecessary. Ideally
    you’re seeing –4.095 V, or something very close, on the – differential output
    at step 11\. If there is any major deviation (for example, more than 0.01 V),
    the 10-kΩ resistors in the differential driver circuit must have problems.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, there are a couple of problems with the current calibration:
    first, it outputs negative voltages, which you cannot apply to an ADS1*x*15 input.
    Second, the gain is off by a factor of two. The following steps rectify that.'
  prefs: []
  type: TYPE_NORMAL
- en: Set the voltage on the single-ended input to your maximum voltage (for example,
    5 V). Measure the voltage between the + and – terminals on the differential outputs;
    it should be about 8.191 V. Reduce the gain using the SPAN pot until the output
    voltage is 4.095 V.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the voltage on the single-ended input to 0 V. Measure the voltage between
    the + differential output and Gnd. Adjust the ZERO pot until it reads +2.047 V.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the voltage on the single-ended input to the maximum expected voltage (for
    example, 5 V). Measure the voltage between the + differential output and Gnd.
    Adjust the SPAN pot until the voltage is +4.095 V.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps 2 and 3 until no further adjustments are needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the maximum voltage to the single-ended input. Measure the voltage between
    the – differential output and ground; it should be somewhere near 0 V. Adjust
    the VREF pot until it’s as close as possible to 0 V.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps 2 through 5 until no further adjustments are necessary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point your circuit should be calibrated for use with an ADS1*x*15 operating
    in differential mode. You should be able to input ±5 to the single-ended input
    and, with appropriate software, read –32768 to +32,767 from the device.
  prefs: []
  type: TYPE_NORMAL
- en: 14.3 ADS1*x*15 Analog-to-Digital Converter Registers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ADS1*x*15 devices have five internal registers: the 8-bit pointer register
    (write only), the 16-bit conversion register (read only), the 16-bit configuration
    register (read/write), the 16-bit low threshold register, and the 16-bit high
    threshold register.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The LO 2 bits of the pointer register select one of the other four registers
    (00: conversion, 01: configuration, 10: low threshold, and 11: high threshold).
    The HO 6 bits of the pointer register value should always be 0\. Pointer register
    selection always occurs after a start condition and an address byte with the LO
    bit equal to 0 (a write operation). The next byte after the address transmission
    is the pointer register value (see [Figure 14-2](#figure14-2)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c14/f14002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-2: Pointer register value follows a write command'
  prefs: []
  type: TYPE_NORMAL
- en: When writing to the configuration or threshold registers, you follow the sequence
    in [Figure 14-2](#figure14-2) with the 2-byte value to write to the register specified
    by the `reg` bits. The HO byte of the 16-bit value follows the pointer register
    value, and the LO byte follows, usually with an ending stop condition. See [Figure
    14-3](#figure14-3) for details.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c14/f14003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-3: Writing a value to a 16-bit register'
  prefs: []
  type: TYPE_NORMAL
- en: Reading from a 16-bit register is slightly more complex than writing to the
    register, as it requires sending 2 address bytes—one with the write command and
    a pointer register value and one with a read command (with an intervening restart
    condition). [Figure 14-4](#figure14-4) shows the sequence needed to read 16 bits
    from a register. Note that the system must send a restart condition between the
    register pointer value and the second address, and that the second address has
    the LO bit set to 1 to indicate a read operation.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c14/f14004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-4: Reading a 16-bit register'
  prefs: []
  type: TYPE_NORMAL
- en: The last 2 bytes of the sequence contain the 16-bit value read from the ADC.
    This consists of the HO byte followed by the LO byte.
  prefs: []
  type: TYPE_NORMAL
- en: 14.3.1 The Conversion Register
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The conversion register (register pointer value 0) is a read-only register that
    holds the value of the last analog-to-digital conversion. This is a two’s complement
    signed binary integer in the range of –32768 to +32,767\. On the ADS1015 device
    (which is only a 12-bit ADC), the LO 4 bits of this register always contain 0,
    meaning the range is actually –32,760 to +32759.
  prefs: []
  type: TYPE_NORMAL
- en: In continuous mode, the ADS1*x*15 automatically fills this register with the
    last conversion it makes. In one-shot mode, the ADS1*x*15 places the last requested
    conversion into this register. See section 14.3.2.5, “Operational Status Bit,”
    later in this chapter for information about starting a conversion.
  prefs: []
  type: TYPE_NORMAL
- en: 14.3.2 The Configuration Register
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most of the activity required to perform an analog-to-digital conversion takes
    place in the configuration register (register pointer value 1). [Table 14-2](#table14-2)
    catalogs the meanings of the 16 bits in the configuration register.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 14-2: Configuration Register Bits'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bit** | **Read operation** | **Write operation** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | Read comparator queue state | 00: assert ALRT after 1 conversion 01:
    assert ALRT after 2 conversions'
  prefs: []
  type: TYPE_NORMAL
- en: '10: assert ALRT after 4 conversions'
  prefs: []
  type: TYPE_NORMAL
- en: '11: disable comparator |'
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Read ALRT latch setting | 0: non-latching ALRT; 1: latching ALRT |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Read ALRT pin polarity | 0: active low ALRT; 1: active high ALRT |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Read comparator mode | Write mode. 0: traditional; 1: windowed |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Read conversion rate | Set conversion rate (see details below) |'
  prefs: []
  type: TYPE_TB
- en: '| 6 |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| 7 |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | Read device mode | Set device mode. 1: one shot; 0: continuous |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | Read PGA setting | Set PGA value |'
  prefs: []
  type: TYPE_TB
- en: '| 10 |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| 11 |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | Read mux selection | Write mux selection |'
  prefs: []
  type: TYPE_TB
- en: '| 13 |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | Read input control | Set input control. 0: differential; 1: single-ended
    |'
  prefs: []
  type: TYPE_TB
- en: '| 15 | 0: device is busy doing a conversion; 1: device is ready | Writing a
    1 to this location begins a conversion from power-down mode |'
  prefs: []
  type: TYPE_TB
- en: The following subsections go into more detail concerning these register configuration
    bits.
  prefs: []
  type: TYPE_NORMAL
- en: 14.3.2.1 Comparator Control Bits
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Bits 0 through 4 in the configuration register control the operation of the
    comparator on the ADS1*x*15\. These control whether the comparator is active,
    and they control the ALRT pin polarity and latch, and the type of comparator.
  prefs: []
  type: TYPE_NORMAL
- en: Bits 0 and 1 enable and disable the comparator and control the alert logic.
    If these bits are 0b11 (the default state on power-up/reset), then the comparator
    circuitry is disabled. If the comparator control bits are 0b00, 0b01, or 0b10,
    then the comparator will be enabled and assert the ALRT pin when the conversion
    value exceeds the threshold register range for one reading, two readings, or four
    readings, respectively. Increasing the number of readings before asserting ALRT
    helps filter out noise spikes.
  prefs: []
  type: TYPE_NORMAL
- en: Bit 2 in the configuration register controls the latching mode on the ALRT pin.
    In the default state (0), the ADS1*x*15 asserts the ALRT pin only while the last
    conversion exceeds the threshold range. Should the conversion value drop back
    below the low threshold range, the IC will deassert the ALRT pin. In the latching
    mode, once a conversion value is outside the threshold range (for the specified
    number of conversions), the ALRT pin is latched in the asserted condition. To
    clear the latch, you have to read the conversion register.
  prefs: []
  type: TYPE_NORMAL
- en: Bit 3 in the configuration register controls the ALRT pin polarity. A 0 in this
    bit position (default on power-up/reset) sets an active low signal; a 1 in this
    position sets an active high signal.
  prefs: []
  type: TYPE_NORMAL
- en: Bit 4 sets the traditional or window (range) comparator mode. In the traditional
    mode, the ADS1*x*15 compares the last conversion value against the high threshold
    register (with hysteresis, deasserting the ALRT pin when the input falls below
    the low threshold value). In the window (range) mode, it compares the last conversion
    value against the low and high threshold registers and generates an ALRT if the
    conversion is outside this range.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the comparator control bits, you also control the comparator
    using the low and high threshold registers. See the discussion of those registers
    in section 14.3.4, “The Low and High Threshold Registers,” for more details, especially
    concerning the definition of the ALRT pin as an alert or a ready function.
  prefs: []
  type: TYPE_NORMAL
- en: 14.3.2.2 Device Mode Configuration Bit and Conversion Rate
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Bit 8 of the configuration register specifies whether the ADS1*x*15 operates
    in “one-shot” conversion mode (1, the default on power-up/reset) or in continuous
    conversion mode (0). In one-shot mode, the ADC will perform a conversion only
    in response to a command arriving over the I²C bus (writing a 1 to bit 15 of the
    configuration register). In continuous mode, the ADC begins a new conversion when
    the current one completes. Bits 5 through 7 determine the sample frequency. The
    ADS1015 sample frequencies appear in [Table 14-3](#table14-3).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 14-3: ADS1015 Sample Frequencies'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Configuration bits 5–7** | **Sample frequency** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 000 | 128 sps |'
  prefs: []
  type: TYPE_TB
- en: '| 001 | 250 sps |'
  prefs: []
  type: TYPE_TB
- en: '| 010 | 490 sps |'
  prefs: []
  type: TYPE_TB
- en: '| 011 | 920 sps |'
  prefs: []
  type: TYPE_TB
- en: '| 100 | 1600 sps |'
  prefs: []
  type: TYPE_TB
- en: '| 101 | 2400 sps |'
  prefs: []
  type: TYPE_TB
- en: '| 110 | 3300 sps |'
  prefs: []
  type: TYPE_TB
- en: '| 111 | 3300 sps |'
  prefs: []
  type: TYPE_TB
- en: The ADS1115 sample frequencies appear in [Table 14-4](#table14-4). Note that
    the sample frequencies are different for the two ICs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 14-4: ADS1115 Sample Frequencies'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Configuration bits 5–7** | **Sample frequency** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 000 | 8 sps |'
  prefs: []
  type: TYPE_TB
- en: '| 001 | 16 sps |'
  prefs: []
  type: TYPE_TB
- en: '| 010 | 32 sps |'
  prefs: []
  type: TYPE_TB
- en: '| 011 | 64 sps |'
  prefs: []
  type: TYPE_TB
- en: '| 100 | 128 sps |'
  prefs: []
  type: TYPE_TB
- en: '| 101 | 250 sps |'
  prefs: []
  type: TYPE_TB
- en: '| 110 | 475 sps |'
  prefs: []
  type: TYPE_TB
- en: '| 111 | 860 sps |'
  prefs: []
  type: TYPE_TB
- en: If the ALRT pin is programmed as the “ready” signal, then the ADS1*x*15 will
    pulse the ALRT (or RDY) pin after each conversion when operating in continuous
    mode. When operating in one-shot mode, the ADS1*x*15 will assert the ALRT/RDY
    pin after the conversion is complete if the COMP_POL bit is set to 0\. See section
    14.3.3, “The Low and High Threshold Registers,” later in this chapter for more
    on how to set the ALRT pin to act as the alert or ready signal.
  prefs: []
  type: TYPE_NORMAL
- en: 14.3.2.3 Programmable Gain Amplifier Control Bits
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Bits 9 through 11 in the configuration register specify the gain to apply to
    the incoming analog signal. [Table 14-5](#table14-5) lists the possible gain values
    and voltage ranges.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 14-5: Programmable Gain Amplifier'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Config settings** | **Gain** | **Input voltage range** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 000 | 2/3 | ±6.144 V |'
  prefs: []
  type: TYPE_TB
- en: '| 001 | 1 | ±4.095 V |'
  prefs: []
  type: TYPE_TB
- en: '| 010 | 2 | ±2.047 V |'
  prefs: []
  type: TYPE_TB
- en: '| 011 | 4 | ±1.023 V |'
  prefs: []
  type: TYPE_TB
- en: '| 100 | 8 | ±0.511 V |'
  prefs: []
  type: TYPE_TB
- en: '| 101, 110, 111 | 16 | ±0.255 V |'
  prefs: []
  type: TYPE_TB
- en: In no case may the voltage ranges in [Table 14-5](#table14-5) exceed Vdd. This
    means that if you select configuration value 0b000, the input voltage is still
    limited to 5 V (assuming Vdd is 5 V) even though the range is 0 V to 6.144 V.
    In this mode, the maximum value you will read from the conversion registers is
    about 26,666 rather than 32,767.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, voltages on input pins must never drop below 0 V. Negative values
    are valid for differential mode only when the + input is less than the – input;
    both inputs must be positive with respect to Gnd.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind, when you look at [Table 14-5](#table14-5), that the voltage ranges
    are further limited by Vdd, regardless of the PGA setting. For example, if you’re
    running the ADS1*x*15 at 3.3 V and you’ve programmed the PGA with 0b001 (±4.095
    V), the maximum voltage input will still be 3.3 V. This means that the readings
    will be in the range of –26399 to +26399, rather than the usual –32768 to +32767\.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll most often program the PGA just once (I most commonly use 0b001, for
    the ±4.095-V range). However, if you dynamically modify the PGA during operation—for
    example, to use a different gain setting for each input channel—this may affect
    the operation of the comparator circuitry. All input channels share the same analog-to-digital
    converter circuitry. If you set the comparator threshold(s) for one channel and
    then switch the input multiplexer to a different channel with a different gain,
    the comparator will trip at different voltages for the two channels. The moral
    of the story is that it’s generally best to use the same gain settings for all
    active input channels when working with the comparator circuit.
  prefs: []
  type: TYPE_NORMAL
- en: 14.3.2.4 Multiplexer Control Bits
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Bits 12 through 13 in the configuration register select the input, and bit 14
    controls differential or single-ended mode. If bit 14 is 0 (default on power-up/reset),
    the ADC operates in differential mode. If bit 14 is 1, the ADC operates in single-ended
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: Bits 12 through 13 select an appropriate input, or pair of inputs, as shown
    in [Table 14-6](#table14-6).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 14-6: Input Multiplexer Selection'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Configuration** **bits 12 and 13** | **If bit 14 is 0 (differential mode)**
    | **If bit 14 is 1 (single-ended mode)** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|  | **+ Terminal** | **– Terminal** | **+ Terminal (– terminal is Gnd)** |'
  prefs: []
  type: TYPE_TB
- en: '| 00 | A0 | A1 | A0 |'
  prefs: []
  type: TYPE_TB
- en: '| 01 | A0 | A3 | A1 |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | A1 | A3 | A2 |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | A2 | A3 | A3 |'
  prefs: []
  type: TYPE_TB
- en: The peculiar 0b01 and 0b10 settings in differential mode allow you to use up
    to three differential inputs, if the three inputs (A0, A1, and A2) all share the
    same – terminal. This usually isn’t the case, so differential inputs typically
    use 0b00 or 0b11 for bits 12 and 13\. In single-ended mode (bit 14 = 1), bits
    12 and 13 select one of the four single-ended input channels.
  prefs: []
  type: TYPE_NORMAL
- en: 14.3.2.5 Operational Status Bit
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When reading the configuration register, bits 0 through 14 reflect the last
    values written to those bits. Bit 15, however, performs different duties on read
    and write operations.
  prefs: []
  type: TYPE_NORMAL
- en: Reading the configuration returns the current *ready* status in bit 15\. If
    this bit returns 1, the ADS1*x*15 is not currently performing a conversion, so
    you can begin a new conversion. If bit 15 returns 0, the ADS1*x*15 is in the middle
    of a conversion, and you cannot begin another. Once you begin a conversion in
    one-shot mode, you can test this bit to determine when that conversion is complete.
    In continuous mode, you don’t really care, as the conversion register contains
    the value of the last conversion made.
  prefs: []
  type: TYPE_NORMAL
- en: To begin a conversion in one-shot mode, write a 1 to bit 15 in the conversion
    register. Keep in mind that you must also rewrite the other 15 configuration bits
    when writing to the configuration register. You typically set up a 16-bit value
    that defines how you want the conversion to proceed and set bit 15 equal to 1
    (to begin the conversion). To write to the configuration register without beginning
    a new conversion, just put a 0 in bit 15.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can write a 1 to bit 15 only when operating in one-shot mode,
    which is also known as *power-down* mode. If the ADS1*x*15 is currently operating
    in continuous mode, you must first put it in one-shot mode by writing a 1 to bit
    8\. You can then programmatically start new conversions by writing a 1 to bit
    15.
  prefs: []
  type: TYPE_NORMAL
- en: 14.3.3 The Low and High Threshold Registers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ADS1*x*15 devices provide two 16-bit threshold registers, low (pointer register
    value is 0b10) and high (0b11). The ADS1115 allows you to write the full 16 bits
    to these registers. As the ADS1015 ADCs are 12-bit devices, you should always
    write 0s into the LO 4 bits of these registers.
  prefs: []
  type: TYPE_NORMAL
- en: When operating as a traditional comparator, the ADS1*x*15 compares the conversion
    register against the value in the high threshold register and asserts the ALRT
    pin if the conversion value is greater than the high threshold. The ADS1*x*15
    uses the low threshold register to determine when to deassert the ALRT signal.
    When the input conversion value falls below the value in the low threshold, the
    ADS1*x*15 deasserts ALRT.
  prefs: []
  type: TYPE_NORMAL
- en: In window comparator mode (range mode), the ADS1*x*15 asserts the ALRT pin whenever
    the conversion value is below the low threshold register value or above the high
    threshold value. If you want to assert the pin while the conversion value is between
    the two thresholds, you can simply invert the ALRT pin using bit 3 of the configuration
    register.
  prefs: []
  type: TYPE_NORMAL
- en: In nonlatching mode (see section 14.3.2.1, “Comparator Control Bits,” earlier
    in this chapter), the ADS1*x*15 will automatically assert and deassert the ALRT
    pin as the conversion value goes in and out of range. In latching mode, once the
    IC asserts the ALRT pin, that pin stays active until the software reads the conversion
    register—that is, assuming the conversion value is back within range at that point.
  prefs: []
  type: TYPE_NORMAL
- en: 'The threshold registers provide one additional hidden feature: control of the
    ALRT pin. If the HO bit of the high threshold register is 1 and the HO bit of
    the low threshold register is 0, then the ADS1*x*15 outputs the ready condition
    (configuration register bit 15) on the ALRT pin (which should be called RDY in
    this configuration). Because the values in the threshold registers are two’s complement
    signed binary integers, this particular situation means that the value in the
    high threshold register is less than the value in the low threshold register.
    This is usually an illegal combination; except for this special case, the value
    in the high threshold must always be greater than the value in the low threshold
    register.'
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the discussion of the internal architecture of the ADS1*x*15
    IC. To program it, however, you’ll need some actual hardware you can wire into
    a circuit containing a controlling CPU. Because of their size, you wouldn’t normally
    try to hook an ADS1*x*15 directly onto a breadboard. The next section describes
    the solution to this problem.
  prefs: []
  type: TYPE_NORMAL
- en: 14.4 The Adafruit ADS1*x*15 Breakout Boards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ADS1*x*15 ICs are tiny SMDs that are difficult for all but the most experienced
    of electronic technicians or circuit assembly houses to use. Adafruit solves this
    issue by putting the IC on a small PCB, a “breakout board” with a set of 0.1-inch
    headers that make it easy to use this IC as part of some other circuit.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-5](#figure14-5) shows the Adafruit ADS1115 breakout board. For what
    it’s worth, the ADS1015 board is identical to the ADS1115 board, except for the
    silkscreen and the actual IC placed on the board.'
  prefs: []
  type: TYPE_NORMAL
- en: The ADS1015 and ADS1115 have identical pinouts consisting of 10 holes into which
    you’d normally solder a 1×10 pin header, as described in [Table 14-7](#table14-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c14/f14005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-5: The Adafruit ADS1115 breakout board'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 14-7: Adafruit ADS1*x*15 Pinout'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Pin (name)** | **Function** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Vdd | Power supply (2 V to 5 V) |'
  prefs: []
  type: TYPE_TB
- en: '| Gnd | Digital and analog ground |'
  prefs: []
  type: TYPE_TB
- en: '| SCL | I²C clock line |'
  prefs: []
  type: TYPE_TB
- en: '| SDA | I²C data line |'
  prefs: []
  type: TYPE_TB
- en: '| ADDR | Address selection line |'
  prefs: []
  type: TYPE_TB
- en: '| ALRT | Alert (comparator out of range) or conversion complete |'
  prefs: []
  type: TYPE_TB
- en: '| A0 | Analog input channel 0 (+ differential input 0) |'
  prefs: []
  type: TYPE_TB
- en: '| A1 | Analog input channel 1 (– differential input 0) |'
  prefs: []
  type: TYPE_TB
- en: '| A2 | Analog input channel 2 (+ differential input 1) |'
  prefs: []
  type: TYPE_TB
- en: '| A3 | Analog input channel 3 (– differential input 1) |'
  prefs: []
  type: TYPE_TB
- en: The Vdd, Gnd, SCL, and SDA pins have the usual connections. However, remember
    that although the power supply can be in the range of 2 V to 5 V, the analog input
    pins must never exceed Vdd. If you power the ADS1*x*15 from 3.3 V, the analog
    inputs are limited to 3.3 V.
  prefs: []
  type: TYPE_NORMAL
- en: The Adafruit ADS1*x*15 breakout boards include 10-kΩ pullup resistors on the
    SCL and SDA lines (to Vdd). While it’s convenient to not have to add the pullups
    yourself, if you connect a large number of such devices (with their own pullups)
    to the same I²C bus, the parallel resistance might be an issue. You’ll have to
    desolder the SMD chip resistors from the breakout board if this is the case.
  prefs: []
  type: TYPE_NORMAL
- en: The ADDR pin is an input that the ADS1*x*15 uses to select one of four different
    I²C addresses. Connecting ADDR to Gnd, Vdd, SDA, or SCL specifies the I²C address
    as shown in [Table 14-8](#table14-8)—a particularly clever way to get four separate
    addresses from a single address pin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 14-8: Address Selection on ADS1*x*15'
  prefs: []
  type: TYPE_NORMAL
- en: '| **ADDR connected to** | **I²C address** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Gnd | 0x48 |'
  prefs: []
  type: TYPE_TB
- en: '| Vdd | 0x49 |'
  prefs: []
  type: TYPE_TB
- en: '| SDA | 0x4A |'
  prefs: []
  type: TYPE_TB
- en: '| SCL | 0x4B |'
  prefs: []
  type: TYPE_TB
- en: 'Now refer back to [Table 14-7](#table14-7); the ALRT pin serves two purposes
    on the ADS1*x*15: when used with the built-in comparator, it can signal when a
    conversion is out of some programmable range. This pin can also be used to indicate
    that a conversion is complete—for example, to generate an interrupt, so the CPU
    doesn’t have to constantly poll the device to see when the conversion is done.
    The ALRT pin is an open-drain output pin. The Adafruit ADS1*x*15 breakout boards
    automatically include a pullup resistor on this line so you can treat the ALRT
    pin as a standard logic output.'
  prefs: []
  type: TYPE_NORMAL
- en: The A0, A1, A2, and A3 are the single-ended input pins (the other signal connection
    goes to Gnd). In differential mode 0b000 (configuration register bits 12 through
    14 are 0b000), pins A0 and A1 correspond to channel zero + and – inputs, respectively,
    and pins A2 and A3 correspond to channel 1 + and – inputs. In differential modes
    0b001, 0b010, and 0b011 (bits 12 through 14 in the configuration register), there
    are three differential inputs using pins (A0, A3), (A1, A3), and (A2, A3), with
    A3 being the common (–) differential signal.
  prefs: []
  type: TYPE_NORMAL
- en: 14.5 An ADS1*x*15 Programming Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Basic ADS1*x*15 programming consists of writing an appropriate configuration
    value to the configuration register (including a “start conversion” bit in one-shot
    mode), waiting for the conversion to complete, and then reading the converted
    value from the conversion register. In a typical system, that’s all there is to
    using the ADS1*x*15\.
  prefs: []
  type: TYPE_NORMAL
- en: As a test, hook up an Adafruit ADS1115 breakout board to an Arduino, as shown
    in [Figure 14-6](#figure14-6). You can also use an ADS1015 if you prefer; the
    code works with either device, and I provide sample output for both devices later
    in this section. Note that the ADDR line is wired to Gnd; this sets the I²C address
    to 0x48\. Vdd is wired to +5 V on the Arduino. The sample program in this section
    will read only the A0 input, so connect an appropriate voltage source to the A0
    pin (0 V to 4.095 V). For quick tests, I just connected A0 to ground and the 3.3-V
    supply.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c14/f14006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-6: Hooking up an ADS1115 breakout board to an Arduino'
  prefs: []
  type: TYPE_NORMAL
- en: The program in [Listing 14-1](#listing14-1) demonstrates reading input channel
    A0 and displaying the result in the Arduino serial monitor window.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For testing purposes, the simplest code will set up the configuration register
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Program bits 0 to 4 with 0b00011 (disable the comparator) ❼
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Program bits 5 to 7 with 0b111 (860 sps, though this value is irrelevant) ❻
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Program bit 8 with 1 (one-shot mode) ❺
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Program bits 9 to 11 with 0b001 (PGA = 4.095 V range) ❹
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Program bits 12 to 14 with 0b100 (single-ended, select A0) ❸
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Program bit 15 with 1 (start conversion) ❷
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After writing this value (0xC3E3) to the configuration register ❽, the ADS1115
    will begin converting the voltage appearing on A0 to digital form. The software
    must wait around 1.2 msec for this conversion to complete before it reads the
    result from the conversion register. Of course, a software delay of 1.2 msec is
    completely inappropriate; the right way to wait for the conversion to complete
    is to test bit 15 of the configuration register (the operational status bit) until
    it is 1 (❶ and ❾).
  prefs: []
  type: TYPE_NORMAL
- en: 'When executing the code in [Listing 14-1](#listing14-1), connecting the A0
    line to ground should produce output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can see the tiny amount of noise present during 16-bit conversions (remember,
    each integer unit represents 0.0000625 V). This particular sequence is very clean
    indeed, ranging from –2 to +3—a variance of only about 0.00003 V, an artifact
    of connecting A0 directly to a power supply pin.
  prefs: []
  type: TYPE_NORMAL
- en: 'This software also works fine with an Adafruit ADS1015 12-bit ADC breakout
    board. Here’s some output from that board:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Although the error looks much greater than with the ADS1*x*15, it’s actually
    better. Remember from “The Conversion Register” earlier in this chapter that the
    LO 4 bits of the conversion register are always 0 and the 12-bit conversion appears
    in bits 4 through 15, so what you’re seeing in the previous output is an occasional
    1-bit error. This is one advantage to using a 12-bit rather than a 16-bit ADC:
    less noise.'
  prefs: []
  type: TYPE_NORMAL
- en: 14.6 Improving Polling Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The program in [Listing 14-1](#listing14-1) polled bit 15 of the configuration
    register until it became 1, indicating the conversion was complete and the ADS1*x*15
    was ready to do another conversion. This might not seem like a big deal, but keep
    in mind that reading the configuration register requires five I²C bus transactions:
    two to set the pointer register value and three to read the actual conversion
    register. At 100 kHz, this could take longer than 500 µsec—almost half the time
    of the conversion!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you could reduce time lost to polling by running the ADS1*x*15 at
    a higher clock frequency, but not all SBCs or CPUs support this; some, as you’ve
    seen in this book, don’t even run at a full 100 kHz. Fortunately, if you have
    a spare input pin on your SBC, there is a much faster solution: program the ALRT
    pin as a RDY pin and test for conversion complete by reading that pin.'
  prefs: []
  type: TYPE_NORMAL
- en: To program the ALRT pin as RDY, write a 0 to bit 15 of the low threshold register
    and a 1 to bit 15 of the high threshold register, turn off comparator latching
    (write a 0 to bit 2 of the configuration register), set the ALRT polarity to 0
    (bit 3 of the configuration register), and enable the comparator. This enables
    reading the RDY status on the ALRT pin. You may have noticed that the ALRT pin
    in [Figure 14-6](#figure14-6) is wired to the D2 digital I/O pin on the Arduino.
    The program in [Listing 14-1](#listing14-1) ignored pin D2, but the program in
    [Listing 14-2](#listing14-2) will use this connection to test for when the conversion
    is complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program in [Listing 14-2](#listing14-2) is just a minor modification of
    the program in [Listing 14-1](#listing14-1). As such, I won’t reprint the repeated
    portions of [Listing 14-1](#listing14-1) but will simply highlight the parts of
    the code that are new. I begin with the usual `#define` statements at the beginning
    of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The main addition to this section is the definition of the `rdy` pin ❶.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, I turn to the `wait4Ready()` function, rewritten from the code in [Listing
    14-1](#listing14-1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This `wait4Ready()` function reads the ready status from digital input pin D2
    ❷ rather than reading the configuration register (which is slow) and testing bit
    15 of that register.
  prefs: []
  type: TYPE_NORMAL
- en: 'We next turn to the `setup()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `setup()` function needs to initialize the threshold registers so that the
    low threshold register has a 0 in its HO bit ❸ and the high threshold register
    has a 1 in its HO bit ❹. This code also activates the comparator circuit so it
    can pass the ready status on to the ALRT pin on the ADS1*x*15.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final change is to the code that writes to the configuration in the main
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: While the code in [Listing 14-1](#listing14-1) disables the comparator on each
    pass of the loop, the code in [Listing 14-2](#listing14-2) needs to keep the comparator
    enabled ❺.
  prefs: []
  type: TYPE_NORMAL
- en: These changes to [Listing 14-1](#listing14-1) produce noticeably faster output.
    [Figure 14-7](#figure14-7) shows the output on the ALRT pin (input to the digital
    I/O D2 pin). When this signal is high, the ADC is busy doing a conversion. When
    it is low, the ADC is ready to do another conversion. As [Figure 14-7](#figure14-7)
    shows, the conversions take slightly more than 1 msec when using a Teensy 3.2
    (remember, the ADS1115, on which this was measured, is capable of about 860 sps).
    The low portion of the oscilloscope trace is the time spent sending the conversion
    command to the ADS1115 plus outputting data to the Arduino Serial terminal.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c14/f14007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-7: Oscilloscope output from [Listing 14-2](#listing14-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that I ran the code that produced the output in [Figure 14-7](#figure14-7)
    on a 96-MHz Teensy 3.2, not a 16-MHz Arduino Uno Rev3\. On an Arduino, the bottom
    portion of the cycle might be a bit wider.
  prefs: []
  type: TYPE_NORMAL
- en: Using the RDY pin is not the only way to improve A/D conversion performance.
    The next section looks at another way to speed up the sampling rate.
  prefs: []
  type: TYPE_NORMAL
- en: 14.7 Improving Performance Using Continuous Scanning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Figure 14-7](#figure14-7), just a little more than half the execution time
    is spent doing an analog-to-digital conversion (that is, when the ALRT [RDY] pin
    is high). Between conversions, there are three activities going on in the main
    Arduino `loop` function: writing to the configuration register to start the conversion,
    reading the conversion value from the ADS1115, and printing the results to the
    Arduino Serial terminal. Writing the results to the Serial terminal is not a blazing
    fast process, but writing the configuration register and reading the conversion
    register require nine I²C bus transactions—probably around 900 µsec on a 100-kHz
    bus.'
  prefs: []
  type: TYPE_NORMAL
- en: Nothing can be done to improve the performance of reading the conversion register—that’s
    the only way to get data out of the ADS1115\. However, you can save the expense
    of writing the configuration register on each loop (around 400 µsec) by putting
    the ADS1115 in continuous conversion mode. In this mode, the CPU can request the
    data from the ADS1115 whenever it wants, without having to check if a conversion
    is complete; the ADS1115 will always return the value of the last conversion and
    will automatically update that value as each new conversion takes place. [Listing
    14-3](#listing14-3) provides the code that puts the ADS1115 in continuous conversion
    mode. Again, I won’t reprint any code shared with the previous two listings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `wait4Conversion()` function in [Listing 14-3](#listing14-3) replaces `wait4Ready()`
    in the previous two listings. This function waits until the RDY line (digital
    input D2) goes low ❶, indicating that a conversion has just completed. The ADS1115
    will pulse RDY low for slightly less than 10 µsec and then automatically set it
    high again. This is plenty long enough for the Arduino (or Teensy, in my case)
    to detect that the conversion has completed. However, the code also has to wait
    for this line to go back high ❷ so that the `loop` function won’t repeat while
    the signal is still low and think another conversion has completed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The only real modification to the setup function from the previous examples
    is that it programs bit 8 of the configuration register with 0 ❸, putting the
    device in continuous conversion mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the `loop()` function, the code to write the configuration register is gone.
    Because the ADS1115 is operating in continuous mode, there is no longer a need
    to start a new conversion by writing to the configuration register. The `wait4Conversion()`
    function ❹ is very fast (it’s all digital I/O with no I²C transactions). This
    leaves only reading the conversion register to slow down the main loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-8](#figure14-8) shows the oscilloscope output for the program in
    [Listing 14-3](#listing14-3). The first thing to note is that the time scale is
    one half that of the previous figure’s (500 µsec instead of 1 msec). The period
    for each pulse is just a little more than 1.2 msec (versus about 2 msec in [Figure
    14-7](#figure14-7)), meaning this code runs almost twice as fast as the code in
    the previous listings.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c14/f14008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-8: Oscilloscope output for [Listing 14-3](#listing14-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The only drawback to using the continuous mode to speed up the application is
    that you can read from only one ADC channel (ignoring the power-saving aspects
    of one-shot/power-down mode). To change multiplexer channels, you have to write
    to the configuration register, which eats up all the time saved by removing that
    call in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: 14.8 Interrupts and the ADS1*x*15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In theory, it’s possible to connect the ALRT (RDY) pin to an interrupt input
    on the Arduino—D2 is an interrupt pin on the Arduino Uno Rev3, for example. Whenever
    an interrupt occurs (due to a conversion complete or a comparison out-of-range
    signal), the interrupt service routine can read the data or process the comparison
    fault and pass that information along to the main program.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, however, using interrupts in Arduino code is dubious at best. I²C
    communications, which would have to take place inside the ISR, are extremely slow,
    and ISRs need to be really fast. Maybe it would work with a high-speed–mode I²C
    clock; you’d have to test that and see.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if you are using a multithreaded RTOS with good interrupt
    support (that is, with an interrupt-driven I²C library), interrupts become very
    practical. The ISR would simply signal a thread when a conversion is complete,
    and that thread could talk to the ADS1115, blocking while I²C transmissions (and
    conversion) are taking place. This would consume little CPU time compared to polling
    and would allow other threads to run with little performance loss.
  prefs: []
  type: TYPE_NORMAL
- en: 14.9 Filtering Noise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the real world—as opposed to the simple test circuits I’ve used in this chapter,
    where I’ve wired an analog input directly to a power supply pin—noise can be a
    big issue when reading analog signals. Sources of noise include the environment,
    the circuitry, and the analog sensors themselves. Fortunately, you can digitally
    filter out some of this noise with some simple software techniques.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most common such techniques is to take several readings—say, three
    to nine—and take the median of those values. This scheme picks the middle of a
    bunch of readings and has the advantage of eliminating outlier values. A slightly
    more efficient technique is to take several readings and compute the arithmetic
    mean of those values. This is usually faster than computing the median but has
    the disadvantage of incorporating outliers into the average.
  prefs: []
  type: TYPE_NORMAL
- en: However, both median and mean are based on a fixed set of values, while analog
    readings tend to be a continuous stream. Therefore, the most appropriate solution
    is to create a *windowed average*. To do so, maintain a list of the last *n* readings,
    where *n* is the window size, and compute the average based on those values. Each
    time a new ADC reading comes along, you add it to the window list and throw out
    the oldest reading from the list.
  prefs: []
  type: TYPE_NORMAL
- en: In relatively noisy environments, I usually use *both* techniques to filter
    out the noise. I keep the last seven or nine readings from the ADC and compute
    the median of those values. Then I keep the last 4 to 20 median values (depending
    on the application) and compute the arithmetic mean of those values. For example,
    if I’m computing the median of 9 values and the arithmetic mean of 10 values,
    I’m actually averaging a total of 90 ADC readings at any one given time. In the
    next section, I’ll describe how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: The price of filtering out noise using averaging is that your results will only
    slowly reflect any sudden changes in the analog readings. For example, if your
    input voltage suddenly jumps from 0 V to 5 V, it may take several hundred readings
    before your average shows a solid 5 V.
  prefs: []
  type: TYPE_NORMAL
- en: 14.9.1 Computing Means and Medians
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Computing the arithmetic mean is relatively simple: just sum all the values
    and divide by the number of values. Choosing a window size that is a power of
    two can improve performance, as division by *n* (normally a slow operation) becomes
    a simple shift-right operation. Normally, the window size is sufficiently small
    that summing all the elements in the window is no big deal; however, if you have
    a large number of items, you can save a small amount of time by subtracting the
    oldest element in the window and then adding in the latest reading.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The generic algorithm for computing a median is to sort the data and pick the
    middle element (or take the mean of the middle two elements if there is an even
    number of elements). The quickselect algorithm does much better (see [https://en.wikipedia.org/wiki/Quickselect](https://en.wikipedia.org/wiki/Quickselect)).
    However, for very small windows (say, three, seven, or nine elements), a brute-force
    approach is probably the most efficient. For example, the common way to compute
    the median of three elements is to use code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Code like this is often used to create a pivot element for the quicksort algorithm;
    see “For More Information” for details.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a generic function that computes the median of an array of any size (not
    just three elements) and is faster for certain array sizes. You’ll normally work
    with a fixed window size in any given application. Simply pull out the code from
    the appropriate case in this function to get an algorithm that works for your
    particular window size.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Insertion into an already sorted list takes time equal to O(lg *n*), where *n*
    is the number of elements in the list. If you keep a sorted list of the last *n*
    readings, you can compute the median more efficiently (though removing the oldest
    element might be tricky). However, this is a book on I²C programming, not algorithm
    development, so I will leave further optimizations to interested readers.
  prefs: []
  type: TYPE_NORMAL
- en: 14.10 Chapter Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter covered the programming and use of the ADS1015 and ADS1115 analog-to-digital
    converters. It began with a discussion of the specifications and features of generic
    ADCs with some specific features of the ADS1*x*15 devices to provide an appropriate
    background for the discussion in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Because most ADCs have a limited range of voltage inputs they can process, you
    will often need to add additional analog circuity to *condition* real-world signals,
    that is, convert the incoming signal to something that is appropriate for the
    ADC. Because the ADS1*x*15 ICs are limited to the (somewhat) unusual range of
    0 V to 4.095 V (in full-range mode), this chapter provided an opamp circuit that
    will convert voltages within the range of ±10 V to a range acceptable to the ADS1*x*15
    ICs.
  prefs: []
  type: TYPE_NORMAL
- en: After discussing analog conditioning, this chapter then did a deep dive into
    the registers present on the ADS1*x*15 devices and how to program them via the
    I²C bus. The chapter described all the various bits in the registers and how to
    initialize and use the ADS1*x*15.
  prefs: []
  type: TYPE_NORMAL
- en: Because the ADS1*x*15 parts are surface-mount devices, they’re a bit difficult
    to wire onto a typical prototyping breadboard. So this chapter briefly described
    the Adafruit breakout boards for the ADS1015 and ADS1115 ICs. Adafruit is also
    kind enough to provide sample library code for Arduino and Raspberry Pi systems,
    for which this chapter provided links.
  prefs: []
  type: TYPE_NORMAL
- en: Although you can use the Adafruit libraries to read analog data using the ADS1*x*15
    devices, the goal of this chapter was to teach you how to program the ADS1*x*15
    parts directly. Therefore, this chapter also provided sample programs that program
    the chips directly and obtain the analog data. It also discussed how to improve
    the performance of the (rather slow) ADC parts, and it briefly touched on using
    interrupts with the ADS1*x*15.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter concluded by pointing out that ADC inputs tend to have a bit of
    noise associated with them. It then described a filtering algorithm (using arithmetic
    mean and median averages) to produce a quieter input.
  prefs: []
  type: TYPE_NORMAL
