- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: The ADS1015 and ADS1115 Analog-to-Digital Converters
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: ADS1015 和 ADS1115 模拟到数字转换器
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Although digital I/O is probably the most popular form of input/output on embedded
    computer systems, analog input is also popular. Converting a real-world analog
    signal (typically a voltage in the range 0 V to 3.3 V or 5 V) to numeric (digital)
    form allows an application to use real-world continuous measurements rather than
    the simple on or off from a digital input device. To perform such conversions,
    you’ll need an ADC.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管数字 I/O 可能是嵌入式计算机系统中最常见的输入/输出形式，但模拟输入也很流行。将现实世界中的模拟信号（通常是 0 V 到 3.3 V 或 5 V
    范围内的电压）转换为数字形式，使应用程序能够使用现实世界的连续测量，而不是来自数字输入设备的简单开/关信号。要进行这种转换，你需要一个 ADC。
- en: Many types of ADCs are available. The vast majority of them convert an input
    voltage to an *n*-bit number, though some convert other physical measurements
    into numeric form. For the most part, real-world sensors produce a voltage output
    rather than producing a digital number directly. You would use an ADC to convert
    this voltage level to a digital value. Therefore, to read common sensor outputs,
    an ADC is a critical item in your toolbox.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 市面上有许多种类型的 ADC。绝大多数将输入电压转换为 *n* 位数字，尽管一些将其他物理量转换为数字形式。大多数现实世界中的传感器输出的是电压，而不是直接输出数字。因此，你需要使用
    ADC 将电压值转换为数字值。因此，要读取常见的传感器输出，ADC 是你工具箱中的一个关键部件。
- en: 'This chapter discusses two popular ADCs: the ADS1015 and the ADS1115\. Both
    devices convert voltages between 0.0 V and some upper bound (such as 4.095 V)
    into numeric form: the ADS1015 produces a 12-bit result, and the ADS1115 produces
    a 16-bit result. The ADS1015 is faster, supporting 3,300 samples per second versus
    the ADS1115 at 860 samples per second (a classic trade-off of bits for speed).
    Although other I²C ADCs are available, the ADS1*x*15 devices are popular because
    Adafruit has created a pair of breakout boards that support these two ICs. The
    original Adafruit designs were open hardware, and over time, low-cost clones of
    these boards have appeared on Amazon and other places. These devices are easy
    to interface to any system that has an I²C bus. Adafruit, for example, provides
    library code for Arduino and Raspberry Pi systems, though it’s easy enough to
    interface these devices to any RTOS or system. However, the purpose of this book
    is to teach you how to directly program I²C peripherals, so the next section provides
    the necessary background information on the ADS1*x*15 so you can program it.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了两款流行的 ADC：ADS1015 和 ADS1115。这两款设备将 0.0 V 到某个上限（如 4.095 V）之间的电压转换为数字形式：ADS1015
    产生 12 位结果，而 ADS1115 产生 16 位结果。ADS1015 更快，支持每秒 3,300 次采样，而 ADS1115 为每秒 860 次采样（这是一个经典的速度与位数之间的权衡）。虽然其他
    I²C ADC 也有，但 ADS1*x*15 系列设备很受欢迎，因为 Adafruit 创建了一对支持这两个 IC 的扩展板。最初的 Adafruit 设计是开源硬件，随着时间的推移，低成本的这些板的克隆版在亚马逊等地方出现。这些设备容易与任何具有
    I²C 总线的系统进行接口。例如，Adafruit 提供了适用于 Arduino 和 Raspberry Pi 系统的库代码，尽管将这些设备与任何 RTOS
    或系统接口也是足够容易的。然而，本书的目的是教你如何直接编程 I²C 外设，因此下一节将提供有关 ADS1*x*15 所需的背景信息，以便你能够编程。
- en: 14.1 Analog-to-Digital Converter Specifications
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.1 模拟到数字转换器规格
- en: ADCs have several important specifications that affect their use. [Table 14-1](#table14-1)
    lists some of the more common specifications.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: ADC 有几个重要的规格，影响其使用。[表 14-1](#table14-1) 列出了其中一些常见的规格。
- en: 'Table 14-1: Typical ADC Features'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 表 14-1：典型的 ADC 特性
- en: '| **Feature** | **Units** | **Description** |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| **特性** | **单位** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Resolution | Bits | The size of the integer value produced by the conversion
    |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 分辨率 | 位 | 转换后产生的整数值的大小 |'
- en: '| Channels | Integer | Number of independent converters available on the device
    |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 通道 | 整数 | 设备上可用的独立转换器数量 |'
- en: '| Polarity | Unipolar or bipolar | Determines whether an ADC supports negative
    voltages (bipolar or differential)^([*](#c14-footnote-001)) or only non-negative
    voltages (unipolar) |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 极性 | 单极性或双极性 | 确定一个 ADC 是否支持负电压（双极性或差分）^([*](#c14-footnote-001))，或仅支持非负电压（单极性）
    |'
- en: '| Range | Volts | Supported voltage range for inputs to the ADC |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 范围 | 伏特 | ADC 输入支持的电压范围 |'
- en: '| Input type | Differential or single-ended | Specifies whether the input(s)
    are differential or single-ended (common ground) |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 输入类型 | 差分或单端 | 指定输入是差分的还是单端的（共地） |'
- en: '| Sample frequency | Hz | Number of readings per second the ADC is capable
    of making (also known as *samples per second* or *sps*) |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 采样频率 | Hz | ADC每秒能够读取的次数（也称为*每秒样本数*或*sps*） |'
- en: '| ^([*](#c14-footnoteref-001))The ADS1*x*15 devices do not accept actual negative
    voltages; rather, they accept a differential input where the difference between
    two positive voltage inputs is negative. See the discussion of differential inputs
    in section 14.1.5, “Differential vs. Single-Ended Modes,” later in this chapter.
    |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| ^([*](#c14-footnoteref-001))ADS1*x*15设备不接受实际的负电压；它们接受的是差分输入，其中两个正电压输入之间的差异为负值。请参阅本章后面14.1.5节“差分模式与单端模式”的差分输入讨论。
    |'
- en: The following subsections will describe each of these items and discuss the
    actual ADC1*x*15 specifications.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节将描述这些项目，并讨论实际的ADC1*x*15规格。
- en: 14.1.1 Analog-to-Digital Converter Resolution
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.1 模拟到数字转换器分辨率
- en: The resolution of an ADC is the number of bits the ADC produces for a conversion.
    Low-end ADCs have an 8- or 10-bit resolution (10 bits is typical for the analog
    pins on a typical Arduino-class SBC), while mid-range ADCs commonly have 12-,
    14-, or 16-bit resolution. Higher-end ADCs support 20- or 24-bit resolution. For
    differential inputs, the ADS1015 device provides a 12-bit resolution, and the
    ADC1115 provides 16 bits of resolution. For single-ended applications on either
    device, you lose a bit (see section 14.1.5, “Differential vs. Single-Ended Modes,”
    for more details on differential versus single-ended mode).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ADC的分辨率是ADC为一次转换产生的位数。低端ADC具有8位或10位分辨率（典型的Arduino类SBC的模拟引脚通常为10位），而中档ADC通常具有12位、14位或16位分辨率。高端ADC支持20位或24位分辨率。对于差分输入，ADS1015设备提供12位分辨率，而ADC1115提供16位分辨率。对于这两种设备的单端应用，您会失去一位（有关差分模式与单端模式的更多详细信息，请参阅14.1.5节“差分模式与单端模式”）。
- en: The resolution determines the smallest difference between two voltages an ADC
    can detect. For example, in full-scale mode both the ADS1015 and ADS1115 ADCs
    support voltages in the range of 0 V to 4.095 V. The resolution of the device
    divides this range by the maximum value. A 12-bit resolution divides the input
    range into 4,096 steps, so in theory, the ADS1015 is capable of resolving a difference
    of 0.001 V. The ADS1115, being a 16-bit converter, breaks up the input range into
    65,536 steps. In theory, it’s capable of resolving a difference of 0.0000625 V—substantially
    better. The single-ended inputs have 11-bit and 15-bit resolution, respectively,
    producing 0.002-V and 0.000125-V steps.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 分辨率决定了ADC能够检测到的两个电压之间的最小差异。例如，在全尺度模式下，ADS1015和ADS1115 ADC支持0 V到4.095 V范围内的电压。设备的分辨率将这个范围除以最大值。12位分辨率将输入范围划分为4,096个步进，因此理论上，ADS1015能够分辨出0.001
    V的差异。ADS1115作为16位转换器，将输入范围分成65,536个步进，理论上能够分辨出0.0000625 V的差异——明显更好。单端输入分别具有11位和15位分辨率，产生0.002
    V和0.000125 V的步进。
- en: 'As a general rule, more is better when it comes to ADC resolution. The higher
    the resolution, the more accurate the reading will be. However, extra resolution
    comes at a cost: all other things equal, higher-resolution ADCs are generally
    more expensive and slower than lower-resolution ADCs. Using a higher-resolution
    ADC also does not guarantee that you’ll get more precise readings. System noise
    and other effects may render the extra resolution meaningless in actual applications.
    For most typical SBC applications, 12 bits are sufficient. The presence of 0.0001
    V of noise often completely obliterates the small readings possible with a 16-bit
    ADC.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，在ADC分辨率方面，更高的分辨率更好。分辨率越高，读数越准确。然而，额外的分辨率是有代价的：在其他条件相同的情况下，高分辨率的ADC通常比低分辨率的ADC更贵且更慢。使用高分辨率的ADC也并不保证能够获得更精确的读数。系统噪声和其他效应可能使额外的分辨率在实际应用中变得毫无意义。对于大多数典型的SBC应用来说，12位分辨率已经足够。0.0001
    V的噪声往往会完全掩盖16位ADC可能产生的小读数。
- en: 14.1.2 Analog-to-Digital Converter Channel Count
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.2 模拟到数字转换器通道数
- en: Many ADC devices provide multiple analog inputs. This allows you to connect
    several analog sources to a single ADC device, thus reducing the count and cost
    of parts. The ADS1015 and ADS1115 devices, for example, provide four input channels.
    ADS1013, ADS1113, ADS1014, and ADS1114 devices provide fewer inputs.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 许多ADC设备提供多个模拟输入。这允许您将多个模拟源连接到单个ADC设备，从而减少部件的数量和成本。例如，ADS1015和ADS1115设备提供四个输入通道。ADS1013、ADS1113、ADS1014和ADS1114设备提供较少的输入。
- en: 'Having multiple input channels does not imply that the device has multiple
    ADCs on board. Instead, most multichannel ADCs have an analog multiplexer, a switch
    that connects a single input to the ADC at a time. This is an important distinction:
    if you have multiple ADCs, they can all convert an input from analog to digital
    concurrently, but a multiplexer switches between inputs, allowing only one conversion
    at a time. The ADS1015 and ADS1115 use internal multiplexers to feed a single
    ADC, so they must perform analog-to-digital conversions for each channel serially.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有多个输入通道并不意味着设备板上有多个 ADC。相反，大多数多通道 ADC 具有一个模拟多路复用器，这是一种在每次将单一输入连接到 ADC 时切换输入的开关。这是一个重要的区别：如果你有多个
    ADC，它们可以同时并行地将输入从模拟转换为数字，但多路复用器在输入之间切换，每次只允许进行一次转换。ADS1015 和 ADS1115 使用内部多路复用器为单个
    ADC 提供信号，因此它们必须依次进行每个通道的模拟到数字转换。
- en: 14.1.3 Analog-to-Digital Converter Polarity
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.3 模拟到数字转换器极性
- en: ADCs can be unipolar or bipolar. *Unipolar* ADCs can convert only non-negative
    voltages to digital form. This is typical of the ADC found on common SBCs; for
    example, Arduino-class SBCs typically convert voltages in the range of 0 V to
    3.3 V or 5 V. Unipolar ADCs cannot handle negative voltages—in fact, a negative
    input voltage might damage the device. Bipolar ADCs can handle positive and negative
    input voltages.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ADC 可以是单极性或双极性。*单极性* ADC 只能将非负电压转换为数字形式。这通常出现在常见的单板计算机 (SBC) 上；例如，Arduino 类
    SBC 通常将 0 V 到 3.3 V 或 5 V 范围内的电压转换为数字形式。单极性 ADC 无法处理负电压——实际上，负输入电压可能会损坏设备。双极性
    ADC 可以处理正负输入电压。
- en: '*Bipolar* ADCs are usually programmable to operate as a bipolar or unipolar
    device. The reason for operating a bipolar device in unipolar mode is resolution.
    Being able to handle positive and negative voltages eats up a bit of resolution.
    For example, if you operate a 16-bit ADC in bipolar mode, you get a 15-bit range
    for the negative voltages and a 15-bit range for the positive voltages. If you
    feed the device only positive voltages, you lose a bit of resolution. However,
    if you program the device for unipolar operation, you get the full 16 bits of
    resolution, allowing you to resolve smaller positive voltages.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*双极性* ADC 通常可以编程为双极性或单极性工作模式。将双极性设备设置为单极性工作模式的原因是分辨率。能够处理正负电压会消耗一部分分辨率。例如，如果你将
    16 位 ADC 设置为双极性模式，你将获得 15 位的负电压范围和 15 位的正电压范围。如果只输入正电压，你会失去一些分辨率。然而，如果你将设备编程为单极性模式，你将获得完整的
    16 位分辨率，从而能够解析更小的正电压。'
- en: The ADS1*x*15 devices aren’t true bipolar ADCs. Pin input voltages must always
    be positive with respect to ground. See section 14.1.5, “Differential vs. Single-Ended
    Modes,” for details on how the ADS1*x*15 handle negative inputs.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ADS1*x*15 设备不是传统的双极性 ADC。引脚输入电压必须始终相对于地面为正。有关 ADS1*x*15 如何处理负输入的详细信息，请参见 14.1.5
    节，“差分模式与单端模式”。
- en: 14.1.4 Analog-to-Digital Converter Range
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.4 模拟到数字转换器范围
- en: '*ADC range* is the range of minimum and maximum voltages an ADC can handle.
    For example, a typical Arduino-class ADC will handle a range of 0 V to 3.3 V or
    0 V to 5 V. Other common ADCs can handle 3.3 V, 4.095 V, 5 V, or 10 V.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*ADC 范围* 是 ADC 可以处理的最小和最大电压范围。例如，典型的 Arduino 类 ADC 可以处理 0 V 到 3.3 V 或 0 V 到
    5 V 的范围。其他常见的 ADC 可以处理 3.3 V、4.095 V、5 V 或 10 V 的范围。'
- en: A given ADC might have two different range specifications. One is the span of
    voltages over which the ADC will produce distinct readings—for example, 0 V to
    5 V. The other range is the maximum permissible voltage the inputs will accept
    without damaging the device, which might be –0.5 V to 5.5 V for a typical ADC
    that supports a normal range of 0 V to 5 V. Generally, though, when discussing
    the range of an ADC, I’m talking about the range of inputs that produce distinct
    readings. Voltages outside this range but still within the maximum permissible
    range tend to clip their readings to the minimum or maximum values.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个给定的 ADC 可能有两种不同的范围规格。一种是 ADC 产生不同读数的电压跨度——例如，0 V 到 5 V。另一种范围是输入端可以接受的最大电压，而不会损坏设备，这对于一个典型的支持正常范围
    0 V 到 5 V 的 ADC 来说，可能是 –0.5 V 到 5.5 V。通常来说，当讨论 ADC 的范围时，我指的是产生不同读数的输入范围。超出这个范围但仍在最大允许范围内的电压倾向于将其读数限制在最小值或最大值。
- en: Unipolar devices almost always have a range from 0 V to some maximum voltage
    *n* V. Bipolar devices typically have a range that is ±*n* V (*n* is typically
    some value such as 3.3 V, 5 V, or 10 V).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 单极性设备几乎总是有一个从 0 V 到某个最大电压 *n* V 的范围。双极性设备通常有一个 ±*n* V 的范围（*n* 通常是某个值，例如 3.3
    V、5 V 或 10 V）。
- en: The ADS1015 and ADS1115 are unipolar in single-ended mode and bipolar in differential
    mode (see the next section for a discussion of differential versus single-ended
    operation). They have a programmable gain stage that limits the range to ±5 V
    (actually 6.144 V, though the pins are limited to 5-V inputs), ±4.095 V, ±2.047
    V, ±1.023 V, ±0.511 V, or ±0.255 V in differential/bipolar mode. For single-ended/unipolar
    mode, cut the range in half with a minimum voltage of 0 V.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ADS1015和ADS1115在单端模式下为单极性，在差分模式下为双极性（关于差分与单端操作的讨论请参见下一节）。它们具有可编程增益阶段，将范围限制为±5
    V（实际上是6.144 V，但引脚限制为5 V输入）、±4.095 V、±2.047 V、±1.023 V、±0.511 V或±0.255 V，适用于差分/双极模式。对于单端/单极模式，将范围缩小一半，最低电压为0
    V。
- en: 14.1.5 Differential vs. Single-Ended Modes
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.5 差分模式与单端模式
- en: 'ADCs commonly operate in one of two modes: differential or single-ended. Single-ended
    inputs are easier to wire, less complex, and compatible with just about any voltage
    source. Differential inputs may require special differential driver voltage sources
    and are therefore more complex to use.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ADC通常在两种模式之一下工作：差分模式或单端模式。单端输入更容易布线，结构简单，并且与几乎所有电压源兼容。差分输入可能需要特殊的差分驱动电压源，因此使用起来更为复杂。
- en: In *single-ended mode*, the ADC has a single input with a common ground (for
    all channels, if the ADC supports multiple input channels). Most Arduino-class
    analog inputs fall into this category, with the conversion measuring the voltage
    between the A*n* analog input pin and the common-to-all-analog-inputs analog ground
    pin.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在*单端模式*下，ADC具有一个带有公共接地的单一输入（如果ADC支持多个输入通道，则所有通道共用接地）。大多数Arduino类的模拟输入都属于这一类别，转换测量的是A*n*模拟输入引脚与所有模拟输入共用的模拟接地引脚之间的电压。
- en: In *differential mode*, an ADC conversion takes two inputs, generally labeled
    + and –, and computes the difference between the voltages on those inputs. It
    then converts this difference to digital form. Differential inputs are generally
    fed from *differential line drivers*, which typically put one half of a single-ended
    voltage on the + output and negative one half of that voltage on the – output.
    Measuring the voltage between the + and – lines gives you the original input voltage.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在*差分模式*下，ADC转换接受两个输入，通常标记为+和–，并计算这些输入电压之间的差值。然后，它将该差值转换为数字形式。差分输入通常来自*差分线路驱动器*，这些驱动器通常将单端电压的一半输出到+输出，将其负一半输出到–输出。测量+线和–线之间的电压可以得到原始输入电压。
- en: The main advantage to using differential inputs is that they reduce noise induced
    by the system. A voltage spike (noise) in the system is often summed onto input
    signal lines, such as the inputs to an ADC. On a single-ended input, that noise
    spike might produce a temporary increase or decrease of the input voltage, resulting
    in a momentary deviant reading from the ADC. That noise spike induces the same
    temporary voltage change on a set of differential inputs. However, the spike produces
    roughly the same increase or decrease on both of the differential inputs. When
    the differential input computes the difference between the two inputs, any value
    added to or subtracted from both differential inputs is eliminated from the conversion
    because the value added to the + line matches the value added to the – line. This
    means differential inputs are much less noisy than single-ended inputs, so you
    should use them whenever possible when working with high-resolution (16-bit or
    higher) ADCs.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用差分输入的主要优点是它们能够减少系统引入的噪声。系统中的电压尖峰（噪声）通常会叠加到输入信号线上，比如ADC的输入。在单端输入中，这种噪声尖峰可能会导致输入电压的暂时升高或降低，从而导致ADC读取的瞬时偏差。该噪声尖峰会在一组差分输入上产生相同的暂时电压变化。然而，这种尖峰对两个差分输入的增加或减少大致相同。当差分输入计算两个输入之间的差值时，任何加到或从两个差分输入中减去的值都会在转换中被消除，因为加到+线上的值与加到–线上的值相匹配。这意味着差分输入比单端输入噪声小得多，因此在使用高分辨率（16位或更高）ADC时，应该尽可能使用差分输入。
- en: There are two problems with differential inputs. First, most multichannel ADCs
    that support differential inputs use one channel for the + input and a second
    input channel for the – output. Therefore, using differential inputs cuts the
    number of available ADC channels in half. Differential inputs also require the
    added expense and complexity of special differential driver circuitry to convert
    a standard voltage (single-ended input) to differential form.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 差分输入存在两个问题。首先，大多数支持差分输入的多通道 ADC 使用一个通道作为正输入，另一个通道作为负输出。因此，使用差分输入会将可用的 ADC 通道数量减少一半。差分输入还需要额外的费用和复杂性来使用专用的差分驱动电路，将标准电压（单端输入）转换为差分形式。
- en: The ADS1*x*15 devices are programmable to operate in single-ended or differential
    mode. Differential mode uses two input channels for each differential input, so
    you wind up with two differential inputs per device (rather than four single-ended
    input channels). Nevertheless, if you’re using an ADS1115 with 16-bit precision,
    you really should operate it in differential mode to take advantage of that extra
    precision and not swamp the LO bits of the reading in noise.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ADS1*x*15 设备可以编程以单端模式或差分模式运行。差分模式为每个差分输入使用两个输入通道，因此每个设备有两个差分输入（而不是四个单端输入通道）。尽管如此，如果你使用的是具有
    16 位精度的 ADS1115，最好将其设置为差分模式，以充分利用额外的精度，避免在读取时产生低位噪声。
- en: The ADS1*x*15 devices do not allow negative voltages on their input pins, which
    affect their differential performance. If your differential line driver converts
    the single-ended input voltage to a positive and negative voltage pair, that negative
    voltage could damage the ADS1*x*15\. Instead, assuming you’re using the range
    of 0 V to 4.095 V, you must devise a differential driver circuit that puts out
    2.047 V on both pins when you want a zero reading. It drives the + pin above 2.047
    V and the – pin below 2.047 V for positive readings; for negative readings, it
    drives the + pin below 2.047 V and the – pin above 2.047 V. The ADS1*x*15 produces
    the maximum (positive or negative) reading when 0 V is on one pin and 4.095 V
    is on the other. If you’re using one of the other voltage ranges on the ADS1*x*15,
    then substitute one half the maximum voltage for 2.047 V and the maximum voltage
    for 4.095 V in this description.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ADS1*x*15 设备不允许输入引脚上有负电压，这会影响它们的差分性能。如果你的差分线路驱动器将单端输入电压转换为正负电压对，那么负电压可能会损坏 ADS1*x*15。相反，假设你使用的是
    0 V 到 4.095 V 的范围，当你希望得到零读数时，必须设计一个差分驱动电路，在两个引脚上输出 2.047 V。它将正引脚驱动到高于 2.047 V，负引脚低于
    2.047 V 以获取正读数；对于负读数，则将正引脚驱动到低于 2.047 V，负引脚高于 2.047 V。当一个引脚为 0 V 另一个引脚为 4.095
    V 时，ADS1*x*15 会产生最大（正或负）读数。如果你使用的是 ADS1*x*15 上的其他电压范围，则在此描述中将最大电压的一半替换为 2.047
    V，最大电压替换为 4.095 V。
- en: Also note that a range of 0 V to 4.095 V produces only a 15-bit result (0 V
    to 32,767 V). Although the ADS1115 allows only positive voltage on its input pins,
    it is a bipolar device and produces 16-bit signed integer conversions (–32,768
    to +32,767). The ADS1115 produces negative outputs when the – input has a higher
    voltage than the + input. For example, if the + input is at 0 V and the – input
    is at 4.095 V, then the ADS1115 produces –32,768 for the conversion.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 还需注意，0 V 到 4.095 V 的范围只产生 15 位结果（0 V 到 32,767 V）。尽管 ADS1115 仅允许正电压输入，它仍然是一个双极性设备，并生成
    16 位有符号整数转换（–32,768 到 +32,767）。当负输入的电压高于正输入时，ADS1115 会产生负输出。例如，如果正输入为 0 V，负输入为
    4.095 V，则 ADS1115 产生 –32,768 的转换结果。
- en: 14.1.6 Sample Frequency
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.6 采样频率
- en: Analog-to-digital conversion is not an instantaneous process. Some ADCs are
    relatively slow, while others are much speedier (and more expensive). Different
    ADCs also have different *sample frequencies*, or readings made per second.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 模数转换不是一个瞬时过程。一些 ADC 相对较慢，而其他一些则要快得多（同时也更昂贵）。不同的 ADC 还具有不同的*采样频率*，即每秒钟读取的次数。
- en: An ADC’s sample frequency has a direct bearing on its applicability. The ADS1*x*15
    devices are not particularly fast. The ADS1115 is capable of 860 samples per second
    (sps) at most; the ADS1015 is a little better, at 3,300 sps. The famous *Nyquest
    theorem* states that you must be able to sample an analog signal at least twice
    its highest frequency in order to create a reasonable digital waveform. This means
    that the ADS1115 is capable of digitizing up to 430-Hz waveforms, while the ADS1015
    can capture 1,650-Hz waveforms. These devices definitely won’t allow you to capture
    digital audio, which requires at least a 40-kHz sample rate for 20-Hz to 20,000-Hz
    capture. Nevertheless, the ADS1*x*15 parts are perfectly acceptable for capturing
    slowly changing signals, like those from human-controlled potentiometers, thermocouples,
    resistive temperature detectors (RTDs), power supply measurement, light sensing
    circuitry, and so on.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ADC 的采样频率直接影响其适用性。ADS1*x*15 设备并不特别快。ADS1115 的最大采样率为每秒 860 次（sps）；而 ADS1015 稍微更快，最大为
    3,300 次每秒。著名的 *奈奎斯特定理* 说明，为了生成合理的数字波形，必须至少以模拟信号的最高频率的两倍进行采样。这意味着 ADS1115 可以对最多
    430 Hz 的波形进行数字化，而 ADS1015 可以捕捉到 1,650 Hz 的波形。这些设备绝对无法用于捕捉数字音频，因为数字音频需要至少 40 kHz
    的采样率来捕捉 20 Hz 到 20,000 Hz 之间的频率。然而，ADS1*x*15 设备非常适合捕捉变化缓慢的信号，例如来自人工控制的电位计、热电偶、热阻温度探测器（RTD）、电源测量、光传感电路等信号。
- en: In some respects, the ADS1*x*115’s slow sample speed isn’t a major problem—the
    I²C bus data transfers provide their own limit on how fast conversions can take
    place. However, these slow conversion rates can also impact the overall application
    performance, especially with Arduino single-thread code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些方面，ADS1*x*115 的较慢采样速度并不是一个主要问题——I²C 总线数据传输本身限制了转换的速度。然而，这些较慢的转换速度也会影响整体应用性能，特别是在使用
    Arduino 单线程代码时。
- en: 14.1.7 Miscellaneous ADS1*x*15 Features
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.7 杂项 ADS1*x*15 特性
- en: 'The ADS1*x*15 devices have the following unique built-in features:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ADS1*x*15 设备具有以下独特的内建功能：
- en: I²C bus speed The ADS1*x*15 devices fully support standard speed mode (100 kHz),
    fast mode (400 kHz), and high-speed mode (up to 3.4 MHz).
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: I²C 总线速度 ADS1*x*15 设备完全支持标准速度模式（100 kHz）、快速模式（400 kHz）和高速模式（最高 3.4 MHz）。
- en: General call support The ADS1*x*15 devices support the I²C general call-reset
    command, where the first byte is 00h and the second byte is 06h.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通用调用支持 ADS1*x*15 设备支持 I²C 通用调用复位命令，其中第一个字节为 00h，第二个字节为 06h。
- en: Programmable gain amplifier The ADS1*x*15 devices feature a programmable gain
    amplifier (PGA), which allows you to set the gain to one of six different levels.
    The gain is selected by 3 bits in the configuration register using the values
    appearing in [Table 14-5](#table14-5) in section 14.3.2.3, “Programmable Gain
    Amplifier Control Bits.” See section 14.3, “ADS1*x*15 Analog-to-Digital Converter
    Registers,” for information about programming the configuration register gain
    settings.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可编程增益放大器 ADS1*x*15 设备配备可编程增益放大器（PGA），可以将增益设置为六个不同的级别之一。增益通过配置寄存器中的 3 位来选择，具体值见第
    14.3.2.3 节 “可编程增益放大器控制位”中的[表 14-5](#table14-5)。有关如何编程配置寄存器增益设置的信息，请参阅第 14.3 节
    “ADS1*x*15 模数转换器寄存器”。
- en: Programmable comparator The ADS1*x*15 devices provide two 16-bit comparator
    registers that automatically compare the current conversion against a low threshold
    value and a high threshold value. When active, the IC will assert the ALRT pin
    whenever the conversion value is less than the low or higher than the high threshold
    value (“windowed” mode) or whenever the conversion value is greater than the high
    threshold value (“traditional” mode).
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可编程比较器 ADS1*x*15 设备提供两个 16 位比较器寄存器，这些寄存器会自动将当前转换值与低阈值和高阈值进行比较。当激活时，IC 会在转换值低于低阈值或高于高阈值时触发
    ALRT 引脚（“窗口模式”），或者当转换值超过高阈值时触发（“传统模式”）。
- en: Continuous (one-shot) mode The ADS1*x*15 devices can be programmed to constantly
    perform ADC conversions or operate in a *one-shot mode* where they perform a conversion
    only in response to a command over the I²C bus.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连续（单次）模式 ADS1*x*15 设备可以被编程为不断执行 ADC 转换，或者以 *单次模式* 运行，仅在接收到 I²C 总线上的命令时执行一次转换。
- en: 14.2 Analog Conditioning
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.2 模拟信号调理
- en: ADC input ranges are often different from the signals you obtain in the real
    world. A range of 0 V to 5 V is common, both as an input to an ADC and as a single
    voltage in the real world. However, ADC ranges and input signals don’t often match.
    The ADS1*x*15 ADCs are a good example; in their full resolution mode, they support
    an input range of only 0 V to 4.095 V, something you rarely see in real life.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ADC的输入范围通常与实际世界中获得的信号不同。0 V到5 V的范围很常见，既作为ADC的输入，也作为现实世界中的单一电压。然而，ADC范围和输入信号往往不匹配。以ADS1*x*15系列ADC为例，在其全分辨率模式下，它们仅支持0
    V到4.095 V的输入范围，这在实际生活中很少见。
- en: The most common voltage ranges of industrial equipment output are probably 0
    V to 5 V, ±5 V, 0 V to 10 V, or ±10 V. While some ADCs, such as the LTC1859 series,
    support these ranges, you will often need to translate the signal you have to
    a signal your ADC will accept. This—along with other activities such as converting
    currents to voltages—is known as *analog conditioning* (or *signal conditioning*).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 工业设备输出的最常见电压范围可能是0 V到5 V、±5 V、0 V到10 V或±10 V。虽然一些ADC，如LTC1859系列，支持这些范围，但你通常需要将你已有的信号转换为ADC可以接受的信号。这——以及将电流转换为电压等其他活动——被称为*模拟调理*（或*信号调理*）。
- en: '[Figure 14-1](#figure14-1) shows a schematic for an opamp circuit that provides
    two functions: signal amplification or reduction, and conversion from single-ended
    input to differential output. The top half of the figure (opamps at pins 1, 2,
    and 3, and 5, 6, and 7) is an amplifier circuit that will take a voltage in the
    range of ±10 V and translate it to some other voltage in the range of ±10 V. Two
    potentiometers, ZERO and SPAN, control the offset and gain of the amplifier. The
    ZERO (offset) pot adds a voltage in the range of –10 V to +10 V to the input,
    while the SPAN (gain) pot adjusts the amplification (gain) from around 0.05 to
    about 20, with a limit of ±10 V on the output.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-1](#figure14-1)显示了一个运算放大器电路的原理图，提供两个功能：信号放大或减小，以及从单端输入到差分输出的转换。图的上半部分（运放连接在1、2、3引脚以及5、6、7引脚）是一个放大电路，将±10
    V范围内的电压转换为±10 V范围内的其他电压。两个电位器，ZERO和SPAN，分别控制放大器的偏移和增益。ZERO（偏移）电位器为输入添加一个-10 V到+10
    V范围的电压，而SPAN（增益）电位器将增益调整为大约0.05到20之间，输出限制在±10 V范围内。'
- en: '![](image_fi/502468c14/f14001.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c14/f14001.png)'
- en: 'Figure 14-1: Amplifier and differential driver for ADS1*x*115'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-1：ADS1*x*115的放大器和差分驱动器
- en: The bottom half of the circuit takes the output from the amplification stage
    and converts it to a differential signal. The top opamp in this differential driver
    is a noninverting amplifier with a gain of one, which simply outputs its input
    voltage as the + differential output. The bottom opamp in this circuit is an inverting
    amplifier, also with a gain of one (0 dB). If the VREF pot is set to 0 V (middle
    position), this amplifier inverts the input. Therefore, this circuit will produce
    the positive output from the top half of the circuit on the + output and the negative
    output from the top half of the circuit on the – output. Overall, this circuit
    has a gain of two (6 dB) because the difference between the + and – outputs is
    actually twice the output from the top half of the circuit. Correct for this by
    reducing the gain in the top amplifier circuit.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 电路的下半部分将来自放大阶段的输出转换为差分信号。这个差分驱动器中的上部运算放大器是一个增益为1的非反相放大器，简单地将其输入电压作为+差分输出输出。这个电路中的下部运算放大器是一个反相放大器，增益也是1（0
    dB）。如果VREF电位器设置为0 V（中间位置），该放大器将反转输入。因此，该电路将产生来自上半部分电路的正输出作为+输出，来自上半部分电路的负输出作为-输出。总体而言，这个电路的增益是二倍（6
    dB），因为+和-输出之间的差值实际上是上半部分电路输出的两倍。通过减少上半部分放大电路中的增益来校正这一点。
- en: Some comments about the quality of the parts in the [Figure 14-1](#figure14-1)
    circuit are in order, because sticking inexpensive components into this circuit
    may produce less-than-desirable results.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 关于[图 14-1](#figure14-1)电路中元件质量的评论是有必要的，因为将低成本的元件放入该电路可能会产生不理想的结果。
- en: First, if you care about long-term stability and lack of drift, you will want
    to use instrumentation-quality OPA4227 or OPA2227 opamps. These aren’t cheap,
    but they are very good. If you don’t mind recalibrating the circuit on a regular
    basis, you can use cheaper (jellybean) LM324 opamps.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果你关心长期稳定性和漂移问题，你应该使用仪器级的OPA4227或OPA2227运算放大器。这些虽然不便宜，但非常好。如果你不介意定期重新校准电路，你可以使用更便宜的（常见的）LM324运算放大器。
- en: Using high-precision, low-TCR resistors in this circuit will also help to ensure
    long-term stability and lack of drift. In particular, the 10-kΩ and 1-kΩ resistors
    should be 0.1 percent 15 PPM/C resistors, which I’ve found for less than $0.50
    each in batches of 100 (at the time this was written). The 20-kΩ pots should be
    10 percent and 50 PPM/C or less; these are not at all cheap, typically $15 to
    $20 each. If you don’t mind recalibrating the circuit on a regular basis, you
    can use cheap resistors and pots—it’s safer to use lower-TCR pots if you need
    to save money.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在此电路中使用高精度、低温系数电阻还有助于确保长期稳定性和无漂移。特别是，10千欧和1千欧电阻应为0.1%、15 PPM/C的电阻，我在批量购买时发现它们的价格不到0.50美元每个（截至本文撰写时）。20千欧电位器应为10%和50
    PPM/C或更低；这些电位器价格不便宜，通常每个15到20美元。如果你不介意定期重新校准电路，你可以使用便宜的电阻和电位器—如果需要节省开支，使用低温系数电位器会更安全。
- en: The two 1-kΩ resistors in this circuit are optional. They are there to prevent
    the gain from going crazy as the SPAN pot approaches one end or the other. Larger
    values like 4.7 kΩ will make gain adjustments smoother, at the expense of a more
    limited gain range. If you pick different resistors, make sure they are low-TCR
    (PPM/C) resistors. The precision isn’t as important because of the pot, but it’s
    usually going to be 0.1 percent for reasonably priced, low-TCR resistors.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此电路中的两个1千欧电阻是可选的。它们的作用是防止当SPAN电位器接近一个端点时增益出现异常。像4.7千欧这样较大的电阻值将使增益调整更加平滑，但代价是增益范围较小。如果选择不同的电阻，请确保它们是低温系数（PPM/C）电阻。由于电位器的存在，精度并不是特别重要，但通常合理价格的低温系数电阻的精度为0.1%。
- en: The circuit’s 27-Ω resistors are also optional and exist just to prevent a complete
    meltdown if the opamp outputs are shorted. If you decide to install these resistors,
    use 1-percent, metal-film resistors. The 390-Ω resistor can also be a 1-percent,
    metal-film resistor; it’s not that important to the circuit.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 电路中的27欧电阻也是可选的，它们仅用于防止在运算放大器输出端短路时造成完全失效。如果决定安装这些电阻，请使用1%的金属膜电阻。390欧电阻也可以使用1%的金属膜电阻；它对电路的影响并不大。
- en: Finally, if you are using single-ended inputs on your ADC, you can drop the
    bottom half of the circuit and feed the output from pin 1 on the OPA4227 directly
    into the ADC. Of course, given the cost, you should probably substitute an OPA2227
    dual opamp in place of the OPA4277 quad opamp if you do this.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你使用的是ADC的单端输入，可以去掉电路的下半部分，并将OPA4227的1号引脚输出直接连接到ADC。当然，考虑到成本问题，如果这样做，你可能需要用OPA2227双运算放大器替换OPA4277四运算放大器。
- en: Before using this circuit, you will need to calibrate it. The following steps
    describe the calibration for an ADS1*x*15 ADC device. You’ll need to modify this
    procedure by changing the output voltage the circuit produces when using a different
    ADC. *Do not connect this circuit to the ADS1*x*15 during calibration.* Doing
    so may damage the ADC.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用此电路之前，你需要进行校准。以下步骤描述了针对ADS1*x*15 ADC设备的校准过程。如果使用不同的ADC，你需要通过改变电路输出电压来修改此过程。*在校准过程中请勿将此电路连接到ADS1*x*15。*
    否则可能会损坏ADC。
- en: Try to put all the pots in approximately their middle position. The position
    doesn’t have to be accurate, but you want the pot wipers away from either end
    of the terminals.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试将所有电位器大致放在中间位置。位置不必非常准确，但你希望电位器的刮刀远离端子两端。
- en: Put 0 V on the single-ended input and apply power to the circuit (±12 V).
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在单端输入端施加0 V电压，并为电路提供电源（±12 V）。
- en: Measure the voltage on pin 7 of the OPA4277 and adjust the ZERO pot until the
    output is as close to zero as possible.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测量OPA4277的7号引脚上的电压，并调整ZERO电位器，直到输出尽可能接近零。
- en: Now, measure the voltage at pin 1 of the OPA4277 and, again, adjust the ZERO
    pot until the output voltage is as close to zero as possible.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，测量OPA4277的1号引脚上的电压，然后再次调整ZERO电位器，直到输出电压尽可能接近零。
- en: Change the input voltage to match the maximum voltage you’re going to allow
    (say, 5 V).
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将输入电压调节至你打算允许的最大电压（例如5 V）。
- en: Measuring the voltage on pin 1 of the OPA4277, adjust the SPAN pot until you
    get an output as close to 4.095 V as possible. This assumes you will be using
    an ADS1*x*15 programmed to accept 0 V to 4.095 V. If using a different ADC or
    an ADS1*x*15 programmed for a different range, adjust this number accordingly.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测量OPA4277的1号引脚上的电压，调整SPAN电位器，直到输出尽可能接近4.095 V。假设你将使用已编程为接受0 V到4.095 V的ADS1*x*15。如果使用不同的ADC或已编程为不同范围的ADS1*x*15，请相应调整此数值。
- en: Repeat steps 4 through 6 until you don’t have to make any changes to the ZERO
    or SPAN pots. Adjusting one may affect the other, so repeating this process fine-tunes
    the calibration.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤4到6，直到你不再需要调整ZERO或SPAN电位器。调整其中一个可能会影响另一个，因此重复此过程可以精细调整标定。
- en: At this point, you’ve calibrated the amplifier stage. If you’re not using a
    differential output, you’re done; you can feed pin 1 on the OPA4277 to the ADC
    input. If you’re using a differential output, further adjustment is necessary.
    The following steps will warp the calibration of the amplification stage; that’s
    okay, since calibrating the amplifier in steps 1 through 7 just verifies the circuit
    is behaving properly before calibrating the differential driver.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你已经完成了放大器阶段的标定。如果你不使用差分输出，你已经完成了标定；可以将OPA4277的第1引脚接到ADC输入。如果你使用差分输出，则还需要进一步调整。接下来的步骤将扭曲放大阶段的标定；这没关系，因为步骤1到7中的标定只是为了验证电路在标定差分驱动器之前正常工作。
- en: Measure the voltage on pin 10 of the OPA4277 and adjust the VREF pot to get
    the voltage as close to zero as possible.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测量OPA4277第10引脚的电压，并调整VREF电位器，使电压尽可能接近零。
- en: Apply 0 V to the single-ended input and measure the + differential output with
    respect to Gnd. You should see 0 V at this point. Otherwise, adjust the offset
    using the ZERO pot.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对单端输入施加0 V，并测量+差分输出与地之间的电压。此时你应该看到0 V。否则，使用ZERO电位器调整偏移量。
- en: While still applying 0 V to the single-ended input, measure the – differential
    output with respect to Gnd. You should see 0 V. Otherwise, adjust the offset using
    the VREF pot.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在仍然施加0 V到单端输入的情况下，测量–差分输出与地之间的电压。此时应为0 V。否则，使用VREF电位器调整偏移量。
- en: Change the voltage on the single-ended input to the maximum value you expect
    (say, 5 V) and measure the + differential output with respect to Gnd. You should
    see 4.095 V at this point. Otherwise, adjust the gain using the SPAN pot.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将单端输入的电压更改为你预期的最大值（比如5 V），并测量+差分输出与地之间的电压。此时你应该看到4.095 V。否则，使用SPAN电位器调整增益。
- en: Repeat steps 2 through 4 until further adjustments are unnecessary. Ideally
    you’re seeing –4.095 V, or something very close, on the – differential output
    at step 11\. If there is any major deviation (for example, more than 0.01 V),
    the 10-kΩ resistors in the differential driver circuit must have problems.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤2到4，直到不再需要进一步调整。理想情况下，在第11步的–差分输出上，你应该看到–4.095 V或非常接近的值。如果有较大的偏差（例如，超过0.01
    V），差分驱动电路中的10 kΩ电阻可能存在问题。
- en: 'At this point, there are a couple of problems with the current calibration:
    first, it outputs negative voltages, which you cannot apply to an ADS1*x*15 input.
    Second, the gain is off by a factor of two. The following steps rectify that.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，当前的标定存在几个问题：首先，它输出负电压，而你不能将负电压应用到ADS1*x*15输入；其次，增益偏离了两倍。接下来的步骤可以解决这些问题。
- en: Set the voltage on the single-ended input to your maximum voltage (for example,
    5 V). Measure the voltage between the + and – terminals on the differential outputs;
    it should be about 8.191 V. Reduce the gain using the SPAN pot until the output
    voltage is 4.095 V.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将单端输入的电压设置为最大电压（例如，5 V）。测量+和–差分输出端子之间的电压；它应该约为8.191 V。使用SPAN电位器减少增益，直到输出电压为4.095
    V。
- en: Set the voltage on the single-ended input to 0 V. Measure the voltage between
    the + differential output and Gnd. Adjust the ZERO pot until it reads +2.047 V.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将单端输入的电压设置为0 V。测量+差分输出和地之间的电压。调整ZERO电位器，直到其读数为+2.047 V。
- en: Set the voltage on the single-ended input to the maximum expected voltage (for
    example, 5 V). Measure the voltage between the + differential output and Gnd.
    Adjust the SPAN pot until the voltage is +4.095 V.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将单端输入的电压设置为最大预期电压（例如，5 V）。测量+差分输出和地之间的电压。调整SPAN电位器，直到电压为+4.095 V。
- en: Repeat steps 2 and 3 until no further adjustments are needed.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤2和3，直到不再需要进一步调整。
- en: Apply the maximum voltage to the single-ended input. Measure the voltage between
    the – differential output and ground; it should be somewhere near 0 V. Adjust
    the VREF pot until it’s as close as possible to 0 V.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对单端输入施加最大电压。测量–差分输出和地之间的电压；它应该接近0 V。调整VREF电位器，直到它尽可能接近0 V。
- en: Repeat steps 2 through 5 until no further adjustments are necessary.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤2到5，直到不再需要进一步调整。
- en: At this point your circuit should be calibrated for use with an ADS1*x*15 operating
    in differential mode. You should be able to input ±5 to the single-ended input
    and, with appropriate software, read –32768 to +32,767 from the device.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此时您的电路应该校准，以便与在差分模式下运行的 ADS1*x*15 设备一起使用。您应该能够输入 ±5 到单端输入，并使用适当的软件从设备读取 -32768
    到 +32767。
- en: 14.3 ADS1*x*15 Analog-to-Digital Converter Registers
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.3 ADS1*x*15 模数转换器寄存器
- en: 'The ADS1*x*15 devices have five internal registers: the 8-bit pointer register
    (write only), the 16-bit conversion register (read only), the 16-bit configuration
    register (read/write), the 16-bit low threshold register, and the 16-bit high
    threshold register.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ADS1*x*15 设备有五个内部寄存器：8 位指针寄存器（仅写），16 位转换寄存器（仅读），16 位配置寄存器（读/写），16 位低阈值寄存器和 16
    位高阈值寄存器。
- en: 'The LO 2 bits of the pointer register select one of the other four registers
    (00: conversion, 01: configuration, 10: low threshold, and 11: high threshold).
    The HO 6 bits of the pointer register value should always be 0\. Pointer register
    selection always occurs after a start condition and an address byte with the LO
    bit equal to 0 (a write operation). The next byte after the address transmission
    is the pointer register value (see [Figure 14-2](#figure14-2)).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 指针寄存器的低 2 位选择其他四个寄存器之一（00：转换，01：配置，10：低阈值，11：高阈值）。指针寄存器值的高 6 位应始终为 0。在启动条件和
    LO 位等于 0 的地址字节后，始终进行指针寄存器选择（写操作）。地址传输后的下一个字节是指针寄存器值（参见 [图 14-2](#figure14-2)）。
- en: '![](image_fi/502468c14/f14002.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c14/f14002.png)'
- en: 'Figure 14-2: Pointer register value follows a write command'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-2：指针寄存器值跟随写命令
- en: When writing to the configuration or threshold registers, you follow the sequence
    in [Figure 14-2](#figure14-2) with the 2-byte value to write to the register specified
    by the `reg` bits. The HO byte of the 16-bit value follows the pointer register
    value, and the LO byte follows, usually with an ending stop condition. See [Figure
    14-3](#figure14-3) for details.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当写入配置或阈值寄存器时，请按照 [图 14-2](#figure14-2) 中的顺序，使用 2 字节值写入由 `reg` 位指定的寄存器。16 位值的高字节跟随指针寄存器值，低字节通常在结束停止条件后跟随。详细信息请参见
    [图 14-3](#figure14-3)。
- en: '![](image_fi/502468c14/f14003.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c14/f14003.png)'
- en: 'Figure 14-3: Writing a value to a 16-bit register'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-3：向 16 位寄存器写入值
- en: Reading from a 16-bit register is slightly more complex than writing to the
    register, as it requires sending 2 address bytes—one with the write command and
    a pointer register value and one with a read command (with an intervening restart
    condition). [Figure 14-4](#figure14-4) shows the sequence needed to read 16 bits
    from a register. Note that the system must send a restart condition between the
    register pointer value and the second address, and that the second address has
    the LO bit set to 1 to indicate a read operation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从 16 位寄存器读取比写入寄存器稍复杂，因为它需要发送 2 个地址字节——一个带有写命令和指针寄存器值的，另一个带有读命令的（中间有重新启动条件）。[图
    14-4](#figure14-4) 显示从寄存器读取 16 位所需的序列。请注意，系统必须在寄存器指针值和第二个地址之间发送重新启动条件，并且第二个地址的
    LO 位设置为 1，表示读操作。
- en: '![](image_fi/502468c14/f14004.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c14/f14004.png)'
- en: 'Figure 14-4: Reading a 16-bit register'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-4：读取 16 位寄存器
- en: The last 2 bytes of the sequence contain the 16-bit value read from the ADC.
    This consists of the HO byte followed by the LO byte.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 序列的最后 2 个字节包含从 ADC 读取的 16 位值。这包括高字节后跟随的低字节。
- en: 14.3.1 The Conversion Register
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.1 转换寄存器
- en: The conversion register (register pointer value 0) is a read-only register that
    holds the value of the last analog-to-digital conversion. This is a two’s complement
    signed binary integer in the range of –32768 to +32,767\. On the ADS1015 device
    (which is only a 12-bit ADC), the LO 4 bits of this register always contain 0,
    meaning the range is actually –32,760 to +32759.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 转换寄存器（寄存器指针值为 0）是一个只读寄存器，保存最后一次模数转换的值。这是一个范围为 -32768 到 +32767 的二进制补码有符号整数。在
    ADS1015 设备上（仅为 12 位 ADC），该寄存器的低 4 位始终包含 0，意味着实际范围是 -32760 到 +32759。
- en: In continuous mode, the ADS1*x*15 automatically fills this register with the
    last conversion it makes. In one-shot mode, the ADS1*x*15 places the last requested
    conversion into this register. See section 14.3.2.5, “Operational Status Bit,”
    later in this chapter for information about starting a conversion.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在连续模式下，ADS1*x*15 自动将此寄存器填充为其进行的最后一次转换。在单次模式下，ADS1*x*15 将最后请求的转换放入此寄存器。有关启动转换的信息，请参见本章后面的
    14.3.2.5 节“操作状态位”。
- en: 14.3.2 The Configuration Register
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.2 配置寄存器
- en: Most of the activity required to perform an analog-to-digital conversion takes
    place in the configuration register (register pointer value 1). [Table 14-2](#table14-2)
    catalogs the meanings of the 16 bits in the configuration register.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 执行模拟到数字转换所需的大部分操作都在配置寄存器中进行（寄存器指针值为 1）。[表 14-2](#table14-2) 列出了配置寄存器中 16 位的含义。
- en: 'Table 14-2: Configuration Register Bits'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 表 14-2：配置寄存器位
- en: '| **Bit** | **Read operation** | **Write operation** |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| **位** | **读取操作** | **写入操作** |'
- en: '| --- | --- | --- |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | Read comparator queue state | 00: assert ALRT after 1 conversion 01:
    assert ALRT after 2 conversions'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '| 0 | 读取比较器队列状态 | 00：在 1 次转换后触发 ALRT；01：在 2 次转换后触发 ALRT |'
- en: '10: assert ALRT after 4 conversions'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '10: 在 4 次转换后触发 ALRT'
- en: '11: disable comparator |'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '11: 禁用比较器 |'
- en: '| 1 |  |  |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 1 |  |  |'
- en: '| 2 | Read ALRT latch setting | 0: non-latching ALRT; 1: latching ALRT |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 读取 ALRT 闩锁设置 | 0：非闩锁 ALRT；1：闩锁 ALRT |'
- en: '| 3 | Read ALRT pin polarity | 0: active low ALRT; 1: active high ALRT |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 读取 ALRT 引脚极性 | 0：ALRT 为低电平有效；1：ALRT 为高电平有效 |'
- en: '| 4 | Read comparator mode | Write mode. 0: traditional; 1: windowed |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 读取比较器模式 | 写入模式。0：传统模式；1：窗口模式 |'
- en: '| 5 | Read conversion rate | Set conversion rate (see details below) |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 读取转换速率 | 设置转换速率（详见下文） |'
- en: '| 6 |  |  |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 6 |  |  |'
- en: '| 7 |  |  |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 7 |  |  |'
- en: '| 8 | Read device mode | Set device mode. 1: one shot; 0: continuous |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 读取设备模式 | 设置设备模式。1：单次触发；0：连续模式 |'
- en: '| 9 | Read PGA setting | Set PGA value |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 读取 PGA 设置 | 设置 PGA 值 |'
- en: '| 10 |  |  |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 10 |  |  |'
- en: '| 11 |  |  |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 11 |  |  |'
- en: '| 12 | Read mux selection | Write mux selection |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 读取多路复用选择 | 写入多路复用选择 |'
- en: '| 13 |  |  |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 13 |  |  |'
- en: '| 14 | Read input control | Set input control. 0: differential; 1: single-ended
    |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 14 | 读取输入控制 | 设置输入控制。0：差分输入；1：单端输入 |'
- en: '| 15 | 0: device is busy doing a conversion; 1: device is ready | Writing a
    1 to this location begins a conversion from power-down mode |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 15 | 0：设备正在进行转换；1：设备已准备好 | 写入 1 到该位置将开始从关机模式进行转换 |'
- en: The following subsections go into more detail concerning these register configuration
    bits.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节将更详细地介绍这些寄存器配置位。
- en: 14.3.2.1 Comparator Control Bits
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.3.2.1 比较器控制位
- en: Bits 0 through 4 in the configuration register control the operation of the
    comparator on the ADS1*x*15\. These control whether the comparator is active,
    and they control the ALRT pin polarity and latch, and the type of comparator.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 配置寄存器中的位 0 到 4 控制 ADS1*x*15 上比较器的操作。这些位控制比较器是否处于激活状态，并控制 ALRT 引脚的极性和闩锁，以及比较器的类型。
- en: Bits 0 and 1 enable and disable the comparator and control the alert logic.
    If these bits are 0b11 (the default state on power-up/reset), then the comparator
    circuitry is disabled. If the comparator control bits are 0b00, 0b01, or 0b10,
    then the comparator will be enabled and assert the ALRT pin when the conversion
    value exceeds the threshold register range for one reading, two readings, or four
    readings, respectively. Increasing the number of readings before asserting ALRT
    helps filter out noise spikes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 位 0 和 1 启用和禁用比较器，并控制警报逻辑。如果这些位为 0b11（上电/复位时的默认状态），则比较器电路被禁用。如果比较器控制位为 0b00、0b01
    或 0b10，则比较器会启用，并在转换值超出阈值寄存器范围时触发 ALRT 引脚，分别对应一次、两次或四次读取。增加触发 ALRT 之前的读取次数有助于过滤掉噪声尖峰。
- en: Bit 2 in the configuration register controls the latching mode on the ALRT pin.
    In the default state (0), the ADS1*x*15 asserts the ALRT pin only while the last
    conversion exceeds the threshold range. Should the conversion value drop back
    below the low threshold range, the IC will deassert the ALRT pin. In the latching
    mode, once a conversion value is outside the threshold range (for the specified
    number of conversions), the ALRT pin is latched in the asserted condition. To
    clear the latch, you have to read the conversion register.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 配置寄存器中的位 2 控制 ALRT 引脚的闩锁模式。在默认状态（0）下，ADS1*x*15 仅在最后一次转换超出阈值范围时触发 ALRT 引脚。如果转换值回落到低于下阈值范围，则
    IC 会取消触发 ALRT 引脚。在闩锁模式下，一旦转换值超出阈值范围（指定次数的转换），ALRT 引脚将被锁存为触发状态。要清除锁存，必须读取转换寄存器。
- en: Bit 3 in the configuration register controls the ALRT pin polarity. A 0 in this
    bit position (default on power-up/reset) sets an active low signal; a 1 in this
    position sets an active high signal.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 配置寄存器中的位 3 控制 ALRT 引脚的极性。该位为 0 时（上电/复位时的默认值）设置为低电平有效信号；该位为 1 时设置为高电平有效信号。
- en: Bit 4 sets the traditional or window (range) comparator mode. In the traditional
    mode, the ADS1*x*15 compares the last conversion value against the high threshold
    register (with hysteresis, deasserting the ALRT pin when the input falls below
    the low threshold value). In the window (range) mode, it compares the last conversion
    value against the low and high threshold registers and generates an ALRT if the
    conversion is outside this range.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 位4设置传统或窗口（范围）比较器模式。在传统模式下，ADS1*x*15将最后一次转换值与高阈值寄存器进行比较（具有滞后效应，当输入低于低阈值时，会解除ALRT引脚的激活）。在窗口（范围）模式下，它将最后一次转换值与低高阈值寄存器进行比较，如果转换超出该范围，则会生成ALRT信号。
- en: In addition to the comparator control bits, you also control the comparator
    using the low and high threshold registers. See the discussion of those registers
    in section 14.3.4, “The Low and High Threshold Registers,” for more details, especially
    concerning the definition of the ALRT pin as an alert or a ready function.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 除了比较器控制位外，您还可以使用低阈值和高阈值寄存器控制比较器。有关这些寄存器的更多细节，尤其是关于如何定义ALRT引脚为警报或就绪功能，请参见14.3.4节，“低阈值和高阈值寄存器”中的讨论。
- en: 14.3.2.2 Device Mode Configuration Bit and Conversion Rate
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.3.2.2 设备模式配置位和转换速率
- en: Bit 8 of the configuration register specifies whether the ADS1*x*15 operates
    in “one-shot” conversion mode (1, the default on power-up/reset) or in continuous
    conversion mode (0). In one-shot mode, the ADC will perform a conversion only
    in response to a command arriving over the I²C bus (writing a 1 to bit 15 of the
    configuration register). In continuous mode, the ADC begins a new conversion when
    the current one completes. Bits 5 through 7 determine the sample frequency. The
    ADS1015 sample frequencies appear in [Table 14-3](#table14-3).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 配置寄存器的第8位指定ADS1*x*15是否在“单次”转换模式（1，默认开机/复位时）或连续转换模式（0）下工作。在单次模式下，ADC仅在接收到通过I²C总线传送的命令时执行转换（向配置寄存器的第15位写入1）。在连续模式下，当当前转换完成时，ADC将开始新的转换。位5至7决定采样频率。ADS1015的采样频率出现在[表
    14-3](#table14-3)中。
- en: 'Table 14-3: ADS1015 Sample Frequencies'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 表 14-3：ADS1015采样频率
- en: '| **Configuration bits 5–7** | **Sample frequency** |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| **配置位5–7** | **采样频率** |'
- en: '| --- | --- |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 000 | 128 sps |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 000 | 128 sps |'
- en: '| 001 | 250 sps |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 001 | 250 sps |'
- en: '| 010 | 490 sps |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 010 | 490 sps |'
- en: '| 011 | 920 sps |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 011 | 920 sps |'
- en: '| 100 | 1600 sps |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 100 | 1600 sps |'
- en: '| 101 | 2400 sps |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 101 | 2400 sps |'
- en: '| 110 | 3300 sps |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 110 | 3300 sps |'
- en: '| 111 | 3300 sps |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 111 | 3300 sps |'
- en: The ADS1115 sample frequencies appear in [Table 14-4](#table14-4). Note that
    the sample frequencies are different for the two ICs.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ADS1115的采样频率出现在[表 14-4](#table14-4)中。请注意，两个IC的采样频率不同。
- en: 'Table 14-4: ADS1115 Sample Frequencies'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 表 14-4：ADS1115采样频率
- en: '| **Configuration bits 5–7** | **Sample frequency** |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| **配置位5–7** | **采样频率** |'
- en: '| --- | --- |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 000 | 8 sps |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 000 | 8 sps |'
- en: '| 001 | 16 sps |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 001 | 16 sps |'
- en: '| 010 | 32 sps |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 010 | 32 sps |'
- en: '| 011 | 64 sps |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 011 | 64 sps |'
- en: '| 100 | 128 sps |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 100 | 128 sps |'
- en: '| 101 | 250 sps |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 101 | 250 sps |'
- en: '| 110 | 475 sps |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 110 | 475 sps |'
- en: '| 111 | 860 sps |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 111 | 860 sps |'
- en: If the ALRT pin is programmed as the “ready” signal, then the ADS1*x*15 will
    pulse the ALRT (or RDY) pin after each conversion when operating in continuous
    mode. When operating in one-shot mode, the ADS1*x*15 will assert the ALRT/RDY
    pin after the conversion is complete if the COMP_POL bit is set to 0\. See section
    14.3.3, “The Low and High Threshold Registers,” later in this chapter for more
    on how to set the ALRT pin to act as the alert or ready signal.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果ALRT引脚被配置为“就绪”信号，则ADS1*x*15在连续模式下每次转换后都会脉冲ALRT（或RDY）引脚。在单次模式下，如果COMP_POL位被设置为0，则ADS1*x*15将在转换完成后激活ALRT/RDY引脚。有关如何设置ALRT引脚作为警报或就绪信号的更多信息，请参见本章后面的14.3.3节，“低阈值和高阈值寄存器”。
- en: 14.3.2.3 Programmable Gain Amplifier Control Bits
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.3.2.3 可编程增益放大器控制位
- en: Bits 9 through 11 in the configuration register specify the gain to apply to
    the incoming analog signal. [Table 14-5](#table14-5) lists the possible gain values
    and voltage ranges.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 配置寄存器的第9至11位指定要应用于输入模拟信号的增益。[表 14-5](#table14-5)列出了可能的增益值和电压范围。
- en: 'Table 14-5: Programmable Gain Amplifier'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 表 14-5：可编程增益放大器
- en: '| **Config settings** | **Gain** | **Input voltage range** |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| **配置设置** | **增益** | **输入电压范围** |'
- en: '| --- | --- | --- |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 000 | 2/3 | ±6.144 V |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 000 | 2/3 | ±6.144 V |'
- en: '| 001 | 1 | ±4.095 V |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 001 | 1 | ±4.095 V |'
- en: '| 010 | 2 | ±2.047 V |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 010 | 2 | ±2.047 V |'
- en: '| 011 | 4 | ±1.023 V |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 011 | 4 | ±1.023 V |'
- en: '| 100 | 8 | ±0.511 V |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 100 | 8 | ±0.511 V |'
- en: '| 101, 110, 111 | 16 | ±0.255 V |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 101, 110, 111 | 16 | ±0.255 V |'
- en: In no case may the voltage ranges in [Table 14-5](#table14-5) exceed Vdd. This
    means that if you select configuration value 0b000, the input voltage is still
    limited to 5 V (assuming Vdd is 5 V) even though the range is 0 V to 6.144 V.
    In this mode, the maximum value you will read from the conversion registers is
    about 26,666 rather than 32,767.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，[表14-5](#table14-5)中的电压范围都不能超过Vdd。这意味着，如果选择配置值0b000，输入电压仍然限制在5 V（假设Vdd为5
    V），即使范围是0 V到6.144 V。在此模式下，从转换寄存器中读取的最大值约为26,666，而不是32,767。
- en: Additionally, voltages on input pins must never drop below 0 V. Negative values
    are valid for differential mode only when the + input is less than the – input;
    both inputs must be positive with respect to Gnd.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，输入引脚上的电压不得低于0 V。负值仅在差分模式下有效，当+输入小于–输入时；两个输入都必须相对于接地为正。
- en: Keep in mind, when you look at [Table 14-5](#table14-5), that the voltage ranges
    are further limited by Vdd, regardless of the PGA setting. For example, if you’re
    running the ADS1*x*15 at 3.3 V and you’ve programmed the PGA with 0b001 (±4.095
    V), the maximum voltage input will still be 3.3 V. This means that the readings
    will be in the range of –26399 to +26399, rather than the usual –32768 to +32767\.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在查看[表14-5](#table14-5)时，电压范围还会受到Vdd的限制，无论PGA的设置如何。例如，如果你以3.3 V运行ADS1*x*15，并且已将PGA编程为0b001（±4.095
    V），则最大电压输入仍然是3.3 V。这意味着读取值将在–26399到+26399的范围内，而不是通常的–32768到+32767。
- en: You’ll most often program the PGA just once (I most commonly use 0b001, for
    the ±4.095-V range). However, if you dynamically modify the PGA during operation—for
    example, to use a different gain setting for each input channel—this may affect
    the operation of the comparator circuitry. All input channels share the same analog-to-digital
    converter circuitry. If you set the comparator threshold(s) for one channel and
    then switch the input multiplexer to a different channel with a different gain,
    the comparator will trip at different voltages for the two channels. The moral
    of the story is that it’s generally best to use the same gain settings for all
    active input channels when working with the comparator circuit.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你最常见的PGA编程通常只进行一次（我最常用的是0b001，±4.095 V范围）。然而，如果你在操作过程中动态修改PGA，例如，为每个输入通道使用不同的增益设置，这可能会影响比较器电路的操作。所有输入通道共享相同的模数转换器电路。如果你为一个通道设置比较器阈值，然后将输入多路复用器切换到具有不同增益的其他通道，比较器将在两个通道上以不同的电压触发。故事的教训是，在使用比较器电路时，最好为所有活动输入通道使用相同的增益设置。
- en: 14.3.2.4 Multiplexer Control Bits
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.3.2.4 多路复用器控制位
- en: Bits 12 through 13 in the configuration register select the input, and bit 14
    controls differential or single-ended mode. If bit 14 is 0 (default on power-up/reset),
    the ADC operates in differential mode. If bit 14 is 1, the ADC operates in single-ended
    mode.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 配置寄存器中的位12和13选择输入，位14控制差分模式或单端模式。如果位14为0（上电/复位时默认值），ADC将在差分模式下工作。如果位14为1，ADC将在单端模式下工作。
- en: Bits 12 through 13 select an appropriate input, or pair of inputs, as shown
    in [Table 14-6](#table14-6).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 位12到位13选择一个合适的输入，或者一对输入，如[表14-6](#table14-6)所示。
- en: 'Table 14-6: Input Multiplexer Selection'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 表14-6：输入多路复用器选择
- en: '| **Configuration** **bits 12 and 13** | **If bit 14 is 0 (differential mode)**
    | **If bit 14 is 1 (single-ended mode)** |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| **配置** **位12和13** | **如果位14为0（差分模式）** | **如果位14为1（单端模式）** |'
- en: '| --- | --- | --- |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '|  | **+ Terminal** | **– Terminal** | **+ Terminal (– terminal is Gnd)** |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '|  | **+ 端子** | **– 端子** | **+ 端子（–端子为接地）** |'
- en: '| 00 | A0 | A1 | A0 |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 00 | A0 | A1 | A0 |'
- en: '| 01 | A0 | A3 | A1 |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 01 | A0 | A3 | A1 |'
- en: '| 10 | A1 | A3 | A2 |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 10 | A1 | A3 | A2 |'
- en: '| 11 | A2 | A3 | A3 |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 11 | A2 | A3 | A3 |'
- en: The peculiar 0b01 and 0b10 settings in differential mode allow you to use up
    to three differential inputs, if the three inputs (A0, A1, and A2) all share the
    same – terminal. This usually isn’t the case, so differential inputs typically
    use 0b00 or 0b11 for bits 12 and 13\. In single-ended mode (bit 14 = 1), bits
    12 and 13 select one of the four single-ended input channels.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在差分模式下，特殊的0b01和0b10设置允许你使用最多三个差分输入，前提是这三个输入（A0、A1和A2）共享相同的–端。这种情况通常不会发生，因此差分输入通常会使用0b00或0b11作为位12和13的值。在单端模式下（位14=1），位12和13选择四个单端输入通道中的一个。
- en: 14.3.2.5 Operational Status Bit
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.3.2.5 操作状态位
- en: When reading the configuration register, bits 0 through 14 reflect the last
    values written to those bits. Bit 15, however, performs different duties on read
    and write operations.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取配置寄存器时，位0到位14反映的是最后写入这些位的值。然而，位15在读取和写入操作时有不同的功能。
- en: Reading the configuration returns the current *ready* status in bit 15\. If
    this bit returns 1, the ADS1*x*15 is not currently performing a conversion, so
    you can begin a new conversion. If bit 15 returns 0, the ADS1*x*15 is in the middle
    of a conversion, and you cannot begin another. Once you begin a conversion in
    one-shot mode, you can test this bit to determine when that conversion is complete.
    In continuous mode, you don’t really care, as the conversion register contains
    the value of the last conversion made.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 读取配置寄存器会返回位15的当前*准备就绪*状态。如果该位返回1，表示ADS1*x*15当前没有进行转换，因此可以开始新的转换。如果位15返回0，表示ADS1*x*15正在进行转换，此时无法开始新的转换。一旦你在单次转换模式下开始了转换，可以通过测试此位来确定转换何时完成。在连续模式下，你不需要关心这一点，因为转换寄存器中保存的是最后一次转换的值。
- en: To begin a conversion in one-shot mode, write a 1 to bit 15 in the conversion
    register. Keep in mind that you must also rewrite the other 15 configuration bits
    when writing to the configuration register. You typically set up a 16-bit value
    that defines how you want the conversion to proceed and set bit 15 equal to 1
    (to begin the conversion). To write to the configuration register without beginning
    a new conversion, just put a 0 in bit 15.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要在单次转换模式下开始转换，请将1写入转换寄存器的位15。请记住，写入配置寄存器时，还必须重新写入其他15个位的配置。你通常会设置一个16位值来定义转换的进行方式，并将位15设置为1（以开始转换）。如果不希望开始新的转换，只需将位15设置为0。
- en: Note that you can write a 1 to bit 15 only when operating in one-shot mode,
    which is also known as *power-down* mode. If the ADS1*x*15 is currently operating
    in continuous mode, you must first put it in one-shot mode by writing a 1 to bit
    8\. You can then programmatically start new conversions by writing a 1 to bit
    15.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，只有在单次转换模式下，才能将位15设置为1，这种模式也被称为*关机*模式。如果ADS1*x*15当前在连续模式下工作，必须先通过将位8写入1将其切换到单次转换模式。然后，你可以通过将位15写入1来编程启动新的转换。
- en: 14.3.3 The Low and High Threshold Registers
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.3 低阈值和高阈值寄存器
- en: The ADS1*x*15 devices provide two 16-bit threshold registers, low (pointer register
    value is 0b10) and high (0b11). The ADS1115 allows you to write the full 16 bits
    to these registers. As the ADS1015 ADCs are 12-bit devices, you should always
    write 0s into the LO 4 bits of these registers.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ADS1*x*15设备提供两个16位的阈值寄存器，低阈值（指针寄存器值为0b10）和高阈值（0b11）。ADS1115允许你将完整的16位写入这些寄存器。由于ADS1015
    ADC是12位设备，因此你应始终将这些寄存器的低4个位写为0。
- en: When operating as a traditional comparator, the ADS1*x*15 compares the conversion
    register against the value in the high threshold register and asserts the ALRT
    pin if the conversion value is greater than the high threshold. The ADS1*x*15
    uses the low threshold register to determine when to deassert the ALRT signal.
    When the input conversion value falls below the value in the low threshold, the
    ADS1*x*15 deasserts ALRT.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当作为传统的比较器工作时，ADS1*x*15会将转换寄存器的值与高阈值寄存器中的值进行比较，如果转换值大于高阈值，它会激活ALRT引脚。ADS1*x*15使用低阈值寄存器来确定何时去激活ALRT信号。当输入转换值低于低阈值的值时，ADS1*x*15会去激活ALRT。
- en: In window comparator mode (range mode), the ADS1*x*15 asserts the ALRT pin whenever
    the conversion value is below the low threshold register value or above the high
    threshold value. If you want to assert the pin while the conversion value is between
    the two thresholds, you can simply invert the ALRT pin using bit 3 of the configuration
    register.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口比较器模式（范围模式）下，ADS1*x*15会在转换值低于低阈值寄存器值或高于高阈值值时激活ALRT引脚。如果你希望在转换值介于两个阈值之间时激活该引脚，可以简单地使用配置寄存器的位3反转ALRT引脚。
- en: In nonlatching mode (see section 14.3.2.1, “Comparator Control Bits,” earlier
    in this chapter), the ADS1*x*15 will automatically assert and deassert the ALRT
    pin as the conversion value goes in and out of range. In latching mode, once the
    IC asserts the ALRT pin, that pin stays active until the software reads the conversion
    register—that is, assuming the conversion value is back within range at that point.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在非锁存模式（见本章前面部分14.3.2.1节，“比较器控制位”）下，ADS1*x*15会根据转换值是否超出范围自动激活和去激活ALRT引脚。在锁存模式下，一旦IC激活ALRT引脚，该引脚会保持激活状态，直到软件读取转换寄存器——也就是说，假设此时转换值已经回到范围内。
- en: 'The threshold registers provide one additional hidden feature: control of the
    ALRT pin. If the HO bit of the high threshold register is 1 and the HO bit of
    the low threshold register is 0, then the ADS1*x*15 outputs the ready condition
    (configuration register bit 15) on the ALRT pin (which should be called RDY in
    this configuration). Because the values in the threshold registers are two’s complement
    signed binary integers, this particular situation means that the value in the
    high threshold register is less than the value in the low threshold register.
    This is usually an illegal combination; except for this special case, the value
    in the high threshold must always be greater than the value in the low threshold
    register.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 阈值寄存器提供了一个额外的隐藏功能：控制 ALRT 引脚。如果高阈值寄存器的 HO 位为 1 且低阈值寄存器的 HO 位为 0，则 ADS1*x*15
    会在 ALRT 引脚上输出就绪状态（配置寄存器的第 15 位）（在此配置中应称其为 RDY）。由于阈值寄存器中的值是二进制补码有符号整数，这种特定情况意味着高阈值寄存器中的值小于低阈值寄存器中的值。这通常是一个非法组合；除这种特殊情况外，高阈值的值必须始终大于低阈值寄存器中的值。
- en: This concludes the discussion of the internal architecture of the ADS1*x*15
    IC. To program it, however, you’ll need some actual hardware you can wire into
    a circuit containing a controlling CPU. Because of their size, you wouldn’t normally
    try to hook an ADS1*x*15 directly onto a breadboard. The next section describes
    the solution to this problem.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分讨论了 ADS1*x*15 集成电路的内部架构。然而，要对其进行编程，你需要一些实际的硬件，可以将其接入包含控制 CPU 的电路中。由于其体积较小，通常不会直接将
    ADS1*x*15 接到面包板上。下一部分将介绍解决此问题的方法。
- en: 14.4 The Adafruit ADS1*x*15 Breakout Boards
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.4 Adafruit ADS1*x*15 分 breakout 板
- en: The ADS1*x*15 ICs are tiny SMDs that are difficult for all but the most experienced
    of electronic technicians or circuit assembly houses to use. Adafruit solves this
    issue by putting the IC on a small PCB, a “breakout board” with a set of 0.1-inch
    headers that make it easy to use this IC as part of some other circuit.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ADS1*x*15 IC 是微型表面贴装器件，除了最有经验的电子技术员或电路组装公司，几乎没有人能够使用。Adafruit 通过将 IC 放置在一个小型
    PCB 上，即一个带有 0.1 英寸引脚头的“分 breakout 板”，解决了这一问题，使得将该 IC 作为其他电路的一部分变得更加容易。
- en: '[Figure 14-5](#figure14-5) shows the Adafruit ADS1115 breakout board. For what
    it’s worth, the ADS1015 board is identical to the ADS1115 board, except for the
    silkscreen and the actual IC placed on the board.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-5](#figure14-5) 显示了 Adafruit ADS1115 分 breakout 板。值得一提的是，ADS1015 板与 ADS1115
    板完全相同，唯一的区别是丝印和板上实际放置的 IC。'
- en: The ADS1015 and ADS1115 have identical pinouts consisting of 10 holes into which
    you’d normally solder a 1×10 pin header, as described in [Table 14-7](#table14-7).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ADS1015 和 ADS1115 具有相同的引脚布局，包括 10 个孔，通常在这些孔中焊接一个 1×10 的引脚头，如[表 14-7](#table14-7)所描述。
- en: '![](image_fi/502468c14/f14005.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c14/f14005.png)'
- en: 'Figure 14-5: The Adafruit ADS1115 breakout board'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-5：Adafruit ADS1115 分 breakout 板
- en: 'Table 14-7: Adafruit ADS1*x*15 Pinout'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 表 14-7：Adafruit ADS1*x*15 引脚布局
- en: '| **Pin (name)** | **Function** |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| **引脚（名称）** | **功能** |'
- en: '| --- | --- |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Vdd | Power supply (2 V to 5 V) |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| Vdd | 电源 (2 V 至 5 V) |'
- en: '| Gnd | Digital and analog ground |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| Gnd | 数字和模拟接地 |'
- en: '| SCL | I²C clock line |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| SCL | I²C 时钟线 |'
- en: '| SDA | I²C data line |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| SDA | I²C 数据线 |'
- en: '| ADDR | Address selection line |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| ADDR | 地址选择线 |'
- en: '| ALRT | Alert (comparator out of range) or conversion complete |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| ALRT | 警报（比较器超出范围）或转换完成 |'
- en: '| A0 | Analog input channel 0 (+ differential input 0) |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| A0 | 模拟输入通道 0 (+ 差分输入 0) |'
- en: '| A1 | Analog input channel 1 (– differential input 0) |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| A1 | 模拟输入通道 1 (– 差分输入 0) |'
- en: '| A2 | Analog input channel 2 (+ differential input 1) |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| A2 | 模拟输入通道 2 (+ 差分输入 1) |'
- en: '| A3 | Analog input channel 3 (– differential input 1) |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| A3 | 模拟输入通道 3 (– 差分输入 1) |'
- en: The Vdd, Gnd, SCL, and SDA pins have the usual connections. However, remember
    that although the power supply can be in the range of 2 V to 5 V, the analog input
    pins must never exceed Vdd. If you power the ADS1*x*15 from 3.3 V, the analog
    inputs are limited to 3.3 V.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Vdd、Gnd、SCL 和 SDA 引脚具有常见连接。然而，请记住，尽管电源可以在 2 V 到 5 V 范围内，模拟输入引脚的电压永远不能超过 Vdd。如果你使用
    3.3 V 为 ADS1*x*15 提供电源，模拟输入将被限制在 3.3 V 以内。
- en: The Adafruit ADS1*x*15 breakout boards include 10-kΩ pullup resistors on the
    SCL and SDA lines (to Vdd). While it’s convenient to not have to add the pullups
    yourself, if you connect a large number of such devices (with their own pullups)
    to the same I²C bus, the parallel resistance might be an issue. You’ll have to
    desolder the SMD chip resistors from the breakout board if this is the case.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Adafruit ADS1*x*15 分 breakout 板在 SCL 和 SDA 线路上包括了 10-kΩ 的上拉电阻（连接到 Vdd）。虽然不需要自己添加上拉电阻很方便，但如果将大量此类设备（带有自己上拉电阻）连接到同一个
    I²C 总线，串联电阻可能会成为问题。如果是这种情况，你需要将 SMD 芯片电阻从 breakout 板上拆除。
- en: The ADDR pin is an input that the ADS1*x*15 uses to select one of four different
    I²C addresses. Connecting ADDR to Gnd, Vdd, SDA, or SCL specifies the I²C address
    as shown in [Table 14-8](#table14-8)—a particularly clever way to get four separate
    addresses from a single address pin.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ADDR 引脚是一个输入引脚，ADS1*x*15 使用它来选择四个不同的 I²C 地址之一。将 ADDR 连接到 Gnd、Vdd、SDA 或 SCL 可根据
    [表 14-8](#table14-8) 中所示的方式指定 I²C 地址——这是一种特别巧妙的方式，通过单个地址引脚获得四个独立的地址。
- en: 'Table 14-8: Address Selection on ADS1*x*15'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 表 14-8：ADS1*x*15 地址选择
- en: '| **ADDR connected to** | **I²C address** |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| **ADDR 连接到** | **I²C 地址** |'
- en: '| --- | --- |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Gnd | 0x48 |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| Gnd | 0x48 |'
- en: '| Vdd | 0x49 |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| Vdd | 0x49 |'
- en: '| SDA | 0x4A |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| SDA | 0x4A |'
- en: '| SCL | 0x4B |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| SCL | 0x4B |'
- en: 'Now refer back to [Table 14-7](#table14-7); the ALRT pin serves two purposes
    on the ADS1*x*15: when used with the built-in comparator, it can signal when a
    conversion is out of some programmable range. This pin can also be used to indicate
    that a conversion is complete—for example, to generate an interrupt, so the CPU
    doesn’t have to constantly poll the device to see when the conversion is done.
    The ALRT pin is an open-drain output pin. The Adafruit ADS1*x*15 breakout boards
    automatically include a pullup resistor on this line so you can treat the ALRT
    pin as a standard logic output.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在返回查看 [表 14-7](#table14-7)；ALRT 引脚在 ADS1*x*15 上有两个用途：当与内置比较器一起使用时，它可以在转换结果超出某个可编程范围时发出信号。这个引脚还可以用来指示转换完成——例如，生成一个中断，这样
    CPU 就不必不断轮询设备来查看转换是否完成。ALRT 引脚是一个开漏输出引脚。Adafruit ADS1*x*15 breakout 板自动在此线路上包含一个上拉电阻，因此你可以将
    ALRT 引脚视为标准逻辑输出。
- en: The A0, A1, A2, and A3 are the single-ended input pins (the other signal connection
    goes to Gnd). In differential mode 0b000 (configuration register bits 12 through
    14 are 0b000), pins A0 and A1 correspond to channel zero + and – inputs, respectively,
    and pins A2 and A3 correspond to channel 1 + and – inputs. In differential modes
    0b001, 0b010, and 0b011 (bits 12 through 14 in the configuration register), there
    are three differential inputs using pins (A0, A3), (A1, A3), and (A2, A3), with
    A3 being the common (–) differential signal.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: A0、A1、A2 和 A3 是单端输入引脚（另一个信号连接到 Gnd）。在差分模式 0b000（配置寄存器位 12 到 14 为 0b000）下，A0
    和 A1 分别对应通道零的正输入和负输入，而 A2 和 A3 分别对应通道 1 的正输入和负输入。在差分模式 0b001、0b010 和 0b011（配置寄存器位
    12 到 14）下，使用（A0，A3）、（A1，A3）和（A2，A3）作为三组差分输入，其中 A3 为公共（–）差分信号。
- en: 14.5 An ADS1*x*15 Programming Example
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.5 ADS1*x*15 编程示例
- en: Basic ADS1*x*15 programming consists of writing an appropriate configuration
    value to the configuration register (including a “start conversion” bit in one-shot
    mode), waiting for the conversion to complete, and then reading the converted
    value from the conversion register. In a typical system, that’s all there is to
    using the ADS1*x*15\.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的 ADS1*x*15 编程包括将适当的配置值写入配置寄存器（包括在单次模式中“启动转换”位），等待转换完成，然后从转换寄存器中读取转换后的值。在典型的系统中，这就是使用
    ADS1*x*15 的全部内容。
- en: As a test, hook up an Adafruit ADS1115 breakout board to an Arduino, as shown
    in [Figure 14-6](#figure14-6). You can also use an ADS1015 if you prefer; the
    code works with either device, and I provide sample output for both devices later
    in this section. Note that the ADDR line is wired to Gnd; this sets the I²C address
    to 0x48\. Vdd is wired to +5 V on the Arduino. The sample program in this section
    will read only the A0 input, so connect an appropriate voltage source to the A0
    pin (0 V to 4.095 V). For quick tests, I just connected A0 to ground and the 3.3-V
    supply.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 作为测试，将 Adafruit ADS1115 breakout 板连接到 Arduino，如 [图 14-6](#figure14-6) 所示。你也可以使用
    ADS1015，如果你更喜欢的话；该代码可以与这两种设备兼容，并且我将在本节后面提供两种设备的示例输出。请注意，ADDR 线已连接到 Gnd；这将 I²C
    地址设置为 0x48。Vdd 连接到 Arduino 的 +5V。该示例程序将仅读取 A0 输入，因此请将适当的电压源连接到 A0 引脚（0 V 至 4.095
    V）。为了快速测试，我只是将 A0 连接到地和 3.3V 电源。
- en: '![](image_fi/502468c14/f14006.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c14/f14006.png)'
- en: 'Figure 14-6: Hooking up an ADS1115 breakout board to an Arduino'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-6：将ADS1115扩展板连接到Arduino
- en: The program in [Listing 14-1](#listing14-1) demonstrates reading input channel
    A0 and displaying the result in the Arduino serial monitor window.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表14-1](#listing14-1)中的程序演示了读取输入通道A0并在Arduino串口监视器窗口中显示结果。'
- en: '[PRE0]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For testing purposes, the simplest code will set up the configuration register
    as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试目的，最简单的代码将配置寄存器设置如下：
- en: Program bits 0 to 4 with 0b00011 (disable the comparator) ❼
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序将第0至4位设置为0b00011（禁用比较器）❼
- en: Program bits 5 to 7 with 0b111 (860 sps, though this value is irrelevant) ❻
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序将第5至7位设置为0b111（860 sps，尽管这个值无关紧要）❻
- en: Program bit 8 with 1 (one-shot mode) ❺
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序将第8位设置为1（单次模式）❺
- en: Program bits 9 to 11 with 0b001 (PGA = 4.095 V range) ❹
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序将第9至11位设置为0b001（PGA = 4.095 V范围）❹
- en: Program bits 12 to 14 with 0b100 (single-ended, select A0) ❸
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序将第12至14位设置为0b100（单端模式，选择A0）❸
- en: Program bit 15 with 1 (start conversion) ❷
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序将第15位设置为1（开始转换）❷
- en: After writing this value (0xC3E3) to the configuration register ❽, the ADS1115
    will begin converting the voltage appearing on A0 to digital form. The software
    must wait around 1.2 msec for this conversion to complete before it reads the
    result from the conversion register. Of course, a software delay of 1.2 msec is
    completely inappropriate; the right way to wait for the conversion to complete
    is to test bit 15 of the configuration register (the operational status bit) until
    it is 1 (❶ and ❾).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 将此值（0xC3E3）写入配置寄存器❽后，ADS1115将开始将A0上的电压转换为数字形式。软件必须等待大约1.2毫秒，直到此转换完成，然后从转换寄存器中读取结果。当然，1.2毫秒的延迟完全不合适；等待转换完成的正确方法是测试配置寄存器的第15位（操作状态位），直到它变为1（❶和❾）。
- en: 'When executing the code in [Listing 14-1](#listing14-1), connecting the A0
    line to ground should produce output like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 执行[列表14-1](#listing14-1)中的代码时，将A0线连接到地应该产生如下输出：
- en: '[PRE1]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can see the tiny amount of noise present during 16-bit conversions (remember,
    each integer unit represents 0.0000625 V). This particular sequence is very clean
    indeed, ranging from –2 to +3—a variance of only about 0.00003 V, an artifact
    of connecting A0 directly to a power supply pin.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到在16位转换过程中存在的微小噪声（记住，每个整数单位代表0.0000625 V）。这个特定的序列确实非常干净，范围从–2到+3，方差只有大约0.00003
    V，这是因为A0直接连接到电源引脚所造成的伪影。
- en: 'This software also works fine with an Adafruit ADS1015 12-bit ADC breakout
    board. Here’s some output from that board:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个软件在Adafruit ADS1015 12位ADC扩展板上也能正常工作。下面是该板的一些输出：
- en: '[PRE2]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Although the error looks much greater than with the ADS1*x*15, it’s actually
    better. Remember from “The Conversion Register” earlier in this chapter that the
    LO 4 bits of the conversion register are always 0 and the 12-bit conversion appears
    in bits 4 through 15, so what you’re seeing in the previous output is an occasional
    1-bit error. This is one advantage to using a 12-bit rather than a 16-bit ADC:
    less noise.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管错误看起来比ADS1*x*15大得多，但实际上是更好的。回想本章前面提到的“转换寄存器”，转换寄存器的低4位始终为0，而12位的转换结果出现在第4至第15位，所以你在前面的输出中看到的只是偶尔出现的1位错误。这是使用12位而非16位ADC的一个优势：噪声更小。
- en: 14.6 Improving Polling Performance
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.6 提升轮询性能
- en: 'The program in [Listing 14-1](#listing14-1) polled bit 15 of the configuration
    register until it became 1, indicating the conversion was complete and the ADS1*x*15
    was ready to do another conversion. This might not seem like a big deal, but keep
    in mind that reading the configuration register requires five I²C bus transactions:
    two to set the pointer register value and three to read the actual conversion
    register. At 100 kHz, this could take longer than 500 µsec—almost half the time
    of the conversion!'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表14-1](#listing14-1)中的程序轮询配置寄存器的第15位，直到它变为1，表示转换完成，ADS1*x*15已经准备好进行另一次转换。这看起来可能不算什么大事，但请记住，读取配置寄存器需要五次I²C总线事务：两次设置指针寄存器的值，三次读取实际的转换寄存器。在100
    kHz的速率下，这可能需要超过500 µsec——几乎是转换时间的一半！'
- en: 'Of course, you could reduce time lost to polling by running the ADS1*x*15 at
    a higher clock frequency, but not all SBCs or CPUs support this; some, as you’ve
    seen in this book, don’t even run at a full 100 kHz. Fortunately, if you have
    a spare input pin on your SBC, there is a much faster solution: program the ALRT
    pin as a RDY pin and test for conversion complete by reading that pin.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以通过提高ADS1*x*15的时钟频率来减少轮询带来的时间损失，但并非所有单板计算机（SBC）或CPU都支持这一点；正如你在本书中看到的，有些甚至无法达到完整的100
    kHz频率。幸运的是，如果你的SBC有空余的输入引脚，就有一个更快的解决方案：将ALRT引脚编程为RDY引脚，并通过读取该引脚来测试转换是否完成。
- en: To program the ALRT pin as RDY, write a 0 to bit 15 of the low threshold register
    and a 1 to bit 15 of the high threshold register, turn off comparator latching
    (write a 0 to bit 2 of the configuration register), set the ALRT polarity to 0
    (bit 3 of the configuration register), and enable the comparator. This enables
    reading the RDY status on the ALRT pin. You may have noticed that the ALRT pin
    in [Figure 14-6](#figure14-6) is wired to the D2 digital I/O pin on the Arduino.
    The program in [Listing 14-1](#listing14-1) ignored pin D2, but the program in
    [Listing 14-2](#listing14-2) will use this connection to test for when the conversion
    is complete.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要将ALRT引脚编程为RDY，引脚设置方法是：将低阈值寄存器的第15位写为0，高阈值寄存器的第15位写为1，关闭比较器锁存（将配置寄存器的第2位写为0），将ALRT极性设置为0（配置寄存器的第3位），并启用比较器。这将允许在ALRT引脚上读取RDY状态。你可能注意到，[图14-6](#figure14-6)中的ALRT引脚已经接入了Arduino的D2数字I/O引脚。[列表14-1](#listing14-1)中的程序忽略了D2引脚，而[列表14-2](#listing14-2)中的程序将使用这个连接来测试转换何时完成。
- en: 'The program in [Listing 14-2](#listing14-2) is just a minor modification of
    the program in [Listing 14-1](#listing14-1). As such, I won’t reprint the repeated
    portions of [Listing 14-1](#listing14-1) but will simply highlight the parts of
    the code that are new. I begin with the usual `#define` statements at the beginning
    of the file:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表14-2](#listing14-2)中的程序仅是对[列表14-1](#listing14-1)中程序的一个小修改。因此，我不会重新打印[列表14-1](#listing14-1)中的重复部分，而是仅突出显示代码中新加入的部分。我从文件开头的常规`#define`语句开始：'
- en: '[PRE3]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The main addition to this section is the definition of the `rdy` pin ❶.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分的主要新增内容是对`rdy`引脚的定义 ❶。
- en: 'Next, I turn to the `wait4Ready()` function, rewritten from the code in [Listing
    14-1](#listing14-1):'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我转向`wait4Ready()`函数，它是从[列表14-1](#listing14-1)中的代码重写的：
- en: '[PRE4]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This `wait4Ready()` function reads the ready status from digital input pin D2
    ❷ rather than reading the configuration register (which is slow) and testing bit
    15 of that register.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`wait4Ready()`函数从数字输入引脚D2 ❷读取就绪状态，而不是读取配置寄存器（那样会比较慢）并测试该寄存器的第15位。
- en: 'We next turn to the `setup()` function:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们转向`setup()`函数：
- en: '[PRE5]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `setup()` function needs to initialize the threshold registers so that the
    low threshold register has a 0 in its HO bit ❸ and the high threshold register
    has a 1 in its HO bit ❹. This code also activates the comparator circuit so it
    can pass the ready status on to the ALRT pin on the ADS1*x*15.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup()`函数需要初始化阈值寄存器，使得低阈值寄存器的HO位 ❸为0，高阈值寄存器的HO位 ❹为1。此代码还会激活比较器电路，以便将就绪状态传递到ADS1*x*15上的ALRT引脚。'
- en: 'The final change is to the code that writes to the configuration in the main
    loop:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的更改是写入配置的代码部分，位于主循环中：
- en: '[PRE6]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: While the code in [Listing 14-1](#listing14-1) disables the comparator on each
    pass of the loop, the code in [Listing 14-2](#listing14-2) needs to keep the comparator
    enabled ❺.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然[列表14-1](#listing14-1)中的代码在每次循环时都会禁用比较器，但[列表14-2](#listing14-2)中的代码需要保持比较器开启
    ❺。
- en: These changes to [Listing 14-1](#listing14-1) produce noticeably faster output.
    [Figure 14-7](#figure14-7) shows the output on the ALRT pin (input to the digital
    I/O D2 pin). When this signal is high, the ADC is busy doing a conversion. When
    it is low, the ADC is ready to do another conversion. As [Figure 14-7](#figure14-7)
    shows, the conversions take slightly more than 1 msec when using a Teensy 3.2
    (remember, the ADS1115, on which this was measured, is capable of about 860 sps).
    The low portion of the oscilloscope trace is the time spent sending the conversion
    command to the ADS1115 plus outputting data to the Arduino Serial terminal.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 对[列表14-1](#listing14-1)所做的这些更改显著提高了输出速度。[图14-7](#figure14-7)显示了ALRT引脚（输入到数字I/O
    D2引脚）的输出。当该信号为高时，ADC正在忙于转换。当信号为低时，ADC准备好进行下一次转换。如[图14-7](#figure14-7)所示，在使用Teensy
    3.2时，转换时间略长于1毫秒（记住，ADS1115在此测量中，大约能够实现860采样每秒）。示波器追踪的低部分是发送转换命令到ADS1115以及向Arduino串口终端输出数据所花费的时间。
- en: '![](image_fi/502468c14/f14007.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c14/f14007.png)'
- en: 'Figure 14-7: Oscilloscope output from [Listing 14-2](#listing14-2)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-7：来自[列表 14-2](#listing14-2)的示波器输出
- en: Remember that I ran the code that produced the output in [Figure 14-7](#figure14-7)
    on a 96-MHz Teensy 3.2, not a 16-MHz Arduino Uno Rev3\. On an Arduino, the bottom
    portion of the cycle might be a bit wider.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我是在96 MHz的Teensy 3.2上运行了生成[图14-7](#figure14-7)中输出的代码，而不是16 MHz的Arduino Uno
    Rev3。在Arduino上，周期的底部部分可能稍微宽一些。
- en: Using the RDY pin is not the only way to improve A/D conversion performance.
    The next section looks at another way to speed up the sampling rate.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RDY引脚并不是唯一提高A/D转换性能的方法。下一节将介绍另一种加速采样率的方法。
- en: 14.7 Improving Performance Using Continuous Scanning
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.7 使用连续扫描提高性能
- en: 'In [Figure 14-7](#figure14-7), just a little more than half the execution time
    is spent doing an analog-to-digital conversion (that is, when the ALRT [RDY] pin
    is high). Between conversions, there are three activities going on in the main
    Arduino `loop` function: writing to the configuration register to start the conversion,
    reading the conversion value from the ADS1115, and printing the results to the
    Arduino Serial terminal. Writing the results to the Serial terminal is not a blazing
    fast process, but writing the configuration register and reading the conversion
    register require nine I²C bus transactions—probably around 900 µsec on a 100-kHz
    bus.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图14-7](#figure14-7)中，执行时间的一半多一点被花费在进行模拟到数字转换（即，当ALRT [RDY]引脚为高电平时）。在两次转换之间，主Arduino
    `loop`函数中有三项活动：写入配置寄存器以启动转换、从ADS1115读取转换值，以及将结果打印到Arduino串口终端。将结果写入串口终端不是一个特别快的过程，但写入配置寄存器和读取转换寄存器需要进行九次I²C总线事务——大约在100
    kHz总线上需要900 µsec。
- en: Nothing can be done to improve the performance of reading the conversion register—that’s
    the only way to get data out of the ADS1115\. However, you can save the expense
    of writing the configuration register on each loop (around 400 µsec) by putting
    the ADS1115 in continuous conversion mode. In this mode, the CPU can request the
    data from the ADS1115 whenever it wants, without having to check if a conversion
    is complete; the ADS1115 will always return the value of the last conversion and
    will automatically update that value as each new conversion takes place. [Listing
    14-3](#listing14-3) provides the code that puts the ADS1115 in continuous conversion
    mode. Again, I won’t reprint any code shared with the previous two listings.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 对读取转换寄存器的性能无法进行任何改进——这是从ADS1115获取数据的唯一方法。然而，你可以通过将ADS1115置于连续转换模式，节省每次循环中写入配置寄存器的开销（大约400
    µsec）。在这种模式下，CPU可以随时请求来自ADS1115的数据，而无需检查转换是否完成；ADS1115会始终返回上一次转换的值，并会在每次新的转换发生时自动更新该值。[列表
    14-3](#listing14-3)提供了将ADS1115置于连续转换模式的代码。再次声明，我不会重新打印任何与前两个列表共享的代码。
- en: '[PRE7]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `wait4Conversion()` function in [Listing 14-3](#listing14-3) replaces `wait4Ready()`
    in the previous two listings. This function waits until the RDY line (digital
    input D2) goes low ❶, indicating that a conversion has just completed. The ADS1115
    will pulse RDY low for slightly less than 10 µsec and then automatically set it
    high again. This is plenty long enough for the Arduino (or Teensy, in my case)
    to detect that the conversion has completed. However, the code also has to wait
    for this line to go back high ❷ so that the `loop` function won’t repeat while
    the signal is still low and think another conversion has completed.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 14-3](#listing14-3)中的`wait4Conversion()`函数替代了前两个列表中的`wait4Ready()`函数。该函数会等待直到RDY线（数字输入D2）变低❶，表示转换已完成。ADS1115会将RDY线拉低约10
    µsec，之后会自动恢复为高电平。这段时间足够Arduino（或者像我使用的Teensy）检测到转换已完成。然而，代码还需要等待该线路恢复为高电平❷，以确保`loop`函数不会在信号仍然为低电平时重复执行，从而误认为另一次转换已完成。'
- en: '[PRE8]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The only real modification to the setup function from the previous examples
    is that it programs bit 8 of the configuration register with 0 ❸, putting the
    device in continuous conversion mode:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前示例中设置函数的唯一实质性修改是它将配置寄存器的第8位编程为0❸，使设备进入连续转换模式：
- en: '[PRE9]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the `loop()` function, the code to write the configuration register is gone.
    Because the ADS1115 is operating in continuous mode, there is no longer a need
    to start a new conversion by writing to the configuration register. The `wait4Conversion()`
    function ❹ is very fast (it’s all digital I/O with no I²C transactions). This
    leaves only reading the conversion register to slow down the main loop.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在`loop()`函数中，写入配置寄存器的代码已经消失。由于ADS1115处于连续模式，因此不再需要通过写入配置寄存器来启动新的转换。`wait4Conversion()`函数❹非常快速（因为它只涉及数字I/O，没有I²C事务）。这使得唯一会减慢主循环的操作就是读取转换寄存器。
- en: '[Figure 14-8](#figure14-8) shows the oscilloscope output for the program in
    [Listing 14-3](#listing14-3). The first thing to note is that the time scale is
    one half that of the previous figure’s (500 µsec instead of 1 msec). The period
    for each pulse is just a little more than 1.2 msec (versus about 2 msec in [Figure
    14-7](#figure14-7)), meaning this code runs almost twice as fast as the code in
    the previous listings.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-8](#figure14-8)显示了程序在[列表14-3](#listing14-3)中的示波器输出。首先要注意的是，时间刻度是前一个图表的一半（500
    µsec而不是1 msec）。每个脉冲的周期略大于1.2 msec（而在[图14-7](#figure14-7)中约为2 msec），意味着这段代码运行速度几乎是之前列表中代码的两倍。'
- en: '![](image_fi/502468c14/f14008.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c14/f14008.png)'
- en: 'Figure 14-8: Oscilloscope output for [Listing 14-3](#listing14-3)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-8：示波器输出 [列表14-3](#listing14-3)
- en: The only drawback to using the continuous mode to speed up the application is
    that you can read from only one ADC channel (ignoring the power-saving aspects
    of one-shot/power-down mode). To change multiplexer channels, you have to write
    to the configuration register, which eats up all the time saved by removing that
    call in the first place.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 使用连续模式加速应用程序的唯一缺点是只能从一个ADC通道读取数据（忽略了单次/关机模式的省电特性）。要更改多路复用器通道，必须写入配置寄存器，这会消耗掉最初通过去掉此调用所节省的所有时间。
- en: 14.8 Interrupts and the ADS1*x*15
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.8 中断与ADS1*x*15
- en: In theory, it’s possible to connect the ALRT (RDY) pin to an interrupt input
    on the Arduino—D2 is an interrupt pin on the Arduino Uno Rev3, for example. Whenever
    an interrupt occurs (due to a conversion complete or a comparison out-of-range
    signal), the interrupt service routine can read the data or process the comparison
    fault and pass that information along to the main program.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，ALRT（RDY）引脚可以连接到Arduino的中断输入—例如，D2是Arduino Uno Rev3上的一个中断引脚。每当发生中断（由于转换完成或比较超出范围信号），中断服务程序可以读取数据或处理比较故障，并将这些信息传递给主程序。
- en: In practice, however, using interrupts in Arduino code is dubious at best. I²C
    communications, which would have to take place inside the ISR, are extremely slow,
    and ISRs need to be really fast. Maybe it would work with a high-speed–mode I²C
    clock; you’d have to test that and see.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，实际上，在Arduino代码中使用中断充其量是值得怀疑的。I²C通信必须在ISR中进行，这非常慢，而中断服务程序需要非常快。也许在高速度模式下的I²C时钟会有效，你得测试一下看看。
- en: On the other hand, if you are using a multithreaded RTOS with good interrupt
    support (that is, with an interrupt-driven I²C library), interrupts become very
    practical. The ISR would simply signal a thread when a conversion is complete,
    and that thread could talk to the ADS1115, blocking while I²C transmissions (and
    conversion) are taking place. This would consume little CPU time compared to polling
    and would allow other threads to run with little performance loss.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你使用的是支持良好中断的多线程RTOS（也就是带有中断驱动的I²C库），那么中断变得非常实用。中断服务程序（ISR）会在转换完成时通知一个线程，而该线程则可以与ADS1115通信，在I²C传输（和转换）进行时会被阻塞。与轮询相比，这样的做法会消耗极少的CPU时间，并且允许其他线程运行，几乎不影响性能。
- en: 14.9 Filtering Noise
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.9 去噪
- en: In the real world—as opposed to the simple test circuits I’ve used in this chapter,
    where I’ve wired an analog input directly to a power supply pin—noise can be a
    big issue when reading analog signals. Sources of noise include the environment,
    the circuitry, and the analog sensors themselves. Fortunately, you can digitally
    filter out some of this noise with some simple software techniques.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中—与本章中我使用的简单测试电路不同，在那些电路中我将模拟输入直接接到电源引脚—在读取模拟信号时，噪声可能是一个大问题。噪声的来源包括环境、电子电路以及模拟传感器本身。幸运的是，你可以通过一些简单的软件技术来数字滤波掉一部分噪声。
- en: One of the most common such techniques is to take several readings—say, three
    to nine—and take the median of those values. This scheme picks the middle of a
    bunch of readings and has the advantage of eliminating outlier values. A slightly
    more efficient technique is to take several readings and compute the arithmetic
    mean of those values. This is usually faster than computing the median but has
    the disadvantage of incorporating outliers into the average.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 其中最常见的技术之一是进行多次读取——比如三次到九次——并取这些值的中位数。这种方法选择一堆读取值中的中间值，优点是可以消除异常值。一个稍微高效一些的技术是进行多次读取并计算这些值的算术平均值。通常，这比计算中位数更快，但缺点是会把异常值纳入平均值中。
- en: However, both median and mean are based on a fixed set of values, while analog
    readings tend to be a continuous stream. Therefore, the most appropriate solution
    is to create a *windowed average*. To do so, maintain a list of the last *n* readings,
    where *n* is the window size, and compute the average based on those values. Each
    time a new ADC reading comes along, you add it to the window list and throw out
    the oldest reading from the list.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，无论是中位数还是平均值，都是基于固定的一组值，而模拟读取往往是连续流动的。因此，最合适的解决方案是创建一个*窗口平均值*。为此，维护一个包含最后*n*个读取值的列表，其中*n*是窗口大小，并基于这些值计算平均值。每次有新的ADC读取时，你将其加入窗口列表，并丢弃列表中最旧的读取值。
- en: In relatively noisy environments, I usually use *both* techniques to filter
    out the noise. I keep the last seven or nine readings from the ADC and compute
    the median of those values. Then I keep the last 4 to 20 median values (depending
    on the application) and compute the arithmetic mean of those values. For example,
    if I’m computing the median of 9 values and the arithmetic mean of 10 values,
    I’m actually averaging a total of 90 ADC readings at any one given time. In the
    next section, I’ll describe how to do this.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在相对嘈杂的环境中，我通常同时使用*两种*技术来过滤噪声。我保留来自ADC的最后七次或九次读取，并计算这些值的中位数。然后，我保留最后4到20个中位数值（具体数量取决于应用），并计算这些值的算术平均值。例如，如果我正在计算9个值的中位数和10个值的算术平均数，那么我实际上是在任何给定时刻平均90个ADC读取值。在下一节中，我将描述如何做到这一点。
- en: The price of filtering out noise using averaging is that your results will only
    slowly reflect any sudden changes in the analog readings. For example, if your
    input voltage suddenly jumps from 0 V to 5 V, it may take several hundred readings
    before your average shows a solid 5 V.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 使用平均化来过滤噪声的代价是，你的结果只能慢慢地反映出模拟读取中的任何突变。例如，如果输入电压突然从0V跳变到5V，可能需要几百次读取，直到你的平均值稳定为5V。
- en: 14.9.1 Computing Means and Medians
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.9.1 计算均值和中位数
- en: 'Computing the arithmetic mean is relatively simple: just sum all the values
    and divide by the number of values. Choosing a window size that is a power of
    two can improve performance, as division by *n* (normally a slow operation) becomes
    a simple shift-right operation. Normally, the window size is sufficiently small
    that summing all the elements in the window is no big deal; however, if you have
    a large number of items, you can save a small amount of time by subtracting the
    oldest element in the window and then adding in the latest reading.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 计算算术平均值相对简单：只需将所有值相加并除以值的数量。选择一个窗口大小为2的幂次方可以提高性能，因为除以*n*（通常是一个较慢的操作）变成了简单的右移操作。通常，窗口大小足够小，以至于对窗口中的所有元素求和不会有什么问题；然而，如果你有大量的项目，通过减去窗口中最旧的元素，然后加上最新的读取，你可以节省少量时间。
- en: 'The generic algorithm for computing a median is to sort the data and pick the
    middle element (or take the mean of the middle two elements if there is an even
    number of elements). The quickselect algorithm does much better (see [https://en.wikipedia.org/wiki/Quickselect](https://en.wikipedia.org/wiki/Quickselect)).
    However, for very small windows (say, three, seven, or nine elements), a brute-force
    approach is probably the most efficient. For example, the common way to compute
    the median of three elements is to use code like the following:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 计算中位数的通用算法是对数据进行排序，并选择中间的元素（如果元素数量为偶数，则取中间两个元素的平均值）。quickselect算法表现得更好（参见[https://en.wikipedia.org/wiki/Quickselect](https://en.wikipedia.org/wiki/Quickselect)）。然而，对于非常小的窗口（比如三、七或九个元素），蛮力方法可能是最有效的。例如，计算三个元素的中位数的常见方法是使用如下代码：
- en: '[PRE10]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Code like this is often used to create a pivot element for the quicksort algorithm;
    see “For More Information” for details.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的代码常用于为快速排序算法创建一个枢轴元素；有关详细信息，请参见“更多信息”。
- en: Here’s a generic function that computes the median of an array of any size (not
    just three elements) and is faster for certain array sizes. You’ll normally work
    with a fixed window size in any given application. Simply pull out the code from
    the appropriate case in this function to get an algorithm that works for your
    particular window size.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个通用函数，用于计算任意大小数组的中值（不仅仅是三个元素），并且在某些数组大小下运行更快。你通常会在给定的应用程序中使用固定窗口大小。只需从此函数中提取适当的代码，即可获得适用于特定窗口大小的算法。
- en: '[PRE11]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Insertion into an already sorted list takes time equal to O(lg *n*), where *n*
    is the number of elements in the list. If you keep a sorted list of the last *n*
    readings, you can compute the median more efficiently (though removing the oldest
    element might be tricky). However, this is a book on I²C programming, not algorithm
    development, so I will leave further optimizations to interested readers.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 插入已排序列表的时间复杂度为 O(lg *n*)，其中 *n* 是列表中元素的数量。如果你保持一个包含最后 *n* 次读取结果的已排序列表，你可以更高效地计算中值（尽管移除最旧的元素可能有点棘手）。然而，这是一本关于
    I²C 编程的书，而不是算法开发书，因此我将把进一步的优化留给有兴趣的读者。
- en: 14.10 Chapter Summary
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.10 章节总结
- en: This chapter covered the programming and use of the ADS1015 and ADS1115 analog-to-digital
    converters. It began with a discussion of the specifications and features of generic
    ADCs with some specific features of the ADS1*x*15 devices to provide an appropriate
    background for the discussion in this chapter.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 ADS1015 和 ADS1115 模拟到数字转换器的编程和使用。首先讨论了通用 ADC 的规格和特点，并特地提到了 ADS1*x*15 设备的一些特殊功能，为本章讨论提供了适当的背景。
- en: Because most ADCs have a limited range of voltage inputs they can process, you
    will often need to add additional analog circuity to *condition* real-world signals,
    that is, convert the incoming signal to something that is appropriate for the
    ADC. Because the ADS1*x*15 ICs are limited to the (somewhat) unusual range of
    0 V to 4.095 V (in full-range mode), this chapter provided an opamp circuit that
    will convert voltages within the range of ±10 V to a range acceptable to the ADS1*x*15
    ICs.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数 ADC 具有有限的电压输入范围，因此你通常需要添加额外的模拟电路来*调理*现实世界的信号，即将输入信号转换为适合 ADC 的信号。由于 ADS1*x*15
    IC 的输入范围被限制在 0 V 到 4.095 V（在全范围模式下）的（有点）不寻常的范围内，本章提供了一个运算放大器电路，它将 ±10 V 范围内的电压转换为
    ADS1*x*15 IC 可接受的范围。
- en: After discussing analog conditioning, this chapter then did a deep dive into
    the registers present on the ADS1*x*15 devices and how to program them via the
    I²C bus. The chapter described all the various bits in the registers and how to
    initialize and use the ADS1*x*15.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了模拟信号调理后，本章深入讲解了 ADS1*x*15 设备上存在的寄存器，以及如何通过 I²C 总线编程它们。章节描述了寄存器中的各种位以及如何初始化和使用
    ADS1*x*15。
- en: Because the ADS1*x*15 parts are surface-mount devices, they’re a bit difficult
    to wire onto a typical prototyping breadboard. So this chapter briefly described
    the Adafruit breakout boards for the ADS1015 and ADS1115 ICs. Adafruit is also
    kind enough to provide sample library code for Arduino and Raspberry Pi systems,
    for which this chapter provided links.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 ADS1*x*15 部件是表面贴装设备，它们在典型的原型面包板上接线有些困难。因此，本章简要介绍了 Adafruit 为 ADS1015 和 ADS1115
    集成电路提供的 breakout 板。Adafruit 还很贴心地为 Arduino 和 Raspberry Pi 系统提供了示例库代码，本章提供了相关链接。
- en: Although you can use the Adafruit libraries to read analog data using the ADS1*x*15
    devices, the goal of this chapter was to teach you how to program the ADS1*x*15
    parts directly. Therefore, this chapter also provided sample programs that program
    the chips directly and obtain the analog data. It also discussed how to improve
    the performance of the (rather slow) ADC parts, and it briefly touched on using
    interrupts with the ADS1*x*15.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以使用 Adafruit 库通过 ADS1*x*15 设备读取模拟数据，但本章的目标是教你如何直接编程控制 ADS1*x*15 部件。因此，本章还提供了直接编程控制芯片并获取模拟数据的示例程序。还讨论了如何提高（相对较慢的）ADC
    部件的性能，并简要介绍了如何与 ADS1*x*15 一起使用中断。
- en: This chapter concluded by pointing out that ADC inputs tend to have a bit of
    noise associated with them. It then described a filtering algorithm (using arithmetic
    mean and median averages) to produce a quieter input.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 本章最后指出，ADC 输入通常会有一些噪声。然后介绍了一种滤波算法（使用算术平均值和中值平均值）来产生更干净的输入。
