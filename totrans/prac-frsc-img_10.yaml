- en: '**9**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**EXTRACTING SUBSETS OF FORENSIC IMAGES**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter covers the selective extraction of data regions from an attached
    drive or a forensically acquired image file. You’ll learn to extract whole partitions,
    deleted or partially overwritten partitions, inter-partition gaps, and various
    volume and file slack areas. In addition, you’ll see how to extract special areas
    such as Unified Extensible Firmware Interface (UEFI) partitions, the sectors hidden
    by a DCO or HPA, and hibernation partitions such as Intel Rapid Start Technology.
  prefs: []
  type: TYPE_NORMAL
- en: The final sections demonstrate extraction of data from allocated and unallocated
    (possibly deleted) areas of the disk for further examination and manual extraction
    of sectors using offsets. Let’s begin with determining the partition layout of
    the drive.
  prefs: []
  type: TYPE_NORMAL
- en: '**Assess Partition Layout and Filesystems**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you’ve attached a disk to your system or have acquired an image file, you
    can perform an analysis of the disk partition scheme. This section explains how
    to identify filesystems, partition tables, and commonly used disk partition schemes.
  prefs: []
  type: TYPE_NORMAL
- en: The disk layout, or *partition scheme*, refers to the method used to organize
    the *partitions* (or *slices*) on a hard disk. The most common partition schemes
    you’ll find in consumer computing are DOS, GPT, BSD, and APM (Apple Partition
    Map, sometimes called *mac*). We’ll start with identifying the partition scheme
    used on a disk.
  prefs: []
  type: TYPE_NORMAL
- en: '***Partition Scheme***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each partition or slice on a disk contains a separate filesystem or is used
    for some other special purpose. A small portion of the disk (often just the first
    sector) defines the layout of the disk by specifying the starting sector of each
    partition, the partition size, the partition type, labels, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: To determine the disk partition scheme, you can examine the initial sectors
    of the disk for indicators. There is no official “Assigned Number” designation
    for partition schemes (there are only half a dozen or so). Don’t confuse this
    with DOS MBR partition types or IDs, which list up to 255 possible filesystems
    and other formats that could reside inside a DOS partition. When you attach the
    subject disk to a workstation, the Linux kernel will attempt to detect and interpret
    the partition scheme used, and it will create the devices for each partition it
    finds.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the Sleuth Kit `mmstat` command to identify the most common partition
    schemes. A list of supported partition schemes is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `mmstat` will output the name of the scheme used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use the disktype tool to identify the partition scheme.
    The disktype tool provides more verbose information and supports partitions, filesystems,
    and file and archive containers. The following example shows output from disktype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You’ll find the original disktype software package at *[http://disktype.sourceforge.net/](http://disktype.sourceforge.net/)*.
    Also, you’ll find a fork and multiple patches for disktype at *[https://github.com/kamwoods/disktype/](https://github.com/kamwoods/disktype/)*,
    *[https://github.com/Pardus-Linux/Packages/tree/master/system/base/disktype/files/](https://github.com/Pardus-Linux/Packages/tree/master/system/base/disktype/files/)*,
    and *[https://github.com/ericpaulbishop/gargoyle/tree/master/package/disktype/patches/](https://github.com/ericpaulbishop/gargoyle/tree/master/package/disktype/patches/)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'A storage medium does not require a partition table or even a filesystem. Binary
    data can be written directly to the raw disk and accessed by any program capable
    of understanding it (for example, some databases can directly use raw disks).
    It’s possible to have disks without partition schemes. In such cases, the filesystem
    starts at sector zero and continues to the end of the disk (that is, the whole
    disk is the partition). This is common with some older USB sticks and floppy disks.
    In such cases, partition analysis tools will be ineffective and generally report
    a false or nonexistent partition table. If a tool cannot detect a partition type,
    it’s worth checking whether a filesystem was written directly to a raw device.
    In this example, `mmstat` finds nothing, but `fsstat` does identify a filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Some encrypted volumes attempt to hide their existence or information about
    the filesystem used, and they don’t use a recognizable partition scheme.
  prefs: []
  type: TYPE_NORMAL
- en: '***Partition Tables***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A partition scheme will have a disk block or set of blocks describing how it’s
    organized. These are called *partition tables* (or *disklabels* for BSD systems),
    and you can query them using various tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the Sleuth Kit `mmls` command to list the partition tables on a
    disk or a forensically acquired image. In this example, `mmls` finds a regular
    DOS partition scheme with a FAT32 partition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The traditional DOS partition scheme is not able to handle disks larger than
    2TB. The GPT partition scheme was created to allow larger disks to be organized
    with a greater number of partitions. GPT supports 128 partitions compared to the
    4 that DOS supports (not counting extended partitions). I have written a paper
    on the forensic analysis of GPT disks and GUID partition tables; you can find
    it here: *[http://dx.doi.org/10.1016/j.diin.2009.07.001](http://dx.doi.org/10.1016/j.diin.2009.07.001)*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most new PC systems are being shipped with GPT partitions today. An example
    of a Windows 8 system’s partition table is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Gary Kessler provides several partition table–parsing tools that provide much
    greater detail. You’ll find these tools at *[http://www.garykessler.net/software/index.html](http://www.garykessler.net/software/index.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the level of detail Kessler’s parsing tools provide, here is
    partial output from the partition table from the preceding example generated using
    the gptparser.pl tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The tool provides detailed information about each of the 128 GPT partitions.
  prefs: []
  type: TYPE_NORMAL
- en: '***Filesystem Identification***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The disktype tool, already presented in “[Partition Scheme](ch09.xhtml#ch09lev2sec01)”
    on [page 260](ch09.xhtml#page_260), allows you to identify partition schemes and
    filesystems within partitions. The Sleuth Kit fsstat tool provides more comprehensive
    information about a filesystem. The fsstat tool can operate directly on a partition
    device or on a forensically acquired image if you specify the sector offset.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous examples, the sector offset of a Windows volume on the *lenovo.raw*
    image file was 3868672\. You can provide this sector offset to the fssstat tool
    using the `-o` flag to analyze the filesystem metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If the drive is directly attached to your workstation, the Linux kernel will
    attempt to parse the partition table and make the disk and partition devices available
    in */dev*, where you can access them directly.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you’re examining a raw image file (*.raw*, *.ewf*, and so on), there
    will be no device files for the image. The kernel will not interpret the partition
    table and will not create the familiar partition devices (*/dev/sda1*, */dev/sda2*,
    and so on). You must specify an offset when accessing a partition within an image
    file.
  prefs: []
  type: TYPE_NORMAL
- en: It’s better to rely on forensic tools to determine the partition details rather
    than to trust the kernel. If a disk is corrupt or damaged, the kernel might refuse
    to create the partition devices or create the wrong ones. The examples you saw
    in this section always specified an offset rather than using the kernel. In situations
    that involve malware, antiforensics, or other malicious misdirection, using forensic
    tools instead of the kernel should take precedence.
  prefs: []
  type: TYPE_NORMAL
- en: '**Partition Extraction**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section describes the extraction of individual partitions, inter-partition
    gaps, and other areas of the disk like the DCO and HPA. Let’s begin with some
    basic examples of extracting regular partitions.
  prefs: []
  type: TYPE_NORMAL
- en: '***Extract Individual Partitions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To access and extract individual partitions rather than the entire hard disk,
    you can use several techniques. I’ll demonstrate a few examples of partition extraction
    using a directly attached drive with a partition device, a partition mapper device,
    and image files operated on by Sleuth Kit’s mmcat- and dd-style tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a disk is accessible as an attached device, acquiring the partition is similar
    to performing a full acquisition with a raw drive device but uses the partition
    device instead. In the following example, the first partition of */dev/sda* is
    extracted to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Extracting partitions requires some capacity planning, because the partition
    will consume disk space (possibly alongside the full drive image). If you need
    only temporary access to a partition from an acquired image file, you can attach
    it as a loop device and access it. The following steps demonstrate this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, use the mmls tool to identify the partition to be attached as a loop,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then use Bash math expansion to convert the sector offset and sector length
    into a byte offset and byte length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The calculated byte offset and byte length are then passed to losetup to create
    a loop device, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can access this resulting loop device using forensic tools in the same
    way as you access the partition device of an attached disk. An example using Sleuth
    Kit fls is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If you need to extract a partition from an existing acquired image into a separate
    file, you can use the dd tools or the Sleuth Kit `mmcat` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'To extract a partition from an acquired image, the initial step is to identify
    the partition and sector details. In the following example, the partition table
    from an acquired disk image shows the partition to be extracted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Extracting a partition from an already acquired image file using dcfldd or
    dd requires adding `skip` (dc3dd uses `iskip`) and `count` parameters, which cause
    the command to jump (skip) ahead to the start of the partition and acquire only
    the size of the partition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this command, the block size is set to 512 bytes to match the sector size,
    the start of the partition is at sector 63, and 78124032 sectors should be extracted.
    With a little additional calculation, you can improve the performance of this
    command by changing the 512-byte block size to something larger (but don’t forget
    to adjust the `skip` and `count` parameters if you do this).
  prefs: []
  type: TYPE_NORMAL
- en: 'With Sleuth Kit version 3.0 and later, you can use the mmcat tool to easily
    extract partitions. To recover the first partition in the previous example using
    mmcat, you must specify the mmls slot number (not the DOS partition number). In
    this case, the first partition is located in the mmls slot number two and can
    be extracted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The mmcat tool simply pipes the output to stdout, so you must either redirect
    it to a file or pipe it into a program.
  prefs: []
  type: TYPE_NORMAL
- en: '***Find and Extract Deleted Partitions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To exhaustively search for partially overwritten or deleted partitions of a
    forensically acquired image, you can use several methods. Sleuth Kit provides
    a basic tool called sigfind to search for binary signature strings. Two useful
    tools for comprehensive partition searching are gpart and testdisk. These tools
    implement filesystem recognition algorithms with more intelligent guessing to
    identify lost partitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running gpart without any options starts a scan for partitions, skipping over
    areas identified as allocated. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Adding a `-f` flag tells gpart to be exhaustive, looking for partitions in every
    sector of the entire disk, even in areas where no partitions are expected to be
    found. This will take much longer than the default gpart scan without flags.
  prefs: []
  type: TYPE_NORMAL
- en: The testdisk tool (*[http://www.cgsecurity.org/](http://www.cgsecurity.org/)*,
    written by Christophe Grenier, who also wrote the photorec carving tool) provides
    several features in addition to partition searching. Testdisk provides an interactive
    interface, supports multiple disk layouts (DOS, GPT, BSD, and more), detects several
    dozen partition types, generates activity logs, and can extract discovered partitions
    to a file. You can use testdisk on devices, raw image files, and even **.e01*
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Use the testdisk tool with caution. This tool was designed for repairing and
    recovering partitions, and it could easily modify evidence. Be sure to use a write
    blocker before running this tool on attached subject disks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also included with the tool is a comprehensive user interactive menu system
    to define options and activities. Shown here is a batch mode example operating
    on an attached disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can perform a certain amount of manual analysis to search for deleted partitions.
    If the partition table shows a large area of unallocated space on a disk, check
    this area to determine whether a partition exists. In the following example, mmls
    shows nearly 2.5GB (4863378 sectors) of empty space at the end of a thumb drive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This unallocated space could be a deleted partition. In this example, running
    fsstat using the offset of the empty space discovers a valid filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If you detect a valid filesystem, you can use the meta information about it
    to determine the probable size of the partition. Knowing the size and starting
    offset, you can extract the discovered partition or further analyze it. You can
    extract it using dd-style tools or more easily with mmcat, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, the mmcat output of the deleted partition discovered in mmls slot 003
    is sent to a file called *deleted_partition.raw*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Identify and Extract Inter-Partition Gaps***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In some cases, there may be gaps between partitions that were created accidentally
    or due to adjacent partitions meeting on cylinder or block boundaries. There could
    also be intentional gaps that were created for hiding data. You can identify and
    recover these inter-partition gaps in the same way as you extract a partition.
    Use mmls to determine the size and sector offset of the gap, and then use dd or
    mmcat to extract it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The mmls output of a partition table is shown here. The disk contains two partitions,
    and there is a gap between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the first partition ends on sector 15626236, but the adjacent
    partition starts on sector 15626240, indicating a three-sector gap between them.
    Although you can extract this inter-partition gap using dd, using mmcat is simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The resulting file is three sectors in size with the contents of the gap between
    the two partitions. Larger gaps between partitions that contain partially overwritten,
    corrupted, or identifiable filesystem fragments can be analyzed with carving tools
    such as foremost.
  prefs: []
  type: TYPE_NORMAL
- en: The gap between the last partition and the end of a disk can also be of interest.
    It may contain artifacts such as content from previously overwritten partitions,
    backup copies of the GPT partition, or even malware attempting to hide segments
    of binary code.
  prefs: []
  type: TYPE_NORMAL
- en: '***Extract HPA and DCO Sector Ranges***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You have already learned how to identify and remove HPA and DCO restrictions.
    Once removed, these areas of the disk can be extracted for separate analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, hdparm shows that an HPA exists, and the mmls output shows
    three slots, one of them being a Linux partition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'After you successfully remove the HPA (and tell the kernel to rescan the SCSI
    bus), running the same commands again produces different output, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now, hdparm indicates the HPA is disabled, and the mmls output shows an additional
    line of output (slot 03) representing the sectors previously hidden by the HPA.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `mmcat` command with partition slot 03 will extract the data from
    HPA, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This example uses a live disk attached to an acquisition host. When an image
    file is acquired from a disk with the HPA removed, mmls will see this hidden region.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting sectors hidden by a DCO is identical to the method shown here with
    the HPA. First use hdparm to expose the DCO-protected sectors, and then extract
    them using dd or mmcat. This procedure does not need to be repeated with additional
    examples specifically demonstrating sectors from a DCO.
  prefs: []
  type: TYPE_NORMAL
- en: '**Other Piecewise Data Extraction**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this final section, I describe various additional examples of piecewise data
    extraction. The contents of this section (in fact the contents of most of this
    chapter) blur together slightly with forensic filesystem analysis, which is not
    the intended scope of the book. For this reason, the examples are slightly less
    descriptive.
  prefs: []
  type: TYPE_NORMAL
- en: '***Extract Filesystem Slack Space***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Slack space* is a traditional digital forensics concept referring to allocated
    but unused data at the end of disk sectors, filesystem blocks, or filesystems
    (RAM slack, file slack, and partition slack, respectively).'
  prefs: []
  type: TYPE_NORMAL
- en: To visualize slack space, imagine this book as a hard disk, where paragraphs
    are sectors, chapters are files, and body of the text is the partition. Notice
    that paragraphs don’t finish exactly at the end of a line, chapters don’t finish
    exactly at the end of a page, and the end of the book might have a couple of additional
    blank pages. These empty spaces are the book’s “slack space.” With storage media,
    if the OS or physical drive has not explicitly written zeros to these areas, they
    might still contain data from previously written files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Historically, extracting and analyzing slack space has been useful in forensic
    investigations. However, the value of slack space is beginning to decrease due
    to several factors:'
  prefs: []
  type: TYPE_NORMAL
- en: • SSDs are using TRIM commands to zero unallocated blocks.
  prefs: []
  type: TYPE_NORMAL
- en: • Modern OSes are writing back zeros to unused portions of sectors and blocks.
  prefs: []
  type: TYPE_NORMAL
- en: • Disks with native 4K sectors align with filesystem block sizes.
  prefs: []
  type: TYPE_NORMAL
- en: • OSes create partitions and filesystems aligned to block boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: As part of the forensic process, acquiring and analyzing potential slack areas
    are still diligent steps to complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'To extract all slack space on a given image, you can use the Sleuth Kit `blkls`
    command. Slack space is filesystem specific, so you must extract slack space on
    each filesystem separately (you can’t just use the entire raw disk). In this example,
    the filesystem offsets of the acquired image are found with mmls, and the slack
    space of each one is extracted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The slack space for each recognized filesystem is saved to a file. The `blkls`
    command’s `-s` flag extracts all slack space (and only slack space). It is important
    to understand that slack space does not refer to unallocated blocks or sectors.
    Slack space is the unused area found within *allocated* blocks and sectors of
    a filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: '***Extract Filesystem Unallocated Blocks***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This next example will gather all unallocated blocks from filesystems on an
    acquired image. Unallocated blocks are filesystem specific, so you need to perform
    this operation separately on each recognized filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the `mmls` command is again used to determine the offsets of each filesystem,
    and the `blkls` command is used to extract unallocated blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The correct `blkls` flag for extracting unallocated blocks is `-A`, but because
    it’s the default command behavior, you can omit it.
  prefs: []
  type: TYPE_NORMAL
- en: You can also perform the inverse action of extracting all (and only) allocated
    blocks using the `blkls -a` command.
  prefs: []
  type: TYPE_NORMAL
- en: '***Manual Extraction Using Offsets***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In certain situations, you might use a hex editor to browse, search, or manually
    analyze the contents of a disk or acquired disk image. The hex editor may provide
    a byte offset, a sector offset, or both.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example uses the console-based hexedit tool to analyze a disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The hexedit tool allows you to directly edit block device files and edit very
    large image files (no loading in memory or temp files), and it provides a sector
    mode (entire sectors and sector offsets are shown).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the sector offset is 2048 (the start of an NTFS partition),
    the byte offset is 0x100181, and the entire sector is shown (note: hexedit assumes
    512-byte sectors):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: From the byte or sector offset, you can construct dd commands to extract what
    was found within the hex editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example uses a sector size of 512, a sector offset, and a sector
    count to extract a range of data (four 512-byte sectors) from an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The next example extracts the same range of data using byte offsets. The `skip`
    command uses Bash math expansion to convert hexadecimal into decimal, which is
    needed for `dd`; the block size is 1 byte; and the count is the number of bytes
    required.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The two previous examples extract the same block (four sectors or 2048 bytes)
    of data. Note that when extracting regions of a disk, it is sensible to ensure
    you have sector- or block-aligned offsets (that is, multiples of the sector size
    or block size).
  prefs: []
  type: TYPE_NORMAL
- en: 'In cases in which you need to extract a range of filesystem blocks, use the
    Sleuth Kit `blkcat` command. The following example extracts 25 blocks from a filesystem
    starting at block 100:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The filesystem block size should be detected by the tool.
  prefs: []
  type: TYPE_NORMAL
- en: The examples in this final section showed how you can access images; use offsets;
    and extract a range of bytes, sectors, or blocks. You can also use other Sleuth
    Kit commands to map sectors to blocks and map blocks to inodes and filenames.
    These tasks are filesystem specific and move into the realm of filesystem forensic
    analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '**Closing Thoughts**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this final chapter, you learned how to extract subsets of drives and forensic
    images. The chapter focused on extracting various portions of an image such as
    sectors hidden by an HPA or DCO, deleted partitions, and inter-partition gaps.
    You also saw the manual extraction of specified sectors and blocks, including
    unallocated blocks and slack space. This chapter bordered on forensic analysis,
    as it looked at identifying partition schemes, understanding partition tables,
    and identifying filesystems. Since this book is about forensic acquisition and
    not forensic analysis, it is a fitting final chapter.
  prefs: []
  type: TYPE_NORMAL
