<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch13">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_283" aria-label="283"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch13">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">13</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">TREES AND FORESTS</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/>&#13;
</figure>&#13;
<p class="INTRO">In previous chapters we explored binary trees that have the restriction of only two children per node. In this chapter, we’ll consider some new structures that go beyond that restriction, such as forests and orchards (when working with a single tree isn’t enough). After that, we’ll move on to study B-trees and red-black trees for faster searching.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-63"/><span class="SANS_Futura_Std_Bold_B_11">Defining Trees and Forests</span></h3>&#13;
<p class="TNI1"><i>Binary trees</i> can be empty or consist of a node (the root) and two children, which are both binary trees themselves. In particular, <i>binary search trees</i> are also <i>ordered</i> trees, because we define a certain order between children and distinguish the left child from the right child.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_284" aria-label="284"/>Let’s expand on those concepts. First, you’ll allow a node to have many children, not just two—in other words, nodes can have degrees greater than 2. You may have trees with a specific number of (possibly empty) children per node, as binary or ternary trees, but in general, no restrictions are placed on the degree of a node. Sometimes trees with an unspecified maximum degree are called <i>multiary</i> or <i>multiway</i>.</p>&#13;
<p class="TX">Moving beyond single trees, a <i>forest</i> is defined as a set of disjointed trees. For instance, you could consider the directory for a given hard drive in your computer to be a tree, but all the different pieces of storage (like hard drives or USB sticks) in your computer would make up a forest.</p>&#13;
<p class="TX">We can even go further and define an <i>orchard</i> as a forest with an ordered relationship between its trees. In a forest, trees are strewn around in a disordered manner, but an orchard has a well-defined layout. Continuing with the computer example, if you assign letters to your drives (<span class="SANS_TheSansMonoCd_W5Regular_11">C:</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">D:</span>, and so on, Microsoft Windows style), your storage actually is an orchard. The forestry-related terms do not end here: you can also have <i>groves</i>, which are like trees, with the exception that their nodes can have links to other nodes, which would turn the data structure into a directed (and possibly cyclic) graph.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>To simplify the terminology in this chapter, we’ll use the terms forests (when no particular order is implied among the trees) and ordered forests (rather than orchards), which is the terminology most textbooks use. Also, in this chapter we won’t work with groves at all.</i></p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h4 class="H2" id="sec2"><span id="h2-101"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Representing Trees with Arrays</span></h4>&#13;
<p class="TNI1">Do you know how to represent a general tree? How about a forest? Let’s start with trees, because by doing so we’ll discover a tip for dealing with forests. The first solution you’ll probably think of is having an array to point at each child, and in JavaScript with varying-length dynamic arrays, that’s the simplest solution. <a href="chapter13.xhtml#fig13-1">Figure 13-1</a> shows a generic tree where the nodes have different degrees.</p>&#13;
<figure class="IMG"><img class="img5" id="fig13-1" src="../images/Figure13-1.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 13-1: A generic tree</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">To implement such a tree, add an array of subtrees to each node, resulting in something like the following (in terms of JavaScript, this code varies <span role="doc-pagebreak" epub:type="pagebreak" id="pg_285" aria-label="285"/>a bit from the style of the book and represents trees with a class, which lets you use a standard interface like the Document Object Model [DOM] node interface):</p>&#13;
<pre id="pre-249"><code>class Tree {&#13;
  constructor(rootKey) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> this._key = rootKey;&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> this._children = [];&#13;
  }&#13;
&#13;
  isEmpty() {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> return this._key === undefined;&#13;
  }&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> _throwIfEmpty() {&#13;
    if (this.isEmpty()) {&#13;
      throw new Error("Empty tree");&#13;
    }&#13;
  }&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> get key() {&#13;
    this._throwIfEmpty();&#13;
    return this._key;&#13;
  }&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> set key(v) {&#13;
    this._key = v;&#13;
  }&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> get isLeaf() {&#13;
    this._throwIfEmpty();&#13;
    return this.childNodes.length === 0;&#13;
  }&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation8">❽</span> get childNodes() {&#13;
    this._throwIfEmpty();&#13;
    return this._children;&#13;
  }&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation9">❾</span> get firstChild() {&#13;
    return this.isLeaf ? null : this.childNodes[0];&#13;
  }&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation10">❿</span> get lastChild() {&#13;
    return this.isLeaf ? null : this.childNodes[this.childNodes.length - 1];&#13;
  }&#13;
&#13;
  // ...more methods...&#13;
}</code></pre>&#13;
<p class="TX">A key field <span class="CodeAnnotation" aria-label="annotation1">❶</span>, which also doubles as a flag, decides whether a tree is empty <span class="CodeAnnotation" aria-label="annotation3">❸</span>, and an array of children <span class="CodeAnnotation" aria-label="annotation2">❷</span> is empty by default. The <span class="SANS_TheSansMonoCd_W5Regular_11">_throwIfEmpty()</span> method <span class="CodeAnnotation" aria-label="annotation4">❹</span> detects incorrect accesses to empty trees (this is used in several <span role="doc-pagebreak" epub:type="pagebreak" id="pg_286" aria-label="286"/>methods). You also add a getter <span class="CodeAnnotation" aria-label="annotation5">❺</span> and a setter <span class="CodeAnnotation" aria-label="annotation6">❻</span> for the tree’s key. Then add some getters to check whether a node is a leaf with no children <span class="CodeAnnotation" aria-label="annotation7">❼</span> and, if not, to get its children <span class="CodeAnnotation" aria-label="annotation8">❽</span>, in particular, accessing its first <span class="CodeAnnotation" aria-label="annotation9">❾</span> and last <span class="CodeAnnotation" aria-label="annotation10">❿</span> child, mimicking well-known DOM node-related methods.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>For more details on the DOM node interface, visit</i> <span class="note_LinkURL"><a href="https://developer.cdn.mozilla.net/en-US/docs/Web/API/Node">https://developer.cdn.mozilla.net/en-US/docs/Web/API/Node</a></span><i>.</i></p>&#13;
<p class="TX">You could consider adding more methods to the tree, but you would need some extra fields to reproduce certain methods, such as <span class="SANS_TheSansMonoCd_W5Regular_11">parentNode</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">previousSibling</span>. We’ll see some ways to achieve those things later in the chapter. Now you can represent general trees and access their nodes, so next take a look at how to add or remove data to update trees.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h5 class="H3" id="sec3"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Adding Nodes to a Tree</span></h5>&#13;
<p class="TNI1">First, add a new child in a specific place among its siblings:</p>&#13;
<pre id="pre-250"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> addChild(keyToAdd, i = this.childNodes.length) {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> this._throwIfEmpty();&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> if (i &lt; 0 || i &gt; this.childNodes.length) {&#13;
    throw new Error("Wrong index at add");&#13;
  } else {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> const newTree = new this.constructor();&#13;
    newTree.key = keyToAdd;&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> this._children.splice(i, 0, newTree);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> return this;&#13;
  }&#13;
}</code></pre>&#13;
<p class="TX">To add a new key, all you need to specify is its position among its siblings; by default, you’ll add it at the end <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If the tree is empty (no root), you throw an error <span class="CodeAnnotation" aria-label="annotation2">❷</span>, and you also do that if the index lies beyond the limits of the current array of children <span class="CodeAnnotation" aria-label="annotation3">❸</span>. If everything’s okay, just create a new tree <span class="CodeAnnotation" aria-label="annotation4">❹</span>, place the new key as its root, and place the tree in the correct position among its siblings <span class="CodeAnnotation" aria-label="annotation5">❺</span>, ending by allowing chaining, as in other previous cases <span class="CodeAnnotation" aria-label="annotation6">❻</span>.</p>&#13;
<p class="TX">Appending a node is easy:</p>&#13;
<pre id="pre-251"><code>appendChild(keyToAppend) {&#13;
  return this.addChild(keyToAppend);&#13;
}</code></pre>&#13;
<p class="TX">You just depend on the default parameters for <span class="SANS_TheSansMonoCd_W5Regular_11">addChild()</span>, which also test whether the tree has a root. No special code needed here.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h5 class="H3" id="sec4"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Removing Nodes from a Tree</span></h5>&#13;
<p class="TNI1">To remove a given child, you need only a test and some array manipulation:</p>&#13;
<pre id="pre-252"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_287" aria-label="287"/>removeChild(i) {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> this._throwIfEmpty();&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if (i &lt; 0 || i &gt;= this.childNodes.length) {&#13;
    throw new Error("Wrong index at remove");&#13;
  } else {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> this._children.splice(i, 1);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> return this;&#13;
  }&#13;
}</code></pre>&#13;
<p class="TX">After verifying that the tree has a root and isn’t empty <span class="CodeAnnotation" aria-label="annotation1">❶</span>, check whether the index of the child to remove is valid or not <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If it is valid, do some array manipulation to remove the child from among its siblings <span class="CodeAnnotation" aria-label="annotation3">❸</span>. End by enabling chaining as when adding a node <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h2-102"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Representing Trees with Binary Trees</span></h4>&#13;
<p class="TNI1">Representing trees with arrays works well, but another way of dealing with trees uses a simpler kind of tree, a binary tree. The trick is to use the left and right pointers in a different way from before: the left one will point to the first child, and the right one will point to the next sibling.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>If you are wondering whether this technique is purely academic or if you’ll ever use it in reality, we’ll be doing so in <a href="chapter15.xhtml">Chapter 15</a> when studying binomial heaps and their variants.</i></p>&#13;
<p class="TX">Revisit the tree shown in <a href="chapter13.xhtml#fig13-1">Figure 13-1</a>. An alternative representation would have each node’s left link pointing to the node’s first child, and the right links would create a list of the node’s siblings. (As with all the other diagrams in this book, left and right null pointers are omitted for clarity.) If you rearrange and rotate the image 45 degrees, so the left pointers actually point down, the scheme becomes clearer, as shown in <a href="chapter13.xhtml#fig13-2">Figure 13-2</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig13-2" src="../images/Figure13-2.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 13-2: A tree represented with the “left-child, right-sibling” style</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Many structures use this <i>left-child, right-sibling</i> convention, but it’s better to rename the left pointer to <i>down</i> for clarity; <i>right</i> will still point to siblings. As for algorithms (adding or removing values and so on), you won’t need to do anything different from what you learned about binary trees in <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_288" aria-label="288"/>&#13;
<h4 class="H2" id="sec6"><span id="h2-103"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Representing Forests</span></h4>&#13;
<p class="TNI1">You can extend these methods for representing trees to represent forests. If you use arrays for pointers, you can simply have an array of roots, each pointing to a specific tree (we’ll see this concept again in <span class="Xref"><a href="chapter14.xhtml">Chapters 14</a></span> and <span class="Xref"><a href="chapter15.xhtml">15</a></span> when discussing binomial and Fibonacci heaps, so consider <a href="chapter13.xhtml#fig13-3">Figure 13-3</a> to be a minor spoiler).</p>&#13;
<figure class="IMG"><img class="img5" id="fig13-3" src="../images/Figure13-3.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 13-3: A forest, represented with an array of roots</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">At the top of the forest is an array with a pointer to the root of each individual tree. If you prefer the binary tree representation, you can do two different things: consider that all roots are siblings or add a fictitious “super-root” that has all the forest trees as subtrees. The first is the usual representation, which would give something like the forest in <a href="chapter13.xhtml#fig13-4">Figure 13-4</a> (this is the same forest as shown in <a href="chapter13.xhtml#fig13-3">Figure 13-3</a>).</p>&#13;
<figure class="IMG"><img class="img5" id="fig13-4" src="../images/Figure13-4.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 13-4: An alternative representation of the same</span> <span class="SANS_Futura_Std_Book_Oblique_11">forest; the roots are linked to the right.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">To access this forest, you need a pointer to the leftmost root; from there, you can access all the trees. You can go even further by making the list of siblings circular and doubly linked; we’ll explore this later and see why those enhancements (and complications) are actually needed.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h2-104"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Traversing Trees</span></h4>&#13;
<p class="TNI1">When studying binary search trees in <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span>, we looked at three different ways of traversing trees by “visiting” all the nodes according to various schemes. With general trees, you don’t have all those methods, but we’ll add <span role="doc-pagebreak" epub:type="pagebreak" id="pg_289" aria-label="289"/>new ones. But first review the traversals we’ve done before and adapt two of them to the general tree:</p>&#13;
<div class="top">&#13;
<p class="RunInPara"><b>Preorder </b>For binary trees, <i>preorder</i> means first visiting the root, then traversing its left subtree, and finally traversing its right subtree. You can adapt this for general trees by first visiting the root and then traversing each of its subtrees in order.</p>&#13;
<p class="RunInPara"><b>Postorder </b>The <i>postorder</i> method for binary trees is similar to preorder, but it first visits the root’s left subtree, then the right, and finally the root itself. The adaptation requires first traversing all the root’s children in order and finally visiting the root itself.</p>&#13;
<p class="RunInPara"><b>Inorder </b>The <i>inorder</i> method doesn’t really have an equivalent. For binary trees, it means first traversing the left subtree, then visiting the root, and finally traversing the right subtree. However, for general trees, you don’t have any reasonable alternative, so you can forgo this traversal (although for B-trees, discussed later in this chapter, you do have a possible inorder version).</p>&#13;
</div>&#13;
<p class="TX">Coding preorder and postorder traversals is fairly straightforward, and the versions used for binary trees require only minor changes (we’ll consider their implementations in the questions at the end of this chapter). Two new methods, however, are worth studying and also appear in other types of algorithms, such as game playing or function optimization: <i>depth-first</i> and <i>breadth-first</i> traversals.</p>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h5 class="H3" id="sec8"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Depth-First Traversal</span></h5>&#13;
<p class="TNI1">The possibly most logical traversal to implement requires visiting the root first and then traversing all its children using the same algorithm. In effect, it’s equivalent to going as deeply as possible into a branch before moving on to another branch—thus, the name <i>depth first</i>. <a href="chapter13.xhtml#fig13-5">Figure 13-5</a> shows an example of such a traversal; the numbers in the nodes reflect the order in which the visits occur.</p>&#13;
<figure class="IMG"><img class="img5" id="fig13-5" src="../images/Figure13-5.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 13-5: A depth-first traversal of a tree</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This kind of algorithm is a classic one, generally used for searches or games. For instance, if you’re trying to get out of a maze, you’d follow some <span role="doc-pagebreak" epub:type="pagebreak" id="pg_290" aria-label="290"/>path until you either exit (and finish) or become blocked, in which case you go back to try another option. (See “<span class="Xref">Finding a Path in a Maze</span>” on <span class="Xref"><a href="chapter5.xhtml#pg_69">page 69</a></span>.) Similarly, in games, you consider some sequence of movements as far as you can (because of time limitations), and if you haven’t found a winning line, you go back to try another one. The logic looks like this:</p>&#13;
<pre id="pre-253"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const depthFirst = (tree, visit = (x) =&gt; console.log(x)) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if (!isEmpty(tree)) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> visit(tree.key);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> tree.children.forEach((v) =&gt; depthFirst(v));&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">The algorithm is similar to some that you wrote for binary trees in <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span>. First, define a default <span class="SANS_TheSansMonoCd_W5Regular_11">visit()</span> function <span class="CodeAnnotation" aria-label="annotation1">❶</span> that just lists the node’s key, and if the tree isn’t empty <span class="CodeAnnotation" aria-label="annotation2">❷</span>, visit its root <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Then proceed to visit all of its children recursively, depth first <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h5 class="H3" id="sec9"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Breadth-First Traversal</span></h5>&#13;
<p class="TNI1">The alternative way to traverse trees is breadth first, which is a traversal style that you haven’t yet met. (This type of traversal is also called <i>level order</i> for reasons that will become apparent.) The idea is that you start at the root; then, you visit all of its children in the next level. Then (and only then), you visit the children’s children at the second level of the tree, and so on. You never visit a node until you’ve already visited all the nodes closer to the root, going down level by level, one by one. <a href="chapter13.xhtml#fig13-6">Figure 13-6</a> shows such a traversal for a generic tree. Again, the numbers reflect the order in which the nodes are visited, and you can verify that each level is fully visited before starting the next level.</p>&#13;
<figure class="IMG"><img class="img5" id="fig13-6" src="../images/Figure13-6.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 13-6: A breadth-first traversal of a tree</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Implementing this strategy requires using a queue, as discussed in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>. As you start visiting nodes “horizontally,” you need to remember to visit their children later, so a queue with a first in, first out (FIFO) strategy works. You can code this as an independent function just for variety:</p>&#13;
<pre id="pre-254"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_291" aria-label="291"/><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> breadthFirst(visit = (x) =&gt; console.log(x)) {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if (!this.isEmpty()) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> const q = new Queue();&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> q.push(this);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> while (!q.isEmpty()) {&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> const t = q.pop();&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> visit(t.key);&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation8">❽</span> t.childNodes.forEach((v) =&gt; q.push(v));&#13;
    }&#13;
  }&#13;
}</code></pre>&#13;
<p class="TX">As with other traversals, a default <span class="SANS_TheSansMonoCd_W5Regular_11">visit()</span> function <span class="CodeAnnotation" aria-label="annotation1">❶</span> logs the node’s key. If the tree to be traversed isn’t empty <span class="CodeAnnotation" aria-label="annotation2">❷</span> (in which case you wouldn’t have to do anything), initialize a queue <span class="CodeAnnotation" aria-label="annotation3">❸</span> by pushing the tree’s root <span class="CodeAnnotation" aria-label="annotation4">❹</span>. The rest of the algorithm is straightforward: while the queue hasn’t been emptied <span class="CodeAnnotation" aria-label="annotation5">❺</span>, you pop its top <span class="CodeAnnotation" aria-label="annotation6">❻</span>, visit that node <span class="CodeAnnotation" aria-label="annotation7">❼</span>, and push all of its children into the queue for future visits <span class="CodeAnnotation" aria-label="annotation8">❽</span>.</p>&#13;
<p class="TX">This algorithm isn’t recursive at all, which isn’t common for trees and other recursively defined structures. There’s an interesting sort of symmetry here: visiting a tree breadth first without recursion requires using a queue, and visiting it depth first without recursion needs a stack; see question 13.3.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h3 class="H1" id="sec10"><span id="h1-64"/><span class="SANS_Futura_Std_Bold_B_11">B-trees</span></h3>&#13;
<p class="TNI1">B-trees have a self-adjusting tree structure with assured logarithmic performance for additions, removals, and searches, so in that sense, you could consider them an extension of height-balanced binary search trees—and a better-performing one at that. A key characteristic of these trees is that nodes can have more than two children, which allows for wider, shorter trees with faster searches.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Nobody really knows what the B in B-tree stands for. This structure was defined in 1972 by Rudolf Bayer and Edward McCreight, but no explanation was given for the term, so you can choose your own interpretation: some proposals have been “balanced,” “broad,” “bushy,” and, obviously, “Bayer.”</i></p>&#13;
<p class="TX">The definition (and implementation) for a B-tree varies among different sources and authors, so let’s make clear what is used here. A B-tree of order <i>m</i> satisfies the following properties:</p>&#13;
<ul class="ul">&#13;
<li class="ListBullet">Every node has <i>p</i> &lt; <i>m</i> keys, in ascending order, and <i>p</i> + 1 children.</li>&#13;
<li class="ListBullet">Every node but the root must have at least <i>m</i>/2 (rounded up) children, or in other words, all nodes (except the root) should be at least half full.</li>&#13;
<li class="ListBullet">The root should have at least one key.</li>&#13;
<li class="ListBullet">All leaves must be at the same level.</li>&#13;
</ul>&#13;
<p class="TX">The B-tree is structured in a fashion similar to a binary search tree: given any key in a node, all the children to its left will be smaller than the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_292" aria-label="292"/>key, and all the children to its right will be greater than it. For instance, you could have a node such as the one shown in <a href="chapter13.xhtml#fig13-7">Figure 13-7</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig13-7" src="../images/Figure13-7.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 13-7: A</span> <span class="SANS_Futura_Std_Book_Oblique_11">B-tree node, showing where keys are to be found</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In this case, the node has four keys, so five children. The first child, to the left of the 34 key, has keys less than 34; the child between 34 and 40 has keys between those two values, and so on, until the last child, the one to the right of the 60 key, has keys greater than that value. (These facts are what we’ll use to search in a B-tree; you’ll see the algorithm soon.) This structure is similar to binary search trees, except that now instead of a maximum of two children per node, we allow a greater number—and for actual implementations (such as an index for actual files in disk), much larger values are preferred in order to have a shorter height and thus faster access.</p>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2" id="sec11"><span id="h2-105"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Defining B-trees</span></h4>&#13;
<p class="TNI1">Let’s start in similar fashion as with binary search trees by defining the basic functions we’ll need:</p>&#13;
<pre id="pre-255"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> let ORDER = undefined;&#13;
&#13;
const newBTree = (order = 3) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if (ORDER === undefined) {&#13;
    ORDER = order;&#13;
  }&#13;
  return null;&#13;
};&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> const newNode = (&#13;
  newKeys = [null],&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> newPtrs = new Array(newKeys.length + 1).fill(null)&#13;
) =&gt; ({&#13;
  keys: newKeys,&#13;
  ptrs: newPtrs&#13;
});&#13;
&#13;
const isEmpty = (tree) =&gt; tree === null;&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation5">❺</span> const _tooBig = (tree, d = 0) =&gt; tree.keys.length + d &gt; ORDER – 1;&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation6">❻</span> const _tooSmall = (tree, d = 0) =&gt;&#13;
  tree.keys.length - d &lt; Math.ceil(ORDER / 2) – 1;</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_293" aria-label="293"/>You can define B-trees of any order, and we’ll use a variable <span class="SANS_TheSansMonoCd_W5Regular_11">ORDER</span> <span class="CodeAnnotation" aria-label="annotation1">❶</span> to store the one you want. The first time you create a B-tree <span class="CodeAnnotation" aria-label="annotation2">❷</span>, you’ll store the desired order (or 3, by default), so all future B-trees will have that order. (This decision begs the question: What if you want to have B-trees of <i>different</i> orders? See question 13.9.) The <span class="SANS_TheSansMonoCd_W5Regular_11">newNode()</span> function <span class="CodeAnnotation" aria-label="annotation3">❸</span> creates a new node with a single <span class="SANS_TheSansMonoCd_W5Regular_11">null</span> key by default, flanked by two null pointers; of course, this node will be “too empty,” unless <span class="SANS_TheSansMonoCd_W5Regular_11">ORDER</span> is small. Note, however, that if you provide an array of keys <span class="CodeAnnotation" aria-label="annotation4">❹</span>, some JavaScript trickery is used to generate (if needed) a corresponding array of null pointers, with one key more; can you see how this works?</p>&#13;
<p class="TX">Finally, a couple of auxiliary functions will come in handy. At times, you’ll need to test whether a node is oversized (or would be, if <span class="SANS_TheSansMonoCd_W5Regular_11">d</span> keys were added to it), with more keys than allowed <span class="CodeAnnotation" aria-label="annotation5">❺</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">_tooBig()</span> will check that. Similarly, <span class="SANS_TheSansMonoCd_W5Regular_11">_tooSmall()</span> determines whether the node is undersized (or would be, if <span class="SANS_TheSansMonoCd_W5Regular_11">d</span> keys were removed from it) and doesn’t have enough keys <span class="CodeAnnotation" aria-label="annotation6">❻</span>. (Be careful not to apply <span class="SANS_TheSansMonoCd_W5Regular_11">_tooSmall()</span> to the root—the only node that is allowed to be smaller.) You’ll use those two methods when adding or removing keys.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2" id="sec12"><span id="h2-106"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Finding a Key in a B-tree</span></h4>&#13;
<p class="TNI1">Let’s start with the most basic algorithm: searching for a key. In a sense, the algorithm is similar to searching a binary search tree; you look for the key, and if you don’t find it in a node, you determine where to continue searching. Consider some examples. Assume you have the following B-tree of order 3; null links are represented with blank boxes, as shown in <a href="chapter13.xhtml#fig13-8">Figure 13-8</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig13-8" src="../images/Figure13-8.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 13-8: A B-tree of order 3</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">If you were looking for 22, that would be easy: it’s in the root, so there’s nothing to do. You can make it more complex and look for 56, as shown in <a href="chapter13.xhtml#fig13-9">Figure 13-9</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig13-9" src="../images/Figure13-9.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 13-9: The search process for key 56</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_294" aria-label="294"/>Start at the root, and since 56 &gt; 22, follow the root’s last pointer to a new node. There, you find that 56 should be between 34 and 60, so follow the middle pointer to yet another node. In that one, you finally find 56, so the search is successful.</p>&#13;
<p class="TX">What about searching for a key that isn’t in the tree? If you had been looking for 38, everything would be the same as for 56, but upon not finding 38 in the node with 40 and 56, you would have continued down the first pointer of the node (since 38 &lt; 40), but finding it null, the search would have been unsuccessful.</p>&#13;
<p class="TX">Now on to the algorithms. Every time you get to a node, you need to see whether the key you want is there; if not, the algorithm tells you what pointer to follow to the next level; there is an auxiliary function for this:</p>&#13;
<pre id="pre-256"><code>const _findIndex = (tree, key) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> const p = tree.keys.findIndex((k) =&gt; k &gt;= key);&#13;
  return p === -1 ? tree.keys.length : p;&#13;
};</code></pre>&#13;
<p class="TX">This looks for the first element in the <span class="SANS_TheSansMonoCd_W5Regular_11">keys</span> array that is greater than or equal to the key you are searching <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If no key fits, <span class="SANS_TheSansMonoCd_W5Regular_11">findIndex()</span> returns <span class="SANS_TheSansMonoCd_W5Regular_11">-1</span>, so in that case, you return the index of the last element of <span class="SANS_TheSansMonoCd_W5Regular_11">ptrs</span> (you’ll see the reason for this tricky code soon enough):</p>&#13;
<pre id="pre-257"><code>const find = (tree, keyToFind) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (isEmpty(tree)) {&#13;
    return false;&#13;
  } else {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> const p = _findIndex(tree, keyToFind);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> return tree.keys[p] === keyToFind || find(tree.ptrs[p], keyToFind);&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">If you are searching for a key and arrive at an empty node <span class="CodeAnnotation" aria-label="annotation1">❶</span>, the key obviously isn’t there. Otherwise, the <span class="SANS_TheSansMonoCd_W5Regular_11">_findIndex()</span> method finds the first key that isn’t less than the searched-for key <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If the key is actually equal to the value you want to find <span class="CodeAnnotation" aria-label="annotation3">❸</span>, you are done; otherwise, continue the search at the corresponding pointer. This is why you had <span class="SANS_TheSansMonoCd_W5Regular_11">_findIndex()</span> return the last position in the array—because that’s the link you need to follow when the key you want to find is greater than all the keys in the node.</p>&#13;
<p class="TX">It may seem like a backward step to do a linear search when you have already seen better ways of searching; see question 13.7 for some ideas on better ways of searching.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h4 class="H2" id="sec13"><span id="h2-107"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Traversing a B-tree</span></h4>&#13;
<p class="TNI1">We can define the equivalent to the inorder traversal for binary trees, which means visiting all keys in ascending order. Since each node has several keys, you need to work carefully. <a href="chapter13.xhtml#fig13-10">Figure 13-10</a> shows how to do this.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_295" aria-label="295"/>&#13;
<figure class="IMG"><img class="img5" id="fig13-10" src="../images/Figure13-10.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 13-10: A traversal for B-trees, similar to inorder for binary trees</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This version of inorder should visit keys in ascending order, so with the node in <a href="chapter15.xhtml#fig15-9">Figure 15-9</a>, start with the first (leftmost) child, then visit the node’s first key, followed by the second child, then the second key, then the third child, then the third key, and so on, ending after having traversed the rightmost child.</p>&#13;
<p class="TX">Here’s a version of it at work:</p>&#13;
<pre id="pre-258"><code>const inOrder = (tree, visit = (x) =&gt; console.log(x)) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (!isEmpty(tree)) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> tree.ptrs.forEach((p, i) =&gt; {&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> inOrder(p, visit);&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> i in tree.keys &amp;&amp; visit(tree.keys[i]);&#13;
    });&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">If the current node is empty <span class="CodeAnnotation" aria-label="annotation1">❶</span>, do nothing; otherwise, do a loop <span class="CodeAnnotation" aria-label="annotation2">❷</span>, alternating between traversing a child <span class="CodeAnnotation" aria-label="annotation3">❸</span> and visiting a key <span class="CodeAnnotation" aria-label="annotation4">❹</span>. For the latter, remember that there’s one fewer key than children. This code uses the <span class="SANS_TheSansMonoCd_W5Regular_11">condition &amp;&amp; expression</span> syntax as a shortcut to an <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> or ternary operator: <span class="SANS_TheSansMonoCd_W5Regular_11">expression</span> is evaluated if and only if <span class="SANS_TheSansMonoCd_W5Regular_11">condition</span> is true; in this case, visit a key if and only if the corresponding index is within the array of keys.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h4 class="H2" id="sec14"><span id="h2-108"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Adding a Key to a B-tree</span></h4>&#13;
<p class="TNI1">Now consider how to add a key. If you want to add a key to a node that has enough empty space, it’s straightforward. The problem is trying to add a key to a node that’s already too full to allow another key. Consider both cases using the B-tree of order 3 from earlier as an example (see <a href="chapter13.xhtml#fig13-11">Figure 13-11</a>).</p>&#13;
<figure class="IMG"><img class="img5" id="fig13-11" src="../images/Figure13-11.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 13-11: A B-tree into which you’ll add some new keys</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_296" aria-label="296"/>First, try to add a 66 key. After searching, you decide it should go with the 63 key, and since that node has enough space, there’s no extra work (see <a href="chapter13.xhtml#fig13-12">Figure 13-12</a>).</p>&#13;
<figure class="IMG"><img class="img5" id="fig13-12" src="../images/Figure13-12.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 13-12: Adding a key at a node with space causes no problems.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Now make things more complicated, and add a 10 key. That’s a problem, because the bottom-left node has no more space. First, you can let it grow beyond its maximum size (see <a href="chapter13.xhtml#fig13-13">Figure 13-13</a>).</p>&#13;
<figure class="IMG"><img class="img5" id="fig13-13" src="../images/Figure13-13.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 13-13: Adding a key at a node at limit requires splitting the node and rotating a key up.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Now you need to split the oversized node in two and make its middle key go up to the parent node. Fortunately, that node has space, so you are done (see <a href="chapter13.xhtml#fig13-14">Figure 13-14</a>).</p>&#13;
<figure class="IMG"><img class="img5" id="fig13-14" src="../images/Figure13-14.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 13-14: After the split, the B-tree structure is okay again.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">If you try to add a 78 key, this node would split twice: first, the 66 key would go up to the 34-60 node, and then that node would split, sending its middle key (60) to its parent. This is the only way a B-tree can grow: if its root needs splitting, it adds a new level.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_297" aria-label="297"/>Take a look at the code and see what happens at the root level:</p>&#13;
<pre id="pre-259"><code>const add = (tree, keyToAdd) =&gt; {&#13;
  if (isEmpty(tree)) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> return newNode([keyToAdd]);&#13;
  } else {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> _add(tree, keyToAdd);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> if (_tooBig(tree)) {&#13;
      const m = Math.ceil(ORDER / 2);&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> const left = newNode(tree.keys.slice(0, m - 1), tree.ptrs.slice(0, m));&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> const right = newNode(tree.keys.slice(m), tree.ptrs.slice(m));&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> tree.keys = [tree.keys[m – 1]];&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> tree.ptrs = [left, right];&#13;
    }&#13;
    return tree;&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">The easiest case is if the tree is empty <span class="CodeAnnotation" aria-label="annotation1">❶</span>, because then all you need to do is create a new node with the new key and a couple of <span class="SANS_TheSansMonoCd_W5Regular_11">null</span> pointers. Otherwise, add the key somewhere in the tree <span class="CodeAnnotation" aria-label="annotation2">❷</span> (using an auxiliary recursive <span class="SANS_TheSansMonoCd_W5Regular_11">_add()</span> method, which will see it immediately), and check whether the root became too big <span class="CodeAnnotation" aria-label="annotation3">❸</span>. If so, create two new nodes <span class="CodeAnnotation" aria-label="annotation4">❹</span> <span class="CodeAnnotation" aria-label="annotation5">❺</span>, each with half the keys and pointers, leaving the middle key at the root <span class="CodeAnnotation" aria-label="annotation6">❻</span>, which will have the two new nodes as children <span class="CodeAnnotation" aria-label="annotation7">❼</span>.</p>&#13;
<p class="TX">But how is the new key actually added, and what’s the <span class="SANS_TheSansMonoCd_W5Regular_11">_add()</span> method missing earlier? Here’s the code:</p>&#13;
<pre id="pre-260"><code>const _add = (tree, keyToAdd) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> const p = _findIndex(tree, keyToAdd);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if (isEmpty(tree.ptrs[p])) {&#13;
    tree.keys.splice(p, 0, keyToAdd);&#13;
    tree.ptrs.splice(p, 0, null);&#13;
  } else {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> const child = tree.ptrs[p];&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> _add(child, keyToAdd);&#13;
&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> if (_tooBig(child)) {&#13;
      // Child too big? Split it&#13;
      const m = Math.ceil(ORDER / 2);&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> const newChild = newNode(child.keys.slice(m), child.ptrs.slice(m));&#13;
&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> tree.keys.splice(p, 0, child.keys[m – 1]);&#13;
      tree.ptrs.splice(p + 1, 0, newChild);&#13;
&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation8">❽</span> child.keys.length = m – 1;&#13;
      child.ptrs.length = m;&#13;
    }&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_298" aria-label="298"/>First find in which subtree of the current node to add the new key <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If the subtree doesn’t exist (the corresponding pointer is <span class="SANS_TheSansMonoCd_W5Regular_11">null</span>), you are at the bottom level and can simply add the key there <span class="CodeAnnotation" aria-label="annotation2">❷</span>; no need to do anything else. (Of course, the bottom node may have grown too large, but that will be checked by its parent, which will fix the situation if needed.) If there is a subtree <span class="CodeAnnotation" aria-label="annotation3">❸</span>, recursively add the new key into it <span class="CodeAnnotation" aria-label="annotation4">❹</span> and then check whether the child grew too large <span class="CodeAnnotation" aria-label="annotation5">❺</span>. If so, you need to add a new node that will get the second half of the keys and pointers of the outsized node <span class="CodeAnnotation" aria-label="annotation6">❻</span>; the middle key and pointer to the new node will go up to the parent <span class="CodeAnnotation" aria-label="annotation7">❼</span>, and you’ll leave the first half of the keys and pointers in the original child <span class="CodeAnnotation" aria-label="annotation8">❽</span>. The code isn’t particularly hard to understand, but handling indices and arrays properly requires care.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h4 class="H2" id="sec15"><span id="h2-109"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Removing a Key from a B-tree</span></h4>&#13;
<p class="TNI1">Adding a key introduces the complexity that sometimes a node grows too big, and dealing with that requires either rotating or moving a key up. Removing a key also causes difficulties, because nodes may become too empty and need to get keys from other nodes or eventually require a key from the parent, which may make the whole B-tree shorter; in the same way that additions may cause it to grow taller, removals may lower its height.</p>&#13;
<p class="TX">There are several possible cases to study, but here are two: removing a key that isn’t in a leaf and removing a key that is in a leaf.</p>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h5 class="H3" id="sec16"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Removing a Key from a Nonleaf Node</span></h5>&#13;
<p class="TNI1">Removing a key in an internal node is easy; it’s the same as for binary search trees. Replace the key with the one that follows it in ascending order and then remove <i>that</i> key (which will be at a leaf) from the tree. For instance, assume you want to remove the 22 key from the tree in <a href="chapter13.xhtml#fig13-15">Figure 13-15</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig13-15" src="../images/Figure13-15.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 13-15: A B-tree from which you’ll remove a key not from a leaf—in this case, the 22</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You first need to locate the key following 22, so follow the link after 22 and then continue following the leftmost link until you get to a leaf to find the 24 key (see <a href="chapter13.xhtml#fig13-16">Figure 13-16</a>).</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_299" aria-label="299"/>&#13;
<figure class="IMG"><img class="img5" id="fig13-16" src="../images/Figure13-16.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 13-16: To remove 22, first locate the following (greater) key, which is 24 in this case.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Now, replace the key to be removed (22) with the following key (24) and proceed with the logic to remove a key from a leaf node (marked in gray in <a href="chapter13.xhtml#fig13-17">Figure 13-17</a>).</p>&#13;
<figure class="IMG"><img class="img5" id="fig13-17" src="../images/Figure13-17.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 13-17: After moving 24 to the place of the 22, you now need to remove the 24 from the leaf node.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">With this method, you always have to remove keys from a leaf node. Here’s how to do it.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h5 class="H3" id="sec17"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Removing a Key from a Leaf Node</span></h5>&#13;
<p class="TNI1">After finding the key to remove and checking that it’s in a leaf node, you have two possible cases: either the node is “full enough,” so removing the key won’t make it too empty, or the node is at its minimum size, which means removing the key will leave it undersized.</p>&#13;
<p class="TX">The first case is easy to handle: continuing the example from the previous section, to remove the 24 key, just remove it from the node, which has enough keys (see <a href="chapter13.xhtml#fig13-18">Figure 13-18</a>).</p>&#13;
<figure class="IMG"><img class="img5" id="fig13-18" src="../images/Figure13-18.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 13-18: If after removal the leaf node still has enough keys, you’re done.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_300" aria-label="300"/>But consider a more complicated case: What happens if you want to remove the 12 key? You have a problem, because the corresponding node would end up with not enough keys, as shown in <a href="chapter13.xhtml#fig13-19">Figure 13-19</a>. (In this case, the node gets emptied, because you are dealing with a B-tree of order 3; in a B-tree of a higher order, the node would still have some keys, but just not enough.)</p>&#13;
<figure class="IMG"><img class="img5" id="fig13-19" src="../images/Figure13-19.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 13-19: An attempt to rotate keys from a sibling to reorganize the</span> <span class="SANS_Futura_Std_Book_Oblique_11">B-tree</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The solution here depends on the node’s siblings. You can try to borrow keys from one of them and check whether it’s possible to borrow from the left or right sibling; both siblings are symmetrical. In this case, the left sibling has enough keys (4 and 9), so you borrow one from it. The 9 key goes into the parent node, and the 11 key is rotated down into the leaf (see <a href="chapter13.xhtml#fig13-20">Figure 13-20</a>).</p>&#13;
<figure class="IMG"><img class="img5" id="fig13-20" src="../images/Figure13-20.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 13-20: A rotation fixed the problem, so you’re done.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You have only one pending case to deal with: What happens if no sibling has keys to share? In that scenario, merge the node with a sibling, borrowing one key from the parent. This step may cause it to become undersized as well and need to be fixed. In this example, say you want to remove the 11 key. Merge it with its sibling and borrow the 9 key, reaching the situation shown in <a href="chapter13.xhtml#fig13-21">Figure 13-21</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig13-21" src="../images/Figure13-21.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 13-21: The leaf node was fixed, but a problem appears above it.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_301" aria-label="301"/>To solve the new undersized node situation, you again turn to the borrowing concept, rotate keys around, and the final tree would look like <a href="chapter13.xhtml#fig13-22">Figure 13-22</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig13-22" src="../images/Figure13-22.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 13-22: A new rotation fixes the problem.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">When doing this sharing and joining, it’s possible that eventually the tree will grow shorter in height. If you removed the 4 and 9 keys in succession, you’d arrive at the tree in <a href="chapter13.xhtml#fig13-23">Figure 13-23</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig13-23" src="../images/Figure13-23.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 13-23: Removing several keys can make a B-tree eventually grow shorter.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Can you do the intermediate steps?</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h5 class="H3" id="sec18"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Implementing the remove() Method</span></h5>&#13;
<p class="TNI1">Now that you’ve seen all the strategies to apply, here’s how to code them. Dealing with a removal at the root level is short:</p>&#13;
<pre id="pre-261"><code>const remove = (tree, keyToRemove) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> tree = _remove(tree, keyToRemove);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> return (isEmpty(tree) || tree.keys.length === 0) &amp;&amp; !isEmpty(tree.ptrs[0])&#13;
    ? tree.ptrs[0]&#13;
    : tree;&#13;
};</code></pre>&#13;
<p class="TX">First use a <span class="SANS_TheSansMonoCd_W5Regular_11">_remove()</span> function to remove the key from the tree recursively <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If the tree is empty, or if the root node has been left with no keys (because it had a single key and had to pass it down when its two children got joined), but the node still has one non-null child (the root might already be at the bottom level, without children) <span class="CodeAnnotation" aria-label="annotation2">❷</span>, return that child. This means the B-tree has become shorter.</p>&#13;
<p class="TX">Now start the actual key removal process:</p>&#13;
<pre id="pre-262"><code>const _remove = (tree, keyToRemove) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (!isEmpty(tree)) {&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_302" aria-label="302"/>  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> const p = _findIndex(tree, keyToRemove);&#13;
    if (tree.keys[p] === keyToRemove) {&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> if (isEmpty(tree.ptrs[p])) {&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> tree.keys.splice(p, 1);&#13;
        tree.ptrs.splice(p, 1);&#13;
      } else {&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> const nextKey = _findMin(tree.ptrs[p + 1]);&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> tree.keys[p] = nextKey;&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> _remove(tree.ptrs[p + 1], nextKey);&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation8">❽</span> _fixChildIfSmall(tree, p + 1);&#13;
      }&#13;
    } else {&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation9">❾</span> _remove(tree.ptrs[p], keyToRemove);&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation10">❿</span> _fixChildIfSmall(tree, p);&#13;
    }&#13;
  }&#13;
  return tree;&#13;
};</code></pre>&#13;
<p class="TX">Start as when doing a search: if the tree is empty, you’re done <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Otherwise, see whether the current node includes the key you want to remove <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If you find the key and are at the bottom level <span class="CodeAnnotation" aria-label="annotation3">❸</span>, just remove that key and its corresponding pointer <span class="CodeAnnotation" aria-label="annotation4">❹</span>; otherwise, if you are at a higher level, find the next key in ascending order <span class="CodeAnnotation" aria-label="annotation5">❺</span> using <span class="SANS_TheSansMonoCd_W5Regular_11">_findMin()</span> and put it in place of the original key you wanted to remove <span class="CodeAnnotation" aria-label="annotation6">❻</span>. Finish by removing the next key from the tree <span class="CodeAnnotation" aria-label="annotation7">❼</span> and fixing its size <span class="CodeAnnotation" aria-label="annotation8">❽</span> if needed (because the child became too small, with not enough keys in it). If the key wasn’t in the node, go down to the next level to remove it <span class="CodeAnnotation" aria-label="annotation9">❾</span> and fix the size if necessary <span class="CodeAnnotation" aria-label="annotation10">❿</span>.</p>&#13;
<p class="TX">How do you find the next key? You have seen similar methods before, and for B-trees, the code is also quite short:</p>&#13;
<pre id="pre-263"><code>const _findMin = (tree) =&gt;&#13;
  isEmpty(tree.ptrs[0]) ? tree.keys[0] : _findMin(tree.ptrs[0]);</code></pre>&#13;
<p class="TX">If there’s no leftmost subtree, return the first key in the node; otherwise, go down to the subtree and look for the minimum there.</p>&#13;
<p class="TX">The last method is <span class="SANS_TheSansMonoCd_W5Regular_11">_fixChildIfSmall()</span>, which deals with all the cases mentioned before and properly rebalances nodes. The following includes four distinct cases, but the logic for each of them is short:</p>&#13;
<pre id="pre-264"><code>const _fixChildIfSmall = (tree, p) =&gt; {&#13;
  const child = tree.ptrs[p];&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (_tooSmall(child)) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if (p &gt; 0 &amp;&amp; !_tooSmall(tree.ptrs[p - 1], 1)) {&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> const leftChild = tree.ptrs[p – 1];&#13;
      child.keys.unshift(tree.keys[p - 1]);&#13;
      child.ptrs.unshift(leftChild.ptrs.pop());&#13;
      tree.keys[p - 1] = leftChild.keys.pop();&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span>} else if (p &lt; tree.keys.length &amp;&amp; !_tooSmall(tree.ptrs[p + 1], 1)) {&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> const rightChild = tree.ptrs[p + 1];&#13;
      child.keys.push(tree.keys[p]);&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_303" aria-label="303"/>      child.ptrs.push(rightChild.ptrs.shift());&#13;
      tree.keys[p] = rightChild.keys.shift();&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span>} else if (p &gt; 0) {&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> const leftChild = tree.ptrs[p – 1];&#13;
      leftChild.keys.push(tree.keys[p - 1], . . .child.keys);&#13;
      leftChild.ptrs.push(...child.ptrs);&#13;
      tree.keys.splice(p - 1, 1);&#13;
      tree.ptrs.splice(p, 1);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation8">❽</span>} else {&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation9">❾</span> const rightChild = tree.ptrs[p + 1];&#13;
      rightChild.keys.unshift(...child.keys, tree.keys[p]);&#13;
      rightChild.ptrs.unshift(...child.ptrs);&#13;
      tree.keys.splice(p, 1);&#13;
      tree.ptrs.splice(p, 1);&#13;
    }&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">First, just verify whether the child is still big enough <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and if so, nothing needs to be done. Then, check whether the child has a left sibling that won’t become too empty if you take one key from it <span class="CodeAnnotation" aria-label="annotation2">❷</span>; if this is the case, do a rotation of keys as described earlier <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Alternatively, check whether the child has a right sibling with enough keys <span class="CodeAnnotation" aria-label="annotation4">❹</span>, and if so, do the rotation with that sibling <span class="CodeAnnotation" aria-label="annotation5">❺</span>. If no rotation was possible and if there is a left sibling <span class="CodeAnnotation" aria-label="annotation6">❻</span>, join it to the child <span class="CodeAnnotation" aria-label="annotation7">❼</span>; otherwise, there must be a right sibling <span class="CodeAnnotation" aria-label="annotation8">❽</span>, so join the child with it instead <span class="CodeAnnotation" aria-label="annotation9">❾</span>. Again, the cases are not complex, but take care when manipulating indices; it’s easy to get things wrong.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h4 class="H2" id="sec19"><span id="h2-110"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Considering Performance for B-trees</span></h4>&#13;
<p class="TNI1">A B-tree ensures that every node (apart from the root) will have a minimum number of children, so it grows exponentially as levels are added, meaning that the height is logarithmic; all paths from the root to another key will be <i>O</i>(log <i>n</i>), so all algorithms turn out to be logarithmic, as shown in <a href="chapter13.xhtml#tab13-1">Table 13-1</a>.</p>&#13;
&#13;
<table class="table">&#13;
<caption><p class="TT" id="tab13-1"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 13-1:</span></span> <span class="SANS_Futura_Std_Book_11">Performance of Operations for B-trees</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Performance</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Add</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Remove</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Find</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Traverse</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">B-trees ensure good performance, so they’re widely used, most notably to create indices for databases; in fact, the B-tree is the default structure for MySQL and PostgreSQL.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_304" aria-label="304"/>&#13;
<h3 class="H1" id="sec20"><span id="h1-65"/><span class="SANS_Futura_Std_Bold_B_11">Red-Black Trees</span></h3>&#13;
<p class="TNI1">B-trees are powerful, but can be a bit complex to implement. However, you can work with them using a binary representation that produces the same results in a different way. In particular, we’ll use B-trees of order 3 but we’ll represent them in a binary tree style. The resulting <i>red-black trees</i> have very good performance and are used, among other places, in the Linux kernel to track directory entries, virtual memory, scheduling, and more. In this section we’ll look at left-leaning red-black trees, which are a variant created by Robert Sedgewick and are easier to implement than the original red-black tree.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>B-trees of order 3 are also known as 2-3 trees, alluding to the fact that their nodes have either two or three children. In the same way, B-trees of order 4 are called 2-3-4 trees or 2-4 trees.</i></p>&#13;
<p class="TX">Consider the nodes in a red-black tree as 2-nodes (with two children) or 3-nodes (with three children). You can represent 2-nodes as common nodes in any binary tree, but here you’ll add an extra node to represent a 3-node (see <a href="chapter13.xhtml#fig13-24">Figure 13-24</a>).</p>&#13;
<figure class="IMG"><img class="img5" id="fig13-24" src="../images/Figure13-24.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 13-24: A red-black node is actually equivalent to a B-tree of order 3.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The standard nodes are black, and the extra nodes added for 3-nodes are red, which allow you to distinguish 2-nodes from 3-nodes. You could also say that links between nodes are black if they point to a black node or red if they point to a red node.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Since this book is black and white, the “red” nodes will be gray with black text and the “black” nodes will be black with white text.</i></p>&#13;
<p class="TX">Because of the way representation was defined, red nodes are always to the left; in addition, a red node can never be connected to another red node (or, alternatively, you can’t have two red links in a row). Also, the root is black, and empty trees (leaves at the bottom) are also black.</p>&#13;
<p class="TX">Now, let’s transform the B-tree we worked with earlier into a red-black tree (see <a href="chapter13.xhtml#fig13-25">Figure 13-25</a>).</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_305" aria-label="305"/>&#13;
<figure class="IMG"><img class="img5" id="fig13-25" src="../images/Figure13-25.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 13-25: A</span> <span class="SANS_Futura_Std_Book_Oblique_11">B-tree that will be converted into a red-black tree</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">All 2-children nodes become black nodes and 3-children nodes add a new red node, as shown in <a href="chapter13.xhtml#fig13-26">Figure 13-26</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig13-26" src="../images/Figure13-26.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 13-26: The equivalent red-black tree</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You now have a binary search tree, which means you can use the earlier key-searching logic without any changes, but you do need to make adjustments when adding or removing keys.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Because of their B-tree origin, red-black trees have another important property. All paths from the root to a leaf have the same number of black nodes and up to that same number of red nodes. This property is called black balance, and we’ll often allude to it in this book.</i></p>&#13;
<p class="TX">Next, let’s look at how to implement these red-black trees, but keep in mind their equivalence to B-trees of order 3, because algorithms will make much more sense that way, essentially doing the same type of work from earlier in this chapter.</p>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
&#13;
<h4 class="H2" id="sec21"><span id="h2-111"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Representing Red-Black Trees</span></h4>&#13;
<p class="TNI1">Red-black trees are just binary search trees, so you can start with some functions you already have, such as the <span class="SANS_TheSansMonoCd_W5Regular_11">find()</span> method and others that need no changes. For these new trees, you need a couple of constants and a method to flip a node’s color (you’ll use these frequently):</p>&#13;
<pre id="pre-265"><code>const RED = "RED";&#13;
const BLACK = "BLACK";&#13;
const flip = (color) =&gt; (color === RED ? BLACK : RED);</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_306" aria-label="306"/>Now start defining the new tree:</p>&#13;
<pre id="pre-266"><code>const newRedBlackTree = () =&gt; null;&#13;
&#13;
const newNode = (key) =&gt; ({&#13;
  key,&#13;
  left: null,&#13;
  right: null,&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> color: RED&#13;
});&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> const _isBlack = (node) =&gt; isEmpty(node) || node.color === BLACK;&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> const _isRed = (node) =&gt; !_isBlack(node);</code></pre>&#13;
<p class="TX">To represent a node’s color, add a <span class="SANS_TheSansMonoCd_W5Regular_11">color</span> attribute <span class="CodeAnnotation" aria-label="annotation1">❶</span>, which is red for new nodes, although that color may be changed to black later. You also add a couple of auxiliary methods to test a node’s color <span class="CodeAnnotation" aria-label="annotation2">❷</span> <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Notice you are defining that an empty tree is black.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
&#13;
<h4 class="H2" id="sec22"><span id="h2-112"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Adding a Key to a Red-Black Tree</span></h4>&#13;
<p class="TNI1">You are essentially just adding a key to a B-tree, which was described earlier. Always add nodes as red, which won’t affect the black balance of the tree, but you can possibly fix their color later or make other changes. Also take care that the root is always black and that all the properties of red-black trees are satisfied.</p>&#13;
<p class="TX">To implement the algorithm, you’ll allow (for a while) problems like having right red links or two consecutive red links, but you’ll use rotations and color changes to fix those situations before you are done. Just add the key and worry about fixing problems later:</p>&#13;
<pre id="pre-267"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const _add = (tree, keyToAdd) =&gt; {&#13;
  if (isEmpty(tree)) {&#13;
    return newNode(keyToAdd);&#13;
  } else {&#13;
    const side = keyToAdd &lt;= tree.key ? "left" : "right";&#13;
    tree[side] = _add(tree[side], keyToAdd);&#13;
<b>  </b><span class="Code_CodeAnnotation" aria-label="annotation2">❷</span><b> return _fixUp(tree);</b>&#13;
  }&#13;
};&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> const add = (tree, keyToAdd) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> const newRoot = _add(tree, keyToAdd);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> newRoot.color = BLACK;&#13;
  return newRoot;&#13;
};</code></pre>&#13;
<p class="TX">Add the key with an auxiliary <span class="SANS_TheSansMonoCd_W5Regular_11">_add()</span> method <span class="CodeAnnotation" aria-label="annotation1">❶</span>, which is the same algorithm as for common binary search trees with only one innovation, a call to a <span class="SANS_TheSansMonoCd_W5Regular_11">_fixUp()</span> function <span class="CodeAnnotation" aria-label="annotation2">❷</span> that takes care of restoring the structure if there are <span role="doc-pagebreak" epub:type="pagebreak" id="pg_307" aria-label="307"/>any problems in it. The addition itself is done <span class="CodeAnnotation" aria-label="annotation3">❸</span>; then first use <span class="SANS_TheSansMonoCd_W5Regular_11">_add()</span> to add the new key to the tree <span class="CodeAnnotation" aria-label="annotation4">❹</span> and then make sure the root is black <span class="CodeAnnotation" aria-label="annotation5">❺</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
&#13;
<h4 class="H2" id="sec23"><span id="h2-113"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Restoring a Red-Black Tree Structure</span></h4>&#13;
<p class="TNI1">If the red-black structure has been damaged somehow, the trick to restoring it lies in the <span class="SANS_TheSansMonoCd_W5Regular_11">_fixUp()</span> method. Remember a new node is always colored red. The possible cases when adding a new key depend on whether the new key ends up forming part of a 2-node or a 3-node.</p>&#13;
<p class="TX">The first situation is simple: if the new child is the left child of a black node, you just turned a 2-node into a 3-node, and since the red child is on the left of the root, everything’s okay. Call this case (a). Otherwise, if the new child is to the right of the black root, you can fix it with a rotation. Call this case (b). <a href="chapter13.xhtml#fig13-27">Figure 13-27</a> shows both cases; N is the newly added key, and R is the original root for the 2-node.</p>&#13;
<figure class="IMG"><img class="img5" id="fig13-27" src="../images/Figure13-27.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 13-27: A rotation is needed if adding a node to the right.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">For case (a), nothing needs to be done, and a rotation to the left solves case (b). In both situations, the black balance of the whole hasn’t been affected. You didn’t add any black links, so everything’s still fine. Also, notice that the N node, originally red, has turned black.</p>&#13;
<p class="TX">The more complex case happens when you add the new key to an existing 2-node (thus creating a 3-node), because in this case, all situations are wrong. The (relatively) easiest case to fix is when the new key becomes the rightmost key in the 3-node, as shown in <a href="chapter13.xhtml#fig13-28">Figure 13-28</a>. Call this case (c).</p>&#13;
<figure class="IMG"><img class="img5" id="fig13-28" src="../images/Figure13-28.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 13-28: You can fix adding a new key to a 2-node tree by flipping colors, but new problems may appear above it.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Here, a quick solution is available: just flip the three nodes’ colors. But notice that doing so will send a red link up the tree, which may require further recursive fixing. Also, verify that the black balance of the tree was maintained, so the fix is good.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_308" aria-label="308"/>The next case in terms of complexity is adding the newest key to the left of the leftmost one in a 3-node. Call this case (d); you need two steps to solve it, as shown in <a href="chapter13.xhtml#fig13-29">Figure 13-29</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig13-29" src="../images/Figure13-29.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 13-29: Adding a child to the left of a left child can also be solved with rotations.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">If the new key is the lowest key in a 3-node, you have two left red children in a row. Start by doing a right rotation at the root, and that will leave you with the previous case (black root, two red children), so a final color flip will again solve the problem, although you may still need more recursive fixes.</p>&#13;
<p class="TX">The final case (e) is the most complex. Add a new key that ends as the middle key, placed between the two existing keys in a 3-node, as shown in <a href="chapter13.xhtml#fig13-30">Figure 13-30</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig13-30" src="../images/Figure13-30.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 13-30: You also can fix adding a child to the right of a left child with rotations plus color-flipping.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In this case, you end with a red node to the right of another red node, which is a no-no. You can solve the issue by starting a rotation to the left, which leaves you with a situation you’ve already dealt with, and finish with another rotation, this time to the right, to get a scenario you’ve seen twice before (black root with two red children), so a final color flip solves everything.</p>&#13;
<p class="TX">Take a look at the rotations code, which is exactly the same as when we studied AVL trees in <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span>, except we don’t need to maintain a <span class="SANS_TheSansMonoCd_W5Regular_11">height</span> attribute:</p>&#13;
<pre id="pre-268"><code>const _rotate = (tree, side) =&gt; {&#13;
  const otherSide = side === "left" ? "right" : "left";&#13;
&#13;
  const auxTree = tree[side];&#13;
  tree[side] = auxTree[otherSide];&#13;
  auxTree[otherSide] = tree;&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_309" aria-label="309"/><b>  auxTree.color = auxTree[otherSide].color;</b>&#13;
<b>  auxTree[otherSide].color = RED;</b>&#13;
&#13;
  return auxTree;&#13;
};</code></pre>&#13;
<p class="TX">The only additions are the two lines in bold that exchange colors.</p>&#13;
<p class="TX">Now we’ll delve into the far more interesting code that applies all the fixes described (note that we’ll also use this code for removals; the same logic applies there):</p>&#13;
<pre id="pre-269"><code>const _fixUp = (tree) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (_isRed(tree.right)) {&#13;
    tree = _rotate(tree, "right");&#13;
  }&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if (_isRed(tree.left) &amp;&amp; _isRed(tree.left.left)) {&#13;
    tree = _rotate(tree, "left");&#13;
  }&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> if (_isRed(tree.left) &amp;&amp; _isRed(tree.right)) {&#13;
    _flipColors(tree);&#13;
  }&#13;
&#13;
  return tree;&#13;
};</code></pre>&#13;
<p class="TX">If the node you’re looking at has a red right child, do a rotation to the left <span class="CodeAnnotation" aria-label="annotation1">❶</span>, which solves case (b) and is the first step for cases (c) and (e), which will be completed later, when you move up recursively. If you have a left red child and a left red grandchild <span class="CodeAnnotation" aria-label="annotation2">❷</span>, this is case (d); you could also have arrived here after doing a rotation in case (e). Finally, after the previous changes, either you have fixed everything—if you were originally in cases (a) or (b)—or you still need to flip the color <span class="CodeAnnotation" aria-label="annotation3">❸</span>, and you’re done.</p>&#13;
<p class="TX">Consider another takeaway from this algorithm: color flipping and rotations to the left or to the right all retain the black balance in a tree, so if you start with a red-black tree and apply only those transformations, you’ll necessarily end with a red-black tree. This concept is important for additions, but you’ll also apply it for removals.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
&#13;
<h4 class="H2" id="sec24"><span id="h2-114"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Removing a Key from a Red-Black Tree</span></h4>&#13;
<p class="TNI1">Removing a key from a red-black tree is probably the most complex algorithm discussed in this book. (Many textbooks and other resources tend to omit it or, at most, only hint at it.) While adding a key is not too complex, being basically the same algorithm as for common binary search trees (plus some logic to ascertain that certain constraints are being kept), deletion requires a more difficult process with changes both up and down the tree.</p>&#13;
<p class="TX">You need to ensure that the key to be deleted is at the bottom of the tree as part of a 3-node (either the black or red node), because in that case, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_310" aria-label="310"/>removing it causes no problem. If the key to be deleted is the red one, just take it off. If you want to delete the black one, put the red key in its place, but change the color to black to maintain balance. <a href="chapter13.xhtml#fig13-31">Figure 13-31</a> shows both cases; X marks the key to be removed.</p>&#13;
<figure class="IMG"><img class="img5" id="fig13-31" src="../images/Figure13-31.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 13-31: Removing a red leaf is direct, and removing the black root is also easy to achieve.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Here’s the process. Either do rotations or flip colors as you go down, so at all times, the node at the root either is red or has a red left child, and you’ll tolerate (for now) having red right children or black nodes with two red children. When you find the key you want, replace it with the following key (as with binary search trees) and then proceed to remove that key from the tree. When you find it, one of the two cases illustrated in <a href="chapter13.xhtml#fig13-31">Figure 13-31</a> will apply, and you’ll effectively remove the key. Finally, apply the “fix-up” algorithm to go back to the root and take care of whatever problems might be left.</p>&#13;
<p class="TX">Remember the invariant to uphold: either the root or its left child must be black. Assume that at some moment in the algorithm, you have to go down to the left. Obviously, if the root is black, you just go down to the left (which is red). The invariant will persist, and now the root will be red. However, if the left child is black, there are two cases, depending on the color of the root’s right child’s left child. If that child is black, you can just flip colors, as <a href="chapter13.xhtml#fig13-32">Figure 13-32</a> shows (it doesn’t include other links or subtrees for clarity, so you can focus on the important nodes). The small triangle points to the new red node, which you’ll move left for the updated invariant.</p>&#13;
<figure class="IMG"><img class="img5" id="fig13-32" src="../images/Figure13-32.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 13-32: Color flipping adjusts this case.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In terms of the equivalent red-black tree, this is like joining nodes to create a 4-node, which you’ll need to split later.</p>&#13;
<p class="TX">If the root’s right child’s left child had been red, you would have needed more steps: flipping, rotating right, rotating left, and flipping again. But after all those transformations (all of which maintain black balance), you’ll be able to go down the left: the root’s left child’s left child will be red, and again the invariant is maintained. <a href="chapter13.xhtml#fig13-33">Figure 13-33</a> shows all the steps.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_311" aria-label="311"/>&#13;
<figure class="IMG"><img class="img1" id="fig13-33" src="../images/Figure13-33.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 13-33: The most complex case requires several rotations and color flips.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The initial tree is (a); (b) is the tree after flipping; (c) is after rotating the root’s right’s left child to the right; (d) is after rotating the root to the left; and finally, (e) is after flipping colors.</p>&#13;
<p class="TX">Considering the equivalent 2-3 tree, this deletion was like borrowing the 4-key from a 3-node to send the 3-key down to create a 3-node together with the 2-key. As before, you are maintaining black balance and there will be nothing to fix later.</p>&#13;
<p class="TX">Now consider the other case, which is when you want to move right. This case is similar to the ones you just explored, but it’s a tad simpler. If the root is black and its right child is red, just move to it with no fuss. If the root is red, its left child is black, and the root’s left child’s left child is also black, you can just flip colors. Take a look at the situation shown in <a href="chapter13.xhtml#fig13-34">Figure 13-34</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig13-34" src="../images/Figure13-34.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 13-34: Color-flipping also fixes the potential 4-node tree.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">As before, this solution is equivalent to joining nodes and creating a 4-node tree, which will need to be fixed later.</p>&#13;
<p class="TX">The last case occurs when you need to move right and the root’s left child’s left child is red. You need to flip colors, do a rotation, and flip colors again to re-establish the invariant, as shown in <a href="chapter13.xhtml#fig13-35">Figure 13-35</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_312" aria-label="312"/>&#13;
<figure class="IMG"><img class="img5" id="fig13-35" src="../images/Figure13-35.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 13-35: This complex case also requires both color flipping and rotations.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In this scenario, (a) is the initial situation, (b) shows the flipped colors, (c) is after rotating the root to the right, and (d) is after flipping colors again.</p>&#13;
<p class="TX">Again, in terms of the original 2-3 tree, this example is like moving the 2-key up from the 3-node where it was to the place of the 3-key, which joins the 4-key into a 3-node. However, note that the final situation is not valid (there’s a red child to the right), so this will need to be fixed later.</p>&#13;
<p class="TX">The complete algorithm is based directly on Sedgewick’s own code, but blame any errors on me. The simple part is this:</p>&#13;
<pre id="pre-270"><code>const remove = (tree, keyToRemove) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> const newRoot = _remove(tree, keyToRemove);&#13;
  if (!isEmpty(newRoot)) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> newRoot.color = BLACK;&#13;
  }&#13;
  return newRoot;&#13;
};</code></pre>&#13;
<p class="TX">First apply the algorithm described to actually remove the key from the tree <span class="CodeAnnotation" aria-label="annotation1">❶</span> and then make sure the root is black <span class="CodeAnnotation" aria-label="annotation2">❷</span> unless, obviously, there’s no key and the tree became empty.</p>&#13;
<p class="TX">The complex part is the <span class="SANS_TheSansMonoCd_W5Regular_11">_remove()</span> code:</p>&#13;
<pre id="pre-271"><code>const _remove = (tree, keyToRemove) =&gt; {&#13;
  if (isEmpty(tree)) {&#13;
    return null;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span>} else if (keyToRemove &lt; tree.key) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if (_isBlack(tree.left) &amp;&amp; _isBlack(tree.left.left)) {&#13;
      _flipColors(tree);&#13;
      if (_isRed(tree.right.left)) {&#13;
        tree.right = _rotate(tree.right, "left");&#13;
        tree = _rotate(tree, "right");&#13;
        _flipColors(tree);&#13;
      }&#13;
    }&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_313" aria-label="313"/>  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> tree.left = _remove(tree.left, keyToRemove);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span>} else {&#13;
    if (_isRed(tree.left)) {&#13;
      tree = _rotate(tree, "left");&#13;
    }&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> if (keyToRemove === tree.key &amp;&amp; isEmpty(tree.right)) {&#13;
      return null;&#13;
    } else {&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> if (_isBlack(tree.right) &amp;&amp; _isBlack(tree.right.left)) {&#13;
        _flipColors(tree);&#13;
        if (_isRed(tree.left.left)) {&#13;
          tree = _rotate(tree, "left");&#13;
          _flipColors(tree);&#13;
        }&#13;
      }&#13;
      if (keyToRemove === tree.key) {&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> tree.key = minKey(tree.right);&#13;
        tree.right = _remove(tree.right, tree.key);&#13;
      } else {&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation8">❽</span> tree.right = _remove(tree.right, keyToRemove);&#13;
      }&#13;
    }&#13;
  }&#13;
<span class="Code_CodeAnnotation" aria-label="annotation9">❾</span> return _fixUp(tree);&#13;
};</code></pre>&#13;
<p class="TX">After verifying that the tree isn’t empty, check whether you need to go left <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and if so <span class="CodeAnnotation" aria-label="annotation2">❷</span>, you may need to apply the transformations you saw earlier before actually moving left <span class="CodeAnnotation" aria-label="annotation3">❸</span>. If the key you want to delete is greater than or equal to the root, start by doing a rotation <span class="CodeAnnotation" aria-label="annotation4">❹</span> so that the red node will be to the right, which you’ll need later. If you find the key <span class="CodeAnnotation" aria-label="annotation5">❺</span> and it has no right child, it must be at the bottom, so you can now delete it. You’ll want to move right, so set things up according to the procedures described earlier <span class="CodeAnnotation" aria-label="annotation6">❻</span> but don’t move just yet. If you find the key but aren’t able to delete it, replace it with the following key in the tree and move right to delete that value <span class="CodeAnnotation" aria-label="annotation7">❼</span>; otherwise, just move right to keep looking for the key to be removed <span class="CodeAnnotation" aria-label="annotation8">❽</span>. At the end, a final fix-up pass <span class="CodeAnnotation" aria-label="annotation9">❾</span> solves any wrong configurations in the tree.</p>&#13;
<p class="TX">Red-black trees have the shortest code for searching and not very complex code for adding a new key (basically, just adding a fix-up call at the end), but the deletions are rather more involved. Getting the code right is difficult (see question 13.10 for a small detail).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
&#13;
<h4 class="H2" id="sec25"><span id="h2-115"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Considering Performance for Red-Black Trees</span></h4>&#13;
<p class="TNI1">We don’t need to analyze the performance of red-black trees, because they’re just another case of B-trees, so you already know that all algorithms (adding, removing, and searching) are <i>O</i>(log <i>n</i>), as <a href="chapter13.xhtml#tab13-2">Table 13-2</a> shows.</p>&#13;
&#13;
<table class="table">&#13;
<caption><p class="TT" id="tab13-2"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_314" aria-label="314"/><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 13-2:</span></span> <span class="SANS_Futura_Std_Book_11">Performance of Operations for Red-Black Trees</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Performance</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Add</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Remove</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Find</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Traverse</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Of course, because of the possible embedded red links, red-black trees are taller on average than B-trees of higher orders (and not all paths from the root to a leaf have the same length), but that doesn’t change the result. Performance will still be logarithmic, even if searches are slower by a (bound) constant factor.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
&#13;
<h3 class="H1" id="sec26"><span id="h1-66"/><span class="SANS_Futura_Std_Bold_B_11">Summary</span></h3>&#13;
<p class="TNI1">In this chapter, we moved beyond binary trees and explored two new structures for the dictionary ADT: B-trees and red-black trees (which are derived from B-trees). These structures provide good performance, and they’re used often because their implementation is not too complex and their speed is significant.</p>&#13;
<p class="TX">In the next chapter, we’ll study heaps, which are a variant of binary trees, and then in the following chapter, we’ll look at extended heaps, which combine heaps and forests to achieve high performance.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
&#13;
<h3 class="H1" id="sec27"><span id="h1-67"/><span class="SANS_Futura_Std_Bold_B_11">Questions</span></h3>&#13;
<p class="ListHead"><b>13.1  Missing Test?</b></p>&#13;
<p class="ListPlainFirst">In the <span class="SANS_TheSansMonoCd_W5Regular_11">appendChild()</span> method for trees, shouldn’t it include a call to <span class="SANS_TheSansMonoCd_W5Regular_11">this._throwIfEmpty()</span>?</p>&#13;
<p class="ListHead"><b>13.2  Traversing General Trees</b></p>&#13;
<p class="ListPlainFirst">Implement the missing preorder and postorder traversals. You might want to do this for both trees represented with arrays of children and for trees with a “left child, right sibling” representation.</p>&#13;
<p class="ListHead"><b>13.3  Nonrecursive Visiting</b></p>&#13;
<p class="ListPlainFirst">Implement a depth-first traversal of a tree without recursion by using a stack as an auxiliary structure.</p>&#13;
<p class="ListHead"><b>13.4  Tree Equality</b></p>&#13;
<p class="ListPlainFirst">Implement an <span class="SANS_TheSansMonoCd_W5Regular_11">equals(tree1, tree2)</span> algorithm that will decide whether two trees are equal—that is, having the same shape and the same keys <span role="doc-pagebreak" epub:type="pagebreak" id="pg_315" aria-label="315"/>in the same positions. You may want to “think outside the box” for this. Maybe you won’t even need recursion!</p>&#13;
<p class="ListHead"><b>13.5  Measuring Trees</b></p>&#13;
<p class="ListPlainFirst">Redo the <span class="SANS_TheSansMonoCd_W5Regular_11">calcSize()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">calcHeight()</span> functions from <span class="listplain_Xref"><a href="chapter12.xhtml">Chapter 12</a></span> (see questions 12.5 and 12.6) to work with multiway trees.</p>&#13;
<p class="ListHead"><b>13.6  Sharing More</b></p>&#13;
<p class="ListPlainFirst">In a B-tree, instead of siblings sharing just one key, you can achieve a better balance if they share more keys. For example, when adding a key, if a node becomes too full and a sibling has enough space, instead of just passing a single key to it, pass as many as possible until both siblings are about equally full. A similar process would work when removing a key. Implement this optimization.</p>&#13;
<p class="ListHead"><b>13.7  Faster Node Searching</b></p>&#13;
<p class="ListPlainFirst">This chapter used linear searching in nodes, but since keys are ordered, a better way would be using binary searching. Make this change. Would that make a difference in the order of the B-trees’ methods? Why or why not?</p>&#13;
<p class="ListHead"><b>13.8  Lowest Order</b></p>&#13;
<p class="ListPlainFirst">Would B-trees of order 2 make sense?</p>&#13;
<p class="ListHead"><b>13.9  Many Orders of Trees</b></p>&#13;
<p class="ListPlainFirst">What would you do if you needed to work with B-trees of different orders? Hint: the problem here is that imported modules are singletons. Look for a way to avoid this behavior.</p>&#13;
<p class="ListHead"><b>13.10  Safe to Delete?</b></p>&#13;
<p class="ListPlainFirst">In the <span class="SANS_TheSansMonoCd_W5Regular_11">remove()</span> algorithm for red-black trees, when you actually delete a node, are you sure it’s possible to remove it without any negative effects?</p>&#13;
</section>&#13;
</section>&#13;
</body></html>