- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">13</samp> <samp class="SANS_Dogma_OT_Bold_B_11">INTERFACING
    WITH PS/2 KEYBOARDS</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: Some Arduino projects, such as motor controllers, lighting systems, or even
    games, need to accept text or numerical data via a familiar, user-friendly form
    of input. This chapter shows you how to accept such data with a standard PS/2-style
    PC keyboard and then display it with an I²C-interface LCD.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll learn to:'
  prefs: []
  type: TYPE_NORMAL
- en: Receive data from a Personal System/2 (PS/2) keyboard through your Arduino
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up I²C-interface LCDs for convenient data display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capture text from a PS/2 keyboard and display on the LCD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ll also build an RGB LED tester with keyboard input, as well as a distraction-free
    text file entry device.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The PS/2 Keyboard</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter uses a keyboard with a PS/2-style interface, first introduced by
    IBM in 1987 along with its new PS/2 series of personal computers. This type of
    interface was prevalent until around 1997, when the USB standard increased in
    popularity. However, PS/2 keyboards are still available and used with various
    PCs and industrial devices due to the simplicity of the interface. The actual
    layout of the keys on a PS/2 keyboard is virtually identical to that of the keyboards
    you use today.
  prefs: []
  type: TYPE_NORMAL
- en: The PS/2 keyboard connector is in the six-pin mini-DIN format, as shown in [Figure
    13-1](chapter13.xhtml#fig13-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF A PS/2 KEYBOARD PLUG](../images/fig13-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-1: A PS/2 keyboard
    connector</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use a simple PS/2 socket breakout board (such as PMD Way part 694804)
    to interface the keyboard with our Arduino, as shown in [Figure 13-2](chapter13.xhtml#fig13-2).
    The socket breakout board uses four connections: 5V, GND, Clock, and Data.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF A PS/2 SOCKET BREAKOUT BOARD](../images/fig13-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-2: A PS/2 socket
    breakout board</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Each key on the keyboard is represented by a numerical code. When a key is pressed
    on the keyboard, the keycode data is sent to the PC via a bidirectional half-duplex
    data line. This means data can travel in either direction between the PC and the
    keyboard but in only one direction at a time.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*PS/2 keyboards are 5 V devices. If you’re using an Arduino or compatible with
    a 3.3 V operating voltage, you’ll need to use a bidirectional level converter
    board between the Arduino and PS/2 breakout.*'
  prefs: []
  type: TYPE_NORMAL
- en: For each keypress, the keyboard sends out a LOW start bit, followed by 8 bits
    that represent the key pressed, then a parity bit along the data line, with a
    matching Clock line to maintain timing and data accuracy. For example, [Figure
    13-3](chapter13.xhtml#fig13-3) shows the Clock (1) and Data (2) lines when P is
    pressed on the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: '![A SCREEN CAPTURE OF PS/2 KEYBOARD DATA SHOWN ON A DIGITAL STORAGE OSCILLOSCOPE](../images/fig13-3.png)'
  prefs: []
  type: TYPE_IMG
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-3:</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">The
    timing diagram for PS/2 keypress shown on a digital storage oscilloscope</samp>
  prefs: []
  type: TYPE_NORMAL
- en: The keycode for the letter P is 0x4D in hexadecimal, or 01001101 in binary—you
    can see the bits marked on the data line in [Figure 13-3](chapter13.xhtml#fig13-3).
    A complete list of the keycodes is available from [*https://<wbr>wiki<wbr>.osdev<wbr>.org<wbr>/PS<wbr>/2<wbr>_Keyboard*](https://wiki.osdev.org/PS/2_Keyboard).
  prefs: []
  type: TYPE_NORMAL
- en: To use the keyboard with your Arduino, you’ll need to install a library. Open
    the IDE’s library manager and search for **ps/2**; then install the resulting
    library.
  prefs: []
  type: TYPE_NORMAL
- en: To test the keyboard, connect the PS/2 breakout board to the Arduino, as shown
    in the schematic in [Figure 13-4](chapter13.xhtml#fig13-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC SYMBOL FOR THE PS/2 KEYBOARD SOCKET BREAKOUT BOARD](../images/fig13-4.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-4: The schematic
    for keyboard connection</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Next, enter and upload the [Listing 13-1](#LiT-13-1) sketch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-1: Testing the PS/2
    keyboard</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: A few moments after uploading, open the Serial Monitor and type anything you
    like on the PS/2 keyboard. [Figure 13-5](chapter13.xhtml#fig13-5) shows an example
    of the project in operation with what I typed on the keyboard displayed in the
    Serial Monitor.
  prefs: []
  type: TYPE_NORMAL
- en: '![AN EXAMPLE OUTPUT ON THE SERIAL MONITOR FOR LISTING 13-1](../images/fig13-5.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-5: Example output
    of the keyboard test sketch</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The sketch initializes the library ❶ and then activates the connection to the
    keyboard on digital pins 4 and 3 ❷; the parameters for <samp class="SANS_TheSansMonoCd_W5Regular_11">keyboard.begin()</samp>
    are the digital pin numbers for the Clock and Data lines, respectively. The sketch
    checks if a button has been pressed ❸ and assigns the result to the character
    variable <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> ❹. After checking
    for function keys using a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch…case</samp>
    statement, it sends the resulting key to the Serial Monitor ❺.
  prefs: []
  type: TYPE_NORMAL
- en: If you find the keyboard returns gibberish, check that the power to the keyboard
    is exactly or close to 5 V DC; the keyboard needs a straight 5 V to function correctly.
    Some Arduino boards can offer a voltage very close to 5 V, but some offer less,
    around 4.7 V or worse. If your voltage is too low, use an external 5 V supply
    for the circuit and future projects that use a PS/2 keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen how to integrate keyboard input into your projects, let’s
    set up an output display, using an I²C-bus-compatible LCD.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">PCF8574 LCD Modules</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using an LCD for display output is popular in the Arduino world. This generally
    involves using an LCD shield or wiring up an HD44780-compatible LCD with eight
    or so wires back to the Arduino. However, in recent years, a new method of using
    these LCDs has gained popularity: soldering a PCF8574 I²C backpack unit to the
    display, which allows you to connect the LCD to your project with only four wires.'
  prefs: []
  type: TYPE_NORMAL
- en: The PCF8574 is an I²C-based port expander that can interface the LCD’s control
    pins to the popular serial data bus. This obviates the need to use digital I/O
    pins and helps simplify the overall wiring. You can either buy the modules separately
    or purchase LCDs with the pre-attached modules, as shown in [Figure 13-6](chapter13.xhtml#fig13-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF THE REAR OF THE LCD WITH A FITTED PCF8574 I2C LCD INTERFACE MODULE](../images/fig13-6.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-6: The rear of a
    PCF8574 I</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUP_11">2</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">C LCD module</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To connect the module to the Arduino, use the 5V/V[CC], GND, Clock, and Data
    lines, as with any other I²C device. You can adjust the display contrast using
    the trimpot on the module. You can also bridge the three pairs of solder bridge
    pads under the trimpot (A0, A1, or A2) to change the I²C bus address from the
    default <samp class="SANS_TheSansMonoCd_W5Regular_11">0 x 27</samp> to one of
    seven other options. To use the LCD with your Arduino, you must install a library.
    Open the IDE’s library manager and search for **PCF8574**; then install the latest
    version of the library.
  prefs: []
  type: TYPE_NORMAL
- en: To test the display, connect to the Arduino, as shown in the schematic in [Figure
    13-7](chapter13.xhtml#fig13-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC SYMBOL FOR PCF8574-CONTROLLED LCD](../images/fig13-7.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-7: The schematic
    for LCD connection</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Next, enter and upload the [Listing 13-2](#LiT-13-2) sketch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-2: Testing the PCF8574
    LCD</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: After the sketch uploads, you should see <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello,
    world!</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">* Arduino *</samp>
    blinking on the LCD, as shown in [Figure 13-8](chapter13.xhtml#fig13-8).
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF THE LCD DISPLAYING THE DEMONSTRATION TEXT, “HELLO WORLD! ARDUINO”](../images/fig13-8.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-8: The I</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I-SUP_11">2</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">C
    LCD in action</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Once the LCD is initialized, basic operation is the same as the usual Arduino
    LCD library. The sketch includes the Wire library for I²C and the I²C LCD library
    ❶ and then creates an instance of the LCD using bus address <samp class="SANS_TheSansMonoCd_W5Regular_11">0x27</samp>.
    It starts communication on the I²C bus to address <samp class="SANS_TheSansMonoCd_W5Regular_11">0x27</samp>
    (the LCD) ❷, then configures the LCD size (16 characters, 2 rows) with <samp class="SANS_TheSansMonoCd_W5Regular_11">lcd.begin()</samp>,
    and finally turns on the backlight with <samp class="SANS_TheSansMonoCd_W5Regular_11">lcd.setBacklight()</samp>.
    You can control the backlight by using 255 to turn the backlight on, and 0 to
    turn it off; in this sketch, it’s set to on ❸.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sketch uses the usual LCD functions: <samp class="SANS_TheSansMonoCd_W5Regular_11">lcd.home()</samp>
    resets the cursor to the top-left character, <samp class="SANS_TheSansMonoCd_W5Regular_11">lcd.clear()</samp>
    clears the display, and so on. If you are using other I²C bus devices in the same
    project, don’t forget to restart the bus to the LCD with another <samp class="SANS_TheSansMonoCd_W5Regular_11">Wire.beginTransmission(0x27)</samp>
    before sending display commands.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If your display doesn’t work, the bus address for your display could be different
    from the one used in the sketch. You can use the Project #30 I²C scanner sketch
    described in [Chapter 10](chapter10.xhtml) to check the device bus address and
    substitute it into the sketch in place of <samp class="SANS_TheSansMonoCd_W5Regular_11">0x27</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Testing the I</samp><samp class="SANS_Futura_Std_Bold_B-SUP_11">2</samp><samp
    class="SANS_Futura_Std_Bold_B_11">C LCD and PS/2 Keyboard</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you’ve experimented with the I²C LCD and the keyboard separately, this
    section shows how they can work together as a test of the combined hardware. I
    hope this helps inspire your own independent project ideas, such as a text editor
    using an LCD or perhaps your own text-based game.
  prefs: []
  type: TYPE_NORMAL
- en: Connect the keyboard and LCD as described in the previous sections and then
    enter and upload the [Listing 13-3](#LiT-13-3) sketch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-3: The LCD and keyboard
    working together</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In a few moments, the LCD backlight should illuminate, and a block cursor should
    start blinking at the top left of the LCD. Now start typing. Whatever you type
    on the keyboard—including text, symbols, and most function keys—should appear
    and then wrap around the screen as if the LCD were a small text editor, as shown
    in [Figure 13-9](chapter13.xhtml#fig13-9). (I’ve turned off the backlight for
    a clearer photograph.)
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF THE LCD DISPLAYING TEXT ENTERED VIA THE PS/2 KEYBOARD, “THE QUICK
    BROWN FOX JUMPED OVER”](../images/fig13-9.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-9: The LCD displaying
    text entered via the PS/2 keyboard</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You can press ESC to clear the screen and move the cursor back to the top left.
    The sketch simply takes input from the keyboard (apart from ESC) and sends each
    press to the display.
  prefs: []
  type: TYPE_NORMAL
- en: The sketch first initializes the required libraries for the LCD and keyboard
    and creates two variables to store the position of the cursor ❶. It then starts
    the keyboard and LCD and turns on the LCD backlight and blinking cursor.
  prefs: []
  type: TYPE_NORMAL
- en: The main loop of the sketch starts ❷ by checking for a press from the keyboard
    and deciding what to do based on the press ❸. First the project checks to see
    whether the user has pressed ENTER. If so, the cursor on the LCD moves to the
    start of the second line or is sent back to the start of the first line if it’s
    already on the second line. The sketch similarly checks for a press of TAB ❹ and
    displays this on the LCD if so. Or, if the user presses ESC ❺, the screen is cleared
    and the cursor moves back to the top left of the LCD.
  prefs: []
  type: TYPE_NORMAL
- en: The sketch continues to check for other keypresses and displays the name of
    the appropriate keys on the LCD ❻. This includes presses of any other keys that
    don’t belong in the previous checks, including letters, numbers, and symbols ❼.
    After every keypress, the cursor position on the LCD is increased so it moves
    along one character for columns ❽ and rows ❾ and moves to the next line or the
    top left of the LCD when necessary ❿.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to read the PS/2 keyboard and display the keys pressed,
    you’ll put these skills to use with the following project that reads integers
    from the keyboard and works with them to control the brightness and colors available
    with an RGB LED.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #39: Creating an RGB LED Tester</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In future projects, you may want to test the various colors that can be displayed
    using a red, green, and blue (RGB) LED to calibrate the settings to reach the
    desired LED brightness and color. In this project, you’ll build a device that
    accepts pulse-width modulation (PWM) values for each color and then controls each
    LED for a defined length of time. If you don’t have an RGB LED, you can still
    enjoy and understand this project using three separate LEDs.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You can learn more about PWM in Chapter 19 of* Arduino Workshop*, 2nd edition
    (No Starch Press, 2021).*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need the following parts for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: An Arduino Uno or compatible board and USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A PS/2 breakout board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A PS/2 keyboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A PCF8574 LCD module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One common-cathode RGB LED or one each of RGB LEDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three 1 kΩ, 0.25 W, 1 percent resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble the circuit as shown in [Figure 13-10](chapter13.xhtml#fig13-10). In
    this project, the breadboard is used as a bridge to help create more 5V and GND
    connections for the two modules to the Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC FOR PROJECT #39](../images/fig13-10.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-10: The schematic
    for Project #39</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now enter and upload the Project #39 sketch. The LCD should display <samp class="SANS_TheSansMonoCd_W5Regular_11">R:</samp>.
    Using the PS/2 keyboard, enter a three-digit value between 000 and 255 to set
    the PWM value for the red LED. The greater the number, the stronger the color
    will be in the LED. Repeat this process for the green and blue LEDs in response
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">G:</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">B:</samp>
    prompts. Finally, the LCD should display a <samp class="SANS_TheSansMonoCd_W5Regular_11">T:</samp>
    prompt. Key in your required duration for the LEDs to be activated, between 000
    and 255 seconds. The LEDs should then activate according to your instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-11](chapter13.xhtml#fig13-11) shows the results of entering in the
    brightness values for all three LEDs and the duration of activation in seconds.'
  prefs: []
  type: TYPE_NORMAL
- en: '![AN EXAMPLE OUTPUT ON THE LCD FROM PROJECT #39\. “R = 255\. G = 127\. B =
    090\. T = 060”](../images/fig13-11.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-11: The Project #39
    user interface in operation</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The sketch first includes and configures the I²C LCD and keyboard libraries,
    as usual ❶, and then defines the LEDs’ Arduino digital pin numbers to color names
    for ease of reference. The custom function <samp class="SANS_TheSansMonoCd_W5Regular_11">readDigit()</samp>
    ❷ returns an integer that is used to return the press of a number on the PS/2
    keyboard. This function uses a variable <samp class="SANS_TheSansMonoCd_W5Regular_11">_digit</samp>,
    which is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">–1</samp> upon initialization
    and stays at that value until a number key is pressed. It then returns the value
    of any button the user presses as the return value for the function.
  prefs: []
  type: TYPE_NORMAL
- en: Since the <samp class="SANS_TheSansMonoCd_W5Regular_11">readDigit()</samp>function
    needs to wait until a number is pressed on the keyboard, a <samp class="SANS_TheSansMonoCd_W5Regular_11">do…while</samp>
    function ❸ continues to loop while awaiting a keypress by testing the value of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">_digit</samp>. When the sketch detects
    a keypress, however, the function interrogates the key’s value with a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch…case</samp>
    function. The value of <samp class="SANS_TheSansMonoCd_W5Regular_11">_digit</samp>
    is then set to the value of the number key pressed, which is equal to the number
    plus 1\. For example, if the user presses the 5 key, the sketch adds 6 to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">_digit</samp> to reflect this. If the
    user doesn’t press one of the numbers, it will return a 0 for _<samp class="SANS_TheSansMonoCd_W5Regular_11">digit</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Once the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">_digit</samp>
    has changed, the test in the <samp class="SANS_TheSansMonoCd_W5Regular_11">do…while</samp>
    function ❺ fails. The code can thus continue to display the appropriate number
    on the LCD ❹ and return the value of the number pressed.
  prefs: []
  type: TYPE_NORMAL
- en: The project needs three-digit values from the user for PWM and time values.
    Therefore, the custom function <samp class="SANS_TheSansMonoCd_W5Regular_11">get3digit()</samp>
    ❻ creates a three-digit number by calling for a digit from the keyboard three
    times and then combining the number into the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>,
    which is returned as the result of this function.
  prefs: []
  type: TYPE_NORMAL
- en: The sketch starts the I²C bus, LCD, and keyboard ❼ and then sets the digital
    pins for the LEDs to outputs using port manipulation (discussed in [Chapter 2](chapter2.xhtml)).
    I’ve set variables to hold the PWM values for each LED and time on delay ❽. The
    project then accepts the user’s value for red PWM, green PWM, blue PWM, and the
    number of seconds for the LEDs to stay on. These are actioned at ❾, and the delay
    is converted to milliseconds. Once the delay has finished, the LEDs are turned
    off, and the system starts again.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an example of capturing and working with numerical input from
    a PS/2 keyboard, you’ll build a device to capture text as well, saving that input
    to an SD card for use with a PC.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #40: Building a Text Capture
    Device</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The text capture device described in this project lets you record notes or other
    writing for later reference, without the distractions of internet or cell phone
    notifications to lure you away from real work. Everything you type onto the project’s
    PS/2 keyboard is recorded to a text file on an SD memory card, which you can then
    open on your PC for final editing.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You can learn more about using SD memory cards in Chapter 7 of* Arduino Workshop*,
    2nd edition (No Starch Press, 2021).*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need the following parts for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: An Arduino Uno or compatible board and USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A PS/2 breakout board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A PS/2 keyboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A PCF8574 LCD module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An SD card module or SD card shield for Arduino
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A blank SD memory card
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble the circuit as shown in [Figure 13-12](chapter13.xhtml#fig13-12). If
    you’re using the SD card shield, insert it onto the Arduino and then connect the
    LCD and PS/2 modules. Again, this project uses the breadboard as a bridge to help
    create more 5V and GND connections for the two modules to the Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC FOR PROJECT #40](../images/fig13-12.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-12: The schematic
    for Project #40</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now enter and upload the Project #40 sketch and then insert the SD card into
    the module. Start typing when prompted by the LCD, as shown in [Figure 13-13](chapter13.xhtml#fig13-13).'
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF THE LCD FROM PROJECT #40 DISPLAYING TEXT CAPTURED FROM THE KEYBOARD.
    “START TYPING: THE QUICK BROWN”](../images/fig13-13.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-13: The LCD from
    Project #40 displaying text captured from a keyboard</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: As you continue typing, the cursor should scroll around to the second row and
    then back to the first, in the same manner as shown in [Figure 13-14](chapter13.xhtml#fig13-14).
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF THE LCD FROM PROJECT #40 DISPLAYING TEXT CAPTURED FROM THE KEYBOARD
    SCROLLING ACROSS TWO LINES: “FOX JUMPED OVER THE LAZY BROWN DOG. N”](../images/fig13-14.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-14: Text scrolling
    across two lines in the LCD</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: As you type, the Arduino should automatically save every 100 characters to a
    file on the SD card. When you’ve finished and want to take the SD card away, press
    ESC on the keyboard. The Arduino should save any remaining characters and then
    prompt you to remove the SD card, as shown in [Figure 13-15](chapter13.xhtml#fig13-15).
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF THE LCD FROM PROJECT #40 DISPLAYING THE MESSAGE “OK TO REMOVE
    CARD”](../images/fig13-15.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-15: The LCD displaying
    the message that it’s okay to remove the SD card</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If there’s an issue with the SD card anytime you attempt a save, the display
    should show the message <samp class="SANS_TheSansMonoCd_W5Regular_11">SD card
    fail</samp>, as shown in [Figure 13-16](chapter13.xhtml#fig13-16).
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF THE LCD FROM PROJECT #40 DISPLAYING THE “SD CARD FAIL” MESSAGE](../images/fig13-16.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-16: The LCD indicating
    a problem with the SD card</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, your SD card may not be properly formatted, your write-protect
    switch may be set to ON, or your card may be missing from the module. Once you’ve
    fixed any problems and removed your SD card, you can view and edit the text file
    created with your PC by inserting the SD card into the PC.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This sketch builds on [Listing 13-3](#LiT-13-3) to include extra code for writing
    to the SD card. First, it declares the global variables ❶, including the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">array_text[]</samp> buffer to hold the
    user input before writing to the SD card, the <samp class="SANS_TheSansMonoCd_W5Regular_11">_counter</samp>
    variable used to track the number of characters that are stored in the buffer,
    and the cursor position on the LCD.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the sketch includes and initializes the required libraries for the SD
    card module, LCD, and keyboard. The custom function <samp class="SANS_TheSansMonoCd_W5Regular_11">halt()</samp>
    ❷ is used to stop the sketch operation and is called after the text is saved to
    the SD card so the user can safely remove the card. It simply loops around forever
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">do…while</samp> function,
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> is always true.
  prefs: []
  type: TYPE_NORMAL
- en: The custom function <samp class="SANS_TheSansMonoCd_W5Regular_11">saveText(boolean
    _halt)</samp> ❸ saves data to the SD card, either saving text and returning to
    user input or saving text and ending operation, as indicated by the Boolean parameter
    <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>,
    respectively. The function checks whether the SD card is okay to use, stopping
    and returning an error if there’s an issue, as shown in [Figure 13-16](chapter13.xhtml#fig13-16).
    If there are no errors, the sketch opens the file whose name is set in this function,
    to which it will write the data; it creates that file if none exists ❹. The sketch
    then writes the text buffer to the SD card and clears the buffer to prepare it
    for more data.
  prefs: []
  type: TYPE_NORMAL
- en: If the parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> was
    passed to the <samp class="SANS_TheSansMonoCd_W5Regular_11">saveText(boolean _halt)</samp>
    function ❺, the code opens the file on the SD card, writes a line of dashes to
    end the text file, and then closes it and indicates this to the user, as shown
    in [Figure 13-15](chapter13.xhtml#fig13-15). From ❻, the usual requirements for
    activating the I²C bus, LCD, and keyboard, as well as setting D10 to an output
    for the SD card module’s SPI interface, occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the sketch sets up the project’s main operation: capturing text from
    the keyboard, displaying it on the LCD, and writing it to the SD card. At ❼ the
    sketch is ready to receive a keystroke from the PS/2 keyboard. If the user presses
    ENTER, the sketch inserts a new line character | in the text array ❽, increments
    the size counter of the array by 1, and moves the cursor along the LCD as required
    to the alternate line. If the user presses ESC, the sketch clears the LCD, saves
    the data to the SD card, and stops operation via a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">saveText(true);</samp>.
    All other keypresses are inserted into the text array as normal text ❾, which
    is then displayed on the LCD, while the sketch increments the size counter by
    1.'
  prefs: []
  type: TYPE_NORMAL
- en: The sketch then checks the text array size. If it is greater than or equal to
    99 characters in size, the text array is written to the text file by calling <samp
    class="SANS_TheSansMonoCd_W5Regular_11">saveText(false);</samp> ❿, which returns
    to normal text capture after the write, followed by resetting the counter to 0\.
    Finally, the sketch updates the cursor position, checking if the text runs over
    the margin and repositioning the cursor if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a final challenge, you might add a real-time clock to Project #40, as well
    as a data timestamp when the file is closed.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many projects suffer from a poor user interface; as you saw in this chapter,
    using a PS/2 keyboard simplifies the process of entering data into a project.
    In this chapter, you learned how to capture data from the keyboard into an Arduino
    and how to save data entered with the keyboard. I hope this chapter served as
    inspiration for improving the configuration or operation in your own work.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, I’ll show you how to harness Bluetooth modules to allow
    for wireless communication between smartphones and other devices with your Arduino
    projects.
  prefs: []
  type: TYPE_NORMAL
