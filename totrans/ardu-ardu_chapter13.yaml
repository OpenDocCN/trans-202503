- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">13</samp> <samp class="SANS_Dogma_OT_Bold_B_11">INTERFACING
    WITH PS/2 KEYBOARDS</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">13</samp> <samp class="SANS_Dogma_OT_Bold_B_11">与PS/2键盘的接口</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: Some Arduino projects, such as motor controllers, lighting systems, or even
    games, need to accept text or numerical data via a familiar, user-friendly form
    of input. This chapter shows you how to accept such data with a standard PS/2-style
    PC keyboard and then display it with an I²C-interface LCD.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Arduino项目，比如电机控制器、照明系统，甚至是游戏，需要通过一种熟悉且用户友好的方式输入文本或数值数据。本章将展示如何通过标准的PS/2风格PC键盘接受这些数据，然后通过I²C接口LCD显示出来。
- en: 'You’ll learn to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习：
- en: Receive data from a Personal System/2 (PS/2) keyboard through your Arduino
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Arduino接收来自个人系统/2（PS/2）键盘的数据
- en: Set up I²C-interface LCDs for convenient data display
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置I²C接口LCD，以便方便地显示数据
- en: Capture text from a PS/2 keyboard and display on the LCD
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从PS/2键盘捕获文本并在LCD上显示
- en: You’ll also build an RGB LED tester with keyboard input, as well as a distraction-free
    text file entry device.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将构建一个带有键盘输入的RGB LED测试器，以及一个无干扰的文本文件输入设备。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The PS/2 Keyboard</samp>
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">PS/2键盘</samp>
- en: This chapter uses a keyboard with a PS/2-style interface, first introduced by
    IBM in 1987 along with its new PS/2 series of personal computers. This type of
    interface was prevalent until around 1997, when the USB standard increased in
    popularity. However, PS/2 keyboards are still available and used with various
    PCs and industrial devices due to the simplicity of the interface. The actual
    layout of the keys on a PS/2 keyboard is virtually identical to that of the keyboards
    you use today.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用的键盘具有PS/2风格的接口，这种接口最初由IBM于1987年与其新的PS/2系列个人计算机一起推出。这种接口在1997年左右流行，但USB标准的普及让其逐渐被取代。然而，由于接口简单，PS/2键盘仍然可用并被各种PC和工业设备使用。PS/2键盘的实际按键布局几乎与今天使用的键盘完全相同。
- en: The PS/2 keyboard connector is in the six-pin mini-DIN format, as shown in [Figure
    13-1](chapter13.xhtml#fig13-1).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: PS/2键盘连接器采用六针迷你DIN格式，如[图13-1](chapter13.xhtml#fig13-1)所示。
- en: '![A PHOTO OF A PS/2 KEYBOARD PLUG](../images/fig13-1.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![PS/2键盘插头的照片](../images/fig13-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-1: A PS/2 keyboard
    connector</samp>'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图13-1：PS/2键盘连接器</samp>
- en: 'We’ll use a simple PS/2 socket breakout board (such as PMD Way part 694804)
    to interface the keyboard with our Arduino, as shown in [Figure 13-2](chapter13.xhtml#fig13-2).
    The socket breakout board uses four connections: 5V, GND, Clock, and Data.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个简单的PS/2插座分线板（例如PMD Way的694804部件）将键盘与Arduino连接，如[图13-2](chapter13.xhtml#fig13-2)所示。插座分线板使用四个连接：5V、GND、时钟和数据。
- en: '![A PHOTO OF A PS/2 SOCKET BREAKOUT BOARD](../images/fig13-2.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![PS/2插座分线板的照片](../images/fig13-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-2: A PS/2 socket
    breakout board</samp>'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图13-2：PS/2插座分线板</samp>
- en: Each key on the keyboard is represented by a numerical code. When a key is pressed
    on the keyboard, the keycode data is sent to the PC via a bidirectional half-duplex
    data line. This means data can travel in either direction between the PC and the
    keyboard but in only one direction at a time.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每个键盘上的按键都有一个数字代码表示。当按下键盘上的一个按键时，按键码数据通过一个双向半双工数据线传输到PC。这意味着数据可以在PC和键盘之间双向传输，但每次只能在一个方向上传输。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*PS/2 keyboards are 5 V devices. If you’re using an Arduino or compatible with
    a 3.3 V operating voltage, you’ll need to use a bidirectional level converter
    board between the Arduino and PS/2 breakout.*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*PS/2键盘是5V设备。如果你使用的是工作电压为3.3V的Arduino或兼容设备，你需要在Arduino与PS/2分线板之间使用双向电平转换板。*'
- en: For each keypress, the keyboard sends out a LOW start bit, followed by 8 bits
    that represent the key pressed, then a parity bit along the data line, with a
    matching Clock line to maintain timing and data accuracy. For example, [Figure
    13-3](chapter13.xhtml#fig13-3) shows the Clock (1) and Data (2) lines when P is
    pressed on the keyboard.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一次按键，键盘会发送一个低电平的起始位，接着是8个比特表示按下的键，然后是一个校验位，通过数据线传输，并且有一个匹配的时钟线来保持时序和数据的准确性。例如，[图13-3](chapter13.xhtml#fig13-3)显示了按下P键时时钟线（1）和数据线（2）。
- en: '![A SCREEN CAPTURE OF PS/2 KEYBOARD DATA SHOWN ON A DIGITAL STORAGE OSCILLOSCOPE](../images/fig13-3.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-3:</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">The
    timing diagram for PS/2 keypress shown on a digital storage oscilloscope</samp>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: The keycode for the letter P is 0x4D in hexadecimal, or 01001101 in binary—you
    can see the bits marked on the data line in [Figure 13-3](chapter13.xhtml#fig13-3).
    A complete list of the keycodes is available from [*https://<wbr>wiki<wbr>.osdev<wbr>.org<wbr>/PS<wbr>/2<wbr>_Keyboard*](https://wiki.osdev.org/PS/2_Keyboard).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: To use the keyboard with your Arduino, you’ll need to install a library. Open
    the IDE’s library manager and search for **ps/2**; then install the resulting
    library.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: To test the keyboard, connect the PS/2 breakout board to the Arduino, as shown
    in the schematic in [Figure 13-4](chapter13.xhtml#fig13-4).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC SYMBOL FOR THE PS/2 KEYBOARD SOCKET BREAKOUT BOARD](../images/fig13-4.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-4: The schematic
    for keyboard connection</samp>'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Next, enter and upload the [Listing 13-1](#LiT-13-1) sketch.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-1: Testing the PS/2
    keyboard</samp>'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: A few moments after uploading, open the Serial Monitor and type anything you
    like on the PS/2 keyboard. [Figure 13-5](chapter13.xhtml#fig13-5) shows an example
    of the project in operation with what I typed on the keyboard displayed in the
    Serial Monitor.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![AN EXAMPLE OUTPUT ON THE SERIAL MONITOR FOR LISTING 13-1](../images/fig13-5.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-5: Example output
    of the keyboard test sketch</samp>'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: The sketch initializes the library ❶ and then activates the connection to the
    keyboard on digital pins 4 and 3 ❷; the parameters for <samp class="SANS_TheSansMonoCd_W5Regular_11">keyboard.begin()</samp>
    are the digital pin numbers for the Clock and Data lines, respectively. The sketch
    checks if a button has been pressed ❸ and assigns the result to the character
    variable <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> ❹. After checking
    for function keys using a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch…case</samp>
    statement, it sends the resulting key to the Serial Monitor ❺.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: If you find the keyboard returns gibberish, check that the power to the keyboard
    is exactly or close to 5 V DC; the keyboard needs a straight 5 V to function correctly.
    Some Arduino boards can offer a voltage very close to 5 V, but some offer less,
    around 4.7 V or worse. If your voltage is too low, use an external 5 V supply
    for the circuit and future projects that use a PS/2 keyboard.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen how to integrate keyboard input into your projects, let’s
    set up an output display, using an I²C-bus-compatible LCD.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">PCF8574 LCD Modules</samp>
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using an LCD for display output is popular in the Arduino world. This generally
    involves using an LCD shield or wiring up an HD44780-compatible LCD with eight
    or so wires back to the Arduino. However, in recent years, a new method of using
    these LCDs has gained popularity: soldering a PCF8574 I²C backpack unit to the
    display, which allows you to connect the LCD to your project with only four wires.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Arduino 世界中，使用 LCD 作为显示输出非常流行。通常，这涉及使用 LCD 扩展板或将与 HD44780 兼容的 LCD 用大约八根线连接回
    Arduino。然而，近年来，一种新的使用这些 LCD 的方法变得越来越流行：将 PCF8574 I²C 背包单元焊接到显示屏上，这样只需四根线就可以将 LCD
    连接到你的项目中。
- en: The PCF8574 is an I²C-based port expander that can interface the LCD’s control
    pins to the popular serial data bus. This obviates the need to use digital I/O
    pins and helps simplify the overall wiring. You can either buy the modules separately
    or purchase LCDs with the pre-attached modules, as shown in [Figure 13-6](chapter13.xhtml#fig13-6).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: PCF8574 是一个基于 I²C 的端口扩展器，它可以将 LCD 的控制引脚连接到流行的串行数据总线。这避免了使用数字 I/O 引脚的需求，并有助于简化整体布线。你可以单独购买模块，或者购买带有预先附加模块的
    LCD，如 [图 13-6](chapter13.xhtml#fig13-6) 所示。
- en: '![A PHOTO OF THE REAR OF THE LCD WITH A FITTED PCF8574 I2C LCD INTERFACE MODULE](../images/fig13-6.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![显示带有 PCF8574 I²C LCD 接口模块的 LCD 背面的照片](../images/fig13-6.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-6: The rear of a
    PCF8574 I</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUP_11">2</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">C LCD module</samp>'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 13-6：PCF8574 I</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I-SUP_11">2</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">C
    LCD 模块的背面</samp>
- en: To connect the module to the Arduino, use the 5V/V[CC], GND, Clock, and Data
    lines, as with any other I²C device. You can adjust the display contrast using
    the trimpot on the module. You can also bridge the three pairs of solder bridge
    pads under the trimpot (A0, A1, or A2) to change the I²C bus address from the
    default <samp class="SANS_TheSansMonoCd_W5Regular_11">0 x 27</samp> to one of
    seven other options. To use the LCD with your Arduino, you must install a library.
    Open the IDE’s library manager and search for **PCF8574**; then install the latest
    version of the library.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要将模块连接到 Arduino，请使用 5V/V[CC]、GND、时钟和数据线，就像连接其他任何 I²C 设备一样。你可以使用模块上的可调电位器调节显示对比度。你还可以在电位器下方的三个焊接桥接垫（A0、A1
    或 A2）之间桥接，以将 I²C 总线地址从默认的 <samp class="SANS_TheSansMonoCd_W5Regular_11">0 x 27</samp>
    更改为其他七个选项之一。要在 Arduino 上使用 LCD，你必须安装一个库。打开 IDE 的库管理器并搜索 **PCF8574**，然后安装该库的最新版本。
- en: To test the display, connect to the Arduino, as shown in the schematic in [Figure
    13-7](chapter13.xhtml#fig13-7).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试显示，按照 [图 13-7](chapter13.xhtml#fig13-7) 中的原理图连接到 Arduino。
- en: '![THE SCHEMATIC SYMBOL FOR PCF8574-CONTROLLED LCD](../images/fig13-7.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![PCF8574 控制 LCD 的原理图符号](../images/fig13-7.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-7: The schematic
    for LCD connection</samp>'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 13-7：LCD 连接的原理图</samp>
- en: Next, enter and upload the [Listing 13-2](#LiT-13-2) sketch.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，输入并上传 [列表 13-2](#LiT-13-2) 草图。
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-2: Testing the PCF8574
    LCD</samp>'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 13-2：测试 PCF8574 LCD</samp>
- en: After the sketch uploads, you should see <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello,
    world!</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">* Arduino *</samp>
    blinking on the LCD, as shown in [Figure 13-8](chapter13.xhtml#fig13-8).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在草图上传后，你应该能看到 <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello, world!</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">* Arduino *</samp> 在 LCD 上闪烁，如
    [图 13-8](chapter13.xhtml#fig13-8) 所示。
- en: '![A PHOTO OF THE LCD DISPLAYING THE DEMONSTRATION TEXT, “HELLO WORLD! ARDUINO”](../images/fig13-8.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![一张 LCD 显示“HELLO WORLD! ARDUINO”演示文本的照片](../images/fig13-8.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-8: The I</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I-SUP_11">2</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">C
    LCD in action</samp>'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 13-8：I</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUP_11">2</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">C LCD 在工作中的表现</samp>
- en: Once the LCD is initialized, basic operation is the same as the usual Arduino
    LCD library. The sketch includes the Wire library for I²C and the I²C LCD library
    ❶ and then creates an instance of the LCD using bus address <samp class="SANS_TheSansMonoCd_W5Regular_11">0x27</samp>.
    It starts communication on the I²C bus to address <samp class="SANS_TheSansMonoCd_W5Regular_11">0x27</samp>
    (the LCD) ❷, then configures the LCD size (16 characters, 2 rows) with <samp class="SANS_TheSansMonoCd_W5Regular_11">lcd.begin()</samp>,
    and finally turns on the backlight with <samp class="SANS_TheSansMonoCd_W5Regular_11">lcd.setBacklight()</samp>.
    You can control the backlight by using 255 to turn the backlight on, and 0 to
    turn it off; in this sketch, it’s set to on ❸.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 LCD 初始化完成，基本操作与常规 Arduino LCD 库相同。该草图包含了用于 I²C 的 Wire 库和 I²C LCD 库 ❶，然后通过总线地址
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0x27</samp> 创建 LCD 的实例。它在 I²C 总线上启动通信，地址为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0x27</samp>（即 LCD） ❷，接着用 <samp class="SANS_TheSansMonoCd_W5Regular_11">lcd.begin()</samp>
    配置 LCD 大小（16 个字符，2 行），最后使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">lcd.setBacklight()</samp>
    打开背光。你可以通过使用 255 来开启背光，0 来关闭背光；在此草图中，背光设置为开启状态 ❸。
- en: 'The sketch uses the usual LCD functions: <samp class="SANS_TheSansMonoCd_W5Regular_11">lcd.home()</samp>
    resets the cursor to the top-left character, <samp class="SANS_TheSansMonoCd_W5Regular_11">lcd.clear()</samp>
    clears the display, and so on. If you are using other I²C bus devices in the same
    project, don’t forget to restart the bus to the LCD with another <samp class="SANS_TheSansMonoCd_W5Regular_11">Wire.beginTransmission(0x27)</samp>
    before sending display commands.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 该草图使用了常规的 LCD 函数：<samp class="SANS_TheSansMonoCd_W5Regular_11">lcd.home()</samp>
    将光标重置到左上角，<samp class="SANS_TheSansMonoCd_W5Regular_11">lcd.clear()</samp> 清除显示屏，等等。如果你在同一个项目中使用其他
    I²C 总线设备，记得在发送显示命令之前，使用另一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Wire.beginTransmission(0x27)</samp>
    来重新启动 LCD 的总线。
- en: 'If your display doesn’t work, the bus address for your display could be different
    from the one used in the sketch. You can use the Project #30 I²C scanner sketch
    described in [Chapter 10](chapter10.xhtml) to check the device bus address and
    substitute it into the sketch in place of <samp class="SANS_TheSansMonoCd_W5Regular_11">0x27</samp>.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '如果显示器无法工作，可能是显示器的总线地址与草图中使用的地址不同。你可以使用[第 10 章](chapter10.xhtml)中描述的项目 #30 I²C
    扫描器草图来检查设备的总线地址，并将其替换为草图中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">0x27</samp>。'
- en: <samp class="SANS_Futura_Std_Bold_B_11">Testing the I</samp><samp class="SANS_Futura_Std_Bold_B-SUP_11">2</samp><samp
    class="SANS_Futura_Std_Bold_B_11">C LCD and PS/2 Keyboard</samp>
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">测试 I</samp><samp class="SANS_Futura_Std_Bold_B-SUP_11">2</samp><samp
    class="SANS_Futura_Std_Bold_B_11">C LCD 和 PS/2 键盘</samp>
- en: Now that you’ve experimented with the I²C LCD and the keyboard separately, this
    section shows how they can work together as a test of the combined hardware. I
    hope this helps inspire your own independent project ideas, such as a text editor
    using an LCD or perhaps your own text-based game.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经分别实验了 I²C LCD 和键盘，本节将展示它们如何作为一个综合硬件进行协作。我希望这能激发你自己独立项目的灵感，比如使用 LCD 的文本编辑器，或许是你自己设计的基于文本的游戏。
- en: Connect the keyboard and LCD as described in the previous sections and then
    enter and upload the [Listing 13-3](#LiT-13-3) sketch.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 按照前面的章节连接键盘和 LCD，然后输入并上传[清单 13-3](#LiT-13-3)草图。
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-3: The LCD and keyboard
    working together</samp>'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 13-3：LCD 和键盘协同工作</samp>
- en: In a few moments, the LCD backlight should illuminate, and a block cursor should
    start blinking at the top left of the LCD. Now start typing. Whatever you type
    on the keyboard—including text, symbols, and most function keys—should appear
    and then wrap around the screen as if the LCD were a small text editor, as shown
    in [Figure 13-9](chapter13.xhtml#fig13-9). (I’ve turned off the backlight for
    a clearer photograph.)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，LCD 背光应该会亮起，块状光标应开始在 LCD 的左上角闪烁。现在开始输入。你在键盘上输入的任何内容——包括文本、符号和大多数功能键——都会显示出来，并且在屏幕上循环，就像
    LCD 是一个小型文本编辑器一样，如[图 13-9](chapter13.xhtml#fig13-9)所示。（为了更清晰的照片，我已关闭背光。）
- en: '![A PHOTO OF THE LCD DISPLAYING TEXT ENTERED VIA THE PS/2 KEYBOARD, “THE QUICK
    BROWN FOX JUMPED OVER”](../images/fig13-9.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![显示通过 PS/2 键盘输入的文本“THE QUICK BROWN FOX JUMPED OVER”的 LCD 照片](../images/fig13-9.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-9: The LCD displaying
    text entered via the PS/2 keyboard</samp>'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 13-9：LCD 显示通过 PS/2 键盘输入的文本</samp>
- en: You can press ESC to clear the screen and move the cursor back to the top left.
    The sketch simply takes input from the keyboard (apart from ESC) and sends each
    press to the display.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按ESC键清除屏幕并将光标移回左上角。程序会从键盘（除了ESC键）获取输入，并将每次按键发送到显示器。
- en: The sketch first initializes the required libraries for the LCD and keyboard
    and creates two variables to store the position of the cursor ❶. It then starts
    the keyboard and LCD and turns on the LCD backlight and blinking cursor.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 程序首先初始化LCD和键盘所需的库，并创建两个变量来存储光标的位置 ❶。然后，它启动键盘和LCD，打开LCD背光和闪烁的光标。
- en: The main loop of the sketch starts ❷ by checking for a press from the keyboard
    and deciding what to do based on the press ❸. First the project checks to see
    whether the user has pressed ENTER. If so, the cursor on the LCD moves to the
    start of the second line or is sent back to the start of the first line if it’s
    already on the second line. The sketch similarly checks for a press of TAB ❹ and
    displays this on the LCD if so. Or, if the user presses ESC ❺, the screen is cleared
    and the cursor moves back to the top left of the LCD.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的主循环首先通过检查键盘上的按键来启动，并根据按键判断接下来要执行的操作 ❷。首先，项目检查用户是否按下了回车键。如果是，LCD上的光标会移动到第二行的起始位置，如果光标已经在第二行，则返回第一行的起始位置。程序同样检查是否按下了TAB键
    ❹，如果按下，就在LCD上显示。或者，如果用户按下ESC ❺，屏幕会清空，光标会移回LCD的左上角。
- en: The sketch continues to check for other keypresses and displays the name of
    the appropriate keys on the LCD ❻. This includes presses of any other keys that
    don’t belong in the previous checks, including letters, numbers, and symbols ❼.
    After every keypress, the cursor position on the LCD is increased so it moves
    along one character for columns ❽ and rows ❾ and moves to the next line or the
    top left of the LCD when necessary ❿.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 程序会继续检查其他按键并在LCD上显示相应按键的名称 ❻。这包括按下任何其他不属于前述检查的按键，包括字母、数字和符号 ❼。每次按键后，LCD上的光标位置会增加，使其在列
    ❽ 和行 ❾ 上移动，并在必要时移动到下一行或LCD的左上角 ❿。
- en: Now that you know how to read the PS/2 keyboard and display the keys pressed,
    you’ll put these skills to use with the following project that reads integers
    from the keyboard and works with them to control the brightness and colors available
    with an RGB LED.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何读取PS/2键盘并显示按下的按键，你将在以下项目中使用这些技能，通过从键盘读取整数并与其一起工作，控制RGB LED的亮度和可用颜色。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #39: Creating an RGB LED Tester</samp>'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Heavy_B_21">项目 #39：创建RGB LED测试仪</samp>'
- en: In future projects, you may want to test the various colors that can be displayed
    using a red, green, and blue (RGB) LED to calibrate the settings to reach the
    desired LED brightness and color. In this project, you’ll build a device that
    accepts pulse-width modulation (PWM) values for each color and then controls each
    LED for a defined length of time. If you don’t have an RGB LED, you can still
    enjoy and understand this project using three separate LEDs.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来的项目中，你可能需要测试可以通过红、绿、蓝（RGB）LED显示的各种颜色，以便校准设置，以达到所需的LED亮度和颜色。在这个项目中，你将构建一个设备，该设备接受每种颜色的脉宽调制（PWM）值，并根据定义的时间控制每个LED。如果你没有RGB
    LED，仍然可以使用三个独立的LED来享受和理解这个项目。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*You can learn more about PWM in Chapter 19 of* Arduino Workshop*, 2nd edition
    (No Starch Press, 2021).*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以在《Arduino Workshop》（第二版，No Starch Press，2021年）第19章了解更多关于PWM的内容。*'
- en: 'You’ll need the following parts for this project:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目需要以下部件：
- en: An Arduino Uno or compatible board and USB cable
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Arduino Uno或兼容板和USB电缆
- en: A PS/2 breakout board
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个PS/2分线板
- en: A PS/2 keyboard
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个PS/2键盘
- en: A PCF8574 LCD module
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个PCF8574 LCD模块
- en: One common-cathode RGB LED or one each of RGB LEDs
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个共阴极RGB LED或各自一个RGB LED
- en: Three 1 kΩ, 0.25 W, 1 percent resistors
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个1 kΩ、0.25 W、1%精度的电阻器
- en: A solderless breadboard
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个无焊接面包板
- en: Various jumper wires
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种跳线
- en: Assemble the circuit as shown in [Figure 13-10](chapter13.xhtml#fig13-10). In
    this project, the breadboard is used as a bridge to help create more 5V and GND
    connections for the two modules to the Arduino.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 按照[图13-10](chapter13.xhtml#fig13-10)中的电路图组装电路。在这个项目中，面包板被用作桥接，帮助为两个模块与Arduino之间提供更多的5V和GND连接。
- en: '![THE SCHEMATIC FOR PROJECT #39](../images/fig13-10.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![项目#39的电路图](../images/fig13-10.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-10: The schematic
    for Project #39</samp>'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图13-10：项目#39的电路图</samp>
- en: 'Now enter and upload the Project #39 sketch. The LCD should display <samp class="SANS_TheSansMonoCd_W5Regular_11">R:</samp>.
    Using the PS/2 keyboard, enter a three-digit value between 000 and 255 to set
    the PWM value for the red LED. The greater the number, the stronger the color
    will be in the LED. Repeat this process for the green and blue LEDs in response
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">G:</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">B:</samp>
    prompts. Finally, the LCD should display a <samp class="SANS_TheSansMonoCd_W5Regular_11">T:</samp>
    prompt. Key in your required duration for the LEDs to be activated, between 000
    and 255 seconds. The LEDs should then activate according to your instructions.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '现在输入并上传项目 #39 的草图。LCD 应显示 <samp class="SANS_TheSansMonoCd_W5Regular_11">R:</samp>。使用
    PS/2 键盘，输入一个介于 000 和 255 之间的三位数字值，用来设置红色 LED 的 PWM 值。数字越大，LED 中的颜色越强。对绿色和蓝色 LED
    重复这个过程，以响应 <samp class="SANS_TheSansMonoCd_W5Regular_11">G:</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">B:</samp>
    提示。最后，LCD 应显示 <samp class="SANS_TheSansMonoCd_W5Regular_11">T:</samp> 提示。输入你要求的
    LED 激活持续时间，单位为 000 到 255 秒。LED 将根据你的指示激活。'
- en: '[Figure 13-11](chapter13.xhtml#fig13-11) shows the results of entering in the
    brightness values for all three LEDs and the duration of activation in seconds.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-11](chapter13.xhtml#fig13-11) 显示了输入所有三个 LED 的亮度值以及激活时长（秒）的结果。'
- en: '![AN EXAMPLE OUTPUT ON THE LCD FROM PROJECT #39\. “R = 255\. G = 127\. B =
    090\. T = 060”](../images/fig13-11.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![来自项目 #39 的 LCD 示例输出。 “R = 255\. G = 127\. B = 090\. T = 060”](../images/fig13-11.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-11: The Project #39
    user interface in operation</samp>'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 13-11：项目 #39 操作中的用户界面</samp>'
- en: 'Let’s see how this works:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何工作的：
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The sketch first includes and configures the I²C LCD and keyboard libraries,
    as usual ❶, and then defines the LEDs’ Arduino digital pin numbers to color names
    for ease of reference. The custom function <samp class="SANS_TheSansMonoCd_W5Regular_11">readDigit()</samp>
    ❷ returns an integer that is used to return the press of a number on the PS/2
    keyboard. This function uses a variable <samp class="SANS_TheSansMonoCd_W5Regular_11">_digit</samp>,
    which is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">–1</samp> upon initialization
    and stays at that value until a number key is pressed. It then returns the value
    of any button the user presses as the return value for the function.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 草图首先像往常一样包含并配置 I²C LCD 和键盘库 ❶，然后将 LED 的 Arduino 数字引脚号定义为颜色名称，方便参考。自定义函数 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">readDigit()</samp> ❷ 返回一个整数，该整数用于返回按下的
    PS/2 键盘数字。此函数使用一个变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">_digit</samp>，初始化时设置为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">–1</samp>，并保持该值直到按下数字键。然后，它返回用户按下的任何按钮的值，作为函数的返回值。
- en: Since the <samp class="SANS_TheSansMonoCd_W5Regular_11">readDigit()</samp>function
    needs to wait until a number is pressed on the keyboard, a <samp class="SANS_TheSansMonoCd_W5Regular_11">do…while</samp>
    function ❸ continues to loop while awaiting a keypress by testing the value of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">_digit</samp>. When the sketch detects
    a keypress, however, the function interrogates the key’s value with a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch…case</samp>
    function. The value of <samp class="SANS_TheSansMonoCd_W5Regular_11">_digit</samp>
    is then set to the value of the number key pressed, which is equal to the number
    plus 1\. For example, if the user presses the 5 key, the sketch adds 6 to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">_digit</samp> to reflect this. If the
    user doesn’t press one of the numbers, it will return a 0 for _<samp class="SANS_TheSansMonoCd_W5Regular_11">digit</samp>.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">readDigit()</samp> 函数需要等待直到键盘按下数字，因此
    <samp class="SANS_TheSansMonoCd_W5Regular_11">do…while</samp> 函数 ❸ 会持续循环，直到通过测试
    <samp class="SANS_TheSansMonoCd_W5Regular_11">_digit</samp> 的值来等待按键。当草图检测到按键时，函数会通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">switch…case</samp> 函数来查询按键的值。然后，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">_digit</samp> 的值被设置为按下的数字键的值，等于数字加 1。例如，如果用户按下数字
    5 键，草图将向 <samp class="SANS_TheSansMonoCd_W5Regular_11">_digit</samp> 添加 6 来反映这一点。如果用户没有按下任何数字，则
    <samp class="SANS_TheSansMonoCd_W5Regular_11">_digit</samp> 返回 0。
- en: Once the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">_digit</samp>
    has changed, the test in the <samp class="SANS_TheSansMonoCd_W5Regular_11">do…while</samp>
    function ❺ fails. The code can thus continue to display the appropriate number
    on the LCD ❹ and return the value of the number pressed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦<samp class="SANS_TheSansMonoCd_W5Regular_11">_digit</samp>的值发生变化，<samp class="SANS_TheSansMonoCd_W5Regular_11">do…while</samp>函数中的测试❺就会失败。因此，代码可以继续在LCD上显示适当的数字❹，并返回按下的数字值。
- en: The project needs three-digit values from the user for PWM and time values.
    Therefore, the custom function <samp class="SANS_TheSansMonoCd_W5Regular_11">get3digit()</samp>
    ❻ creates a three-digit number by calling for a digit from the keyboard three
    times and then combining the number into the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>,
    which is returned as the result of this function.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目需要用户输入三个数字值来设置PWM和时间值。因此，用户自定义函数<samp class="SANS_TheSansMonoCd_W5Regular_11">get3digit()</samp>❻通过从键盘读取三次数字并将其组合成变量<samp
    class="SANS_TheSansMonoCd_W5Regular_11">z</samp>，作为该函数的返回结果。
- en: The sketch starts the I²C bus, LCD, and keyboard ❼ and then sets the digital
    pins for the LEDs to outputs using port manipulation (discussed in [Chapter 2](chapter2.xhtml)).
    I’ve set variables to hold the PWM values for each LED and time on delay ❽. The
    project then accepts the user’s value for red PWM, green PWM, blue PWM, and the
    number of seconds for the LEDs to stay on. These are actioned at ❾, and the delay
    is converted to milliseconds. Once the delay has finished, the LEDs are turned
    off, and the system starts again.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 草图启动I²C总线、LCD和键盘❼，然后通过端口操作设置LED的数字引脚为输出（详见[第2章](chapter2.xhtml)）。我设置了变量来保存每个LED的PWM值和时间延迟❽。接着，项目接受用户输入的红色PWM、绿色PWM、蓝色PWM和LED点亮的秒数。这些操作会在❾执行，延迟时间转换为毫秒。一旦延迟结束，LED会熄灭，系统重新开始。
- en: Now that you have an example of capturing and working with numerical input from
    a PS/2 keyboard, you’ll build a device to capture text as well, saving that input
    to an SD card for use with a PC.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经掌握了从PS/2键盘获取和处理数字输入的示例，接下来您将构建一个设备，用于捕获文本并将其保存到SD卡，以便与PC一起使用。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #40: Building a Text Capture
    Device</samp>'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_21">项目#40：构建文本捕获设备</samp>
- en: The text capture device described in this project lets you record notes or other
    writing for later reference, without the distractions of internet or cell phone
    notifications to lure you away from real work. Everything you type onto the project’s
    PS/2 keyboard is recorded to a text file on an SD memory card, which you can then
    open on your PC for final editing.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目中描述的文本捕获设备让您可以记录笔记或其他文本，供以后参考，不会被互联网或手机通知等干扰，避免分心。这一切您在项目中的PS/2键盘上输入的内容都会被记录到SD存储卡上的文本文件中，您可以在PC上打开该文件进行最终编辑。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*You can learn more about using SD memory cards in Chapter 7 of* Arduino Workshop*,
    2nd edition (No Starch Press, 2021).*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*您可以在《Arduino工作坊》第二版（No Starch Press, 2021）第7章中了解更多关于使用SD存储卡的内容。*'
- en: 'You’ll need the following parts for this project:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目需要以下零件：
- en: An Arduino Uno or compatible board and USB cable
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块Arduino Uno或兼容板及USB线
- en: A PS/2 breakout board
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个PS/2接线板
- en: A PS/2 keyboard
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台PS/2键盘
- en: A PCF8574 LCD module
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个PCF8574 LCD模块
- en: An SD card module or SD card shield for Arduino
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个SD卡模块或Arduino的SD卡扩展板
- en: A blank SD memory card
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一张空白SD存储卡
- en: A solderless breadboard
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块无焊接面包板
- en: Various jumper wires
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种跳线
- en: Assemble the circuit as shown in [Figure 13-12](chapter13.xhtml#fig13-12). If
    you’re using the SD card shield, insert it onto the Arduino and then connect the
    LCD and PS/2 modules. Again, this project uses the breadboard as a bridge to help
    create more 5V and GND connections for the two modules to the Arduino.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 按照[图13-12](chapter13.xhtml#fig13-12)所示组装电路。如果使用SD卡扩展板，请将其插入Arduino，然后连接LCD和PS/2模块。再次提醒，本项目使用面包板作为桥梁，帮助为这两个模块提供更多的5V和GND连接到Arduino。
- en: '![THE SCHEMATIC FOR PROJECT #40](../images/fig13-12.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![项目#40的原理图](../images/fig13-12.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-12: The schematic
    for Project #40</samp>'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图13-12：项目#40的原理图</samp>
- en: 'Now enter and upload the Project #40 sketch and then insert the SD card into
    the module. Start typing when prompted by the LCD, as shown in [Figure 13-13](chapter13.xhtml#fig13-13).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输入并上传项目#40的草图，然后将SD卡插入模块。当LCD提示时开始输入，如[图13-13](chapter13.xhtml#fig13-13)所示。
- en: '![A PHOTO OF THE LCD FROM PROJECT #40 DISPLAYING TEXT CAPTURED FROM THE KEYBOARD.
    “START TYPING: THE QUICK BROWN”](../images/fig13-13.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![项目 #40 的 LCD 显示从键盘捕获的文本：“开始输入：快速的棕色”](../images/fig13-13.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-13: The LCD from
    Project #40 displaying text captured from a keyboard</samp>'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 13-13：项目 #40 的 LCD 显示从键盘捕获的文本</samp>'
- en: As you continue typing, the cursor should scroll around to the second row and
    then back to the first, in the same manner as shown in [Figure 13-14](chapter13.xhtml#fig13-14).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当您继续输入时，光标应在第二行滚动，然后返回到第一行，方式与 [图 13-14](chapter13.xhtml#fig13-14) 所示相同。
- en: '![A PHOTO OF THE LCD FROM PROJECT #40 DISPLAYING TEXT CAPTURED FROM THE KEYBOARD
    SCROLLING ACROSS TWO LINES: “FOX JUMPED OVER THE LAZY BROWN DOG. N”](../images/fig13-14.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![项目 #40 的 LCD 显示从键盘捕获的文本，滚动跨越两行：“狐狸跳过懒惰的棕色狗。N”](../images/fig13-14.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-14: Text scrolling
    across two lines in the LCD</samp>'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 13-14：文本在 LCD 上滚动跨越两行</samp>
- en: As you type, the Arduino should automatically save every 100 characters to a
    file on the SD card. When you’ve finished and want to take the SD card away, press
    ESC on the keyboard. The Arduino should save any remaining characters and then
    prompt you to remove the SD card, as shown in [Figure 13-15](chapter13.xhtml#fig13-15).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当您输入时，Arduino 应该自动将每 100 个字符保存到 SD 卡上的文件中。当您输入完毕并且想取出 SD 卡时，按下键盘上的 ESC 键。Arduino
    应该保存剩余的字符，然后提示您取出 SD 卡，如 [图 13-15](chapter13.xhtml#fig13-15) 所示。
- en: '![A PHOTO OF THE LCD FROM PROJECT #40 DISPLAYING THE MESSAGE “OK TO REMOVE
    CARD”](../images/fig13-15.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![项目 #40 的 LCD 显示“可以移除卡片”的消息](../images/fig13-15.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-15: The LCD displaying
    the message that it’s okay to remove the SD card</samp>'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 13-15：LCD 显示可以移除 SD 卡的消息</samp>
- en: If there’s an issue with the SD card anytime you attempt a save, the display
    should show the message <samp class="SANS_TheSansMonoCd_W5Regular_11">SD card
    fail</samp>, as shown in [Figure 13-16](chapter13.xhtml#fig13-16).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在任何尝试保存时 SD 卡出现问题，显示器应显示信息 <samp class="SANS_TheSansMonoCd_W5Regular_11">SD
    card fail</samp>，如 [图 13-16](chapter13.xhtml#fig13-16) 所示。
- en: '![A PHOTO OF THE LCD FROM PROJECT #40 DISPLAYING THE “SD CARD FAIL” MESSAGE](../images/fig13-16.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![项目 #40 的 LCD 显示“SD 卡故障”信息的照片](../images/fig13-16.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-16: The LCD indicating
    a problem with the SD card</samp>'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 13-16：LCD 显示 SD 卡出现问题</samp>
- en: In this case, your SD card may not be properly formatted, your write-protect
    switch may be set to ON, or your card may be missing from the module. Once you’ve
    fixed any problems and removed your SD card, you can view and edit the text file
    created with your PC by inserting the SD card into the PC.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您的 SD 卡可能没有正确格式化，写保护开关可能被设置为开启，或者 SD 卡可能没有插入模块中。修复问题并取出 SD 卡后，您可以通过将
    SD 卡插入 PC 来查看和编辑使用您的 PC 创建的文本文件。
- en: 'Let’s see how this works:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的：
- en: '[PRE4]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This sketch builds on [Listing 13-3](#LiT-13-3) to include extra code for writing
    to the SD card. First, it declares the global variables ❶, including the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">array_text[]</samp> buffer to hold the
    user input before writing to the SD card, the <samp class="SANS_TheSansMonoCd_W5Regular_11">_counter</samp>
    variable used to track the number of characters that are stored in the buffer,
    and the cursor position on the LCD.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 本草图基于 [列表 13-3](#LiT-13-3) 构建，加入了写入 SD 卡的额外代码。首先，它声明了全局变量 ❶，包括用于在写入 SD 卡之前保存用户输入的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">array_text[]</samp> 缓冲区，跟踪缓冲区中存储字符数的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">_counter</samp> 变量，以及 LCD 上的光标位置。
- en: Next, the sketch includes and initializes the required libraries for the SD
    card module, LCD, and keyboard. The custom function <samp class="SANS_TheSansMonoCd_W5Regular_11">halt()</samp>
    ❷ is used to stop the sketch operation and is called after the text is saved to
    the SD card so the user can safely remove the card. It simply loops around forever
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">do…while</samp> function,
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> is always true.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，程序包含并初始化SD卡模块、LCD和键盘所需的库。自定义函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">halt()</samp>
    ❷ 用于停止程序的操作，并在文本保存到SD卡后调用，以便用户可以安全地移除SD卡。它仅在 <samp class="SANS_TheSansMonoCd_W5Regular_11">do…while</samp>
    函数中永久循环，因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> 始终为真。
- en: The custom function <samp class="SANS_TheSansMonoCd_W5Regular_11">saveText(boolean
    _halt)</samp> ❸ saves data to the SD card, either saving text and returning to
    user input or saving text and ending operation, as indicated by the Boolean parameter
    <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>,
    respectively. The function checks whether the SD card is okay to use, stopping
    and returning an error if there’s an issue, as shown in [Figure 13-16](chapter13.xhtml#fig13-16).
    If there are no errors, the sketch opens the file whose name is set in this function,
    to which it will write the data; it creates that file if none exists ❹. The sketch
    then writes the text buffer to the SD card and clears the buffer to prepare it
    for more data.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">saveText(boolean _halt)</samp>
    ❸ 将数据保存到SD卡，具体是根据布尔参数 <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> 来决定是保存文本并返回用户输入，还是保存文本并结束操作。该函数会检查SD卡是否可用，如果出现问题，会停止并返回错误，具体如[图13-16](chapter13.xhtml#fig13-16)所示。如果没有错误，程序将打开此函数中设置的文件并向其写入数据；如果文件不存在，则会创建该文件
    ❹。然后，程序会将文本缓冲区写入SD卡，并清空缓冲区，以准备接收更多数据。
- en: If the parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> was
    passed to the <samp class="SANS_TheSansMonoCd_W5Regular_11">saveText(boolean _halt)</samp>
    function ❺, the code opens the file on the SD card, writes a line of dashes to
    end the text file, and then closes it and indicates this to the user, as shown
    in [Figure 13-15](chapter13.xhtml#fig13-15). From ❻, the usual requirements for
    activating the I²C bus, LCD, and keyboard, as well as setting D10 to an output
    for the SD card module’s SPI interface, occur.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数 <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> 被传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">saveText(boolean
    _halt)</samp> 函数 ❺，代码会打开SD卡上的文件，写入一行破折号来结束文本文件，然后关闭该文件并向用户指示，具体如[图13-15](chapter13.xhtml#fig13-15)所示。从
    ❻ 开始，通常需要激活I²C总线、LCD和键盘，并设置D10为SD卡模块SPI接口的输出。
- en: 'Next, the sketch sets up the project’s main operation: capturing text from
    the keyboard, displaying it on the LCD, and writing it to the SD card. At ❼ the
    sketch is ready to receive a keystroke from the PS/2 keyboard. If the user presses
    ENTER, the sketch inserts a new line character | in the text array ❽, increments
    the size counter of the array by 1, and moves the cursor along the LCD as required
    to the alternate line. If the user presses ESC, the sketch clears the LCD, saves
    the data to the SD card, and stops operation via a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">saveText(true);</samp>.
    All other keypresses are inserted into the text array as normal text ❾, which
    is then displayed on the LCD, while the sketch increments the size counter by
    1.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，程序设置项目的主要操作：从键盘捕获文本，显示在LCD上，并将其写入SD卡。在 ❼ 处，程序准备接收来自PS/2键盘的按键。如果用户按下ENTER，程序将在文本数组中插入一个换行符
    | ❽，将数组的大小计数器增加1，并根据需要将光标移动到LCD的另一行。如果用户按下ESC，程序会清除LCD，将数据保存到SD卡，并通过调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">saveText(true);</samp>
    停止操作。所有其他按键都会作为普通文本插入到文本数组 ❾ 中，然后显示在LCD上，同时程序将大小计数器加1。
- en: The sketch then checks the text array size. If it is greater than or equal to
    99 characters in size, the text array is written to the text file by calling <samp
    class="SANS_TheSansMonoCd_W5Regular_11">saveText(false);</samp> ❿, which returns
    to normal text capture after the write, followed by resetting the counter to 0\.
    Finally, the sketch updates the cursor position, checking if the text runs over
    the margin and repositioning the cursor if necessary.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，程序会检查文本数组的大小。如果数组的大小大于或等于99个字符，程序会通过调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">saveText(false);</samp>
    ❿ 将文本数组写入文本文件，写入后返回正常的文本捕获状态，并将计数器重置为0。最后，程序会更新光标位置，检查文本是否超出边距，并在必要时重新定位光标。
- en: 'For a final challenge, you might add a real-time clock to Project #40, as well
    as a data timestamp when the file is closed.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最终挑战，你可以为第40号项目添加一个实时钟表，并在文件关闭时加上数据时间戳。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp>
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">继续前进</samp>
- en: Many projects suffer from a poor user interface; as you saw in this chapter,
    using a PS/2 keyboard simplifies the process of entering data into a project.
    In this chapter, you learned how to capture data from the keyboard into an Arduino
    and how to save data entered with the keyboard. I hope this chapter served as
    inspiration for improving the configuration or operation in your own work.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 许多项目的用户界面表现不佳；正如你在这一章中看到的，使用PS/2键盘简化了数据输入的过程。在这一章中，你学习了如何将键盘数据捕获到Arduino中，并如何保存键盘输入的数据。希望本章能为你改善自己项目的配置或操作提供一些灵感。
- en: In the next chapter, I’ll show you how to harness Bluetooth modules to allow
    for wireless communication between smartphones and other devices with your Arduino
    projects.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将向你展示如何利用蓝牙模块，让智能手机与其他设备通过无线通信与Arduino项目进行连接。
