<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Makefile Debugging"><div class="titlepage"><div><div><h1 class="title"><a id="makefile_debugging"/>Chapter 2. Makefile Debugging</h1></div></div></div><p><a id="iddle1168" class="indexterm"/><a id="iddle1172" class="indexterm"/><a id="iddle1641" class="indexterm"/><a id="iddle1878" class="indexterm"/>This chapter covers techniques that can be useful when debugging makefiles. The lack of built-in debugging tools, and the complexities of following variables in <code class="literal">make</code>, can make it very challenging to understand why a particular target was (or more often was not) built.</p><p>The first recipe in this chapter shows the single most useful line that you can add to a makefile; it’s the equivalent of a print statement inserted into code for debugging.</p><div class="sect1" title="Printing the Value of a Makefile Variable"><div class="titlepage"><div><div><h1 class="title"><a id="printing_the_value_of_a_makefile_variabl"/>Printing the Value of a Makefile Variable</h1></div></div></div><p>If you’ve ever looked in a makefile, you’ll realize that makefile variables (often just called variables) form the backbone of any <code class="literal">make</code> process. Variables often define which files will be compiled, what command line parameters to <a id="iddle1013" class="indexterm"/><a id="iddle1028" class="indexterm"/><a id="iddle1511" class="indexterm"/><a id="iddle1517" class="indexterm"/><a id="iddle1619" class="indexterm"/><a id="iddle1870" class="indexterm"/><a id="iddle1911" class="indexterm"/>pass to compilers, and even where to find the compiler. And if you’ve ever tried to debug a makefile, you know that the number one question you ask yourself is, “What is the value of variable <code class="literal">X</code>?”</p><p>GNU <code class="literal">make</code> doesn’t have a built-in debugger, nor does it provide the sort of interactivity you’d get from a scripting language like Perl or Python. So how do you figure out the value of a variable?</p><p>Take a look at the simple makefile shown in <a class="xref" href="ch02.html#simple_makefile_that_sets_various_variab" title="Example 2-1. A simple makefile that sets various variables">Example 2-1</a>, which just sets various variables:</p><div class="example"><a id="simple_makefile_that_sets_various_variab"/><p class="title">Example 2-1. A simple makefile that sets various variables</p><div class="example-contents"><pre class="programlisting">X=$(YS) hate $(ZS)
Y=dog
YS=$(Y)$(S)
Z=cat
ZS=$(Z)$(S)
S=s

all:</pre></div></div><p>What is the value of <code class="literal">X</code>?</p><p>The small size and simplicity of this makefile make it feasible to trace through all the variable assignments, but even then it takes some work to conclude that <code class="literal">X</code> is <code class="literal">dogs hate cats</code>. In a multi-thousand-line makefile, one that fully utilizes the power of GNU <code class="literal">make</code>’s variables and functions, figuring out the value of a variable can be laborious indeed. Fortunately, here’s a little <code class="literal">make</code> recipe that does all the work for you:</p><a id="pro_id00138"/><pre class="programlisting">print-%: ; @echo $* = $($*)</pre><p>Now you can find the value of variable <code class="literal">X</code> with the following command:</p><a id="pro_id00139"/><pre class="programlisting">$ <span class="strong"><strong>make print-X</strong></span></pre><p>Because an explicit rule for the <code class="literal">print-X</code> target doesn’t exist, <code class="literal">make</code> looks for a pattern rule, finds <code class="literal">print-%</code> (the <code class="literal">%</code> acts as a wildcard), and runs the associated command. The command uses <code class="literal">$*</code>, a special variable that contains the value matched by the <code class="literal">%</code> in the rule, to print the name of the variable, and then does <code class="literal">$($*)</code> to get its value. This is a very useful technique in makefiles because it allows the name of a variable to be computed. In this case, the name of the variable to be printed comes from another variable, <code class="literal">$*</code>.</p><p>Here’s how this rule can be used to print the values of variables defined in the makefile in <a class="xref" href="ch02.html#simple_makefile_that_sets_various_variab" title="Example 2-1. A simple makefile that sets various variables">Example 2-1</a>:</p><a id="pro_id00140"/><pre class="programlisting">$ <span class="strong"><strong>make print-X</strong></span>
X = dogs hate cats
$ <span class="strong"><strong>make print-YS</strong></span>
YS = dogs
$ <span class="strong"><strong>make print-S</strong></span>
S = s</pre><p><a id="iddle1169" class="indexterm"/><a id="iddle1227" class="indexterm"/><a id="iddle1588" class="indexterm"/><a id="iddle1640" class="indexterm"/><a id="iddle1872" class="indexterm"/>Sometimes it’s useful to know <span class="emphasis"><em>how</em></span> a variable was defined. <code class="literal">make</code> has the <code class="literal">$origin</code> function, which returns a string containing the <span class="emphasis"><em>type</em></span> of a variable—that is, whether it was defined in a makefile, on the command line, or in the environment. Modifying <code class="literal">print-%</code> to print out origin information as well is easy:</p><a id="pro_id00141"/><pre class="programlisting">print-%: ; @echo $* = '$($*)' from $(origin $*)</pre><p>Now we see that <code class="literal">YS</code> is defined in the makefile:</p><a id="pro_id00142"/><pre class="programlisting">$ <span class="strong"><strong>make print-YS</strong></span>
YS = 'dogs' from file</pre><p>If we override the value of <code class="literal">YS</code> on the command line, we’ll see:</p><a id="pro_id00143"/><pre class="programlisting">$ <span class="strong"><strong>make print-YS YS=fleas</strong></span>
YS = 'fleas' from command line</pre><p>Because <code class="literal">YS</code> was set on the <code class="literal">make</code> command line, its <code class="literal">$(origin)</code> is now <code class="literal">command line</code> and no longer <code class="literal">file</code>.</p></div><div class="sect1" title="Dumping Every Makefile Variable"><div class="titlepage"><div><div><h1 class="title"><a id="dumping_every_makefile_variable"/>Dumping Every Makefile Variable</h1></div></div></div><p>The previous section showed you how to print the value of a single makefile variable using a special rule. But what if you want to print every variable defined in a makefile?</p><p>Fortunately, GNU <code class="literal">make</code> 3.80 introduced a couple of new features that make it feasible to print the value of all the variables defined in a makefile using a single rule.</p><p>Consider <a class="xref" href="ch02.html#simple_makefile_that_sets_various_variab" title="Example 2-1. A simple makefile that sets various variables">Example 2-1</a> again. It sets five variables: <code class="literal">X</code>, <code class="literal">Y</code>, <code class="literal">Z</code>, <code class="literal">S</code>, <code class="literal">YS</code>, and <code class="literal">ZS</code>. Adding the following lines to the example creates a target called <code class="literal">printvars</code> that will dump all the variables defined in the makefile, as shown in <a class="xref" href="ch02.html#target_to_print_all_variables" title="Example 2-2. A target to print all variables">Example 2-2</a>.</p><div class="example"><a id="target_to_print_all_variables"/><p class="title">Example 2-2. A target to print all variables</p><div class="example-contents"><pre class="programlisting">.PHONY: printvars
printvars:
→ @$(foreach V,$(sort $(.VARIABLES)),            \
→ $(if $(filter-out environ% default automatic,  \
→ $(origin $V)),$(info $V=$($V) ($(value $V)))))</pre></div></div><p>Before we look closely at how this works, try it out on your own, as shown in <a class="xref" href="ch02.html#all_the_variables_from_listing_2-1_dumpe" title="Example 2-3. All the variables from Example 2-1 dumped by printvars">Example 2-3</a>.</p><div class="example"><a id="all_the_variables_from_listing_2-1_dumpe"/><p class="title">Example 2-3. All the variables from <a class="xref" href="ch02.html#simple_makefile_that_sets_various_variab" title="Example 2-1. A simple makefile that sets various variables">Example 2-1</a> dumped by <code class="literal">printvars</code></p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>make printvars</strong></span>
MAKEFILE_LIST= Makefile helper.mak ( Makefile helper.mak)
MAKEFLAGS= ()
S=s (s)
SHELL=/bin/sh (/bin/sh)
X=dogs hate cats ($(YS) hate $(ZS))
Y=dog (dog)
YS=dogs ($(Y)$(S))
Z=cat (cat)
ZS=cats ($(Z)$(S))</pre></div></div><p><a id="iddle1284" class="indexterm"/><a id="iddle1859" class="indexterm"/><a id="iddle1892" class="indexterm"/>Notice how <code class="literal">make</code> has thrown in three extra variables that weren’t explicitly defined—<code class="literal">MAKEFILE_LIST</code>, <code class="literal">MAKEFLAGS</code>, and <code class="literal">SHELL</code>—but the rest are all defined in the makefile. Each line shows the name of the variable, its fully substituted value, and the way in which it was defined.</p><p>It’s a lot easier to understand the long complex line used to print the variables when it’s reformatted like this:</p><a id="pro_id00144"/><pre class="programlisting">   $(foreach V,$(sort $(.VARIABLES)),
     $(if
➊    $(filter-out environment% default automatic,$(origin $V)),
       $(info $V=$($V) ($(value $V)))
     )
   )</pre><p>The <code class="literal">.VARIABLES</code> variable is a new feature in GNU <code class="literal">make</code> 3.80: its value is a list of the names of all the variables defined in the makefile. First, the code sorts it into order: <code class="literal">$(sort $(.VARIABLES))</code>. Then it goes through the sorted list, variable name by variable name, and sets <code class="literal">V</code> to each name in turn: <code class="literal">$(foreach V,$(sort (.VARIABLES)),...)</code>.</p><p>For each variable name, the loop decides whether to print or ignore the variable depending on how it was defined. If it’s a built-in variable, like <code class="literal">$@</code> or <code class="literal">$(CC)</code>, or came from the environment, it shouldn’t get printed. This decision is made by the predicate at ➊. It first figures out how the variable referenced by <code class="literal">$V</code> was defined by calling <code class="literal">$(origin $V)</code>. This call returns a string describing how the variable was defined: <code class="literal">environment</code> for environment variables, <code class="literal">file</code> for variables defined in a makefile, and <code class="literal">default</code> for things the <code class="literal">make</code> defines. The <code class="literal">$(filter-out)</code> statement says if the result of <code class="literal">$(origin)</code> matches any of the patterns <code class="literal">environment%</code>, <code class="literal">default</code>, or <code class="literal">automatic</code> (<code class="literal">automatic</code> is returned by <code class="literal">$(origin)</code> for <code class="literal">make</code>’s automatic variable like <code class="literal">$@</code>, <code class="literal">$&lt;</code>, and so on), then return an empty string; otherwise, leave it alone. This means <code class="literal">$(if)</code>’s predicate will be true only if the variable was defined in the makefile or set on the command line.</p><p>If <code class="literal">$(if)</code>’s predicate is true, then <code class="literal">$(info $V=$($V) ($(value $V)))</code> outputs a message containing the name of the variable, its fully expanded value, and its defined value. The <code class="literal">$(value)</code> function is another new feature in GNU <code class="literal">make</code> 3.80; it outputs the value of a variable without expanding it. In <a class="xref" href="ch02.html#all_the_variables_from_listing_2-1_dumpe" title="Example 2-3. All the variables from Example 2-1 dumped by printvars">Example 2-3</a>, <code class="literal">$(YS)</code> would return the value <code class="literal">dogs</code>, but <code class="literal">$(value YS)</code> would return <code class="literal">$(Y)$(S)</code>. That is, <code class="literal">$(value YS)</code> shows us how <code class="literal">YS</code> is defined, not its final value. That’s a very useful debugging feature.</p></div><div class="sect1" title="Tracing Variable Values"><div class="titlepage"><div><div><h1 class="title"><a id="tracing_variable_values"/>Tracing Variable Values</h1></div></div></div><p><a id="iddle1174" class="indexterm"/><a id="iddle1835" class="indexterm"/><a id="iddle1887" class="indexterm"/>As a makefile grows, it can become difficult to figure out where a variable is used. This is especially true because of GNU <code class="literal">make</code>’s recursive variables: the use of a variable could be hidden deep inside some other variable declaration in the makefile. This recipe shows how to trace individual variables as they are used.</p><p>For this example, we’ll use the makefile in <a class="xref" href="ch02.html#example_makefile_for_tracing" title="Example 2-4. Example makefile for tracing">Example 2-4</a> (the lines have been numbered for later reference purposes).</p><div class="example"><a id="example_makefile_for_tracing"/><p class="title">Example 2-4. Example makefile for tracing</p><div class="example-contents"><pre class="programlisting"> 1 X=$(YS) hate $(ZS)
 2 Y=dog
 3 YS=$(Y)$(S)
 4 Z=cat
 5 ZS=$(Z)$(S)
 6 S=s
 7
 8 all: $(YS) $(ZS)
 9 all: ; @echo $(X)
10
11 $(YS): ; @echo $(Y) $(Y)
12 $(ZS): ; @echo $(Z) $(Z)</pre></div></div><p>When run, this makefile prints:</p><a id="pro_id00145"/><pre class="programlisting">dog dog
cat cat
dogs hate cats</pre><p>As you can see in <a class="xref" href="ch02.html#example_makefile_for_tracing" title="Example 2-4. Example makefile for tracing">Example 2-4</a>, the makefile contains a number of recursively defined variables and uses them in rule definitions and commands.</p><div class="sect2" title="Tracing Variable Use"><div class="titlepage"><div><div><h2 class="title"><a id="tracing_variable_use"/>Tracing Variable Use</h2></div></div></div><p>If you trace through <a class="xref" href="ch02.html#example_makefile_for_tracing" title="Example 2-4. Example makefile for tracing">Example 2-4</a>, you’ll see that the variable <code class="literal">$(Y)</code> is used on lines 8, 9, and 11, and twice on line 12. It’s amazing how often variables are used! The reason is that <code class="literal">make</code> gets the value of a recursively expanded variable (such as <code class="literal">YS</code> in <a class="xref" href="ch02.html#example_makefile_for_tracing" title="Example 2-4. Example makefile for tracing">Example 2-4</a>) only when it is needed (that is, when the variable is used and hence expanded), and recursively expanded variables are frequently deeply nested.</p><p>It’s annoying enough to trace a variable through the simple makefile in <a class="xref" href="ch02.html#example_makefile_for_tracing" title="Example 2-4. Example makefile for tracing">Example 2-4</a>, but doing so for a real makefile would be practically impossible. Fortunately, it’s possible to get <code class="literal">make</code> to do the work for you with the following code, which you should add to the start of the makefile to be traced (it’ll only get used when explicitly called):</p><a id="pro_id00146"/><pre class="programlisting">ifdef TRACE
.PHONY: _trace _value
_trace: ; @$(MAKE) --no-print-directory TRACE= \
      $(TRACE)='$$(warning TRACE $(TRACE))$(shell $(MAKE) TRACE=$(TRACE) _value)'
_value: ; @echo '$(value $(TRACE))'
endif</pre><p><a id="iddle1781" class="indexterm"/><a id="iddle1833" class="indexterm"/><a id="iddle1897" class="indexterm"/>Before we dive into how it works, here’s an example of using it to trace the value of <code class="literal">Y</code> in our example makefile. To use the tracer, tell <code class="literal">make</code> to run the <code class="literal">trace</code> target by setting the <code class="literal">TRACE</code> variable to the name of the variable you want to trace. Tracing the variable <code class="literal">Y</code> looks like this:</p><a id="pro_id00147"/><pre class="programlisting">$ <span class="strong"><strong>make TRACE=Y</strong></span>
Makefile:8: TRACE Y
Makefile:11: TRACE Y
Makefile:12: TRACE Y
Makefile:12: TRACE Y
dog dog
cat cat
Makefile:9: TRACE Y
dogs hate cats</pre><p>From the <code class="literal">TRACE</code> output you can see <code class="literal">Y</code> being used first on line 8 in the definition of the <code class="literal">all</code> target, which references <code class="literal">Y</code> via the <code class="literal">$(YS)</code>; then on line 11 the definition of the <code class="literal">cats</code> target, which also uses <code class="literal">$(YS)</code>; then twice on line 12 with the two direct references to <code class="literal">$(Y)</code>; and finally on line 9 via <code class="literal">$(X)</code>, which references <code class="literal">$(YS)</code>, which references <code class="literal">$(Y)</code>.</p><p>Likewise, we can use the tracer to find out where <code class="literal">$(S)</code> is used:</p><a id="pro_id00148"/><pre class="programlisting">$ <span class="strong"><strong>make TRACE=S</strong></span>
Makefile:8: TRACE S
Makefile:8: TRACE S
Makefile:11: TRACE S
Makefile:12: TRACE S
dog dog
cat cat
Makefile:9: TRACE S
Makefile:9: TRACE S
dogs hate cats</pre><p>The output shows that <code class="literal">S</code> is first used twice on line 8 (the <code class="literal">all</code> target used <code class="literal">XS</code> and <code class="literal">YS</code>, which both use <code class="literal">S</code>). Then <code class="literal">S</code> appears again on line 4 (because <code class="literal">YS</code> is used) and line 12 (because <code class="literal">XS</code> is used). Finally, <code class="literal">S</code> is used twice on line 9, when <code class="literal">X</code> is echoed as <code class="literal">X</code> is used by <code class="literal">XS</code> and <code class="literal">YS</code>, which both use <code class="literal">S</code>.</p></div><div class="sect2" title="How the Variable Tracer Works"><div class="titlepage"><div><div><h2 class="title"><a id="how_the_variable_tracer_works"/>How the Variable Tracer Works</h2></div></div></div><p>GNU <code class="literal">make</code> has a special <code class="literal">$(warning)</code> function that outputs a warning message to <code class="literal">STDERR</code> and returns the empty string. At a high level, our tracer code changes the value of the variable to be traced to include a <code class="literal">$(warning)</code> message. Every time the variable is expanded, the warning is printed, and whenever <code class="literal">make</code> outputs a warning message, it prints the name of the makefile in use and the line number.</p><p><a id="iddle1142" class="indexterm"/><a id="iddle1728" class="indexterm"/>For example, say the definition of <code class="literal">Y</code> is changed from</p><a id="pro_id00149"/><pre class="programlisting">Y=dog</pre><p>to</p><a id="pro_id00150"/><pre class="programlisting">Y=$(warning TRACE Y)dog</pre><p>Then, whenever <code class="literal">$(Y)</code> is expanded, a warning would be generated, and <code class="literal">$(Y)</code> would have the value <code class="literal">dog</code>. And because <code class="literal">$(warning)</code> doesn’t return any value, the value of <code class="literal">Y</code> is unaffected.</p><p>To add this <code class="literal">$(warning)</code> call, the tracer code first obtains the unexpanded value of the variable to be traced, then prepends it with an appropriate <code class="literal">$(warning)</code>, and finally runs the desired <code class="literal">make</code> with the specially modified value of the variable being examined. It uses the <code class="literal">$(value)</code> function, which as you saw in <a class="xref" href="ch02.html#target_to_print_all_variables" title="Example 2-2. A target to print all variables">Example 2-2</a> enables you to get the unexpanded value of a variable.</p><p>Here’s how the tracer works in detail. If <code class="literal">TRACE</code> is defined, <code class="literal">make</code> will process the block of tracer definitions. In that case, because <code class="literal">_trace</code> is the first target encountered, it will be the rule that runs by default. The <code class="literal">_trace</code> rule contains a single, complex command:</p><a id="pro_id00151"/><pre class="programlisting">@$(MAKE) --no-print-directory TRACE= \
       $(TRACE)='$$(warning TRACE $(TRACE))$(shell $(MAKE) TRACE=$(TRACE) _value)'</pre><p>On the right side of the command is a <code class="literal">$(shell)</code> invocation that reruns the makefile with a different goal. If we are tracing <code class="literal">YS</code>, for example, this <code class="literal">$(shell)</code> runs the command:</p><a id="pro_id00152"/><pre class="programlisting">make TRACE=YS _value</pre><p>This will run the <code class="literal">_value</code> rule, which is defined like so:</p><a id="pro_id00153"/><pre class="programlisting">_value: ; @echo '$(value $(TRACE))'</pre><p>Because <code class="literal">TRACE</code> has been set to <code class="literal">YS</code>, this rule simply echoes the definition of <code class="literal">YS</code>, which is the literal string <code class="literal">$(Y)$(S)</code>. So that’s what <code class="literal">$(shell)</code> ends up evaluating to.</p><p>That <code class="literal">$(shell)</code> call is in fact inside a command line variable definition (usually called a <span class="emphasis"><em>command line override</em></span>):</p><a id="pro_id00154"/><pre class="programlisting">$(TRACE)='$$(warning TRACE $(TRACE))$(shell $(MAKE)TRACE=$(TRACE) _value)'</pre><p>This adds the <code class="literal">$(warning)</code> needed to output the <code class="literal">TRACE X</code> messages. Notice how the name of the variable being defined is a computed value: its name is contained in <code class="literal">$(TRACE)</code>. When tracing <code class="literal">YS</code>, this definition turns into:</p><a id="pro_id00155"/><pre class="programlisting">YS='$(warning TRACE YS)$(Y)$(S)'</pre><p><a id="iddle1038" class="indexterm"/><a id="iddle1752" class="indexterm"/><a id="iddle1868" class="indexterm"/>The single quotes are used to prevent the shell from seeing the <code class="literal">$</code> sign. The double <code class="literal">$</code> is used to prevent <code class="literal">make</code> from seeing the <code class="literal">$</code>. In either case a variable expansion would occur (either in <code class="literal">make</code> or by the shell), and we want to delay any variable expansion until <code class="literal">YS</code> is actually used.</p><p>Finally, the <code class="literal">_trace</code> rule recursively runs <code class="literal">make</code>:</p><a id="pro_id00156"/><pre class="programlisting">make TRACE= YS='$(warning TRACE YS)$(Y)$(S)'</pre><p>The value of <code class="literal">TRACE</code> is reset to the empty string, because this recursive invocation of <code class="literal">make</code> should run the real rules rather than the tracer rules. Also, it overrides the value of <code class="literal">YS</code>. Recall that variables defined on the command line override definitions in the makefile: even though <code class="literal">YS</code> is defined in the makefile, the <code class="literal">warning</code>-enabled, command line definition is the one that’s used. Now, every time <code class="literal">YS</code> is expanded, a warning is printed.</p><p>Note that this technique doesn’t work for a variable that is target specific. <code class="literal">make</code> allows you to define a variable as specific to a target in the manner shown in <a class="xref" href="ch02.html#defining_a_target-specific_variable" title="Example 2-5. Defining a target-specific variable">Example 2-5</a>:</p><div class="example"><a id="defining_a_target-specific_variable"/><p class="title">Example 2-5. Defining a target-specific variable</p><div class="example-contents"><pre class="programlisting">all: FOO=foo
all: a
all: ; @echo $(FOO)

a: ; @echo $(FOO)</pre></div></div><p>The variable <code class="literal">FOO</code> will have the value <code class="literal">foo</code> in the rule that builds <code class="literal">all</code> and in any prerequisites of <code class="literal">all</code>. The makefile in <a class="xref" href="ch02.html#defining_a_target-specific_variable" title="Example 2-5. Defining a target-specific variable">Example 2-5</a> will print <code class="literal">foo</code> twice, because <code class="literal">FOO</code> is defined in both the <code class="literal">all</code> and <code class="literal">a</code> rules. The tracer is unable to obtain the value of <code class="literal">FOO</code> and would in fact cause this makefile to behave incorrectly.</p><p>The tracer works by redefining the variable being traced as described earlier. Because this happens outside a rule definition, the tracer has no way of obtaining the value of a variable that is target specific. For example, in <a class="xref" href="ch02.html#defining_a_target-specific_variable" title="Example 2-5. Defining a target-specific variable">Example 2-5</a>, <code class="literal">FOO</code> is defined only when running the <code class="literal">all</code> or <code class="literal">a</code> rules. The tracer has no way of obtaining its value. Using the tracer on that makefile to trace <code class="literal">FOO</code> results in the wrong behavior:</p><a id="pro_id00157"/><pre class="programlisting">$ <span class="strong"><strong>make TRACE=FOO</strong></span>
Makefile:10: TRACE FOO
Makefile:8: TRACE FOO</pre><p>That should have output <code class="literal">foo</code> twice (once for the <code class="literal">all</code> rule and once for <code class="literal">a</code>), but the tracer has redefined <code class="literal">FOO</code> and messed up its value. Don’t use this tracer for target-specific variables.</p><p><a id="iddle1141" class="indexterm"/><a id="iddle1173" class="indexterm"/><a id="iddle1783" class="indexterm"/><a id="iddle1830" class="indexterm"/><a id="iddle1832" class="indexterm"/><a id="iddle1834" class="indexterm"/>The <code class="literal">$(warning)</code> function sends its output to <code class="literal">STDERR</code>, which makes it possible to separate normal <code class="literal">make</code> output from the tracer. Simply redirect <code class="literal">STDERR</code> to a trace log file. Here’s an example:</p><a id="pro_id00158"/><pre class="programlisting">$ <span class="strong"><strong>make TRACE=S 2&gt; trace.log</strong></span>
dog dog
cat cat
dogs hate cats</pre><p>This command will write normal <code class="literal">make</code> output to the command line while redirecting the trace output to <span class="emphasis"><em>trace.log</em></span>.</p></div></div><div class="sect1" title="Tracing Rule Execution"><div class="titlepage"><div><div><h1 class="title"><a id="tracing_rule_execution"/>Tracing Rule Execution</h1></div></div></div><p>Until GNU <code class="literal">make</code> 4.0, there was no built-in way to trace the order of execution of makefile targets. GNU <code class="literal">make</code> 4.0 added the <code class="literal">--trace</code> option, which I cover in <a class="xref" href="ch02.html#gnu_make_4dot0_tracing" title="GNU make 4.0 Tracing">GNU make 4.0 Tracing</a>, but if you need to use an earlier version of <code class="literal">make</code>, it’s handy to have another way to trace a makefile. The techniques shown here work with GNU <code class="literal">make</code> 4.0 and earlier.</p><div class="note" title="Note"><h3 class="title"><a id="ch02note01"/>Note</h3><p><span class="emphasis"><em>If you’ve ever stared at a cryptic log output and asked yourself, “What rule caused that output?” or “Where’s the output for the <code class="literal">foo</code> rule?” then this section is for you. And to be honest, who hasn’t wondered what GNU <code class="literal">make</code>’s log file output means?</em></span></p></div><div class="sect2" title="An Example"><div class="titlepage"><div><div><h2 class="title"><a id="example"/>An Example</h2></div></div></div><p>This section uses the following example makefile:</p><a id="pro_id00159"/><pre class="programlisting">.PHONY: all
all: foo.o bar

bar: ; @touch $@</pre><p>It builds two files: <code class="literal">foo.o</code> and <code class="literal">bar</code>. We’ll assume that <code class="literal">foo.c</code> exists so that <code class="literal">make</code>’s built-in rules create <code class="literal">foo.o</code>; whereas <code class="literal">bar</code> is a simple rule that just touches <code class="literal">$@</code>. If you run <code class="literal">make</code> for the first time with this makefile, you’d see the following output:</p><a id="pro_id00160"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
cc -c -o foo.o foo.c</pre><p>This log output is rather cryptic. There’s no sign of the rule for <code class="literal">bar</code> being run (because <code class="literal">touch $@</code> was hidden using the <code class="literal">@</code> modifier, which prevents the command from being printed). And there’s no indication that it was the rule for <code class="literal">foo.o</code> that generated the <code class="literal">cc</code> compilation line. Nor is there any indication that the <code class="literal">all</code> rule was used.</p><p><a id="iddle1030" class="indexterm"/><a id="iddle1134" class="indexterm"/><a id="iddle1639" class="indexterm"/><a id="iddle1736" class="indexterm"/><a id="iddle1742" class="indexterm"/><a id="iddle1932" class="indexterm"/>You could, of course, use <code class="literal">make -n</code> (which just prints the commands to be run without actually executing them) to look at the work that GNU <code class="literal">make</code> would perform:</p><a id="pro_id00161"/><pre class="programlisting">$ <span class="strong"><strong>make -n</strong></span>
cc -c -o foo.o foo.c
touch bar</pre><p>In this case it’s practical, but in general <code class="literal">make -n</code>’s output can be just as cryptic as a normal log file, and it doesn’t provide any way of matching lines in the log with lines in the makefile.</p></div><div class="sect2" title="The SHELL Hack"><div class="titlepage"><div><div><h2 class="title"><a id="shell_hack"/>The SHELL Hack</h2></div></div></div><p>One simple way to enhance the output of GNU <code class="literal">make</code> is to redefine <code class="literal">SHELL</code>, which is a built-in variable that contains the name of the shell to use when <code class="literal">make</code> executes commands. Most shells have an <code class="literal">-x</code> option that causes them to print each command they are about to execute; therefore, if you modify <code class="literal">SHELL</code> in a makefile by appending <code class="literal">-x</code>, it will cause every command to be printed as the makefile is run.</p><p>Here’s the example makefile modified using GNU <code class="literal">make</code>’s <code class="literal">+=</code> operator to append <code class="literal">-x</code> to <code class="literal">SHELL</code>:</p><a id="pro_id00162"/><pre class="programlisting">SHELL += -x

.PHONY: all
all: foo.o bar

bar: ; @touch $@</pre><p>In some shells this may not work (the shell may expect a single word of options). In GNU <code class="literal">make</code> 4.0 and later, a variable called <code class="literal">.SHELLFLAGS</code> contains the flags for the shell and can be set to avoid this problem instead of altering <code class="literal">SHELL</code>.</p><p>Now the makefile output reveals that <code class="literal">touch bar</code> was generated by the rule for <code class="literal">bar</code>:</p><a id="pro_id00163"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
cc -c -o foo.o foo.c
+ cc -c -o foo.o foo.c
+ touch bar</pre><p>The <code class="literal">SHELL</code> technique has one disadvantage: it slows <code class="literal">make</code> down. If <code class="literal">SHELL</code> is left untouched, <code class="literal">make</code> will often avoid using the shell altogether if it knows it can execute the command directly—for simple operations like compilation and linking, for example. But once <code class="literal">SHELL</code> is redefined in a makefile, <code class="literal">make</code> will always use the shell, thus slowing it down.</p><p>Of course, that doesn’t make this a bad debugging trick: getting additional information for a brief slowdown is a very small price to pay. But <a id="iddle1294" class="indexterm"/><a id="iddle1740" class="indexterm"/>redefining <code class="literal">SHELL</code> doesn’t help track the relationship between the lines in a log file and the makefile. Fortunately, this is possible to do with an even smarter redefinition of <code class="literal">SHELL</code>.</p></div><div class="sect2" title="An Even Smarter SHELL Hack"><div class="titlepage"><div><div><h2 class="title"><a id="even_smarter_shell_hack"/>An Even Smarter SHELL Hack</h2></div></div></div><p>If <code class="literal">SHELL</code> has been redefined, <code class="literal">make</code> will expand its value before it runs each line of each rule. This means that if the expansion of <code class="literal">SHELL</code> were to output information, it would be possible to print information before each rule runs.</p><p>As you saw in <a class="xref" href="ch02.html#tracing_variable_values" title="Tracing Variable Values">Tracing Variable Values</a>, the <code class="literal">$(warning)</code> function helpfully outputs a string of your choosing, along with the name of the makefile and the line number at which the <code class="literal">$(warning)</code> was written. By adding a <code class="literal">$(warning)</code> call to <code class="literal">SHELL</code>, it’s possible to print detailed information every time <code class="literal">SHELL</code> gets expanded. The following code snippet does just this:</p><a id="pro_id00164"/><pre class="programlisting">OLD_SHELL := $(SHELL)
SHELL = $(warning Building $@)$(OLD_SHELL)

.PHONY: all
all: foo.o bar

bar: ; @touch $@</pre><p>The first line captures the normal value of <code class="literal">SHELL</code> in a variable called <code class="literal">OLD_SHELL</code>. Notice the use of <code class="literal">:=</code> to get <code class="literal">SHELL</code>’s final value, not its definition. The second line defines <code class="literal">SHELL</code> to include the old shell value and a <code class="literal">$(warning)</code> that will print the name of the target being built.</p><p>Running GNU <code class="literal">make</code> now produces very useful information:</p><a id="pro_id00165"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
make: Building foo.o
cc -c -o foo.o foo.c
Makefile:7: Building bar</pre><p>The first line of output is produced when the built-in pattern rule to build <code class="literal">foo.o</code> is about to be executed. Because no makefile or line number information gets printed, we know that a built-in rule was used here. Then you see the actual output of the built-in rule (the <code class="literal">cc</code> command). This is followed by another piece of output from the <code class="literal">$(warning)</code>, stating that <code class="literal">bar</code> is about to be built using the rule in the makefile at line 7.</p><p>We used <code class="literal">$@</code> in the <code class="literal">$(warning)</code> statement that we added to <code class="literal">SHELL</code>, but there’s nothing stopping us from using other automatic variables. For example, in <a class="xref" href="ch02.html#using_the_shell_hack" title="Example 2-6. Using the SHELL hack">Example 2-6</a>, we use <code class="literal">$&lt;</code>, which holds the first prerequisite from which the target is being built, and <code class="literal">$?</code>, which holds the list of prerequisites that are newer than the target and tells us why the target is being built.</p><div class="example"><a id="using_the_shell_hack"/><p class="title">Example 2-6. Using the <code class="literal">SHELL</code> hack</p><div class="example-contents"><pre class="programlisting">OLD_SHELL := $(SHELL)
SHELL = $(warning Building $@$(if $&lt;, (from $&lt;))$(if $?, ($? newer)))$(OLD_SHELL)

.PHONY: all
all: foo.o bar

bar: ; touch $@</pre></div></div><p><a id="iddle1355" class="indexterm"/><a id="iddle1831" class="indexterm"/>Here <code class="literal">SHELL</code> has been redefined to output three pieces of information: the name of the target being built (<code class="literal">$@</code>), the name of the first prerequisite (<code class="literal">$&lt;</code>, which is wrapped in a <code class="literal">$(if)</code> so that nothing is printed if there is no prerequisite), and the names of any newer prerequisites (<code class="literal">$?</code>).</p><p>Deleting <code class="literal">foo.o</code> and running <code class="literal">make</code> on this makefile now shows that <code class="literal">foo.o</code> was built from <code class="literal">foo.c</code> because <code class="literal">foo.c</code> was newer than <code class="literal">foo.o</code> (because it was missing):</p><a id="pro_id00166"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
make: Building foo.o (from foo.c) (foo.c newer)
cc -c -o foo.o foo.c
Makefile:7: Building bar</pre><p>There’s nothing to stop us from combining this <code class="literal">$(warning)</code> trick with <code class="literal">-x</code> to get output showing which rules ran and what commands were executed, as shown in <a class="xref" href="ch02.html#combining_the_dollarleft_parenthesiswarn" title="Example 2-7. Combining the $(warning) trick with -x">Example 2-7</a>.</p><div class="example"><a id="combining_the_dollarleft_parenthesiswarn"/><p class="title">Example 2-7. Combining the $(<code class="literal">warning</code>) trick with <code class="literal">-x</code></p><div class="example-contents"><pre class="programlisting">OLD_SHELL := $(SHELL)
SHELL = $(warning Building $@$(if $&lt;, (from $&lt;))$(if $?, ($? newer)))$(OLD_SHELL) -x

.PHONY: all
all: foo.o bar

bar: ; @touch $@</pre></div></div><p>Here’s the full output of the makefile in <a class="xref" href="ch02.html#combining_the_dollarleft_parenthesiswarn" title="Example 2-7. Combining the $(warning) trick with -x">Example 2-7</a>.</p><a id="pro_id00167"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
make: Building foo.o (from foo.c) (foo.c newer)
cc -c -o foo.o foo.c
+ cc -c -o foo.o foo.c
Makefile:7: Building bar
+ touch bar</pre><p>This assumes that <code class="literal">foo.c</code> was newer than <code class="literal">foo.o</code> (or <code class="literal">foo.o</code> was missing) when <code class="literal">make</code> was run.</p></div><div class="sect2" title="GNU make 4.0 Tracing"><div class="titlepage"><div><div><h2 class="title"><a id="gnu_make_4dot0_tracing"/>GNU make 4.0 Tracing</h2></div></div></div><p>GNU <code class="literal">make</code> 4.0 added a <code class="literal">--trace</code> command line option that you can use to trace rule execution. It provides output similar to that of <a class="xref" href="ch02.html#combining_the_dollarleft_parenthesiswarn" title="Example 2-7. Combining the $(warning) trick with -x">Example 2-7</a>. Here’s <a id="iddle1065" class="indexterm"/><a id="iddle1369" class="indexterm"/><a id="iddle1503" class="indexterm"/><a id="iddle1696" class="indexterm"/>what happens when <a class="xref" href="ch02.html#using_the_shell_hack" title="Example 2-6. Using the SHELL hack">Example 2-6</a>, minus the <code class="literal">SHELL</code> modifications, is traced using GNU <code class="literal">make</code> 4.0:</p><a id="pro_id00168"/><pre class="programlisting">$ <span class="strong"><strong>make --trace</strong></span>
&lt;builtin&gt;: update target 'foo.o' due to: foo.c
cc    -c -o foo.o foo.c
Makefile:4: target 'bar' does not exist
touch bar</pre><p>When called with the <code class="literal">--trace</code> option, GNU <code class="literal">make</code> 4.0 overrides the <code class="literal">@</code> modifier (used in the earlier example to suppress <code class="literal">touch bar</code>) in the same way that the <code class="literal">-n</code> and <code class="literal">--just-print</code> flags do.</p></div></div><div class="sect1" title="Makefile Assertions"><div class="titlepage"><div><div><h1 class="title"><a id="makefile_assertions"/>Makefile Assertions</h1></div></div></div><p>Most programming languages have assertions: statements that do nothing if the value they assert is true but cause a fatal error if not. They’re commonly used as a runtime debugging aid to catch very odd situations. A typical assert in C might look like <code class="literal">assert( foo != bar )</code> and would result in a fatal error if <code class="literal">foo</code> and <code class="literal">bar</code> are the same.</p><p>Unfortunately, GNU <code class="literal">make</code> does not have any form of built-in assertions. But they are easy to create from existing functions, and there are even convenient assertion functions defined in the GNU Make Standard Library (GMSL).</p><p>The GMSL project (which is covered in <a class="xref" href="ch06.html" title="Chapter 6. The GNU Make Standard Library">Chapter 6</a>) provides two assertion functions: <code class="literal">assert</code> and <code class="literal">assert_exists</code>.</p><div class="sect2" title="assert"><div class="titlepage"><div><div><h2 class="title"><a id="assert"/>assert</h2></div></div></div><p>The <code class="literal">assert</code> function will output a fatal error if its first argument is false. As with <code class="literal">make</code>’s <code class="literal">$(if)</code> function, GMSL treats any non-empty string as true and an empty string as false. Thus, if <code class="literal">assert</code>’s argument is an empty string, the assertion will cause a fatal error; the second argument to <code class="literal">assert</code> will be printed as part of the error. For example, this makefile breaks immediately because <code class="literal">$(FOO)</code> and <code class="literal">$(BAR)</code> are the same:</p><a id="pro_id00169"/><pre class="programlisting">include gmsl

FOO := foo
BAR := foo

$(call assert,$(call sne,$(FOO),$(BAR)),FOO and BAR should not be equal)</pre><p>Because <code class="literal">assert</code> is not a built-in function—it’s user defined in the GMSL makefile—we must use <code class="literal">$(call)</code>.</p><p>We get the message:</p><a id="pro_id00170"/><pre class="programlisting">Makefile:5: *** GNU Make Standard Library: Assertion failure: FOO and BAR should
not be equal. Stop.</pre><p><a id="iddle1062" class="indexterm"/><a id="iddle1119" class="indexterm"/><a id="iddle1756" class="indexterm"/><a id="iddle1785" class="indexterm"/><a id="iddle1789" class="indexterm"/>The assertion uses another GMSL function, <code class="literal">sne</code>, which compares two strings and returns true if they are not equal or false otherwise.</p><p>Because true simply means <span class="emphasis"><em>not an empty string</em></span>, it’s easy to assert that a variable be defined:</p><a id="pro_id00171"/><pre class="programlisting">include gmsl

$(call assert,$(FOO),FOO is not defined)</pre><p>You can use this assertion, for example, to check that a user has set all necessary command line variables; if <code class="literal">FOO</code> is required for the makefile to run properly but the user forgot to set it on the command line, the assertion will cause an error.</p><p>You can even use assertions to enforce that certain command line flags are not used. Here’s an example that prevents the user from setting <code class="literal">-i</code>, the ignore errors flag:</p><a id="pro_id00172"/><pre class="programlisting">include gmsl

$(foreach o,$(MAKEFLAGS),$(call assert,$(call sne,-i,$o),You can't use the -i option))

ifneq ($(patsubst -%,-,$(firstword $(MAKEFLAGS))),-)
$(call assert,$(call sne,$(patsubst i%,i,$(patsubst %i,i,$(firstword \
$(MAKEFLAGS)))),i),You can't use the -i option)
endif</pre><p>This example is more complex than the previous two because <code class="literal">make</code> can store the <code class="literal">-i</code> flag in <code class="literal">MAKEFLAGS</code> in two ways: as a flag in the familiar form <code class="literal">-i</code> or as a block of single characters in the first word of <code class="literal">MAKEFLAGS</code>. That is, setting the command line flags <code class="literal">-i -k</code> results in <code class="literal">MAKEFLAGS</code> having the value <code class="literal">ki</code>. So the first <code class="literal">assert</code> in the loop looks for <code class="literal">-i</code>, and the second <code class="literal">assert</code> searches for <code class="literal">i</code> in the first word of <code class="literal">MAKEFLAGS</code>.</p></div><div class="sect2" title="assert_exists"><div class="titlepage"><div><div><h2 class="title"><a id="assertunderscoreexists"/>assert_exists</h2></div></div></div><p>Because the success of a build relies on having all necessary files present, the GMSL provides an assertion specifically designed to warn if a file is missing. The <code class="literal">assert_exists</code> function has a single argument: the name of the file that must exist. For example, to check that the file <span class="emphasis"><em>foo.txt</em></span> exists before any commands are run by the makefile, you can add an assertion at the start:</p><a id="pro_id00173"/><pre class="programlisting">include gmsl

$(call assert_exists,foo.txt)</pre><p>If the file does not exist, the build stops:</p><a id="pro_id00174"/><pre class="programlisting">Makefile:3: *** GNU Make Standard Library: Assertion failure: file 'foo.txt'
missing. Stop.</pre><p><a id="iddle1068" class="indexterm"/><a id="iddle1201" class="indexterm"/>The assertion stopped the build and the line on which the assertion is found in the makefile—in this case, 3—is shown.</p></div><div class="sect2" title="assert_target_directory"><div class="titlepage"><div><div><h2 class="title"><a id="assertunderscoretargetunderscoredirector"/>assert_target_directory</h2></div></div></div><p>A common problem in building real-world makefiles is that you must construct directory hierarchies during or before the build. You can ensure that every directory exists before each rule runs by creating a special <code class="literal">assert_target_directory</code> variable, as shown in <a class="xref" href="ch02.html#creating_an_assertunderscoretargetunders" title="Example 2-8. Creating an assert_target_directory variable">Example 2-8</a>.</p><div class="example"><a id="creating_an_assertunderscoretargetunders"/><p class="title">Example 2-8. Creating an <code class="literal">assert_target_directory</code> variable</p><div class="example-contents"><pre class="programlisting">include gmsl

assert_target_directory = $(call assert,$(wildcard $(dir $@)),Target directory $(dir $@) missing)

foo/all: ; @$(call assert_target_directory)echo $@</pre></div></div><p>By inserting <code class="literal">$(call assert_target_directory)</code> at the start of each rule or pattern rule’s recipe, <code class="literal">make</code> automatically checks that the directory in which the target is to be written exists. For example, if <span class="emphasis"><em>foo/</em></span> does not exist, the makefile in <a class="xref" href="ch02.html#creating_an_assertunderscoretargetunders" title="Example 2-8. Creating an assert_target_directory variable">Example 2-8</a> results in the following error:</p><a id="pro_id00175"/><pre class="programlisting">Makefile:6: *** GNU Make Standard Library: Assertion failure: Target directory
foo/ missing. Stop.</pre><p>The error gives the name of the makefile and the line number at which the problem occurred, making it trivial to find the problem.</p><p>For a final trick, it’s possible to use a two-line modification to cause the makefile to check every rule for a missing directory. Instead of adding <code class="literal">$(call assert_target_directory)</code> to every rule, just redefine the <code class="literal">SHELL</code> variable to include <code class="literal">$(call assert_target_directory)</code>. This does slow performance but can be useful in tracking down a missing directory somewhere deep in nested makefiles:</p><a id="pro_id00176"/><pre class="programlisting">include gmsl

assert_target_directory = $(call assert,$(wildcard $(dir $@)),Target directory $(dir $@) missing)

OLD_SHELL := $(SHELL)
SHELL = $(call assert_target_directory)$(OLD_SHELL)

foo/all: ; @echo $@</pre><p><code class="literal">make</code> expands the value of <code class="literal">SHELL</code> and hence performs a call to <code class="literal">assert_target_directory</code> for every rule that is run. This simple change means that every rule checks that the target directory exists.</p><p><a id="iddle1088" class="indexterm"/><a id="iddle1120" class="indexterm"/><a id="iddle1138" class="indexterm"/><a id="iddle1170" class="indexterm"/><a id="iddle1358" class="indexterm"/><a id="iddle1367" class="indexterm"/>The new value of <code class="literal">SHELL</code> consists of a call to <code class="literal">assert_target_directory</code>, which always returns an empty string, followed by the old value of <code class="literal">SHELL</code>, which had been stored in <code class="literal">OLD_SHELL</code>. Note how <code class="literal">OLD_SHELL</code> is defined using <code class="literal">:=</code> so that <code class="literal">SHELL</code> doesn’t refer to itself—<code class="literal">OLD_SHELL</code> contains the value of <code class="literal">SHELL</code> at runtime and can be safely used to redefine <code class="literal">SHELL</code>. If <code class="literal">OLD_SHELL</code> were defined using <code class="literal">=</code>, <code class="literal">make</code> would fail to run because of a circular reference: <code class="literal">SHELL</code> would refer to <code class="literal">OLD_SHELL</code>, which in turn would refer to <code class="literal">SHELL</code>, and so on.</p><p>The <code class="literal">assert_target_directory</code> function works by calling the built-in <code class="literal">$(wildcard)</code> function with the name of the directory where the current target being built should be written. The <code class="literal">$(wildcard)</code> function simply checks to see whether the directory exists and returns the name of the directory if so or the empty string if the directory is missing. The target is defined by the automatic variable <code class="literal">$@</code>, and the directory portion is extracted with <code class="literal">$(dir)</code>.</p></div></div><div class="sect1" title="An Interactive GNU make Debugger"><div class="titlepage"><div><div><h1 class="title"><a id="interactive_gnu_make_debugger"/>An Interactive GNU make Debugger</h1></div></div></div><p>Despite GNU <code class="literal">make</code>’s popularity, debugging facilities are few and far between. GNU <code class="literal">make</code> has a <code class="literal">-d</code> option that outputs extensive (but not necessarily useful) debugging information about a build, and a <code class="literal">-p</code> option that prints GNU <code class="literal">make</code>’s internal database of rules and variables. This section shows how to build an interactive debugger for GNU <code class="literal">make</code> using only GNU <code class="literal">make</code>’s internal functions and the shell <code class="literal">read</code> command.</p><p>The debugger has breakpoints, dumps information about the rule at which a breakpoint is hit, and allows interactive querying of variable values and definitions.</p><div class="sect2" title="The Debugger in Action"><div class="titlepage"><div><div><h2 class="title"><a id="debugger_in_action"/>The Debugger in Action</h2></div></div></div><p>Before you see how the debugger works, let’s look at how to use it. The debugger and these examples all assume that you are using GNU <code class="literal">make</code> 3.80 or later. <a class="xref" href="ch02.html#setting_a_breakpoint_using_the_underscor" title="Example 2-9. Setting a breakpoint using the __BREAKPOINT variable">Example 2-9</a> shows an example makefile that builds <code class="literal">all</code> from the prerequisites <code class="literal">foo</code> and <code class="literal">bar</code>.</p><div class="example"><a id="setting_a_breakpoint_using_the_underscor"/><p class="title">Example 2-9. Setting a breakpoint using the <code class="literal">__BREAKPOINT</code> variable</p><div class="example-contents"><pre class="programlisting">MYVAR1 = hello
MYVAR2 = $(MYVAR1) everyone
all: MYVAR3 = $(MYVAR2)
all: foo bar
→ $(__BREAKPOINT)
→ @echo Finally making $@
foo bar:
→ @echo Building $@</pre></div></div><p>To illustrate the use of the debugger, a breakpoint is set in the <code class="literal">all</code> rule by inserting a line at the start of the rule’s recipe that consists of just the variable <code class="literal">__BREAKPOINT</code>. <code class="literal">$(__BREAKPOINT)</code> gets expanded when the rule runs, causing the debugger to break execution and prompt when the <code class="literal">all</code> rule is about to run, as shown in <a class="xref" href="ch02.html#setting_a_breakpoint_using_the_underscor" title="Example 2-9. Setting a breakpoint using the __BREAKPOINT variable">Example 2-9</a>.</p><p><a id="iddle1363" class="indexterm"/><a id="iddle1364" class="indexterm"/><a id="iddle1366" class="indexterm"/><a id="iddle1405" class="indexterm"/><a id="iddle1429" class="indexterm"/><a id="iddle1784" class="indexterm"/><a id="iddle1882" class="indexterm"/>Here’s what happens when this makefile is executed with no existing files called <code class="literal">all</code>, <code class="literal">foo</code>, or <code class="literal">bar</code>:</p><a id="pro_id00177"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
Building foo
Building bar
Makefile:51: GNU Make Debugger Break
Makefile:51: - Building 'all' from 'foo bar'
Makefile:51: - First prerequisite is 'foo'
Makefile:51: - Prerequisites 'foo bar' are newer than 'all'
1&gt;</pre><p>First, you see the output from the execution of the rules for <code class="literal">foo</code> and <code class="literal">bar</code> (the <code class="literal">Building foo</code> and <code class="literal">Building bar</code> lines), and then there’s a break into the debugger. The debugger break shows the line at which the break occurred and in which makefile. In this case, the breakpoint occurred at line 51 of the makefile. (It’s line 51 because what’s not shown in <a class="xref" href="ch02.html#setting_a_breakpoint_using_the_underscor" title="Example 2-9. Setting a breakpoint using the __BREAKPOINT variable">Example 2-9</a> is all the actual GNU <code class="literal">make</code> variables that make the debugger work.)</p><p>The debugger also outputs information about the rule being built. Here you can see that <code class="literal">all</code> is built from <code class="literal">foo</code> and <code class="literal">bar</code> and that the first prerequisite is <code class="literal">foo</code>. That’s important because it’s the first prerequisite that is stored in GNU <code class="literal">make</code>’s <code class="literal">$&lt;</code> automatic variable. (<code class="literal">$&lt;</code> is typically used as the source code filename for compilation.) The debugger also shows why the <code class="literal">all</code> rule ran: <code class="literal">foo</code> and <code class="literal">bar</code> are both newer than <code class="literal">all</code> (because they were both just built by their respective rules).</p><p>Finally, the debugger prompts <code class="literal">1&gt;</code> for a command. The debugger will accept 32 commands before automatically continuing execution of the makefile. The number <code class="literal">1</code> indicates that this is the first command; once <code class="literal">32&gt;</code> is reached, the debugger will continue automatically. The first thing to do is ask for help by typing <code class="literal">h</code>:</p><a id="pro_id00178"/><pre class="programlisting">1&lt; <span class="strong"><strong>h</strong></span>
Makefile:51: c       continue
Makefile:51: q       quit
Makefile:51: v VAR   print value of $(VAR)
Makefile:51: o VAR   print origin of $(VAR)
Makefile:51: d VAR   print definition of $(VAR)
2&gt;</pre><p>The debugger provides two means of stopping debugging: typing <code class="literal">c</code> continues with normal execution of the makefile; typing <code class="literal">q</code> quits <code class="literal">make</code>. The three debugger commands <code class="literal">v</code>, <code class="literal">o</code>, and <code class="literal">d</code> allow the user to interrogate GNU <code class="literal">make</code> variables by asking for the value of a variable, its origin (where it was defined), or its definition. For example, the makefile in <a class="xref" href="ch02.html#setting_a_breakpoint_using_the_underscor" title="Example 2-9. Setting a breakpoint using the __BREAKPOINT variable">Example 2-9</a> contains two variables—<code class="literal">MYVAR1</code> and <code class="literal">MYVAR2</code>—and a variable that is specific to the <code class="literal">all</code> rule: <code class="literal">MYVAR3</code>. A first step is to ask the debugger for the values of each of these variables:</p><a id="pro_id00179"/><pre class="programlisting">2&gt; <span class="strong"><strong>v MYVAR1</strong></span>
Makefile:55: MYVAR1 has value 'hello'
3&gt; <span class="strong"><strong>v MYVAR2</strong></span>
Makefile:55: MYVAR2 has value 'hello everyone'
4&gt; <span class="strong"><strong>v MYVAR3</strong></span>
Makefile:55: MYVAR3 has value 'hello everyone'
5&gt;</pre><p><a id="iddle1090" class="indexterm"/><a id="iddle1360" class="indexterm"/><a id="iddle1615" class="indexterm"/>If it wasn’t clear how <code class="literal">MYVAR3</code> got its value, you could ask the debugger for its definition:</p><a id="pro_id00180"/><pre class="programlisting">5&gt; <span class="strong"><strong>d MYVAR3</strong></span>
Makefile:55: MYVAR3 is defined as '$(MYVAR2)'
6&gt;</pre><p>This shows that <code class="literal">MYVAR3</code> is defined as <code class="literal">$(MYVAR2)</code>. And so the obvious next step is to find out how <code class="literal">MYVAR2</code> is defined (and also <code class="literal">MYVAR1</code>):</p><a id="pro_id00181"/><pre class="programlisting">6&gt; <span class="strong"><strong>d MYVAR2</strong></span>
Makefile:55: MYVAR2 is defined as '$(MYVAR1) everyone' 7
&gt; <span class="strong"><strong>d MYVAR1</strong></span>
Makefile:55: MYVAR1 is defined as 'hello'
8&gt;</pre><p>And if it wasn’t clear where <code class="literal">MYVAR1</code> got its value, the <code class="literal">o</code> command will show its origin:</p><a id="pro_id00182"/><pre class="programlisting">8&gt; <span class="strong"><strong>o MYVAR1</strong></span>
Makefile:55: MYVAR1 came from file
9&gt;</pre><p>This means that <code class="literal">MYVAR1</code> is defined in a makefile. In contrast:</p><a id="pro_id00183"/><pre class="programlisting">$ <span class="strong"><strong>make MYVAR1=Hello</strong></span>
1&gt; <span class="strong"><strong>v MYVAR1</strong></span>
Makefile:55: MYVAR1 has value 'Hello'
2&gt; <span class="strong"><strong>o MYVAR1</strong></span>
Makefile:55: MYVAR1 came from command line
3&gt;</pre><p>If the user has overridden the value of <code class="literal">MYVAR1</code> on the command line (by running, say, <code class="literal">make MYVAR1=Hello</code>), the <code class="literal">o</code> command reflects that.</p></div><div class="sect2" title="Breakpoints in Patterns"><div class="titlepage"><div><div><h2 class="title"><a id="breakpoints_in_patterns"/>Breakpoints in Patterns</h2></div></div></div><p>As well as setting breakpoints in normal rules, you can also set them in patterns. Every time that pattern rule is used, the breakpoint is hit. For example:</p><a id="pro_id00184"/><pre class="programlisting">all: foo.x bar.x

%.x: FOO = foo
%.x: %.y
→ $(__BREAKPOINT)
→ @echo Building $@ from $&lt;...

foo.y:
bar.y:</pre><p><a id="iddle1089" class="indexterm"/><a id="iddle1504" class="indexterm"/>Here, <code class="literal">all</code> is built from <code class="literal">foo.x</code> and <code class="literal">bar.x</code>, which requires building them from <code class="literal">foo.y</code> and <code class="literal">bar.y</code> using the <code class="literal">%.x: %.y</code> rule. A breakpoint is inserted in the pattern rule, and the debugger breaks twice: once for <code class="literal">foo.x</code> and once for <code class="literal">bar.x</code>:</p><a id="pro_id00185"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
Makefile:66: GNU Make Debugger Break
Makefile:66: - Building 'foo.x' from 'foo.y'
Makefile:66: - First prerequisite is 'foo.y'
Makefile:66: - Prerequisites 'foo.y' are newer than 'foo.x'
1&gt; <span class="strong"><strong>c</strong></span>
Building foo.x from foo.y...
Makefile:66: GNU Make Debugger Break
Makefile:66: - Building 'bar.x' from 'bar.y'
Makefile:66: - First prerequisite is 'bar.y'
Makefile:66: - Prerequisites 'bar.y' are newer than 'bar.x'
1&gt; <span class="strong"><strong>c</strong></span>
Building bar.x from bar.y...</pre><p>Even pattern-specific variables work:</p><a id="pro_id00186"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
Makefile:67: GNU Make Debugger Break
Makefile:67: - Building 'foo.x' from 'foo.y'
Makefile:67: - First prerequisite is 'foo.y'
Makefile:67: - Prerequisites 'foo.y' are newer than 'foo.x'
1&gt; <span class="strong"><strong>v FOO</strong></span>
Makefile:67: FOO has value 'foo'
2&gt;</pre><p><code class="literal">%.x</code> has a pattern-specific variable <code class="literal">FOO</code> with the value <code class="literal">foo</code>; the debugger <code class="literal">v</code> command can access it during a breakpoint on the pattern rule.</p></div><div class="sect2" title="Breakpoints in Makefiles"><div class="titlepage"><div><div><h2 class="title"><a id="breakpoints_in_makefiles"/>Breakpoints in Makefiles</h2></div></div></div><p>Additionally, you can simply insert a breakpoint in a makefile if needed. Parsing of makefiles will pause at the breakpoint so you can examine the current state of variables in the makefile. For example, with a breakpoint after each definition of <code class="literal">FOO</code> in this makefile, you can see its value change:</p><a id="pro_id00187"/><pre class="programlisting">FOO = foo
$(__BREAKPOINT)
FOO = bar
$(__BREAKPOINT)</pre><p><a id="iddle1365" class="indexterm"/>Here’s a sample run:</p><a id="pro_id00188"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
Makefile:76: GNU Make Debugger Break
1&gt; <span class="strong"><strong>v FOO</strong></span>
Makefile:76: FOO has value 'foo'
2&gt; <span class="strong"><strong>c</strong></span>
Makefile:78: GNU Make Debugger Break
1&gt; <span class="strong"><strong>v FOO</strong></span>
Makefile:78: FOO has value 'bar'
2&gt;</pre><p>The two separate breakpoints are activated (one after each time <code class="literal">FOO</code> is set). Using the debugger’s <code class="literal">v</code> command shows how the value of <code class="literal">FOO</code> changes at each breakpoint.</p></div><div class="sect2" title="Debugger Internals"><div class="titlepage"><div><div><h2 class="title"><a id="debugger_internals"/>Debugger Internals</h2></div></div></div><p>The debugger draws on functions defined in the GMSL (you can read more about the GMSL in <a class="xref" href="ch06.html" title="Chapter 6. The GNU Make Standard Library">Chapter 6</a>). The first line of the debugger includes the GMSL functions:</p><a id="pro_id00189"/><pre class="programlisting">include gmsl

__LOOP := 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32</pre><p>The debugger uses the <code class="literal">__PROMPT</code> variable to output the <code class="literal">n&gt;</code> and read in a command followed by a single argument. <code class="literal">__PROMPT</code> uses the <code class="literal">read</code> shell command to get the command and argument into shell variables <code class="literal">$CMD</code> and <code class="literal">$ARG</code> and then returns a list of two elements: the first element is the command and the second is the argument. Expanding <code class="literal">__PROMPT</code> prompts for and returns a single command and argument pair:</p><a id="pro_id00190"/><pre class="programlisting">__PROMPT = $(shell read -p "$(__HISTORY)&gt; " CMD ARG ; echo $$CMD $$ARG)</pre><p>You use the <code class="literal">__BREAK</code> variable to get and handle a single command. First, it stores the result of <code class="literal">__PROMPT</code> in <code class="literal">__INPUT</code>, and then it calls the <code class="literal">__DEBUG</code> function (which handles debugger commands) with two arguments: the command and its argument returned by <code class="literal">__PROMPT</code> in <code class="literal">__INPUT</code>.</p><a id="pro_id00191"/><pre class="programlisting">__BREAK = $(eval __INPUT := $(__PROMPT))       \
          $(call __DEBUG,                      \
              $(word 1,$(__INPUT)),            \
              $(word 2,$(__INPUT)))</pre><p>The <code class="literal">__DEBUG</code> function handles the core of the debugger. <code class="literal">__DEBUG</code> takes a single character command in <code class="literal">$1</code>, its first argument, and an optional argument to the command in <code class="literal">$2</code>. <code class="literal">$1</code> is stored in the variable <code class="literal">__c</code> and <code class="literal">$2</code> in <code class="literal">__a</code>. <a id="iddle1257" class="indexterm"/><a id="iddle1418" class="indexterm"/><a id="iddle1654" class="indexterm"/>Then <code class="literal">__DEBUG</code> examines <code class="literal">__c</code> to see whether it is one of the supported debugger commands (<code class="literal">c</code>, <code class="literal">q</code>, <code class="literal">v</code>, <code class="literal">d</code>, <code class="literal">o</code>, or <code class="literal">h</code>); if not, a call to <code class="literal">$(warning)</code> will output an error message.</p><p><code class="literal">__DEBUG</code> consists of a set of nested <code class="literal">$(if)</code> statements that use the GMSL <code class="literal">seq</code> function to determine if the <code class="literal">__c</code> is a valid debugger command. If it is, <code class="literal">$(if)</code>’s first argument is expanded; if not, the next <code class="literal">$(if)</code> is examined. For example, the <code class="literal">v</code> command (which outputs the value of a variable) is handled like this:</p><a id="pro_id00192"/><pre class="programlisting">$(if $(call seq,$(__c),v),$(warning $(__a) has value '$($(__a))'), ... next if ... )</pre><p>If the <code class="literal">__c</code> command is <code class="literal">v</code>, then <code class="literal">$(warning)</code> is used to output the value of the variable named by <code class="literal">__a</code> (the <code class="literal">$($(__a))</code> outputs the value of the variable whose name is stored in <code class="literal">__a</code>).</p><p>When <code class="literal">__DEBUG</code> is done, it returns either <code class="literal">$(true)</code> or <code class="literal">$(false)</code> (the empty string). <code class="literal">$(true)</code> indicates that the debugger should stop prompting for commands and continue execution (the <code class="literal">q</code> command is handled by calling GNU <code class="literal">make</code>’s <code class="literal">$(error)</code> function to cause a fatal error, which stops <code class="literal">make</code>):</p><a id="pro_id00193"/><pre class="programlisting">__DEBUG = $(eval __c = $(strip $1))                      \
          $(eval __a = $(strip $2))                      \
          $(if $(call seq,$(__c),c),                     \
           $(true),                                      \
           $(if $(call seq,$(__c),q),                    \
            $(error Debugger terminated build),          \
            $(if $(call seq,$(__c),v),                   \
             $(warning $(__a) has value '$($(__a))'),    \
             $(if $(call seq,$(__c),d),                  \
     $(warning $(__a) is defined as '$(value $(__a))'),  \
               $(if $(call seq,$(__c),o),                \
     $(warning $(__a) came from $(origin $(__a))),       \
                $(if $(call seq,$(__c),h),               \
                 $(warning c       continue)             \
                 $(warning q       quit)                 \
             $(warning v VAR print value of $$(VAR))     \
             $(warning o VAR print origin of $$(VAR))    \
        $(warning d VAR print definition of $$(VAR)),    \
        $(warning Unknown command '$(__c)')))))))</pre><p>Finally, we come to the definition of <code class="literal">__BREAKPOINT</code> (the breakpoint variable we used in <a class="xref" href="ch02.html#setting_a_breakpoint_using_the_underscor" title="Example 2-9. Setting a breakpoint using the __BREAKPOINT variable">Example 2-9</a>). It first outputs a banner containing information (you’ll see what <code class="literal">__BANNER</code> does in a moment); then it loops asking for commands by calling <code class="literal">__BREAK</code>. The loop terminates either if it runs out of items in <code class="literal">__LOOP</code> (which is where the 32-command limit is defined) or if a call to <code class="literal">__BREAK</code> returns <code class="literal">$(true)</code>:</p><a id="pro_id00194"/><pre class="programlisting">__BREAKPOINT = $(__BANNER)                              \
               $(eval __TERMINATE := $(false))          \
               $(foreach __HISTORY,                     \
                   $(__LOOP),                           \
                   $(if $(__TERMINATE),,                \
                      $(eval __TERMINATE := $(__BREAK))))</pre><p><a id="iddle1361" class="indexterm"/><code class="literal">__BANNER</code> shows that the debugger has stopped at a breakpoint, and by examining GNU <code class="literal">make</code> automatic variables, it is able to give information about the current rule being built:</p><a id="pro_id00195"/><pre class="programlisting">__BANNER = $(warning GNU Make Debugger Break)           \
           $(if $^,                                     \
              $(warning - Building '$@' from '$^'),     \
              $(warning - Building '$@'))               \
       $(if $&lt;,$(warning - First prerequisite is '$&lt;')) \
           $(if $%,$(warning - Archive target is '$%')) \
           $(if $?,$(warning - Prerequisites '$?' are newer than '$@'))</pre><p>Here’s the complete debugger code:</p><a id="pro_id00196"/><pre class="programlisting">__LOOP := 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32

__PROMPT = $(shell read -p "$(__HISTORY)&gt; " CMD ARG ; echo $$CMD $$ARG)

__DEBUG = $(eval __c = $(strip $1))                     \
          $(eval __a = $(strip $2))                     \
          $(if $(call seq,$(__c),c),                    \
           $(true),                                     \
           $(if $(call seq,$(__c),q),                   \
            $(error Debugger terminated build),         \
            $(if $(call seq,$(__c),v),                  \
             $(warning $(__a) has value '$($(__a))'),   \
             $(if $(call seq,$(__c),d),                 \
     $(warning $(__a) is defined as '$(value $(__a))'), \
               $(if $(call seq,$(__c),o),               \
     $(warning $(__a) came from $(origin $(__a))),      \
               $(if $(call seq,$(__c),h),               \
                $(warning c       continue)             \
                $(warning q       quit)                 \
             $(warning v VAR print value of $$(VAR))    \
             $(warning o VAR print origin of $$(VAR))   \
        $(warning d VAR print definition of $$(VAR)),   \
        $(warning Unknown command '$(__c)')))))))

__BREAK = $(eval __INPUT := $(__PROMPT))                \
          $(call __DEBUG,                               \
              $(word 1,$(__INPUT)),                     \
              $(word 2,$(__INPUT)))

__BANNER = $(warning GNU Make Debugger Break)           \
           $(if $^,                                     \
              $(warning - Building '$@' from '$^'),     \
              $(warning - Building '$@'))               \
       $(if $&lt;,$(warning - First prerequisite is '$&lt;')) \
           $(if $%,$(warning - Archive target is '$%')) \
           $(if $?,$(warning - Prerequisites '$?' are newer than '$@'))
__BREAKPOINT = $(__BANNER)                              \
               $(eval __TERMINATE := $(false))          \
               $(foreach __HISTORY,                     \
               $(__LOOP),                               \
               $(if $(__TERMINATE),,                    \
                  $(eval __TERMINATE := $(__BREAK))))</pre><p><a id="iddle1230" class="indexterm"/><a id="iddle1362" class="indexterm"/><a id="iddle1507" class="indexterm"/><a id="iddle1811" class="indexterm"/>For the most up-to-date version, visit the GNU <code class="literal">make</code> Debugger open source project at <span class="emphasis"><em><a class="ulink" href="http://gmd.sf.net/">http://gmd.sf.net/</a></em></span>.</p></div></div><div class="sect1" title="Dynamic Breakpoints in the GNU make Debugger"><div class="titlepage"><div><div><h1 class="title"><a id="dynamic_breakpoints_in_the_gnu_make_debu"/>Dynamic Breakpoints in the GNU make Debugger</h1></div></div></div><p>The preceding section showed how to build a debugger for GNU <code class="literal">make</code> entirely in GNU <code class="literal">make</code>. But it had only static (hardcoded) breakpoints. This section shows you how to enhance the debugger by adding dynamic breakpoints. That makes it possible to set and remove breakpoints on the name of a file (in GNU <code class="literal">make</code> language, a <span class="emphasis"><em>target</em></span>) that the makefile will build.</p><p>It’s no longer necessary to insert the <code class="literal">$(__BREAKPOINT)</code> string in a makefile. Typing a simple set breakpoint command has the same effect. And another keystroke lists all breakpoints currently in effect.</p><p>This section shows the use of the new breakpoints and how they are coded. The new code is written entirely in GNU <code class="literal">make</code>’s variable language and uses the GMSL set functions (detailed in <a class="xref" href="ch06.html" title="Chapter 6. The GNU Make Standard Library">Chapter 6</a>) to maintain the list of current breakpoints.</p><p>Getting the breakpoints to activate requires a little GNU <code class="literal">make</code> magic, but first let’s look at an example.</p><div class="sect2" title="Dynamic Breakpoints in Action"><div class="titlepage"><div><div><h2 class="title"><a id="dynamic_breakpoints_in_action"/>Dynamic Breakpoints in Action</h2></div></div></div><p>Before you see how the debugger works, let’s look at how to use it. The debugger and these examples all assume that you are using GNU <code class="literal">make</code> 3.80 or later.</p><p>Here’s an example makefile that builds <code class="literal">all</code> from prerequisites <code class="literal">foo</code> and <code class="literal">bar</code>.</p><a id="pro_id00197"/><pre class="programlisting">include gmd

MYVAR1 = hello
MYVAR2 = $(MYVAR1) everyone

all: MYVAR3 = $(MYVAR2)
all: foo bar
all: ; @echo Finally making $@
foo bar: ; @echo Building $@

$(__BREAKPOINT)</pre><p>To illustrate the use of the debugger, a breakpoint is set in the makefile by inserting a line at the end of the makefile that consists of just the variable <code class="literal">$(__BREAKPOINT)</code>. <code class="literal">$(__BREAKPOINT)</code> will get expanded when the makefile finishes being parsed, causing the debugger to break execution before any rules are run and prompt for input. (The debugger is included here with the <code class="literal">include gmd</code> command at the start. You can get the GMD files from the GMD website at <span class="emphasis"><em><a class="ulink" href="http://gmd.sf.net/">http://gmd.sf.net/</a></em></span>; it’s all open source code.)</p><p><a id="iddle1167" class="indexterm"/><a id="iddle1406" class="indexterm"/><a id="iddle1659" class="indexterm"/>Here’s what happens when this makefile is executed with no existing files called <code class="literal">all</code>, <code class="literal">foo</code>, or <code class="literal">bar</code>.</p><a id="pro_id00198"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
Makefile:11: GNU Make Debugger Break
1&gt; <span class="strong"><strong>h</strong></span>
Makefile:11: c:     continue
Makefile:11: q:     quit
Makefile:11: v VAR: print value of $(VAR)
Makefile:11: o VAR: print origin of $(VAR)
Makefile:11: d VAR: print definition of $(VAR)
Makefile:11: b TAR: set a breakpoint on target TAR
Makefile:11: r TAR: unset breakpoint on target TAR
Makefile:11: l: list all target breakpoints
2&gt;</pre><p>The debugger immediately breaks and waits for input. The first thing to do is type <code class="literal">h</code> to see the help text and the three new commands: <code class="literal">b</code> (to set a breakpoint), <code class="literal">r</code> (to remove a breakpoint), and <code class="literal">l</code> (to list current breakpoints).</p><p>Then set two breakpoints in the makefile: one when <code class="literal">foo</code> gets built and one for <code class="literal">all</code>. (If you look back at <a class="xref" href="ch02.html#debugger_in_action" title="The Debugger in Action">The Debugger in Action</a>, you’ll see that you can also achieve this by modifying the makefile, but these new breakpoints can be set dynamically at runtime.)</p><p>After setting the breakpoints, use the <code class="literal">l</code> command to verify that they are set:</p><a id="pro_id00199"/><pre class="programlisting">2&gt; <span class="strong"><strong>b foo</strong></span>
Makefile:11: Breakpoint set on `foo'
3&gt; <span class="strong"><strong>b all</strong></span>
Makefile:11: Breakpoint set on `all'
4&gt; <span class="strong"><strong>l</strong></span>
Makefile:11: Current target breakpoints: `all' `foo'
5&gt;</pre><p>Continuing execution by entering <code class="literal">c</code> causes the <code class="literal">foo</code> breakpoint to be hit immediately. <code class="literal">foo</code> is the first target that the makefile will build (followed by <code class="literal">bar</code> and finally <code class="literal">all</code>). The breakpoint indicates that the rule for <code class="literal">foo</code> is at line 9:</p><a id="pro_id00200"/><pre class="programlisting">5&gt; <span class="strong"><strong>c</strong></span>
Makefile:9: GNU Make Debugger Break
Makefile:9: - Building 'foo'
1&gt;</pre><p>Continuing on, first the output (generated when <code class="literal">bar</code> is created) appears, and then the <code class="literal">all</code> breakpoint is hit.</p><a id="pro_id00201"/><pre class="programlisting">1&gt; <span class="strong"><strong>c</strong></span>
Building foo
Building bar
Makefile:7: GNU Make Debugger Break
Makefile:7: - Building 'all' from 'foo bar'
Makefile:7: - First prerequisite is 'foo'
Makefile:7: - Prerequisites 'foo bar' are newer than 'all'
1&gt;</pre><p><a id="iddle1044" class="indexterm"/><a id="iddle1045" class="indexterm"/><a id="iddle1087" class="indexterm"/><a id="iddle1359" class="indexterm"/><a id="iddle1515" class="indexterm"/><a id="iddle1658" class="indexterm"/><a id="iddle1718" class="indexterm"/><a id="iddle1813" class="indexterm"/>The <code class="literal">all</code> breakpoint prints out much more information than <code class="literal">foo</code> because <code class="literal">all</code> has prerequisites.</p></div><div class="sect2" title="The Easy Part"><div class="titlepage"><div><div><h2 class="title"><a id="easy_part"/>The Easy Part</h2></div></div></div><p>To add the breakpoint functions to the GNU <code class="literal">make</code> debugger, the debugger code that handles the keyboard was first altered to recognize the <code class="literal">b</code>, <code class="literal">r</code>, and <code class="literal">l</code> commands and call user-defined GNU <code class="literal">make</code> functions <code class="literal">__BP_SET</code>, <code class="literal">__BP_UNSET</code>, and <code class="literal">__BP_LIST</code>.</p><p>The targets for which breakpoints are defined are simply a GMSL set of target names. Initially, there are no breakpoints and so the set, called <code class="literal">__BREAKPOINTS</code>, is empty:</p><a id="pro_id00202"/><pre class="programlisting">__BREAKPOINTS := $(empty_set)</pre><p>Setting and removing breakpoints is a matter of calling the GMSL functions <code class="literal">set_insert</code> and <code class="literal">set_remove</code> to add or remove an element from <code class="literal">__BREAKPOINTS</code>:</p><a id="pro_id00203"/><pre class="programlisting">__BP_SET = $(eval __BREAKPOINTS := $(call set_insert,$1,$(__BREAKPOINTS))) \
          $(warning Breakpoint set on `$1')

__BP_UNSET = $(if $(call set_is_member,$1,$(__BREAKPOINTS)),               \
        $(eval __BREAKPOINTS := $(call set_remove,$1,$(__BREAKPOINTS)))    \
        $(warning Breakpoint on `$1' removed),                             \
        $(warning Breakpoint on `$1' not found))</pre><p>Both functions use the GNU <code class="literal">make $(eval)</code> function to change the value of <code class="literal">__BREAKPOINTS</code>. <code class="literal">$(eval FOO)</code> evaluates its argument <code class="literal">FOO</code> as if it were a piece of text during parsing of the makefile: this means that at runtime you can change variable values or define new rules.</p><p><code class="literal">__BP_UNSET</code> used the GMSL function <code class="literal">set_is_member</code> to determine whether the breakpoint being removed was actually defined and output a helpful message in the case that the user tries to remove a nonexistent breakpoint (which may be caused by a typing error on their part).</p><p>Listing the current breakpoints is simply a matter of outputting the contents of the set stored in <code class="literal">__BREAKPOINTS</code>. Because that set is just a list with no duplicates, <code class="literal">__BP_LIST</code> feeds its value into the GNU <code class="literal">make</code> functions <code class="literal">$(addprefix)</code> and <code class="literal">$(addsuffix)</code> to put quotation marks around the target names:</p><a id="pro_id00204"/><pre class="programlisting">__BP_LIST = $(if $(__BREAKPOINTS),                      \
             $(warning Current target breakpoints:      \
       $(addsuffix ',$(addprefix `,$(__BREAKPOINTS)))), \
             $(warning No target breakpoints set))</pre><p><code class="literal">__BP_LIST</code> uses the GNU <code class="literal">make $(if)</code> function to choose between listing the breakpoints if there are any or saying <code class="literal">No target breakpoints set</code> if <a id="iddle1007" class="indexterm"/><a id="iddle1719" class="indexterm"/><a id="iddle1741" class="indexterm"/><a id="iddle1814" class="indexterm"/>the <code class="literal">__BREAKPOINTS</code> set is empty. <code class="literal">$(if)</code> will evaluate its second argument if <code class="literal">$(__BREAKPOINTS)</code> is a non-empty string and evaluate its third argument if there are no breakpoints.</p></div><div class="sect2" title="The Trick"><div class="titlepage"><div><div><h2 class="title"><a id="trick"/>The Trick</h2></div></div></div><p>To get GNU <code class="literal">make</code> to break into the debugger, it has to expand the <code class="literal">__BREAKPOINT</code> variable, which outputs information about the breakpoint and prompts for commands. But for that to happen, we need a way to check which breakpoints are defined every time a rule is about to run. If we can engineer that, then <code class="literal">make</code> can expand <code class="literal">$(__BREAKPOINT)</code> if necessary, causing <code class="literal">make</code> to stop at the breakpoint.</p><p>Fortunately, it’s possible to cause <code class="literal">make</code> to expand <code class="literal">__BREAKPOINT</code> by modifying the built-in <code class="literal">SHELL</code> variable.</p><p>The <code class="literal">SHELL</code> variable is also expanded every time a command is about to run inside a rule. That makes it ideal for checking breakpoints. Here’s the actual code in the GNU <code class="literal">make</code> debugger that uses <code class="literal">SHELL</code> for breakpoint handling:</p><a id="pro_id00205"/><pre class="programlisting">__BP_OLD_SHELL := $(SHELL)
__BP_NEW_SHELL = $(if $(call seq,$(__BP_FLAG),$@), \
                 $(call $1,),                      \
                 $(__BP_CHECK))$(__BP_OLD_SHELL)
SHELL = $(call __BP_NEW_SHELL,$1)</pre><p>First, the real value of <code class="literal">SHELL</code> is stored in <code class="literal">__BP_OLD_SHELL</code> (note that the GNU <code class="literal">make :=</code> operator is used to capture the value, not the definition, of <code class="literal">SHELL</code>). Then <code class="literal">SHELL</code> is redefined to call the <code class="literal">__BP_NEW_SHELL</code> variable.</p><p><code class="literal">__BP_NEW_SHELL</code> is where the interesting work is done. The last part of it is <code class="literal">$(__BP_OLD_SHELL)</code>, which is the value of the original <code class="literal">SHELL</code> variable. After all, once it’s done checking breakpoints, GNU <code class="literal">make</code> needs to use the original <code class="literal">shell</code> to actually run commands. Before that there’s a rather complex <code class="literal">$(if)</code>. Concentrate for a moment on the call to <code class="literal">$(__BP_CHECK)</code>. That’s the variable that will actually check to see whether the breakpoint should be executed. It’s defined like this:</p><a id="pro_id00206"/><pre class="programlisting">__BP_CHECK = $(if $(call set_is_member,$@,        \
              $(__BREAKPOINTS)),                  \
              $(eval __BP_FLAG := $@)             \
              $(eval __IGNORE := $(call SHELL,    \
                                 __BREAKPOINT)))
__BP_FLAG :=</pre><p><code class="literal">__BP_CHECK</code> checks to see whether the current target being built (stored in the standard GNU <code class="literal">make</code> automatic variable <code class="literal">$@</code>) is present in the list of breakpoints. It does this using the GMSL function <code class="literal">set_is_member</code>. If the target is present, it does two things: it sets an internal variable called <code class="literal">__BP_FLAG</code> to be the target for which the breakpoint has activated and then proceeds to <code class="literal">$(call)</code> a variable and throw away the result by storing it in a variable called <a id="iddle1256" class="indexterm"/><a id="iddle1668" class="indexterm"/><a id="iddle1678" class="indexterm"/><code class="literal">__IGNORE</code>. That’s done so that <code class="literal">__BP_CHECK</code>’s return value will always be empty; it’s used, after all, in the definition of <code class="literal">SHELL</code>, which ultimately needs to be just the name of the <code class="literal">shell</code> to execute.</p><p>Experienced GNU <code class="literal">make</code> users will be scratching their heads wondering about the odd syntax <code class="literal">$(call SHELL,__BREAKPOINT)</code>. That’s where some GNU <code class="literal">make</code> rocket science comes in.</p></div><div class="sect2" title="Rocket Science"><div class="titlepage"><div><div><h2 class="title"><a id="rocket_science"/>Rocket Science</h2></div></div></div><p>Instead of writing <code class="literal">$(call SHELL,__BREAKPOINT)</code>, it’s tempting to write <code class="literal">$(__BREAKPOINT)</code> to get the breakpoint to activate. But that doesn’t work.</p><p>Doing so would cause a fatal GNU <code class="literal">make</code> error. Follow the chain of variables up from <code class="literal">__BP_CHECK</code>, and it becomes clear that it’s been expanded because <code class="literal">SHELL</code> was being expanded (because a rule was about to run). Follow into <code class="literal">__BREAKPOINT</code>, and there’s a nasty surprise: a call to <code class="literal">$(shell)</code> (this can be seen in the GMD code in <a class="xref" href="ch05.html#page_64">Addition and Subtraction</a> or in the preceding section), which will cause <code class="literal">SHELL</code> to be expanded.</p><p>Danger, Will Robinson! <code class="literal">SHELL</code> is defined in terms of <code class="literal">SHELL</code>, which causes GNU <code class="literal">make</code> to spot the recursion and give up. The <code class="literal">$(call SHELL,__BREAKPOINT)</code> syntax lets us play with fire. Any time a variable is <code class="literal">$(call)</code>ed in GNU <code class="literal">make</code>, the flag used to check for recursion is disabled. So doing <code class="literal">$(call SHELL,__BREAKPOINT)</code> means that the recursion flag on <code class="literal">SHELL</code> is turned off (avoiding the error) and the definition of <code class="literal">SHELL</code> calls <code class="literal">__BP_NEW_SHELL</code> with one argument. The argument is the word <code class="literal">__BREAKPOINT</code>. <code class="literal">__BP_NEW_SHELL</code> checks to see whether <code class="literal">__BP_FLAG</code> is set to the same value as <code class="literal">$@</code> (which it does using the GMSL <code class="literal">seq</code> function) and then proceeds to <code class="literal">$(call)</code> its first argument (which is <code class="literal">__BREAKPOINT</code>); the breakpoint fires and the prompt appears.</p><p>It might seem that some horrible infinite recursion will occur when the <code class="literal">$(shell)</code> gets executed and <code class="literal">SHELL</code> is expanded again. Two things prevent that: <code class="literal">__BP_FLAG</code> is still the same as <code class="literal">$@</code> (so <code class="literal">__BP_CHECK</code> is not called again), and this time <code class="literal">SHELL</code> has no argument (the value in <code class="literal">$1</code> is empty), so the <code class="literal">$(call $1,)</code> does nothing and recursion stops.</p></div></div><div class="sect1" title="An Introduction to remake"><div class="titlepage"><div><div><h1 class="title"><a id="introduction_to_remake"/>An Introduction to remake</h1></div></div></div><p>The <code class="literal">remake</code> project (<span class="emphasis"><em><a class="ulink" href="http://bashdb.sourceforge.net/remake/">http://bashdb.sourceforge.net/remake/</a></em></span>) is a fork of GNU <code class="literal">make</code> that integrates a complete debugger created by modifying the GNU <code class="literal">make</code> source code. <code class="literal">remake</code> forked from GNU <code class="literal">make</code> 3.82 and is currently at version 3.82+dbg-0.9.</p><div class="sect2" title="Just Print and Trace"><div class="titlepage"><div><div><h2 class="title"><a id="just_print_and_trace"/>Just Print and Trace</h2></div></div></div><p>To illustrate the operation of <code class="literal">remake</code>, let’s use <a class="xref" href="ch02.html#simple_makefile_to_illustrate_remake" title="Example 2-10. A simple makefile to illustrate remake">Example 2-10</a>, a sample makefile:</p><div class="example"><a id="simple_makefile_to_illustrate_remake"/><p class="title">Example 2-10. A simple makefile to illustrate remake</p><div class="example-contents"><pre class="programlisting">.PHONY: all
all: foo bar baz

foo: bar
→ @touch $@
bar:
→ @touch $@

baz: bam
→ @touch $@

bam:
→ @touch $@</pre></div></div><p>Running the standard GNU <code class="literal">make -n</code> (or <code class="literal">--just-print</code>) option against this makefile produces the following output:</p><a id="pro_id00207"/><pre class="programlisting">$ <span class="strong"><strong>make -n</strong></span>
touch bar
touch foo
touch bam
touch baz</pre><p>But <code class="literal">remake</code> provides a makefile and line number information for each rule. The information shows the target (the value of <code class="literal">$@</code>) and the commands to be run:</p><a id="pro_id00208"/><pre class="programlisting">$ remake -n
##&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
Makefile:8: bar
touch bar
##&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
##&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
Makefile:5: foo
touch foo
##&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
##&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
Makefile:14: bam
touch bam
##&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
##&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
Makefile:11: baz
touch baz
##&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</pre><p>Of course, you have to run any real makefile to understand its execution. <code class="literal">remake</code> provides a handy tracing option, <code class="literal">-x</code>, which runs the makefile while outputting information about why targets are being built and showing the commands executed and their output:</p><a id="pro_id00209"/><pre class="programlisting">$ <span class="strong"><strong>remake -x</strong></span>
Reading makefiles...
Updating goal targets....
Makefile:2  File `all' does not exist.
  Makefile:4 File `foo' does not exist.
    Makefile:7 File `bar' does not exist.
    Makefile:7 Must remake target `bar'.
##&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
Makefile:8: bar
touch bar
##&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
+ touch bar
   Makefile:7 Successfully remade target file `bar'.
 Makefile:4 Must remake target `foo'.
##&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
Makefile:5: foo
touch foo
##&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
+ touch foo
 Makefile:4 Successfully remade target file `foo'.
  Makefile:10 File `baz' does not exist.
    Makefile:13 File `bam' does not exist.
   Makefile:13 Must remake target `bam'.
##&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
Makefile:14: bam
touch bam
##&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
+ touch bam
   Makefile:13 Successfully remade target file `bam'.
 Makefile:10 Must remake target `baz'.
##&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
Makefile:11: baz
touch baz
##&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
+ touch baz

Makefile:10 Successfully remade target file `baz'.
Makefile:2 Must remake target `all'. Is a phony target.
Makefile:2 Successfully remade target file `all'.</pre><p>The trace option really comes into its own when an error occurs. Here’s the output when a nonexistent option <code class="literal">-z</code> is added to the <code class="literal">touch</code> in the commands for target <code class="literal">bar</code>:</p><a id="pro_id00210"/><pre class="programlisting">$ <span class="strong"><strong>remake -x</strong></span>
Reading makefiles...
Updating goal targets....
Makefile:2 File `all' does not exist.
  Makefile:4 File `foo' does not exist.
    Makefile:7 File `bar' does not exist.
   Makefile:7 Must remake target `bar'.
##&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
Makefile:8: bar
touch -z bar
##&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
+ touch -z bar
touch: invalid option -- 'z'
Try `touch --help' for more information.
Makefile:8: *** [bar] Error 1

#0 bar at Makefile:8
#1 foo at Makefile:4
#2 all at Makefile:2
Command-line arguments:
       "-x"</pre><p><a id="iddle1171" class="indexterm"/><a id="iddle1679" class="indexterm"/>Right at the bottom of that output is the call stack of targets that were dependent on <code class="literal">bar</code> building successfully, plus, of course, the error generated by <code class="literal">touch</code>, the actual command that was executed, and where to find it in the makefile.</p></div><div class="sect2" title="Debugging"><div class="titlepage"><div><div><h2 class="title"><a id="debugging"/>Debugging</h2></div></div></div><p>Because <code class="literal">remake</code> contains an interactive debugger, you can use it to debug the <code class="literal">touch</code> problem. Run <code class="literal">remake</code> with the <code class="literal">-X</code> option (uppercase <code class="literal">X</code> for the debugger; lowercase <code class="literal">x</code> for tracing), and the debugger breaks at the first target to be built:</p><a id="pro_id00211"/><pre class="programlisting">$ <span class="strong"><strong>remake -X</strong></span>
GNU Make 3.82+dbg0.9
Built for x86_64-unknown-linux-gnu
Copyright (C) 2010 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Reading makefiles...
Updating makefiles....
Updating goal targets....
  Makefile:2 File `all' does not exist.
-&gt; (Makefile:4)
foo: bar
remake&lt;0&gt;</pre><p>So the first break is at line 2 of the makefile and shows that the first target is <code class="literal">all</code> (and the complete prerequisite list is shown). Entering <code class="literal">h</code> gives complete help information:</p><a id="pro_id00212"/><pre class="programlisting">remake&lt;0&gt; <span class="strong"><strong>h</strong></span>
  Command                Short Name  Aliases
  ---------------------- ----------  ---------
  break [TARGET|LINENUM] [all|run|prereq|end]* (b) L
  cd DIR                          (C)
  comment TEXT                    (#)
  continue [TARGET [all|run|prereq|end]*] (c)
  delete breakpoint numbers..     (d)
  down [AMOUNT]                   (D)
  edit                            (e)
  eval STRING                     (E)
  expand STRING                   (x)
  finish [AMOUNT]                 (F)
  frame N                         (f)
  help [COMMAND]                  (h) ?, ??
  info [SUBCOMMAND]               (i)
  list [TARGET|LINE-NUMBER]       (l)
  next [AMOUNT]                   (n)
  print {VARIABLE [attrs...]}     (p)
  pwd                             (P)
  quit [exit-status]              (q) exit, return
  run [ARGS]                      (R) restart
  set OPTION {on|off|toggle}
  set variable VARIABLE VALUE     (=)
  setq VARIABLE VALUE             (")
  shell STRING                    (!) !!
  show [SUBCOMMAND]               (S)
  source FILENAME                 (&lt;)
  skip                            (k)
  step [AMOUNT]                   (s)
  target [TARGET-NAME] [info1 [info2...]] (t)
  up [AMOUNT]                     (u)
  where                           (T) backtrace, bt
  write [TARGET [FILENAME]]       (w)</pre><p>Because the <code class="literal">touch</code> problem occurs later in the <code class="literal">make</code> execution (in the <code class="literal">bar</code> rule), just continue by single stepping with <code class="literal">s</code>:</p><a id="pro_id00213"/><pre class="programlisting">remake&lt;1&gt; <span class="strong"><strong>s</strong></span>
    Makefile:4 File `foo' does not exist.
-&gt; (Makefile:7)
bar:
remake&lt;2&gt; <span class="strong"><strong>s</strong></span>
      Makefile:7 File `bar' does not exist.
      Makefile:7 Must remake target `bar'.
Invoking recipe from Makefile:8 to update target `bar'.
##&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
touch -z bar
##&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
++ (Makefile:7)
bar
remake&lt;3&gt; <span class="strong"><strong>s</strong></span>
touch: invalid option -- 'z'
Try 'touch --help' for more information.
Makefile:7: *** [bar] Error 1

#0 bar at Makefile:7
#1 foo at Makefile:4
#2 all at Makefile:2

***Entering debugger because we encountered a fatal error.
** Exiting the debugger will exit make with exit code 1.
!! (Makefile:7)
bar
remake&lt;4&gt;</pre><p><a id="iddle1091" class="indexterm"/><a id="iddle1809" class="indexterm"/><a id="iddle1817" class="indexterm"/>While in the debugger, you can fix the error in the makefile and then enter <code class="literal">R</code> to restart the build:</p><a id="pro_id00214"/><pre class="programlisting">remake&lt;4&gt; <span class="strong"><strong>R</strong></span>
Changing directory to /home/jgc and restarting...
GNU Make 3.82+dbg0.9
Built for x86_64-unknown-linux-gnu
Copyright (C) 2010 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Reading makefiles...
Updating makefiles....
Updating goal targets....
  Makefile:2 File `all' does not exist.
-&gt; (Makefile:4)
foo: bar
remake&lt;0&gt; <span class="strong"><strong>c</strong></span></pre><p>Now things work correctly.</p></div><div class="sect2" title="Targets, Macro Values, and Expansion"><div class="titlepage"><div><div><h2 class="title"><a id="targetscomma_macro_valuescomma_and_expan"/>Targets, Macro Values, and Expansion</h2></div></div></div><p>When stopped in the debugger, it’s possible to interrogate information about targets in the makefile, such as variable values (expanded and unexpanded) and commands. For example, in <a class="xref" href="ch02.html#simple_makefile_to_illustrate_remake" title="Example 2-10. A simple makefile to illustrate remake">Example 2-10</a>, when stopped at a breakpoint, you can find all the information <code class="literal">remake</code> has about the <code class="literal">all</code> target by using the <code class="literal">target</code> command:</p><a id="pro_id00215"/><pre class="programlisting">$ <span class="strong"><strong>remake -X</strong></span>
GNU Make 3.82+dbg0.9
Built for x86_64-unknown-linux-gnu
Copyright (C) 2010 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Reading makefiles...
Updating makefiles....
Updating goal targets....
  /home/jgc/src/thirdparty/remake-3.82+dbg0.9/Makefile:2 File `all' does not exist.
-&gt; (/home/jgc/src/thirdparty/remake-3.82+dbg0.9/Makefile:4)
foo: bar
remake&lt;0&gt; <span class="strong"><strong>target all</strong></span>
all: foo bar baz
# Phony target (prerequisite of .PHONY).
# Implicit rule search has not been done.
# Implicit/static pattern stem: `'
# File does not exist.
# File has not been updated.
# Commands not yet started.
# automatic
# @ := all
# automatic
# % :=
# automatic
# * :=
# automatic
# + := foo bar baz
# automatic
# | :=
# automatic
# &lt; := all
# automatic
# ^ := foo bar baz
# automatic
# ? :=
remake&lt;1&gt;</pre><p><code class="literal">remake</code> shows that <code class="literal">all</code> is a phony target and dumps information about the automatic variables that will be set for this rule. There’s no restriction on asking about the current target:</p><a id="pro_id00216"/><pre class="programlisting">remake&lt;1&gt; <span class="strong"><strong>target foo</strong></span>
foo: bar
#  Implicit rule search has not been done.
#  Implicit/static pattern stem: `'
#  File does not exist.
#  File has not been updated.
#  Commands not yet started.
#  automatic
# @ := foo
# automatic
# % :=
# automatic
# * :=
# automatic
# + := bar
# automatic
# | :=
# automatic
# &lt; := bar
# automatic
# ^ := bar
# automatic
# ? :=
#  commands to execute (from `Makefile', line 5):
    @touch $@

remake&lt;2&gt;</pre><p><a id="iddle1267" class="indexterm"/><a id="iddle1636" class="indexterm"/><a id="iddle1713" class="indexterm"/><a id="iddle1723" class="indexterm"/><a id="iddle1810" class="indexterm"/>Because target <code class="literal">foo</code> has commands, they are listed at the bottom (along with where to find them in which makefile). To see the expanded form of the commands, use the <code class="literal">expand</code> modifier of the <code class="literal">target</code> command:</p><a id="pro_id00217"/><pre class="programlisting">remake&lt;2&gt; <span class="strong"><strong>target foo expand</strong></span>
foo:
#  commands to execute (from `Makefile', line 5):
   @touch foo

remake&lt;3&gt;</pre><p>To get information about a variable, we use the handy <code class="literal">print</code> and <code class="literal">expand</code> commands: <code class="literal">print</code> gives the definition of a variable, and <code class="literal">expand</code> gives its post-expansion value. Here’s how to find out the definition of the built-in <code class="literal">COMPILE.c</code> variable (which contains the command used to compile <code class="literal">.c</code> files):</p><a id="pro_id00218"/><pre class="programlisting">remake&lt;4&gt; <span class="strong"><strong>print COMPILE.c</strong></span>
(origin default) COMPILE.c = $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c</pre><p>To see the expanded value, <code class="literal">expand</code> it:</p><a id="pro_id00219"/><pre class="programlisting">remake&lt;7&gt; <span class="strong"><strong>expand COMPILE.c</strong></span>
(origin default) COMPILE.c := cc -c</pre><p><code class="literal">remake</code> can also set variable values using <code class="literal">set</code> (which expands a string and sets the variable to that value) and <code class="literal">setq</code> (which sets the variable to a string without expansion). For example, changing <code class="literal">CC</code> from <code class="literal">cc</code> to <code class="literal">gcc</code> changes the C compiler <code class="literal">make</code> will use:</p><a id="pro_id00220"/><pre class="programlisting">remake&lt;7&gt; <span class="strong"><strong>expand COMPILE.c</strong></span>
(origin default) COMPILE.c := cc    -c
remake&lt;8&gt; <span class="strong"><strong>print CC</strong></span>
(origin default) CC = cc
remake&lt;9&gt; <span class="strong"><strong>setq CC gcc</strong></span>
Variable CC now has value 'gcc'
remake&lt;10&gt; <span class="strong"><strong>print CC</strong></span>
(origin debugger) CC = gcc
remake&lt;11&gt; <span class="strong"><strong>expand COMPILE.c</strong></span>
(origin default) COMPILE.c := gcc   -c
remake&lt;12&gt;</pre><p><code class="literal">remake</code> is a very useful tool to add to your <code class="literal">make</code> toolkit. You don’t need to use it every day, but switching from <code class="literal">make</code> to <code class="literal">remake</code> when you have a knotty problem to solve is hassle-free if you are not using any features added in GNU <code class="literal">make</code> 4.0.</p></div></div></div></body></html>