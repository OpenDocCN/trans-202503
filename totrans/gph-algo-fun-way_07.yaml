- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp> <samp class="SANS_Dogma_OT_Bold_B_11">BREADTH-FIRST
    SEARCH</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp> <samp class="SANS_Dogma_OT_Bold_B_11">广度优先搜索</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: '*Breadth-first search* is an alternative approach for exploring graphs that
    progresses like a wave from a starting node. Whereas depth-first search prioritizes
    recently discovered nodes, breadth-first search prioritizes exploring nodes discovered
    earlier in the search. This simple change in prioritization leads to radically
    different behavior of the search algorithm, along with a variety of useful properties.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*广度优先搜索* 是探索图的一种替代方法，它像波浪一样从起始节点开始推进。与深度优先搜索优先处理最近发现的节点不同，广度优先搜索优先探索在搜索过程中较早发现的节点。这一优先级的简单变化导致搜索算法表现出截然不同的行为，并具有一系列有用的特性。'
- en: The key idea behind breadth-first search is that it explores nodes using a first-in,
    first-out ordering, such as that provided by a queue. Each time the search encounters
    a previously unseen node, it places that node in a queue of nodes to explore later.
    When it’s ready to move on to the next node, it doesn’t look at the current node’s
    neighbors, but rather it extracts the node from the front of the queue, meaning
    that it always picks the node that has been waiting the longest.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 广度优先搜索的关键思想是，它使用先进先出（FIFO）的顺序来探索节点，例如队列所提供的顺序。每当搜索遇到一个以前未见过的节点时，它会将该节点放入一个待后续探索的节点队列中。当准备继续探索下一个节点时，搜索不会查看当前节点的邻居，而是从队列的前端提取节点，这意味着它总是选择等待时间最长的节点。
- en: In the previous chapter, we visualized depth-first search as an adventurer exploring
    a labyrinth. We can picture breadth-first search as the same adventurer using
    a different strategy, meticulously working their way through a list of future
    rooms to explore. Determined to visit uncharted territories as soon as possible,
    the explorer enumerates all unexplored rooms in a list. Each time they find a
    new room, they append it to the bottom of the list. Resisting the temptation to
    ditch their plans and rush into this new location, they consult their list and
    turn to the topmost unvisited option instead.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '在前一章中，我们将深度优先搜索比作一位冒险者在迷宫中探险。我们可以将广度优先搜索想象成同样的冒险者，采用不同的策略，仔细地通过未来要探索的房间列表。为了尽早访问未知的领域，探险者会将所有未探索的房间列入清单。每当他们发现一个新房间时，就将它添加到清单的底部。尽管有诱惑放弃计划，冲向这个新地点，他们依然会查看清单，转而选择清单顶部的未访问选项。  '
- en: This chapter introduces breadth-first search and examines its properties. In
    particular, breadth-first search finds the shortest path from a node to all other
    reachable nodes in unweighted graphs, making it a useful component in a variety
    of more complicated algorithms.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了广度优先搜索并探讨其性质。特别是，广度优先搜索能够在无权图中找到从一个节点到所有其他可达节点的最短路径，使其成为许多更复杂算法中有用的组成部分。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Use Cases</samp>
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">应用场景</samp>
- en: Breadth-first search maps naturally onto numerous real-world tasks, such as
    learning new concepts or exploring a new city.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 广度优先搜索自然地映射到许多现实世界的任务中，例如学习新概念或探索一座新城市。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Learning New Topics</samp>
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">学习新主题</samp>
- en: Breadth-first search provides a systematic approach to learning new concepts
    that focuses on building up the foundations before investigating any one area
    too deeply. Suppose you’re learning a new programming language. Each node in the
    graph represents a concept you must learn, while the edges between the nodes represent
    pointers between the concepts. Perhaps you’re reading a chapter on Python that
    discusses both its syntax and its execution model. These concepts become neighbors
    of the current chapter, which we can either explore immediately or put on the
    list to explore later.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 广度优先搜索提供了一种系统的学习新概念的方法，侧重于在深入研究某一领域之前，先打好基础。假设你正在学习一门新的编程语言。图中的每个节点代表你必须学习的一个概念，而节点之间的边则代表这些概念之间的联系。也许你正在阅读一章关于
    Python 的内容，讨论了它的语法和执行模型。这些概念成为当前章节的邻居，我们可以立即探索它们，或者将它们列入稍后探索的清单。
- en: A breadth-first search approach to learning prioritizes the concepts that have
    been on our “to learn” list the longest. You might start at the general concept
    of the Python language, then note the immediate neighbor topics of syntax, execution
    model, and running a sample program. Each topic goes on your list to explore,
    and you proceed through them one at a time. While learning about syntax, you come
    across references to lists, sets, and dictionaries. Instead of flipping ahead
    to those chapters, you add each concept to the bottom of your list to explore
    later and continue to the next topic at the top of the list. This means you’re
    able to complete a simple “Hello, world!” program before delving into lambda expressions.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 广度优先学习方法优先处理在我们的“待学习”列表中存在时间最长的概念。你可能从 Python 语言的总体概念开始，然后注意到紧邻的主题，如语法、执行模型和运行示例程序。每个主题都会加入你的探索列表，然后你逐一进行学习。在学习语法时，你可能会遇到关于列表、集合和字典的内容。与其提前翻到相关章节，你会把这些概念添加到列表的底部，稍后再进行探索，然后继续学习列表顶部的下一个主题。这样，你就能在深入了解
    lambda 表达式之前，先完成一个简单的“Hello, world!”程序。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Exploring a New City</samp>
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">探索新城市</samp>
- en: Suppose you’re exploring a new city, building your knowledge base by establishing
    a known area of explored nodes, then expanding the frontier into the unknown.
    One day after work, you travel that extra block to try the coffee shop you’ve
    seen down the street. Another day, you ask the age-old question, “What’s over
    that hill?” As you discover new neighborhoods, you write down newly discovered
    but as-yet-unvisited areas for later adventures.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在探索一个新城市，构建你的知识库，通过建立已探索区域的已知节点，再逐步扩展到未知区域。一天工作后，你多走了一街区去尝试那家你在街上看到的咖啡店。另一天，你问自己一个古老的问题：“那座山的另一边是什么？”当你发现新邻区时，你会记下这些新发现的、但尚未访问的区域，以便以后去探索。
- en: Contrast this breadth-first approach with the admittedly more adventurous depth-first
    method of walking in one direction until you hit the city limits. The latter tactic
    will efficiently expand the areas seen, but at the cost of deferring closer options.
    If you always go north when you have the option, you might end up 50 blocks north,
    yet remain completely unaware of the amazing coffee shop one block south of your
    apartment.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将这种广度优先的方法与显然更具冒险精神的深度优先方法对比，后者是在一个方向上行进，直到你到达城市边界。这种方法能够高效扩展已看到的区域，但代价是推迟了更接近的选项。如果你在每次有选择时总是向北走，可能会走到北边50个街区，然而却完全没有意识到离你公寓只有一个街区远的惊人咖啡店。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Breadth-First Search Algorithm</samp>
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">广度优先搜索算法</samp>
- en: Breadth-first search operates by maintaining a *queue of nodes* and iteratively
    exploring them until the queue is empty. The nodes in the queue are reachable
    from a visited node but have not been visited themselves.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 广度优先搜索通过保持一个*节点队列*并迭代地探索队列中的节点，直到队列为空。队列中的节点是从已访问的节点可达的，但尚未被访问。
- en: Breadth-first search begins by inserting a *starting node* into the queue. In
    many applications, the choice of the starting node is obvious. If you are browsing
    an online encyclopedia of coffee grinders, for example, the starting node is the
    first page you open. If you are searching for a path from your hotel to the closest
    coffee shop, the starting node will be the hotel. If you are searching through
    your social network for someone who can get you concert tickets, the starting
    node is yourself, the center of the network. In the examples in this chapter,
    we arbitrarily use node 0 as our starting point.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 广度优先搜索从将一个*起始节点*插入队列开始。在许多应用中，起始节点的选择是显而易见的。例如，如果你正在浏览一部关于咖啡磨豆机的在线百科全书，起始节点就是你打开的第一页。如果你正在寻找从酒店到最近咖啡店的路径，起始节点就是酒店。如果你正在通过社交网络寻找能帮你买到音乐会门票的人，起始节点就是你自己，网络的中心。在本章的示例中，我们随意选择节点
    0 作为起始节点。
- en: At the start of each iteration of a breadth-first search, the algorithm dequeues
    the first node and visits it. It then checks that node’s outgoing edges and adds
    any previously unvisited neighbors to the queue. The process continues, one node
    at a time, until the queue is empty.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在广度优先搜索的每次迭代开始时，算法会从队列中取出第一个节点并访问它。然后它会检查该节点的出边，并将任何尚未访问过的邻居节点加入队列。这个过程会持续进行，每次访问一个节点，直到队列为空。
- en: If the graph being explored is not fully connected, the search terminates before
    visiting every node. In many cases, this is exactly what we want. If we are looking
    for a path from the hotel to a coffee shop, we do not care about unreachable coffee
    shops. Perhaps we are on a tropical island with a road network connecting our
    hotel to 10 coffee shops. Our search would spread out to find coffee shops across
    the island but would stop short of suggesting cafés on neighboring islands.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正在探索的图不是完全连通的，搜索将在访问所有节点之前终止。在许多情况下，这正是我们所需要的。如果我们在寻找从酒店到咖啡馆的路径，我们不关心无法到达的咖啡馆。也许我们正处于一个热带岛屿上，岛屿上的道路网络将酒店与10家咖啡馆相连。我们的搜索会扩展到岛屿上的咖啡馆，但不会建议邻近岛屿上的咖啡馆。
- en: However, in some cases, we need a more comprehensive search. If we are searching
    for information on coffee grinders, we do not want to miss important context simply
    because someone neglected to add a hyperlink. We can extend the breadth-first
    search to exhaustively explore every node by adding the first unexplored node
    to the queue whenever the queue is empty.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，我们需要更全面的搜索。如果我们在搜索有关咖啡研磨机的信息，我们不希望仅仅因为某人没有添加超链接而错过重要的上下文。我们可以通过每当队列为空时，将第一个未探索的节点添加到队列中，从而扩展广度优先搜索，彻底探索每个节点。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">代码</samp>
- en: 'The code for breadth-first search consists of a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop exploring new nodes until the queue of pending nodes is empty:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 广度优先搜索的代码由一个<samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>循环组成，探索新的节点直到待处理节点队列为空：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">breadth_first_search()</samp>
    code starts by creating the helper data structures, including the list of which
    nodes have been seen (<samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>),
    a list of previous nodes in the search to represent the path (<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>),
    and a queue (<samp class="SANS_TheSansMonoCd_W5Regular_11">pending</samp>). For
    the queue, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Queue</samp>
    data structure defined in Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">queue</samp>
    library, which requires an additional <samp class="SANS_TheSansMonoCd_W5Regular_11">import
    queue</samp> in the file. However, it’s also possible to use a built-in data structure
    such as a <samp class="SANS_TheSansMonoCd_W5Regular_11">list</samp>. Before the
    main loop begins, the code inserts the starting node into the <samp class="SANS_TheSansMonoCd_W5Regular_11">pending</samp>
    queue and marks it as seen ❶.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">breadth_first_search()</samp>代码首先创建辅助数据结构，包括记录已访问节点的列表(<samp
    class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>)，表示路径的搜索中前一个节点的列表(<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>)，以及一个队列(<samp
    class="SANS_TheSansMonoCd_W5Regular_11">pending</samp>)。对于队列，我们使用Python的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">queue</samp>库中定义的<samp class="SANS_TheSansMonoCd_W5Regular_11">Queue</samp>数据结构，这需要在文件中额外添加<samp
    class="SANS_TheSansMonoCd_W5Regular_11">import queue</samp>。然而，也可以使用像<samp class="SANS_TheSansMonoCd_W5Regular_11">list</samp>这样的内置数据结构。在主循环开始之前，代码将起始节点插入到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">pending</samp>队列中，并将其标记为已访问❶。
- en: The function uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop to continue exploring nodes until the queue is empty. During each iteration,
    it takes the node from the front of the queue and uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop to check each of its neighbors. If the function has not already seen the
    neighbor ❷, it adds it to the queue, marks it as seen, and updates the pointer
    to the previous node. The function finishes by returning the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    list, which captures the path taken by the search.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数使用<samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>循环继续探索节点，直到队列为空。在每次迭代中，它从队列的前端取出一个节点，并使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环检查该节点的每个邻居。如果该函数尚未访问该邻居❷，它将其添加到队列中，标记为已访问，并更新指向前一个节点的指针。函数最后返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp>列表，该列表记录了搜索过程中经过的路径。
- en: Unlike the implementations of depth-first search in [Chapter 4](chapter4.xhtml),
    which marked a node as seen when the search visited it, this breadth-first search
    implementation marks nodes as seen when it first adds them to the queue. This
    prevents repeat entries in the queue.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与[第 4 章](chapter4.xhtml)中深度优先搜索的实现不同，后者在搜索访问到节点时就将其标记为已访问，广度优先搜索的实现是在首次将节点添加到队列时将其标记为已访问。这样可以防止队列中出现重复的条目。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">一个例子</samp>
- en: '[Figure 5-1](#fig5-1) shows an example of the steps of a breadth-first search
    through a graph with 10 nodes. The shaded nodes have been marked seen. Each subfigure
    shows the settings of the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    array and the state of the queue with the front on the left-hand side.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-1](#fig5-1) 显示了通过一个包含 10 个节点的图进行广度优先搜索的步骤示例。被阴影标记的节点已被标记为已访问。每个子图显示了 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp> 数组的设置以及队列的状态，队列的前端在左侧。'
- en: '[Figure 5-1(a)](#fig5-1) represents the state of the search before we start
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop. The search
    has marked the starting node (0) as seen and placed it on the queue. All other
    nodes remain marked unseen. Every node has a back pointer (<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>)
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>, including the starting
    node.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-1(a)](#fig5-1) 表示在我们开始 <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    循环之前，搜索的状态。搜索已经将起始节点（0）标记为已访问，并将其放入队列中。所有其他节点仍然标记为未访问。每个节点的回指针（<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>）的值为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>，包括起始节点。'
- en: '![In (A), only node 0 is shaded and all elements of the last array are set
    to –1\. In (B), node 0 is enclosed in a dashed circle and its neighbors (nodes
    1, 5, and 7) are shaded. The last array has entries of 0 for elements 1, 5, and
    7.](../images/f05001.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![在(A)中，只有节点 0 被阴影标记，last 数组的所有元素都设置为 –1。在(B)中，节点 0 被虚线圈住，且其邻居（节点 1、5 和 7）被阴影标记。last
    数组中元素 1、5 和 7 的条目为 0。](../images/f05001.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-1: The steps of a
    breadth-first search</samp>'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 5-1：广度优先搜索的步骤</samp>
- en: 'The search begins in earnest in [Figure 5-1(b)](#fig5-1), when it removes node
    0 from the queue and explores it. It finds three neighbors (nodes 1, 5, and 7),
    marks each of these as seen, and places them in the queue to explore later. In
    this way, the queue is much like a daily to-do list: we cross an item off, realize
    that it leads to more tasks, and add those to the end of the list. We also update
    the last array to indicate the path we will take to each of these nodes. The value
    0 indicates that node 0 precedes each of the nodes on the path.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索在图 5-1(b) 中正式开始，当时它从队列中移除节点 0 并对其进行探索。它发现三个邻居（节点 1、5 和 7），将每个邻居标记为已访问，并将它们放入队列中以便稍后探索。通过这种方式，队列就像每天的待办事项清单：我们完成一项任务，意识到它会引发更多任务，并将这些任务添加到清单的末尾。我们还更新了
    last 数组，以指示到达这些节点的路径。值为 0 表示节点 0 在路径上先于每个节点。
- en: The search next visits node 1 in [Figure 5-1(c)](#fig5-1). This node has only
    one unseen neighbor (node 2), since we have already seen node 0\. The algorithm
    marks node 2 as seen, adds it to the queue, and sets its entry in the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    array to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索接下来访问图 5-1(c) 中的节点 1。该节点只有一个未访问的邻居（节点 2），因为我们已经访问过节点 0。算法将节点 2 标记为已访问，加入队列，并将其在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> 数组中的条目设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>。
- en: In [Figure 5-1(d)](#fig5-1), we begin to see how this search diverges from the
    depth-first search. Rather than continuing down the current path, breadth-first
    search explores the earliest-seen node that is still unexplored. In this case,
    it moves to node 5\. In the context of the adventurer exploring a labyrinth, this
    corresponds to exploring the room at the top of our hero’s list. Admittedly, this
    could be inefficient in the physical world. The adventurer may need to backtrack
    through much of the labyrinth to return to that room. However, this is not a problem
    in the computational realm. Once we have the index of a node, we can easily load
    it into memory.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图5-1(d)](#fig5-1)中，我们开始看到广度优先搜索与深度优先搜索的不同之处。广度优先搜索不是继续沿着当前路径向下，而是探索第一个尚未探索的最早出现的节点。在这种情况下，它转向节点5。在冒险者探索迷宫的情境下，这相当于探索英雄列表上最上面的房间。诚然，在现实世界中，这可能效率低下。冒险者可能需要返回并走回迷宫的许多地方，才能重新到达那个房间。然而，在计算机领域，这不是问题。一旦我们获得了节点的索引，就可以轻松地将其加载到内存中。
- en: In [Figure 5-1(d)](#fig5-1), the algorithm explores node 5 and finds two new
    neighbors, nodes 6 and 8\. It marks each of these as seen and updates their last
    entries to point back to node 5\. It then places 6 and 8 at the end of our list
    of nodes to explore; it will investigate them in due time.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图5-1(d)](#fig5-1)中，算法探索了节点5，发现了两个新的邻居节点6和8。它标记这两个节点为已访问，并更新它们的最后一个条目指向节点5。然后，它将6和8放在待探索节点列表的末尾；它将适时进行调查。
- en: The search continues in [Figure 5-1(e)](#fig5-1) by exploring the last of node
    0’s neighbors with a visit to node 7\. While we have now seen a significant fraction
    of the nodes in the example graph, we have visited only nodes that are one or
    fewer steps from node 0\. Our search is spreading like a wave from the starting
    node, visiting all the close nodes before hitting ones farther away.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索在[图5-1(e)](#fig5-1)中继续进行，通过访问节点7来探索节点0的最后一个邻居。虽然我们现在已经看到了示例图中的大部分节点，但我们只访问了距离节点0一步或更少的节点。我们的搜索像波浪一样从起始节点扩展，先访问所有靠近的节点，然后再访问更远的节点。
- en: The search continues through the rest of the figure. At each step, it retrieves
    the node at the front of the queue for exploration. This is the node that has
    been waiting longest on its list. It visits that node, checking for and processing
    any new neighbors. The search completes in [Figure 5-1(k)](#fig5-1) when it extracts
    the final node from the queue.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索继续在图的其余部分进行。在每一步中，它从队列的前端提取节点进行探索。这个节点是队列中等待时间最长的节点。它访问该节点，检查并处理任何新的邻居。搜索在[图5-1(k)](#fig5-1)中完成，当它从队列中提取出最后一个节点时。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Finding Shortest Paths</samp>
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">寻找最短路径</samp>
- en: A major benefit of breadth-first search is that it will find the shortest paths
    from the starting node to all reachable nodes on an unweighted graph. When working
    with unweighted graphs, we use the term *shortest paths* to indicate paths with
    the fewest number of edges. Breadth-first search is able to find such paths thanks
    to how the algorithm prioritizes which paths it explores. By using a first-in,
    first-out data structure, the algorithm effectively prioritizes unexplored nodes
    that are closest to the start node.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 广度优先搜索的一个主要优点是，它能够找到从起始节点到所有可达节点的最短路径。处理无权图时，我们使用*最短路径*这一术语来表示边数最少的路径。广度优先搜索能够找到这样的路径，得益于算法在探索路径时的优先级排序。通过使用先进先出的数据结构，算法有效地优先考虑最靠近起始节点的未探索节点。
- en: '[Figure 5-2](#fig5-2) illustrates this behavior, depicting the graph from [Figure
    5-1](#fig5-1) with dashed lines indicating the number of steps to each node. While
    exploring the starting node, breadth-first search enqueues all nodes that can
    be reached in one step from this node. Next, it explores each of those nodes in
    order. While exploring a node one step away, it might find new nodes that are
    two steps away. However, these are always added to the end of the queue and thus
    explored after all the nodes that are one step away have been visited. As a result,
    breadth-first search sweeps through all nodes *k* steps away before considering
    any that are *k* + 1 steps away.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5-2](#fig5-2)展示了这一行为，描绘了[图5-1](#fig5-1)中的图，虚线表示到达每个节点的步数。在探索起始节点时，广度优先搜索会将所有可以从此节点一步到达的节点加入队列。接下来，它按顺序探索这些节点。在探索一步之遥的节点时，它可能会发现一些距离两步远的新节点。然而，这些节点总是被添加到队列的末尾，因此在所有一步之遥的节点都被访问后才会进行探索。因此，广度优先搜索会先遍历所有*距离k*步的节点，然后再考虑任何*距离k+1*步的节点。'
- en: '![Node 0 is in the region labeled 0 steps. Nodes 1, 5, and 7 are in the region
    labeled 1 step.](../images/f05002.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![节点0位于标为0步的区域。节点1、5和7位于标为1步的区域。](../images/f05002.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-2: Contour lines showing
    the expansion of breadth-first search</samp>'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图5-2：显示广度优先搜索扩展的等高线</samp>
- en: In weighted graphs, the concept of *shortest paths* is often used to describe
    the paths with the lowest sum of edge weights. Since breadth-first search does
    not consider edge weight, a breadth-first search will not find the shortest path
    in terms of cost.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在加权图中，*最短路径*的概念通常用来描述边权重总和最小的路径。由于广度优先搜索不考虑边的权重，因此广度优先搜索不会找到成本最小的最短路径。
- en: As an example, consider the graph in [Figure 5-3](#fig5-3). Both nodes 1 and
    2 will be seen by breadth-first search during the exploration of node 2\. Both
    will be marked as seen, added to the queue, and assigned 0 as the previous node
    on their path, regardless of the edge weight to that node. The algorithm does
    not look for or find the lower weight path through node 1 to node 2, but it still
    finds the one with the fewest number of edges.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，考虑[图5-3](#fig5-3)中的图。无论到达该节点的边权重如何，节点1和节点2都会在探索节点2时通过广度优先搜索被访问。它们都会被标记为已访问，添加到队列中，并将它们的路径上的前一个节点设为0。该算法并不会寻找或找到通过节点1到节点2的低权重路径，但它仍然会找到包含最少边数的路径。
- en: '![A three-node graph with the same contour lines as figure 5-2\. The edges
    are labeled with weights. (0, 1) has weight 1.0, (0, 2) has weight 10.0, and (1,
    2) has weight 1.0\. dashed lines indicating the number of steps to each node.
    Node 0 is in the region labeled 0 steps. Nodes 1 and 2 are in the region labeled
    1 step.](../images/f05003.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![一个三节点图，与图5-2相同的等高线。边缘标注了权重。(0, 1)的权重为1.0，(0, 2)的权重为10.0，(1, 2)的权重为1.0。虚线表示到每个节点的步数。节点0位于标为0步的区域。节点1和2位于标为1步的区域。](../images/f05003.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-3: Contour lines showing
    the expansion of breadth-first search on a weighted graph</samp>'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图5-3：显示广度优先搜索在加权图上扩展的等高线</samp>
- en: We’ll consider the question of edge weights and shortest paths later in the
    book. [Chapter 7](chapter7.xhtml) introduces a variety of shortest-path algorithms
    on weighted graphs, while [Chapter 8](chapter8.xhtml) examines heuristic search
    algorithms that account for edge weights.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书后面讨论边权重和最短路径的问题。[第7章](chapter7.xhtml)介绍了各种加权图上的最短路径算法，[第8章](chapter8.xhtml)则研究了考虑边权重的启发式搜索算法。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Simple Path Planning</samp>
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">简单路径规划</samp>
- en: The fact that breadth-first search finds paths with the smallest number of edges
    makes it useful for a limited set of *path-planning* tasks. Consider the old-time
    video game task of planning a path on a flat two-dimensional grid where some squares
    are obstructed by boulders. This section discusses how to create a graph to represent
    this problem and the solution we get when running breadth-first search.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 广度优先搜索能够找到最少边数的路径，使得它在有限的一些*路径规划*任务中非常有用。考虑一下老式视频游戏中的任务：在一个平坦的二维网格上规划路径，其中一些方格被岩石障碍物阻挡。本节讨论了如何创建一个图来表示这个问题，以及运行广度优先搜索时得到的解决方案。
- en: Breadth-first search path planning on a flat plane with obstacles provides a
    useful illustration of the operation of breadth-first search. It also introduces
    how we can think about representing path-planning problems in graph form, preparing
    us for later chapters that cover better algorithms for path planning. These include
    *lowest-cost path algorithms* that account for edge weights to simulate differing
    costs of various terrain and *heuristically guided search algorithms* that improve
    the running time of the search itself by prioritizing the most promising paths.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在有障碍物的平面上进行广度优先搜索路径规划，提供了广度优先搜索操作的有用示例。它还介绍了我们如何通过图的形式来表示路径规划问题，为后续章节的更优路径规划算法做准备。这些算法包括考虑边权重的*最低成本路径算法*，用以模拟不同地形的成本差异，以及通过优先选择最有可能的路径来提高搜索本身运行时间的*启发式引导搜索算法*。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Constructing a Graph
    from a Grid</samp>
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">从网格构建图</samp>
- en: Constructing a graph representation of a regular grid has a variety of uses,
    from path planning to computer vision. The underlying grid might represent spatial
    regions on a map (for path planning or scientific computation), pixels in an image
    (for computer vision), or even just an arrangement of nodes. For the purposes
    of this section, we’ll focus on a video game map.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 构建规则网格的图形表示有多种用途，从路径规划到计算机视觉。底层的网格可能代表地图上的空间区域（用于路径规划或科学计算）、图像中的像素（用于计算机视觉），甚至只是节点的排列。为了本节的目的，我们将重点讨论视频游戏地图。
- en: We generate a grid-based graph by creating a single node for each grid square
    and a single undirected edge linking each pair of adjacent squares. For a grid
    where the number of rows = *height* and number of columns = *width*, we start
    by allocating *height* × *width* nodes. We can visually represent these in a grid
    pattern, as shown in [Figure 5-4(b)](#fig5-4), but technically they are stored
    in a single list within a graph data structure.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过为每个网格方格创建一个单独的节点，并为每对相邻的方格创建一个单独的无向边来生成基于网格的图。对于一个行数 = *height* 和列数 = *width*
    的网格，我们首先分配 *height* × *width* 个节点。我们可以将这些节点以网格模式直观地表示，如[图 5-4(b)](#fig5-4)所示，但从技术上讲，它们存储在图数据结构中的一个单一列表中。
- en: '![(A) shows a 4 × 4 grid. (B) shows a 4 × 4 graph. Nodes in the graph are connected
    to their neighbors above, below, to the right, and to the left.](../images/f05004.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![(A) 显示一个4×4的网格。(B) 显示一个4×4的图形。图中的节点与其上下左右的相邻节点相连接。](../images/f05004.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-4: A grid (a) and
    a graph representation of the grid (b)</samp>'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 5-4：一个网格（a）和其图形表示（b）</samp>
- en: 'We can map the grid coordinates for row *r* and column *c* to a corresponding
    node index as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将行*r*和列*c*的网格坐标映射到相应的节点索引，如下所示：
- en: '*index* = *r* × *width* + *c*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*index* = *r* × *width* + *c*'
- en: 'Because the edges are undirected, we can scan the nodes from top left to bottom
    right and insert edges to the nodes to the right of or below the current node.
    If we specify this as a loop over the *r* and *c* values of the grid, our tests
    of whether to include an edge are as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些边是无向的，我们可以从左上角扫描节点到右下角，并向右侧或下方的相邻节点插入边。如果我们将其指定为遍历网格的*r*和*c*值，那么我们检查是否包括一条边的条件如下：
- en: If *c* < *width* – 1, the node has a neighbor to its right at *index* + 1.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*c* < *width* – 1，节点右侧有一个相邻节点，索引为*index* + 1。
- en: If *r* < *height* – 1, the node has a neighbor below it at *index* + *width*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*r* < *height* – 1，节点下方有一个相邻节点，索引为*index* + *width*。
- en: '[Listing 5-1](#list5-1) shows the code for constructing a grid-based graph.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 5-1](#list5-1)展示了构建基于网格的图形的代码。'
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-1: Creating a graph
    representation of a grid</samp>'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 5-1：创建网格的图形表示</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">make_grid_graph()</samp> code
    starts by creating an undirected graph <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>
    with one node for each grid square. It then loops over all the grid cells with
    two <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops, computes the
    corresponding node index ❶, and checks whether there should be an edge to the
    right of ❷ or below ❸ the current node. The code completes by returning the graph
    <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">make_grid_graph()</samp>代码首先创建一个无向图<samp
    class="SANS_TheSansMonoCd_W5Regular_11">g</samp>，每个网格方格对应一个节点。然后，它使用两个<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环遍历所有网格单元，计算相应的节点索引❶，并检查是否需要在当前节点的右侧❷或下方❸添加一条边。代码最后返回图<samp
    class="SANS_TheSansMonoCd_W5Regular_11">g</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding Obstacles</samp>
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">添加障碍物</samp>
- en: Path planning across a flat plane is not a particularly exciting task. Even
    in the context of describing breadth-first search, it amounts to little more than
    watching the frontier of visited nodes expand across the grid. To make the example
    more interesting, let’s add obstacles to the grid. We pass these to the code in
    the form of tuples (*r*, *c*) that indicate the obstacle’s row and column in the
    grid. This allows us to make grids like the one in [Figure 5-5](#fig5-5), where
    the open cells are traversable and the shaded circles represent obstacles.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在平坦的平面上进行路径规划并不是一项特别令人兴奋的任务。即使是在描述广度优先搜索的上下文中，它也不过是看着访问节点的边界在网格中扩展而已。为了让例子更加有趣，我们向网格中添加障碍物。我们通过元组
    (*r*, *c*) 将这些信息传递给代码，表示障碍物在网格中的行和列。这使我们能够创建像[图 5-5](#fig5-5)中那样的网格，其中开放单元是可遍历的，阴影圆圈表示障碍物。
- en: '![The obstacles are shaded circles. There are obstacles in the second and fifth
    cells along the top row. The top left cell is labeled with an s.](../images/f05005.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![障碍物是阴影圆圈。第一行的第二个和第五个单元格中有障碍物。左上角的单元格标记为 s。](../images/f05005.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-5: A 6×6 grid with
    eight obstacles</samp>'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 5-5：一个带有八个障碍物的 6×6 网格</samp>
- en: 'The code follows the same form as [Listing 5-1](#list5-1) but uses this extra
    information:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与[示例 5-1](#list5-1)的形式相同，但使用了额外的信息：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As in [Listing 5-1](#list5-1), the code starts by creating an undirected graph
    <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> with one node for each
    grid square. It then loops over all the grid cells with two <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops. At each grid square, it checks whether the current cell is blocked by an
    obstacle ❶. If it is blocked, the node has no edges into or out of it. If it isn’t
    blocked, the code computes the index in the node list, checks whether there should
    be an edge to the right of the current node ❷, and checks whether there should
    be an edge below the current node ❸. Both edge checks include the additional constraint
    that the neighboring cell must not be blocked by an obstacle.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如[示例 5-1](#list5-1)所示，代码首先创建一个无向图 <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>，其中每个网格单元对应一个节点。然后，代码通过两个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环遍历所有网格单元。在每个网格单元中，检查当前单元是否被障碍物阻塞
    ❶。如果被阻塞，该节点没有进入或离开的边。如果没有被阻塞，代码计算节点列表中的索引，检查是否需要在当前节点的右侧添加一条边 ❷，并检查是否需要在当前节点下方添加一条边
    ❸。这两个边的检查都包括一个额外的约束条件：邻近的单元格不能被障碍物阻塞。
- en: 'This function demonstrates the power of general graph representation, which
    allows us to fully capture the structure of the environment, including valid transitions
    and obstacles. If we can transition directly from one point to another, the graph
    has an edge between the corresponding nodes. Otherwise, no transition is allowed.
    We do not need to save the dimensions of the graph or the list of obstacles. We
    can use similar approaches to model walls in a maze. As we will see in later chapters,
    we can use edge weights and directionality to further increase modeling power.  ####
    <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running Breadth-First
    Search</samp>'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数展示了通用图表示法的强大功能，它允许我们完全捕捉环境的结构，包括有效的转换和障碍物。如果我们可以直接从一个点转移到另一个点，图中会在相应的节点之间添加一条边。否则，不允许任何转换。我们不需要保存图的维度或障碍物的列表。我们可以使用类似的方法来建模迷宫中的墙壁。正如我们在后面的章节中将看到的，我们可以使用边的权重和方向性来进一步增强建模能力。####
    <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">运行广度优先搜索</samp>
- en: We can run breadth-first search on the grid-based graphs from the previous two
    sections without any modifications. After all, both functions are producing standard
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> objects. [Figure 5-6](#fig5-6)
    shows the results of running breadth-first search on the grid from [Figure 5-5](#fig5-5),
    where *S* denotes the starting node at row 0, column 0.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在前两节中介绍的基于网格的图上运行广度优先搜索，而无需任何修改。毕竟，两个函数都产生标准的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>
    对象。[图 5-6](#fig5-6)展示了在[图 5-5](#fig5-5)中的网格上运行广度优先搜索的结果，其中 *S* 表示位于第 0 行，第 0 列的起始节点。
- en: '![Both subfigures show the 6 × 6 grid from Figure 5-5\. In the figure on the
    left the unoccupied cells are each numbered. The top left cell has the number
    zero and the one below it one. In the figure on the right the unoccupied cells
    have arrows pointing back to the cell that precedes them. The first cell in the
    second row points up to the top left cell.](../images/f05006.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![两个子图展示了图 5-5 中的 6 × 6 网格。在左侧的图中，未占用的单元格都被编号。左上角的单元格标号为零，下面的单元格标号为一。在右侧的图中，未占用的单元格有箭头指向前一个单元格。第二行的第一个单元格指向左上角的单元格。](../images/f05006.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-6: Grids with the
    exploration order (a) and last pointers (b) after breadth-first search</samp>'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 5-6：广度优先搜索后的探索顺序 (a) 和最后指针
    (b)</samp>
- en: The grid in [Figure 5-6(a)](#fig5-6) shows the order in which the search visits
    each grid cell. It starts in the upper left-hand corner and expands outward like
    an oozing blob creature attempting to absorb the world. While the other cells
    are close by straight-line distance metrics, it takes a while for the search to
    visit them, because the search needs to navigate around the obstacles.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-6(a)](#fig5-6) 中的网格显示了搜索访问每个网格单元的顺序。它从左上角开始，像一个渗透的胶状生物一样向外扩展，试图吸收整个世界。虽然其他单元格的直线距离很近，但搜索需要一些时间才能访问它们，因为搜索需要绕过障碍物。'
- en: The grid in [Figure 5-6(b)](#fig5-6) shows the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    pointers for each node in the graph. Using these, we can reconstruct the shortest
    path from any destination node back to the start node. For example, the cell in
    row 3, column 2 (labeled with a 9) can reach the origin by moving up, left, up,
    left, and up. We can reverse these pointers to get the shortest path *from* the
    start node to any reachable destination.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-6(b)](#fig5-6) 中的网格显示了图中每个节点的 <samp class="SANS_TheSansMonoCd_W5Regular_11">最后</samp>
    指针。利用这些指针，我们可以从任何目标节点重新构建到起始节点的最短路径。例如，第 3 行第 2 列的单元格（标记为 9）可以通过向上、向左、向上、向左和向上的方式到达起点。我们可以反转这些指针，得到从起始节点到任何可达目标的最短路径。'
- en: <samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp>
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">为什么这很重要</samp>
- en: Breadth-first search provides an alternate mechanism for searching graphs with
    different behavior. Due to the way it orders nodes to explore, it prioritizes
    nodes that are closest to the starting node as measured by the number of edges.
    As a result, breadth-first search explores outward from the starting node in a
    frontier and will find paths to each node with the fewest edges. This behavior
    makes this search a useful component of various more complex graph algorithms.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 广度优先搜索提供了一种不同的图搜索机制，其行为不同。由于它对节点的探索顺序，它优先探索与起始节点距离最近的节点，距离是通过边的数量来衡量的。因此，广度优先搜索从起始节点向外扩展，探索每个节点时经过的边数最少。这种行为使得广度优先搜索成为各种更复杂图算法的重要组成部分。
- en: In addition, breadth-first search is both simple and efficient. Unlike the common
    recursive implementation of depth-first search, the standard implementation of
    breadth-first search uses an iterative <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop rather than recursive function calls to operate on the queue.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，广度优先搜索既简单又高效。与常见的递归实现深度优先搜索不同，广度优先搜索的标准实现使用迭代的 <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    循环，而不是递归函数调用来操作队列。
- en: 'The next chapters explore a different type of graph search: algorithms that
    find the shortest paths on weighted graphs. These algorithms build on the basic
    searches we have introduced so far and unlock a range of new applications.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的章节将探讨另一种类型的图搜索：在加权图上找到最短路径的算法。这些算法基于我们目前介绍的基本搜索，解锁了一系列新的应用。
