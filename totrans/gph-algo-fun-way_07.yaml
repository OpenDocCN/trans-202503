- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp> <samp class="SANS_Dogma_OT_Bold_B_11">BREADTH-FIRST
    SEARCH</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Breadth-first search* is an alternative approach for exploring graphs that
    progresses like a wave from a starting node. Whereas depth-first search prioritizes
    recently discovered nodes, breadth-first search prioritizes exploring nodes discovered
    earlier in the search. This simple change in prioritization leads to radically
    different behavior of the search algorithm, along with a variety of useful properties.'
  prefs: []
  type: TYPE_NORMAL
- en: The key idea behind breadth-first search is that it explores nodes using a first-in,
    first-out ordering, such as that provided by a queue. Each time the search encounters
    a previously unseen node, it places that node in a queue of nodes to explore later.
    When it’s ready to move on to the next node, it doesn’t look at the current node’s
    neighbors, but rather it extracts the node from the front of the queue, meaning
    that it always picks the node that has been waiting the longest.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we visualized depth-first search as an adventurer exploring
    a labyrinth. We can picture breadth-first search as the same adventurer using
    a different strategy, meticulously working their way through a list of future
    rooms to explore. Determined to visit uncharted territories as soon as possible,
    the explorer enumerates all unexplored rooms in a list. Each time they find a
    new room, they append it to the bottom of the list. Resisting the temptation to
    ditch their plans and rush into this new location, they consult their list and
    turn to the topmost unvisited option instead.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces breadth-first search and examines its properties. In
    particular, breadth-first search finds the shortest path from a node to all other
    reachable nodes in unweighted graphs, making it a useful component in a variety
    of more complicated algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Use Cases</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Breadth-first search maps naturally onto numerous real-world tasks, such as
    learning new concepts or exploring a new city.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Learning New Topics</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Breadth-first search provides a systematic approach to learning new concepts
    that focuses on building up the foundations before investigating any one area
    too deeply. Suppose you’re learning a new programming language. Each node in the
    graph represents a concept you must learn, while the edges between the nodes represent
    pointers between the concepts. Perhaps you’re reading a chapter on Python that
    discusses both its syntax and its execution model. These concepts become neighbors
    of the current chapter, which we can either explore immediately or put on the
    list to explore later.
  prefs: []
  type: TYPE_NORMAL
- en: A breadth-first search approach to learning prioritizes the concepts that have
    been on our “to learn” list the longest. You might start at the general concept
    of the Python language, then note the immediate neighbor topics of syntax, execution
    model, and running a sample program. Each topic goes on your list to explore,
    and you proceed through them one at a time. While learning about syntax, you come
    across references to lists, sets, and dictionaries. Instead of flipping ahead
    to those chapters, you add each concept to the bottom of your list to explore
    later and continue to the next topic at the top of the list. This means you’re
    able to complete a simple “Hello, world!” program before delving into lambda expressions.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Exploring a New City</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Suppose you’re exploring a new city, building your knowledge base by establishing
    a known area of explored nodes, then expanding the frontier into the unknown.
    One day after work, you travel that extra block to try the coffee shop you’ve
    seen down the street. Another day, you ask the age-old question, “What’s over
    that hill?” As you discover new neighborhoods, you write down newly discovered
    but as-yet-unvisited areas for later adventures.
  prefs: []
  type: TYPE_NORMAL
- en: Contrast this breadth-first approach with the admittedly more adventurous depth-first
    method of walking in one direction until you hit the city limits. The latter tactic
    will efficiently expand the areas seen, but at the cost of deferring closer options.
    If you always go north when you have the option, you might end up 50 blocks north,
    yet remain completely unaware of the amazing coffee shop one block south of your
    apartment.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Breadth-First Search Algorithm</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Breadth-first search operates by maintaining a *queue of nodes* and iteratively
    exploring them until the queue is empty. The nodes in the queue are reachable
    from a visited node but have not been visited themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Breadth-first search begins by inserting a *starting node* into the queue. In
    many applications, the choice of the starting node is obvious. If you are browsing
    an online encyclopedia of coffee grinders, for example, the starting node is the
    first page you open. If you are searching for a path from your hotel to the closest
    coffee shop, the starting node will be the hotel. If you are searching through
    your social network for someone who can get you concert tickets, the starting
    node is yourself, the center of the network. In the examples in this chapter,
    we arbitrarily use node 0 as our starting point.
  prefs: []
  type: TYPE_NORMAL
- en: At the start of each iteration of a breadth-first search, the algorithm dequeues
    the first node and visits it. It then checks that node’s outgoing edges and adds
    any previously unvisited neighbors to the queue. The process continues, one node
    at a time, until the queue is empty.
  prefs: []
  type: TYPE_NORMAL
- en: If the graph being explored is not fully connected, the search terminates before
    visiting every node. In many cases, this is exactly what we want. If we are looking
    for a path from the hotel to a coffee shop, we do not care about unreachable coffee
    shops. Perhaps we are on a tropical island with a road network connecting our
    hotel to 10 coffee shops. Our search would spread out to find coffee shops across
    the island but would stop short of suggesting cafés on neighboring islands.
  prefs: []
  type: TYPE_NORMAL
- en: However, in some cases, we need a more comprehensive search. If we are searching
    for information on coffee grinders, we do not want to miss important context simply
    because someone neglected to add a hyperlink. We can extend the breadth-first
    search to exhaustively explore every node by adding the first unexplored node
    to the queue whenever the queue is empty.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The code for breadth-first search consists of a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop exploring new nodes until the queue of pending nodes is empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">breadth_first_search()</samp>
    code starts by creating the helper data structures, including the list of which
    nodes have been seen (<samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>),
    a list of previous nodes in the search to represent the path (<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>),
    and a queue (<samp class="SANS_TheSansMonoCd_W5Regular_11">pending</samp>). For
    the queue, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Queue</samp>
    data structure defined in Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">queue</samp>
    library, which requires an additional <samp class="SANS_TheSansMonoCd_W5Regular_11">import
    queue</samp> in the file. However, it’s also possible to use a built-in data structure
    such as a <samp class="SANS_TheSansMonoCd_W5Regular_11">list</samp>. Before the
    main loop begins, the code inserts the starting node into the <samp class="SANS_TheSansMonoCd_W5Regular_11">pending</samp>
    queue and marks it as seen ❶.
  prefs: []
  type: TYPE_NORMAL
- en: The function uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop to continue exploring nodes until the queue is empty. During each iteration,
    it takes the node from the front of the queue and uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop to check each of its neighbors. If the function has not already seen the
    neighbor ❷, it adds it to the queue, marks it as seen, and updates the pointer
    to the previous node. The function finishes by returning the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    list, which captures the path taken by the search.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the implementations of depth-first search in [Chapter 4](chapter4.xhtml),
    which marked a node as seen when the search visited it, this breadth-first search
    implementation marks nodes as seen when it first adds them to the queue. This
    prevents repeat entries in the queue.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 5-1](#fig5-1) shows an example of the steps of a breadth-first search
    through a graph with 10 nodes. The shaded nodes have been marked seen. Each subfigure
    shows the settings of the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    array and the state of the queue with the front on the left-hand side.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-1(a)](#fig5-1) represents the state of the search before we start
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop. The search
    has marked the starting node (0) as seen and placed it on the queue. All other
    nodes remain marked unseen. Every node has a back pointer (<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>)
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>, including the starting
    node.'
  prefs: []
  type: TYPE_NORMAL
- en: '![In (A), only node 0 is shaded and all elements of the last array are set
    to –1\. In (B), node 0 is enclosed in a dashed circle and its neighbors (nodes
    1, 5, and 7) are shaded. The last array has entries of 0 for elements 1, 5, and
    7.](../images/f05001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-1: The steps of a
    breadth-first search</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The search begins in earnest in [Figure 5-1(b)](#fig5-1), when it removes node
    0 from the queue and explores it. It finds three neighbors (nodes 1, 5, and 7),
    marks each of these as seen, and places them in the queue to explore later. In
    this way, the queue is much like a daily to-do list: we cross an item off, realize
    that it leads to more tasks, and add those to the end of the list. We also update
    the last array to indicate the path we will take to each of these nodes. The value
    0 indicates that node 0 precedes each of the nodes on the path.'
  prefs: []
  type: TYPE_NORMAL
- en: The search next visits node 1 in [Figure 5-1(c)](#fig5-1). This node has only
    one unseen neighbor (node 2), since we have already seen node 0\. The algorithm
    marks node 2 as seen, adds it to the queue, and sets its entry in the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    array to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 5-1(d)](#fig5-1), we begin to see how this search diverges from the
    depth-first search. Rather than continuing down the current path, breadth-first
    search explores the earliest-seen node that is still unexplored. In this case,
    it moves to node 5\. In the context of the adventurer exploring a labyrinth, this
    corresponds to exploring the room at the top of our hero’s list. Admittedly, this
    could be inefficient in the physical world. The adventurer may need to backtrack
    through much of the labyrinth to return to that room. However, this is not a problem
    in the computational realm. Once we have the index of a node, we can easily load
    it into memory.
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 5-1(d)](#fig5-1), the algorithm explores node 5 and finds two new
    neighbors, nodes 6 and 8\. It marks each of these as seen and updates their last
    entries to point back to node 5\. It then places 6 and 8 at the end of our list
    of nodes to explore; it will investigate them in due time.
  prefs: []
  type: TYPE_NORMAL
- en: The search continues in [Figure 5-1(e)](#fig5-1) by exploring the last of node
    0’s neighbors with a visit to node 7\. While we have now seen a significant fraction
    of the nodes in the example graph, we have visited only nodes that are one or
    fewer steps from node 0\. Our search is spreading like a wave from the starting
    node, visiting all the close nodes before hitting ones farther away.
  prefs: []
  type: TYPE_NORMAL
- en: The search continues through the rest of the figure. At each step, it retrieves
    the node at the front of the queue for exploration. This is the node that has
    been waiting longest on its list. It visits that node, checking for and processing
    any new neighbors. The search completes in [Figure 5-1(k)](#fig5-1) when it extracts
    the final node from the queue.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Finding Shortest Paths</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A major benefit of breadth-first search is that it will find the shortest paths
    from the starting node to all reachable nodes on an unweighted graph. When working
    with unweighted graphs, we use the term *shortest paths* to indicate paths with
    the fewest number of edges. Breadth-first search is able to find such paths thanks
    to how the algorithm prioritizes which paths it explores. By using a first-in,
    first-out data structure, the algorithm effectively prioritizes unexplored nodes
    that are closest to the start node.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-2](#fig5-2) illustrates this behavior, depicting the graph from [Figure
    5-1](#fig5-1) with dashed lines indicating the number of steps to each node. While
    exploring the starting node, breadth-first search enqueues all nodes that can
    be reached in one step from this node. Next, it explores each of those nodes in
    order. While exploring a node one step away, it might find new nodes that are
    two steps away. However, these are always added to the end of the queue and thus
    explored after all the nodes that are one step away have been visited. As a result,
    breadth-first search sweeps through all nodes *k* steps away before considering
    any that are *k* + 1 steps away.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Node 0 is in the region labeled 0 steps. Nodes 1, 5, and 7 are in the region
    labeled 1 step.](../images/f05002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-2: Contour lines showing
    the expansion of breadth-first search</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In weighted graphs, the concept of *shortest paths* is often used to describe
    the paths with the lowest sum of edge weights. Since breadth-first search does
    not consider edge weight, a breadth-first search will not find the shortest path
    in terms of cost.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, consider the graph in [Figure 5-3](#fig5-3). Both nodes 1 and
    2 will be seen by breadth-first search during the exploration of node 2\. Both
    will be marked as seen, added to the queue, and assigned 0 as the previous node
    on their path, regardless of the edge weight to that node. The algorithm does
    not look for or find the lower weight path through node 1 to node 2, but it still
    finds the one with the fewest number of edges.
  prefs: []
  type: TYPE_NORMAL
- en: '![A three-node graph with the same contour lines as figure 5-2\. The edges
    are labeled with weights. (0, 1) has weight 1.0, (0, 2) has weight 10.0, and (1,
    2) has weight 1.0\. dashed lines indicating the number of steps to each node.
    Node 0 is in the region labeled 0 steps. Nodes 1 and 2 are in the region labeled
    1 step.](../images/f05003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-3: Contour lines showing
    the expansion of breadth-first search on a weighted graph</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll consider the question of edge weights and shortest paths later in the
    book. [Chapter 7](chapter7.xhtml) introduces a variety of shortest-path algorithms
    on weighted graphs, while [Chapter 8](chapter8.xhtml) examines heuristic search
    algorithms that account for edge weights.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Simple Path Planning</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The fact that breadth-first search finds paths with the smallest number of edges
    makes it useful for a limited set of *path-planning* tasks. Consider the old-time
    video game task of planning a path on a flat two-dimensional grid where some squares
    are obstructed by boulders. This section discusses how to create a graph to represent
    this problem and the solution we get when running breadth-first search.
  prefs: []
  type: TYPE_NORMAL
- en: Breadth-first search path planning on a flat plane with obstacles provides a
    useful illustration of the operation of breadth-first search. It also introduces
    how we can think about representing path-planning problems in graph form, preparing
    us for later chapters that cover better algorithms for path planning. These include
    *lowest-cost path algorithms* that account for edge weights to simulate differing
    costs of various terrain and *heuristically guided search algorithms* that improve
    the running time of the search itself by prioritizing the most promising paths.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Constructing a Graph
    from a Grid</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Constructing a graph representation of a regular grid has a variety of uses,
    from path planning to computer vision. The underlying grid might represent spatial
    regions on a map (for path planning or scientific computation), pixels in an image
    (for computer vision), or even just an arrangement of nodes. For the purposes
    of this section, we’ll focus on a video game map.
  prefs: []
  type: TYPE_NORMAL
- en: We generate a grid-based graph by creating a single node for each grid square
    and a single undirected edge linking each pair of adjacent squares. For a grid
    where the number of rows = *height* and number of columns = *width*, we start
    by allocating *height* × *width* nodes. We can visually represent these in a grid
    pattern, as shown in [Figure 5-4(b)](#fig5-4), but technically they are stored
    in a single list within a graph data structure.
  prefs: []
  type: TYPE_NORMAL
- en: '![(A) shows a 4 × 4 grid. (B) shows a 4 × 4 graph. Nodes in the graph are connected
    to their neighbors above, below, to the right, and to the left.](../images/f05004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-4: A grid (a) and
    a graph representation of the grid (b)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can map the grid coordinates for row *r* and column *c* to a corresponding
    node index as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*index* = *r* × *width* + *c*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the edges are undirected, we can scan the nodes from top left to bottom
    right and insert edges to the nodes to the right of or below the current node.
    If we specify this as a loop over the *r* and *c* values of the grid, our tests
    of whether to include an edge are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If *c* < *width* – 1, the node has a neighbor to its right at *index* + 1.
  prefs: []
  type: TYPE_NORMAL
- en: If *r* < *height* – 1, the node has a neighbor below it at *index* + *width*.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-1](#list5-1) shows the code for constructing a grid-based graph.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-1: Creating a graph
    representation of a grid</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">make_grid_graph()</samp> code
    starts by creating an undirected graph <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>
    with one node for each grid square. It then loops over all the grid cells with
    two <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops, computes the
    corresponding node index ❶, and checks whether there should be an edge to the
    right of ❷ or below ❸ the current node. The code completes by returning the graph
    <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding Obstacles</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Path planning across a flat plane is not a particularly exciting task. Even
    in the context of describing breadth-first search, it amounts to little more than
    watching the frontier of visited nodes expand across the grid. To make the example
    more interesting, let’s add obstacles to the grid. We pass these to the code in
    the form of tuples (*r*, *c*) that indicate the obstacle’s row and column in the
    grid. This allows us to make grids like the one in [Figure 5-5](#fig5-5), where
    the open cells are traversable and the shaded circles represent obstacles.
  prefs: []
  type: TYPE_NORMAL
- en: '![The obstacles are shaded circles. There are obstacles in the second and fifth
    cells along the top row. The top left cell is labeled with an s.](../images/f05005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-5: A 6×6 grid with
    eight obstacles</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code follows the same form as [Listing 5-1](#list5-1) but uses this extra
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As in [Listing 5-1](#list5-1), the code starts by creating an undirected graph
    <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> with one node for each
    grid square. It then loops over all the grid cells with two <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops. At each grid square, it checks whether the current cell is blocked by an
    obstacle ❶. If it is blocked, the node has no edges into or out of it. If it isn’t
    blocked, the code computes the index in the node list, checks whether there should
    be an edge to the right of the current node ❷, and checks whether there should
    be an edge below the current node ❸. Both edge checks include the additional constraint
    that the neighboring cell must not be blocked by an obstacle.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function demonstrates the power of general graph representation, which
    allows us to fully capture the structure of the environment, including valid transitions
    and obstacles. If we can transition directly from one point to another, the graph
    has an edge between the corresponding nodes. Otherwise, no transition is allowed.
    We do not need to save the dimensions of the graph or the list of obstacles. We
    can use similar approaches to model walls in a maze. As we will see in later chapters,
    we can use edge weights and directionality to further increase modeling power.  ####
    <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running Breadth-First
    Search</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We can run breadth-first search on the grid-based graphs from the previous two
    sections without any modifications. After all, both functions are producing standard
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> objects. [Figure 5-6](#fig5-6)
    shows the results of running breadth-first search on the grid from [Figure 5-5](#fig5-5),
    where *S* denotes the starting node at row 0, column 0.
  prefs: []
  type: TYPE_NORMAL
- en: '![Both subfigures show the 6 × 6 grid from Figure 5-5\. In the figure on the
    left the unoccupied cells are each numbered. The top left cell has the number
    zero and the one below it one. In the figure on the right the unoccupied cells
    have arrows pointing back to the cell that precedes them. The first cell in the
    second row points up to the top left cell.](../images/f05006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-6: Grids with the
    exploration order (a) and last pointers (b) after breadth-first search</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The grid in [Figure 5-6(a)](#fig5-6) shows the order in which the search visits
    each grid cell. It starts in the upper left-hand corner and expands outward like
    an oozing blob creature attempting to absorb the world. While the other cells
    are close by straight-line distance metrics, it takes a while for the search to
    visit them, because the search needs to navigate around the obstacles.
  prefs: []
  type: TYPE_NORMAL
- en: The grid in [Figure 5-6(b)](#fig5-6) shows the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    pointers for each node in the graph. Using these, we can reconstruct the shortest
    path from any destination node back to the start node. For example, the cell in
    row 3, column 2 (labeled with a 9) can reach the origin by moving up, left, up,
    left, and up. We can reverse these pointers to get the shortest path *from* the
    start node to any reachable destination.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Breadth-first search provides an alternate mechanism for searching graphs with
    different behavior. Due to the way it orders nodes to explore, it prioritizes
    nodes that are closest to the starting node as measured by the number of edges.
    As a result, breadth-first search explores outward from the starting node in a
    frontier and will find paths to each node with the fewest edges. This behavior
    makes this search a useful component of various more complex graph algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, breadth-first search is both simple and efficient. Unlike the common
    recursive implementation of depth-first search, the standard implementation of
    breadth-first search uses an iterative <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop rather than recursive function calls to operate on the queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next chapters explore a different type of graph search: algorithms that
    find the shortest paths on weighted graphs. These algorithms build on the basic
    searches we have introduced so far and unlock a range of new applications.'
  prefs: []
  type: TYPE_NORMAL
