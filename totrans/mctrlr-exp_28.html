<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2" id="app03"><span epub:type="pagebreak" id="page_291"/><strong>C  More Privilege Escalation</strong></h2>&#13;
<h3 class="h3" id="app03_1"><strong>C.1 Game Boy Advance BIOS</strong></h3>&#13;
<p class="noindent">Like its predecessor, Nintendo’s Game Boy Advance contains a mask ROM that executes at reset to boot a game cartridge after verifying that it contains a valid Nintendo logo for trademark protection. In the Game Boy, the ROM would unmap itself just before jumping into the game cartridge, but the Game Boy Advance keeps the ROM mapped into memory. We call this a <em>BIOS</em> because, like the BIOS ROM in an IBM PC, this ROM contains convenience functions that are called as interrupts.</p>&#13;
<p class="indent">Unlike many targets in this book, the attacker has the privilege of running arbitrary machine code on the device. This is possible with a simple EEPROM chip wired to the right pins of a game catridge, and it was very quickly available to hobbyists after Nintendo released the GBA.</p>&#13;
<p class="indent">A dump of the BIOS ROM is useful for emulating the platform, so access restrictions are in place. The ROM is disabled whenever an address outside of its range is fetched as code, then enabled when an address within its range is fetched as code. This happens in hardware at the instant of the access.</p>&#13;
<p class="indent">In this chapter, we’ll see three methods of tricking the Game Boy Advance into allowing a read of the BIOS ROM. One abuses a BIOS call that has no source address restrictions, one preemptively interrupts a BIOS call to change the source address after validation, and the third executes instructions from unmapped memory so that the pipeline will unlock ROM for a fetch.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_292"/><img id="chCfig1" src="../images/f0292-01.jpg" alt="Image" width="778" height="765"/></div>&#13;
<p class="figcap">Figure C.1: Nintendo GBA CPU</p>&#13;
<h4 class="h4" id="ch00lev2sec1"><span epub:type="pagebreak" id="page_293"/><strong>MidiKey2Freq Method</strong></h4>&#13;
<p class="noindent">Fader (2001) is the classic exploit for dumping the BIOS ROM, recreated in <a href="app03.xhtml#chCfig3">Figure C.3</a>. It’s a variant on a classic technique of kernel memory exposure in Unix, where a system call fails to validate the source address so the caller can peek at memory with the kernel’s privileges.</p>&#13;
<p class="indent"><span class="literal">MidiKey2Freq</span> is implemented as ROM interrupt <span class="literal">0x1f</span>. It takes a pointer to a MIDI sample, reads four bytes at that address, and performs an audio processing function on those four bytes. However this audio function has neither range nor alignment restrictions, and it leaves the top byte unchanged. Fader’s exploit loops through the ROM address space, grabbing the most significant byte in the return value each time.</p>&#13;
<h4 class="h4" id="ch00lev2sec2"><strong>Endrift Method</strong></h4>&#13;
<p class="noindent">For a while it was thought that the <span class="literal">MidiKey2Freq</span> method was the only way to dump the BIOS ROM, but that didn’t seem right to Vicki Pfau. In Pfau (2017), she presents two different black-box techniques for dumping the BIOS ROM. Both of her techniques rely upon the ARM7’s interrupt priorities, triggering a hardware interrupt while the software interrupt of the BIOS call is in progress.</p>&#13;
<p class="indent">The nested interrupt can’t directly read the BIOS, but it does have full privileges to read and write the call stack of the software interrupt in the BIOS call.</p>&#13;
<p class="indent">Vicki’s black-box example registers a timer interrupt to overlap with a software interrupt call to <span class="literal">CPUFastSet</span>. The <span class="literal">CPUFastSet</span> handler performs fast copies within the BIOS address space, but it validates the source address so the caller cannot simply export the BIOS with it. While the BIOS software interrupt is running, it is itself interrupted by her <span class="literal">bbTest</span> handler, which then scans the software interrupt call stack for the source pointer in the <span class="literal">CPUFastSet</span> stack frame. Overwriting the source pointer with a ROM address before returning then causes the BIOS to proceed with an illegal copy, as the source address is only validated at the start of the interrupt handler and not repeated for each word.</p>&#13;
<table class="table95">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td><span epub:type="pagebreak" id="page_294"/><p class="tab-para"><span class="literal">0x00</span></p></td>&#13;
<td><p class="tab-para">SoftReset</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x01</span></p></td>&#13;
<td><p class="tab-para">RegisterRamReset</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x02</span></p></td>&#13;
<td><p class="tab-para">Halt</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x03</span></p></td>&#13;
<td><p class="tab-para">Stop</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x04</span></p></td>&#13;
<td><p class="tab-para">IntrWait</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x05</span></p></td>&#13;
<td><p class="tab-para">VBlankIntrWait</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x06</span></p></td>&#13;
<td><p class="tab-para">Div</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x07</span></p></td>&#13;
<td><p class="tab-para">DivArm</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x08</span></p></td>&#13;
<td><p class="tab-para">Sqrt</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x09</span></p></td>&#13;
<td><p class="tab-para">ArcTan</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x0A</span></p></td>&#13;
<td><p class="tab-para">ArcTan2</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x0B</span></p></td>&#13;
<td><p class="tab-para">CPUSet</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x0C</span></p></td>&#13;
<td><p class="tab-para"><strong>CPUFastSet</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x0D</span></p></td>&#13;
<td><p class="tab-para">BiosChecksum</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x0E</span></p></td>&#13;
<td><p class="tab-para">BgAffineSet</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x0F</span></p></td>&#13;
<td><p class="tab-para">ObjAffineSet</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x10</span></p></td>&#13;
<td><p class="tab-para">BitUnpack</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x11</span></p></td>&#13;
<td><p class="tab-para">LZ77UnCompWRAM</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x12</span></p></td>&#13;
<td><p class="tab-para">LZ77UnCompVRAM</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x13</span></p></td>&#13;
<td><p class="tab-para">HuffUnComp</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x14</span></p></td>&#13;
<td><p class="tab-para">RLUnCompWRAM</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x15</span></p></td>&#13;
<td><p class="tab-para">RLUnCompVRAM</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x16</span></p></td>&#13;
<td><p class="tab-para">Diff8bitUnFilterWRAM</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x17</span></p></td>&#13;
<td><p class="tab-para">Diff8bitUnFilterVRAM</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x18</span></p></td>&#13;
<td><p class="tab-para">Diff16bitUnFilter</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x19</span></p></td>&#13;
<td><p class="tab-para">SoundBiasChange</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x1A</span></p></td>&#13;
<td><p class="tab-para">SoundDriverInit</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x1B</span></p></td>&#13;
<td><p class="tab-para">SoundDriverMode</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x1C</span></p></td>&#13;
<td><p class="tab-para">SoundDriverMain</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x1D</span></p></td>&#13;
<td><p class="tab-para">SoundDriverVSync</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x1E</span></p></td>&#13;
<td><p class="tab-para">SoundChannelClear</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x1F</span></p></td>&#13;
<td><p class="tab-para"><strong>MIDIKey2Freq</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x20</span></p></td>&#13;
<td><p class="tab-para">MusicPlayerOpen</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x21</span></p></td>&#13;
<td><p class="tab-para">MusicPlayerStart</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x22</span></p></td>&#13;
<td><p class="tab-para">MusicPlayerStop</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x23</span></p></td>&#13;
<td><p class="tab-para">MusicPlayerContinue</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x24</span></p></td>&#13;
<td><p class="tab-para">MusicPlayerFadeOut</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x25</span></p></td>&#13;
<td><p class="tab-para">MultiBoot</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x26</span></p></td>&#13;
<td><p class="tab-para">HardReset</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x27</span></p></td>&#13;
<td><p class="tab-para">CustomHalt</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x28</span></p></td>&#13;
<td><p class="tab-para">SoundDriverVSyncOff</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x29</span></p></td>&#13;
<td><p class="tab-para">SoundDriverVSyncOn</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><span class="literal">0x2A</span></p></td>&#13;
<td><p class="tab-para">SoundGetJumpList</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="tab-cap1" id="chCtab1">Table C.1: Game Boy Advance BIOS Interrupts</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_295"/><img id="chCfig2" src="../images/f0295-01.jpg" alt="Image" width="725" height="522"/></div>&#13;
<p class="figcap">Figure C.2: Game Boy Advance Memory Map</p>&#13;
<div class="image"><img id="chCfig3" src="../images/f0295-02.jpg" alt="Image" width="821" height="345"/></div>&#13;
<p class="figcap">Figure C.3: MidiKey2Freq ROM Dumper from Fader (2001)</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_296"/><img id="chCfig4" src="../images/f0296-01.jpg" alt="Image" width="821" height="345"/></div>&#13;
<p class="figcap">Figure C.4: Optimized GBA BIOS Dumper from Pfau (2017)</p>&#13;
<div class="image"><img id="chCfig5" src="../images/f0296-02.jpg" alt="Image" width="821" height="252"/></div>&#13;
<p class="figcap">Figure C.5: BIOS Peek Function from Hearn (2017)</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_297"/>The black box method is particularly nice because it doesn’t require the author to already have a copy of the BIOS and the timing calibration does not need to be particularly accurate. Vicki also presents an optimized implementation that simply makes a <span class="literal">bx</span> call directly into the middle of the <span class="literal">CPUFastSet</span>, as BIOS entry points are unenforced and that code may always read from the BIOS. See <a href="app03.xhtml#chCfig4">Figure C.4</a>.</p>&#13;
<h4 class="h4" id="ch00lev2sec3"><strong>Executing Missing Memory</strong></h4>&#13;
<p class="noindent">While Fader rather directly uses a BIOS call to leak memory and Pfau reuses pieces of BIOS code by either faking a stack or modifying the real one in a nested interrupt, Hearn (2017) goes to the absolute extreme of sophistication. She manages to execute code from unmapped memory at the far end of the address space, so a prefetched instruction from the beginning of memory unlocks the BIOS before being flushed out of the pipeline. I shit you not!</p>&#13;
<p class="indent">Thinking back to your undergrad computer science days, a Nineties RISC chip like the ARM7TDMI uses a pipelined architecture. This particular example has three pipeline stages: fetch, decode, and execute. At the same time that the CPU is executing an instruction, it is decoding the next instruction and fetching the instruction after that. When the fetched and decoded instructions aren’t worthwhile, they are simply flushed away.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_298"/>The CPU communicates with its peripherals, such as memories and I/O, over a bus. On ARM7TDMI, there is a curious effect that the data lines of this bus hold their last value, returning it whenever an unmapped address is fetched.<sup><a id="app3fn_1" href="footnotes.xhtml#app3fn1">1</a></sup> If you read <span class="literal">0xdead-beef</span> from anywhere, or if you write it anywhere, and then read from an unused address like <span class="literal">0x10000000</span> or <span class="literal">0x4bidb10c</span> without any other bus access in between, you will read back <span class="literal">0xdeadbeef</span>. This is a quirk of the architecture, and many others will trigger a fault or return a different value.<sup><a id="app3fn_2" href="footnotes.xhtml#app3fn2">2</a></sup></p>&#13;
<p class="indent">Combining these observations, Hearn realized that if she could write two Thumb instructions as single 32-bit word to anywhere, then jump to them at <span class="literal">0xfffffffd</span>, the first instruction might execute just after the BIOS ROM’s first instruction at <span class="literal">0x0000-0000</span> is fetched, unlocking the ROM. The few lines of Thumb assembly in <a href="app03.xhtml#chCfig5">Figure C.5</a> accomplish this, and they are an absolute work of art.</p>&#13;
<p class="indent">In reading the code, don’t forget how Thumb addressing works. <span class="literal">0xfffffffd</span> is odd to imply Thumb mode, but the 16-bit instruction is fetched from <span class="literal">0xfffffffc</span>. 32 bits are fetched at a time, and there will be no separate fetch for the second instruction.</p>&#13;
<p class="indent">Line 7 writes her instruction pair to the end of memory and Line 8 jumps to execute it at the end of memory. The <span class="literal">ldr</span> instruction reads whatever BIOS address is given as a parameter right back into the return value, and the <span class="literal">bx lr</span> instruction returns back to the caller. “But wait,” you might ask, “how is the first instruction able to read from the BIOS ROM if we haven’t yet executed anything from the ROM?”</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_299"/>The CPU pipeline is the answer. Before the <span class="literal">ldr</span> instruction loads a word from the ROM, the pipeline will have already fetched a 32-bit word from <span class="literal">0x00000000</span> for decoding and eventually execution. This unlocks the ROM for a data fetch, and it doesn’t matter that these pipelined instructions will be flushed away with the <span class="literal">bx</span> instruction that comes next.</p>&#13;
<h3 class="h3" id="app03_2"><strong>C.2 MSP432 IP Encapsulation</strong></h3>&#13;
<p class="noindent">IP Encapsulation (IPE) is a feature of some MSP430 and MSP432 devices from Texas Instruments that serves roughly the same purpose as TrustZone-M or other trusted execution environments (TEE). The idea is that you might purchase a microcontroller with a radio library, and you would be able to <em>use</em> the library but not <em>read</em> the library for reverse engineering or cloning.</p>&#13;
<p class="indent">Like other privilege escalation exploits in this chapter, the defender is at a distinct disadvantage. The attacker is able to run native code, to attach a debugger, and to apply fault injection. The defender merely hopes that TI’s restrictions are sufficient to prevent extraction of protected libraries.</p>&#13;
<p class="indent">Sah and Hicks (2023) describe this feature in depth, along with some design mistakes that expose the encapsulated firmware. Two facts in particular are important for exploitation: first, the IPE feature does nothing to enforce specific entry points into the protected code, allowing gadgets to be reused when called from user program memory. Second, the IPE feature does nothing to disable the majority of interrupt sources, and timer interrupts are particularly useful for getting execution in the middle of the encapsulation library so that the attacker code can learn things about the library.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_300"/>Exploitation details vary between the 16-bit MSP430 architecture and the 32-bit ARM architecture used by the MSP432. In either case, a timer with a very small count is used to trigger an exception inside the protected library, then the exception handler in the unprotected application observes the register states to make informed guesses about the state of the code.</p>&#13;
<p class="indent">For example, if the handler observes that some extra return pointers have been pushed to the stack, those pointers will reveal the locations of <span class="literal">call</span> instructions on MSP430 or <span class="literal">bl</span>/<span class="literal">blx</span> instructions on MSP432. Similarly, the attacker can locate <span class="literal">ret</span> instructions by calling them after setting the link register on ARM or loading a return pointer to the stack in MSP430.</p>&#13;
<p class="indent">Eventually, the attacker will discover a gadget that will read an arbitrary address into a register. Maybe the gadget returns afterward, in which case no timer is necessary. Maybe it does not return, in which case the timer’s countdown can be used to repeatedly call into this gadget and then bounce out again. Either way, repeated usage of the gadget can extract all protected memory.</p>&#13;
<h3 class="h3" id="app03_3"><strong>C.3 BCM11123 U-Boot and TrustZone</strong></h3>&#13;
<p class="indent">Cisco’s model 8861 IP Phone uses a Broadcom BCM11123 CPU with TrustZone. A TrustZone chip has two modes, with <em>secure</em> code having privileges that the <em>non-secure</em> code lacks. It’s not that the non-secure code is exploitable, so much as that it is not trusted. Communication between the two modes takes the form of interrupt handlers, much like system calls from userland to a kernel.</p>&#13;
<p class="indent">In the case of this phone, U-Boot runs in non-secure memory, making API calls to a TrustZone monitor in order to validate and launch a Linux kernel. Cui and Housley (2017) is largely about EMFI attacks, but that paper’s appendix describes a nifty attack against this arrangement.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_301"/><img id="chCfig6" src="../images/f0301-01.jpg" alt="Image" width="818" height="403"/></div>&#13;
<p class="figcap">Figure C.6: Cui and Housely’s Exploit for the BCM11123</p>&#13;
<p class="indent">The authors began by faulting the phone’s NAND flash during boot, in order to drop into U-Boot’s command line, much like the ROM bootloader of the Freescale MC13224 in <a href="ch14.xhtml#ch14">Chapter 14</a>. This bootloader has handy commands for reading, writing, and executing memory, but because it’s in the non-secure world, that’s not enough to dump or control the secure side of the chip in Trust-Zone. The game is then to find a vulnerability in the TrustZone monitor and to exploit it from U-Boot.</p>&#13;
<p class="indent">The bug in question is in the <span class="literal">_ssapi_public_decrypt</span> function, which lacks a necessary length check and fails to ensure that the source and destination addresses are on the appropriate sides of the TrustZone barrier. By carefully choosing the right parameters, Cui and Housley were able to copy small chunks out of the secure world into non-secured memory accessible by U-Boot, for <span epub:type="pagebreak" id="page_302"/>reverse engineering and dumping.</p>&#13;
<p class="indent">They then used the same bug in the opposite direction, clobbering a return pointer in the secure world and promote U-Boot itself to run within the TrustZone.</p>&#13;
<h3 class="h3" id="app03_4"><strong>C.4 LPC55S69 Hardware and Software</strong></h3>&#13;
<p class="noindent">The LPC55 series of microcontrollers use the ARM Cortex-M architecture, with TrustZone-M as a means to protect key material such as a secret key unique to each device from the user programmed application. Ideally, this would let a board designer install software on the chip that uses this key material, but even a serious bug in that application software would not allow an attacker to control the trusted zone, its software, or its keys.</p>&#13;
<p class="indent">Some Cortex-M devices include a Flash Patch and Breakpoint (FPB) unit, which allows a few words of memory to be patched, overriding their real value with a chosen one. In devices like the LPC55 that support TrustZone-M, that IP block is explicitly prohibited by ARM for fear that in remapping the address space, the TrustZone-M protections might be invalidated.</p>&#13;
<p class="indent">While reverse engineering an application for the LPC55S69, Laura Abbott discovered that there is a custom module much like the forbidden FPB unit, allowing for small patches to a few 32-bit words at any address in memory, including words of the ROM. She documents that module in Abbott (2021), along with a way to use it to fake the signature verification of ROM patches, allowing malicious ones to be installed that will persist to the next boot.</p>&#13;
<p class="indent">The module exists as an APB peripheral at <span class="literal">0x4003e000</span> in non-secure memory and <span class="literal">0x5003e000</span> in secure memory, a region missing from the memory map in the LPC55S6x user manual. Because it exists in both privileged and unprivileged modes, unprivileged code can use it to patch the privileged ROM code’s behavior as a form of privilege escalation!</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_303"/><img id="chCfig7" src="../images/f0303-01.jpg" alt="Image" width="778" height="722"/></div>&#13;
<p class="figcap">Figure C.7: LPC55S69</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_304"/>This patch module’s configuration is wiped at reset, but what if an attacker wanted a patch to be persistent, such as to disable secure boot authentication? Abbot describes a table of patch entries in a protected flash memory region with the following structure. The three supported commands include single-word changes, an <span class="literal">svc</span> entry point change, and a patch to SRAM.</p>&#13;
<div class="imagel"><img src="../images/f0304-01.jpg" alt="Image" width="812" height="205"/></div>&#13;
<p class="indent">In addition to the undocumented patching module, there is a second software vulnerability for escalation into the secure world. A software vulnerability in the parsing of firmware update headers, described in Abbott (2022), allows for privilege escalation from the non-secure world and persistent control past the next reset.</p>&#13;
<p class="indent">The bug is in the header structure, shown in <a href="app03.xhtml#chCfig8">Figure C.8</a>. By design, <span class="literal">m_keyBlobBlock</span> ought to be the block number that is just after the header. Each block is 16 bytes, so block 8 would be just after the 128-byte header.</p>&#13;
<p class="indent">Instead of the secure boot parser copying just the header, it continues copying blocks until it counts up to <span class="literal">m_keyBlobBlock</span>. When the number is larger than 8, this copying becomes a classic buffer overflow.</p>&#13;
<p class="indent">See also <a href="app01.xhtml#app01_3">Chapter A.3</a> for a buffer over-read in the bootloader’s USB stack and <a href="app05.xhtml#app05_2">Chapter E.2</a> for a set of glitching attacks against the chip.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_305"/><img id="chCfig8" src="../images/f0305-01.jpg" alt="Image" width="822" height="671"/></div>&#13;
<p class="figcap">Figure C.8: LPC55 SB2 Update Header</p>&#13;
<h3 class="h3" id="app03_5"><span epub:type="pagebreak" id="page_306"/><strong>C.5 FM3 Flash Patching</strong></h3>&#13;
<p class="noindent">Infineon’s FM3 series of Cortex M3 microcontrollers is used in at least some models of Sony’s Dualshock4 controller for the Playstation 4. Enthusiast (2018) describes a flash patch and breakpoint (FPB) trick, somewhat similar to those in <a href="ch17.xhtml#ch17">Chapters 17</a> and <a href="app03.xhtml#app03_4">C.4</a>, that allows flash memory to be extracted by persisting patches across a reset.</p>&#13;
<p class="indent">The chip has boot mode pins, labeled as <span class="literal">MD</span>, that are sensed at reset to execute either an application from flash memory or a serial bootloader from ROM. USBDirect is the manufacturer’s programming tool, and it operates by loading a blob of native code into SRAM. An open source replacement for this blob is available, and by patching it, you can freely play around with the programming environment.</p>&#13;
<p class="indent">That’s a nice and easy start, but the code runs in a restricted environment with access to flash memory disabled until a mass erase is performed. Any attempt to read from flash memory simply returns garbage data, and this also applies to tricky read methods like a DMA transfer.</p>&#13;
<p class="indent">With more experimentation, the author found that SRAM persists across resets. As we saw in <a href="ch02.xhtml#ch02">Chapter 2</a>, this is a great way to leave shellcode around for a subsequent attack.</p>&#13;
<p class="indent">Knowing that SRAM was not reset, the author looked into other peripheral devices, eventually finding the FPB unit. The FPB holds six pairs of addresses, remapping a code fetch from the first address into a fetch for the second address. This module’s configuration is also not cleared at reset!</p>&#13;
<p class="indent">The final exploit consists of an SRAM blob for the serial boot-loader that enables the FPB, using it to patch the user application in flash memory to re-enter the serial bootloader. At that point, the normal SRAM blob can be presented. Because the <span epub:type="pagebreak" id="page_307"/>device booted from flash memory, read restrictions are not enabled and this blob can dump all flash memory. Mass erasing and rewriting that firmware then unlocks the target, much as we saw in <a href="ch17.xhtml#ch17">Chapter 17</a> except with no requirement for a voltage glitch at reset.<span epub:type="pagebreak" id="page_308"/></p>&#13;
</div>
</div>
</body></html>