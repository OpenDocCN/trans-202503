- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp> <samp class="SANS_Dogma_OT_Bold_B_11">SHORTEST
    PATHS</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp> <samp class="SANS_Dogma_OT_Bold_B_11">最短路径</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: The problem of finding the lowest-cost path through a graph, as measured by
    the sum of edge weights along the path, is naturally analogous to a range of real-world
    path planning and optimization tasks. For example, we may be interested in routing
    trucks between two cities such that we minimize the total cost of fuel. In this
    chapter, we consider algorithms to find paths with the minimum cost starting at
    a given origin.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找图中最低代价路径的问题，通过路径上所有边的权重之和来衡量，天然类似于现实世界中一系列路径规划和优化任务。例如，我们可能有兴趣规划卡车在两个城市之间的路线，以最小化燃料总费用。本章将讨论用于寻找从给定起点出发的最低代价路径的算法。
- en: While the problem of finding these paths is often called the *shortest-path
    problem*, it is more accurate to think of it in terms of lowest-cost path, since
    a path’s cost is not always a function of distance. For example, this chapter
    will also consider versions of the problem that allow negative edge weights. We
    will use the terms *shortest path* and *lowest-cost path* interchangeably throughout
    the chapter; the formulations and implementations are the same.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管寻找这些路径的问题通常被称为*最短路径问题*，但将其视为最低代价路径问题更为准确，因为路径的代价并不总是距离的函数。例如，本章还将讨论允许负权重边的版本。我们将在本章中交替使用*最短路径*和*最低代价路径*这两个术语；它们的公式和实现是相同的。
- en: This chapter covers three algorithms for finding shortest paths. We start with
    *Dijkstra’s algorithm*, which, like the search algorithms in the previous chapters,
    explores outward from a starting node. The *Bellman-Ford algorithm* iteratively
    refines the best paths by considering individual edges. Finally, the *Floyd-Warshall
    algorithm* allows us to find the shortest paths between all pairs of nodes.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了三种寻找最短路径的算法。我们首先介绍*Dijkstra 算法*，它像前几章中的搜索算法一样，从起始节点向外扩展。*Bellman-Ford 算法*通过逐步考虑各个边来改进最佳路径。最后，*Floyd-Warshall
    算法*使我们能够找到所有节点对之间的最短路径。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Lowest-Cost Paths</samp>
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">最低代价路径</samp>
- en: 'Before we can dive into algorithms to determine the lowest-cost paths through
    graphs, we must formalize what we mean by lowest-cost path. Recall from [Chapter
    3](chapter3.xhtml) that the total cost of a path is the sum of all edge weights
    along the path. For a path *p* = [*e*[0], *e*[1], . . . , *e*k], we define the
    cost as:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论确定图中最低代价路径的算法之前，我们必须明确最低代价路径的定义。回想一下[第 3 章](chapter3.xhtml)，路径的总代价是路径上所有边的权重之和。对于路径
    *p* = [*e*[0], *e*[1], . . . , *e*k]，我们定义代价为：
- en: '*PathCost*(*p*) = *∑*i [= 0 to] k *e*i.<samp class="SANS_TheSansMonoCd_W5Regular_11">weight</samp>'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*路径代价*(*p*) = *∑*i [= 0 到] k *e*i.<samp class="SANS_TheSansMonoCd_W5Regular_11">weight</samp>'
- en: 'We take the *shortest path* to be a sequence of edges *p* = [*e*[0], *e*[1],
    . . . , *e*k] from a given origin node *u* to a given destination node *v* that
    minimizes the path cost:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将*最短路径*定义为从给定起始节点 *u* 到给定目标节点 *v* 的边的序列 *p* = [*e*[0], *e*[1], . . . , *e*k]，它最小化路径代价：
- en: '*ShortestPath*(*u*, *v*) = *MIN*p (*PathCost*(*p*)) such that *e*[0].<samp
    class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp> = *u* and *e*k.<samp
    class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp> = *v*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*最短路径*(*u*, *v*) = *最小值* p (*路径代价*(*p*)) 使得 *e*[0].<samp class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp>
    = *u* 且 *e*k.<samp class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp> = *v*'
- en: 'We then define the *distance* between two nodes as the cost of the shortest
    path between those nodes:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义两个节点之间的*距离*为这两个节点之间最短路径的代价：
- en: '*dist*(*u*, *v*) = *PathCost*(*ShortestPath*(*u*, *v*))'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*dist*(*u*, *v*) = *路径代价*(*最短路径*(*u*, *v*))'
- en: As a concrete example, consider paths from node 0 to node 5 through the six-node
    graph with directed edges in [Figure 7-1](#fig7-1). The weights are shown for
    each edge. Our goal is to find the sequence of edges from node 0 to node 5 that
    incurs the least cost.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个具体的例子，考虑从节点 0 到节点 5 的路径，经过具有定向边的六节点图，如[图 7-1](#fig7-1)。每条边的权重已显示。我们的目标是找到从节点
    0 到节点 5 的边的序列，以使总成本最小。
- en: '![Each edge is labeled with its weight. The weight of edge (0, 3) is 1.0, the
    weight of edge (3, 4) is 1.0, and the weight of the edge (4, 5) is 2.0.](../images/f07001.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![每条边都标有其权重。边 (0, 3) 的权重为 1.0，边 (3, 4) 的权重为 1.0，边 (4, 5) 的权重为 2.0。](../images/f07001.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-1: A weighted, directed
    graph with six nodes</samp>'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-1：一个带权重的有向图，包含六个节点</samp>
- en: '[Table 7-1](#tab7-1) lists the cost of a few possible paths from node 0 to
    node 5 in [Figure 7-1](#fig7-1), showing that we can define a variety of paths
    with differing costs. In this example, the shortest path is [0, 3, 4, 5] with
    *dist*(0, 5) = *PathCost* ([0, 3, 4, 5]) = 4.0\. The lowest cost between two nodes
    may not use the minimum number of edges but may instead take more lower-cost steps.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 7-1](#tab7-1)列出了从节点 0 到节点 5 在[图 7-1](#fig7-1)中的一些可能路径的成本，显示我们可以定义多种具有不同成本的路径。在这个例子中，最短路径是[0,
    3, 4, 5]，其*dist*(0, 5) = *PathCost* ([0, 3, 4, 5]) = 4.0。两个节点之间的最低成本路径可能不会使用最少的边，而是可能采取更多较低成本的步骤。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 7-1:</samp> <samp class="SANS_Futura_Std_Book_11">Path
    Costs from Node 0 to Node 5</samp>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 7-1:</samp> <samp class="SANS_Futura_Std_Book_11">从节点
    0 到节点 5 的路径成本</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Path</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Cost</samp>
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">路径</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">成本</samp>
    |'
- en: '| --- | --- |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0, 3, 4, 5</samp> | <samp class="SANS_Futura_Std_Book_11">4.0</samp>
    |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0, 3, 4, 5</samp> | <samp class="SANS_Futura_Std_Book_11">4.0</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0, 4, 5</samp> | <samp class="SANS_Futura_Std_Book_11">4.5</samp>
    |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0, 4, 5</samp> | <samp class="SANS_Futura_Std_Book_11">4.5</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0, 1, 0, 3, 4, 5</samp> | <samp class="SANS_Futura_Std_Book_11">13.0</samp>
    |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0, 1, 0, 3, 4, 5</samp> | <samp class="SANS_Futura_Std_Book_11">13.0</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0, 3, 4, 3, 4, 5</samp> | <samp class="SANS_Futura_Std_Book_11">8.0</samp>
    |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0, 3, 4, 3, 4, 5</samp> | <samp class="SANS_Futura_Std_Book_11">8.0</samp>
    |'
- en: As [Table 7-1](#tab7-1) demonstrates, paths can contain loops. If we restrict
    the problem to using only positive edge weights, loops will strictly increase
    the cost of a path. Shortest-path algorithms will thus avoid them. This is immediately
    apparent from real-world examples such as the adventurer exploring a labyrinth
    in [Chapter 4](chapter4.xhtml). Looping around the same rooms in a labyrinth not
    only requires extra walking but also repeatedly incurs the cost of facing any
    respawned monsters.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如[表 7-1](#tab7-1)所示，路径可能包含环路。如果我们将问题限制为仅使用正边权值，环路将严格增加路径的成本。最短路径算法将避免这些环路。这在现实世界中的例子中是显而易见的，比如冒险者在[第
    4 章](chapter4.xhtml)中探索迷宫的情形。在迷宫中绕圈走不仅需要额外的步伐，而且还会重复面临任何复生怪物的代价。
- en: However, this problem becomes more complex (and less intuitive to visualize)
    if we allow negative edge weights. For this reason, the algorithms in this chapter
    place constraints on the use of negative weights, requiring that paths include
    no loops with a negative cost.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果允许负的边权值，问题会变得更加复杂（且更难以直观地可视化）。因此，本章中的算法对负权值的使用进行了限制，要求路径中不包含具有负成本的环路。
- en: A graph may have multiple lowest-cost paths between two nodes. The algorithms
    in this chapter produce one of the lowest-cost paths.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一个图中可能有多个最低成本的路径。此章中的算法产生其中之一。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Dijkstra’s Algorithm</samp>
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">Dijkstra 算法</samp>
- en: '*Dijkstra’s algorithm*, invented by the computer scientist Edsger W. Dijkstra,
    finds the lowest-cost path from a given starting node to all other nodes in the
    graph. It can work on either unweighted graphs or weighted graphs, with the constraint
    that none of the edge weights are negative. This constraint mirrors real-world
    path-planning problems in that we cannot decrease the total path length (cost)
    by adding another step. The clearest example of this is planning a road trip to
    minimize the total distance traveled. Since it is impossible to have negative
    distance, we can never shorten the trip by adding another step to the current
    path.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**Dijkstra 算法**由计算机科学家Edsger W. Dijkstra发明，用于从给定的起始节点到图中所有其他节点找到最低成本路径。它可以在无权图或加权图上运行，前提是边权值没有负值。这个限制反映了现实世界中的路径规划问题，因为我们无法通过增加一个额外的步骤来减少总路径长度（成本）。最典型的例子是规划公路旅行，目的是最小化旅行的总距离。由于不可能有负的距离，我们永远无法通过增加一个步骤来缩短旅行。'
- en: Dijkstra’s algorithm operates by maintaining a set of unvisited nodes and continually
    updating each one’s current estimated cost. It continually reduces the number
    of unvisited nodes by choosing the closest (lowest-cost) unvisited node and visiting
    it. It then explores this node and checks whether it provides a better path to
    each of its unvisited neighbors. In more detail, the algorithm computes the cost
    of the new proposed path by taking the cost to the current node and adding the
    cost to the neighbor. If this new cost is less than the best cost seen so far,
    the algorithm updates the cost.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Dijkstra 算法通过维护未访问节点的集合并不断更新每个节点的当前估计代价来运行。它通过选择距离起点最近（代价最低）的未访问节点并访问它，持续减少未访问节点的数量。然后它探索该节点并检查是否提供通向每个未访问邻居的更优路径。更详细地说，算法通过将当前节点的代价与邻居的代价相加来计算新提出路径的代价。如果新路径的代价小于迄今为止看到的最佳代价，算法就会更新该代价。
- en: Because the algorithm always chooses the closest (least-cost) node to explore
    next, we can be sure we’re taking the shortest possible path every time we visit
    each node. This arises from the fact we do not allow negative edge weights, so
    the addition of steps always increases the cost of the path.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因为算法始终选择下一个要探索的最近（最低代价）节点，我们可以确保每次访问节点时都在走最短的路径。这是因为我们不允许负的边权重，所以增加步骤总是会增加路径的代价。
- en: To visualize this, consider the state of the algorithm before visiting node
    *v*. We might worry that there is a better path to *v* through some unvisited
    node. After all, we haven’t seen all the paths in the graph. We might not have
    even visited all of *v*’s neighbors. However, any such path would have to travel
    through an unvisited node *w*. Since *v* is selected first, the cost of the path
    from the origin *u* to *w* is at least as large as the cost from *u* to *v*, and
    that gets us only part of the way to *v*. The subsequent path from *w* to *v*
    would only further increase the cost.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化这一点，考虑在访问节点 *v* 之前算法的状态。我们可能会担心通过某个未访问节点到 *v* 的路径更优。毕竟，我们还没有看到图中的所有路径，甚至可能没有访问过
    *v* 的所有邻居。然而，任何这样的路径都必须经过一个未访问的节点 *w*。由于 *v* 是首先被选中的，从起点 *u* 到 *w* 的路径代价至少和从 *u*
    到 *v* 的路径代价一样大，而这仅仅是到达 *v* 的一部分。随后的从 *w* 到 *v* 的路径只会进一步增加代价。
- en: For our adventurer mapping out a labyrinth from [Chapter 4](chapter4.xhtml),
    Dijkstra’s algorithm mirrors their clearing the maze room by room. The adventurer,
    a former cartography student, keeps meticulous notes on the shortest path found
    to each room they visit, since their retirement plan is to build dungeon guides
    they can sell to future adventurers. As the adventurer plans their next move,
    they consider which unvisited rooms they could reach, then try to determine the
    best path to each room from the dungeon entrance (the origin node). The path lengths
    are the cost of getting to an adjacent room, then transitioning to the unexplored
    room.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们从 [第 4 章](chapter4.xhtml) 中描绘迷宫的冒险者，Dijkstra 算法就像他们逐个房间地清理迷宫。这个冒险者曾是地图学的学生，他在每个访问过的房间里都详细记录了找到的最短路径，因为他的退休计划是编写地下城指南，并将其出售给未来的冒险者。在计划下一步行动时，冒险者会考虑可以到达哪些未访问的房间，然后尝试确定从地下城入口（起点节点）到每个房间的最佳路径。路径的长度是到达相邻房间的代价，然后转移到未探索房间的代价。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">代码</samp>
- en: 'The code for Dijkstra’s algorithm uses a priority queue to manage the set of
    unvisited nodes, as shown in the following implementation:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Dijkstra 算法的代码使用优先队列来管理未访问节点的集合，如下所示：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code relies on a custom implementation of the priority queue described
    in [Appendix B](appendix_B.xhtml) that allows for the dynamic updating of priorities.
    Interested readers can find the details in that appendix. For now, it is sufficient
    to view <samp class="SANS_TheSansMonoCd_W5Regular_11">PriorityQueue</samp> as
    a data structure that allows the efficient insertion of prioritized elements,
    removal of the element with the minimum priority, lookup of elements, and updates
    to elements’ priority.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码依赖于 [附录 B](appendix_B.xhtml) 中描述的优先队列的自定义实现，该实现允许动态更新优先级。有兴趣的读者可以在该附录中找到详细信息。现在，仅需要将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">PriorityQueue</samp> 视为一种数据结构，它允许高效地插入带优先级的元素、移除具有最低优先级的元素、查找元素以及更新元素的优先级。
- en: 'The code starts by creating several helper data structures, including the following:
    a list of best costs so far to each node (<samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>),
    a list indicating the last node visited before a given node (<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>),
    and a min-heap priority queue of unvisited nodes (<samp class="SANS_TheSansMonoCd_W5Regular_11">pq</samp>).
    The code places the starting index (<samp class="SANS_TheSansMonoCd_W5Regular_11">start_index</samp>)
    into the priority queue with a priority of <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp>
    and all other nodes into the priority queue with an infinite priority ❶. The cost
    to the starting node is marked as <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp>.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先创建多个辅助数据结构，包括以下内容：到每个节点的最佳成本列表（<samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>），指示在访问某个节点之前上一个访问节点的列表（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp>），以及一个未访问节点的最小堆优先队列（<samp class="SANS_TheSansMonoCd_W5Regular_11">pq</samp>）。代码将起始节点的索引（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">start_index</samp>）放入优先队列中，优先级为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp>，其余节点的优先级为无限大 ❶。起始节点的成本标记为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp>。
- en: The code then processes the nodes in the priority queue one by one, iterating
    through them with a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop until the priority queue is empty. During each iteration, the code extracts
    the minimum-cost node from the priority queue and explores it ❷.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码逐个处理优先队列中的节点，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    循环迭代，直到优先队列为空。在每次迭代中，代码从优先队列中提取出最小成本节点并进行探索 ❷。
- en: The code uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop
    to consider each of the current node’s neighbors, checking whether the neighbor
    is still in the priority queue with the <samp class="SANS_TheSansMonoCd_W5Regular_11">in_queue()</samp>
    function ❸. If the node is in the queue, the code has not yet visited it. The
    code then checks whether it has found a better path to that neighbor through the
    current node ❹. This check corresponds to comparing the best-cost path to the
    neighbor found so far (<samp class="SANS_TheSansMonoCd_W5Regular_11">cost[neighbor]</samp>)
    with the cost of the best path going through the current node (<samp class="SANS_TheSansMonoCd_W5Regular_11">cost[index]</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">edge
    .weight</samp>). Since the code initially sets all non-starting nodes to an infinite
    cost, they will at least be updated the first time they are seen. If the code
    has found a better path to the neighbor, it updates the neighbor node’s priority
    in the queue, its previous node in <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>,
    and the best cost ❺.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环来考虑当前节点的每一个邻居，检查该邻居是否仍在优先队列中，使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">in_queue()</samp> 函数 ❸。如果节点仍在队列中，说明代码尚未访问过该节点。然后，代码检查是否通过当前节点找到了一条更优的路径通往该邻居
    ❹。此检查对应于将当前找到的最优路径成本（<samp class="SANS_TheSansMonoCd_W5Regular_11">cost[neighbor]</samp>）与经过当前节点的最优路径成本（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">cost[index]</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">edge.weight</samp>）进行比较。由于代码最初将所有非起始节点的成本设为无限大，它们至少会在第一次被访问时被更新。如果代码找到了通往邻居的更优路径，它将更新该邻居节点在队列中的优先级、该节点的前一个节点在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> 中的记录，以及最优成本 ❺。
- en: The code continues exploring unvisited nodes (those still in the priority queue)
    until all nodes have been visited. As noted previously, once the code visits a
    node, it has found the shortest path and does not need to reconsider any visited
    nodes. When the code has visited all nodes, it returns the list of previous nodes
    on the path.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 代码继续探索未访问的节点（那些仍在优先队列中的节点），直到所有节点都被访问过。如前所述，一旦代码访问了某个节点，就说明已经找到了最短路径，并且不需要重新考虑任何已访问的节点。当代码访问完所有节点后，它返回路径上的前一个节点列表。
- en: Given the *heap-based* implementation of Dijkstra’s algorithm presented here,
    we can imagine how the algorithm scales to larger graph sizes. The algorithm visits
    each node exactly once by inserting all the nodes into a priority queue and then
    removing them one by one. Using a heap-based priority queue, each operation scales
    as log (|*V* |), so the entire time for iterating over these nodes scales as |*V*
    | log (|*V* |). During the visit to each node, we check whether each neighbor
    is in the priority queue and potentially update the priority. Since we are using
    the custom <samp class="SANS_TheSansMonoCd_W5Regular_11">PriorityQueue</samp>
    described in [Appendix B](appendix_B.xhtml), the lookup uses a dictionary and
    takes constant time on average. The update scales as log (|*V* |). Since we visit
    each node only once and consider its outgoing edges once, we will perform at most
    one update per edge, giving a cost that scales as |*E*| log (|*V* |). Thus, the
    total cost of the algorithm scales as |*V* | log (|*V* |) + |*E*| log (|*V* |)
    = (|*V* | + |*E*|) log (|*V* |).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这里展示的基于*堆*的Dijkstra算法实现，我们可以想象该算法如何在更大规模的图中扩展。该算法通过将所有节点插入优先队列并逐个移除节点，确保每个节点只访问一次。使用基于堆的优先队列，每个操作的时间复杂度为log(|*V*|)，因此迭代这些节点的总时间复杂度为|*V*|
    log(|*V*|)。在访问每个节点时，我们检查其每个邻居是否在优先队列中，并可能更新优先级。由于我们使用了在[附录B](appendix_B.xhtml)中描述的自定义<samp
    class="SANS_TheSansMonoCd_W5Regular_11">PriorityQueue</samp>，查找操作使用字典，并且在平均情况下是常数时间。更新操作的复杂度为log(|*V*|)。由于我们每个节点只访问一次，并且只考虑其出边一次，所以最多每条边更新一次，成本为|*E*|
    log(|*V*|)。因此，算法的总成本为|*V*| log(|*V*|) + |*E*| log(|*V*|) = (|*V*| + |*E*|) log(|*V*|)。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">一个示例</samp>'
- en: '[Figure 7-2](#fig7-2) illustrates Dijkstra’s algorithm operating on a five-node
    graph. Each subfigure represents the state of the algorithm after finishing a
    step. The dashed circle indicates the node that was just processed, while shaded
    nodes are those that have been visited. The priority queue (<samp class="SANS_TheSansMonoCd_W5Regular_11">pq</samp>)
    is shown in sorted order to make it easy to see the relative priorities, although
    it is stored in heap order.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-2](#fig7-2)展示了Dijkstra算法在一个五节点图上的操作。每个子图表示算法完成一步后的状态。虚线圆圈表示刚刚处理的节点，阴影节点表示已经访问过的节点。优先队列（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">pq</samp>）以排序顺序显示，便于查看相对优先级，尽管它实际是按堆排序存储的。'
- en: '![Each subfigure shows the graph, the array last, the array cost, and a sorted
    version of the priority queue.](../images/f07002.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![每个子图展示了图、last数组、cost数组和排序后的优先队列。](../images/f07002.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-2: The steps of Dijkstra’s
    algorithm</samp>'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-2：Dijkstra算法的步骤</samp>
- en: '[Figure 7-2(a)](#fig7-2) represents the state of the algorithm before the first
    node is explored. The adventurer is standing at the entrance, ready to begin their
    quest. All nodes have <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    entries of <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>, indicating
    we do not know the path to get to them. Node 0 has a cost of <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>,
    since our search begins there, and all other nodes have an infinite estimated
    cost because we do not yet know *any* possible path. Unlike the algorithms for
    depth-first search and breadth-first search, we start with all nodes in the priority
    queue.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-2(a)](#fig7-2)表示在探索第一个节点之前，算法的状态。冒险者站在入口处，准备开始他们的任务。所有节点的<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>条目为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>，表示我们尚不知道到达它们的路径。节点0的成本为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp>，因为搜索从这里开始，而所有其他节点的估算成本为无限大，因为我们尚未知道*任何*可能的路径。与深度优先搜索和广度优先搜索算法不同，我们一开始就将所有节点放入优先队列。'
- en: 'At each step, the algorithm explores the best node remaining in the queue.
    In [Figure 7-2(b)](#fig7-2), it selects node 0 (the only node without an infinite
    cost) and visits it. It finds edges to three neighbors: nodes 1, 2, and 3\. The
    search compares the cost of a path through node 0 to the current costs. Since
    the new cost is less than infinity for all three nodes, it updates their entries
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">pq</samp>. This update in the
    priority queue reorders the list of nodes to explore next.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一步中，算法都会探索队列中剩余的最佳节点。在[图 7-2(b)](#fig7-2)中，算法选择了节点 0（唯一一个没有无限代价的节点），并访问了它。它发现有三条边通向邻居：节点
    1、节点 2 和节点 3。搜索比较了通过节点 0 到达其他节点的路径代价与当前代价的大小。由于新路径代价对这三个节点来说都小于无限大，算法更新了它们在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">pq</samp> 中的条目。这个在优先队列中的更新重新排序了待探索的节点列表。
- en: '[Figure 7-2(c)](#fig7-2) shows what happens when the search visits node 2\.
    This node has a single neighbor (node 3) with an estimated cost of <samp class="SANS_TheSansMonoCd_W5Regular_11">2.0</samp>.
    However, the path to node 3 through node 2 now provides a better option with a
    total cost of 0.5 + 1.0 = 1.5\. The algorithm updates the <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>
    entry of node 3 to <samp class="SANS_TheSansMonoCd_W5Regular_11">1.5</samp> and
    its <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> entry to <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-2(c)](#fig7-2)展示了当搜索访问节点 2 时发生的情况。该节点有一个邻居（节点 3），其估算代价为<samp class="SANS_TheSansMonoCd_W5Regular_11">2.0</samp>。然而，现在通过节点
    2 到达节点 3 的路径提供了一个更优的选择，总代价为 0.5 + 1.0 = 1.5。算法将节点 3 的<samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>条目更新为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">1.5</samp>，并将其<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>条目更新为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">2</samp>。'
- en: Through the lens of our adventurer, room 2 provides a better path to room 3\.
    Maybe there is a particularly powerful monster guarding the passage from room
    0 to room 3\. The adventurer, cognizant of the needs of future generations of
    explorers, takes this into account and redirects the suggested path to room 3
    to go through room 2.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的冒险者角度看，房间 2 提供了一条到房间 3 的更优路径。也许有一只特别强大的怪物守卫着从房间 0 到房间 3 的通道。为了未来的探索者考虑，冒险者会将建议的路径改变，选择通过房间
    2 前往房间 3。
- en: The search continues through the remaining nodes. When the algorithm visits
    node 3 in [Figure 7-2(d)](#fig7-2), it finds a better path to node 1\. Similarly,
    visiting node 1 in [Figure 7-2(e)](#fig7-2) provides a better path to node 4\.
    The search completes in [Figure 7-2(f)](#fig7-2) after visiting the final node.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索继续在剩余节点中进行。当算法访问到[图 7-2(d)](#fig7-2)中的节点 3 时，发现到节点 1 的路径更优。类似地，访问到[图 7-2(e)](#fig7-2)中的节点
    1 时，提供了一条到节点 4 的更优路径。搜索在[图 7-2(f)](#fig7-2)中完成，访问了最后一个节点。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Disconnected Graphs</samp>
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">断开的图</samp>
- en: Asking what happens if some nodes are not reachable from the starting node can
    help us understand how Dijkstra’s algorithm performs on a disconnected graph.
    Consider the four-node graph in [Figure 7-3](#fig7-3), where only nodes 0 and
    1 are reachable when starting from node 0.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 询问如果某些节点无法从起始节点到达，会发生什么，能够帮助我们理解 Dijkstra 算法在断开图上的表现。考虑[图 7-3](#fig7-3)中的四节点图，其中从节点
    0 出发时，只有节点 0 和节点 1 是可达的。
- en: '![The graph has three edges: from node 0 to node 1, from node 2 to node 3,
    and from node 3 to node 2.](../images/f07003.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![该图有三条边：从节点 0 到节点 1，从节点 2 到节点 3，以及从节点 3 到节点 2。](../images/f07003.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-3: A graph with unreachable
    nodes</samp>'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-3：一个包含不可达节点的图</samp>
- en: This corresponds to unreachable rooms in the labyrinth. From legend, the adventurer
    knows the labyrinth has four rooms, but they can reach only two. There is no path
    from room 0 to room 2 or room 3, so the adventurer has no choice but to indicate
    this in their notes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这对应于迷宫中的不可达房间。从传说中，冒险者知道迷宫有四个房间，但他们只能到达其中两个。房间 0 到房间 2 或房间 3 之间没有路径，所以冒险者只能在笔记中标明这一点。
- en: Dijkstra’s algorithm can easily handle this case. Both nodes 2 and 3 are initially
    assigned a <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> value of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp> and an infinite cost.
    Because there is no path from node 0 to either of these nodes, when either is
    extracted from the priority queue, it still has an infinite cost. When the algorithm
    considers the node’s neighbors, the estimated cost through that node will be infinite,
    so the algorithm never updates either <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>. At the end of the
    algorithm, both nodes 2 and 3 will have last pointers of <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Dijkstra 算法可以轻松处理这种情况。节点 2 和 3 最初被分配了 <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    值 <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp> 和无限大的成本。由于从节点 0 到这两个节点之间没有路径，当其中一个节点从优先队列中提取出来时，它的成本仍然是无限大的。当算法考虑到该节点的邻居时，通过该节点的估计成本将是无限的，因此算法不会更新任何
    <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>。在算法结束时，节点
    2 和 3 的最后指针将为 <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Negative Edge Weights</samp>
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">负权边</samp>
- en: In real-world problems, edge weights can be negative, representing a negative
    cost (a benefit). Consider the example of communications within a social network,
    where each connection between friends is an edge. The weight of each edge represents
    the cost of passing a rumor from one person to the next. This cost might be the
    loss of the time required to send a text or to chat. However, in some cases, the
    edge weight can be negative and represent a benefit to using that channel of communication.
    If two friends have not spoken in a while, the cost of reengaging to pass along
    some gossip may very well be negative.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实问题中，边的权重可能是负数，表示负成本（或一种利益）。例如，考虑社交网络中的通信，每对朋友之间的连接就是一条边。每条边的权重表示将谣言从一个人传递到另一个人的成本。这个成本可能是发送短信或聊天所需的时间损失。然而，在某些情况下，边的权重可能为负，表示使用该通信渠道的利益。如果两个朋友有一段时间没有交谈，重新联系并传递一些八卦的成本可能是负的。
- en: Alternatively, we can envision path planning to minimize the battery usage of
    an electric vehicle. If an edge represents a steep downhill road, we can use the
    combination of gravity and regenerative braking to charge the battery. The cost
    in terms of battery usage for this segment is negative.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们可以设想路径规划来最小化电动汽车的电池使用。如果一条边代表一条陡峭的下坡路，我们可以利用重力和再生制动来为电池充电。该段路径的电池使用成本是负的。
- en: Note that in the context of negative edge weights, the term *shortest path*
    does not really make sense, as distances cannot be negative. No matter how skilled
    you are at path planning, you cannot organize a cycling trip that gets you home
    before you set out. However, we continue to refer to these problems as *shortest
    path* for consistency with the wider literature.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在负权边的情况下，*最短路径*一词并不完全有意义，因为距离不能为负。无论你在路径规划上多么熟练，你都不能组织一次在出发之前就已经回到家的骑行旅行。然而，为了与广泛的文献保持一致，我们仍然继续称这些问题为*最短路径*。
- en: 'When considering the shortest path through a graph with negative edges, we
    still need to maintain one constraint: the graph cannot contain negative cycles.
    A *negative cycle* occurs whenever there is a path from a node back to itself
    where the sum of edge weights is negative. In the presence of such cycles, the
    entire concept of lowest-cost path breaks down. For example, consider the graph
    in [Figure 7-4](#fig7-4), where edge (0, 1) has a weight of <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp>
    and edge (1, 0) has a weight of <samp class="SANS_TheSansMonoCd_W5Regular_11">-2.0</samp>.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑带有负权边的图中的最短路径时，我们仍然需要保持一个约束条件：图中不能包含负环。*负环*是指当从一个节点回到自身时，边的权重之和为负数的路径。在存在这样的环时，最低成本路径的概念将失效。例如，考虑[图
    7-4](#fig7-4)，其中边 (0, 1) 的权重为 <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp>，而边
    (1, 0) 的权重为 <samp class="SANS_TheSansMonoCd_W5Regular_11">-2.0</samp>。
- en: '![A graph with three nodes and three edges. The edge (1, 2) has a weight of
    1.0.](../images/f07004.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含三个节点和三条边的图。边 (1, 2) 的权重为 1.0。](../images/f07004.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-4: A graph with a
    negative cycle</samp>'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-4：带有负环的图</samp>
- en: If we try to find the lowest-cost path from node 0 to node 2 in [Figure 7-4](#fig7-4),
    we immediately run into problems. As shown in [Table 7-2](#tab7-2), we can keep
    adding another loop from node 0 to node 1 to node 0 to further reduce the cost.
    The lowest-cost path would loop back and forth forever.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试在[图 7-4](#fig7-4)中找到从节点 0 到节点 2 的最低成本路径，我们会立即遇到问题。如[表 7-2](#tab7-2)所示，我们可以不断地从节点
    0 到节点 1 再到节点 0 添加另一个循环以进一步降低成本。最低成本路径将会永远来回循环。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 7-2:</samp> <samp class="SANS_Futura_Std_Book_11">The
    Cost of Paths in [Figure 7-4](#fig7-4)</samp>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 7-2:</samp> <samp class="SANS_Futura_Std_Book_11">[图
    7-4](#fig7-4)中的路径成本</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Path</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Cost</samp>
    |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">路径</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">成本</samp>
    |'
- en: '| --- | --- |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0, 1, 2</samp> | <samp class="SANS_Futura_Std_Book_11">2</samp>
    |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0, 1, 2</samp> | <samp class="SANS_Futura_Std_Book_11">2</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0, 1, 0, 1, 2</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0, 1, 0, 1, 2</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0, 1, 0, 1, 0, 1, 2</samp> | <samp
    class="SANS_Futura_Std_Book_11">0</samp> |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0, 1, 0, 1, 0, 1, 2</samp> | <samp
    class="SANS_Futura_Std_Book_11">0</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0, 1, 0, 1, 0, 1, 0, 1, 2</samp> |
    <samp class="SANS_Futura_Std_Book_11">–1</samp> |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0, 1, 0, 1, 0, 1, 0, 1, 2</samp> |
    <samp class="SANS_Futura_Std_Book_11">–1</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">. . .</samp> | <samp class="SANS_Futura_Std_Book_11">. . .</samp>
    |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">. . .</samp> | <samp class="SANS_Futura_Std_Book_11">. . .</samp>
    |'
- en: In contrast, [Figure 7-5](#fig7-5) shows a graph with a negative edge weight
    but no negative cycles. It is possible to travel from node 1 to node 0 with a
    negative cost. However, any path from node 0 back to itself or node 1 back to
    itself will have a total positive cost.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，[图 7-5](#fig7-5)展示了一个具有负边权但没有负环的图。可以从节点 1 到节点 0 以负成本旅行。然而，从节点 0 返回到自身或从节点
    1 返回到自身的任何路径将具有总正成本。
- en: '![A graph with four nodes and five edges. The edge (0, 1) has a weight of 3.5\.
    the edge (1, 0) has a weight –0.5.](../images/f07005.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![一个具有四个节点和五条边的图。边 (0, 1) 的权重为 3.5，边 (1, 0) 的权重为 –0.5。](../images/f07005.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-5: A graph with a
    negative edge weight but no negative cycles</samp>'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-5: 具有负边权但无负环的图</samp>'
- en: How can we tell whether a graph has negative cycles? A negative cycle could
    be incredibly long, looping through every node of the graph and thus not be immediately
    obvious. The Bellman-Ford algorithm solves this problem for us by checking for
    the existence of negative cycles in a graph.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何判断一个图是否具有负环？负环可能非常长，通过图的每个节点循环，因此不会立即显现。Bellman-Ford 算法通过检查图中负环的存在来解决这个问题。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Bellman-Ford Algorithm</samp>
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">贝尔曼-福特算法</samp>
- en: A major drawback of Dijkstra’s algorithm is that it is limited to graphs with
    positive edge weights. The Bellman-Ford algorithm removes this limitation, but
    it must add computational cost to do so.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Dijkstra 算法的一个主要缺点是它仅限于具有正边权的图。Bellman-Ford 算法消除了这一限制，但必须增加计算成本才能实现。
- en: The *Bellman-Ford algorithm* operates by repeatedly iterating over the list
    of edges and using them to update the best cost to each node (a process called
    *relaxation*). Like Dijkstra’s algorithm, it maintains a list <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>
    that stores the best cost seen so far from the origin to each node. Each time
    Bellman-Ford considers an edge, it asks if this edge presents a better path to
    the edge’s destination node by comparing that node’s current cost estimate (entry
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>) to the one provided
    by traveling from the edge’s origin (using the origin’s entry in <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>
    plus the edge weight). It repeats this test over and over, improving the estimates
    of the best paths.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*Bellman-Ford 算法*通过反复遍历边列表，并利用这些边来更新到达每个节点的最佳成本来运行（这个过程叫做 *松弛*）。与 Dijkstra
    算法类似，它维护一个列表 <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>，存储从起点到每个节点的当前最佳成本估算。每当
    Bellman-Ford 考虑一条边时，它会比较该边的目标节点当前的成本估算（即 <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>
    中的条目）与通过从边的起点出发（使用起点在 <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>
    中的条目加上边的权重）得出的估算，查看这条边是否提供了更好的路径。它会不断重复这个测试，不断改进最佳路径的估算。'
- en: We can visualize the algorithm as an extremely thorough travel agent considering
    flight options for the coming travel season. The agent starts with an origin like
    Chicago and looks for the cheapest path to each possible destination around the
    world. Obviously, the agent cannot take every flight themselves (that is, cannot
    travel the entire graph). However, they can easily scan through the list of flights
    and their prices to update their spreadsheet of estimates.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将该算法想象为一位非常细致的旅行代理人，正在为即将到来的旅游季节考虑航班选项。代理人从一个起点（例如芝加哥）开始，寻找前往全球每个可能目的地的最便宜路径。显然，代理人不能亲自乘坐每个航班（也就是说，不能遍历整个图）。然而，他们可以轻松地浏览航班和价格列表，更新他们的估算表格。
- en: After a single scan through the flight list, the agent knows the best direct
    flights from Chicago to every other city. They scan through the list again, asking
    if they can build better paths to each possible destination using what they know
    about the best trips so far. They repeatedly scan the list, updating their estimates,
    until they have the best path to every destination.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在对航班列表进行一次扫描后，代理人就能知道从芝加哥到其他每个城市的最佳直飞航班。然后，他们再次扫描列表，询问是否可以利用当前掌握的最佳旅行信息，构建通往每个目的地的更好路径。代理人反复扫描列表，更新他们的估算，直到为每个目的地找到最佳路径。
- en: Like the travel agent, with each iteration of Bellman-Ford’s outer loop, we
    are effectively building better paths. This progressive construction of paths
    is shown in [Figure 7-6](#fig7-6). The bold lines represent the best-known path
    from node 2 to node 0 after each iteration.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 就像旅行代理人一样，通过 Bellman-Ford 外层循环的每次迭代，我们实际上在构建更好的路径。这个路径逐步构建的过程在 [图 7-6](#fig7-6)
    中得到了展示。加粗的线条表示每次迭代后，从节点 2 到节点 0 的最佳已知路径。
- en: '![A graph with four nodes and five edges. In subfigure A, the edge (0, 3) with
    weight 10.0 is bolded. In subfigure B, the edges (0, 2) with weight 5.0 and (2,
    3) with weight 1.0 are bolded. In subfigure C, the edges (0,1), (1, 2), and (2,
    3), all with weight 1.0, are bolded.](../images/f07006.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含四个节点和五条边的图。在子图 A 中，边 (0, 3) 的权重为 10.0，已加粗。在子图 B 中，边 (0, 2) 的权重为 5.0 和边
    (2, 3) 的权重为 1.0 已加粗。在子图 C 中，边 (0,1)，(1, 2) 和 (2, 3)，其权重均为 1.0，都已加粗。](../images/f07006.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-6: The Bellman-Ford
    algorithm finding progressively better paths from node 2 to node 0</samp>'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-6：Bellman-Ford 算法从节点 2 到节点
    0 找到逐步更优的路径</samp>
- en: '[Figure 7-6(a)](#fig7-6) shows the best path from node 2 to node 0 after one
    iteration through each edge. Since the algorithm has looked at each edge only
    once, it sees a direct path only from node 2 to node 0 with cost <samp class="SANS_TheSansMonoCd_W5Regular_11">10.0</samp>.
    It did not have a chance to realize it could build a better path using the edges
    (2, 1) and (1, 0). During the second iteration, the algorithm uses the knowledge
    of a path with cost <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp> from
    node 2 to node 1 to build a path to node 0\. The best path to node 0 is updated
    to go through node 1 and costs <samp class="SANS_TheSansMonoCd_W5Regular_11">2.0</samp>,
    as shown in [Figure 7-6(b)](#fig7-6).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-6(a)](#fig7-6)展示了节点2到节点0经过每条边一次后得到的最佳路径。由于算法仅查看了每条边一次，它只看到从节点2到节点0的直接路径，成本为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">10.0</samp>。它没有机会意识到可以通过边(2, 1)和(1, 0)构建更好的路径。在第二次迭代中，算法利用从节点2到节点1的成本为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp>的路径，构建了一条到节点0的路径。节点0的最佳路径更新为经过节点1，成本为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">2.0</samp>，如[图 7-6(b)](#fig7-6)所示。'
- en: We can cap the total number of iterations at |*V* | – 1, where |*V* | is the
    number of nodes in the graph. Because negative cycles are not allowed, a least-cost
    path can never return to the same node, as doing so would strictly increase the
    cost of the path. This is the reason real-world travel itineraries between different
    cities do not include cycles—that is, multiple layovers at the same airport.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将总迭代次数限制为|*V*| – 1，其中|*V*|是图中节点的数量。由于不允许负环，最小成本路径永远不能返回到相同的节点，因为这样做会严格增加路径的成本。这也是现实世界中不同城市间的旅行路线不包含循环的原因——即，不会有多次在同一机场的中转。
- en: Since the least-cost path can never repeat nodes, it can touch at most all |*V*
    | nodes and use |*V* | – 1 edges. For the six-node graph in [Figure 7-7](#fig7-7),
    for example, the lowest-cost path from node 0 to node 1 is [0, 3, 4, 5, 2, 1].
    Although there are alternate paths with fewer steps, the lowest-cost path from
    node 0 to node 1 uses five edges and visits all the nodes in the graph.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于最小成本路径不能重复经过节点，因此它最多可以触及所有|*V*|个节点，并使用|*V*| – 1条边。例如，在[图 7-7](#fig7-7)中，节点0到节点1的最低成本路径是[0,
    3, 4, 5, 2, 1]。虽然存在经过更少步骤的备选路径，但节点0到节点1的最低成本路径使用了五条边，并访问了图中的所有节点。
- en: '![The graph has an edge from node 0 to node 1 with weight 10.0\. The edges
    (0, 3), (3, 4), (4, 5), (5, 2), and (2, 1) all have weight 1.0.](../images/f07007.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![该图从节点0到节点1有一条权重为10.0的边。边(0, 3)、(3, 4)、(4, 5)、(5, 2)和(2, 1)的权重均为1.0。](../images/f07007.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-7: An example graph
    with a five-step path from node 0 to node 1</samp>'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-7：一个包含从节点0到节点1的五步路径的示例图</samp>
- en: Bellman-Ford uses this constraint to both stop the algorithm and test for cycles.
    After |*V* | – 1 iterations of the outer loop, it has found all possible lowest-cost
    paths. Because this algorithm uses two nested <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops (one over the number of nodes and the other over each edge), its cost scales
    as the product |*E*| |*V* |.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Bellman-Ford算法利用这一约束来停止算法并检测环路。在外循环执行|*V*| – 1次迭代后，它已经找到了所有可能的最小成本路径。由于该算法使用了两个嵌套的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环（一个遍历节点数量，另一个遍历每一条边），其成本按|*E*|
    |*V*|的乘积来扩展。
- en: Additional iterations through the edges will not help unless there is a negative
    cycle. Armed with this knowledge, the algorithm tries one additional iteration
    and tests whether any costs decrease. If so, it knows the graph has a negative
    cycle.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 除非存在负环，额外的边迭代不会有任何帮助。掌握这一知识后，算法会进行一次额外的迭代，并测试是否有任何成本降低。如果有，它就知道图中存在负环。
- en: We can picture this last test as our travel agent performing one last check
    over their list of least-cost flights. They notice that adding another leg between
    Pittsburgh and Boston further lowers the price. Confused, they look back over
    the flight data and see that a trip from Chicago to Boston to Pittsburgh to Boston
    to Seattle is the cheapest option so far. The loop from Boston to Pittsburgh and
    back provides a negative cycle. Obviously, something has gone wrong with the flight
    pricing, creating a loop that effectively costs negative dollars. The travel agent
    hurries to call their client about a potential free 10-stop trip before the airline
    fixes the problem.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将最后的测试想象成我们的旅行代理人对其最便宜航班列表进行最后一次检查。他们注意到，在匹兹堡和波士顿之间添加一段航程进一步降低了价格。感到困惑时，他们回顾航班数据，发现从芝加哥到波士顿，再到匹兹堡，再到波士顿，再到西雅图的行程是目前为止最便宜的选项。从波士顿到匹兹堡再回到波士顿的循环提供了一个负环。显然，航班定价出现了问题，形成了一个有效的负费用循环。旅行代理人赶紧打电话给客户，告诉他们可能有一次免费的
    10 站旅行，赶在航空公司修复问题之前。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">代码</samp>
- en: 'The Bellman-Ford iterates over each edge |*V* | – 1 times. Every iteration,
    it asks the following simple question: “Does the current edge provide a better
    path to its destination node?” The code uses a pair of <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops to drive this search:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Bellman-Ford 会对每一条边进行 |*V* | – 1 次迭代。每次迭代，它都会问一个简单的问题：“当前边是否提供到目的地节点的更好路径？”代码使用一对
    <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环来驱动这个搜索：
- en: '[PRE1]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">BellmanFord()</samp> function
    takes a <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> and starting
    index and returns either the best path to each destination (using a <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    array) or <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> if the graph
    has a negative loop. We need to import <samp class="SANS_TheSansMonoCd_W5Regular_11">Union</samp>
    from Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">typing</samp> library
    to allow type hints for the multiple return values.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">BellmanFord()</samp> 函数接受一个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">图</samp> 和起始索引，返回到每个目的地的最佳路径（使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp> 数组）或如果图中存在负环则返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>。我们需要从
    Python 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">typing</samp> 库导入 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Union</samp>，以便对多个返回值进行类型提示。
- en: This code starts by creating the tracking data structures, including the best
    costs so far (<samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>) and the
    previous node on the current path (<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>).
    It also extracts a full list of edges for the algorithm using the <samp class="SANS_TheSansMonoCd_W5Regular_11">make_edge_list()</samp>
    function, which iterates through each node and assembles a list of every edge
    in the graph. Finally, it sets the cost of the starting node to 0.0.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先创建跟踪数据结构，包括目前为止的最佳费用（<samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>）和当前路径上前一个节点（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp>）。它还使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">make_edge_list()</samp>
    函数提取算法所需的完整边列表，该函数遍历每个节点并组装图中的每一条边。最后，它将起始节点的费用设置为 0.0。
- en: A pair of nested <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops
    drives |*V* | – 1 iterations over the list of edges. For each edge, the code assesses
    the cost to the destination using that edge ❶. If this cost is less than the current
    best cost ❷, the code updates both the best-cost estimate and the path to the
    node. Note that the reduced cost may not result from changing the previous node
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>); rather, the cost
    to the previous node could have decreased due to a better path to that previous
    node.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一对嵌套的 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环驱动 |*V* | –
    1 次遍历边列表。对于每条边，代码评估通过该边到达目的地的费用 ❶。如果该费用小于当前的最佳费用 ❷，代码就会更新最佳费用估算值和到该节点的路径。请注意，减少的费用可能不是由于更改了前一个节点（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp>）；相反，前一个节点的费用可能是由于有了更好的路径而下降了。
- en: When the code has completed |*V* | – 1 iterations of the outer loop, it has
    finished the optimization. Before concluding, it checks whether the solution is
    valid. If any cost could still be improved by taking another step ❸, the graph
    must have a negative cost cycle, in which case the algorithm returns <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>.
    Otherwise, it returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    list.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码完成 |*V* | – 1 次外部循环迭代时，它已经完成了优化。在结束之前，它会检查解决方案是否有效。如果任何成本仍然可以通过再走一步 ❸ 来改进，那么图中必定存在负成本环，在这种情况下，算法返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>。否则，它返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    列表。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">一个例子</samp>
- en: '[Figure 7-8](#fig7-8) shows the first iteration of the outer loop of the Bellman-Ford
    algorithm. Since the algorithm takes (|*V* | – 1) |*E*| steps, where |*E*| is
    the number of edges, it is not feasible to show all 36 steps. Instead, we consider
    the first iteration of the outer loop to review how the paths (represented by
    <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>) and estimated costs
    change. Each subfigure represents the state of the algorithm after examining the
    bolded edge.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-8](#fig7-8) 显示了 Bellman-Ford 算法外部循环的第一次迭代。由于算法需要进行 (|*V* | – 1) |*E*|
    步，其中 |*E*| 是边的数量，因此不可能展示所有的 36 步。相反，我们考虑外部循环的第一次迭代，以回顾路径（由 <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    表示）和估算成本的变化。每个子图表示算法在检查加粗的边后的状态。'
- en: '![Each subfigure shows a graph with five nodes, the array last, and the array
    cost.](../images/f07008.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![每个子图显示了一个包含五个节点的图，数组 last 和数组 cost。](../images/f07008.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-8: The starting state
    and nine steps performed during the first iteration of Bellman-Ford’s outer loop</samp>'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-8：Bellman-Ford 外部循环第一次迭代的起始状态和九个步骤</samp>
- en: '[Figure 7-8(a)](#fig7-8) shows the state of the algorithm before it examines
    any edges. All the nodes have an estimated infinite cost except the starting node.
    In [Figure 7-8(b)](#fig7-8), the algorithm tests the first edge and sees that
    it provides a better path to its destination, node 1\. It updates the path to
    node 1 to be the path from node 0 and the best cost to be <samp class="SANS_TheSansMonoCd_W5Regular_11">3.5</samp>.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-8(a)](#fig7-8) 显示了算法在检查任何边之前的状态。除了起始节点外，所有节点的估计成本都是无限大。在 [图 7-8(b)](#fig7-8)
    中，算法测试了第一条边，并发现它提供了一条到目标节点 1 的更优路径。它将到节点 1 的路径更新为从节点 0 出发的路径，并将最佳成本更新为 <samp class="SANS_TheSansMonoCd_W5Regular_11">3.5</samp>。'
- en: The search continues through each of the graph’s edges, considering the cost
    to a single node—the current edge’s destination—with each iteration. In [Figure
    7-8(c)](#fig7-8), it finds a better path to node 2; in [Figure 7-8(d)](#fig7-8),
    it finds a better path to node 3\. It doesn’t update anything in [Figure 7-8(e)](#fig7-8)
    because the best cost from node 0 to node 0 is <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp>,
    and we don’t need an unnecessary loop through node 1 to get back to the starting
    point.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索通过图中的每一条边继续进行，每次迭代时考虑到单个节点——当前边的目标节点的成本。在 [图 7-8(c)](#fig7-8) 中，它发现了一条到节点
    2 的更优路径；在 [图 7-8(d)](#fig7-8) 中，它发现了一条到节点 3 的更优路径。在 [图 7-8(e)](#fig7-8) 中，它没有更新任何内容，因为从节点
    0 到节点 0 的最佳成本是 <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp>，我们不需要通过节点
    1 再次绕回起点。
- en: At the end of the first iteration of the outer loop, shown as [Figure 7-8(j)](#fig7-8),
    the search has examined each edge and made updates to the best paths and cost
    estimations. However, the algorithm is not complete. The true best path to node
    4 is [0, 2, 3, 1, 4] and has a cost of <samp class="SANS_TheSansMonoCd_W5Regular_11">3.0</samp>.
    It will not find this final cost until it reconsiders the edge (1, 4). When it
    considered this edge in the first round, it had yet to find the best path to node
    1, so its cost estimate is too large.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在外部循环的第一次迭代结束时，如 [图 7-8(j)](#fig7-8) 所示，搜索已经检查了每条边并更新了最佳路径和成本估算。然而，算法尚未完成。到节点
    4 的真实最佳路径是 [0, 2, 3, 1, 4]，其成本为 <samp class="SANS_TheSansMonoCd_W5Regular_11">3.0</samp>。直到重新考虑边
    (1, 4) 时，算法才会找到这个最终的成本。在第一次循环中，算法还未找到到节点 1 的最佳路径，因此它的成本估算值过大。
- en: As the algorithm continues, it revisits edges and continually updates the best
    path and its cost. [Figure 7-9](#fig7-9) shows the final step of the algorithm.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 随着算法的继续，它会重新检查边，并不断更新最佳路径及其成本。[图 7-9](#fig7-9) 显示了算法的最终步骤。
- en: '![The edge (4, 1) with weight 1.0 is bolded. The last array reads [-1, 3, 0,
    2, 1] and the cost array reads [0.0, 2.5, 0.5, 1.5, 3.0].](../images/f07009.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![边（4, 1）权重为1.0，已加粗。最后的数组为[-1, 3, 0, 2, 1]，成本数组为[0.0, 2.5, 0.5, 1.5, 3.0]。](../images/f07009.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-9: The final state
    of the Bellman- Ford algorithm</samp>'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-9：Bellman-Ford算法的最终状态</samp>
- en: After examining the edge (4, 1) for the fourth time, the algorithm has completed
    both loops. The costs and paths have converged to their true values.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四次检查边（4, 1）后，算法已经完成了两个循环。成本和路径已收敛到其真实值。
- en: <samp class="SANS_Futura_Std_Bold_B_11">All-Pairs Shortest Paths</samp>
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">所有节点对最短路径</samp>
- en: Both our explorer and travel agent examples were satisfied with an algorithm
    that finds the lowest-cost path from a given start node to all other nodes in
    the graph. However, what if we want to find the shortest path between *any* pair
    of nodes in the graph? Even within the context of our previous two analogies,
    we can see the appeal of such an approach. Once the adventurer has mapped out
    the entire magical labyrinth, they may want to move back and forth between arbitrary
    rooms to help other adventurers who are in trouble. Likewise, our travel agent
    may want to go global, planning trips from any starting location to any destination
    in the world. In both cases, we need to find the least-cost path between two arbitrary
    nodes.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的探险者和旅行社例子都满足于找到从给定起点到图中所有其他节点的最低成本路径的算法。然而，如果我们想要找到图中*任何*节点对之间的最短路径呢？即便是在我们之前的两个类比中，我们也能看到这种方法的吸引力。一旦冒险者绘制出整个魔法迷宫，他们可能希望在任意房间之间来回穿梭，以帮助其他遇到困难的冒险者。同样，我们的旅行社可能想要全球化，规划从任何起点到全球任何目的地的旅行。在这两种情况下，我们都需要找到两个任意节点之间的最低成本路径。
- en: The *all-pairs shortest-path problem* aims to find the shortest path between
    every pair of nodes in a graph. Phrased another way, we now want to build a *matrix*
    <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> such that each row <samp
    class="SANS_TheSansMonoCd_W5Regular_11">last[i]</samp> contains the previous-node
    list for paths starting from node *i*. In this formulation, the entry of the matrix
    <samp class="SANS_TheSansMonoCd_W5Regular_11">last[i][j]</samp> is the node immediately
    before *j* on the path from *i* to node *j*. As with our previous <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    array formulation in the various search algorithms and other shortest-path algorithms,
    for a fixed starting point, we can trace the previous nodes backward from our
    destination to the origin.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*所有节点对最短路径问题*的目标是找到图中每对节点之间的最短路径。换句话说，我们现在希望构建一个*矩阵*<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>，使得每一行<samp
    class="SANS_TheSansMonoCd_W5Regular_11">last[i]</samp>包含从节点*i*出发的路径的前驱节点列表。在这个公式中，矩阵的条目<samp
    class="SANS_TheSansMonoCd_W5Regular_11">last[i][j]</samp>是从*i*到节点*j*路径上，紧接着*j*之前的节点。与我们之前在各种搜索算法和其他最短路径算法中使用的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp>数组公式一样，对于一个固定的起点，我们可以从目的地追溯前驱节点，直到回到起点。'
- en: 'We can solve the problem of finding all pairs of shortest paths by adding a
    loop around either of the algorithms discussed so far in this chapter. For example,
    we could fill in the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    matrix using a single <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop and the Bellman-Ford algorithm:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在本章讨论的任何一个算法周围添加一个循环来解决寻找所有节点对最短路径的问题。例如，我们可以使用一个单一的<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环和Bellman-Ford算法来填充<samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp>矩阵：
- en: '[PRE2]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Since the cost of the Bellman-Ford algorithm scales as |*E*| |*V* |, the total
    cost of this approach scales as |*E*| |*V* |². Similarly, we could wrap Dijkstra’s
    algorithm (as implemented in this chapter) with a cost that scales as |*V* | (|*V*
    | + |*E*|) log (|*V* |). This is the computational equivalent of calling a travel
    agent in each city and asking for the lowest-cost trips out of that city. Using
    the combined information of the shortest path from each starting node to all possible
    destinations, we can assemble the costs for traveling between any pair of cities.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Bellman-Ford算法的成本为|*E*| |*V*|，这种方法的总成本为|*E*| |*V*|²。类似地，我们可以用成本为|*V*|（|*V*|
    + |*E*|）log（|*V*|）来包装Dijkstra算法（如本章所实现）。这相当于在每个城市调用旅行社，询问从该城市出发的最低成本的旅行。通过结合从每个起点到所有可能目的地的最短路径信息，我们可以汇总两个城市之间旅行的成本。
- en: 'The following section introduces an alternate algorithm for finding all least-cost
    paths: Floyd-Warshall. This algorithm scales well to dense graphs where |*E*|
    is much greater than |*V* |. Instead of iterating over unvisited nodes or all
    edges, the Floyd-Warshall algorithm considers each node that could be on the intermediate
    path and decides whether to use it.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分介绍了一种替代的最短路径算法：Floyd-Warshall。该算法对密集图表现良好，特别是当|*E*|远大于|*V*|时。Floyd-Warshall算法并非遍历未访问的节点或所有边，而是考虑可能作为中间路径节点的每个节点，并决定是否使用该节点。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Floyd-Warshall Algorithm</samp>
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">Floyd-Warshall算法</samp>
- en: The *Floyd-Warshall algorithm* solves the all-pairs shortest-path problem by
    iteratively considering and optimizing the nodes between each origin and destination.
    An *intermediate path* consists of those nodes after the origin and before the
    destination. This algorithm effectively builds up better paths by considering
    nodes for inclusion in the intermediate path. An outer <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop iterates over each node *u* and asks, “Would any path be better if we included
    a stop at node *u*?” For each intermediate node *u*, the algorithm tests every
    path under consideration to see if it helps. If so, it adds it.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*Floyd-Warshall算法*通过迭代地考虑和优化每个起点和终点之间的节点来解决所有点对最短路径问题。*中间路径*由起点之后、终点之前的节点组成。该算法通过考虑将节点包含在中间路径中来有效地构建更好的路径。外部的`for`循环迭代每个节点*u*，并询问：“如果我们在节点*u*处停一下，是否会有更好的路径？”对于每个中间节点*u*，算法会测试每条待考虑的路径，看看它是否有帮助。如果有，它就将其加入。'
- en: Throughout the process, we maintain matrix versions of the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp> arrays we used in
    both Dijkstra’s and Bellman-Ford. Each row of these matrices corresponds to the
    arrays for a single starting node, and each entry indicates the value (cost or
    previous node on the path) for a specific destination node. We initialize both
    matrices to represent best paths *without* any intermediate nodes. The initial
    value of <samp class="SANS_TheSansMonoCd_W5Regular_11">cost[u][v]</samp> is the
    edge weight of (*u*, *v*) if the edge exists, 0 if *u* = *v*, and infinite otherwise.
    Similarly, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">last[u][v]</samp>
    is *u* if the edge (*u*, *v*) exists and *u* ≠ *v*. Otherwise, the value is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-1</samp> to indicate the lack of a path.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个过程中，我们维护了之前在Dijkstra和Bellman-Ford算法中使用的`last`和`cost`数组的矩阵版本。这些矩阵的每一行对应一个起始节点的数组，每个条目表示某个目标节点的值（路径的成本或前一个节点）。我们初始化这两个矩阵以表示*没有*任何中间节点的最佳路径。`cost[u][v]`的初始值是如果边（*u*，*v*）存在则为边的权重，如果*u*
    = *v*则为0，否则为无穷大。类似地，`last[u][v]`的值是如果边（*u*，*v*）存在且*u* ≠ *v*，则为*u*，否则值为`-1`，表示没有路径。
- en: '[Figure 7-10](#fig7-10) shows an example of the Floyd-Warshall algorithm’s
    state. The graph on the left is for reference, while the two matrices show the
    current estimated costs and best paths. This initial state is the computational
    equivalent of the travel agent planning for a customer who will take only direct
    flights. A pair of cities (*u*, *v*) is considered only if there is a direct flight
    from *u* to *v*. All other cities might as well have infinite cost.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-10](#fig7-10)显示了Floyd-Warshall算法状态的示例。左侧的图是参考图，而两个矩阵则展示了当前估算的成本和最佳路径。这个初始状态是计算上等同于旅行社为客户规划只选择直飞航班的情况。只有当从*u*到*v*有直飞航班时，才会考虑城市对（*u*，*v*）。所有其他城市的成本可以看作是无限大。'
- en: '![a graph with four nodes to the left, a 4 × 4 cost matrix in the center, and
    a 4 × 4 last matrix to the right. Node 0 has an outgoing edge to node 1 with weight
    10 and an outgoing edge to node 2 with weight 1.](../images/f07010.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![一个图，左侧有四个节点，中央是一个4×4的成本矩阵，右侧是一个4×4的最后路径矩阵。节点0有一条权重为10指向节点1的边，还有一条权重为1指向节点2的边。](../images/f07010.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-10: The state of the
    data structures at the start of the Floyd-Warshall algorithm</samp>'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-10：Floyd-Warshall算法开始时数据结构的状态</samp>
- en: The Floyd-Warshall algorithm, using a computational technique called *dynamic
    programming*, effectively builds the best paths using intermediate nodes in {0,
    1, . . . , *k*} from paths that can contain only intermediate nodes in {0, 1,
    . . . , *k* – 1}. Since negative loops are not allowed, each node can be used
    at most once in the path. For each origin-destination pair (*u*, *v*), the algorithm
    checks whether there is a better path through node *k* that uses only intermediate
    nodes {0, 1, . . . , *k*}. We can program this by reusing the <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> matrices from the
    previous iteration (*k* – 1). If there is a better path through *k*, the combined
    cost of the best paths from *u* to *k* and from *k* to *v* must be less than the
    cost of the current path from *u* to *v*. We can directly read these paths and
    costs from the last iteration’s <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> matrices.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 弗洛伊德-沃尔夏尔算法利用一种称为*动态规划*的计算技术，有效地构建了使用{0, 1, ... , *k*}中间节点的最佳路径，这些路径只能包含{0,
    1, ... , *k* - 1}中间节点。由于不允许负循环，每个节点在路径中最多只能使用一次。对于每对起点-终点(*u*, *v*)，算法检查是否有通过节点*k*的更好路径，该路径仅使用中间节点{0,
    1, ... , *k*}。我们可以通过重新使用上一次迭代(*k* - 1)的<samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp>矩阵来进行编程。如果通过*k*有更好的路径，从*u*到*k*和从*k*到*v*的最佳路径的组合成本必须小于当前从*u*到*v*的路径成本。我们可以直接从上一次迭代的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>矩阵中读取这些路径和成本。
- en: To see how this works, consider the graph and algorithm state in [Figure 7-11](#fig7-11),
    which takes place after paths with potential intermediate nodes 0, 1, and 2 in
    the figure’s graph have been tested. The <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> matrices represent
    the best paths that can have intermediate nodes in {0, 1, 2}. The best path from
    node 0 to node 1 is still the direct step [0, 1] because we cannot use node 3
    yet.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看其运作原理，请考虑图中的图形和算法状态[图7-11](#fig7-11)，这发生在测试了图中可能的中间节点0、1和2之后。矩阵<samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp>表示可以有中间节点{0, 1, 2}的最佳路径。从节点0到节点1的最佳路径仍然是直接步骤[0,
    1]，因为我们还不能使用节点3。
- en: '![The top row of the cost matrix reads [0.0, 10.0, 1.0, 2.0] and the top row
    of the last matrix reads [–1, 0, 0, 2].](../images/f07011.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![成本矩阵的顶行为[0.0, 10.0, 1.0, 2.0]，最后矩阵的顶行为[–1, 0, 0, 2]。](../images/f07011.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-11: The state of the
    Floyd-Warshall algorithm’s data structures after testing nodes 0, 1, and 2</samp>'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图7-11：在测试节点0、1和2后弗洛伊德-沃尔夏尔算法数据结构的状态</samp>
- en: When we consider the paths that could use node 3 as an intermediate node, we
    find several better paths, as shown in [Figure 7-12](#fig7-12). Let’s again consider
    the path from node 0 to node 1\. When we ask whether there is a better path from
    node 0 to node 1 through node 3, we find that there is. The path through node
    3 has a cost of 3.0, since the cost of the path from 0 to 3 (through node 2) is
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2.0</samp> and the cost of the path
    from 3 to 1 is <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp>.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑可以使用节点3作为中间节点的路径时，我们发现了几条更好的路径，如[图7-12](#fig7-12)所示。让我们再次考虑从节点0到节点1的路径。当我们询问是否有通过节点3从节点0到节点1的更好路径时，我们发现确实有。通过节点3的路径成本为3.0，因为从0到3的路径成本（通过节点2）为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">2.0</samp>，从3到1的路径成本为<samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp>。
- en: '![The top row of the cost matrix reads [0.0, 3.0, 1.0, 2.0] and the top row
    of the last matrix reads [-1, 3, 0, 2].](../images/f07012.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![成本矩阵的顶行为[0.0, 3.0, 1.0, 2.0]，最后矩阵的顶行为[-1, 3, 0, 2]。](../images/f07012.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-12: The state of the
    Floyd-Warshall algorithm’s data structures after testing nodes 0, 1, 2, and 3</samp>'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图7-12：在测试节点0、1、2和3后弗洛伊德-沃尔夏尔算法数据结构的状态</samp>
- en: By adding node 3 as an intermediate node along the path from node 0 to node
    1, we also add node 2\. The best path is now [0, 2, 3, 1]. This illustrates the
    power of Floyd-Warshall’s iterative approach. We are not just considering the
    intermediate node in isolation but also the best paths to and from that node.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将节点 3 作为中间节点添加到从节点 0 到节点 1 的路径中，我们还添加了节点 2。最佳路径现在是 [0, 2, 3, 1]。这说明了 Floyd-Warshall
    迭代方法的强大之处。我们不仅仅是孤立地考虑中间节点，而是考虑到到达和离开该节点的最佳路径。
- en: Since the algorithm tests for an improved path between each pair of nodes for
    every possible intermediate node, it requires a triply nested <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop over the nodes. The cost of the algorithm therefore scales as |*V* |³. While
    this might seem expensive, the relative running time of the previous approaches
    depends on the relative number of edges and nodes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该算法在每对节点之间测试每个可能的中间节点的改进路径，因此需要对节点进行三重嵌套的 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环。因此，算法的成本按 |*V* |³ 的比例增长。虽然这看起来可能很昂贵，但先前方法的相对运行时间取决于边和节点的相对数量。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">代码</samp>
- en: 'The core of the Floyd-Warshall algorithm is a triply nested set of <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops that iterate first over each intermediate node to add (*k*) and then through
    each pair of nodes (*i*, *j*) that need a path, as shown in the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Floyd-Warshall 算法的核心是三重嵌套的 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环，首先遍历每个中间节点（*k*），然后遍历每一对需要路径的节点（*i*, *j*），如下代码所示：
- en: '[PRE3]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The code starts by setting up the initial <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> matrices. A pair
    of nested <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops is used
    to iterate over each entry ❶. Best costs are set to 0.0 for the diagonals (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">i</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp>), the edge weights for
    nodes linked by edges, and infinity otherwise. The code uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>
    class’s <samp class="SANS_TheSansMonoCd_W5Regular_11">get_edge()</samp> function
    to check for and retrieve an edge, requiring an additional import of <samp class="SANS_TheSansMonoCd_W5Regular_11">Union</samp>
    from Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">typing</samp> library.
    Similarly, the previous nodes are set to the origin for any pair linked by an
    edge and <samp class="SANS_TheSansMonoCd_W5Regular_11">–1</samp> otherwise (including
    the diagonals) ❷.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 代码通过设置初始的 <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp> 矩阵开始。使用一对嵌套的 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环来遍历每个条目 ❶。对角线上的最佳成本被设置为 0.0 (<samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp>)，通过边连接的节点的边权重被设置为边权值，否则设置为无穷大。代码使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> 类的 <samp class="SANS_TheSansMonoCd_W5Regular_11">get_edge()</samp>
    函数来检查并检索边，这需要额外导入 Python 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">typing</samp>
    库中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Union</samp>。类似地，任何通过边相连的节点对的前置节点被设置为源节点，其他节点（包括对角线）设置为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">–1</samp> ❷。
- en: The code performs the majority of the processing via the triply nested <samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops. The outer loop iterates
    over the intermediate node <samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp>
    under consideration. The two inner loops iterate through each pair of nodes <samp
    class="SANS_TheSansMonoCd_W5Regular_11">i</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp>.
    For each pair, the code checks whether it can achieve a better path through node
    <samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp> ❸. If so, it updates both
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    arrays to reflect this. Unlike previous algorithms in the book, the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    array’s entry is updated to match the last step on the *path* from <samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> ❹.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 代码通过三重嵌套的<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环执行大部分处理。外部循环迭代当前考虑的中间节点<samp
    class="SANS_TheSansMonoCd_W5Regular_11">k</samp>。两个内循环遍历每对节点<samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">j</samp>。对于每一对，代码检查是否可以通过节点<samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp>获得更好的路径❸。如果可以，它将更新<samp
    class="SANS_TheSansMonoCd_W5Regular_11">成本</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">最后</samp>数组以反映这一点。与书中之前的算法不同，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">最后</samp>数组的条目会被更新，以匹配从<samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp>到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">j</samp>的*路径*上的最后一步❹。
- en: When the code finishes checking all intermediate nodes for all possible pairs
    of origin and destination, it returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    matrix of paths.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码检查完所有可能的起点和终点对的所有中间节点后，它返回路径的<samp class="SANS_TheSansMonoCd_W5Regular_11">最后</samp>矩阵。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">一个示例</samp>
- en: '[Figure 7-13](#fig7-13) shows an example of the Floyd-Warshall algorithm operating
    on a graph with five nodes. Each of the first five subfigures shows the state
    of the data structures *after* the iteration that adds the dashed node to the
    set of possible intermediate nodes. Shaded nodes have already been added. Thus,
    [Figure 7-13(a)](#fig7-13) shows the state before the first iteration and [Figure
    7-13(b)](#fig7-13) shows the state after the conclusion of the first iteration,
    when the node 0 has been considered as an intermediate node.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-13](#fig7-13)展示了Floyd-Warshall算法在一个包含五个节点的图上的应用示例。前五个子图展示了*在*将虚线节点加入可能的中间节点集合后的数据结构状态。阴影节点已经被加入。因此，[图
    7-13(a)](#fig7-13)展示了第一次迭代前的状态，而[图 7-13(b)](#fig7-13)展示了第一次迭代结束后的状态，当时节点0已被考虑为一个中间节点。'
- en: '![Each subfigure shows the graph, the cost matrix, and the last matrix.](../images/f07013.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![每个子图展示了图形、成本矩阵和最后的矩阵。](../images/f07013.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-13: Iterations of
    the Floyd-Warshall algorithm on a graph with five nodes</samp>'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-13：Floyd-Warshall 算法在一个包含五个节点的图上的迭代</samp>
- en: Consider this example in the context of our travel agent’s plan to conquer the
    global market. They create two spreadsheets, where the first (<samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>)
    maps the origin and destination pair to the total cost. The second (<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>)
    maps the same pair to the city on the itinerary immediately before the destination.
    At a loss for how to start, the agent fills in the direct flights as shown in
    [Figure 7-13(a)](#fig7-13). The <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>
    matrix contains the cost of the flight between any pair of cities (with <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp> for a “flight” to the same
    city) and infinity if there is no direct path. The <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    matrix shows the city from which the originating flight came, or <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>
    if there is no previous city. This is the starting state for the algorithm.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们旅行代理征服全球市场计划的背景下考虑这个例子。他们创建了两个电子表格，第一个（<samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>）将出发地和目的地的组合映射到总成本。第二个（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp>）将相同的组合映射到目的地之前的城市。由于不知道如何开始，代理填写了如[图7-13(a)](#fig7-13)所示的直飞航班。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>矩阵包含了任何一对城市之间的飞行成本（同一城市之间的飞行成本为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp>），如果没有直达路径则为无穷大。<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>矩阵显示出发航班来源的城市，或者如果没有前一个城市则为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>。这是算法的初始状态。
- en: Next, the travel agent considers Chicago (node 0) and asks, “What if I route
    them through that city? Of course, I’ll use the best possible path I’m currently
    aware of to get my customers from the origin to Chicago and from Chicago to their
    destination. I’m only talking about adding a single intermediate stop.” As shown
    in [Figure 7-13(b)](#fig7-13), this does not help any of the paths, and the travel
    agent does not change their matrices.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，旅行代理考虑了芝加哥（节点0），并问道：“如果我通过这个城市来规划路线会怎样？当然，我会使用目前知道的最佳路径，把我的顾客从出发地带到芝加哥，再从芝加哥带到目的地。我只是谈论在行程中增加一个中转站。”如[图7-13(b)](#fig7-13)所示，这并没有改善任何路径，旅行代理没有改变他们的矩阵。
- en: The agent then moves on to New York (node 1) and asks the same question. As
    shown in [Figure 7-13(c)](#fig7-13), the possibilities expand. By considering
    a layover in New York, travelers from Chicago (node 0) can now reach Portland,
    Maine (node 2). Similarly, travelers from Portland (node 2) and Charlotte (node
    4) can reach Chicago (node 0) and Pittsburgh (node 3).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代理继续考虑纽约（节点1）并提出同样的问题。如[图7-13(c)](#fig7-13)所示，可能性扩展了。通过考虑在纽约的中途停留，来自芝加哥（节点0）的旅客现在可以到达缅因州波特兰（节点2）。同样，来自波特兰（节点2）和夏洛特（节点4）的旅客可以到达芝加哥（节点0）和匹兹堡（节点3）。
- en: Buoyed by their success, the travel agent immediately considers layovers in
    Portland (node 2). This does not provide much help, as using Portland as an intermediate
    stop does not reduce the cost of any of the paths. The agent sighs, wonders if
    their success with New York was a fluke, and continues with their search.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功的鼓舞下，旅行代理立即考虑在波特兰（节点2）停留。然而，这并没有提供太大帮助，因为将波特兰作为中转站并没有降低任何路径的成本。代理叹了口气，怀疑他们在纽约的成功是否只是偶然，然后继续他们的搜索。
- en: Their persistence is rewarded after considering Pittsburgh (node 3), as shown
    by the matrices in [Figure 7-13(e)](#fig7-13). The agent discovers new paths to
    Charlotte (node 4) from Chicago (node 0), New York (node 1), and Portland (node
    2).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 他们的坚持在考虑匹兹堡（节点3）后得到了回报，正如[图7-13(e)](#fig7-13)中的矩阵所示。代理发现了从芝加哥（节点0）、纽约（节点1）和波特兰（节点2）到夏洛特（节点4）的新路径。
- en: So far, the agent has found only paths to new cities, however. None of the layovers
    has reduced the cost between cities that already had a path. Therefore, considering
    Charlotte (node 4) is an eye-opening experience, as it offers an improved layover
    for multiple trips. Before considering Charlotte as a stop, the trip from Chicago
    to Portland took the path [0, 1, 2] with a cost of <samp class="SANS_TheSansMonoCd_W5Regular_11">15</samp>.
    Now travelers can make the same trip using the path [0, 3, 4, 2] with a cost of
    only <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>. Even the trip from
    New York to Portland is cheaper via the path [1, 3, 4, 2] than it was with a direct
    flight.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，代理只找到通往新城市的路径。然而，所有的中途停留并没有减少那些已经有路径的城市之间的成本。因此，考虑到夏洛特（节点 4）是一次开眼界的经历，因为它为多次旅行提供了更好的中途停留。在考虑将夏洛特作为停靠点之前，从芝加哥到波特兰的旅行路径为[0,
    1, 2]，成本为<samp class="SANS_TheSansMonoCd_W5Regular_11">15</samp>。现在，旅行者可以通过路径[0,
    3, 4, 2]完成同样的旅行，成本仅为<samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>。即使是从纽约到波特兰的旅行，通过路径[1,
    3, 4, 2]也比直接航班便宜。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Computing Graph Diameter</samp>
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">计算图的直径</samp>
- en: The *diameter* of a graph is a measure that characterizes the maximum distance
    nodes in a graph. We define the diameter as the maximum distance between any two
    nodes in the graph
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图的*直径*是一个衡量图中节点之间最大距离的指标。我们将直径定义为图中任意两节点之间的最大距离。
- en: '*diameter* = argmaxu [∈] E, v [∈] E *dist*(*u*, *v*)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*直径* = argmaxu [∈] E, v [∈] E *dist*(*u*, *v*)'
- en: where, as noted earlier in the chapter, *dist*(*u*, *v*) is the cost of the
    shortest path between *u* and *v*. We can use the algorithms in this chapter to
    construct this measure that helps analyze or compare graphs.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，*dist*(*u*, *v*)是节点*u*和*v*之间最短路径的成本。我们可以使用本章中的算法来构建这一度量，帮助分析或比较图。
- en: For example, consider our labyrinth adventurer. After years of questing and
    victory over a hundred underground labyrinths and too many monsters, they decide
    to retire and start a labyrinth aid operation. They want to pick one labyrinth,
    spend their days there, and help other struggling adventurers (for a reasonable
    fee). Their key consideration is how quickly they can jump in and help their clients.
    After all, it’s no good if the monsters overwhelm the clients before the adventurer
    can provide aid (or the client can pay). This is complicated by the fact that
    both the rescuer and their clients could be at any node in the labyrinth when
    they run into trouble. If the adventurer has multiple simultaneous clients, they
    might even find themselves dashing between rooms.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑我们的迷宫冒险者。在经历了多年的冒险，战胜了百余个地下迷宫和无数怪物后，他们决定退休并开始运营迷宫援助工作。他们希望选择一个迷宫，花费自己的一生在那里，帮助其他陷入困境的冒险者（收取合理费用）。他们的关键考虑因素是他们能多快跳进迷宫并帮助客户。毕竟，如果怪物在冒险者能够提供帮助之前就已经压倒了客户（或者客户还没付费），那就没有意义了。这个问题的复杂性在于，救援者和他们的客户可能会在迷宫中的任何一个节点遇到麻烦。如果冒险者同时有多个客户，他们甚至可能发现自己在房间之间奔波。
- en: The adventurer decides to find a labyrinth with a diameter between 5 and 10
    rooms. Any larger and they will not be able to get to their client in time. Any
    smaller and there probably is not enough of a challenge for the other adventurers
    to need help. Satisfied with their reasoning, they compute the diameter of all
    the dungeons in their vicinity and pick one in the correct range.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 冒险者决定寻找一个直径在5到10个房间之间的迷宫。如果直径更大，他们将无法及时到达客户。如果直径更小，其他冒险者可能根本不需要帮助。满意于自己的推理后，他们计算了周围所有地下城的直径，并选择了一个在正确范围内的迷宫。
- en: 'We can extract the diameter of a graph directly from the <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>
    matrix in the Floyd-Warshall algorithm by iterating over entries and finding the
    maximum. Alternately, we can reconstruct it from the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    matrix by walking each of the paths backward and summing up the path cost. Here
    is code for the second approach in order to illustrate the use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    matrix:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接从Floyd-Warshall算法中的<samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>矩阵中提取图的直径，通过遍历条目并找到最大值。或者，我们可以通过从<samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp>矩阵中反向遍历每条路径并求和路径成本来重新构建直径。以下是第二种方法的代码，旨在演示如何使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp>矩阵：
- en: '[PRE4]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code uses the Floyd-Warshall algorithm to compute the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    matrix of paths ❶. It then iterates over all pairings of origin and destination
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp>)
    using a pair of nested <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops. For each such pairing, the code starts at the destination and walks backward
    through the last matrix until it hits the origin ❷. Along the way, it extracts
    each edge and adds its weight to the current sum. If the path dead-ends (that
    is, if <samp class="SANS_TheSansMonoCd_W5Regular_11">last[i][current]</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>
    when <samp class="SANS_TheSansMonoCd_W5Regular_11">current !=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>),
    the function will immediately return an infinite distance to indicate there is
    no path between a pair of nodes ❸. If all pairs have a valid path, the code tracks
    the costliest one seen ❹ and returns this maximum as the graph’s diameter.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用 Floyd-Warshall 算法计算路径的最后矩阵 ❶。然后，它通过一对嵌套的 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环遍历所有的起点和终点配对 (<samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">j</samp>)。对于每一对配对，代码从终点开始，向回走过最后的矩阵，直到到达起点
    ❷。在此过程中，它提取每条边并将其权重加到当前的总和中。如果路径到达死胡同（即，当 <samp class="SANS_TheSansMonoCd_W5Regular_11">last[i][current]</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>
    且 <samp class="SANS_TheSansMonoCd_W5Regular_11">current !=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    时），函数将立即返回一个无限大的距离，以表示这对节点之间没有路径 ❸。如果所有配对都有有效路径，代码将跟踪看到的最昂贵路径 ❹，并返回这个最大值作为图的直径。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp>
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">为什么这很重要</samp>
- en: Lowest-cost algorithms are directly applicable to a range of real-world problems,
    from path planning to optimization. The algorithms in this chapter provide practical
    methods for efficiently finding such paths. Both Dijkstra’s algorithm and the
    Bellman-Ford algorithm return solutions to all possible destinations in the graph.
    The Floyd-Warshall algorithm extends this even further and returns the shortest
    path between all possible origins and destinations.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最低成本算法直接应用于一系列现实世界的问题，从路径规划到优化。本章中的算法提供了高效找到此类路径的实用方法。Dijkstra 算法和 Bellman-Ford
    算法都返回图中所有可能目的地的解。Floyd-Warshall 算法进一步扩展这一点，返回所有可能起点和终点之间的最短路径。
- en: The three algorithms presented in this chapter also illustrated general techniques
    that can be adapted to solve other graph problems. Dijkstra’s algorithm maintains
    a priority queue of unvisited nodes that represent an unexplored frontier of possibilities.
    In [Chapter 10](chapter10.xhtml), we will see how another algorithm uses this
    same approach to solve a different optimization problem. The Bellman-Ford algorithm
    provides a glimpse into algorithms that operate over the set of edges. The Floyd-Warshall
    algorithm demonstrates a more complex dynamic programming approach. It constructs
    the best path with a subset of possible intermediate nodes from the simpler problem
    of best paths constructed from a smaller such subset.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍的三种算法还展示了可以适应解决其他图问题的一般技术。Dijkstra 算法维护一个未访问节点的优先队列，代表了一个未探索的可能性前沿。在 [第十章](chapter10.xhtml)
    中，我们将看到另一种算法如何使用相同的方法解决不同的优化问题。Bellman-Ford 算法提供了一些关于在边集上操作的算法的视角。Floyd-Warshall
    算法展示了一种更复杂的动态规划方法，它通过一个较小的子集从更简单的最佳路径问题中构建最优路径。
- en: The next chapter introduces algorithms that can incorporate additional heuristic
    information to limit the number of nodes they must visit when finding the lowest-cost
    path from a given origin to a given destination. While these algorithms do not
    produce shorter paths than the ones in this chapter, they run faster by focusing
    the search on the most promising nodes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章介绍了可以结合附加启发式信息来限制在寻找从给定起点到给定终点的最低成本路径时必须访问的节点数的算法。尽管这些算法所产生的路径不比本章中的路径更短，但它们通过将搜索集中在最有前景的节点上，运行得更快。
