- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp> <samp class="SANS_Dogma_OT_Bold_B_11">SHORTEST
    PATHS</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The problem of finding the lowest-cost path through a graph, as measured by
    the sum of edge weights along the path, is naturally analogous to a range of real-world
    path planning and optimization tasks. For example, we may be interested in routing
    trucks between two cities such that we minimize the total cost of fuel. In this
    chapter, we consider algorithms to find paths with the minimum cost starting at
    a given origin.
  prefs: []
  type: TYPE_NORMAL
- en: While the problem of finding these paths is often called the *shortest-path
    problem*, it is more accurate to think of it in terms of lowest-cost path, since
    a path’s cost is not always a function of distance. For example, this chapter
    will also consider versions of the problem that allow negative edge weights. We
    will use the terms *shortest path* and *lowest-cost path* interchangeably throughout
    the chapter; the formulations and implementations are the same.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covers three algorithms for finding shortest paths. We start with
    *Dijkstra’s algorithm*, which, like the search algorithms in the previous chapters,
    explores outward from a starting node. The *Bellman-Ford algorithm* iteratively
    refines the best paths by considering individual edges. Finally, the *Floyd-Warshall
    algorithm* allows us to find the shortest paths between all pairs of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Lowest-Cost Paths</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we can dive into algorithms to determine the lowest-cost paths through
    graphs, we must formalize what we mean by lowest-cost path. Recall from [Chapter
    3](chapter3.xhtml) that the total cost of a path is the sum of all edge weights
    along the path. For a path *p* = [*e*[0], *e*[1], . . . , *e*k], we define the
    cost as:'
  prefs: []
  type: TYPE_NORMAL
- en: '*PathCost*(*p*) = *∑*i [= 0 to] k *e*i.<samp class="SANS_TheSansMonoCd_W5Regular_11">weight</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'We take the *shortest path* to be a sequence of edges *p* = [*e*[0], *e*[1],
    . . . , *e*k] from a given origin node *u* to a given destination node *v* that
    minimizes the path cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '*ShortestPath*(*u*, *v*) = *MIN*p (*PathCost*(*p*)) such that *e*[0].<samp
    class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp> = *u* and *e*k.<samp
    class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp> = *v*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We then define the *distance* between two nodes as the cost of the shortest
    path between those nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '*dist*(*u*, *v*) = *PathCost*(*ShortestPath*(*u*, *v*))'
  prefs: []
  type: TYPE_NORMAL
- en: As a concrete example, consider paths from node 0 to node 5 through the six-node
    graph with directed edges in [Figure 7-1](#fig7-1). The weights are shown for
    each edge. Our goal is to find the sequence of edges from node 0 to node 5 that
    incurs the least cost.
  prefs: []
  type: TYPE_NORMAL
- en: '![Each edge is labeled with its weight. The weight of edge (0, 3) is 1.0, the
    weight of edge (3, 4) is 1.0, and the weight of the edge (4, 5) is 2.0.](../images/f07001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-1: A weighted, directed
    graph with six nodes</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 7-1](#tab7-1) lists the cost of a few possible paths from node 0 to
    node 5 in [Figure 7-1](#fig7-1), showing that we can define a variety of paths
    with differing costs. In this example, the shortest path is [0, 3, 4, 5] with
    *dist*(0, 5) = *PathCost* ([0, 3, 4, 5]) = 4.0\. The lowest cost between two nodes
    may not use the minimum number of edges but may instead take more lower-cost steps.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 7-1:</samp> <samp class="SANS_Futura_Std_Book_11">Path
    Costs from Node 0 to Node 5</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Path</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Cost</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0, 3, 4, 5</samp> | <samp class="SANS_Futura_Std_Book_11">4.0</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0, 4, 5</samp> | <samp class="SANS_Futura_Std_Book_11">4.5</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0, 1, 0, 3, 4, 5</samp> | <samp class="SANS_Futura_Std_Book_11">13.0</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0, 3, 4, 3, 4, 5</samp> | <samp class="SANS_Futura_Std_Book_11">8.0</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: As [Table 7-1](#tab7-1) demonstrates, paths can contain loops. If we restrict
    the problem to using only positive edge weights, loops will strictly increase
    the cost of a path. Shortest-path algorithms will thus avoid them. This is immediately
    apparent from real-world examples such as the adventurer exploring a labyrinth
    in [Chapter 4](chapter4.xhtml). Looping around the same rooms in a labyrinth not
    only requires extra walking but also repeatedly incurs the cost of facing any
    respawned monsters.
  prefs: []
  type: TYPE_NORMAL
- en: However, this problem becomes more complex (and less intuitive to visualize)
    if we allow negative edge weights. For this reason, the algorithms in this chapter
    place constraints on the use of negative weights, requiring that paths include
    no loops with a negative cost.
  prefs: []
  type: TYPE_NORMAL
- en: A graph may have multiple lowest-cost paths between two nodes. The algorithms
    in this chapter produce one of the lowest-cost paths.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Dijkstra’s Algorithm</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Dijkstra’s algorithm*, invented by the computer scientist Edsger W. Dijkstra,
    finds the lowest-cost path from a given starting node to all other nodes in the
    graph. It can work on either unweighted graphs or weighted graphs, with the constraint
    that none of the edge weights are negative. This constraint mirrors real-world
    path-planning problems in that we cannot decrease the total path length (cost)
    by adding another step. The clearest example of this is planning a road trip to
    minimize the total distance traveled. Since it is impossible to have negative
    distance, we can never shorten the trip by adding another step to the current
    path.'
  prefs: []
  type: TYPE_NORMAL
- en: Dijkstra’s algorithm operates by maintaining a set of unvisited nodes and continually
    updating each one’s current estimated cost. It continually reduces the number
    of unvisited nodes by choosing the closest (lowest-cost) unvisited node and visiting
    it. It then explores this node and checks whether it provides a better path to
    each of its unvisited neighbors. In more detail, the algorithm computes the cost
    of the new proposed path by taking the cost to the current node and adding the
    cost to the neighbor. If this new cost is less than the best cost seen so far,
    the algorithm updates the cost.
  prefs: []
  type: TYPE_NORMAL
- en: Because the algorithm always chooses the closest (least-cost) node to explore
    next, we can be sure we’re taking the shortest possible path every time we visit
    each node. This arises from the fact we do not allow negative edge weights, so
    the addition of steps always increases the cost of the path.
  prefs: []
  type: TYPE_NORMAL
- en: To visualize this, consider the state of the algorithm before visiting node
    *v*. We might worry that there is a better path to *v* through some unvisited
    node. After all, we haven’t seen all the paths in the graph. We might not have
    even visited all of *v*’s neighbors. However, any such path would have to travel
    through an unvisited node *w*. Since *v* is selected first, the cost of the path
    from the origin *u* to *w* is at least as large as the cost from *u* to *v*, and
    that gets us only part of the way to *v*. The subsequent path from *w* to *v*
    would only further increase the cost.
  prefs: []
  type: TYPE_NORMAL
- en: For our adventurer mapping out a labyrinth from [Chapter 4](chapter4.xhtml),
    Dijkstra’s algorithm mirrors their clearing the maze room by room. The adventurer,
    a former cartography student, keeps meticulous notes on the shortest path found
    to each room they visit, since their retirement plan is to build dungeon guides
    they can sell to future adventurers. As the adventurer plans their next move,
    they consider which unvisited rooms they could reach, then try to determine the
    best path to each room from the dungeon entrance (the origin node). The path lengths
    are the cost of getting to an adjacent room, then transitioning to the unexplored
    room.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The code for Dijkstra’s algorithm uses a priority queue to manage the set of
    unvisited nodes, as shown in the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This code relies on a custom implementation of the priority queue described
    in [Appendix B](appendix_B.xhtml) that allows for the dynamic updating of priorities.
    Interested readers can find the details in that appendix. For now, it is sufficient
    to view <samp class="SANS_TheSansMonoCd_W5Regular_11">PriorityQueue</samp> as
    a data structure that allows the efficient insertion of prioritized elements,
    removal of the element with the minimum priority, lookup of elements, and updates
    to elements’ priority.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code starts by creating several helper data structures, including the following:
    a list of best costs so far to each node (<samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>),
    a list indicating the last node visited before a given node (<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>),
    and a min-heap priority queue of unvisited nodes (<samp class="SANS_TheSansMonoCd_W5Regular_11">pq</samp>).
    The code places the starting index (<samp class="SANS_TheSansMonoCd_W5Regular_11">start_index</samp>)
    into the priority queue with a priority of <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp>
    and all other nodes into the priority queue with an infinite priority ❶. The cost
    to the starting node is marked as <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: The code then processes the nodes in the priority queue one by one, iterating
    through them with a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop until the priority queue is empty. During each iteration, the code extracts
    the minimum-cost node from the priority queue and explores it ❷.
  prefs: []
  type: TYPE_NORMAL
- en: The code uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop
    to consider each of the current node’s neighbors, checking whether the neighbor
    is still in the priority queue with the <samp class="SANS_TheSansMonoCd_W5Regular_11">in_queue()</samp>
    function ❸. If the node is in the queue, the code has not yet visited it. The
    code then checks whether it has found a better path to that neighbor through the
    current node ❹. This check corresponds to comparing the best-cost path to the
    neighbor found so far (<samp class="SANS_TheSansMonoCd_W5Regular_11">cost[neighbor]</samp>)
    with the cost of the best path going through the current node (<samp class="SANS_TheSansMonoCd_W5Regular_11">cost[index]</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">edge
    .weight</samp>). Since the code initially sets all non-starting nodes to an infinite
    cost, they will at least be updated the first time they are seen. If the code
    has found a better path to the neighbor, it updates the neighbor node’s priority
    in the queue, its previous node in <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>,
    and the best cost ❺.
  prefs: []
  type: TYPE_NORMAL
- en: The code continues exploring unvisited nodes (those still in the priority queue)
    until all nodes have been visited. As noted previously, once the code visits a
    node, it has found the shortest path and does not need to reconsider any visited
    nodes. When the code has visited all nodes, it returns the list of previous nodes
    on the path.
  prefs: []
  type: TYPE_NORMAL
- en: Given the *heap-based* implementation of Dijkstra’s algorithm presented here,
    we can imagine how the algorithm scales to larger graph sizes. The algorithm visits
    each node exactly once by inserting all the nodes into a priority queue and then
    removing them one by one. Using a heap-based priority queue, each operation scales
    as log (|*V* |), so the entire time for iterating over these nodes scales as |*V*
    | log (|*V* |). During the visit to each node, we check whether each neighbor
    is in the priority queue and potentially update the priority. Since we are using
    the custom <samp class="SANS_TheSansMonoCd_W5Regular_11">PriorityQueue</samp>
    described in [Appendix B](appendix_B.xhtml), the lookup uses a dictionary and
    takes constant time on average. The update scales as log (|*V* |). Since we visit
    each node only once and consider its outgoing edges once, we will perform at most
    one update per edge, giving a cost that scales as |*E*| log (|*V* |). Thus, the
    total cost of the algorithm scales as |*V* | log (|*V* |) + |*E*| log (|*V* |)
    = (|*V* | + |*E*|) log (|*V* |).
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-2](#fig7-2) illustrates Dijkstra’s algorithm operating on a five-node
    graph. Each subfigure represents the state of the algorithm after finishing a
    step. The dashed circle indicates the node that was just processed, while shaded
    nodes are those that have been visited. The priority queue (<samp class="SANS_TheSansMonoCd_W5Regular_11">pq</samp>)
    is shown in sorted order to make it easy to see the relative priorities, although
    it is stored in heap order.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Each subfigure shows the graph, the array last, the array cost, and a sorted
    version of the priority queue.](../images/f07002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-2: The steps of Dijkstra’s
    algorithm</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-2(a)](#fig7-2) represents the state of the algorithm before the first
    node is explored. The adventurer is standing at the entrance, ready to begin their
    quest. All nodes have <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    entries of <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>, indicating
    we do not know the path to get to them. Node 0 has a cost of <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>,
    since our search begins there, and all other nodes have an infinite estimated
    cost because we do not yet know *any* possible path. Unlike the algorithms for
    depth-first search and breadth-first search, we start with all nodes in the priority
    queue.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At each step, the algorithm explores the best node remaining in the queue.
    In [Figure 7-2(b)](#fig7-2), it selects node 0 (the only node without an infinite
    cost) and visits it. It finds edges to three neighbors: nodes 1, 2, and 3\. The
    search compares the cost of a path through node 0 to the current costs. Since
    the new cost is less than infinity for all three nodes, it updates their entries
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">pq</samp>. This update in the
    priority queue reorders the list of nodes to explore next.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-2(c)](#fig7-2) shows what happens when the search visits node 2\.
    This node has a single neighbor (node 3) with an estimated cost of <samp class="SANS_TheSansMonoCd_W5Regular_11">2.0</samp>.
    However, the path to node 3 through node 2 now provides a better option with a
    total cost of 0.5 + 1.0 = 1.5\. The algorithm updates the <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>
    entry of node 3 to <samp class="SANS_TheSansMonoCd_W5Regular_11">1.5</samp> and
    its <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> entry to <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: Through the lens of our adventurer, room 2 provides a better path to room 3\.
    Maybe there is a particularly powerful monster guarding the passage from room
    0 to room 3\. The adventurer, cognizant of the needs of future generations of
    explorers, takes this into account and redirects the suggested path to room 3
    to go through room 2.
  prefs: []
  type: TYPE_NORMAL
- en: The search continues through the remaining nodes. When the algorithm visits
    node 3 in [Figure 7-2(d)](#fig7-2), it finds a better path to node 1\. Similarly,
    visiting node 1 in [Figure 7-2(e)](#fig7-2) provides a better path to node 4\.
    The search completes in [Figure 7-2(f)](#fig7-2) after visiting the final node.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Disconnected Graphs</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Asking what happens if some nodes are not reachable from the starting node can
    help us understand how Dijkstra’s algorithm performs on a disconnected graph.
    Consider the four-node graph in [Figure 7-3](#fig7-3), where only nodes 0 and
    1 are reachable when starting from node 0.
  prefs: []
  type: TYPE_NORMAL
- en: '![The graph has three edges: from node 0 to node 1, from node 2 to node 3,
    and from node 3 to node 2.](../images/f07003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-3: A graph with unreachable
    nodes</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This corresponds to unreachable rooms in the labyrinth. From legend, the adventurer
    knows the labyrinth has four rooms, but they can reach only two. There is no path
    from room 0 to room 2 or room 3, so the adventurer has no choice but to indicate
    this in their notes.
  prefs: []
  type: TYPE_NORMAL
- en: Dijkstra’s algorithm can easily handle this case. Both nodes 2 and 3 are initially
    assigned a <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> value of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp> and an infinite cost.
    Because there is no path from node 0 to either of these nodes, when either is
    extracted from the priority queue, it still has an infinite cost. When the algorithm
    considers the node’s neighbors, the estimated cost through that node will be infinite,
    so the algorithm never updates either <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>. At the end of the
    algorithm, both nodes 2 and 3 will have last pointers of <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Negative Edge Weights</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In real-world problems, edge weights can be negative, representing a negative
    cost (a benefit). Consider the example of communications within a social network,
    where each connection between friends is an edge. The weight of each edge represents
    the cost of passing a rumor from one person to the next. This cost might be the
    loss of the time required to send a text or to chat. However, in some cases, the
    edge weight can be negative and represent a benefit to using that channel of communication.
    If two friends have not spoken in a while, the cost of reengaging to pass along
    some gossip may very well be negative.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we can envision path planning to minimize the battery usage of
    an electric vehicle. If an edge represents a steep downhill road, we can use the
    combination of gravity and regenerative braking to charge the battery. The cost
    in terms of battery usage for this segment is negative.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in the context of negative edge weights, the term *shortest path*
    does not really make sense, as distances cannot be negative. No matter how skilled
    you are at path planning, you cannot organize a cycling trip that gets you home
    before you set out. However, we continue to refer to these problems as *shortest
    path* for consistency with the wider literature.
  prefs: []
  type: TYPE_NORMAL
- en: 'When considering the shortest path through a graph with negative edges, we
    still need to maintain one constraint: the graph cannot contain negative cycles.
    A *negative cycle* occurs whenever there is a path from a node back to itself
    where the sum of edge weights is negative. In the presence of such cycles, the
    entire concept of lowest-cost path breaks down. For example, consider the graph
    in [Figure 7-4](#fig7-4), where edge (0, 1) has a weight of <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp>
    and edge (1, 0) has a weight of <samp class="SANS_TheSansMonoCd_W5Regular_11">-2.0</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph with three nodes and three edges. The edge (1, 2) has a weight of
    1.0.](../images/f07004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-4: A graph with a
    negative cycle</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If we try to find the lowest-cost path from node 0 to node 2 in [Figure 7-4](#fig7-4),
    we immediately run into problems. As shown in [Table 7-2](#tab7-2), we can keep
    adding another loop from node 0 to node 1 to node 0 to further reduce the cost.
    The lowest-cost path would loop back and forth forever.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 7-2:</samp> <samp class="SANS_Futura_Std_Book_11">The
    Cost of Paths in [Figure 7-4](#fig7-4)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Path</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Cost</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0, 1, 2</samp> | <samp class="SANS_Futura_Std_Book_11">2</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0, 1, 0, 1, 2</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0, 1, 0, 1, 0, 1, 2</samp> | <samp
    class="SANS_Futura_Std_Book_11">0</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0, 1, 0, 1, 0, 1, 0, 1, 2</samp> |
    <samp class="SANS_Futura_Std_Book_11">–1</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">. . .</samp> | <samp class="SANS_Futura_Std_Book_11">. . .</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: In contrast, [Figure 7-5](#fig7-5) shows a graph with a negative edge weight
    but no negative cycles. It is possible to travel from node 1 to node 0 with a
    negative cost. However, any path from node 0 back to itself or node 1 back to
    itself will have a total positive cost.
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph with four nodes and five edges. The edge (0, 1) has a weight of 3.5\.
    the edge (1, 0) has a weight –0.5.](../images/f07005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-5: A graph with a
    negative edge weight but no negative cycles</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: How can we tell whether a graph has negative cycles? A negative cycle could
    be incredibly long, looping through every node of the graph and thus not be immediately
    obvious. The Bellman-Ford algorithm solves this problem for us by checking for
    the existence of negative cycles in a graph.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Bellman-Ford Algorithm</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A major drawback of Dijkstra’s algorithm is that it is limited to graphs with
    positive edge weights. The Bellman-Ford algorithm removes this limitation, but
    it must add computational cost to do so.
  prefs: []
  type: TYPE_NORMAL
- en: The *Bellman-Ford algorithm* operates by repeatedly iterating over the list
    of edges and using them to update the best cost to each node (a process called
    *relaxation*). Like Dijkstra’s algorithm, it maintains a list <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>
    that stores the best cost seen so far from the origin to each node. Each time
    Bellman-Ford considers an edge, it asks if this edge presents a better path to
    the edge’s destination node by comparing that node’s current cost estimate (entry
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>) to the one provided
    by traveling from the edge’s origin (using the origin’s entry in <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>
    plus the edge weight). It repeats this test over and over, improving the estimates
    of the best paths.
  prefs: []
  type: TYPE_NORMAL
- en: We can visualize the algorithm as an extremely thorough travel agent considering
    flight options for the coming travel season. The agent starts with an origin like
    Chicago and looks for the cheapest path to each possible destination around the
    world. Obviously, the agent cannot take every flight themselves (that is, cannot
    travel the entire graph). However, they can easily scan through the list of flights
    and their prices to update their spreadsheet of estimates.
  prefs: []
  type: TYPE_NORMAL
- en: After a single scan through the flight list, the agent knows the best direct
    flights from Chicago to every other city. They scan through the list again, asking
    if they can build better paths to each possible destination using what they know
    about the best trips so far. They repeatedly scan the list, updating their estimates,
    until they have the best path to every destination.
  prefs: []
  type: TYPE_NORMAL
- en: Like the travel agent, with each iteration of Bellman-Ford’s outer loop, we
    are effectively building better paths. This progressive construction of paths
    is shown in [Figure 7-6](#fig7-6). The bold lines represent the best-known path
    from node 2 to node 0 after each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph with four nodes and five edges. In subfigure A, the edge (0, 3) with
    weight 10.0 is bolded. In subfigure B, the edges (0, 2) with weight 5.0 and (2,
    3) with weight 1.0 are bolded. In subfigure C, the edges (0,1), (1, 2), and (2,
    3), all with weight 1.0, are bolded.](../images/f07006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-6: The Bellman-Ford
    algorithm finding progressively better paths from node 2 to node 0</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-6(a)](#fig7-6) shows the best path from node 2 to node 0 after one
    iteration through each edge. Since the algorithm has looked at each edge only
    once, it sees a direct path only from node 2 to node 0 with cost <samp class="SANS_TheSansMonoCd_W5Regular_11">10.0</samp>.
    It did not have a chance to realize it could build a better path using the edges
    (2, 1) and (1, 0). During the second iteration, the algorithm uses the knowledge
    of a path with cost <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp> from
    node 2 to node 1 to build a path to node 0\. The best path to node 0 is updated
    to go through node 1 and costs <samp class="SANS_TheSansMonoCd_W5Regular_11">2.0</samp>,
    as shown in [Figure 7-6(b)](#fig7-6).'
  prefs: []
  type: TYPE_NORMAL
- en: We can cap the total number of iterations at |*V* | – 1, where |*V* | is the
    number of nodes in the graph. Because negative cycles are not allowed, a least-cost
    path can never return to the same node, as doing so would strictly increase the
    cost of the path. This is the reason real-world travel itineraries between different
    cities do not include cycles—that is, multiple layovers at the same airport.
  prefs: []
  type: TYPE_NORMAL
- en: Since the least-cost path can never repeat nodes, it can touch at most all |*V*
    | nodes and use |*V* | – 1 edges. For the six-node graph in [Figure 7-7](#fig7-7),
    for example, the lowest-cost path from node 0 to node 1 is [0, 3, 4, 5, 2, 1].
    Although there are alternate paths with fewer steps, the lowest-cost path from
    node 0 to node 1 uses five edges and visits all the nodes in the graph.
  prefs: []
  type: TYPE_NORMAL
- en: '![The graph has an edge from node 0 to node 1 with weight 10.0\. The edges
    (0, 3), (3, 4), (4, 5), (5, 2), and (2, 1) all have weight 1.0.](../images/f07007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-7: An example graph
    with a five-step path from node 0 to node 1</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Bellman-Ford uses this constraint to both stop the algorithm and test for cycles.
    After |*V* | – 1 iterations of the outer loop, it has found all possible lowest-cost
    paths. Because this algorithm uses two nested <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops (one over the number of nodes and the other over each edge), its cost scales
    as the product |*E*| |*V* |.
  prefs: []
  type: TYPE_NORMAL
- en: Additional iterations through the edges will not help unless there is a negative
    cycle. Armed with this knowledge, the algorithm tries one additional iteration
    and tests whether any costs decrease. If so, it knows the graph has a negative
    cycle.
  prefs: []
  type: TYPE_NORMAL
- en: We can picture this last test as our travel agent performing one last check
    over their list of least-cost flights. They notice that adding another leg between
    Pittsburgh and Boston further lowers the price. Confused, they look back over
    the flight data and see that a trip from Chicago to Boston to Pittsburgh to Boston
    to Seattle is the cheapest option so far. The loop from Boston to Pittsburgh and
    back provides a negative cycle. Obviously, something has gone wrong with the flight
    pricing, creating a loop that effectively costs negative dollars. The travel agent
    hurries to call their client about a potential free 10-stop trip before the airline
    fixes the problem.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Bellman-Ford iterates over each edge |*V* | – 1 times. Every iteration,
    it asks the following simple question: “Does the current edge provide a better
    path to its destination node?” The code uses a pair of <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops to drive this search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">BellmanFord()</samp> function
    takes a <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> and starting
    index and returns either the best path to each destination (using a <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    array) or <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> if the graph
    has a negative loop. We need to import <samp class="SANS_TheSansMonoCd_W5Regular_11">Union</samp>
    from Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">typing</samp> library
    to allow type hints for the multiple return values.
  prefs: []
  type: TYPE_NORMAL
- en: This code starts by creating the tracking data structures, including the best
    costs so far (<samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>) and the
    previous node on the current path (<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>).
    It also extracts a full list of edges for the algorithm using the <samp class="SANS_TheSansMonoCd_W5Regular_11">make_edge_list()</samp>
    function, which iterates through each node and assembles a list of every edge
    in the graph. Finally, it sets the cost of the starting node to 0.0.
  prefs: []
  type: TYPE_NORMAL
- en: A pair of nested <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops
    drives |*V* | – 1 iterations over the list of edges. For each edge, the code assesses
    the cost to the destination using that edge ❶. If this cost is less than the current
    best cost ❷, the code updates both the best-cost estimate and the path to the
    node. Note that the reduced cost may not result from changing the previous node
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>); rather, the cost
    to the previous node could have decreased due to a better path to that previous
    node.
  prefs: []
  type: TYPE_NORMAL
- en: When the code has completed |*V* | – 1 iterations of the outer loop, it has
    finished the optimization. Before concluding, it checks whether the solution is
    valid. If any cost could still be improved by taking another step ❸, the graph
    must have a negative cost cycle, in which case the algorithm returns <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>.
    Otherwise, it returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    list.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 7-8](#fig7-8) shows the first iteration of the outer loop of the Bellman-Ford
    algorithm. Since the algorithm takes (|*V* | – 1) |*E*| steps, where |*E*| is
    the number of edges, it is not feasible to show all 36 steps. Instead, we consider
    the first iteration of the outer loop to review how the paths (represented by
    <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>) and estimated costs
    change. Each subfigure represents the state of the algorithm after examining the
    bolded edge.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Each subfigure shows a graph with five nodes, the array last, and the array
    cost.](../images/f07008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-8: The starting state
    and nine steps performed during the first iteration of Bellman-Ford’s outer loop</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-8(a)](#fig7-8) shows the state of the algorithm before it examines
    any edges. All the nodes have an estimated infinite cost except the starting node.
    In [Figure 7-8(b)](#fig7-8), the algorithm tests the first edge and sees that
    it provides a better path to its destination, node 1\. It updates the path to
    node 1 to be the path from node 0 and the best cost to be <samp class="SANS_TheSansMonoCd_W5Regular_11">3.5</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: The search continues through each of the graph’s edges, considering the cost
    to a single node—the current edge’s destination—with each iteration. In [Figure
    7-8(c)](#fig7-8), it finds a better path to node 2; in [Figure 7-8(d)](#fig7-8),
    it finds a better path to node 3\. It doesn’t update anything in [Figure 7-8(e)](#fig7-8)
    because the best cost from node 0 to node 0 is <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp>,
    and we don’t need an unnecessary loop through node 1 to get back to the starting
    point.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the first iteration of the outer loop, shown as [Figure 7-8(j)](#fig7-8),
    the search has examined each edge and made updates to the best paths and cost
    estimations. However, the algorithm is not complete. The true best path to node
    4 is [0, 2, 3, 1, 4] and has a cost of <samp class="SANS_TheSansMonoCd_W5Regular_11">3.0</samp>.
    It will not find this final cost until it reconsiders the edge (1, 4). When it
    considered this edge in the first round, it had yet to find the best path to node
    1, so its cost estimate is too large.
  prefs: []
  type: TYPE_NORMAL
- en: As the algorithm continues, it revisits edges and continually updates the best
    path and its cost. [Figure 7-9](#fig7-9) shows the final step of the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '![The edge (4, 1) with weight 1.0 is bolded. The last array reads [-1, 3, 0,
    2, 1] and the cost array reads [0.0, 2.5, 0.5, 1.5, 3.0].](../images/f07009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-9: The final state
    of the Bellman- Ford algorithm</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: After examining the edge (4, 1) for the fourth time, the algorithm has completed
    both loops. The costs and paths have converged to their true values.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">All-Pairs Shortest Paths</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both our explorer and travel agent examples were satisfied with an algorithm
    that finds the lowest-cost path from a given start node to all other nodes in
    the graph. However, what if we want to find the shortest path between *any* pair
    of nodes in the graph? Even within the context of our previous two analogies,
    we can see the appeal of such an approach. Once the adventurer has mapped out
    the entire magical labyrinth, they may want to move back and forth between arbitrary
    rooms to help other adventurers who are in trouble. Likewise, our travel agent
    may want to go global, planning trips from any starting location to any destination
    in the world. In both cases, we need to find the least-cost path between two arbitrary
    nodes.
  prefs: []
  type: TYPE_NORMAL
- en: The *all-pairs shortest-path problem* aims to find the shortest path between
    every pair of nodes in a graph. Phrased another way, we now want to build a *matrix*
    <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> such that each row <samp
    class="SANS_TheSansMonoCd_W5Regular_11">last[i]</samp> contains the previous-node
    list for paths starting from node *i*. In this formulation, the entry of the matrix
    <samp class="SANS_TheSansMonoCd_W5Regular_11">last[i][j]</samp> is the node immediately
    before *j* on the path from *i* to node *j*. As with our previous <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    array formulation in the various search algorithms and other shortest-path algorithms,
    for a fixed starting point, we can trace the previous nodes backward from our
    destination to the origin.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can solve the problem of finding all pairs of shortest paths by adding a
    loop around either of the algorithms discussed so far in this chapter. For example,
    we could fill in the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    matrix using a single <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop and the Bellman-Ford algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Since the cost of the Bellman-Ford algorithm scales as |*E*| |*V* |, the total
    cost of this approach scales as |*E*| |*V* |². Similarly, we could wrap Dijkstra’s
    algorithm (as implemented in this chapter) with a cost that scales as |*V* | (|*V*
    | + |*E*|) log (|*V* |). This is the computational equivalent of calling a travel
    agent in each city and asking for the lowest-cost trips out of that city. Using
    the combined information of the shortest path from each starting node to all possible
    destinations, we can assemble the costs for traveling between any pair of cities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following section introduces an alternate algorithm for finding all least-cost
    paths: Floyd-Warshall. This algorithm scales well to dense graphs where |*E*|
    is much greater than |*V* |. Instead of iterating over unvisited nodes or all
    edges, the Floyd-Warshall algorithm considers each node that could be on the intermediate
    path and decides whether to use it.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Floyd-Warshall Algorithm</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Floyd-Warshall algorithm* solves the all-pairs shortest-path problem by
    iteratively considering and optimizing the nodes between each origin and destination.
    An *intermediate path* consists of those nodes after the origin and before the
    destination. This algorithm effectively builds up better paths by considering
    nodes for inclusion in the intermediate path. An outer <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop iterates over each node *u* and asks, “Would any path be better if we included
    a stop at node *u*?” For each intermediate node *u*, the algorithm tests every
    path under consideration to see if it helps. If so, it adds it.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the process, we maintain matrix versions of the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp> arrays we used in
    both Dijkstra’s and Bellman-Ford. Each row of these matrices corresponds to the
    arrays for a single starting node, and each entry indicates the value (cost or
    previous node on the path) for a specific destination node. We initialize both
    matrices to represent best paths *without* any intermediate nodes. The initial
    value of <samp class="SANS_TheSansMonoCd_W5Regular_11">cost[u][v]</samp> is the
    edge weight of (*u*, *v*) if the edge exists, 0 if *u* = *v*, and infinite otherwise.
    Similarly, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">last[u][v]</samp>
    is *u* if the edge (*u*, *v*) exists and *u* ≠ *v*. Otherwise, the value is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-1</samp> to indicate the lack of a path.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-10](#fig7-10) shows an example of the Floyd-Warshall algorithm’s
    state. The graph on the left is for reference, while the two matrices show the
    current estimated costs and best paths. This initial state is the computational
    equivalent of the travel agent planning for a customer who will take only direct
    flights. A pair of cities (*u*, *v*) is considered only if there is a direct flight
    from *u* to *v*. All other cities might as well have infinite cost.'
  prefs: []
  type: TYPE_NORMAL
- en: '![a graph with four nodes to the left, a 4 × 4 cost matrix in the center, and
    a 4 × 4 last matrix to the right. Node 0 has an outgoing edge to node 1 with weight
    10 and an outgoing edge to node 2 with weight 1.](../images/f07010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-10: The state of the
    data structures at the start of the Floyd-Warshall algorithm</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The Floyd-Warshall algorithm, using a computational technique called *dynamic
    programming*, effectively builds the best paths using intermediate nodes in {0,
    1, . . . , *k*} from paths that can contain only intermediate nodes in {0, 1,
    . . . , *k* – 1}. Since negative loops are not allowed, each node can be used
    at most once in the path. For each origin-destination pair (*u*, *v*), the algorithm
    checks whether there is a better path through node *k* that uses only intermediate
    nodes {0, 1, . . . , *k*}. We can program this by reusing the <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> matrices from the
    previous iteration (*k* – 1). If there is a better path through *k*, the combined
    cost of the best paths from *u* to *k* and from *k* to *v* must be less than the
    cost of the current path from *u* to *v*. We can directly read these paths and
    costs from the last iteration’s <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> matrices.
  prefs: []
  type: TYPE_NORMAL
- en: To see how this works, consider the graph and algorithm state in [Figure 7-11](#fig7-11),
    which takes place after paths with potential intermediate nodes 0, 1, and 2 in
    the figure’s graph have been tested. The <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> matrices represent
    the best paths that can have intermediate nodes in {0, 1, 2}. The best path from
    node 0 to node 1 is still the direct step [0, 1] because we cannot use node 3
    yet.
  prefs: []
  type: TYPE_NORMAL
- en: '![The top row of the cost matrix reads [0.0, 10.0, 1.0, 2.0] and the top row
    of the last matrix reads [–1, 0, 0, 2].](../images/f07011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-11: The state of the
    Floyd-Warshall algorithm’s data structures after testing nodes 0, 1, and 2</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When we consider the paths that could use node 3 as an intermediate node, we
    find several better paths, as shown in [Figure 7-12](#fig7-12). Let’s again consider
    the path from node 0 to node 1\. When we ask whether there is a better path from
    node 0 to node 1 through node 3, we find that there is. The path through node
    3 has a cost of 3.0, since the cost of the path from 0 to 3 (through node 2) is
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2.0</samp> and the cost of the path
    from 3 to 1 is <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '![The top row of the cost matrix reads [0.0, 3.0, 1.0, 2.0] and the top row
    of the last matrix reads [-1, 3, 0, 2].](../images/f07012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-12: The state of the
    Floyd-Warshall algorithm’s data structures after testing nodes 0, 1, 2, and 3</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: By adding node 3 as an intermediate node along the path from node 0 to node
    1, we also add node 2\. The best path is now [0, 2, 3, 1]. This illustrates the
    power of Floyd-Warshall’s iterative approach. We are not just considering the
    intermediate node in isolation but also the best paths to and from that node.
  prefs: []
  type: TYPE_NORMAL
- en: Since the algorithm tests for an improved path between each pair of nodes for
    every possible intermediate node, it requires a triply nested <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop over the nodes. The cost of the algorithm therefore scales as |*V* |³. While
    this might seem expensive, the relative running time of the previous approaches
    depends on the relative number of edges and nodes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The core of the Floyd-Warshall algorithm is a triply nested set of <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops that iterate first over each intermediate node to add (*k*) and then through
    each pair of nodes (*i*, *j*) that need a path, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The code starts by setting up the initial <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> matrices. A pair
    of nested <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops is used
    to iterate over each entry ❶. Best costs are set to 0.0 for the diagonals (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">i</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp>), the edge weights for
    nodes linked by edges, and infinity otherwise. The code uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>
    class’s <samp class="SANS_TheSansMonoCd_W5Regular_11">get_edge()</samp> function
    to check for and retrieve an edge, requiring an additional import of <samp class="SANS_TheSansMonoCd_W5Regular_11">Union</samp>
    from Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">typing</samp> library.
    Similarly, the previous nodes are set to the origin for any pair linked by an
    edge and <samp class="SANS_TheSansMonoCd_W5Regular_11">–1</samp> otherwise (including
    the diagonals) ❷.
  prefs: []
  type: TYPE_NORMAL
- en: The code performs the majority of the processing via the triply nested <samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops. The outer loop iterates
    over the intermediate node <samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp>
    under consideration. The two inner loops iterate through each pair of nodes <samp
    class="SANS_TheSansMonoCd_W5Regular_11">i</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp>.
    For each pair, the code checks whether it can achieve a better path through node
    <samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp> ❸. If so, it updates both
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    arrays to reflect this. Unlike previous algorithms in the book, the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    array’s entry is updated to match the last step on the *path* from <samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> ❹.
  prefs: []
  type: TYPE_NORMAL
- en: When the code finishes checking all intermediate nodes for all possible pairs
    of origin and destination, it returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    matrix of paths.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 7-13](#fig7-13) shows an example of the Floyd-Warshall algorithm operating
    on a graph with five nodes. Each of the first five subfigures shows the state
    of the data structures *after* the iteration that adds the dashed node to the
    set of possible intermediate nodes. Shaded nodes have already been added. Thus,
    [Figure 7-13(a)](#fig7-13) shows the state before the first iteration and [Figure
    7-13(b)](#fig7-13) shows the state after the conclusion of the first iteration,
    when the node 0 has been considered as an intermediate node.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Each subfigure shows the graph, the cost matrix, and the last matrix.](../images/f07013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-13: Iterations of
    the Floyd-Warshall algorithm on a graph with five nodes</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Consider this example in the context of our travel agent’s plan to conquer the
    global market. They create two spreadsheets, where the first (<samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>)
    maps the origin and destination pair to the total cost. The second (<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>)
    maps the same pair to the city on the itinerary immediately before the destination.
    At a loss for how to start, the agent fills in the direct flights as shown in
    [Figure 7-13(a)](#fig7-13). The <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>
    matrix contains the cost of the flight between any pair of cities (with <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp> for a “flight” to the same
    city) and infinity if there is no direct path. The <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    matrix shows the city from which the originating flight came, or <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>
    if there is no previous city. This is the starting state for the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the travel agent considers Chicago (node 0) and asks, “What if I route
    them through that city? Of course, I’ll use the best possible path I’m currently
    aware of to get my customers from the origin to Chicago and from Chicago to their
    destination. I’m only talking about adding a single intermediate stop.” As shown
    in [Figure 7-13(b)](#fig7-13), this does not help any of the paths, and the travel
    agent does not change their matrices.
  prefs: []
  type: TYPE_NORMAL
- en: The agent then moves on to New York (node 1) and asks the same question. As
    shown in [Figure 7-13(c)](#fig7-13), the possibilities expand. By considering
    a layover in New York, travelers from Chicago (node 0) can now reach Portland,
    Maine (node 2). Similarly, travelers from Portland (node 2) and Charlotte (node
    4) can reach Chicago (node 0) and Pittsburgh (node 3).
  prefs: []
  type: TYPE_NORMAL
- en: Buoyed by their success, the travel agent immediately considers layovers in
    Portland (node 2). This does not provide much help, as using Portland as an intermediate
    stop does not reduce the cost of any of the paths. The agent sighs, wonders if
    their success with New York was a fluke, and continues with their search.
  prefs: []
  type: TYPE_NORMAL
- en: Their persistence is rewarded after considering Pittsburgh (node 3), as shown
    by the matrices in [Figure 7-13(e)](#fig7-13). The agent discovers new paths to
    Charlotte (node 4) from Chicago (node 0), New York (node 1), and Portland (node
    2).
  prefs: []
  type: TYPE_NORMAL
- en: So far, the agent has found only paths to new cities, however. None of the layovers
    has reduced the cost between cities that already had a path. Therefore, considering
    Charlotte (node 4) is an eye-opening experience, as it offers an improved layover
    for multiple trips. Before considering Charlotte as a stop, the trip from Chicago
    to Portland took the path [0, 1, 2] with a cost of <samp class="SANS_TheSansMonoCd_W5Regular_11">15</samp>.
    Now travelers can make the same trip using the path [0, 3, 4, 2] with a cost of
    only <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>. Even the trip from
    New York to Portland is cheaper via the path [1, 3, 4, 2] than it was with a direct
    flight.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Computing Graph Diameter</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *diameter* of a graph is a measure that characterizes the maximum distance
    nodes in a graph. We define the diameter as the maximum distance between any two
    nodes in the graph
  prefs: []
  type: TYPE_NORMAL
- en: '*diameter* = argmaxu [∈] E, v [∈] E *dist*(*u*, *v*)'
  prefs: []
  type: TYPE_NORMAL
- en: where, as noted earlier in the chapter, *dist*(*u*, *v*) is the cost of the
    shortest path between *u* and *v*. We can use the algorithms in this chapter to
    construct this measure that helps analyze or compare graphs.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider our labyrinth adventurer. After years of questing and
    victory over a hundred underground labyrinths and too many monsters, they decide
    to retire and start a labyrinth aid operation. They want to pick one labyrinth,
    spend their days there, and help other struggling adventurers (for a reasonable
    fee). Their key consideration is how quickly they can jump in and help their clients.
    After all, it’s no good if the monsters overwhelm the clients before the adventurer
    can provide aid (or the client can pay). This is complicated by the fact that
    both the rescuer and their clients could be at any node in the labyrinth when
    they run into trouble. If the adventurer has multiple simultaneous clients, they
    might even find themselves dashing between rooms.
  prefs: []
  type: TYPE_NORMAL
- en: The adventurer decides to find a labyrinth with a diameter between 5 and 10
    rooms. Any larger and they will not be able to get to their client in time. Any
    smaller and there probably is not enough of a challenge for the other adventurers
    to need help. Satisfied with their reasoning, they compute the diameter of all
    the dungeons in their vicinity and pick one in the correct range.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can extract the diameter of a graph directly from the <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>
    matrix in the Floyd-Warshall algorithm by iterating over entries and finding the
    maximum. Alternately, we can reconstruct it from the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    matrix by walking each of the paths backward and summing up the path cost. Here
    is code for the second approach in order to illustrate the use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This code uses the Floyd-Warshall algorithm to compute the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    matrix of paths ❶. It then iterates over all pairings of origin and destination
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp>)
    using a pair of nested <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops. For each such pairing, the code starts at the destination and walks backward
    through the last matrix until it hits the origin ❷. Along the way, it extracts
    each edge and adds its weight to the current sum. If the path dead-ends (that
    is, if <samp class="SANS_TheSansMonoCd_W5Regular_11">last[i][current]</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>
    when <samp class="SANS_TheSansMonoCd_W5Regular_11">current !=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>),
    the function will immediately return an infinite distance to indicate there is
    no path between a pair of nodes ❸. If all pairs have a valid path, the code tracks
    the costliest one seen ❹ and returns this maximum as the graph’s diameter.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lowest-cost algorithms are directly applicable to a range of real-world problems,
    from path planning to optimization. The algorithms in this chapter provide practical
    methods for efficiently finding such paths. Both Dijkstra’s algorithm and the
    Bellman-Ford algorithm return solutions to all possible destinations in the graph.
    The Floyd-Warshall algorithm extends this even further and returns the shortest
    path between all possible origins and destinations.
  prefs: []
  type: TYPE_NORMAL
- en: The three algorithms presented in this chapter also illustrated general techniques
    that can be adapted to solve other graph problems. Dijkstra’s algorithm maintains
    a priority queue of unvisited nodes that represent an unexplored frontier of possibilities.
    In [Chapter 10](chapter10.xhtml), we will see how another algorithm uses this
    same approach to solve a different optimization problem. The Bellman-Ford algorithm
    provides a glimpse into algorithms that operate over the set of edges. The Floyd-Warshall
    algorithm demonstrates a more complex dynamic programming approach. It constructs
    the best path with a subset of possible intermediate nodes from the simpler problem
    of best paths constructed from a smaller such subset.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter introduces algorithms that can incorporate additional heuristic
    information to limit the number of nodes they must visit when finding the lowest-cost
    path from a given origin to a given destination. While these algorithms do not
    produce shorter paths than the ones in this chapter, they run faster by focusing
    the search on the most promising nodes.
  prefs: []
  type: TYPE_NORMAL
