<html><head></head><body>
<h2 class="h2" id="ch21"><span epub:type="pagebreak" id="page_171"/>—21—<br/>The Binary Search Tree Property</h2>&#13;
<p class="noindent">Wait,” Frank said. “That’s wrong.”</p>&#13;
<p class="indent">Socks, who had just finished inserting a node, looked up in surprise. “What?”</p>&#13;
<p class="indent">“The node you just inserted,” said Frank. “It’s in the wrong place.”</p>&#13;
<p class="indent">Socks peered at the tree. “But 63 is larger than 60, so it goes in the right-hand subtree.”</p>&#13;
<div class="image"><img src="../images/f0172-01.jpg" alt="image"/></div>&#13;
<p class="indent">“But it’s greater than its great-grandparent 61, so it should have gone to that node’s right subtree. You have it down the left subtree. One of the key properties of a binary search tree is that <em>all</em> nodes in the left subtree are less than the current node, and <em>all</em> nodes in the right subtree are larger.”</p>&#13;
<p class="indent">“I know that,” said Socks quietly.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_172"/>“Then why is it in the left subtree?” Frank asked.</p>&#13;
<p class="indent">“I made a mistake,” said Socks.</p>&#13;
<p class="indent">“How did you miss that 63 is larger than 61?” Frank asked.</p>&#13;
<p class="indent">“I . . . I started at 60,” Socks admitted.</p>&#13;
<p class="indent">“What?”</p>&#13;
<p class="indent">“Well, I had recently inserted node 60 . . . and 63 is close to 60 . . . so I just started at 60 and inserted it below that.”</p>&#13;
<p class="indent">“You didn’t start at the root?” Frank snapped.</p>&#13;
<p class="indent">“I figured this would be faster,” said Socks. “I got to skip down most of the tree.”</p>&#13;
<p class="indent">“You ended up putting it in the wrong place. How many other shortcuts have you taken?”</p>&#13;
<p class="indent">“A few,” admitted Socks.</p>&#13;
<p class="indent">Frank groaned, then, for good measure, muttered a long string of curses. Socks stared at the ground and wisely said nothing.</p>&#13;
<p class="indent">After he had finally calmed down, Frank took a few deep breaths and surveyed the tree.</p>&#13;
<p class="indent">“We’ll have to do an exhaustive search,” he said through gritted teeth. “If the tree doesn’t maintain the binary search tree property, we can’t safely do any pruning. We’ll have to check each node.”</p>&#13;
<p class="indent">“Hey,” said Socks suddenly. “We had to check each node to put it in the tree. Why didn’t we just do an exhaustive search then?”</p>&#13;
<p class="indent">“Amortized cost,” Frank said. “I was hoping to use the tree for a bunch of searches in the future. I doubt 50 days to 70 days will be the only range we search. As we get more evidence, we might do different range searches. Maybe we would even need to do a few exact searches. The cost of building the tree would be averaged out over many searches, and the overall effort would be lower—possibly much lower. Amortized cost considers the total cost for a bunch of searches and thus spreads the cost of building the tree over many searches.”</p>&#13;
<p class="indent">“Oh,” said Socks. “Like my magic button trees.”</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_173"/>Frank fought the urge to shake the young wizard and yell, “Of course like the button tree! They’re both binary search trees. They both benefit from a one-time construction cost by making many subsequent searches faster.” Instead, he settled for a snarky “Of course.”</p>&#13;
<p class="indent">“Great idea,” said Socks. “We can save lots of time in the future.”</p>&#13;
<p class="indent">“Could have saved,” Frank corrected him.</p>&#13;
<p class="indent">“Oh,” said Socks. “Right. I broke the tree, didn’t I?”</p>&#13;
<div class="sidebar">&#13;
<p class="sidebart"><strong>POLICE ALGORITHMS 101: BINARY SEARCH TREES</strong></p>&#13;
<p class="sbsub"><em><strong>Excerpt from Professor Drecker’s Lecture</strong></em></p>&#13;
<p class="noindent">As we have seen in this lecture, we can use information about the structure of a binary search tree to search efficiently. Not only that, but we can add and remove nodes from trees. However, whenever we change a data structure, it is vitally important to ensure that we’re not violating the properties that we use.</p>&#13;
<p class="indent">For binary search trees, it is important to maintain the <em>binary search tree property</em>. This property states that (1) the values of the data in the left node (and all its children) are less than or equal to the value of the current node and (2) the values of the data in the right node (and all its children) are greater than or equal to the value of the current node. If we violate this property, we no longer have a binary search tree, and we can’t prune branches of the tree during a search.<span epub:type="pagebreak" id="page_174"/></p>&#13;
</div>&#13;
</body></html>