## **1**

**INTRODUCING CSS3**

![Image](graphics/common-01.jpg)

In this first chapter, I’ll cover the code conventions used in this book and discuss some syntax that’s unique to CSS3, but before getting to that, let me explain a little about the history of CSS3\. Obviously, you don’t need to know its history to use CSS3, but I think having some context about the current state of CSS3 is important.

CSS3 is a specification in flux. Some parts of the spec are considered stable and have been well implemented in modern browsers; other parts should be considered experimental and have been partially implemented to varying degrees; yet others are still theoretical proposals and have not been implemented at all. Some browsers have created their own CSS properties that aren’t described in any CSS3 specification and perhaps never will be.

All of this means that knowing how the standardization process works and the levels of implementation for each new property is vital to understanding how you can use CSS3 in your code both now and in the future.

### **What CSS3 Is and How It Came to Be**

First, I want to discuss what CSS3 is—and isn’t—and the form it takes. The W3C’s approach to CSS3 is quite different from its approach to CSS2, so this overview should help you understand how and when you can use CSS3 and why it has such varied implementation across different browsers.

#### ***A Brief History of CSS3***

The last major version of CSS was CSS2.1, a revision of the CSS2 specification that was originally published in 1997\. Despite ongoing development and review since that time, many people are surprised to learn that CSS2 only became an “official” recommendation of the W3C in 2011\. (I talk more about the recommendation process shortly.) More surprising still is the fact that Internet Explorer 8 (IE8)—released in 2009—lays claim to being the first browser to support the entire CSS2.1 specification fully.

In the last few years, the talk has been about the new revision—CSS3\. I say “new,” but in fact work on CSS3 began back in 1998, the year after CSS2 was published. Browser implementation of CSS2 continued to be so frustratingly inconsistent, however, that the W3C decided to halt work on any new revision and work on CSS2.1 instead, standardizing the way CSS had been implemented in the real world. In 2005, all of the CSS3 modules were moved back to Working Draft status, and the editing and review process began again.

For many years, Internet Explorer dominated the ever-expanding market of Internet users and showed no sign of wanting to implement CSS3\. But over the last ten years or so, a whole new range of browsers has appeared to compete for users, and this plethora of choice has led to a features arms race. One beneficiary of that arms race has been CSS3\. Each of the browsers wants to offer developers and users the latest in web technologies, and with the CSS3 spec already mostly written, implementing and even adding new features has been a no-brainer.

So here we are today, with the CSS3 specification under active development, a broad range of browsers implementing it, and a community of interested developers building with it, studying it, and writing about it. A healthy situation, and one we couldn’t have foreseen just a few years ago.

#### ***CSS3 Is Modular***

Creating the default styling language for every markup-based document in the world is an enormous undertaking, and the W3C was aware that it would take many years to come to fruition. W3C members, conscious that they didn’t want to hold up some of the more obvious, in-demand features while they were considering and debating some of the more esoteric ones, made the decision to split CSS3 into various modules. Each of the modules could then be worked on by different authors at different paces, and the implementation and recommendation process—which I discuss shortly—could be staggered.

This is why, instead of a single, monolithic CSS3 specification document, you have CSS3 Basic User Interface Module, Selectors Level 3, Media Queries, and so on. Some of these modules are revisions of CSS2.1, and some are newly created, but all fall under the banner of CSS3.

One of the few things I find irritating (I’m an easy-going guy) is that on many blogs you’ll hear people complaining, “I want to use CSS3, but it won’t be ready for years.” This is nonsense; some CSS3 modules already have quite stable implementation in all modern browsers, and many more are just months away from prime time. If you want to wait until all of the modules are 100 percent implemented across every browser in existence, you’ll be waiting forever.

So CSS3 is here, and some of it is ready to use right now—you just have to be mindful about how you use it.

#### ***There Is No CSS3***

Okay, I realize that’s a pretty provocative statement, but it is technically true. As CSS has become modular, each module is designated a level number to mark how many revisions it has been through. Some of the more mature modules, such as Selectors, are already at Level 4; many of the modules featured in this book, such as Fonts, are at Level 3; whereas some very new modules, such as Flexbox, are only at Level 1 or possibly moving into Level 2.

What this means is that CSS is a living standard: As I mentioned earlier, there will be no more monolithic versions; each module will move at its own pace; and new modules will be added as new features are scoped. CSS3 is merely a convenient shorthand to mean “CSS features developed since CSS2.1.” CSS4 will never exist. Eventually the numbering will fall away, and we’ll just have CSS, with modules at different levels.

But let us not be deterred! I’ll continue to refer to CSS3 in this book in the sense that it’s defined above, as a convenient shorthand for new CSS features. This label eases understanding and means I don’t have to change the title of this book!

### **Module Status and the Recommendation Process**

As I move through this book and discuss each of the different modules, I’ll sometimes refer to that module’s status. Status is set by the W3C, and it indicates the module’s progress through the recommendation process; note, however, that status is *not* necessarily an indication of a module’s degree of implementation in any browser.

When a proposed document is first accepted as part of CSS3, its status is designated *Working Draft*. This status means the document has been published and is now ready for review by the community—in this case, the community being browser makers, working groups, and other interested parties. A document may stay as a Working Draft for a long period, undergoing many revisions. Not all documents make it past this status level, and a document may return to this status on many occasions.

Before a document can progress from a Working Draft, its status changes to *Last Call*, which means the review period is about to close and usually indicates the document is ready to progress to the next level.

That next level is *Candidate Recommendation*, which means the W3C is satisfied the document makes sense, the latest reviews have found no significant problems, and all technical requirements have been satisfied. At this point, browser makers may begin to implement the properties in the document to gather real-world feedback.

When two or more browsers have implemented the properties in the same way and if no serious technical issues have come to light, the document may progress to being a *Proposed Recommendation*. This status means the proposal is now mature and implemented and ready to be endorsed by the W3C Advisory Committee. When this endorsement has been granted, the proposal becomes a *Recommendation*.

To reiterate what I briefly touched on before, the recommendation process and the implementation process do not always work in the same way. A module can be well-implemented across all browsers, yet still hold Working Draft status—as I write this, the Transitions module ([Chapter 14](ch14.html#ch14)) has exactly that status. Conversely, a module may hold Candidate Recommendation status yet have only limited implementation—CSS Shapes ([Chapter 19](ch19.html#ch19)) fits this description right now.

As a result, I’ve written this book in a loose order of implementation, rather than based on recommendation status. Earlier chapters discuss features that have full implementation across all browsers (or should by the time this book is released); later chapters cover features that are implemented in some browsers only—often with browser-specific prefixes; and chapters toward the end of the book deal with potential, speculative, or partial implementations of properties.

### **Introducing the Syntax**

With the introductions and explanations out of the way, let’s get to the meat of CSS3\. Throughout this book, I use a certain syntactical convention to demonstrate each of the new rules and properties. It looks something like this:

```
*E* { property: *value*; }
```

In this code example, the selector is represented with *E*. Of course, in HTML, this selector doesn’t exist; I’m merely using it to indicate the selector is irrelevant; any selector could be used here.

Next, you have the property itself; in this case, I’ve used a made-up property, called `property`. Following this is the value of the property. For this, I use an italicized alias to refer to the value, which in this case I’ve called `*value*`.

If a property accepts multiple values, I’ll list each with a unique alias. So a new property that requires three values might be defined like this:

```
*E* { property: *first second third*; }
```

With all that said, let’s pretend we have a new property called `monkeys` (I’ve always wanted a `monkeys` property), which accepts only a single value. Using this book’s syntax, I would introduce it like this:

```
*E* { monkeys: *value*; }
```

And when it came to providing a practical example of it, I might show it with a valid value—say, a number value—like this:

```
*E* { monkeys: 12; }
```

### **Vendor Prefixes**

When a module is still under active review, as much of CSS3 is, a lot is subject to change; a property’s syntax may be revised, or a property may be dropped entirely. On occasion, even the wording of the draft itself is perhaps a little nebulous and open to interpretation.

At the same time, browsers need to implement these features so we can see how they work in practice. But consider the difficulties that would occur if two separate browsers implemented the same property but interpreted it inconsistently: The result of your code would appear differently—perhaps radically so—in each of the browsers. To prevent this from happening, each of the browser vendors began to prefix a short code to the beginning of experimental properties. Let’s imagine our much-desired `monkeys` property has been newly defined in a specification, and that all of the major browser vendors have decided to implement it to see how it works. In this case, you would use the following code:

```
E {
    -moz-monkeys: value; /* Firefox */
    -ms-monkeys: value; /* Internet Explorer */
    -webkit-monkeys: value; /* Chrome/Safari */
}
```

The amount of repetition may seem somewhat unnecessary, but the repetition is for our own good; the last thing you want is for all the browsers to implement the `monkeys` property differently, leading to total chaos.

Although well-intentioned, the use of vendor prefixes has led to many problems—developers used them in their production websites but did not remove them later when the browser implementation had changed. This, in turn, meant that browser vendors have to continue to support experimental features forever to avoid breakages on websites that use them. Because of this, Chrome and Firefox are now backing away from using prefixed properties, preferring instead to implement new features that are disabled, by default, and must be opted into by developers until they are stable enough for widespread use. That said, plenty of prefixed properties are still out there, and I’ll note in the book when you must use them.

### **Let’s Get Started**

That should be everything you need to get started with this book—except, of course, an inquisitive nature. I have a lot of ground to cover in CSS3, so I’ll move fairly quickly, but each chapter should give you the knowledge you need to build your own tests, demonstrations, and sites that take advantage of the flexibility and rich features that CSS3 provides.

We’ll begin with a look at one of the simplest—and yet potentially the most disruptive (and I mean that in a good way)—new features: Media Queries.