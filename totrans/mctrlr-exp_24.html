<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2a" id="ch24"><span epub:type="pagebreak" id="page_227"/><strong>24  Clipper Chip Diffusion ROM</strong></h2>&#13;
<p class="noindent">In the Nineties, the Clinton administration had an obsession with key escrow cryptography. They wanted to provide American citizens with cryptography that the US government itself could break, but in a way that excluded foreign governments from the same privilege. This was called the Clipper chip in general, and in this chapter we’ll focus on the PCMCIA generation of that chip, known as the MYK82 or Fortezza card. We’ll dump its firmware and extract it into useful bits.</p>&#13;
<p class="indent">It worked roughly like this: suppose that Monica calls Bill for a private conversation. As she hits the <em>encrypt</em> button, the two telephones perform a key exchange. After the keys are exchanged, her phone will send Bill’s phone a bundle called the Law Enforcement Access Field (LEAF) containing (1) their session key encrypted with Monica’s personal key and (2) a checksum of the session key. The LEAF is encrypted with a “family key” that every Clipper device contains but which was not given to consumers. Every unit has the family key, but only spooky agencies with a warrant were able to look up Monica’s personal key and decrypt the session key.</p>&#13;
<p class="indent">Astute readers will notice that these keys are all symmetric and that the scheme does not hold up to an attacker with control of firmware. If you had the family key, things might work differently. Bill could call Monica, perform the key exchange, and then send along a tampered LEAF with (1) a random number and (2) the checksum of the real session key. Her phone would validate the checksum and allow the call to proceed, but any spooky agencies listening in would not be able to decrypt the random number into a session key. Monica’s phone does not have access to the key escrow database, so it’s unable to know that the authorities are being tricked.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_228"/><img id="ch24fig1" src="../images/f0228-01.jpg" alt="Image" width="777" height="778"/></div>&#13;
<p class="figcap">Figure 24.1: MYK82 Chip in a Fortezza PCMCIA Card</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_229"/><img id="ch24fig2" src="../images/f0229-01.jpg" alt="Image" width="777" height="785"/></div>&#13;
<p class="figcap">Figure 24.2: MYK82 Die</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_230"/>It’s also worth noting that Bill does not strictly need to know the family key. Without a tampered device, Bill might simply call Monica a few tens of thousands of times while corrupting the LEAF bundle, until the 16-bit checksum collides and her phone believes that the LEAF was not corrupted. Blaze (1994) describes such an attack, as well as a detailed explanation of the Escrowed Encryption Standard.</p>&#13;
<p class="indent">The MYK82 chip contained in the Fortezza card implements this protocol, with handy library functions for using the card in Windows and Solaris. <a href="ch24.xhtml#ch24fig1">Figure 24.1</a> shows this chip on the card in a QFP package. This package is a little weird in that the lead frame is <em>above</em> the die, and the die faces downward into the PCB. Perhaps this is to frustrate RF emissions, as the die sits between two ground planes.</p>&#13;
<p class="indent">The die is shown in its entirety in <a href="ch24.xhtml#ch24fig2">Figure 24.2</a>. The CPU can be seen in the southwest, including an ARM6 logo that tells us we can expect 32-bit ARM instructions without the shortened Thumb instruction set that came later in ARM7. There are three ROMs on this chip, with the largest holding code in the east. Two smaller ROMs hold the same Skipjack F-Table in the south of the chip, just a little east of center; these are exactly 256 bytes and match up to those in the Skipjack documentation, which has since been declassified.</p>&#13;
<p class="indent">The MYK82 chip, like its predecessor the MYK78, uses diffusion ROMs. These shape the diffusion layer beneath the transistors so that a working transistor will produce a one and a broken transistor will produce a zero.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_231"/>Because bits are not surface visible, a delayering procedure like that in <a href="ch22.xhtml#ch22">Chapter 22</a> is needed to remove the upper layers that cover the diffusion layer. My usual procedure for this chip is to first burn off the packaging with 63% nitric acid and then to delayer the chip in 5% hydrofluoric acid. Both of these run on a hot plate in my fume hood, but I do the HF reaction in a sealed plastic test tube to minimize the fumes.</p>&#13;
<p class="indent">Before delayering, bits can just barely be seen in aggregate at low magnification. This has something to do with optics and a little bit of exposure, as individual bits can hardly be seen at all. After delayering, bits dramatically jump out, visible at both high and low magnifications.</p>&#13;
<p class="indent"><a href="ch24.xhtml#ch24fig3">Figure 24.3</a> is the ROM as a whole, and because that’s still a bit hard to see in print, <a href="ch24.xhtml#ch24fig5">Figure 24.5</a> shows just the six most significant bits at the far right of the ROM. <a href="ch24.xhtml#ch24fig4">Figure 24.4</a> shows a close up of bits. To figure out the decoding, I took those two photos on a flight to Bogota with no local friends and no local responsibilities. By the time I left, I had decoded the ROM into 32-bit words and made a few friends.<sup><a id="ch24fn_1" href="footnotes.xhtml#ch24fn1">1</a></sup></p>&#13;
<p class="indent">Our first clue was the ARM6 logo elsewhere on the die. ARM6 predates Thumb, so all instructions are 32 bits wide and aligned to 32-bits. We can see that the bottom of the ROM is quite sparse, filled in with the same color in every bit. These happen to be zeroes, and they correctly imply that the code is built up from rows at the top of the ROM.</p>&#13;
<p class="indent">ARM reverse engineers will tell you that 32-bit code stands out because most instructions begin with an <span class="literal">E</span> as the most significant nybble. If you look at the right six bits in <a href="ch24.xhtml#ch24fig5">Figure 24.5</a>, you will see that the each major column holds two bits. (You might also figure that out from <a href="ch24.xhtml#ch24fig3">Figure 24.3</a>, where 16 major columns represent 32 bits.) The rightmost major column is mostly filled with ones, while the major column to its left has ones on the right half and zeroes on the left half. This is our <span class="literal">E</span> nybble, formed from the right as one, one, one, zero!</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_232"/><img id="ch24fig3" src="../images/f0232-01.jpg" alt="Image" width="1123" height="424"/></div>&#13;
<p class="figcap">Figure 24.3: MYK82 Code ROM</p>&#13;
<div class="image"><img id="ch24fig4" src="../images/f0232-02.jpg" alt="Image" width="1123" height="78"/></div>&#13;
<p class="figcap">Figure 24.4: MYK82 ROM Bits</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_233"/><img id="ch24fig5" src="../images/f0233-01.jpg" alt="Image" width="620" height="1125"/></div>&#13;
<p class="figcap">Figure 24.5: Right six bits of the MYK82 Code ROM</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_234"/>Sure enough, we can find 32-bit words by taking a bit from each of the 32 minor columns—that’s two from each major column—with the most significant bit on the far right and the least significant bit on the far left. We already know that the program begins on the first row because of the empty, zeroed rows at the end. All that is left is to understand the order of the words within a given row.</p>&#13;
<p class="indent">Each of the rows has 512 bits to it, so we know that they contain 16 words apiece. To learn the order, I simply wrote a decoder that output them in order and piped this into a disassembler. The correct ordering was from right to left, just as the bits are best read from right to left.</p>&#13;
<p class="indent">At this point, it’s clear how to decode the ROM into 32-bit words, but to get them into bytes, we would like to understand the endianness. Does the most significant byte come first or last? This is where things get weird.</p>&#13;
<p class="indent">Endianness is not a matter of byte order in words, but a matter of how words are seen as bytes or vice versa. The internal ROM is only composed of 32-bit words that are never fetched in smaller sizes, so it has no endianness. The ARM6 CPU has no instruction to fetch bytes from ROM, but there is a wiring decision of the external EEPROM memory. That EEPROM contains code as big-endian bytes, and it is only from that that we can say the machine as a whole is big-endian.</p>&#13;
</div>
</div>
</body></html>