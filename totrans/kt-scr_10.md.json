["```\nfun main() {\n    // Define an array to be sorted.\n    val arr = intArrayOf(8, 3, 4, 5, 1, 2)\n\n    println(\"\\n*** Sorting an Array Using Insertion Sort ***\\n\")\n    println(\"original array:\\n${arr.contentToString()}\")\n    // Call the insertion sort function.\n    insertionSort(arr)\n    println(\"sorted array:\\n${arr.contentToString()}\")\n}\n\nfun insertionSort(A: IntArray) {\n    // Sorting happens in place.\n  ❶ for (i in 1 until A.size) {\n        val key = A[i]\n        var j = i\n      ❷ while(j > 0 && A[j-1] > key) {\n            A[j] = A[j-1]\n            j -= 1\n        }\n      ❸ A[j] = key\n    }\n}\n```", "```\n*** Sorting an Array Using Insertion Sort ***\n\noriginal array:\n[8, 3, 4, 5, 1, 2]\nsorted array:\n[1, 2, 3, 4, 5, 8]\n```", "```\nfun main() {\n    val arr = intArrayOf(8, 3, 4, 5, 1, 2)\n\n    println(\"\\n*** Sorting an Array Using Merge Sort ***\\n\")\n    println(\"original array:\\n${arr.contentToString()}\")\n    // Call the recursive function.\n  ❶ mergeSort(arr)\n    println(\"\\nsorted array:\\n${arr.contentToString()}\")\n}\n\nfun mergeSort(arr: IntArray) {\n    val length = arr.size\n    if (length < 2) return // done splitting subarrays\n\n  ❷ val middle = length / 2\n    val leftArray = arr.copyOfRange(0, middle)\n    val rightArray = arr.copyOfRange(middle, length)\n\n  ❸ mergeSort(leftArray)\n    mergeSort(rightArray)\n    merge(leftArray, rightArray, arr)\n}\n\nfun merge(leftArray: IntArray, rightArray: IntArray,\n          arr: IntArray) {\n\n    val leftSize = leftArray.size\n    val rightSize = rightArray.size\n    var i = 0   // for original array\n    var l = 0   // for left array\n    var r = 0   // for right array\n\n    // Compare, sort, and merge.\n  ❹ while(l < leftSize && r < rightSize) {\n        if (leftArray[l] < rightArray[r]) {\n            arr[i] = leftArray[l]\n            l++\n        } else {\n            arr[i] = rightArray[r]\n            r++\n        }\n      ❺ i++\n    }\n\n    // If all elements of a subarray are assigned, assign the\n    // remaining elements of the nonempty array to \"arr\".\n    while (l < leftSize) {\n        arr[i] = leftArray[l]\n        l++\n        i++\n    }\n\n    while (r < rightSize) {\n        arr[i] = rightArray[r]\n        r++\n i++\n    }\n}\n```", "```\n*** Sorting an Array Using Merge Sort ***\n\noriginal array:\n[8, 3, 4, 5, 1, 2]\n\nsorted array:\n[1, 2, 3, 4, 5, 8]\n```", "```\nfun main() {\n    val arr = intArrayOf(8, 3, 4, 5, 1, 2)\n\n    println(\"\\n*** Sorting an Array Using Quick Sort ***\\n\")\n    println(\"original array:\\n${arr.contentToString()}\")\n    // Call the recursive function.\n  ❶ quickSort(arr, start = 0, end = arr.size -1)\n    println(\"\\nsorted array:\\n${arr.contentToString()}\")\n}\n\nfun quickSort(arr: IntArray, start: Int, end: Int) {\n    // Check that the termination condition for recursion\n    // base case is when start = end.\n  ❷ if (start < end) {\n val pivotIndex = partition(arr, start, end)\n        quickSort(arr = arr, start = start, end = pivotIndex - 1)\n        quickSort(arr = arr, start = pivotIndex + 1, end = end)\n    }\n}\n\nfun partition(arr: IntArray, start: Int, end: Int): Int {\n    val pivot = arr[end]\n    var i = start\n\n    for (j in start until end) {\n      ❸ if (arr[j] < pivot) {\n            swap(arr, i, j)\n            i++\n        }\n    }\n  ❹ swap(arr, i, end)\n    return i\n}\n\nfun swap(arr: IntArray, i: Int, j: Int) {\n    val temp = arr[i]\n    arr[i] = arr[j]\n    arr[j] = temp\n}\n```", "```\n*** Sorting an Array Using Quick Sort ***\n\noriginal array:\n[8, 3, 4, 5, 1, 2]\n\nsorted array:\n[1, 2, 3, 4, 5, 8]\n```", "```\nimport java.util.ArrayDeque\n\nfun main() {\n  ❶ val graph = mapOf(\n        \"0\" to setOf(\"1\", \"2\", \"3\"),\n        \"1\" to setOf(\"0\", \"2\"),\n        \"2\" to setOf(\"0\", \"1\", \"4\"),\n        \"3\" to setOf(\"0\"),\n        \"4\" to setOf(\"2\")\n    )\n    println(\"\\n*** Depth-First Search of a Graph ***\\n\")\n    println(\"Graph to search:\")\n    for ((key,value) in graph)\n        println(\"Node: $key,  Neighbors: $value\")\n\n  ❷ val visited = dfsStack(graph, \"0\")\n    println(\"\\nVisited nodes:\\n$visited\")\n}\n\nfun dfsStack(graph: Map<String, Set<String>>, start: String):\n             Set<String> {\n\n    val visited = mutableSetOf<String>()\n    val stack = ArrayDeque<String>()\n    stack.push(start)\n\n  ❸ while (stack.isNotEmpty()) {\n        val node = stack.pop()\n if (node !in visited) {\n            // Do something as needed.\n            visited.add(node)\n          ❹ for (next in graph[node]!!) {\n                 stack.push(next)\n            }\n        }\n    }\n    return visited\n}\n```", "```\n*** Depth-First Search of a Graph ***\n\nGraph to search:\nNode: 0,  Neighbors: [1, 2, 3]\nNode: 1,  Neighbors: [0, 2]\nNode: 2,  Neighbors: [0, 1, 4]\nNode: 3,  Neighbors: [0]\nNode: 4,  Neighbors: [2]\n\nVisited nodes:\n[0, 3, 2, 4, 1]\n```", "```\nimport java.util.ArrayDeque\n\nfun main() {\n    // Define the graph to be searched.\n    val graph = mapOf(\n        \"0\" to setOf(\"1\", \"2\", \"3\"),\n        \"1\" to setOf(\"0\", \"2\"),\n        \"2\" to setOf(\"0\", \"1\", \"4\"),\n        \"3\" to setOf(\"0\"),\n        \"4\" to setOf(\"2\")\n    )\n    println(\"\\n*** Breadth-First Search of a Graph ***\\n\")\n    println(\"Graph to search:\")\n    for ((key,value) in graph)\n        println(\"Node: $key,  Neighbors: $value\")\n\n  ❶ val visited = bfsQueue(graph, \"0\")\n    println(\"\\nVisited nodes:\\n$visited\")\n}\n\nfun bfsQueue(graph: Map<String, Set<String>>, start: String): Set<String> {\n    val visited = mutableSetOf<String>()\n visited.add(start)\n    val queue = ArrayDeque<String>()\n    queue.offer(start)\n\n  ❷ while (queue.isNotEmpty()) {\n        val node = queue.poll()\n        for (next in graph[node]!!) {\n          ❸ if (next !in visited) {\n                queue.offer(next)\n                visited.add(next)\n            }\n        }\n    }\n    return visited\n}\n```", "```\n*** Breadth-First Search of a Graph ***\n\nGraph to search:\nNode: 0,  Neighbors: [1, 2, 3]\nNode: 1,  Neighbors: [0, 2]\nNode: 2,  Neighbors: [0, 1, 4]\nNode: 3,  Neighbors: [0]\nNode: 4,  Neighbors: [2]\n\nVisited nodes:\n[0, 1, 2, 3, 4]\n```", "```\n// no import block\n\ndata class Node(\n    var gScore: Int,\n    var fScore: Int,\n    var previousNode: String\n)\n\nfun main() {\n    // Define the graph to be searched.\n  ❶ val graph = mapOf(\n \"A\" to mapOf(\"B\" to 4, \"C\" to 6, \"D\" to 5),\n        \"B\" to mapOf(\"A\" to 4, \"C\" to 2, \"E\" to 4, \"F\" to 4),\n        \"C\" to mapOf(\"A\" to 6, \"B\" to 2, \"D\" to 3, \"F\" to 3),\n        \"D\" to mapOf(\"A\" to 5, \"C\" to 3, \"G\" to 6, \"H\" to 4),\n        \"E\" to mapOf(\"B\" to 4, \"I\" to 6),\n        \"F\" to mapOf(\"B\" to 4, \"C\" to 3, \"G\" to 4, \"I\" to 5),\n        \"G\" to mapOf(\"D\" to 6, \"F\" to 4, \"I\" to 6, \"K\" to 3),\n        \"H\" to mapOf(\"D\" to 4, \"K\" to 3),\n        \"I\" to mapOf(\"E\" to 6, \"F\" to 5, \"G\" to 6, \"J\" to 6),\n        \"J\" to mapOf(\"I\" to 6, \"K\" to 5),\n        \"K\" to mapOf(\"G\" to 3, \"H\" to 3, \"J\" to 5, \"L\" to 3),\n        \"L\" to mapOf(\"K\" to 3, \"M\" to 5),\n        \"M\" to mapOf(\"L\" to 5)\n    )\n\n    println(\"### A* algorithm ###\")\n    println(\"\\nDisplay graph:\")\n    displayGraph(graph)\n\n    val startNode  = \"A\"\n    val targetNode = \"J\"    // Also, ensure its h-score is 0.\n  ❷ val visitedList = aStar(graph, startNode, targetNode)\n\n    println(\"\\n--- Final Visited List ---\")\n    displayList(visitedList)\n    displayShortestPath(visitedList, startNode, targetNode)\n}\n```", "```\nfun displayGraph(graph: Map<String, Map<String, Int>>) {\n    for ((node, neighbors) in graph) {\n        println(\"Node: $node\")\n        print(\"Neighbors: \")\n\n        for ((nNode, cost) in neighbors) {\n            print(\"$nNode:$cost \")\n        }\n        println()\n    }\n    println()\n}\n```", "```\nfun displayList(mapList: Map<String, Node>) {\n    println(\"   (g-score, f-score, previous)\")\n\n    for ((node, attributes) in mapList) {\n        println(\"$node: $attributes\")\n    }\n    println()\n}\n```", "```\nfun displayShortestPath(visited: Map<String, Node>,\n                        startNode: String, targetNode: String) {\n\n var currentNode = targetNode\n    var path = targetNode\n    println(\"path initialized from target: $path\")\n\n    while (currentNode != startNode) {\n      ❶ val previousNode = visited[currentNode]!!.previousNode\n        // previousNode is placed before \"path\" so no need to reorder.\n      ❷ path = previousNode + path\n        println(\"previousNode: $previousNode\")\n        println(\"path updated: $path\")\n        currentNode = previousNode\n    }\n\n    val cost = visited[targetNode]!!.gScore\n    println(\"\\nThe shortest path from $startNode to $targetNode is:\")\n    println(\"Path: $path\")\n    println(\"Cost: $cost\")\n}\n```", "```\nfun aStar(graph: Map<String, Map<String, Int>>,\n          startNode: String, targetNode: String):\n          Map<String, Node> {\n\n    // Define two mutable maps.\n    val visited = mutableMapOf<String, Node>()\n    val unvisited = mutableMapOf<String, Node>()\n\n    // Initialize all unvisited nodes.\n    for (node in graph.keys) {\n        // The list is made of g-score, f-score, and previous node.\n      ❶ unvisited[node] = Node(Int.MAX_VALUE, Int.MAX_VALUE, \"none\")\n    }\n\n // Update the start node attributes in the unvisited list.\n    val hScore = getHScore(startNode)\n\n    // for startNode: g-score = 0, f-score = 10, previous node = none\n  ❷ unvisited[startNode] = Node(0, hScore, \"none\")\n\n    println(\"--- Initialized state of unvisited list ---\")\n    displayList(unvisited)\n\n  ❸ while (unvisited.isNotEmpty()) {\n        // Set the node with minimum f-score to current node.\n      ❹ val currentNode = getCurrentNode(unvisited)\n\n      ❺ if (currentNode == targetNode) {\n            // Add the targetNode to visited.\n            visited[currentNode] = unvisited[currentNode]!!\n            println(\"--- Target node:$currentNode reached ---\")\n            break\n        }\n\n        val neighbors = graph[currentNode]!!\n\n        for (node in neighbors.keys) {\n          ❻ if (node !in visited) {\n                val newGScore =\n                    unvisited[currentNode]!!.gScore + neighbors[node]!!\n\n              ❼ if (newGScore < unvisited[node]!!.gScore) {\n                    unvisited[node] = Node(\n                        newGScore,\n                        newGScore + getHScore(node),\n                        currentNode)\n                }\n            }\n        }\n\n        // Add currentNode to visited.\n        visited[currentNode] = unvisited[currentNode]!!\n\n        // Remove currentNode from unvisited.\n        unvisited.remove(currentNode)\n    }\n    return visited\n}\n```", "```\nfun getHScore(node: String) = when (node) {\n    \"A\" -> 8   // start node\n    \"B\" -> 6\n    \"C\" -> 6\n    \"D\" -> 6\n    \"E\" -> 4\n    \"F\" -> 4\n    \"G\" -> 4\n    \"H\" -> 4\n    \"I\" -> 2\n    \"J\" -> 0   // target node\n    \"K\" -> 2\n    \"L\" -> 4\n    \"M\" -> 6\n    else -> 0\n}\n```", "```\nfun getCurrentNode(unvisited: Map<String, Node>) =\n    unvisited.minByOrNull {it.value.fScore}!!.key\n```", "```\n*** A-star algorithm ***\n\nDisplay graph:\nNode: A\nNeighbors: B:4 C:6 D:5\nNode: B\nNeighbors: A:4 C:2 E:4 F:4\nNode: C\n`--snip--`\nNode: L\nNeighbors: K:3 M:5\nNode: M\nNeighbors: L:5\n\n--- Initialized state of unvisited list ---\n   (g-score, f-score, previous)\nA: Node(gScore=0, fScore=8, previousNode=none)\nB: Node(gScore=2147483647, fScore=2147483647, previousNode=none)\nC: Node(gScore=2147483647, fScore=2147483647, previousNode=none)\n`--snip--`\nL: Node(gScore=2147483647, fScore=2147483647, previousNode=none)\nM: Node(gScore=2147483647, fScore=2147483647, previousNode=none)\n\n--- Target node:J reached ---\n\n--- Final Visited List ---\n   (g-score, f-score, previous)\nA: Node(gScore=0, fScore=8, previousNode=none)\nB: Node(gScore=4, fScore=10, previousNode=A)\nD: Node(gScore=5, fScore=11, previousNode=A)\nC: Node(gScore=6, fScore=12, previousNode=A)\nE: Node(gScore=8, fScore=12, previousNode=B)\nF: Node(gScore=8, fScore=12, previousNode=B)\nH: Node(gScore=9, fScore=13, previousNode=D)\nK: Node(gScore=12, fScore=14, previousNode=H)\nG: Node(gScore=11, fScore=15, previousNode=D)\nI: Node(gScore=13, fScore=15, previousNode=F)\nJ: Node(gScore=17, fScore=17, previousNode=K)\n\npath initialized from target: J\npreviousNode: K\npath updated: KJ\npreviousNode: H\npath updated: HKJ\npreviousNode: D\npath updated: DHKJ\npreviousNode: A\npath updated: ADHKJ\n\nThe shortest path from A to J is:\nPath: ADHKJ\nCost: 17\n```"]