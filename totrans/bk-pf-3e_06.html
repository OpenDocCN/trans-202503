<html><head></head><body><section class="chapter" epub:type="chapter" id="turning_the_tables_for_proactive_defense" title="Chapter&#xA0;6.&#xA0;Turning the Tables for Proactive Defense"><div class="titlepage"><div><div><h2 class="title">Chapter 6. Turning the Tables for Proactive Defense</h2></div></div></div><div class="mediaobject"><a id="med_id00011"/><img alt="Turning the Tables for Proactive Defense" src="httpatomoreillycomsourcenostarchimages2127149.png.jpg"/></div><p><a class="indexterm" id="iddle1691"/><a class="indexterm" id="iddle1818"/>In the previous chapter, you saw how you might need to spend considerable time and energy making sure that the services you want to offer will be available even when you have strict packet filtering in place. Now, with your working setup in place, you’ll soon notice that some services tend to attract a little more unwanted attention than others.</p><p>Here’s the scenario: You have a network with packet filtering to match your site’s needs, including some services that need to be accessible to users from elsewhere. Unfortunately, when services are available, there’s a risk that someone will want to exploit them for some sort of mischief.</p><p>You’ll almost certainly have remote login via SSH (Secure Shell), as well as SMTP email running on your network—both are tempting targets. In this chapter, we’ll look at ways to make it harder to gain unauthorized access via SSH, and then we’ll turn to some of the more effective ways to deny spammers use of your servers.</p><div class="sect1" title="Turning Away the Brutes"><div class="titlepage"><div><div><h2 class="title" id="turning_away_the_brutes" style="clear: both">Turning Away the Brutes</h2></div></div></div><p><a class="indexterm" id="iddle1102"/><a class="indexterm" id="iddle1103"/><a class="indexterm" id="iddle1105"/><a class="indexterm" id="iddle1702"/><a class="indexterm" id="iddle1703"/><a class="indexterm" id="iddle1705"/><a class="indexterm" id="iddle1885"/><a class="indexterm" id="iddle1886"/><a class="indexterm" id="iddle1888"/>The Secure Shell service, commonly referred to as SSH, is a fairly crucial service for Unix administrators. It’s frequently the main interface to the machine and a favorite target of script kiddie attacks.</p><div class="sect2" title="SSH Brute-Force Attacks"><div class="titlepage"><div><div><h3 class="title" id="ssh_brute-force_attacks">SSH Brute-Force Attacks</h3></div></div></div><p>If you run an SSH login service that’s accessible from the Internet, you’ve probably seen entries like this in your authentication logs:</p><a id="pro_id00215"/><pre class="programlisting">Sep 26 03:12:34 skapet sshd[25771]: Failed password for root from 200.72.41.31 port 40992 ssh2&#13;
Sep 26 03:12:34 skapet sshd[5279]: Failed password for root from 200.72.41.31 port 40992 ssh2&#13;
Sep 26 03:12:35 skapet sshd[5279]: Received disconnect from 200.72.41.31: 11: Bye Bye&#13;
Sep 26 03:12:44 skapet sshd[29635]: Invalid user admin from 200.72.41.31&#13;
Sep 26 03:12:44 skapet sshd[24703]: input_userauth_request: invalid user admin&#13;
Sep 26 03:12:44 skapet sshd[24703]: Failed password for invalid user admin from 200.72.41.31&#13;
port 41484 ssh2&#13;
Sep 26 03:12:44 skapet sshd[29635]: Failed password for invalid user admin from 200.72.41.31&#13;
port 41484 ssh2&#13;
Sep 26 03:12:45 skapet sshd[24703]: Connection closed by 200.72.41.31&#13;
Sep 26 03:13:10 skapet sshd[11459]: Failed password for root from 200.72.41.31 port 43344 ssh2&#13;
Sep 26 03:13:10 skapet sshd[7635]: Failed password for root from 200.72.41.31 port 43344 ssh2&#13;
Sep 26 03:13:10 skapet sshd[11459]: Received disconnect from 200.72.41.31: 11: Bye Bye&#13;
Sep 26 03:13:15 skapet sshd[31357]: Invalid user admin from 200.72.41.31&#13;
Sep 26 03:13:15 skapet sshd[10543]: input_userauth_request: invalid user admin&#13;
Sep 26 03:13:15 skapet sshd[10543]: Failed password for invalid user admin from 200.72.41.31&#13;
port 43811 ssh2&#13;
Sep 26 03:13:15 skapet sshd[31357]: Failed password for invalid user admin from 200.72.41.31&#13;
port 43811 ssh2&#13;
Sep 26 03:13:15 skapet sshd[10543]: Received disconnect from 200.72.41.31: 11: Bye Bye&#13;
Sep 26 03:13:25 skapet sshd[6526]: Connection closed by 200.72.41.31</pre><p>This is what a <span class="emphasis"><em>brute-force attack</em></span> looks like. Someone or something is trying by brute force to find a username and password combination that lets them get into your system.</p><p>The simplest response would be to write a <span class="emphasis"><em>pf.conf</em></span> rule that blocks all access, but that leads to another class of problems, including how to let people with legitimate business on your system access it. Setting up your <code class="literal">sshd</code> to accept only key-based authentication would help but most likely would not stop the kiddies from trying. You might consider moving the service to another port, but then again, the ones flooding you on port 22 would probably be able to scan their way to port 22222 for a repeat performance.<sup>[<a class="footnote" href="#ftn.ch06fn01" id="ch06fn01">30</a>]</sup></p><p>Since OpenBSD 3.7 (and equivalents), PF has offered a slightly more elegant solution.</p></div><div class="sect2" title="Setting Up an Adaptive Firewall"><div class="titlepage"><div><div><h3 class="title" id="setting_up_an_adaptive_firewall">Setting Up an Adaptive Firewall</h3></div></div></div><p><a class="indexterm" id="iddle1014"/><a class="indexterm" id="iddle1106"/><a class="indexterm" id="iddle1247"/><a class="indexterm" id="iddle1258"/><a class="indexterm" id="iddle1501"/><a class="indexterm" id="iddle1502"/><a class="indexterm" id="iddle1581"/><a class="indexterm" id="iddle1706"/><a class="indexterm" id="iddle1889"/><a class="indexterm" id="iddle1908"/><a class="indexterm" id="iddle1933"/>To thwart brute-force attacks, you can write your <code class="literal">pass</code> rules so they maintain certain limits on what connecting hosts can do. For good measure, you can banish violators to a table of addresses to which you deny some or all access. You can even choose to drop all existing connections from machines that overreach your limits. To enable this feature, first set up the table by adding the following line to your configuration before any filtering rules:</p><a id="pro_id00216"/><pre class="programlisting">table &lt;bruteforce&gt; persist</pre><p>Then, early in your rule set, <code class="literal">block</code> brute forcers, as shown here:</p><a id="pro_id00217"/><pre class="programlisting">block quick from &lt;bruteforce&gt;</pre><p>Finally, add your <code class="literal">pass</code> rule:</p><a id="pro_id00218"/><pre class="programlisting">pass proto tcp to $localnet port $tcp_services \&#13;
     keep state (max-src-conn 100, max-src-conn-rate 15/5, \&#13;
         overload &lt;bruteforce&gt; flush global)</pre><p>This rule is very similar to what you’ve seen in earlier examples. The interesting part in this context is the contents of the parentheses, called <span class="emphasis"><em>state-tracking options</em></span>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">max-src-conn</code> is the number of simultaneous connections allowed from one host. In this example, it’s set to <code class="literal">100</code>. You may want a slightly higher or lower value, depending on your network’s traffic patterns.</p></li><li class="listitem"><p><code class="literal">max-src-conn-rate</code> is the rate of new connections allowed from any single host. Here, it’s set to <code class="literal">15</code> connections per 5 seconds, denoted as <code class="literal">15/5</code>. Choose a rate that suits your setup.</p></li><li class="listitem"><p><code class="literal">overload &lt;bruteforce&gt;</code> means that the address of any host that exceeds the preceding limits is added to the table <code class="literal">bruteforce</code>. Our rule set blocks all traffic from addresses in the <code class="literal">bruteforce</code> table. Once a host exceeds any of these limits and is put in the overload table, the rule no longer matches traffic from that host. Make sure that overloaders are handled, if only by a default block rule or similar.</p></li><li class="listitem"><p><code class="literal">flush global</code> says that when a host reaches the limit, all states for its connections are terminated (flushed). The <code class="literal">global</code> option means that for good measure, <code class="literal">flush</code> applies to all states created by traffic from that host, no matter which rule created a state.</p></li></ul></div><p>As you can imagine, the effect of this tiny addition to the rule set is dramatic. After a few tries, brute forcers end up in the <code class="literal">bruteforce</code> table. That means that all their existing connections are terminated (flushed) and any new attempts will be blocked, most likely with <code class="literal">Fatal: timeout before authentication</code> messages at their end. You have created an <span class="emphasis"><em>adaptive firewall</em></span> that adjusts automatically to conditions in your network and acts on undesirable activity.</p><div class="note" title="Note"><h3 class="title"><a id="ch06note01"/>Note</h3><p><a class="indexterm" id="iddle1306"/><a class="indexterm" id="iddle1307"/><a class="indexterm" id="iddle1503"/><span class="emphasis"><em>These adaptive rules are effective only for protection against the traditional, rapid-fire type of brute-force attempts. The low-intensity, distributed password-guessing attempts that were first identified as such in 2008 and have been recurring ever since (known among other names as</em></span> The Hail Mary Cloud<span class="emphasis"><em><sup>[<a class="footnote" href="#ftn.ch06fn02" id="ch06fn02">31</a>]</sup>) don’t produce traffic that will match these rules.</em></span></p></div><p>It’s likely that you will want some flexibility in your rule set and want to allow a larger number of connections for some services, but you also might like to be a little more tight-fisted when it comes to SSH. In that case, you could supplement the general-purpose <code class="literal">pass</code> rule with something like the following one early in your rule set:</p><a id="pro_id00219"/><pre class="programlisting">pass quick proto { tcp, udp } to port ssh \&#13;
     keep state (max-src-conn 15, max-src-conn-rate 5/3, \&#13;
        overload &lt;bruteforce&gt; flush global)</pre><p>You should be able to find the set of parameters that’s just right for your situation by reading the relevant man pages and the <span class="emphasis"><em>PF User Guide</em></span> (see <a class="xref" href="apa.html" title="Appendix A. Resources">Appendix A</a>).</p><div class="note" title="Note"><h3 class="title"><a id="ch06note02"/>Note</h3><p><span class="emphasis"><em>Remember that these sample rules are intended as illustrations and your network’s needs may be better served by different rules. Setting the number of simultaneous connections or the rate of connections too low may block legitimate traffic. There’s a potential risk of self-inflicted denial of service when the configuration includes many hosts behind a common NATing gateway and the users on the NATed hosts have legitimate business on the other side of a gateway with strict <code class="literal">overload</code> rules.</em></span></p></div><p>The state-tracking options and the <code class="literal">overload</code> mechanism don’t need to apply exclusively to the SSH service, and blocking all traffic from offenders isn’t always desired. You could, for example, use a rule like this:</p><a id="pro_id00220"/><pre class="programlisting">pass proto { tcp, udp } to port $mail_services \&#13;
     keep state (max 1500, max-src-conn 100)</pre><p>Here, <code class="literal">max</code> specifies the maximum number of states that can be created for each rule with no <code class="literal">overload</code> to protect a mail or Web service from receiving more connections than it can handle (keep in mind that the number of rules loaded depends on what the <code class="literal">$mail_services</code> macro expands to). Once the <code class="literal">max</code> limit is reached, new connections will not match this rule until the old ones terminate. Alternatively, you could remove the <code class="literal">max</code> restriction, add an <code class="literal">overload</code> part to the rule, and assign offenders to a queue with a minimal bandwidth allocation (see the discussion of traffic shaping in <a class="xref" href="ch07.html" title="Chapter 7. Traffic Shaping with Queues and Priorities">Chapter 7</a> for details on setting up queues).</p><p><a class="indexterm" id="iddle1104"/><a class="indexterm" id="iddle1226"/><a class="indexterm" id="iddle1337"/><a class="indexterm" id="iddle1645"/><a class="indexterm" id="iddle1704"/><a class="indexterm" id="iddle1887"/><a class="indexterm" id="iddle1934"/><a class="indexterm" id="iddle1935"/><a class="indexterm" id="iddle1939"/>Some sites use <code class="literal">overload</code> to implement a multitiered system, where hosts that trip one <code class="literal">overload</code> rule are transferred to one or more intermediate “probation” tables for special treatment. It can be useful in Web contexts not to block traffic from hosts in the overload tables outright but rather to redirect all HTTP requests from these hosts to specific Web pages (as in the <code class="literal">authpf</code> example near the end of <a class="xref" href="ch04.html" title="Chapter 4. Wireless Networks Made Easy">Chapter 4</a>).</p></div><div class="sect2" title="Tidying Your Tables with pfctl"><div class="titlepage"><div><div><h3 class="title" id="tidying_your_tables_with_pfctl">Tidying Your Tables with pfctl</h3></div></div></div><p>With the <code class="literal">overload</code> rules from the previous section in place, you now have an adaptive firewall that automatically detects undesirable behavior and adds offenders’ IP addresses to tables. Watching the logs and the tables can be fun in the short run, but because those rules only add to the tables, we run into the next challenge: keeping the content of the tables up-to-date and relevant.</p><p>When you’ve run a configuration with an adaptive rule set for a while, at some point, you’ll discover that an IP address one of your <code class="literal">overload</code> rules blocked last week due to a brute-force attack was actually a dynamically assigned address, which is now assigned to a different ISP customer with a legitimate reason to communicate with hosts in your network.<sup>[<a class="footnote" epub:type="noteref" href="#ftn.ch06fn03" id="ch06fn03">32</a>]</sup> If your adaptive rules catch a lot of traffic on a busy network, you may also find that the overload tables will grow over time to take up an increasing amount of memory.</p><p>The solution is to <span class="emphasis"><em>expire</em></span> table entries—to remove entries after a certain amount of time. In OpenBSD 4.1, <code class="literal">pfctl</code> acquired the ability to expire table entries based on the time since their statistics were last reset.<sup>[<a class="footnote" epub:type="noteref" href="#ftn.ch06fn04" id="ch06fn04">33</a>]</sup> (In almost all instances, this reset time is equal to the time since the table entry was added.) The keyword is <code class="literal">expire</code>, and the table entry’s age is specified in seconds. Here’s an example:</p><a id="pro_id00221"/><pre class="programlisting">$ <span class="strong"><strong>sudo pfctl -t bruteforce -T expire 86400</strong></span></pre><p>This command will remove <code class="literal">bruteforce</code> table entries that had their statistics reset more than 86,400 seconds (24 hours) ago.</p><div class="note" title="Note"><h3 class="title"><a id="ch06note03"/>Note</h3><p><span class="emphasis"><em>The choice of 24 hours as the expiry time is a fairly arbitrary one. You should choose a value that you feel is a reasonable amount of time for any problem at the other end to be noticed and fixed. If you have adaptive rules in place, it’s a good idea to set up <code class="literal">crontab</code> entries to run table expiry at regular intervals with a command much like the preceding one to make sure your tables are kept up-to-date.</em></span></p></div></div></div><div class="sect1" title="Giving Spammers a Hard Time with spamd"><div class="titlepage"><div><div><h2 class="title" id="giving_spammers_a_hard_time_with_spamd" style="clear: both">Giving Spammers a Hard Time with spamd</h2></div></div></div><p><a class="indexterm" id="iddle1163"/><a class="indexterm" id="iddle1692"/><a class="indexterm" id="iddle1693"/><a class="indexterm" id="iddle1695"/><a class="indexterm" id="iddle1819"/><a class="indexterm" id="iddle1826"/><a class="indexterm" id="iddle1827"/><a class="indexterm" id="iddle1829"/><a class="indexterm" id="iddle1842"/><a class="indexterm" id="iddle1843"/><a class="indexterm" id="iddle1846"/><a class="indexterm" id="iddle1856"/><a class="indexterm" id="iddle1911"/><a class="indexterm" id="iddle1943"/>Email is a fairly essential service that needs special attention due to the large volume of unwanted messages, or <span class="emphasis"><em>spam</em></span>. The volume of unsolicited commercial messages was already a painful problem when malware makers discovered that email-borne worms would work and started using email to spread their payload. During the early 2000s, the combined volume of spam and email-borne malware had increased to the point where running an SMTP mail service without some sort of spam countermeasures had become almost unthinkable.</p><p>Spam-fighting measures are almost as old as the spam problem itself. The early efforts focused on analysis of the messages’ contents (known as <span class="emphasis"><em>content filtering</em></span>) and to some extent on interpretation of the messages’ rather trivially forgeable headers, such as the purported sender address (<code class="literal">From:</code>) or the store and forward paths of intermediate deliveries recorded in the <code class="literal">Received:</code> headers.</p><p>When the OpenBSD team designed its spam-fighting solution <code class="literal">spamd</code>, first introduced with OpenBSD 3.3 in 2003, the developers instead focused on the network level and the immediate communication partner in the SMTP conversations along with any available information about hosts that tried to deliver messages. The developers set out to create a small, simple, and secure program. The early implementation was based almost entirely on creative use of PF tables combined with data from trusted external sources.</p><div class="note" title="Note"><h3 class="title"><a id="ch06note04"/>Note</h3><p><span class="emphasis"><em>In addition to the OpenBSD spam-deferral daemon, the content-filtering-based antispam package SpamAssassin</em></span> (<a class="ulink" href="http://spamassassin.apache.org/" target="_top">http://spamassassin.apache.org/</a>) <span class="emphasis"><em>features a program called <code class="literal">spamd</code>. Both programs are designed to help fight spam, but they take very different approaches to the underlying problem and don’t interoperate directly. However, when both programs are correctly configured and running, they complement each other well.</em></span></p></div><div class="sect2" title="Network-Level Behavior Analysis and Blacklisting"><div class="titlepage"><div><div><h3 class="title" id="network-level_behavior_analysis_and_blac">Network-Level Behavior Analysis and Blacklisting</h3></div></div></div><p>The original <code class="literal">spamd</code> design is based on the observation that spammers send a lot of mail and the incredibly small likelihood of you being the first person to receive a particular message. In addition, spam is sent via a few spammer-friendly networks and numerous hijacked machines. Both the individual messages and the machines that send them will be reported to blacklist maintainers quickly, and the blacklist data consisting of known spam senders’ IP addresses forms the basis for <code class="literal">spamd</code>’s processing.</p><p>When dealing with blacklisted hosts, <code class="literal">spamd</code> employs a method called <span class="emphasis"><em>tarpitting</em></span>. When the daemon receives an SMTP connection, it presents its banner and immediately switches to a mode where it answers SMTP traffic at the rate of 1 byte per second, using a tiny selection of SMTP commands designed to make sure that mail is never delivered but rather rejected back into the sender’s queue once the message headers have been transferred. The intention is to waste as much time as possible on the sending end <a class="indexterm" id="iddle1078"/><a class="indexterm" id="iddle1269"/><a class="indexterm" id="iddle1536"/><a class="indexterm" id="iddle1828"/><a class="indexterm" id="iddle1857"/><a class="indexterm" id="iddle2041"/>while costing the receiver pretty much nothing. This specific tarpitting implementation with 1-byte SMTP replies is often referred to as <span class="emphasis"><em>stuttering</em></span>. Blacklist-based tarpitting with stuttering was the default mode for <code class="literal">spamd</code> up to and including OpenBSD 4.0.</p><div class="note" title="Note"><h3 class="title"><a id="ch06note05"/>Note</h3><p><span class="emphasis"><em>On FreeBSD and NetBSD, spamd is not part of the base system but is available through ports and packages as</em></span> mail/spamd<span class="emphasis"><em>. If you’re running PF on FreeBSD or NetBSD, you need to install the port or package before following the instructions over the next few pages.</em></span></p></div><div class="sect3" title="Setting Up spamd in Blacklisting Mode"><div class="titlepage"><div><div><h4 class="title" id="setting_up_spamd_in_blacklisting_mode">Setting Up spamd in Blacklisting Mode</h4></div></div></div><p>To set up <code class="literal">spamd</code> to run in traditional, blacklisting-only mode, you first put a special-purpose table and a matching redirection in <span class="emphasis"><em>pf.conf</em></span> and then turn your attention to <code class="literal">spamd</code>’s own <span class="emphasis"><em>spamd.conf</em></span>. <code class="literal">spamd</code> then hooks into the PF rule set via the table and the redirection.</p><p>The following are the <span class="emphasis"><em>pf.conf</em></span> lines for this configuration:</p><a id="pro_id00222"/><pre class="programlisting">table &lt;spamd&gt; persist&#13;
pass in on $ext_if inet proto tcp from &lt;spamd&gt; to \&#13;
      { $ext_if, $localnet } port smtp rdr-to 127.0.0.1 port 8025</pre><p>And here is the pre–OpenBSD 4.7 syntax:</p><a id="pro_id00223"/><pre class="programlisting">table &lt;spamd&gt; persist&#13;
rdr pass on $ext_if inet proto tcp from &lt;spamd&gt; to \&#13;
         { $ext_if, $localnet } port smtp -&gt; 127.0.0.1 port 8025</pre><p>The table, <code class="literal">&lt;spamd&gt;</code>, is there to store the IP addresses you import from trusted blacklist sources. The redirection takes care of all SMTP attempts from hosts that are already in the blacklist. <code class="literal">spamd</code> listens on port 8025 and responds s-l-o-w-l-y (1 byte per second) to all SMTP connections it receives as a result of the redirection. Later on in the rule set, you would have a rule that makes sure legitimate SMTP traffic passes to the mail server. <span class="emphasis"><em>spamd.conf</em></span> is where you specify the sources of your blacklist data and any exceptions or local overrides you want.</p><div class="note" title="Note"><h3 class="title"><a id="ch06note06"/>Note</h3><p><span class="emphasis"><em>On OpenBSD 4.0 and earlier (and by extension, ports based on versions prior to OpenBSD 4.1),</em></span> spamd.conf <span class="emphasis"><em>was in</em></span> /etc<span class="emphasis"><em>. Beginning with OpenBSD 4.1,</em></span> spamd. conf <span class="emphasis"><em>is found in</em></span> /etc/mail <span class="emphasis"><em>instead. The FreeBSD port installs a sample configuration in</em></span> /usr/local/etc/spamd/spamd.conf.sample<span class="emphasis"><em>.</em></span></p></div><p>Near the beginning of <span class="emphasis"><em>spamd.conf</em></span>, you’ll notice a line without a <code class="literal">#</code> comment sign that looks like <code class="literal">all:\</code>. This line specifies the blacklists you’ll use. Here is an example:</p><a id="pro_id00224"/><pre class="programlisting">all:\&#13;
:uatraps:whitelist:</pre><p><a class="indexterm" id="iddle1236"/><a class="indexterm" id="iddle1278"/><a class="indexterm" id="iddle1338"/><a class="indexterm" id="iddle2020"/>Add all blacklists that you want to use below the <code class="literal">all:\</code> line, separating each with a colon (<span class="strong"><strong><code class="literal">:</code></strong></span>). To use whitelists to subtract addresses from your blacklist, add the name of the whitelist immediately after the name of each blacklist, as in <code class="literal">:blacklist:whitelist:</code></p><p>Next is the blacklist definition:</p><a id="pro_id00225"/><pre class="programlisting">uatraps:\&#13;
        :black:\&#13;
        :msg="SPAM. Your address %A has sent spam within the last 24 hours":\&#13;
        :method=http:\&#13;
        :file=www.openbsd.org/spamd/traplist.gz</pre><p>Following the name (<code class="literal">uatraps</code>), the first data field specifies the list type—in this case, <code class="literal">black</code>. The <code class="literal">msg</code> field contains the message to be displayed to blacklisted senders during the SMTP dialogue. The <code class="literal">method</code> field specifies how <code class="literal">spamd-setup</code> fetches the list data—in this case, via HTTP. Other possibilities include fetching via FTP (<code class="literal">ftp</code>), from a file in a mounted filesystem (<code class="literal">file</code>), or via execution of an external program (<code class="literal">exec</code>). Finally, the <code class="literal">file</code> field specifies the name of the file <code class="literal">spamd</code> expects to receive.</p><p>The definition of a whitelist follows much the same pattern but omits the message parameter:</p><a id="pro_id00226"/><pre class="programlisting">whitelist:\&#13;
        :white:\&#13;
        :method=file:\&#13;
        :file=/etc/mail/whitelist.txt</pre><div class="note" title="Note"><h3 class="title"><a id="ch06note07"/>Note</h3><p><span class="emphasis"><em>The suggested blacklists in the current default</em></span> spamd.conf <span class="emphasis"><em>are actively maintained and have rarely, if ever, contained false positives. However, earlier versions of that file also suggested lists that excluded large blocks of the Internet, including several address ranges that claim to cover entire countries. If your site expects to exchange legitimate mail with any of the countries in question, those lists may not be optimal for your setup. Other popular lists have been known to list entire <code class="literal">/16</code> ranges as spam sources, and it’s well worth reviewing the details of the list’s maintenance policy before putting a blacklist into production.</em></span></p></div><p>Put the lines for <code class="literal">spamd</code> and the startup parameters you want in your <span class="emphasis"><em>/etc/ rc.conf.local</em></span> on OpenBSD or in <span class="emphasis"><em>/etc/rc.conf</em></span> on FreeBSD or NetBSD. Here’s an example:</p><a id="pro_id00227"/><pre class="programlisting">spamd_flags="-v -b" # for normal use: "" and see spamd-setup(8)</pre><p>Here, we enable <code class="literal">spamd</code> and set it to run in blacklisting mode with the <code class="literal">-b</code> flag. In addition, the <code class="literal">-v</code> flag enables verbose logging, which is useful for keeping track of <code class="literal">spamd</code>’s activity for debugging purposes.</p><p><a class="indexterm" id="iddle1489"/><a class="indexterm" id="iddle1743"/><a class="indexterm" id="iddle1841"/><a class="indexterm" id="iddle1870"/>On FreeBSD, the <span class="emphasis"><em>/etc/rc.conf</em></span> settings that control <code class="literal">spamd</code>’s behavior are <code class="literal">obspamd_enable</code>, which should be set to <code class="literal">"YES"</code> in order to enable <code class="literal">spamd</code>, and <code class="literal">obspamd_flags</code>, where you fill in any command-line options for <code class="literal">spamd</code>:</p><a id="pro_id00228"/><pre class="programlisting">obspamd_enable="YES"&#13;
obspamd_flags="-v -b" # for normal use: "" and see spamd-setup(8)</pre><div class="note" title="Note"><h3 class="title"><a id="ch06note08"/>Note</h3><p><span class="emphasis"><em>To have spamd run in pure blacklist mode on OpenBSD 4.1 or newer, you can achieve the same effect by setting the spamd_black variable to “YES” and then restarting spamd.</em></span></p></div><p>Once you’ve finished editing the setup, start <code class="literal">spamd</code> with the options you want and complete the configuration with <code class="literal">spamd-setup</code>. Finally, create a <code class="literal">cron</code> job that calls <code class="literal">spamd-setup</code> to update the blacklist at reasonable intervals. In pure blacklist mode, you can view and manipulate the table contents using <code class="literal">pfctl</code> table commands.</p></div><div class="sect3" title="spamd Logging"><div class="titlepage"><div><div><h4 class="title" id="spamd_logging">spamd Logging</h4></div></div></div><p>By default, <code class="literal">spamd</code> logs to your general system logs. To send the <code class="literal">spamd</code> log messages to a separate log file, add an entry like this to <span class="emphasis"><em>syslog.conf</em></span>:</p><a id="pro_id00229"/><pre class="programlisting">!!spamd&#13;
daemon.err;daemon.warn;daemon.info;daemon.debug         /var/log/spamd</pre><p>Once you’re satisfied that <code class="literal">spamd</code> is running and doing what it’s supposed to do, you’ll probably want to add the <code class="literal">spamd</code> log file to your log rotations, too. After you’ve run <code class="literal">spamd-setup</code> and the tables are filled, you can view the table contents using <code class="literal">pfctl</code>.</p><div class="note" title="Note"><h3 class="title"><a id="ch06note09"/>Note</h3><p><span class="emphasis"><em>In the sample</em></span> pf.conf <span class="emphasis"><em>fragment at the beginning of this section, the redirection</em></span> (<span class="emphasis"><em>rdr-to) rule is also a pass rule. If you opted for a match rule instead (or if you’re using an older PF version and chose to write a rdr rule that doesn’t include a pass part), be sure to set up a pass rule to let traffic through to your redirection. You may also need to set up rules to let legitimate email through. However, if you’re already running an email service on your network, you can probably go on using your old SMTP pass rules.</em></span></p></div><p>Given a set of reliable and well-maintained blacklists, <code class="literal">spamd</code> in pure blacklisting mode does a good job of reducing spam. However, with pure blacklisting, you catch traffic only from hosts that have already tried to deliver spam elsewhere, and you put your trust in external data sources to determine which hosts deserve to be tarpitted. For a setup that provides a more immediate response to network-level behavior and offers some real gains in spam prevention, consider <span class="emphasis"><em>greylisting</em></span>, which is a crucial part of how the modern <code class="literal">spamd</code> works.</p></div></div><div class="sect2" title="Greylisting: My Admin Told Me Not to Talk to Strangers"><div class="titlepage"><div><div><h3 class="title" id="greylisting_my_admin_told_me_not_to_talk">Greylisting: My Admin Told Me Not to Talk to Strangers</h3></div></div></div><p><a class="indexterm" id="iddle1294"/><a class="indexterm" id="iddle1296"/><a class="indexterm" id="iddle1300"/><a class="indexterm" id="iddle1315"/><a class="indexterm" id="iddle1697"/><a class="indexterm" id="iddle1832"/><a class="indexterm" id="iddle1835"/><a class="indexterm" id="iddle1848"/><a class="indexterm" id="iddle1859"/><a class="indexterm" id="iddle1861"/><a class="indexterm" id="iddle1864"/>Greylisting consists mainly of interpreting the current SMTP standards and adding a little white lie to make life easier.</p><p>Spammers tend to use other people’s equipment to send their messages, and the software they install without the legal owner’s permission needs to be relatively lightweight in order to run undetected. Unlike legitimate mail senders, spammers typically don’t consider any individual message they send to be important. Taken together, this means that typical spam and malware sender software aren’t set up to interpret SMTP status codes correctly. This is a fact that we can use to our advantage, as Evan Harris proposed in his 2003 paper titled “The Next Step in the Spam Control War: Greylisting.” <sup>[<a class="footnote" href="#ftn.ch06fn05" id="ch06fn05">34</a>]</sup></p><p>As Harris noted, when a compromised machine is used to send spam, the sender application tends to try delivery only once, without checking for any results or return codes. Real SMTP implementations interpret SMTP return codes and act on them, and real mail servers retry if the initial attempt fails with any kind of temporary error.</p><p>In his paper, Harris outlined a practical approach:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>On first SMTP contact from a previously unknown communication partner, <span class="emphasis"><em>do not</em></span> receive email on the first delivery attempt, but instead, respond with a status code that indicates a temporary local problem, and store the sender IP address for future reference.</p></li><li class="listitem"><p>If the sender retries immediately, reply as before with the temporary failure status code.</p></li><li class="listitem"><p>If the sender retries after a set minimum amount of time (1 hour, for example) but not more than a maximum waiting period (4 hours, for example), accept the message for delivery and record the sender IP address in your whitelist.</p></li></ul></div><p>This is the essence of greylisting. And fortunately, you can set up and maintain a greylisting <code class="literal">spamd</code> on your PF-equipped gateway.</p><div class="sect3" title="Setting Up spamd in Greylisting Mode"><div class="titlepage"><div><div><h4 class="title" id="setting_up_spamd_in_greylisting_mode">Setting Up spamd in Greylisting Mode</h4></div></div></div><p>OpenBSD’s <code class="literal">spamd</code> acquired its ability to greylist in OpenBSD 3.5. Beginning with OpenBSD 4.1, <code class="literal">spamd</code> runs in greylisting mode by default.</p><p>In the default greylisting mode, the <code class="literal">spamd</code> table used for blacklisting, as described in the previous section, becomes superfluous. You can still use blacklists, but <code class="literal">spamd</code> will use a combination of private data structures for blacklist data and the <code class="literal">spamdb</code> database to store greylisting-related data. A typical set of rules for <code class="literal">spamd</code> in default mode looks like this:</p><a id="pro_id00230"/><pre class="programlisting">table &lt;spamd-white&gt; persist&#13;
table &lt;nospamd&gt; persist file "/etc/mail/nospamd"&#13;
pass in log on egress proto tcp to port smtp \&#13;
            rdr-to 127.0.0.1 port spamd&#13;
pass in log on egress proto tcp from &lt;nospamd&gt; to port smtp&#13;
pass in log on egress proto tcp from &lt;spamd-white&gt; to port smtp&#13;
pass out log on egress proto tcp to port smtp</pre><p><a class="indexterm" id="iddle1164"/><a class="indexterm" id="iddle1270"/><a class="indexterm" id="iddle2042"/>This includes the necessary <code class="literal">pass</code> rules to let legitimate email flow to the intended destinations from your own network. The <code class="literal">&lt;spamd-white&gt;</code> table is the whitelist, maintained by <code class="literal">spamd</code>. The hosts in the <code class="literal">&lt;spamd-white&gt;</code> table have passed the greylisting hurdle, and mail from these machines is allowed to pass to the real mail servers or their content-filtering frontends. In addition, the <code class="literal">nospamd</code> table is there for you to load addresses of hosts that you don’t want to expose to <code class="literal">spamd</code> processing, and the matching <code class="literal">pass</code> rule makes sure SMTP traffic from those hosts passes.</p><p>In your network, you may want to tighten those rules to pass SMTP traffic only to and from hosts that are allowed to send and receive email via SMTP. We’ll get back to the <code class="literal">nospamd</code> table in <a class="xref" href="ch06.html#handling_sites_that_do_not_play_well_wit" title="Handling Sites That Do Not Play Well with Greylisting">Handling Sites That Do Not Play Well with Greylisting</a>.</p><p>The following are the equivalent rules in pre–OpenBSD 4.7 syntax:</p><a id="pro_id00231"/><pre class="programlisting">table &lt;spamd-white&gt; persist&#13;
table &lt;nospamd&gt; persist file "/etc/mail/nospamd"&#13;
rdr pass in log on egress proto tcp to port smtp \&#13;
            -&gt; 127.0.0.1 port spamd&#13;
pass in log on egress proto tcp from &lt;nospamd&gt; to port smtp&#13;
pass in log on egress proto tcp from &lt;spamd-white&gt; to port smtp&#13;
pass out log on egress proto tcp to port smtp</pre><p>On FreeBSD, in order to use <code class="literal">spamd</code> in greylisting mode, you need a file descriptor filesystem (see <code class="literal">man 5 fdescfs</code>) mounted at <span class="emphasis"><em>/dev/fd/</em></span>. To implement this, add the following line to <span class="emphasis"><em>/etc/fstab</em></span> and make sure the <code class="literal">fdescfs</code> code is in your kernel, either compiled in or by loading the module via the appropriate <code class="literal">kldload</code> command.</p><a id="pro_id00232"/><pre class="programlisting">fdescfs /dev/fd fdescfs rw 0 0</pre><p>To begin configuring <code class="literal">spamd</code>, place the lines for <code class="literal">spamd</code> and the startup parameters you want in <span class="emphasis"><em>/etc/rc.conf.local</em></span>. Here’s an example:</p><a id="pro_id00233"/><pre class="programlisting">spamd_flags="-v -G 2:4:864" # for normal use: "" and see spamd-setup(8)</pre><p>On FreeBSD, the equivalent line should go in <span class="emphasis"><em>/etc/rc.conf</em></span>:</p><a id="pro_id00234"/><pre class="programlisting">obspamd_flags="-v -G 2:4:864" # for normal use: "" and see spamd-setup(8)</pre><p>You can fine-tune several of the greylisting-related parameters via <code class="literal">spamd</code> command-line parameters trailing the <code class="literal">-G</code> option.</p><div class="sidebar"><a id="why_greylisting_works"/><div class="sidebar-title">Why Greylisting Works</div><p><a class="indexterm" id="iddle1237"/><a class="indexterm" id="iddle1833"/><a class="indexterm" id="iddle1862"/>A significant amount of design and development effort has been put into making essential services, such as SMTP email transmission, fault-tolerant. In practical terms, this means that the best effort of a service such as SMTP is as close as you can get to having a perfect record for delivering messages. That’s why we can rely on greylisting to eventually let us receive email from proper mail servers.</p><p>The current standard for Internet email transmission is defined in RFC 5321.<sup>[<a class="footnote" href="#ftn.ch06fn05a" id="ch06fn05a">35</a>]</sup> The following are several excerpts from Section 4.5.4.1, “Sending Strategy”:</p><div class="blockquote"><blockquote class="blockquote"><p>“In a typical system, the program that composes a message has some method for requesting immediate attention for a new piece of outgoing mail, while mail that cannot be transmitted immediately MUST be queued and periodically retried by the sender. . . .</p><p>“The sender <span class="emphasis"><em>MUST</em></span> delay retrying a particular destination after one attempt has failed. In general, the retry interval <span class="emphasis"><em>SHOULD</em></span> be at least 30 minutes; however, more sophisticated and variable strategies will be beneficial when the SMTP client can determine the reason for non-delivery.</p><p>“Retries continue until the message is transmitted or the sender gives up; the give-up time generally needs to be at least 4–5 days.”</p></blockquote></div><p>Delivering email is a collaborative, best-effort process, and the RFC clearly states that if the site you are trying to send mail to reports that it can’t receive at the moment, it is your duty (a must requirement) to try again later, giving the receiving server a chance to recover from its problem.</p><p>The clever wrinkle to greylisting is that it’s a convenient white lie. When we claim to have a temporary local problem, that problem is really the equivalent of “My admin told me not to talk to strangers.” Well-behaved senders with valid messages will call again, but spammers won’t wait around for the chance to retry, since doing so increases their cost of delivering messages. This is why greylisting still works, and since it’s based on strict adherence to accepted standards,<sup>[<a class="footnote" epub:type="noteref" href="#ftn.ch06fn05b" id="ch06fn05b">36</a>]</sup> false positives are rare.</p></div><p><a class="indexterm" id="iddle1165"/><a class="indexterm" id="iddle1293"/><a class="indexterm" id="iddle1299"/><a class="indexterm" id="iddle1301"/><a class="indexterm" id="iddle1611"/><a class="indexterm" id="iddle1834"/><a class="indexterm" id="iddle1836"/><a class="indexterm" id="iddle1863"/><a class="indexterm" id="iddle1865"/><a class="indexterm" id="iddle2021"/><a class="indexterm" id="iddle2040"/>The colon-separated list <code class="literal">2:4:864</code> represents the values <code class="literal">passtime</code>, <code class="literal">greyexp</code>, and <code class="literal">whiteexp</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">passtime</code> denotes the minimum number of minutes <code class="literal">spamd</code> considers a reasonable time before retry. The default is 25 minutes, but here we’ve reduced it to 2 minutes.</p></li><li class="listitem"><p><code class="literal">greyexp</code> is the number of hours an entry stays in the greylisted state before it’s removed from the database.</p></li><li class="listitem"><p><code class="literal">whiteexp</code> determines the number of hours a whitelisted entry is kept. The default values for <code class="literal">greyexp</code> and <code class="literal">whiteexp</code> are 4 hours and 864 hours (just over 1 month), respectively.</p></li></ul></div></div><div class="sect3" title="Greylisting in Practice"><div class="titlepage"><div><div><h4 class="title" id="greylisting_in_practice">Greylisting in Practice</h4></div></div></div><p>Users and administrators at sites that implement greylisting tend to agree that greylisting gets rid of most of their spam, with a significant drop in the load on any content filtering they have in place for their mail. We’ll start by looking at what <code class="literal">spamd</code>’s greylisting looks like according to log files and then return with some data.</p><p>If you start <code class="literal">spamd</code> with the <code class="literal">-v</code> command-line option for verbose logging, your logs will include a few more items of information in addition to IP addresses. With verbose logging, a typical log excerpt looks like this:</p><a id="pro_id00235"/><pre class="programlisting">Oct 2 19:53:21 delilah spamd[26905]: 65.210.185.131: connected (1/1), lists: spews1&#13;
Oct 2 19:55:04 delilah spamd[26905]: 83.23.213.115: connected (2/1)&#13;
Oct 2 19:55:05 delilah spamd[26905]: (GREY) 83.23.213.115: &lt;gilbert@keyholes.net&gt; -&gt;&#13;
&lt;wkitp98zpu.fsf@datadok.no&gt;&#13;
Oct 2 19:55:05 delilah spamd[26905]: 83.23.213.115: disconnected after 0 seconds.&#13;
Oct 2 19:55:05 delilah spamd[26905]: 83.23.213.115: connected (2/1)&#13;
Oct 2 19:55:06 delilah spamd[26905]: (GREY) 83.23.213.115: &lt;gilbert@keyholes.net&gt; -&gt;&#13;
&lt;wkitp98zpu.fsf@datadok.no&gt;&#13;
Oct 2 19:55:06 delilah spamd[26905]: 83.23.213.115: disconnected after 1 seconds.&#13;
Oct 2 19:57:07 delilah spamd[26905]: (BLACK) 65.210.185.131: &lt;bounce-3C7E40A4B3@branch15.&#13;
summer-bargainz.com&gt; -&gt; &lt;adm@dataped.no&gt;&#13;
Oct 2 19:58:50 delilah spamd[26905]: 65.210.185.131: From: Auto lnsurance Savings &lt;noreply@&#13;
branch15.summer-bargainz.com&gt;&#13;
Oct 2 19:58:50 delilah spamd[26905]: 65.210.185.131: Subject: Start SAVlNG M0NEY on Auto&#13;
lnsurance&#13;
Oct 2 19:58:50 delilah spamd[26905]: 65.210.185.131: To: adm@dataped.no&#13;
Oct 2 20:00:05 delilah spamd[26905]: 65.210.185.131: disconnected after 404 seconds. lists:&#13;
spews1&#13;
Oct 2 20:03:48 delilah spamd[26905]: 222.240.6.118: connected (1/0)&#13;
Oct 2 20:03:48 delilah spamd[26905]: 222.240.6.118: disconnected after 0 seconds.&#13;
Oct 2 20:06:51 delilah spamd[26905]: 24.71.110.10: connected (1/1), lists: spews1&#13;
Oct 2 20:07:00 delilah spamd[26905]: 221.196.37.249: connected (2/1)&#13;
Oct 2 20:07:00 delilah spamd[26905]: 221.196.37.249: disconnected after 0 seconds.&#13;
Oct 2 20:07:12 delilah spamd[26905]: 24.71.110.10: disconnected after 21 seconds. lists:&#13;
spews1</pre><p><a class="indexterm" id="iddle1701"/><a class="indexterm" id="iddle1820"/><a class="indexterm" id="iddle1845"/><a class="indexterm" id="iddle1872"/><a class="indexterm" id="iddle1873"/><a class="indexterm" id="iddle2044"/>The first line is the beginning of a connection from a machine in the <code class="literal">spews1</code> blacklist. The next six lines show the complete records of two connection attempts from another machine, which each time connects as the second active connection. This second machine isn’t yet in any blacklist, so it’s grey-listed. Note the rather curious delivery address (<span class="emphasis"><em><span class="email"><a class="email" href="mailto:wkitp98zpu.fsf@datadok.no">wkitp98zpu.fsf@datadok.no</a></span></em></span>) in the message that the greylisted machine tries to deliver. There’s a useful trick that we’ll look at in <a class="xref" href="ch06.html#greytrapping" title="Greytrapping">Greytrapping</a>. The <code class="literal">(GREY)</code> and <code class="literal">(BLACK)</code> before the addresses indicate greylisting or blacklisting status. Then there’s more activity from the blacklisted host, and a little later we see that after 404 seconds (or 6 minutes and 44 seconds), the blacklisted host gives up without completing the delivery.</p><p>The remaining lines show a few very short connections, including one from a machine already on a blacklist. This time, though, the machine disconnects too quickly to see any <code class="literal">(BLACK)</code> flag at the beginning of the SMTP dialogue, but we see a reference to the list name (<code class="literal">spews1</code>) at the end.</p><p>Roughly 400 seconds is about the amount of time that naive blacklisted spammers hang around (according to data from various sites) and about the time it takes (at the rate of 1 byte per second) to complete the <code class="literal">EHLO ...</code> dialogue until <code class="literal">spamd</code> rejects the message. However, while peeking at the logs, you’re likely to find some spammers that hang around significantly longer. For example, in the data from our office gateway, one log entry stood out:</p><a id="pro_id00236"/><pre class="programlisting">Dec 11 23:57:24 delilah spamd[32048]: 69.6.40.26: connected (1/1), lists:&#13;
spamhaus spews1 spews2&#13;
Dec 12 00:30:08 delilah spamd[32048]: 69.6.40.26: disconnected after 1964&#13;
seconds. lists: spamhaus spews1 spews2</pre><p>This particular machine was already on several blacklists when it made 13 attempts at delivery from December 9 through December 12. The last attempt lasted 32 minutes and 44 seconds, without completing the delivery. Relatively intelligent spam senders drop the connection during the first few seconds, like the ones in the first log fragment. Others give up after around 400 seconds. A few hang on for hours. (The most extreme case we’ve recorded hung on for 42,673 seconds, which is almost 12 hours.)</p></div></div><div class="sect2" title="Tracking Your Real Mail Connections: spamlogd"><div class="titlepage"><div><div><h3 class="title" id="tracking_your_real_mail_connections_spam">Tracking Your Real Mail Connections: spamlogd</h3></div></div></div><p>Behind the scenes, rarely mentioned and barely documented, is one of <code class="literal">spamd</code>’s most important helper programs: the <code class="literal">spamlogd</code> whitelist updater. As the name suggests, <code class="literal">spamlogd</code> works quietly in the background, logging connections to and from your mail servers to keep your whitelist updated. The idea is to make sure that valid mail sent between hosts you communicate with regularly goes through with a minimum of fuss.</p><div class="note" title="Note"><h3 class="title"><a id="ch06note10"/>Note</h3><p><span class="emphasis"><em>If you’ve followed the discussion up to this point, <code class="literal">spamlogd</code> has probably been started automatically already. However, if your initial <code class="literal">spamd</code> configuration didn’t include greylisting, <code class="literal">spamlogd</code> may not have been started, and you may experience strange symptoms, like the greylist and whitelist not being updated properly. Restarting <code class="literal">spamd</code> after you’ve enabled greylisting should ensure that <code class="literal">spamlogd</code> is loaded and available, too.</em></span></p></div><p><a class="indexterm" id="iddle1302"/><a class="indexterm" id="iddle1359"/><a class="indexterm" id="iddle1698"/><a class="indexterm" id="iddle1837"/><a class="indexterm" id="iddle1866"/>In order to perform its job properly, <code class="literal">spamlogd</code> needs you to log SMTP connections to and from your mail servers, just as we did in the sample rule sets in <a class="xref" href="ch05.html" title="Chapter 5. Bigger or Trickier Networks">Chapter 5</a>:</p><a id="pro_id00237"/><pre class="programlisting">emailserver = "192.0.2.225"&#13;
pass log proto tcp to $emailserver port $email&#13;
pass log proto tcp from $emailserver to port smtp</pre><p>On OpenBSD 4.1 and higher (and equivalents), you can create several <code class="literal">pflog</code> interfaces and specify where rules should be logged. Here’s how to separate the data <code class="literal">spamlogd</code> needs to read from the rest of your PF logs:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Create a separate <code class="literal">pflog1</code> interface using <code class="literal">ifconfig pflog1 create</code>, or create a <span class="emphasis"><em>hostname.pflog1</em></span> file with just the line <code class="literal">up</code>.</p></li><li class="listitem"><p>Change the rules to the following:</p><a id="pro_id00238"/><pre class="programlisting">pass log (to pflog1) proto tcp to $emailserver port $email&#13;
pass log (to pflog1) proto tcp from $emailserver to port smtp</pre></li><li class="listitem"><p>Add <code class="literal">-l pflog1</code> to <code class="literal">spamlogd</code>’s startup parameters.</p></li></ol></div><p>This separates the <code class="literal">spamd</code>-related logging from the rest. (See <a class="xref" href="ch09.html" title="Chapter 9. Logging, Monitoring, and Statistics">Chapter 9</a> for more about logging.)</p><p>With the preceding rules in place, <code class="literal">spamlogd</code> will add the IP addresses that receive email you send to the whitelist. This isn’t an ironclad guarantee that the reply will pass immediately, but in most configurations, it helps speed things significantly.</p></div><div class="sect2" title="Greytrapping"><div class="titlepage"><div><div><h3 class="title" id="greytrapping">Greytrapping</h3></div></div></div><p>We know that spam senders rarely use a fully compliant SMTP implementation to send their messages, which is why greylisting works. We also know that spammers rarely check that the addresses they feed to their hijacked machines are actually deliverable. Combine these facts, and you see that if a greylisted machine tries to send a message to an invalid address in your domain, there’s a good chance that the message is spam or malware.</p><p>This realization led to the next evolutionary step in <code class="literal">spamd</code> development—a technique dubbed <span class="emphasis"><em>greytrapping</em></span>. When a greylisted host tries to deliver mail to a known bad address in our domains, the host is added to a locally maintained blacklist called <code class="literal">spamd-greytrap</code>. Members of the <code class="literal">spamd-greytrap</code> list are treated to the same 1-byte-per-second tarpitting as members of other blacklists.</p><p>Greytrapping as implemented in <code class="literal">spamd</code> is simple and elegant. The main thing you need as a starting point is <code class="literal">spamd</code> running in greylisting mode. The other crucial component is a list of addresses in domains your servers handle email for, but only ones that you’re sure will never receive legitimate email. The number of addresses in your list is unimportant, but there must be at least one, and the upper limit is mainly defined by how many addresses you wish to add.</p><p><a class="indexterm" id="iddle1238"/><a class="indexterm" id="iddle1852"/>Next, you use <code class="literal">spamdb</code> to feed your list to the greytrapping feature and sit back to watch. First, a sender tries to send email to an address on your grey-trap list and is simply greylisted, as with any sender you haven’t exchanged email with before. If the same machine tries again, either to the same, invalid address or another address on your greytrapping list, the greytrap is triggered, and the offender is put into <code class="literal">spamd-greytrap</code> for 24 hours. For the next 24 hours, any SMTP traffic from the greytrapped host will be stuttered, with 1-byte-at-a-time replies.</p><p>That 24-hour period is short enough not to cause serious disruption of legitimate traffic because real SMTP implementations will keep trying to deliver for at least a few days. Experience from large-scale implementations of the technique shows that it rarely produces false positives. Machines that continue spamming after 24 hours will make it back to the tarpit soon enough.</p><p>To set up your traplist, use <code class="literal">spamdb</code>’s <code class="literal">-T</code> option. In my case, the strange address<sup>[<a class="footnote" epub:type="noteref" href="#ftn.ch06fn06" id="ch06fn06">37</a>]</sup> I mentioned earlier in <a class="xref" href="ch06.html#greylisting_in_practice" title="Greylisting in Practice">Greylisting in Practice</a> was a natural candidate for inclusion:</p><a id="pro_id00239"/><pre class="programlisting">$ <span class="strong"><strong>sudo spamdb -T -a wkitp98zpu.fsf@datadok.no</strong></span></pre><p>The command I actually entered was <code class="literal">$ sudo spamdb -T -a "&lt;wkitp98zpu.fsf@datadok.no&gt;"</code>. In OpenBSD 4.1 and newer, <code class="literal">spamdb</code> doesn’t require the angle brackets or quotes, but it will accept them.</p><p>Add as many addresses as you like. I tend to find new additions for my local list of spamtrap addresses by looking in the greylist and mail server logs for failed attempts to deliver delivery failure reports to nonexistent addresses in my domains (yes, it really is as crazy as it sounds).</p><div class="warning" epub:type="warning" title="Warning"><h3 class="title"><a id="ch06note11"/>Warning</h3><p><span class="emphasis"><em>Make sure that the addresses you add to your spamtrap lists are invalid and will stay invalid. There’s nothing quite like the embarrassment of discovering that you made a valid address into a spamtrap, however temporarily.</em></span></p></div><p>The following log fragment shows how a spam-sending machine is grey-listed at first contact and then comes back and clumsily tries to deliver messages to the curious address I added to my traplist, only to end up in the <code class="literal">spamd-greytrap</code> blacklist after a few minutes. We know what it will be doing for the next 20-odd hours.</p><a id="pro_id00240"/><pre class="programlisting">Nov 6 09:50:25 delilah spamd[23576]: 210.214.12.57: connected (1/0)&#13;
Nov 6 09:50:32 delilah spamd[23576]: 210.214.12.57: connected (2/0)&#13;
Nov 6 09:50:40 delilah spamd[23576]: (GREY) 210.214.12.57: &lt;gilbert@keyholes.net&gt; -&gt;&#13;
&lt;wkitp98zpu.fsf@datadok.no&gt;&#13;
Nov 6 09:50:40 delilah spamd[23576]: 210.214.12.57: disconnected after 15 seconds.&#13;
Nov 6 09:50:42 delilah spamd[23576]: 210.214.12.57: connected (2/0)&#13;
Nov 6 09:50:45 delilah spamd[23576]: (GREY) 210.214.12.57: &lt;bounce-3C7E40A4B3@branch15.summerbargainz.&#13;
com&gt; -&gt; &lt;adm@dataped.no&gt;&#13;
Nov 6 09:50:45 delilah spamd[23576]: 210.214.12.57: disconnected after 13 seconds.&#13;
Nov 6 09:50:50 delilah spamd[23576]: 210.214.12.57: connected (2/0)&#13;
Nov 6 09:51:00 delilah spamd[23576]: (GREY) 210.214.12.57: &lt;gilbert@keyholes.net&gt; -&gt;&#13;
&lt;wkitp98zpu.fsf@datadok.no&gt;&#13;
Nov 6 09:51:00 delilah spamd[23576]: 210.214.12.57: disconnected after 18 seconds.&#13;
Nov 6 09:51:02 delilah spamd[23576]: 210.214.12.57: connected (2/0)&#13;
Nov 6 09:51:02 delilah spamd[23576]: 210.214.12.57: disconnected after 12 seconds.&#13;
Nov 6 09:51:02 delilah spamd[23576]: 210.214.12.57: connected (2/0)&#13;
Nov 6 09:51:18 delilah spamd[23576]: (GREY) 210.214.12.57: &lt;gilbert@keyholes.net&gt; -&gt;&#13;
&lt;wkitp98zpu.fsf@datadok.no&gt;&#13;
Nov 6 09:51:18 delilah spamd[23576]: 210.214.12.57: disconnected after 16 seconds.&#13;
Nov 6 09:51:18 delilah spamd[23576]: (GREY) 210.214.12.57: &lt;bounce-3C7E40A4B3@branch15.summerbargainz.&#13;
com&gt; -&gt; &lt;adm@dataped.no&gt;&#13;
Nov 6 09:51:18 delilah spamd[23576]: 210.214.12.57: disconnected after 16 seconds.&#13;
Nov 6 09:51:20 delilah spamd[23576]: 210.214.12.57: connected (1/1), lists: spamd-greytrap&#13;
Nov 6 09:51:23 delilah spamd[23576]: 210.214.12.57: connected (2/2), lists: spamd-greytrap&#13;
Nov 6 09:55:33 delilah spamd[23576]: (BLACK) 210.214.12.57: &lt;gilbert@keyholes.net&gt; -&gt;&#13;
&lt;wkitp98zpu.fsf@datadok.no&gt;&#13;
Nov 6 09:55:34 delilah spamd[23576]: (BLACK) 210.214.12.57: &lt;bounce-3C7E40A4B3@branch15.&#13;
summer-bargainz.com&gt; -&gt; &lt;adm@dataped.no&gt;</pre><p><a class="indexterm" id="iddle1304"/><a class="indexterm" id="iddle1699"/><a class="indexterm" id="iddle1838"/><a class="indexterm" id="iddle1840"/><a class="indexterm" id="iddle1847"/><a class="indexterm" id="iddle1849"/><a class="indexterm" id="iddle1851"/><a class="indexterm" id="iddle1853"/><a class="indexterm" id="iddle1867"/><a class="indexterm" id="iddle1869"/><a class="indexterm" id="iddle2043"/>As a side note, it looks like even though the spammer moved to send from a different machine, both the <code class="literal">From:</code> and <code class="literal">To:</code> addresses stayed the same. The fact that he’s still trying to send to an address that’s never been deliverable is a strong indicator that this spammer doesn’t check his lists frequently.</p></div><div class="sect2" title="Managing Lists with spamdb"><div class="titlepage"><div><div><h3 class="title" id="managing_lists_with_spamdb">Managing Lists with spamdb</h3></div></div></div><p>There may be times when you need to view or change the contents of blacklists, whitelists, and greylists. These records are located in the <span class="emphasis"><em>/var/db/spamdb</em></span> database, and an administrator’s main interface to managing those lists is <code class="literal">spamdb</code>.</p><p>Early versions of <code class="literal">spamdb</code> simply offered options to add whitelist entries to the database or update existing ones (<code class="literal">spamdb -a</code> <span class="emphasis"><em>nn</em></span><code class="literal">.</code><span class="emphasis"><em>mm</em></span><code class="literal">.</code><span class="emphasis"><em>nn</em></span><code class="literal">.</code><span class="emphasis"><em>mm</em></span>). You could delete whitelist entries (<code class="literal">spamdb -d</code> <span class="emphasis"><em>nn</em></span><code class="literal">.</code><span class="emphasis"><em>mm</em></span><code class="literal">.</code><span class="emphasis"><em>nn</em></span><code class="literal">.</code><span class="emphasis"><em>mm</em></span>) to compensate for shortcomings in either the blacklists used or the effects of the greylisting algorithms. Recent versions of <code class="literal">spamdb</code> offer some interesting features to support greytrapping.</p><div class="sect3" title="Updating Lists"><div class="titlepage"><div><div><h4 class="title" id="updating_lists">Updating Lists</h4></div></div></div><p>If you run <code class="literal">spamdb</code> without any parameters, it lists the contents of your <code class="literal">spamdb</code> database, and it lets you add or delete both spamtrap addresses and traplist entries. You can also add whitelist entries on the fly.</p><p>If you want to add a host to your whitelist without adding it to your permanent <span class="emphasis"><em>nospamd</em></span> file and reloading your rule set or the table, you could do it from the command line instead, like this:</p><a id="pro_id00241"/><pre class="programlisting">$ sudo spamdb -a 213.187.179.198</pre><p><a class="indexterm" id="iddle1297"/><a class="indexterm" id="iddle1305"/><a class="indexterm" id="iddle1839"/><a class="indexterm" id="iddle1850"/><a class="indexterm" id="iddle1854"/><a class="indexterm" id="iddle1868"/><a class="indexterm" id="iddle1915"/><a class="indexterm" id="iddle1916"/>If a spam sender managed to get a message delivered despite your best efforts, you could correct the situation by adding the spam sender to the <code class="literal">spamd-greytrap</code> list like this:</p><a id="pro_id00242"/><pre class="programlisting">$ sudo spamdb -a -t 192.168.2.128</pre><p>Adding a new trap address is just as simple:</p><a id="pro_id00243"/><pre class="programlisting">$ sudo spamdb -a -T _-medvetsky@ehtrib.org</pre><p>If you want to reverse either of these decisions, you would simply substitute <code class="literal">-d</code> for the <code class="literal">-a</code> option in both these commands.</p></div><div class="sect3" title="Keeping spamd Greylists in Sync"><div class="titlepage"><div><div><h4 class="title" id="keeping_spamd_greylists_in_sync">Keeping spamd Greylists in Sync</h4></div></div></div><p>Beginning with OpenBSD 4.1, <code class="literal">spamd</code> can keep greylisting databases in sync across any number of cooperating greylisting gateways. The implementation is via a set of <code class="literal">spamd</code> command-line options:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <code class="literal">-Y</code> option specifies a <span class="emphasis"><em>sync target</em></span>—that is, the IP address(es) of other <code class="literal">spamd</code>-running gateways you want to inform of updates to your greylisting information.</p></li><li class="listitem"><p>On the receiving end, the <code class="literal">-y</code> option specifies a <span class="emphasis"><em>sync listener</em></span>, which is the address or interface where this <code class="literal">spamd</code> instance is prepared to receive greylisting updates from other hosts.</p></li></ul></div><p>For example, our main <code class="literal">spamd</code> gateway <code class="literal">mainoffice-gw.example.com</code> might have the following options added to its startup command line to establish a sync target and sync listener, respectively:</p><a id="pro_id00244"/><pre class="programlisting">-Y minorbranch-gw.example.com -y mainoffice-gw.example.com</pre><p>Conversely, <code class="literal">minorbranch-gw.example.com</code> at the branch office would have the hostnames reversed:</p><a id="pro_id00245"/><pre class="programlisting">-Y mainoffice-gw.example.com -y minorbranch-gw.example.com</pre><p>The <code class="literal">spamd</code> daemon also supports shared-secret authentication between the synchronization partners. Specifically, if you create the file <span class="emphasis"><em>/etc/mail/ spamd.key</em></span> and distribute copies of it to all synchronization partners, it’ll be used to calculate the necessary checksums for authentication. The <span class="emphasis"><em>spamd.key</em></span> file itself can be any kind of data, such as random data harvested from <span class="emphasis"><em>/dev/arandom</em></span>, as suggested by the <code class="literal">spamd</code> man page.</p><div class="note" title="Note"><h3 class="title"><a id="ch06note12"/>Note</h3><p><a class="indexterm" id="iddle1291"/><a class="indexterm" id="iddle1295"/><a class="indexterm" id="iddle1694"/><a class="indexterm" id="iddle1696"/><a class="indexterm" id="iddle1821"/><a class="indexterm" id="iddle1830"/><a class="indexterm" id="iddle1831"/><a class="indexterm" id="iddle1858"/><a class="indexterm" id="iddle1860"/><span class="emphasis"><em>In situations where direct synchronization of <code class="literal">spamd</code>-related data isn’t practical or if you simply want to share your <code class="literal">spamd-greytrap</code> with others, exporting the contents of your list of locally trapped spam senders to a text file may be desirable. The list format <code class="literal">spamd-setup</code> expects is one address per line, optionally with comment lines starting with one or more # characters. Exporting your list of currently trapped addresses in a usable format can be as simple as putting together a one-liner with <code class="literal">spamdb, grep</code>, and a little imagination.</em></span></p></div></div></div><div class="sect2" title="Detecting Out-of-Order MX Use"><div class="titlepage"><div><div><h3 class="title" id="detecting_out-of-order_mx_use">Detecting Out-of-Order MX Use</h3></div></div></div><p>OpenBSD 4.1 gave <code class="literal">spamd</code> the ability to detect out-of-order MX use. Contacting a secondary mail exchanger first instead of trying the main one is a fairly well-known spammer trick and one that runs contrary to the behavior we expect from ordinary email transfer agents. In other words, if someone tries the email exchangers in the wrong order, we can be pretty sure that they’re trying to deliver spam.</p><p>For our <span class="emphasis"><em>example.com</em></span> domain with main mail server 192.0.2.225 and backup 192.0.2.224, adding <code class="literal">-M 192.0.2.224</code> to <code class="literal">spamd</code>’s startup options would mean that any host that tries to contact 192.0.2.224 via SMTP before contacting the main mail server at 192.0.2.225 will be added to the local <code class="literal">spamdgreytrap</code> list for the next 24 hours.</p></div><div class="sect2" title="Handling Sites That Do Not Play Well with Greylisting"><div class="titlepage"><div><div><h3 class="title" id="handling_sites_that_do_not_play_well_wit">Handling Sites That Do Not Play Well with Greylisting</h3></div></div></div><p>Unfortunately, there are situations where you’ll need to compensate for the peculiarities of other sites’ email setups.</p><p>The first email message sent from any site that hasn’t contacted you for as long as the greylister keeps its data around will be delayed for some random amount of time, which depends mainly on the sender’s retry interval. There are times when even a minimal delay is undesirable. If, for example, you have some infrequent customers who demand your immediate and urgent attention to their business when they do contact you, an initial delivery delay of what could be up to several hours may not be optimal. In addition, you are bound to encounter misconfigured mail servers that either don’t retry at all or retry too quickly, perhaps stopping delivery retries after just one attempt.</p><p>Also, some sites are large enough to have several outgoing SMTP servers, and they don’t play well with greylisting because they’re not guaranteed to retry delivery of any given message from the same IP address used with the prior delivery attempt. Even though those sites comply with the retry requirements, it’s obvious that this is one of the few remaining downsides of greylisting.</p><p><a class="indexterm" id="iddle1808"/><a class="indexterm" id="iddle1809"/><a class="indexterm" id="iddle1875"/><a class="indexterm" id="iddle1876"/>One way to compensate for such situations is to define a table for a local whitelist to be fed from a file in case of reboots. To make sure SMTP traffic from the addresses in the table is not fed to <code class="literal">spamd</code>, add a <code class="literal">pass</code> rule to allow the traffic to pass:</p><a id="pro_id00246"/><pre class="programlisting">table &lt;nospamd&gt; persist file "/etc/mail/nospamd"&#13;
pass in log on egress proto tcp from &lt;nospamd&gt; to port smtp</pre><p>In pre–OpenBSD 4.7 syntax, add a <code class="literal">no rdr</code> rule at the top of your redirection block and a matching <code class="literal">pass</code> rule to let SMTP traffic from the hosts in your <code class="literal">nospamd</code> table through, as shown here:</p><a id="pro_id00247"/><pre class="programlisting">no rdr proto tcp from &lt;nospamd&gt; to $mailservers port smtp&#13;
pass in log on egress proto tcp from &lt;nospamd&gt; to port smtp</pre><p>Once you’ve made these changes to your rule set, enter the addresses you need to protect from redirection into the <span class="emphasis"><em>/etc/mail/nospamd</em></span> file. Then reload your rule set using <code class="literal">pfctl -f /etc/pf.conf</code>. You can then use all the expected table tricks on the <code class="literal">&lt;nospamd&gt;</code> table, including replacing its content after editing the <span class="emphasis"><em>nospamd</em></span> file. In fact, this approach is strongly hinted at in both man pages and sample configuration files distributed with recent versions of <code class="literal">spamd</code>.</p><p>At least some sites with many outgoing SMTP servers publish information about which hosts are allowed to send email for their domain via Sender Policy Framework (SPF) records as part of the domain’s DNS information.<sup>[<a class="footnote" href="#ftn.ch06fn07" id="ch06fn07">38</a>]</sup> To retrieve the SPF records for our <span class="emphasis"><em>example.com</em></span> domain, use the <code class="literal">host</code> command’s <code class="literal">-ttxt</code> option as follows:</p><a id="pro_id00248"/><pre class="programlisting">$ <span class="strong"><strong>host -ttxt example.com</strong></span></pre><p>This command would produce an answer roughly like the following:</p><a id="pro_id00249"/><pre class="programlisting">example.com descriptive text "v=spf1 ip4:192.0.2.128/25 -all"</pre><p>Here, the text in quotes is the <span class="emphasis"><em>example.com</em></span> domain’s SPF record. If you want email from <span class="emphasis"><em>example.com</em></span> to arrive quickly and you trust the people there not to send or relay spam, choose the address range from the SPF record, add it to your <span class="emphasis"><em>nospamd</em></span> file, and reload the <code class="literal">&lt;nospamd&gt;</code> table contents from the updated file.</p></div></div><div class="sect1" title="Spam-Fighting Tips"><div class="titlepage"><div><div><h2 class="title" id="spam-fighting_tips" style="clear: both">Spam-Fighting Tips</h2></div></div></div><p><a class="indexterm" id="iddle1076"/><a class="indexterm" id="iddle1079"/><a class="indexterm" id="iddle1239"/><a class="indexterm" id="iddle1303"/><a class="indexterm" id="iddle1557"/><a class="indexterm" id="iddle1700"/><a class="indexterm" id="iddle1844"/>When used selectively, blacklists combined with <code class="literal">spamd</code> are powerful, precise, and efficient spam-fighting tools. The load on the <code class="literal">spamd</code> machine is minimal. On the other hand, <code class="literal">spamd</code> will never perform better than its weakest data source, which means you’ll need to monitor your logs and use whitelisting when necessary.</p><p>It’s also feasible to run <code class="literal">spamd</code> in a pure greylisting mode, with no blacklists. In fact, some users report that a purely greylisting <code class="literal">spamd</code> configuration is about as effective a spam-fighting tool as configurations with blacklists and sometimes significantly more effective than content filtering. One such report posted to <span class="emphasis"><em>openbsd-misc</em></span> claimed that a pure greylisting configuration immediately rid the company of approximately 95 percent of its spam load. (This report is accessible via <span class="emphasis"><em><a class="ulink" href="http://marc.info/" target="_top">http://marc.info/</a></em></span>, among other places; search for the subject “Followup – spamd greylisting results.”)</p><p>I recommend two very good blacklists. One is Bob Beck’s traplist based on “ghosts of usenet postings past.” Generated automatically by computers running <code class="literal">spamd</code> at the University of Alberta, Bob’s setup is a regular <code class="literal">spamd</code> system that removes trapped addresses automatically after 24 hours, which means that you get an extremely low number of false positives. The number of hosts varies widely and has been as high as 670,000. While still officially in testing, the list was made public in January 2006. The list is available from <span class="emphasis"><em><a class="ulink" href="http://www.openbsd.org/spamd/traplist.gz" target="_top">http://www.openbsd.org/spamd/traplist.gz</a></em></span>. It’s part of recent sample <span class="emphasis"><em>spamd.conf</em></span> files as the <code class="literal">uatraps</code> blacklist.</p><p>The other list I recommend is <span class="emphasis"><em>heise.de</em></span>’s <code class="literal">nixspam</code>, which has a 12-hour automatic expiry and extremely good accuracy. It’s also in the sample <span class="emphasis"><em>spamd.conf</em></span> file. Detailed information about this list is available from <span class="emphasis"><em><a class="ulink" href="http://www.heise.de/ix/nixspam/dnsbl_en/" target="_top">http://www.heise.de/ix/nixspam/dnsbl_en/</a></em></span>.</p><p>Once you’re happy with your setup, try introducing local greytrapping. This is likely to catch a few more undesirables, and it’s good, clean fun. Some limited experiments—carried out while writing this chapter (chronicled at <span class="emphasis"><em><a class="ulink" href="http://bsdly.blogspot.com/" target="_top">http://bsdly.blogspot.com/</a></em></span> in entries starting with <span class="emphasis"><em><a class="ulink" href="http://bsdly.blogspot.com/2007/07/hey-spammer-heres-list-for-you.html" target="_top">http://bsdly.blogspot.com/2007/07/hey-spammer-heres-list-for-you.html</a></em></span>)—even suggest that harvesting the invalid addresses spammers use from your mail server logs, from <code class="literal">spamd</code> logs, or directly from your greylist to put in your traplist is extremely efficient. Publishing the list on a moderately visible Web page appears to ensure that the addresses you put there will be recorded over and over again by address-harvesting robots and will provide you with even better greytrapping material, as they’re then more likely to be kept on the spammers’ list of known good addresses.</p></div><div class="footnotes" epub:type="footnotes"><br/><hr style="width: 100; align: left;"/><div class="footnote" id="ftn.ch06fn01"><p><sup>[<a class="para" href="#ch06fn01">30</a>] </sup>At the time this chapter was first written, this was purely theoretical; I hadn’t yet had any credible reports that this was happening. That changed during 2012 when reliable sources started reporting the appearance of brute-force sequences at odd ports. See <span class="emphasis"><em><a class="ulink" href="http://bsdly.blogspot.com/2013/02/theres-no-protection-in-high-ports.html" target="_top">http://bsdly.blogspot.com/2013/02/theres-no-protection-in-high-ports.html</a></em></span> for more.</p></div><div class="footnote" id="ftn.ch06fn02"><p><sup>[<a class="para" href="#ch06fn02">31</a>] </sup>For an overview of the Hail Mary Cloud sequence of brute-force attempts, see the article “The Hail Mary Cloud and the Lessons Learned” at <span class="emphasis"><em><a class="ulink" href="http://bsdly.blogspot.com/2013/10/the-hail-mary-cloud-and-lessons-learned.html" target="_top">http://bsdly.blogspot.com/2013/10/the-hail-mary-cloud-and-lessons-learned.html</a></em></span>. More resources are referenced there and in <a class="xref" href="apa.html" title="Appendix A. Resources">Appendix A</a>.</p></div><div class="footnote" epub:type="footnote" id="ftn.ch06fn03"><p><sup>[<a class="para" href="#ch06fn03">32</a>] </sup>From a longer-term perspective, it’s fairly normal for entire networks and larger ranges of IP addresses to be reassigned to new owners in response to events in the physical, business-oriented world.</p></div><div class="footnote" epub:type="footnote" id="ftn.ch06fn04"><p><sup>[<a class="para" href="#ch06fn04">33</a>] </sup>Before <code class="literal">pfctl</code> acquired the ability to expire table entries, table expiry was more likely than not handled by the special-purpose utility <code class="literal">expiretable</code>. If your <code class="literal">pfctl</code> doesn’t have the <code class="literal">expire</code> option, you should seriously consider upgrading to a newer system. If upgrading is for some reason not practical, look for <code class="literal">expiretable</code> in your package system.</p></div><div class="footnote" id="ftn.ch06fn05"><p><sup>[<a class="para" href="#ch06fn05">34</a>] </sup>The original Harris paper and a number of other useful articles and resources can be found at <span class="emphasis"><em><a class="ulink" href="http://www.greylisting.org/" target="_top">http://www.greylisting.org/</a></em></span>.</p></div><div class="footnote" id="ftn.ch06fn05a"><p><sup>[<a class="para" href="#ch06fn05a">35</a>] </sup>The relevant parts of RFC 5321 are identical to the corresponding parts of RFC 2821, which is obsolete. Some of us were more than a little disappointed that the IETF didn’t clarify these chunks of the text, now moving forward on the standards track. My reaction (actually, it’s quite a rant) is at <span class="emphasis"><em><a class="ulink" href="http://bsdly.blogspot.com/2008/10/ietf-failed-to-account-for-greylisting.html" target="_top">http://bsdly.blogspot.com/2008/10/ietf-failed-to-account-for-greylisting.html</a></em></span>.</p></div><div class="footnote" epub:type="footnote" id="ftn.ch06fn05b"><p><sup>[<a class="para" href="#ch06fn05b">36</a>] </sup>The relevant RFCs are mainly RFC 1123 and RFC 5321, which made obsolete the earlier RFC 2821. Remember that temporary rejection is an SMTP fault-tolerance feature.</p></div><div class="footnote" epub:type="footnote" id="ftn.ch06fn06"><p><sup>[<a class="para" href="#ch06fn06">37</a>] </sup>Of course, this address is totally bogus. It looks like the kind of message ID the GNUS email and news client generates, and it was probably lifted from a news spool or some unfortunate malware victim’s mailbox.</p></div><div class="footnote" id="ftn.ch06fn07"><p><sup>[<a class="para" href="#ch06fn07">38</a>] </sup>SPF records are stored in DNS zones as TXT records. See <span class="emphasis"><em><a class="ulink" href="http://www.openspf.org/" target="_top">http://www.openspf.org/</a></em></span> for details.</p></div></div></section></body></html>