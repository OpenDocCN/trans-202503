- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">6</samp> <samp class="SANS_Dogma_OT_Bold_B_11">ENUMERATING
    HARDWARE AND NETWORK CONFIGURATIONS</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hardware information, such as CPU speed and RAM allotment, and networking configurations,
    such as the MAC and IP addresses of the host’s network interfaces, can indicate
    to malware that it’s operating in a lab environment. Additionally, malware can
    use these pieces of information to establish context within its operating environment.
    In this chapter, we’ll discuss the techniques that malware might use to gather
    this information and evade detection.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Hardware and Device Configurations</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: System hardware configurations can provide valuable information to a malware
    sample that it can use to determine whether it’s running in a VM or sandbox. VMs
    use emulated hardware that can easily be differentiated from real hardware, and
    they are often configured much differently from physical systems. The malware
    can also enumerate hardware information, like the number of processors, the amount
    of RAM installed in the system, the hard drive storage capacity, and more. In
    this section, we’ll explore each of these areas in turn.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">CPU</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Because virtualized CPUs look a bit different from their physical counterparts,
    malware will often check the host’s processor to determine the context in which
    it’s running. There are a few ways the malware can retrieve CPU hardware information.
    One of the more common approaches is calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetSystemInfo</samp>
    function to get the <samp class="SANS_TheSansMonoCd_W5Regular_11">dwNumberOfProcessors</samp>
    value, which represents how many processors the system has. Modern computer systems
    almost always have more than one processor and processor core. To determine whether
    it’s running on a virtual machine, the malware might check whether the host has
    fewer than two processor cores, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this pseudocode, the sample defines a struct (<samp class="SANS_TheSansMonoCd_W5Regular_11">systemInfo</samp>),
    then calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetSystemInfo</samp>.
    A *struct*, short for structure, is a data type that allows for grouping of other
    data under a single name. All of the information returned from the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetSystemInfo</samp>
    function will be stored in the <samp class="SANS_TheSansMonoCd_W5Regular_11">systemInfo</samp>
    struct. The malware then inspects the <samp class="SANS_TheSansMonoCd_W5Regular_11">dwNumberOfProcessors</samp>
    value in the struct and, if the <samp class="SANS_TheSansMonoCd_W5Regular_11">numProcessors</samp>
    value is less than <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>, will
    terminate itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, a malware sample can call the following functions to return information
    it can use to infer the environment it’s running in:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">GetLogicalProcessorInformation</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11"> </samp>Returns processor core information.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">GetNativeSystemInfo </samp>Returns
    similar information as <samp class="SANS_TheSansMonoCd_W5Regular_11">GetSystemInfo</samp>,
    but is normally invoked by 64-bit applications.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">IsProcessorFeaturePresent </samp>Returns
    the status of various processor features. If it returns true for <samp class="SANS_TheSansMonoCd_W5Regular_11">PF_VIRT_FIRMWARE_ENABLED</samp>,
    the system is using virtual firmware, an obvious clue that the system is likely
    virtualized.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Process Environment Block can also be used for CPU enumeration. To recap
    from [Chapter 1](chapter1.xhtml), the PEB structure consists of pointers to other
    structures in memory that contain information about the currently running process.
    The following code shows how malware can search the PEB to retrieve CPU information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The sample moves the address of the PEB (stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">fs:[0x30]</samp>)
    into the <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp> register, then
    puts the specific offset of the PEB in which the malware is interested (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">[eax+0x64]</samp>) in the <samp class="SANS_TheSansMonoCd_W5Regular_11">edx</samp>
    register. Offset 0x64 in the PEB structure stores the number of processor cores
    configured on the system. If the number of processor cores is <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    the malware terminates itself by jumping to the <samp class="SANS_TheSansMonoCd_W5Regular_11">terminate_process</samp>
    function.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*For 64-bit processes, the address of the PEB will be in the gs register at
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">gs:[0x60]</samp>, so be
    on the lookout for malware referencing this address as well.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">RAM</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Modern computers typically have a minimum of 4GB of RAM, but some malware analysis
    environments and sandboxes may not have this amount. If the installed RAM is below
    the 4GB threshold (or similar), the malware might assume it is running in a virtual
    environment. To check this, the malware calls the Windows function <samp class="SANS_TheSansMonoCd_W5Regular_11">GetPhysicallyInstalledSystemMemory</samp>
    to return the amount of system memory, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here the malware sample calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetPhysicallyInstalledSystemMemory</samp>
    function with <samp class="SANS_TheSansMonoCd_W5Regular_11">TotalMemoryInKilobytes</samp>
    as a parameter, which will store the total system memory value returned from the
    function. After the function call, the malware compares the <samp class="SANS_TheSansMonoCd_W5Regular_11">TotalMemoryInKilobytes</samp>
    value with <samp class="SANS_TheSansMonoCd_W5Regular_11">4194302</samp>, which
    is 4,194,302 kilobytes, or 4GB. If the amount of system RAM is lower than 4GB,
    the malware sample will jump to <samp class="SANS_TheSansMonoCd_W5Regular_11">terminate_process</samp>
    and delete itself.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Hard Disks</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most modern computers are allotted hundreds of gigabytes of storage space. Malware
    can query the storage capacity of the hard disks, and if that value is below a
    certain threshold, it might determine that it’s running in a virtual environment.
    This threshold is typically 40GB, 60GB, or 80GB, but this number may increase
    as average storage capacity grows.
  prefs: []
  type: TYPE_NORMAL
- en: The most common Windows functions used for gathering hard disk and capacity
    information are <samp class="SANS_TheSansMonoCd_W5Regular_11">GetDiskFreeSpace</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetDiskFreeSpaceEx</samp>. Other
    than evasion, there are limited reasons why malware would be querying the hard
    disk space, so these functions should raise a red flag for you. An easy way to
    bypass this evasion tactic is to increase the size of your VM disks to more than
    40GB or, even better, 80GB.
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows contains many API functions that are not well known and are less commonly
    used. One example is the <samp class="SANS_TheSansMonoCd_W5Regular_11">IsNativeVhdBoot</samp>
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">IsNativeVhdBoot</samp> doesn’t
    return <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, the system was
    booted from a virtual hard disk, which indicates a VM. Note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">IsNativeVhdBoot</samp>
    function is effective only on Windows 8 and above.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Monitor Configurations</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A typical modern computer setup will likely have a high-resolution monitor and
    sometimes more than one, whereas (most) VMs and sandboxes will not. Some malware
    specifically looks for the number of monitors in use, and if it detects, say,
    only one monitor, it might infer that it’s in an analysis environment. To accomplish
    this, it can call the Windows API function <samp class="SANS_TheSansMonoCd_W5Regular_11">GetSystemMetrics</samp>,
    which returns a specific variable called <samp class="SANS_TheSansMonoCd_W5Regular_11">SM_CMONITORS</samp>
    representing the number of monitors in use. Another option is to call the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">EnumDisplayMonitors</samp> function, which
    doesn’t return the total number directly but instead executes a callback function
    for each monitor. A *callback function* is simply a way of performing tasks for
    each object—in this case, a monitor—that invokes it.
  prefs: []
  type: TYPE_NORMAL
- en: Malware can also check screen resolution using the same functions. The typical
    resolution for a non-virtualized end-user system is quite high, such as 1,600
    × 900\. If the display resolution of your analysis machine is lower (say, 1,152
    × 864), malware might note this.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">USB Controllers</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Many VMs are configured to use either an older USB protocol version (V1.1 or
    V2.0, for example) or no USB controller device at all. Because most modern non-virtualized
    systems have at least one USB controller with an up-to-date USB device version,
    this can be a good clue for malware.
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows provides a helpful API just for enumeration of USB devices and settings:
    *Winusb.dll*. If you spot malware attempting to import this DLL and use its functions,
    it’s a strong indicator that something fishy is going on.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Firmware Tables</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most system hardware is accompanied by low-level software known as *firmware*.
    Firmware breathes life into the hardware; without it, the hardware couldn’t interface
    with the OS or any other programs. Windows keeps track of firmware in *firmware
    tables* that also contain the make and model of the associated hardware, which
    malware can exploit to identify any hypervisor-related information.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at a firmware table. [Figure 6-1](chapter6.xhtml#fig6-1) shows
    the output on my VM of Nirsoft’s free tool FirmwareTablesView.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig6-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-1: Firmware tables
    displayed in FirmwareTablesView</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You can likely already spot the anomalies that a malware sample could take advantage
    of. There are multiple references to *VBOX*, which is the standard prefix for
    VirtualBox hypervisor firmware.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Firmware column, you can see the type of each firmware table, also called
    the *provider signature*: ACPI, SMBIOS, or Raw. Some functions, like <samp class="SANS_TheSansMonoCd_W5Regular_11">GetSystemFirmwareTable</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumSystemFirmwareTables</samp>,
    require a provider signature to retrieve firmware tables. The following code shows
    a piece of malware calling <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumSystemFirmwareTables</samp>
    to inspect the ACPI tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Later, this malware will search the buffer storing the firmware tables for hypervisor-related
    strings like <samp class="SANS_TheSansMonoCd_W5Regular_11">Oracle</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Vbox</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualBox</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">VMware</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">VMware,
    Inc</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySystemInformation</samp>
    function also returns a lot of different system information, for both malicious
    and legitimate reasons. Malware can use this function to enumerate firmware tables.
    Here’s what this might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The malware calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySystemInformation</samp>
    function with a few important parameters. The first parameter, <samp class="SANS_TheSansMonoCd_W5Regular_11">SystemInformationLength</samp>
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">[ebp+Length]</samp>), is the size
    of the buffer that will receive the data returned from the function call. The
    second parameter, <samp class="SANS_TheSansMonoCd_W5Regular_11">SystemFirmwareTableInformation</samp>
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>), is a pointer to that
    buffer. The third parameter, <samp class="SANS_TheSansMonoCd_W5Regular_11">76</samp>,
    represents the system information class that this malware is interested in, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SystemFirmwareTableInformation</samp>.
    After the malware calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySystemInformation</samp>
    function and the firmware table structure is stored in the buffer, it can enumerate
    the buffer for hypervisor-related information.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">SystemFirmwareTableInformation</samp>
    data class is undocumented by Microsoft, so there isn’t much public information
    about it. Microsoft keeps certain functionalities internal, likely so that they
    can’t be easily abused, but malware authors and researchers will inevitably find
    them. Conix Cybersécurité has compiled a complete list of the data classes that
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySystemInformation</samp>
    can return at [*https://<wbr>github<wbr>.com<wbr>/conix<wbr>-security<wbr>/zer0m0n<wbr>/blob<wbr>/master<wbr>/src<wbr>/driver<wbr>/include<wbr>/nt<wbr>/structures<wbr>/SYSTEM<wbr>_INFORMATION<wbr>_CLASS<wbr>.h*](https://github.com/conix-security/zer0m0n/blob/master/src/driver/include/nt/structures/SYSTEM_INFORMATION_CLASS.h).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Other Hardware Devices</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Examples of other hardware configurations that malware might use to obtain information
    about its environment are CD or DVD drives, sound cards and audio configurations,
    attached printers (or the lack thereof), and serial ports. We’ll go over some
    more of these settings in [Appendix A](appendix-A.xhtml), but because malware
    could enumerate any and all hardware configurations on the victim system, it’s
    impossible to include all of them in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll turn our attention to the networking-related information that malware
    might use to suss out a VM or sandbox environment.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Networking-Related Artifacts</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Networking-related artifacts such as IP address configurations, currently established
    connections, open service ports, and even the domain that the victim system is
    joined to can help malware detect its operating environment. In this section,
    you’ll learn how.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">IP Address Configurations</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Malware may want to get the host’s IP address for a number of reasons, most
    notably to detect if the host is running in a sandbox or malware analysis lab.
    The default IP address range for internal VirtualBox networks is 192.168.56.*X*.
    The default IP range for VMware Workstation is 192.168.*X.X*, with the last two
    octets being randomized (such as 192.168.5.100, or 192.168.187.101). The range
    depends on what version of the hypervisor software the system is running. If the
    victim system has an IP address in these ranges, the malware might either determine
    it’s a VM or further scrutinize the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Retrieving the IP address of the host is as simple as leveraging the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetAdaptersAddresses</samp> function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Like many Windows API functions, <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAdaptersAddresses</samp>
    takes a series of parameters. In this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">push
    edx</samp> pushes to the stack the address of the buffer <samp class="SANS_TheSansMonoCd_W5Regular_11">AdapterAddresses</samp>,
    which will hold all the address data returned from the function call. The next
    three instructions push the <samp class="SANS_TheSansMonoCd_W5Regular_11">reserved</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">flags</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">family</samp>
    parameters. The most important is the <samp class="SANS_TheSansMonoCd_W5Regular_11">family</samp>
    parameter, which contains a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>,
    telling <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAdaptersAddresses</samp>
    to return only IPv4 information. [Table 6-1](chapter6.xhtml#tab6-1) lists the
    definitions of each <samp class="SANS_TheSansMonoCd_W5Regular_11">family</samp>
    parameter value.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 6-1:</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAdaptersAddresses
    family</samp> <samp class="SANS_Futura_Std_Book_11">Parameter Values</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">ASCII value</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Numerical
    value</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Definition</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">AF_UNSPEC</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">Returns both IPv4 and IPv6 addresses</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">AF_INET</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
    | <samp class="SANS_Futura_Std_Book_11">Returns only IPv4 addresses</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">AF_INET6</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">23</samp>
    | <samp class="SANS_Futura_Std_Book_11">Returns only IPv6 addresses</samp> |'
  prefs: []
  type: TYPE_TB
- en: Next, the malware calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAdaptersAddresses</samp>
    function. Later in the code, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">AdapterAddresses.FirstUnicastAddress</samp>
    is moved into <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>, and the
    variable <samp class="SANS_TheSansMonoCd_W5Regular_11">bad_ip_address</samp> is
    moved into <samp class="SANS_TheSansMonoCd_W5Regular_11">edx</samp>. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">FirstUnicastAddress</samp> variable is
    part of <samp class="SANS_TheSansMonoCd_W5Regular_11">AdapterAddresses</samp>
    and contains the first IP address in the structure. The <samp class="SANS_TheSansMonoCd_W5Regular_11">bad_ip_address</samp>
    variable contains the IP address that the malware is checking against. Let’s assume
    this value is <samp class="SANS_TheSansMonoCd_W5Regular_11">192.168.56.2</samp>,
    indicating a VirtualBox network. The malware compares the <samp class="SANS_TheSansMonoCd_W5Regular_11">FirstUnicastAddress</samp>
    value with the <samp class="SANS_TheSansMonoCd_W5Regular_11">bad_ip_address</samp>
    using <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp eax, edx</samp> to see
    if the victim system has the IP address <samp class="SANS_TheSansMonoCd_W5Regular_11">192.168.56.2</samp>.
    If this IP exists in the <samp class="SANS_TheSansMonoCd_W5Regular_11">AdapterAddresses</samp>
    structure, the malware jumps to the <samp class="SANS_TheSansMonoCd_W5Regular_11">terminate_process</samp>
    function to terminate itself.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that there are many ways to enumerate the IP addresses on a system.
    Some functions involve querying the interface information directly, while others
    use a more back-channel method, such as listing the IP network tables. IP address
    information can also be queried using Windows tools such as WMI, PowerShell, and
    the Windows command line. You should be suspicious of any malware looking for
    the host’s internal IP address, as it could be using a detection technique.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Domain Configurations</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Malware may attempt to enumerate the victim host’s domain to ensure the target
    is within a certain company or network, or to weed out malware analysis environments.
    In this case, a *domain* is simply a logical grouping of systems on a network.
    The computer you use for work is likely part of a domain whose name relates to
    your company name. This domain is also typically part of your system’s *hostname*,
    or the name of your device on the network. If you work at Evil Corp, for example,
    your domain name might be *evil.corp* and your hostname might be *your.computer.evil.corp*.
  prefs: []
  type: TYPE_NORMAL
- en: Domain enumeration can be a great evasive tactic for malware. For example, if
    the victim system isn’t associated with a domain, or if the domain it’s attached
    to doesn’t match the malware’s primary target, the malware may terminate itself
    to avoid analysis or change its behavior. Common Windows API functions for enumerating
    a host’s domain are <samp class="SANS_TheSansMonoCd_W5Regular_11">GetComputerName</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">DsGetDcName</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to Windows API functions, malware may query these registry keys,
    which may contain the domain of the system:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">HKCU\Volatile Environment</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM\System\CurrentControlSet\Services\Tcpip\Parameters</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To thwart this tactic, join your VMs and sandboxes to a domain. Even if the
    domain is fake, it can still trick malware into executing. We’ll discuss more
    about faking domains and network connectivity in [Appendix A](appendix-A.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">MAC Address Configurations</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *media access control (MAC) address* is a unique identifier applied to all
    computer network hardware. The MAC address consists of digits (3 bytes) that represent
    the device manufacturer, followed by another series of digits (3 additional bytes)
    specific to the host’s hardware devices (see [Figure 6-2](chapter6.xhtml#fig6-2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig6-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-2: MAC address structure</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 6-2](chapter6.xhtml#fig6-2), the example MAC address is 00:50:56:62:9A:12\.
    The first 3 bytes (00:50:56) represent the manufacturer’s identifier (in this
    case, VMware), and the last 3 bytes represent this specific adapter.
  prefs: []
  type: TYPE_NORMAL
- en: Malware can query the host’s MAC addresses to see if the host is using a specific
    manufacturer’s network hardware. Each piece of network hardware has its own dedicated
    MAC address as well, so malware can also use this information to target its victims.
    An example of this is the now well-known supply chain attack dubbed “ShadowHammer,”
    which occurred in 2019\. The attackers used a list of preselected MAC addresses
    to target and infect specific computers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To obtain a list of MAC addresses on the host, malware can call the Windows
    API function <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAdaptersAddresses</samp>.
    It then compares that list to a hardcoded list of MAC addresses, infecting the
    system only if it finds a network device with a matching MAC address. After the
    malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAdaptersAddresses</samp>
    (using the same technique I outlined in “IP Address Configurations” on [page 109](chapter6.xhtml#pg_109)),
    it checks the <samp class="SANS_TheSansMonoCd_W5Regular_11">PhysicalAddress</samp>
    value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">AdapterAddresses</samp>
    structure, which contains the host’s MAC addresses, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Later, the malware moves data onto the stack with instructions like <samp class="SANS_TheSansMonoCd_W5Regular_11">mov
    [ebp+var_38], 0B203B000h</samp>. This data represents part of the MAC address
    that the malware will compare to the victim’s MAC addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'VM-related MAC addresses can also be enumerated this way. The presence of one
    of the following MAC address prefixes would indicate to the malware that it’s
    running in a VM environment and possibly being analyzed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**VMware Workstation**'
  prefs: []
  type: TYPE_NORMAL
- en: 00:50:56 ...
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 00:0C:29 ...
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 00:05:69 ...
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VirtualBox**'
  prefs: []
  type: TYPE_NORMAL
- en: 08:00:27 ...
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*To bypass this detection technique, change the MAC addresses of your VMs and
    sandboxes.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">External IP Address
    and Internet Connectivity</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One evasion technique that has seen increasing use is obtaining the potential
    victim’s external IP address. Malware might want this information for two reasons.
    First, malware can use it to determine the potential victim’s location. Some malware
    may target victims only in a certain area of the world, or it might want to exclude
    certain geographical regions. Not only does this help the malware stay on target,
    but it also aids in anti-analysis and evasion; if the potential victim isn’t within
    the malware’s regional scope, the malware will terminate itself or modify its
    behavior, likely fooling sandboxes and malware analysts.
  prefs: []
  type: TYPE_NORMAL
- en: Second, malware can use the host’s external IP address information or internet
    connection status to detect an analysis environment. For example, if the external
    IP is a popular virtual private network (VPN) gateway (such as NordVPN or ExpressVPN)
    or a TOR exit node, then the malware may infer that it’s being analyzed. (After
    all, if someone is using TOR or a VPN, they *must* be a malware analyst, right?)
    In addition, it’s often the case that sandboxes and analysis environments are
    intentionally offline, so if the host has no external IP address at all, the malware
    might assume it’s running in a lab environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'This technique can be executed in a number of ways, but perhaps the most common
    is simply sending a web request to an IP lookup service, such as *WhatIsMyIP.com*
    or *IPLocation.net*. These are legitimate services that report back the external
    IP and geolocation information of a calling host. If you detonate malware in an
    analysis sandbox or lab and you see HTTP requests to sites like these, it’s a
    signal that the malware might be attempting to look up the host’s external IP
    address or location. Here’s how that might look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: First, the malware sample moves the value <samp class="SANS_TheSansMonoCd_W5Regular_11">lpszServerName</samp>,
    which contains the domain *icanhazip.com*, into the <samp class="SANS_TheSansMonoCd_W5Regular_11">ecx</samp>
    register for later use ❶. The <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetConnectA</samp>
    function takes a lot of parameters, but the important ones are <samp class="SANS_TheSansMonoCd_W5Regular_11">nServerPort</samp>
    ❷, which indicates the port on which this malware sample will contact the domain
    (port <samp class="SANS_TheSansMonoCd_W5Regular_11">80</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">HTTP</samp>),
    and the domain itself, now stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">ecx</samp>
    ❸. Finally, it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetConnectA</samp>
    ❹. This sample’s code is essentially contacting the *icanhazip.com* domain over
    HTTP to obtain the host’s external IP address.
  prefs: []
  type: TYPE_NORMAL
- en: 'A related method is to simply send a DNS or HTTP request to an online service
    provider. Any service provider will do, but *Google.com* is a common one. If the
    malware sample sends a request to a web server and receives no data (or incorrect
    data), it might deduce that it’s being analyzed. The following sample attempts
    to contact *Google.com* and then checks the response to ensure it matches the
    normal response from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: After attempting to contact *Google.com* (using <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetConnectA</samp>),
    the sample pushes parameters for the <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetReadFile</samp>
    function, including <samp class="SANS_TheSansMonoCd_W5Regular_11">dwNumberOfBytesToRead</samp>
    ❶, which contains the number of bytes to be read from the web server response
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">9</samp>), and <samp class="SANS_TheSansMonoCd_W5Regular_11">lpBuffer</samp>
    ❷, which is a pointer to the data <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetReadFile</samp>
    will return. Next, the malware sample calls <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetReadFile</samp>
    ❸, which reads the first 9 bytes from Google’s response (which should be <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><!doctype</samp>). Finally, the code compares
    the <samp class="SANS_TheSansMonoCd_W5Regular_11"><!doctype</samp> value to the
    actual response stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">lpBuffer</samp>
    ❹. If the responses are different, this malware sample might conclude that the
    system isn’t connected to the internet or is perhaps being analyzed in a sandbox.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s not uncommon to see this external IP validation technique in modern malware,
    so be on the lookout for it. If you’re analyzing a malware sample and see outbound
    HTTP or DNS requests to websites such as *WhatIsMyIP.com* or to service providers
    such as *Google.com* or *AWS.Amazon.com*, there’s a chance the malware is using
    this VM detection technique. Here are some other websites to keep an eye out for:'
  prefs: []
  type: TYPE_NORMAL
- en: '*api.ipify.org*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*checkip.amazonaws.com*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*checkip.dyndns.com*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*icanhazip.com*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ip-api.com*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ip.anysrc.net*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ipecho.net*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ipinfo.io*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*iplocation.net*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*myexternalip.com*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*myipaddress.com*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*showipaddress.com*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*whatismyip.com*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*whatismyipaddress.com*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*wtfismyip.com*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">TCP Connection States</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the previous section, I mentioned that malware analysts often configure their
    analysis machines and sandboxes to be completely offline or connected to a fake
    network. Malware can take advantage of this behavior by enumerating the outgoing
    TCP connections and trying to determine if they’re valid. A legitimate end-user
    system or server will likely have many outgoing TCP connections to various external
    IP addresses and ports. A malware analysis machine or sandbox, unless connected
    to a real network like the internet, may have only a few connections or none at
    all.
  prefs: []
  type: TYPE_NORMAL
- en: This tactic involves using the Windows API <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTcpTable</samp>
    function, which returns a table listing the current status of the latest TCP connections
    on the system, similar to the result of running *netstat.exe* on the host. This
    table might look something like [Table 6-2](chapter6.xhtml#tab6-2).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 6-2:</samp> <samp class="SANS_Futura_Std_Book_11">Sample
    TCP Connections</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Local address</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Local
    port</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Remote address</samp> |
    <samp class="SANS_Futura_Std_Heavy_B_11">Remote port</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">State</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">127.0.0.1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">2869</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">local-machine</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">49202</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">TIME_WAIT</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">127.0.0.1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">2869</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">local-machine</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">49203</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">ESTABLISHED</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">192.168.1.2</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">49157</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">91.184.220.29</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">80</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ESTABLISHED</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">192.168.1.2</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">49158</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">64.233.160.15</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">443</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ESTABLISHED</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">...</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">...</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">...</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">...</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">...</samp> |'
  prefs: []
  type: TYPE_TB
- en: An offline malware analysis machine or sandbox likely won’t have any established
    remote TCP connections like the third and fourth rows in [Table 6-2](chapter6.xhtml#tab6-2).
  prefs: []
  type: TYPE_NORMAL
- en: Malware can also, of course, leverage native Windows tools for this, such as
    the aforementioned *netstat.exe*. When inspecting malware, watch for attempts
    to enumerate TCP state information via Windows functions or native Windows tools.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we covered many of the hardware and network configuration enumeration
    techniques that malware might use to determine its operating environment. As you’ve
    seen, understanding its environment and establishing context are key to malware’s
    ability to detect VMs and sandboxes, evade analysts, or otherwise stay on target.
    In the next chapter, we’ll explore how malware exposes the malware analysis environment
    by inspecting runtime anomalies, monitoring performance, and abusing virtual processor
    instructions.
  prefs: []
  type: TYPE_NORMAL
