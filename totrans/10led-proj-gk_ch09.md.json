["```\n#include <SimbleeForMobile.h>\n\n#define SFM SimbleeForMobile // A macro to shorten our later\n                             //  library calls to a\n                             //  reasonable length.\n\n// Aliases for the pin assignments for each button.\n#define BUTTON1 15\n#define BUTTON2 12\n#define BUTTON3 11\n#define BUTTON4 9\n\n// Linearize the output of the LED in 16 steps. Because of the\n//  nonlinear response of the human eye, for the LED to look\n//  like it is fading in a linear fashion, nonlinear steps\n//  of brightness are needed.\nconst int LEDSteps[16] = {255, 191, 154, 128, 107, 90, 76, 64,\n                            53,  43,  34,  26,  19, 12,  6,  0};\n\n// Timer variable definitions.\nint timer1 = 60;   // timer1 defaults to 60 seconds\n\nint t1Default = 60;\n\nlong t1last = 0;\n\nint t1LEDIndex = 0;\n\nint t1LEDDir = 1;\n\nint t1LEDVal = 255;\n\nlong LEDUpdateLast = 0;\n\n// Timer active definitions.\nbool t1active = false;\n\n// Flash storage definitions and variables.\n#define FLASH_PAGE 251\n\nunsigned long *t1p = ADDRESS_OF_PAGE(FLASH_PAGE);\n\nvoid setup()\n{\n  // Our buttons need to be inputs, with pullups.\n  pinMode(BUTTON1, INPUT_PULLUP);\n  pinMode(BUTTON2, INPUT_PULLUP);\n  pinMode(BUTTON3, INPUT_PULLUP);\n  pinMode(BUTTON4, INPUT_PULLUP);\n  // This is the output pin for the LEDs. I didn't\n  //  make a #define for it because this is the only\n  //  place we use it.\n  pinMode(3, OUTPUT);\n  // This function is defined farther down in the\n  //  code. It handles writing the current values\n  //  of LED brightness to the four LEDs.\n  updateLEDs();\n  // Serial is only used during debugging.\n  Serial.begin(115200);\n\n  // SFM.deviceName and SFM.advertisementData must,\n  //  together, contain fewer than 16 characters.\n  //  These strings put us at 15\\. Whew!\n  SFM.deviceName = \"Bracer of Time\";\n  SFM.advertisementData = \" \";\n  SFM.begin();\n\n  // If we have values in the flash memory, we want to\n  //  extract them and use those as our defaults. If we\n  //  don't have values in flash, the flash value will\n  //  read as -1, so we can check that to see whether we\n  //  want to use the value in flash or not.\n  if ((int)*t1p > 0) t1Default = (int)*t1p;\n  timer1 = t1Default;\n\n}\n\nvoid loop()\n{\n  // SFM.process() handles the UI processing, if a phone\n  //  is connected to the device.\n  SFM.process();\n\n  // Timer 1 section\n  // Start the timer when the button is pressed and the timer\n  //  isn't running.\n  if ((digitalRead(BUTTON1) == LOW) && (t1active == false)) \n  {\n    delay(25);          // Debounce the input.\n    t1active = true;    // Start the timer.\n    t1last = millis();  // Start counting from now.\n    timer1 = t1Default; // Use the current default value for\n                        //  the timer.\n    while (digitalRead(BUTTON1) == LOW) \n    {/*Wait for the button to be released*/}\n  }\n\n  // Stop the timer if it's running.\n  if ((digitalRead(BUTTON1) == LOW) && t1active)\n  {\n    delay(25);          // Debounce the input.\n    t1active = false;   // Stop the timer.\n    while (digitalRead(BUTTON1) == LOW) \n    {/*Wait for the button to be released*/}\n  }\n  // Activates every 1000ms while the timer is running to\n  //  keep the time updating.\n  if ((millis() - t1last > 1000) && t1active)\n  {\n    t1last = millis();\n    timer1--;\n    Serial.println(timer1);\n    if (timer1 == 0)\n    {\n      timer1 = t1Default;\n      t1active = false;\n      t1LEDVal = 255;\n      updateLEDs();\n      Serial.println(\"Timer 1 expired!\");\n    }\n  }\n\n  // LED blinking section\n  // Updates 10 times a second, to update the LED of any\n  //  timer that is running.\n  if (millis() - LEDUpdateLast > 100)\n  {\n    // First, take a note on the current time, so we\n    //  know when to next enter this subsection of code.\n    LEDUpdateLast = millis();\n\n    // Update the values being displayed on the LEDs.\n    updateLEDs();\n\n    // Now, calculate the values that we'll display on\n    //  the LEDs next time through the loop.\n    // T1 LED section\n    if (t1active)\n    {\n      // Adjust the LED value for this LED by changing\n      //  the index we use from the LEDSteps array.\n      t1LEDVal = LEDSteps[t1LEDIndex+=t1LEDDir];\n      // \"Bounce\" the direction of adjustment when we\n      //  reach one end or the other of the array.\n      if (t1LEDIndex == 0)\n      {\n        t1LEDDir = 1;\n      }\n      else if (t1LEDIndex == 15)\n      {\n        t1LEDDir = -1;\n      }\n    }\n\n  }\n}\n\n// UI Element object handles\n// We could have put this stuff up at the top, but I\n//  wanted it closer to the UI function.\nuint8_t t1Input;\n\nuint8_t getValuesButton;\nuint8_t updateButton;\n\n// This function is a Simblee library function that\n//  defines the UI elements that we'll see on the phone.\nvoid ui()\n{\n  SFM.beginScreen();\n  // We need to refetch these values every time we\n  //  reconnect to the phone, in case they changed.\n  if ((int)*t1p > 0) t1Default = (int)*t1p;\n  timer1 = t1Default;\n\n  // These are the text boxes that display the name of\n  //  the timer the text field will be controlling.\n  SFM.drawText(40,80, \"Timer 1:\");\n\n  // These are the text fields that allow the user to input\n  //  a number to be used for the default value of each timer.\n  int temp = -1;\n  t1Input = SFM.drawTextField(100, 70, 50, temp);\n\n  // Define two buttons: one to get the values from flash and\n  //  populate the text fields, and one to store the values to\n  //  flash.\n  getValuesButton = SFM.drawButton(40,240,150, \"Get settings\");\n  updateButton = SFM.drawButton(40, 300, 150, \"Store settings\");\n  SFM.endScreen();\n}\n\n// This is a Simblee library function that handles events caused\n//  by objects in the UI. We have two types of events in this\n//  application: text field entry events and button events.\nvoid ui_event(event_t &event)\n{\n  // First, handle the text field entry events. These occur when\n  //  the \"enter\" key is pressed while the cursor is in a text\n  //  field.\n  if (event.id == t1Input)\n  {\n    t1Default = event.value;\n    Serial.println(event.value);\n  }\n\n  // Now, the update stored values button. This records\n  //  the values in the fields to flash memory so they\n  //  persist through power loss or reset.\n  if (event.id == updateButton)\n  {\n    int rc = flashPageErase(FLASH_PAGE);\n    Serial.println(rc);\n    rc = flashWrite(t1p, (unsigned long)t1Default);\n    Serial.println(*t1p);\n    timer1 = t1Default;\n  }\n\n  // This button fetches the current values and puts them\n  //  into the text fields.\n  if (event.id == getValuesButton)\n  {\n    SFM.updateValue(t1Input, timer1);\n  }\n}\n\n// Put the current intensity on each LED.\nvoid updateLEDs()\n{\n  RGB_Show(t1LEDVal,0,0,3);\n}\n```"]