<html><head></head><body>
<h2 class="h2" id="ch09"><span epub:type="pagebreak" id="page_259"/><span class="big"><strong>9</strong></span><br/><strong>EXTRACTING SUBSETS OF FORENSIC IMAGES</strong></h2>&#13;
<div class="imagef"><img src="../images/common-01.jpg" alt="image"/></div>&#13;
<p class="noindent">This chapter covers the selective extraction of data regions from an attached drive or a forensically acquired image file. You’ll learn to extract whole partitions, deleted or partially overwritten partitions, inter-partition gaps, and various volume and file slack areas. In addition, you’ll see how to extract special areas such as Unified Extensible Firmware Interface (UEFI) partitions, the sectors hidden by a DCO or HPA, and hibernation partitions such as Intel Rapid Start Technology.</p>&#13;
<p class="indent">The final sections demonstrate extraction of data from allocated and unallocated (possibly deleted) areas of the disk for further examination and manual extraction of sectors using offsets. Let’s begin with determining the partition layout of the drive.</p>&#13;
<h3 class="h3" id="ch09lev1sec01"><strong>Assess Partition Layout and Filesystems</strong></h3>&#13;
<p class="noindent">Once you’ve attached a disk to your system or have acquired an image file, you can perform an analysis of the disk partition scheme. This section explains how to identify filesystems, partition tables, and commonly used disk partition schemes.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_260"/>The disk layout, or <em>partition scheme</em>, refers to the method used to organize the <em>partitions</em> (or <em>slices</em>) on a hard disk. The most common partition schemes you’ll find in consumer computing are DOS, GPT, BSD, and APM (Apple Partition Map, sometimes called <em>mac</em>). We’ll start with identifying the partition scheme used on a disk.</p>&#13;
<h4 class="h4" id="ch09lev2sec01"><em><strong>Partition Scheme</strong></em></h4>&#13;
<p class="noindenta">Each partition or slice on a disk contains a separate filesystem or is used for some other special purpose. A small portion of the disk (often just the first sector) defines the layout of the disk by specifying the starting sector of each partition, the partition size, the partition type, labels, and so on.</p>&#13;
<p class="indent">To determine the disk partition scheme, you can examine the initial sectors of the disk for indicators. There is no official “Assigned Number” designation for partition schemes (there are only half a dozen or so). Don’t confuse this with DOS MBR partition types or IDs, which list up to 255 possible filesystems and other formats that could reside inside a DOS partition. When you attach the subject disk to a workstation, the Linux kernel will attempt to detect and interpret the partition scheme used, and it will create the devices for each partition it finds.</p>&#13;
<p class="indent">You can use the Sleuth Kit <span class="literal">mmstat</span> command to identify the most common partition schemes. A list of supported partition schemes is shown here:</p>&#13;
<p class="programs"># <strong>mmstat -t list</strong><br/>Supported partition types:<br/>        dos (DOS Partition Table)<br/>        mac (MAC Partition Map)<br/>        bsd (BSD Disk Label)<br/>        sun (Sun Volume Table of Contents (Solaris))<br/>        gpt (GUID Partition Table (EFI))</p>&#13;
<p class="indent">Running <span class="literal">mmstat</span> will output the name of the scheme used:</p>&#13;
<p class="programs"># <strong>mmstat image.raw</strong><br/>dos</p>&#13;
<p class="indent">Alternatively, you can use the disktype tool to identify the partition scheme. The disktype tool provides more verbose information and supports partitions, filesystems, and file and archive containers. The following example shows output from disktype:</p>&#13;
<p class="programs">$ <strong>sudo disktype /dev/sda</strong><br/><br/>--- /dev/sda<br/>Block device, size 27.96 GiB (30016659456 bytes)<br/>DOS/MBR partition map<br/>Partition 1: 27.95 GiB (30015610880 bytes, 58624240 sectors from 2048)<br/>  Type 0x83 (Linux)</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_261"/>You’ll find the original disktype software package at <em><a href="http://disktype.sourceforge.net/">http://disktype.sourceforge.net/</a></em>. Also, you’ll find a fork and multiple patches for disktype at <em><a href="https://github.com/kamwoods/disktype/">https://github.com/kamwoods/disktype/</a></em>, <em><a href="https://github.com/Pardus-Linux/Packages/tree/master/system/base/disktype/files/">https://github.com/Pardus-Linux/Packages/tree/master/system/base/disktype/files/</a></em>, and <em><a href="https://github.com/ericpaulbishop/gargoyle/tree/master/package/disktype/patches/">https://github.com/ericpaulbishop/gargoyle/tree/master/package/disktype/patches/</a></em>.</p>&#13;
<p class="indent">A storage medium does not require a partition table or even a filesystem. Binary data can be written directly to the raw disk and accessed by any program capable of understanding it (for example, some databases can directly use raw disks). It’s possible to have disks without partition schemes. In such cases, the filesystem starts at sector zero and continues to the end of the disk (that is, the whole disk is the partition). This is common with some older USB sticks and floppy disks. In such cases, partition analysis tools will be ineffective and generally report a false or nonexistent partition table. If a tool cannot detect a partition type, it’s worth checking whether a filesystem was written directly to a raw device. In this example, <span class="literal">mmstat</span> finds nothing, but <span class="literal">fsstat</span> does identify a filesystem:</p>&#13;
<p class="programs"># <strong>mmls /dev/sdj</strong><br/>Cannot determine partition type<br/># <strong>disktype /dev/sdj</strong><br/><br/>--- /dev/sdj<br/>Block device, size 1.406 MiB (1474560 bytes)<br/>FAT12 file system (hints score 5 of 5)<br/>  Volume size 1.390 MiB (1457664 bytes, 2847 clusters of 512 bytes)<br/><br/># <strong>mmstat /dev/sdj</strong><br/>Cannot determine partition type<br/># <strong>fsstat /dev/sdj</strong><br/>FILE SYSTEM INFORMATION<br/>--------------------------------------------<br/>File System Type: FAT12<br/>...</p>&#13;
<p class="indent">Some encrypted volumes attempt to hide their existence or information about the filesystem used, and they don’t use a recognizable partition scheme.</p>&#13;
<h4 class="h4" id="ch09lev2sec02"><em><strong>Partition Tables</strong></em></h4>&#13;
<p class="noindenta">A partition scheme will have a disk block or set of blocks describing how it’s organized. These are called <em>partition tables</em> (or <em>disklabels</em> for BSD systems), and you can query them using various tools.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_262"/>You can use the Sleuth Kit <span class="literal">mmls</span> command to list the partition tables on a disk or a forensically acquired image. In this example, <span class="literal">mmls</span> finds a regular DOS partition scheme with a FAT32 partition:</p>&#13;
<p class="programs"># <strong>mmls image.raw</strong><br/>DOS Partition Table<br/>Offset Sector: 0<br/>Units are in 512-byte sectors<br/><br/>     Slot    Start        End          Length       Description<br/>00:  Meta    0000000000   0000000000   0000000001   Primary Table (#0)<br/>01:  -----   0000000000   0000000062   0000000063   Unallocated<br/>02:  00:00   0000000063   0005028344   0005028282   Win95 FAT32 (0x0b)<br/>03:  -----   0005028345   0005033951   0000005607   Unallocated</p>&#13;
<p class="indent">The traditional DOS partition scheme is not able to handle disks larger than 2TB. The GPT partition scheme was created to allow larger disks to be organized with a greater number of partitions. GPT supports 128 partitions compared to the 4 that DOS supports (not counting extended partitions). I have written a paper on the forensic analysis of GPT disks and GUID partition tables; you can find it here: <em><a href="http://dx.doi.org/10.1016/j.diin.2009.07.001">http://dx.doi.org/10.1016/j.diin.2009.07.001</a></em>.</p>&#13;
<p class="indent">Most new PC systems are being shipped with GPT partitions today. An example of a Windows 8 system’s partition table is shown here:</p>&#13;
<p class="programs"># <strong>mmls lenovo.raw</strong><br/>GUID Partition Table (EFI)<br/>Offset Sector: 0<br/>Units are in 512-byte sectors<br/><br/>     Slot    Start        End          Length       Description<br/>00:  Meta    0000000000   0000000000   0000000001   Safety Table<br/>01:  -----   0000000000   0000002047   0000002048   Unallocated<br/>02:  Meta    0000000001   0000000001   0000000001   GPT Header<br/>03:  Meta    0000000002   0000000033   0000000032   Partition Table<br/>04:  00      0000002048   0002050047   0002048000<br/>05:  01      0002050048   0002582527   0000532480   EFI system partition<br/>06:  02      0002582528   0003606527   0001024000<br/>07:  03      0003606528   0003868671   0000262144   Microsoft reserved partition<br/>08:  04      0003868672   1902323711   1898455040   Basic data partition<br/>09:  05      1902323712   1953523711   0051200000</p>&#13;
<p class="indent">Gary Kessler provides several partition table–parsing tools that provide much greater detail. You’ll find these tools at <em><a href="http://www.garykessler.net/software/index.html">http://www.garykessler.net/software/index.html</a></em>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_263"/>To illustrate the level of detail Kessler’s parsing tools provide, here is partial output from the partition table from the preceding example generated using the gptparser.pl tool:</p>&#13;
<p class="programs">$ <strong>gptparser.pl -i lenovo.raw</strong><br/><br/>GPT Parser V1.4 beta - Gary C. Kessler (14 March 2013)<br/><br/>Source file = /exam/lenovo.raw<br/>Input file length = 17408 bytes.<br/><br/>***** LBA 0: Protective/Legacy MBR *****<br/><br/>000:  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................<br/>016:  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................<br/>...<br/>=== Partition Table #5 (LBA 3, bytes 0:127) ===<br/>000-015  Partition type GUID: 0xA2-A0-D0-EB-E5-B9-33-44-87-C0-68-B6-B7-26-99-C7<br/>         GUID: EBD0A0A2-B9E5-4433-87C0-68B6B72699C7<br/>         Type: Data partition (Linux *or* Windows)<br/>016-031  Partition GUID: 0x64-12-FF-80-A7-F7-72-42-B6-46-25-33-6D-96-13-B5<br/>         GUID: 80FF1264-F7A7-4272-B646-25336D9613B5<br/>032-039  First LBA: 0x00-08-3B-00-00-00-00-00 [3,868,672]<br/>040-047  Last LBA: 0xFF-27-63-71-00-00-00-00 [1,902,323,711]<br/>048-055  Partition attributes: 0x00-00-00-00-00-00-00-00<br/>056-127  Partition name --<br/>056:  42 00 61 00 73 00 69 00 63 00 20 00 64 00 61 00   B.a.s.i.c. .d.a.<br/>072:  74 00 61 00 20 00 70 00 61 00 72 00 74 00 69 00   t.a. .p.a.r.t.i.<br/>088:  74 00 69 00 6F 00 6E 00 00 00 00 00 00 00 00 00   t.i.o.n.........<br/>104:  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................<br/>120:  00 00 00 00 00 00 00 00                           ........<br/>      Name: Basic data partition<br/>...</p>&#13;
<p class="indent">The tool provides detailed information about each of the 128 GPT partitions.</p>&#13;
<h4 class="h4" id="ch09lev2sec03"><em><strong>Filesystem Identification</strong></em></h4>&#13;
<p class="noindenta">The disktype tool, already presented in “<a href="ch09.xhtml#ch09lev2sec01">Partition Scheme</a>” on <a href="ch09.xhtml#page_260">page 260</a>, allows you to identify partition schemes and filesystems within partitions. The Sleuth Kit fsstat tool provides more comprehensive information about a filesystem. The fsstat tool can operate directly on a partition device or on a forensically acquired image if you specify the sector offset.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_264"/>In the previous examples, the sector offset of a Windows volume on the <em>lenovo.raw</em> image file was 3868672. You can provide this sector offset to the fssstat tool using the <span class="literal">-o</span> flag to analyze the filesystem metadata:</p>&#13;
<p class="programs"># <strong>fsstat -o 3868672 lenovo.raw</strong><br/>FILE SYSTEM INFORMATION<br/>--------------------------------------------<br/>File System Type: NTFS<br/>Volume Serial Number: 4038B39F38B39300<br/>OEM Name: NTFS<br/>Volume Name: Windows8_OS<br/>Version: Windows XP<br/><br/>METADATA INFORMATION<br/>--------------------------------------------<br/>First Cluster of MFT: 786432<br/>...</p>&#13;
<p class="indent">If the drive is directly attached to your workstation, the Linux kernel will attempt to parse the partition table and make the disk and partition devices available in <em>/dev</em>, where you can access them directly.</p>&#13;
<p class="indent">However, if you’re examining a raw image file (<em>.raw</em>, <em>.ewf</em>, and so on), there will be no device files for the image. The kernel will not interpret the partition table and will not create the familiar partition devices (<em>/dev/sda1</em>, <em>/dev/sda2</em>, and so on). You must specify an offset when accessing a partition within an image file.</p>&#13;
<p class="indent">It’s better to rely on forensic tools to determine the partition details rather than to trust the kernel. If a disk is corrupt or damaged, the kernel might refuse to create the partition devices or create the wrong ones. The examples you saw in this section always specified an offset rather than using the kernel. In situations that involve malware, antiforensics, or other malicious misdirection, using forensic tools instead of the kernel should take precedence.</p>&#13;
<h3 class="h3" id="ch09lev1sec02"><strong>Partition Extraction</strong></h3>&#13;
<p class="noindent">This section describes the extraction of individual partitions, inter-partition gaps, and other areas of the disk like the DCO and HPA. Let’s begin with some basic examples of extracting regular partitions.</p>&#13;
<h4 class="h4" id="ch09lev2sec04"><em><strong>Extract Individual Partitions</strong></em></h4>&#13;
<p class="noindenta">To access and extract individual partitions rather than the entire hard disk, you can use several techniques. I’ll demonstrate a few examples of partition extraction using a directly attached drive with a partition device, a partition mapper device, and image files operated on by Sleuth Kit’s mmcat- and dd-style tools.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_265"/>If a disk is accessible as an attached device, acquiring the partition is similar to performing a full acquisition with a raw drive device but uses the partition device instead. In the following example, the first partition of <em>/dev/sda</em> is extracted to a file:</p>&#13;
<p class="programs"># <strong>dcfldd if=/dev/sda1 of=partition.raw</strong></p>&#13;
<p class="indent">Extracting partitions requires some capacity planning, because the partition will consume disk space (possibly alongside the full drive image). If you need only temporary access to a partition from an acquired image file, you can attach it as a loop device and access it. The following steps demonstrate this method.</p>&#13;
<p class="indent">First, use the mmls tool to identify the partition to be attached as a loop, as follows:</p>&#13;
<p class="programs"># <strong>mmls lenovo.raw</strong><br/>GUID Partition Table (EFI)<br/>Offset Sector: 0<br/>Units are in 512-byte sectors<br/>...<br/>05:  01      0002050048   0002582527   0000532480   EFI system partition<br/>...</p>&#13;
<p class="indent">Then use Bash math expansion to convert the sector offset and sector length into a byte offset and byte length:</p>&#13;
<p class="programs"># <strong>echo $((2050048*512))</strong><br/>1049624576<br/># <strong>echo $((532480*512))</strong><br/>272629760</p>&#13;
<p class="indent">The calculated byte offset and byte length are then passed to losetup to create a loop device, as follows:</p>&#13;
<p class="programs"># <strong>losetup --read-only --find --show --offset 1049624576 --sizelimit 272629760</strong><br/>    <strong>lenovo.raw</strong><br/>/dev/loop2</p>&#13;
<p class="indent">You can access this resulting loop device using forensic tools in the same way as you access the partition device of an attached disk. An example using Sleuth Kit fls is shown here:</p>&#13;
<p class="programs"># <strong>fls /dev/loop2</strong><br/>r/r 3:  SYSTEM_DRV (Volume Label Entry)<br/>d/d 4:  EFI<br/>d/d 5:  BOOT<br/>d/d * 7:        MSIa11f8.tmp<br/>d/d * 8:        _SI2DBB4.TMP<br/>d/d * 9:        _190875_<br/>...</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_266"/>If you need to extract a partition from an existing acquired image into a separate file, you can use the dd tools or the Sleuth Kit <span class="literal">mmcat</span> command.</p>&#13;
<p class="indent">To extract a partition from an acquired image, the initial step is to identify the partition and sector details. In the following example, the partition table from an acquired disk image shows the partition to be extracted:</p>&#13;
<p class="programs"># <strong>mmls image.raw</strong><br/>DOS Partition Table<br/>Offset Sector: 0<br/>Units are in 512-byte sectors<br/><br/>     Slot    Start        End          Length       Description<br/>...<br/>02:  00:00   0000000063   0078124094   0078124032   Linux (0x83)<br/>...</p>&#13;
<p class="indent">Extracting a partition from an already acquired image file using dcfldd or dd requires adding <span class="literal">skip</span> (dc3dd uses <span class="literal">iskip</span>) and <span class="literal">count</span> parameters, which cause the command to jump (skip) ahead to the start of the partition and acquire only the size of the partition:</p>&#13;
<p class="programs">$ <strong>dcfldd if=image.raw of=partition.raw bs=512 skip=63 count=78124032</strong></p>&#13;
<p class="indent">In this command, the block size is set to 512 bytes to match the sector size, the start of the partition is at sector 63, and 78124032 sectors should be extracted. With a little additional calculation, you can improve the performance of this command by changing the 512-byte block size to something larger (but don’t forget to adjust the <span class="literal">skip</span> and <span class="literal">count</span> parameters if you do this).</p>&#13;
<p class="indent">With Sleuth Kit version 3.0 and later, you can use the mmcat tool to easily extract partitions. To recover the first partition in the previous example using mmcat, you must specify the mmls slot number (not the DOS partition number). In this case, the first partition is located in the mmls slot number two and can be extracted as follows:</p>&#13;
<p class="programs">$ <strong>mmcat image.raw 2 &gt; partition.raw</strong></p>&#13;
<p class="indent">The mmcat tool simply pipes the output to stdout, so you must either redirect it to a file or pipe it into a program.</p>&#13;
<h4 class="h4" id="ch09lev2sec05"><em><strong>Find and Extract Deleted Partitions</strong></em></h4>&#13;
<p class="noindenta">To exhaustively search for partially overwritten or deleted partitions of a forensically acquired image, you can use several methods. Sleuth Kit provides a basic tool called sigfind to search for binary signature strings. Two <span epub:type="pagebreak" id="page_267"/>useful tools for comprehensive partition searching are gpart and testdisk. These tools implement filesystem recognition algorithms with more intelligent guessing to identify lost partitions.</p>&#13;
<p class="indent">Running gpart without any options starts a scan for partitions, skipping over areas identified as allocated. For example:</p>&#13;
<p class="programs"># <strong>gpart lenovo.raw</strong><br/><br/>Begin scan...<br/>Possible partition(Windows NT/W2K FS), size(1000mb), offset(1mb)<br/>Possible partition(Windows NT/W2K FS), size(3mb), offset(1030mb)<br/>Possible partition(Windows NT/W2K FS), size(3mb), offset(1494mb)<br/>Possible partition(Windows NT/W2K FS), size(926980mb), offset(1889mb)<br/>Possible partition(Windows NT/W2K FS), size(25000mb), offset(928869mb)<br/>End scan.<br/>...<br/>Guessed primary partition table:<br/>Primary partition(1)<br/>   type: 007(0x07)(OS/2 HPFS, NTFS, QNX or Advanced UNIX)<br/>   size: 1000mb #s(2048000) s(2048-2050047)<br/>   chs:  (0/32/33)-(406/60/28)d (0/32/33)-(406/60/28)r<br/>...</p>&#13;
<p class="indent">Adding a <span class="literal">-f</span> flag tells gpart to be exhaustive, looking for partitions in every sector of the entire disk, even in areas where no partitions are expected to be found. This will take much longer than the default gpart scan without flags.</p>&#13;
<p class="indent">The testdisk tool (<em><a href="http://www.cgsecurity.org/">http://www.cgsecurity.org/</a></em>, written by Christophe Grenier, who also wrote the photorec carving tool) provides several features in addition to partition searching. Testdisk provides an interactive interface, supports multiple disk layouts (DOS, GPT, BSD, and more), detects several dozen partition types, generates activity logs, and can extract discovered partitions to a file. You can use testdisk on devices, raw image files, and even <em>*.e01</em> files.</p>&#13;
<p class="indent">Use the testdisk tool with caution. This tool was designed for repairing and recovering partitions, and it could easily modify evidence. Be sure to use a write blocker before running this tool on attached subject disks.</p>&#13;
<p class="indent">Also included with the tool is a comprehensive user interactive menu system to define options and activities. Shown here is a batch mode example operating on an attached disk:</p>&#13;
<p class="programs"># <strong>testdisk /list /dev/sdb</strong><br/>TestDisk 7.0, Data Recovery Utility, April 2015<br/>Christophe GRENIER &lt;grenier@cgsecurity.org&gt;<br/>http://www.cgsecurity.org<br/>Please wait...<br/>Disk /dev/sdb - 15 GB / 14 GiB - CHS 14663 64 32<br/>Sector size:512<br/>Model: SanDisk Ultra Fit, FW:1.00<br/><br/>Disk /dev/sdb - 15 GB / 14 GiB - CHS 14663 64 32<br/>     Partition                  Start        End    Size in sectors<br/> 1 P FAT32 LBA                0   1  1 14663  44 18   30031218 [NO NAME]<br/>     FAT32, blocksize=16384</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_268"/>You can perform a certain amount of manual analysis to search for deleted partitions. If the partition table shows a large area of unallocated space on a disk, check this area to determine whether a partition exists. In the following example, mmls shows nearly 2.5GB (4863378 sectors) of empty space at the end of a thumb drive:</p>&#13;
<p class="programs"># <strong>mmls /dev/sdb</strong><br/>DOS Partition Table<br/>Offset Sector: 0<br/>Units are in 512-byte sectors<br/><br/>      Slot      Start        End          Length       Description<br/>000:  Meta      0000000000   0000000000   0000000001   Primary Table (#0)<br/>001:  -------   0000000000   0000002047   0000002048   Unallocated<br/>002:  000:000   0000002048   0025167871   0025165824   Win95 FAT32 (0x0c)<br/>003:  -------   0025167872   0030031249   0004863378   Unallocated</p>&#13;
<p class="indent">This unallocated space could be a deleted partition. In this example, running fsstat using the offset of the empty space discovers a valid filesystem:</p>&#13;
<p class="programs"># <strong>fsstat -o 25167872 /dev/sdb</strong><br/>FILE SYSTEM INFORMATION<br/>--------------------------------------------<br/>File System Type: Ext3<br/>Volume Name:<br/>Volume ID: 74a2f1b777ae52bc9748c3dbca837a80<br/><br/>Last Written at: 2016-05-21 15:42:54 (CEST)<br/>Last Checked at: 2016-05-21 15:42:54 (CEST)<br/>...</p>&#13;
<p class="indent">If you detect a valid filesystem, you can use the meta information about it to determine the probable size of the partition. Knowing the size and starting offset, you can extract the discovered partition or further analyze it. You can extract it using dd-style tools or more easily with mmcat, like this:</p>&#13;
<p class="programs"># <strong>mmcat /dev/sdb 3 &gt; deleted_partition.raw</strong></p>&#13;
<p class="indent">Here, the mmcat output of the deleted partition discovered in mmls slot 003 is sent to a file called <em>deleted_partition.raw</em>.</p>&#13;
<h4 class="h4" id="ch09lev2sec06"><span epub:type="pagebreak" id="page_269"/><em><strong>Identify and Extract Inter-Partition Gaps</strong></em></h4>&#13;
<p class="noindenta">In some cases, there may be gaps between partitions that were created accidentally or due to adjacent partitions meeting on cylinder or block boundaries. There could also be intentional gaps that were created for hiding data. You can identify and recover these inter-partition gaps in the same way as you extract a partition. Use mmls to determine the size and sector offset of the gap, and then use dd or mmcat to extract it.</p>&#13;
<p class="indent">The mmls output of a partition table is shown here. The disk contains two partitions, and there is a gap between them:</p>&#13;
<p class="programs"># <strong>mmls /dev/sdb</strong><br/>DOS Partition Table<br/>Offset Sector: 0<br/>Units are in 512-byte sectors<br/><br/>      Slot      Start        End          Length       Description<br/>000:  Meta      0000000000   0000000000   0000000001   Primary Table (#0)<br/>001:  -------   0000000000   0000002047   0000002048   Unallocated<br/>002:  000:000   0000002048   0015626236   0015624189   Linux (0x83)<br/>003:  -------   0015626237   0015626239   0000000003   Unallocated<br/>004:  000:001   0015626240   0030031249   0014405010   Linux (0x83)</p>&#13;
<p class="indent">In this example, the first partition ends on sector 15626236, but the adjacent partition starts on sector 15626240, indicating a three-sector gap between them. Although you can extract this inter-partition gap using dd, using mmcat is simpler:</p>&#13;
<p class="programs"># <strong>mmcat /dev/sdb 3 &gt; gap.raw</strong><br/># <strong>ls -l gap.raw</strong><br/>-rw-r----- 1 root root 1536 May 21 16:11 gap.raw</p>&#13;
<p class="indent">The resulting file is three sectors in size with the contents of the gap between the two partitions. Larger gaps between partitions that contain partially overwritten, corrupted, or identifiable filesystem fragments can be analyzed with carving tools such as foremost.</p>&#13;
<p class="indent">The gap between the last partition and the end of a disk can also be of interest. It may contain artifacts such as content from previously overwritten partitions, backup copies of the GPT partition, or even malware attempting to hide segments of binary code.</p>&#13;
<h4 class="h4" id="ch09lev2sec07"><em><strong>Extract HPA and DCO Sector Ranges</strong></em></h4>&#13;
<p class="noindenta">You have already learned how to identify and remove HPA and DCO restrictions. Once removed, these areas of the disk can be extracted for separate analysis.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_270"/>In this example, hdparm shows that an HPA exists, and the mmls output shows three slots, one of them being a Linux partition:</p>&#13;
<p class="programs"># <strong>hdparm -N /dev/sdh</strong><br/><br/>/dev/sdh:<br/> max sectors   = 234441648/976773168, HPA is enabled<br/># <strong>mmls /dev/sdh</strong><br/>DOS Partition Table<br/>Offset Sector: 0<br/>Units are in 512-byte sectors<br/><br/>     Slot    Start        End          Length       Description<br/>00:  Meta    0000000000   0000000000   0000000001   Primary Table (#0)<br/>01:  -----   0000000000   0000002047   0000002048   Unallocated<br/>02:  00:00   0000002048   0234441647   0234439600   Linux (0x83)</p>&#13;
<p class="indent">After you successfully remove the HPA (and tell the kernel to rescan the SCSI bus), running the same commands again produces different output, as shown here:</p>&#13;
<p class="programs"># <strong>hdparm -N p976773168 /dev/sdh</strong><br/><br/>/dev/sdh:<br/> setting max visible sectors to 976773168 (permanent)<br/> max sectors   = 976773168/976773168, HPA is disabled<br/># <strong>mmls /dev/sdh</strong><br/>DOS Partition Table<br/>Offset Sector: 0<br/>Units are in 512-byte sectors<br/><br/>     Slot    Start        End          Length       Description<br/>00:  Meta    0000000000   0000000000   0000000001   Primary Table (#0)<br/>01:  -----   0000000000   0000002047   0000002048   Unallocated<br/>02:  00:00   0000002048   0234441647   0234439600   Linux (0x83)<br/>03:  -----   0234441648   0976773167   0742331520   Unallocated</p>&#13;
<p class="indent">Now, hdparm indicates the HPA is disabled, and the mmls output shows an additional line of output (slot 03) representing the sectors previously hidden by the HPA.</p>&#13;
<p class="indent">Using the <span class="literal">mmcat</span> command with partition slot 03 will extract the data from HPA, as follows:</p>&#13;
<p class="programs"># <strong>mmcat /dev/sdh 3 &gt; hpa.raw</strong></p>&#13;
<p class="indent">This example uses a live disk attached to an acquisition host. When an image file is acquired from a disk with the HPA removed, mmls will see this hidden region.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_271"/>Extracting sectors hidden by a DCO is identical to the method shown here with the HPA. First use hdparm to expose the DCO-protected sectors, and then extract them using dd or mmcat. This procedure does not need to be repeated with additional examples specifically demonstrating sectors from a DCO.</p>&#13;
<h3 class="h3" id="ch09lev1sec03"><strong>Other Piecewise Data Extraction</strong></h3>&#13;
<p class="noindent">In this final section, I describe various additional examples of piecewise data extraction. The contents of this section (in fact the contents of most of this chapter) blur together slightly with forensic filesystem analysis, which is not the intended scope of the book. For this reason, the examples are slightly less descriptive.</p>&#13;
<h4 class="h4" id="ch09lev2sec08"><em><strong>Extract Filesystem Slack Space</strong></em></h4>&#13;
<p class="noindenta"><em>Slack space</em> is a traditional digital forensics concept referring to allocated but unused data at the end of disk sectors, filesystem blocks, or filesystems (RAM slack, file slack, and partition slack, respectively).</p>&#13;
<p class="indent">To visualize slack space, imagine this book as a hard disk, where paragraphs are sectors, chapters are files, and body of the text is the partition. Notice that paragraphs don’t finish exactly at the end of a line, chapters don’t finish exactly at the end of a page, and the end of the book might have a couple of additional blank pages. These empty spaces are the book’s “slack space.” With storage media, if the OS or physical drive has not explicitly written zeros to these areas, they might still contain data from previously written files.</p>&#13;
<p class="indentb">Historically, extracting and analyzing slack space has been useful in forensic investigations. However, the value of slack space is beginning to decrease due to several factors:</p>&#13;
<p class="bull">• SSDs are using TRIM commands to zero unallocated blocks.</p>&#13;
<p class="bull">• Modern OSes are writing back zeros to unused portions of sectors and blocks.</p>&#13;
<p class="bull">• Disks with native 4K sectors align with filesystem block sizes.</p>&#13;
<p class="bull">• OSes create partitions and filesystems aligned to block boundaries.</p>&#13;
<p class="indentt">As part of the forensic process, acquiring and analyzing potential slack areas are still diligent steps to complete.</p>&#13;
<p class="indent">To extract all slack space on a given image, you can use the Sleuth Kit <span class="literal">blkls</span> command. Slack space is filesystem specific, so you must extract slack space on each filesystem separately (you can’t just use the entire raw disk). In this example, the filesystem offsets of the acquired image are found with mmls, and the slack space of each one is extracted:</p>&#13;
<p class="programs"># <strong>mmls lenovo.raw</strong><br/>GUID Partition Table (EFI)<br/>Offset Sector: 0<br/>Units are in 512-byte sectors<br/><br/>     Slot    Start        End          Length       Description<br/>04:  00      0000002048   0002050047   0002048000<br/>05:  01      0002050048   0002582527   0000532480   EFI system partition<br/>06:  02      0002582528   0003606527   0001024000<br/>...<br/>08:  04      0003868672   1902323711   1898455040   Basic data partition<br/>...<br/># <strong>blkls -o 2048 -s lenovo.raw &gt; slack.04</strong><br/># <strong>blkls -o 2050048 -s lenovo.raw &gt; slack.05</strong><br/># <strong>blkls -o 2582528 -s lenovo.raw &gt; slack.06</strong><br/># <strong>blkls -o 3868672 -s lenovo.raw &gt; slack.08</strong></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_272"/>The slack space for each recognized filesystem is saved to a file. The <span class="literal">blkls</span> command’s <span class="literal">-s</span> flag extracts all slack space (and only slack space). It is important to understand that slack space does not refer to unallocated blocks or sectors. Slack space is the unused area found within <em>allocated</em> blocks and sectors of a filesystem.</p>&#13;
<h4 class="h4" id="ch09lev2sec09"><em><strong>Extract Filesystem Unallocated Blocks</strong></em></h4>&#13;
<p class="noindenta">This next example will gather all unallocated blocks from filesystems on an acquired image. Unallocated blocks are filesystem specific, so you need to perform this operation separately on each recognized filesystem.</p>&#13;
<p class="indent">Here, the <span class="literal">mmls</span> command is again used to determine the offsets of each filesystem, and the <span class="literal">blkls</span> command is used to extract unallocated blocks:</p>&#13;
<p class="programs"># <strong>blkls -o 2048 lenovo.raw &gt; unalloc.04</strong><br/># <strong>blkls -o 2050048 lenovo.raw &gt; unalloc.05</strong><br/># <strong>blkls -o 2582528 lenovo.raw &gt; unalloc.06</strong><br/># <strong>blkls -o 3868672 lenovo.raw &gt; unalloc.08</strong></p>&#13;
<p class="indent">The correct <span class="literal">blkls</span> flag for extracting unallocated blocks is <span class="literal">-A</span>, but because it’s the default command behavior, you can omit it.</p>&#13;
<p class="indent">You can also perform the inverse action of extracting all (and only) allocated blocks using the <span class="literal">blkls -a</span> command.</p>&#13;
<h4 class="h4" id="ch09lev2sec10"><em><strong>Manual Extraction Using Offsets</strong></em></h4>&#13;
<p class="noindenta">In certain situations, you might use a hex editor to browse, search, or manually analyze the contents of a disk or acquired disk image. The hex editor may provide a byte offset, a sector offset, or both.</p>&#13;
<p class="indent">This example uses the console-based hexedit tool to analyze a disk:</p>&#13;
<p class="programs"># <strong>hexedit -s /dev/sda</strong></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_273"/>The hexedit tool allows you to directly edit block device files and edit very large image files (no loading in memory or temp files), and it provides a sector mode (entire sectors and sector offsets are shown).</p>&#13;
<p class="indent">In the following example, the sector offset is 2048 (the start of an NTFS partition), the byte offset is 0x100181, and the entire sector is shown (note: hexedit assumes 512-byte sectors):</p>&#13;
<p class="programs">00100000   EB 52 90 4E 54 46 53 20  20 20 20 00 02 08 00 00  .R.NTFS    .....<br/>00100010   00 00 00 00 00 F8 00 00  3F 00 FF 00 00 08 00 00  ........?.......<br/>00100020   00 00 00 00 80 00 80 00  01 48 00 00 00 00 00 00  .........H......<br/>00100030   04 00 00 00 00 00 00 00  80 04 00 00 00 00 00 00  ................<br/>00100040   F6 00 00 00 01 00 00 00  22 90 FD 7E 2E 42 12 09  ........"..~.B..<br/>00100050   00 00 00 00 FA 33 C0 8E  D0 BC 00 7C FB 68 C0 07  .....3.....|.h..<br/>00100060   1F 1E 68 66 00 CB 88 16  0E 00 66 81 3E 03 00 4E  ..hf......f.&gt;..N<br/>00100070   54 46 53 75 15 B4 41 BB  AA 55 CD 13 72 0C 81 FB  TFSu..A..U..r...<br/>00100080   55 AA 75 06 F7 C1 01 00  75 03 E9 D2 00 1E 83 EC  U.u.....u.......<br/>00100090   18 68 1A 00 B4 48 8A 16  0E 00 8B F4 16 1F CD 13  .h...H..........<br/>001000A0   9F 83 C4 18 9E 58 1F 72  E1 3B 06 0B 00 75 DB A3  .....X.r.;...u..<br/>001000B0   0F 00 C1 2E 0F 00 04 1E  5A 33 DB B9 00 20 2B C8  ........Z3... +.<br/>001000C0   66 FF 06 11 00 03 16 0F  00 8E C2 FF 06 16 00 E8  f...............<br/>001000D0   40 00 2B C8 77 EF B8 00  BB CD 1A 66 23 C0 75 2D  @.+.w......f#.u-<br/>001000E0   66 81 FB 54 43 50 41 75  24 81 F9 02 01 72 1E 16  f..TCPAu$....r..<br/>001000F0   68 07 BB 16 68 70 0E 16  68 09 00 66 53 66 53 66  h...hp..h..fSfSf<br/>00100100   55 16 16 16 68 B8 01 66  61 0E 07 CD 1A E9 6A 01  U...h..fa.....j.<br/>00100110   90 90 66 60 1E 06 66 A1  11 00 66 03 06 1C 00 1E  ..f`..f...f.....<br/>00100120   66 68 00 00 00 00 66 50  06 53 68 01 00 68 10 00  fh....fP.Sh..h..<br/>00100130   B4 42 8A 16 0E 00 16 1F  8B F4 CD 13 66 59 5B 5A  .B..........fY[Z<br/>00100140   66 59 66 59 1F 0F 82 16  00 66 FF 06 11 00 03 16  fYfY.....f......<br/>00100150   0F 00 8E C2 FF 0E 16 00  75 BC 07 1F 66 61 C3 A0  ........u...fa..<br/>00100160   F8 01 E8 08 00 A0 FB 01  E8 02 00 EB FE B4 01 8B  ................<br/>00100170   F0 AC 3C 00 74 09 B4 0E  BB 07 00 CD 10 EB F2 C3  ..&lt;.t...........<br/>00100180   0D 0A 41 20 64 69 73 6B  20 72 65 61 64 20 65 72  ..A disk read er<br/>00100190   72 6F 72 20 6F 63 63 75  72 72 65 64 00 0D 0A 42  ror occurred...B<br/>001001A0   4F 4F 54 4D 47 52 20 69  73 20 6D 69 73 73 69 6E  OOTMGR is missin<br/>001001B0   67 00 0D 0A 42 4F 4F 54  4D 47 52 20 69 73 20 63  g...BOOTMGR is c<br/>001001C0   6F 6D 70 72 65 73 73 65  64 00 0D 0A 50 72 65 73  ompressed...Pres<br/>001001D0   73 20 43 74 72 6C 2B 41  6C 74 2B 44 65 6C 20 74  s Ctrl+Alt+Del t<br/>001001E0   6F 20 72 65 73 74 61 72  74 0D 0A 00 00 00 00 00  o restart.......<br/>001001F0   00 00 00 00 00 00 00 00  80 9D B2 CA 00 00 55 AA  ..............U.<br/><br/>---  sda       --0x100181/0x6FD21E000--sector 2048---------------------------</p>&#13;
<p class="indent">From the byte or sector offset, you can construct dd commands to extract what was found within the hex editor.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_274"/>The following example uses a sector size of 512, a sector offset, and a sector count to extract a range of data (four 512-byte sectors) from an image:</p>&#13;
<p class="programs"># <strong>dd if=/dev/sda of=sectors.raw skip=2048 bs=512 count=4</strong></p>&#13;
<p class="indent">The next example extracts the same range of data using byte offsets. The <span class="literal">skip</span> command uses Bash math expansion to convert hexadecimal into decimal, which is needed for <span class="literal">dd</span>; the block size is 1 byte; and the count is the number of bytes required.</p>&#13;
<p class="programs"># <strong>dd if=/dev/sda of=bytes.raw skip=$((0x100000)) bs=1 count=2048</strong></p>&#13;
<p class="indent">The two previous examples extract the same block (four sectors or 2048 bytes) of data. Note that when extracting regions of a disk, it is sensible to ensure you have sector- or block-aligned offsets (that is, multiples of the sector size or block size).</p>&#13;
<p class="indent">In cases in which you need to extract a range of filesystem blocks, use the Sleuth Kit <span class="literal">blkcat</span> command. The following example extracts 25 blocks from a filesystem starting at block 100:</p>&#13;
<p class="programs"># <strong>blkcat /dev/sda1 100 25 &gt; blocks.raw</strong></p>&#13;
<p class="indent">The filesystem block size should be detected by the tool.</p>&#13;
<p class="indent">The examples in this final section showed how you can access images; use offsets; and extract a range of bytes, sectors, or blocks. You can also use other Sleuth Kit commands to map sectors to blocks and map blocks to inodes and filenames. These tasks are filesystem specific and move into the realm of filesystem forensic analysis.</p>&#13;
<h3 class="h3" id="ch09lev1sec04"><strong>Closing Thoughts</strong></h3>&#13;
<p class="noindent">In this final chapter, you learned how to extract subsets of drives and forensic images. The chapter focused on extracting various portions of an image such as sectors hidden by an HPA or DCO, deleted partitions, and inter-partition gaps. You also saw the manual extraction of specified sectors and blocks, including unallocated blocks and slack space. This chapter bordered on forensic analysis, as it looked at identifying partition schemes, understanding partition tables, and identifying filesystems. Since this book is about forensic acquisition and not forensic analysis, it is a fitting final chapter.</p>&#13;
</body></html>