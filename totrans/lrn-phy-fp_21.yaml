- en: '19'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '19'
- en: INTERACTING PARTICLES
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 相互作用粒子
- en: '![Image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common.jpg)'
- en: 'In Newtonian mechanics, forces that act on particles are produced by other
    particles. The goal of this chapter is to develop the key ideas that will allow
    us to predict the motion of multiple interacting particles: Newton’s third law,
    the two-body force, and the distinction between internal and external forces.
    As usual, we’ll express these ideas in code.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在牛顿力学中，作用于粒子的力是由其他粒子产生的。本章的目标是发展出关键的概念，使我们能够预测多个相互作用粒子的运动：牛顿第三定律、两体力，以及内部力与外部力的区别。像往常一样，我们将通过代码来表达这些概念。
- en: We’ll begin the chapter by discussing Newton’s third law. We’ll then develop
    the idea of a two-body force to express the notion that an interaction between
    two particles leads to one force produced by one particle on a second particle
    and simultaneously leads to another force produced by the second particle on the
    first particle. Two-body force is a significant enough idea in multi-particle
    situations that we’ll define a data type for two-body force. We’ll decide which
    particles are going to be in our system and then distinguish between an internal
    force and an external force. We’ll finish the chapter by considering the state
    of a multi-particle system and writing a state-update rule that automatically
    applies Newton’s third law, so we need not apply it manually. In the next chapter,
    we’ll apply the ideas discussed here to specific example situations.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过讨论牛顿第三定律来开始这一章。接着，我们将发展两体力的概念，来表达两个粒子之间的相互作用导致一个粒子对第二个粒子施加一个力，并同时导致第二个粒子对第一个粒子施加另一个力。两体力在多粒子情况中是一个足够重要的概念，因此我们将为两体力定义一种数据类型。我们将决定哪些粒子将出现在我们的系统中，并区分内部力和外部力。最后，我们将通过考虑多粒子系统的状态并编写一个状态更新规则来结束这一章，这个规则会自动应用牛顿第三定律，这样我们就不需要手动应用它了。在下一章中，我们将把这里讨论的概念应用到具体的例子情境中。
- en: Newton’s Third Law
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 牛顿第三定律
- en: If we stand on slippery ice and push our friend, we might find ourselves accelerating
    in the direction opposite from the way we pushed. We produced a force on our friend,
    but our friend also produced a force on us, whether or not that was their intention.
    Newton’s third law claims that these two forces are equal and opposite.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们站在滑冰场上并推我们的朋友，我们可能会发现自己会朝着与推的方向相反的方向加速。我们对朋友施加了一个力，但我们的朋友也对我们施加了一个力，不管他们是否有这个意图。牛顿第三定律声称这两个力是相等且方向相反的。
- en: '**Newton’s third law, Newton’s words [**[15](bib.xhtml#bib15)**]**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**牛顿第三定律，牛顿的原话 [**[15](bib.xhtml#bib15)**]**'
- en: '*To any action there is always an opposite and equal reaction; in other words,
    the actions of two bodies upon each other are always equal and always opposite
    in direction.*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何动作都会有一个相反且相等的反应；换句话说，两个物体之间的相互作用总是相等的，并且方向总是相反的。*'
- en: '**Newton’s third law, modern version**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**牛顿第三定律，现代版本**'
- en: '*If object A exerts a force on object B, then object B exerts a force on object
    A. This second force is equal in magnitude to the first force, but opposite in
    direction.*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果物体 A 对物体 B 施加一个力，那么物体 B 对物体 A 施加一个力。这个第二个力的大小与第一个力相等，但方向相反。*'
- en: When we say the *second* force, we’re not implying an order in time. The forces
    arise together, from the same process, whatever the interaction between the objects
    is.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说*第二*个力时，并不意味着时间上的顺序。这些力是一起产生的，来自于同一个过程，不管物体之间的相互作用是什么。
- en: When dealing with Newton’s second law, as we did in the previous five chapters,
    we’re only concerned with the forces that act *on* the object we’re applying Newton’s
    second law to. If an object also produces forces on other objects, that’s fine,
    but those forces only get counted when we apply Newton’s second law to one of
    those other objects. Newton’s second law cares about the forces *on* an object,
    not the forces produced *by* an object.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理牛顿第二定律时，正如我们在前五章中所做的那样，我们只关注作用在我们应用牛顿第二定律的物体*上的*力。如果一个物体还对其他物体产生了力，这也是可以的，但这些力只有在我们将牛顿第二定律应用到那些其他物体时才会被考虑。牛顿第二定律关心的是作用在物体*上的*力，而不是物体产生的*力*。
- en: Newton’s third law, on the other hand, cares about both and asserts a relationship
    between them for each interaction. Newton’s second law applies to an object; Newton’s
    third law applies to an interaction between two objects.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，牛顿第三定律关心的是两者，并对每个相互作用之间的关系进行断言。牛顿第二定律适用于一个物体；而牛顿第三定律适用于两个物体之间的相互作用。
- en: '[Listing 19-1](ch19.xhtml#ch19list1) shows the first lines of code for the
    `MultipleObjects` module we’ll develop in this chapter.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19-1](ch19.xhtml#ch19list1)展示了我们将在本章中开发的`MultipleObjects`模块的第一行代码。'
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 19-1: Opening lines of code for the `MultipleObjects` module*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 19-1：`MultipleObjects`模块的开头代码*'
- en: 'You should be familiar with the first line by now: it turns on warnings. The
    second line turns on a language option that allows us to use multiparameter type
    classes; we’ll explain this later in the chapter. We name the module `MultipleObjects`.
    We import the data types `Vec` and `R` from `SimpleVec` so we can refer to them
    in our type signatures. We also import the zero vector, the `magnitude` function,
    and the basic vector operators from `SimpleVec`. We use the type classes `RealVectorSpace`
    and `HasTime` to extend the general-purpose numerical methods `euler` and `rungeKutta4`
    to the multi-particle setting of this chapter. By making the new data type for
    multi-particle state an instance of these two type classes, we’ll be able to use
    the two general-purpose numerical methods. We import `newtonSecondPS`, the function
    that applies Newton’s second law to a single particle, to use in the function
    we write that applies Newton’s second law to a collection of particles. We import
    `euler` to use as a basis for writing an Euler-Cromer method for multiple particles.
    We’ll fill out the rest of the module as we move through the chapter.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该已经熟悉第一行代码了：它启用了警告。第二行启用了一个语言选项，允许我们使用多参数类型类；我们将在本章后面解释这一点。我们将模块命名为`MultipleObjects`。我们从`SimpleVec`导入数据类型`Vec`和`R`，以便在我们的类型签名中使用它们。我们还导入了零向量、`magnitude`函数和基本向量运算符，从`SimpleVec`中进行引用。我们使用类型类`RealVectorSpace`和`HasTime`来扩展通用数值方法`euler`和`rungeKutta4`，以适应本章的多粒子环境。通过使多粒子状态的新数据类型成为这两个类型类的实例，我们将能够使用这两个通用数值方法。我们导入了`newtonSecondPS`，该函数将牛顿第二定律应用于单个粒子，供我们在编写将牛顿第二定律应用于一组粒子的函数时使用。我们导入了`euler`，作为编写多粒子欧拉-克罗梅方法的基础。我们将在本章的过程中完善模块的其余部分。
- en: NOTE
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '*We’ll be using the terms* body, object, *and* particle *interchangeably. A
    particle connotes a small thing; the words* body *and* object *sometimes connote
    things that are larger and have an orientation in space. Change in orientation
    is called* rotation, *and the study of objects with orientations that can rotate
    as well as move through space is called* rigid-body mechanics. *We won’t be getting
    into rigid-body mechanics here, although this chapter contains important prerequisite
    material for the subject. What we mean when using the word* body, object, *or*
    particle *is something that can experience forces, move, and accelerate through
    space but that either has no orientation or allows us to ignore its orientation.
    Sometimes the term point particle is used to emphasize that orientation is irrelevant.*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将交替使用术语* 体、物体、*和*粒子*。粒子指代一个小物体；而*体*和*物体*有时指的是较大且具有空间定向的物体。定向变化叫做*旋转*，而研究能够旋转并在空间中移动的物体的学科叫做*刚体力学*。*我们在这里不涉及刚体力学，尽管本章包含了学习该主题的重要先决知识。我们所说的*体、物体*或*粒子*是指能够承受力、在空间中移动和加速的东西，但它要么没有定向，要么我们可以忽略其定向。有时使用术语点粒子来强调定向无关紧要。*'
- en: Two-Body Forces
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 两体力
- en: 'In [Chapter 16](ch16.xhtml), we defined a `OneBodyForce` to be a function taking
    the state of a particle as input and producing a (vector) force on the particle
    as output. The one-body force is appropriate when the force acting on the one
    body depends only on that body’s state of affairs: namely, its position, velocity,
    mass, charge, or current time.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第16章](ch16.xhtml)，我们定义了一个`OneBodyForce`，它是一个接受粒子状态作为输入并输出对该粒子的（向量）力的函数。单体力适用于当作用于单一物体的力仅取决于该物体的状态：即其位置、速度、质量、荷电量或当前时间。
- en: Many forces in mechanics are fundamentally *two-body* in nature, meaning the
    force vector depends on the states of both the particle producing the force and
    the particle experiencing the force. A *two-body force* is a force that depends
    on the states of two particles.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 力学中的许多力本质上是*两体*的，这意味着力向量取决于产生力的粒子和经历力的粒子的状态。*两体力*是指依赖于两个粒子状态的力。
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The type `ForceVector` is a type synonym for `Vec`, the name suggesting that
    the particular vector we have in mind represents a force.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`ForceVector`类型是`Vec`的类型同义词，名称表明我们考虑的特定向量表示一个力。'
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The force vector returned by a two-body force is produced *by* the particle
    whose state is given first in `TwoBodyForce`, and it acts *on* the particle whose
    state is given second. Let’s call this the *by-on convention*. The comments in
    the code just shown remind us of this convention.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 两体力返回的力向量是由`TwoBodyForce`中首先给定状态的粒子*产生*的，它作用于第二个给定状态的粒子。我们称之为*by-on约定*。刚才展示的代码注释提醒我们这一约定。
- en: Every two-body force we write should obey Newton’s third law. If the two particle
    states are exchanged, the force vector produced should be negated from what it
    was. That is, if `f` is a two-body force, the vector `f st2 st1` should be the
    negative of `f st1 st2`. Since the force acting on one particle is the negative
    of the force acting on the other, a convention like the by-on convention is important
    so that, for example, gravity acts as an attractive force and not as a repulsive
    force.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们写的每个二体力应该遵循牛顿第三定律。如果交换两个粒子的状态，产生的力向量应该是原来力的反向。也就是说，如果`f`是二体力，向量`f st2 st1`应该是`f
    st1 st2`的负向。由于作用于一个粒子的力是作用于另一个粒子的力的反向，像by-on约定这样的约定非常重要，以便例如重力作为吸引力作用，而不是排斥力。
- en: 'There is a relationship between a two-body force and a one-body force. Given
    the state of a particle that is producing a force, we can turn a two-body force
    into a one-body force by providing the two-body force with its first input and
    nothing else. This creates a function. The function takes the state of a particle
    on which the force acts and returns a force vector, making the function a one-body
    force. Here is the Haskell code to express this idea:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 二体力和一体力之间存在关系。给定产生力的粒子的状态，我们可以通过仅提供二体力的第一个输入并不提供其他信息，将二体力转换为一体力。这会创建一个函数。该函数接受作用于粒子上的状态并返回一个力向量，使得该函数成为一体力。以下是用Haskell代码表达这一概念：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code is deceptively simple. By applying the two-body force `f` to the state
    of the particle that is producing the force, we obtain a one-body force. The local
    variable `stBy` holds the state of the particle producing the force; equivalently,
    the force is produced *by* the particle with the state `stBy`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看似简单。通过将二体力`f`应用于产生力的粒子的状态，我们得到了一个一体力。局部变量`stBy`保存产生力的粒子的状态；等价地，力是由状态为`stBy`的粒子*产生*的。
- en: If our brains worked more like the Haskell compiler, we might not bother to
    make this definition of `oneFromTwo` because in any place we use this function,
    we could achieve equivalent behavior with fewer keystrokes by omitting the name
    `oneFromTwo` and reversing the order of its arguments. However, my brain does
    not work enough like the Haskell compiler for this to be an easy or natural thing
    to do. I believe that this function, silly as it is for the Haskell compiler,
    offers value to the human reader and writer of code because it engages the ideas
    and terminology of mechanics, namely one- and two-body forces. With experience
    in programming, you will come across more ways of writing code that the compiler
    sees as equivalent but that sit differently on your brain. Use the flexibility
    of the language to write in a way that is easy for you, and perhaps others, to
    read and understand. Your code is not just for the computer; it’s for you and
    other people too.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的脑袋工作方式更像Haskell编译器，我们或许不会费心去定义`oneFromTwo`，因为在任何使用该函数的地方，我们可以通过省略`oneFromTwo`的名字并反转参数顺序来达到等效的行为。然而，我的大脑并不像Haskell编译器那样运作，因此这对我来说并不是一种容易或自然的做法。我相信，这个函数对于Haskell编译器来说或许有些傻，但对于人类的代码读者和写作者来说，它有其价值，因为它涉及了力学的概念和术语，特别是一体力和二体力。随着编程经验的积累，你会遇到更多编译器认为等效的写法，但它们在你脑海中的表现方式不同。利用语言的灵活性，以便你自己，或许其他人，能够轻松阅读和理解你的代码。你的代码不仅仅是为了计算机，它同样是为了你和其他人。
- en: We’ll use the function `oneFromTwo` when we talk about springs later in the
    chapter. We’ll also use it when we want to collect all the forces that act on
    one particle.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面谈到弹簧时使用`oneFromTwo`函数。当我们想要收集作用在一个粒子上的所有力时，我们也会使用它。
- en: Let’s look at some examples of two-body forces. We need to be careful of two
    issues as we write a two-body force. First, a two-body force needs to respect
    Newton’s third law. To achieve this, as we will see in the examples that follow,
    the states of the two bodies need to be used in a symmetric way. (More precisely,
    the two states need to be used in an *anti-symmetric* way so that interchanging
    them produces a minus sign.) Second, we need to respect the by-on convention so
    we have a clear understanding of which body the force acts on. Haskell’s type
    system will not prevent us from mistakenly writing a `TwoBodyForce` that violates
    Newton’s third law, or one that returns the wrong force, so we need to be careful.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些双体力的例子。在编写双体力时，我们需要注意两个问题。首先，双体力需要遵守牛顿的第三定律。为此，正如我们在以下例子中所见，两个物体的状态需要对称地使用。（更准确地说，这两个状态需要以*反对称*的方式使用，这样交换它们会产生负号。）第二，我们需要遵循“由……作用于……”的惯例，以便清楚地理解力作用于哪个物体。Haskell的类型系统并不会阻止我们错误地写出一个违反牛顿第三定律的`TwoBodyForce`，或者一个返回错误力的函数，所以我们需要小心。
- en: Universal Gravity
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 万有引力
- en: Newton was the first to give a quantitative relationship describing the gravitational
    force between two massive spherical objects. He showed that the force exerted
    by one object on another is directly proportional to the mass of each object and
    inversely proportional to the square of the distance between their centers. As
    an equation, Newton’s law of universal gravity can be written as
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿是第一个给出描述两个大质量球形物体之间引力定量关系的人。他表明，一个物体对另一个物体施加的力与每个物体的质量成正比，并且与它们中心之间距离的平方成反比。作为一个方程，牛顿的万有引力定律可以写为：
- en: '![Image](Images/343fig01.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/343fig01.jpg)'
- en: 'where *m*[1] is the mass of object 1, *m*[2] is the mass of object 2, and *r*
    is the distance between the centers of the objects. This equation gives the magnitude
    of the force produced by object 1 on object 2 (which, by Newton’s third law, is
    the same as the magnitude of the force produced by object 2 on object 1). In SI
    units, the constant *G* = 6.67408 × 10^(–11) N m²/kg². Equation 19.1 can be translated
    into Haskell as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*m*[1]是物体1的质量，*m*[2]是物体2的质量，*r*是物体中心之间的距离。这个方程给出了物体1对物体2施加的力的大小（根据牛顿第三定律，这个力的大小与物体2对物体1施加的力的大小相同）。在国际单位制中，常数*G*
    = 6.67408 × 10^(–11) N m²/kg²。方程19.1可以用Haskell表示如下：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We can use vector notation to give a more comprehensive version of Newton’s
    law of universal gravity, which includes the direction of the force in the equation.
    Define the displacement vector **r**[21] to be the vector that points from particle
    1 to particle 2, as in [Figure 19-1](ch19.xhtml#ch19fig1).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用向量表示法给出牛顿万有引力定律的更全面版本，该版本包括了方程中的力的方向。定义位移向量**r**[21]为从粒子1指向粒子2的向量，如[图19-1](ch19.xhtml#ch19fig1)所示。
- en: '![Image](Images/343fig02.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/343fig02.jpg)'
- en: '*Figure 19-1: The displacement vector r[21] points from particle 1 to particle
    2.*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*图19-1：位移向量r[21]指向从粒子1到粒子2的方向。*'
- en: We’ll also define a unit vector ![Image](Images/e0343-02.jpg) to point in the
    direction from particle 1 to particle 2.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将定义一个单位向量 ![图片](Images/e0343-02.jpg)，它指向从粒子1到粒子2的方向。
- en: '![Image](Images/343equ02.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/343equ02.jpg)'
- en: The force **F**[21] exerted on particle 2 produced by particle 1 is given in
    vector notation by replacing *r* in Equation 19.1 with |**r**[21]| and indicating
    the direction of the force with ![Image](Images/e0344-01.jpg) because the force
    on particle 2 points toward particle 1.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子1对粒子2施加的力**F**[21]可以通过将方程19.1中的*r*替换为|**r**[21]|，并用![图片](Images/e0344-01.jpg)表示力的方向来给出，因为作用在粒子2上的力是指向粒子1的。
- en: '![Image](Images/344equ01.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/344equ01.jpg)'
- en: Notice that the force **F**[21] on object 2 points opposite to the displacement
    vector **r**[21]; that is, it points toward object 1\. This makes sense because
    gravity is an attractive force.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，作用在物体2上的力**F**[21]与位移向量**r**[21]的方向相反；也就是说，它指向物体1。这是合理的，因为引力是一种吸引力。
- en: Comparing Equations 19.1 and 19.3, we see that Equation 19.1 is simpler, while
    Equation 19.3 is more powerful since the direction of the force is encoded in
    the equation.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 比较方程19.1和19.3，我们看到方程19.1更简单，而方程19.3更强大，因为它在方程中编码了力的方向。
- en: 'If **r**[1] is the position vector for particle 1 and **r**[2] is the position
    vector for particle 2, then **r**[21] = **r**[2] – **r**[1], and we can write
    the force on particle 2 as:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果**r**[1]是粒子1的位置向量，**r**[2]是粒子2的位置向量，那么**r**[21] = **r**[2] – **r**[1]，我们可以将粒子2上的力表示为：
- en: '![Image](Images/344equ02.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/344equ02.jpg)'
- en: 'Here is the Haskell definition for the two-body force of universal gravity:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关于普遍引力两体力的 Haskell 定义：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We use the extraction (also called eliminator or selector) functions `mass`
    and `posVec` from the `ParticleState` data type to extract the masses and position
    vectors of the two particles and we give local names to these values. The final
    expression we return comes from Equation 19.4.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`ParticleState`数据类型中的提取函数（也叫做消除器或选择器）`mass`和`posVec`来提取两个粒子的质量和位置向量，并为这些值指定局部名称。我们返回的最终表达式来自方程19.4。
- en: Notice that universal gravity obeys Newton’s third law. We calculate the force
    **F**[12] produced by particle 2 on particle 1 by exchanging the roles of *m*[1]
    with *m*[2] and of **r**[1] with **r**[2].
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，普遍引力遵循牛顿的第三定律。我们通过交换* m *[1]和* m *[2]，以及交换**r**[1]和**r**[2]的位置来计算粒子2对粒子1施加的力**F**[12]。
- en: '![Image](Images/344equ03.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/344equ03.jpg)'
- en: Constant Repulsive Force
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 恒定排斥力
- en: Let’s try to write a constant repulsive force between two objects; in other
    words, a force that doesn’t depend on the distance between the objects.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试编写一个恒定排斥力，作用于两个物体之间；换句话说，一个不依赖于物体之间距离的力。
- en: 'Here’s a wrong way to do it:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个错误的做法：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The intent of the code is clear: we intend to ignore the states of the particles
    and return whatever force was given. This code satisfies the Haskell type checker
    and compiles, but it does not satisfy Newton’s third law. Since the particle states
    are completely ignored, there is no chance that exchanging the particle states
    will reverse the direction of the force, as required by Newton’s third law.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的意图是明确的：我们打算忽略粒子的状态并返回任何给定的力。此代码通过了 Haskell 类型检查器并成功编译，但它不符合牛顿第三定律。由于完全忽略了粒子状态，因此无法通过交换粒子状态来改变力的方向，这正是牛顿第三定律所要求的。
- en: 'Here is a constant repulsive force that does obey Newton’s third law:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个恒定的排斥力，符合牛顿第三定律：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Instead of passing a force vector to our function, we now pass only a force
    magnitude. We use the positions of the two bodies to determine what direction
    “repulsive” is. When we exchange the two particle states in this two-body force,
    the direction of the force is properly reversed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再传递一个力向量给我们的函数，而是只传递一个力的大小。我们使用两个物体的位置来确定“排斥”的方向。当我们交换这两个粒子的状态时，力的方向会正确地反转。
- en: Linear Spring
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 线性弹簧
- en: A spring, typically made of coiled metal or plastic, can be extended by pulling
    its ends apart and compressed by pushing them toward each other. The spring has
    some equilibrium length, which is the distance between the two ends when the spring
    is detached and allowed to assume its natural shape.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 弹簧通常由金属或塑料制成，通过拉开两端可以使其伸长，通过推近两端可以使其压缩。弹簧有一个平衡长度，即弹簧被分离并允许恢复其自然形状时，两端之间的距离。
- en: If objects are connected to the ends of the spring, the spring can exert forces
    on these objects. If the distance between the two objects becomes less than the
    equilibrium length of the spring, the spring compresses and exerts repulsive forces
    on the objects in an effort to restore its equilibrium length. Similarly, an extended
    spring seeks restoration by exerting attractive forces on the objects at its ends.
    If the mass of the spring is negligible compared with the masses of the objects
    at its ends, then the force exerted by one end of the spring on one object will
    be equal and opposite to the force exerted by the other end of the spring on the
    other object. The spring acts as a Newton’s third law–respecting two-body force
    between the two objects. Since the magnitudes of the forces at each end are equal,
    we sometimes speak of the force of the spring as if it were one single value.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果物体连接到弹簧的两端，弹簧就能对这些物体施加力。如果两物体之间的距离小于弹簧的平衡长度，弹簧会压缩，并施加排斥力以恢复其平衡长度。类似地，当弹簧被拉长时，会通过施加吸引力来恢复平衡。如果弹簧的质量相较于弹簧两端物体的质量可以忽略不计，那么弹簧一端对物体施加的力将等于且相反于另一端对另一个物体施加的力。弹簧充当了一个遵循牛顿第三定律的两体力。由于每端力的大小相等，我们有时会将弹簧的力当作一个单一的数值来看待。
- en: We’ll assume a spring that does not bend but only compresses or extends along
    a line connecting the ends. If *r*[21] is the distance between the ends of the
    spring and *r[e]* is the equilibrium length of the spring, the spring is in extension
    when *r*[21] > *r[e]*, in compression when *r*[21] < *r[e]*, and in equilibrium
    when *r*[21] = *r[e]*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设弹簧不弯曲，只在连接两端的直线上进行压缩或拉伸。如果*r*[21]是弹簧两端之间的距离，*r[e]*是弹簧的平衡长度，当*r*[21] > *r[e]*时，弹簧处于拉伸状态；当*r*[21]
    < *r[e]*时，弹簧处于压缩状态；当*r*[21] = *r[e]*时，弹簧处于平衡状态。
- en: The size of the force exerted by a spring depends on how much the spring has
    been extended or compressed from its equilibrium length. A larger extension or
    compression produces a larger force. The force exerted by the spring depends on
    the difference *r*[21] – *r[e]*. A *linear spring* is one in which the force is
    proportional to this difference. The constant of proportionality *k* is called
    the *spring constant*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 弹簧施加的力的大小取决于弹簧从平衡长度延伸或压缩的程度。延伸或压缩越大，力越大。弹簧施加的力依赖于差值*r*[21] – *r[e]*。*线性弹簧*是指力与该差值成正比的弹簧。比例常数*k*称为*弹簧常数*。
- en: Let’s call **r**[21] the displacement vector from object 1 at one end of the
    spring to object 2 at the other, as in [Figure 19-1](ch19.xhtml#ch19fig1). Then
    *r*[21] = |**r**[21]| is the distance from one end to the other, and ![Image](Images/e0346-01.jpg)
    is a unit vector from end 1 toward end 2\. [Table 19-1](ch19.xhtml#ch19tab1) shows
    the force on each end of the spring.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们称**r**[21]为从弹簧一端物体1到另一端物体2的位移向量，如[图19-1](ch19.xhtml#ch19fig1)所示。那么*r*[21]
    = |**r**[21]|是从一端到另一端的距离，![Image](Images/e0346-01.jpg)是从端1指向端2的单位向量。[表19-1](ch19.xhtml#ch19tab1)显示了弹簧两端的力。
- en: '**Table 19-1:** Forces on Each End of a Linear Spring'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**表19-1：** 线性弹簧两端的力'
- en: '|  | **Spring state** | **Force at end 1** | **Force at end 2** |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '|  | **弹簧状态** | **端1的力** | **端2的力** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| *r*[21] > *r[e]* | Extension | ![Image](Images/e0346-02.jpg) | ![Image](Images/e0346-03.jpg)
    |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| *r*[21] > *r[e]* | 拉伸 | ![Image](Images/e0346-02.jpg) | ![Image](Images/e0346-03.jpg)
    |'
- en: '| *r*[21] = *r[e]* | Equilibrium | 0 | 0 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| *r*[21] = *r[e]* | 平衡 | 0 | 0 |'
- en: '| *r*[21] < *r[e]* | Compression | ![Image](Images/e0346-04.jpg) | ![Image](Images/e0346-05.jpg)
    |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| *r*[21] < *r[e]* | 压缩 | ![Image](Images/e0346-04.jpg) | ![Image](Images/e0346-05.jpg)
    |'
- en: 'The force **F**[21] exerted on object 2 produced by the spring connected to
    object 1 is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 弹簧作用在物体2上的力**F**[21]如下所示：
- en: '![Image](Images/346equ01.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/346equ01.jpg)'
- en: 'This equation holds whether the spring is in extension, compression, or equilibrium.
    If **r**[1] is the position vector for object 1 and **r**[2] is the position vector
    for object 2, then **r**[21] = **r**[2] – **r**[1], and we can write the force
    on object 2 as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方程在弹簧处于拉伸、压缩或平衡状态时都成立。如果**r**[1]是物体1的位置向量，**r**[2]是物体2的位置向量，那么**r**[21] =
    **r**[2] – **r**[1]，我们可以将作用在物体2上的力写成如下形式：
- en: '![Image](Images/346equ02.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/346equ02.jpg)'
- en: 'Here is Haskell code for the two-body force of a linear spring with spring
    constant `k` and equilibrium length `re`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Haskell代码，用于计算具有弹簧常数`k`和平衡长度`re`的线性弹簧的双体力：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There may be times when we want to attach one end of a spring to a fixed wall
    or ceiling. In that case, the spring is better represented by a one-body force.
    This is a good opportunity to use the function `oneFromTwo` that we wrote earlier
    in this chapter to produce a one-body force from a two-body force. Given a spring
    constant, an equilibrium length, and a fixed position for one end of the spring,
    the function `fixedLinearSpring` produces a one-body force for the object attached
    to the other end of the spring.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们可能需要将弹簧的一端固定到墙壁或天花板上。在这种情况下，弹簧最好用一个单体力来表示。这是一个很好的机会，可以使用我们在本章前面编写的函数`oneFromTwo`，将双体力转化为单体力。给定弹簧常数、平衡长度以及弹簧一端的固定位置，函数`fixedLinearSpring`可以为附着在另一端的物体产生一个单体力。
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The function `fixedLinearSpring` works by creating a fake particle state at
    the fixed end of the spring. The particle state is fake in that its only use is
    to supply a position; we do not intend to allow this particle state to evolve
    as we would for a real particle. When this fake particle state is given to the
    function `oneFromTwo` along with the two-body force `linearSpring k re`, we obtain
    a one-body force that describes the force the spring exerts on the movable mass.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`fixedLinearSpring`的工作原理是创建一个假粒子状态，位于弹簧的固定端。这个粒子状态是“假”的，因为它的唯一作用是提供位置；我们不打算让这个粒子状态像真实粒子一样演化。当这个假粒子状态与双体力`linearSpring
    k re`一起传递给函数`oneFromTwo`时，我们得到一个一体力，描述了弹簧对可动质量施加的力。
- en: Central Force
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 中心力
- en: The three two-body forces we have considered so far—universal gravity, a constant
    repulsive force, and a linear spring—are all examples of a *central force*, which
    is a force between two particles that depends only on the distance between them
    and acts along the line that joins them. A central force can be either attractive
    or repulsive. A general expression for the force on object 2 produced by a central
    force from object 1 is
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们考虑的三种双体力——万有引力、常量排斥力和线性弹簧力——都是*中心力*的例子，中心力是作用在两个粒子之间的力，仅依赖于它们之间的距离，并沿着连接它们的线方向作用。中心力可以是吸引力也可以是排斥力。由物体1产生的中心力对物体2的作用力的通用表达式为：
- en: '![Image](Images/347equ01.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/347equ01.jpg)'
- en: or
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '![Image](Images/347equ02.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/347equ02.jpg)'
- en: 'if **r**[1] is the position vector for object 1 and **r**[2] is the position
    vector for object 2\. Here is the central force in Haskell:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果**r**[1]是物体1的位置向量，**r**[2]是物体2的位置向量。以下是Haskell中的中心力：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We provide `centralForce` with a scalar function `f` that describes how the
    force depends on the distance between the two objects.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了`centralForce`，它使用标量函数`f`来描述力是如何依赖于两个物体之间的距离的。
- en: 'The linear spring force of the previous section can be alternatively defined
    using this `centralForce` function as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 前一部分中提到的线性弹簧力可以通过使用这个`centralForce`函数来重新定义，如下所示：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here we send the scalar function
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们传递标量函数
- en: '*f*(*r*) = –*k*(*r* – *r[e]*)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*(*r*) = –*k*(*r* – *r[e]*)'
- en: to `centralForce`, where the negative sign indicates that the force is attractive
    when *r* > *r[e]*. Exercise 19.3 asks you to write universal gravity as a central
    force.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 到`centralForce`，其中负号表示当*r* > *r[e]*时力是吸引力。习题19.3要求你将万有引力写成中心力。
- en: Elastic Billiard Interaction
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 弹性台球相互作用
- en: In an elastic collision between two objects, the objects compress a bit and
    store energy, much like a spring, before bouncing apart. In an introductory physics
    course, collisions are typically treated as “black box” events, where we don’t
    get involved in the particular forces that act between the colliding objects but
    rather use conservation of momentum to figure out how the objects will move after
    the collision instead. Here, we’ll view the force between objects as a two-body
    force that is 0 when the objects are apart from one another and that acts as a
    spring when the objects come into contact.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个物体发生弹性碰撞时，物体会稍微压缩并储存能量，就像弹簧一样，然后再弹开。在初级物理课程中，碰撞通常被视为“黑箱”事件，我们不涉及碰撞物体之间具体的作用力，而是利用动量守恒来推算碰撞后物体的运动。这里，我们将物体之间的力视为一个双体力，当物体之间相隔时力为零，而当物体接触时力表现为弹簧力。
- en: 'The crucial thing to know is whether the objects are touching or not touching.
    We only keep track of the position of the center of each object in the state,
    so the question becomes whether the centers of the two objects are closer than
    some threshold distance between the centers that we’ll call *r[e]*. If the distance
    between the objects is greater than *r[e]*, there is no force. If the distance
    is less than *r[e]*, we’ll model the force as a compressed linear spring with
    spring constant *k*. The following equation gives the force on object 2 produced
    by object 1:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是要知道物体是否接触。我们只在状态中跟踪每个物体的质心位置，因此问题就变成了两个物体的质心是否更接近某个阈值距离，这个阈值距离我们称为*r[e]*。如果物体之间的距离大于*r[e]*，则没有力。如果距离小于*r[e]*，我们将力建模为一个压缩的线性弹簧，弹簧常数为*k*。以下方程给出了物体1对物体2的力：
- en: '![Image](Images/348equ01.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/348equ01.jpg)'
- en: 'This force is like half of a linear spring. It behaves like a linear spring
    under compression, when the centers are closer than the threshold distance *r[e]*,
    but there is no force when the spring would exhibit extension. Here is the Haskell
    code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个力就像一个线性弹簧的一半。它在压缩时表现得像一个线性弹簧，当中心距离小于阈值距离 *r[e]* 时会产生力，但当弹簧会出现拉伸时，则没有力。下面是
    Haskell 代码：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When the distance between the particles is greater than or equal to the threshold
    separation, the particles feel no force. When the distance between the particles
    is less than the threshold separation, the objects are touching and compressing
    a bit, feeling a force of repulsion. We’ll use this two-body force to animate
    a collision in the next chapter.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当粒子之间的距离大于或等于阈值分离时，粒子不受任何力作用。当粒子之间的距离小于阈值分离时，物体接触并稍微压缩，感受到排斥力。我们将在下一章中使用这种两体力来模拟碰撞。
- en: Internal and External Forces
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内力与外力
- en: When we have multiple interacting particles, the forces that act on any one
    particle can be classified into two sorts. On the one hand, there are the forces
    produced by other particles in the collection of particles we are paying attention
    to. These are the forces to which Newton’s third law applies. If we care about
    particles A and B, and A feels a force from B, then Newton’s third law reminds
    us that somewhere in our calculation we need to account for the fact that B feels
    a force from A.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有多个相互作用的粒子时，作用在任何一个粒子上的力可以分为两种。一方面，存在由我们关注的粒子集合中的其他粒子产生的力。这些是牛顿第三定律适用的力。如果我们关心粒子
    A 和 B，并且 A 感受到来自 B 的力，那么牛顿第三定律提醒我们，在我们的计算中需要考虑 B 感受到来自 A 的力这一事实。
- en: On the other hand, there are the forces produced by things outside of the collection
    of particles we are paying attention to. We may want Earth’s surface gravity as
    a force without having to include Earth as one of the particles we care about.
    We may want to include forces produced by electric or magnetic fields without
    including the sources of these fields in our calculation. For this second sort
    of force, Newton’s third law is irrelevant; it tells us about a force that acts
    on something we don’t care about and don’t need to account for in our calculation.
    The distinction between these two sorts of forces motivates the following definitions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，存在由我们关注的粒子集合外部的物体产生的力。我们可能希望将地球表面的重力作为一种力，而不需要将地球作为我们关心的粒子之一。我们可能还希望包括由电场或磁场产生的力，而不包括这些场的源头在我们的计算中。对于第二种类型的力，牛顿第三定律并不适用；它告诉我们关于作用在我们不关心的事物上的力，而这些我们不需要在计算中考虑。区分这两种力促使了以下定义的产生。
- en: A *system of particles* is simply a choice of which particles to pay attention
    to. We decide which particles to include in our system, and these are the particles
    whose motion we calculate by applying Newton’s second law.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*粒子系统*仅仅是一个选择，决定关注哪些粒子。我们决定在系统中包括哪些粒子，这些粒子的运动通过应用牛顿第二定律来计算。'
- en: For a system of particles, it’s useful to distinguish between an *internal force*
    (a force produced by a particle in our system) and an *external force* (a force
    produced by something outside of our system). By making this distinction between
    forces, we will be able to write a state-update rule that automatically applies
    Newton’s third law for us. An external force does not require Newton’s third law;
    it’s treated the same as last chapter because we’re not concerned with the motion
    of the object creating the force. For an internal force, both particles are in
    our system, and we can treat them symmetrically, making sure that each particle
    experiences the appropriate force.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于粒子系统，区分*内力*（由我们系统中的粒子产生的力）和*外力*（由我们系统外部的物体产生的力）是有用的。通过区分这些力，我们能够写出一个状态更新规则，自动为我们应用牛顿第三定律。外力不需要牛顿第三定律；它与上一章的处理方式相同，因为我们不关心产生该力的物体的运动。对于内力，两个粒子都在我们的系统中，我们可以对它们进行对称处理，确保每个粒子都经历了适当的力。
- en: Let’s make a new data type for force that demands every force be either an external
    force or an internal force.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的力的数据类型，要求每个力必须是外力或内力之一。
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `Int`s in this data type definition are particle numbers. We are going to
    number the particles in our system, starting with 0\. A particular external force
    is specified by giving the particle number that experiences the force along with
    the one-body force that describes it. For example, the `Force`
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据类型定义中的`Int`是粒子编号。我们将从0开始编号我们系统中的粒子。通过指定经历某种外力的粒子编号以及描述该外力的单体力，我们可以确定特定的外力。例如，`Force`
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: indicates that particle 98 experiences the force of a linear spring with spring
    constant 1 and equilibrium length 0.5, and whose other end is fixed at position
    100![Image](Images/icap.jpg).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 表示粒子98受到一个线性弹簧的作用，弹簧常数为1，平衡长度为0.5，且弹簧的另一端固定在位置100处![Image](Images/icap.jpg)。
- en: A particular internal force is specified by giving numbers for the two particles
    that participate in the interaction, followed by the two-body force that describes
    the interaction. For example, the `Force`
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 特定的内力通过给出参与相互作用的两个粒子的编号，后跟描述这种相互作用的双体力来指定。例如，`Force`
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: indicates that particles 0 and 1 interact via universal gravity. The `Force`
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 表示粒子0和1通过万有引力相互作用。`Force`
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: means the same thing. To indicate that particles 0 and 1 interact by universal
    gravity, we include one, but not both, of these forces in the list of forces that
    describes the setting for our system of particles.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 表示相同的意思。为了表示粒子0和1通过万有引力相互作用，我们在描述粒子系统设置的力的列表中仅包含其中之一，而不是两者。
- en: The State of a Multi-Particle System
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多粒子系统的状态
- en: The state of a system of particles consists of the information contained in
    the states of each particle. A list of particle states is an appropriate type
    for the state of a system of multiple particles.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子系统的状态由每个粒子状态中的信息组成。粒子状态的列表是描述多个粒子系统状态的适当类型。
- en: There are a few ways we could approach this. We could use the data type `[ParticleState]`
    to describe the state of a system of particles. We could also write a type synonym
    to give an alternate name to a list of single-particle states. However, we won’t
    follow either of these two paths because we already use a list of single-particle
    states to represent a solution to a one-particle mechanics problem. In this solution,
    each single-particle state describes the same particle at a different time. The
    state of a multi-particle system wants a list of particles for a different purpose;
    each single-particle state describes a different particle at the same time.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过几种方式来处理这个问题。我们可以使用数据类型`[ParticleState]`来描述粒子系统的状态。我们也可以写一个类型同义词，为单粒子状态的列表提供另一个名称。然而，我们不会选择这两条路径，因为我们已经使用单粒子状态的列表来表示单粒子力学问题的解。在这个解中，每个单粒子状态描述的是同一个粒子在不同时间的状态。多粒子系统的状态需要一个粒子列表来达成不同的目的；每个单粒子状态描述的是不同粒子在同一时刻的状态。
- en: Since we do not want to confuse a list of single-particle states used as a solution
    to a one-particle mechanics problem with a list used to describe a multi-particle
    system, we create a new data type using the `data` keyword so that the compiler
    regards the two types as different. Different purposes suggest different types.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不想将作为单粒子力学问题解的单粒子状态列表与描述多粒子系统的列表混淆，我们使用`data`关键字创建了一个新数据类型，以便编译器将这两种类型视为不同类型。不同的用途意味着不同的类型。
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We build a value with type `MultiParticleState` with the data constructor `MPS`,
    which is short for multi-particle state. We could have used `MultiParticleState`
    as the name of the data constructor; however, I chose `MPS` because it’s shorter
    and appears less awkward to use in code to me. Underneath the data constructor
    is a plain old list of single-particle states. The `data` constructor makes the
    type `MultiParticleState` distinct from the type `[ParticleState]`. We use record
    syntax to obtain the extraction function `particleStates` without having to explicitly
    define it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用数据构造器`MPS`（多粒子状态的缩写）构建一个类型为`MultiParticleState`的值。我们本可以使用`MultiParticleState`作为数据构造器的名称，但我选择了`MPS`，因为它更短，也在代码中使用起来不那么笨重。数据构造器下方是一个普通的单粒子状态列表。`data`构造器使得类型`MultiParticleState`与类型`[ParticleState]`区分开来。我们使用记录语法来获取提取函数`particleStates`，而无需显式定义它。
- en: Underneath the data constructor, the single-particle states reside in a list,
    meaning we can refer to the particles by number, starting with `0`. Each particle
    is labeled by a number with type `Int`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据构造器下方，单粒子状态存储在一个列表中，这意味着我们可以通过编号来引用粒子，从`0`开始。每个粒子都通过一个类型为`Int`的数字来标记。
- en: We note in passing that using a list for the states of each particle is not
    the most efficient way to handle data. In this book, we are primarily concerned
    with the clarity, beauty, and simplicity of the code we write, and we are less
    concerned with its efficiency. A good rule in Haskell programming is not to worry
    about efficiency until your code runs slower than you would like. At that point,
    it makes sense to ask what can be done to make it faster. In the old days, functional
    programming was saddled with a reputation for slowness. However, that is no longer
    true. Haskell, in particular, provides data structures such as arrays that can
    be more efficient than the list structure we are using. The list-based method
    we use works well for tens of particles, but it may be too slow for hundreds of
    particles. If you get to the point where you want to run simulations with hundreds
    or thousands of particles, I recommend looking into array types. For simplicity,
    we stick to the list data type in this book.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们顺便提一下，使用列表来表示每个粒子的状态并不是处理数据的最高效方式。在本书中，我们主要关注的是我们编写的代码的清晰性、美观性和简洁性，而对其效率关注较少。在Haskell编程中，一个好的规则是，直到你的代码运行得比你希望的慢时，才考虑效率问题。到那时，再问怎么做才能让它更快。在过去，函数式编程曾有一个慢的名声，但现在这种说法不再成立。特别是Haskell，提供了如数组等数据结构，它们可能比我们正在使用的列表结构更高效。我们使用的基于列表的方法对于十几个粒子效果很好，但对于几百个粒子可能就太慢了。如果你达到了需要用几百或几千个粒子来进行模拟的程度，我建议你研究一下数组类型。为了简便起见，本书中我们坚持使用列表数据类型。
- en: 'To do animation with the `Vis` module using the function `simulateVis` we wrote
    in [Chapter 16](ch16.xhtml), a data type that represents the state of something
    needs to be an instance of type class `HasTime`, which means that a state needs
    to have a time associated with it. Each single-particle state has a time; in fact,
    every single-particle state that makes up a multi-particle state has the same
    time. So, we’ll just take the time from particle number 0\. Here is the instance
    declaration:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用[第16章](ch16.xhtml)中编写的`simulateVis`函数进行动画，在`Vis`模块中，表示某个事物状态的数据类型需要是类型类`HasTime`的一个实例，这意味着状态需要与时间相关联。每个单粒子状态都有一个时间；事实上，组成多粒子状态的每个单粒子状态都有相同的时间。因此，我们将直接使用粒子编号0的时间。以下是实例声明：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We use pattern matching on the input to define the function `timeOf`. By giving
    the data constructor `MPS` followed by a list, we have access to that list in
    the body of the function and can use the list element operator (`!!`).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对输入使用模式匹配来定义`timeOf`函数。通过给数据构造器`MPS`后跟一个列表，我们可以在函数体内访问该列表，并使用列表元素操作符（`!!`）。
- en: In the next chapter, we’ll animate a system of two masses and two springs. The
    animation uses `simulateVis`, which uses `timeOf`. Since the state space for that
    animation is `MultiParticleState`, `simulateVis` needs the `timeOf` that goes
    with `MultiParticleState`, which is exactly what the instance declaration provides.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将为两个质量和两个弹簧制作动画。该动画使用了`simulateVis`，它依赖于`timeOf`。由于该动画的状态空间是`MultiParticleState`，`simulateVis`需要与`MultiParticleState`相对应的`timeOf`，这正是实例声明所提供的内容。
- en: 'Recall that in [Chapter 16](ch16.xhtml) we introduced the data type `DParticleState`
    to hold the time derivatives of the state variables in `ParticleState`. Here,
    in the many-particle setting, we do something similar and define a new data type
    `DMultiParticleState` to hold the time derivatives of the state variables in `MultiParticleState`.
    Here is the data type definition:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，在[第16章](ch16.xhtml)中，我们介绍了数据类型`DParticleState`，用于保存`ParticleState`中状态变量的时间导数。在这里，在多粒子设置中，我们做了类似的事情，定义了一个新的数据类型`DMultiParticleState`，用于保存`MultiParticleState`中状态变量的时间导数。以下是该数据类型的定义：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can see from this definition that we are just packaging a list of `DParticleState`s,
    analogous to the way we packaged a list of `ParticleState`s in the data type definition
    above for `MultiParticleState`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个定义中可以看出，我们只是在打包一个`DParticleState`的列表，这类似于我们在上面为`MultiParticleState`的定义中打包`ParticleState`列表的方式。
- en: With a new data type in hand to represent the state of a multi-particle system,
    let us turn to the question of how that state evolves in time—in other words,
    how the state gets updated.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有了一个新的数据类型来表示多粒子系统的状态后，我们接下来要讨论的是该状态如何随时间演化——换句话说，状态是如何更新的。
- en: State Update for Multiple Particles
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多粒子状态更新
- en: For a system of multiple particles, [Figure 19-2](ch19.xhtml#ch19fig2) gives
    an overview of the data representations and functions that transform among them,
    much as [Figure 16-3](ch16.xhtml#ch16fig3) did for a single particle.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多个粒子的系统，[图 19-2](ch19.xhtml#ch19fig2)提供了数据表示和在它们之间转换的函数的概述，类似于[图 16-3](ch16.xhtml#ch16fig3)在单粒子情况下的展示。
- en: '![Image](Images/352fig01.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/352fig01.jpg)'
- en: '*Figure 19-2: Data representations and functions that transform among them*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 19-2：数据表示和在它们之间转换的函数*'
- en: The four representations are forces, differential equation, state-update function,
    and evolver. In the next section, we’ll discuss Newton’s second law and the function
    `newtonSecondMPS` that implements it in the multi-particle setting. We’ll see
    how to use our numerical methods in this setting, and we’ll define the composite
    functions `updateMPS` and `statesMPS` that are shown in [Figure 19-2](ch19.xhtml#ch19fig2).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 四种表示方法分别是：力、微分方程、状态更新函数和演化器。在下一节中，我们将讨论牛顿第二定律以及在多粒子系统中实现它的函数`newtonSecondMPS`。我们将看到如何在这种设置中使用数值方法，并且定义在[图
    19-2](ch19.xhtml#ch19fig2)中显示的复合函数`updateMPS`和`statesMPS`。
- en: Implementing Newton’s Second Law
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现牛顿第二定律
- en: For a system of interacting particles, both Newton’s second law and Newton’s
    third law are involved in producing a differential equation. [Figure 19-3](ch19.xhtml#ch19fig3)
    shows a schematic diagram for a two-body mechanics problem.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于相互作用的粒子系统，牛顿第二定律和牛顿第三定律都参与了微分方程的形成。[图 19-3](ch19.xhtml#ch19fig3)展示了一个两体力学问题的示意图。
- en: '![Image](Images/353fig01.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/353fig01.jpg)'
- en: '*Figure 19-3: Schematic representation of Newton’s second law and Newton’s
    third law working together in a two-body situation. The two bodies interact with
    each other, and each body has external forces acting on it as well.*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 19-3：牛顿第二定律和牛顿第三定律在两体问题中共同作用的示意图。两个物体相互作用，每个物体也有外力作用在它们身上。*'
- en: The function **F**[1e], shown in the upper left of [Figure 19-3](ch19.xhtml#ch19fig3),
    produces the net external force on particle 1\. The external forces on particle
    1 can depend on time, the position of particle 1, and the velocity of particle
    1\. These three quantities are shown as inputs to **F**[1e]. We find the net external
    force on particle 1 by supplying the inputs to the function to form **F**[1e](*t*,
    **r**[1] (*t*), **v**[1] (*t*)). If there are multiple external forces acting
    on particle 1, they need to be added together (as vectors). The function **F**[1e]
    needs to return this sum.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 函数**F**[1e]，如[图 19-3](ch19.xhtml#ch19fig3)左上角所示，表示粒子1上的净外力。粒子1上的外力可能依赖于时间、粒子1的位置和粒子1的速度。这三个量作为输入传递给**F**[1e]。我们通过向该函数提供输入来求得粒子1的净外力，形成**F**[1e](*t*,
    **r**[1] (*t*), **v**[1] (*t*)）。如果有多个外力作用于粒子1，它们需要（按向量）相加。函数**F**[1e]需要返回这个和。
- en: Moving down the diagram from **F**[1e], we find a summation that adds together
    the net external force and the net internal force to produce the net force on
    particle 1 that appears in Newton’s second law. We’ll talk about the net internal
    force shortly; for now let’s keep moving down the left column of the diagram.
    Newton’s second law says that dividing the net force on particle 1 by the mass
    of particle 1 will give the acceleration of particle 1\. Integrating the acceleration
    produces the velocity, and integrating the velocity produces the position. The
    position and velocity of particle 1 feed back as inputs to the net external force
    function **F**[1e].
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 从**F**[1e]向下移动图示，我们找到一个求和过程，它将净外力和净内力相加，得到粒子1上的净力，这出现在牛顿第二定律中。我们稍后会讨论净内力；现在先继续向下移动图示的左列。牛顿第二定律表示，将粒子1上的净力除以粒子1的质量会得到粒子1的加速度。对加速度进行积分得到速度，再对速度进行积分得到位置。粒子1的位置和速度作为输入反馈给净外力函数**F**[1e]。
- en: The position and velocity of particle 1 also get combined with those of particle
    2, governed by the right column of [Figure 19-3](ch19.xhtml#ch19fig3), to produce
    a relative position and a relative velocity that serve as inputs to **F**[21],
    the internal force of particle 1 on particle 2\. If particle 1 exerts multiple
    forces on particle 2, perhaps a spring force and an electrical force, these must
    be added as vectors to form **F**[21](**r**[2](*t*) – **r**[1](*t*),**v**[2](*t*)
    – **v**[1](*t*)), the net internal force of particle 1 on particle 2\. An internal
    force between two particles shouldn’t depend explicitly on time, and it should
    depend on the positions and velocities of the two particles only through their
    relative values. All of the two-body forces we introduced earlier in the chapter
    have this property.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子1的位置和速度也与粒子2的位置和速度结合，根据[图19-3](ch19.xhtml#ch19fig3)的右列，产生一个相对位置和相对速度，作为**F**[21]的输入，即粒子1对粒子2的内力。如果粒子1对粒子2施加多个力，比如弹簧力和电力，这些力必须作为矢量相加，形成**F**[21](**r**[2](*t*)
    – **r**[1](*t*),**v**[2](*t*) – **v**[1](*t*)), 即粒子1对粒子2的净内力。两个粒子之间的内力不应显式依赖于时间，而应仅通过它们的相对值依赖于两粒子的位置和速度。我们在本章早些时候介绍的所有二体力都具有这一性质。
- en: Since **F**[21](**r**[2](*t*) – **r**[1](*t*),**v**[2](*t*) – **v**[1](*t*))
    is the force on particle 2, it goes straight into the summation on the right to
    be added to the net external force on particle 2\. By Newton’s third law, the
    force on particle 1 produced by particle 2 is equal and opposite to this, hence
    the multiplication by –1 to produce the net internal force on particle 1 before
    it gets added to the net external force on particle 1.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于**F**[21](**r**[2](*t*) – **r**[1](*t*),**v**[2](*t*) – **v**[1](*t*))是粒子2上的力，它直接进入右侧的求和，与粒子2上的净外力相加。根据牛顿第三定律，粒子1所受的力等于粒子2对粒子1的作用力且方向相反，因此乘以-1，得到粒子1上的净内力，然后与粒子1上的净外力相加。
- en: Time is produced by integrating the constant 1, as in our previous schematic
    diagrams. Time is an input to each of the net external force functions, but not
    to the net internal force function.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 时间是通过对常数1进行积分来生成的，就像我们之前的示意图那样。时间是每个净外力函数的输入，但不是净内力函数的输入。
- en: To summarize [Figure 19-3](ch19.xhtml#ch19fig3), the internal and external forces
    on each particle must be added together to form the net force on the particle,
    which, per Newton’s second law, gets divided by its mass to calculate the acceleration
    of the particle. Newton’s third law is carried out in the center column, where
    the force of interaction is calculated, sent unchanged to particle 2, and sent
    negated to particle 1\. The internal forces express the interaction between the
    two particles, while the external forces represent interactions with things outside
    of the system. All of the feedback means that a set of coupled differential equations
    will be the mathematical expression of a multi-particle mechanics problem.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 总结[图19-3](ch19.xhtml#ch19fig3)，每个粒子上的内力和外力必须加在一起，形成粒子上的净力，根据牛顿第二定律，净力除以粒子的质量即可计算粒子的加速度。牛顿第三定律在中间列中得以体现，在那里计算出相互作用的力，将其不变地传送给粒子2，并将其取反后传送给粒子1。内力表达了两个粒子之间的相互作用，而外力则代表了与系统外部事物的相互作用。所有这些反馈意味着一组耦合的微分方程将是多粒子力学问题的数学表达。
- en: We can write Newton’s second law as a set of coupled differential equations.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将牛顿第二定律写成一组耦合的微分方程。
- en: '![Image](Images/354equ01.jpg)![Image](Images/354equ02.jpg)![Image](Images/354equ03.jpg)![Image](Images/354equ04.jpg)![Image](Images/354equ05.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/354equ01.jpg)![Image](Images/354equ02.jpg)![Image](Images/354equ03.jpg)![Image](Images/354equ04.jpg)![Image](Images/354equ05.jpg)'
- en: The time derivative of time is 1, as in single-particle mechanics. The time
    derivative of position is velocity, and this holds for each particle. The time
    derivative of velocity is acceleration, which is found by dividing net force by
    mass for each particle. The net force on a particle is the sum of the net external
    force and the net internal force. The function **F**[2*e*] produces the net external
    force on particle 2 when given the time, the position of particle 2, and the velocity
    of particle 2\. The function **F**[*mn*] produces the internal force of particle
    *n* on particle *m* when given the relative position and relative velocity of
    particles *m* and *n*. The net internal force on particle 2, for example, is
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 时间的时间导数为1，就像单粒子力学中一样。位置的时间导数是速度，这对每个粒子都成立。速度的时间导数是加速度，它是通过对每个粒子将净力除以质量得到的。粒子上的净力是净外力和净内力的总和。函数**F**[2*e*]在给定时间、粒子2的位置和粒子2的速度时，产生粒子2的净外力。函数**F**[*mn*]在给定粒子*m*和*n*的相对位置和相对速度时，产生粒子*n*对粒子*m*的内力。例如，粒子2上的净内力是：
- en: '![Image](Images/355fig01.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/355fig01.jpg)'
- en: where we add the internal forces produced by all of the other particles in the
    system. We have only given equations for the first two particles in a system,
    but there is a similar pair of equations for every particle in the system. Hopefully
    the pattern is clear.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里添加了系统中所有其他粒子产生的内力。我们仅为系统中的前两个粒子给出了方程，但每个粒子都有一对类似的方程。希望这个模式是清晰的。
- en: 'In [Chapter 16](ch16.xhtml), which was concerned with the motion of a single
    particle, we used the function `newtonSecondPS` to transform a list of forces
    into a differential equation. We would now like an analogous function for multiple
    particles. We would like a function with the following type signature:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第16章](ch16.xhtml)中，我们讨论的是单个粒子的运动，我们使用了`newtonSecondPS`函数将一系列力转换为微分方程。现在我们希望为多个粒子提供一个类似的函数。我们希望有一个如下类型签名的函数：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The name of this function has *MPS* on the end to remind us that it works with
    the `MultiParticleState` state space.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的名字以*MPS*结尾，提醒我们它与`MultiParticleState`状态空间一起工作。
- en: 'Our plan is to apply Newton’s second law to each particle in the system. For
    each particle, we identify all of the external and internal forces that act on
    it, and we transform each of these into a one-body force. Once we have the list
    of one-body forces that act on a particle, we can use the function `newtonSecondPS`
    to calculate the time derivatives of all the state variables for that particle.
    When we have the time derivatives of each state variable for each particle, we’ll
    bundle it all up and ask `newtonSecondMPS` to return that bundle. Here’s the code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的计划是将牛顿第二定律应用于系统中的每个粒子。对于每个粒子，我们识别作用于它的所有外力和内力，并将每个内力转化为一个单体力。一旦我们得到了作用于粒子的所有单体力的列表，我们就可以使用`newtonSecondPS`函数计算该粒子的所有状态变量的时间导数。当我们获得每个粒子每个状态变量的时间导数时，我们将把所有这些合并起来，并请求`newtonSecondMPS`返回这个合并结果。以下是代码：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first line in the code names the incoming list of forces `fs` and gives
    *two* names to the incoming multi-particle state. When placed between two names
    on the left side of a definition, the `@` (“at symbol”) allows the code writer
    to give a simple identifier to the incoming value *and* simultaneously do pattern
    matching on the input. The simple identifier `mpst` stands for the incoming multi-particle
    state with type `MultiParticleState`. Since it appears underneath the data constructor
    `MPS`, the name `sts` stands for the list of single-particle states (type `[ParticleState]`).
    We want to use both `mpst` and `sts` in our definition.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第一行命名了传入的力列表`fs`，并给传入的多粒子状态指定了*两个*名称。当出现在定义的左侧两个名称之间时，`@`（“at符号”）允许代码编写者为传入值提供一个简单的标识符，并同时对输入进行模式匹配。简单标识符`mpst`代表传入的多粒子状态，类型为`MultiParticleState`。由于它出现在数据构造器`MPS`下方，因此名称`sts`代表单粒子状态的列表，类型为`[ParticleState]`。我们希望在定义中使用`mpst`和`sts`。
- en: In the second line of code, we define a local function `deriv` to calculate
    the time derivatives of single-particle state variables. Its argument `(n,st)`
    is a pair of particle number and single-particle state. Its return value is a
    collection of derivatives (type `DParticleState`). This local function uses `newtonSecondPS`
    to calculate the derivatives. The expression `forcesOn n mpst fs` is the list
    of one-body forces that act on particle number `n` when the multi-particle state
    is `mpst` and the list of all system forces (external and internal) is `fs`. We
    will write the function `forcesOn` next.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的第二行，我们定义了一个局部函数`deriv`，用于计算单粒子状态变量的时间导数。它的参数`(n, st)`是粒子编号和单粒子状态的一个对。它的返回值是导数的集合（类型为`DParticleState`）。这个局部函数使用`newtonSecondPS`来计算导数。表达式`forcesOn
    n mpst fs`是作用在粒子编号`n`上的单粒子力的列表，其中多粒子状态为`mpst`，而所有系统力（包括外力和内力）为`fs`。接下来，我们将编写`forcesOn`函数。
- en: In the final line, we zip together particle numbers with associated particle
    states to make a list of number-state pairs. We then map the local function `deriv`
    onto that list, producing a list of time derivatives of single-particle states
    (type `[DParticleState]`). Finally, we apply the `DMPS` data constructor to form
    the time multi-particle state derivative (type `DMultiParticleState`).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行，我们将粒子编号与相应的粒子状态组合在一起，形成一个编号-状态对的列表。然后，我们对该列表应用局部函数`deriv`，得到单粒子状态的时间导数列表（类型为`[DParticleState]`）。最后，我们应用`DMPS`数据构造器来形成时间多粒子状态的导数（类型为`DMultiParticleState`）。
- en: From a physics standpoint, all we are doing is applying Newton’s second law
    to each particle in the system. The apparent complexity comes partly from our
    need to number the particles and partly from our desire to use clear types to
    represent the things we care about (such as internal and external forces). The
    clear types benefit us in two ways. First, types represent the important ideas
    in physics and help us think about them. Second, types help the compiler find
    our mistakes. By doing some of the heavy lifting in functions like this, we will
    end up with a collection of powerful functions that let us solve multi-particle
    problems with relative ease.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 从物理学的角度来看，我们所做的只是将牛顿第二定律应用到系统中的每个粒子。表面上的复杂性部分来自我们需要给粒子编号，部分来自我们希望使用清晰的类型来表示我们关心的事物（例如内部和外部力）。清晰的类型在两个方面对我们有帮助。首先，类型代表了物理学中的重要概念，并帮助我们思考这些概念。其次，类型帮助编译器发现我们的错误。通过在像这样的函数中做一些繁重的工作，我们最终会得到一组强大的函数，使我们能够相对容易地解决多粒子问题。
- en: 'How do we find the net force on each particle? In other words, how do we write
    the function `forcesOn` we used earlier? What type should `forcesOn` have? The
    function `forcesOn` needs to take a particle number, a multi-particle state, and
    a list of forces as inputs, and it needs to produce a list of one-body forces
    as output. Here is the type signature and the definition for `forcesOn`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何找到每个粒子的合力？换句话说，我们如何编写我们之前使用的`forcesOn`函数？`forcesOn`应该是什么类型？`forcesOn`函数需要接受一个粒子编号、一个多粒子状态和一个力列表作为输入，并且它需要输出一个单粒子力的列表。这里是`forcesOn`的类型签名和定义：
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The incoming particle number is named `n`, and the incoming multi-particle state
    is named `mpst`. We don’t bother to name the list of forces, which means that
    `forcesOn n mpst` has type `[Force] -> [OneBodyForce]`. You can see from the definition
    that `forcesOn` passes most of the work on to another as-yet-undefined function
    called `forceOn` (note the dropped *s*). The idea is that the function `forceOn
    n mpst` has type `Force -> OneBodyForce` and transforms an external or internal
    force in the list of system forces into a one-body force acting on particle `n`.
    If we can transform a single force, we can use `map` to transform a list of forces.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 传入的粒子编号命名为`n`，传入的多粒子状态命名为`mpst`。我们不需要给力列表命名，这意味着`forcesOn n mpst`的类型为`[Force]
    -> [OneBodyForce]`。从定义中可以看出，`forcesOn`将大部分工作委托给另一个尚未定义的函数`forceOn`（注意省略了*s*）。其思想是，函数`forceOn
    n mpst`的类型为`Force -> OneBodyForce`，将系统力列表中的外力或内力转换为作用在粒子`n`上的单粒子力。如果我们能转换单个力，我们就可以使用`map`来转换力的列表。
- en: The function `forceOn` needs to deal with both external and internal forces.
    External forces are easier. We just have to check whether the external force acts
    on particle `n`. If so, we return the one-body force held inside the external
    force. If not, we make up a one-body force that is zero.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`forceOn`需要处理外力和内力。外力较为简单。我们只需检查外力是否作用于粒子`n`。如果是，我们返回外力内包含的单粒子力。如果不是，我们就构造一个值为零的单粒子力。
- en: 'For an internal force, we need to check whether either of the particle numbers
    specified in the internal force are particle number `n` that we care about. If
    so, we use the `oneFromTwo` function written earlier in the chapter that constructs
    a one-body force from a two-body force. If not, we again make up a zero force.
    Here is the code for `forceOn`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于内力，我们需要检查内力中指定的两个粒子编号是否与我们关心的粒子编号`n`匹配。如果匹配，我们使用前面章节中编写的`oneFromTwo`函数，将双体力转换为单体力。如果不匹配，我们再次构造一个零力。以下是`forceOn`的代码：
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The function uses pattern matching on the `Force` input, so there is one part
    of the definition for each of the two data constructors of `Force` (that is, one
    part for an external force and a second part for an internal force). This definition
    uses a Haskell feature called *guards*. A guard is the vertical bar on the left
    of several of the lines of code. The guard is a convenient alternative to an `if-then-else`
    construction, especially when there are more than two possibilities, as in the
    part of the definition that works with internal forces.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数对`Force`输入使用模式匹配，因此每个`Force`数据构造函数（即外力和内力）都有一部分定义。这个定义使用了Haskell中的*守卫*功能。守卫就是代码中几行左侧的竖线，它是`if-then-else`结构的一个便捷替代方案，尤其当有多个可能性时，比如处理内力的部分。
- en: 'Each line in the guard construction consists of four items: a vertical bar,
    a Boolean condition, an equal sign, and a result. At each vertical bar, the condition
    is checked. If the condition is true, the corresponding result is returned; if
    the condition is false, we go to the next vertical bar and repeat the process.
    It is good practice for the condition in the last guard line to be `otherwise`,
    which is just another name for `True`. By using `otherwise`, we are guaranteed
    that one of the guard conditions will hold and consequently that one of the results
    will be returned.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`guard`构造中的每一行由四个部分组成：竖线、布尔条件、等号和结果。在每个竖线处都会检查条件。如果条件为真，则返回对应的结果；如果条件为假，则继续检查下一个竖线并重复此过程。最后一行的条件通常使用`otherwise`，它实际上就是`True`的另一种表示方式。通过使用`otherwise`，我们可以确保至少有一个守卫条件为真，从而返回相应的结果。'
- en: The first part of the definition for `forceOn` is for an external force. We
    check whether particle number `n`, the particle we are currently interested in,
    matches particle number `n0`, the particle on which the current external force
    acts. If they match, we return the one-body force `fOneBody` contained in the
    external force. If they don’t match, we return the one-body force `const zeroV`,
    a one-body force that ignores the state of the particle and simply returns the
    zero vector.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`forceOn`定义的第一部分用于外力。我们检查粒子编号`n`（即我们当前关心的粒子）是否与外力作用的粒子编号`n0`匹配。如果匹配，返回外力中包含的单体力`fOneBody`；如果不匹配，则返回一个忽略粒子状态、简单返回零向量的单体力`const
    zeroV`。'
- en: The second part of the definition for `forceOn` is for an internal force. An
    internal force involves two particles; if the particle we care about is either
    of these, the function needs to return the appropriate one-body force. We first
    check whether particle number `n`, the particle we are currently interested in,
    matches particle number `n0`, the first of the two particles involved in the internal
    force. If `n` equals `n0`, we are interested in the force that particle `n1` exerts
    on particle `n0`. We provide `oneFromTwo`, the function we wrote earlier in the
    chapter to convert a two-body force to a one-body force, with the single-particle
    state for `n1`, called `sts !! n1`, and the two-body force contained in the internal
    force, called `fTwoBody`. The function `oneFromTwo` returns the one-body force
    that acts on particle `n`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`forceOn`定义的第二部分用于处理内力。内力涉及两个粒子；如果我们关心的粒子是其中之一，函数需要返回适当的单体力。我们首先检查粒子编号`n`（即我们当前关心的粒子）是否与内力中涉及的两个粒子之一的编号`n0`匹配。如果`n`等于`n0`，我们就关心粒子`n1`对粒子`n0`施加的力。我们将前面章节中写的`oneFromTwo`函数提供给粒子`n1`的单体状态（即`sts
    !! n1`）和内力中包含的双体力（即`fTwoBody`）。`oneFromTwo`函数返回作用于粒子`n`的单体力。'
- en: If `n` does not equal `n0`, we check whether `n` equals `n1`, the other particle
    involved in the internal force under consideration. If so, we are interested in
    the force that particle `n0` exerts on particle `n1`. We provide `oneFromTwo`
    with the single-particle state for `n0`, called `sts !! n0`, and with the two-body
    force contained in the internal force. The function `oneFromTwo` again returns
    the one-body force that acts on particle `n`. Finally, if particle `n` matches
    neither `n0` nor `n1`, we return a zero force.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`n`不等于`n0`，我们检查`n`是否等于`n1`，即参与内力作用的另一个粒子。如果是这样，我们关心的是粒子`n0`对粒子`n1`施加的力。我们为`oneFromTwo`提供粒子`n0`的单粒子状态，称为`sts
    !! n0`，以及内力中的双体力。函数`oneFromTwo`再次返回作用在粒子`n`上的单体力。最后，如果粒子`n`既不匹配`n0`也不匹配`n1`，我们返回零力。
- en: The part of the definition of `forceOn` that deals with an internal force is
    how we apply Newton’s third law. This is the part that guarantees the forces will
    be equal and opposite because they come from the same internal force. For each
    of the two particles involved, we use the same two-body force to produce the one-body
    force that acts on each particle; only the single-particle states are interchanged.
    Since a two-body force has the property that particle interchange negates the
    force, Newton’s third law is automatically applied. We can’t make the mistake
    of remembering that `n1` exerts a force on `n0` but forgetting that `n0` exerts
    a force on `n1`. Our language of internal forces and our code to deal with them
    ensure that Newton’s third law holds without further attention from the code writer.
    In particular, each time we investigate a new multi-particle system, all we give
    is a list of external and internal forces. We don’t have to ensure that the force
    `n1` exerts on `n0` is equal and opposite to the force `n0` exerts on `n1`. Haskell
    deals with this automatically.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`forceOn`定义中处理内力的部分是我们如何应用牛顿第三定律的部分。这一部分保证了力的大小和方向相等且相反，因为它们来自同一个内力。对于涉及的两个粒子，我们使用相同的双体力来产生作用在每个粒子上的单体力；只有单粒子状态被互换。由于双体力具有粒子交换会抵消力的特性，牛顿第三定律自动得到应用。我们不会犯这样的错误：记得`n1`对`n0`施加力，却忘了`n0`对`n1`施加力。我们对内力的语言和处理它们的代码确保了牛顿第三定律在没有程序员额外注意的情况下自动得以满足。特别是，每次我们研究一个新的多粒子系统时，我们提供的只是外力和内力的列表。我们不需要确保`n1`对`n0`施加的力与`n0`对`n1`施加的力相等且方向相反。Haskell会自动处理这一切。'
- en: Numerical Methods for Multiple Particles
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 多粒子的数值方法
- en: 'Recall that the Euler and fourth-order Runge-Kutta methods are general methods
    for solving any differential equation. At the end of [Chapter 15](ch15.xhtml),
    we wrote functions `euler` and `rungeKutta4` that work with any state space `s`
    that is an instance of type class `RealVectorSpace`. To make these two functions
    usable with the `MultiParticleState` state space, we need to write two instance
    declarations. Here they are:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，欧拉法和四阶龙格-库塔法是求解任何微分方程的通用方法。在[第15章](ch15.xhtml)的末尾，我们编写了函数`euler`和`rungeKutta4`，它们适用于任何状态空间`s`，该状态空间是`RealVectorSpace`类型类的一个实例。为了使这两个函数能够与`MultiParticleState`状态空间一起使用，我们需要编写两个实例声明。它们如下所示：
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The content of this instance declaration is that the sum of two multi-particle
    states is just the particle-wise sum.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实例声明的内容是两个多粒子状态的和就是每个粒子的逐个和。
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This instance declaration says that “shifting” a multi-particle state by a state
    derivative is just shifting each single-particle state by the associated single-particle
    state derivative.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实例声明表示“通过状态导数对多粒子状态进行‘平移’”只是将每个单粒子状态平移由相关的单粒子状态导数所平移。
- en: 'The Euler-Cromer method is not a general method for any differential equation,
    so we need to write an explicit numerical method for Euler-Cromer as it applies
    to the `MultiParticleState` data type. Here it is:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 欧拉-克罗梅尔方法并不是适用于所有微分方程的通用方法，因此我们需要为欧拉-克罗梅尔方法编写一个显式的数值方法，适用于`MultiParticleState`数据类型。它如下所示：
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We choose to calculate the Euler-Cromer derivatives by first taking an Euler
    step, which is easy to do and correctly updates the mass, charge, time, and velocity
    for each particle. However, the position needs to be fixed because it needs to
    be based on the updated velocity. The local variable `mpst0` stands for the incoming
    multi-particle state, while `mpst1` stands for the Euler-updated multi-particle
    state. The variables `sts0` and `sts1` are the lists of single-particle states
    underneath the `MPS` data constructor for the incoming and Euler-updated multi-particle
    states.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择通过首先进行欧拉步来计算欧拉-克罗梅尔导数，这样操作简单，能够正确更新每个粒子的质量、电荷、时间和速度。然而，位置需要被修正，因为它需要基于更新后的速度。局部变量`mpst0`代表传入的多粒子状态，而`mpst1`代表经过欧拉更新的多粒子状态。变量`sts0`和`sts1`是传入和欧拉更新后的多粒子状态下的单粒子状态列表。
- en: To form the Euler-Cromer-updated multi-particle state, we use a list comprehension
    to go through all the particles and apply the Euler-Cromer update Equation 15.10,
    which updates the incoming position with the Euler-updated velocity.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了形成欧拉-克罗梅尔更新后的多粒子状态，我们使用列表推导来遍历所有粒子，并应用欧拉-克罗梅尔更新公式15.10，该公式用欧拉更新后的速度更新传入的位置。
- en: Composite Functions
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 复合函数
- en: 'As in the single-particle situation, it’s convenient to have composite functions
    that take two or three steps in [Figure 19-2](ch19.xhtml#ch19fig2). The function
    `updateMPS` is the composition of Newton’s second law with a numerical method
    and is useful for animation. You can see from its definition that it’s just this
    composition:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 与单粒子情况一样，方便的是有复合函数，这些复合函数在[图19-2](ch19.xhtml#ch19fig2)中包含两步或三步操作。函数`updateMPS`是牛顿第二定律与数值方法的组合，适用于动画。你可以从其定义中看到，它正是这种组合：
- en: '[PRE27]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The function `solver` in [Figure 19-2](ch19.xhtml#ch19fig2) also takes two steps
    in data representations, solving a differential equation by producing an evolver
    that can then generate a list of states from an initial state. We wrote `solver`
    in [Chapter 15](ch15.xhtml), and that code works just fine in the multi-particle
    setting.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[图19-2](ch19.xhtml#ch19fig2)中的函数`solver`也采取了数据表示中的两步，通过生成一个可以从初始状态生成状态列表的进化器来求解微分方程。我们在[第15章](ch15.xhtml)编写了`solver`，这段代码在多粒子环境中运行得很好。'
- en: 'The function `statesMPS` takes all three steps in [Figure 19-2](ch19.xhtml#ch19fig2),
    transforming a list of forces into an evolver. Its definition is what you would
    expect: a composition of Newton’s second law, a numerical method, and iteration.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`statesMPS`包含[图19-2](ch19.xhtml#ch19fig2)中的所有三步，将力的列表转化为一个进化器。其定义就是你所预期的：牛顿第二定律、数值方法和迭代的组合。
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we applied Newtonian mechanics to multiple interacting objects
    moving in three dimensions. Newton’s third law governs the interaction between
    particles. A two-body force is a force that depends on the states of two particles.
    We classify the forces that act on particles in our system into internal forces,
    which are produced by other particles in our system, and external forces, which
    are produced by something outside of our system. The state of a system of particles
    is described by giving the single-particle states for each of the particles in
    the system. Our `MultiParticleState` data type does exactly that. Our state-update
    procedure is still based on Newton’s second law, but now it automatically applies
    Newton’s third law to all internal forces.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将牛顿力学应用于多个在三维空间中相互作用的物体。牛顿第三定律支配粒子之间的相互作用。双粒子力是依赖于两粒子状态的力。我们将作用在系统中粒子上的力分为内力和外力，内力由系统内的其他粒子产生，外力则由系统外部的事物产生。粒子系统的状态通过给出每个粒子的单粒子状态来描述。我们的`MultiParticleState`数据类型正是做到了这一点。我们的状态更新过程仍然基于牛顿第二定律，但现在它会自动将牛顿第三定律应用于所有的内力。
- en: As in the single-particle situation, solving a mechanics problem is still a
    process of transforming information through a sequence of four representations.
    For the multi-particle case, we start with a list of internal and external forces,
    produce a differential equation, produce a state-update function, and finally
    produce a list of multi-particle states.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 与单粒子情况一样，解决力学问题仍然是通过一系列四种表示形式转换信息的过程。对于多粒子情况，我们首先列出内外力，产生一个微分方程，产生一个状态更新函数，最后生成多粒子状态列表。
- en: The process of producing the differential equation from the forces has evolved
    over the course of [Part II](part02.xhtml) of this book. Newton’s second law is
    always present, but the state has contained more information as we moved from
    one dimension to three dimensions to multiple particles. [Table 19-2](ch19.xhtml#ch19tab2)
    shows the functions we have used to carry out Newton’s second law by producing
    a differential equation. The function `newtonSecondV` is for one particle in one
    dimension when the forces depend only on velocity. The function `newtonSecondTV`
    is for one particle in one dimension when the forces depend only on time and velocity.
    The function `newtonSecond1D` is for one particle in one dimension when the forces
    could depend on any combination of time, position, or velocity. The function `newtonSecondPS`
    is for one particle in three dimensions when the forces could depend on time,
    position, or velocity. Finally, the function `newtonSecondMPS` is for multiple
    particles in three dimensions where the forces could depend on time, position,
    or velocity.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 19-2:** Functions for Newton’s Second Law'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Type** |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
- en: '| `newtonSecondV` | `Mass ->``[Velocity -> Force] -> Velocity -> R` |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
- en: '| `newtonSecondTV` | `Mass ->``[(Time, Velocity) -> Force] -> (Time, Velocity)
    -> (R, R)` |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
- en: '| `newtonSecond1D` | `Mass ->``[State1D -> Force] -> State1D -> (R, R, R)`
    |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
- en: '| `newtonSecondPS` | `[OneBodyForce] -> ParticleState -> DParticleState` |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
- en: '| `newtonSecondMPS` | `[Force] -> MultiParticleState -> DMultiParticleState`
    |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
- en: We have used the type `Force` in two different ways over the course of [Part
    II](part02.xhtml). In a one-dimensional setting, `Force` is simply a type synonym
    for a real number. In the three-dimensional, multi-particle setting of this chapter,
    the definition of `Force` is much more complex, describing a data type that could
    be an internal force or an external force and including the dependence of force
    on state. We have come a long way. In the next chapter, we’ll apply these ideas
    to specific examples of interacting particles and animate our results.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise 19.1.** Write a function `speed`'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: that returns the speed of a particle from its state.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 19.2.** We could use pattern matching on the input rather than extraction
    functions to write the two-body force for universal gravity. The resulting definition
    has the benefit of being a bit shorter. Complete the following definition:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**Exercise 19.3.** Universal gravity is a central force. Use the function `centralForce`
    to write the function'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: that expresses the same two-body force as `universalGravity`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 19.4.** Our constant repulsive force is a central force. Rewrite
    the constant repulsive force using `centralForce`.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 19.5.** No real spring is completely linear across its entire range.
    In Exercise 15.10, we introduced the Lennard-Jones spring as an example of a nonlinear
    spring.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'The force on end 2 of the spring is given by the following expression, in which
    *r[e]* is the equilibrium length and *D[e]* is the dissociation energy (that is,
    the energy required to extend the spring so that the ends are very far apart):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 弹簧末端 2 处的力由以下表达式给出，其中 *r[e]* 是平衡长度，*D[e]* 是解离能（即，拉伸弹簧使两端非常远的所需能量）：
- en: '![Image](Images/361equ01.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/361equ01.jpg)'
- en: If *r*[21] < *r[e]*, the force on particle 2 will be in the direction of **r**[21],
    which is repulsive. If *r*[21] > *r[e]*, the force on particle 2 will be in the
    direction of –**r**[21], which is attractive.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *r*[21] < *r[e]*，粒子 2 上的力将在 **r**[21] 方向上，这表示排斥。如果 *r*[21] > *r[e]*，粒子 2
    上的力将在 –**r**[21] 方向上，这表示吸引。
- en: Write the function `lennardJones`, which takes a dissociation energy and an
    equilibrium length and returns a two-body force for the Lennard-Jones spring.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 编写函数 `lennardJones`，它接受解离能和平衡长度并返回 Lennard-Jones 弹簧的二体力。
- en: '[PRE32]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '**Exercise 19.6.** Write a function `systemKE`'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题 19.6.** 编写一个函数`systemKE`'
- en: '[PRE33]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: that returns the kinetic energy of a system of particles by adding up the kinetic
    energy of each particle.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数返回一个粒子系统的动能，通过将每个粒子的动能加起来。
- en: '**Exercise 19.7.** Each wire in a schematic diagram can be labeled with a type.
    Label each wire in [Figure 19-3](ch19.xhtml#ch19fig3) with a type.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题 19.7.** 每个示意图中的导线可以用类型标记。请在[图 19-3](ch19.xhtml#ch19fig3)中标记每条导线的类型。'
- en: '**Exercise 19.8.** An alternative way to write the function `forcesOn` is to
    form the list of one-body forces by appending a list of one-body forces that come
    from external forces to a list of one-body forces that come from internal forces.
    This method has the advantage of not requiring us to make up any fake zero forces
    and not needing the function `forceOn`.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题 19.8.** 编写函数 `forcesOn` 的另一种方式是，通过将外力产生的单体力列表附加到由内力产生的单体力列表，形成一个单体力列表。该方法的优点是我们不需要构造任何虚假的零力，也不需要函数
    `forceOn`。'
- en: '[PRE34]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In defining the function `internalForcesOn`, we use pattern matching inside
    a list comprehension. We exclude any force that does not match the pattern. Following
    the model of `internalForcesOn`, write the function `externalForcesOn`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义函数 `internalForcesOn` 时，我们在列表推导式中使用模式匹配。我们排除任何不匹配模式的力。根据 `internalForcesOn`
    的模型，编写函数 `externalForcesOn`。
