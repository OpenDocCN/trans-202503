- en: '19'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: INTERACTING PARTICLES
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In Newtonian mechanics, forces that act on particles are produced by other
    particles. The goal of this chapter is to develop the key ideas that will allow
    us to predict the motion of multiple interacting particles: Newton’s third law,
    the two-body force, and the distinction between internal and external forces.
    As usual, we’ll express these ideas in code.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll begin the chapter by discussing Newton’s third law. We’ll then develop
    the idea of a two-body force to express the notion that an interaction between
    two particles leads to one force produced by one particle on a second particle
    and simultaneously leads to another force produced by the second particle on the
    first particle. Two-body force is a significant enough idea in multi-particle
    situations that we’ll define a data type for two-body force. We’ll decide which
    particles are going to be in our system and then distinguish between an internal
    force and an external force. We’ll finish the chapter by considering the state
    of a multi-particle system and writing a state-update rule that automatically
    applies Newton’s third law, so we need not apply it manually. In the next chapter,
    we’ll apply the ideas discussed here to specific example situations.
  prefs: []
  type: TYPE_NORMAL
- en: Newton’s Third Law
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we stand on slippery ice and push our friend, we might find ourselves accelerating
    in the direction opposite from the way we pushed. We produced a force on our friend,
    but our friend also produced a force on us, whether or not that was their intention.
    Newton’s third law claims that these two forces are equal and opposite.
  prefs: []
  type: TYPE_NORMAL
- en: '**Newton’s third law, Newton’s words [**[15](bib.xhtml#bib15)**]**'
  prefs: []
  type: TYPE_NORMAL
- en: '*To any action there is always an opposite and equal reaction; in other words,
    the actions of two bodies upon each other are always equal and always opposite
    in direction.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Newton’s third law, modern version**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If object A exerts a force on object B, then object B exerts a force on object
    A. This second force is equal in magnitude to the first force, but opposite in
    direction.*'
  prefs: []
  type: TYPE_NORMAL
- en: When we say the *second* force, we’re not implying an order in time. The forces
    arise together, from the same process, whatever the interaction between the objects
    is.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with Newton’s second law, as we did in the previous five chapters,
    we’re only concerned with the forces that act *on* the object we’re applying Newton’s
    second law to. If an object also produces forces on other objects, that’s fine,
    but those forces only get counted when we apply Newton’s second law to one of
    those other objects. Newton’s second law cares about the forces *on* an object,
    not the forces produced *by* an object.
  prefs: []
  type: TYPE_NORMAL
- en: Newton’s third law, on the other hand, cares about both and asserts a relationship
    between them for each interaction. Newton’s second law applies to an object; Newton’s
    third law applies to an interaction between two objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 19-1](ch19.xhtml#ch19list1) shows the first lines of code for the
    `MultipleObjects` module we’ll develop in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 19-1: Opening lines of code for the `MultipleObjects` module*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should be familiar with the first line by now: it turns on warnings. The
    second line turns on a language option that allows us to use multiparameter type
    classes; we’ll explain this later in the chapter. We name the module `MultipleObjects`.
    We import the data types `Vec` and `R` from `SimpleVec` so we can refer to them
    in our type signatures. We also import the zero vector, the `magnitude` function,
    and the basic vector operators from `SimpleVec`. We use the type classes `RealVectorSpace`
    and `HasTime` to extend the general-purpose numerical methods `euler` and `rungeKutta4`
    to the multi-particle setting of this chapter. By making the new data type for
    multi-particle state an instance of these two type classes, we’ll be able to use
    the two general-purpose numerical methods. We import `newtonSecondPS`, the function
    that applies Newton’s second law to a single particle, to use in the function
    we write that applies Newton’s second law to a collection of particles. We import
    `euler` to use as a basis for writing an Euler-Cromer method for multiple particles.
    We’ll fill out the rest of the module as we move through the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be using the terms* body, object, *and* particle *interchangeably. A
    particle connotes a small thing; the words* body *and* object *sometimes connote
    things that are larger and have an orientation in space. Change in orientation
    is called* rotation, *and the study of objects with orientations that can rotate
    as well as move through space is called* rigid-body mechanics. *We won’t be getting
    into rigid-body mechanics here, although this chapter contains important prerequisite
    material for the subject. What we mean when using the word* body, object, *or*
    particle *is something that can experience forces, move, and accelerate through
    space but that either has no orientation or allows us to ignore its orientation.
    Sometimes the term point particle is used to emphasize that orientation is irrelevant.*'
  prefs: []
  type: TYPE_NORMAL
- en: Two-Body Forces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [Chapter 16](ch16.xhtml), we defined a `OneBodyForce` to be a function taking
    the state of a particle as input and producing a (vector) force on the particle
    as output. The one-body force is appropriate when the force acting on the one
    body depends only on that body’s state of affairs: namely, its position, velocity,
    mass, charge, or current time.'
  prefs: []
  type: TYPE_NORMAL
- en: Many forces in mechanics are fundamentally *two-body* in nature, meaning the
    force vector depends on the states of both the particle producing the force and
    the particle experiencing the force. A *two-body force* is a force that depends
    on the states of two particles.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The type `ForceVector` is a type synonym for `Vec`, the name suggesting that
    the particular vector we have in mind represents a force.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The force vector returned by a two-body force is produced *by* the particle
    whose state is given first in `TwoBodyForce`, and it acts *on* the particle whose
    state is given second. Let’s call this the *by-on convention*. The comments in
    the code just shown remind us of this convention.
  prefs: []
  type: TYPE_NORMAL
- en: Every two-body force we write should obey Newton’s third law. If the two particle
    states are exchanged, the force vector produced should be negated from what it
    was. That is, if `f` is a two-body force, the vector `f st2 st1` should be the
    negative of `f st1 st2`. Since the force acting on one particle is the negative
    of the force acting on the other, a convention like the by-on convention is important
    so that, for example, gravity acts as an attractive force and not as a repulsive
    force.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a relationship between a two-body force and a one-body force. Given
    the state of a particle that is producing a force, we can turn a two-body force
    into a one-body force by providing the two-body force with its first input and
    nothing else. This creates a function. The function takes the state of a particle
    on which the force acts and returns a force vector, making the function a one-body
    force. Here is the Haskell code to express this idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This code is deceptively simple. By applying the two-body force `f` to the state
    of the particle that is producing the force, we obtain a one-body force. The local
    variable `stBy` holds the state of the particle producing the force; equivalently,
    the force is produced *by* the particle with the state `stBy`.
  prefs: []
  type: TYPE_NORMAL
- en: If our brains worked more like the Haskell compiler, we might not bother to
    make this definition of `oneFromTwo` because in any place we use this function,
    we could achieve equivalent behavior with fewer keystrokes by omitting the name
    `oneFromTwo` and reversing the order of its arguments. However, my brain does
    not work enough like the Haskell compiler for this to be an easy or natural thing
    to do. I believe that this function, silly as it is for the Haskell compiler,
    offers value to the human reader and writer of code because it engages the ideas
    and terminology of mechanics, namely one- and two-body forces. With experience
    in programming, you will come across more ways of writing code that the compiler
    sees as equivalent but that sit differently on your brain. Use the flexibility
    of the language to write in a way that is easy for you, and perhaps others, to
    read and understand. Your code is not just for the computer; it’s for you and
    other people too.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the function `oneFromTwo` when we talk about springs later in the
    chapter. We’ll also use it when we want to collect all the forces that act on
    one particle.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at some examples of two-body forces. We need to be careful of two
    issues as we write a two-body force. First, a two-body force needs to respect
    Newton’s third law. To achieve this, as we will see in the examples that follow,
    the states of the two bodies need to be used in a symmetric way. (More precisely,
    the two states need to be used in an *anti-symmetric* way so that interchanging
    them produces a minus sign.) Second, we need to respect the by-on convention so
    we have a clear understanding of which body the force acts on. Haskell’s type
    system will not prevent us from mistakenly writing a `TwoBodyForce` that violates
    Newton’s third law, or one that returns the wrong force, so we need to be careful.
  prefs: []
  type: TYPE_NORMAL
- en: Universal Gravity
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Newton was the first to give a quantitative relationship describing the gravitational
    force between two massive spherical objects. He showed that the force exerted
    by one object on another is directly proportional to the mass of each object and
    inversely proportional to the square of the distance between their centers. As
    an equation, Newton’s law of universal gravity can be written as
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/343fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'where *m*[1] is the mass of object 1, *m*[2] is the mass of object 2, and *r*
    is the distance between the centers of the objects. This equation gives the magnitude
    of the force produced by object 1 on object 2 (which, by Newton’s third law, is
    the same as the magnitude of the force produced by object 2 on object 1). In SI
    units, the constant *G* = 6.67408 × 10^(–11) N m²/kg². Equation 19.1 can be translated
    into Haskell as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We can use vector notation to give a more comprehensive version of Newton’s
    law of universal gravity, which includes the direction of the force in the equation.
    Define the displacement vector **r**[21] to be the vector that points from particle
    1 to particle 2, as in [Figure 19-1](ch19.xhtml#ch19fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/343fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-1: The displacement vector r[21] points from particle 1 to particle
    2.*'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also define a unit vector ![Image](Images/e0343-02.jpg) to point in the
    direction from particle 1 to particle 2.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/343equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The force **F**[21] exerted on particle 2 produced by particle 1 is given in
    vector notation by replacing *r* in Equation 19.1 with |**r**[21]| and indicating
    the direction of the force with ![Image](Images/e0344-01.jpg) because the force
    on particle 2 points toward particle 1.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/344equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the force **F**[21] on object 2 points opposite to the displacement
    vector **r**[21]; that is, it points toward object 1\. This makes sense because
    gravity is an attractive force.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Equations 19.1 and 19.3, we see that Equation 19.1 is simpler, while
    Equation 19.3 is more powerful since the direction of the force is encoded in
    the equation.
  prefs: []
  type: TYPE_NORMAL
- en: 'If **r**[1] is the position vector for particle 1 and **r**[2] is the position
    vector for particle 2, then **r**[21] = **r**[2] – **r**[1], and we can write
    the force on particle 2 as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/344equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the Haskell definition for the two-body force of universal gravity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We use the extraction (also called eliminator or selector) functions `mass`
    and `posVec` from the `ParticleState` data type to extract the masses and position
    vectors of the two particles and we give local names to these values. The final
    expression we return comes from Equation 19.4.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that universal gravity obeys Newton’s third law. We calculate the force
    **F**[12] produced by particle 2 on particle 1 by exchanging the roles of *m*[1]
    with *m*[2] and of **r**[1] with **r**[2].
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/344equ03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Constant Repulsive Force
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s try to write a constant repulsive force between two objects; in other
    words, a force that doesn’t depend on the distance between the objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a wrong way to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The intent of the code is clear: we intend to ignore the states of the particles
    and return whatever force was given. This code satisfies the Haskell type checker
    and compiles, but it does not satisfy Newton’s third law. Since the particle states
    are completely ignored, there is no chance that exchanging the particle states
    will reverse the direction of the force, as required by Newton’s third law.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a constant repulsive force that does obey Newton’s third law:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Instead of passing a force vector to our function, we now pass only a force
    magnitude. We use the positions of the two bodies to determine what direction
    “repulsive” is. When we exchange the two particle states in this two-body force,
    the direction of the force is properly reversed.
  prefs: []
  type: TYPE_NORMAL
- en: Linear Spring
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A spring, typically made of coiled metal or plastic, can be extended by pulling
    its ends apart and compressed by pushing them toward each other. The spring has
    some equilibrium length, which is the distance between the two ends when the spring
    is detached and allowed to assume its natural shape.
  prefs: []
  type: TYPE_NORMAL
- en: If objects are connected to the ends of the spring, the spring can exert forces
    on these objects. If the distance between the two objects becomes less than the
    equilibrium length of the spring, the spring compresses and exerts repulsive forces
    on the objects in an effort to restore its equilibrium length. Similarly, an extended
    spring seeks restoration by exerting attractive forces on the objects at its ends.
    If the mass of the spring is negligible compared with the masses of the objects
    at its ends, then the force exerted by one end of the spring on one object will
    be equal and opposite to the force exerted by the other end of the spring on the
    other object. The spring acts as a Newton’s third law–respecting two-body force
    between the two objects. Since the magnitudes of the forces at each end are equal,
    we sometimes speak of the force of the spring as if it were one single value.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll assume a spring that does not bend but only compresses or extends along
    a line connecting the ends. If *r*[21] is the distance between the ends of the
    spring and *r[e]* is the equilibrium length of the spring, the spring is in extension
    when *r*[21] > *r[e]*, in compression when *r*[21] < *r[e]*, and in equilibrium
    when *r*[21] = *r[e]*.
  prefs: []
  type: TYPE_NORMAL
- en: The size of the force exerted by a spring depends on how much the spring has
    been extended or compressed from its equilibrium length. A larger extension or
    compression produces a larger force. The force exerted by the spring depends on
    the difference *r*[21] – *r[e]*. A *linear spring* is one in which the force is
    proportional to this difference. The constant of proportionality *k* is called
    the *spring constant*.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s call **r**[21] the displacement vector from object 1 at one end of the
    spring to object 2 at the other, as in [Figure 19-1](ch19.xhtml#ch19fig1). Then
    *r*[21] = |**r**[21]| is the distance from one end to the other, and ![Image](Images/e0346-01.jpg)
    is a unit vector from end 1 toward end 2\. [Table 19-1](ch19.xhtml#ch19tab1) shows
    the force on each end of the spring.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 19-1:** Forces on Each End of a Linear Spring'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Spring state** | **Force at end 1** | **Force at end 2** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *r*[21] > *r[e]* | Extension | ![Image](Images/e0346-02.jpg) | ![Image](Images/e0346-03.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: '| *r*[21] = *r[e]* | Equilibrium | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| *r*[21] < *r[e]* | Compression | ![Image](Images/e0346-04.jpg) | ![Image](Images/e0346-05.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: 'The force **F**[21] exerted on object 2 produced by the spring connected to
    object 1 is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/346equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This equation holds whether the spring is in extension, compression, or equilibrium.
    If **r**[1] is the position vector for object 1 and **r**[2] is the position vector
    for object 2, then **r**[21] = **r**[2] – **r**[1], and we can write the force
    on object 2 as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/346equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is Haskell code for the two-body force of a linear spring with spring
    constant `k` and equilibrium length `re`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: There may be times when we want to attach one end of a spring to a fixed wall
    or ceiling. In that case, the spring is better represented by a one-body force.
    This is a good opportunity to use the function `oneFromTwo` that we wrote earlier
    in this chapter to produce a one-body force from a two-body force. Given a spring
    constant, an equilibrium length, and a fixed position for one end of the spring,
    the function `fixedLinearSpring` produces a one-body force for the object attached
    to the other end of the spring.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The function `fixedLinearSpring` works by creating a fake particle state at
    the fixed end of the spring. The particle state is fake in that its only use is
    to supply a position; we do not intend to allow this particle state to evolve
    as we would for a real particle. When this fake particle state is given to the
    function `oneFromTwo` along with the two-body force `linearSpring k re`, we obtain
    a one-body force that describes the force the spring exerts on the movable mass.
  prefs: []
  type: TYPE_NORMAL
- en: Central Force
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The three two-body forces we have considered so far—universal gravity, a constant
    repulsive force, and a linear spring—are all examples of a *central force*, which
    is a force between two particles that depends only on the distance between them
    and acts along the line that joins them. A central force can be either attractive
    or repulsive. A general expression for the force on object 2 produced by a central
    force from object 1 is
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/347equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/347equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'if **r**[1] is the position vector for object 1 and **r**[2] is the position
    vector for object 2\. Here is the central force in Haskell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We provide `centralForce` with a scalar function `f` that describes how the
    force depends on the distance between the two objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The linear spring force of the previous section can be alternatively defined
    using this `centralForce` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here we send the scalar function
  prefs: []
  type: TYPE_NORMAL
- en: '*f*(*r*) = –*k*(*r* – *r[e]*)'
  prefs: []
  type: TYPE_NORMAL
- en: to `centralForce`, where the negative sign indicates that the force is attractive
    when *r* > *r[e]*. Exercise 19.3 asks you to write universal gravity as a central
    force.
  prefs: []
  type: TYPE_NORMAL
- en: Elastic Billiard Interaction
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In an elastic collision between two objects, the objects compress a bit and
    store energy, much like a spring, before bouncing apart. In an introductory physics
    course, collisions are typically treated as “black box” events, where we don’t
    get involved in the particular forces that act between the colliding objects but
    rather use conservation of momentum to figure out how the objects will move after
    the collision instead. Here, we’ll view the force between objects as a two-body
    force that is 0 when the objects are apart from one another and that acts as a
    spring when the objects come into contact.
  prefs: []
  type: TYPE_NORMAL
- en: 'The crucial thing to know is whether the objects are touching or not touching.
    We only keep track of the position of the center of each object in the state,
    so the question becomes whether the centers of the two objects are closer than
    some threshold distance between the centers that we’ll call *r[e]*. If the distance
    between the objects is greater than *r[e]*, there is no force. If the distance
    is less than *r[e]*, we’ll model the force as a compressed linear spring with
    spring constant *k*. The following equation gives the force on object 2 produced
    by object 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/348equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This force is like half of a linear spring. It behaves like a linear spring
    under compression, when the centers are closer than the threshold distance *r[e]*,
    but there is no force when the spring would exhibit extension. Here is the Haskell
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When the distance between the particles is greater than or equal to the threshold
    separation, the particles feel no force. When the distance between the particles
    is less than the threshold separation, the objects are touching and compressing
    a bit, feeling a force of repulsion. We’ll use this two-body force to animate
    a collision in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Internal and External Forces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we have multiple interacting particles, the forces that act on any one
    particle can be classified into two sorts. On the one hand, there are the forces
    produced by other particles in the collection of particles we are paying attention
    to. These are the forces to which Newton’s third law applies. If we care about
    particles A and B, and A feels a force from B, then Newton’s third law reminds
    us that somewhere in our calculation we need to account for the fact that B feels
    a force from A.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, there are the forces produced by things outside of the collection
    of particles we are paying attention to. We may want Earth’s surface gravity as
    a force without having to include Earth as one of the particles we care about.
    We may want to include forces produced by electric or magnetic fields without
    including the sources of these fields in our calculation. For this second sort
    of force, Newton’s third law is irrelevant; it tells us about a force that acts
    on something we don’t care about and don’t need to account for in our calculation.
    The distinction between these two sorts of forces motivates the following definitions.
  prefs: []
  type: TYPE_NORMAL
- en: A *system of particles* is simply a choice of which particles to pay attention
    to. We decide which particles to include in our system, and these are the particles
    whose motion we calculate by applying Newton’s second law.
  prefs: []
  type: TYPE_NORMAL
- en: For a system of particles, it’s useful to distinguish between an *internal force*
    (a force produced by a particle in our system) and an *external force* (a force
    produced by something outside of our system). By making this distinction between
    forces, we will be able to write a state-update rule that automatically applies
    Newton’s third law for us. An external force does not require Newton’s third law;
    it’s treated the same as last chapter because we’re not concerned with the motion
    of the object creating the force. For an internal force, both particles are in
    our system, and we can treat them symmetrically, making sure that each particle
    experiences the appropriate force.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s make a new data type for force that demands every force be either an external
    force or an internal force.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `Int`s in this data type definition are particle numbers. We are going to
    number the particles in our system, starting with 0\. A particular external force
    is specified by giving the particle number that experiences the force along with
    the one-body force that describes it. For example, the `Force`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: indicates that particle 98 experiences the force of a linear spring with spring
    constant 1 and equilibrium length 0.5, and whose other end is fixed at position
    100![Image](Images/icap.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: A particular internal force is specified by giving numbers for the two particles
    that participate in the interaction, followed by the two-body force that describes
    the interaction. For example, the `Force`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: indicates that particles 0 and 1 interact via universal gravity. The `Force`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: means the same thing. To indicate that particles 0 and 1 interact by universal
    gravity, we include one, but not both, of these forces in the list of forces that
    describes the setting for our system of particles.
  prefs: []
  type: TYPE_NORMAL
- en: The State of a Multi-Particle System
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The state of a system of particles consists of the information contained in
    the states of each particle. A list of particle states is an appropriate type
    for the state of a system of multiple particles.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few ways we could approach this. We could use the data type `[ParticleState]`
    to describe the state of a system of particles. We could also write a type synonym
    to give an alternate name to a list of single-particle states. However, we won’t
    follow either of these two paths because we already use a list of single-particle
    states to represent a solution to a one-particle mechanics problem. In this solution,
    each single-particle state describes the same particle at a different time. The
    state of a multi-particle system wants a list of particles for a different purpose;
    each single-particle state describes a different particle at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Since we do not want to confuse a list of single-particle states used as a solution
    to a one-particle mechanics problem with a list used to describe a multi-particle
    system, we create a new data type using the `data` keyword so that the compiler
    regards the two types as different. Different purposes suggest different types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We build a value with type `MultiParticleState` with the data constructor `MPS`,
    which is short for multi-particle state. We could have used `MultiParticleState`
    as the name of the data constructor; however, I chose `MPS` because it’s shorter
    and appears less awkward to use in code to me. Underneath the data constructor
    is a plain old list of single-particle states. The `data` constructor makes the
    type `MultiParticleState` distinct from the type `[ParticleState]`. We use record
    syntax to obtain the extraction function `particleStates` without having to explicitly
    define it.
  prefs: []
  type: TYPE_NORMAL
- en: Underneath the data constructor, the single-particle states reside in a list,
    meaning we can refer to the particles by number, starting with `0`. Each particle
    is labeled by a number with type `Int`.
  prefs: []
  type: TYPE_NORMAL
- en: We note in passing that using a list for the states of each particle is not
    the most efficient way to handle data. In this book, we are primarily concerned
    with the clarity, beauty, and simplicity of the code we write, and we are less
    concerned with its efficiency. A good rule in Haskell programming is not to worry
    about efficiency until your code runs slower than you would like. At that point,
    it makes sense to ask what can be done to make it faster. In the old days, functional
    programming was saddled with a reputation for slowness. However, that is no longer
    true. Haskell, in particular, provides data structures such as arrays that can
    be more efficient than the list structure we are using. The list-based method
    we use works well for tens of particles, but it may be too slow for hundreds of
    particles. If you get to the point where you want to run simulations with hundreds
    or thousands of particles, I recommend looking into array types. For simplicity,
    we stick to the list data type in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do animation with the `Vis` module using the function `simulateVis` we wrote
    in [Chapter 16](ch16.xhtml), a data type that represents the state of something
    needs to be an instance of type class `HasTime`, which means that a state needs
    to have a time associated with it. Each single-particle state has a time; in fact,
    every single-particle state that makes up a multi-particle state has the same
    time. So, we’ll just take the time from particle number 0\. Here is the instance
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We use pattern matching on the input to define the function `timeOf`. By giving
    the data constructor `MPS` followed by a list, we have access to that list in
    the body of the function and can use the list element operator (`!!`).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll animate a system of two masses and two springs. The
    animation uses `simulateVis`, which uses `timeOf`. Since the state space for that
    animation is `MultiParticleState`, `simulateVis` needs the `timeOf` that goes
    with `MultiParticleState`, which is exactly what the instance declaration provides.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that in [Chapter 16](ch16.xhtml) we introduced the data type `DParticleState`
    to hold the time derivatives of the state variables in `ParticleState`. Here,
    in the many-particle setting, we do something similar and define a new data type
    `DMultiParticleState` to hold the time derivatives of the state variables in `MultiParticleState`.
    Here is the data type definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You can see from this definition that we are just packaging a list of `DParticleState`s,
    analogous to the way we packaged a list of `ParticleState`s in the data type definition
    above for `MultiParticleState`.
  prefs: []
  type: TYPE_NORMAL
- en: With a new data type in hand to represent the state of a multi-particle system,
    let us turn to the question of how that state evolves in time—in other words,
    how the state gets updated.
  prefs: []
  type: TYPE_NORMAL
- en: State Update for Multiple Particles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a system of multiple particles, [Figure 19-2](ch19.xhtml#ch19fig2) gives
    an overview of the data representations and functions that transform among them,
    much as [Figure 16-3](ch16.xhtml#ch16fig3) did for a single particle.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/352fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-2: Data representations and functions that transform among them*'
  prefs: []
  type: TYPE_NORMAL
- en: The four representations are forces, differential equation, state-update function,
    and evolver. In the next section, we’ll discuss Newton’s second law and the function
    `newtonSecondMPS` that implements it in the multi-particle setting. We’ll see
    how to use our numerical methods in this setting, and we’ll define the composite
    functions `updateMPS` and `statesMPS` that are shown in [Figure 19-2](ch19.xhtml#ch19fig2).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Newton’s Second Law
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For a system of interacting particles, both Newton’s second law and Newton’s
    third law are involved in producing a differential equation. [Figure 19-3](ch19.xhtml#ch19fig3)
    shows a schematic diagram for a two-body mechanics problem.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/353fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-3: Schematic representation of Newton’s second law and Newton’s
    third law working together in a two-body situation. The two bodies interact with
    each other, and each body has external forces acting on it as well.*'
  prefs: []
  type: TYPE_NORMAL
- en: The function **F**[1e], shown in the upper left of [Figure 19-3](ch19.xhtml#ch19fig3),
    produces the net external force on particle 1\. The external forces on particle
    1 can depend on time, the position of particle 1, and the velocity of particle
    1\. These three quantities are shown as inputs to **F**[1e]. We find the net external
    force on particle 1 by supplying the inputs to the function to form **F**[1e](*t*,
    **r**[1] (*t*), **v**[1] (*t*)). If there are multiple external forces acting
    on particle 1, they need to be added together (as vectors). The function **F**[1e]
    needs to return this sum.
  prefs: []
  type: TYPE_NORMAL
- en: Moving down the diagram from **F**[1e], we find a summation that adds together
    the net external force and the net internal force to produce the net force on
    particle 1 that appears in Newton’s second law. We’ll talk about the net internal
    force shortly; for now let’s keep moving down the left column of the diagram.
    Newton’s second law says that dividing the net force on particle 1 by the mass
    of particle 1 will give the acceleration of particle 1\. Integrating the acceleration
    produces the velocity, and integrating the velocity produces the position. The
    position and velocity of particle 1 feed back as inputs to the net external force
    function **F**[1e].
  prefs: []
  type: TYPE_NORMAL
- en: The position and velocity of particle 1 also get combined with those of particle
    2, governed by the right column of [Figure 19-3](ch19.xhtml#ch19fig3), to produce
    a relative position and a relative velocity that serve as inputs to **F**[21],
    the internal force of particle 1 on particle 2\. If particle 1 exerts multiple
    forces on particle 2, perhaps a spring force and an electrical force, these must
    be added as vectors to form **F**[21](**r**[2](*t*) – **r**[1](*t*),**v**[2](*t*)
    – **v**[1](*t*)), the net internal force of particle 1 on particle 2\. An internal
    force between two particles shouldn’t depend explicitly on time, and it should
    depend on the positions and velocities of the two particles only through their
    relative values. All of the two-body forces we introduced earlier in the chapter
    have this property.
  prefs: []
  type: TYPE_NORMAL
- en: Since **F**[21](**r**[2](*t*) – **r**[1](*t*),**v**[2](*t*) – **v**[1](*t*))
    is the force on particle 2, it goes straight into the summation on the right to
    be added to the net external force on particle 2\. By Newton’s third law, the
    force on particle 1 produced by particle 2 is equal and opposite to this, hence
    the multiplication by –1 to produce the net internal force on particle 1 before
    it gets added to the net external force on particle 1.
  prefs: []
  type: TYPE_NORMAL
- en: Time is produced by integrating the constant 1, as in our previous schematic
    diagrams. Time is an input to each of the net external force functions, but not
    to the net internal force function.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize [Figure 19-3](ch19.xhtml#ch19fig3), the internal and external forces
    on each particle must be added together to form the net force on the particle,
    which, per Newton’s second law, gets divided by its mass to calculate the acceleration
    of the particle. Newton’s third law is carried out in the center column, where
    the force of interaction is calculated, sent unchanged to particle 2, and sent
    negated to particle 1\. The internal forces express the interaction between the
    two particles, while the external forces represent interactions with things outside
    of the system. All of the feedback means that a set of coupled differential equations
    will be the mathematical expression of a multi-particle mechanics problem.
  prefs: []
  type: TYPE_NORMAL
- en: We can write Newton’s second law as a set of coupled differential equations.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/354equ01.jpg)![Image](Images/354equ02.jpg)![Image](Images/354equ03.jpg)![Image](Images/354equ04.jpg)![Image](Images/354equ05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The time derivative of time is 1, as in single-particle mechanics. The time
    derivative of position is velocity, and this holds for each particle. The time
    derivative of velocity is acceleration, which is found by dividing net force by
    mass for each particle. The net force on a particle is the sum of the net external
    force and the net internal force. The function **F**[2*e*] produces the net external
    force on particle 2 when given the time, the position of particle 2, and the velocity
    of particle 2\. The function **F**[*mn*] produces the internal force of particle
    *n* on particle *m* when given the relative position and relative velocity of
    particles *m* and *n*. The net internal force on particle 2, for example, is
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/355fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where we add the internal forces produced by all of the other particles in the
    system. We have only given equations for the first two particles in a system,
    but there is a similar pair of equations for every particle in the system. Hopefully
    the pattern is clear.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 16](ch16.xhtml), which was concerned with the motion of a single
    particle, we used the function `newtonSecondPS` to transform a list of forces
    into a differential equation. We would now like an analogous function for multiple
    particles. We would like a function with the following type signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The name of this function has *MPS* on the end to remind us that it works with
    the `MultiParticleState` state space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our plan is to apply Newton’s second law to each particle in the system. For
    each particle, we identify all of the external and internal forces that act on
    it, and we transform each of these into a one-body force. Once we have the list
    of one-body forces that act on a particle, we can use the function `newtonSecondPS`
    to calculate the time derivatives of all the state variables for that particle.
    When we have the time derivatives of each state variable for each particle, we’ll
    bundle it all up and ask `newtonSecondMPS` to return that bundle. Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The first line in the code names the incoming list of forces `fs` and gives
    *two* names to the incoming multi-particle state. When placed between two names
    on the left side of a definition, the `@` (“at symbol”) allows the code writer
    to give a simple identifier to the incoming value *and* simultaneously do pattern
    matching on the input. The simple identifier `mpst` stands for the incoming multi-particle
    state with type `MultiParticleState`. Since it appears underneath the data constructor
    `MPS`, the name `sts` stands for the list of single-particle states (type `[ParticleState]`).
    We want to use both `mpst` and `sts` in our definition.
  prefs: []
  type: TYPE_NORMAL
- en: In the second line of code, we define a local function `deriv` to calculate
    the time derivatives of single-particle state variables. Its argument `(n,st)`
    is a pair of particle number and single-particle state. Its return value is a
    collection of derivatives (type `DParticleState`). This local function uses `newtonSecondPS`
    to calculate the derivatives. The expression `forcesOn n mpst fs` is the list
    of one-body forces that act on particle number `n` when the multi-particle state
    is `mpst` and the list of all system forces (external and internal) is `fs`. We
    will write the function `forcesOn` next.
  prefs: []
  type: TYPE_NORMAL
- en: In the final line, we zip together particle numbers with associated particle
    states to make a list of number-state pairs. We then map the local function `deriv`
    onto that list, producing a list of time derivatives of single-particle states
    (type `[DParticleState]`). Finally, we apply the `DMPS` data constructor to form
    the time multi-particle state derivative (type `DMultiParticleState`).
  prefs: []
  type: TYPE_NORMAL
- en: From a physics standpoint, all we are doing is applying Newton’s second law
    to each particle in the system. The apparent complexity comes partly from our
    need to number the particles and partly from our desire to use clear types to
    represent the things we care about (such as internal and external forces). The
    clear types benefit us in two ways. First, types represent the important ideas
    in physics and help us think about them. Second, types help the compiler find
    our mistakes. By doing some of the heavy lifting in functions like this, we will
    end up with a collection of powerful functions that let us solve multi-particle
    problems with relative ease.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we find the net force on each particle? In other words, how do we write
    the function `forcesOn` we used earlier? What type should `forcesOn` have? The
    function `forcesOn` needs to take a particle number, a multi-particle state, and
    a list of forces as inputs, and it needs to produce a list of one-body forces
    as output. Here is the type signature and the definition for `forcesOn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The incoming particle number is named `n`, and the incoming multi-particle state
    is named `mpst`. We don’t bother to name the list of forces, which means that
    `forcesOn n mpst` has type `[Force] -> [OneBodyForce]`. You can see from the definition
    that `forcesOn` passes most of the work on to another as-yet-undefined function
    called `forceOn` (note the dropped *s*). The idea is that the function `forceOn
    n mpst` has type `Force -> OneBodyForce` and transforms an external or internal
    force in the list of system forces into a one-body force acting on particle `n`.
    If we can transform a single force, we can use `map` to transform a list of forces.
  prefs: []
  type: TYPE_NORMAL
- en: The function `forceOn` needs to deal with both external and internal forces.
    External forces are easier. We just have to check whether the external force acts
    on particle `n`. If so, we return the one-body force held inside the external
    force. If not, we make up a one-body force that is zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'For an internal force, we need to check whether either of the particle numbers
    specified in the internal force are particle number `n` that we care about. If
    so, we use the `oneFromTwo` function written earlier in the chapter that constructs
    a one-body force from a two-body force. If not, we again make up a zero force.
    Here is the code for `forceOn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The function uses pattern matching on the `Force` input, so there is one part
    of the definition for each of the two data constructors of `Force` (that is, one
    part for an external force and a second part for an internal force). This definition
    uses a Haskell feature called *guards*. A guard is the vertical bar on the left
    of several of the lines of code. The guard is a convenient alternative to an `if-then-else`
    construction, especially when there are more than two possibilities, as in the
    part of the definition that works with internal forces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each line in the guard construction consists of four items: a vertical bar,
    a Boolean condition, an equal sign, and a result. At each vertical bar, the condition
    is checked. If the condition is true, the corresponding result is returned; if
    the condition is false, we go to the next vertical bar and repeat the process.
    It is good practice for the condition in the last guard line to be `otherwise`,
    which is just another name for `True`. By using `otherwise`, we are guaranteed
    that one of the guard conditions will hold and consequently that one of the results
    will be returned.'
  prefs: []
  type: TYPE_NORMAL
- en: The first part of the definition for `forceOn` is for an external force. We
    check whether particle number `n`, the particle we are currently interested in,
    matches particle number `n0`, the particle on which the current external force
    acts. If they match, we return the one-body force `fOneBody` contained in the
    external force. If they don’t match, we return the one-body force `const zeroV`,
    a one-body force that ignores the state of the particle and simply returns the
    zero vector.
  prefs: []
  type: TYPE_NORMAL
- en: The second part of the definition for `forceOn` is for an internal force. An
    internal force involves two particles; if the particle we care about is either
    of these, the function needs to return the appropriate one-body force. We first
    check whether particle number `n`, the particle we are currently interested in,
    matches particle number `n0`, the first of the two particles involved in the internal
    force. If `n` equals `n0`, we are interested in the force that particle `n1` exerts
    on particle `n0`. We provide `oneFromTwo`, the function we wrote earlier in the
    chapter to convert a two-body force to a one-body force, with the single-particle
    state for `n1`, called `sts !! n1`, and the two-body force contained in the internal
    force, called `fTwoBody`. The function `oneFromTwo` returns the one-body force
    that acts on particle `n`.
  prefs: []
  type: TYPE_NORMAL
- en: If `n` does not equal `n0`, we check whether `n` equals `n1`, the other particle
    involved in the internal force under consideration. If so, we are interested in
    the force that particle `n0` exerts on particle `n1`. We provide `oneFromTwo`
    with the single-particle state for `n0`, called `sts !! n0`, and with the two-body
    force contained in the internal force. The function `oneFromTwo` again returns
    the one-body force that acts on particle `n`. Finally, if particle `n` matches
    neither `n0` nor `n1`, we return a zero force.
  prefs: []
  type: TYPE_NORMAL
- en: The part of the definition of `forceOn` that deals with an internal force is
    how we apply Newton’s third law. This is the part that guarantees the forces will
    be equal and opposite because they come from the same internal force. For each
    of the two particles involved, we use the same two-body force to produce the one-body
    force that acts on each particle; only the single-particle states are interchanged.
    Since a two-body force has the property that particle interchange negates the
    force, Newton’s third law is automatically applied. We can’t make the mistake
    of remembering that `n1` exerts a force on `n0` but forgetting that `n0` exerts
    a force on `n1`. Our language of internal forces and our code to deal with them
    ensure that Newton’s third law holds without further attention from the code writer.
    In particular, each time we investigate a new multi-particle system, all we give
    is a list of external and internal forces. We don’t have to ensure that the force
    `n1` exerts on `n0` is equal and opposite to the force `n0` exerts on `n1`. Haskell
    deals with this automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Numerical Methods for Multiple Particles
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Recall that the Euler and fourth-order Runge-Kutta methods are general methods
    for solving any differential equation. At the end of [Chapter 15](ch15.xhtml),
    we wrote functions `euler` and `rungeKutta4` that work with any state space `s`
    that is an instance of type class `RealVectorSpace`. To make these two functions
    usable with the `MultiParticleState` state space, we need to write two instance
    declarations. Here they are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The content of this instance declaration is that the sum of two multi-particle
    states is just the particle-wise sum.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This instance declaration says that “shifting” a multi-particle state by a state
    derivative is just shifting each single-particle state by the associated single-particle
    state derivative.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Euler-Cromer method is not a general method for any differential equation,
    so we need to write an explicit numerical method for Euler-Cromer as it applies
    to the `MultiParticleState` data type. Here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We choose to calculate the Euler-Cromer derivatives by first taking an Euler
    step, which is easy to do and correctly updates the mass, charge, time, and velocity
    for each particle. However, the position needs to be fixed because it needs to
    be based on the updated velocity. The local variable `mpst0` stands for the incoming
    multi-particle state, while `mpst1` stands for the Euler-updated multi-particle
    state. The variables `sts0` and `sts1` are the lists of single-particle states
    underneath the `MPS` data constructor for the incoming and Euler-updated multi-particle
    states.
  prefs: []
  type: TYPE_NORMAL
- en: To form the Euler-Cromer-updated multi-particle state, we use a list comprehension
    to go through all the particles and apply the Euler-Cromer update Equation 15.10,
    which updates the incoming position with the Euler-updated velocity.
  prefs: []
  type: TYPE_NORMAL
- en: Composite Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As in the single-particle situation, it’s convenient to have composite functions
    that take two or three steps in [Figure 19-2](ch19.xhtml#ch19fig2). The function
    `updateMPS` is the composition of Newton’s second law with a numerical method
    and is useful for animation. You can see from its definition that it’s just this
    composition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The function `solver` in [Figure 19-2](ch19.xhtml#ch19fig2) also takes two steps
    in data representations, solving a differential equation by producing an evolver
    that can then generate a list of states from an initial state. We wrote `solver`
    in [Chapter 15](ch15.xhtml), and that code works just fine in the multi-particle
    setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function `statesMPS` takes all three steps in [Figure 19-2](ch19.xhtml#ch19fig2),
    transforming a list of forces into an evolver. Its definition is what you would
    expect: a composition of Newton’s second law, a numerical method, and iteration.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we applied Newtonian mechanics to multiple interacting objects
    moving in three dimensions. Newton’s third law governs the interaction between
    particles. A two-body force is a force that depends on the states of two particles.
    We classify the forces that act on particles in our system into internal forces,
    which are produced by other particles in our system, and external forces, which
    are produced by something outside of our system. The state of a system of particles
    is described by giving the single-particle states for each of the particles in
    the system. Our `MultiParticleState` data type does exactly that. Our state-update
    procedure is still based on Newton’s second law, but now it automatically applies
    Newton’s third law to all internal forces.
  prefs: []
  type: TYPE_NORMAL
- en: As in the single-particle situation, solving a mechanics problem is still a
    process of transforming information through a sequence of four representations.
    For the multi-particle case, we start with a list of internal and external forces,
    produce a differential equation, produce a state-update function, and finally
    produce a list of multi-particle states.
  prefs: []
  type: TYPE_NORMAL
- en: The process of producing the differential equation from the forces has evolved
    over the course of [Part II](part02.xhtml) of this book. Newton’s second law is
    always present, but the state has contained more information as we moved from
    one dimension to three dimensions to multiple particles. [Table 19-2](ch19.xhtml#ch19tab2)
    shows the functions we have used to carry out Newton’s second law by producing
    a differential equation. The function `newtonSecondV` is for one particle in one
    dimension when the forces depend only on velocity. The function `newtonSecondTV`
    is for one particle in one dimension when the forces depend only on time and velocity.
    The function `newtonSecond1D` is for one particle in one dimension when the forces
    could depend on any combination of time, position, or velocity. The function `newtonSecondPS`
    is for one particle in three dimensions when the forces could depend on time,
    position, or velocity. Finally, the function `newtonSecondMPS` is for multiple
    particles in three dimensions where the forces could depend on time, position,
    or velocity.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 19-2:** Functions for Newton’s Second Law'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Type** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `newtonSecondV` | `Mass ->``[Velocity -> Force] -> Velocity -> R` |'
  prefs: []
  type: TYPE_TB
- en: '| `newtonSecondTV` | `Mass ->``[(Time, Velocity) -> Force] -> (Time, Velocity)
    -> (R, R)` |'
  prefs: []
  type: TYPE_TB
- en: '| `newtonSecond1D` | `Mass ->``[State1D -> Force] -> State1D -> (R, R, R)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `newtonSecondPS` | `[OneBodyForce] -> ParticleState -> DParticleState` |'
  prefs: []
  type: TYPE_TB
- en: '| `newtonSecondMPS` | `[Force] -> MultiParticleState -> DMultiParticleState`
    |'
  prefs: []
  type: TYPE_TB
- en: We have used the type `Force` in two different ways over the course of [Part
    II](part02.xhtml). In a one-dimensional setting, `Force` is simply a type synonym
    for a real number. In the three-dimensional, multi-particle setting of this chapter,
    the definition of `Force` is much more complex, describing a data type that could
    be an internal force or an external force and including the dependence of force
    on state. We have come a long way. In the next chapter, we’ll apply these ideas
    to specific examples of interacting particles and animate our results.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise 19.1.** Write a function `speed`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: that returns the speed of a particle from its state.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 19.2.** We could use pattern matching on the input rather than extraction
    functions to write the two-body force for universal gravity. The resulting definition
    has the benefit of being a bit shorter. Complete the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '**Exercise 19.3.** Universal gravity is a central force. Use the function `centralForce`
    to write the function'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: that expresses the same two-body force as `universalGravity`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 19.4.** Our constant repulsive force is a central force. Rewrite
    the constant repulsive force using `centralForce`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 19.5.** No real spring is completely linear across its entire range.
    In Exercise 15.10, we introduced the Lennard-Jones spring as an example of a nonlinear
    spring.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The force on end 2 of the spring is given by the following expression, in which
    *r[e]* is the equilibrium length and *D[e]* is the dissociation energy (that is,
    the energy required to extend the spring so that the ends are very far apart):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/361equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If *r*[21] < *r[e]*, the force on particle 2 will be in the direction of **r**[21],
    which is repulsive. If *r*[21] > *r[e]*, the force on particle 2 will be in the
    direction of –**r**[21], which is attractive.
  prefs: []
  type: TYPE_NORMAL
- en: Write the function `lennardJones`, which takes a dissociation energy and an
    equilibrium length and returns a two-body force for the Lennard-Jones spring.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '**Exercise 19.6.** Write a function `systemKE`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: that returns the kinetic energy of a system of particles by adding up the kinetic
    energy of each particle.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 19.7.** Each wire in a schematic diagram can be labeled with a type.
    Label each wire in [Figure 19-3](ch19.xhtml#ch19fig3) with a type.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 19.8.** An alternative way to write the function `forcesOn` is to
    form the list of one-body forces by appending a list of one-body forces that come
    from external forces to a list of one-body forces that come from internal forces.
    This method has the advantage of not requiring us to make up any fake zero forces
    and not needing the function `forceOn`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In defining the function `internalForcesOn`, we use pattern matching inside
    a list comprehension. We exclude any force that does not match the pattern. Following
    the model of `internalForcesOn`, write the function `externalForcesOn`.
  prefs: []
  type: TYPE_NORMAL
