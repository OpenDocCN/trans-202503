- en: '**10'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**10'
- en: 'AN EVOLUTION OF MBR AND VBR INFECTION TECHNIQUES: OLMASCO**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: MBR和VBR感染技术的演变：OLMASCO**
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: 'In response to the first wave of bootkits, security developers began work on
    antivirus products that specifically checked the MBR code for modifications, forcing
    attackers to look for other infection techniques. In early 2011, the TDL4 family
    evolved into new malware with infection tricks that had never before been seen
    in the wild. One example is Olmasco, a bootkit largely based on TDL4 but with
    a key difference: Olmasco infects the *partition table* of the MBR rather than
    the MBR code, allowing it to infect the system and bypass the Kernel-Mode Code
    Signing Policy while avoiding detection by increasingly savvy antimalware software.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为应对第一波引导程序的攻击，安全开发人员开始着手开发专门检查MBR代码是否被修改的杀毒产品，迫使攻击者寻找其他感染技术。2011年初，TDL4家族演变成了新的恶意软件，采用了以前从未见过的感染手段。其中一个例子是Olmasco，它在很大程度上基于TDL4，但有一个关键区别：Olmasco感染MBR的*分区表*，而不是MBR代码，使其能够感染系统并绕过内核模式代码签名策略，同时避开越来越智能的反恶意软件的检测。
- en: Olmasco is also the first known bootkit to employ a combination of MBR and VBR
    infection methods, though it still primarily targets the MBR, setting it apart
    from VBR-infecting bootkits such as Rovnix and Carberp (which we’ll discuss in
    [Chapter 11](ch11.xhtml#ch11)).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Olmasco也是首个已知的引导程序，它结合了MBR和VBR感染方法，尽管它仍然主要针对MBR，这使得它与感染VBR的引导程序（例如Rovnix和Carberp，稍后我们将在[第11章](ch11.xhtml#ch11)讨论）有所不同。
- en: Like its TDL predecessors, Olmasco uses the PPI business model for distribution,
    which should be familiar from our discussion of the TDL3 rootkit in [Chapter 1](ch01.xhtml#ch01).
    The PPI model is similar to schemes used for distributing toolbars for browsers,
    like Google’s toolbars, and uses embedded unique identifiers (UIDs) to allow distributors
    to track the number of installations and thus their revenue. Information about
    the distributor is embedded into the executable, and special servers calculate
    the number of installations. The distributor is paid a fixed amount of money per
    a specified number of installations.^([1](footnotes.xhtml#ch10fn1))
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 与其前辈TDL一样，Olmasco使用PPI商业模式进行分发，这一模式在我们讨论[第1章](ch01.xhtml#ch01)的TDL3 Rootkit时已经熟悉。PPI模式类似于用于分发浏览器工具栏（如谷歌工具栏）的方案，并使用嵌入的唯一标识符（UID）允许分发商追踪安装次数，从而获得收入。分发商的信息嵌入到可执行文件中，特殊服务器计算安装次数。分发商根据安装次数支付固定金额的报酬。^([1](footnotes.xhtml#ch10fn1))
- en: 'In this chapter, we’ll look at three main aspects of Olmasco: the dropper that
    infects the system; the bootkit component that infects the MBR partition table;
    and the rootkit section that hooks the hard drive driver and delivers the payload,
    leverages the hidden filesystem, and implements functionality to redirect network
    communication.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将关注Olmasco的三个主要方面：感染系统的投放程序；感染MBR分区表的引导程序组件；以及挂钩硬盘驱动程序、传送有效载荷、利用隐藏文件系统并实现网络通信重定向功能的Rootkit部分。
- en: '**The Dropper**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**投放程序**'
- en: A dropper is a special malicious application that acts as the carrier of some
    other malware stored as an encrypted payload. The dropper arrives at a victim’s
    computer and unpacks and executes the payload—in our case, the Olmasco infector—which
    in turn installs and executes the bootkit components onto the system. Droppers
    usually also implement a number of antidebugging and antiemulation checks, executed
    before the payload is unpacked, to evade automated malware analysis systems, as
    we’ll see a little later.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 投放程序是一种特殊的恶意应用程序，充当其他恶意软件的载体，该恶意软件以加密有效载荷的形式存储。投放程序到达受害者计算机后，会解压并执行有效载荷——在我们这个例子中，就是Olmasco感染程序——进而安装并执行引导程序组件。投放程序通常还会实现一系列反调试和反仿真检查，这些检查在有效载荷解压前执行，以规避自动化恶意软件分析系统，稍后我们将看到这一点。
- en: '**DROPPER VS. DOWNLOADER**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**投放程序与下载器**'
- en: Another common type of malicious application used to deliver malware onto a
    system is the *downloader*. A downloader, as its name suggests, downloads the
    payload from a remote server rather than using the dropper method of carrying
    the payload itself. In practice though, the term *dropper* is more common and
    is frequently used as a synonym for downloader.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的恶意应用程序类型是*下载器*。顾名思义，下载器从远程服务器下载有效载荷，而不是通过携带有效载荷的方式使用投放程序方法。实际上，*投放程序*这个术语更为常见，通常被用作下载器的同义词。
- en: '***Dropper Resources***'
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***投放程序资源***'
- en: The dropper has a modular structure and stores most of the bootkit’s malicious
    components in its *resource* section. Each component (for example, an identifier
    value, bootloader component, or payload) is stored in a single resource entry
    encrypted with RC4 (see “[The RC4 Stream Cipher](ch10.xhtml#ch10sb01)” on [page
    136](ch10.xhtml#page_136) for more details). The size of the resource entry is
    used as a decryption key. [Table 10-1](ch10.xhtml#ch10tab01) lists the bootkit
    components in the dropper’s resource section.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 投放器具有模块化结构，并将大部分引导工具的恶意组件存储在其 *资源* 部分。每个组件（例如标识符值、引导加载程序组件或有效载荷）都存储在一个单独的资源条目中，并使用
    RC4 加密（更多详情请参见 “[RC4 流密码](ch10.xhtml#ch10sb01)” [第 136 页](ch10.xhtml#page_136)）。资源条目的大小用作解密密钥。[表
    10-1](ch10.xhtml#ch10tab01) 列出了投放器资源部分中的引导工具组件。
- en: '**Table 10-1:** Bootkit Components in the Olmasco Dropper'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10-1：** Olmasco 投放器中的引导工具组件'
- en: '| **Resource name** | **Description** |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| **资源名称** | **描述** |'
- en: '| --- | --- |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| *affid* | Unique affiliate identifier. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| *affid* | 唯一的联盟标识符。 |'
- en: '| *subid* | Subidentifier of affiliate. This is linked to the affiliate ID,
    and an affiliate can have multiple subidentifiers. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| *subid* | 联盟的子标识符。它与联盟 ID 关联，一个联盟可以有多个子标识符。 |'
- en: '| *boot* | First part of the malicious bootloader. It is executed at the beginning
    of the boot process. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| *boot* | 恶意引导加载程序的第一部分。它在启动过程开始时执行。 |'
- en: '| *cmd32* | User-mode payload for 32-bit processes. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| *cmd32* | 适用于 32 位进程的用户模式有效载荷。 |'
- en: '| *cmd64* | User-mode payload for 64-bit processes. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| *cmd64* | 适用于 64 位进程的用户模式有效载荷。 |'
- en: '| *dbg32* | Third part of the malicious bootloader component (fake *kdcom.dll*
    library) for 32-bit systems. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| *dbg32* | 恶意引导加载程序组件的第三部分（伪 *kdcom.dll* 库），适用于 32 位系统。 |'
- en: '| *dbg64* | Third part of the malicious bootloader component (fake *kdcom.dll*
    library) for 64-bit systems. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| *dbg64* | 恶意引导加载程序组件的第三部分（伪 *kdcom.dll* 库），适用于 64 位系统。 |'
- en: '| *drv32* | Malicious kernel-mode driver for 32-bit systems. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| *drv32* | 适用于 32 位系统的恶意内核模式驱动程序。 |'
- en: '| *drv64* | Malicious kernel-mode driver for 64-bit systems. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| *drv64* | 适用于 64 位系统的恶意内核模式驱动程序。 |'
- en: '| *ldr32* | Second part of the malicious bootloader. It is executed by the
    *boot* component on 32-bit systems. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| *ldr32* | 恶意引导加载程序的第二部分。它由 32 位系统上的 *boot* 组件执行。 |'
- en: '| *ldr64* | Second part of the malicious bootloader. It is executed by the
    *boot* component on 64-bit systems. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| *ldr64* | 恶意引导加载程序的第二部分。它由 64 位系统上的 *boot* 组件执行。 |'
- en: '| *main* | Unknown. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| *main* | 未知。 |'
- en: '| *build* | Build number of the dropper. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| *build* | 投放器的构建号。 |'
- en: '| *name* | Name of the dropper. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| *name* | 投放器的名称。 |'
- en: '| *vbr* | VBR of the malicious Olmasco partition on the hard drive. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| *vbr* | 恶意 Olmasco 分区在硬盘上的 VBR。 |'
- en: The identifiers *affid* and *subid* are used in the PPI scheme to calculate
    the number of installations. The parameter *affid* is the unique identifier of
    the affiliate (that is, the distributor). The parameter *subid* is a subidentifier
    that distinguishes installations from different sources. For instance, if an affiliate
    of the PPI program distributes the malware from two different file-hosting services,
    the malware coming from these sources will have the same *affid* but different
    *subid*s. This way, the affiliate can compare the number of installations for
    each *subid* and determine which source is more profitable.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*affid* 和 *subid* 标识符在 PPI 方案中用于计算安装次数。参数 *affid* 是联盟的唯一标识符（即分发者）。参数 *subid*
    是区分不同来源安装的子标识符。例如，如果 PPI 计划的联盟从两个不同的文件托管服务分发恶意软件，那么来自这些来源的恶意软件将具有相同的 *affid* 但不同的
    *subid*。这样，联盟可以比较每个 *subid* 的安装数量，从而确定哪个来源更有利可图。'
- en: We’ll discuss the bootkit components *boot*, *vbr*, *dbg32*, *dbg64*, *drv32*,
    *drv64*, *ldr32*, and *ldr64* shortly, but *main*, *build*, and *name* are described
    only in the table.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将很快讨论引导工具组件 *boot*、*vbr*、*dbg32*、*dbg64*、*drv32*、*drv64*、*ldr32* 和 *ldr64*，但
    *main*、*build* 和 *name* 仅在表中描述。
- en: '**THE RC4 STREAM CIPHER**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**RC4 流密码**'
- en: RC4 is a stream cipher developed in 1987 by Ron Rivest of RSA Security. RC4
    takes a variable-length key and generates a stream of pseudorandom bytes used
    to encrypt the plaintext. This cipher is increasingly popular among malware developers
    due to its compact and straightforward implementation. For that reason, many rootkits
    and bootkits are implemented with RC4 to protect the payload, communication with
    command-and-control (C&C) servers, and configuration information.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: RC4是一种由RSA Security的Ron Rivest于1987年开发的流密码。RC4使用可变长度的密钥，并生成用于加密明文的伪随机字节流。由于其紧凑和简单的实现方式，这种加密算法在恶意软件开发者中越来越受欢迎。因此，许多rootkit和bootkit都使用RC4来保护有效负载、与命令与控制（C&C）服务器的通信以及配置文件信息。
- en: '***Tracing Functionality for Future Development***'
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***未来开发的追踪功能***'
- en: The Olmasco dropper introduced error-reporting functionality to aid developers
    in further development. After successfully executing each step of infection (that
    is, each step in the bootkit installation algorithm), the bootkit reports a “checkpoint”
    to the C&C servers. That means that if installation fails, the developers can
    determine precisely at which step the failure occurred. In the case of errors,
    the bootkit sends an additional comprehensive error message, giving developers
    sufficient information to determine the source of the fault.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Olmasco dropper引入了错误报告功能，以帮助开发者进行进一步开发。在成功执行每个感染步骤后（即bootkit安装算法中的每个步骤），bootkit会向C&C服务器报告一个“检查点”。这意味着如果安装失败，开发者可以准确地确定失败发生在哪个步骤。如果发生错误，bootkit会发送一条额外的综合错误消息，提供足够的信息以便开发者确定故障源。
- en: The tracing information is sent via the HTTP `GET` method to a C&C server whose
    domain name is hardcoded into the dropper. [Listing 10-1](ch10.xhtml#ch10list01)
    shows an Olmasco infector routine decompiled by Hex-Rays that generates a query
    string to report the status information of the infection.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 追踪信息通过HTTP的`GET`方法发送到一个C&C服务器，其域名硬编码在dropper中。[清单10-1](ch10.xhtml#ch10list01)显示了通过Hex-Rays反编译的Olmasco感染程序，该程序生成一个查询字符串来报告感染的状态信息。
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 10-1: Sending tracing information to a C&C server*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单10-1：向C&C服务器发送追踪信息*'
- en: At ➊, the malware executes a `_snprintf` routine to generate the query string
    with the dropper’s parameters. At ➋, it sends the request. The value `check_point_code`
    corresponds to the ordinal number of the step in the installation algorithm that
    sent the message. For instance, 1 corresponds to the very first step in the algorithm,
    2 to the second step, and so on. At the end of a successful installation, the
    C&C server receives a sequence of numbers like 1, 2, 3, 4, . . . *N*, where *N*
    is the final step. If a full installation is unsuccessful, the C&C server will
    receive the sequence 1, 2, 3, . . . *P*, where *P* is the step at which the algorithm
    failed. This allows the malware developers to identify and fix the faulty step
    in the infection algorithm.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，恶意软件执行一个`_snprintf`例程，以生成包含dropper参数的查询字符串。在➋，它发送请求。`check_point_code`的值对应于安装算法中发送消息的步骤的序号。例如，1对应算法中的第一步，2对应第二步，依此类推。在成功安装的最后，C&C服务器会接收到类似1,
    2, 3, 4, . . . *N*的数字序列，其中*N*是最后一步。如果完整安装失败，C&C服务器将接收到序列1, 2, 3, . . . *P*，其中*P*是算法失败的步骤。这使得恶意软件开发者能够识别并修复感染算法中的故障步骤。
- en: '***Antidebugging and Antiemulation Tricks***'
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***反调试和反仿真技巧***'
- en: Olmasco also introduced some new tricks for bypassing sandbox analysis and for
    protection against memory dumps. The dropper is compressed using a custom packer
    that, once executed, unpacks the original decompressed dropper and wipes out certain
    fields of its PE header in memory, such as the address of the original entry point
    and the section table. [Figure 10-1](ch10.xhtml#ch10fig01) shows a PE header before
    and after this data deletion. On the left side the PE header is partially destroyed,
    and on the right side it is unmodified.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Olmasco还引入了一些新的技巧，用于绕过沙箱分析以及保护免受内存转储攻击。dropper使用自定义打包工具进行压缩，执行后会解压缩原始的未压缩dropper，并清除其PE头部中的某些字段，例如原始入口点地址和节表。[图10-1](ch10.xhtml#ch10fig01)显示了数据删除前后PE头部的情况。左侧的PE头部部分被破坏，右侧未被修改。
- en: '![image](../images/10fig01.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/10fig01.jpg)'
- en: '*Figure 10-1: Erasing PE header data*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-1：擦除PE头部数据*'
- en: This trick provides good protection against memory dumping in debugging sessions
    or automated unpacking. Deleting the valid PE header makes it difficult to determine
    the geometry of the PE file and dump it correctly, because the dumping software
    won’t be able to find out the exact location of code and data sections. Without
    this information, it can’t reconstruct the PE image correctly and will fail.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧能有效防止在调试会话或自动解包过程中进行内存转储。删除有效的PE头使得很难确定PE文件的几何结构并正确地进行转储，因为转储软件无法找到代码和数据部分的确切位置。没有这些信息，转储软件无法正确重建PE镜像并会失败。
- en: Olmasco also includes countermeasures for bot trackers based on virtual machines.
    During installation, Olmasco detects whether the dropper is running in a virtual
    environment using the *Windows Management Instrumentation (WMI)* IWbemServices
    interface and sends this information to a C&C server. If a virtual environment
    is detected, the dropper halts execution and deletes itself from the filesystem
    (as opposed to unpacking the malicious binary and exposing it to analysis tools).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Olmasco还包括针对基于虚拟机的机器人跟踪器的对策。在安装过程中，Olmasco通过*Windows管理工具（WMI）* IWbemServices接口检测投放器是否在虚拟环境中运行，并将此信息发送到C&C服务器。如果检测到虚拟环境，投放器会停止执行并从文件系统中删除自己（而不是解包恶意二进制文件并暴露给分析工具）。
- en: '**NOTE**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The Microsoft WMI is a set of interfaces provided on Windows-based platforms
    for data and operations management. One of its main purposes is to automate administrative
    tasks on remote computers. From the malware’s point of view, WMI provides a rich
    set of* Component Object Model (COM) *objects that it can use to gather comprehensive
    information on a system, such as platform information, running processes, and
    security software in use.*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*Microsoft WMI是Windows平台上提供的一组接口，用于数据和操作管理。其主要用途之一是自动化远程计算机的管理任务。从恶意软件的角度来看，WMI提供了一套丰富的*组件对象模型（COM）*对象，恶意软件可以利用这些对象收集有关系统的全面信息，如平台信息、运行中的进程和使用中的安全软件。*'
- en: 'The malware also uses WMI to gather the following information about a targeted
    system:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件还使用WMI来收集有关目标系统的以下信息：
- en: '**Computer** System name, username, domain name, user workgroup, number of
    processors, and so on'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**计算机** 系统名称、用户名、域名、用户工作组、处理器数量等'
- en: '**Processor** Number of cores, processor name, data width, and number of logical
    processors'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**处理器** 核心数、处理器名称、数据宽度和逻辑处理器数量'
- en: '**SCSI controller** Name and manufacturer'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**SCSI控制器** 名称和制造商'
- en: '**IDE controller** Name and manufacturer'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**IDE控制器** 名称和制造商'
- en: '**Disk drive** Name, model, and interface type'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**磁盘驱动器** 名称、型号和接口类型'
- en: '**BIOS** Name and manufacturer'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**BIOS** 名称和制造商'
- en: '**OS** Major and minor version, service pack number, and more'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**操作系统** 主要和次要版本、服务包号等'
- en: Malware operators can use this information to check the hardware configuration
    of an infected system and determine whether it’s useful to them. For instance,
    they can use the BIOS name and manufacturer to detect virtual environments (such
    as VMware, VirtualBox, Bochs, or QEMU), which are frequently used in automated
    malware analysis environments and, therefore, of no interest to malware operators.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件操作者可以利用这些信息检查被感染系统的硬件配置，并确定其是否对他们有用。例如，他们可以使用BIOS名称和制造商来检测虚拟环境（如VMware、VirtualBox、Bochs或QEMU），这些虚拟环境常用于自动化恶意软件分析环境，因此对恶意软件操作者没有兴趣。
- en: On the other hand, they can use the system name and domain name to identify
    the company that owns the infected machine. Using this, they can deploy a custom
    payload that specifically targets that company.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，它们可以使用系统名称和域名来识别拥有被感染机器的公司。利用这些信息，它们可以部署专门针对该公司的定制负载。
- en: '**The Bootkit Functionality**'
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Bootkit功能**'
- en: Once the sandbox checks are finished, the dropper proceeds to install the bootkit
    component onto the system. The bootkit component of Olmasco has been modified
    from the TDL4 bootkit (which, as [Chapter 7](ch07.xhtml#ch07) discussed, overwrites
    the MBR and reserves space at the end of the bootable hard drive for storing its
    malicious components), though Olmasco employs a rather different approach for
    infecting the system.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦沙箱检查完成，投放器会继续将bootkit组件安装到系统中。Olmasco的bootkit组件已从TDL4 bootkit进行了修改（如[第7章](ch07.xhtml#ch07)所讨论的，TDL4会覆盖MBR并在可引导硬盘的末尾保留空间，用于存储其恶意组件），尽管Olmasco采用了一个相当不同的方式来感染系统。
- en: '***Bootkit Infection Technique***'
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Bootkit感染技术***'
- en: First, Olmasco creates a partition at the end of the bootable hard drive. Partition
    tables in Windows hard drives always contain some unpartitioned (or unallocated)
    space at the end, and usually this space is enough to hold a bootkit’s components—and
    sometimes more. The malware creates a malicious partition by occupying the unpartitioned
    space and modifying a free partition table entry in the partition table of the
    original, legitimate MBR to point to it. Strangely, this newly created malicious
    partition is limited to 50GB, no matter how much unpartitioned space is available.
    One possible explanation for limiting the size of the partition is to avoid attracting
    the attention of a user by taking up all the available unpartitioned space.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Olmasco 会在可启动硬盘的末尾创建一个分区。Windows 硬盘上的分区表总是包含一些未分配的空间，并且通常这些空间足以容纳启动工具的组件——有时甚至更多。恶意软件通过占用这些未分配的空间并修改原始合法
    MBR 的空闲分区表项，将其指向新创建的恶意分区，从而创建一个恶意分区。奇怪的是，这个新创建的恶意分区的大小被限制为 50GB，无论未分配空间有多大。一种可能的解释是，限制分区大小是为了避免通过占用所有可用的未分配空间引起用户的注意。
- en: As we discussed in [Chapter 5](ch05.xhtml#ch05), the MBR partition table is
    at offset 0x1BE from the start of the MBR and consists of four 16-byte entries,
    each describing a corresponding partition on the hard drive. There are at most
    four primary partitions on the hard drive, and only one partition can be marked
    as active, so there is only one partition that the bootkit can boot from. The
    malware overwrites the first empty entry in the partition table with the parameters
    of the malicious partition, marks it as active, and initializes the VBR of the
    newly created partition, as shown in [Listing 10-2](ch10.xhtml#ch10list02).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在 [第 5 章](ch05.xhtml#ch05) 中讨论的那样，MBR 分区表位于 MBR 起始处的偏移 0x1BE 位置，由四个 16 字节的条目组成，每个条目描述硬盘上的一个对应分区。硬盘上最多可以有四个主分区，而且只能标记一个分区为活动分区，因此启动工具只能从一个分区启动。恶意软件将分区表中第一个空白条目覆盖为恶意分区的参数，并将其标记为活动分区，初始化新创建分区的
    VBR，如 [列表 10-2](ch10.xhtml#ch10list02) 所示。
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 10-2: Partition table after Olmasco infection*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-2：Olmasco 感染后的分区表*'
- en: Here you can see the malicious partition’s starting address ➊ and size in sectors
    ➋. If the Olmasco bootkit finds that there is no free entry in the partition table,
    it reports this to the C&C server and terminates. [Figure 10-2](ch10.xhtml#ch10fig02)
    shows what happens to the partition table after the system is infected with Olmasco.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到恶意分区的起始地址 ➊ 和大小（以扇区为单位） ➋。如果 Olmasco 启动工具发现分区表中没有空闲项，它会向 C&C 服务器报告，并终止操作。[图
    10-2](ch10.xhtml#ch10fig02) 显示了系统感染 Olmasco 后分区表的变化。
- en: '![image](../images/10fig02.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/10fig02.jpg)'
- en: '*Figure 10-2: Layout of hard drive before and after an Olmasco infection*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-2：Olmasco 感染前后的硬盘布局*'
- en: After infection, a previously empty partition table entry is connected to the
    Olmasco partition and becomes the active partition entry. You can see that the
    MBR code itself remains untouched; the only thing affected is the MBR partition
    table. For additional stealth, the first sector of the Olmasco partition table
    also looks very similar to the legitimate VBR, meaning security software may be
    tricked into believing that Olmasco’s partition is a legitimate partition on the
    hard disk.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 感染后，之前为空的分区表项会连接到 Olmasco 分区，并成为活动分区项。你可以看到，MBR 代码本身保持不变，唯一受到影响的是 MBR 分区表。为了增加隐蔽性，Olmasco
    分区表的第一个扇区也与合法的 VBR 非常相似，这意味着安全软件可能会误认为 Olmasco 的分区是硬盘上的合法分区。
- en: '***Boot Process of the Infected System***'
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***感染系统的启动过程***'
- en: Once a system is infected with Olmasco, it will boot accordingly. The boot process
    of an infected machine is presented in [Figure 10-3](ch10.xhtml#ch10fig03).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦系统感染了 Olmasco，它将按相应方式启动。感染机器的启动过程如 [图 10-3](ch10.xhtml#ch10fig03) 所示。
- en: '![image](../images/10fig03.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/10fig03.jpg)'
- en: '*Figure 10-3: Olmasco-infected system boot process*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-3：Olmasco 感染系统的启动过程*'
- en: 'When the infected machine next boots, the malicious VBR ➋ of the Olmasco partition
    receives control, right after the MBR code is executed ➊ and before the OS bootloader
    components are loaded. This allows the malware to gain control before the OS does.
    When a malicious VBR receives control, it reads the *boot* file from the root
    directory of Olmasco’s hidden filesystem ➌ and transfers control to it. This *boot*
    component plays the same role as the *ldr16* module in previous versions of TDL4:
    it hooks the BIOS interrupt 13h handler ➍ to patch the Boot Configuration Data
    (BCD) ➎ and loads the VBR of the originally active partition.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当被感染的机器下次启动时，Olmasco 分区的恶意 VBR ➋ 获得控制权，在 MBR 代码执行 ➊ 之后，操作系统引导加载程序组件加载之前。这样，恶意软件可以在操作系统之前获得控制。当恶意
    VBR 获得控制时，它从 Olmasco 隐藏文件系统的根目录读取 *boot* 文件 ➌ 并将控制权转交给它。这个 *boot* 组件与 TDL4 早期版本中的
    *ldr16* 模块作用相同：它钩住 BIOS 中断 13h 处理程序 ➍ 来修补引导配置数据（BCD） ➎，并加载原来活动分区的 VBR。
- en: Conceptually, the boot processes of Olmasco and TDL4 are very similar, and the
    components are the same except that Olmasco has different names for the hidden
    filesystem components, as listed in [Table 10-2](ch10.xhtml#ch10tab02). The TDL4
    boot process was covered in detail in [Chapter 7](ch07.xhtml#ch07).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，Olmasco 和 TDL4 的引导过程非常相似，组件基本相同，只是 Olmasco 对隐藏文件系统组件使用了不同的名称，如 [表 10-2](ch10.xhtml#ch10tab02)
    所列。TDL4 的引导过程在 [第 7 章](ch07.xhtml#ch07) 中有详细介绍。
- en: '**Table 10-2:** Boot Components of Olmasco vs. TDL4'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10-2：** Olmasco 与 TDL4 的引导组件对比'
- en: '| **Olmasco** |   | **TDL4** |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| **Olmasco** |   | **TDL4** |'
- en: '| --- | --- | --- |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| *boot* |   | *ldr16* |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| *boot* |   | *ldr16* |'
- en: '| *dbg32*, *dbg64* |   | *ldr32*, *ldr64* |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| *dbg32*, *dbg64* |   | *ldr32*, *ldr64* |'
- en: '**The Rootkit Functionality**'
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Rootkit 功能**'
- en: 'The bootkit’s job is done once it has loaded the malicious kernel-mode driver
    (➏ in [Figure 10-4](ch10.xhtml#ch10fig04)), which implements Olmasco’s rootkit
    functionality. The rootkit section of Olmasco is responsible for the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载了恶意的内核模式驱动程序（➏，见 [图 10-4](ch10.xhtml#ch10fig04)），引导程序的工作就完成了，这个驱动程序实现了 Olmasco
    的 rootkit 功能。Olmasco 的 rootkit 部分负责以下内容：
- en: Hooking the hard drive device object
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 钩住硬盘设备对象
- en: Injecting the payload from the hidden filesystem into processes
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将有效载荷从隐藏文件系统注入到进程中
- en: Maintaining the hidden filesystem
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护隐藏文件系统
- en: Implementing the Transport Driver Interface (TDI) to redirect network communication
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现传输驱动接口（TDI）以重定向网络通信
- en: '***Hooking the Hard Drive Device Object and Injecting the Payload***'
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***钩住硬盘设备对象并注入有效载荷***'
- en: 'The first two elements in the list are essentially the same as in TDL4: Olmasco
    uses the same techniques to hook the hard drive device object and inject the payload
    from the hidden filesystem into processes. Hooking the hard drive device object
    helps prevent the contents of the original MBR from being restored by security
    software, allowing Olmasco to persist through reboot. Olmasco intercepts all the
    read/write requests to the hard drive and blocks those that attempt to modify
    the MBR or read the contents of the hidden filesystem.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的前两个元素本质上与 TDL4 中相同：Olmasco 使用相同的技术来钩住硬盘设备对象，并将有效载荷从隐藏文件系统注入到进程中。钩住硬盘设备对象有助于防止安全软件恢复原始
    MBR 的内容，从而使 Olmasco 在重启后仍能保持存在。Olmasco 拦截所有对硬盘的读写请求，并阻止那些试图修改 MBR 或读取隐藏文件系统内容的请求。
- en: '***Maintaining the Hidden Filesystem***'
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***维护隐藏文件系统***'
- en: The hidden filesystem is an important feature of complex threats such as rootkits
    and bootkits because it provides a covert channel for storing information on a
    victim’s computer. Traditional malware relies on the OS filesystem (NTFS, FAT32,
    extX, and so forth) to store its components, but this makes it vulnerable to forensic
    analysis or detection by security software. To address this, some advanced malware
    types implement their own custom filesystem, which they store in an unallocated
    area of the hard drive. In the vast majority of modern configurations, there are
    at least a few hundred megabytes of unallocated space at the end of the hard drive,
    sufficient for storing malicious components and configuration information. With
    this approach, the files stored in a hidden filesystem aren’t accessible through
    conventional APIs such as Win32 API `CreateFileX`, `ReadFileX`, and so on, but
    the malware is still able to communicate with the hidden storage and access data
    stored there through a special interface. The malware usually also encrypts the
    contents of a hidden filesystem to further hinder forensic analysis.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏文件系统是复杂威胁（如 rootkit 和 bootkit）中的一个重要特性，因为它提供了一个隐秘的通道，用于在受害者计算机上存储信息。传统的恶意软件依赖操作系统文件系统（NTFS、FAT32、extX
    等）来存储其组件，但这使得它容易受到取证分析或安全软件的检测。为了解决这个问题，一些高级恶意软件实现了自己的自定义文件系统，并将其存储在硬盘的未分配区域中。在绝大多数现代配置中，硬盘的末尾至少有几百兆字节的未分配空间，足以存储恶意组件和配置信息。通过这种方式，存储在隐藏文件系统中的文件无法通过常规的
    API（如 Win32 API `CreateFileX`、`ReadFileX` 等）访问，但恶意软件仍然能够通过特殊接口与隐藏存储进行通信并访问其中存储的数据。恶意软件通常还会加密隐藏文件系统的内容，以进一步阻碍取证分析。
- en: '[Figure 10-4](ch10.xhtml#ch10fig04) shows an example of a hidden filesystem.
    You can see that it is located right after the OS filesystem and doesn’t interfere
    with normal OS operation.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-4](ch10.xhtml#ch10fig04) 显示了一个隐藏文件系统的示例。可以看到，它位于操作系统文件系统之后，并且不会干扰正常的操作系统操作。'
- en: '![image](../images/10fig04.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/10fig04.jpg)'
- en: '*Figure 10-4: A hidden filesystem on a hard drive*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-4：硬盘上的隐藏文件系统*'
- en: 'Olmasco’s methods for storing payload modules in the hidden filesystem are
    almost all inherited from the TDL4: it reserves space at the end of the hard drive
    to house its filesystem, whose contents are protected by low-level hooks and an
    RC4 stream cipher. However, Olmasco’s developers extended the design and implementation
    of their hidden filesystem and added enhancements that can support file and folder
    hierarchy, verify the integrity of a file to check if it is corrupted, and better
    manage internal filesystem structures.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Olmasco 存储载荷模块在隐藏文件系统中的方法几乎完全继承自 TDL4：它在硬盘的末尾保留空间来存放其文件系统，文件系统的内容通过低级挂钩和 RC4
    流密码进行保护。然而，Olmasco 的开发人员扩展了隐藏文件系统的设计和实现，并添加了可以支持文件和文件夹层次结构、验证文件完整性以检查其是否损坏、以及更好地管理内部文件系统结构的增强功能。
- en: '**Folder Hierarchy Support**'
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**文件夹层次结构支持**'
- en: Whereas the TDL4 hidden filesystem was capable of storing only files, Olmasco’s
    hidden filesystem can store both files and directories. The root directory is
    denoted with the usual backslash (`\`). For instance, [Listing 10-3](ch10.xhtml#ch10list03)
    shows a fragment of a VBR in Olmasco’s hidden partition, which loads a file named
    *boot* from the root directory using `\boot` ➊.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与 TDL4 的隐藏文件系统只能存储文件不同，Olmasco 的隐藏文件系统可以存储文件和目录。根目录用通常的反斜杠（`\`）表示。例如，[清单 10-3](ch10.xhtml#ch10list03)
    显示了 Olmasco 隐藏分区中 VBR 的片段，该片段通过 `\boot` ➊ 从根目录加载名为 *boot* 的文件。
- en: '[PRE2]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 10-3: A fragment of a VBR of an Olmasco partition*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-3：Olmasco 分区的 VBR 片段*'
- en: '**Integrity Verification**'
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**完整性验证**'
- en: Upon reading a file from the filesystem, Olmasco checks for corruption of the
    contents. This capability wasn’t apparent in TDL4\. Olmasco introduced an additional
    field in each file’s data structure to store the CRC32 checksum value of the file
    contents. If Olmasco detects corruption, it removes the corresponding entry from
    the filesystem and frees those occupied sectors, as shown in [Listing 10-4](ch10.xhtml#ch10list04).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在从文件系统读取文件时，Olmasco 会检查内容是否损坏。这个功能在 TDL4 中并不明显。Olmasco 在每个文件的数据结构中引入了一个额外的字段，用于存储文件内容的
    CRC32 校验和值。如果 Olmasco 检测到损坏，它会从文件系统中移除对应的条目，并释放那些被占用的扇区，如[清单 10-4](ch10.xhtml#ch10list04)所示。
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 10-4: Reading a file from Olmasco’s hidden filesystem*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-4：从 Olmasco 的隐藏文件系统读取文件*'
- en: The routine `RkFsLocateFileInDir` ➊ locates the file in the directory, reads
    its contents ➋, and then computes the file CRC32 checksum and compares ➌ it against
    the value stored in the filesystem. If the values don’t match, the routine deletes
    the files and frees the sectors occupied by the corrupted file ➍. This makes the
    hidden filesystem more robust and the rootkit more stable by reducing the chances
    of loading and executing a corrupted file.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`RkFsLocateFileInDir` ➊ 例程定位目录中的文件，读取其内容 ➋，然后计算文件的 CRC32 校验和，并与文件系统中存储的值进行比较
    ➌。如果值不匹配，例程将删除这些文件，并释放由损坏文件占用的扇区 ➍。这使得隐藏的文件系统更加健壮，根工具包更加稳定，减少了加载和执行损坏文件的可能性。'
- en: '**Filesystem Management**'
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**文件系统管理**'
- en: The filesystem implemented in Olmasco is more mature than that implemented in
    TDL4, so it requires more efficient management in terms of free space usage and
    data structure manipulations. Two special files, *$bad* and *$bitmap*, were introduced
    to help support filesystem contents.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Olmasco 实现的文件系统比 TDL4 实现的文件系统更加成熟，因此在空闲空间使用和数据结构操作方面需要更高效的管理。引入了两个特殊文件，*$bad*
    和 *$bitmap*，来支持文件系统内容的管理。
- en: The *$bitmap* file contains a bitmap of free sectors in the hidden filesystem.
    The bitmap is an array of bits, where every bit corresponds to a sector in the
    filesystem. When a bit is set to `1`, it means the corresponding sector is occupied.
    Using *$bitmap* helps to find a location in the filesystem for storing a new file.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*$bitmap* 文件包含隐藏文件系统中空闲扇区的位图。该位图是一个位数组，每个位对应文件系统中的一个扇区。当某个位被设置为 `1` 时，表示对应的扇区已被占用。使用
    *$bitmap* 有助于在文件系统中找到存储新文件的位置。'
- en: The *$bad* file is a bitmask used to track sectors that contain corrupted files.
    Since Olmasco hijacks the unpartitioned space at the end of the hard drive for
    the hidden filesystem, there is a possibility that some other software may write
    to this area and corrupt the contents of Olmasco’s files. The malware marks these
    sectors in a *$bad* file to prevent their usage in the future.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*$bad* 文件是一个位图，用于跟踪包含损坏文件的扇区。由于 Olmasco 劫持了硬盘末尾的未分区空间来存储隐藏的文件系统，因此有可能其他软件会向这个区域写入数据，从而损坏
    Olmasco 文件的内容。恶意软件将在 *$bad* 文件中标记这些扇区，以防止将来再次使用它们。'
- en: Both of these system files occupy the same level as the root directory and are
    not accessible to the payload, but are for system use only. Interestingly, there
    are files with the same names in the NTFS. This means Olmasco may also use these
    files to trick users into believing that the malicious partition is a legitimate
    NTFS volume.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个系统文件与根目录处于同一层级，无法被负载访问，仅供系统使用。有趣的是，在 NTFS 中也有同名的文件。这意味着 Olmasco 可能还会利用这些文件来欺骗用户，让他们认为恶意分区是一个合法的
    NTFS 卷。
- en: '***Implementing the Transport Driver Interface to Redirect Network Communication***'
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***实现传输驱动程序接口以重定向网络通信***'
- en: The Olmasco bootkit’s hidden filesystem has two modules, `tdi32` and `tdi64`,
    that work with the *Transport Driver Interface (TDI)*. The TDI is a kernel-mode
    network interface that provides an abstraction layer between transport protocols,
    such as TCP/IP, and TDI clients, such as sockets. It’s exposed at the upper edge
    of all transport protocol stacks. A TDI filter allows malware to intercept network
    communication before it reaches transport protocols.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Olmasco 启动工具包的隐藏文件系统有两个模块，`tdi32` 和 `tdi64`，它们与 *传输驱动程序接口 (TDI)* 协同工作。TDI 是一种内核模式的网络接口，为传输协议（如
    TCP/IP）和 TDI 客户端（如套接字）提供抽象层。它位于所有传输协议栈的上层边缘。TDI 过滤器允许恶意软件在网络通信到达传输协议之前拦截它。
- en: The *tdi32*/*tdi64* drivers are loaded by the main rootkit driver *drv32*/*drv64*
    via the undocumented API technique `IoCreateDriver(L"\\Driver\\usbprt", tdi32EntryPoint)`,
    where `tdi32EntryPoint` corresponds to the entry point of the malicious TDI driver.
    [Listing 10-5](ch10.xhtml#ch10list05) shows the routine that attaches the TDI
    to these device objects.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*tdi32*/*tdi64* 驱动程序通过未文档化的 API 技术 `IoCreateDriver(L"\\Driver\\usbprt", tdi32EntryPoint)`
    被主根工具包驱动程序 *drv32*/*drv64* 加载，其中 `tdi32EntryPoint` 对应恶意 TDI 驱动程序的入口点。[列表 10-5](ch10.xhtml#ch10list05)
    显示了将 TDI 附加到这些设备对象的例程。'
- en: '[PRE4]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 10-5: Attaching the TDI driver to network devices*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-5：将 TDI 驱动程序附加到网络设备*'
- en: 'The malicious TDI driver then attaches to the following list of network device
    objects:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意 TDI 驱动程序随后附加到以下网络设备对象列表：
- en: '***\Device\Tcp*** Provides access to TCP protocol at ➊'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '***\Device\Tcp*** 提供对 TCP 协议的访问 ➊'
- en: '***\Device\Udp*** Provides access to UDP protocol at ➋'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '***\Device\Udp*** 提供对 UDP 协议的访问 ➋'
- en: '***\Device\IP*** Provides access to IP protocol at ➌'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '***\Device\IP*** 提供对IP协议的访问在 ➌'
- en: '***\Device\RawIp*** Provides access to raw IP protocol (that is, raw sockets)
    at ➍'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '***\Device\RawIp*** 提供对原始IP协议的访问（即原始套接字）在 ➍'
- en: The main functionality of the malicious TDI driver is to monitor `TDI_CONNECT`
    requests. If an attempt is made to connect to IP address 1.1.1.1 over one of the
    hooked protocols, the malware changes it to address 69.175.67.172 and sets the
    port number to 0x5000\. One of the reasons for doing this is to bypass network
    security software that operates above the TDI layer. In such a case, malicious
    components may attempt to establish a connection with IP address 1.1.1.1, which
    is not malicious, shouldn’t draw the attention of security software, and is processed
    further up than the TDI level. At this point, the malicious `tdi` component replaces
    the original value of the destination with the value 69.175.67.172, and the connection
    is rerouted to another host.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意TDI驱动程序的主要功能是监视`TDI_CONNECT`请求。如果通过某个钩住的协议尝试连接到IP地址1.1.1.1，恶意软件会将其更改为地址69.175.67.172，并将端口号设置为0x5000。这样做的原因之一是绕过在TDI层之上的网络安全软件。在这种情况下，恶意组件可能尝试与IP地址1.1.1.1建立连接，而这个地址本身并不具备恶意性，不会引起安全软件的注意，并且其处理位置在TDI层之上。此时，恶意`tdi`组件将目标地址的原始值替换为69.175.67.172，连接被重定向到另一个主机。
- en: '**Conclusion**'
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结论**'
- en: 'In this chapter, we looked at how the Olmasco bootkit uses the MBR partition
    table as another bootkit infection vector. Olmasco is a descendant of the notorious
    TDL4 bootkit and inherits much of its functionality, while adding a few tricks
    of its own; its combination of MBR partition table modification and use of a fake
    VBR makes it stealthier than its predecessor. In the following chapters, we’ll
    consider two more bootkits that target the VBR using sophisticated infection techniques:
    Rovnix and Gapz.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Olmasco引导病毒如何利用MBR分区表作为另一个引导病毒感染途径。Olmasco是臭名昭著的TDL4引导病毒的后代，继承了它的大部分功能，并且增加了一些新的技巧；它通过修改MBR分区表并使用伪造的VBR，使其比前任更加隐蔽。在接下来的章节中，我们将考虑另外两个采用复杂感染技术，针对VBR的引导病毒：Rovnix和Gapz。
