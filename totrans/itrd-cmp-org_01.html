<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2" id="ch01"><span epub:type="pagebreak" id="page_1"/><strong><span class="big">1</span><br/>SETTING THE STAGE</strong></h2>&#13;
<div class="image1"><img src="../images/pg23_Image_2.jpg" alt="Image" width="191" height="190"/></div>&#13;
<p class="noindentz">We’ll start with a brief overview of how computer hardware can be thought of as organized into three subsystems. The goal of this chapter is to make sure we have a common framework for discussing how things are organized and how they fit together. Working within this framework, you’ll learn how a program is created and executed.</p>&#13;
<p class="indent">There is a fair amount of programming in this book. To help you prepare for this, the chapter ends with a section describing how to set up a programming environment, using my system as an example.</p>&#13;
<h3 class="h3" id="ch01lev1sec1"><strong>Computer Subsystems</strong></h3>&#13;
<p class="noindent">You can think of computer hardware as consisting of three separate subsystems: the <em>central processing unit (CPU)</em>, <em>memory</em>, and <em>input/output (I/O)</em>. These are connected with <em>buses</em>, as shown in <a href="ch01.xhtml#ch1fig1">Figure 1-1</a>.</p>&#13;
<span epub:type="pagebreak" id="page_2"/>&#13;
<div class="image"><img id="ch1fig1" src="../images/pg30_Image_3.jpg" alt="Image" width="456" height="176"/></div>&#13;
<p class="figcap"><em>Figure 1-1: The subsystems of a computer</em></p>&#13;
<p class="indent">Let’s take each of these elements in turn:</p>&#13;
<p class="noindentin"><strong>Central processing unit (CPU)</strong>   Controls the flow of data to and from memory and I/O devices. The CPU performs arithmetic and logical operations on the data. It can decide the order of operations based on the results of arithmetic and logic operations. It contains a small amount of very fast memory.</p>&#13;
<p class="noindentin"><strong>Memory</strong>   Provides storage that is readily accessible to the CPU and I/O devices for the instructions to the CPU and the data they manipulate.</p>&#13;
<p class="noindentin"><strong>Input/output (I/O)</strong>   Communicates with the outside world and with mass storage devices (for example, the disk, network, USB, and printer).</p>&#13;
<p class="noindentin"><strong>Bus</strong>   A physical communication pathway with a protocol specifying exactly how the pathway is used.</p>&#13;
<p class="indenta">As indicated by the arrows in <a href="ch01.xhtml#ch1fig1">Figure 1-1</a>, signals can flow in either direction on the buses. The <em>address bus</em> is used to specify a memory location or an I/O device. Program data and program instructions flow on the <em>data bus</em>. The <em>control bus</em> carries signals that specify how each of the subsystems should be using the signals on the other buses.</p>&#13;
<p class="indent">The buses shown in <a href="ch01.xhtml#ch1fig1">Figure 1-1</a> indicate logical groupings of the signals that must pass between the three subsystems. A given bus implementation might not have physically separate paths for each of the three types of signals. For example, if you have ever installed a graphics card in a computer, it probably used the Peripheral Component Interconnect Express (PCI-E) bus. The same physical connections on the PCI-E bus carry addresses and data, but at different times.</p>&#13;
<h3 class="h3" id="ch01lev1sec2"><strong>Creating and Executing a Program</strong></h3>&#13;
<p class="noindent">A <em>program</em> consists of a sequence of machine instructions stored in memory. A <em>machine instruction</em> causes the computer to perform a specific operation and can be thought of as the native language of the computer.</p>&#13;
<p class="indent">When we create a new program, we use an <em>editor</em> to write the <em>source code</em> for the program, usually in a high-level language such as Python, Java, C++, or C. Python continues to be one of the top programming languages. It’s also the most commonly used language for programming the Raspberry Pi.</p>&#13;
<p class="indent">To create a program in Python, we use an editor to write the program and store it in a source code file. Then, we use the <span class="literal">python</span> command to <span epub:type="pagebreak" id="page_3"/>execute our program. For example, to execute the Python program called <em>my_program.py</em>, we would use the following command:</p>&#13;
<pre class="pre">$ <span class="codestrong1">python my_program.py</span></pre>&#13;
<p class="indent">This command invokes the Python program, which is an <em>interpreter</em> that translates each Python language statement into machine instructions and tells the computer to execute it. Each time we want to execute our program, we need to use the <span class="literal">python</span> command to interpret our source code and execute it.</p>&#13;
<p class="indent">Python and other interpreted languages do a good job of hiding the machine language from us. However, our goal in this book is to see how a program uses machine language to control the computer, so we’ll use C for our programming, which will make it easier for us to see the machine code.</p>&#13;
<p class="indent">As with Python, we use an editor to write a program in C and store it in a source code file. We then use a <em>compiler</em> to translate the C source code into machine language. Instead of translating and executing each statement one at a time, a compiler considers all the statements in a source code file when figuring out how to best translate them into machine code. The resulting machine code is stored in an <em>object</em> file. One or more object files can be linked together to produce an <em>executable</em> file, which is what we use to run our program. For example, we can compile a program named <em>my_program.c</em> with the command:</p>&#13;
<pre class="pre">$ <span class="codestrong1">gcc -o my_program my_program.c</span></pre>&#13;
<p class="indent">To execute our program, we use:</p>&#13;
<pre class="pre">$ <span class="codestrong1">./my_program</span></pre>&#13;
<p class="indent">Don’t worry if you don’t know C. I’ll explain the features we need as we go through the book.</p>&#13;
<p class="indent">Whether they come from an interpreter program or an executable file, the machine instructions that make up the program are loaded into memory. Most programs include some constant data that is also loaded into memory. The CPU executes the program by reading, or <em>fetching</em>, each instruction from memory and executing it. The data is also fetched as needed by the program.</p>&#13;
<p class="indent">When the CPU is ready to execute the next instruction in the program, the location of that instruction in memory is placed on the address bus. The CPU also places a <em>read</em> signal on the control bus. The memory subsystem responds by placing the instruction on the data bus, from where the CPU can copy it. The same sequence of events takes place if the CPU is instructed to read data from memory.</p>&#13;
<p class="indent">If the CPU is instructed to store data in memory, it places the data on the data bus, places the location in memory where the data is to be stored on the address bus, and places a <em>write</em> signal on the control bus. The memory subsystem responds by copying the data on the data bus into the specified memory location.</p>&#13;
<span epub:type="pagebreak" id="page_4"/>&#13;
<p class="indent">Most programs also access I/O devices. Some of these are meant to interact with humans, such as a keyboard, mouse, or screen. Others are meant for machine-readable I/O, such as a disk. I/O devices are very slow compared to the CPU and memory, and they vary widely in their timing characteristics. Because of their timing characteristics, data transfers between I/O devices and the CPU and memory must be explicitly programmed.</p>&#13;
<p class="indent">Programming an I/O device requires a thorough understanding of how the device works and how it interacts with the CPU and memory. We’ll look at some of the general concepts near the end of the book. Meanwhile, nearly every program we write in this book will use at least the terminal screen, which is an output device. The operating system includes functions to perform I/O, and the C runtime environment provides a library of application-oriented functions to access the operating system’s I/O functions. We’ll use these C library functions to perform most of our I/O operations and leave I/O programming to more advanced books.</p>&#13;
<p class="indent">These few paragraphs are intended to provide you with a general overview of how computer hardware is organized. Before exploring these concepts in more depth, the next section will help you set up the tools you’ll need for the programming covered in the rest of the book.</p>&#13;
<h3 class="h3" id="ch01lev1sec3"><strong>The Programming Environment</strong></h3>&#13;
<p class="noindent">In this section, I’ll describe how I set up my Raspberry Pi to do all the programming described in this book. If you’re setting up a Raspberry Pi, I also recommend reading the “Set Up Your Raspberry Pi” section of the Raspberry Pi documentation at <em><a href="https://www.raspberrypi.com/documentation/computers/getting-started.html">https://www.raspberrypi.com/documentation/computers/getting-started.html</a></em>.</p>&#13;
<p class="indent">I’m using the officially supported operating system, Raspberry Pi OS, which is based on the Debian distribution of Linux. You must use the 64-bit version for the programming in this book; the 32-bit version will not work. Other operating systems available for the Raspberry Pi may not support the programming we’ll be doing.</p>&#13;
<p class="indent">Instead of a hard drive or solid-state drive, the Raspberry Pi uses a micro SD card for secondary storage. I used Raspberry Pi Imager to set up my micro SD card (it’s available at <em><a href="https://www.raspberrypi.com/software/">https://www.raspberrypi.com/software/</a></em>, with a short video showing how this is done). When you run Raspberry Pi Imager, select <strong>Raspberry Pi OS (other)</strong> and then <strong>Raspberry Pi OS Full (64-bit)</strong>.</p>&#13;
<p class="indent">The full version includes software tools you’ll need for the programming in this book. You should use the latest version and keep your system updated. This might install newer versions of the software development tools than are available at the time of writing this book. You may see some differences from the code listings in the book, but any variations should be small.</p>&#13;
<p class="indent">Raspberry Pi OS uses the <span class="literal">bash</span> shell program to accept keyboard commands and pass them to the operating system. If you’re new to the command line, I’ll show you the basic commands you need as we go through the book. You’ll be much more productive if you take the time to become <span epub:type="pagebreak" id="page_5"/>familiar with using the command line. To learn more, I recommend William Shotts’s <em>The Linux Command Line</em>, 2nd edition (No Starch Press, 2019).</p>&#13;
<p class="indent">You should also become familiar with the documentation provided in Linux for the programming tools we’ll be using. The simplest is the help system built into most programs. You access help by typing the name of the program with only the <span class="literal">--help</span> option. For example, <span class="literal">gcc --help</span> brings up a list of the command line options you can use with <span class="literal">gcc</span>, with a brief description of what each does.</p>&#13;
<p class="indent">Most Linux programs include a manual, usually called a <em>man page</em>, that provides more complete documentation than the help facility. You can read it by using the <span class="literal">man</span> command followed by the name of the program. For example, <span class="literal">man man</span> brings up the man page for the <span class="literal">man</span> program.</p>&#13;
<p class="indent">GNU programs come with even more complete documentation that can be read with the <span class="literal">info</span> program. You can install the Raspberry Pi OS <span class="literal">info</span> package on your system with the following command:</p>&#13;
<pre class="pre">$ <span class="codestrong1">sudo apt install info</span></pre>&#13;
<p class="indent">Once it’s installed, you can read about <span class="literal">info</span> with the following command, which generates the output shown:</p>&#13;
<pre class="pre">$ <span class="codestrong1">info info</span> &#13;
Next: Stand-alone Info,  Up: (dir) &#13;
 &#13;
Stand-alone GNU Info &#13;
 &#13;
 &#13;
** &#13;
This documentation describes the stand-alone Info reader which you can &#13;
use to read Info documentation. &#13;
   If you are new to the Info reader, then you can get started by typing &#13;
'H' for a list of basic key bindings.  You can read through the rest of &#13;
this manual by typing &lt;SPC&gt; and &lt;DEL&gt; (or &lt;Space&gt; and &lt;Backspace&gt;) to &#13;
move forwards and backwards in it. &#13;
 &#13;
* Menu: &#13;
 &#13;
* Stand-alone Info::            What is Info? &#13;
* Invoking Info::               Options you can pass on the command line. &#13;
* Cursor Commands::             Commands which move the cursor within a node. &#13;
* Scrolling Commands::          Commands for reading the text within a node. &#13;
* Node Commands::               Commands for selecting a new node. &#13;
* Searching Commands::          Commands for searching an Info file. &#13;
* Index Commands::              Commands for looking up in indices. &#13;
* Xref Commands::               Commands for selecting cross-references. &#13;
* Window Commands::             Commands which manipulate multiple windows. &#13;
* Printing Nodes::              How to print out the contents of a node. &#13;
* Miscellaneous Commands::      A few commands that defy categorization. &#13;
* Variables::                   How to change the default behavior of Info. <span epub:type="pagebreak" id="page_6"/>&#13;
* Colors and Styles::           Customize the colors used by Info. &#13;
* Custom Key Bindings::         How to define your own key-to-command bindings. &#13;
* Index::                       Global index. &#13;
-----Info: (info-stnd)Top, 31 lines --All------------------------------------- &#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="indent">Items beginning with <span class="literal">*</span> and ending with <span class="literal">::</span> are hyperlinks to other pages in the manual. Use the arrow keys on your keyboard to put the cursor any place within such an item and press <small>ENTER</small> to bring up that page.</p>&#13;
<p class="indent">I had to install the following Raspberry Pi OS packages to get the <span class="literal">info</span> documentation for the programming tools we’ll be using:</p>&#13;
<p class="noindentin"><span class="codestrong">binutils-doc</span>   This adds useful documentation for the GNU assembler <span class="literal">as</span> (sometimes called <span class="literal">gas</span>).</p>&#13;
<p class="noindentin"><span class="codestrong">gcc-doc</span>   This adds useful documentation for the GNU <span class="literal">gcc</span> compiler.</p>&#13;
<p class="noindenta">The packages you need to get these features may differ depending on the version of the operating system you are using.</p>&#13;
<p class="indent">In most cases, I’ve compiled the programs with no optimization (the <span class="literal">-O0</span> option) because the goal is to study concepts, not to create the most efficient code. The examples should work with most versions of <span class="literal">gcc</span>, <span class="literal">g++</span>, and <span class="literal">as</span> that are installed with Raspberry Pi OS. However, the machine code generated by the compiler may differ, depending on its specific configuration and version. You will begin seeing compiler-generated assembly language about halfway through the book. Any differences should be consistent as you continue through the rest of the book.</p>&#13;
<p class="indent">You will need to use a text editor for your programming. Do not use a word processor. Word processors add a lot of hidden control characters to format the text. These hidden characters confuse compilers and assemblers, causing them to not work.</p>&#13;
<p class="indent">Several excellent text editors exist for the Raspberry Pi, each with its own personality. I recommend trying several and deciding which one you prefer. A few options are preinstalled with Raspberry Pi OS. If you right-click a text file, you will get your choice of the following:</p>&#13;
<p class="noindentin"><strong>Geany</strong>   This is the default editor for programming. It opens if you simply double-click a source code file. The Geany editor provides many useful features in an integrated development environment (IDE).</p>&#13;
<p class="noindentin"><strong>Text Editor</strong>   The actual editor is Mousepad. It’s a very minimal editor lacking many features that are useful for writing program code.</p>&#13;
<p class="noindentin"><strong>Vim</strong>   The Vim editor is an improved version of the Vi editor, which was created for Unix in 1976. It provides a command line user interface that is mode-oriented. Text is manipulated through keyboard commands. Several commands place Vim in “text insert” mode. The <small>ESC</small> key is used to return to command mode.<span epub:type="pagebreak" id="page_7"/></p>&#13;
<p class="indenta">Raspberry Pi OS also comes with the Thonny IDE preinstalled. The tools it includes are intended primarily for Python programming.</p>&#13;
<p class="indent">Another popular editor is Emacs. You can install it on your Raspberry Pi with the following command:</p>&#13;
<pre class="pre">$ <span class="codestrong1">sudo apt install emacs</span></pre>&#13;
<p class="noindent">You can use Emacs from the command line or through a graphical user interface.</p>&#13;
<p class="indent">My favorite editor is Visual Studio Code (VS Code). VS Code is free and available for all common platforms; you can learn more about it at <em><a href="https://code.visualstudio.com">https://code.visualstudio.com</a></em>. It’s also in the Raspberry Pi OS package repositories and can be installed with the following command:</p>&#13;
<pre class="pre">$ <span class="codestrong1">sudo apt install code</span></pre>&#13;
<p class="indent">When installed, it shows up as Visual Studio Code when you right-click a text file. VS Code uses a graphic user interface for editing. It also allows you to open a terminal window to use the command line.</p>&#13;
<p class="indent">The names of the programs mentioned here are <span class="literal">geany</span>, <span class="literal">mousepad</span>, <span class="literal">vim</span>, <span class="literal">thonny</span>, <span class="literal">emacs</span>, and <span class="literal">code</span>. To launch any of these editors from the command line, give the name of the program followed by the name of the file you wish to open. For example, you can use VS Code to create the Python program in “Your Turn” <a href="ch01.xhtml#ch1exe1">exercise 1.1</a> with the following command:</p>&#13;
<pre class="pre">$ <span class="codestrong1">code hello_world.py</span></pre>&#13;
<p class="noindent">If the file <em>hello_world.py</em> does not yet exist, VS Code will create it when you save your work. If the file does exist, VS Code will open it for you to work on.</p>&#13;
<p class="indent">I installed VS Code on my Windows 11 laptop. It allows me to log on to my Raspberry Pi, do all my editing in the editing panel, and open a terminal panel for compiling and executing my programs. You don’t need to install VS Code on your Raspberry Pi for this.</p>&#13;
<p class="indent">Geany, Vim, and VS Code are all good choices for the programming covered in this book. If you’re already comfortable with a text editor on the Raspberry Pi, I recommend sticking with that. Don’t spend too much time trying to pick the “best” one.</p>&#13;
<div class="box">&#13;
<p class="box-title"><strong>YOUR TURN</strong></p>&#13;
<p class="box-list" id="ch1exe1">1.1     Make sure that you understand the Raspberry Pi you’ll be using for the programming in this book. What CPU does it use? How much memory does it have? What are the I/O devices connected to it? Which editor will you be using?<span epub:type="pagebreak" id="page_8"/></p>&#13;
<p class="box-list" id="ch1exe2">1.2     Create the following Python program in a file named <em>hello_world.py</em> and execute it:</p>&#13;
<pre class="preb"># Hello, World program&#13;
print("Hello, World!")</pre>&#13;
<p class="box-parai">What files were created in this exercise?</p>&#13;
<p class="box-list" id="ch1exe3">1.3     Write the following C program in a file named <em>hello_world.c</em>, then compile and execute it:</p>&#13;
<pre class="preb">// Hello, World program &#13;
#include &lt;stdio.h&gt; &#13;
int main(void) &#13;
{ &#13;
    printf("Hello, World!\n"); &#13;
    return 0; &#13;
}</pre>&#13;
<p class="box-parai">What files were created in this exercise?</p>&#13;
</div>&#13;
<h3 class="h3" id="ch01lev1sec4"><strong>What You’ve Learned</strong></h3>&#13;
<p class="noindentin"><strong>Central processing unit (CPU)</strong>  The subsystem that controls most of the activities of the computer. It also contains a small amount of very fast memory.</p>&#13;
<p class="noindentin"><strong>Memory</strong>   The subsystem that provides storage for programs and data.</p>&#13;
<p class="noindentin"><strong>Input/output (I/O)</strong>   The subsystem that provides a means of communication with the outside world and with mass storage devices.</p>&#13;
<p class="noindentin"><strong>Bus</strong>   A communication pathway between the CPU, memory, and I/O.</p>&#13;
<p class="noindentin"><strong>Program execution</strong>   An overview of how the three subsystems and the buses are used when a program is run.</p>&#13;
<p class="noindentin"><strong>Programming environment</strong>   An example of how to set up the tools needed to do the programming in this book.</p>&#13;
<p class="indenta">In the next chapter, you will start learning how data is stored in a computer, get an introduction to programming in C, and start learning how to use the debugger as a learning tool.</p>&#13;
</div>
</div>
</body></html>