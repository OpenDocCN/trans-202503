- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 21 PSEUDO-ENVIRONMENT VARIABLES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: I introduced environment variables in [Chapter 2](chapter2.xhtml) with the set
    command, and they have found their way onto nearly every page since. You can define
    and resolve a simple variable and then maybe reset and use it again in various
    ways. *Pseudo-environment variables* are similar but also quite distinct. You
    can resolve them just like regular environment variables, but their origins or
    how they are set are substantially different.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve already discussed a few pseudo-environment variables, including path,
    pathext, cd, and errorlevel. All pseudo-environment variables share some characteristics,
    but many have unique qualities. There are different means of setting many of them,
    and some you should never set at all. Some are active before you run a bat file,
    and the interpreter updates others repeatedly during an execution.
  prefs: []
  type: TYPE_NORMAL
- en: Each pseudo-environment variable has an intrinsic quality in the Batch universe
    that you must understand before properly using it. In this chapter, I’ll explain
    the intricacies of some pseudo-environment variables already touched on and explore
    some useful ones that we’ll use in future chapters. I’ll also provide the long-promised
    explanation of the primary difference between bat and cmd files from the coder’s
    perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Date and Time
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can easily retrieve the current date and time with the aptly named date
    and time pseudo-environment variables, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This command would have produced the following output if executed shortly after
    the Boston Red Sox snapped their 86-year championship drought:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The date variable contains the current date, formatted as day of week, month,
    day, and year. The day of the week always presents as a three-character mixed-case
    abbreviation, followed by a space, a two-byte month, a forward slash, a two-byte
    day, another slash, and a four-byte year. For instance, Sun 06/08/1986 is an example
    from the early Batch era.
  prefs: []
  type: TYPE_NORMAL
- en: The time variable contains the current time, formatted as hours, minutes, seconds,
    and hundredths of seconds. It uses military time or a 24-hour clock, so 11:39
    PM translates to 23:39:00.00. If the hour is a single digit, Batch precedes it
    with a space instead of a leading zero; just before the stroke of 10:00 AM, time
    resolves to a space followed by 9:59:59.99, and midnight presents as a space followed
    by 0:00:00.00.
  prefs: []
  type: TYPE_NORMAL
- en: It’s certainly an oddity, but keep in mind that time has a leading space in
    lieu of a zero, while date has a leading 0 for all the one-digit months and days
    of the month.
  prefs: []
  type: TYPE_NORMAL
- en: Since date and time are nicely formatted, you can easily use them to enhance
    reports and logfiles, and because date is consistently formatted, it’s easy to
    substring out a datestamp, formatted as CCYYMMDD, as shown in [Listing 21-1](#Lis21-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 21-1: Two commands in the Datestamp.bat bat file to build a datestamp'
  prefs: []
  type: TYPE_NORMAL
- en: (To save keystrokes I like to use the pound sign as a very short variable name,
    but only for a very concise and limited use. Using this variable much later in
    the bat file would be confusing, but using it immediately within the next line
    or two is a nice way to condense the code. Though I must admit that %#:~7,2% is
    esoteric and not to everyone’s liking.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a different technique, here’s the code to build a timestamp formatted
    as HHMMSSss:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first command replaces the leading space, if it exists, with a 0. The next
    two commands remove the two colons and the decimal point.
  prefs: []
  type: TYPE_NORMAL
- en: Unless coding and testing before 10 AM, it’s disturbingly easy to forget about
    the leading space, but it’s critical. If you miss it while testing in the afternoon,
    the variable will suddenly contain a space at the stroke of midnight, and depending
    on how you plan to use it, failures could ensue at a very inopportune time of
    day. Consider this one more batveat.
  prefs: []
  type: TYPE_NORMAL
- en: Datestamps and timestamps have many uses. You can use them in filenames to indicate
    their creation date and time. In an if command, you can compare them to other
    datestamps or timestamps to turn on logic at a specific date and time. You can
    even capture them before and after some process to measure elapsed time.
  prefs: []
  type: TYPE_NORMAL
- en: Prompt
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The prompt pseudo-environment variable does double duty as a command. Just as
    path is a command to change the path variable, prompt is a command to change the
    prompt variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](chapter12.xhtml), when discussing the interpreter-generated
    output (stdout), I mentioned that the interpreter prefixes the output from every
    command, whether it ends up on the console or redirected to a trace file, with
    the prompt. By default, the prompt is the current directory followed by a greater-than
    symbol. For instance, if the two lines of code producing a datestamp in *Datestamp.bat*
    from [Listing 21-1](#Lis21-1) were run from the *C:\Batch\* directory, it might
    generate the following output to a trace file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: But defaults are made to be changed. The prompt variable contains hardcoded
    text and/or special codes that define the content of the prompt seen in stdout,
    and the prompt command is the tool that updates the prompt variable. The command’s
    lone argument is the new prompt variable, which’ll change what we see in stdout.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate, if I were particularly self-absorbed and wanted my signature
    on every line of executed code, this simple command would assuage my ego:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Two pieces of hardcoded text are in the argument, Jack''s and Code. Additionally,
    two special codes insert a space ($S) in between the words and a greater-than
    sign ($G) at the end. Running the same two lines of code on the same date now
    produces this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'But this command and variable were not created for vanity; they were created
    to populate the prompt with customized information. Consider this far more complex
    and esoteric example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This prompt command isn’t the easiest to read, but here it’s broken down:'
  prefs: []
  type: TYPE_NORMAL
- en: '%~NX0    Bat filename and extension; perhaps resolves to Datestamp.bat'
  prefs: []
  type: TYPE_NORMAL
- en: $A    Ampersand; resolves to &
  prefs: []
  type: TYPE_NORMAL
- en: $N    Drive letter; perhaps resolves to C
  prefs: []
  type: TYPE_NORMAL
- en: ':    Hardcoded text; appears as :'
  prefs: []
  type: TYPE_NORMAL
- en: $$    Dollar sign; resolves to $
  prefs: []
  type: TYPE_NORMAL
- en: $C    Open parenthesis; resolves to (
  prefs: []
  type: TYPE_NORMAL
- en: $D    Date; perhaps resolves to Wed 10/27/2004
  prefs: []
  type: TYPE_NORMAL
- en: $B    Pipe; resolves to |
  prefs: []
  type: TYPE_NORMAL
- en: $T    Time; perhaps resolves to 23:39:12.34
  prefs: []
  type: TYPE_NORMAL
- en: $F    Close parenthesis; resolves to)
  prefs: []
  type: TYPE_NORMAL
- en: $G    Greater-than sign; resolves to >
  prefs: []
  type: TYPE_NORMAL
- en: 'After you assign this prompt variable, executing the same two lines might result
    in this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Of these entities in this prompt variable, all but a couple are special codes
    specific to the prompt command. One byte, the colon, is hardcoded, and the first
    item, %~NX0, is just a resolved variable. It happens to be the name and extension
    of the bat file being executed, but most any variable would work here.
  prefs: []
  type: TYPE_NORMAL
- en: The special code for time ($T) allows you to see exactly when each and every
    command executes. If a bat file seems to take longer to execute than it should,
    this is a simple means of pinpointing the bottleneck. In the previous example,
    the fact that the second command executed a hundredth of a second after the first
    is displayed in the prompt, while the rest of the prompt is unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: Also, notice that the greater-than sign ($G) is the last character in the prompt.
    Without it, the prompt bleeds into the command following it, producing a rather
    unreadable stdout. It isn’t required, but it’s good form to conclude the prompt
    with the greater-than sign or some sort of special character.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even add a space or two after the greater-than sign to further distinguish
    the prompt from the output. Regardless of the current prompt variable, this command
    will add two spaces to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This command clearly shows the two uses of prompt. Assuming that the default
    prompt was active, the prompt variable resolves to $P$G (current directory and
    greater-than sign). The command then appends this with $S$S and uses it as the
    argument to the prompt command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This command activates the new prompt with trailing spaces for the execution
    of any subsequent commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: With hardcoded text and all the characters available with the special codes,
    you can easily customize the prompt to virtually any text imaginable to suit any
    need. I showed a number of the special codes earlier, but the help command provides
    a complete list.
  prefs: []
  type: TYPE_NORMAL
- en: Random Numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The random pseudo-environment variable resolves to a random number between 0
    and 32,767, inclusive. You can use this to simulate a coin flip; an even number
    is heads, and an odd is tails. If you want to randomly launch a process on one
    of any number of servers, this pseudo-environment variable gives you that ability.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate one use of random, in [Chapter 15](chapter15.xhtml) I demonstrated
    interactive Batch with a bat file that offered up a joke, pun, or riddle—but just
    one of each. Unfortunately, it didn’t take long to exhaust the material. Now imagine
    a library of 100 bat jokes, 100 bat puns, and 100 bat riddles. Unfortunately (or
    fortunately), I won’t list them here. Imagine further that when the user asks
    for a pun, we randomly select one of the 100 puns from the library.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this happen, we need a couple of things. First, we need to put the
    100 puns into an array so that we can select them individually. (That’ll come
    in [Chapter 29](chapter29.xhtml).) More important at this moment, we need a means
    of generating one random number out of 100 possible numbers. The following set
    /A command uses the random pseudo-environment variable and the modulo operator
    to generate a *random* number between 0 and 99 (sort of):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If the puns are labeled 0 through 99, we can simply choose the pun based on
    the value of punNbr. If the puns are labeled 1 through 100, we merely need to
    add 1 to the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There are two reasons I mentioned that this “sort of” works. First, like the
    vast majority of computer-generated random numbers, this is actually a pseudo-random
    number and not truly random. (Yes, this is the pseudo-random pseudo-environment
    variable.) When the bat file first starts, the interpreter seeds the random function
    with the current time, which it uses in the algorithm that generates all future
    random numbers on request. This means that two bat files starting at the very
    same moment will see the same set of pseudo-random numbers generated—even two
    bat files launched within seconds of each other will see very similar *random*
    numbers, at least for the first few invocations. It’s important to be aware of
    this, although pseudo-random numbers are more than acceptable for most applications.
  prefs: []
  type: TYPE_NORMAL
- en: The second reason punNbr isn’t truly random is that 32,768, the total number
    of random numbers, isn’t divisible by 100\. If you executed the first set command
    in this section 32,768 times (once for each number from 0 to 32,767), 0 would
    be the result 328 times. Likewise, 1 through 67 would be the result 328 times
    each. But you would see 68 as the result only 327 times, and the same goes for
    all of the numbers up to and including 99. The upshot is that some numbers will
    be *randomly* selected just slightly more often than other numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The remainder of this section is the inevitable result of a just slightly obsessive-compulsive
    mathematician becoming a coder who ultimately deals with random numbers. The vast
    majority of the time a pseudo-random number and modulo arithmetic will more than
    get the job done, but if you want to find out how to get as close as possible
    to a truly random number, read on.
  prefs: []
  type: TYPE_NORMAL
- en: The cmdcmdline Variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another interesting pseudo-environment variable is cmdcmdline, or *command
    command line*. It looks redundant, but it’s the command line command that originally
    started the current execution. On Windows computers, the *.bat* extension is associated
    with the Windows *cmd.exe* program by default, and when you open a bat file, this
    program executes it. To demonstrate, assume that the *DateTime.bat* bat file contains
    this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the bat file might write this to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When you open or double-click a bat file, behind the scenes Windows is calling
    the *cmd.exe* program with the /C option and the bat file as its argument. If
    this bat file calls another bat file, the value of cmdcmdline won’t change. It’s
    consistently the command that started the high-level process.
  prefs: []
  type: TYPE_NORMAL
- en: You can parse this variable to get some useful information. Even from a called
    bat file, you can retrieve the original parameter list. If you have redirected
    stdout to a trace file, the path and name of the trace file are at the end of
    the variable’s value, ready to be extracted. A bat file might be designed to run
    in two different modes, stand-alone or invoked by another bat file, with slightly
    different logic needed in each mode. To intelligently determine the mode, compare
    the contents of this variable to the %0 hidden parameter. If you find the name
    of the same bat file in both fields, it’s the high-level bat file and, therefore,
    stand-alone. If not, it must be a called bat file.
  prefs: []
  type: TYPE_NORMAL
- en: System Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another class of pseudo-environment variables informs you about the machine
    where a bat file executes. They are called *system variables*.
  prefs: []
  type: TYPE_NORMAL
- en: A sampling of these system variables includes USERNAME, USERPROFILE, PROCESS_ARCHITECTURE,
    NUMBER_OF_PROCESSORS, and others that’ll be meaningful to anyone familiar with
    the workings of a Windows computer. The variable ProgramFiles resolves to the
    root directory where Microsoft has installed its 64-bit program files, and ProgramFiles(x86)
    does the same for its 32-bit counterpart.
  prefs: []
  type: TYPE_NORMAL
- en: After all of these verbosely named variables, it might seem odd, but OS is a
    severe abbreviation of *operating system*. The directory for holding *temporary*
    files is special enough to warrant two system variables, TEMP and TMP, while you
    can reference the root *Windows directory* via windir.
  prefs: []
  type: TYPE_NORMAL
- en: The USERDOMAIN variable is very handy when your bat file can run in different
    domains, perhaps even different physical locations. Each domain likely has differing
    infrastructure, such as pathing for certain resources, and this one variable is
    the key to making the code intelligent enough to run in those multiple locations.
    Another system variable that I’ve used often is COMPUTERNAME. If a process can
    be launched on any one of dozens of servers, you can use this variable to easily
    determine exactly where the bat file is being executed.
  prefs: []
  type: TYPE_NORMAL
- en: '> NOTE'
  prefs: []
  type: TYPE_NORMAL
- en: '*Despite appearances, I’m not being arbitrary with the capitalization of the
    system variable names in this section. You’re probably aware that all Batch variables
    are case-insensitive and that I typically use camel case, but I show each pseudo-environment
    variable as Microsoft presents them—that is, what would be displayed by running
    a set command with no arguments at the command prompt to avoid any confusion.
    Some are entirely uppercase, some entirely lowercase, some are camel case, some
    are even snake case (words separated by underscores), and a couple even have parentheses
    in the variable name. It’s truly a nightmare for anyone yearning for consistency.*'
  prefs: []
  type: TYPE_NORMAL
- en: Explore further on your own. Pull up the command prompt and enter the three-byte
    command, set, to see a list of all the variables set on your machine. All of them
    are available at the onset of any bat file’s execution on that particular computer.
  prefs: []
  type: TYPE_NORMAL
- en: Bat Files vs. cmd Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 1](chapter1.xhtml), I introduced bat files and cmd files. At the
    time, I mentioned that the only significant difference from a coder’s perspective
    concerned how and when the interpreter sets the return code. Here I’ll detail
    those differences.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve discussed three commands that set errorlevel to a nonzero value when
    the command fails to execute properly: set, path, and prompt. Actually, most commands
    do this, but these differ in that when the command executes successfully, they
    don’t set errorlevel to 0. The upshot is that you can’t trust the value of errorlevel
    after you execute one of these commands.'
  prefs: []
  type: TYPE_NORMAL
- en: In a cmd file, however, executing these commands successfully always sets errorlevel
    to 0, and when they fail, they always set errorlevel to a nonzero value. (I said
    that this was *the* biggest difference. I didn’t say it was a *big* difference.)
  prefs: []
  type: TYPE_NORMAL
- en: Most coders, including myself, rarely interrogate the return code for these
    commands. Even if you pass a nonexistent directory to the path command, it won’t
    fail; it fails only when it can’t reset the variable with a valid path for some
    reason, and I’ve never seen that happen. Likewise, the prompt command accepts
    pretty much anything as the prompt variable, and I’ve never seen it fail either.
    Setting a simple variable with the set command is also difficult to get wrong.
    The one possible exception is when using set /A to do some arithmetic. For instance,
    a missing operand or division by zero generates nonzero values of errorlevel.
  prefs: []
  type: TYPE_NORMAL
- en: That said, if you want to interrogate errorlevel after executing one of these
    commands, there are two solutions. First, when using a bat file, in some way,
    shape, or fashion, you need to reset errorlevel to zero before executing the set,
    path, or prompt command. If the command fails, the interpreter resets errorlevel
    to a nonzero value; if it succeeds, errorlevel will still be zero. The other option
    is to use a cmd file.
  prefs: []
  type: TYPE_NORMAL
- en: There’s one hurdle to overcome with setting the return code to zero in a bat
    file. In general, the issue is how to set pseudo-environment variables. More specifically,
    errorlevel should never be set to anything with a set command, but there’s always
    a way.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Pseudo-Environment Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You have the power to set and reset some pseudo-environment variables. You’ve
    learned that path, cd, and prompt act as both commands and variables, where the
    command resets the variable of the same name. They’re set to defaults when a bat
    file starts, but you can change the values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other pseudo-environment variables, such as windir, are already set when a
    bat file starts, and it would be foolish to reset them. The interpreter sets and
    resets still other such variables during a bat file’s execution, perhaps many
    times. For instance, most commands reset errorlevel; the time variable takes on
    a new value every 100th of a second, and if the bat file is running at midnight,
    date will change as well. You should never set those variables. Notice that I
    didn’t write that you *cannot* set these variables. There’s nothing to stop you
    from executing this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: There’s no compiler to prevent this hubris. The interpreter doesn’t abort and
    crash the execution. It essentially says, “So you want to set errorlevel now?
    This was my variable, but if you want it, fine, it’s yours now. But I’ll have
    nothing more to do with it.” I probably personify the interpreter more than I
    should, but it can be so very passive-aggressive.
  prefs: []
  type: TYPE_NORMAL
- en: This simple yet ill-advised set command transforms the variable into a simple
    user variable and removes it from the domain of the pseudo-environment variables.
    Subsequent commands will succeed or fail, commands that would normally generate
    a return code, but since errorlevel is no longer a pseudo-environment variable,
    it’ll remain as is, unchanged from its erroneously assigned value, until the run
    stream ends or another ill-advised set command erroneously resets it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the pseudo-environment variables that should never be set with a set
    command are errorlevel, date, time, cmdcmdline, and random. When in doubt, it’s
    best to assume that any pseudo-environment variable shouldn’t be reset. It wouldn’t
    make sense to reset most of these variables, but there’s just one that you might
    want to reset: errorlevel. In the prior section, I detail just such a scenario.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command resets errorlevel to 0 without even mentioning errorlevel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The cmd command opens a new command shell, and the /C option tells the interpreter
    to execute the command that comes after it and then terminate the new command
    shell when it’s through. In this example, it executes a simple exit command returning
    0. The result is that it sets errorlevel to 0—without a set command.
  prefs: []
  type: TYPE_NORMAL
- en: If this looks oddly familiar, that’s because I mentioned the *cmd.exe* program
    earlier in this chapter. You can invoke the same program, which also happens to
    be the interpreter, with the cmd command to execute a bat file or another command.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Truly understanding pseudo-environment variables will give you more tools, allowing
    you to complete more tasks. I didn’t provide an exhaustive list, but I touched
    on the important ones. You learned how to manipulate the prompt, how to generate
    random numbers, and about the dangers of erroneously setting certain pseudo-environment
    variables. I also discussed the errorlevel pseudo-environment variable in two
    contexts. You can reset it to any number, but not how you probably imagined, and
    it behaves a little differently in bat files compared to cmd files.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn how to create and format reports in Batch
    using the date and time pseudo-environment variables.
  prefs: []
  type: TYPE_NORMAL
