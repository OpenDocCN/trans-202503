<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2s" id="ch03"><span epub:type="pagebreak" id="page_117"/><strong><span class="big">3</span> <span class="float">Oscillation</span></strong></h2>&#13;
<p class="bq"><em>Trigonometry is a sine of the times.</em></p>&#13;
<p class="att">—Anonymous</p>&#13;
<div class="image"><img src="../images/pg157_Image_217.jpg" alt="Image" width="1125" height="633"/></div>&#13;
<p class="caption"><strong><em>Gala</em> by Bridget Riley, 1974; acrylic on canvas, 159.7 × 159.7 cm</strong></p>&#13;
<p class="noindent7">Bridget Riley, a celebrated British artist, was a driving force behind the Op Art movement of the 1960s. Her work features geometric patterns that challenge the viewer’s perceptions and evoke feelings of movement or vibration. Her 1974 piece <em>Gala</em> showcases a series of curvilinear forms that ripple across the canvas, evoking the natural rhythm of the sine wave.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_118"/>In <a href="ch01.xhtml#ch01">Chapters 1</a> and <a href="ch02.xhtml#ch02">2</a>, I carefully worked out an object-oriented structure to animate a shape in a p5.js canvas, using a vector to represent position, velocity, and acceleration driven by forces in the environment. I could move straight from here into topics such as particle systems, steering forces, group behaviors, and more. However, doing so would mean skipping a fundamental aspect of motion in the natural world: <strong>oscillation</strong>, or the back-and-forth movement of an object around a central point or position.</p>&#13;
<p class="noindent">To model oscillation, you need to understand a little bit about <strong>trigonometry</strong>, the mathematics of triangles. Learning some trig will give you new tools to generate patterns and create new motion behaviors in a p5.js sketch. You’ll learn to harness angular velocity and acceleration to spin objects as they move. You’ll be able to use the sine and cosine functions to model nice ease-in, ease-out wave patterns. You’ll also learn to calculate the more complex forces at play in situations that involve angles, such as a pendulum swinging or a box sliding down an incline.</p>&#13;
<p class="noindent">I’ll start with the basics of working with angles in p5.js, then cover several aspects of trigonometry. In the end, I’ll connect trigonometry with what you learned about forces in <a href="ch02.xhtml#ch02">Chapter 2</a>. This chapter’s content will pave the way for more sophisticated examples that require trig later in this book.</p>&#13;
<h3 class="h3" id="ch00lev1sec30"><strong>Angles</strong></h3>&#13;
<p class="noindent">Before going any further, I need to make sure you understand how the concept of an <strong>angle</strong> fits into creative coding in p5.js. If you have experience with p5.js, you’ve undoubtedly encountered this issue while using the <code>rotate()</code> function to rotate and spin objects. You’re most likely to be familiar with the concept of an angle as measured in <strong>degrees</strong> (see <a href="ch03.xhtml#ch3fig1">Figure 3.1</a>).</p>&#13;
<div class="image"><img id="ch3fig1" src="../images/pg158_Image_218.jpg" alt="Image" width="981" height="420"/></div>&#13;
<p class="figcap">Figure 3.1: Angles measured in degrees</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_119"/>A full rotation goes from 0 to 360 degrees, and 90 degrees (a right angle) is one-fourth of 360, shown in <a href="ch03.xhtml#ch3fig1">Figure 3.1</a> as two perpendicular lines.</p>&#13;
<p class="noindent">Angles are commonly used in computer graphics to specify a rotation for a shape. For example, the square in <a href="ch03.xhtml#ch3fig2">Figure 3.2</a> is rotated 45 degrees around its center.</p>&#13;
<div class="image"><img id="ch3fig2" src="../images/pg159_Image_219.jpg" alt="Image" width="303" height="310"/></div>&#13;
<p class="figcap">Figure 3.2: A square rotated by 45 degrees</p>&#13;
<p class="noindent">The catch is that, by default, p5.js measures angles not in degrees but in <strong>radians</strong>. This alternative unit of measurement is defined by the ratio of the length of the arc of a circle (a segment of the circle’s circumference) to the radius of that circle. One radian is the angle at which that ratio equals 1 (see <a href="ch03.xhtml#ch3fig3">Figure 3.3</a>). A full circle (360 degrees) is equivalent to 2π radians, 180 degrees is equivalent to π radians, and 90 degrees is equivalent to π/2 radians.</p>&#13;
<div class="image"><img id="ch3fig3" src="../images/pg159_Image_220.jpg" alt="Image" width="414" height="300"/></div>&#13;
<p class="figcap">Figure 3.3: The arc length for an angle of 1 radian is equal to the radius.</p>&#13;
<p class="noindent">The formula to convert from degrees to radians is as follows:</p>&#13;
<div class="imagei"><img src="../images/pg159_Image_221.jpg" alt="Image" width="205" height="43"/></div>&#13;
<p class="noindent">Thankfully, if you prefer to think of angles in degrees, you can call <code>angleMode(DEGREES)</code>, or you can use the convenience function <code>radians()</code> to convert values from degrees to radians. The constants <code>PI</code>, <code>TWO_PI</code>, and <code>HALF_PI</code> are also available (equivalent to 180, 360, and 90 degrees, respectively). For example, here are two ways in p5.js to rotate a shape by 60 degrees:</p>&#13;
<pre class="pre">let angle = 60;&#13;
rotate(radians(angle));&#13;
&#13;
angleMode(DEGREES);&#13;
rotate(angle);</pre>&#13;
<div class="box">&#13;
<p class="box-title"><span epub:type="pagebreak" id="page_120"/><img class="inline" src="../images/zoom.jpg" alt="Image" width="24" height="31"/> <strong>What Is Pi?</strong></p>&#13;
<p class="noindent">The mathematical constant <strong>pi</strong> (or the Greek letter π) is a real number defined as the ratio of a circle’s circumference (the distance around the outside of the circle) to its diameter (a straight line that passes through the circle’s center). It’s equal to approximately 3.14159 and can be accessed in p5.js with the built-in <code>PI</code> variable.</p>&#13;
</div>&#13;
<p class="noindent">While degrees can be useful, for the purposes of this book, I’ll be working with radians because they’re the standard unit of measurement across many programming languages and graphics environments. If they’re new to you, this is a good opportunity to practice! Additionally, if you aren’t familiar with the way rotation is implemented in p5.js, I recommend watching my Coding Train video series on transformations in p5.js (<em><a href="https://thecodingtrain.com/transformations">https://thecodingtrain.com/transformations</a></em>).</p>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch3exe1"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 3.1</strong></p>&#13;
<p class="noindent">Rotate a baton-like object around its center by using <code>translate()</code> and <code>rotate()</code>.</p>&#13;
<div class="imagel"><img src="../images/pg160_Image_222.jpg" alt="Image" width="1044" height="439"/></div>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec31"><strong>Angular Motion</strong></h3>&#13;
<p class="noindent">Another term for rotation is <strong>angular motion</strong>—that is, motion about an angle. Just as linear motion can be described in terms of velocity—the rate at which an object’s position changes over time—angular motion can be described in terms of <strong>angular velocity</strong>—the rate at which an object’s angle changes over time. By extension, <strong>angular acceleration</strong> describes changes in an object’s angular velocity.</p>&#13;
<p class="noindent">Luckily, you already have all the math you need to understand angular motion. Remember the stuff I dedicated almost all of <a href="ch01.xhtml#ch01">Chapters 1</a> and <a href="ch02.xhtml#ch02">2</a> to explaining?</p>&#13;
<div class="imagei"><span epub:type="pagebreak" id="page_121"/><img src="../images/pg161_Image_223.jpg" alt="Image" width="300" height="78"/></div>&#13;
<p class="noindent">You can apply exactly the same logic to a rotating object:</p>&#13;
<p class="hang">angular velocity = angular velocity + angular acceleration</p>&#13;
<p class="hang">angle = angle + angular velocity</p>&#13;
<p class="noindent">In fact, these angular motion formulas are simpler than their linear motion equivalents since the angle here is a <em>scalar</em> quantity (a single number), not a vector! This is because in 2D space, there’s one axis of rotation; in 3D space, the angle would become a vector. (Note that in most contexts, these formulas would include a multiplication by the change in time, referred to as <em>delta time</em>. I’m assuming a delta time of 1 that corresponds to one frame of animation in p5.js.)</p>&#13;
<p class="noindent">Using the answer from <a href="ch03.xhtml#ch3exe1">Exercise 3.1</a>, let’s say you wanted to rotate a baton in p5.js by a certain angle. Originally, the code might have read as follows:</p>&#13;
<pre class="pre">translate(width / 2, height / 2);&#13;
rotate(angle);&#13;
line(-60, 0, 60, 0);&#13;
circle(60, 0, 16);&#13;
circle(-60, 0, 16, 16);&#13;
&#13;
angle = angle + 0.1;</pre>&#13;
<p class="noindent">Adding in the principles of angular motion, I can instead write the following example (the solution to <a href="ch03.xhtml#ch3exe1">Exercise 3.1</a>).</p>&#13;
<div class="imagel" id="ch3ex1"><img src="../images/pg161_Image_224.jpg" alt="Image" width="1125" height="1318"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_122"/>Instead of incrementing <code>angle</code> by a fixed amount to steadily rotate the baton, for every frame I add <code>angleAcceleration</code> to <code>angleVelocity</code>, then add <code>angleVelocity</code> to <code>angle</code>. As a result, the baton starts with no rotation and then spins faster and faster as the angular velocity accelerates.</p>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch3exe2"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 3.2</strong></p>&#13;
<p class="noindent">Add an interaction to the spinning baton. How can you control the acceleration with the mouse? Can you introduce the idea of drag, decreasing the angular velocity over time so the baton eventually comes to rest?</p>&#13;
</div>&#13;
<p class="noindent">The logical next step is to incorporate this idea of angular motion into the <code>Mover</code> class. First, I need to add some variables to the class’s constructor:</p>&#13;
<div class="imageiL"><img src="../images/pg162_Image_226.jpg" alt="Image" width="1139" height="395"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_123"/>Then, in <code>update()</code>, the mover’s position and angle are updated according to the algorithm I just demonstrated:</p>&#13;
<div class="imagel"><img src="../images/pg163_Image_228.jpg" alt="Image" width="1138" height="301"/></div>&#13;
<p class="noindent">Of course, for any of this to matter, I also need to rotate the object when drawing it in the <code>show()</code> method. (I’ll add a line from the center to the edge of the circle so that rotation is visible. You could also draw the object as a shape other than a circle.)</p>&#13;
<div class="imagel"><img src="../images/pg163_Image_229.jpg" alt="Image" width="1139" height="561"/></div>&#13;
<p class="noindent">At this point, if you were to actually go ahead and create a <code>Mover</code> object, you wouldn’t see it behave any differently. This is because the angular acceleration is initialized to zero ( <code>this.angleAcceleration = 0;</code> ). For the object to rotate, it needs a nonzero acceleration! Certainly, one option is to hardcode a number in the constructor:</p>&#13;
<pre class="pre">    this.angleAcceleration = 0.01;</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_124"/>You can produce a more interesting result, however, by dynamically assigning an angular acceleration in the <code>update()</code> method according to forces in the environment. This could be my cue to start researching the physics of angular acceleration based on the concepts of torque (<em><a href="https://en.wikipedia.org/wiki/Torque">https://en.wikipedia.org/wiki/Torque</a></em>) and moment of inertia (<em><a href="https://en.wikipedia.org/wiki/Moment_of_inertia">https://en.wikipedia.org/wiki/Moment_of_inertia</a></em>), but at this stage, that level of simulation would be a bit of a rabbit hole. (I’ll cover modeling angular acceleration with a pendulum in more detail in “The Pendulum” on <a href="ch03.xhtml#ch00lev1sec39">page 154</a>, as well as look at how third-party physics libraries realistically model rotational motion in <a href="ch06.xhtml#ch06">Chapter 6</a>.)</p>&#13;
<p class="noindent">Instead, a quick-and-dirty solution that yields creative results will suffice. A reasonable approach is to calculate angular acceleration as a function of the object’s linear acceleration, its rate of change of velocity along a path vector, as opposed to its rotation. Here’s an example:</p>&#13;
<div class="imagel"><img src="../images/pg164_Image_230.jpg" alt="Image" width="1125" height="134"/></div>&#13;
<p class="noindent">Yes, this is arbitrary, but it does do <em>something</em>. If the object is accelerating to the right, its angular rotation accelerates in a clockwise direction; acceleration to the left results in a counterclockwise rotation. Of course, it’s important to think about scale in this case. The value of the acceleration vector’s <code>x</code> component might be too large, causing the object to spin in a way that looks ridiculous or unrealistic. You might even notice a visual illusion called the <em>wagon wheel effect</em>: an object appears to be rotating more slowly or even in the opposite direction because of the large changes between each frame of animation.</p>&#13;
<p class="noindent">Dividing the <code>x</code> component by a value, or perhaps constraining the angular velocity to a reasonable range, could really help. Here’s the entire <code>update()</code> function with these tweaks added.</p>&#13;
<div class="imagel" id="ch3ex2"><span epub:type="pagebreak" id="page_125"/><img src="../images/pg164_Image_231.jpg" alt="Image" width="1125" height="971"/></div>&#13;
<p class="noindent">Notice that I’ve used multiple strategies to keep the object from spinning out of control. First, I divide <code>acceleration.x</code> by <code>10</code> before assigning it to <code>angleAcceleration</code>. Then, for good measure, I also use <code>constrain()</code> to confine <code>angleVelocity</code> to the range <code>(–0.1, 0.1)</code>.</p>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch3exe3"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 3.3</strong></p>&#13;
<p class="noindent">Step 1: Create a simulation of objects being shot out of a cannon. Each object should experience a sudden force when shot (just once) as well as gravity (always present).</p>&#13;
<p class="noindent">Step 2: Add rotation to the object to model its spin as it’s shot from the cannon. How realistic can you make it look?</p>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec32"><strong>Trigonometry Functions</strong></h3>&#13;
<p class="noindent">I think I’m ready to reveal the secret of trigonometry. I’ve discussed angles, I’ve spun a baton. Now it’s time for . . . wait for it . . . <em>sohcahtoa</em>. Yes, <em>sohcahtoa</em>! This seemingly nonsensical word is actually the foundation for much of computer graphics work. A basic understanding of trigonometry is essential if you want to calculate angles, figure out distances between points, and work with circles, arcs, or lines. And <em>sohcahtoa</em> is a mnemonic device (albeit a somewhat absurd one) for remembering the meanings of the trigonometric functions sine, cosine, and tangent. It references the sides of a right triangle, as shown in <a href="ch03.xhtml#ch3fig4">Figure 3.4</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_126"/><img id="ch3fig4" src="../images/pg166_Image_233.jpg" alt="Image" width="771" height="297"/></div>&#13;
<p class="figcap">Figure 3.4: A right triangle showing the sides as adjacent, opposite, and hypotenuse</p>&#13;
<p class="noindent">Take one of the non-right angles in the triangle. The <em>adjacent</em> side is the one touching that angle, the <em>opposite</em> side is the one not touching that angle, and the <em>hypotenuse</em> is the side opposite the right angle. <em>Sohcahtoa</em> tells you how to calculate the angle’s trigonometric functions in terms of the lengths of these sides:</p>&#13;
<ul class="bullet">&#13;
<li class="noindent"><strong>soh:</strong> <strong>s</strong>ine(angle) = <strong>o</strong>pposite/<strong>h</strong>ypotenuse</li>&#13;
<li class="noindent"><strong>cah:</strong> <strong>c</strong>osine(angle) = <strong>a</strong>djacent/<strong>h</strong>ypotenuse</li>&#13;
<li class="noindent"><strong>toa:</strong> <strong>t</strong>angent(angle) = <strong>o</strong>pposite/<strong>a</strong>djacent</li>&#13;
</ul>&#13;
<p class="noindent">Take a look at <a href="ch03.xhtml#ch3fig4">Figure 3.4</a> again. You don’t need to memorize it, but see if you feel comfortable with it. Try redrawing it yourself. Next, let’s look at it in a slightly different way (see <a href="ch03.xhtml#ch3fig5">Figure 3.5</a>).</p>&#13;
<div class="image"><img id="ch3fig5" src="../images/pg166_Image_234.jpg" alt="Image" width="323" height="282"/></div>&#13;
<p class="figcap">Figure 3.5: A vector <img class="inline" src="../images/pg81_Image_71.jpg" alt="Image" width="12" height="16"/> with components <em>x</em>, <em>y</em>, and <em>angle</em></p>&#13;
<p class="noindent">See how a right triangle is created from the vector <img class="inline" src="../images/pg81_Image_73.jpg" alt="Image" width="11" height="17"/>? The vector arrow is the hypotenuse, and the components of the vector (<em>x</em> and <em>y</em>) are the sides of the triangle. The angle is an additional means for specifying the vector’s direction (or <em>heading</em>). Viewed in this way, the trigonometric functions establish a relationship between the components of a vector and its direction + magnitude. As such, trigonometry will prove very useful throughout this book. To illustrate this, let’s look at an example that requires the tangent function.</p>&#13;
<h3 class="h3" id="ch00lev1sec33"><strong>Pointing in the Direction of Movement</strong></h3>&#13;
<p class="noindent">Think all the way back to <a href="ch01.xhtml#ch1ex10">Example 1.10</a>, which featured a <code>Mover</code> object accelerating toward the mouse (<a href="ch03.xhtml#ch3fig6">Figure 3.6</a>).</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_127"/><img id="ch3fig6" src="../images/pg167_Image_235.jpg" alt="Image" width="1125" height="469"/></div>&#13;
<p class="figcap">Figure 3.6: A mover accelerating toward the mouse (from <a href="ch01.xhtml#ch1ex10">Example 1.10</a>)</p>&#13;
<p class="noindent">You might notice that almost all the shapes I’ve been drawing so far have been circles. This is convenient for several reasons, one of which is that using circles allows me to avoid the question of rotation. Rotate a circle and, well, it looks exactly the same. Nevertheless, there comes a time in all motion programmers’ lives when they want to move something around onscreen that isn’t shaped like a circle. Perhaps it’s an ant, or a car, or a spaceship. To look realistic, that object should point in its direction of movement.</p>&#13;
<p class="noindent">When I say “point in its direction of movement,” what I really mean is “rotate according to its velocity vector.” Velocity is a vector, with an x- and y-component, but to rotate in p5.js, you need one number, an angle. Let’s look at the trigonometry diagram once more, this time focused on an object’s velocity vector (<a href="ch03.xhtml#ch3fig7">Figure 3.7</a>).</p>&#13;
<div class="image"><img id="ch3fig7" src="../images/pg167_Image_236.jpg" alt="Image" width="977" height="351"/></div>&#13;
<p class="figcap">Figure 3.7: The tangent of a velocity vector’s angle is <em>y</em> divided by <em>x</em>.</p>&#13;
<p class="noindent">The vector’s x- and y-components are related to its angle through the tangent function. Using the <em>toa</em> in <em>sohcahtoa</em>, I can write the relationship as follows:</p>&#13;
<div class="imagei"><img src="../images/pg167_Image_237.jpg" alt="Image" width="315" height="65"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_128"/>The problem here is that while I know the x- and y-components of the velocity vector, I don’t know the angle of its direction. I have to solve for that angle. This is where another function known as the <em>inverse tangent</em>, or <em>arctangent</em> (<em>arctan</em> or <em>atan</em>, for short), comes in. (There are also <em>inverse sine</em> and <em>inverse cosine</em> functions, called <em>arcsine</em> and <em>arccosine</em>, respectively.)</p>&#13;
<p class="noindent">If the tangent of value <em>a</em> equals value <em>b</em>, then the inverse tangent of <em>b</em> equals <em>a</em>. For example:</p>&#13;
<table class="table">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="borderb"><p class="tab-para">If</p></td>&#13;
<td class="borderb"><p class="tab-para">tan(<em>a</em>) = <em>b</em></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para">then</p></td>&#13;
<td><p class="tab-para"><em>a</em> = arctan(<em>b</em>)</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="noindent">See how one is the inverse of the other? This allows me to solve for the vector’s angle:</p>&#13;
<table class="table">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="borderb"><p class="tab-para">If</p></td>&#13;
<td class="borderb"><p class="tab-para"><img class="inline" src="../images/pg168_Image_238.jpg" alt="Image" width="233" height="44"/></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para">then</p></td>&#13;
<td><p class="tab-para"><img class="inline" src="../images/pg168_Image_239.jpg" alt="Image" width="269" height="45"/></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="noindent">Now that I have the formula, let’s see where it should go in the <code>Mover</code> class’s <code>show()</code> method to make the mover (now drawn as a rectangle) point in its direction of motion. Note that in p5.js, the function for inverse tangent is <code>atan()</code>:</p>&#13;
<div class="imagel"><img src="../images/pg168_Image_240.jpg" alt="Image" width="1125" height="470"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_129"/>This code is pretty darn close and almost works. There’s a big problem, though. Consider the two velocity vectors depicted in <a href="ch03.xhtml#ch3fig8">Figure 3.8</a>.</p>&#13;
<div class="image"><img id="ch3fig8" src="../images/pg169_Image_241.jpg" alt="Image" width="505" height="280"/></div>&#13;
<p class="figcap">Figure 3.8: The vectors <img class="inline" src="../images/pg169_Image_242.jpg" alt="Image" width="15" height="17"/> and <img class="inline" src="../images/pg169_Image_243.jpg" alt="Image" width="15" height="17"/> with components (4, –3) and (–4, 3) point in opposite directions.</p>&#13;
<p class="noindent">Though superficially similar, the two vectors point in quite different directions—opposite directions, in fact! In spite of this, look at what happens if I apply the inverse tangent formula to solve for the angle of each vector:</p>&#13;
<div class="imagei"><img src="../images/pg169_Image_244.jpg" alt="Image" width="945" height="83"/></div>&#13;
<p class="noindent">I get the same angle! That can’t be right, though, since the vectors are pointing in opposite directions. It turns out this is a pretty common problem in computer graphics. I could use <code>atan()</code> along with conditional statements to account for positive/negative scenarios, but p5.js (along with most programming environments) has a helpful function called <code>atan2()</code> that resolves the issue for me.</p>&#13;
<div class="imagel" id="ch3ex3"><img src="../images/pg169_Image_245.jpg" alt="Image" width="1126" height="887"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_130"/>To simplify this even further, the <code>p5.Vector</code> class provides a method called <code>heading()</code>, which takes care of calling <code>atan2()</code> and returns the 2D direction angle, in radians, for any <code>p5.Vector</code>:</p>&#13;
<div class="imagel"><img src="../images/pg170_Image_246.jpg" alt="Image" width="1125" height="59"/></div>&#13;
<p class="noindent">With <code>heading()</code>, it turns out you don’t actually need to implement the trigonometry functions in your code, but understanding how they’re all working is still helpful.</p>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch3exe4"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 3.4</strong></p>&#13;
<p class="noindent">Create a simulation of a vehicle that you can drive around the screen by using the arrow keys: the left arrow accelerates the car to the left, and the right arrow accelerates to the right. The car should point in the direction in which it’s currently moving.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec34"><strong>Polar vs. Cartesian Coordinates</strong></h3>&#13;
<p class="noindent">Anytime you draw a shape in p5.js, you have to specify a pixel position, a set of x- and y-coordinates. These are known as <strong>Cartesian coordinates</strong>, named for René Descartes, the French mathematician who developed the ideas behind Cartesian space.</p>&#13;
<p class="noindent">Another useful coordinate system, known as <strong>polar coordinates</strong>, describes a point in space as a distance from the origin (like the radius of a circle) and an angle of rotation around the origin (usually called <em>θ</em>, the Greek letter theta). Thinking in terms of vectors, a Cartesian coordinate describes a vector’s x- and y-components, whereas a polar coordinate describes a vector’s magnitude (length) and direction (angle).</p>&#13;
<p class="noindent">When working in p5.js, you may find it more convenient to think in polar coordinates, especially when creating sketches that involve rotational or circular movements. However, p5.js’s drawing functions understand only (<em>x</em>, <em>y</em>) Cartesian coordinates. Happily for you, trigonometry holds the key to converting back and forth between polar and Cartesian (see <a href="ch03.xhtml#ch3fig9">Figure 3.9</a>). This allows you to design with whatever coordinate system you have in mind, while always drawing using Cartesian coordinates.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_131"/><img id="ch3fig9" src="../images/pg171_Image_247.jpg" alt="Image" width="949" height="751"/></div>&#13;
<p class="figcap">Figure 3.9: The Greek letter <em>θ</em> (theta) is often used to denote an angle. Since a polar coordinate is conventionally referred to as (<em>r</em>, <em>θ</em>), I’ll use <code>theta</code> as a variable name when referring to an angle in p5.js.</p>&#13;
<p class="noindent">For example, given a polar coordinate with a radius of 75 pixels and an angle (<em>θ</em>) of 45 degrees (or π/4 radians), the Cartesian <em>x</em> and <em>y</em> can be computed as follows:</p>&#13;
<p class="hang">cos(<em>θ</em>) = <em>x/r</em> ⇒ <em>x = r</em> × cos(<em>θ</em>)</p>&#13;
<p class="hang">sin(<em>θ</em>) = <em>y/r</em> ⇒ <em>y = r</em> × sin(<em>θ</em>)</p>&#13;
<p class="noindent">The functions for sine and cosine in p5.js are <code>sin()</code> and <code>cos()</code>, respectively. Each takes one argument, a number representing an angle in radians. These formulas can thus be coded as follows:</p>&#13;
<div class="imagel"><img src="../images/pg171_Image_248.jpg" alt="Image" width="1125" height="167"/></div>&#13;
<p class="noindent">This type of conversion can be useful in certain applications. For instance, moving a shape along a circular path using Cartesian coordinates isn’t so easy. However, with polar coordinates, it’s simple: just increment the angle! Here’s how it’s done with global <code>r</code> and <code>theta</code> variables.</p>&#13;
<div class="imagel" id="ch3ex4"><span epub:type="pagebreak" id="page_132"/><img src="../images/pg172_Image_249.jpg" alt="Image" width="1126" height="1302"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_133"/>Polar-to-Cartesian conversion is common enough that p5.js includes a handy function to take care of it for you. It’s included as a static method of the <code>p5.Vector</code> class called <code>fromAngle()</code>. It takes an angle in radians and creates a unit vector in Cartesian space that points in the direction specified by the angle. Here’s how that would look in <a href="ch03.xhtml#ch3ex4">Example 3.4</a>:</p>&#13;
<div class="imagel"><img src="../images/pg173_Image_250.jpg" alt="Image" width="1125" height="262"/></div>&#13;
<p class="noindent">Are you amazed yet? I’ve demonstrated some pretty great uses of tangent (for finding the angle of a vector) and sine and cosine (for converting from polar to Cartesian coordinates). I could stop right here and be satisfied. But I’m not going to. This is only the beginning. As I’ll show you next, what sine and cosine can do for you goes beyond mathematical formulas and right triangles.</p>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch3exe5"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 3.5</strong></p>&#13;
<p class="noindent">Using <a href="ch03.xhtml#ch3ex4">Example 3.4</a> as a basis, draw a spiral path. Start in the center and move outward. Note that this can be done by changing only one line of code and adding one line of code!</p>&#13;
<div class="imagel"><img src="../images/pg173_Image_251.jpg" alt="Image" width="1043" height="439"/></div>&#13;
</div>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch3exe6"><span epub:type="pagebreak" id="page_134"/><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 3.6</strong></p>&#13;
<p class="noindent">Simulate the spaceship in the game <em>Asteroids</em>. In case you aren’t familiar with <em>Asteroids</em>, here’s a brief description: A spaceship (represented as a triangle) floats in 2D space. The left arrow key turns the spaceship counterclockwise; the right arrow key turns it clockwise. The Z key applies a thrust force in the direction the spaceship is pointing.</p>&#13;
<div class="imagel"><img src="../images/pg174_Image_252.jpg" alt="Image" width="1044" height="439"/></div>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec35"><strong>Properties of Oscillation</strong></h3>&#13;
<p class="noindent">Take a look at the graph of the sine function in <a href="ch03.xhtml#ch3fig10">Figure 3.10</a>, where <em>y</em> = sin(<em>x</em>).</p>&#13;
<div class="image"><img id="ch3fig10" src="../images/pg174_Image_253.jpg" alt="Image" width="1083" height="331"/></div>&#13;
<p class="figcap">Figure 3.10: A graph of <em>y</em> = sin(<em>x</em>)</p>&#13;
<p class="noindent">The output of the sine function is a smooth curve alternating between –1 and 1, also known as a <strong>sine wave</strong>. This behavior, a periodic movement between two points, is the <strong>oscillation</strong> I mentioned at the start of the chapter. Plucking a guitar string, swinging a pendulum, bouncing on a pogo stick—all are examples of oscillating motion that can be modeled using the sine function.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_135"/>In a p5.js sketch, you can simulate oscillation by assigning the output of the sine function to an object’s position. I’ll begin with a basic scenario: I want a circle to oscillate between the left side and the right side of a canvas (<a href="ch03.xhtml#ch3fig11">Figure 3.11</a>).</p>&#13;
<div class="image"><img id="ch3fig11" src="../images/pg175_Image_254.jpg" alt="Image" width="1125" height="469"/></div>&#13;
<p class="figcap">Figure 3.11: An oscillating circle</p>&#13;
<p class="noindent">This pattern of oscillating back and forth around a central point is known as <strong>simple harmonic motion</strong> (or, to be fancier, the periodic sinusoidal oscillation of an object). The code to achieve it is remarkably simple, but before I get into it, I’d like to introduce some of the key terminology related to oscillation (and waves).</p>&#13;
<p class="noindent">When a moving object exhibits simple harmonic motion, its position (in this case, the x-position) can be expressed as a function of time, with the following two elements:</p>&#13;
<ul class="bullet">&#13;
<li class="noindent"><strong>Amplitude:</strong> The distance from the center of motion to either extreme</li>&#13;
<li class="noindent"><strong>Period:</strong> The duration (time) for one complete cycle of motion</li>&#13;
</ul>&#13;
<p class="noindent">To understand these terms, look again at the graph of the sine function in <a href="ch03.xhtml#ch3fig10">Figure 3.10</a>. The curve never rises above 1 or below –1 along the y-axis, so the sine function has an amplitude of 1. Meanwhile, the wave pattern of the curve repeats every 2π units along the x-axis, so the sine function’s period is 2π. (By convention, the units here are radians, since the input value to the sine function is customarily an angle measured in radians.)</p>&#13;
<p class="noindent">So much for the amplitude and period of an abstract sine function, but what are amplitude and period in the p5.js world of an oscillating circle? Well, amplitude can be measured rather easily in pixels. For example, if the canvas is 200 pixels wide, I might choose to oscillate around the center of the canvas, going between 100 pixels right of center and 100 pixels left of center. In other words, the amplitude is 100 pixels.</p>&#13;
<div class="imagel"><span epub:type="pagebreak" id="page_136"/><img src="../images/pg176_Image_255.jpg" alt="Image" width="1125" height="84"/></div>&#13;
<p class="noindent">The period is the amount of time for one complete cycle of an oscillation. However, in a p5.js sketch, what does <em>time</em> really mean? In theory, I could say I want the circle to oscillate every three seconds, then come up with an elaborate algorithm for moving the object according to real-world time, using <code>millis()</code> to track the passage of milliseconds. For what I’m trying to accomplish here, however, real-world time isn’t necessary. The more useful measure of time in p5.js is the number of <strong>frames</strong> that have elapsed, available through the built-in <code>frameCount</code> variable. Do I want the oscillating motion to repeat every 30 frames? Every 50 frames? For now, how about a period of 120 frames:</p>&#13;
<div class="imagel"><img src="../images/pg176_Image_256.jpg" alt="Image" width="1125" height="109"/></div>&#13;
<p class="noindent">Once I have the amplitude and period, it’s time to write a formula to calculate the circle’s x-position as a function of time (the current frame count):</p>&#13;
<div class="imagel"><img src="../images/pg176_Image_257.jpg" alt="Image" width="1125" height="109"/></div>&#13;
<p class="noindent">Think about what’s going here. First, whatever value the <code>sin()</code> function returns is multiplied by <code>amplitude</code>. As you saw in <a href="ch03.xhtml#ch3fig10">Figure 3.10</a>, the output of the sine function oscillates between –1 and 1. Multiplying that value by my chosen amplitude—call it <em>a</em>—gives me the desired result: a value that oscillates between –<em>a</em> and <em>a</em>. (This is also a place where you could use p5.js’s <code>map()</code> function to map the output of <code>sin()</code> to a custom range.)</p>&#13;
<p class="noindent">Now, think about what’s inside the <code>sin()</code> function:</p>&#13;
<pre class="pre">TWO_PI * frameCount / period</pre>&#13;
<p class="noindent">What’s going on here? Start with what you know. I’ve explained that sine has a period of 2π, meaning it will start at 0 and repeat at 2π, 4π, 6π, and so on. If my desired period of oscillation is 120 frames, I want the circle to be in the same position when <code>frameCount</code> is at 120 frames, 240 frames, 360 frames, and so on. Here, <code>frameCount</code> is the only value changing over time; it starts at 0 and counts upward. Let’s take a look at what the formula yields as <code>frameCount</code> increases.</p>&#13;
<table class="table">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:35%"/>&#13;
<col style="width:45%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<td class="borderb"><span epub:type="pagebreak" id="page_137"/><p class="tab-para"><code>frameCount</code></p></td>&#13;
<td class="borderb"><p class="tab-para"><code>frameCount / period</code></p></td>&#13;
<td class="borderb"><p class="tab-para"><code>TWO_PI * frameCount / period</code></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="borderb"><p class="tab-para">0</p></td>&#13;
<td class="borderb"><p class="tab-para">0</p></td>&#13;
<td class="borderb"><p class="tab-para">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="borderb"><p class="tab-para">60</p></td>&#13;
<td class="borderb"><p class="tab-para">0.5</p></td>&#13;
<td class="borderb"><p class="tab-para">π</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="borderb"><p class="tab-para">120</p></td>&#13;
<td class="borderb"><p class="tab-para">1</p></td>&#13;
<td class="borderb"><p class="tab-para">2π</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="borderb"><p class="tab-para">240</p></td>&#13;
<td class="borderb"><p class="tab-para">2</p></td>&#13;
<td class="borderb"><p class="tab-para">4π</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para">. . .</p></td>&#13;
<td><p class="tab-para">. . .</p></td>&#13;
<td><p class="tab-para">. . .</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="noindent">Dividing <code>frameCount</code> by <code>period</code> tells me the number of cycles that have been completed. (Is the wave halfway through the first cycle? Have two cycles completed?) Multiplying that number by <code>TWO_PI</code>, I get the desired result, an appropriate input to the <code>sin()</code> function, since <code>TWO_PI</code> is the value required for sine (or cosine) to complete one full cycle.</p>&#13;
<p class="noindent">Putting it together, here’s an example that oscillates the <code>x</code> position of a circle with an amplitude of 100 pixels and a period of 120 frames.</p>&#13;
<div class="imagel" id="ch3ex5"><img src="../images/pg177_Image_258.jpg" alt="Image" width="1127" height="1128"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_138"/>Before moving on, I would be remiss not to mention <strong>frequency</strong>, the number of cycles of an oscillation per time unit. Frequency is the inverse of the period—that is, 1 divided by the period. For example, if the period is 120 frames, only 1/120th of a cycle is completed in 1 frame, and so the frequency is 1/120. In <a href="ch03.xhtml#ch3ex5">Example 3.5</a>, I chose to define the rate of oscillation in terms of the period, and therefore I didn’t need a variable for frequency. Sometimes, however, thinking in terms of frequency rather than period is more useful.</p>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch3exe7"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 3.7</strong></p>&#13;
<p class="noindent">Using the sine function, create a simulation of a weight (sometimes referred to as a <em>bob</em>) that hangs from a spring from the top of the window. Use the <code>map()</code> function to calculate the vertical position of the bob. In “Spring Forces” on <a href="ch03.xhtml#ch00lev1sec38">page 147</a>, I’ll demonstrate how to create this same simulation by modeling the forces of a spring according to Hooke’s law.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec36"><strong>Oscillation with Angular Velocity</strong></h3>&#13;
<p class="noindent">An understanding of oscillation, amplitude, and period (or frequency) can be essential in the course of simulating real-world behaviors. However, there’s a slightly easier way to implement the simple harmonic motion from <a href="ch03.xhtml#ch3ex5">Example 3.5</a>, one that achieves the same result with fewer variables. Take one more look at the oscillation formula:</p>&#13;
<pre class="pre">let x = amplitude * sin(TWO_PI * frameCount / period);</pre>&#13;
<p class="noindent">Now I’ll rewrite it in a slightly different way:</p>&#13;
<pre class="pre">let x = amplitude * sin( <span class="codestrong">some value that increments slowly</span> );</pre>&#13;
<p class="noindent">If you care about precisely defining the period of oscillation in terms of frames of animation, you might need the formula as I first wrote it. If you don’t care about the exact period, however—for example, if you’ll be choosing it randomly—all you really need inside the <code>sin()</code> function is a value that increments slowly enough for the object’s motion to appear smooth from one frame to the next. Every time this value ticks past a multiple of 2π, the object will have completed one cycle of oscillation.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_139"/>This technique mirrors what I did with Perlin noise in <a href="ch00.xhtml#ch00">Chapter 0</a>. In that case, I incremented an offset variable (which I called <code>t</code> or <code>xoff</code>) to sample various outputs from the <code>noise()</code> function, creating a smooth transition of values. Now, I’m going to increment a value (I’ll call it <code>angle</code>) that’s fed into the <code>sin()</code> function. The difference is that the output from <code>sin()</code> is a smoothly repeating sine wave, without any randomness.</p>&#13;
<p class="noindent">You might be wondering why I refer to the incrementing value as <code>angle</code>, given that the object has no visible rotation. The term <em>angle</em> is used because the value is passed into the <code>sin()</code> function, and angles are the traditional inputs to trigonometric functions. With this in mind, I can reintroduce the concept of angular velocity (and acceleration) to rewrite the example to calculate the <code>x</code> position in terms of a changing angle. I’ll assume these global variables:</p>&#13;
<pre class="pre">let angle = 0;&#13;
let angleVelocity = 0.05;</pre>&#13;
<p class="noindent">I can then write this:</p>&#13;
<pre class="pre">function draw() {&#13;
  angle += angleVelocity;&#13;
  let x = amplitude * sin(angle);&#13;
}</pre>&#13;
<p class="noindent">Here <code>angle</code> is my “value that increments slowly,” and the amount it slowly increments by is <code>angleVelocity</code>.</p>&#13;
<div class="imagel" id="ch3ex6"><img src="../images/pg179_Image_260.jpg" alt="Image" width="1125" height="1209"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_140"/>Just because I’m not referencing the period directly doesn’t mean that I’ve eliminated the concept. After all, the greater the angular velocity, the faster the circle will oscillate (and therefore the shorter the period). In fact, the period is the number of frames it takes for <code>angle</code> to increment by 2π. Since the amount <code>angle</code> increments is controlled by the angular velocity, I can calculate the period as follows:</p>&#13;
<p class="hang">period = 2π/angular velocity</p>&#13;
<p class="noindent">To illustrate the power of thinking of oscillation in terms of angular velocity, I’ll expand the example a bit more by creating an <code>Oscillator</code> class whose objects can oscillate independently along both the x-axis (as before) <em>and</em> the y-axis. The class will need two angles, two angular velocities, and two amplitudes (one for each axis).</p>&#13;
<p class="noindent">This is a perfect opportunity to use <code>createVector()</code> to package each pair of values together! Unlike previous vectors, the values in these vectors won’t be sets of Cartesian coordinates. Nevertheless, the <code>p5.Vector</code> class provides a convenient way to manage pairs of values—in this case, pairs of angles (and their associated velocities, accelerations, and so on).</p>&#13;
<div class="imagel" id="ch3ex7"><span epub:type="pagebreak" id="page_141"/><img src="../images/pg181_Image_262.jpg" alt="Image" width="1126" height="1435"/></div>&#13;
<p class="noindent">To better understand the <code>Oscillator</code> class, it might be helpful to focus on the movement of a single oscillator in the animation. First, observe its horizontal movement. You’ll notice that it oscillates regularly back and forth along the x-axis. Switching your focus to its vertical movement, you’ll see it <span epub:type="pagebreak" id="page_142"/>oscillating up and down along the y-axis. Each oscillator has its own distinct rhythm, given the random initialization of its angle, angular velocity, and amplitude.</p>&#13;
<p class="noindent">The key is to recognize that the <code>x</code> and <code>y</code> properties of the <code>p5.Vector</code> objects <code>this.angle</code>, <code>this.angleVelocity</code>, and <code>this.amplitude</code> aren’t tied to spatial vectors anymore. Instead, they’re used to store the respective properties for two separate oscillations (one along the x-axis, one along the y-axis). Ultimately, these oscillations are manifested spatially when <code>x</code> and <code>y</code> are calculated in the <code>show()</code> method, mapping the oscillations onto the positions of the object.</p>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch3exe8"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 3.8</strong></p>&#13;
<p class="noindent">Try initializing each <code>Oscillator</code> object with velocities and amplitudes that aren’t random to create some sort of regular pattern. Can you make the oscillators appear to be the legs of an insect-like creature?</p>&#13;
</div>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch3exe9"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 3.9</strong></p>&#13;
<p class="noindent">Incorporate angular acceleration into the <code>Oscillator</code> object.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec37"><strong>Waves</strong></h3>&#13;
<p class="noindent">Imagine a single circle oscillating up and down according to the sine function. This is the equivalent of simulating a single point along the x-axis of a wave. With a little panache and a <code>for</code> loop, you can animate the entire wave by placing a series of oscillating circles next to one another (<a href="ch03.xhtml#ch3fig12">Figure 3.12</a>).</p>&#13;
<div class="image"><img id="ch3fig12" src="../images/pg182_Image_263.jpg" alt="Image" width="1125" height="469"/></div>&#13;
<p class="figcap">Figure 3.12: Animating the sine wave with oscillating circles</p>&#13;
<p class="noindent">You could use this wavy pattern to design the body or appendages of a creature, or to simulate a soft surface (such as water). Let’s dive into how the code for this sketch works.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_143"/>Here, the same concepts of amplitude (the wave’s height) and period (the wave’s duration) come into play. However, when drawing the entire wave, the term <em>period</em> shifts its meaning from representing time to describing the width (in pixels) of a full wave cycle. The term for the spatial period (as opposed to the temporal period) of a wave is <strong>wavelength</strong>—the distance a wave travels to complete one full oscillation cycle. And just as with the previous oscillation example, you have the choice of computing the wave pattern according to a precise wavelength or by arbitrarily incrementing the angle value (<em>delta angle</em>) for each spot on the wave.</p>&#13;
<p class="noindent">I’ll go with the simpler case, incrementing the angle. I know I need three variables: an angle, a delta angle (analogous to the previous angular velocity), and an amplitude:</p>&#13;
<pre class="pre">let angle = 0;&#13;
let deltaAngle = 0.2;&#13;
let amplitude = 100;</pre>&#13;
<p class="noindent">Then I’m going to loop through all the <code>x</code> values for each point on the wave. For now, I’ll put 24 pixels between adjacent <code>x</code> values. For each <code>x</code>, I’ll follow these three steps:</p>&#13;
<ol class="order">&#13;
<li class="noindent">Calculate the y-position according to amplitude and the sine of the angle.</li>&#13;
<li class="noindent">Draw a circle at the (<em>x</em>, <em>y</em>) position.</li>&#13;
<li class="noindent">Increment the angle by the delta angle.</li>&#13;
</ol>&#13;
<p class="noindent">The following example translates these steps into code.</p>&#13;
<div class="imagel" id="ch3ex8"><img src="../images/pg183_Image_264.jpg" alt="Image" width="1125" height="1183"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_144"/>What happens if you try different values for <code>deltaAngle</code>? <a href="ch03.xhtml#ch3fig13">Figure 3.13</a> shows some options.</p>&#13;
<div class="image"><img id="ch3fig13" src="../images/pg184_Image_266.jpg" alt="Image" width="1125" height="391"/></div>&#13;
<p class="figcap">Figure 3.13: Three sine waves with varying <code>deltaAngle</code> values (0.05, 0.2, and 0.6 from left to right)</p>&#13;
<p class="noindent">Although I’m not precisely calculating the wavelength, you can see that the greater the change in angle, the shorter the wavelength. It’s also worth noting that as the wavelength decreases, it becomes more difficult to make out the wave since the vertical distance between the individual points increases.</p>&#13;
<p class="noindent">Notice that everything in <a href="ch03.xhtml#ch3ex8">Example 3.8</a> happens inside <code>setup()</code>, so the result is static. The wave never changes or undulates. Adding motion is a bit tricky. Your first instinct might be to say, “Hey, no problem, I’ll just put the <code>for</code> loop inside the <code>draw()</code> function and let <code>angle</code> continue incrementing from one cycle to the next.”</p>&#13;
<p class="noindent">That’s a nice thought, but it doesn’t work. If you try it out, the result will appear extremely erratic and glitchy. To understand why, look back at <a href="ch03.xhtml#ch3ex8">Example 3.8</a>. The right edge of the wave doesn’t match the height of the left edge, so where the wave ends in one cycle of <code>draw()</code> can’t be where it starts in the next. Instead, you need a variable dedicated entirely to tracking the starting <code>angle</code> value in each <span epub:type="pagebreak" id="page_145"/>frame of the animation. This variable (which I’ll call <code>startAngle</code>) increments at its own pace, controlling how much the wave progresses from one frame to the next.</p>&#13;
<div class="imagel" id="ch3ex9"><img src="../images/pg185_Image_267.jpg" alt="Image" width="1126" height="1298"/></div>&#13;
<p class="noindent">In this code example, the increment of <code>startAngle</code> is hardcoded to be <code>0.02</code>, but you may want to consider reusing <code>deltaAngle</code> or creating a second variable instead. By reusing <code>deltaAngle</code>, the spatial progression of the wave would be tied to the temporal one, possibly creating a more synchronized movement. Introducing a separate variable, perhaps called <code>startAngleVelocity</code>, would allow <span epub:type="pagebreak" id="page_146"/>independent control of the speed of the wave. The term <em>velocity</em> is appropriate here since the start angle is changing over time.</p>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch3exe10"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 3.10</strong></p>&#13;
<p class="noindent">Try using the Perlin noise function instead of sine or cosine to set the <code>y</code> values in <a href="ch03.xhtml#ch3ex9">Example 3.9</a>.</p>&#13;
</div>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch3exe11"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 3.11</strong></p>&#13;
<p class="noindent">Encapsulate the wave-generating code into a <code>Wave</code> class, and create a sketch that displays two waves (with different amplitudes/periods), as shown in the following image. Try moving beyond plain circles and lines to visualize the wave in a more creative way. What about connecting the points by using <code>beginShape()</code>, <code>endShape()</code>, and <code>vertex()</code>?</p>&#13;
<div class="imagel"><img src="../images/pg186_Image_268.jpg" alt="Image" width="1044" height="439"/></div>&#13;
</div>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch3exe12"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 3.12</strong></p>&#13;
<p class="noindent">To create more complex waves, you can add multiple waves together. Calculate the height (or <code>y</code>) values for several waves and add those values together to get a single <code>y</code> value. The result is a new wave that incorporates the characteristics of each individual wave.</p>&#13;
<div class="imagel"><img src="../images/pg186_Image_269.jpg" alt="Image" width="1044" height="439"/></div>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec38"><span epub:type="pagebreak" id="page_147"/><strong>Spring Forces</strong></h3>&#13;
<p class="noindent">Exploring the mathematics of triangles and waves has been lovely, but perhaps you’re starting to miss Newton’s laws of motion and vectors. After all, the core of this book is about simulating the physics of moving bodies. In “Properties of Oscillation” on <a href="ch03.xhtml#ch00lev1sec35">page 134</a>, I modeled simple harmonic motion by mapping a sine wave to a range of pixels on a canvas. <a href="ch03.xhtml#ch3exe7">Exercise 3.7</a> asked you to use this technique to create a simulation of a bob hanging from a spring with the <code>sin()</code> function. That kind of quick-and-dirty, one-line-of-code solution won’t do, however, if what you really want is a bob hanging from a spring that responds to other forces in the environment (wind, gravity, and so on). To achieve a simulation like that, you need to model the force of the spring by using vectors.</p>&#13;
<div class="image"><img id="ch3fig14" src="../images/pg187_Image_270.jpg" alt="Image" width="200" height="605"/></div>&#13;
<p class="figcap">Figure 3.14: A spring with an anchor and bob</p>&#13;
<p class="noindent">I’ll consider a spring to be a connection between a movable bob (or weight) and a fixed anchor point (see <a href="ch03.xhtml#ch3fig14">Figure 3.14</a>).</p>&#13;
<p class="noindent">The force of the spring is a vector calculated according to Hooke’s law, named for Robert Hooke, a British physicist who developed the formula in 1660. Hooke originally stated the law in Latin: “<em>Ut tensio, sic vis</em>,” or “As the extension, so the force.” Think of it this way:</p>&#13;
<div class="image"><img id="ch3fig15" src="../images/pg187_Image_271.jpg" alt="Image" width="448" height="547"/></div>&#13;
<p class="figcap">Figure 3.15: A spring’s extension (<em>x</em>) is the difference between its current length and its rest length.</p>&#13;
<div class="exe">&#13;
<p class="noindent">The force of the spring is directly proportional to the extension of the spring.</p>&#13;
</div>&#13;
<p class="noindent">The extension is a measure of how much the spring has been stretched or compressed: as shown in <a href="ch03.xhtml#ch3fig15">Figure 3.15</a>, it’s the difference between the current length of the spring and the spring’s resting length (its equilibrium state). Hooke’s law therefore says that if you pull on the bob a lot, the spring’s force will be strong, whereas if you pull on the bob a little, the force will be weak.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_148"/>Mathematically, the law is stated as follows:</p>&#13;
<p class="hang"><em>F<sub>spring</sub></em> = −<em>kx</em></p>&#13;
<p class="noindent">Here <em>k</em> is the <em>spring constant</em>. Its value scales the force, setting how elastic or rigid the spring is. Meanwhile, <em>x</em> is the extension, the current length minus the rest length.</p>&#13;
<p class="noindent">Now remember, force is a vector, so you need to calculate both magnitude and direction. For the code, I’ll start with the following three variables—two vectors for the anchor and bob positions, and one rest length:</p>&#13;
<div class="imagel"><img src="../images/pg188_Image_272.jpg" alt="Image" width="1125" height="131"/></div>&#13;
<p class="noindent">I’ll then use Hooke’s law to calculate the magnitude of the force. For that, I need <code>k</code> and <code>x</code>. Calculating <code>k</code> is easy; it’s just a constant, so I’ll make something up:</p>&#13;
<pre class="pre">let k = 0.1;</pre>&#13;
<p class="noindent">Finding <code>x</code> is perhaps a bit more difficult. I need to know the difference between the current length and the rest length. The rest length is defined as the variable <code>restLength</code>. What’s the current length? The distance between the anchor and the bob. And how can I calculate that distance? How about the magnitude of a vector that points from the anchor to the bob? (Note that this is exactly the same process I employed to find the distance between objects for the purposes of calculating gravitational attraction in <a href="ch02.xhtml#ch02">Chapter 2</a>.)</p>&#13;
<div class="imagel"><img src="../images/pg188_Image_273.jpg" alt="Image" width="1126" height="206"/></div>&#13;
<p class="noindent">Now that I’ve sorted out the elements necessary for the magnitude of the force (–<em>kx</em>), I need to figure out the direction, a unit vector pointing in the direction of the force. The good news is that I already have this vector. Right? Just a moment ago I asked the question, “How can I calculate that distance?” and I answered, “How about the magnitude of a vector that points from the anchor to the bob?” Well, that vector describes the direction of the force!</p>&#13;
<p class="noindent"><a href="ch03.xhtml#ch3fig16">Figure 3.16</a> shows that if you stretch the spring beyond its rest length, a force should pull it back toward the anchor. And if the spring shrinks below its rest length, the force should push it away from the anchor. The Hooke’s law formula accounts for this reversal of direction with the –1.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_149"/><img id="ch3fig16" src="../images/pg189_Image_274.jpg" alt="Image" width="829" height="538"/></div>&#13;
<p class="figcap">Figure 3.16: The spring force points in the opposite direction of the displacement.</p>&#13;
<p class="noindent">All I need to do now is set the magnitude of the vector used for the distance calculation. Let’s take a look at the code and rename that vector variable <code>force</code>:</p>&#13;
<div class="imagel"><img src="../images/pg189_Image_275.jpg" alt="Image" width="1125" height="231"/></div>&#13;
<p class="noindent">Now that I have the algorithm for computing the spring force, the question remains: What OOP structure should I use? This is one of those situations that has no one correct answer. Several possibilities exist, and the one I choose depends on my goals and personal coding style.</p>&#13;
<p class="noindent">Since I’ve been working all along with a <code>Mover</code> class, I’ll stick with this same framework. I’ll think of the <code>Mover</code> class as the spring’s bob. The bob needs <code>position</code>, <code>velocity</code>, and <code>acceleration</code> vectors to move about the canvas. Perfect—I have those already! And perhaps the bob experiences a gravity force via the <code>applyForce()</code> method. This leaves just one more step, applying the spring force:</p>&#13;
<div class="imagel"><img src="../images/pg189_Image_276.jpg" alt="Image" width="1125" height="533"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_150"/>One option would be to write all the spring-force code in the main <code>draw()</code> loop. But thinking ahead to when you might have multiple bob and spring connections, it would be wise to create an additional class, a <code>Spring</code> class. As shown in <a href="ch03.xhtml#ch3fig17">Figure 3.17</a>, the <code>Bob</code> class keeps track of the bob’s movements; the <code>Spring</code> class keeps track of the spring’s anchor position and its rest length, and calculates the spring force on the bob.</p>&#13;
<div class="image"><img id="ch3fig17" src="../images/pg190_Image_278.jpg" alt="Image" width="645" height="653"/></div>&#13;
<p class="figcap">Figure 3.17: The <code>Spring</code> class has anchor and rest length; the <code>Bob</code> class has position, velocity, and acceleration.</p>&#13;
<p class="noindent">This allows me to write a lovely sketch as follows:</p>&#13;
<div class="imagel"><img src="../images/pg190_Image_279.jpg" alt="Image" width="1125" height="673"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_151"/>Think about how this compares to my first stab at gravitational attraction in <a href="ch02.xhtml#ch2ex6">Example 2.6</a>, when I had separate <code>Mover</code> and <code>Attractor</code> classes. There, I wrote something like this:</p>&#13;
<pre class="pre">  let force = attractor.attract(mover);&#13;
  mover.applyForce(force);</pre>&#13;
<p class="noindent">The analogous situation with a spring might have been as follows:</p>&#13;
<pre class="pre">  let force = spring.connect(bob);&#13;
  bob.applyForce(force);</pre>&#13;
<p class="noindent">Instead, in this example I have the following:</p>&#13;
<pre class="pre">  spring.connect(bob);</pre>&#13;
<p class="noindent">What gives? Why don’t I need to call <code>applyForce()</code> on the bob? The answer, of course, is that I <em>do</em> need to call <code>applyForce()</code> on the bob. It’s just that instead of doing it in <code>draw()</code>, I’m demonstrating that a perfectly reasonable (and sometimes preferable) alternative is to ask the <code>connect()</code> method to call <code>applyForce()</code> on the bob internally:</p>&#13;
<div class="imagel"><img src="../images/pg191_Image_281.jpg" alt="Image" width="1125" height="267"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_152"/>Why do it one way with the <code>Attractor</code> class and another way with the <code>Spring</code> class? When I first discussed forces, showing all the forces being applied in the <code>draw()</code> loop was a clearer way to help you learn about force accumulation. Now that you’re more comfortable, perhaps it’s simpler to embed some of the details inside the objects themselves.</p>&#13;
<p class="noindent">Let’s take a look at the rest of the elements in the <code>Spring</code> class.</p>&#13;
<div class="imagel" id="ch3ex10"><img src="../images/pg192_Image_282.jpg" alt="Image" width="1125" height="1656"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_153"/>The complete code for this example is available on the book’s website and incorporates two additional features: (1) the <code>Bob</code> class includes methods for mouse interactivity, allowing you to drag the bob around the window, and (2) the <code>Spring</code> class includes a method to constrain the connection’s length between a minimum and a maximum value.</p>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch3exe13"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 3.13</strong></p>&#13;
<p class="noindent">Before running to see the example online, take a look at this <code>constrainLength</code> method and see if you can fill in the blanks:</p>&#13;
<div class="imagel"><img src="../images/pg193_Image_284.jpg" alt="Image" width="1043" height="759"/></div>&#13;
</div>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch3exe14"><span epub:type="pagebreak" id="page_154"/><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 3.14</strong></p>&#13;
<p class="noindent">Create a system of multiple bobs and spring connections. How about connecting a bob to another bob with no fixed anchor?</p>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec39"><strong>The Pendulum</strong></h3>&#13;
<p class="noindent">You might have noticed that in <a href="ch03.xhtml#ch3ex10">Example 3.10</a>’s spring code, I never once used sine or cosine. Before you write off all this trigonometry stuff as a tangent, however, allow me to show an example of how it all fits together. Imagine a bob hanging from an anchor connected by a spring with a fully rigid connection that can be neither compressed nor extended. This idealized scenario describes a pendulum and provides an excellent opportunity to practice combining all that you’ve learned about forces and trigonometry.</p>&#13;
<div class="image"><img id="ch3fig18" src="../images/pg194_Image_285.jpg" alt="Image" width="403" height="551"/></div>&#13;
<p class="figcap">Figure 3.18: A pendulum with a pivot, arm, and bob</p>&#13;
<p class="noindent">A <strong>pendulum</strong> is a bob suspended by an arm from a pivot (previously called the <em>anchor</em> in the spring). When the pendulum is at rest, it hangs straight down, as in <a href="ch03.xhtml#ch3fig18">Figure 3.18</a>. If you lift up the pendulum at an angle from its resting state and then release it, however, it starts to swing back and forth, tracing the shape of an arc. A real-world pendulum would live in a 3D space, but I’m going to look at a simpler scenario: a pendulum in the 2D space of a p5.js canvas. <a href="ch03.xhtml#ch3fig19">Figure 3.19</a> shows the pendulum in a nonresting position and adds the forces at play: gravity and tension.</p>&#13;
<p class="noindent">When the pendulum swings, its arm and bob are essentially rotating around the fixed point of the pivot. If no arm connected the bob and the pivot, the bob would simply fall to the ground under the influence of gravity. Obviously, that isn’t what happens. Instead, the fixed length of the arm creates the second force—tension. However, I’m not going to work with this scenario according to these forces, at least not in the way I approached the spring scenario.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_155"/>Instead of using <em>linear</em> acceleration and velocity, I’m going to describe the motion of the pendulum in terms of <em>angular</em> acceleration and <em>angular</em> velocity, which refer to the change of the arm’s angle <em>θ</em> relative to the pendulum’s resting position. I should first warn you, especially if you’re a seasoned physicist, that I’m going to conveniently ignore several important concepts here: conservation of energy, momentum, centripetal force, and more. This isn’t intended to be a comprehensive description of pendulum physics. My goal is to offer you an opportunity to practice your new skills in trigonometry and further explore the relationship between forces and angles through a concrete example.</p>&#13;
<div class="image"><img id="ch3fig19" src="../images/pg195_Image_286.jpg" alt="Image" width="431" height="572"/></div>&#13;
<p class="figcap">Figure 3.19: A pendulum showing <em>θ</em> as the angle relative to its resting position</p>&#13;
<p class="noindent">To calculate the pendulum’s angular acceleration, I’m going to use Newton’s second law of motion but with a little trigonometric twist. Take a look at <a href="ch03.xhtml#ch3fig19">Figure 3.19</a> and tilt your head so that the pendulum’s arm becomes the vertical axis. The force of gravity suddenly points askew, a little to the left—it’s at an angle with respect to your tilted head. If this is starting to hurt your neck, don’t worry. I’ll redraw the tilted figure and relabel the forces <em>F<sub>g</sub></em> for gravity and <em>T</em> for tension (<a href="ch03.xhtml#ch3fig20">Figure 3.20</a>, left).</p>&#13;
<p class="noindent">Let’s now take the force of gravity and divide its vector into x- and y-components, with the arm as the new y-axis. These components form a right triangle, with the force of gravity as the hypotenuse (<a href="ch03.xhtml#ch3fig20">Figure 3.20</a>, right). I’ll call them <em>F<sub>gx</sub></em> and <em>F<sub>gy</sub></em>, but what do these components mean? Well, the <em>F<sub>gy</sub></em> component represents the force that’s opposite to <em>T</em>, the tension force. Remember, the tension force is what keeps the bob from falling off.</p>&#13;
<p class="noindent">The other component, <em>F<sub>gx</sub></em>, is perpendicular to the arm of the pendulum, and it’s the force I’ve been looking for all along! It causes the pendulum to rotate. As the pendulum swings, the y-axis (the arm) will always be perpendicular to the direction of motion. Therefore, I can ignore the tension and <em>F<sub>gy</sub></em> forces and focus on <em>F<sub>gx</sub></em>, which is the <strong>net force</strong> in the direction of motion. And because this force is part of a right triangle, I can calculate it with . . . you guessed it, trigonometry!</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_156"/><img id="ch3fig20" src="../images/pg196_Image_287.jpg" alt="Image" width="967" height="638"/></div>&#13;
<p class="figcap">Figure 3.20: On the left, the pendulum is drawn rotated so that the arm is the y-axis. The right shows <em>F<sub>g</sub></em> zoomed in and divided into components <em>F<sub>gx</sub></em> and <em>F<sub>gy</sub></em>.</p>&#13;
<p class="noindent">The key here is that the top angle of the right triangle is the same as the angle <em>θ</em> between the pendulum’s arm and its resting position. Just as I demonstrated in the discussion of polar coordinates, the sine and cosine functions allow me to separate out the components of the gravity force (the hypotenuse) according to this angle. For <em>F<sub>gx</sub></em>, I need to use sine:</p>&#13;
<p class="hang"><em>sin(θ</em>) = <em>F<sub>gx</sub></em> / <em>F<sub>g</sub></em></p>&#13;
<p class="noindent">Solving for <em>F<sub>gx</sub></em>, I get this:</p>&#13;
<p class="hang"><em>F<sub>gx</sub></em> = <em>F<sub>g</sub></em> × sin(<em>θ</em>)</p>&#13;
<p class="noindent">I’ll now rename this force <em>F<sub>p</sub></em> for <em>force of the pendulum</em>. In <a href="ch03.xhtml#ch3fig21">Figure 3.21</a>, I’ve restored the diagram to its original orientation and relabeled the components. I’ve also moved the starting point of <em>F<sub>p</sub></em> from the bottom of the right triangle to the bob’s center, to clarify how this force moves the bob.</p>&#13;
<p class="noindent">There it is. The net force of the pendulum that causes the rotation is calculated as follows:</p>&#13;
<p class="hang"><em>F<sub>p</sub></em> = <em>F<sub>g</sub></em> × sin(<em>θ</em>)</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_157"/><img id="ch3fig21" src="../images/pg197_Image_288.jpg" alt="Image" width="418" height="713"/></div>&#13;
<p class="figcap">Figure 3.21: <em>F<sub>gx</sub></em> is now labeled <em>F<sub>p</sub></em>, the net force in the direction of motion.</p>&#13;
<p class="noindent">Lest you forget, however, my goal is to determine the angular acceleration of the pendulum. Once I have that, I’ll be able to apply the rules of motion to find a new angle <em>θ</em> for each frame of the animation:</p>&#13;
<p class="hang">angular velocity = angular velocity + angular acceleration</p>&#13;
<p class="hang">angle = angle + angular velocity</p>&#13;
<p class="noindent">The good news is that Newton’s second law establishes a relationship between force and acceleration—namely, <em>F</em> = <em>M</em> × <em>A</em>, or <em>A</em> = <em>F / M</em>. So if the force of the pendulum is equal to the force of gravity times the sine of the angle, then I have this:</p>&#13;
<p class="hang">pendulum angular acceleration = acceleration due to gravity × sin(<em>θ</em>)</p>&#13;
<p class="noindent">This is a good time for a reminder that the context here is creative coding and not pure physics. Yes, the acceleration due to gravity on Earth is 9.8 meters per second squared. But this number isn’t relevant in our world of pixels. Instead, I’ll use an arbitrary constant (called <code>gravity</code>) as a variable that scales the acceleration (incidentally, angular acceleration is usually written as <em>α</em> so as to distinguish it from linear acceleration <em>A</em>):</p>&#13;
<p class="hang"><em>α</em> = gravity × sin(<em>θ</em>)</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_158"/>Before I put everything together, there’s another detail I neglected to mention. Or really, lots of little details. Think about the pendulum arm for a moment. Is it a metal rod? A string? A rubber band? How is it attached to the pivot point? How long is it? What’s its mass? Is it a windy day? I could continue to ask a lot of questions that would affect the simulation. I choose to live, however, in a fantasy world, one where the pendulum’s arm is an idealized rod that never bends and where the mass of the bob is concentrated in a single, infinitesimally small point.</p>&#13;
<p class="noindent">Even though I prefer not to worry myself with all these questions, a critical piece is still missing, related to the calculation of angular acceleration. To keep the derivation of the pendulum’s angular acceleration simple, I assumed that the length of the pendulum’s arm is 1. In reality, however, the length of the pendulum’s arm affects the acceleration of the pendulum because of the concepts of torque and moment of inertia.</p>&#13;
<p class="noindent"><strong>Torque</strong> (or τ) is a measure of the rotational force acting on an object. In the case of a pendulum, torque is proportional to both the mass of the bob and the length of the arm (<em>M</em> × <em>r</em>). The <strong>moment of inertia</strong> (or <em>I</em>) of a pendulum is a measure of the amount of difficulty in rotating the pendulum around the pivot point. It’s proportional to the mass of the bob and the <em>square</em> of the length of the arm (<em>Mr</em><sup>2</sup>).</p>&#13;
<p class="noindent">Remember Newton’s second law, <em>F</em> = <em>M</em> × <em>A</em>? Well, it has a rotational counterpart, <em>τ</em> = <em>I</em> × <em>α</em>. By rearranging the equation to solve for the angular acceleration <em>α</em>, I get <em>α</em> = <em>τ</em> /<em>I</em>. Simplifying further, this becomes <em>Mr</em>/<em>Mr</em><sup>2</sup> or 1/<em>r</em>. The angular acceleration doesn’t depend on the pendulum’s mass!</p>&#13;
<p class="noindent">This is just like Galileo’s Leaning Tower of Pisa experiment demonstrating linear acceleration, where different objects fell at the same rate, regardless of their mass. Here, once again, the mass of a bob doesn’t influence its angular acceleration—only the length of its arm does. Thus, the final formula becomes this:</p>&#13;
<div class="imagei"><img src="../images/pg198_Image_289.jpg" alt="Image" width="180" height="44"/></div>&#13;
<p class="noindent">Amazing! In the end, the formula is so simple that you might be wondering why I bothered going through the explanation at all. I mean, learning is great, but I could have easily just said, “Hey, the angular acceleration of a pendulum is a constant times the sine of the angle divided by the length of the arm.” That would be missing the point. The purpose of this book isn’t to learn how pendulums swing or gravity works. The point is to think creatively about how shapes can move around a screen in a computationally based graphics system. The pendulum is just a case study. If you can understand the approach to programming a pendulum, you can apply the same techniques to other scenarios, no matter how you choose to design your p5.js canvas world.</p>&#13;
<p class="noindent">Now, I’m not finished yet. I may be happy with my simple, elegant formula for angular acceleration, but I still have to apply it in code. This is an excellent opportunity to practice some OOP skills and create a <code>Pendulum</code> class. First, think about all the properties of a pendulum that I’ve mentioned:</p>&#13;
<ul class="bullet">&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_159"/>Arm length</li>&#13;
<li class="noindent">Angle</li>&#13;
<li class="noindent">Angular velocity</li>&#13;
<li class="noindent">Angular acceleration</li>&#13;
</ul>&#13;
<p class="noindent">The <code>Pendulum</code> class needs all these properties too:</p>&#13;
<div class="imagel"><img src="../images/pg199_Image_290.jpg" alt="Image" width="1138" height="295"/></div>&#13;
<p class="noindent">Next, I need to write an <code>update()</code> method to update the pendulum’s angle according to the formula:</p>&#13;
<div class="imagel"><img src="../images/pg199_Image_291.jpg" alt="Image" width="1138" height="332"/></div>&#13;
<p class="noindent">Note that the acceleration calculation now includes a multiplication by –1. When the pendulum is to the right of its resting position, the angle is positive, and so the sine of the angle is also positive. However, gravity should pull the bob back toward the resting position. Conversely, when the pendulum is to the left of its resting position, the angle is negative, and so its sine is negative too. In this case, the pulling force should be positive. Multiplying by –1 is necessary in both scenarios.</p>&#13;
<p class="noindent">Next, I need a <code>show()</code> method to draw the pendulum on the canvas. But where exactly should I draw it? How do I calculate the x- and y-coordinates (Cartesian!) for both the pendulum’s pivot point (let’s call it <code>pivot</code>) and bob position (let’s call it <code>bob</code>)? This may be getting a little tiresome, but the answer, yet again, is trigonometry, as shown in <a href="ch03.xhtml#ch3fig22">Figure 3.22</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_160"/><img id="ch3fig22" src="../images/pg200_Image_292.jpg" alt="Image" width="501" height="576"/></div>&#13;
<p class="figcap">Figure 3.22: The bob position relative to the pivot in polar and Cartesian coordinates</p>&#13;
<p class="noindent">First, I’ll need to add a <code>this.pivot</code> property to the constructor to specify where to draw the pendulum on the canvas:</p>&#13;
<pre class="pre">this.pivot = createVector(100, 10);</pre>&#13;
<p class="noindent">I know the bob should be a set distance away from the pivot, as determined by the arm length. That’s my variable <code>r</code>, which I’ll set now:</p>&#13;
<pre class="pre">this.r = 125;</pre>&#13;
<p class="noindent">I also know the bob’s current angle relative to the pivot: it’s stored in the variable <code>angle</code>. Between the arm length and the angle, what I have is a polar coordinate for the bob: (<em>r</em>, <em>θ</em>). What I really need is a Cartesian coordinate, but luckily I already know how to use sine and cosine to convert from polar to Cartesian. And so:</p>&#13;
<pre class="pre">this.bob = createVector(r * sin(this.angle), r * cos(this.angle));</pre>&#13;
<p class="noindent">Notice that I’m using <code>sin(this.angle)</code> for the <em>x</em> value and <code>cos(this.angle)</code> for the <em>y</em>. This is the opposite of what I showed you in “Polar vs. Cartesian Coordinates” on <a href="ch03.xhtml#ch00lev1sec34">page 130</a>. The reason is that I’m now looking for the top angle of a right triangle pointing down, as depicted in <a href="ch03.xhtml#ch3fig21">Figure 3.21</a>. This angle lives between the y-axis and the hypotenuse, instead of between the x-axis and the hypotenuse, as you saw earlier in <a href="ch03.xhtml#ch3fig9">Figure 3.9</a>.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_161"/>Right now, the value of <code>this.bob</code> is assuming that the pivot is at point (0, 0). To get the bob’s position relative to wherever the pivot <em>actually</em> happens to be, I can just add <code>pivot</code> to the <code>bob</code> vector:</p>&#13;
<pre class="pre">this.bob.add(this.pivot);</pre>&#13;
<p class="noindent">Now all that remains is the little matter of drawing a line and a circle (you should be more creative, of course):</p>&#13;
<pre class="pre">stroke(0);&#13;
fill(127);&#13;
line(this.pivot.x, this.pivot.y, this.bob.x, this.bob.y);&#13;
circle(this.bob.x, this.bob.y, 16);</pre>&#13;
<p class="noindent">Finally, a real-world pendulum is going to experience a certain amount of friction (at the pivot point) and air resistance. As it stands, the pendulum would swing forever with the given code. To make it more realistic, I can slow the pendulum with a damping trick. I say <em>trick</em> because rather than model the resistance forces with some degree of accuracy (as I did in <a href="ch02.xhtml#ch02">Chapter 2</a>), I can achieve a similar result simply by reducing the angular velocity by an arbitrary amount during each cycle. The following code reduces the velocity by 1 percent (or multiplies it by 0.99) for each frame of animation:</p>&#13;
<pre class="pre">this.angleVelocity *= 0.99;</pre>&#13;
<p class="noindent">Putting everything together, I have the following example (with the pendulum beginning at a 45-degree angle).</p>&#13;
<div class="imagel" id="ch3ex11"><span epub:type="pagebreak" id="page_162"/><img src="../images/pg201_Image_293.jpg" alt="Image" width="1125" height="2282"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_163"/>On the book’s website, this example has additional code to allow the user to grab the pendulum and swing it with the mouse.</p>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch3exe15"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 3.15</strong></p>&#13;
<p class="noindent">String together a series of pendulums so that the bob of one is the pivot point of another. Note that doing this may produce intriguing results but will be wildly inaccurate physically. Simulating an actual double pendulum requires sophisticated equations. You can read about them in the Wolfram Research article on double pendulums (<em><a href="https://scienceworld.wolfram.com/physics/DoublePendulum.html">https://scienceworld.wolfram.com/physics/DoublePendulum.html</a></em>) or watch my video on coding a double pendulum (<em><a href="https://thecodingtrain.com/doublependulum">https://thecodingtrain.com/doublependulum</a></em>).</p>&#13;
<div class="imagel"><img src="../images/pg203_Image_296.jpg" alt="Image" width="1044" height="439"/></div>&#13;
</div>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch3exe16"><span epub:type="pagebreak" id="page_164"/><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 3.16</strong></p>&#13;
<div class="imagel"><img src="../images/pg204_Image_297.jpg" alt="Image" width="855" height="389"/></div>&#13;
<p class="noindent">Using trigonometry, how do you calculate the magnitude of the <strong>normal force</strong> depicted here (the force perpendicular to the incline on which the sled rests)? You can consider the magnitude of <em>F</em><sub>gravity</sub> to be a known constant. Look for a right triangle to help get you started. After all, the normal force is equal and opposite to a component of the force of gravity. If it helps to draw over the diagram and make more right triangles, go for it!</p>&#13;
</div>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch3exe17"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 3.17</strong></p>&#13;
<p class="noindent">Create a simulation of a box sliding down an incline with friction. Note that the magnitude of the friction force is proportional to the normal force, as discussed in the previous exercise.</p>&#13;
</div>&#13;
<div class="box">&#13;
<p class="box-title" id="ch03end1"><span epub:type="pagebreak" id="page_165"/><img class="inline" src="../images/bird.jpg" alt="Image" width="30" height="33"/> <strong>The Ecosystem Project</strong></p>&#13;
<p class="noindent">Take one of your creatures and incorporate oscillation into its motion. You can use the <code>Oscillator</code> class from <a href="ch03.xhtml#ch3ex7">Example 3.7</a> as a model. The <code>Oscillator</code> object, however, oscillates around a single point (the middle of the window). Try oscillating around a moving point.</p>&#13;
<p class="noindent">In other words, design a creature that moves around the screen according to position, velocity, and acceleration. But that creature isn’t just a static shape; it’s an oscillating body. Consider tying the speed of oscillation to the speed of motion. Think of a butterfly’s flapping wings or the legs of an insect. Can you make it appear as though the creature’s internal mechanics (oscillation) drive its locomotion? See the book’s website for an additional example combining attraction from <a href="ch02.xhtml#ch02">Chapter 2</a> with oscillation.</p>&#13;
<div class="imagel"><img src="../images/pg205_Image_298.jpg" alt="Image" width="1041" height="641"/><span epub:type="pagebreak" id="page_166"/></div>&#13;
</div>&#13;
</div>
</div>
</body></html>