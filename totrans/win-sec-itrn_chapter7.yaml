- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp> <samp class="SANS_Dogma_OT_Bold_B_11">THE
    ACCESS CHECK PROCESS</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ve covered the first two components of the SRM: the security access token
    and the security descriptor. Now we’ll define its final component: the access
    check process, which accepts the token and the security descriptor and applies
    a fixed set of rules to determine whether an application can access a resource.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by discussing the APIs you can call to perform an access check.
    Then we’ll take a deep dive into the implementation of the access check inside
    the Windows kernel, detailing how this check processes the different parts of
    the security descriptor and <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object to generate a final granted access value for the resource. In doing so,
    we’ll develop our own basic implementation of the access check process using a
    PowerShell script.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Running an Access Check</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a caller attempts to open a resource, the kernel performs an access check
    based on the caller’s identity. The API used to run the access check depends on
    whether it’s being called from kernel mode or user mode. Let’s start by describing
    the kernel-mode API.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Kernel-Mode Access
    Checks</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAccessCheck</samp> API
    implements the access check process in kernel mode. It accepts the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security descriptor    **The security descriptor to use for the check; must
    contain both owner and group SIDs'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security subject context    **The primary and impersonation tokens for the
    caller'
  prefs: []
  type: TYPE_NORMAL
- en: '**Desired access    **An access mask for the access requested by the caller'
  prefs: []
  type: TYPE_NORMAL
- en: '**Access mode    **The caller’s access mode, set to either <samp class="SANS_TheSansMonoCd_W5Regular_11">UserMode</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">KernelMode</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '**Generic mapping    **The type-specific generic mapping'
  prefs: []
  type: TYPE_NORMAL
- en: 'The API returns four values:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Granted access    **An access mask for the access the user was granted'
  prefs: []
  type: TYPE_NORMAL
- en: '**Access status code    **An NT status code indicating the result of the access
    check'
  prefs: []
  type: TYPE_NORMAL
- en: '**Privileges    **Any privileges used during the access check'
  prefs: []
  type: TYPE_NORMAL
- en: '**Success code    **A Boolean value; if <samp class="SANS_TheSansMonoCd_W5Regular_11">TRUE</samp>,
    the access check succeeded'
  prefs: []
  type: TYPE_NORMAL
- en: If the access check succeeds, the API will set the granted access to the desired
    access parameter, the success code to true, and the access status code to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">STATUS_SUCCESS</samp>. However, if any
    bit in the desired access is not granted, it will set the granted access to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, the success code to false, and
    the access status code to <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_ACCESS_DENIED</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: You might wonder why the API bothers returning the granted access value if all
    bits in the desired access must be granted for this value to indicate a success.
    The reason is that this behavior supports the <samp class="SANS_TheSansMonoCd_W5Regular_11">MaximumAllowed</samp>
    access mask bit, which the caller can set in the desired access parameter. If
    the bit is set and the access check grants at least one access, the API returns
    <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_SUCCESS</samp>, setting the
    granted access to the maximum allowed access.
  prefs: []
  type: TYPE_NORMAL
- en: The security subject context parameter is a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY
    _SUBJECT_CONTEXT</samp> structure containing the caller’s primary token and any
    impersonation token of the caller’s thread. Typically, kernel code will use the
    kernel API <samp class="SANS_TheSansMonoCd_W5Regular_11">SeCaptureSubjectContext</samp>
    to initialize the structure and gather the correct tokens for the current caller.
    If the impersonation token is captured, it must be at Impersonation level or above;
    otherwise, the API will fail and the access status code will be set to <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_BAD_IMPERSONATION_LEVEL</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAccessCheck</samp>
    might not occur in the thread that made the original resource request. For example,
    the check might have been delegated to a background thread in the <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp>
    process. The kernel can capture the subject context from the original thread and
    then pass that context to the thread that calls <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAccessCheck</samp>,
    to ensure that the access check uses the correct identity.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Access Mode</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The access-mode parameter has two possible values, <samp class="SANS_TheSansMonoCd_W5Regular_11">UserMode</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">KernelMode</samp>. If you pass
    <samp class="SANS_TheSansMonoCd_W5Regular_11">UserMode</samp> to this parameter,
    all access checks will continue as normal. However, if you pass <samp class="SANS_TheSansMonoCd_W5Regular_11">KernelMode</samp>,
    the kernel will disable all access checks. Why would you want to call <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAccessCheck</samp>
    without enforcing any security? Well, usually, you won’t directly call the API
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">KernelMode</samp> value.
    Instead, the parameter will be set to the value of the calling thread’s <samp
    class="SANS_TheSansMonoCd_W5Regular_11">PreviousMode</samp> parameter, which is
    stored in the thread’s kernel object structure. When you call a system call from
    a user-mode application, the <samp class="SANS_TheSansMonoCd_W5Regular_11">PreviousMode</samp>
    value is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">UserMode</samp>
    and passed to any API that needs the <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessMode</samp>
    set.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the kernel normally enforces all access checks. [Figure 7-1](chapter7.xhtml#fig7-1)
    shows the described behavior with a user-mode application calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>
    system call.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure7-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-1: A thread’s PreviousMode
    value when calling the NtCreateMutant system call</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Even though the thread calling <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAccessCheck</samp>
    in [Figure 7-1](chapter7.xhtml#fig7-1) is executing kernel code, the thread’s
    <samp class="SANS_TheSansMonoCd_W5Regular_11">PreviousMode</samp> value reflects
    the fact that the call was started from <samp class="SANS_TheSansMonoCd_W5Regular_11">UserMode</samp>.
    Therefore, the <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessMode</samp>
    parameter specified to <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAccessCheck</samp>
    will be <samp class="SANS_TheSansMonoCd_W5Regular_11">UserMode</samp>, and the
    kernel will enforce the access check.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common way of transitioning the thread’s <samp class="SANS_TheSansMonoCd_W5Regular_11">PreviousMode</samp>
    value from <samp class="SANS_TheSansMonoCd_W5Regular_11">UserMode</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">KernelMode</samp> is for the existing
    kernel code to call a system call via its <samp class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp>
    form: for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">ZwCreateMutant</samp>.
    When such a call is made, the system call dispatch correctly identifies that the
    previous execution occurred in the kernel and sets <samp class="SANS_TheSansMonoCd_W5Regular_11">PreviousMode</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">KernelMode</samp>. [Figure 7-2](chapter7.xhtml#fig7-2)
    shows the transition of the thread’s <samp class="SANS_TheSansMonoCd_W5Regular_11">PreviousMode</samp>
    from <samp class="SANS_TheSansMonoCd_W5Regular_11">UserMode</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">KernelMode</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure7-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-2: A thread’s PreviousMode
    value being set to KernelMode after a call to ZwCreateMutant</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 7-2](chapter7.xhtml#fig7-2), the user-mode application calls a hypothetical
    kernel system call, <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSomeOtherCall</samp>,
    that internally calls <samp class="SANS_TheSansMonoCd_W5Regular_11">ZwCreateMutant</samp>.
    The code executing in the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSomeOtherCall</samp>
    function runs with the <samp class="SANS_TheSansMonoCd_W5Regular_11">PreviousMode</samp>
    value set to <samp class="SANS_TheSansMonoCd_W5Regular_11">UserMode</samp>. However,
    once it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">ZwCreateMutant</samp>,
    the mode changes to <samp class="SANS_TheSansMonoCd_W5Regular_11">KernelMode</samp>
    for the duration of the system call. In this case, because <samp class="SANS_TheSansMonoCd_W5Regular_11">ZwCreateMutant</samp>
    would call <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAccessCheck</samp>
    to determine whether the caller had access to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object, the API would receive the <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessMode</samp>
    set to <samp class="SANS_TheSansMonoCd_W5Regular_11">KernelMode</samp>, disabling
    access checking.
  prefs: []
  type: TYPE_NORMAL
- en: This behavior could introduce a security issue if the hypothetical <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSomeOtherCall</samp>
    allowed the user-mode application to influence where the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object was created. Once the access check is disabled, it might be possible to
    create or modify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    in a location that the user would not normally be allowed to access.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Memory Pointer Checking</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The access-mode parameter has a second purpose: when <samp class="SANS_TheSansMonoCd_W5Regular_11">UserMode</samp>
    is specified, the kernel will check any pointers passed as parameters to a kernel
    API to ensure that they do not point to kernel memory locations. This is an important
    security restriction; it prevents an application in user mode from forcing a kernel
    API to read or write to kernel memory it should not have access to.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifying <samp class="SANS_TheSansMonoCd_W5Regular_11">KernelMode</samp>
    disables these pointer checks at the same time as it disables the access checking.
    This mixing of behavior can introduce security issues: a kernel-mode driver might
    want to disable only pointer checking but inadvertently disable access checking
    as well.'
  prefs: []
  type: TYPE_NORMAL
- en: How a caller can indicate these different uses of the access-mode parameter
    depends on the kernel APIs being used. For example, you can sometimes specify
    two <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessMode</samp> values, one
    for the pointer checking and one for the access checking. A more common method
    is to specify a flag to the call; for example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">OBJECT_ATTRIBUTES</samp>
    structure passed to system calls has a flag called <samp class="SANS_TheSansMonoCd_W5Regular_11">ForceAccessCheck</samp>
    that disables pointer checking but leaves access checking enabled.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re analyzing a kernel driver, it’s worth paying attention to the use
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp> APIs in which the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ForceAccessCheck</samp> flag is not set.
    If a non-administrator user can control the target object manager path for the
    call, then there’s likely to be a security vulnerability. For example, CVE-2020-17136
    is a vulnerability in a kernel driver responsible for implementing the Microsoft
    OneDrive remote filesystem. The issue occurred because the API that the driver
    exposed to the Explorer shell did not set the <samp class="SANS_TheSansMonoCd_W5Regular_11">ForceAccessCheck</samp>
    flag when creating a cloud-based file. Because of that, a user calling the APIs
    in the kernel driver could create an arbitrary file anywhere they wanted on the
    filesystem, allowing them to gain administrator privileges.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">User-Mode Access
    Checks</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To support user-mode applications, the kernel exposes its access check implementation
    through the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAccessCheck</samp>
    system call. This system call uses the same access check algorithm as the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SeAccessCheck</samp> API; however, it’s
    tailored to the unique behavior of user-mode callers. The parameters for the system
    call are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security descriptor    **The security descriptor to use for the check; must
    contain owner and group SIDs'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client token    **A handle to an impersonation token for the caller'
  prefs: []
  type: TYPE_NORMAL
- en: '**Desired access    **An access mask for the access requested by the caller'
  prefs: []
  type: TYPE_NORMAL
- en: '**Generic mapping    **The type-specific generic mapping'
  prefs: []
  type: TYPE_NORMAL
- en: 'The API returns four values:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Granted access    **An access mask for the access the user was granted'
  prefs: []
  type: TYPE_NORMAL
- en: '**Access status code    **An NT status code indicating the result of the access
    check'
  prefs: []
  type: TYPE_NORMAL
- en: '**Privileges    **Any privileges used during the access check'
  prefs: []
  type: TYPE_NORMAL
- en: '**NT success code    **A separate NT status code indicating the status of the
    system call'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll notice that some of the parameters present in the kernel API are missing
    here. For example, there is no reason to specify the access mode, as it will always
    be set to the caller’s mode (<samp class="SANS_TheSansMonoCd_W5Regular_11">UserMode</samp>,
    for a user-mode caller). Also, the caller’s identity is now a handle to an impersonation
    token rather than a subject context. This handle must have <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp>
    access to be used for the access check. If you want to perform the access check
    against a primary token, you’ll need to duplicate that token to an impersonation
    token first.
  prefs: []
  type: TYPE_NORMAL
- en: Another difference is that the impersonation token used in user mode can be
    as low as Identification level. The reason for this disparity is that the system
    call is designed for user services that want to check a caller’s permissions,
    and it’s possible that the caller will have granted access to an Identification-level
    token; this condition must be accounted for.
  prefs: []
  type: TYPE_NORMAL
- en: The system call also returns an additional NT status code instead of the Boolean
    value returned by the kernel API. The return value indicates whether there was
    a problem with the parameters passed to the system call. For example, if the security
    descriptor doesn’t have both the owner and group SIDs set, the system call will
    return <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_INVALID_SECURITY_DESCR</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Get-NtGrantedAccess
    PowerShell Command</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAccessCheck</samp>
    system call to determine the caller’s granted access based on a security descriptor
    and an access token. The PowerShell module wraps the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAccessCheck</samp>
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp>
    command, as shown in [Listing 7-1](chapter7.xhtml#Lis7-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-1: Determining the caller’s granted access'
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating the default security descriptor using the <samp class="SANS_TheSansMonoCd_W5Regular_11">EffectiveToken</samp>
    parameter ❶, and we confirm that it is correct by formatting it. In simplistic
    terms, the system call will check this security descriptor’s DACL for an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Allowed</samp> ACE that matches one of
    the token’s SIDs; if such an ACE exists, it will grant the access mask. As the
    first ACE in the DACL grants the current user SID <samp class="SANS_TheSansMonoCd_W5Regular_11">Full
    Access</samp>, we’d expect the result of the check to also grant <samp class="SANS_TheSansMonoCd_W5Regular_11">Full
    Access</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: We then call <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp>,
    passing it the security descriptor ❷. We don’t specify an explicit token, so it
    uses the current effective token. We also do not specify an access mask, which
    means that the command checks <samp class="SANS_TheSansMonoCd_W5Regular_11">MaximumAllowed</samp>
    access, converting the result to a string. It returns <samp class="SANS_TheSansMonoCd_W5Regular_11">Full
    Access</samp>, as we expected based on the DACL.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we test the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp>
    command when supplied an explicit access mask using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Access</samp>
    parameter ❸. The command will work out the access mask enumeration for the security
    descriptor’s type to allow us to specify type-specific values. We requested to
    check for <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState</samp>, so
    we receive only that access. For example, if we were opening a handle to a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> object, then the handle’s
    access mask would grant only <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to test an access denied case, we remove all the ACEs from the DACL
    ❹. If there is no <samp class="SANS_TheSansMonoCd_W5Regular_11">Allowed</samp>
    ACE, then no access should be granted. But when we run <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp>
    again, we get a surprise: we were granted <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp> access instead
    of nothing ❺. To understand why we received these access levels, we need to dig
    into the internals of the access check process. We’ll do so in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Access Check Process in PowerShell</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The access check process in Windows has changed substantially since the first
    version of Windows NT. This evolution has resulted in a complex set of algorithms
    that calculate what access a user is granted based on the combination of the security
    descriptor and the token. The flowchart in [Figure 7-3](chapter7.xhtml#fig7-3)
    shows the major components of the access check process.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure7-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-3: The access check
    process</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to combine the token, the security descriptor, and the desired
    access mask. The access check process then uses this information in the following
    three main checks to determine whether access should be granted or denied:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mandatory access check    **Denies access to resources when the token does
    not meet a set policy'
  prefs: []
  type: TYPE_NORMAL
- en: '**Token access check    **Grants access based on the token’s owner and privileges'
  prefs: []
  type: TYPE_NORMAL
- en: '**Discretionary access check    **Grants or denies access based on the DACL'
  prefs: []
  type: TYPE_NORMAL
- en: To explore these steps in more detail, let’s write a basic implementation of
    the access check process in PowerShell. This PowerShell implementation won’t replace
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp> command,
    as, for simplicity, it won’t check for maximum allowed access and might not include
    newer features. Even so, having an implementation that you can analyze and debug
    can help you gain a greater understanding of the overall process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the access check is quite complex; therefore, we’ll build
    it in stages. You can access the full implementation in the *chapter7_access_check_impl.psm1*
    script included with the book’s example code. To use the script, import it as
    a module with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining the Access
    Check Function</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The module exports a single top-level function to perform the access check,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-PSGrantedAccess</samp>, shown
    in [Listing 7-2](chapter7.xhtml#Lis7-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-2: The top-level access check function'
  prefs: []
  type: TYPE_NORMAL
- en: 'The function accepts the four parameters we defined earlier in the chapter:
    a token, the security descriptor, the type’s generic mapping, and the desired
    access. If the caller doesn’t specify a token, we’ll use their effective token
    for the rest of the access check.'
  prefs: []
  type: TYPE_NORMAL
- en: The first task the function tackles is building a context that represents the
    current state of the access check process ❶. The most important property used
    here is <samp class="SANS_TheSansMonoCd_W5Regular_11">RemainingAccess</samp>.
    We initially set this property to the <samp class="SANS_TheSansMonoCd_W5Regular_11">DesiredAccess</samp>
    parameter, then remove bits from the property as they’re granted during the access
    check process.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the function follows the flowchart in [Figure 7-3](chapter7.xhtml#fig7-3).
    First it performs the mandatory access check ❷. We’ll describe what this check
    does in the next section. If the check fails, then the function completes with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_ACCESS_DENIED</samp>. To
    simplify the code, the full script defines a helper function, <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AccessResult</samp>,
    to build the result of the access check. [Listing 7-3](chapter7.xhtml#Lis7-3)
    shows this function definition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-3: Implementing the Get-AccessResult helper function'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the token access check updates the <samp class="SANS_TheSansMonoCd_W5Regular_11">RemainingAccess</samp>
    property in the context ❸. If <samp class="SANS_TheSansMonoCd_W5Regular_11">RemainingAccess</samp>
    becomes empty, then we can conclude we’ve been granted all access rights and can
    return <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_SUCCESS</samp> ❹.
    If it’s not empty, we make a second check: if the caller requested <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp>
    and the token didn’t grant that right, this check fails ❺.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we perform the discretionary access check. As with the token access
    check, we check the <samp class="SANS_TheSansMonoCd_W5Regular_11">RemainingAccess</samp>
    property: if it’s empty, the caller has received all the accesses they’ve requested
    ❻; otherwise, they’ve been denied access ❼. With that overview in mind, let’s
    delve into the details of each check in turn.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Performing the Mandatory
    Access Check</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Windows Vista introduced a feature called *Mandatory Integrity Control (MIC)*
    that uses the token’s integrity level and the mandatory label ACE to control resource
    access based on a general policy. MIC is a type of mandatory access check (MAC).
    The key behavior of a MAC is that it cannot grant access to a resource; it can
    only deny access. If the caller requests more access than the policy permits,
    the access check will immediately deny access, and if the MAC denies access, the
    DACL will never be checked. Because there is no way for a non-privileged user
    to circumvent the check, it’s considered mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: In the latest versions of Windows, the access check process performs two additional
    mandatory checks along with MIC. These checks implement similar behavior, so we’ll
    group them together. [Listing 7-4](chapter7.xhtml#Lis7-4) defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-MandatoryAccess</samp>
    function we called in [Listing 7-2](chapter7.xhtml#Lis7-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-4: Implementing the Test-MandatoryAccess function'
  prefs: []
  type: TYPE_NORMAL
- en: 'This function performs three checks: <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-ProcessTrustLevel</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-AccessFilter</samp>, and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Test-MandatoryIntegrityLevel</samp>. If
    any of these checks fails, then the entire access check process fails, returning
    <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_ACCESS_DENIED</samp>. Let’s
    detail each check in turn.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Process Trust Level Check</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Windows Vista introduced *protected processes*, which are processes that even
    an administrator can’t manipulate and compromise. The original purpose of protected
    processes was to protect media content. However, Microsoft has since expanded
    them to cover a range of uses, such as protecting antivirus services and virtual
    machines.
  prefs: []
  type: TYPE_NORMAL
- en: A token can be assigned a *process trust level SID*. This SID depends on the
    protection level of a protected process and is assigned when such a process is
    created. To restrict access to a resource, the access check process determines
    whether the token’s SID is equally or more trusted than a trust level SID in the
    security descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: When one SID is considered equally or more trusted than another, it’s said to
    *dominate*. To check whether one process trust level SID dominates another, you
    can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlSidDominatesForTrust</samp>
    API or the <samp class="SANS_TheSansMonoCd_W5Regular_11">Compare-NtSid</samp>
    command with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Dominates</samp>
    parameter. [Listing 7-5](chapter7.xhtml#Lis7-5) translates the algorithm for checking
    the process trust level, which is stored in a process trust label ACE, into PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-5: The process trust level check algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: To check the process trust level, we need to query the SID for the current token
    ❶. If the token does not have a trust level SID, then we define the lowest possible
    SID. Next, we initialize an access mask to all bits set ❷.
  prefs: []
  type: TYPE_NORMAL
- en: We then enumerate the values in the SACL, checking any process trust label ACE
    other than <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp> ❸.
    When we find a relevant ACE, we compare its SID to the SID queried for the token
    ❹. If the ACE SID dominates, then the token has a lower protection level, and
    the access mask is set to the value from the ACE.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we compare the access mask to the remaining access the caller requested
    ❺. If all the bits in the access mask are present in the remaining access, then
    the function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>,
    which indicates that the process trust level check succeeded. Note that the check
    always adds <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp>,
    regardless of the mask in the ACE.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s test the behavior of the process trust label ACE. Rather than create a
    new protected process, we’ll use the process trust level SID of the anonymous
    user’s token for the access check. To simplify testing, we’ll define a helper
    function that we can reuse. This function in [Listing 7-6](chapter7.xhtml#Lis7-6)
    will create a default security descriptor that grants access to both the current
    user and the anonymous user. Whenever we need a security descriptor for a test,
    we can call this function and use the returned value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-6: Defining a helper function for testing'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">New-BaseSD</samp> function
    creates a basic security descriptor with the owner and group set to the *SYSTEM*
    user. It then adds an <samp class="SANS_TheSansMonoCd_W5Regular_11">Allowed</samp>
    ACE for the anonymous and current user SIDs, granting them full access. It also
    sets the mandatory label to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Untrusted</samp>
    integrity level (you’ll learn why the integrity level is important in “The Mandatory
    Integrity Level Check” on page 235). Finally, it maps any generic access to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> type-specific access. Let’s
    now test the process trust label, as shown in [Listing 7-7](chapter7.xhtml#Lis7-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-7: Testing the process trust label ACE'
  prefs: []
  type: TYPE_NORMAL
- en: First, we create our base security descriptor and add a process trust label,
    granting <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState</samp> access
    only to tokens whose process trust level does not dominate the process trust label
    ❶. When we run the access check, we see that the effective token, which doesn’t
    have any process trust level, gets <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState</samp>
    access only ❷, indicating that the process trust label is being enforced.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we get a handle to an anonymous user’s token using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>,
    query its process trust level SID, and compare it to the SID we added to the security
    descriptor ❸. The call to <samp class="SANS_TheSansMonoCd_W5Regular_11">Compare-NtSid</samp>
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> ❹, which indicates
    the token’s process trust level SID dominates the one in the security descriptor.
    To confirm this, we run the access check and find that the anonymous user’s token
    is granted <samp class="SANS_TheSansMonoCd_W5Regular_11">Full Access</samp> ❺,
    which means the process trust label did not limit its access.
  prefs: []
  type: TYPE_NORMAL
- en: You might wonder whether you could impersonate the anonymous token to bypass
    the process trust label. Remember that in user mode we’re calling <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAccessCheck</samp>,
    which takes only a single <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    handle, but that the kernel’s <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAccessCheck</samp>
    takes both a primary token and an impersonation token. Before the kernel verifies
    the process trust label, it checks both tokens and chooses the one with the lower
    trust level. Therefore, if the impersonation token is trusted but your primary
    token is untrusted, the effective trust level will be untrusted.
  prefs: []
  type: TYPE_NORMAL
- en: Windows applies a secondary security check when assigning the process trust
    label ACE to a resource. While you need only <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp>
    access to set the process trust label, you cannot change or remove the ACE if
    your effective trust level does not dominate the label’s trust level. This prevents
    you from setting a new, arbitrary process trust label ACE. Microsoft uses this
    ability to check certain files related to Windows applications for modifications
    and verify that the files were created by a protected process.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Access Filter ACE</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The second mandatory access check is the access filter ACE. It works in a similar
    manner to the process trust label ACE, except that instead of using a process
    trust level to determine whether to apply a restricting access mask, it uses a
    conditional expression that evaluates to either <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. If the conditional
    evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>, the ACE’s
    access mask limits the maximum granted access for the access check; if it evaluates
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>, the access filter
    is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: You can have multiple access filter ACEs in the SACL. Every conditional expression
    that evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> removes
    more of the access mask. Therefore, if you match one ACE but don’t match a second
    ACE that restricts to <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp>,
    you’ll get a maximum access of <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp>.
    We can express this logic in a PowerShell function, as shown in [Listing 7-8](chapter7.xhtml#Lis7-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-8: The access filter check algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm resembles the one we implemented to check the process trust level.
    The only difference is that we check a conditional expression rather than the
    SID ❶. The function supports multiple access filter ACEs; for each matching ACE,
    the access mask is bitwise ANDed with the final access mask, which starts with
    all access mask bits set ❷. As the masks are ANDed, each ACE can only remove access,
    not add it. Once we’ve checked all the ACEs, we check the remaining access to
    determine whether the check succeeded or failed ❸.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 7-9](chapter7.xhtml#Lis7-9), we check the behavior of the access
    filter algorithm to ensure it works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-9: Testing the access filter ACE'
  prefs: []
  type: TYPE_NORMAL
- en: We add the access filter ACE to the security descriptor with the conditional
    expression <samp class="SANS_TheSansMonoCd_W7Bold_B_11">"</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">Exists
    TSA://ProcUnique</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">"</samp> ❶.
    The expression checks whether the <samp class="SANS_TheSansMonoCd_W5Regular_11">TSA://ProcUnique</samp>
    security attribute is present in the token. For a normal user, this check should
    always return <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>; however,
    the attribute doesn’t exist in the anonymous user’s token. We set the mask to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState</samp> and the SID to
    the *Everyone* group. Note that the SID isn’t verified, so it can have any value,
    but using the *Everyone* group is conventional.
  prefs: []
  type: TYPE_NORMAL
- en: We can check the current effective token’s security attributes using <samp class="SANS_TheSansMonoCd_W5Regular_11">Show-NtTokenEffective</samp>
    ❷. Getting the maximum access for the effective token results in <samp class="SANS_TheSansMonoCd_W5Regular_11">Full
    Access</samp> ❸, meaning the access filter check passes without restricting access.
    However, when we repeat this using the anonymous user’s token, the access filter
    check fails and the access is restricted to <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState</samp>
    only ❹.
  prefs: []
  type: TYPE_NORMAL
- en: To set an access filter, you need only <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp>
    access. So, what’s to prevent a user removing the filter? Obviously, the access
    filter shouldn’t grant <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp>
    access in the first place, but if it does, you can limit any changes to a protected
    process trust level. To do this, set the ACE SID to a process trust level SID,
    and set the <samp class="SANS_TheSansMonoCd_W5Regular_11">TrustProtected</samp>
    ACE flag. Now a caller with a lower process trust level won’t be able to remove
    or modify the access filter ACE.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Mandatory Integrity Level
    Check</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Finally, we’ll implement the mandatory integrity level check. In the SACL, a
    mandatory label ACE’s SID represents the security descriptor’s integrity level.
    Its mask, which expresses the mandatory policy, combines the <samp class="SANS_TheSansMonoCd_W5Regular_11">NoReadUp</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NoWriteUp</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">NoExecuteUp</samp>
    policies to determine the maximum access the system can grant the caller based
    on the <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GenericWrite</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericExecute</samp>
    values from the generic mapping structure.
  prefs: []
  type: TYPE_NORMAL
- en: To determine whether to enforce the policy, the check compares the integrity
    level SIDs of the security descriptor and token. If the token’s SID dominates
    the security descriptor’s, then no policy is enforced and any access is permitted.
    However, if the token’s SID doesn’t dominate, then any access requested outside
    of the value for the policy causes the access check to fail with <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_ACCESS_DENIED</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating whether one integrity level SID dominates another is much simpler
    than calculating the equivalent value for the process trust level SID. To do so,
    we extract the last RID from each SID and compare these as numbers. If one integrity
    level SID’s RID is greater than or equal to the other, it dominates.
  prefs: []
  type: TYPE_NORMAL
- en: However, calculating the access mask for the policy based on the generic mapping
    is much more involved, as it requires a consideration of shared access rights.
    We won’t implement the code for calculating the access mask, as we can use an
    option on <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtAccessMask</samp>
    to calculate it for us.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 7-10](chapter7.xhtml#Lis7-10), we implement the mandatory integrity
    level check.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-10: The mandatory integrity level check algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: We start by checking the token’s mandatory policy ❶. In this case, we check
    whether the <samp class="SANS_TheSansMonoCd_W5Regular_11">NoWriteUp</samp> flag
    is set. If the flag is not set, then we disable integrity level checking for this
    token and return <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>. This
    flag is rarely turned off, however, and it requires <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>
    to disable, so in almost all cases the integrity level check will continue.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to capture the security descriptor’s integrity level and mandatory
    policy from the mandatory label ACE. If the ACE exists, we extract these values
    and map the policy to the maximum access mask using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtAccessMask</samp>
    ❷. If the ACE doesn’t exist, the algorithm uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>
    integrity level and a <samp class="SANS_TheSansMonoCd_W5Regular_11">NoWriteUp</samp>
    policy by default ❸.
  prefs: []
  type: TYPE_NORMAL
- en: If the token has the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRelabelPrivilege</samp>
    privilege, we add the <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp>
    access back to the maximum access, even if the policy removed it ❹. This allows
    a caller with <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRelabelPrivilege</samp>
    enabled to change the security descriptor’s mandatory integrity label ACE.
  prefs: []
  type: TYPE_NORMAL
- en: We then query the token’s integrity level SID and compare it to the security
    descriptor’s ❺. If the token’s SID dominates, then the check passes and allows
    any access. Otherwise, the calculated policy access mask must grant the entirety
    of the remaining access mask requested. Note that we don’t treat <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp>
    differently here, as we did in the process trust level and access filter checks.
    We remove it if the policy contains <samp class="SANS_TheSansMonoCd_W5Regular_11">NoWriteUp</samp>,
    the default for all resource types.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s verify the behavior of the mandatory integrity level check in the real
    access check process ([Listing 7-11](chapter7.xhtml#Lis7-11)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-11: Testing the mandatory label ACE'
  prefs: []
  type: TYPE_NORMAL
- en: We first create a security descriptor and check its mandatory integrity label.
    We can see that it’s set to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Untrusted</samp>
    integrity level, which is the lowest level, and that its policy is <samp class="SANS_TheSansMonoCd_W5Regular_11">NoWriteUp</samp>
    ❶. We then get the maximum access for the anonymous user’s token, which we can
    see has an integrity level of <samp class="SANS_TheSansMonoCd_W5Regular_11">Untrusted</samp>
    ❷. As this integrity level matches the security descriptor’s integrity level,
    the token is allowed full access.
  prefs: []
  type: TYPE_NORMAL
- en: To test access mask restrictions, we remove the mandatory label ACE from the
    security descriptor so that the access check will default to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>
    integrity level ❸. Running the check again, we now get <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState|ReadControl|Synchronize</samp>
    ❹, which is the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> object’s
    full access without the <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericWrite</samp>
    access mask.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the implementation of the mandatory access check. We’ve seen
    that this algorithm is really composed of three separate checks for the process
    trust level, the access filter, and the integrity level. Each check can only deny
    access; it never grants additional access.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Performing the Token
    Access Check</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The second main check, the token access check, uses properties of the caller’s
    token to determine whether to grant certain access rights. More specifically,
    it checks for any special privileges, as well as for the owner of the security
    descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the mandatory access check, the token access check can grant access to
    a resource if it has removed all bits from the token’s access mask. [Listing 7-12](chapter7.xhtml#Lis7-12)
    implements the top-level <samp class="SANS_TheSansMonoCd_W5Regular_11">Result-TokenAccess</samp>
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-12: The token access check algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: The check is simple. First we check the token’s privileges using a function
    we’ll define next, <samp class="SANS_TheSansMonoCd_W5Regular_11">Resolve-TokenPrivilegeAccess</samp>,
    passing it the current context. If certain privileges are enabled, this function
    modifies the token’s remaining access; if the remaining access is empty, meaning
    no access remains to be granted, we can return immediately. We then call <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Resolve-TokenOwnerAccess</samp>, which
    checks whether the token owns the resource and can also update <samp class="SANS_TheSansMonoCd_W5Regular_11">RemainingAccess</samp>.
    Let’s dig into these individual checks.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Privilege Check</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The *privilege check* ([Listing 7-13](chapter7.xhtml#Lis7-13)) determines whether
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object has three
    different privileges enabled. For each one, if the privilege is enabled we grant
    an access mask and the bits from the remaining access.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-13: The token privilege access check algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: First, we check whether the caller has requested <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp>;
    if so, and if <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSecurityPrivilege</samp>
    is enabled, we remove <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp>
    from the remaining access ❶. We also update the list of privileges we’ve used
    so that we can return it to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we perform similar checks for <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTakeOwnershipPrivilege</samp>
    ❷ and <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRelabelPrivilege</samp>
    ❸ and remove <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp> from
    the remaining access if they’re enabled. Lastly, we update the <samp class="SANS_TheSansMonoCd_W5Regular_11">RemainingAccess</samp>
    value with the final access mask ❹.
  prefs: []
  type: TYPE_NORMAL
- en: Granting <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp> access
    to both <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTakeOwnershipPrivilege</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRelabelPrivilege</samp> makes
    sense from the kernel’s perspective, as you need <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp>
    access to modify the owner SID and integrity level. However, this implementation
    also means that a token with only <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRelabelPrivilege</samp>
    can take ownership of the resource, which we might not always intend. Fortunately,
    even administrators don’t get <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRelabelPrivilege</samp>
    by default, making this a minor issue.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s check this function against the real access check process. Run the script
    in [Listing 7-14](chapter7.xhtml#Lis7-14) as an administrator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-14: Testing the token privilege check'
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating a security descriptor that should grant no access to the
    current user ❶. We then enable <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTakeOwnershipPrivilege</samp>
    ❷. Next, we request an access check for <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp>
    access and specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">PassResult</samp>
    parameter, which outputs the full access check result ❸. The result shows that
    the access check succeeded, granting <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp>
    access, but also that the check used the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTakeOwnershipPrivilege</samp>
    ❹. To verify that we weren’t granted <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp>
    access for another reason, we disable the privilege ❺ and rerun the check. This
    time, it denies us access ❻.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Owner Check</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The *owner check* exists to grant <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp> access to the
    owner of the resource, even if the DACL doesn’t grant that owner any other access.
    The purpose of this check is to prevent a user from locking themselves out of
    their own resources. If they accidentally change the DACL so that they no longer
    have access, they can still use <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp>
    access to return the DACL to its previous state.
  prefs: []
  type: TYPE_NORMAL
- en: The check compares the owner SID in the security descriptor with all enabled
    token groups (not just the token owner), granting access if a match is found.
    We demonstrated this behavior at the start of this chapter, in [Listing 7-1](chapter7.xhtml#Lis7-1).
    In [Listing 7-15](chapter7.xhtml#Lis7-15), we implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">Resolve-TokenOwnerAccess</samp>
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-15: The token owner access check algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: We use <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-NtTokenGroup</samp>
    to check whether the security descriptor’s owner SID is an enabled member of the
    token ❶. If the owner SID is not a member, we simply return. If it is a member,
    the code then needs to check whether there are any *OWNER RIGHTS* SIDs (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">S-1-3-4</samp>) in the DACL ❷. If there
    are, then we don’t follow the default process; instead, we rely on the DACL check
    to grant access to the owner. Finally, if both checks pass, we can remove <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp>
    from the remaining access ❸.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 7-16](chapter7.xhtml#Lis7-16), we verify this behavior in the real
    access check process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-16: Testing the token owner check'
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating a security descriptor with the owner and group set to *Everyone*
    ❶. We also create a security descriptor with an empty DACL, which means the access
    check process will consider only the owner check when calculating the granted
    access. When we run the access check, we get <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp> ❷.
  prefs: []
  type: TYPE_NORMAL
- en: We then add a single ACE with the *OWNER RIGHTS* SID ❸. This disables the default
    owner access and causes the access check to grant only the access specified in
    the ACE (in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState</samp>).
    When we run the access check again, we now find that the only granted access is
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState</samp> ❹ and that we
    no longer have <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp> access.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the token access check. As we demonstrated, the algorithm can
    grant certain access rights to a caller before any significant processing of the
    security descriptor takes place. This is primarily to allow users to maintain
    access to their own resources and for administrators to take ownership of other
    users’ files. Now let’s continue to the final check.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Performing the Discretionary
    Access Check</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ve relied on the behavior of the DACL for a few of our tests. Now we’ll explore
    exactly how the DACL check works. Checking the DACL may seem simple, but the devil
    is in the details. [Listing 7-17](chapter7.xhtml#Lis7-17) implements the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-17: The discretionary access check algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: We begin by checking whether the DACL is present; if it is, we check whether
    it’s a NULL ACL ❶. If there is no DACL or only a NULL ACL, there is no security
    to enforce, so the function clears the remaining access and returns, granting
    the token any access to the resource that the mandatory access check hasn’t restricted.
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve confirmed that there is a DACL to check, we can enumerate each of
    its ACEs ❷. If an ACE is <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp>,
    it won’t take part in the check, so we ignore it ❸. Next, we need to map the SID
    in the ACE to the SID we’re checking using a helper function we’ll define next,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AceSid</samp> ❹. This function
    converts the *OWNER RIGHTS* SID for the ACE to the current security descriptor’s
    owner, as shown in [Listing 7-18](chapter7.xhtml#Lis7-18).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-18: The implementation of Get-AceSid'
  prefs: []
  type: TYPE_NORMAL
- en: With the SID in hand, we can now evaluate each ACE based on its type. For the
    simplest type, <samp class="SANS_TheSansMonoCd_W5Regular_11">Allowed</samp>, we
    check whether the SID is in the token’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Enabled</samp>
    groups. If so, we grant the access represented by the ACE’s mask and can remove
    those bits from the remaining access ❺.
  prefs: []
  type: TYPE_NORMAL
- en: For the <samp class="SANS_TheSansMonoCd_W5Regular_11">Denied</samp> type, we
    also check whether the SID is in the token’s groups; however, this check must
    include both <samp class="SANS_TheSansMonoCd_W5Regular_11">Enabled</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DenyOnly</samp> groups, so we pass
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">DenyOnly</samp> parameter ❻.
    Note that it’s possible to configure the token’s user SID as a <samp class="SANS_TheSansMonoCd_W5Regular_11">DenyOnly</samp>
    group as well, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-NtTokenGroup</samp>
    takes this into account. A <samp class="SANS_TheSansMonoCd_W5Regular_11">Denied</samp>
    ACE doesn’t modify the remaining access; instead, the function compares the mask
    against the current remaining access, and if any bit of remaining access is also
    set in the mask, then the function denies that access and immediately returns
    the remaining access.
  prefs: []
  type: TYPE_NORMAL
- en: The final two ACE types we cover are variations on the <samp class="SANS_TheSansMonoCd_W5Regular_11">Allowed</samp>
    type. The first, <samp class="SANS_TheSansMonoCd_W5Regular_11">AllowedCompound</samp>,
    contains the additional server SID. To perform this check, the function compares
    both the normal SID and the server SID with the caller token’s groups, as these
    values might be different ❼. (Note that the server SID should be mapped to the
    owner if the *OWNER RIGHTS* SID is used.) The ACE condition is met only if both
    SIDs are enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we check the <samp class="SANS_TheSansMonoCd_W5Regular_11">AllowedCallback</samp>
    ACE type. To do so, we again check the SID, as well as whether a conditional expression
    matches the token using <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-NtAceCondition</samp>
    ❽. If the expression returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>,
    the ACE condition is met, and we remove the mask from the remaining access. To
    fully implement the conditional check, we also need to pass in any resource attributes
    from the security descriptor (I’ll describe resource attributes in more detail
    in “The Central Access Policy” on page 255). Notice that we’re intentionally not
    checking <samp class="SANS_TheSansMonoCd_W5Regular_11">DenyCallback</samp>. This
    is because the kernel does not support <samp class="SANS_TheSansMonoCd_W5Regular_11">DenyCallback</samp>
    ACEs, although the user mode–only <samp class="SANS_TheSansMonoCd_W5Regular_11">AuthzAccessCheck</samp>
    API does.
  prefs: []
  type: TYPE_NORMAL
- en: After we’ve processed the ACE, we check the remaining access ❾. If the remaining
    access is empty, we’ve been granted the entire requested access and can stop processing
    ACEs. This is why we have a canonical ACL ordering, as discussed in [Chapter 5](chapter5.xhtml);
    if <samp class="SANS_TheSansMonoCd_W5Regular_11">Denied</samp> ACEs were placed
    after <samp class="SANS_TheSansMonoCd_W5Regular_11">Allowed</samp> ACEs, the remaining
    access could become empty, and the loop might exit before ever checking a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Denied</samp> ACE.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, this function sets the <samp class="SANS_TheSansMonoCd_W5Regular_11">RemainingAccess</samp>
    ❿. If the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">RemainingAccess</samp>
    is non-empty, the access check fails with <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_ACCESS_DENIED</samp>.
    Therefore, an empty DACL blocks all access; if there are no ACEs, the <samp class="SANS_TheSansMonoCd_W5Regular_11">RemainingAccess</samp>
    never changes, so it won’t be empty at the end of the function.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now covered all three access checks, and you should have a better understanding
    of their structure. However, there is more to the access check process. In the
    next section, we’ll discuss how this process supports the implementation of sandboxes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Sandboxing</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [Chapter 4](chapter4.xhtml), we covered two types of sandbox tokens: restricted
    and lowbox. These sandbox tokens modify the access check process by adding more
    checks. Let’s discuss each token type in more detail, starting with restricted
    tokens.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Restricted Tokens</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using a restricted token affects the access check process by introducing a second
    owner and a discretionary access check against the list of restricted SIDs. In
    [Listing 7-19](chapter7.xhtml#Lis7-19), we modify the owner SID check in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Resolve-TokenOwnerAccess</samp> function
    to account for this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-19: The modified Get-TokenOwner access check for restricted tokens'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first perform the existing SID check ❶. If the owner SID isn’t in the list
    of token groups, then we don’t grant <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp> access. Next
    is the additional check ❷: if the token is restricted, then we check the list
    of restricted SIDs for the owner SID and grant the token <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp> access only
    if the owner SID is in both the main group list and the restricted SID list.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll follow the same pattern for the discretionary access check, although for
    simplicity, we’ll add a Boolean <samp class="SANS_TheSansMonoCd_W5Regular_11">Restricted</samp>
    switch parameter to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get -DiscretionaryAccess</samp>
    function and pass it to any call to <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-NtTokenGroup</samp>.
    For example, we can modify the allowed ACE check implemented in [Listing 7-17](chapter7.xhtml#Lis7-17),
    so it looks as shown in [Listing 7-20](chapter7.xhtml#Lis7-20).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-20: The modified Allowed ACE type for restricted tokens'
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 7-20](chapter7.xhtml#Lis7-20), we set the <samp class="SANS_TheSansMonoCd_W5Regular_11">Restricted</samp>
    parameter to the value of a parameter passed into <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-DiscretionaryAccess</samp>.
    We now need to modify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get -PSGrantedAccess</samp>
    function defined in [Listing 7-2](chapter7.xhtml#Lis7-2) to call <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-DiscretionaryAccess</samp>
    twice for a restricted token ([Listing 7-21](chapter7.xhtml#Lis7-21)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-21: The Get-PSGrantedAccess function modified to account for restricted
    tokens'
  prefs: []
  type: TYPE_NORMAL
- en: We first capture the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">RemainingAccess</samp>
    value ❶, as the discretionary access check will modify it and we want to repeat
    that check a second time. We then run the discretionary access check and save
    the result in a variable ❷. If this first check succeeded and the token is restricted,
    we must perform a second check ❸. We also need to consider whether the token is
    write restricted and whether the remaining access includes write access ❹. We
    look for write access by checking the passed generic mapping. (Note that the owner
    check doesn’t perform a write check, so in theory it could grant the token <samp
    class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp> access, which is considered
    a form of write access.)
  prefs: []
  type: TYPE_NORMAL
- en: Next we run the check again, this time with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Restricted</samp>
    parameter to indicate that the restricted SIDs should be checked ❺. If this second
    check also passes, we set the <samp class="SANS_TheSansMonoCd_W5Regular_11">$success</samp>
    variable to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> and grant
    access to the resource ❻.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the restricted SID check applies to both <samp class="SANS_TheSansMonoCd_W5Regular_11">Allowed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Denied</samp> ACE types. This
    means that if the DACL contains a <samp class="SANS_TheSansMonoCd_W5Regular_11">Denied</samp>
    ACE that references a SID in the restricted SID list, the function will deny access,
    even if the SID isn’t in the normal group list.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Lowbox Tokens</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The access check process for a lowbox token resembles that for a restricted
    token. A lowbox token can contain a list of capability SIDs used to perform a
    second check, like the check we performed with the list of restricted SIDs. Likewise,
    if the access check process doesn’t grant access through both normal and capability
    checks, the access check fails. However, the lowbox token’s access check contains
    some subtle differences:'
  prefs: []
  type: TYPE_NORMAL
- en: It will consider the token’s package SID in addition to its list of capability
    SIDs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The checked capability SIDs must have the enabled attribute flag set to be considered
    active.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The check applies only to <samp class="SANS_TheSansMonoCd_W5Regular_11">Allowed</samp>
    ACE types, not to <samp class="SANS_TheSansMonoCd_W5Regular_11">Denied</samp>
    ACE types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NULL DACLs do not grant full access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition, two special package SIDs will match any token’s package SID for
    the purposes of the package SID check:'
  prefs: []
  type: TYPE_NORMAL
- en: '*ALL APPLICATION PACKAGES* (<samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-2-1</samp>)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ALL RESTRICTED APPLICATION PACKAGES* (<samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-2-2</samp>)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking for the *ALL APPLICATION PACKAGES* SID during the package SID check
    can be disabled if the token used for the access check has the <samp class="SANS_TheSansMonoCd_W5Regular_11">WIN://NOALLAPPPKG</samp>
    security attribute set to a single value of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>.
    In this case, the package SID check will only consider the *ALL RESTRICTED APPLICATION
    PACKAGES* SID. If the security attribute isn’t present or is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>,
    the access check considers both special package SIDs. Microsoft refers to processes
    with this security attribute as running a *Less Privileged AppContainer (LPAC)*.
  prefs: []
  type: TYPE_NORMAL
- en: Because setting a token’s security attribute requires the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>
    privilege, the process creation APIs have an option for adding the <samp class="SANS_TheSansMonoCd_W5Regular_11">WIN://NOALLAPPPKG</samp>
    security attribute to a new process’s token. [Listing 7-22](chapter7.xhtml#Lis7-22)
    shows a basic implementation of the lowbox access check for <samp class="SANS_TheSansMonoCd_W5Regular_11">Allowed</samp>
    ACE types. You should add this code to the discretionary access check in [Listing
    7-17](chapter7.xhtml#Lis7-17), in the locations indicated in the comments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-22: An implementation of the lowbox access check for Allowed ACEs'
  prefs: []
  type: TYPE_NORMAL
- en: The first test verifies whether the SID is in the token’s group list. If it
    finds the SID in the group list, it removes the mask from the remaining access
    check ❶. If the group test fails, we check whether it’s a package or capability
    SID. We must ensure that we’re not checking whether we’re in the restricted SID
    mode ❷, as this mode doesn’t define lowbox checks.
  prefs: []
  type: TYPE_NORMAL
- en: Our check for the capability SIDs includes the package SID and the *ALL APPLICATION
    PACKAGES* SID ❸. If we find a match, we remove the mask from the remaining access
    ❹. However, we need to maintain separate remaining access values for normal SIDs
    and AppContainer SIDs. Therefore, we create two variables, <samp class="SANS_TheSansMonoCd_W5Regular_11">$access</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">$ac_access</samp>. We initialize
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">$ac_access</samp> variable to
    the value of the original <samp class="SANS_TheSansMonoCd_W5Regular_11">DesiredAccess</samp>,
    not the current remaining access, as we won’t grant owner rights such as <samp
    class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp> unless the SID also matches
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">Allowed</samp> package or capability
    SID ACE. We also modify the loop’s exit condition to consider both remaining access
    values ❺; they must both be empty before we exit.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll add some additional checks to better isolate AppContainer processes
    from existing <samp class="SANS_TheSansMonoCd_W5Regular_11">Low</samp> integrity
    level sandboxes, such as Internet Explorer’s protected mode. The first change
    we implement affects the mandatory access check. If the check fails for a lowbox
    token, we then check the security descriptor’s integrity level a second time.
    If the integrity level is less than or equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>,
    we assume that the check succeeds. This is even though lowbox tokens have a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Low</samp> integrity level, as demonstrated
    in [Chapter 4](chapter4.xhtml), which would normally prevent write access to the
    resource. This behavior allows a more privileged application to grant a lowbox
    token access to a resource while blocking <samp class="SANS_TheSansMonoCd_W5Regular_11">Low</samp>
    integrity level sandboxes.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-23](chapter7.xhtml#Lis7-23) demonstrates this behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-23: The behavior of a mandatory access check against a lowbox token'
  prefs: []
  type: TYPE_NORMAL
- en: We start by building a security descriptor that grants <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp>
    access for the *Everyone* and *ALL APPLICATION PACKAGES* groups ❶. We also set
    an explicit integrity level of <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>
    ❷, although this isn’t necessary, as <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>
    is the default for security descriptors without a mandatory label ACE. We then
    perform an access check using a <samp class="SANS_TheSansMonoCd_W5Regular_11">Low</samp>
    integrity level token, and we receive only read access to the security descriptor
    ❸. Next, we try the access check again with a lowbox token; although the token’s
    integrity level is still <samp class="SANS_TheSansMonoCd_W5Regular_11">Low</samp>,
    the token is granted <samp class="SANS_TheSansMonoCd_W5Regular_11">Full Access</samp>
    ❹.
  prefs: []
  type: TYPE_NORMAL
- en: The second change we implement is that if the DACL contains a package SID we
    deny access to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Low</samp> integrity
    level token, regardless of the security descriptor’s integrity level or DACL.
    This mechanism blocks access to resources that are assigned the default DACL,
    as the package SID is added to the default DACL when a lowbox token is created.
    [Listing 7-24](chapter7.xhtml#Lis7-24) tests this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-24: Verifying the behavior of the package SID for Low integrity level
    tokens'
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating a lowbox token ❶. The token does not have any added capability
    SIDs, only the package SID. Next, we build a default security descriptor from
    the lowbox token ❷. When inspecting the entries in the security descriptor, we
    see that the current user SID ❸ and the package SID ❹ have been granted <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Full Access</samp>. As a lowbox token
    has <samp class="SANS_TheSansMonoCd_W5Regular_11">Low</samp> integrity level,
    the security descriptor inheritance rules require the integrity level to be added
    to the security descriptor ❺.
  prefs: []
  type: TYPE_NORMAL
- en: We then request the granted access for the security descriptor based on the
    lowbox token and receive <samp class="SANS_TheSansMonoCd_W5Regular_11">Full Access</samp>
    ❻. Next, we create a duplicate of the current token but set its integrity level
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">Low</samp>. We now get a granted
    access of <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> ❼, even though
    we expected to receive <samp class="SANS_TheSansMonoCd_W5Regular_11">Full Access</samp>
    based on the integrity level ACE in the security descriptor. In this case, the
    presence of the package SID in the security descriptor blocked access.
  prefs: []
  type: TYPE_NORMAL
- en: 'One final thing to note: as the sandbox access checks are orthogonal, it’s
    possible to create a lowbox token from a restricted token, causing both lowbox
    checks and restricted SID checks to occur. The resulting access is the most restrictive
    of all, making for a stronger sandbox primitive.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Enterprise Access Checks</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Enterprise deployments of Windows often perform some additional access checks.
    You won’t typically need these checks on stand-alone installations of Windows,
    but you should still understand how they modify the access check process if present.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Object Type Access
    Check</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For simplicity’s sake, one thing I intentionally removed from the discretionary
    access check algorithm was the handling of object ACEs. To support object ACEs,
    you must use a different access check API: either <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAccessCheckByType</samp>
    in kernel mode or the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAccessCheckByType</samp>
    system call. These APIs introduce two additional parameters to the access check
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Principal  </samp>A SID used to
    replace the *SELF* SID in ACEs
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ObjectTypes  </samp>A list of GUIDs
    that are valid for the check
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">Principal</samp> is easy
    to define: when we’re processing the DACL and we encounter an ACE’s SID that’s
    set to the *SELF* SID (<samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-10</samp>),
    we replace the SID with a value from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Principal</samp>
    parameter. (Microsoft introduced the *SELF* SID for use in Active Directory; we’ll
    discuss its purpose in more detail in [Chapter 11](chapter11.xhtml).) [Listing
    7-25](chapter7.xhtml#Lis7-25) shows an adjusted version of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AceSid</samp>
    function that takes this into account. You’ll also have to modify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-PSGrantedAccess</samp>
    function to receive the <samp class="SANS_TheSansMonoCd_W5Regular_11">Principal</samp>
    parameter by adding it to the <samp class="SANS_TheSansMonoCd_W5Regular_11">$Context</samp>
    value.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-25: Adding the principal SID to the Get-AceSid function'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-26](chapter7.xhtml#Lis7-26) tests the behavior of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Principal</samp>
    SID.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-26: Testing the Principal SID replacement'
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating a security descriptor with the owner and group set to the
    *SYSTEM* user SID and a single <samp class="SANS_TheSansMonoCd_W5Regular_11">Allowed</samp>
    ACE that grants the *SELF* SID <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp>
    access ❶. Based on the access-checking rules, this should not grant the user any
    access to the resource. We can confirm that this is the case with a call to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp> ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we get the effective token’s user SID and pass it in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Principal</samp>
    parameter to <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp>
    ❸. The DACL check will then replace the *SELF* SID with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Principal</samp>
    SID, which matches the current user and therefore grants <samp class="SANS_TheSansMonoCd_W5Regular_11">Full
    Access</samp>. This check replaces SIDs in the DACL and SACL only; setting *SELF*
    as the owner SID won’t grant any access.
  prefs: []
  type: TYPE_NORMAL
- en: The other parameter, <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectTypes</samp>,
    is much trickier to implement. It provides a list of GUIDs that are valid for
    the access check process. Each GUID represents the type of an object to be accessed;
    for example, you might have a GUID associated with a computer object and a different
    one for a user object.
  prefs: []
  type: TYPE_NORMAL
- en: Each GUID also has an associated level, turning the list into a hierarchical
    tree. Each node maintains its own remaining access, which it initializes to the
    main <samp class="SANS_TheSansMonoCd_W5Regular_11">RemainingAccess</samp> value.
    Active Directory uses this hierarchy to implement a concept of properties and
    property sets, as shown in [Figure 7-4](chapter7.xhtml#fig7-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure7-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-4: Active Directory–style
    properties</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Each node in [Figure 7-4](chapter7.xhtml#fig7-4) shows the name we’ve given
    it, a portion of the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp>
    GUID, and the current <samp class="SANS_TheSansMonoCd_W5Regular_11">RemainingAccess</samp>
    value (in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp>).
    Level 0 corresponds to the top-level object, of which there can be only one in
    the list. At level 1 are the property sets, here numbered 1 and 2\. Below each
    property set, at level 2, are the individual properties.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the object types in a hierarchy enables us to configure a security
    descriptor to grant access to multiple properties using a single ACE by setting
    the access on the property set. If we grant a property set some access, we also
    grant that access to all properties contained in that set. Conversely, if we deny
    access to a single property, the deny status will propagate up the tree and deny
    access to the entire property set and object as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider a basic implementation of object type access. The code in [Listing
    7-27](chapter7.xhtml#Lis7-27) relies on an <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectTypes</samp>
    property added to the access context. We can generate the values for this parameter
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-ObjectTypeTree</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-ObjectTypeTree</samp> commands,
    whose use we'll cover on page 254.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-27](chapter7.xhtml#Lis7-27) shows the access check implementation
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">AllowedObject</samp> ACE
    type. Add it to the ACE enumeration code from [Listing 7-17](chapter7.xhtml#Lis7-17).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-27: An implementation of the AllowedObject ACE access check algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: We start with the SID check ❶. If the SIDs don’t match, we don’t process the
    ACE. Next, we check whether the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectTypes</samp>
    property exists in the context and whether the ACE defines an <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp>
    ❷ (the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp> on the
    ACE is optional). Again, if these checks fail, we ignore the ACE. Finally, we
    check whether there is an entry in the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectTypes</samp>
    parameter for the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp>
    GUID ❸.
  prefs: []
  type: TYPE_NORMAL
- en: If all checks pass, we consider the ACE for the access check. First we revoke
    the access from the entry in the tree of objects ❹. This removes the access not
    only from the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp>
    entry we found but also from any children of that entry. We also revoke the access
    we’re maintaining for this function.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s apply this behavior to the tree shown in [Figure 7-4](chapter7.xhtml#fig7-4).
    If the <samp class="SANS_TheSansMonoCd_W5Regular_11">AllowedObject</samp> ACE
    grants <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp> access
    to property set 1, the new tree will look like the one in [Figure 7-5](chapter7.xhtml#fig7-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure7-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-5: The object type
    tree after access is granted to property set 1</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: As the <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp> access
    has been removed from the <samp class="SANS_TheSansMonoCd_W5Regular_11">RemainingAccess</samp>
    for property set 1, it’s also been removed for properties X and Y. These nodes
    now have an empty <samp class="SANS_TheSansMonoCd_W5Regular_11">RemainingAccess</samp>.
    Note that for <samp class="SANS_TheSansMonoCd_W5Regular_11">Allowed</samp> ACEs
    only the main <samp class="SANS_TheSansMonoCd_W5Regular_11">RemainingAccess</samp>
    matters, as the tree’s purpose is to handle <samp class="SANS_TheSansMonoCd_W5Regular_11">Denied</samp>
    ACEs correctly. This means that not every object type must have a <samp class="SANS_TheSansMonoCd_W5Regular_11">RemainingAccess</samp>
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> for the access check
    to succeed.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s handle the <samp class="SANS_TheSansMonoCd_W5Regular_11">DeniedObject</samp>
    ACE. Add the code in [Listing 7-28](chapter7.xhtml#Lis7-28) to the existing ACE
    enumeration code in [Listing 7-17](chapter7.xhtml#Lis7-17).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-28: An implementation of the DeniedObject ACE access check algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: As usual, we begin by checking all ACEs with the <samp class="SANS_TheSansMonoCd_W5Regular_11">DeniedObject</samp>
    type ❶<samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> If the check passes,
    we next check the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectTypes</samp>
    context property ❷. When we handled the <samp class="SANS_TheSansMonoCd_W5Regular_11">AllowedObject</samp>
    ACE, we stopped the check if the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp>
    property was missing. However, we handle the <samp class="SANS_TheSansMonoCd_W5Regular_11">DeniedObject</samp>
    ACEs differently. If there is no <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectTypes</samp>
    property, the check will continue as if it were a normal <samp class="SANS_TheSansMonoCd_W5Regular_11">Denied</samp>
    ACE, by considering the main <samp class="SANS_TheSansMonoCd_W5Regular_11">RemainingAccess</samp>
    ❹.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the ACE’s access mask contains bits in the <samp class="SANS_TheSansMonoCd_W5Regular_11">RemainingAccess</samp>,
    we deny access ❸. If this check passes, we check the value against the main <samp
    class="SANS_TheSansMonoCd_W5Regular_11">RemainingAccess</samp>. This demonstrates
    the purpose of maintaining the tree: if the <samp class="SANS_TheSansMonoCd_W5Regular_11">Denied</samp>
    ACE matched property X in [Figure 7-5](chapter7.xhtml#fig7-5), the denied mask
    would have no effect. However, if the <samp class="SANS_TheSansMonoCd_W5Regular_11">Denied</samp>
    ACE matched property Z, then that object type, and by association property set
    2 and the root object type, would be denied as well. [Figure 7-6](chapter7.xhtml#fig7-6)
    demonstrates this: you can see that those nodes are all now denied, even though
    the property set 1 branch is still allowed.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure7-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-6: The object type
    tree after denying access to property Z</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAccessCheckByType</samp>
    system call returns a single status and granted access for the entire list of
    object types, reflecting the access specified at the root of the object type tree.
    Therefore, in the case of [Figure 7-6](chapter7.xhtml#fig7-6), the whole access
    check would fail.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out which particular object types failed the access check, you can
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAccessCheckByTypeResultList</samp>
    system call, which returns a status and the granted access for every entry in
    the object type list. [Listing 7-29](chapter7.xhtml#Lis7-29) shows how you can
    use this system call by specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">ResultList</samp>
    parameter to <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-29: Example showing the difference between normal and list results'
  prefs: []
  type: TYPE_NORMAL
- en: We start by building the object type tree to match the tree in [Figure 7-4](chapter7.xhtml#fig7-4)
    ❶. We don’t care about the specific GUID values except for that of property Z,
    which we’ll need for the <samp class="SANS_TheSansMonoCd_W5Regular_11">DeniedObject</samp>
    ACE, so we generate random GUIDs. Next, we build the security descriptor, creating
    an ACE that denies <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>
    access to property Z ❷. We also include a non-object ACE to grant <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp> access.
  prefs: []
  type: TYPE_NORMAL
- en: We first run the access check with the object type tree but without the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ResultList</samp> parameter, requesting
    both <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp> access ❸. We use the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Denied</samp> ACE, as it matches
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp> GUID in the
    object type tree. As we expected, this causes the access check process to return
    <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_ACCESS_DENIED</samp>, with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> as the granted access
    ❹.
  prefs: []
  type: TYPE_NORMAL
- en: When we execute the access check again, this time with <samp class="SANS_TheSansMonoCd_W5Regular_11">ResultList</samp>,
    we receive a list of access check results ❺. The top-level object entry still
    indicates that access was denied, but access was granted to property set 1 and
    its children ❻. This result corresponds to the tree shown in [Figure 7-6](chapter7.xhtml#fig7-6).
    Also note that the entries for which access was denied don’t show an empty granted
    access; instead, they indicate that <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>
    access would have been granted if the request had succeeded. This is an artifact
    of how the access check is implemented under the hood and almost certainly shouldn’t
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Central Access
    Policy</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *central access policy*, a feature added in Windows 8 and Windows Server
    2012 for use in enterprise networks, is the core security mechanism behind a Windows
    feature called *Dynamic Access Control.* It relies on device and user claim attributes
    in the token.
  prefs: []
  type: TYPE_NORMAL
- en: We talked briefly about user and device claims in [Chapter 4](chapter4.xhtml),
    when discussing the conditional expression format. A *user claim* is a security
    attribute added to the token for a specific user. For example, you might have
    a claim that represents the country in which a user is employed. You can sync
    the value of the claim with values stored in Active Directory so that if the user,
    say, moves to another country, their user claim will update the next time they
    authenticate.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *device claim* belongs to the computer used to access the resource. For example,
    a device claim might indicate whether the computer is located in a secure room
    or is running a specific version of Windows. [Figure 7-7](chapter7.xhtml#fig7-7)
    shows a common use of a central access policy: restricting access to files on
    a server in an enterprise network.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure7-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-7: A central access
    policy on a file server</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This central access policy contains one or more security descriptors that the
    access check will consider in addition to a file’s security descriptor. The final
    granted access is the most restrictive result of the access checks. While not
    strictly necessary, the additional security descriptors can rely on user and device
    claims in <samp class="SANS_TheSansMonoCd_W5Regular_11">AllowedCallback</samp>
    ACEs to determine the granted access. The enterprise’s Kerberos authentication
    must be configured to support the claims in order to send them over the network.
    We’ll come back to Kerberos authentication in [Chapter 14](chapter14.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: You might wonder how using a central access policy differs from simply configuring
    the security of the files to use the device and user claims. The main difference
    is that it’s managed centrally using policies in the enterprise domain group policy.
    This means an administrator can change the central access policy in one place
    to update it across the enterprise.
  prefs: []
  type: TYPE_NORMAL
- en: A second difference is that the central access policy works more like a mandatory
    access control mechanism. For example, a user might typically be able to modify
    the security descriptor for the file; however, the central access policy could
    restrict their access or block it outright if, for example, the user moved to
    a new country or used a different computer not accounted for in the rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'We won’t discuss how to configure a central access policy, as that topic is
    more appropriate for a book on Windows enterprise management. Instead, we’ll explore
    how it’s enforced by the kernel’s access check process. The Windows registry stores
    the central access policy when the computer’s group policy is updated, and you
    can find the key at the following location: *HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa\CentralizedAccessPolicies*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There can be more than one configured policy, each containing the following
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: The name and description of the policy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A SID that uniquely identifies the policy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or more policy rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In turn, each policy rule contains the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: The name and description of the rule
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A conditional expression that determines when the rule should be enforced
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The security descriptor to use in the central access policy access check
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional staging security descriptor used to test new policy rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-CentralAccessPolicy</samp>
    PowerShell command to display the list of policies and rules. For most Windows
    systems, the command won’t return any information. To see results like those in
    [Listing 7-30](chapter7.xhtml#Lis7-30), you’ll need to join a domain that is configured
    to use a central access policy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-30: Displaying the central access policy'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, when we run <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-CentralAccessPolicy</samp>
    we see two policies, <samp class="SANS_TheSansMonoCd_W5Regular_11">Secure Room
    Policy</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Main Policy</samp>.
    Each policy has a <samp class="SANS_TheSansMonoCd_W5Regular_11">CapId</samp> SID
    and a <samp class="SANS_TheSansMonoCd_W5Regular_11">Rules</samp> property, which
    we can expand to see the individual rules. The output table contains the following
    fields: <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Description</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">AppliesTo</samp>, which is a
    conditional expression used to select whether the rule should be enforced. If
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">AppliesTo</samp> field is empty,
    the rule will always be enforced. The <samp class="SANS_TheSansMonoCd_W5Regular_11">AppliesTo</samp>
    field for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Secure Rule</samp>
    selects on a resource attribute, which we’ll come back to in [Listing 7-32](chapter7.xhtml#Lis7-32).'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s display the security descriptor for this rule. The DACL contains a single
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AllowedCallback</samp> ACE that
    grants full access to the *Everyone* group if the condition matches. In this case,
    the clearance user claim must be set to the value <samp class="SANS_TheSansMonoCd_W5Regular_11">TS/ST3</samp>,
    and the device claim location must be set to <samp class="SANS_TheSansMonoCd_W5Regular_11">Secure</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll walk through a basic implementation of the central access policy access
    check to better understand what the policy is being used for. Add the code in
    [Listing 7-31](chapter7.xhtml#Lis7-31) to the end of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-PSGrantedAccess</samp>
    function from [Listing 7-2](chapter7.xhtml#Lis7-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-31: The central access policy check'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-31](chapter7.xhtml#Lis7-31) begins immediately after the discretionary
    access check. If this check fails, the <samp class="SANS_TheSansMonoCd_W5Regular_11">$success</samp>
    variable will be <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>, and
    we should return <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_ACCESS_DENIED</samp>
    ❶. To start the process of enforcing a central access policy, we need to query
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ScopedPolicyId</samp> ACE from
    the SACL ❷. If there is no <samp class="SANS_TheSansMonoCd_W5Regular_11">ScopedPolicyId</samp>
    ACE, we can return success. We also return success if there is no central access
    policy with a <samp class="SANS_TheSansMonoCd_W5Regular_11">CapId</samp> that
    matches the ACE’s SID ❸.'
  prefs: []
  type: TYPE_NORMAL
- en: Within the central access policy check, we first set the effective access to
    the original <samp class="SANS_TheSansMonoCd_W5Regular_11">DesiredAccess</samp>
    ❹. We’ll use the effective access to determine how much of the <samp class="SANS_TheSansMonoCd_W5Regular_11">DesiredAccess</samp>
    we can grant after processing all the policy rules. Next, we check the <samp class="SANS_TheSansMonoCd_W5Regular_11">AppliesTo</samp>
    conditional expression for each rule. If there is no value, the rule applies to
    all resources and tokens. If there is a conditional expression, we must check
    it using <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-NtAceCondition</samp>,
    passing any resource attributes from the security descriptor ❺. If the test doesn’t
    pass, the check should skip to the next rule.
  prefs: []
  type: TYPE_NORMAL
- en: We build a new security descriptor using the owner, group, and SACL from the
    original security descriptor but the DACL from the rule’s security descriptor
    ❻. If the rule applies, we do another discretionary access check for the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">DesiredAccess</samp> ❼. After this check,
    we remove any bits that we weren’t granted from the <samp class="SANS_TheSansMonoCd_W5Regular_11">effective_access</samp>
    variable ❽.
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve checked all the applicable rules, we test whether the effective access
    is empty. If it is, the central access policy has not granted the token any access,
    so we return <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_ACCESS_DENIED</samp>
    ❾. Otherwise, we return success, but we return only the remaining effective access
    that grants less access than the result of the first access check ❿.
  prefs: []
  type: TYPE_NORMAL
- en: 'While most central access policies are designed to check files, we can modify
    any resource type to enforce a policy. To enable it for another resource, we need
    to do two things: set a scoped policy ID ACE with the SID of the policy to enable,
    and add any resource attribute ACEs to match the <samp class="SANS_TheSansMonoCd_W5Regular_11">AppliesTo</samp>
    condition, if there is one. We perform these tasks in [Listing 7-32](chapter7.xhtml#Lis7-32).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-32: Enabling the Secure Room Policy for a registry key'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we need to do is add a resource attribute ACE to satisfy the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AppliesTo</samp> condition for the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Secure Rule</samp>. We create a
    security attribute object with the name <samp class="SANS_TheSansMonoCd_W5Regular_11">EnableSecure</samp>
    and a single <samp class="SANS_TheSansMonoCd_W5Regular_11">Int64</samp> value
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> ❶. We add this security
    attribute to an ACE of type <samp class="SANS_TheSansMonoCd_W5Regular_11">ResourceAttribute</samp>
    in the security descriptor’s SACL ❷. We then need to set the SID of the central
    access policy, which we can get from the output of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-CentralAccessPolicy</samp>
    command in a <samp class="SANS_TheSansMonoCd_W5Regular_11">ScopedPolicyId</samp>
    ACE ❸. We can format the security descriptor to check that the ACEs are correct.
  prefs: []
  type: TYPE_NORMAL
- en: We now set the two ACEs to the resource. In this case, the resource we’ll pick
    is a registry key ❺. Note that you must have previously created this registry
    key for the operation to succeed. The <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityInformation</samp>
    parameter must be set to <samp class="SANS_TheSansMonoCd_W5Regular_11">Scope</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Attribute</samp>. As we observed
    in [Chapter 5](chapter5.xhtml), to set the <samp class="SANS_TheSansMonoCd_W5Regular_11">ScopedPolicyId</samp>
    ACE, we need <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp>
    access, which means we need to first enable <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSecurityPrivilege</samp>
    ❹.
  prefs: []
  type: TYPE_NORMAL
- en: If you access the registry key, you should find the policy to be enforced. Note
    that because the central access policy is configured for use with filesystems,
    the access mask in the security descriptor might not work correctly with other
    resources, such as registry keys. You could manually configure the attributes
    in Active Directory if you really wanted to support this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing to mention is that central access policy rules support specifying
    a staging security descriptor as well as the normal security descriptor. We can
    use this staging security descriptor to test an upcoming security change before
    deploying it widely. The staging security descriptor is checked in the same way
    as the normal security descriptor, except the result of the check is used only
    to compare against the real granted access, and an audit log is generated if the
    two access masks differ.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Worked Examples</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s finish with some worked examples using the commands you’ve learned about
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using the Get-PSGrantedAccess
    Command</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Throughout this chapter, we’ve built our own implementation of the access check
    process: the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-PSGrantedAccess</samp>
    command. In this section, we’ll explore the use of this command. You can retrieve
    the module containing it from the *chapter_7_access_check_impl.psm1* file included
    with the online additional materials for this book.'
  prefs: []
  type: TYPE_NORMAL
- en: Because <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-PSGrantedAccess</samp>
    is a simple implementation of the access check, it’s missing some features, such
    as support for calculating maximum access. However, it can still help you understand
    the access check process. You can, for example, use a PowerShell debugger in the
    PowerShell Integrated Scripting Environment (ISE) or Visual Studio Code to step
    through the access check and see how it functions based on different input.
  prefs: []
  type: TYPE_NORMAL
- en: Run the commands in [Listing 7-33](chapter7.xhtml#Lis7-33) as a non-administrator
    split-token user.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-33: Using the Get-PSGrantedAccess command'
  prefs: []
  type: TYPE_NORMAL
- en: First, we import the module containing the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-PSGrantedAccess</samp>
    command ❶. The import assumes the module file is saved in your current directory;
    if it’s not, modify the path as appropriate. We then build a restrictive security
    descriptor, granting read access to the *Everyone* group and nobody else ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-PSGrantedAccess</samp>,
    requesting <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp> access
    along with the <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp> object
    type’s generic mapping ❸. We don’t specify a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    parameter, which means the check will use the caller’s effective token. The command
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_SUCCESS</samp>, and
    the granted access matches the desired access we originally passed to it.
  prefs: []
  type: TYPE_NORMAL
- en: Then we change the desired access to <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp>
    access only ❹. Based on the restrictive security descriptor, only the owner of
    the security descriptor, which was set to the *SYSTEM* user, should be granted
    this access. When we rerun the access check, we get <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_ACCESS_DENIED</samp>
    and no granted access ❺.
  prefs: []
  type: TYPE_NORMAL
- en: To show how we can bypass these restrictions, we query for the caller’s linked
    token ❻. As described in [Chapter 4](chapter4.xhtml), UAC uses the linked token
    to expose the full administrator token. This command won’t work unless you’re
    running the script as a split-token administrator. However, we can enable the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTakeOwnershipPrivilege</samp>
    privilege on the linked token ❼, which should bypass the owner check for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp>. The access check should
    now return <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_SUCCESS</samp>
    and grant the desired access ❽. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Privileges</samp>
    column shows that <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTakeOwnershipPrivilege</samp>
    was used to grant the access right.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, it’s worth running this script in a debugger and stepping into
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-PSGrantedAccess</samp> to follow
    along with the access check process so that you understand it better. I also recommend
    trying different combinations of values in the security descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Calculating Granted
    Access for Resources</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you really need to know the granted access of a resource, you’re better off
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp>
    command over the PowerShell implementation we’ve developed. Let’s see how we can
    use this command to get the granted access for a list of resources. In [Listing
    7-34](chapter7.xhtml#Lis7-34), we’ll take the script we used in [Chapter 6](chapter6.xhtml)
    to find the owners of objects and calculate the full granted access.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-34: Enumerating objects and getting their granted access'
  prefs: []
  type: TYPE_NORMAL
- en: In this modified version of the script created in [Listing 6-37](chapter6.xhtml#Lis6-37),
    instead of merely checking the owner SID, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp>
    with the security descriptor ❶. This should retrieve the granted access for the
    caller. Another strategy would have been to check the granted access for any impersonation
    token at the Identification level with <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp>
    access on the handle, then pass it as the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    parameter. In the next chapter, we’ll explore an easier way to do large-scale
    access checking without having to write your own scripts.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Wrapping Up</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we detailed the implementation of the access check process
    in Windows at length. This included describing the operating system’s mandatory
    access checks, token owner and privilege checks, and discretionary access checks.
    We also built our own implementation of the access check process to enable you
    to better understand it.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we covered how the two types of sandboxing tokens (restricted and lowbox)
    affect the access check process to restrict resource access. Finally, we discussed
    object type checking and central access policies, important features of enterprise
    security for Windows.
  prefs: []
  type: TYPE_NORMAL
