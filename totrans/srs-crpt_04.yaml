- en: '3'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '3'
- en: CRYPTOGRAPHIC SECURITY
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 加密安全
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: Cryptographic definitions of security are not the same as those that apply to
    general computer security. The main difference between software security and cryptographic
    security is that the latter can be *quantified*. Unlike in the software world,
    where applications are usually seen as either secure or insecure, in the cryptographic
    world it’s often possible to calculate the amount of effort required to break
    a cryptographic algorithm. Also, whereas software security focuses on preventing
    attackers from abusing a program’s code, the goal of cryptographic security is
    to make well-defined problems impossible to solve.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学的安全性定义与通用计算机安全性定义并不相同。软件安全与密码学安全的主要区别在于，后者可以被*量化*。与软件世界中通常将应用程序视为安全或不安全不同，在密码学世界中，往往可以计算出破解一个密码算法所需的努力程度。此外，软件安全侧重于防止攻击者滥用程序的代码，而密码学安全的目标是使得明确的问题无法解决。
- en: Cryptographic problems involve mathematical notions, but not complex math—or
    at least not in this book. This chapter walks you through some of these security
    notions and how they’re applied to solve real-world problems. In the following
    sections, I discuss how to quantify crypto security in ways that are both theoretically
    sound and practically relevant. I discuss the notions of informational versus
    computational security, bit security versus full attack cost, provable versus
    heuristic security, and symmetric versus asymmetric key generation. I conclude
    the chapter with actual examples of failures in seemingly strong cryptography.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学问题涉及数学概念，但不是复杂的数学——至少在本书中不是。 本章将引导你了解这些安全概念以及它们如何应用于解决实际问题。在接下来的部分中，我将讨论如何量化加密安全，既符合理论逻辑，又具有实际相关性。我将讨论信息安全与计算安全、位安全与完整攻击成本、可证明安全与启发式安全、对称与非对称密钥生成的概念。最后，我会通过实际的密码学失败示例来总结本章内容。
- en: Defining the Impossible
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义不可行
- en: In [Chapter 1](ch01.xhtml#ch1), I described a cipher’s security relative to
    an attacker’s capabilities and goals, and deemed a cipher secure if it was impossible
    to reach these goals given an attacker’s known capabilities. But what does *impossible*
    mean in this context?
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.xhtml#ch1)中，我描述了密码的安全性相对于攻击者的能力和目标，并认为如果给定攻击者已知的能力，无法实现这些目标，则该密码是安全的。但在这种语境下，*不可行*到底是什么意思呢？
- en: 'Two notions define the concept of impossible in cryptography: informational
    security and computational security. Roughly speaking, *informational security*
    is about theoretical impossibility whereas *computational security* is about practical
    impossibility. Informational security doesn’t quantify security because it views
    a cipher as either secure or insecure, with no middle ground; it’s therefore useless
    in practice, although it plays an important role in theoretical cryptography.
    Computational security is the more relevant and practical measure of the strength
    of a cipher.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学中“不可行”的概念由两个概念定义：信息安全和计算安全。粗略地说，*信息安全*是关于理论上的不可能，而*计算安全*则是关于实际的不可能。信息安全并不量化安全性，因为它将密码视为要么安全，要么不安全，没有中间地带；因此，虽然在理论密码学中发挥着重要作用，但在实践中它是没有用的。计算安全则是衡量密码强度的更相关和实际的标准。
- en: '*Security in Theory: Informational Security*'
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*理论中的安全性：信息安全*'
- en: Informational security is based not on how hard it is to break a cipher, but
    whether it’s conceivable to break it at all. A cipher is informationally secure
    only if, even given unlimited computation time and memory, it cannot be broken.
    Even if a successful attack on a cipher would take trillions of years, such a
    cipher is informationally *in*secure.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 信息安全的基础不是看破解密码有多难，而是看是否可以想象破解它。只有在即使给定无限的计算时间和内存也无法破解时，密码才被认为是信息上安全的。即使对一个密码的成功攻击需要几万亿年的时间，这样的密码也是信息上*不*安全的。
- en: For example, the one-time pad introduced in [Chapter 1](ch01.xhtml#ch1) is informationally
    secure. Recall that the one-time pad encrypts a plaintext, *P*, to a ciphertext,
    *C* = *P* ⊕ *K*, where *K* is a random bit string that is unique to each plaintext.
    The cipher is informationally secure because given a ciphertext and unlimited
    time to try all possible keys, *K*, and compute the corresponding plaintext, *P*,
    you would still be unable to identify the right *K* because there are as many
    possible *P*s as there are *K*s.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，第 [1 章](ch01.xhtml#ch1) 中介绍的一次性密码本是信息安全的。回想一下，一次性密码本将明文 *P* 加密为密文 *C* = *P*
    ⊕ *K*，其中 *K* 是一个对每个明文唯一的随机比特串。这个密码在信息安全上是安全的，因为给定一个密文和无限的时间去尝试所有可能的密钥 *K* 并计算对应的明文
    *P*，你仍然无法确定正确的 *K*，因为可能的 *P* 的数量与 *K* 的数量一样多。
- en: '*Security in Practice: Computational Security*'
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*实践中的安全：计算安全性*'
- en: Unlike informational security, computational security views a cipher as secure
    if it cannot be broken within a *reasonable* amount of time, and with reasonable
    resources such as memory, hardware, budget, energy, and so on. Computational security
    is a way to quantify the security of a cipher or any crypto algorithm.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 与信息安全不同，计算安全性认为一个密码在 *合理* 时间内无法被破解，且使用合理的资源，如内存、硬件、预算、能源等，就可以认为它是安全的。计算安全性是一种量化密码或任何加密算法安全性的方法。
- en: For example, consider a cipher, **E**, for which you know a plaintext–ciphertext
    pair (*P*, *C*) but not the 128-bit key, *K*, that served to compute *C* = **E**(*K*,
    *P*). This cipher is not informationally secure because you could break it after
    trying the 2^(128) possible 128-bit *K*s until you find the one that satisfies
    **E**(*K*, *P*) = *C*. But in practice, even testing 100 billion keys per second,
    it would take more than 100,000,000,000,000,000,000 years. In other words, reasonably
    speaking, this cipher is computationally secure because it’s practically impossible
    to break.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个密码 **E**，你知道一个明文–密文对 (*P*, *C*)，但不知道用于计算 *C* = **E**(*K*, *P*) 的 128
    位密钥 *K*。这个密码在信息安全上是不安全的，因为你可以尝试 2^(128) 个可能的 128 位密钥 *K*，直到找到一个满足 **E**(*K*, *P*)
    = *C* 的密钥。但实际上，即使每秒测试 1000 亿个密钥，仍然需要超过 100,000,000,000,000,000,000 年才能破解。换句话说，从合理的角度看，这个密码是计算上安全的，因为它几乎不可能被破解。
- en: 'Computational security is sometimes expressed in terms of two values:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 计算安全有时用两个值来表示：
- en: '*t*, which is a limit on the number of operations that an attacker will carry
    out'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*t*，它是攻击者执行的操作次数的上限'
- en: ε (called “epsilon”), which is a limit on the probability of success of an attack
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ε（称为“epsilon”），它是攻击成功概率的上限
- en: We then say that a cryptographic scheme is (*t,* ε)*-secure* if an attacker
    performing at most *t* operations—whatever those operations are—has a probability
    of success that is no higher than ε, where ε is at least 0 and at most 1\. Computational
    security gives a limit on how hard it is to break a cryptographic algorithm.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着说，如果一个加密方案是 (*t,* ε)*-安全* 的，那么执行最多 *t* 次操作的攻击者——无论这些操作是什么——成功的概率不高于 ε，其中
    ε 至少为 0，至多为 1。计算安全性给出了破解一个加密算法的难度上限。
- en: 'Here it’s important to know that *t* and ε are just limits: if a cipher is
    (*t,* ε)*-secure*, then no attacker performing fewer than *t* operations will
    succeed (with probability ε). But that doesn’t imply that an attacker doing exactly
    *t* operations will succeed, and it doesn’t tell you how many operations are needed,
    which may be much larger than *t*. We say that *t* is a *lower bound* on the computation
    effort needed, because you’d need at least *t* operations to compromise security.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，需要知道的是 *t* 和 ε 只是上限：如果一个密码是 (*t,* ε)*-安全* 的，那么执行少于 *t* 次操作的攻击者将不会成功（概率为
    ε）。但这并不意味着执行正好 *t* 次操作的攻击者就会成功，也没有告诉你需要多少操作，可能比 *t* 要大得多。我们说 *t* 是所需计算工作量的 *下限*，因为至少需要
    *t* 次操作才能破坏安全性。
- en: We sometimes know precisely how much effort it takes to break a cipher; in such
    cases we say that a (*t*, ε*)-security* gives us a *tight bound* when an attack
    exists that breaks the cipher with probability ε and exactly *t* operations.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有时能精确知道破解密码需要多少努力；在这种情况下，我们说 (*t*, ε*)-安全* 给出了一个 *紧界*，当存在一个攻击能够以 ε 的概率用正好
    *t* 次操作破解密码时。
- en: For example, consider a symmetric cipher with a 128-bit key. Ideally, this cipher
    should be (*t, t/2*^(128))*-secure* for any value of *t* between 1 and 2^(128).
    The best attack should be *brute force* (trying all keys until you find the correct
    one). Any better attack would have to exploit some imperfection in the cipher,
    so we strive to create ciphers where brute force is the best possible attack.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个使用 128 位密钥的对称加密算法。理想情况下，该加密算法应该是(*t, t/2*^(128))*-安全*，对于 *t* 的任何值，范围在
    1 到 2^(128) 之间。最佳攻击方法应是 *暴力破解*（尝试所有密钥直到找到正确的密钥）。任何更好的攻击方法必须利用加密算法中的某些缺陷，因此我们努力创建那些暴力破解是最佳攻击方法的加密算法。
- en: 'Given the statement (*t*, *t*/*2*^(128))*-secure*, let’s examine the probability
    of success of three possible attacks:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有(*t*, *t*/*2*^(128))*-安全*，让我们来分析三种可能的攻击成功概率：
- en: In the first case, *t* = 1, an attacker tries one key and succeeds with a probability
    of ε = 1/2^(128).
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一种情况下，*t* = 1，攻击者尝试一个密钥并成功，成功的概率为 ε = 1/2^(128)。
- en: In the second case, *t* = 2^(128), an attacker tries all 2^(128) keys and one
    succeeds. Thus, the probability ε = 1 (if the attacker tries all keys, obviously
    the right one must be one of them).
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二种情况下，*t* = 2^(128)，攻击者尝试所有 2^(128) 个密钥，最终会成功。因此，成功的概率 ε = 1（如果攻击者尝试所有密钥，显然正确的密钥一定会被尝试到）。
- en: In the third case, an attacker tries only *t* = 2^(64) keys, and succeeds with
    a probability of ε = 2^(64)/2^(128) = 2^(−64). When an attacker only tries a fraction
    of all keys, the success probability is proportional to the number of keys tried.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第三种情况下，攻击者只尝试 *t* = 2^(64) 个密钥，并成功的概率为 ε = 2^(64)/2^(128) = 2^(−64)。当攻击者只尝试部分密钥时，成功的概率与尝试的密钥数量成正比。
- en: We can conclude that a cipher with a key of *n* bits is at best (*t, t/2*^(*n*))*-secure*,
    for any *t* between 1 and 2^(*n*), because no matter how strong the cipher, a
    brute-force attack against it will always succeed. The key thus needs be long
    enough to blunt brute-force attacks in practice.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以得出结论，一个密钥长度为 *n* 位的加密算法，在最好的情况下，其安全性为 (*t, t/2*^(*n*))*-安全*，对于任何 *t* 的值，范围从
    1 到 2^(*n*)，因为无论加密算法多么强大，针对它的暴力破解攻击最终总会成功。因此，密钥需要足够长，以有效抵御暴力破解攻击。
- en: '**NOTE**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this example, we are counting the number of evaluations of the cipher,
    not the absolute time or number of processor clock cycles. Computational security
    is technology agnostic, which is good: a cipher that is* (t, ε)-secure *today
    will be* (t, ε)-secure *tomorrow, but what’s considered secure in practice today
    might not be considered secure tomorrow.*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这个例子中，我们计算的是加密算法的评估次数，而不是绝对时间或处理器时钟周期数。计算安全性不依赖于技术，这一点很好：今天是*（t, ε）-安全*的加密算法明天依然是*（t,
    ε）-安全*的，但今天在实践中被认为是安全的，明天可能就不再被认为是安全的。*'
- en: Quantifying Security
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 量化安全性
- en: When an attack is found, the first thing you want to know is how efficient it
    is in theory, and how practical it is, if at all. Likewise, given a cipher that’s
    allegedly secure, you want to know what amount of work it can withstand. To address
    those questions, I’ll explain how cryptographic security can be measured in bits
    (the theoretical view) and what factors affect the actual cost of an attack.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当发现一种攻击时，你首先想知道的是它在理论上的效率如何，以及它在实践中是否可行。同样，给定一个被认为是安全的加密算法，你也想知道它能够承受多少工作量。为了回答这些问题，我将解释如何用位数来衡量密码学安全性（理论视角）以及哪些因素影响攻击的实际成本。
- en: '*Measuring Security in Bits*'
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*以位数衡量安全性*'
- en: When speaking of computational security, we say that a cipher is *t-secure*
    when a successful attack needs at least *t* operations. We thus avoid the unintuitive
    (*t*, ε) notation by assuming a success probability of ε close to 1, or what we
    care about in practice. We then express security in bits, where “*n*-bit security”
    means that about 2^(*n*) operations are needed to compromise some particular security
    notion.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算安全性时，我们说一个加密算法是 *t-安全* 的，当一个成功的攻击至少需要 *t* 次操作。因此，我们通过假设成功概率 ε 接近 1 来避免不直观的
    (*t*, ε) 符号，这也正是我们在实际中关心的。然后，我们用位数表示安全性，其中“*n*-位安全”意味着需要大约 2^(*n*) 次操作来破解某个特定的安全概念。
- en: 'If you know approximately how many operations it takes to break a cipher, you
    can determine its security level in bits by taking the binary logarithm of the
    number of operations: if it takes 1000000 operations, the security level is log[2](1000000),
    or about 20 bits (that is, 1000000 is approximately equal to 2^(20)). Recall that
    an *n*-bit key will give at most *n*-bit security because a brute-force attack
    with all 2^(*n*) possible keys will always succeed. But the key size doesn’t always
    match the security level—it just gives an *upper bound*, or the highest possible
    security level.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你大概知道破解一个密码需要多少操作，你可以通过对操作次数取二进制对数来确定其安全级别：如果需要1000000次操作，安全级别就是log[2](1000000大约是20位（也就是说，1000000大约等于2^(20)）。回想一下，*n*位密钥最多提供*n*位安全性，因为用所有2^(*n*)个可能的密钥进行暴力攻击总是会成功的。但密钥的大小并不总是与安全级别相匹配——它只是提供了一个*上界*，即最高可能的安全级别。
- en: 'A security level may be smaller than the key size for one of two reasons:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 安全级别可能小于密钥大小，原因有两个：
- en: An attack broke the cipher in fewer operations than expected—for example, using
    a method that recovers the key by trying not all 2^(*n*) keys, but only a subset
    of those.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种攻击方法用比预期更少的操作破解了密码——例如，使用一种通过尝试不全部2^(*n*)个密钥，而只是其中一个子集来恢复密钥的方法。
- en: The cipher’s security level intentionally differs from its key size, as with
    most public key algorithms. For example, the RSA algorithm with a 2048-bit secret
    key provides less than 100-bit security.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码的安全级别故意与密钥大小不同，就像大多数公钥算法一样。例如，RSA算法使用2048位的秘密密钥提供的安全性不到100位。
- en: Bit security proves useful when comparing ciphers’ security levels but doesn’t
    provide enough information on the actual cost of an attack. It is sometimes too
    simple an abstraction because it just assumes that an *n*-bit-secure cipher takes
    2^(*n*) operations to break, whatever these operations are. Two ciphers with the
    same bit security level can therefore have vastly different real-world security
    levels when you factor in the actual cost of an attack to a real attacker.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 位安全性在比较密码的安全级别时非常有用，但它并没有提供足够的信息来判断攻击的实际成本。它有时是一个过于简单的抽象，因为它只是假设一个*n*位安全的密码需要2^(*n*)次操作来破解，不管这些操作是什么。因此，两个具有相同位安全级别的密码，在考虑到攻击者实际攻击成本时，可能在现实世界中的安全级别差异巨大。
- en: Say we have two ciphers, each with a 128-bit key and 128-bit security. Each
    must be evaluated 2^(128) times in order to be broken, except that the second
    cipher is 100 times slower than the first. Evaluating the second cipher 2^(128)
    times thus takes the same time as 100 × 2^(128) ≈ 2^(134.64) evaluations of the
    first. If we count in terms of the first, fast cipher, then breaking the slower
    one takes 2^(134.64) operations. If we count in terms of the second, slow cipher,
    it only takes 2^(128) operations. Should we then say that the second cipher is
    stronger than the first? In principle, yes, but we rarely see such a hundred-fold
    performance difference between commonly used ciphers.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个密码，每个密码都使用128位密钥和128位安全性。每个密码都需要进行2^(128)次评估才能被破解，只是第二个密码的速度比第一个慢100倍。因此，评估第二个密码2^(128)次所需的时间与100
    × 2^(128) ≈ 2^(134.64)次评估第一个密码所需的时间相同。如果我们以第一个较快的密码为基准，那么破解较慢的密码需要2^(134.64)次操作。如果我们以第二个较慢的密码为基准，则只需要2^(128)次操作。那么我们是否可以说第二个密码比第一个密码更强？原则上是的，但我们很少看到常用密码之间有如此百倍的性能差异。
- en: The inconsistent definition of an operation raises more difficulties when comparing
    the efficiency of attacks. Some attacks claim to reduce a cipher’s security because
    they perform 2^(120) evaluations of some operation rather than 2^(128) evaluations
    of the cipher, but the speed of each type of attack is left out of the analysis.
    The 2^(120)-operation attack won’t always be faster than a 2^(128) brute-force
    attack.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 操作的不一致定义在比较攻击效率时引发了更多困难。一些攻击声称通过执行2^(120)次某种操作而不是2^(128)次密码评估来降低密码的安全性，但分析中没有考虑每种攻击类型的速度。2^(120)次操作的攻击并不总是比2^(128)次暴力攻击更快。
- en: Nevertheless, bit security remains a useful notion as long as the operation
    is reasonably defined—meaning about as fast as an evaluation of the cipher. After
    all, in real life, all it takes to determine whether a security level is sufficient
    is an order of magnitude.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，只要操作定义合理——即大致与密码评估的速度相当——位安全性仍然是一个有用的概念。毕竟，在现实生活中，判断一个安全级别是否足够，只需要一个数量级的比较。
- en: '*Full Attack Cost*'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*完整攻击成本*'
- en: 'Bit security expresses the cost of the fastest attack against a cipher by estimating
    the order of magnitude of the number of operations it needs to succeed. But other
    factors affect the cost of an attack, and these must be taken into account when
    estimating the actual security level. I’ll explain the four main ones: parallelism,
    memory, precomputation, and the number of targets.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 位安全性通过估算成功执行攻击所需操作数的数量级来表示对密码的最快攻击成本。但是，其他因素也会影响攻击的成本，在估算实际安全性时必须考虑这些因素。我将解释其中的四个主要因素：并行性、内存、预计算和目标数量。
- en: Parallelism
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 并行性
- en: 'The first factor to consider is computational parallelism. For example, consider
    two attacks of 2^(56) operations each. The difference between the two is that
    the second attack can be parallelized but not the first: the first attack performs
    2^(56) *sequentially dependent* operations, such as *x*[*i* + 1] = *f*[*i*](*x*[*i*])
    for some *x*[0] and some functions *f*[*i*] (with *i* from 1 to 2^(56)), whereas
    the second performs 2^(56) *independent* operations, such as *x*[*i*] = *f*[*i*](*x*)
    for some *x* and *i* from 1 to 2^(56), which can be executed in parallel. Parallel
    processing can be orders of magnitude faster than sequential processing. For example,
    if you had 2^(16) = 65536 processors available, you could divide the workload
    of the parallel attacks into 2^(16) independent tasks, each performing 2^(56)
    / 2^(16) = 2^(40) operations. The first attack, however, cannot benefit from having
    multiple cores available because each operation relies on the previous operation’s
    result. Therefore, the parallel attack will complete 65536 times faster than the
    sequential one, even though they perform the same number of operations.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个要考虑的因素是计算并行性。例如，考虑两种每种都包含 2^(56) 操作的攻击。两者的区别在于，第二种攻击可以并行化，而第一种攻击则不能：第一种攻击执行的是
    2^(56) *顺序依赖*的操作，例如 *x*[*i* + 1] = *f*[*i*](*x*[*i*])，其中 *x*[0] 和一些函数 *f*[*i*]（*i*
    从 1 到 2^(56)）；而第二种攻击执行的是 2^(56) *独立*的操作，例如 *x*[*i*] = *f*[*i*](*x*)，其中 *x* 和 *i*
    从 1 到 2^(56)，可以并行执行。并行处理的速度可以比顺序处理快几个数量级。例如，如果你有 2^(16) = 65536 个处理器可用，你可以将并行攻击的工作负载划分为
    2^(16) 个独立任务，每个任务执行 2^(56) / 2^(16) = 2^(40) 次操作。然而，第一种攻击无法从多个核心的可用性中受益，因为每个操作都依赖于前一个操作的结果。因此，即使两者执行的操作数量相同，平行攻击也将比顺序攻击快
    65536 倍。
- en: '**NOTE**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Algorithms that become* N *times faster to attack when* N *cores are available
    are called* embarrassingly parallel, *and we say that their execution times* scale
    linearly *with respect to the number of computing cores.*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*当* N *个核心可用时，攻击速度提高* N *倍的算法被称为*极其并行的，*我们称它们的执行时间*与计算核心的数量*呈线性缩放关系。*'
- en: Memory
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 内存
- en: 'The second factor when determining the cost of an attack is memory. Cryptanalytic
    attacks should be evaluated with respect to their use of time and space: how many
    operations do they perform over time, how much memory or space do they consume,
    how do they use the space they consume, and what’s the speed of the available
    memory? Unfortunately, bit security is concerned only with the time it takes to
    perform an attack.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 确定攻击成本的第二个因素是内存。密码分析攻击应根据其时间和空间的使用来评估：它们在执行过程中进行多少操作，消耗了多少内存或空间，如何利用它们所占用的空间，以及可用内存的速度有多快？不幸的是，位安全性仅关注执行攻击所需的时间。
- en: Concerning the way space is used, it’s important to consider how many memory
    lookups are required as part of an attack, the speed of memory accesses (which
    may differ between reads and writes), the size of the data accessed, the access
    pattern (contiguous or random memory addresses), and how data is structured in
    memory. For example, on one of today’s general-purpose CPUs, reading from a register
    takes one cycle, whereas reading from the CPU’s cache memory takes around 20 cycles
    (for the L3 cache), and reading from DRAM usually takes at least 100 cycles. A
    factor of 100 can make the difference between one day and three months.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 关于空间的使用方式，重要的是考虑执行攻击时需要多少内存查找、内存访问的速度（读取和写入之间可能有所不同）、访问的数据的大小、访问模式（连续的或随机的内存地址）以及数据在内存中的结构。例如，在今天的一些通用
    CPU 上，从寄存器读取数据需要一个周期，而从 CPU 的缓存内存（L3 缓存）读取大约需要 20 个周期，从 DRAM 读取通常至少需要 100 个周期。100
    倍的差异可能意味着从一天到三个月的时间差。
- en: Precomputation
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 预计算
- en: Precomputation operations are those that need to be performed only once and
    can be reused over subsequent executions of the attack. Precomputation is sometimes
    called the *offline stage* of an attack.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 预计算操作是指那些只需要执行一次，并且可以在后续的攻击执行中重复使用的操作。预计算有时被称为攻击的*离线阶段*。
- en: For example, consider the time-memory trade-off attack. When performing this
    kind of attack, the attacker performs one huge computation that produces large
    lookup tables that are then stored and reused to perform the actual attack. For
    example, one attack on 2G mobile encryption took two months to build two terabytes’
    worth of tables, which were then used to break the encryption in 2G and recover
    a secret session key in only a few seconds.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑时间-内存权衡攻击。在执行这种攻击时，攻击者进行一次巨大的计算，生成大量的查找表，然后将其存储并在实际攻击中重复使用。例如，某次针对2G移动加密的攻击花费了两个月的时间来构建两个TB大小的表格，这些表格随后被用来破解2G加密，并在几秒钟内恢复一个秘密会话密钥。
- en: Number of Targets
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 目标数量
- en: Finally, we come to the number of targets of the attack. The greater the number
    of targets, the greater the attack surface, and the more attackers can learn about
    the keys they’re after.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来看看攻击的目标数量。目标数量越大，攻击面越广，攻击者能够了解的密钥信息也就越多。
- en: 'For example, consider a brute-force key search: if you target a single *n*-bit
    key, it will take 2^(*n*) attempts to find the correct key with certainty. But
    if you target multiple *n*-bit keys—say, a number *M*—and if for a single *P*
    you have *M* distinct ciphertexts, where *C* = **E**(*K*, *P*) for each of the
    *M* keys (*K*) that you’re after, it will again take 2^(*n*) attempts to find
    each key. But if you’re only interested in *at least one* of the *M* keys and
    not in every one, it would take on average 2^(*n*) / *M* attempts to succeed.
    For example, to break one 128-bit key of 2^(16) = 65536 target keys, it will take
    on average 2^(128 − 16) = 2^(112) evaluations of the cipher. That is, the cost
    (and speed) of the attack decreases as the number of targets increases.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑暴力破解密钥搜索：如果你仅仅针对一个*n*位的密钥，破解正确密钥需要进行2^(*n*)次尝试。但如果你同时针对多个*n*位密钥——假设数量为*M*——并且对于每一个单独的*P*你有*M*个不同的密文，其中*C*
    = **E**(*K*, *P*)表示你要找的*M*个密钥(*K*)的加密结果，那么破解每个密钥依然需要2^(*n*)次尝试。但如果你只关心*至少一个*密钥，而不是每一个密钥，那么成功的平均尝试次数将是2^(*n*)
    / *M*。例如，要破解一个128位的密钥，在2^(16) = 65536个目标密钥中，平均需要2^(128 − 16) = 2^(112)次对加密算法的评估。也就是说，随着目标数量的增加，攻击的成本（和速度）会减少。
- en: '*Choosing and Evaluating Security Levels*'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*选择与评估安全性等级*'
- en: Choosing a security level often involves selecting between 128-bit and 256-bit
    security because most standard crypto algorithms and implementations are available
    in one of these two security levels. Below 128 bits you’ll find schemes with 64-
    or 80-bit security, but these are generally not secure enough for real-world use.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 选择安全性等级通常涉及在128位和256位安全性之间做出选择，因为大多数标准加密算法和实现都提供这两种安全性等级。在128位以下，你会找到64位或80位的安全方案，但这些方案通常不足以在实际环境中使用。
- en: At a high level, 128-bit security means that you’d need to carry out approximately
    2^(128) operations to break that crypto system. To give you a sense of what this
    number means, consider the fact that the universe is approximately 2^(88) nanoseconds
    old (there’s a billion nanoseconds in a second). Since testing a key with today’s
    technology takes no less than a nanosecond, you’d need several times the age of
    the universe for an attack to succeed (2^(40) times to be precise) if it takes
    exactly one nanosecond to test a key.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，128位的安全性意味着你需要执行大约2^(128)次操作才能破解该加密系统。为了让你理解这个数字的含义，可以考虑这样一个事实：宇宙大约有2^(88)纳秒的历史（每秒有十亿纳秒）。由于今天的技术下，测试一个密钥至少需要一纳秒，如果测试一个密钥需要一纳秒，那么成功破解攻击所需的时间将是宇宙年龄的几倍（准确来说是2^(40)倍）。
- en: But can’t parallelism and multiple targets dramatically reduce the time it takes
    to complete a successful attack? Not exactly. Say you’re interested in breaking
    any of a million targets, and that you have a million parallel cores available.
    That brings the search time down from 2^(128) to (2^(128) / 2^(20)) / 2^(20) =
    2^(88), which is equivalent to only one universe lifetime.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，难道并行性和多个目标不能大幅度减少完成一次成功攻击所需的时间吗？其实不完全是。假设你希望破解其中任意一个百万个目标，并且你有一百万个并行核心可用。这样，搜索时间就从2^(128)缩短到(2^(128)
    / 2^(20)) / 2^(20) = 2^(88)，这相当于仅仅一个宇宙的生命周期。
- en: 'Another thing to consider when evaluating security levels is the evolution
    of technology. Moore’s law posits that computing efficiency doubles roughly every
    two years. We can think of this as a loss of one bit of security every two years:
    if today a $1000 budget allows you to break, say, a 40-bit key in one hour, then
    Moore’s law says that two years later, you could break a 41-bit key in one hour
    for the same $1000 budget (I’m simplifying). We can extrapolate from this to say
    that, according to Moore’s law, we’ll have 40 fewer bits of security in 80 years
    compared to today. In other words, in 80 years doing 2^(128) operations may cost
    as much as doing 2^(88) operations today. Accounting for parallelism and multiple
    targets, as discussed earlier, we’re down to 2^(48) nanoseconds of computation,
    or about three days. But this extrapolation is highly inaccurate, because Moore’s
    law won’t and can’t scale that much. Still, you get the idea: what looks infeasible
    today may be realistic in a century.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在评估安全等级时需要考虑的因素是技术的进步。摩尔定律指出，计算效率大约每两年翻一番。我们可以将其视为每两年损失一个位的安全性：如果今天1000美元的预算能在一小时内破解一个40位的密钥，那么根据摩尔定律，两年后，你可以用同样的1000美元破解一个41位的密钥（我在简化）。我们可以从中推断，根据摩尔定律，与今天相比，80年后我们将失去40个位的安全性。换句话说，在80年后，执行2^(128)次操作的成本可能与今天执行2^(88)次操作的成本相当。考虑到并行处理和多个目标，如之前讨论的那样，我们的计算时间降到2^(48)纳秒，约为三天。但这一推算是非常不准确的，因为摩尔定律不可能如此扩展。然而，你可以理解：今天看起来不可行的事情，可能在一个世纪后变得现实。
- en: There will be times when a security level lower than 128 bits is justified.
    For example, when you need security for only a short time period and when the
    costs of implementing a higher security level will negatively impact the cost
    or usability of a system. A real-world example is that of pay TV systems, wherein
    encryption keys are either 48 or 64 bits. This sounds ridiculously low, but that’s
    a sufficient security level because the key is refreshed every 5 or 10 seconds.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有时低于128位的安全等级是可以接受的。例如，当你只需要短时间的安全保护，且实施更高安全等级的成本会对系统的成本或可用性产生负面影响时。一个现实的例子是付费电视系统，其中的加密密钥为48位或64位。听起来这似乎低得可笑，但这是足够的安全等级，因为密钥每5秒或10秒就会刷新一次。
- en: Nevertheless, to ensure long-term security, you should choose 256-bit security
    or a bit less. Even in a worst-case scenario—the existence of quantum computers,
    see [Chapter 14](ch14.xhtml#ch14)—a 256-bit secure scheme is unlikely to be broken
    in the foreseeable future. More than 256 bits of security is practically unnecessary,
    except as a marketing device.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了确保长期安全，你应该选择256位安全性或者稍低一些的安全性。即使是在最坏的情况下——量子计算机的出现，见[第14章](ch14.xhtml#ch14)——256位安全方案在可预见的未来也不太可能被破解。超过256位的安全性实际上是不必要的，除非作为一种营销手段。
- en: As NIST cryptographer John Kelsey once put it, “The difference between 80 bits
    and 128 bits of key search is like the difference between a mission to Mars and
    a mission to Alpha Centauri. As far as I can see, there is no meaningful difference
    between 192-bit and 256-bit keys in terms of practical brute-force attacks; impossible
    is impossible.”
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如NIST的密码学家约翰·凯尔西曾经说过的：“80位和128位密钥的搜索差异，就像是一次火星任务和一次阿尔法·仙女座任务之间的差异。据我所知，192位和256位密钥在实际暴力破解攻击中的差异并没有什么意义；不可能就是不可能。”
- en: Achieving Security
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现安全性
- en: Once you’ve chosen a security level, it’s important to guarantee that your cryptographic
    schemes will stick to it. In other words, you want *confidence*, not just hope
    and uncertainty, that things will work as planned, all the time.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择了安全等级，就必须确保你的加密方案能够维持这一等级。换句话说，你需要*信心*，而不仅仅是希望和不确定性，确保事情会按照计划始终如一地进行。
- en: When building confidence in the security of a crypto algorithm, you can rely
    on mathematical proofs, an approach called *provable security*, or on evidence
    of failed attempts to break the algorithm, which I’ll call *heuristic security*
    (though it’s sometimes called *probable* security). These two approaches are complementary
    and neither is better than the other, as you’ll see.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立对加密算法安全性的信心时，你可以依赖数学证明，这是一种称为*可证明安全性*的方法，或者依赖算法未被攻破的证据，这种方法我称之为*启发式安全性*（尽管它有时也被称为*可能的*安全性）。这两种方法是互补的，并没有哪一个比另一个更好，正如你将看到的那样。
- en: '*Provable Security*'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*可证明安全性*'
- en: Provable security is about proving that breaking your crypto scheme is at least
    as hard as solving another problem known to be hard. Such a *security proof* guarantees
    that the crypto remains safe as long as the hard problem remains hard. This type
    of proof is called a *reduction*, and it comes from the field of complexity theory.
    We say that breaking some cipher is reducible to problem X if any method to solve
    problem X also yields a method to break the cipher.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 可证明的安全性是指证明破解你的加密方案至少和解决另一个已知困难的问题一样困难。这样的*安全性证明*保证了只要困难问题仍然困难，加密就会保持安全。这种类型的证明叫做*简化*，它来自于复杂性理论领域。如果解决问题X的任何方法也能提供破解某个加密算法的方法，那么我们就说破解某个加密算法可以简化为问题X。
- en: 'Security proofs come in two flavors, depending on the type of presumably hard
    problem used: proofs relative to a mathematical problem and proofs relative to
    a cryptographic problem.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性证明有两种类型，取决于所使用的假定困难问题：与数学问题相关的证明和与加密问题相关的证明。
- en: Proofs Relative to a Mathematical Problem
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 与数学问题相关的证明
- en: Many security proofs (such as those for public-key crypto) show that breaking
    a crypto scheme is at least as hard as solving some hard mathematical problem.
    We’re talking of problems for which a solution is known to exist, and is easy
    to verify once it’s known, but is computationally hard to find.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 许多安全性证明（例如公共密钥加密的证明）表明，破解一个加密方案至少和解决某个困难的数学问题一样困难。我们讨论的是那些已知有解并且一旦知道其解就容易验证，但计算上很难找到解的问题。
- en: '**NOTE**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*There’s no real proof that seemingly hard math problems are actually hard.
    In fact, proving this for a specific class of problems is one of the greatest
    challenges in the field of complexity theory, and as I write this there is a $1,000,000
    bounty for anyone who can solve it, awarded by the Clay Mathematics Institute.
    This is discussed in more detail in [Chapter 9](ch09.xhtml#ch9).*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*没有真正的证明表明看似困难的数学问题确实是困难的。实际上，证明这一点对于某些特定类型的问题是复杂性理论领域的最大挑战之一，正如我写这段话时，Clay数学研究所为任何能解决这个问题的人提供100万美元的奖金。这一点将在[第9章](ch09.xhtml#ch9)中详细讨论。*'
- en: 'For example, consider the challenge of solving the *factoring problem*, which
    is the best-known math problem in crypto: given a number that you know is the
    product of two prime numbers (*n* = *pq*), find the said primes. For example,
    if *n* = 15, the answer is 3 and 5\. That’s easy for a small number, but it becomes
    exponentially harder as the size of the number grows. For example, if a number,
    *n*, is 3000 bits long (about 900 decimal digits) or more, factoring is believed
    to be practically infeasible.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑解决*分解问题*的挑战，这是加密中最著名的数学问题：给定一个已知是两个质数的乘积（*n* = *pq*）的数字，找出这两个质数。例如，如果 *n*
    = 15，答案是3和5。对于一个小数字来说，这是容易的，但随着数字大小的增加，问题变得指数级地困难。例如，如果一个数字 *n* 长度为3000位（大约900个十进制数字）或更多，分解被认为在实际中是不可行的。
- en: 'RSA is the most famous crypto scheme to rely on the factoring problem: RSA
    encrypts a plaintext, *P*, seen as a large number, by computing *C* = *P*^(*e*)
    mod *n*, where the number *e* and *n* = *pq* are the public key. Decryption recovers
    a plaintext from a ciphertext by computing *P* = *C*^(*d*) mod *n*, where *d*
    is the private key associated to *e* and *n*. If we can factor *n*, then we can
    break RSA (by recovering the private key from the public key), and if we can obtain
    the private key, then we can factor *n*; in other words, recovering an RSA private
    key and factoring *n* are equivalently hard problems. That’s the kind of reduction
    we’re looking for in provable security. However, there is no guarantee that recovering
    an RSA plaintext is as hard as factoring *n*, since the knowledge of a plaintext
    doesn’t reveal the private key.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: RSA是最著名的依赖于分解问题的加密方案：RSA通过计算 *C* = *P*^(*e*) mod *n* 加密一个明文 *P*，其中 *e* 和 *n*
    = *pq* 是公钥。解密则通过计算 *P* = *C*^(*d*) mod *n* 从密文恢复明文，其中 *d* 是与 *e* 和 *n* 相关联的私钥。如果我们能够分解
    *n*，就能破解RSA（通过从公钥恢复私钥），如果我们能获得私钥，就可以分解 *n*；换句话说，恢复RSA私钥和分解 *n* 是等价的困难问题。这就是我们在可证明安全性中寻找的那种简化。然而，没有保证恢复RSA明文与分解
    *n* 同样困难，因为知道明文并不会揭示私钥。
- en: Proofs Relative to Another Crypto Problem
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 另一个加密问题相关的证明
- en: Instead of comparing a crypto scheme to a math problem, you can compare it to
    another crypto scheme and prove that you can only break the second if you can
    break the first. Security proofs for symmetric ciphers usually follow this approach.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将一个加密方案与另一个加密方案进行比较，并证明只有在能够破解第一个的情况下，才能破解第二个来进行比较，而不是将加密方案与一个数学问题进行比较。对对称加密算法的安全证明通常采用这种方法。
- en: For example, if all you have is a single permutation algorithm, then you can
    build symmetric ciphers, random bit generators, and other crypto objects such
    as hash functions by combining calls to the permutations with various types of
    inputs (as you’ll see in [Chapter 6](ch06.xhtml#ch6)). Proofs then show that the
    newly created schemes are secure if the permutation is secure. In other words,
    we know for sure that the newly created algorithm is *not weaker* than the original
    one. Such proofs usually work by crafting an attack on the smaller component given
    an attack on the larger one—that is, by showing a reduction.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你只有一个置换算法，那么你可以通过将对置换的调用与各种输入类型相结合，构建对称加密算法、随机位生成器和其他加密对象（如哈希函数）（正如你将在[第六章](ch06.xhtml#ch6)中看到的）。然后，证明表明，如果置换算法是安全的，那么新创建的方案也是安全的。换句话说，我们可以确信新创建的算法*不弱于*原始算法。这类证明通常通过在较大的组件上进行攻击来展示较小组件的攻击——也就是通过展示一种简化的方式。
- en: 'When you’re proving that a crypto algorithm is no weaker than another, the
    main benefit is that of a reduced attack surface: instead of analyzing both the
    core algorithm and the combination, you can simply look at the new cipher’s core
    algorithm. Specifically, if you write a cipher that uses a newly developed permutation
    and a new combination, you may prove that the combination doesn’t weaken security
    compared to the core algorithm. Therefore, to break the combination, you need
    to break the new permutation.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当你证明一个加密算法不比另一个弱时，主要的好处是减少了攻击面：你可以只分析新加密算法的核心算法，而不必分析核心算法和组合的两者。具体来说，如果你写了一个使用新开发的置换和新组合的加密算法，你可以证明该组合在安全性上不弱于核心算法。因此，要破解该组合，你需要破解新的置换算法。
- en: Caveats
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Cryptography researchers rely heavily on security proofs, whether with respect
    to math problem schemes or to other crypto schemes. But the existence of a security
    proof does not guarantee that a cryptographic scheme is perfect, nor is it an
    excuse for neglecting the more practical aspects of implementation. After all,
    as cryptographer Lars Knudsen once said, “If it’s provably secure, it’s probably
    not,” meaning that a security proof shouldn’t be taken as an absolute guarantee
    of security. Worse, there are multiple reasons why a “provably secure” scheme
    may lead to a security failure.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学研究人员在很大程度上依赖于安全证明，无论是针对数学问题方案还是其他加密方案。然而，安全证明的存在并不保证一个加密方案是完美的，也不能成为忽视实现中更实际方面的借口。毕竟，正如密码学家拉尔斯·克努森曾经说过的，“如果它被证明是安全的，那它可能并不安全”，这意味着安全证明不应被视为安全的绝对保障。更糟糕的是，存在多种原因导致一个“可证明安全”的方案可能会导致安全失败。
- en: One issue is with the phrase “proof of security” itself. In mathematics, a proof
    is the demonstration of an *absolute truth*, but in crypto, a proof is only the
    demonstration of a *relative truth*. For example, a proof that your cipher is
    as hard to break as it is to compute discrete logarithms—finding the number *x*
    given *g* and *g*^(*x*) mod *n*—guarantees that if your cipher fails, a whole
    lot of other ciphers will fail as well, and nobody will blame you if the worst
    happens.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题在于“安全证明”这个词本身。在数学中，证明是展示*绝对真理*，但在密码学中，证明仅仅是展示*相对真理*。例如，证明你的加密算法像计算离散对数问题一样难以破解——给定*g*和*g*^(*x*)
    mod *n*，找出数字*x*——可以保证如果你的加密算法失败，那么很多其他的加密算法也会失败，而且如果最坏的情况发生了，没人会责怪你。
- en: Another caveat is that security proofs are usually proven with respect to a
    single notion of security. For example, you might prove that recovering the private
    key of a cipher is as hard as the factoring problem. But if you can recover plaintexts
    from ciphertext without the key, you’ll bypass the proof, and recovering the key
    hardly matters.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个警告是，安全证明通常是相对于单一的安全概念来证明的。例如，你可能证明恢复加密算法的私钥和因式分解问题一样困难。但是，如果你能够在没有密钥的情况下从密文中恢复明文，那么你就绕过了证明，而恢复密钥就不再重要。
- en: Then again, proofs are not always correct, and it may be easier to break an
    algorithm than originally thought.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，证明并不总是正确的，破解一个算法可能比最初想象的更容易。
- en: '**NOTE**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Unfortunately, few researchers carefully check security proofs, which commonly
    span dozens of pages, thus complicating quality control. That said, demonstrating
    that a proof is incorrect doesn’t necessarily imply that the proof’s goal is completely
    wrong; if the result is correct, the proof may be salvaged by correcting its errors.*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*不幸的是，很少有研究人员会仔细检查安全证明，这些证明通常长达几十页，因此增加了质量控制的复杂性。也就是说，证明不正确并不一定意味着证明的目标完全错误；如果结果是正确的，可能通过纠正错误来挽救证明。*'
- en: Another important consideration is that hard math problems sometimes turn out
    to be easier to solve than expected. For example, certain weak parameters make
    breaking RSA easy. Or the math problem may be hard in certain cases, but not on
    average, as often happens when the reference problem is new and not well understood.
    That’s what happened when the 1978 knapsack encryption scheme by Merkle and Hellman
    was later totally broken using lattice reduction techniques.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的考虑因素是，某些困难的数学问题有时可能比预期的更容易解决。例如，某些弱参数使得破解RSA变得简单。或者数学问题在某些情况下很难，但平均来看却并不难，这种情况通常发生在参考问题是新的且尚未完全理解时。1978年，Merkle和Hellman提出的背包加密方案就发生了这种情况，后来它被通过格减法技术完全破解。
- en: 'Finally, although the proof of an algorithm’s security may be fine, the implementation
    of the algorithm can be weak. For example, attackers may exploit side-channel
    information such as power consumption or execution time to learn about an algorithm’s
    internal operations in order to break it, thus bypassing the proof. Or implementers
    may misuse the crypto scheme: if the algorithm is too complicated with too many
    knobs to configure, chances are higher that the user or developer will get a configuration
    wrong, which may render the algorithm completely insecure.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，虽然一个算法的安全性证明可能没问题，但该算法的实现可能存在漏洞。例如，攻击者可能利用侧信道信息，如功耗或执行时间，来了解算法的内部操作，从而破解它，绕过安全证明。或者实现者可能错误地使用了加密方案：如果算法过于复杂，配置选项过多，用户或开发者出错的可能性就会增加，这可能会使算法变得完全不安全。
- en: '*Heuristic Security*'
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*启发式安全性*'
- en: Provable security is a great tool to gain confidence in a crypto scheme, but
    it doesn’t apply to all kinds of algorithms. In fact, most symmetric ciphers don’t
    have a security proof. For example, every day we rely on the Advanced Encryption
    Standard (AES) to securely communicate using our mobile phones, laptops, and desktop
    computers, but AES is not provably secure; there’s no proof that it’s as hard
    to break as some well-known problem. AES can’t be related to a math problem or
    to another algorithm because it is the hard problem itself.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 可证明的安全性是增加对加密方案信心的一个伟大工具，但并不适用于所有类型的算法。事实上，大多数对称加密算法没有安全性证明。例如，我们每天依赖高级加密标准（AES）通过手机、笔记本电脑和台式计算机安全地进行通信，但AES并没有可证明的安全性；没有证据表明它像一些著名的问题那样难以破解。AES不能与一个数学问题或其他算法关联，因为它本身就是一个难题。
- en: In cases where provable security doesn’t apply, the only reason to trust a cipher
    is because many skilled people tried to break it and failed. This is sometimes
    called *heuristic security*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在不可证明安全的情况下，唯一能信任一个密码的原因是因为许多经验丰富的人尝试过破解它并且失败了。这有时被称为*启发式安全性*。
- en: When can we be sure that a cipher is secure then? We can never be sure, but
    we can be pretty confident that an algorithm won’t be broken when hundreds of
    experienced cryptanalysts have each spent hundreds of hours trying to break it
    and published their findings—usually by attempting attacks on *simplified versions*
    of a cipher (often versions with fewer operations, or fewer *rounds*, which are
    short series of operations that ciphers iterate in order to mix bits together).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们何时能够确定一个密码是安全的呢？我们永远无法完全确定，但我们可以相当有信心地认为，当成百上千名经验丰富的密码分析师各自花费数百小时试图破解某个算法并发布了他们的研究结果——通常是通过攻击*简化版*的密码（通常是减少操作步骤或减少*轮数*，轮数是密码通过若干次操作来混合位的过程）——该算法不会被破解。
- en: When analyzing a new cipher, cryptanalysts first try to break one round, then
    two, three, or as many as they can. The *security margin* is then the difference
    between the total number of rounds and the number of rounds that were successfully
    attacked. When after years of study a cipher’s security margin is still high,
    we become confident that it’s (probably) secure.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析新的密码时，密码分析师首先尝试破解一轮，然后是两轮、三轮，或尽可能多的轮数。*安全余量*就是总轮数与成功攻击的轮数之间的差距。当经过多年的研究后，某个密码的安全余量仍然很高时，我们就能相当有信心地认为它是（可能是）安全的。
- en: Generating Keys
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成密钥
- en: If you plan to encrypt something, you’ll have to generate keys, whether they
    are temporary “session keys” (like the ones generated when browsing an HTTPS site)
    or long-term public keys. Recall from [Chapter 2](ch02.xhtml#ch2) that secret
    keys are the crux of cryptographic security and should be randomly generated so
    that they are unpredictable and secret.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划加密某些东西，你必须生成密钥，无论是临时的“会话密钥”（就像浏览HTTPS网站时生成的那种）还是长期的公钥。回想一下[第二章](ch02.xhtml#ch2)，秘密密钥是加密安全的关键，应该通过随机生成以确保其不可预测性和保密性。
- en: 'For example, when you browse an HTTPS website, your browser receives the site’s
    public key and uses it to establish a symmetric key that’s only valid for the
    current session, and that site’s public key and its associated private key may
    be valid for years. Therefore, it’d better be hard to find for an attacker. But
    generating a secret key isn’t always as simple as dumping enough pseudo­random
    bits. Cryptographic keys may be generated in one of three ways:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当你浏览HTTPS网站时，浏览器接收该站点的公钥，并利用它建立一个仅在当前会话有效的对称密钥，而该站点的公钥及其相关的私钥可能会有效多年。因此，它最好对于攻击者来说难以找到。但是，生成一个秘密密钥并不总是像提取足够多的伪随机比特那么简单。加密密钥可能通过以下三种方式之一生成：
- en: '*Randomly*, using a pseudorandom number generator (PRNG) and, when needed,
    a key-generation algorithm'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*随机地*，使用伪随机数生成器（PRNG），并在需要时，使用密钥生成算法。'
- en: From a *password*, using a key derivation function (KDF), which transforms the
    user-supplied password into a key
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一个*密码*出发，使用密钥派生函数（KDF），将用户提供的密码转化为密钥。
- en: Through a *key agreement protocol*, which is a series of message exchanges between
    two or more parties that ends with the establishment of a shared key
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过*密钥协商协议*，这是两个或更多方之间的一系列消息交换，最终建立共享密钥。
- en: 'For now, I’ll explain the simplest method: randomized generation.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我将解释最简单的方法：随机生成。
- en: '*Generating Symmetric Keys*'
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*生成对称密钥*'
- en: 'Symmetric keys are secret keys shared by two parties, and they are the simplest
    to generate. They are usually the same length as the security level they provide:
    a 128-bit key provides 128-bit security, and any of the 2^(128) possible keys
    is a valid one that can do the job as well as any other key.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对称密钥是由两方共享的秘密密钥，它们是最简单生成的。它们通常与它们所提供的安全级别长度相同：128位密钥提供128位的安全性，任何2^(128)个可能的密钥都是有效的，并且能够与其他任何密钥一样完成任务。
- en: 'To generate a symmetric key of *n* bits using a cryptographic PRNG, you simply
    ask it for *n* pseudorandom bits and use those bits as the key. That’s it. You
    can, for example, use the OpenSSL toolkit to generate a random symmetric key by
    dumping pseudorandom bytes, as in the following command (obviously, your result
    will differ from mine):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用加密PRNG生成一个*n*位的对称密钥，你只需向它请求*n*个伪随机比特，并将这些比特用作密钥。就这样。例如，你可以使用OpenSSL工具包通过提取伪随机字节来生成一个随机的对称密钥，如下命令所示（显然，你的结果与我的会有所不同）：
- en: '[PRE0]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Generating Asymmetric Keys*'
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*生成非对称密钥*'
- en: Unlike symmetric keys, asymmetric keys are usually longer than the security
    level they provide. But that’s not the main problem. Asymmetric keys are trickier
    to generate than symmetric ones because you can’t just dump *n* bits from your
    PRNG and get away with the result. Asymmetric keys aren’t just raw bit sequences;
    instead, they represent a specific type of object, such as a large number with
    specific properties (in RSA, a product of two primes). A random bit string value
    (and thus a random number) is unlikely to have the specific properties needed,
    and therefore won’t be a valid key.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与对称密钥不同，非对称密钥通常比它们所提供的安全级别更长。但这不是主要问题。非对称密钥比对称密钥更难生成，因为你不能仅仅从伪随机数生成器（PRNG）中提取*n*位并期望得到有效结果。非对称密钥不仅仅是原始的比特序列；它们代表一种特定类型的对象，比如具有特定属性的大数字（在RSA中是两个质数的积）。一个随机的比特串（因此也是一个随机数）不太可能具备所需的特定属性，因此不会是一个有效的密钥。
- en: To generate an asymmetric key, you send pseudorandom bits as a seed to a *key-generation
    algorithm*. This key-generation algorithm takes as input a seed value that’s at
    least as long as the intended security level and then constructs from it a private
    key and its respective public key, ensuring that both satisfy all the necessary
    criteria. For example, a naive key-generation algorithm for RSA would generate
    a number, *n* = *pq*, by using an algorithm to generate two random primes of about
    the same length. That algorithm would pick random numbers until one happens to
    be prime—so you’d also need an algorithm to test whether a number is prime.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成一个非对称密钥，你将伪随机位作为种子发送给*密钥生成算法*。这个密钥生成算法以一个至少与预定安全级别相同长度的种子值为输入，然后从中构建出私钥及其相应的公钥，确保两者都满足所有必要的标准。例如，一个简单的
    RSA 密钥生成算法会生成一个数字 *n* = *pq*，通过使用一个算法生成两个大约相同长度的随机素数。该算法会随机选择数字，直到其中一个恰好是素数——因此，你还需要一个算法来测试一个数字是否是素数。
- en: 'To save yourself the burden of manually implementing the key-generation algorithm,
    you can use OpenSSL to generate a 4096-bit RSA private key, like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免手动实现密钥生成算法的负担，你可以使用 OpenSSL 生成一个 4096 位的 RSA 私钥，像这样：
- en: '[PRE1]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that the key comes in a specific format—namely, base64-encoded data between
    the `BEGIN RSA PRIVATE KEY` and `END RSA PRIVATE KEY` markers. That’s a standard
    encoding format supported by most systems, which then convert this representation
    to raw bytes of data. The dot sequences at the beginning are a kind of progress
    bar, and `e is 65537 (0x10001)` indicates the parameter to use when encrypting
    (remember that RSA encrypts by computing *C* = *P*^(*e*) mod *n*).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，密钥是以特定格式呈现的——即，在 `BEGIN RSA PRIVATE KEY` 和 `END RSA PRIVATE KEY` 标记之间的 base64
    编码数据。这是大多数系统支持的标准编码格式，系统将此表示形式转换为原始字节数据。开始处的点序列是一种进度条，`e 是 65537（0x10001）` 表示加密时使用的参数（记住，RSA
    通过计算 *C* = *P*^(*e*) mod *n* 来加密）。
- en: '*Protecting Keys*'
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*保护密钥*'
- en: Once you have a secret key, you need to keep it secret, yet available when you
    need it. There are three ways to address this problem.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你拥有了一个秘密密钥，你需要保持它的机密性，同时确保在需要时可以使用它。有三种方法可以解决这个问题。
- en: '**Key wrapping (encrypting the key using a second key)**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**密钥封装（使用第二个密钥加密密钥）**'
- en: The problem with this approach is that the second key must be available when
    you need to decrypt the protected key. In practice, this second key is often generated
    from a password supplied by the user when he needs to use the protected key. That’s
    how private keys for the Secure Shell (SSH) protocol are usually protected.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的问题在于，第二个密钥必须在你需要解密受保护的密钥时可用。实际上，这个第二个密钥通常是由用户在需要使用受保护的密钥时提供的密码生成的。这就是如何保护安全外壳协议（SSH）中私钥的方式。
- en: '**On-the-fly generation from a password**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**从密码实时生成**'
- en: 'Here, no encrypted file needs to be stored because the key comes straight out
    from the password. Modern systems like miniLock use this method. Although this
    method is more direct than key wrapping, it’s less widespread, in part because
    it’s more vulnerable to weak passwords. Say, for example, that an attacker captured
    some encrypted message: if key wrapping was used, the attacker first needs to
    get the protected key file, which is usually stored locally on the user’s file
    system and therefore not easy to access. But if on-the-fly generation was used,
    the attacker can directly search for the correct password by attempting to decrypt
    the encrypted message with candidate passwords. And if the password is weak, the
    key is compromised.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，不需要存储加密文件，因为密钥直接来自密码。像 miniLock 这样的现代系统使用这种方法。尽管这种方法比密钥封装更直接，但它的应用不如密钥封装广泛，部分原因是它更容易受到弱密码的攻击。例如，如果攻击者截获了某个加密消息：如果使用了密钥封装，攻击者首先需要获取受保护的密钥文件，而该文件通常存储在用户的本地文件系统中，因此不容易访问。但如果使用了实时生成，攻击者可以通过尝试用候选密码解密加密消息，直接搜索正确的密码。如果密码较弱，密钥就会被破解。
- en: '**Storing the key on a hardware token (smart card or USB dongle)**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**将密钥存储在硬件令牌（智能卡或USB加密狗）上**'
- en: In this approach, the key is stored in secure memory and remains safe even if
    the computer is compromised. This is the safest approach to key storage, but also
    the costliest and least convenient because it requires you to carry the hardware
    token with you and run the risk of losing it. Smart cards and USB dongles usually
    require you to enter a password to unlock the key from the secure memory.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，密钥存储在安全内存中，即使计算机被攻破，它仍然保持安全。这是最安全的密钥存储方法，但也是最昂贵且最不方便的，因为它要求你随身携带硬件令牌，并且有丢失的风险。智能卡和USB加密狗通常需要输入密码来解锁存储在安全内存中的密钥。
- en: '**NOTE**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Whatever method you use, make sure not to mistake the private key for the
    public one when exchanging keys, and don’t accidentally publish the private key
    through email or source code. (I’ve actually found private keys on GitHub.)*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*无论使用何种方法，在交换密钥时务必确保不要将私钥误认为公钥，也不要通过电子邮件或源代码意外发布私钥。（我实际上在 GitHub 上发现过私钥。）*'
- en: 'To test key wrapping, run the OpenSSL command shown here with the argument
    `-aes128` to tell OpenSSL to encrypt the key with the cipher AES-128 (AES with
    a 128-bit key):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试密钥包装，请运行此处显示的OpenSSL命令，并使用参数`-aes128`告诉OpenSSL用AES-128（128位密钥的AES加密）来加密密钥：
- en: '[PRE2]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The passphrase requested will be used to encrypt the newly created key.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 系统将要求输入密码短语，用于加密新创建的密钥。
- en: How Things Can Go Wrong
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事物如何出错
- en: Cryptographic security can go wrong in many ways. The biggest risk is when we
    have a false sense of security thanks to security proofs or to well-studied protocols,
    as illustrated by the following two examples.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学安全可能以多种方式出错。最大的风险是，当我们因为安全证明或经过充分研究的协议而产生虚假的安全感时，如以下两个例子所示。
- en: '*Incorrect Security Proof*'
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*错误的安全证明*'
- en: Even proofs of security by renowned researchers may be wrong. One of the most
    striking examples of a proof gone terribly wrong is that of *Optimal Asymmetric
    Encryption Padding (OAEP)*, a method of secure encryption that used RSA and was
    implemented in many applications. Yet, an incorrect proof of OAEP’s security against
    chosen-ciphertext attackers was accepted as valid for seven years, until a researcher
    found the flaw in 2001\. Not only was the proof wrong, the result was wrong as
    well. A new proof later showed that OAEP is only almost secure against chosen-ciphertext
    attackers. We now have to trust the new proof and hope that it’s flawless. (For
    further details, see the 2001 paper “OAEP Reconsidered” by Victor Shoup.)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 即便是知名研究人员的安全证明也可能是错误的。最令人震惊的错误证明之一是*最优非对称加密填充（OAEP）*，这是一种使用RSA的安全加密方法，已被应用于许多应用程序。然而，OAEP对抗选择密文攻击者的安全性证明曾被错误地接受为有效长达七年，直到2001年一位研究员发现了其中的缺陷。不仅证明是错的，结论也是错的。后来一个新的证明显示，OAEP对选择密文攻击者几乎是安全的。我们现在必须相信这个新的证明，并希望它是无懈可击的。（更多详情，请参见Victor
    Shoup 2001年的论文《OAEP重新审视》）。
- en: '*Short Keys for Legacy Support*'
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*为兼容旧版支持使用短密钥*'
- en: 'In 2015, researchers found that some HTTPS sites and SSH servers supported
    public-key cryptography with shorter keys than expected: namely, 512 bits instead
    of at least 2048 bits. Remember, with public-key schemes, the security level isn’t
    equal to the key size, and in the case of HTTPS, keys of 512 bits offer a security
    level of approximately 60 bits. These keys could be broken after only about two
    weeks of computation using a cluster of 72 processors. Many websites were affected,
    including the FBI’s. Although the software was ultimately fixed (thanks to patches
    for OpenSSL and for other software), the problem was quite an unpleasant surprise.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 2015年，研究人员发现一些HTTPS网站和SSH服务器支持比预期更短的公钥加密：即512位，而不是至少2048位。请记住，在公钥方案中，安全性水平并不等同于密钥大小，对于HTTPS来说，512位密钥的安全性约为60位。这些密钥在仅使用72个处理器的集群计算大约两周后就能被破解。许多网站受到了影响，包括FBI的网站。尽管软件最终得到了修复（得益于OpenSSL和其他软件的补丁），但这个问题仍然是一个令人不快的惊讶。
- en: Further Reading
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: To learn more about provable security for symmetric ciphers, read the sponge
    functions documentation (*[http://sponge.noekeon.org/](http://sponge.noekeon.org/)*).
    Sponge functions introduced the permutation-based approach in symmetric crypto,
    which describes how to construct a bunch of different cryptographic functions
    using only one permutation.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于对称密码算法的可证明安全性，请阅读海绵函数文档（* [http://sponge.noekeon.org/](http://sponge.noekeon.org/)
    *）。海绵函数引入了基于置换的方法来进行对称加密，描述了如何仅使用一种置换构造一系列不同的加密函数。
- en: Some must-reads on the real cost of attacks include Bernstein’s 2005 paper “Understanding
    Brute Force” and Wiener’s 2004 paper “The Full Cost of Cryptanalytic Attacks,”
    both available online for free.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 关于攻击的实际成本，一些必读文献包括Bernstein于2005年发表的论文《理解暴力破解》和Wiener于2004年发表的论文《密码分析攻击的全部成本》，两篇文章都可以在线免费获取。
- en: To determine the security level for a given key size, visit *[http://www.keylength.com/](http://www.keylength.com/)*.
    This site also offers an explanation on how private keys are protected in common
    cryptographic utilities, such as SSH, OpenSSL, GnuPG, and so on.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定给定密钥长度的安全级别，请访问 *[http://www.keylength.com/](http://www.keylength.com/)*。该网站还提供了关于常见加密工具（如SSH、OpenSSL、GnuPG等）中如何保护私钥的解释。
- en: Finally, as an exercise, pick an application (such as a secure messaging application)
    and identify its crypto schemes, key length, and respective security levels. You’ll
    often find surprising inconsistencies, such as a first scheme providing a 256-bit
    security level but a second scheme providing only 100-bit security. The security
    of the whole system is often only as strong as that of its weakest component.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，作为一个练习，选择一个应用程序（如安全消息传递应用程序），并识别其加密方案、密钥长度和相应的安全级别。你常常会发现一些出乎意料的不一致性，例如，第一个方案提供256位的安全级别，而第二个方案仅提供100位安全级别。整个系统的安全性通常只与其最弱组件的安全性相当。
