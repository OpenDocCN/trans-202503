- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp> <samp class="SANS_Dogma_OT_Bold_B_11">CONTROL
    FLOW</samp>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp> <samp class="SANS_Dogma_OT_Bold_B_11">控制流</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: 'In this chapter, you’ll learn how to control the order in which individual
    statements are evaluated. We’ll start by going over expression statements and
    compound statements that define the work to be performed. We’ll then cover three
    kinds of statements that determine which code blocks are executed and in what
    order: selection, iteration, and jump statements.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何控制各个语句求值的顺序。我们将从表达式语句和复合语句开始，它们定义了要执行的工作。然后，我们将讨论三种语句，它们决定了哪些代码块被执行以及执行的顺序：选择语句、迭代语句和跳转语句。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Expression Statements</samp>
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">表达式语句</samp>
- en: An *expression statement* is an optional expression terminated by a semicolon.
    It’s one of the most common statements and a basic unit of work. The following
    examples show different expression statements.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*表达式语句*是一个可选的表达式，以分号结束。它是最常见的语句之一，也是基本的工作单元。以下示例展示了不同的表达式语句。
- en: 'Assigns a value to <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个值赋给<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Assigns the sum of <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 将<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>的和赋值给<samp
    class="SANS_TheSansMonoCd_W5Regular_11">c</samp>：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A null statement:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 空语句：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can use a null statement when the syntax of the language requires a statement
    but no expression needs to be evaluated. Null statements are commonly used as
    placeholders in iteration statements.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当语言的语法要求一个语句但不需要求值表达式时，可以使用空语句。空语句通常用作迭代语句中的占位符。
- en: 'The following expression statement increments the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp>:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表达式语句将递增<samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp>的值：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After each full expression has been evaluated, its value (if any) is discarded
    (including assignment expressions in which the assignment itself is a side effect
    of the operation) so that any useful results occur as the consequence of side
    effects (as discussed in [Chapter 4](chapter4.xhtml)). Three of the four expression
    statements in this example have side effects (the null statement does nothing).
    Once all side effects have completed, execution proceeds to the statement following
    the semicolon.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个完整的表达式被求值之后，它的值（如果有的话）会被丢弃（包括赋值表达式，其中赋值本身是操作的副作用），以便任何有用的结果作为副作用的结果发生（如[第4章](chapter4.xhtml)所讨论）。在这个例子中，四个表达式语句中的三个都有副作用（空语句不执行任何操作）。一旦所有副作用完成，执行将继续进行到分号后的语句。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Compound Statements</samp>
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">复合语句</samp>
- en: 'A *compound statement*, or *block*, is a list of zero or more statements, surrounded
    by braces. The statements in the block may be any kind of statement described
    throughout this chapter. Some of these statements may be declarations. (In early
    versions of C, declarations within the block had to precede all nondeclarations,
    but that restriction no longer applies.) Each statement in the block is executed
    in sequence unless modified by a control statement. After the final statement
    has been evaluated, execution proceeds to after the closing brace:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*复合语句*，或称为*代码块*，是由零个或多个语句组成的列表，括在大括号内。代码块中的语句可以是本章中描述的任何类型的语句。其中一些语句可能是声明。（在早期的C语言版本中，块内的声明必须出现在所有非声明之前，但这个限制现在不再适用。）除非被控制语句修改，否则代码块中的每个语句都会按顺序执行。在最后一个语句执行完后，执行将继续进行到闭括号之后：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This example declares a static variable of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    called <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp>. The second
    line increases a variable <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    declared in an outer scope by the value stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>.
    Finally, <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> is incremented
    to track how many times this block has been executed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子声明了一个名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> 的静态变量，类型为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>。第二行通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    中存储的值增加了在外部作用域中声明的变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>。最后，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">count</samp> 被递增，用来追踪此代码块被执行的次数。
- en: Compound statements can be nested so that one compound statement fully encloses
    another. You may also have blocks with no statements at all (just the empty braces).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 复合语句可以嵌套，以便一个复合语句完全包含另一个。你还可以有没有任何语句的代码块（只是空的大括号）。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Selection Statements</samp>
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">选择语句</samp>
- en: '*Selection statements* allow you to conditionally execute a substatement depending
    on the value of a controlling expression. The *controlling expression* determines
    which statements are executed based on a condition. Selection statements include
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement and the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*选择语句* 允许你根据控制表达式的值有条件地执行子语句。*控制表达式* 决定了根据条件执行哪些语句。选择语句包括 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    语句和 <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> 语句。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">if</samp>
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">if</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement allows
    a programmer to execute a substatement based on the value of a controlling expression
    of scalar type.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句允许程序员根据标量类型的控制表达式的值来执行子语句。
- en: 'There are two kinds of <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements. The first conditionally determines whether the substatement is executed:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句。第一种根据条件有条件地决定是否执行子语句：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this case, the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">substatement</samp>
    is executed if the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression</samp>
    is not equal to 0\. Only the single <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">substatement</samp>
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement is conditionally
    executed, although it can be a compound statement.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">表达式</samp>
    不等于 0，<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">子语句</samp> 就会被执行。只有
    <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句的单个 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">子语句</samp>
    会根据条件执行，尽管它也可以是一个复合语句。
- en: '[Listing 5-1](chapter5.xhtml#Lis5-1) shows a division function that uses <samp
    class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements. It divides a specified
    dividend by a specified divisor and returns the result in the object referenced
    by <samp class="SANS_TheSansMonoCd_W5Regular_11">quotient</samp>. The function
    tests for both division by zero and signed integer overflow and returns <samp
    class="SANS_TheSansMonoCd_W5Regular_11">false</samp> in either case.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-1](chapter5.xhtml#Lis5-1) 显示了一个使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    语句的除法函数。它将指定的被除数除以指定的除数，并将结果返回到 <samp class="SANS_TheSansMonoCd_W5Regular_11">quotient</samp>
    所引用的对象中。该函数测试了除以零和有符号整数溢出，并在这两种情况下返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>。'
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-1: A safe division
    function</samp>'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 5-1：一个安全的除法函数</samp>
- en: The first line of this function ❶ tests <samp class="SANS_TheSansMonoCd_W5Regular_11">quotient</samp>
    to ensure that it’s not null. If it is null, the function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>
    to indicate that it is unable to return a value. (We cover <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statements later in this chapter.)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的第一行 ❶ 测试 <samp class="SANS_TheSansMonoCd_W5Regular_11">quotient</samp> 以确保它不为
    null。如果为 null，函数返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>，表示无法返回值。（我们将在本章后面介绍
    <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> 语句。）
- en: The second line of the function ❷ contains a more complex <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement. Its controlling expression tests whether the divisor is 0 or whether
    the division would result in signed integer overflow if unchecked. If the result
    of this expression is not equal to 0, the function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>
    ❸ to indicate that it is unable to produce a quotient. If the controlling expression
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement evaluates
    to 0, the function does not return, and the remaining statements ❹ are executed
    to calculate the quotient and return <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的第二行❷包含一个更复杂的 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句。其控制表达式测试除数是否为
    0，或者如果不检查除法是否会导致符号整数溢出。如果该表达式的结果不等于 0，函数返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>
    ❸，表示无法得到商。如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句的控制表达式计算结果为
    0，函数不返回，并且执行剩余语句❹来计算商并返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>。
- en: 'The second kind of <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement includes an <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    clause, which selects an alternative substatement to execute when the initial
    substatement is not selected:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句包含一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    子句，当初始子语句未被选择时，选择一个替代子语句执行：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this form, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">substatement1</samp>
    is executed if <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression</samp>
    is not equal to 0, and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">substatement2</samp>
    is executed if <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression</samp>
    is equal to 0\. One of these substatements is executed, but never both.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种形式下，如果 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression</samp>
    不等于 0，则执行 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">substatement1</samp>，如果
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression</samp> 等于 0，则执行
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">substatement2</samp>。这些子语句中会执行一个，但永远不会同时执行。
- en: For either form of the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement, the conditionally executed substatement may also be an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement. A common use of this is the <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp>
    ladder, shown in [Listing 5-2](chapter5.xhtml#Lis5-2).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何形式的 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句，条件执行的子语句也可以是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句。这种常见用法就是 <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp>
    阶梯，如[列表 5-2](chapter5.xhtml#Lis5-2)所示。
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-2: The</samp> <samp
    class="I">if...else</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">ladder
    syntax</samp>'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 5-2：The</samp> <samp class="I">if...else</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">阶梯语法</samp>
- en: 'One (and only one) of the four statements in an <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp>
    ladder will execute:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp> 阶梯中，四个语句中（且仅有一个）会执行：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">substatement1</samp>
    executes if <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expr1</samp>
    does not equal 0.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">substatement1</samp>
    在 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expr1</samp> 不等于 0 时执行。
- en: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">substatement2</samp>
    executes if <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expr1</samp>
    equals 0 and if <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expr2</samp>
    does not equal 0.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">substatement2</samp>
    在 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expr1</samp> 等于 0 且 <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expr2</samp> 不等于 0 时执行。
- en: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">substatement3</samp>
    executes if both <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expr1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expr2</samp> equal
    0 and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expr3</samp> does
    not equal 0.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">substatement3</samp>
    在 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expr1</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expr2</samp> 都等于 0 且 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expr3</samp>
    不等于 0 时执行。
- en: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">substatement4</samp>
    executes only if the preceding conditions are all equal to 0.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">substatement4</samp>
    仅在前面的所有条件都为 0 时执行。
- en: The example shown in [Listing 5-3](chapter5.xhtml#Lis5-3) uses an <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp>
    ladder to print grades.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-3](chapter5.xhtml#Lis5-3)中的例子使用了一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp>
    结构来打印成绩。'
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-3: Using an</samp>
    <samp class="I">if...else</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">ladder
    to print grades</samp>'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 5-3：使用</samp> <samp class="I">if...else</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">结构打印成绩</samp>
- en: 'In this <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp> ladder,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">printgrade</samp> function tests
    the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>
    parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">marks</samp> to determine
    whether it is greater than or equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">90</samp>.
    If so, the function prints <samp class="SANS_TheSansMonoCd_W5Regular_11">YOUR
    GRADE : A</samp>. Otherwise, it tests whether <samp class="SANS_TheSansMonoCd_W5Regular_11">marks</samp>
    is greater than or equal to 80, and so forth down the <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp>
    ladder. If <samp class="SANS_TheSansMonoCd_W5Regular_11">marks</samp> is not greater
    than or equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">70</samp>, the
    function prints <samp class="SANS_TheSansMonoCd_W5Regular_11">YOUR GRADE : Failed</samp>.
    This example uses a coding style in which the closing brace is followed by the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> clause on the same line.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个 <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp> 结构中，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">printgrade</samp> 函数测试 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp> 参数 <samp class="SANS_TheSansMonoCd_W5Regular_11">marks</samp> 的值，判断它是否大于或等于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">90</samp>。如果是，函数打印 <samp class="SANS_TheSansMonoCd_W5Regular_11">YOUR
    GRADE : A</samp>。否则，函数会测试 <samp class="SANS_TheSansMonoCd_W5Regular_11">marks</samp>
    是否大于或等于 80，依此类推，直到 <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp>
    结构的末尾。如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">marks</samp> 不大于或等于 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">70</samp>，则函数打印 <samp class="SANS_TheSansMonoCd_W5Regular_11">YOUR
    GRADE : Failed</samp>。这个例子使用了一种编码风格，其中闭合括号与 <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    子句写在同一行。'
- en: 'Only a single statement following the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement is executed. For example, in the following code snippet, <samp class="SANS_TheSansMonoCd_W5Regular_11">conditionally_executed</samp>
    is executed only if <samp class="SANS_TheSansMonoCd_W5Regular_11">condition</samp>
    is not equal to 0, but <samp class="SANS_TheSansMonoCd_W5Regular_11">unconditionally_executed</samp>
    is always executed:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 只有紧跟在 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句后的单个语句会被执行。例如，在下面的代码片段中，只有当
    <samp class="SANS_TheSansMonoCd_W5Regular_11">condition</samp> 不等于 0 时，<samp class="SANS_TheSansMonoCd_W5Regular_11">conditionally_executed</samp>
    才会执行，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">unconditionally_executed</samp>
    总是会执行：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Attempting to add another conditionally executed function is a common source
    of errors:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试添加另一个条件执行的函数是一个常见的错误来源：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this code snippet, <samp class="SANS_TheSansMonoCd_W5Regular_11">also_conditionally_executed</samp>
    is *unconditionally* executed. The name and indented formatting are deceptive
    because whitespace (in general) and indentation (in particular) are meaningless
    to the syntax. This code can be fixed by adding braces to delimit a single compound
    statement or block. This block is then executed as the single conditionally executed
    statement:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，<samp class="SANS_TheSansMonoCd_W5Regular_11">also_conditionally_executed</samp>
    是 *无条件* 执行的。变量名和缩进格式是误导性的，因为空格（一般而言）和缩进（特别是）对语法没有意义。通过添加大括号来限定一个复合语句或代码块，可以修复这段代码。然后，这个代码块作为单一的条件执行语句执行：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'While the original code snippet was not incorrect, many coding guidelines recommend
    always including braces to avoid this kind of error:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然原始代码片段并不错误，但许多编码规范建议始终包括大括号，以避免这种错误：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'My personal style is to omit the braces only when I can include the conditionally
    executed statement on the same line as the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我的个人风格是，仅当我能将条件执行语句与 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    语句写在同一行时，才省略大括号：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This issue is less problematic when you let your integrated development environment
    (IDE) format your code for you, as it won’t be fooled by code indentation when
    formatting your code. The GCC and Clang compilers provide a <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wmisleading-indentation</samp>
    compiler flag that checks code indentation and warns when it doesn’t correspond
    to the control flow.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当你让集成开发环境（IDE）为你格式化代码时，这个问题就不那么严重了，因为它不会被代码缩进迷惑。GCC 和 Clang 编译器提供了 <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wmisleading-indentation</samp>
    编译器标志，检查代码缩进并在其与控制流不符时发出警告。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">switch</samp>
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">switch</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement works
    just like the <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp> ladder,
    except that the controlling expression must have an integer type. For example,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement in [Listing
    5-4](chapter5.xhtml#Lis5-4) performs the same function as the <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp>
    ladder from [Listing 5-3](chapter5.xhtml#Lis5-3), provided that <samp class="SANS_TheSansMonoCd_W5Regular_11">marks</samp>
    is an integer in the range of 0 to 109\. If <samp class="SANS_TheSansMonoCd_W5Regular_11">marks</samp>
    is greater than 109, it will result in a failed grade because the resulting quotient
    will be greater than 10 and will consequently be caught by the default case.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> 语句的工作方式类似于 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp> 语句梯，唯一不同的是控制表达式必须是整数类型。例如，[Listing
    5-4](chapter5.xhtml#Lis5-4) 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    语句与 [Listing 5-3](chapter5.xhtml#Lis5-3) 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp>
    语句执行相同的功能，前提是 <samp class="SANS_TheSansMonoCd_W5Regular_11">marks</samp> 是一个 0
    到 109 之间的整数。如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">marks</samp> 大于 109，将导致成绩不及格，因为结果商会大于
    10，最终会被默认的 case 捕获。
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-4: Using a</samp>
    <samp class="I">switch</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement
    to print out grades</samp>'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-4: 使用</samp> <samp
    class="I">switch</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">语句输出成绩</samp>'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement causes
    control to jump to one of the three substatements, depending on the value of the
    controlling expression and the constant expressions in each <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>
    label. Following the jump, code is executed sequentially until the next control
    flow statement is reached. In our example, a jump to <samp class="SANS_TheSansMonoCd_W5Regular_11">case
    10</samp> (which is empty) flows through and executes the subsequent statements
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">case 9</samp>. This is necessary
    to the logic so that a perfect grade of 100 results in an A and not an F.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> 语句根据控制表达式的值和每个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">case</samp> 标签中的常量表达式，控制跳转到三个子语句之一。跳转后，代码按顺序执行，直到遇到下一个控制流语句。在我们的例子中，跳转到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">case 10</samp>（该语句为空）后，会继续执行 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">case 9</samp> 中的后续语句。这是逻辑所必需的，以确保完美的 100
    分会导致 A，而不是 F。
- en: You can terminate the execution of the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    by inserting a <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement,
    causing control to jump to the execution of the statement directly following the
    overall <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement.
    (We discuss <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statements
    in more detail later in this chapter.) Make sure you remember to include a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement before the next
    <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp> label. If omitted, the
    control flow falls through to the next <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement—a
    common source of errors. Because the <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    statement isn’t required, omitting it doesn’t typically produce compiler diagnostics.
    GCC issues a warning for fall-through if you use the <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wimplicit-fallthrough</samp>
    flag. The C23 standard introduces the <samp class="SANS_TheSansMonoCd_W5Regular_11">[[fallthrough]]</samp>
    attribute as a way for a programmer to specify that fall-through behavior is desirable,
    under the assumption that silent fall-through is an accidental omission of a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过插入一个<samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>语句来终止<samp
    class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>语句的执行，控制将跳转到紧跟在整体<samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>语句之后的语句。（我们将在本章稍后详细讨论<samp
    class="SANS_TheSansMonoCd_W5Regular_11">break</samp>语句。）确保在下一个<samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>标签之前包含一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">break</samp>语句。如果漏掉了，控制流将直接跳到下一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">case</samp>，这是常见的错误来源。由于<samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>语句并不是必须的，漏掉它通常不会产生编译器诊断。如果使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-Wimplicit-fallthrough</samp>标志，GCC会对fall-through情况发出警告。C23标准引入了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">[[fallthrough]]</samp>属性，允许程序员指定fall-through行为是期望的，前提是认为默默的fall-through是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">break</samp>语句的意外遗漏。
- en: Integer promotions are performed on the controlling expression. The constant
    expression in each <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp> label
    is converted to the promoted type of the controlling expression. If a converted
    value matches that of the promoted controlling expression, control jumps to the
    statement following the matched <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>
    label. Otherwise, if there is no match but there is a <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp>
    label, control jumps to the labeled statement. If no converted <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>
    constant expression matches and there is no <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp>
    label, no part of the switch body is executed. When <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    statements are nested, a <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp> label is accessible
    only within the closest enclosing <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    statement.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 整型提升发生在控制表达式上。每个<samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>标签中的常量表达式会被转换为控制表达式的提升类型。如果转换后的值与提升后的控制表达式匹配，控制将跳转到匹配的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">case</samp>标签后面的语句。否则，如果没有匹配的结果但有一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">default</samp>标签，控制将跳转到该标签指向的语句。如果没有任何转换后的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">case</samp>常量表达式匹配，并且没有<samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp>标签，则不会执行<samp
    class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>体中的任何部分。当<samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>语句嵌套时，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">case</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp>标签仅在最靠近的外层<samp
    class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>语句中可访问。
- en: There are best practices regarding the use of <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    statements. [Listing 5-5](chapter5.xhtml#Lis5-5) shows a less-than-ideal implementation
    of a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement that
    assigns interest rates to an account based on the account type. The <samp class="SANS_TheSansMonoCd_W5Regular_11">AccountType</samp>
    enumeration represents the fixed number of account types offered by the bank.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> 语句有一些最佳实践。[列表
    5-5](chapter5.xhtml#Lis5-5) 显示了一个不太理想的 <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    语句实现，它根据账户类型为账户分配利率。<samp class="SANS_TheSansMonoCd_W5Regular_11">AccountType</samp>
    枚举表示银行提供的固定数量的账户类型。
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-5: A</samp> <samp
    class="I">switch</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement
    without a</samp> <samp class="I">default</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">label</samp>'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 5-5：一个没有</samp> <samp class="I">default</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">标签的</samp> <samp class="I">switch</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">语句</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">assignInterestRate</samp>
    function defines a single parameter of the enumeration type <samp class="SANS_TheSansMonoCd_W5Regular_11">AccountType</samp>
    and switches on it to assign the appropriate interest rate associated with each
    account type.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">assignInterestRate</samp> 函数定义了一个枚举类型参数
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AccountType</samp>，并基于它进行切换，分配与每个账户类型相关的适当利率。
- en: 'Nothing is wrong with the code as written, but it requires programmers to update
    the code in at least two separate places if they want to make any changes. Let’s
    say the bank introduces a new type of account: a certificate of deposit. A programmer
    updates the <samp class="SANS_TheSansMonoCd_W5Regular_11">AccountType</samp> enumeration
    as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 代码本身没有问题，但如果程序员想要进行更改，就需要在至少两个不同的地方更新代码。假设银行引入了一种新的账户类型：定期存款证书。程序员更新了 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AccountType</samp> 枚举，如下所示：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: However, if the programmer neglects to modify the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    statement in the <samp class="SANS_TheSansMonoCd_W5Regular_11">assignInterestRate</samp>
    function, the <samp class="SANS_TheSansMonoCd_W5Regular_11">interest_rate</samp>
    isn’t assigned, resulting in an uninitialized read when the function attempts
    to print that value. This problem is common because the enumeration may be declared
    far from the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement,
    and the program may contain many similar <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    statements that all reference an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">AccountType</samp>
    in their controlling expression.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果程序员未能修改 <samp class="SANS_TheSansMonoCd_W5Regular_11">assignInterestRate</samp>
    函数中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> 语句，<samp class="SANS_TheSansMonoCd_W5Regular_11">interest_rate</samp>
    将不会被赋值，导致在函数尝试打印该值时出现未初始化读取的错误。这个问题很常见，因为枚举可能被声明在离 <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    语句很远的地方，而程序中可能包含许多类似的 <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    语句，它们都在控制表达式中引用了一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">AccountType</samp>
    类型的对象。
- en: Both Clang and GCC help diagnose these problems at compilation time when you
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wswitch-enum</samp> flag.
    Alternatively, you can protect against such errors and improve the testability
    of this code by adding this <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp>
    case to the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement,
    as shown in [Listing 5-6](chapter5.xhtml#Lis5-6).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是 Clang 还是 GCC，当你使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wswitch-enum</samp>
    标志时，它们都能在编译时帮助诊断这些问题。或者，你可以通过在 <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    语句中添加 <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp> 情况来防止此类错误，并提高此代码的可测试性，如
    [列表 5-6](chapter5.xhtml#Lis5-6) 所示。
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-6: A</samp> <samp
    class="I">switch</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement
    with a</samp> <samp class="I">default</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">label</samp>'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 5-6：一个有</samp> <samp class="I">default</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">标签的</samp> <samp class="I">switch</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">语句</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement now
    includes a case for <samp class="SANS_TheSansMonoCd_W5Regular_11">CD</samp>, and
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp> clause is unused.
    However, retaining the <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp>
    clause is good practice, in case another account type is added in the future.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> 语句现在包含了一个针对 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CD</samp> 的案例，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp>
    子句没有被使用。然而，保留 <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp> 子句是一个好习惯，以防将来添加了其他账户类型。
- en: 'Including a <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp> clause
    does have the drawback of suppressing compiler warnings and not diagnosing the
    problem until runtime. Compiler warnings (if supported by your compiler) are therefore
    a better approach.  ## <samp class="SANS_Futura_Std_Bold_B_11">Iteration Statements</samp>'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 包括 <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp> 子句的缺点是抑制了编译器警告，且在运行时才会诊断出问题。因此，编译器警告（如果编译器支持的话）通常是更好的方法。##
    <samp class="SANS_Futura_Std_Bold_B_11">迭代语句</samp>
- en: '*Iteration statements* cause substatements (or compound statements) to be executed
    zero or more times, subject to termination criteria. The English word *iteration*
    means “the repetition of a process.” Iteration statements are more informally
    and commonly referred to as loops. A *loop* is “a process, the end of which is
    connected to the beginning.”'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*迭代语句* 使子语句（或复合语句）在满足终止条件的情况下执行零次或多次。英文单词 *iteration* 的意思是“一个过程的重复”。迭代语句更常见的非正式称呼是循环。*循环*
    是“一个过程，其结尾与开头相连。”'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">while</samp>
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">while</samp>
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> statement causes
    the loop body to execute repeatedly until the controlling expression is equal
    to 0\. The evaluation of the controlling expression occurs before each execution
    of the loop body. Consider the following example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> 语句导致循环体反复执行，直到控制表达式的值等于
    0。在每次执行循环体之前，会先评估控制表达式。考虑以下示例：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is not initially greater
    than 0, the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop exits
    without executing the loop body. If <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    is greater than 0, its value is output and then decremented. Once the end of the
    loop is reached, the controlling expression is tested again. This pattern repeats
    until the expression evaluates to 0\. Overall, this loop will count down from
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> to 1.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 初始值不大于 0，<samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    循环会在不执行循环体的情况下退出。如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 大于
    0，则输出其值，然后将其递减。一旦到达循环末尾，将再次测试控制表达式。这个模式会一直重复，直到表达式的值为 0。总体来说，这个循环会从 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    递减到 1。
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop is an entry-controlled
    loop that executes until its controlling expression evaluates to 0\. [Listing
    5-7](chapter5.xhtml#Lis5-7) shows an implementation of the C standard library
    <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> function. This function
    copies the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">val</samp> (converted
    to an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>) into
    each of the first <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> characters
    of the object pointed to by <samp class="SANS_TheSansMonoCd_W5Regular_11">dest</samp>.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> 循环是一个入口控制的循环，直到其控制表达式的值为
    0 时才会终止。[列表 5-7](chapter5.xhtml#Lis5-7)展示了 C 标准库 <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp>
    函数的实现。该函数将 <samp class="SANS_TheSansMonoCd_W5Regular_11">val</samp>（转换为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> 类型）的值复制到由 <samp class="SANS_TheSansMonoCd_W5Regular_11">dest</samp>
    指向的对象的前 <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> 个字符中。
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-7: The C standard
    library</samp> <samp class="I">memset</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 5-7：C 标准库</samp> <samp class="I">memset</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">函数</samp>
- en: The first line of the <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp>
    function converts <samp class="SANS_TheSansMonoCd_W5Regular_11">dest</samp> to
    a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>
    and assigns the resulting value to the <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> pointer <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>.
    This lets us preserve the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">dest</samp>
    to return on the last line of the function. The remaining two lines of the function
    form a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop that copies
    the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">val</samp> (converted
    to an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>) into
    each of the first <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> characters
    of the object <samp class="SANS_TheSansMonoCd_W5Regular_11">dest</samp> points
    to. The controlling expression of the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop tests that <samp class="SANS_TheSansMonoCd_W5Regular_11">n-- > 0</samp>.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> 函数的第一行将 <samp class="SANS_TheSansMonoCd_W5Regular_11">dest</samp>
    转换为指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> 的指针，并将结果赋值给
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> 指针 <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>。这使得我们能够保留
    <samp class="SANS_TheSansMonoCd_W5Regular_11">dest</samp> 的值，以便在函数的最后一行返回。该函数的其余两行组成一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> 循环，将值 <samp class="SANS_TheSansMonoCd_W5Regular_11">val</samp>（转换为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>）复制到 <samp class="SANS_TheSansMonoCd_W5Regular_11">dest</samp>
    所指向的对象的前 <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> 个字符中。<samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    循环的控制表达式测试 <samp class="SANS_TheSansMonoCd_W5Regular_11">n-- > 0</samp>。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> argument is a loop
    counter that’s decremented on each iteration of the loop as a side effect of the
    evaluation of the controlling expression. The loop counter in this case monotonically
    decreases until it reaches the minimum value (0). The loop performs <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>
    repetitions, where <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> is less
    than or equal to the bound of the memory that <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    references.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> 参数是一个循环计数器，在每次迭代时作为控制表达式的副作用递减。在这种情况下，循环计数器单调递减，直到达到最小值（0）。该循环执行
    <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> 次重复，其中 <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>
    小于或等于 <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> 引用的内存边界。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> pointer designates
    a sequence of objects of type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp>, from <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> through
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">n - 1</samp>. The value of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">val</samp> is converted to an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> and written to each object in turn. If <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>
    is greater than the bound of the object that <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    references, the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop
    writes to memory outside the bounds of this object. This is undefined behavior
    and a common security flaw, referred to as a *buffer overflow*, or *overrun*.
    Provided the object referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    has at least <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> bytes, the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop terminates without
    undefined behavior. In the final iteration of the loop, the controlling expression
    <samp class="SANS_TheSansMonoCd_W5Regular_11">n-- > 0</samp> evaluates to 0, causing
    the loop to terminate.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <​samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>指针表示一系列<​samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp>类型的对象，从<​samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>到<​samp
    class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> <​samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <​samp class="SANS_TheSansMonoCd_W5Regular_11">n - 1</samp>。<​samp class="SANS_TheSansMonoCd_W5Regular_11">val</samp>的值被转换为<​samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>并依次写入每个对象。如果<​samp
    class="SANS_TheSansMonoCd_W5Regular_11">n</samp>大于<​samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>引用的对象的边界，<​samp
    class="SANS_TheSansMonoCd_W5Regular_11">while</samp>循环会写入该对象的边界之外的内存。这是未定义的行为，通常称为*缓冲区溢出*或*溢出*。如果<​samp
    class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>引用的对象至少有<​samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>个字节，<​samp
    class="SANS_TheSansMonoCd_W5Regular_11">while</samp>循环将不会发生未定义的行为而终止。在循环的最后一次迭代中，控制表达式<​samp
    class="SANS_TheSansMonoCd_W5Regular_11">n-- > 0</samp>的值为0，导致循环终止。
- en: It’s possible to write an *infinite loop*—a loop that never terminates. To avoid
    writing a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop that
    inadvertently runs forever, be sure you initialize any objects referenced by the
    controlling expression before the start of the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop. Also make sure that the controlling expression changes during the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop’s execution in a manner
    that causes the loop to terminate after iterating an appropriate number of times.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编写一个*无限循环*——一个永远不会终止的循环。为了避免编写一个无意中永远运行的<​samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>循环，请确保在<​samp
    class="SANS_TheSansMonoCd_W5Regular_11">while</samp>循环开始之前初始化由控制表达式引用的任何对象。同时，确保在<​samp
    class="SANS_TheSansMonoCd_W5Regular_11">while</samp>循环执行过程中，控制表达式以一种方式发生变化，导致循环在适当的迭代次数后终止。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">do...while</samp>
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <​samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">do...while</samp>
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">do...while</samp> statement
    is similar to the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> statement,
    except that the evaluation of the controlling expression occurs after each execution
    of the loop body rather than before. As a result, the loop body is guaranteed
    to execute once before the condition is tested. The <samp class="SANS_TheSansMonoCd_W5Regular_11">do...while</samp>
    iteration statement has the following syntax:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: <​samp class="SANS_TheSansMonoCd_W5Regular_11">do...while</samp>语句与<​samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>语句相似，不同之处在于，控制表达式的评估发生在每次执行循环体之后，而不是之前。因此，保证循环体在测试条件之前至少执行一次。<​samp
    class="SANS_TheSansMonoCd_W5Regular_11">do...while</samp>迭代语句具有以下语法：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In a <samp class="SANS_TheSansMonoCd_W5Regular_11">do...while</samp> iteration,
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">statement</samp> is unconditionally
    executed once, after which <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression</samp>
    is evaluated. If <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression</samp>
    is not equal to 0, control returns to the top of the loop and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">statement</samp>
    is executed again. Otherwise, execution passes to the statement following the
    loop.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在<samp class="SANS_TheSansMonoCd_W5Regular_11">do...while</samp>迭代中，<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">statement</samp>会无条件执行一次，然后对<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression</samp>进行求值。如果<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression</samp>不等于0，则控制返回到循环的顶部，重新执行<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">statement</samp>。否则，执行跳转到循环后的语句。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">do...while</samp> iteration
    statement is commonly used in input/output (I/O), where it makes sense to read
    from a stream before testing the state of the stream, as shown in [Listing 5-8](chapter5.xhtml#Lis5-8).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">do...while</samp>迭代语句通常用于输入/输出（I/O）中，在这种情况下，在测试流状态之前从流中读取数据是有意义的，如[清单5-8](chapter5.xhtml#Lis5-8)所示。
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-8: An input loop</samp>'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 5-8: 一个输入循环</samp>'
- en: This code inputs a floating-point quantity, a unit of measure (as a string),
    and an item name (also as a string) from the standard input stream <samp class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp>
    until the end-of-file indicator has been set or a read error has occurred. We’ll
    discuss I/O in detail in [Chapter 8](chapter8.xhtml).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码从标准输入流<samp class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp>输入一个浮点数、一个度量单位（作为字符串）和一个物品名称（同样作为字符串），直到文件末尾指示符被设置或发生读取错误为止。我们将在[第8章](chapter8.xhtml)详细讨论输入/输出。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">for</samp>
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">for</samp>
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> statement might
    be the most C-like thing about C. The <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    statement repeatedly executes a statement and is typically used when the number
    of iterations is known before entering the loop. It has the following syntax:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>语句可能是C语言中最“C风格”的部分。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp>语句重复执行一个语句，通常用于当循环的迭代次数在进入循环之前就已知的情况。它具有以下语法：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The controlling expression (<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression2</samp>)
    is evaluated before each execution of the loop body, and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression3</samp>
    is evaluated after each execution of the loop body. If <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">clause1</samp>
    is a declaration, the scope of any identifiers it declares is the remainder of
    the declaration and the entire loop, including the other two expressions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 控制表达式（<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression2</samp>）在每次执行循环体之前进行求值，而<sup
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression3</samp>则在每次执行循环体之后进行求值。如果<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">clause1</samp>是一个声明，它声明的任何标识符的作用域将是声明的剩余部分以及整个循环，包括其他两个表达式。
- en: The purpose of <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">clause1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression2</samp>, and
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression3</samp> is apparent
    when we translate the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    statement into an equivalent <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop, as shown in [Figure 5-1](chapter5.xhtml#fig5-1).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>语句转换为等效的<samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>循环时，<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">clause1</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression2</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression3</samp>的作用变得显而易见，如[图5-1](chapter5.xhtml#fig5-1)所示。
- en: '![](../images/f05001.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/f05001.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-1: Translating a <samp
    class="I">for</samp> loop into a <samp class="I">while</samp> loop</samp>'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 5-1: 将 <samp class="I">for</samp>
    循环转化为 <samp class="I">while</samp> 循环</samp>'
- en: '[Listing 5-9](chapter5.xhtml#Lis5-9) shows a modified version of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> implementation from [Listing
    5-7](chapter5.xhtml#Lis5-7); we have replaced the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop with a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 5-9](chapter5.xhtml#Lis5-9) 显示了[清单 5-7](chapter5.xhtml#Lis5-7)中 <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp>
    实现的修改版本；我们已将 <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> 循环替换为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环。'
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-9: Filling a character
    array by using a</samp> <samp class="I">for</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop</samp>'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 5-9：使用</samp> <samp class="I">for</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">循环填充字符数组</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop is popular
    among C programmers because it provides a convenient location for declaring and/or
    initializing the loop counter ❶, specifying the controlling expression for the
    loop ❷, and incrementing the loop counter ❸, all on the same line. The <samp class="SANS_TheSansMonoCd_W5Regular_11">*(ptr</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i)</samp>
    lvalue expression could be written equivalently using the index operator as <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ptr[i]</samp>.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环在 C 程序员中很受欢迎，因为它为声明和/或初始化循环计数器❶、指定控制循环的表达式❷以及递增循环计数器❸提供了一个方便的位置，所有这些都可以在同一行内完成。
    <samp class="SANS_TheSansMonoCd_W5Regular_11">*(ptr</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i)</samp> 左值表达式也可以等效地使用索引运算符写为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ptr[i]</samp>。
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop can also
    be somewhat misleading. Let’s take the example of a singly linked list in C that
    declares a <samp class="SANS_TheSansMonoCd_W5Regular_11">node</samp> structure
    consisting of a <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp> element
    and a pointer to the <samp class="SANS_TheSansMonoCd_W5Regular_11">next</samp>
    node in the list. We also define a pointer <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">node</samp> structure:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环也可能有些误导。我们来看一个 C
    语言中单向链表的例子，它声明了一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">node</samp> 结构体，其中包含一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp> 元素和指向链表中下一个节点的指针 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">next</samp>。我们还定义了一个指针 <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">node</samp> 结构：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Using the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>,
    the following example (used to deallocate the storage for a linked list) erroneously
    reads the value <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> after it
    has been freed:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> 的定义，下面的例子（用于释放链表的存储）错误地在释放后读取了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> 的值：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Reading <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> after it has
    been freed is undefined behavior.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在释放后读取 <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> 是未定义行为。
- en: 'If this loop were rewritten as a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop, it would become apparent that the code reads <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    after it was freed:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个循环改写成一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> 循环，那么代码会变得明显，它会在释放后读取
    <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop can be confusing
    because it evaluates <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression3</samp>
    after the main body of the loop, even though lexically it appears before the loop’s
    body.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环可能会令人困惑，因为它在循环主体之后评估
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression3</samp>，即使在语法上它看起来出现在循环体之前。
- en: 'The correct way to perform this operation is to save the required pointer before
    freeing it, like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这个操作的正确方式是在释放指针之前保存所需的指针，像这样：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can read more about dynamic memory management in [Chapter 6](chapter6.xhtml).  ##
    <samp class="SANS_Futura_Std_Bold_B_11">Jump Statements</samp>'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以在[第六章](chapter6.xhtml)中阅读更多关于动态内存管理的内容。  ## <samp class="SANS_Futura_Std_Bold_B_11">跳转语句</samp>'
- en: A *jump statement* unconditionally transfers control to another section of the
    same function when encountered. These are the lowest-level control flow statements
    and generally correspond closely to the underlying assembly language code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*跳转语句*在遇到时会无条件地将控制转移到同一函数的另一个部分。这些是最低级别的控制流语句，通常与底层汇编语言代码密切对应。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">goto</samp>
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">goto</samp>
- en: 'Any statement may be preceded by a *label*, which is an identifier followed
    by a colon. C23 also allows you to place labels in front of declarations and at
    the end of a compound statement, which was not allowed in previous versions of
    C. A <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp> statement causes
    a jump to the statement prefixed by the named label in the enclosing function.
    The jump is unconditional, meaning it happens every time the <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>
    statement is executed. Here’s an example of a <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>
    statement:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 任何语句前面都可以加一个*标签*，标签是一个标识符，后面跟着一个冒号。C23还允许你将标签放在声明前面以及复合语句的末尾，这是以前的C版本不允许的。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>语句会导致控制跳转到在封闭函数中由命名标签前缀标识的语句。这个跳转是无条件的，这意味着每次执行<samp
    class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>语句时都会发生。以下是一个<samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>语句的示例：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Execution continues until the <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>
    statement is reached, at which point control jumps to the statement following
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">location</samp> label, where
    execution continues. Statements between the <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>
    statement and the label are passed over.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 执行会持续进行，直到遇到<samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>语句，此时控制跳转到紧随<samp
    class="SANS_TheSansMonoCd_W5Regular_11">location</samp>标签后的语句，执行继续。<samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>语句与标签之间的语句会被跳过。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp> statement has
    had a bad reputation since Edsger Dijkstra wrote a paper titled “Go To Statement
    Considered Harmful” (1968). His criticism was that <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>
    statements can result in *spaghetti code* (code with a complex and tangled control
    structure, resulting in a program flow that’s conceptually twisted and tangled
    like a bowl of spaghetti) if used haphazardly. However, <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>
    statements can also make code easier to read if used in a clear, consistent manner.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Edsger Dijkstra在1968年写了题为“Go To Statement Considered Harmful”的论文后，<samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>语句一直有着不好的声誉。他的批评是，如果使用不当，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>语句可能导致*意大利面条式代码*（代码的控制结构复杂且纠缠，程序流程概念上像一碗意大利面条一样错综复杂）。然而，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>语句如果以清晰、一致的方式使用，也可以使代码更易于阅读。
- en: One helpful way to use <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>
    statements is to chain them together to release allocated resources (such as dynamic
    allocated memory or an open file) when an error occurs and you must leave a function.
    This scenario happens when a program allocates multiple resources; each allocation
    can fail, and resources must be released to prevent leaking. If the first resource
    allocation fails, no cleanup is needed, because no resources have been allocated.
    However, if the second resource cannot be allocated, the first resource needs
    to be released. Similarly, if the third resource cannot be allocated, the second
    and first resources allocated need to be released, and so forth. This pattern
    results in duplicated cleanup code, and it can be error-prone because of the duplication
    and additional complexity.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用<samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>语句的一种有用方法是将它们串联起来，在发生错误并且必须退出函数时释放已分配的资源（如动态分配的内存或打开的文件）。这种情况通常发生在程序分配多个资源时，每个分配可能会失败，必须释放资源以防止泄漏。如果第一个资源分配失败，不需要清理，因为没有资源被分配。但是，如果第二个资源无法分配，则需要释放第一个资源。同样，如果第三个资源无法分配，则需要释放第二个和第一个资源，以此类推。这个模式导致重复的清理代码，而且由于重复和额外的复杂性，容易出错。
- en: One solution is to use nested <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements, which can also become difficult to read if nested too deeply. Instead,
    we can use a <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp> chain as
    shown in [Listing 5-10](chapter5.xhtml#Lis5-10) to release resources.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是使用嵌套的 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句，但如果嵌套过深，也会变得难以阅读。相反，我们可以使用如
    [示例 5-10](chapter5.xhtml#Lis5-10) 中所示的 <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>
    链来释放资源。
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-10: Using a</samp>
    <samp class="I">goto</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">chain
    to release resources</samp>'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 5-10：使用</samp> <samp class="I">goto</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">链释放资源</samp>
- en: 'The code follows a simple pattern: resources are allocated in a certain order,
    operated upon, and then released in reverse (last in, first out) order. If an
    error occurs while allocating a resource, the code uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>
    to jump to the appropriate location in cleanup code and releases only those resources
    that have been allocated.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 代码遵循一个简单的模式：资源按照一定顺序分配、操作，然后按相反的顺序（后进先出）释放。如果在分配资源时发生错误，代码使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>
    跳转到清理代码中的适当位置，并且只释放那些已经分配的资源。
- en: 'Used like this, <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp> statements
    can make code easier to read. A real-world example is the <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_process</samp>
    function from <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel/fork.c</samp>
    from v6.7 of the Linux kernel (*[https://<wbr>elixir<wbr>.bootlin<wbr>.com<wbr>/linux<wbr>/v6<wbr>.7<wbr>/source<wbr>/kernel<wbr>/fork<wbr>.c#L2245](https://elixir.bootlin.com/linux/v6.7/source/kernel/fork.c#L2245)*),
    which uses 20 <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp> labels
    to perform cleanup code when an internal function fails.  ### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">continue</samp>'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '这样使用时，<samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp> 语句可以使代码更易读。一个实际的例子是
    Linux 内核 v6.7 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel/fork.c</samp>
    文件中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_process</samp> 函数（*<samp
    class="SANS_TheSansMonoCd_W5Regular_11">[https://<wbr>elixir<wbr>.bootlin<wbr>.com<wbr>/linux<wbr>/v6<wbr>.7<wbr>/source<wbr>/kernel<wbr>/fork<wbr>.c#L2245](https://elixir.bootlin.com/linux/v6.7/source/kernel/fork.c#L2245)*），该函数使用了
    20 个 <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp> 标签，在内部函数失败时执行清理代码。
    ### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">continue</samp>'
- en: You can use a <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statement inside a loop to jump to the end of the loop body, skipping the execution
    of the remaining statements inside the loop body for the current iteration. For
    example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement
    is equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">goto END_LOOP_BODY;</samp>
    in each of the loops shown in [Listing 5-11](chapter5.xhtml#Lis5-11).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在循环内部使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> 语句，跳转到循环体的末尾，跳过当前迭代中剩余语句的执行。例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> 语句等价于在 [示例 5-11](chapter5.xhtml#Lis5-11)
    中每个循环中使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">goto END_LOOP_BODY;</samp>。
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-11: Using the</samp>
    <samp class="I">continue</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement</samp>'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 5-11：使用</samp> <samp class="I">continue</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">语句</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement
    is used in conjunction with a conditional statement so that processing may continue
    with the subsequent loop iteration after the objective of the current loop iteration
    has been achieved.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> 语句与条件语句配合使用，以便在当前循环迭代的目标完成后，继续处理后续的循环迭代。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">break</samp>
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">break</samp>
- en: 'A <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement terminates
    execution of a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> or
    iteration statement. We used <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    within a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement
    in [Listing 5-4](chapter5.xhtml#Lis5-4). Within a loop, a <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    statement causes the loop to terminate and the program execution to resume at
    the statement following the loop. For instance, the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop in the following example exits only when the uppercase or lowercase Q key
    is pressed on the keyboard:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> 语句终止 <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    或迭代语句的执行。在[列表 5-4](chapter5.xhtml#Lis5-4)中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    语句里，我们使用了 <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>。在循环中，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">break</samp> 语句会导致循环终止，程序的执行将在循环后的语句处继续。例如，以下示例中的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环只有在按下大写或小写 Q 键时才会退出：
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We typically use <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    statements to discontinue the execution of the loop when the work it was performing
    has been completed. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    statement in [Listing 5-12](chapter5.xhtml#Lis5-12) exits the loop after it finds
    the specified key in an array. Assuming that <samp class="SANS_TheSansMonoCd_W5Regular_11">key</samp>
    is unique in <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>, the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">find_element</samp> function would behave
    the same without the <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    statement but, depending on the length of the array and the point at which <samp
    class="SANS_TheSansMonoCd_W5Regular_11">key</samp> is discovered, could run much
    slower.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> 语句在完成循环任务后中止循环的执行。例如，[列表
    5-12](chapter5.xhtml#Lis5-12) 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    语句会在找到数组中的指定键后退出循环。假设 <samp class="SANS_TheSansMonoCd_W5Regular_11">key</samp>
    在 <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> 中是唯一的，<samp class="SANS_TheSansMonoCd_W5Regular_11">find_element</samp>
    函数没有 <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> 语句时也会表现相同，但根据数组的长度以及
    <samp class="SANS_TheSansMonoCd_W5Regular_11">key</samp> 被发现的位置，可能会运行得更慢。
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-12: Breaking out
    of a loop</samp>'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 5-12：跳出循环</samp>
- en: 'Because <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">break</samp> bypass part of a loop body,
    use these statements carefully: the code following these statements is not executed.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    会跳过循环体的部分内容，因此使用这些语句时需要小心：这些语句后的代码将不会被执行。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">return</samp>
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">return</samp>
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement terminates
    execution of the current function and returns control to its caller. You’ve already
    seen many examples of <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statements in this book. A function may have zero or more <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statements.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> 语句终止当前函数的执行并将控制权返回给调用者。你已经在本书中看到过很多
    <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> 语句。一个函数可以有零个或多个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">return</samp> 语句。
- en: 'A <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement can
    simply return, or it can return an expression. Within a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    function (a function that doesn’t return a value), the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement should simply return. When a function returns a value, the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement should return an expression that produces a value of the return type.
    If a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement with
    an expression is executed, the value of the expression is returned to the caller
    as the value of the function call expression:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> 语句可以简单地返回，或者返回一个表达式。在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 函数（一个不返回值的函数）中，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">return</samp> 语句应该简单地返回。当一个函数返回一个值时，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">return</samp> 语句应该返回一个产生返回类型值的表达式。如果执行了带表达式的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> 语句，那么表达式的值将作为函数调用表达式的返回值返回给调用者：
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This simple function sums its parameters and returns the sum. The return expression
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp> produces a value of type
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, which matches the return
    type of the function. If this expression produced a different type, it would be
    implicitly converted to an object having the return type of the function. The
    return expression can also be as simple as returning 0 or 1\. The function result
    may then be used in an expression or assigned to a variable.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的函数对它的参数求和并返回总和。返回表达式 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>
    产生一个类型为 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 的值，这与函数的返回类型相匹配。如果这个表达式产生了不同的类型，它会隐式转换为具有函数返回类型的对象。返回表达式也可以像返回
    0 或 1 一样简单。然后可以在表达式中使用该函数结果，或者将其赋值给一个变量。
- en: 'Be aware that if control reaches the closing brace of a non-<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    function (a function declared to return a value) without evaluating a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement with an expression, using the return value of the function call is undefined
    behavior. For example, the following function fails to return a value when <samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is nonnegative because the condition
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a < 0</samp> is false:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果控制流在没有评估 <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> 语句且没有表达式的情况下到达一个非
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 函数（一个声明为返回值的函数）的闭括号，则使用该函数调用的返回值会导致未定义的行为。例如，当
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> 为非负数时，以下函数未能返回一个值，因为条件
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a < 0</samp> 为假：
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We can easily repair this defect by providing a return value when <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    is nonnegative, as shown in [Listing 5-13](chapter5.xhtml#Lis5-13).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> 为非负数时提供一个返回值来轻松修复这个缺陷，正如
    [列表 5-13](chapter5.xhtml#Lis5-13) 中所示。
- en: '[PRE38]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-13: The</samp> <samp
    class="I">absolute_value</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function
    returns a value along all paths.</samp>'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 5-13：该</samp> <samp class="I">absolute_value</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">函数沿所有路径返回一个值。</samp>
- en: However, this code still has a bug (see [Chapter 3](chapter3.xhtml)). Identifying
    this bug is left as an exercise for you.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这段代码仍然有一个 bug（请参见 [第 3 章](chapter3.xhtml)）。发现这个 bug 留给你自己练习。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: 'In this chapter, you learned about control flow statements. Control flow statements
    allow you to create flexible programs that can repeat tasks and alter their execution
    based on program inputs:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了控制流语句。控制流语句允许你创建灵活的程序，这些程序可以重复任务并根据程序输入更改执行方式：
- en: Selection statements, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>, allow you to
    select from a set of statements depending on the value of a controlling expression.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择语句，如 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>，允许你根据控制表达式的值从一组语句中进行选择。
- en: Iteration statements repeatedly execute a loop body until a controlling expression
    equals 0.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代语句重复执行循环体，直到控制表达式等于 0。
- en: Jump statements unconditionally transfer control to a new location.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳转语句无条件地将控制转移到一个新位置。
- en: In the next chapter, you’ll learn about dynamically allocated memory. Similar
    to control flow statements, you can use dynamic memory to create flexible programs
    that allocate memory based on program inputs.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，你将学习动态分配的内存。与控制流语句类似，你可以使用动态内存来创建灵活的程序，依据程序输入来分配内存。
