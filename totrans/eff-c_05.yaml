- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp> <samp class="SANS_Dogma_OT_Bold_B_11">CONTROL
    FLOW</samp>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
- en: 'In this chapter, you’ll learn how to control the order in which individual
    statements are evaluated. We’ll start by going over expression statements and
    compound statements that define the work to be performed. We’ll then cover three
    kinds of statements that determine which code blocks are executed and in what
    order: selection, iteration, and jump statements.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Expression Statements</samp>
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An *expression statement* is an optional expression terminated by a semicolon.
    It’s one of the most common statements and a basic unit of work. The following
    examples show different expression statements.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'Assigns a value to <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Assigns the sum of <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A null statement:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can use a null statement when the syntax of the language requires a statement
    but no expression needs to be evaluated. Null statements are commonly used as
    placeholders in iteration statements.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'The following expression statement increments the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp>:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After each full expression has been evaluated, its value (if any) is discarded
    (including assignment expressions in which the assignment itself is a side effect
    of the operation) so that any useful results occur as the consequence of side
    effects (as discussed in [Chapter 4](chapter4.xhtml)). Three of the four expression
    statements in this example have side effects (the null statement does nothing).
    Once all side effects have completed, execution proceeds to the statement following
    the semicolon.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Compound Statements</samp>
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *compound statement*, or *block*, is a list of zero or more statements, surrounded
    by braces. The statements in the block may be any kind of statement described
    throughout this chapter. Some of these statements may be declarations. (In early
    versions of C, declarations within the block had to precede all nondeclarations,
    but that restriction no longer applies.) Each statement in the block is executed
    in sequence unless modified by a control statement. After the final statement
    has been evaluated, execution proceeds to after the closing brace:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This example declares a static variable of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    called <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp>. The second
    line increases a variable <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    declared in an outer scope by the value stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>.
    Finally, <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> is incremented
    to track how many times this block has been executed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Compound statements can be nested so that one compound statement fully encloses
    another. You may also have blocks with no statements at all (just the empty braces).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Selection Statements</samp>
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Selection statements* allow you to conditionally execute a substatement depending
    on the value of a controlling expression. The *controlling expression* determines
    which statements are executed based on a condition. Selection statements include
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement and the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">if</samp>
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement allows
    a programmer to execute a substatement based on the value of a controlling expression
    of scalar type.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements. The first conditionally determines whether the substatement is executed:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this case, the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">substatement</samp>
    is executed if the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression</samp>
    is not equal to 0\. Only the single <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">substatement</samp>
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement is conditionally
    executed, although it can be a compound statement.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-1](chapter5.xhtml#Lis5-1) shows a division function that uses <samp
    class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements. It divides a specified
    dividend by a specified divisor and returns the result in the object referenced
    by <samp class="SANS_TheSansMonoCd_W5Regular_11">quotient</samp>. The function
    tests for both division by zero and signed integer overflow and returns <samp
    class="SANS_TheSansMonoCd_W5Regular_11">false</samp> in either case.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-1: A safe division
    function</samp>'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: The first line of this function ❶ tests <samp class="SANS_TheSansMonoCd_W5Regular_11">quotient</samp>
    to ensure that it’s not null. If it is null, the function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>
    to indicate that it is unable to return a value. (We cover <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statements later in this chapter.)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: The second line of the function ❷ contains a more complex <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement. Its controlling expression tests whether the divisor is 0 or whether
    the division would result in signed integer overflow if unchecked. If the result
    of this expression is not equal to 0, the function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>
    ❸ to indicate that it is unable to produce a quotient. If the controlling expression
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement evaluates
    to 0, the function does not return, and the remaining statements ❹ are executed
    to calculate the quotient and return <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'The second kind of <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement includes an <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    clause, which selects an alternative substatement to execute when the initial
    substatement is not selected:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this form, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">substatement1</samp>
    is executed if <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression</samp>
    is not equal to 0, and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">substatement2</samp>
    is executed if <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression</samp>
    is equal to 0\. One of these substatements is executed, but never both.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: For either form of the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement, the conditionally executed substatement may also be an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement. A common use of this is the <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp>
    ladder, shown in [Listing 5-2](chapter5.xhtml#Lis5-2).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-2: The</samp> <samp
    class="I">if...else</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">ladder
    syntax</samp>'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'One (and only one) of the four statements in an <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp>
    ladder will execute:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">substatement1</samp>
    executes if <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expr1</samp>
    does not equal 0.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">substatement2</samp>
    executes if <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expr1</samp>
    equals 0 and if <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expr2</samp>
    does not equal 0.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">substatement3</samp>
    executes if both <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expr1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expr2</samp> equal
    0 and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expr3</samp> does
    not equal 0.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">substatement4</samp>
    executes only if the preceding conditions are all equal to 0.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The example shown in [Listing 5-3](chapter5.xhtml#Lis5-3) uses an <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp>
    ladder to print grades.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-3](chapter5.xhtml#Lis5-3)中的例子使用了一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp>
    结构来打印成绩。'
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-3: Using an</samp>
    <samp class="I">if...else</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">ladder
    to print grades</samp>'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 5-3：使用</samp> <samp class="I">if...else</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">结构打印成绩</samp>
- en: 'In this <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp> ladder,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">printgrade</samp> function tests
    the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>
    parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">marks</samp> to determine
    whether it is greater than or equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">90</samp>.
    If so, the function prints <samp class="SANS_TheSansMonoCd_W5Regular_11">YOUR
    GRADE : A</samp>. Otherwise, it tests whether <samp class="SANS_TheSansMonoCd_W5Regular_11">marks</samp>
    is greater than or equal to 80, and so forth down the <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp>
    ladder. If <samp class="SANS_TheSansMonoCd_W5Regular_11">marks</samp> is not greater
    than or equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">70</samp>, the
    function prints <samp class="SANS_TheSansMonoCd_W5Regular_11">YOUR GRADE : Failed</samp>.
    This example uses a coding style in which the closing brace is followed by the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> clause on the same line.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个 <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp> 结构中，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">printgrade</samp> 函数测试 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp> 参数 <samp class="SANS_TheSansMonoCd_W5Regular_11">marks</samp> 的值，判断它是否大于或等于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">90</samp>。如果是，函数打印 <samp class="SANS_TheSansMonoCd_W5Regular_11">YOUR
    GRADE : A</samp>。否则，函数会测试 <samp class="SANS_TheSansMonoCd_W5Regular_11">marks</samp>
    是否大于或等于 80，依此类推，直到 <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp>
    结构的末尾。如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">marks</samp> 不大于或等于 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">70</samp>，则函数打印 <samp class="SANS_TheSansMonoCd_W5Regular_11">YOUR
    GRADE : Failed</samp>。这个例子使用了一种编码风格，其中闭合括号与 <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    子句写在同一行。'
- en: 'Only a single statement following the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement is executed. For example, in the following code snippet, <samp class="SANS_TheSansMonoCd_W5Regular_11">conditionally_executed</samp>
    is executed only if <samp class="SANS_TheSansMonoCd_W5Regular_11">condition</samp>
    is not equal to 0, but <samp class="SANS_TheSansMonoCd_W5Regular_11">unconditionally_executed</samp>
    is always executed:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 只有紧跟在 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句后的单个语句会被执行。例如，在下面的代码片段中，只有当
    <samp class="SANS_TheSansMonoCd_W5Regular_11">condition</samp> 不等于 0 时，<samp class="SANS_TheSansMonoCd_W5Regular_11">conditionally_executed</samp>
    才会执行，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">unconditionally_executed</samp>
    总是会执行：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Attempting to add another conditionally executed function is a common source
    of errors:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试添加另一个条件执行的函数是一个常见的错误来源：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this code snippet, <samp class="SANS_TheSansMonoCd_W5Regular_11">also_conditionally_executed</samp>
    is *unconditionally* executed. The name and indented formatting are deceptive
    because whitespace (in general) and indentation (in particular) are meaningless
    to the syntax. This code can be fixed by adding braces to delimit a single compound
    statement or block. This block is then executed as the single conditionally executed
    statement:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，<samp class="SANS_TheSansMonoCd_W5Regular_11">also_conditionally_executed</samp>
    是 *无条件* 执行的。变量名和缩进格式是误导性的，因为空格（一般而言）和缩进（特别是）对语法没有意义。通过添加大括号来限定一个复合语句或代码块，可以修复这段代码。然后，这个代码块作为单一的条件执行语句执行：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'While the original code snippet was not incorrect, many coding guidelines recommend
    always including braces to avoid this kind of error:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然原始代码片段并不错误，但许多编码规范建议始终包括大括号，以避免这种错误：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'My personal style is to omit the braces only when I can include the conditionally
    executed statement on the same line as the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我的个人风格是，仅当我能将条件执行语句与 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    语句写在同一行时，才省略大括号：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This issue is less problematic when you let your integrated development environment
    (IDE) format your code for you, as it won’t be fooled by code indentation when
    formatting your code. The GCC and Clang compilers provide a <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wmisleading-indentation</samp>
    compiler flag that checks code indentation and warns when it doesn’t correspond
    to the control flow.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当你让集成开发环境（IDE）为你格式化代码时，这个问题就不那么严重了，因为它不会被代码缩进迷惑。GCC 和 Clang 编译器提供了 <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wmisleading-indentation</samp>
    编译器标志，检查代码缩进并在其与控制流不符时发出警告。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">switch</samp>
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">switch</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement works
    just like the <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp> ladder,
    except that the controlling expression must have an integer type. For example,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement in [Listing
    5-4](chapter5.xhtml#Lis5-4) performs the same function as the <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp>
    ladder from [Listing 5-3](chapter5.xhtml#Lis5-3), provided that <samp class="SANS_TheSansMonoCd_W5Regular_11">marks</samp>
    is an integer in the range of 0 to 109\. If <samp class="SANS_TheSansMonoCd_W5Regular_11">marks</samp>
    is greater than 109, it will result in a failed grade because the resulting quotient
    will be greater than 10 and will consequently be caught by the default case.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> 语句的工作方式类似于 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp> 语句梯，唯一不同的是控制表达式必须是整数类型。例如，[Listing
    5-4](chapter5.xhtml#Lis5-4) 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    语句与 [Listing 5-3](chapter5.xhtml#Lis5-3) 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp>
    语句执行相同的功能，前提是 <samp class="SANS_TheSansMonoCd_W5Regular_11">marks</samp> 是一个 0
    到 109 之间的整数。如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">marks</samp> 大于 109，将导致成绩不及格，因为结果商会大于
    10，最终会被默认的 case 捕获。
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-4: Using a</samp>
    <samp class="I">switch</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement
    to print out grades</samp>'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-4: 使用</samp> <samp
    class="I">switch</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">语句输出成绩</samp>'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement causes
    control to jump to one of the three substatements, depending on the value of the
    controlling expression and the constant expressions in each <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>
    label. Following the jump, code is executed sequentially until the next control
    flow statement is reached. In our example, a jump to <samp class="SANS_TheSansMonoCd_W5Regular_11">case
    10</samp> (which is empty) flows through and executes the subsequent statements
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">case 9</samp>. This is necessary
    to the logic so that a perfect grade of 100 results in an A and not an F.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> 语句根据控制表达式的值和每个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">case</samp> 标签中的常量表达式，控制跳转到三个子语句之一。跳转后，代码按顺序执行，直到遇到下一个控制流语句。在我们的例子中，跳转到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">case 10</samp>（该语句为空）后，会继续执行 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">case 9</samp> 中的后续语句。这是逻辑所必需的，以确保完美的 100
    分会导致 A，而不是 F。
- en: You can terminate the execution of the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    by inserting a <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement,
    causing control to jump to the execution of the statement directly following the
    overall <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement.
    (We discuss <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statements
    in more detail later in this chapter.) Make sure you remember to include a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement before the next
    <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp> label. If omitted, the
    control flow falls through to the next <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement—a
    common source of errors. Because the <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    statement isn’t required, omitting it doesn’t typically produce compiler diagnostics.
    GCC issues a warning for fall-through if you use the <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wimplicit-fallthrough</samp>
    flag. The C23 standard introduces the <samp class="SANS_TheSansMonoCd_W5Regular_11">[[fallthrough]]</samp>
    attribute as a way for a programmer to specify that fall-through behavior is desirable,
    under the assumption that silent fall-through is an accidental omission of a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过插入一个<samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>语句来终止<samp
    class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>语句的执行，控制将跳转到紧跟在整体<samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>语句之后的语句。（我们将在本章稍后详细讨论<samp
    class="SANS_TheSansMonoCd_W5Regular_11">break</samp>语句。）确保在下一个<samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>标签之前包含一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">break</samp>语句。如果漏掉了，控制流将直接跳到下一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">case</samp>，这是常见的错误来源。由于<samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>语句并不是必须的，漏掉它通常不会产生编译器诊断。如果使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-Wimplicit-fallthrough</samp>标志，GCC会对fall-through情况发出警告。C23标准引入了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">[[fallthrough]]</samp>属性，允许程序员指定fall-through行为是期望的，前提是认为默默的fall-through是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">break</samp>语句的意外遗漏。
- en: Integer promotions are performed on the controlling expression. The constant
    expression in each <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp> label
    is converted to the promoted type of the controlling expression. If a converted
    value matches that of the promoted controlling expression, control jumps to the
    statement following the matched <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>
    label. Otherwise, if there is no match but there is a <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp>
    label, control jumps to the labeled statement. If no converted <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>
    constant expression matches and there is no <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp>
    label, no part of the switch body is executed. When <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    statements are nested, a <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp> label is accessible
    only within the closest enclosing <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    statement.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 整型提升发生在控制表达式上。每个<samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>标签中的常量表达式会被转换为控制表达式的提升类型。如果转换后的值与提升后的控制表达式匹配，控制将跳转到匹配的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">case</samp>标签后面的语句。否则，如果没有匹配的结果但有一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">default</samp>标签，控制将跳转到该标签指向的语句。如果没有任何转换后的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">case</samp>常量表达式匹配，并且没有<samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp>标签，则不会执行<samp
    class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>体中的任何部分。当<samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>语句嵌套时，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">case</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp>标签仅在最靠近的外层<samp
    class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>语句中可访问。
- en: There are best practices regarding the use of <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    statements. [Listing 5-5](chapter5.xhtml#Lis5-5) shows a less-than-ideal implementation
    of a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement that
    assigns interest rates to an account based on the account type. The <samp class="SANS_TheSansMonoCd_W5Regular_11">AccountType</samp>
    enumeration represents the fixed number of account types offered by the bank.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> 语句有一些最佳实践。[列表
    5-5](chapter5.xhtml#Lis5-5) 显示了一个不太理想的 <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    语句实现，它根据账户类型为账户分配利率。<samp class="SANS_TheSansMonoCd_W5Regular_11">AccountType</samp>
    枚举表示银行提供的固定数量的账户类型。
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-5: A</samp> <samp
    class="I">switch</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement
    without a</samp> <samp class="I">default</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">label</samp>'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 5-5：一个没有</samp> <samp class="I">default</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">标签的</samp> <samp class="I">switch</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">语句</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">assignInterestRate</samp>
    function defines a single parameter of the enumeration type <samp class="SANS_TheSansMonoCd_W5Regular_11">AccountType</samp>
    and switches on it to assign the appropriate interest rate associated with each
    account type.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">assignInterestRate</samp> 函数定义了一个枚举类型参数
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AccountType</samp>，并基于它进行切换，分配与每个账户类型相关的适当利率。
- en: 'Nothing is wrong with the code as written, but it requires programmers to update
    the code in at least two separate places if they want to make any changes. Let’s
    say the bank introduces a new type of account: a certificate of deposit. A programmer
    updates the <samp class="SANS_TheSansMonoCd_W5Regular_11">AccountType</samp> enumeration
    as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 代码本身没有问题，但如果程序员想要进行更改，就需要在至少两个不同的地方更新代码。假设银行引入了一种新的账户类型：定期存款证书。程序员更新了 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AccountType</samp> 枚举，如下所示：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: However, if the programmer neglects to modify the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    statement in the <samp class="SANS_TheSansMonoCd_W5Regular_11">assignInterestRate</samp>
    function, the <samp class="SANS_TheSansMonoCd_W5Regular_11">interest_rate</samp>
    isn’t assigned, resulting in an uninitialized read when the function attempts
    to print that value. This problem is common because the enumeration may be declared
    far from the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement,
    and the program may contain many similar <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    statements that all reference an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">AccountType</samp>
    in their controlling expression.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果程序员未能修改 <samp class="SANS_TheSansMonoCd_W5Regular_11">assignInterestRate</samp>
    函数中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> 语句，<samp class="SANS_TheSansMonoCd_W5Regular_11">interest_rate</samp>
    将不会被赋值，导致在函数尝试打印该值时出现未初始化读取的错误。这个问题很常见，因为枚举可能被声明在离 <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    语句很远的地方，而程序中可能包含许多类似的 <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    语句，它们都在控制表达式中引用了一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">AccountType</samp>
    类型的对象。
- en: Both Clang and GCC help diagnose these problems at compilation time when you
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wswitch-enum</samp> flag.
    Alternatively, you can protect against such errors and improve the testability
    of this code by adding this <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp>
    case to the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement,
    as shown in [Listing 5-6](chapter5.xhtml#Lis5-6).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是 Clang 还是 GCC，当你使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wswitch-enum</samp>
    标志时，它们都能在编译时帮助诊断这些问题。或者，你可以通过在 <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    语句中添加 <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp> 情况来防止此类错误，并提高此代码的可测试性，如
    [列表 5-6](chapter5.xhtml#Lis5-6) 所示。
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-6: A</samp> <samp
    class="I">switch</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement
    with a</samp> <samp class="I">default</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">label</samp>'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 5-6：一个有</samp> <samp class="I">default</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">标签的</samp> <samp class="I">switch</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">语句</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement now
    includes a case for <samp class="SANS_TheSansMonoCd_W5Regular_11">CD</samp>, and
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp> clause is unused.
    However, retaining the <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp>
    clause is good practice, in case another account type is added in the future.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'Including a <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp> clause
    does have the drawback of suppressing compiler warnings and not diagnosing the
    problem until runtime. Compiler warnings (if supported by your compiler) are therefore
    a better approach.  ## <samp class="SANS_Futura_Std_Bold_B_11">Iteration Statements</samp>'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '*Iteration statements* cause substatements (or compound statements) to be executed
    zero or more times, subject to termination criteria. The English word *iteration*
    means “the repetition of a process.” Iteration statements are more informally
    and commonly referred to as loops. A *loop* is “a process, the end of which is
    connected to the beginning.”'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">while</samp>
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> statement causes
    the loop body to execute repeatedly until the controlling expression is equal
    to 0\. The evaluation of the controlling expression occurs before each execution
    of the loop body. Consider the following example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is not initially greater
    than 0, the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop exits
    without executing the loop body. If <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    is greater than 0, its value is output and then decremented. Once the end of the
    loop is reached, the controlling expression is tested again. This pattern repeats
    until the expression evaluates to 0\. Overall, this loop will count down from
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> to 1.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop is an entry-controlled
    loop that executes until its controlling expression evaluates to 0\. [Listing
    5-7](chapter5.xhtml#Lis5-7) shows an implementation of the C standard library
    <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> function. This function
    copies the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">val</samp> (converted
    to an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>) into
    each of the first <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> characters
    of the object pointed to by <samp class="SANS_TheSansMonoCd_W5Regular_11">dest</samp>.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-7: The C standard
    library</samp> <samp class="I">memset</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: The first line of the <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp>
    function converts <samp class="SANS_TheSansMonoCd_W5Regular_11">dest</samp> to
    a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>
    and assigns the resulting value to the <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> pointer <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>.
    This lets us preserve the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">dest</samp>
    to return on the last line of the function. The remaining two lines of the function
    form a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop that copies
    the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">val</samp> (converted
    to an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>) into
    each of the first <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> characters
    of the object <samp class="SANS_TheSansMonoCd_W5Regular_11">dest</samp> points
    to. The controlling expression of the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop tests that <samp class="SANS_TheSansMonoCd_W5Regular_11">n-- > 0</samp>.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> argument is a loop
    counter that’s decremented on each iteration of the loop as a side effect of the
    evaluation of the controlling expression. The loop counter in this case monotonically
    decreases until it reaches the minimum value (0). The loop performs <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>
    repetitions, where <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> is less
    than or equal to the bound of the memory that <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    references.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> pointer designates
    a sequence of objects of type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp>, from <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> through
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">n - 1</samp>. The value of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">val</samp> is converted to an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> and written to each object in turn. If <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>
    is greater than the bound of the object that <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    references, the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop
    writes to memory outside the bounds of this object. This is undefined behavior
    and a common security flaw, referred to as a *buffer overflow*, or *overrun*.
    Provided the object referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    has at least <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> bytes, the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop terminates without
    undefined behavior. In the final iteration of the loop, the controlling expression
    <samp class="SANS_TheSansMonoCd_W5Regular_11">n-- > 0</samp> evaluates to 0, causing
    the loop to terminate.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible to write an *infinite loop*—a loop that never terminates. To avoid
    writing a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop that
    inadvertently runs forever, be sure you initialize any objects referenced by the
    controlling expression before the start of the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop. Also make sure that the controlling expression changes during the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop’s execution in a manner
    that causes the loop to terminate after iterating an appropriate number of times.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">do...while</samp>
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">do...while</samp> statement
    is similar to the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> statement,
    except that the evaluation of the controlling expression occurs after each execution
    of the loop body rather than before. As a result, the loop body is guaranteed
    to execute once before the condition is tested. The <samp class="SANS_TheSansMonoCd_W5Regular_11">do...while</samp>
    iteration statement has the following syntax:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In a <samp class="SANS_TheSansMonoCd_W5Regular_11">do...while</samp> iteration,
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">statement</samp> is unconditionally
    executed once, after which <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression</samp>
    is evaluated. If <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression</samp>
    is not equal to 0, control returns to the top of the loop and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">statement</samp>
    is executed again. Otherwise, execution passes to the statement following the
    loop.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">do...while</samp> iteration
    statement is commonly used in input/output (I/O), where it makes sense to read
    from a stream before testing the state of the stream, as shown in [Listing 5-8](chapter5.xhtml#Lis5-8).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-8: An input loop</samp>'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: This code inputs a floating-point quantity, a unit of measure (as a string),
    and an item name (also as a string) from the standard input stream <samp class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp>
    until the end-of-file indicator has been set or a read error has occurred. We’ll
    discuss I/O in detail in [Chapter 8](chapter8.xhtml).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">for</samp>
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> statement might
    be the most C-like thing about C. The <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    statement repeatedly executes a statement and is typically used when the number
    of iterations is known before entering the loop. It has the following syntax:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The controlling expression (<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression2</samp>)
    is evaluated before each execution of the loop body, and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression3</samp>
    is evaluated after each execution of the loop body. If <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">clause1</samp>
    is a declaration, the scope of any identifiers it declares is the remainder of
    the declaration and the entire loop, including the other two expressions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">clause1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression2</samp>, and
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression3</samp> is apparent
    when we translate the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    statement into an equivalent <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop, as shown in [Figure 5-1](chapter5.xhtml#fig5-1).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/f05001.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-1: Translating a <samp
    class="I">for</samp> loop into a <samp class="I">while</samp> loop</samp>'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-9](chapter5.xhtml#Lis5-9) shows a modified version of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> implementation from [Listing
    5-7](chapter5.xhtml#Lis5-7); we have replaced the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop with a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-9: Filling a character
    array by using a</samp> <samp class="I">for</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop</samp>'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop is popular
    among C programmers because it provides a convenient location for declaring and/or
    initializing the loop counter ❶, specifying the controlling expression for the
    loop ❷, and incrementing the loop counter ❸, all on the same line. The <samp class="SANS_TheSansMonoCd_W5Regular_11">*(ptr</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i)</samp>
    lvalue expression could be written equivalently using the index operator as <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ptr[i]</samp>.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop can also
    be somewhat misleading. Let’s take the example of a singly linked list in C that
    declares a <samp class="SANS_TheSansMonoCd_W5Regular_11">node</samp> structure
    consisting of a <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp> element
    and a pointer to the <samp class="SANS_TheSansMonoCd_W5Regular_11">next</samp>
    node in the list. We also define a pointer <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">node</samp> structure:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Using the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>,
    the following example (used to deallocate the storage for a linked list) erroneously
    reads the value <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> after it
    has been freed:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Reading <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> after it has
    been freed is undefined behavior.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'If this loop were rewritten as a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop, it would become apparent that the code reads <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    after it was freed:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop can be confusing
    because it evaluates <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression3</samp>
    after the main body of the loop, even though lexically it appears before the loop’s
    body.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'The correct way to perform this operation is to save the required pointer before
    freeing it, like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can read more about dynamic memory management in [Chapter 6](chapter6.xhtml).  ##
    <samp class="SANS_Futura_Std_Bold_B_11">Jump Statements</samp>'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: A *jump statement* unconditionally transfers control to another section of the
    same function when encountered. These are the lowest-level control flow statements
    and generally correspond closely to the underlying assembly language code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">goto</samp>
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Any statement may be preceded by a *label*, which is an identifier followed
    by a colon. C23 also allows you to place labels in front of declarations and at
    the end of a compound statement, which was not allowed in previous versions of
    C. A <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp> statement causes
    a jump to the statement prefixed by the named label in the enclosing function.
    The jump is unconditional, meaning it happens every time the <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>
    statement is executed. Here’s an example of a <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>
    statement:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Execution continues until the <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>
    statement is reached, at which point control jumps to the statement following
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">location</samp> label, where
    execution continues. Statements between the <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>
    statement and the label are passed over.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp> statement has
    had a bad reputation since Edsger Dijkstra wrote a paper titled “Go To Statement
    Considered Harmful” (1968). His criticism was that <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>
    statements can result in *spaghetti code* (code with a complex and tangled control
    structure, resulting in a program flow that’s conceptually twisted and tangled
    like a bowl of spaghetti) if used haphazardly. However, <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>
    statements can also make code easier to read if used in a clear, consistent manner.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: One helpful way to use <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>
    statements is to chain them together to release allocated resources (such as dynamic
    allocated memory or an open file) when an error occurs and you must leave a function.
    This scenario happens when a program allocates multiple resources; each allocation
    can fail, and resources must be released to prevent leaking. If the first resource
    allocation fails, no cleanup is needed, because no resources have been allocated.
    However, if the second resource cannot be allocated, the first resource needs
    to be released. Similarly, if the third resource cannot be allocated, the second
    and first resources allocated need to be released, and so forth. This pattern
    results in duplicated cleanup code, and it can be error-prone because of the duplication
    and additional complexity.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: One solution is to use nested <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements, which can also become difficult to read if nested too deeply. Instead,
    we can use a <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp> chain as
    shown in [Listing 5-10](chapter5.xhtml#Lis5-10) to release resources.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-10: Using a</samp>
    <samp class="I">goto</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">chain
    to release resources</samp>'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'The code follows a simple pattern: resources are allocated in a certain order,
    operated upon, and then released in reverse (last in, first out) order. If an
    error occurs while allocating a resource, the code uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>
    to jump to the appropriate location in cleanup code and releases only those resources
    that have been allocated.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Used like this, <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp> statements
    can make code easier to read. A real-world example is the <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_process</samp>
    function from <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel/fork.c</samp>
    from v6.7 of the Linux kernel (*[https://<wbr>elixir<wbr>.bootlin<wbr>.com<wbr>/linux<wbr>/v6<wbr>.7<wbr>/source<wbr>/kernel<wbr>/fork<wbr>.c#L2245](https://elixir.bootlin.com/linux/v6.7/source/kernel/fork.c#L2245)*),
    which uses 20 <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp> labels
    to perform cleanup code when an internal function fails.  ### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">continue</samp>'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: You can use a <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statement inside a loop to jump to the end of the loop body, skipping the execution
    of the remaining statements inside the loop body for the current iteration. For
    example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement
    is equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">goto END_LOOP_BODY;</samp>
    in each of the loops shown in [Listing 5-11](chapter5.xhtml#Lis5-11).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-11: Using the</samp>
    <samp class="I">continue</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement</samp>'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement
    is used in conjunction with a conditional statement so that processing may continue
    with the subsequent loop iteration after the objective of the current loop iteration
    has been achieved.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">break</samp>
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement terminates
    execution of a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> or
    iteration statement. We used <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    within a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement
    in [Listing 5-4](chapter5.xhtml#Lis5-4). Within a loop, a <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    statement causes the loop to terminate and the program execution to resume at
    the statement following the loop. For instance, the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop in the following example exits only when the uppercase or lowercase Q key
    is pressed on the keyboard:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We typically use <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    statements to discontinue the execution of the loop when the work it was performing
    has been completed. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    statement in [Listing 5-12](chapter5.xhtml#Lis5-12) exits the loop after it finds
    the specified key in an array. Assuming that <samp class="SANS_TheSansMonoCd_W5Regular_11">key</samp>
    is unique in <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>, the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">find_element</samp> function would behave
    the same without the <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    statement but, depending on the length of the array and the point at which <samp
    class="SANS_TheSansMonoCd_W5Regular_11">key</samp> is discovered, could run much
    slower.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-12: Breaking out
    of a loop</samp>'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Because <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">break</samp> bypass part of a loop body,
    use these statements carefully: the code following these statements is not executed.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">return</samp>
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement terminates
    execution of the current function and returns control to its caller. You’ve already
    seen many examples of <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statements in this book. A function may have zero or more <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statements.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'A <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement can
    simply return, or it can return an expression. Within a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    function (a function that doesn’t return a value), the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement should simply return. When a function returns a value, the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement should return an expression that produces a value of the return type.
    If a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement with
    an expression is executed, the value of the expression is returned to the caller
    as the value of the function call expression:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This simple function sums its parameters and returns the sum. The return expression
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp> produces a value of type
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, which matches the return
    type of the function. If this expression produced a different type, it would be
    implicitly converted to an object having the return type of the function. The
    return expression can also be as simple as returning 0 or 1\. The function result
    may then be used in an expression or assigned to a variable.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Be aware that if control reaches the closing brace of a non-<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    function (a function declared to return a value) without evaluating a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement with an expression, using the return value of the function call is undefined
    behavior. For example, the following function fails to return a value when <samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is nonnegative because the condition
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a < 0</samp> is false:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We can easily repair this defect by providing a return value when <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    is nonnegative, as shown in [Listing 5-13](chapter5.xhtml#Lis5-13).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-13: The</samp> <samp
    class="I">absolute_value</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function
    returns a value along all paths.</samp>'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: However, this code still has a bug (see [Chapter 3](chapter3.xhtml)). Identifying
    this bug is left as an exercise for you.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, you learned about control flow statements. Control flow statements
    allow you to create flexible programs that can repeat tasks and alter their execution
    based on program inputs:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Selection statements, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>, allow you to
    select from a set of statements depending on the value of a controlling expression.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iteration statements repeatedly execute a loop body until a controlling expression
    equals 0.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jump statements unconditionally transfer control to a new location.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn about dynamically allocated memory. Similar
    to control flow statements, you can use dynamic memory to create flexible programs
    that allocate memory based on program inputs.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
