- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp> <samp class="SANS_Dogma_OT_Bold_B_11">CONTROL
    FLOW</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this chapter, you’ll learn how to control the order in which individual
    statements are evaluated. We’ll start by going over expression statements and
    compound statements that define the work to be performed. We’ll then cover three
    kinds of statements that determine which code blocks are executed and in what
    order: selection, iteration, and jump statements.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Expression Statements</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An *expression statement* is an optional expression terminated by a semicolon.
    It’s one of the most common statements and a basic unit of work. The following
    examples show different expression statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assigns a value to <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Assigns the sum of <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A null statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can use a null statement when the syntax of the language requires a statement
    but no expression needs to be evaluated. Null statements are commonly used as
    placeholders in iteration statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following expression statement increments the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: After each full expression has been evaluated, its value (if any) is discarded
    (including assignment expressions in which the assignment itself is a side effect
    of the operation) so that any useful results occur as the consequence of side
    effects (as discussed in [Chapter 4](chapter4.xhtml)). Three of the four expression
    statements in this example have side effects (the null statement does nothing).
    Once all side effects have completed, execution proceeds to the statement following
    the semicolon.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Compound Statements</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *compound statement*, or *block*, is a list of zero or more statements, surrounded
    by braces. The statements in the block may be any kind of statement described
    throughout this chapter. Some of these statements may be declarations. (In early
    versions of C, declarations within the block had to precede all nondeclarations,
    but that restriction no longer applies.) Each statement in the block is executed
    in sequence unless modified by a control statement. After the final statement
    has been evaluated, execution proceeds to after the closing brace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This example declares a static variable of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    called <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp>. The second
    line increases a variable <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    declared in an outer scope by the value stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>.
    Finally, <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> is incremented
    to track how many times this block has been executed.
  prefs: []
  type: TYPE_NORMAL
- en: Compound statements can be nested so that one compound statement fully encloses
    another. You may also have blocks with no statements at all (just the empty braces).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Selection Statements</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Selection statements* allow you to conditionally execute a substatement depending
    on the value of a controlling expression. The *controlling expression* determines
    which statements are executed based on a condition. Selection statements include
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement and the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">if</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement allows
    a programmer to execute a substatement based on the value of a controlling expression
    of scalar type.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements. The first conditionally determines whether the substatement is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">substatement</samp>
    is executed if the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression</samp>
    is not equal to 0\. Only the single <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">substatement</samp>
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement is conditionally
    executed, although it can be a compound statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-1](chapter5.xhtml#Lis5-1) shows a division function that uses <samp
    class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements. It divides a specified
    dividend by a specified divisor and returns the result in the object referenced
    by <samp class="SANS_TheSansMonoCd_W5Regular_11">quotient</samp>. The function
    tests for both division by zero and signed integer overflow and returns <samp
    class="SANS_TheSansMonoCd_W5Regular_11">false</samp> in either case.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-1: A safe division
    function</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The first line of this function ❶ tests <samp class="SANS_TheSansMonoCd_W5Regular_11">quotient</samp>
    to ensure that it’s not null. If it is null, the function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>
    to indicate that it is unable to return a value. (We cover <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statements later in this chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: The second line of the function ❷ contains a more complex <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement. Its controlling expression tests whether the divisor is 0 or whether
    the division would result in signed integer overflow if unchecked. If the result
    of this expression is not equal to 0, the function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>
    ❸ to indicate that it is unable to produce a quotient. If the controlling expression
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement evaluates
    to 0, the function does not return, and the remaining statements ❹ are executed
    to calculate the quotient and return <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second kind of <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement includes an <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    clause, which selects an alternative substatement to execute when the initial
    substatement is not selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this form, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">substatement1</samp>
    is executed if <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression</samp>
    is not equal to 0, and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">substatement2</samp>
    is executed if <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression</samp>
    is equal to 0\. One of these substatements is executed, but never both.
  prefs: []
  type: TYPE_NORMAL
- en: For either form of the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement, the conditionally executed substatement may also be an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement. A common use of this is the <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp>
    ladder, shown in [Listing 5-2](chapter5.xhtml#Lis5-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-2: The</samp> <samp
    class="I">if...else</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">ladder
    syntax</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'One (and only one) of the four statements in an <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp>
    ladder will execute:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">substatement1</samp>
    executes if <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expr1</samp>
    does not equal 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">substatement2</samp>
    executes if <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expr1</samp>
    equals 0 and if <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expr2</samp>
    does not equal 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">substatement3</samp>
    executes if both <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expr1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expr2</samp> equal
    0 and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expr3</samp> does
    not equal 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">substatement4</samp>
    executes only if the preceding conditions are all equal to 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The example shown in [Listing 5-3](chapter5.xhtml#Lis5-3) uses an <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp>
    ladder to print grades.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-3: Using an</samp>
    <samp class="I">if...else</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">ladder
    to print grades</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp> ladder,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">printgrade</samp> function tests
    the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>
    parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">marks</samp> to determine
    whether it is greater than or equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">90</samp>.
    If so, the function prints <samp class="SANS_TheSansMonoCd_W5Regular_11">YOUR
    GRADE : A</samp>. Otherwise, it tests whether <samp class="SANS_TheSansMonoCd_W5Regular_11">marks</samp>
    is greater than or equal to 80, and so forth down the <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp>
    ladder. If <samp class="SANS_TheSansMonoCd_W5Regular_11">marks</samp> is not greater
    than or equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">70</samp>, the
    function prints <samp class="SANS_TheSansMonoCd_W5Regular_11">YOUR GRADE : Failed</samp>.
    This example uses a coding style in which the closing brace is followed by the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> clause on the same line.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Only a single statement following the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement is executed. For example, in the following code snippet, <samp class="SANS_TheSansMonoCd_W5Regular_11">conditionally_executed</samp>
    is executed only if <samp class="SANS_TheSansMonoCd_W5Regular_11">condition</samp>
    is not equal to 0, but <samp class="SANS_TheSansMonoCd_W5Regular_11">unconditionally_executed</samp>
    is always executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Attempting to add another conditionally executed function is a common source
    of errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code snippet, <samp class="SANS_TheSansMonoCd_W5Regular_11">also_conditionally_executed</samp>
    is *unconditionally* executed. The name and indented formatting are deceptive
    because whitespace (in general) and indentation (in particular) are meaningless
    to the syntax. This code can be fixed by adding braces to delimit a single compound
    statement or block. This block is then executed as the single conditionally executed
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'While the original code snippet was not incorrect, many coding guidelines recommend
    always including braces to avoid this kind of error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'My personal style is to omit the braces only when I can include the conditionally
    executed statement on the same line as the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This issue is less problematic when you let your integrated development environment
    (IDE) format your code for you, as it won’t be fooled by code indentation when
    formatting your code. The GCC and Clang compilers provide a <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wmisleading-indentation</samp>
    compiler flag that checks code indentation and warns when it doesn’t correspond
    to the control flow.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">switch</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement works
    just like the <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp> ladder,
    except that the controlling expression must have an integer type. For example,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement in [Listing
    5-4](chapter5.xhtml#Lis5-4) performs the same function as the <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp>
    ladder from [Listing 5-3](chapter5.xhtml#Lis5-3), provided that <samp class="SANS_TheSansMonoCd_W5Regular_11">marks</samp>
    is an integer in the range of 0 to 109\. If <samp class="SANS_TheSansMonoCd_W5Regular_11">marks</samp>
    is greater than 109, it will result in a failed grade because the resulting quotient
    will be greater than 10 and will consequently be caught by the default case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-4: Using a</samp>
    <samp class="I">switch</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement
    to print out grades</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement causes
    control to jump to one of the three substatements, depending on the value of the
    controlling expression and the constant expressions in each <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>
    label. Following the jump, code is executed sequentially until the next control
    flow statement is reached. In our example, a jump to <samp class="SANS_TheSansMonoCd_W5Regular_11">case
    10</samp> (which is empty) flows through and executes the subsequent statements
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">case 9</samp>. This is necessary
    to the logic so that a perfect grade of 100 results in an A and not an F.
  prefs: []
  type: TYPE_NORMAL
- en: You can terminate the execution of the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    by inserting a <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement,
    causing control to jump to the execution of the statement directly following the
    overall <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement.
    (We discuss <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statements
    in more detail later in this chapter.) Make sure you remember to include a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement before the next
    <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp> label. If omitted, the
    control flow falls through to the next <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement—a
    common source of errors. Because the <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    statement isn’t required, omitting it doesn’t typically produce compiler diagnostics.
    GCC issues a warning for fall-through if you use the <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wimplicit-fallthrough</samp>
    flag. The C23 standard introduces the <samp class="SANS_TheSansMonoCd_W5Regular_11">[[fallthrough]]</samp>
    attribute as a way for a programmer to specify that fall-through behavior is desirable,
    under the assumption that silent fall-through is an accidental omission of a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement.
  prefs: []
  type: TYPE_NORMAL
- en: Integer promotions are performed on the controlling expression. The constant
    expression in each <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp> label
    is converted to the promoted type of the controlling expression. If a converted
    value matches that of the promoted controlling expression, control jumps to the
    statement following the matched <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>
    label. Otherwise, if there is no match but there is a <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp>
    label, control jumps to the labeled statement. If no converted <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>
    constant expression matches and there is no <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp>
    label, no part of the switch body is executed. When <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    statements are nested, a <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp> label is accessible
    only within the closest enclosing <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: There are best practices regarding the use of <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    statements. [Listing 5-5](chapter5.xhtml#Lis5-5) shows a less-than-ideal implementation
    of a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement that
    assigns interest rates to an account based on the account type. The <samp class="SANS_TheSansMonoCd_W5Regular_11">AccountType</samp>
    enumeration represents the fixed number of account types offered by the bank.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-5: A</samp> <samp
    class="I">switch</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement
    without a</samp> <samp class="I">default</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">label</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">assignInterestRate</samp>
    function defines a single parameter of the enumeration type <samp class="SANS_TheSansMonoCd_W5Regular_11">AccountType</samp>
    and switches on it to assign the appropriate interest rate associated with each
    account type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nothing is wrong with the code as written, but it requires programmers to update
    the code in at least two separate places if they want to make any changes. Let’s
    say the bank introduces a new type of account: a certificate of deposit. A programmer
    updates the <samp class="SANS_TheSansMonoCd_W5Regular_11">AccountType</samp> enumeration
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: However, if the programmer neglects to modify the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    statement in the <samp class="SANS_TheSansMonoCd_W5Regular_11">assignInterestRate</samp>
    function, the <samp class="SANS_TheSansMonoCd_W5Regular_11">interest_rate</samp>
    isn’t assigned, resulting in an uninitialized read when the function attempts
    to print that value. This problem is common because the enumeration may be declared
    far from the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement,
    and the program may contain many similar <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    statements that all reference an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">AccountType</samp>
    in their controlling expression.
  prefs: []
  type: TYPE_NORMAL
- en: Both Clang and GCC help diagnose these problems at compilation time when you
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wswitch-enum</samp> flag.
    Alternatively, you can protect against such errors and improve the testability
    of this code by adding this <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp>
    case to the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement,
    as shown in [Listing 5-6](chapter5.xhtml#Lis5-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-6: A</samp> <samp
    class="I">switch</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement
    with a</samp> <samp class="I">default</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">label</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement now
    includes a case for <samp class="SANS_TheSansMonoCd_W5Regular_11">CD</samp>, and
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp> clause is unused.
    However, retaining the <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp>
    clause is good practice, in case another account type is added in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Including a <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp> clause
    does have the drawback of suppressing compiler warnings and not diagnosing the
    problem until runtime. Compiler warnings (if supported by your compiler) are therefore
    a better approach.  ## <samp class="SANS_Futura_Std_Bold_B_11">Iteration Statements</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '*Iteration statements* cause substatements (or compound statements) to be executed
    zero or more times, subject to termination criteria. The English word *iteration*
    means “the repetition of a process.” Iteration statements are more informally
    and commonly referred to as loops. A *loop* is “a process, the end of which is
    connected to the beginning.”'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">while</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> statement causes
    the loop body to execute repeatedly until the controlling expression is equal
    to 0\. The evaluation of the controlling expression occurs before each execution
    of the loop body. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is not initially greater
    than 0, the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop exits
    without executing the loop body. If <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    is greater than 0, its value is output and then decremented. Once the end of the
    loop is reached, the controlling expression is tested again. This pattern repeats
    until the expression evaluates to 0\. Overall, this loop will count down from
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> to 1.
  prefs: []
  type: TYPE_NORMAL
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop is an entry-controlled
    loop that executes until its controlling expression evaluates to 0\. [Listing
    5-7](chapter5.xhtml#Lis5-7) shows an implementation of the C standard library
    <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> function. This function
    copies the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">val</samp> (converted
    to an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>) into
    each of the first <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> characters
    of the object pointed to by <samp class="SANS_TheSansMonoCd_W5Regular_11">dest</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-7: The C standard
    library</samp> <samp class="I">memset</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The first line of the <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp>
    function converts <samp class="SANS_TheSansMonoCd_W5Regular_11">dest</samp> to
    a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>
    and assigns the resulting value to the <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> pointer <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>.
    This lets us preserve the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">dest</samp>
    to return on the last line of the function. The remaining two lines of the function
    form a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop that copies
    the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">val</samp> (converted
    to an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>) into
    each of the first <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> characters
    of the object <samp class="SANS_TheSansMonoCd_W5Regular_11">dest</samp> points
    to. The controlling expression of the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop tests that <samp class="SANS_TheSansMonoCd_W5Regular_11">n-- > 0</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> argument is a loop
    counter that’s decremented on each iteration of the loop as a side effect of the
    evaluation of the controlling expression. The loop counter in this case monotonically
    decreases until it reaches the minimum value (0). The loop performs <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>
    repetitions, where <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> is less
    than or equal to the bound of the memory that <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    references.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> pointer designates
    a sequence of objects of type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp>, from <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> through
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">n - 1</samp>. The value of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">val</samp> is converted to an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> and written to each object in turn. If <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>
    is greater than the bound of the object that <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    references, the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop
    writes to memory outside the bounds of this object. This is undefined behavior
    and a common security flaw, referred to as a *buffer overflow*, or *overrun*.
    Provided the object referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    has at least <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> bytes, the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop terminates without
    undefined behavior. In the final iteration of the loop, the controlling expression
    <samp class="SANS_TheSansMonoCd_W5Regular_11">n-- > 0</samp> evaluates to 0, causing
    the loop to terminate.
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible to write an *infinite loop*—a loop that never terminates. To avoid
    writing a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop that
    inadvertently runs forever, be sure you initialize any objects referenced by the
    controlling expression before the start of the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop. Also make sure that the controlling expression changes during the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop’s execution in a manner
    that causes the loop to terminate after iterating an appropriate number of times.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">do...while</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">do...while</samp> statement
    is similar to the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> statement,
    except that the evaluation of the controlling expression occurs after each execution
    of the loop body rather than before. As a result, the loop body is guaranteed
    to execute once before the condition is tested. The <samp class="SANS_TheSansMonoCd_W5Regular_11">do...while</samp>
    iteration statement has the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In a <samp class="SANS_TheSansMonoCd_W5Regular_11">do...while</samp> iteration,
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">statement</samp> is unconditionally
    executed once, after which <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression</samp>
    is evaluated. If <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression</samp>
    is not equal to 0, control returns to the top of the loop and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">statement</samp>
    is executed again. Otherwise, execution passes to the statement following the
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">do...while</samp> iteration
    statement is commonly used in input/output (I/O), where it makes sense to read
    from a stream before testing the state of the stream, as shown in [Listing 5-8](chapter5.xhtml#Lis5-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-8: An input loop</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This code inputs a floating-point quantity, a unit of measure (as a string),
    and an item name (also as a string) from the standard input stream <samp class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp>
    until the end-of-file indicator has been set or a read error has occurred. We’ll
    discuss I/O in detail in [Chapter 8](chapter8.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">for</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> statement might
    be the most C-like thing about C. The <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    statement repeatedly executes a statement and is typically used when the number
    of iterations is known before entering the loop. It has the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The controlling expression (<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression2</samp>)
    is evaluated before each execution of the loop body, and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression3</samp>
    is evaluated after each execution of the loop body. If <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">clause1</samp>
    is a declaration, the scope of any identifiers it declares is the remainder of
    the declaration and the entire loop, including the other two expressions.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">clause1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression2</samp>, and
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression3</samp> is apparent
    when we translate the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    statement into an equivalent <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop, as shown in [Figure 5-1](chapter5.xhtml#fig5-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/f05001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-1: Translating a <samp
    class="I">for</samp> loop into a <samp class="I">while</samp> loop</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-9](chapter5.xhtml#Lis5-9) shows a modified version of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> implementation from [Listing
    5-7](chapter5.xhtml#Lis5-7); we have replaced the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop with a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-9: Filling a character
    array by using a</samp> <samp class="I">for</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop is popular
    among C programmers because it provides a convenient location for declaring and/or
    initializing the loop counter ❶, specifying the controlling expression for the
    loop ❷, and incrementing the loop counter ❸, all on the same line. The <samp class="SANS_TheSansMonoCd_W5Regular_11">*(ptr</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i)</samp>
    lvalue expression could be written equivalently using the index operator as <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ptr[i]</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop can also
    be somewhat misleading. Let’s take the example of a singly linked list in C that
    declares a <samp class="SANS_TheSansMonoCd_W5Regular_11">node</samp> structure
    consisting of a <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp> element
    and a pointer to the <samp class="SANS_TheSansMonoCd_W5Regular_11">next</samp>
    node in the list. We also define a pointer <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">node</samp> structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>,
    the following example (used to deallocate the storage for a linked list) erroneously
    reads the value <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> after it
    has been freed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Reading <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> after it has
    been freed is undefined behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'If this loop were rewritten as a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop, it would become apparent that the code reads <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    after it was freed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop can be confusing
    because it evaluates <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression3</samp>
    after the main body of the loop, even though lexically it appears before the loop’s
    body.
  prefs: []
  type: TYPE_NORMAL
- en: 'The correct way to perform this operation is to save the required pointer before
    freeing it, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You can read more about dynamic memory management in [Chapter 6](chapter6.xhtml).  ##
    <samp class="SANS_Futura_Std_Bold_B_11">Jump Statements</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: A *jump statement* unconditionally transfers control to another section of the
    same function when encountered. These are the lowest-level control flow statements
    and generally correspond closely to the underlying assembly language code.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">goto</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Any statement may be preceded by a *label*, which is an identifier followed
    by a colon. C23 also allows you to place labels in front of declarations and at
    the end of a compound statement, which was not allowed in previous versions of
    C. A <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp> statement causes
    a jump to the statement prefixed by the named label in the enclosing function.
    The jump is unconditional, meaning it happens every time the <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>
    statement is executed. Here’s an example of a <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Execution continues until the <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>
    statement is reached, at which point control jumps to the statement following
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">location</samp> label, where
    execution continues. Statements between the <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>
    statement and the label are passed over.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp> statement has
    had a bad reputation since Edsger Dijkstra wrote a paper titled “Go To Statement
    Considered Harmful” (1968). His criticism was that <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>
    statements can result in *spaghetti code* (code with a complex and tangled control
    structure, resulting in a program flow that’s conceptually twisted and tangled
    like a bowl of spaghetti) if used haphazardly. However, <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>
    statements can also make code easier to read if used in a clear, consistent manner.
  prefs: []
  type: TYPE_NORMAL
- en: One helpful way to use <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>
    statements is to chain them together to release allocated resources (such as dynamic
    allocated memory or an open file) when an error occurs and you must leave a function.
    This scenario happens when a program allocates multiple resources; each allocation
    can fail, and resources must be released to prevent leaking. If the first resource
    allocation fails, no cleanup is needed, because no resources have been allocated.
    However, if the second resource cannot be allocated, the first resource needs
    to be released. Similarly, if the third resource cannot be allocated, the second
    and first resources allocated need to be released, and so forth. This pattern
    results in duplicated cleanup code, and it can be error-prone because of the duplication
    and additional complexity.
  prefs: []
  type: TYPE_NORMAL
- en: One solution is to use nested <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements, which can also become difficult to read if nested too deeply. Instead,
    we can use a <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp> chain as
    shown in [Listing 5-10](chapter5.xhtml#Lis5-10) to release resources.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-10: Using a</samp>
    <samp class="I">goto</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">chain
    to release resources</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code follows a simple pattern: resources are allocated in a certain order,
    operated upon, and then released in reverse (last in, first out) order. If an
    error occurs while allocating a resource, the code uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>
    to jump to the appropriate location in cleanup code and releases only those resources
    that have been allocated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Used like this, <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp> statements
    can make code easier to read. A real-world example is the <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_process</samp>
    function from <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel/fork.c</samp>
    from v6.7 of the Linux kernel (*[https://<wbr>elixir<wbr>.bootlin<wbr>.com<wbr>/linux<wbr>/v6<wbr>.7<wbr>/source<wbr>/kernel<wbr>/fork<wbr>.c#L2245](https://elixir.bootlin.com/linux/v6.7/source/kernel/fork.c#L2245)*),
    which uses 20 <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp> labels
    to perform cleanup code when an internal function fails.  ### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">continue</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You can use a <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statement inside a loop to jump to the end of the loop body, skipping the execution
    of the remaining statements inside the loop body for the current iteration. For
    example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement
    is equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">goto END_LOOP_BODY;</samp>
    in each of the loops shown in [Listing 5-11](chapter5.xhtml#Lis5-11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-11: Using the</samp>
    <samp class="I">continue</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement
    is used in conjunction with a conditional statement so that processing may continue
    with the subsequent loop iteration after the objective of the current loop iteration
    has been achieved.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">break</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement terminates
    execution of a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> or
    iteration statement. We used <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    within a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement
    in [Listing 5-4](chapter5.xhtml#Lis5-4). Within a loop, a <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    statement causes the loop to terminate and the program execution to resume at
    the statement following the loop. For instance, the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop in the following example exits only when the uppercase or lowercase Q key
    is pressed on the keyboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We typically use <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    statements to discontinue the execution of the loop when the work it was performing
    has been completed. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    statement in [Listing 5-12](chapter5.xhtml#Lis5-12) exits the loop after it finds
    the specified key in an array. Assuming that <samp class="SANS_TheSansMonoCd_W5Regular_11">key</samp>
    is unique in <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>, the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">find_element</samp> function would behave
    the same without the <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    statement but, depending on the length of the array and the point at which <samp
    class="SANS_TheSansMonoCd_W5Regular_11">key</samp> is discovered, could run much
    slower.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-12: Breaking out
    of a loop</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">break</samp> bypass part of a loop body,
    use these statements carefully: the code following these statements is not executed.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">return</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement terminates
    execution of the current function and returns control to its caller. You’ve already
    seen many examples of <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statements in this book. A function may have zero or more <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'A <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement can
    simply return, or it can return an expression. Within a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    function (a function that doesn’t return a value), the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement should simply return. When a function returns a value, the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement should return an expression that produces a value of the return type.
    If a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement with
    an expression is executed, the value of the expression is returned to the caller
    as the value of the function call expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This simple function sums its parameters and returns the sum. The return expression
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp> produces a value of type
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, which matches the return
    type of the function. If this expression produced a different type, it would be
    implicitly converted to an object having the return type of the function. The
    return expression can also be as simple as returning 0 or 1\. The function result
    may then be used in an expression or assigned to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Be aware that if control reaches the closing brace of a non-<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    function (a function declared to return a value) without evaluating a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement with an expression, using the return value of the function call is undefined
    behavior. For example, the following function fails to return a value when <samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is nonnegative because the condition
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a < 0</samp> is false:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We can easily repair this defect by providing a return value when <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    is nonnegative, as shown in [Listing 5-13](chapter5.xhtml#Lis5-13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-13: The</samp> <samp
    class="I">absolute_value</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function
    returns a value along all paths.</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: However, this code still has a bug (see [Chapter 3](chapter3.xhtml)). Identifying
    this bug is left as an exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, you learned about control flow statements. Control flow statements
    allow you to create flexible programs that can repeat tasks and alter their execution
    based on program inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: Selection statements, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>, allow you to
    select from a set of statements depending on the value of a controlling expression.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iteration statements repeatedly execute a loop body until a controlling expression
    equals 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jump statements unconditionally transfer control to a new location.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn about dynamically allocated memory. Similar
    to control flow statements, you can use dynamic memory to create flexible programs
    that allocate memory based on program inputs.
  prefs: []
  type: TYPE_NORMAL
