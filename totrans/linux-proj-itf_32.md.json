["```\n#include <pthread.h>\n\nint `pthread_cancel` (pthread_t *thread*);\n```", "```\n#include <pthread.h>\n\nint `pthread_setcancelstate`(int *state*, int **oldstate*);\nint `pthread_setcanceltype`(int *type*, int **oldtype*);\n```", "```\n$ `./t_pthread_cancel`\nNew thread started\nLoop 1\nLoop 2\nLoop 3\nThread was canceled\n```", "```\n`threads/thread_cancel.c`\n#include <pthread.h>\n#include \"tlpi_hdr.h\"\n\nstatic void *\nthreadFunc(void *arg)\n{\n    int j;\n    printf(\"New thread started\\n\");     /* May be a cancellation point */\n    for (j = 1; ; j++) {\n        printf(\"Loop %d\\n\", j);         /* May be a cancellation point */\n        sleep(1);                       /* A cancellation point */\n    }\n\n    /* NOTREACHED */\n    return NULL;\n}\n\nint\nmain(int argc, char *argv[])\n{\n    pthread_t thr;\n    int s;\n    void *res;\n\n    s = pthread_create(&thr, NULL, threadFunc, NULL);\n    if (s != 0)\n        errExitEN(s, \"pthread_create\");\n\n    sleep(3);                           /* Allow new thread to run a while */\n\n    s = pthread_cancel(thr);\n    if (s != 0)\n        errExitEN(s, \"pthread_cancel\");\n\n    s = pthread_join(thr, &res);\n    if (s != 0)\n        errExitEN(s, \"pthread_join\");\n\n    if (res == PTHREAD_CANCELED)\n        printf(\"Thread was canceled\\n\");\n    else\n        printf(\"Thread was not canceled (should not happen!)\\n\");\n\n    exit(EXIT_SUCCESS);\n}\n      `threads/thread_cancel.c`\n```", "```\n#include <pthread.h>\n\nvoid `pthread_testcancel`(void);\n```", "```\n#include <pthread.h>\n\nvoid `pthread_cleanup_push`(void (**routine*)(void*), void **arg*);\nvoid `pthread_cleanup_pop`(int *execute*);\n```", "```\nvoid\nroutine(void *arg)\n{\n    /* Code to perform cleanup */\n}\n```", "```\npthread_cleanup_push(func, arg);\n...\nif (cond) {\n    pthread_cleanup_pop(0);\n}\n```", "```\n`threads/thread_cleanup.c`\n    #include <pthread.h>\n    #include \"tlpi_hdr.h\"\n\n    static pthread_cond_t cond = PTHREAD_COND_INITIALIZER;\n    static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;\n    static int glob = 0;                    /* Predicate variable */\n\n    static void     /* Free memory pointed to by 'arg' and unlock mutex */\n    cleanupHandler(void *arg)\n    {\n        int s;\n\n        printf(\"cleanup: freeing block at %p\\n\", arg);\n    free(arg);\n\n        printf(\"cleanup: unlocking mutex\\n\");\n    s = pthread_mutex_unlock(&mtx);\n        if (s != 0)\n            errExitEN(s, \"pthread_mutex_unlock\");\n    }\n\n    static void *\n    threadFunc(void *arg)\n    {\n        int s;\n        void *buf = NULL;                   /* Buffer allocated by thread */\n\n    buf = malloc(0x10000);              /* Not a cancellation point */\n        printf(\"thread:  allocated memory at %p\\n\", buf);\n\n    s = pthread_mutex_lock(&mtx);       /* Not a cancellation point */\n        if (s != 0)\n            errExitEN(s, \"pthread_mutex_lock\");\n\n    pthread_cleanup_push(cleanupHandler, buf);\n\n        while (glob == 0) {\n        s = pthread_cond_wait(&cond, &mtx);    /* A cancellation point */\n            if (s != 0)\n                errExitEN(s, \"pthread_cond_wait\");\n        }\n\n        printf(\"thread:  condition wait loop completed\\n\");\n    pthread_cleanup_pop(1);             /* Executes cleanup handler */\n        return NULL;\n    }\n\n    int\n    main(int argc, char *argv[])\n    {\n        pthread_t thr;\n        void *res;\n        int s;\n\n        s = pthread_create(&thr, NULL, threadFunc, NULL);\n        if (s != 0)\n            errExitEN(s, \"pthread_create\");\n\n        sleep(2);                   /* Give thread a chance to get started */\n\n        if (argc == 1) {            /* Cancel thread */\n            printf(\"main:    about to cancel thread\\n\");\n        s = pthread_cancel(thr);\n            if (s != 0)\n                errExitEN(s, \"pthread_cancel\");\n\n        } else {                    /* Signal condition variable */\n            printf(\"main:    about to signal condition variable\\n\");\n            glob = 1;\n        s = pthread_cond_signal(&cond);\n            if (s != 0)\n                errExitEN(s, \"pthread_cond_signal\");\n        }\n\n    s = pthread_join(thr, &res);\n        if (s != 0)\n            errExitEN(s, \"pthread_join\");\n        if (res == PTHREAD_CANCELED)\n            printf(\"main:    thread was canceled\\n\");\n        else\n            printf(\"main:    thread terminated normally\\n\");\n\n        exit(EXIT_SUCCESS);\n    }\n          `threads/thread_cleanup.c`\n```", "```\n$ .`/thread_cleanup`\nthread:  allocated memory at 0x804b050\nmain:    about to cancel thread\ncleanup: freeing block at 0x804b050\ncleanup: unlocking mutex\nmain:    thread was canceled\n```", "```\n$ `./thread_cleanup s`\nthread:  allocated memory at 0x804b050\nmain:    about to signal condition variable\nthread:  condition wait loop completed\ncleanup: freeing block at 0x804b050\ncleanup: unlocking mutex\nmain:    thread terminated normally\n```"]