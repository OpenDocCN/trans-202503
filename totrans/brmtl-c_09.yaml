- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Complex Data Types
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll move beyond arrays and simple types to create more complex
    data types. We’ll start with a simple `enum` that defines a named list of items.
    Then we’ll look at structures and unions, which hold values of different types,
    accessed by name (unlike arrays, which contain values of a single type accessed
    by number or index). To make a custom data type, we’ll combine enums, structures,
    and unions. In addition, we’ll explore how structures are used in embedded programming.
    Finally, we’ll take a look at `typedef`, which allows us to define our own data
    type from existing types.
  prefs: []
  type: TYPE_NORMAL
- en: Enums
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An *enumerated type*, or `enum`, is a data type that allows us to define a
    named list of items. For example, if we want to store a limited set of colors
    in a variable, we could enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Although this will work, we would still need to keep track of the various colors.
    Fortunately, C will do that for us if we use an `enum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: With `enum`, C does the bookkeeping for us. If we have only three colors, that’s
    not much of a problem. However, the X Window System has more than 750 named colors.
    Keeping track of all those numbers is a nontrivial process.
  prefs: []
  type: TYPE_NORMAL
- en: 'C tends to be a bit loose when it comes to types. Internally, C assigns `COLOR_RED`,
    `COLOR_BLUE`, and `COLOR_GREEN` the integer values of 0, 1, and 2, respectively.
    We normally don’t care about that, but sometimes this assignment surfaces. For
    example, this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'will print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, C does not type-check `enum` assignments. For example, the following
    statement will not generate an error or warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Our `enum` defines three colors, so the legal numbers for colors are 0, 1, and
    2—not 33\. This can be a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we write a function to print the color stored in `colorIWant`. What
    will users think when they see the following output?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing an incorrect answer like this gives the user a good indication that
    your program is broken. You can give a better one if you use the `enum` value
    to index an array. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if `colorIWant` is 33, the program will print:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Your results may vary, depending on what data there is in element 33 of a three-element
    array.
  prefs: []
  type: TYPE_NORMAL
- en: Preprocessor Tricks and Enums
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, you’ll learn how to use some advanced preprocessor directives
    to make dealing with enums a little easier. First, I want to say that 999 times
    out of 1,000, using a clever trick will cause more trouble than it’s worth. Simple
    and clear is almost always better than complex and clever. This situation is one
    of the few exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at some code that defines colors and the names of colors.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This example has two items that depend on each other: `colorType` and `colorNames`.
    The programmer who wrote it was nice enough to put in a comment indicating that
    those two items are linked, and the two items are actually defined next to each
    other. (Sometimes two items that depend on each other can be in different files
    without comments indicating the linkage.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'As programmers, we want our code to be as simple as possible. Having two different
    items that must be updated simultaneously is not ideal. We can solve this problem
    through the clever use of the preprocessor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s start with the first definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The backslash (`\`) tells the C preprocessor that the line is continued. We’ve
    put them all in the same column, so it’s obvious if we accidentally omit one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now everywhere we use `COLOR_LIST`, the C preprocessor will turn it into the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When we define the `enum`, we need our list to be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We get this by defining `DEFINE_ITEM` to output only the item name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'gets turned into this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we erase the definition of `DEFINE_ITEM` since we don’t need it anymore
    for the `enum` definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define the `colorNames` list by redefining the `DEFINE_ITEM` macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The hash mark (`#`) tells the preprocessor to change the token that follows
    into a string, so now `COLOR_LIST` will expand into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the full definition for `colorNames`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The comments are a vital part of this definition. Any time you use a cute trick
    like this, document it well so that the poor person maintaining this code has
    some idea of what you did.
  prefs: []
  type: TYPE_NORMAL
- en: Structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The C *structure* (`struct`) allows us to group together multiple items of
    different types. The items, called *fields*, are identified by name. It’s different
    from an array that defines a data structure containing items of the same type,
    and the items, called *elements*, are indexed by number. For example, consider
    this structure that groups together information describing a house:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To access an element of a structure, use the format `variable.field`, with
    a dot in the middle. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following program shows how to put this all together:'
  prefs: []
  type: TYPE_NORMAL
- en: '**struct.c**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Let’s debug this program in the STM32 Workbench (see [Figure 8-1](#figure8-1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f08001](image_fi/501621c08/f08001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-1: The `struct` variable display'
  prefs: []
  type: TYPE_NORMAL
- en: Stopping on line 20, we can now see the structure in the variable list. Clicking
    the + icon expands the structure to show what’s in it.
  prefs: []
  type: TYPE_NORMAL
- en: Structures in Memory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s take a look at how the C compiler will lay out this structure in memory.
    The compiler needs to allocate 1 byte for `stories` (`uint8_t`), 1 byte for `bedrooms`
    (`uint8_t`), and 4 bytes for `squareFeet` (`uint32_t`). Logically, the layout
    should look like [Table 8-1](#table8-1).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 8-1: Structure Layout'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Offset** | **Type** | **Field** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | `uint8_t` | `stories` |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | `uint8_t` | `bedrooms` |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | `uint32_t` | `squareFeet` |'
  prefs: []
  type: TYPE_TB
- en: '| 3 |  |'
  prefs: []
  type: TYPE_TB
- en: '| 4 |  |'
  prefs: []
  type: TYPE_TB
- en: '| 5 |  |'
  prefs: []
  type: TYPE_TB
- en: 'From [Table 8-1](#table8-1), we see that the structure takes up 6 bytes. However,
    when we run the program, we see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Where did the other 2 bytes come from?
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is memory design. On the ARM chip (and many others), memory is
    organized as a series of 32-bit integers aligned on a 4-byte boundary, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `0x10000` | 32 bits |'
  prefs: []
  type: TYPE_TB
- en: '| `0x10004` | 32 bits |'
  prefs: []
  type: TYPE_TB
- en: '| `0x10008` | 32 bits |'
  prefs: []
  type: TYPE_TB
- en: '| `. . .` |  |'
  prefs: []
  type: TYPE_TB
- en: Let’s say we want an 8-bit byte at `0x10001`. The machine fetches 32 bits from
    `0x10000` and then throws away 24 bits, which is wasteful because extra data is
    fetched, although there is no performance hit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s say we need a 32-bit integer starting at `0x10002`. Attempting to
    fetch this data directly results in an alignment exception that will abort our
    program. The computer has to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Fetch 16 bits from `0x10000`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fetch 16 bits from `0x10004`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Combine them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The internal ARM circuitry does *not* complete these steps. Instead, the compiler
    must generate multiple instructions to do the work, which isn’t good for performance.
    (We go into this in more detail later in the chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: It would be much nicer if `squareFeet` aligned on a 4-byte boundary instead
    of a 2-byte boundary, so the compiler optimizes the layout of the structure by
    adding 2 bytes of padding. This makes the structure larger but much easier to
    deal with. [Table 8-2](#table8-2) shows the structure’s actual adjusted layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 8-2: Padded Structure Layout'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Offset** | **Type** | **Field** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | `uint8_t` | `stories` |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | `uint8_t` | `bedrooms` |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | `uint8_t` | (padding) |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | `uint8_t` | (padding) |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | `uint32_t` | `squareFeet` |'
  prefs: []
  type: TYPE_TB
- en: '| 5 |  |'
  prefs: []
  type: TYPE_TB
- en: '| 6 |  |'
  prefs: []
  type: TYPE_TB
- en: '| 7 |  |'
  prefs: []
  type: TYPE_TB
- en: This extra padding is sometimes a problem. For example, if you have a lot of
    houses and very limited memory, the padding in each house structure adds up to
    a lot of wasted space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example is in embedded programming. I had an old, pre-iPod music device
    called the Rio that didn’t come with Linux tools to load the music onto the device,
    so I wrote some tools myself. Every data block had a header that looked something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When I first loaded songs on my Rio, they would play fine. But when I pressed
    Rewind to back up a few seconds, the device would go crazy and start the song
    all over again. The problem was that GCC was adding padding to the structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As a result, what the Rio thought was the previous block was instead some padding
    and half the value of the previous block. No wonder the device became confused.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution was to tell the compiler not to add padding with the `packed`
    attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `__attribute__((packed))` is a GNU extension to the C language,
    and it may not work on other compilers.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Unaligned Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, the compiler will “adjust” the alignment of elements of a structure
    for efficient memory access. As we’ve seen, hardware designers sometimes have
    different ideas, and in order to get the structure to match the hardware, we have
    to include the `__attribute__((packed))` directive.
  prefs: []
  type: TYPE_NORMAL
- en: To see why the compiler makes such adjustments, let’s write a program that does
    both aligned and unaligned 32-bit accesses. The packed structure is more compact,
    but it requires more code to access the 32-bit value. The unpacked structure is
    efficient to access, but it takes up more memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following program shows how both the packed and unpacked structures are
    accessed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'First, let’s look at the code generated to fetch an aligned `uint32_t`  1 (comments
    added):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It uses one instruction to get the address of the structure and one to get the
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s look at the unaligned fetch 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The unaligned fetch requires four instructions instead of the one required
    by an aligned fetch. The program must use two load instructions to get the two
    halves of the number: one shift to get the top half to the top of the register,
    and a logical OR to combine the two numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: Code like this must be used every time an unaligned `uint32_t` is loaded or
    stored. You can see why the compiler might want to avoid doing that and adds padding.
  prefs: []
  type: TYPE_NORMAL
- en: Structure Initialization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can initialize structures by putting the initializer list inside curly brackets
    (`{}`). For example, the following statement declares and initializes `myHouse`
    with one statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In early versions of the language, that was the only way to initialize structures.
    Later, when C99 (the C specification finalized in 1999) came along, a new feature
    called *designated initializers* was added to let you initialize fields by name.
    Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The fields must be in the same order as they are declared in the structure.
    The GCC compiler has an extension that lets you use designated initializers using
    a different method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the order does not have to match the order in which the fields
    were declared.
  prefs: []
  type: TYPE_NORMAL
- en: Structure Assignment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C does not allow you to assign one array to another, but it does allow you
    to assign one structure to another. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: If these were arrays, assignment would be illegal, but since they are structures,
    it works.
  prefs: []
  type: TYPE_NORMAL
- en: Structure Pointers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C’s parameter-passing mechanism uses *call by value*, meaning that if we pass
    a parameter to a procedure, it copies the value of the parameter onto the stack.
    This practice is not a problem when we have something small like a 2-byte integer,
    but most structures are not very small and actually can be quite large. When a
    structure is passed as a parameter, *the entire structure is copied onto the stack*,
    making it an expensive operation. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: What’s going on here is that in order to perform the “call by value” parameter
    passing, the compiler must generate code to copy `aRectangle` in its entirety
    onto the stack. For larger structures, that can use a lot of stack space and take
    up a lot of time copying the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s more efficient to pass a structure as a pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, only the pointer (a small item) is passed as a parameter. In
    the case of the ARM compiler, this is done by putting it in a register: quick,
    easy, and no stack space used.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the advantages of call by value is any changes to the parameter are not
    passed back to the caller. But we didn’t make any changes, so that’s not an issue.
  prefs: []
  type: TYPE_NORMAL
- en: When we passed parameters as pointers, we used `const` to indicate that no changes
    to the parameters were allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s a little awkward to access a member of a structure pointer using the `(*rectangle).height`
    syntax. Because of this, C has added some syntactic sugar that allows us to use
    a shortcut—the `->` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: C feels free to treat an array as a pointer and a pointer as an array. When
    an array is passed in as a parameter, the array is automatically turned into a
    pointer. When an array is specified as a procedure parameter, it is automatically
    turned into a pointer behind your back.
  prefs: []
  type: TYPE_NORMAL
- en: Saying C is “call by value” is not strictly true. It’s more precise to say,
    “C is called by value, except for arrays, which are called by pointer value.”
  prefs: []
  type: TYPE_NORMAL
- en: Structure Naming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like many things in C, the naming of structures is not all that simple. That’s
    because in a single C structure declaration, we can define a structure name (or
    not) and a variable (or not). Here’s the general syntax for a structure definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s consider the example when we don’t have a structure name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This defines the `aBox` variable, but what type is `aBox`? It is a structure
    with no name, or an *anonymous structure*. Anonymous structures can be used to
    define a variable only when the structure is defined. They do not specify a structure
    name that can be used in later declarations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s consider the case where we leave off the variable name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This defines a structure type but no variables. It can be used later to define
    a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We can put in both a structure name and a variable name in the same declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This defines both a `box` structure and a variable `aBox`.
  prefs: []
  type: TYPE_NORMAL
- en: 'C has one more trick up its sleeve—we can have a structure definition with
    no structure name and no variable name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Because there is no structure name, we can use this only to access the variable
    defined here. But no variable is defined here, so we can’t access anything, which
    means that although it’s perfectly legal, it’s also perfectly useless.
  prefs: []
  type: TYPE_NORMAL
- en: Unions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `union` is like a `struct` except that instead of each field being assigned
    a different location, all the fields are stored in the same location. Here’s an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler allocates 4 bytes for the `uint32_t` and *the same 4 bytes* for
    the `float`. Let’s take a look at this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The second assignment actually changes `anInteger` to 1065353216 (0x3f800000).
    It’s a very strange integer, but as a floating point, it’s 1.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Good programming practice is to use the same field name for storing and retrieving
    a value from an union. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: When you use different fields, the results will be different on different machines.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In this case the value of `someInt` will depend on the size of an integer, the
    size of a float, the floating-point format, and the byte order, all of which are
    processor-dependent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s talk about the byte order problem. Let’s say you have four cards
    in your hand, numbered 1, 2, 3, and 4\. You want to put them into a row of four
    boxes in front of you. So, you take the top card and put it in the leftmost box,
    you put the next card in the box to the right of that, and so on. Your boxes now
    contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 | 2 | 3 | 4 |'
  prefs: []
  type: TYPE_TB
- en: When you pick up the cards, you start at the right and put each card on top
    of the pile. The result is that you get 1, 2, 3, and 4 in order back in your hand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now another person comes along and puts the cards in the boxes starting on
    the right side and going left. Their boxes look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 4 | 3 | 2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: They pick up the cards starting at the left and work right. Again, this person
    will wind up with 1, 2, 3, and 4 in their hand, in exactly that order.
  prefs: []
  type: TYPE_NORMAL
- en: What I’ve just described is how two different CPU architectures will store numbers
    in memory. In some cases it will be 1, 2, 3, and 4 and in others 4, 3, 2, and
    1\. As long as you are storing and retrieving the same size number, byte order
    makes no difference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s say you want to store four cards in the boxes but retrieve only two,
    which means your boxes look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 | 2 | 3 | 4 |'
  prefs: []
  type: TYPE_TB
- en: When you pick up your cards, you get only 1 and 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the other person’s storage looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 4 | 3 | 2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: The leftmost *n* boxes are always used when retrieving cards, so this person
    will start at the left and grab 3 and 4, meaning they’ll get a different result.
  prefs: []
  type: TYPE_NORMAL
- en: This difference is caused by the two of you using a different order when storing
    and retrieving cards. The same thing happens in computers. Different computers
    store things in different orders. As a result, you are going to get different
    answers on different machines if you try and store one type of data and retrieve
    another.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, if you put something in `theValue.anInteger`, the only way you’re
    guaranteed to get consistent results is to take it out using only the `theValue.anInteger`
    field.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Custom Type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’re now going to take all three of our new data types—`struct`, `union`, and
    `enum`—and combine them into one large data type in order to draw a shape on the
    screen. The shape can be a square, rectangle, circle, or triangle. Each of those
    shapes can be described differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need to describe a square is a single side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To describe a rectangle, we need a width and height:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We can draw a circle with only its radius:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to draw a triangle, we describe the base and height:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'A generic shape type should hold any one of these, which indicates that we
    need a `union`. But in order to draw a shape, we need to know not only its description
    but also what type of shape it is. The `enum` data type was designed for a limited
    list of simple values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we get to define our data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The first field is `type`, which contains the type of shape contained in the
    structure. The second field contains the `dimensions` of the shape. It’s a `union`
    because different shapes have different dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to draw the shapes looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This design pattern is fairly common in C programming: a `union` that can hold
    many different types of data and an `enum` that tells which type we actually have.'
  prefs: []
  type: TYPE_NORMAL
- en: Structures and Embedded Programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we take a hardware specification and turn it into a C structure,
    using what we’ve learned so far about structures and alignment.
  prefs: []
  type: TYPE_NORMAL
- en: The small computer system interface (SCSI) was designed to provide a standard
    way of transferring data to and from devices. It started in 1986 and since has
    been expanded and enhanced a great deal. It works by sending a structure called
    a command block to the device and getting back data and status messages in return.
  prefs: []
  type: TYPE_NORMAL
- en: When first written, the SCSI standard defined the `READ (6)` command, which
    limited the block address to 16 bits, allowing for a disk of up to 16MB, which
    was large for the time. Of course, disk makers quickly created bigger disks, so
    the SCSI people had to create a new command to allow for a bigger drive. This
    was the `READ (10)` command, which was followed by the `READ (12)`, `READ (16)`,
    and `READ (32)` commands. The `READ (32)` command uses a 64-bit block address.
    Hopefully, it will take the disk manufacturers a little time to catch up and create
    an 8-zebibyte disk.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-2](#figure8-2) shows the command block for the `READ (10)` command.
    If we want to read data from the disk, we’ll need a C structure to contain this
    information and send it to the device.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f08002](image_fi/501621c08/f08002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-2: The `READ (10)` command block'
  prefs: []
  type: TYPE_NORMAL
- en: 'At first, it seems like a simple translation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Now, because we’re paranoid and careful, the first thing we did in the program
    was to put in an `assert` statement to make sure our definition matches the hardware.
    An `assert` statement aborts the program if the condition is not true. If we expect
    the `read10` control block to contain 10 bytes and it doesn’t, our program has
    a big problem. And we do too, because the `assert` fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'So what happened? Inspecting the structure, we see that the `lba` field (a
    `uint32`) is aligned on a 2-byte boundary. The compiler wants to put it on a 4-byte
    boundary, so it added 2 bytes of padding. We need to pack the structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `packed` attribute tells GCC to not add any padding. As a result, our structure
    is inefficient, but it matches the hardware. Also, our `assert` doesn’t fail,
    so we’ve done it right.
  prefs: []
  type: TYPE_NORMAL
- en: typedef
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can define our own types using the `typedef` statement. For example, the
    following statement defines a new `dimension` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This type is equivalent to an `unsigned int` and can be used like any other
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax of a `typedef` is similar to that of a variable declaration. It
    contains the `typedef` keyword and the name of the initial type, as well as the
    name of the defined type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'One example of `typedef` can be found in the *stdint.h* file, which is included
    in many of our programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In the early days of C, an `int` could be 16 or 32 bits, depending on the processor.
    In the early days of programming, if users wanted to use a 16-bit integer (which
    the old C standard didn’t support), they had to put something like this in their
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: After years of having to define our own precise data types, the C standards
    committee created the *stdint.h* header file and made it a part of the language.
  prefs: []
  type: TYPE_NORMAL
- en: Function Pointers and typedef
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C allows pointers to functions, which are useful when doing callbacks. For
    example, we might tell a graphics system to call a given function when a button
    is pressed. The code for that might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The `functionToHandleButtonPress` parameter is a pointer to a function that
    returns an integer and takes a constant event pointer as its single argument.
    That sentence is a mess, and it doesn’t get any easier when we translate it to
    C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The first set of parentheses is required because without it we define a function
    that returns an integer pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Rather than remember these convoluted syntax rules, let’s simplify the syntax
    using `typedef`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This changes the definition of `registerButtonPressHandler` from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The `typedef` provides a way of organizing types to simplify our code, as well
    as make things clearer.
  prefs: []
  type: TYPE_NORMAL
- en: typedef and struct
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve already seen how we can use `struct` to define a structured data type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'To use this structure, we must use the `struct` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The `typedef` statement allows us to avoid using the `struct` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The `typedef` in this case tells C that we want to define a new `rectangle`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Some people believe that using `typedef` to define a new structure type makes
    the code simpler and cleaner. Others prefer to use `struct` because it makes it
    obvious that a variable is a `struct`. The syntax is optional, so use whatever
    works best for you.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter is all about organizing data. The `enum` type allows you to organize
    simple name lists without having to worry about which field gets what value. Structures
    provide a powerful tool for organizing data of different types. For embedded programmers,
    they are also useful for communicating with actual hardware devices. However,
    keep in mind that a hardware designer’s idea of how a structure is laid out can
    be different from what C thinks it should be.
  prefs: []
  type: TYPE_NORMAL
- en: While structures can hold only a fixed set of data, unions can hold multiple
    sets (just not at the same time). Between the two of them, we have a great deal
    of control over how we store data.
  prefs: []
  type: TYPE_NORMAL
- en: Another tool for organizing data is the `typedef` directive, which allows us
    to define our own types. It lets us represent data using familiar types instead
    of being forced to use the basic C types.
  prefs: []
  type: TYPE_NORMAL
- en: Many complex data types exist, and C provides a good set of tools for managing
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Programming Problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a structure to hold a fraction. Then create procedures that add, subtract,
    multiply, and divide fractions. The fractions should be stored in normalized form.
    In other words, 2/4 should be stored as 1/2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a structure called `car` that holds attributes common to both electric
    and gas-powered cars. Add to it a union with two fields, `electric` and `gas`,
    that are structures that hold attributes specific to that type of car. For example,
    `numberOfPassengers` is common to all cars. The field `chargingTime` would be
    electric-only.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a structure to describe a student (single class). The data should contain
    not only the student’s name and ID number but also an array containing the student’s
    grades.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a structure to handle the data shown in [Figure 8-3](#figure8-3).![f08003](image_fi/501621c08/f08003.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8-3: IPv4 header format'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The Southern California Railroad has the only Acme Traffic Signal (the one
    with arms and lights) actually at an intersection. To change the signal from STOP
    to GO, the controller must do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Turn off the STOP light.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Turn on the GO light.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Turn on the DIRECTION relay.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Energize the ARM relay.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait 3 seconds.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Turn off the ARM relay.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Turn off the DIRECTION relay.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have the following commands available: (1) change state of light *x* to
    *y*, where *x* is STOP or GO, and *y* is ON or OFF; (2) set DIRECTION relay power
    to *x*, where *x* is ON or OFF; and (3) sleep for *n* seconds. Write a structure
    for each command. Then write a union that holds an `enum` to identify the command
    and the structure for the given command.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
