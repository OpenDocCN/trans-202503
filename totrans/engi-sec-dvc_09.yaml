- en: '**7'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SECURE COMMUNICATION**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the past, many embedded systems operated in an *air-gapped* environment,
    not connected to any wired or wireless network. Although this practice is still
    present in some industries, it’s slowly vanishing for the simple reason that none
    of the modern ideas like predictive maintenance, data-driven optimization, and
    remote access work without proper communication channels.
  prefs: []
  type: TYPE_NORMAL
- en: Even the first cryptographic methods in the days of Caesar aimed to protect
    communication, and 2,000 years later, the internet is inconceivable without secure
    communication. However, a significant number of *devices* still don’t use secure
    protocols for data exchange with their administrators and other entities in their
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll first look at the set of requirements that’s imposed
    on robust communication channels, followed by an introduction to the most common
    protocol to tackle these challenges and a corresponding practical case study.
    Afterward, we’ll look at two areas where the standard solution doesn’t help: non-IP
    communication and the need for redundancy.'
  prefs: []
  type: TYPE_NORMAL
- en: '**All the Protection Goals**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Communication is inherent to human nature. We exchange thoughts, provide assistance
    to others, and work together in teams. Every child who whispers something into
    somebody’s ear is implicitly aware of confidentiality protection.
  prefs: []
  type: TYPE_NORMAL
- en: For written messages, confidentiality has been a topic for thousands of years,
    as the example of Caesar shows, and it’s still present in postal privacy laws.
    For centuries, monarchs have used royal seals to guarantee the integrity and authenticity
    of documents, while replication of information by letterpress printing clearly
    targets availability—even if one “information source” fails, still others can
    be used to acquire that same “communication data.”
  prefs: []
  type: TYPE_NORMAL
- en: Digital communication at internet scale has been practiced for roughly 30 years,
    and it’s not surprising that it unites the demands for *all the protection goals*
    of previous communication approaches. Considering the specific field of (I)IoT
    device communication, confidentiality is apparently useful, because either proprietary
    values corresponding to intellectual property are transferred or personal data
    about humans is communicated that deserves privacy protection.
  prefs: []
  type: TYPE_NORMAL
- en: Also, integrity and authenticity are valued in many cases—for example, for control
    commands in industrial systems. In those scenarios, it’s very important that the
    origin of communication is a legitimate party and that messages haven’t been altered
    on the way. As mentioned before, typical (I)IoT devices rely on working communication
    channels. Disturbances—for example, those introduced by DoS attacks—threaten proper
    system operation and maybe even related business models.
  prefs: []
  type: TYPE_NORMAL
- en: '**Transport Layer Security**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we talk about data communication, we usually start by locating it within
    the *Open Systems Interconnection (OSI) model*. This model supports us in structuring
    stacks of communication protocols, as shown in [Table 7-1](ch07.xhtml#ch07tab01).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-1:** Communication Layers According to the OSI Model'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Number** | **Layer** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | Application | Application-specific communication data processing |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | Presentation | Translation between network data and application |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Session | Session management for communication between nodes |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Transport | Management of data transmissions between network nodes |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Network | Management of a multiparticipant network |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Data link | Transfer of data frames between two entities |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Physical | Wired/wireless transmission over a physical medium |'
  prefs: []
  type: TYPE_TB
- en: The Ethernet standard IEEE 802.3 is a typical example that specifies properties
    for layers 1 and 2\. Often, Internet Protocol (IP) handles the network layer,
    while Transmission Control Protocol (TCP) and User Datagram Protocol (UDP) cover
    functionalities in layers 4 and 5\. Application protocols like the common HyperText
    Transfer Protocol (HTTP) are represented by layer 7.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section focuses on one of the most common protocols for secure communication:
    Transport Layer Security (TLS). It might seem obvious that it’s located on layer
    4 of the OSI model; however, encryption and decryption are usually attributed
    to layer 6\. And since TLS also performs some kind of session management, we could
    say that it spans across layers 4 to 6 and, thereby, introduces a protection layer
    between raw packets distributed over a network and the application using the transmitted
    data in the end.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*TLS is application agnostic. Its payload might carry any application protocol
    like HTTP or even industrial protocols like Modbus.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***History***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the 1990s, while Netscape was working on a browser application of the same
    name, the need for secure internet communication became apparent. In 1995, Netscape
    published the predecessor of TLS, the Secure Sockets Layer (SSL) protocol in version
    2.0\. SSL 2.0 and SSL 3.0, released the following year, had significant security
    issues and should never be used in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, many software applications as well as product marketing brochures
    use *SSL* and *TLS* synonymously. Usually, you can assume it’s “a modern TLS version,”
    but as a customer, I would have much more confidence if the manufacturer would
    show its security know-how by not mentioning SSL anymore, anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: The new protocol name was introduced in 1999 with TLS 1.0 (which was an upgraded
    version of SSL 3.0), maybe to reduce association with the weaknesses of the previous
    SSL versions. TLS 1.1 fixed security issues with the CBC operation mode of block
    ciphers in 2006\. However, both TLS 1.0 and TLS 1.1 were officially deprecated
    in March 2021 and should not be used in modern products.
  prefs: []
  type: TYPE_NORMAL
- en: Version 1.2 of TLS was specified in August 2008 and is still widely in use.
    It replaced the use of weak hash functions like MD5 and SHA-1 with their modern
    counterpart, SHA-256, and extended the support for authenticated encryption ciphers
    like AES-GCM. However, the complexity of TLS 1.2 became its own enemy, and correct
    configuration was not trivial. To minimize configuration mistakes and maximize
    security and performance at the same time, TLS 1.3 was published in 2018\. Every
    new device should use that version by default.
  prefs: []
  type: TYPE_NORMAL
- en: '***TLS Basics***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'TLS is a set of client-server protocols that unite many modern cryptographic
    primitives introduced in [Chapter 2](ch02.xhtml#ch02). These are the two most
    important sub-protocols in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Handshake protocol**    In this subprotocol, the cryptographic algorithms
    used to protect a communication channel are negotiated between client and server.
    Usually, at least one of them is authenticated to the other, but mutual authentication
    is also possible. Additionally, the handshake process establishes shared key material
    for the crypto algorithms used in the following communication. Any errors or tampering
    attacks at this stage lead to the termination of the connection.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Record protocol**    This subprotocol is responsible for organizing and protecting
    the bulk of traffic between two endpoints based on the algorithms and parameters
    negotiated in the handshake protocol.'
  prefs: []
  type: TYPE_NORMAL
- en: A further general property of TLS is that it uses X.509 certificates for authentication.
    However, in contrast to the device certificates mentioned in [Chapter 6](ch06.xhtml#ch06),
    the common name in these certificates usually corresponds to the device’s IP address,
    its hostname, or its fully qualified domain name (FQDN). This is because the information
    is used to establish the basic connection to the device on the network layer in
    the first place, and the device then has to prove that it’s the legitimate entity
    at this network node.
  prefs: []
  type: TYPE_NORMAL
- en: Never underestimate the complexity of TLS, and stick to secure defaults whenever
    you don’t have specific requirements to change them. The following sections shed
    light on the main properties of the two TLS versions in use today.
  prefs: []
  type: TYPE_NORMAL
- en: '***TLS 1.3***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: TLS 1.3 is specified in RFC 8446 and is *the* version that product engineers
    should implement and use. [Figure 7-1](ch07.xhtml#ch07fig01) illustrates the handshake
    process for mutual authentication that could, for example, be part of a machine-to-machine
    communication scenario.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: A typical TLS 1.3 handshake with mutual authentication*'
  prefs: []
  type: TYPE_NORMAL
- en: In the first step, the client initiates the connection establishment by sending
    the `ClientHello` ➊ message to a server. This message contains the client’s key
    share for a DHE or ECDHE key agreement scheme, its supported TLS version, and
    a list of available crypto algorithms and parameters. In response, the server
    provides its own data for the intended key exchange, its certificate, and a signature
    proving the possession of the corresponding private key. Further, it requests
    the client to authenticate itself and concludes the `ServerHello` ➋ of the handshake
    with a `Finished` message.
  prefs: []
  type: TYPE_NORMAL
- en: In the third part of the handshake, the client fulfills the server’s certificate
    request by sending its certificate and a signature proving its identity ➌. After
    the client’s `Finished` message, both parties can be sure about the other’s identity
    and are prepared to securely exchange application data ➍.
  prefs: []
  type: TYPE_NORMAL
- en: '**Further Handshake Options**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Besides key-agreement schemes like DHE and ECDHE that guarantee perfect forward
    secrecy but also consume significant performance, TLS 1.3 also provides a *pre-shared
    key (PSK)* option, which distributes keys to devices in an earlier process. However,
    this isn’t the default variant and should be used only in exceptional cases and
    for solid reasons.
  prefs: []
  type: TYPE_NORMAL
- en: To reduce the necessity for the execution of a complete handshake, TLS 1.3 allows
    you to reuse PSKs from previous (EC)DHE handshakes if the client and server agree
    on it, which means costly asymmetric crypto operations can be spared and efficiency
    is enhanced.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a client and server share a PSK, TLS 1.3 provides a zero round-trip time
    (0-RTT) mode that allows a client to send PSK-encrypted data with its first message,
    immediately enabling application data communication. However, this speed improvement
    comes at a price: perfect forward secrecy can’t be guaranteed anymore, and the
    0-RTT messages are not protected against replay of messages obtained earlier.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Selection of Crypto Algorithms**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Compared to TLS 1.2, TLS 1.3 has significantly reduced the set of possible crypto
    algorithms to be used. This is a strong security enhancement, since it prevents
    *downgrade attacks* that try to influence crypto parameter negotiation to force
    the usage of weak algorithms. In the course of this cleanup, the *cipher suite*,
    a collection of supported crypto algorithms, was reduced to contain symmetric
    crypto only.
  prefs: []
  type: TYPE_NORMAL
- en: For this symmetric cryptography, TLS 1.3 requires the implementation of the
    `TLS_AES_128_GCM_SHA256` cipher suite, which means that AES with a 128-bit key
    has to operate in GCM mode, and the hash function SHA-256 must be available to
    be used as an HMAC-based extract-and-expand key derivation function (HKDF), which
    is relevant to derive TLS secrets. The additional `TLS_AES_256_GCM_SHA384` and
    `TLS_CHACHA20_POLY1305_SHA256` cipher suites should also be implemented but aren’t
    mandatory. Two cipher suites based on the CCM mode complete the five possible
    options for symmetric crypto in TLS 1.3, and they all belong to the class of modern
    AEAD algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding digital signature algorithms and certificates, TLS 1.3 implementations
    must support RSA PSS and PKCS1 in combination with SHA-256, but also ECDSA based
    on the NIST curve `secp256r1` and SHA-256\. The mandatory curve for ECDHE is also
    `secp256r1`, but the RFC recommends the additional implementation of X25519\.
    DHE based on finite field groups is also possible.
  prefs: []
  type: TYPE_NORMAL
- en: '***TLS 1.2***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although TLS 1.3 is the most recent version, many devices still rely on TLS
    1.2 specified in RFC 5246, or at least support its use to maintain compatibility
    to legacy devices. However, this requires taking precautions to guarantee secure
    communication.
  prefs: []
  type: TYPE_NORMAL
- en: '**TLS 1.2 vs. TLS 1.3**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A somewhat formal difference between TLS 1.2 and TLS 1.3 is that version 1.2
    cipher suites include asymmetric as well as symmetric algorithms and parameters.
    For example, the `TLS_DH_RSA_WITH_AES_256_CBC_SHA384` cipher suite specifies that
    DH (without the *E* for *ephemeral*) is used for key exchange; authentication
    is based on an RSA certificate; AES with a 256-bit key in CBC mode is used for
    payload encryption, and SHA-384 is the hash function used in the key-derivation
    scheme.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the different cipher suite format, TLS 1.2 supports and allows
    a much larger set of crypto algorithms, which can have negative consequences in
    several cases. Besides the possibility of choosing static key-exchange mechanisms
    based on RSA and DH, it’s even possible to select cipher suites that explicitly
    allow anonymous DH key exchange, which means without any verification of the communication
    partner.
  prefs: []
  type: TYPE_NORMAL
- en: TLS 1.2 also allows you to select legacy ciphers like 3DES and Rivest Cipher
    4 (RC4) or even the `NULL` cipher without payload encryption. Further, operation
    modes like CBC can be selected that don’t lead to AEAD-compliant security.
  prefs: []
  type: TYPE_NORMAL
- en: The option to compress data before transmitting it over TLS was well-meant by
    the designers and is still available in TLS 1.2, but it facilitates vulnerability,
    as shown by the Compression Ratio Info-Leak Made Easy (CRIME) attack.
  prefs: []
  type: TYPE_NORMAL
- en: Besides those security-related differences, TLS 1.2 also misses some performance
    optimizations introduced by TLS 1.3 and the 0-RTT mode.
  prefs: []
  type: TYPE_NORMAL
- en: '**Secure Usage**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The key to the secure configuration of TLS 1.2 lies in the strong restriction
    of its options. Your implementation must disallow deprecated ciphers like 3DES,
    RC4, weakened export ciphers, CBC operation mode, and (of course) the `NULL` cipher.
    Key exchange based on RSA key transport has to be denied as well as anonymous
    DH. Further, options like data compression have to be disabled to reduce the attack
    surface.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at it the other way around, your configuration should enable only cipher
    suites that implement DHE and ECDHE key exchange and symmetric AEAD ciphers in
    combination with hash functions from the SHA-2 family, which means TLS 1.2 can
    be trimmed to behave similarly to TLS 1.3 and provide secure communication channels.
  prefs: []
  type: TYPE_NORMAL
- en: '***Requirements for Devices and Infrastructure***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Assuming you’ve decided that TLS is the way to go for your device and you want
    to make things happen, you still have some requirements to consider before implementing
    a semi-secure communication helter-skelter. From a device perspective, you should
    analyze at least five aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Private-key storage**    If your device has to be able to authenticate itself
    by signing data with a private key, it needs a secure place to store that secret
    in a confidential way.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Certificate store**    The verification of communication partners’ identities
    is possible only if your device is in possession of corresponding public keys
    and root certificates. These files don’t contain confidential information but
    need to be stored in an integrity-protected way because they represent your device’s
    trust base.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Trustworthy source of randomness**    Key-generation and key-exchange schemes
    in TLS require the availability of trustworthy random numbers. If your device
    generates “random numbers” based on a static value, this might have severe consequences
    for TLS security.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reliable time base**    Especially in industrial scenarios, but also in other
    application domains, devices often don’t need a real-time clock. However, if you
    want to use TLS, your device has to be able to verify the validity period of certificates,
    which is clearly not possible if it’s stuck in the 1980s time-wise.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Crypto performance**    The TLS handshake performs several operations based
    on asymmetric crypto. Low-performance devices might reach their limit, for example,
    if they have to perform signing with RSA keys. The basic decision of RSA or ECDSA
    might have a strong impact on this point. It also makes a big difference if your
    device is meant to act as a client authenticating once a day, or if it has to
    handle hundreds of connection and authentication requests per minute as a server.'
  prefs: []
  type: TYPE_NORMAL
- en: Not only does your device itself need to be prepared for TLS, but also your
    infrastructure and processes need to support it. A common example is the operation
    of a PKI to manage the generation, updating, and revocation of certificates.
  prefs: []
  type: TYPE_NORMAL
- en: Further, the real-time clock in your device probably depends on external time
    synchronization mechanisms like Network Time Protocol (NTP) and Precision Time
    Protocol (PTP), which require appropriate network services, master clocks, and
    the like.
  prefs: []
  type: TYPE_NORMAL
- en: '***Application Examples and Software Libraries***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The most common use case for TLS is HyperText Transfer Protocol Secure (HTTPS),
    the protocol used throughout the internet. It’s also known as *HTTP over TLS*,
    because that’s essentially what’s happening: TLS establishes a secure channel
    between a client and a web server. Within this channel, plain HTTP requests and
    responses are exchanged. In the same way, secure communication can be achieved
    for many other application protocols.'
  prefs: []
  type: TYPE_NORMAL
- en: TLS is based on TCP, but is there a way to protect applications like Voice over
    IP (VoIP) or online gaming that rely on UDP or other stateless protocols? Yes,
    you can use a variant called *Datagram Transport Layer Security (DTLS)*. DTLS
    1.2 and DTLS 1.3 are based on TLS 1.2 and TLS 1.3, respectively. They guarantee
    the same security as their TCP-based counterparts but can handle loss and reordering
    of packets.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to TLS implementations, OpenSSL is probably the most popular one
    on Linux systems as well as in the field of embedded systems. However, if either
    source code transparency or small footprint are of interest to your product, Mbed
    TLS might be worth a look. Further, implementations are available in a multitude
    of programming languages, such as Rustls for the Rust community.
  prefs: []
  type: TYPE_NORMAL
- en: '**Case Study: Secure MQTT Communication**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Over the last few years as a professor, I’ve seen several student projects using
    the MQTT protocol, because it’s pretty comprehensible and perfectly suits the
    needs of resource-constrained devices in IoT scenarios. It’s used to transmit
    sensor values like temperature or pressure as well as to control messages like
    start and stop commands for actuators in a system.
  prefs: []
  type: TYPE_NORMAL
- en: However, if I ask for a secure communication channel for the obviously sensitive
    message content, I usually get responses like “But it’s only a proof of concept!”
    or “There was no time left to tackle this complex topic.” And, “Why do you always
    ask such painful questions?”
  prefs: []
  type: TYPE_NORMAL
- en: In this case study, I’ll set up the Eclipse Mosquitto MQTT broker service on
    my STM32MP157F-DK2 board and configure it properly for secure communication based
    on TLS. Further, I’ll dynamically test the implementation for misconfigurations.
  prefs: []
  type: TYPE_NORMAL
- en: '***Mosquitto Installation and Configuration***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because the toolchain for my STM32MP157F-DK2 device is based on the Yocto Project,
    I can simply add the `mosquitto` recipe from `recipes-connectivity` of the `meta-networking`
    layer to my image to install the broker software on my device. The version I get
    is `2.0.14`. Of course, this comes only with a default configuration located at
    */etc/mosquitto/mosquitto.conf*.
  prefs: []
  type: TYPE_NORMAL
- en: In MQTT, the broker is a central component that receives messages and data published
    by clients and distributes this information to clients that subscribe to it. For
    clients, it’s essential to share their data only with legitimate brokers and rely
    on messages only from brokers they trust. Therefore, MQTT brokers have to cryptographically
    authenticate to connecting clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned previously, TLS uses certificates for authentication, so the first
    step for broker authentication is to generate a corresponding certificate. I used
    Python and OpenSSL to create a CA and a MQTT broker certificate in a similar way,
    as described for device identities in [Chapter 6](ch06.xhtml#ch06). An important
    difference is the chosen common name in the certificate: it corresponds to the
    hostname *http://mqtt.iot-device-corp.com/* under which the device can be reached
    within my network. This is important for hostname verification by the clients,
    so they can be sure to be connected to the correct host.'
  prefs: []
  type: TYPE_NORMAL
- en: Armed with the CA certificate `ca.crt`, the broker certificate `mqtt_broker.crt`,
    and its corresponding private key `mqtt_broker.key`, we can configure the basic
    TLS settings for `mosquitto` as shown in [Listing 7-1](ch07.xhtml#ch07list01).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-1: The basic TLS configuration for* mosquitto'
  prefs: []
  type: TYPE_NORMAL
- en: While plain MQTT is usually offered at port 1883, the version using secure communication
    based on TLS is typically provided at port 8883\. Required certificates and keys
    can, for example, be stored in */etc/mosquitto/ certs/*. So far, so good.
  prefs: []
  type: TYPE_NORMAL
- en: However, up until now, the system is configured only for server-side authentication.
    Client authentication would have to be managed by maintaining a password file
    on the device hosting the broker application (for example, at */etc/mosquitto/password_file*),
    which might be tedious, and the associated security level would be medium at best.
    But since TLS supports mutual certificate-based authentication, and Mosquitto
    is able to utilize that procedure for application layer usage, it’s worth a look.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-2](ch07.xhtml#ch07list02) shows the two options that have to be
    added to *mosquitto.conf*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-2: Important options for certificate-based authentication of MQTT
    clients*'
  prefs: []
  type: TYPE_NORMAL
- en: The first line makes the broker request a certificate for authentication from
    each connecting client, while the second line enables the use of the common name
    contained in the provided certificate as the username in the MQTT application.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that, in this case, the client certificate has to be
    issued by the CA provided before by the `cafile` parameter. If you want to provide
    several trusted CAs to Mosquitto, the `capath` option is your friend. In my case,
    I just used the same CA as for the MQTT broker to create a further certificate,
    this time with the common name `mqtt-client123`.
  prefs: []
  type: TYPE_NORMAL
- en: '***The First Test Run***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After starting `mosquitto` with the new configuration file, a brief `nmap` scan
    reveals that the MQTT broker is now available at port 8883, as shown in [Listing
    7-3](ch07.xhtml#ch07list03).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-3: An* nmap *scan showing open port 8883*'
  prefs: []
  type: TYPE_NORMAL
- en: To test the secure communication, I wrote a little Python script that uses the
    Eclipse Paho MQTT client library. [Listing 7-4](ch07.xhtml#ch07list04) shows the
    basic settings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-4: The basic Paho MQTT client configuration in Python*'
  prefs: []
  type: TYPE_NORMAL
- en: Besides obvious necessities like the hostname and the port of the MQTT broker,
    the client is also able to handle TLS settings like a trusted CA in *ca.crt*,
    and the client’s authentication data located in the *mqtt_client.crt* and *mqtt_client.key*
    files.
  prefs: []
  type: TYPE_NORMAL
- en: In the test application, the client subscribes to the topic `foo/bar`, publishes
    some data to the same topic, and receives the information again from the broker,
    as shown in [Listing 7-5](ch07.xhtml#ch07list05).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-5: The* mosquitto *console output during a test*'
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, a connection was successfully established on port 8883 ➊. Also, `mosquitto`
    directly uses the client certificate’s common name (`mqtt-client123`) as the associated
    username ➋ for this connection. Both client commands, `SUBSCRIBE` ➌ and `PUBLISH`
    ➍, are correctly received and handled on the broker side as well.
  prefs: []
  type: TYPE_NORMAL
- en: '***Communication Security Analysis with Wireshark and SSLyze***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The application seems to be working properly even though we already activated
    several TLS security features. That raises hope, but as security engineers, we’d
    prefer to base our trust on thorough analysis rather than gut feelings.
  prefs: []
  type: TYPE_NORMAL
- en: One of the tools for such analysis is Wireshark. It allows us to capture network
    communication traffic and analyze it for security properties. I first configured
    it to collect all exchanged data between the test station and the STM32MP157F
    device. Afterward, I filtered for TLS packets. [Figure 7-2](ch07.xhtml#ch07fig02)
    shows a snippet of the result.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: The TLS messages exchanged during MQTT communication*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that a TLS handshake with its characteristic `ClientHello` and `ServerHello`
    messages took place. Afterward, encrypted `Application Data` packets were transmitted
    between client and broker.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Figure 7-3](ch07.xhtml#ch07fig03), Wireshark also provides the
    details of the TLS negotiation—namely, that the cipher suite `TLS_AES_256_GCM_SHA384`
    was selected for bulk data transmissions. This, in turn, tells us that TLS 1.3
    is used, because that specific cipher suite belongs to the most recent TLS version.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: The details of the TLS handshake*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Be careful when analyzing the TLS version used in network traffic. The legacy*
    Version *field says it’s* TLS 1.2*, but it’s not.*'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, it seems that functionality and security measures work as expected.
    Let’s use one more tool to finalize our confidence in this work. The SSLyze Python
    application is able to test TLS servers of all kinds regarding a variety of pitfalls
    and misconfigurations that would lower your product’s security if they go unnoticed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start the TLS scan, simply enter the hostname and corresponding port: sslyze
    mqtt.iot-device-corp.com:8883.'
  prefs: []
  type: TYPE_NORMAL
- en: The comprehensive results shed light on some interesting details. The extract
    shown in [Listing 7-6](ch07.xhtml#ch07list06) deals with certificate verification.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-6: The* sslyze *console output regarding certificate verification*'
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that I created the certificate correctly, which means that
    I included the correct server name of my device as the common name in the certificate
    ➊. However, many `FAILED` entries ➋ also occur. This happens because my certificate
    is not part of the popular certificate stores from Android, Windows, Mozilla,
    and the like, which was never the plan, but if you aim for broad trust compatibility
    of your certificates, this test might be important for you.
  prefs: []
  type: TYPE_NORMAL
- en: The main part of the results is about the cipher suites and TLS versions that
    a server accepts. The results in [Listing 7-7](ch07.xhtml#ch07list07) indicate
    that deprecated TLS versions and their corresponding cipher suites are all rejected
    by the implemented MQTT broker as intended. The default settings of `mosquitto`
    already seem to prohibit the use of these old protocols and ciphers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-7: The desired rejection of all deprecated cipher suites*'
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Listing 7-8](ch07.xhtml#ch07list08), the standard settings of `mosquitto`
    still support TLS 1.2, which is a good thing regarding backward compatibility,
    because many legacy devices in the field don’t support TLS 1.3, but the list of
    supported cipher suites as given by `sslyze` exhibits some weaknesses.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-8: The offered TLS 1.2 ciphers*'
  prefs: []
  type: TYPE_NORMAL
- en: The output shows that the implementation at hand still offers options that allow
    for RSA-based key exchange (`TLS_RSA_WITH_...`) and others that still use the
    CBC operation mode for AES encryption of application data. Both are not supported
    by TLS 1.3 and are not recommended anymore.
  prefs: []
  type: TYPE_NORMAL
- en: This insight allows us to adjust the *mosquitto.conf* file again by specifying
    the parameter `ciphers`, as shown in [Listing 7-9](ch07.xhtml#ch07list09).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-9: The restriction of TLS 1.2 ciphers in* mosquitto.conf'
  prefs: []
  type: TYPE_NORMAL
- en: This restricts the TLS 1.2 ciphers of `mosquitto` to only six modern options
    for RSA-based authentication and three for ECDSA certificates, which means the
    security of the MQTT communication at hand is enhanced one step further.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Mosquitto relies on OpenSSL for secure TLS communication. Enter* openssl ciphers
    *to list all ciphers offered by OpenSSL on a specific system.*'
  prefs: []
  type: TYPE_NORMAL
- en: Regarding TLS 1.3, the recommended cipher suites are supported correctly, as
    shown in [Listing 7-10](ch07.xhtml#ch07list010).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-10: TLS 1.3 support is available as intended*'
  prefs: []
  type: TYPE_NORMAL
- en: This is the base for future-proof device communication.
  prefs: []
  type: TYPE_NORMAL
- en: '**Secure Communication Without TLS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned multiple times in this chapter, TLS should be the default solution
    if your device needs to communicate securely. However, not all application scenarios
    and communication technologies allow TLS to be used.
  prefs: []
  type: TYPE_NORMAL
- en: For example, wireless communication for dedicated use cases like sensor or mesh
    networks might rely on proprietary protocols that don’t include a TCP/IP stack.
    Further, some wired bus architectures like the controller area network (CAN) bus
    specify their own message format and data structures without relying on TCP/IP
    technology, and they might require a certain real-time behavior that can’t be
    guaranteed with TLS. Also, very power-constrained devices like battery-powered
    remote control units for alarm systems, garage doors, and industrial cranes often
    use frequencies of 433 and 868 MHz within the license-free industrial, scientific,
    and medical (ISM) radio band, and they optimize message content and lengths for
    energy consumption, which renders a TLS handshake impossible.
  prefs: []
  type: TYPE_NORMAL
- en: However, it would be naive to conclude that these applications have to live
    without security measures because TLS doesn’t fit. The issue just requires a different
    development approach. For those cases, usually no out-of-the-box solution exists,
    but custom, application-specific security protocols have to be developed. Of course,
    having extensive experience in cryptography, protocol design, and verification
    of such systems would be useful, but, in reality, that’s rarely the case.
  prefs: []
  type: TYPE_NORMAL
- en: A pragmatic approach could be to regard TLS 1.3 and the cryptographic primitives
    it uses as a self-service store. If you’re looking for specific protection measures
    (for example, to protect authenticity and integrity of commands sent by your remote
    control), digital signatures based on RSA or ECDSA would be a reliable solution.
    Whether you decide to work with certificates, as TLS does, or manage the raw public
    keys yourself depends on your requirements and possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if your CAN bus traffic contains confidential messages, and integrity
    is also on your wish list, AES-GCM or ChaCha20-Poly1305 might be suitable candidates.
    If your scenario allows for management and distribution of pre-shared secrets,
    you can spare the costly key-exchange algorithms. If not, DHE or ECDHE, as used
    by TLS 1.3, might be the algorithms of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: This sounds rather shallow and, to some extent it is, because you have to clarify
    hundreds of details on the way to your specific implementation. However, this
    information gives you some guidance as to where your journey needs to go.
  prefs: []
  type: TYPE_NORMAL
- en: '**Redundancy in Secure Communication**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you’ve made it to this point, you’ve read a lot about how secure communication
    can be achieved by using TLS and its magical crypto features to protect confidentiality
    and integrity of messages as well as authenticity of communication partners. However,
    at the beginning of this chapter, I said that communication demands all the protection
    goals, including availability. But to be clear: TLS and cryptography in general
    are *not able to protect availability*.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, in some use cases, the availability of transmitted data is essential—for
    example, in domains where technical safety measures protect humans from accidents
    and injuries, but also in systems where downtime leads to significant financial
    losses, as in production or transportation. In those applications, if a message
    is lost, the correct functionality of a device or a whole system is at risk. These
    threats have to be handled by *logical or physical redundancy*.
  prefs: []
  type: TYPE_NORMAL
- en: Approaching this problem on a logical level means sending messages multiple
    times or adding redundancy data generated by error-detecting codes like CRC checksums
    or error-correcting algorithms like Hamming codes. This is useful for transmissions
    over noisy or unreliable channels and to handle disturbance events originating,
    for example, from electromagnetic interference or cosmic radiation. However, these
    measures don’t offer adequate protection against deliberate destruction and continuous
    interruption of a physical communication line.
  prefs: []
  type: TYPE_NORMAL
- en: The only way to be resilient in such situations is to implement multiple physical
    communication channels. A common example is a *ring topology*, used in many industrial
    infrastructures to connect devices to one another in a ring-like structure. However,
    that configuration requires devices to have two network interfaces, left and right,
    and messages always have to be sent in both directions and can be received on
    two different interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: This leads to engineering and component efforts on each device, and the system
    installation as a whole becomes more expensive. In addition, the communication
    delay depends on the number of devices in the ring, and the bandwidth has to be
    shared among all network participants. However, this physical redundancy is robust
    against corrupted messages, broken or cut cables, and even device replacement
    during system operation. The international standard IEC 62439 describes several
    ways to achieve high availability in industrial networks, for example, based on
    a ring or a mesh topology.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The IoT and its industrial counterpart are not possible without secure communication.
    A variety of protection goals from confidentiality to integrity to authenticity,
    and even availability, are demanded for modern communication channels. Besides
    the necessary cryptographic capabilities, devices need to support state-of-the-art
    protocols like TLS 1.3 to achieve a high security level. In some use cases, where
    the loss of messages is critical and redundant physical communication media are
    required, devices even have to provide multiple communication interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter’s case study showed an example implementation of a MQTT-broker
    with TLS-based communication and the necessary configuration parameters. It showed
    that thorough security analysis of the final result can help spot misconfigurations
    and weak cipher suites offered by a service.
  prefs: []
  type: TYPE_NORMAL
- en: Although TLS is one of the most common and most popular security protocols,
    many others exist that are meant for dedicated applications. For example, Internet
    Protocol security (IPsec) can be used to establish a virtual private network (VPN)
    on OSI layer 3, while the SSH protocol enables remote access to devices for administrators.
    On OSI layer 2, the idea of Time-Sensitive Networking (TSN) takes care of communication
    channel separation on a shared physical medium, while IEEE 802.1AE (also known
    as *MACsec*) aims for protected communication.
  prefs: []
  type: TYPE_NORMAL
- en: And even if you don’t find any protocol that directly suits your needs, the
    conglomeration of modern security protocols can definitely serve as inspiration
    for solving your specific challenges.
  prefs: []
  type: TYPE_NORMAL
