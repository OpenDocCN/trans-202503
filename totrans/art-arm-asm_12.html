<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch9">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_477" aria-label="477"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch9">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">9</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">NUMERIC CONVERSION</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="378" height="378"/>&#13;
</figure>&#13;
<p class="ChapterIntro">This chapter discusses basic conversions between various numeric formats, including integer to decimal string, integer to hexadecimal string, floating-point to string, hexadecimal string to integer, decimal string to integer, and real string to floating-point. It also covers error handling for string-to-numeric conversions, as well as performance enhancements. Finally, it introduces standard-precision conversions (for 8-, 16-, 32-, and 64-bit integer formats) and extended-precision conversions (for example, 128-bit integer/string conversions).</p>&#13;
<p class="TX">In this chapter, you’ll begin to solve problems directly in assembly language, rather than translating a solution from an HLL as you did in previous chapters. Some examples here first present code that solves a problem with an HLL-based solution, then provide an optimized assembly language <span role="doc-pagebreak" epub:type="pagebreak" id="pg_478" aria-label="478"/>solution. This should help you learn to solve assembly language problems without relying on HLLs, thereby producing higher-quality programs.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-105"/><span class="SANS_Futura_Std_Bold_B_11">9.1 Converting Numeric Strings to Values</span></h3>&#13;
<p class="TNI1">Up to this point, this book has relied on the C stdlib to perform numeric I/O (writing numeric data to the display and reading numeric data from the user). However, the library doesn’t provide extended-precision numeric I/O facilities (and even 64-bit numeric I/O is questionable; this book has been using a GCC extension to <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span> to do 64-bit numeric output). Therefore, it’s time to break down how to do numeric I/O in assembly language.</p>&#13;
<p class="TX">Because most OSes support only character or string input and output, you won’t actually do numeric I/O. Instead, you’ll write functions that convert between numeric values and strings, then do string I/O. The examples in this section work with 64-bit (non-extended-precision) and 128-bit values, but the algorithms are general and extend to any number of bits.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h4 class="H2" id="sec2"><span id="h2-167"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">9.1.1 Numeric Values to Hexadecimal Strings</span></h4>&#13;
<p class="TNI1">In this section, you’ll learn to convert numeric values (bytes, half words, words, double words, and so on) to a character string containing the equivalent hexadecimal characters for the value. To begin, you need a function that converts a 4-bit nibble into a single ASCII character in the range <span class="SANS_TheSansMonoCd_W5Regular_11">'0'</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">'9'</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">'A'</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">'F'</span>. In an HLL such as C, you could write this as follows:</p>&#13;
<pre id="pre-725"><code>// Assume nibbleIn is in the range 0-15: &#13;
&#13;
charOut = nibbleIn + '0'; &#13;
if(charOut &gt; '9') charOut = charOut + ('A' - '9' - 1); </code></pre>&#13;
<p class="TX">You can convert any numeric value in the range 0 to 9 to its corresponding ASCII character by ORing the numeric value with <span class="SANS_TheSansMonoCd_W5Regular_11">'0'</span> (0x30). Unfortunately, this maps numeric values in the range 0xA through 0xF to 0x3A through 0x3F, so the C code checks to see if it produces a value greater than 0x3A and adds <span class="SANS_TheSansMonoCd_W5Regular_11">7</span> (<span class="SANS_TheSansMonoCd_W5Regular_11">'A'</span> – <span class="SANS_TheSansMonoCd_W5Regular_11">'9'</span> – <span class="SANS_TheSansMonoCd_W5Regular_11">1</span>) to produce a final character code in the range 0x41 to 0x46 (<span class="SANS_TheSansMonoCd_W5Regular_11">'A'</span> through <span class="SANS_TheSansMonoCd_W5Regular_11">'F'</span>).</p>&#13;
<p class="TX">With a function that converts a nibble to the appropriate ASCII character, you can convert bytes, half words, and so on by taking all the nibbles in the number and calling the function on each one to produce the corresponding output character. However, because ARM assembly language programs generally deal with objects no smaller than a byte, it’s more straightforward and efficient to write a function that converts a byte value to two ASCII characters. Let’s call this function <span class="SANS_TheSansMonoCd_W5Regular_11">btoh</span> (byte to hex).</p>&#13;
<p class="TX">Listing 9-1 shows a straightforward <span class="SANS_TheSansMonoCd_W5Regular_11">btoh</span> implementation. This function expects a single-byte value in X1 (ignoring bits 8 to 63 in X1) and returns the two characters in bits 0 to 15 of X1. Listing 9-1 converts a C algorithm into assembly language by using the techniques described in <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>.</p>&#13;
<pre id="pre-726"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_479" aria-label="479"/>// Listing9-1.S &#13;
&#13;
#include "aoaa.inc"&#13;
&#13;
            proc    btoh_simple &#13;
            and     x1, x1, #0xFF   // Ensure only 8 bits. &#13;
            mov     x0, x1          // Save LO nibble. &#13;
&#13;
            // Process the HO nibble: &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> lsr     x1, x1, #4      // Move HO nibble to LO posn. &#13;
            orr     x1, x1, #'0'    // Convert to 0x30 to 0x3F. &#13;
            cmp     x1, #'9'        // See if 0x3A to 0x3F. &#13;
            bls     le9as &#13;
            add     x1, x1, #7      // Convert 0x3A to 0x3F to &#13;
 le9as:                             // 'A' through 'F'. &#13;
&#13;
            // Process the LO nibble: &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> and     x0, x0, #0xF    // Strip away HO nibble. &#13;
            orr     x0, x0, #'0'    // Convert to 0x30 to 0x3F. &#13;
            cmp     x0, #'9'        // See if 0x3A to 0x3F. &#13;
            bls     le9bs &#13;
            add     x0, x0, #7      // Convert 0x3A to 0x3F to &#13;
 le9bs:                             // 'A' through 'F'. &#13;
            // Merge the 2 bytes into X1. &#13;
&#13;
            orr     x1, x1, x0, lsl #8 &#13;
            ret &#13;
            endp    btoh_simple </code></pre>&#13;
<p class="TX">This function returns the character corresponding to the HO nibble in bits 0 through 7 <span class="CodeAnnotation" aria-label="annotation1">❶</span> and the character corresponding to the LO nibble in bits 8 through 15 <span class="CodeAnnotation" aria-label="annotation2">❷</span>. This is because you’ll generally use this function to build up character strings containing the converted hexadecimal value. Character strings are inherently <i>big-endian</i>, with the most significant digit appearing in the lowest memory address (so the number will be read from left to right when you print the string). Returning the two characters swapped in X1 allows you to store the two characters as a half-word value into memory by using a single instruction.</p>&#13;
<p class="TX">You may be wondering why <span class="SANS_TheSansMonoCd_W5Regular_11">btoh_simple</span> passes the value to convert in X1 rather than X0 (the standard “first argument” location). This is in anticipation of functions that will output the characters to a memory buffer (string). For those string-based functions, X0 will contain the address of the buffer.</p>&#13;
<p class="TX">Because Listing 9-1 is basically hand-compiled C/C++ code, the performance will be about the same as (or worse than) the code produced by an optimizing C/C++ compiler processing the C code given earlier. To write faster code in assembly language, you’ll first need to measure the performance of two functions to determine which one is faster. While you can do so with many software tools (performance analyzers, or <i>profilers</i>), I’ve employed a simple solution: write a main program that calls the function <span role="doc-pagebreak" epub:type="pagebreak" id="pg_480" aria-label="480"/>many times, then use the Unix <span class="SANS_TheSansMonoCd_W5Regular_11">time</span> command line utility to measure the amount of time the program takes to run. Listing 9-2 shows such a program, for example.</p>&#13;
<pre id="pre-727"><code>// Listing9-2.S &#13;
&#13;
#include "aoaa.inc"&#13;
&#13;
<var>Include both simple and other code here necessary for a working program.</var> &#13;
&#13;
            proc    asmMain, public &#13;
&#13;
            locals  am                  // Preserve the X20 and &#13;
            dword   saveX20             // X21 registers that &#13;
            dword   saveX21             // this program uses &#13;
            byte    stackspace, 64      // as loop-control &#13;
            endl    am                  // variables. &#13;
&#13;
            enter   am.size    // Create activation record. &#13;
&#13;
            str     x20, [fp, #saveX20] // Preserve nonvolatile &#13;
            str     x21, [fp, #saveX21] // registers. &#13;
&#13;
// Outer loop executes 10,000,000 times: &#13;
&#13;
            ldr     x20, =10000000 &#13;
outer: &#13;
&#13;
// Inner loop executes 256 times, once for each byte value. &#13;
// It just calls the btoh_*** function and ignores the &#13;
// return value. Do this to measure the speed of the &#13;
// function. &#13;
&#13;
#define funcToCall btoh_x1 // btoh_x1, btoh2, btoh_nob, or btoh_simple &#13;
&#13;
            mov     x21, #256 &#13;
inner:      add     x1, x20, #-1 &#13;
            bl      funcToCall &#13;
            adds    x21, x21, #-1 &#13;
            bne     inner &#13;
            adds    x20, x20, #-1 &#13;
            bne     outer &#13;
&#13;
&#13;
&#13;
            mov     x1, #0x9a       // Value to test &#13;
            mov     x6, x1          // Save for later. &#13;
            bl      funcToCall &#13;
&#13;
            // Print btoh_*** return result: &#13;
&#13;
            and     x2, x1, #0xff   // Print HO nibble first. &#13;
            mstr    x2, [sp, #8] &#13;
            lsr     x3, x1, #8      // Print LO nibble second. &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_481" aria-label="481"/>            mstr    x3, [sp, #16] &#13;
            mov     x1, x6          // Retrieve save value. &#13;
            mstr    x1, [sp] &#13;
            lea     x0, fmtStr1 &#13;
            bl      printf &#13;
            ldr     x21, [fp, #saveX21] // Restore nonvolatile &#13;
            ldr     x20, [fp, #saveX20] // registers. &#13;
            leave &#13;
            ret &#13;
&#13;
            endp    asmMain </code></pre>&#13;
<p class="TX">An advanced software engineer might find several faults with this technique for measuring the executing time of some code. However, it is simple, is easy to understand and use, and doesn’t require any special software tools. While the measurements it produces are not perfect, it’s good enough for most purposes.</p>&#13;
<p class="TX">Here’s the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and sample output (using the Unix <span class="SANS_TheSansMonoCd_W5Regular_11">time</span> command to time the running of the program):</p>&#13;
<pre id="pre-728"><code>$ <span class="SANS_TheSansMonoCd_W7Bold_11">./build Listing9-2</span> &#13;
$ <span class="SANS_TheSansMonoCd_W7Bold_11">time ./Listing9-2</span> &#13;
Calling Listing9-2: &#13;
Value=9a, as hex=9A &#13;
Listing9-2 terminated &#13;
./Listing9-2  3.49s user 0.01s system 98% cpu 3.542 total </code></pre>&#13;
<p class="TX">On my Mac mini M1, this took about 3.5 seconds to run. (Obviously, this will vary by system; for example, on a Raspberry Pi 3, it took about 37 seconds.)</p>&#13;
<p class="TX">As noted in <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>, branches tend to run slower than straight-line code. Listing 9-2 uses branches to handle cases when the converted character is <span class="SANS_TheSansMonoCd_W5Regular_11">'0'</span> through <span class="SANS_TheSansMonoCd_W5Regular_11">'9'</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">'A'</span> through <span class="SANS_TheSansMonoCd_W5Regular_11">'F'</span>. I wrote a version using the <span class="SANS_TheSansMonoCd_W5Regular_11">csel</span> instruction to differentiate these two cases after ORing or adding <span class="SANS_TheSansMonoCd_W5Regular_11">'0'</span> to the nibble value. The code ran in 2.5 seconds (on a Mac mini M1). However, this was achieved by not preserving the X1 and X2 registers. Saving X1 and X2 to memory and restoring them increased the execution time to 4.68 seconds.</p>&#13;
<p class="TX">You’ve just discovered a big time sink in ARM assembly code: accessing memory is very slow (and the <span class="SANS_TheSansMonoCd_W5Regular_11">ldp</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">stp</span> instructions are much slower than the <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">str</span> instructions). This is why Arm defined nonvolatile registers, so you don’t have to preserve certain working registers in memory. Nevertheless, preserving volatile registers is sometimes worthwhile to ensure that programs are correct. Assembly language code can quickly become complex, and having a function stomp on registers you forgot to save in your calling code can lead to long debugging sessions. A fast program with defects is never as good as a slower program that works properly.</p>&#13;
<p class="TX">When writing 32-bit ARM code for a Raspberry Pi 400 (for the second volume of this series), I discovered that using a 256-element lookup table (with each element containing the two characters corresponding to the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_482" aria-label="482"/>hexadecimal value) was faster than the standard algorithm. When I tried that approach in 64-bit ARM assembly, the runtime was 4.6 seconds. Once again, memory accesses (at least on the Apple M1 CPU) are expensive. On a different system, such as a Pi 3, 4, or 5, you will get different results.</p>&#13;
<p class="TX">Once you can convert a single byte to a pair of hexadecimal characters, creating a string, output to the display is straightforward. We can call the <span class="SANS_TheSansMonoCd_W5Regular_11">btoh</span> (byte to hex) function for each byte in the number and store the corresponding characters away in a string. With this function, you can write <span class="SANS_TheSansMonoCd_W5Regular_11">btoStr</span> (byte to string), <span class="SANS_TheSansMonoCd_W5Regular_11">hwtoStr</span> (half word to string), <span class="SANS_TheSansMonoCd_W5Regular_11">wtoStr</span> (word to string), and <span class="SANS_TheSansMonoCd_W5Regular_11">dtoStr</span> (double word to string) functions. This chapter expands several of the lower-level functions (<span class="SANS_TheSansMonoCd_W5Regular_11">btoStr</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">hwtoStr</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">wtoStr</span>) and uses procedure calls to the smaller functions for the larger-sized conversions (<span class="SANS_TheSansMonoCd_W5Regular_11">dtoStr</span>). In <span class="Xref"><a href="chapter13.xhtml">Chapter 13</a></span>, I discuss macros that will provide another way to easily expand these functions.</p>&#13;
<p class="TX">The approach this book takes is to try to write fast conversion code. If you would prefer to save space rather than increase speed, see the following <span class="Xref">“Reducing Code Size”</span> box for details.</p>&#13;
<aside class="box" aria-label="box-26">&#13;
<p class="BH" id="box-26"><span class="SANS_Dogma_OT_Bold_B_11">REDUCING CODE SIZE</span></p>&#13;
<p class="BTNI"><span class="SANS_Futura_Std_Book_11">To reduce code size and make these functions easier to write, you can code</span> <span class="SANS_TheSansMonoCd_W5Regular_11">hwtoStr</span> <span class="SANS_Futura_Std_Book_11">to call</span> <span class="SANS_TheSansMonoCd_W5Regular_11">btoStr</span> <span class="SANS_Futura_Std_Book_11">twice (and concatenate their output), code</span> <span class="SANS_TheSansMonoCd_W5Regular_11">wtoStr</span> <span class="SANS_Futura_Std_Book_11">to call</span> <span class="SANS_TheSansMonoCd_W5Regular_11">hwtoStr</span> <span class="SANS_Futura_Std_Book_11">twice, code</span> <span class="SANS_TheSansMonoCd_W5Regular_11">dtoStr</span> <span class="SANS_Futura_Std_Book_11">to call</span> <span class="SANS_TheSansMonoCd_W5Regular_11">wtoStr</span> <span class="SANS_Futura_Std_Book_11">twice, and so on. This produces functions with just a few instructions each, but the performance suffers. For example, assuming you’ve written the functions in this fashion, consider a call to</span> <span class="SANS_TheSansMonoCd_W5Regular_11">dtoStr</span><span class="SANS_Futura_Std_Book_11">: it calls</span> <span class="SANS_TheSansMonoCd_W5Regular_11">wtoStr</span> <span class="SANS_Futura_Std_Book_11">twice;</span> <span class="SANS_TheSansMonoCd_W5Regular_11">wtoStr</span> <span class="SANS_Futura_Std_Book_11">calls</span> <span class="SANS_TheSansMonoCd_W5Regular_11">hwtoStr</span> <span class="SANS_Futura_Std_Book_11">twice, which calls</span> <span class="SANS_TheSansMonoCd_W5Regular_11">btoStr</span> <span class="SANS_Futura_Std_Book_11">twice (which ultimately calls the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">btoh</span> <span class="SANS_Futura_Std_Book_11">function). This means that</span> <span class="SANS_TheSansMonoCd_W5Regular_11">dtoStr</span> <span class="SANS_Futura_Std_Book_11">makes 22 total calls. As most of these (except possibly</span> <span class="SANS_TheSansMonoCd_W5Regular_11">btoh</span><span class="SANS_Futura_Std_Book_11">) are higher-level functions, they should preserve any registers they modify. If each function saves a couple of registers, this results in 28 writes to, and 28 reads from, memory to preserve and restore the register values. As you saw with the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">btoh</span> <span class="SANS_Futura_Std_Book_11">function, preserving registers can be expensive.</span></p>&#13;
<p class="BTX"><span class="SANS_Futura_Std_Book_11">A higher-performance alternative, albeit requiring more code, is to call</span> <span class="SANS_TheSansMonoCd_W5Regular_11">btoh</span> <span class="SANS_Futura_Std_Book_11">(with no register preservation) as many times as necessary to convert each of the data types to the appropriately sized string. The higher-level function can preserve the registers exactly once and make multiple calls to</span> <span class="SANS_TheSansMonoCd_W5Regular_11">btoh</span> <span class="SANS_Futura_Std_Book_11">(such as the high-performance</span> <span class="SANS_TheSansMonoCd_W5Regular_11">btoh_x1</span> <span class="SANS_Futura_Std_Book_11">function that doesn’t preserve registers). Within that function (for example,</span> <span class="SANS_TheSansMonoCd_W5Regular_11">dtoStr</span><span class="SANS_Futura_Std_Book_11">), it is aware that</span> <span class="SANS_TheSansMonoCd_W5Regular_11">btoh</span> <span class="SANS_Futura_Std_Book_11">might wipe out X0 and X1; the higher-level function preserves those registers, so its caller doesn’t have to, and treats them as volatile across calls to</span> <span class="SANS_TheSansMonoCd_W5Regular_11">btoh</span><span class="SANS_Futura_Std_Book_11">. This way, the registers are saved and restored only once across the call to the higher-level function.</span></p>&#13;
<p class="BoxBodyLast"><span class="SANS_Futura_Std_Book_11">Another possible performance improvement is to ditch the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">btoh</span> <span class="SANS_Futura_Std_Book_11">function entirely and expand it inline in the higher-level functions. Before software engineers recoil in horror from this suggestion, remember these are very low-level functions that are generally part of a library rather than an application program</span> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_483" aria-label="483"/><span class="SANS_Futura_Std_Book_11">(other than via linking in the appropriate library). For low-level library code, optimization generally pays off handsomely. For those with doubts, consider using macros (see <a href="chapter13.xhtml">Chapter 13</a>), which give you the benefit of straight-line efficient code along with the structured nature of procedure calls.</span></p>&#13;
</aside>&#13;
<p class="TX">All the binary-to-hexadecimal string functions will accept two parameters: a value to convert in the X1 register, and a pointer to a string buffer to hold the string result in X0. These functions will assume that the buffer is sufficiently large to hold the string result: <span class="SANS_TheSansMonoCd_W5Regular_11">btoStr</span> requires a 3-character buffer, <span class="SANS_TheSansMonoCd_W5Regular_11">hwtoStr</span> requires a 5-character buffer, <span class="SANS_TheSansMonoCd_W5Regular_11">wtoStr</span> requires a 9-character buffer, and <span class="SANS_TheSansMonoCd_W5Regular_11">dtoStr</span> requires a 17-character buffer. Each byte in the value requires two characters in the buffer. In addition to the character data, the buffer must also include 1 byte for the zero-terminating byte. The caller is responsible for ensuring that the buffer is large enough.</p>&#13;
<p class="TX">To implement these four hexadecimal-to-string functions, I’ll start by writing four hexadecimal-to-buffer functions. There are two differences between the <span class="SANS_TheSansMonoCd_W5Regular_11">*tobuf</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">*tostr</span> functions (where the <span class="SANS_TheSansMonoCd_W5Regular_11">*</span> indicates a substitution of <span class="SANS_TheSansMonoCd_W5Regular_11">b</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">hw</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">w</span>, or <span class="SANS_TheSansMonoCd_W5Regular_11">d</span>, as per regular expression syntax):</p>&#13;
<ul class="ul">&#13;
<li class="BL">The <span class="SANS_TheSansMonoCd_W5Regular_11">*tobuf</span> functions do not preserve any registers. They modify the values in X0 and X2.</li>&#13;
<li class="BL">The <span class="SANS_TheSansMonoCd_W5Regular_11">*tobuf</span> functions leave X0 pointing at the zero-terminating byte at the end of the string, which is often useful; the <span class="SANS_TheSansMonoCd_W5Regular_11">*tostr</span> functions preserve X0’s value (pointing at the first character of the output buffer).</li>&#13;
</ul>&#13;
<p class="TX">I will also take this opportunity to introduce another assembly language feature: multiple entry points to a function. The <span class="SANS_TheSansMonoCd_W5Regular_11">btobuf</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">htobuf</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">wtobuf</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">dtobuf</span> functions all contain common code. Listing 9-3 merges all these functions into a single function (<span class="SANS_TheSansMonoCd_W5Regular_11">dtobuf</span>) with separate entry points into the code sequence for the other three functions.</p>&#13;
<pre id="pre-729"><code>// Listing9-3.S &#13;
&#13;
<var>  Usual header code snipped</var> &#13;
&#13;
// dtobuf &#13;
//&#13;
// Convert a dword to a string of 16 hexadecimal digits. &#13;
//&#13;
// Inputs: &#13;
//  X0-     Pointer to the buffer. Must have at least &#13;
//          17 bytes available. &#13;
//  X1-     Value to convert &#13;
//&#13;
// Outputs: &#13;
//  X0-     Points at zero-terminating byte at the end &#13;
//          of the converted string &#13;
//&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_484" aria-label="484"/>// Note:    This function does not preserve any registers. &#13;
//          It is the caller's responsibility to preserve &#13;
//          registers. &#13;
//&#13;
//          Registers modified: X0, X2 &#13;
&#13;
            proc    dtobuf &#13;
&#13;
#define AtoF   ('A'-'9'-1) &#13;
&#13;
            // Process the HO nibble: &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> lsr     x2, x1, #60 &#13;
            orr     w2, w2, #'0'    // Convert to 0x30 to 0x3F. &#13;
            cmp     w2, #'9'        // See if 0x3A to 0x3F. &#13;
            bls     dec15           // Skip if 0 to 9. &#13;
            add     w2, w2, #AtoF   // If it was A to F &#13;
 dec15: &#13;
            strb    w2, [x0], #1    // Store byte to memory. &#13;
&#13;
            // Process nibble 14: &#13;
&#13;
            lsr     x2, x1, #56     // See comments for HO nibble. &#13;
            and     x2, x2, 0xf &#13;
            orr     w2, w2, #'0' &#13;
            cmp     w2, #'9' &#13;
            bls     dec14 &#13;
            add     w2, w2, #AtoF &#13;
dec14:      strb    w2, [x0], #1 &#13;
&#13;
            // Process nibble 13: &#13;
&#13;
            lsr     x2, x1, #52 &#13;
            and     x2, x2, 0xf &#13;
            orr     w2, w2, #'0' &#13;
            cmp     w2, #'9' &#13;
            bls     dec13 &#13;
            add     w2, w2, #AtoF &#13;
dec13:      strb    w2, [x0], #1 &#13;
&#13;
            // Process nibble 12: &#13;
&#13;
            lsr     x2, x1, #48 &#13;
            and     x2, x2, 0xf &#13;
            orr     w2, w2, #'0' &#13;
            cmp     w2, #'9' &#13;
            bls     dec12 &#13;
            add     w2, w2, #AtoF &#13;
dec12:      strb    w2, [x0], #1 &#13;
&#13;
            // Process nibble 11: &#13;
&#13;
            lsr     x2, x1, #44 &#13;
            and     x2, x2, 0xf &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_485" aria-label="485"/>            orr     w2, w2, #'0' &#13;
            cmp     w2, #'9' &#13;
            bls     dec11 &#13;
            add     w2, w2, #AtoF &#13;
dec11:      strb    w2, [x0], #1 &#13;
&#13;
            // Process nibble 10: &#13;
&#13;
            lsr     x2, x1, #40 &#13;
            and     x2, x2, 0xf &#13;
            orr     w2, w2, #'0' &#13;
            cmp     w2, #'9' &#13;
            bls     dec10 &#13;
            add     w2, w2, #AtoF &#13;
dec10:      strb    w2, [x0], #1 &#13;
&#13;
            // Process nibble 9: &#13;
&#13;
            lsr     x2, x1, #36 &#13;
            and     x2, x2, 0xf &#13;
            orr     w2, w2, #'0' &#13;
            cmp     w2, #'9' &#13;
            bls     dec9 &#13;
            add     w2, w2, #AtoF &#13;
dec9:       strb    w2, [x0], #1 &#13;
&#13;
            // Process nibble 8: &#13;
&#13;
            lsr     x2, x1, #32 &#13;
            and     x2, x2, 0xf &#13;
            orr     w2, w2, #'0' &#13;
            cmp     w2, #'9' &#13;
            bls     dec8 &#13;
            add     w2, w2, #AtoF &#13;
dec8:       strb    w2, [x0], #1 &#13;
&#13;
// Entry point for wtobuf &#13;
//&#13;
// wtobuf &#13;
//&#13;
// Convert a word to a string of 8 hexadecimal digits. &#13;
//&#13;
// Inputs: &#13;
//  X0-     Pointer to the buffer. Must have at least &#13;
//          9 bytes available. &#13;
//  X1-     Value to convert &#13;
//&#13;
// Outputs: &#13;
//  X0-     Points at zero-terminating byte at the end &#13;
//          of the converted string &#13;
//&#13;
// Note:    This function does not preserve any registers. &#13;
//          It is the caller's responsibility to preserve &#13;
//          registers. &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_486" aria-label="486"/>//&#13;
//          Registers modified: X0, X2 &#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> wtobuf: &#13;
            // Process nibble 7: &#13;
&#13;
            lsr     x2, x1, #28 // See comments for nibble 15. &#13;
            and     x2, x2, 0xf &#13;
            orr     w2, w2, #'0' &#13;
            cmp     w2, #'9' &#13;
            bls     dec7 &#13;
            add     w2, w2, #AtoF &#13;
dec7:       strb    w2, [x0], #1 &#13;
&#13;
            // Process nibble 6: &#13;
&#13;
            lsr     x2, x1, #24 &#13;
            and     x2, x2, 0xf &#13;
            orr     w2, w2, #'0' &#13;
            cmp     w2, #'9' &#13;
            bls     dec6 &#13;
            add     w2, w2, #AtoF &#13;
dec6:       strb    w2, [x0], #1 &#13;
&#13;
            // Process nibble 5: &#13;
&#13;
            lsr     x2, x1, #20 &#13;
            and     x2, x2, 0xf &#13;
            orr     w2, w2, #'0' &#13;
            cmp     w2, #'9' &#13;
            bls     dec5 &#13;
            add     w2, w2, #AtoF &#13;
dec5:       strb    w2, [x0], #1 &#13;
&#13;
            // Process nibble 4: &#13;
&#13;
            lsr     x2, x1, #16 &#13;
            and     x2, x2, 0xf &#13;
            orr     w2, w2, #'0' &#13;
            cmp     w2, #'9' &#13;
            bls     dec4 &#13;
            add     w2, w2, #AtoF &#13;
dec4:       strb    w2, [x0], #1 &#13;
&#13;
// Entry point for htobuf: &#13;
//&#13;
// htobuf &#13;
//&#13;
// Convert a half word to a string of 4 hexadecimal digits. &#13;
//&#13;
// Inputs: &#13;
//  X0-     Pointer to the buffer. Must have at least &#13;
//          5 bytes available. &#13;
//  X1-     Value to convert &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_487" aria-label="487"/>//&#13;
// Outputs: &#13;
//  X0-     Points at zero-terminating byte at the end &#13;
//          of the converted string &#13;
//&#13;
// Note:    This function does not preserve any registers. &#13;
//          It is the caller's responsibility to preserve &#13;
//          registers. &#13;
//&#13;
//          Registers modified: X0, X2 &#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> htobuf: &#13;
            // Process nibble 3: &#13;
&#13;
            lsr     x2, x1, #12 // See comments for nibble 15. &#13;
            and     x2, x2, 0xf &#13;
            orr     w2, w2, #'0' &#13;
            cmp     w2, #'9' &#13;
            bls     dec3 &#13;
            add     w2, w2, #AtoF &#13;
dec3:       strb    w2, [x0], #1 &#13;
&#13;
            // Process nibble 2: &#13;
&#13;
            lsr     x2, x1, #8 &#13;
            and     x2, x2, 0xf &#13;
            orr     w2, w2, #'0' &#13;
            cmp     w2, #'9' &#13;
            bls     dec2 &#13;
            add     w2, w2, #AtoF &#13;
dec2:       strb    w2, [x0], #1 &#13;
&#13;
// Entry point for btobuf: &#13;
//&#13;
// btobuf &#13;
//&#13;
// Convert a byte to a string of two hexadecimal digits. &#13;
//&#13;
// Inputs: &#13;
//  X0-     Pointer to the buffer. Must have at least &#13;
//          3 bytes available. &#13;
//  X1-     Value to convert &#13;
//&#13;
// Outputs: &#13;
//  X0-     Points at zero-terminating byte at the end &#13;
//          of the converted string &#13;
//&#13;
// Note:    This function does not preserve any registers. &#13;
//          It is the caller's responsibility to preserve &#13;
//          registers. &#13;
//&#13;
//          Registers modified: X0, X2 &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_488" aria-label="488"/>            // Process nibble 1: &#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> btobuf: &#13;
            lsr     x2, x1, #4      // See comments for nibble 15. &#13;
            and     x2, x2, 0xf &#13;
            orr     w2, w2, #'0' &#13;
            cmp     w2, #'9' &#13;
            bls     dec1 &#13;
            add     w2, w2, #AtoF &#13;
dec1:       strb    w2, [x0], #1 &#13;
&#13;
            // Process LO nibble: &#13;
&#13;
            and     x2, x1, 0xf &#13;
            orr     x2, x2, #'0' &#13;
            cmp     w2, #'9' &#13;
            bls     dec0 &#13;
            add     w2, w2, #AtoF &#13;
dec0:       strb    w2, [x0], #1 &#13;
&#13;
            strb    wzr, [x0]       // Zero-terminate. &#13;
            ret &#13;
            endp    dtobuf </code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">dtobuf</span> function begins by processing the HO nibble (nibble 15) of the dword <span class="CodeAnnotation" aria-label="annotation1">❶</span>. For performance reasons, this code uses an unrolled loop, processing each nibble individually. Each nibble uses the standard algorithm for converting a binary value to a hexadecimal character.</p>&#13;
<p class="TX">After this code processes the HO eight hex digits, you’ll notice an entry point for the <span class="SANS_TheSansMonoCd_W5Regular_11">wtobuf</span> function <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Code calling <span class="SANS_TheSansMonoCd_W5Regular_11">wtobuf</span> transfers control into the middle of the <span class="SANS_TheSansMonoCd_W5Regular_11">dtobuf</span> function (literally). This works because <span class="SANS_TheSansMonoCd_W5Regular_11">dtobuf</span> doesn’t push anything onto the stack or otherwise alter the environment that would require special work by <span class="SANS_TheSansMonoCd_W5Regular_11">wtobuf</span> on entry. Likewise, entry points for <span class="SANS_TheSansMonoCd_W5Regular_11">htobuf</span> <span class="CodeAnnotation" aria-label="annotation3">❸</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">btobuf</span> <span class="CodeAnnotation" aria-label="annotation4">❹</span> are at nibbles 3 and 1, respectively. By merging these functions into a single section of code, you save all the code that would be used for <span class="SANS_TheSansMonoCd_W5Regular_11">wtobuf</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">htobuf</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">btobuf</span>.</p>&#13;
<p class="TX">I made several failed attempts at optimizing this code. First, I tried saving 8 bytes in a register and wrote the data to memory a dword at a time rather than a byte at a time. This ran slower (on my Mac mini M1). I also tried eliminating branches in the code by using <span class="SANS_TheSansMonoCd_W5Regular_11">csel</span> instructions. Surprisingly, that code ran slower too. I even tried using a <span class="SANS_TheSansMonoCd_W5Regular_11">ubfx</span> instruction (see <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span>), which still ran slower than the code with branches. I timed these versions on a Mac mini M1 and a Raspberry Pi 400. While the timings on the two machines varied greatly, the relative performance of the three algorithms remained the same (the branch version was always faster). Sometimes, getting clever with different algorithms can hurt you. That’s why you should always test the performance of your code (preferably on multiple architectures).</p>&#13;
<p class="TX">With the <span class="SANS_TheSansMonoCd_W5Regular_11">*tobuf</span> functions out of the way, writing the <span class="SANS_TheSansMonoCd_W5Regular_11">*toStr</span> functions is relatively easy. The <span class="SANS_TheSansMonoCd_W5Regular_11">*toStr</span> functions simply call the <span class="SANS_TheSansMonoCd_W5Regular_11">*tobuf</span> functions and <span role="doc-pagebreak" epub:type="pagebreak" id="pg_489" aria-label="489"/>preserve the registers that the <span class="SANS_TheSansMonoCd_W5Regular_11">*tobuf</span> functions modify. Listing 9-4 provides the code for these functions (note that <i>Listing9-4.S</i>, from the online files, also includes the code for the <span class="SANS_TheSansMonoCd_W5Regular_11">dtobuf</span> function; to avoid redundancy, I’ve removed that code from the listing).</p>&#13;
<pre id="pre-730"><code>// Listing9-4.S &#13;
//&#13;
// btoStr, htoStr, wtoStr, and dtoStr functions &#13;
// Also includes btobuf, htobuf, wtobuf, and &#13;
// dtobuf functions &#13;
&#13;
            #include    "aoaa.inc"&#13;
&#13;
            .section    .rodata, "" &#13;
ttlStr:     .asciz      "Listing 9-4"&#13;
&#13;
            .data &#13;
&#13;
// Buffer space used by main program &#13;
&#13;
buffer:     .space      256,0 &#13;
&#13;
            .code &#13;
            .extern     printf &#13;
&#13;
// Return program title to C++ program: &#13;
&#13;
            proc    getTitle, public &#13;
            lea     x0, ttlStr &#13;
            ret &#13;
            endp    getTitle &#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span><var> Insert the code for dtobuf here. See Listing 9-3.</var> &#13;
&#13;
// btoStr-&#13;
//&#13;
// Inputs: &#13;
//&#13;
//  X0- Pointer to buffer that will hold the result &#13;
//      (must allocate at least 3 bytes for buffer) &#13;
//  X1- Value to print (in LO byte) &#13;
//&#13;
// Outputs: &#13;
//&#13;
//  Buffer pointed at by X0 receives the two-character &#13;
//  conversion of the value in X1 to a hexadecimal string. &#13;
//&#13;
//  Preserves all registers. &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> proc    btoStr &#13;
&#13;
            str     x2, [sp, #-16]! &#13;
            stp     x0, lr, [sp, #-16]! &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_490" aria-label="490"/>            bl      btobuf &#13;
&#13;
            // Restore registers and return: &#13;
&#13;
            ldp     x0, lr, [sp], #16 &#13;
            ldr     x2, [sp], #16 &#13;
            ret &#13;
            endp    btoStr &#13;
&#13;
// htoStr &#13;
//&#13;
// Inputs: &#13;
//&#13;
//  X0- Pointer to buffer that will hold the result &#13;
//      (must allocate at least 5 bytes for buffer) &#13;
//  X1- Value to print (in LO hword) &#13;
//&#13;
// Outputs: &#13;
//&#13;
//  Buffer pointed at by X0 receives the four-character &#13;
//  conversion of the hword value in X1 to a hexadecimal string. &#13;
//&#13;
//  Preserves all registers &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> proc    htoStr &#13;
&#13;
            str     x2, [sp, #-16]! &#13;
            stp     x0, lr, [sp, #-16]! &#13;
&#13;
            bl      htobuf &#13;
&#13;
            // Restore registers and return: &#13;
&#13;
            ldp     x0, lr, [sp], #16 &#13;
            ldr     x2, [sp], #16 &#13;
            ret &#13;
            endp    htoStr &#13;
&#13;
// wtoStr &#13;
//&#13;
// Inputs: &#13;
//&#13;
//  X0- Pointer to buffer that will hold the result &#13;
//      (must allocate at least 9 bytes for buffer) &#13;
//  X1- Value to print (in LO word) &#13;
//&#13;
// Outputs: &#13;
//&#13;
//  Buffer pointed at by X0 receives the eight-character &#13;
//  conversion of the word value in X1 to a hexadecimal string. &#13;
//&#13;
//  Preserves all registers &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> proc    wtoStr &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_491" aria-label="491"/>            str     x2, [sp, #-16]! &#13;
            stp     x0, lr, [sp, #-16]! &#13;
&#13;
            bl      wtobuf &#13;
&#13;
            // Restore registers and return: &#13;
&#13;
            ldp     x0, lr, [sp], #16 &#13;
            ldr     x2, [sp], #16 &#13;
            ret &#13;
            endp    wtoStr &#13;
&#13;
// dtoStr &#13;
//&#13;
// Inputs: &#13;
//&#13;
//  X0- Pointer to buffer that will hold the result &#13;
//      (must allocate at least 17 bytes for buffer) &#13;
//  X1- Value to print &#13;
//&#13;
// Outputs: &#13;
//&#13;
//  Buffer pointed at by X0 receives the 16-character &#13;
//  conversion of the dword value in X1 to a hexadecimal string. &#13;
//&#13;
//  Preserves all registers &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> proc    dtoStr &#13;
&#13;
            str     x2, [sp, #-16]! &#13;
            stp     x0, lr, [sp, #-16]! &#13;
&#13;
            bl      dtobuf &#13;
&#13;
            // Restore registers and return: &#13;
&#13;
            ldp     x0, lr, [sp], #16 &#13;
            ldr     x2, [sp], #16 &#13;
            ret &#13;
            endp    dtoStr &#13;
&#13;
// Utility functions to print bytes, hwords, words, and dwords: &#13;
&#13;
pbStr:      wastr   "Byte=%s\n"&#13;
&#13;
            proc    pByte &#13;
&#13;
            locals  pb &#13;
            qword   pb.saveX0X1 &#13;
            byte    pb.buffer, 32 &#13;
            byte    pb.stkSpace, 64 &#13;
            endl    pb &#13;
&#13;
            enter   pb.size &#13;
            stp     x0, x1, [fp, #pb.saveX0X1] &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_492" aria-label="492"/>            mov     x1, x0 &#13;
            add     x0, fp, #pb.buffer  // lea x0, stkSpace &#13;
            bl      btoStr &#13;
&#13;
            lea     x0, pbStr &#13;
            add     x1, fp, #pb.buffer &#13;
            mstr    x1, [sp] &#13;
            bl      printf &#13;
&#13;
            ldp     x0, x1, [fp, #pb.saveX0X1] &#13;
            leave &#13;
            endp    pByte &#13;
&#13;
phStr:      wastr   "Hword=%s\n"&#13;
&#13;
            proc    pHword &#13;
&#13;
            locals  ph &#13;
            qword   ph.saveX0X1 &#13;
            byte    ph.buffer, 32 &#13;
            byte    ph.stkSpace, 64 &#13;
            endl    ph &#13;
&#13;
            enter   ph.size &#13;
            stp     x0, x1, [fp, #ph.saveX0X1] &#13;
&#13;
            mov     x1, x0 &#13;
            add     x0, fp, #ph.buffer  // lea x0, stkSpace &#13;
            bl      htoStr &#13;
&#13;
            lea     x0, phStr &#13;
            add     x1, fp, #ph.buffer &#13;
            mstr    x1, [sp] &#13;
            bl      printf &#13;
&#13;
            ldp     x0, x1, [fp, #ph.saveX0X1] &#13;
            leave &#13;
            endp    pHword &#13;
&#13;
pwStr:      wastr   "Word=%s\n"&#13;
&#13;
            proc    pWord &#13;
&#13;
            locals  pw &#13;
            qword   pw.saveX0X1 &#13;
            byte    pw.buffer, 32 &#13;
            byte    pw.stkSpace, 64 &#13;
            endl    pw &#13;
&#13;
            enter   pw.size &#13;
            stp     x0, x1, [fp, #pw.saveX0X1] &#13;
&#13;
            mov     x1, x0 &#13;
            add     x0, fp, #pw.buffer  // lea x0, stkSpace &#13;
            bl      wtoStr &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_493" aria-label="493"/>            lea     x0, pwStr &#13;
            add     x1, fp, #pw.buffer &#13;
            mstr    x1, [sp] &#13;
            bl      printf &#13;
&#13;
            ldp     x0, x1, [fp, #pw.saveX0X1] &#13;
            leave &#13;
            endp    pWord &#13;
&#13;
pdStr:      wastr   "Dword=%s\n"&#13;
&#13;
            proc    pDword &#13;
&#13;
            locals  pd &#13;
            qword   pd.saveX0X1 &#13;
            byte    pd.buffer, 32 &#13;
            byte    pd.stkSpace, 64 &#13;
            endl    pd &#13;
&#13;
            enter   pd.size &#13;
            stp     x0, x1, [fp, #pd.saveX0X1] &#13;
&#13;
            mov     x1, x0 &#13;
            add     x0, fp, #pd.buffer  // lea x0, stkSpace &#13;
            bl      dtoStr &#13;
&#13;
            lea     x0, pdStr &#13;
            add     x1, fp, #pd.buffer &#13;
            mstr    x1, [sp] &#13;
            bl      printf &#13;
&#13;
            ldp     x0, x1, [fp, #pd.saveX0X1] &#13;
            leave &#13;
            endp    pDword &#13;
&#13;
// Here is the asmMain function: &#13;
&#13;
            proc    asmMain, public &#13;
&#13;
            // Local storage: &#13;
&#13;
            locals  am &#13;
            byte    stackspace, 64 &#13;
            endl    am &#13;
&#13;
            enter   am.size             // Create activation record. &#13;
&#13;
            ldr     x0, =0x0123456789abcdef &#13;
            bl      pByte &#13;
            bl      pHword &#13;
            bl      pWord &#13;
            bl      pDword &#13;
&#13;
            leave &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_494" aria-label="494"/>            ret &#13;
&#13;
            endp    asmMain </code></pre>&#13;
<p class="TX">As noted, I’ve pulled the <span class="SANS_TheSansMonoCd_W5Regular_11">dtobuf</span> function out of this listing; insert that code <span class="CodeAnnotation" aria-label="annotation1">❶</span>. The <span class="SANS_TheSansMonoCd_W5Regular_11">btoStr</span> function <span class="CodeAnnotation" aria-label="annotation2">❷</span> saves the X0, X2, and LR registers on the stack (the registers that will be modified by calls to the <span class="SANS_TheSansMonoCd_W5Regular_11">*tobuf</span> functions), calls the <span class="SANS_TheSansMonoCd_W5Regular_11">btobuf</span> function to write the two hex digits to the buffer pointed at by X0, then restores the registers and returns. The code does largely the same for <span class="SANS_TheSansMonoCd_W5Regular_11">htoStr</span> <span class="CodeAnnotation" aria-label="annotation3">❸</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">wtoStr</span> <span class="CodeAnnotation" aria-label="annotation4">❹</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">dtoStr</span> <span class="CodeAnnotation" aria-label="annotation5">❺</span>, the only difference being the conversion function they call.</p>&#13;
<p class="TX">Here’s the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and sample output for the program in Listing 9-4:</p>&#13;
<pre id="pre-731"><code>$ <span class="SANS_TheSansMonoCd_W7Bold_11">./build Listing9-4</span> &#13;
$ <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing9-4</span> &#13;
Calling Listing9-4: &#13;
Byte=EF &#13;
Hword=CDEF &#13;
Word=89ABCDEF &#13;
Dword=0123456789ABCDEF &#13;
Listing9-4 terminated </code></pre>&#13;
<p class="TX">As the assembly code appearing in this book calls C/C++ standard library functions for I/O, these binary-to-hexadecimal-string functions will all produce zero-terminated C-compatible strings. They are easy enough to modify to produce other string formats, if need be. See <span class="Xref"><a href="chapter14.xhtml">Chapter 14</a></span> for more on string functions.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h2-168"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">9.1.2 Extended-Precision Hexadecimal Values to Strings</span></h4>&#13;
<p class="TNI1">Extended-precision hexadecimal-to-string conversion is easy: it’s simply an extension of the normal hexadecimal conversion routines from the previous section. For example, Listing 9-5 is a 128-bit hexadecimal conversion function, <span class="SANS_TheSansMonoCd_W5Regular_11">qtoStr</span>, which expects a pointer to a 128-bit value in X2:X1 and a pointer to a buffer in X0. <i>Listing9-5.S</i> is largely based on <i>Listing9-4.S</i>; to avoid redundancy, I’ve included just the <span class="SANS_TheSansMonoCd_W5Regular_11">qtoStr</span> function here.</p>&#13;
<pre id="pre-732"><code>// Listing9-5.S &#13;
//&#13;
// qtoStr &#13;
//&#13;
// Inputs: &#13;
//&#13;
//  X0-     Pointer to buffer that will hold the result &#13;
//          (must allocate at least 33 bytes for buffer) &#13;
//  X2:X1-  Value to print &#13;
//&#13;
// Outputs: &#13;
//&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_495" aria-label="495"/>//  Buffer pointed at by X0 receives the 32-character &#13;
//  conversion of the dword value in X2:X1 to a hexadecimal string. &#13;
//&#13;
//  Preserves all registers &#13;
&#13;
            proc    qtoStr &#13;
&#13;
            str     x2, [sp, #-16]! &#13;
            stp     x0, lr, [sp, #-16]! &#13;
            str     x1, [sp, #-16]!     // Save for later. &#13;
&#13;
            mov     x1, x2              // Convert HO dword first. &#13;
            bl      dtobuf &#13;
            ldr     x1, [sp], #16       // Restore X1 value. &#13;
            bl      dtobuf &#13;
&#13;
            // Restore registers and return: &#13;
&#13;
            ldp     x0, lr, [sp], #16 &#13;
            ld4     x2, [sp], #16 &#13;
            ret &#13;
            endp    qtoStr </code></pre>&#13;
<p class="TX">The function in Listing 9-5 calls <span class="SANS_TheSansMonoCd_W5Regular_11">dtobuf</span> twice to convert the 128-bit qword value to a string by converting first the HO dword, then the LO dword, and concatenating their results. To extend this conversion to any number of bytes, simply convert the HO bytes down to the LO bytes of the large object.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-169"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">9.1.3 Unsigned Decimal Values to Strings</span></h4>&#13;
<p class="TNI1">Decimal output is a little more complicated than hexadecimal output because, unlike for hexadecimal values, the HO bits of a binary number affect the LO digits of the decimal representation. Therefore, you must create the decimal representation for a binary number by extracting one decimal digit at a time from the number.</p>&#13;
<p class="TX">The most common solution for unsigned decimal output is to successively divide the value by 10 until the result becomes 0. The remainder after the first division is a value in the range 0 to 9, which corresponds to the LO digit of the decimal number. Successive divisions by 10 (and their corresponding remainder) extract successive digits from the number.</p>&#13;
<p class="TX">Iterative solutions to this problem generally allocate storage for a string of characters large enough to hold the entire number. The code then extracts the decimal digits in a loop and places them in the string one by one. At the end of the conversion process, the routine prints the characters in the string in reverse order (remember, the divide algorithm extracts the LO digits first and the HO digits last, the opposite of the way you need to print them).</p>&#13;
<p class="TX">This section employs a <i>recursive solution</i> because it is a little more elegant. This solution begins by dividing the value by 10 and saving the remainder in a local variable. If the quotient is not 0, the routine recursively calls <span role="doc-pagebreak" epub:type="pagebreak" id="pg_496" aria-label="496"/>itself to output any leading digits first. On return from the recursive call (which outputs all the leading digits), the recursive algorithm outputs the digit associated with the remainder to complete the operation. For example, here’s how the operation works when printing the decimal value 789:</p>&#13;
<div class="top">&#13;
<p class="ListNumber">  1.  Divide 789 by 10. The quotient is 78, and the remainder is 9.</p>&#13;
<p class="ListNumber">  2.  Save the remainder (9) in a local variable and recursively call the routine with the quotient.</p>&#13;
<p class="ListNumber">  3.  Recursive entry 1: divide 78 by 10. The quotient is 7, and the remainder is 8.</p>&#13;
<p class="ListNumber">  4.  Save the remainder (8) in a local variable and recursively call the routine with the quotient.</p>&#13;
<p class="ListNumber">  5.  Recursive entry 2: divide 7 by 10. The quotient is 0, and the remainder is 7.</p>&#13;
<p class="ListNumber">  6.  Save the remainder (7) in a local variable. Because the quotient is 0, don’t call the routine recursively.</p>&#13;
<p class="ListNumber">  7.  Output the remainder value saved in the local variable (7). Return to the caller (recursive entry 1).</p>&#13;
<p class="ListNumber">  8.  Return to recursive entry 1: output the remainder value saved in the local variable in recursive entry 1 (8). Return to the caller (original invocation of the procedure).</p>&#13;
<p class="ListNumber">  9.  Original invocation: output the remainder value saved in the local variable in the original call (9). Return to the original caller of the output routine.</p>&#13;
</div>&#13;
<p class="TX">Listing 9-6 provides an implementation of this recursive algorithm for 64-bit unsigned integers.</p>&#13;
<pre id="pre-733"><code>// Listing9-6.S &#13;
//&#13;
// u64toBuf function &#13;
&#13;
            #include    "aoaa.inc"&#13;
&#13;
            .section    .rodata, "" &#13;
ttlStr:     .asciz      "Listing 9-6"&#13;
fmtStr1:    .asciz      "Value(%llu) = string(%s)\n"&#13;
&#13;
            .align      3 &#13;
qwordVal:   .dword      0x1234567890abcdef &#13;
            .dword      0xfedcba0987654321 &#13;
&#13;
            .data &#13;
buffer:     .space      256,0 &#13;
&#13;
            .code &#13;
            .extern     printf &#13;
&#13;
// Return program title to C++ program: &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_497" aria-label="497"/>            proc    getTitle, public &#13;
            lea     x0, ttlStr &#13;
            ret &#13;
            endp    getTitle &#13;
            &#13;
// u64ToStr &#13;
//&#13;
//  Converts a 64-bit unsigned integer to a string &#13;
//&#13;
//  Inputs: &#13;
//      X0-     Pointer to buffer to receive string &#13;
//      X1-     Unsigned 64-bit integer to convert &#13;
//&#13;
//  Outputs: &#13;
//      Buffer- Receives the zero-terminated string &#13;
//&#13;
//  Buffer must have at least 21 bytes allocated for it. &#13;
//  This function preserves all registers. &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> proc    u64ToStr &#13;
            stp     x0, x1, [sp, #-16]! &#13;
            stp     x2, x3, [sp, #-16]! &#13;
            str     lr, [sp, #-16]! &#13;
&#13;
            bl      u64ToBuf &#13;
&#13;
            ldr     lr, [sp], #16 &#13;
            ldp     x2, x3, [sp], #16 &#13;
            ldp     x0, x1, [sp], #16 &#13;
            ret &#13;
            endp    u64ToStr &#13;
&#13;
// u64ToBuf &#13;
//&#13;
//  Converts a 64-bit unsigned integer to a string &#13;
//&#13;
//  Inputs: &#13;
//      X0-     Pointer to buffer to receive string &#13;
//      X1-     Unsigned 64-bit integer to convert &#13;
//&#13;
//  Outputs: &#13;
//      X0-     Points at zero-terminating byte &#13;
//      Buffer- Receives the zero-terminated string &#13;
//&#13;
//  Buffer must have at least 21 bytes allocated for it. &#13;
//&#13;
//  Caller must preserve X0, X1, X2, and X3! &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> proc    u64ToBuf &#13;
            cmp     x1, xzr         // See if X1 is 0. &#13;
            bne     u64ToBufRec &#13;
&#13;
            // Special case for zero, just write &#13;
            // "0" to the buffer. Leave X0 pointing &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_498" aria-label="498"/>            // at the zero-terminating byte. &#13;
&#13;
            mov     w1, #'0' &#13;
            strh    w1, [x0], #1    // Also emits zero byte &#13;
            ret &#13;
            endp    u64ToBuf &#13;
&#13;
// u64ToBufRec is the recursive version that handles &#13;
// nonzero values: &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> proc    u64ToBufRec &#13;
            stp     x2, lr, [sp, #-16]! // Preserve remainder. &#13;
&#13;
            // Divide X1 by 10 and save quotient and remainder: &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> mov     x2, #10 &#13;
            udiv    x3, x1, x2      // X3 = quotient &#13;
            msub    x2, x3, x2, x1  // X2 = remainder &#13;
&#13;
            // Make recursive call if quotient is not 0: &#13;
&#13;
            cmp     x3, xzr &#13;
            beq     allDone &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> mov     x1, x3              // Set up for call. &#13;
            bl      u64ToBufRec &#13;
&#13;
            // When this function has processed all the &#13;
            // digits, write them to the buffer. Also &#13;
            // write a zero-terminating byte, in case &#13;
            // this is the last digit to output. &#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation6">❻</span> allDone:    orr     w2, w2, #'0'    // Convert to char. &#13;
            strh    w2, [x0], #1    // Bump pointer after store. &#13;
          <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> ldp     x2, lr, [sp], #16 &#13;
            ret &#13;
            endp    u64ToBufRec &#13;
&#13;
// Here is the "asmMain" function. &#13;
&#13;
            proc    asmMain, public &#13;
&#13;
            enter   64              // Reserve space on stack. &#13;
&#13;
// Test u64ToBuf: &#13;
&#13;
            mov     x1, 0xFFFF &#13;
            movk    x1, 0xFFFF, lsl #16 &#13;
            movk    x1, 0xFFFF, lsl #32 &#13;
            movk    x1, 0xFFFF, lsl #48 &#13;
            lea     x0, buffer &#13;
            bl      u64ToStr &#13;
&#13;
            lea     x2, buffer &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_499" aria-label="499"/>            mstr    x2, [sp, #8] &#13;
            mov     x1, 0xFFFF &#13;
            movk    x1, 0xFFFF, lsl #16 &#13;
            movk    x1, 0xFFFF, lsl #32 &#13;
            movk    x1, 0xFFFF, lsl #48 &#13;
            mstr    x1, [sp] &#13;
            lea     x0, fmtStr1 &#13;
            bl      printf &#13;
&#13;
            leave &#13;
            ret &#13;
            endp    asmMain </code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">u64toStr</span> function <span class="CodeAnnotation" aria-label="annotation1">❶</span> is a facade that preserves the registers while calling the <span class="SANS_TheSansMonoCd_W5Regular_11">u64ToBuf</span> procedure. The <span class="SANS_TheSansMonoCd_W5Regular_11">u64ToBuf</span> function <span class="CodeAnnotation" aria-label="annotation2">❷</span> handles the special case when X1 contains 0 (the recursive code terminates when the result is 0). If X1 is 0 upon entry, this code immediately writes a <span class="SANS_TheSansMonoCd_W5Regular_11">'0'</span> character to the output buffer, increments X0, and returns. If X1 is nonzero, it transfers control to the recursive <span class="SANS_TheSansMonoCd_W5Regular_11">u64toBufRec</span> function <span class="CodeAnnotation" aria-label="annotation3">❸</span> to process the value. For performance reasons, <span class="SANS_TheSansMonoCd_W5Regular_11">u64ToBufRec</span> preserves only X2 (which contains the remainder value on recursive calls) and LR.</p>&#13;
<p class="TX">The recursive function computes the quotient and remainder <span class="CodeAnnotation" aria-label="annotation4">❹</span>. The quotient is left in X3, and the remainder is in X2. If the quotient was nonzero, there are still more HO digits to process: copy the quotient into X1 and make the recursive call to <span class="SANS_TheSansMonoCd_W5Regular_11">u64toBufRec</span> <span class="CodeAnnotation" aria-label="annotation5">❺</span>. On the return from the recursive call <span class="CodeAnnotation" aria-label="annotation6">❻</span> (or if the recursive call was skipped), all HO digits have been emitted to the buffer, so convert the current digit to a character and add it to the end of the buffer. Note that the post-increment addressing mode automatically increments X0 to point at the zero-terminated byte emitted by the <span class="SANS_TheSansMonoCd_W5Regular_11">strh</span> instruction. The code restores the value in X2 <span class="CodeAnnotation" aria-label="annotation7">❼</span>, in the event that this was a recursive call.</p>&#13;
<p class="TX">Here’s the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and sample output for Listing 9-6:</p>&#13;
<pre id="pre-734"><code>$ <span class="SANS_TheSansMonoCd_W7Bold_11">./build Listing9-6</span> &#13;
$ <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing9-6</span> &#13;
Calling Listing9-6: &#13;
Value(18446744073709551615) = string(18446744073709551615) &#13;
Listing9-6 terminated </code></pre>&#13;
<p class="TX">Unlike hexadecimal output, there’s no need to provide a byte-size, hword-size, or word-size numeric-to-decimal-string conversion function. Simply zero-extending the smaller values to 64 bits is sufficient. Unlike the hexadecimal conversions, no leading zeros are emitted by the <span class="SANS_TheSansMonoCd_W5Regular_11">u64toStr</span> function, so the output is the same for all sizes of variables (64 bits and smaller).</p>&#13;
<p class="TX">This code has several opportunities for optimization. Since decimal-to-string conversions are common (most program output uses this function) and the algorithm is not as fast as hexadecimal conversion, optimizing this code is probably worthwhile.</p>&#13;
<p class="TX">It’s easy enough to get rid of the recursion and do an iterative version of <span class="SANS_TheSansMonoCd_W5Regular_11">u64toStr</span>. This eliminates the need to preserve the registers and return <span role="doc-pagebreak" epub:type="pagebreak" id="pg_500" aria-label="500"/>address on multiple recursive calls (typically, one recursive call for each digit converted) and having to build the activation record on each call. Listing 9-7 takes this one step further, unraveling the loop (up to 20 iterations, one for each possible digit).</p>&#13;
<pre id="pre-735"><code>// Listing9-7.S &#13;
//&#13;
// u64toStr function (nonrecursive, straight-line &#13;
// code version) &#13;
&#13;
            #include    "aoaa.inc"&#13;
&#13;
            .section    .rodata, "" &#13;
ttlStr:     .asciz      "Listing 9-7"&#13;
fmtStr1:    .asciz      "low=%s, " &#13;
fmtStr2:    .asciz      "hi=%s\n"&#13;
&#13;
loData:     .dword      0, 1, 10, 100, 1000, 10000, 100000 &#13;
            .dword      1000000, 10000000, 100000000 &#13;
            .dword      1000000000, 10000000000, 100000000000 &#13;
            .dword      1000000000000, 10000000000000 &#13;
            .dword      100000000000000, 1000000000000000 &#13;
            .dword      10000000000000000, 100000000000000000 &#13;
            .dword      1000000000000000000, 10000000000000000000 &#13;
            .equ        dataCnt, .-loData &#13;
&#13;
hiData:     .dword      9, 9, 99, 999, 9999, 99999, 999999 &#13;
            .dword      9999999, 99999999, 999999999 &#13;
            .dword      9999999999, 99999999999, 999999999999 &#13;
            .dword      9999999999999, 99999999999999 &#13;
            .dword      999999999999999, 9999999999999999 &#13;
            .dword      99999999999999999, 999999999999999999 &#13;
            .dword      9999999999999999999 &#13;
            .dword      -1 &#13;
&#13;
            .data &#13;
buffer:     .space      256, 0 &#13;
&#13;
            .code &#13;
            .extern     printf &#13;
&#13;
// Return program title to C++ program: &#13;
&#13;
            proc    getTitle, public &#13;
            lea     x0, ttlStr &#13;
            ret &#13;
            endp    getTitle &#13;
&#13;
// u64ToBuf &#13;
//&#13;
//  Converts a 64-bit unsigned integer to a string &#13;
//&#13;
//  Inputs: &#13;
//      X0-     Pointer to buffer to receive string &#13;
//      X1-     Unsigned 64-bit integer to convert &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_501" aria-label="501"/>//&#13;
//  Outputs: &#13;
//      Buffer- Receives the zero-terminated string &#13;
//      X0-     Points at zero-terminating byte in string &#13;
//&#13;
//  Buffer must have at least 21 bytes allocated for it. &#13;
//  Note: Caller is responsible for preserving X0-X7! &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> proc    u64ToBuf &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> mov     x4, #10 &#13;
            mov     x5, xzr &#13;
            mov     x6, xzr &#13;
            mov     x7, xzr &#13;
&#13;
            // Handle the LO digit here: &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> udiv    x2, x1, x4      // X2 = quotient &#13;
            msub    x3, x2, x4, x1  // X3 = remainder &#13;
            orr     x3, x3, #'0' &#13;
            orr     x5, x3, x5, lsl #8 &#13;
            cmp     x2, #0 &#13;
            beq     allDone1 &#13;
&#13;
            // Handle the 10's digit here: &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> udiv    x1, x2, x4      // X1 = quotient &#13;
            msub    x3, x1, x4, x2  // X3 = remainder &#13;
            orr     x3, x3, #'0' &#13;
            orr     x5, x3, x5, lsl #8 &#13;
            cmp     x1, #0 &#13;
            beq     allDone2 &#13;
&#13;
            // Handle the 100's digit here: &#13;
&#13;
            udiv    x2, x1, x4      // X2 = quotient &#13;
            msub    x3, x2, x4, x1  // X3 = remainder &#13;
            orr     x3, x3, #'0' &#13;
            orr     x5, x3, x5, lsl #8 &#13;
            cmp     x2, #0 &#13;
            beq     allDone3 &#13;
&#13;
            // Handle the 1000's digit here: &#13;
&#13;
            udiv    x1, x2, x4      // X1 = quotient &#13;
            msub    x3, x1, x4, x2  // X3 = remainder &#13;
            orr     x3, x3, #'0' &#13;
            orr     x5, x3, x5, lsl #8 &#13;
            cmp     x1, #0 &#13;
            beq     allDone4 &#13;
&#13;
            // Handle the 10,000's digit here: &#13;
&#13;
            udiv    x2, x1, x4      // X2 = quotient &#13;
            msub    x3, x2, x4, x1  // X3 = remainder &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_502" aria-label="502"/>            orr     x3, x3, #'0' &#13;
            orr     x5, x3, x5, lsl #8 &#13;
            cmp     x2, #0 &#13;
            beq     allDone5 &#13;
&#13;
            // Handle the 100,000's digit here: &#13;
&#13;
            udiv    x1, x2, x4      // X1 = quotient &#13;
            msub    x3, x1, x4, x2  // X3 = remainder &#13;
            orr     x3, x3, #'0' &#13;
            orr     x5, x3, x5, lsl #8 &#13;
            cmp     x1, #0 &#13;
            beq     allDone6 &#13;
&#13;
            // Handle the 1,000,000's digit here: &#13;
&#13;
            udiv    x2, x1, x4      // X2 = quotient &#13;
            msub    x3, x2, x4, x1  // X3 = remainder &#13;
            orr     x6, x3, #'0' &#13;
            cmp     x2, #0 &#13;
            beq     allDone7 &#13;
&#13;
            // Handle the 10,000,000's digit here: &#13;
&#13;
            udiv    x1, x2, x4      // X1 = quotient &#13;
            msub    x3, x1, x4, x2  // X3 = remainder &#13;
            orr     x3, x3, #'0' &#13;
            orr     x6, x3, x6, lsl #8 &#13;
            cmp     x1, #0 &#13;
            beq     allDone8 &#13;
&#13;
            // Handle the 100,000,000's digit here: &#13;
&#13;
            udiv    x2, x1, x4      // X2 = quotient &#13;
            msub    x3, x2, x4, x1  // X3 = remainder &#13;
            orr     x3, x3, #'0' &#13;
            orr     x6, x3, x6, lsl #8 &#13;
            cmp     x2, #0 &#13;
            beq     allDone9 &#13;
&#13;
            // Handle the 1,000,000,000's digit here: &#13;
&#13;
            udiv    x1, x2, x4      // X1 = quotient &#13;
            msub    x3, x1, x4, x2  // X3 = remainder &#13;
            orr     x3, x3, #'0' &#13;
            orr     x6, x3, x6, lsl #8 &#13;
            cmp     x1, #0 &#13;
            beq     allDone10 &#13;
&#13;
            // Handle the 10,000,000,000's digit here: &#13;
&#13;
            udiv    x2, x1, x4      // X2 = quotient &#13;
            msub    x3, x2, x4, x1  // X3 = remainder &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_503" aria-label="503"/>            orr     x3, x3, #'0' &#13;
            orr     x6, x3, x6, lsl #8 &#13;
            cmp     x2, #0 &#13;
            beq     allDone11 &#13;
&#13;
            // Handle the 100,000,000,000's digit here: &#13;
&#13;
            udiv    x1, x2, x4      // X1 = quotient &#13;
            msub    x3, x1, x4, x2  // X3 = remainder &#13;
            orr     x3, x3, #'0' &#13;
            orr     x6, x3, x6, lsl #8 &#13;
            cmp     x1, #0 &#13;
            beq     allDone12 &#13;
&#13;
            // Handle the 1,000,000,000,000's digit here: &#13;
&#13;
            udiv    x2, x1, x4      // X2 = quotient &#13;
            msub    x3, x2, x4, x1  // X3 = remainder &#13;
            orr     x3, x3, #'0' &#13;
            orr     x6, x3, x6, lsl #8 &#13;
            cmp     x2, #0 &#13;
            beq     allDone13 &#13;
&#13;
            // Handle the 10,000,000,000,000's digit here: &#13;
&#13;
            udiv    x1, x2, x4      // X1 = quotient &#13;
            msub    x3, x1, x4, x2  // X3 = remainder &#13;
            orr     x3, x3, #'0' &#13;
            orr     x6, x3, x6, lsl #8 &#13;
            cmp     x1, #0 &#13;
            beq     allDone14 &#13;
&#13;
            // Handle the 100,000,000,000,000's digit here: &#13;
&#13;
            udiv    x2, x1, x4      // X2 = quotient &#13;
            msub    x3, x2, x4, x1  // X3 = remainder &#13;
            orr     x7, x3, #'0' &#13;
            orr     x6, x3, x6, lsl #8&#13;
            cmp     x2, #0 &#13;
            beq     allDone15 &#13;
&#13;
            // Handle the 1,000,000,000,000,000's digit here: &#13;
&#13;
            udiv    x1, x2, x4      // X1 = quotient &#13;
            msub    x3, x1, x4, x2  // X3 = remainder &#13;
            orr     x3, x3, #'0' &#13;
            orr     x7, x3, x7, lsl #8 &#13;
            cmp     x1, #0 &#13;
            beq     allDone16 &#13;
&#13;
            // Handle the 10,000,000,000,000,000's digit here: &#13;
&#13;
            udiv    x2, x1, x4      // X2 = quotient &#13;
            msub    x3, x2, x4, x1  // X3 = remainder &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_504" aria-label="504"/>            orr     x3, x3, #'0' &#13;
            orr     x7, x3, x7, lsl #8     &#13;
            cmp     x2, #0 &#13;
            beq     allDone17 &#13;
&#13;
            // Handle the 100,000,000,000,000,000's digit here: &#13;
&#13;
            udiv    x1, x2, x4      // X1 = quotient &#13;
            msub    x3, x1, x4, x2  // X3 = remainder &#13;
            orr     x3, x3, #'0' &#13;
            orr     x7, x3, x7, lsl #8 &#13;
            cmp     x1, #0 &#13;
            beq     allDone18 &#13;
&#13;
            // Handle the 1,000,000,000,000,000,000's digit here: &#13;
&#13;
            udiv    x2, x1, x4      // X2 = quotient &#13;
            msub    x3, x2, x4, x1  // X3 = remainder &#13;
            orr     x3, x3, #'0' &#13;
            orr     x7, x3, x7, lsl #8 &#13;
            cmp     x2, #0 &#13;
            beq     allDone19 &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> udiv    x1, x2, x4      // X1 = quotient &#13;
            msub    x3, x1, x4, x2  // X3 = remainder &#13;
            orr     x3, x3, #'0' &#13;
            orr     x7, x3, x7, lsl #8 &#13;
&#13;
allDone20:  str     x7, [x0], #6 &#13;
            str     x6, [x0], #8 &#13;
            str     x5, [x0], #7 &#13;
            ret &#13;
&#13;
            // When this function has processed all the &#13;
            // digits, write them to the buffer. Also &#13;
            // write a zero-terminating byte, in case &#13;
            // this is the last digit to output. &#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> allDone1: strh    w5, [x0], #1 &#13;
            ret &#13;
&#13;
  allDone2: strh    w5, [x0], #2 &#13;
            strb    wzr, [x0] &#13;
            ret &#13;
&#13;
  allDone3: str     w5, [x0], #3 &#13;
            ret &#13;
&#13;
  allDone4: str     w5, [x0], #4 &#13;
            strb    wzr, [x0] &#13;
            ret &#13;
&#13;
  allDone5: str     x5, [x0], #4 &#13;
            lsr     x5, x5, #32 &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_505" aria-label="505"/>            strh    w5, [x0], #1 &#13;
            ret &#13;
&#13;
  allDone6: str     w5, [x0], #4 &#13;
            lsr     x5, x5, #32 &#13;
            strh    w5, [x0], #2 &#13;
            strb    wzr, [x0] &#13;
            ret &#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> allDone7: strb    w6, [x0], #1 &#13;
            str     x5, [x0], #7 &#13;
            ret &#13;
&#13;
  allDone8: strh    w6, [x0], #2 &#13;
            str     x5, [x0], #7    // Writes an extra garbage byte &#13;
            ret &#13;
&#13;
  allDone9: str     w6, [x0], #3 &#13;
            str     x5, [x0], #7 &#13;
            ret &#13;
&#13;
  allDone10: &#13;
            str     w6, [x0], #4 &#13;
            str     x5, [x0], #7 &#13;
            ret &#13;
&#13;
  allDone11: &#13;
            str     x6, [x0], #5 &#13;
            str     x5, [x0], #7 &#13;
            ret &#13;
&#13;
  allDone12: &#13;
            str     x6, [x0], #6 &#13;
            str     x5, [x0], #7 &#13;
            ret &#13;
&#13;
  allDone13: &#13;
            str     x6, [x0], #7 &#13;
            str     x5, [x0], #7 &#13;
            ret &#13;
&#13;
  allDone14: &#13;
&#13;
            str     x6, [x0], #8 &#13;
            str     x5, [x0], #7 &#13;
            ret &#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation8">❽</span> allDone15: &#13;
            strb    w7, [x0], #1 &#13;
            str     x6, [x0], #8 &#13;
            str     x5, [x0], #7 &#13;
            ret &#13;
&#13;
  allDone16: &#13;
            strh    w7, [x0], #2 &#13;
            str     x6, [x0], #8 &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_506" aria-label="506"/>            str     x5, [x0], #7 &#13;
            ret &#13;
&#13;
  allDone17: &#13;
            str     w7, [x0], #3 &#13;
            str     x6, [x0], #8 &#13;
            str     x5, [x0], #7 &#13;
            ret &#13;
&#13;
  allDone18: &#13;
            str     w7, [x0], #4 &#13;
            str     x6, [x0], #8 &#13;
            str     x5, [x0], #7 &#13;
            ret &#13;
&#13;
  allDone19: &#13;
            str     x7, [x0], #5 &#13;
            str     x6, [x0], #8 &#13;
            str     x5, [x0], #7 &#13;
            ret &#13;
            endp    u64ToBuf &#13;
&#13;
// u64ToStr &#13;
//&#13;
//  Version of u64ToBuf that preserves the registers &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation9">❾</span> proc    u64ToStr &#13;
            stp     x0, x1, [sp, #-16]! // Preserve registers. &#13;
            stp     x2, x3, [sp, #-16]! &#13;
            stp     x4, x5, [sp, #-16]! &#13;
            stp     x6, x7, [sp, #-16]! &#13;
            str     lr, [sp, #-16]! &#13;
            bl      u64ToBuf &#13;
            ldr     lr, [sp], #16 &#13;
            ldp     x6, x7, [sp], #16   // Restore registers. &#13;
            ldp     x4, x5, [sp], #16 &#13;
            ldp     x2, x3, [sp], #16 &#13;
            ldp     x0, x1, [sp], #16 &#13;
            ret &#13;
            endp    u64ToStr &#13;
&#13;
// Here is the asmMain function: &#13;
&#13;
            proc    asmMain, public &#13;
&#13;
            locals  am &#13;
            qword   am.x20_x21 &#13;
            dword   am.x22 &#13;
            byte    stk, 64 &#13;
            endl    am &#13;
&#13;
            enter   am.size             // Create act rec. &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_507" aria-label="507"/>            // Preserve nonvolatile registers: &#13;
&#13;
            stp     x20, x21, [fp, #am.x20_x21] &#13;
            str     x22, [fp, #am.x22] &#13;
&#13;
            lea     x20, loData &#13;
            lea     x21, hiData &#13;
            mov     x22, xzr &#13;
 loop: &#13;
            lea     x0, buffer &#13;
            ldr     x1, [x20, x22, lsl #3] &#13;
            bl      u64ToStr &#13;
&#13;
            lea     x0, fmtStr1 &#13;
            lea     x1, buffer &#13;
            mstr    x1, [sp] &#13;
            bl      printf &#13;
&#13;
            lea     x0, buffer &#13;
            ldr     x1, [x21, x22, lsl #3] &#13;
            bl      u64ToStr &#13;
&#13;
            lea     x0, fmtStr2 &#13;
            lea     x1, buffer &#13;
            mstr    x1, [sp] &#13;
            bl      printf &#13;
&#13;
            add     x22, x22, #1 &#13;
            cmp     x22, #(dataCnt / 8) &#13;
            blo     loop &#13;
&#13;
            ldr     x22, [fp, #am.x22] &#13;
            ldp     x20, x21, [fp, #am.x20_x21] &#13;
&#13;
            leave &#13;
            endp    asmMain </code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">u64ToBuf</span> function <span class="CodeAnnotation" aria-label="annotation1">❶</span> is a variant of <span class="SANS_TheSansMonoCd_W5Regular_11">u64ToStr</span> that doesn’t preserve any registers. It stomps on X0 through X7, and the caller is responsible for saving any registers it needs preserved.</p>&#13;
<p class="TX">This function initializes X4 with the constant 10 <span class="CodeAnnotation" aria-label="annotation2">❷</span>, because each digit conversion will divide and multiply by this constant, which must be in a register. Reserving X4 for this constant spares the code from having to reload the constant all the time. This code zeros out X5, X6, and X7, which will hold the characters of the converted string; this also initializes the zero-terminating byte (which can be in various locations in these registers, depending on the number of output digits).</p>&#13;
<p class="TX">The function converts the binary number to a string of digits by using the same basic “divide and remainder” algorithm as did the program in Listing 9-6 <span class="CodeAnnotation" aria-label="annotation3">❸</span>. The function divides the value by 10; the remainder is a value in the range 0 to 9 that the function converts to the corresponding ASCII character. The code shifts the converted digit into its final output <span role="doc-pagebreak" epub:type="pagebreak" id="pg_508" aria-label="508"/>position in the X5, X6, or X7 register. Digits 1 through 6, the HO digits, wind up in X5; digits 7 through 14 in X6; and digits 15 through 20 in X7. Zero bytes fill in all the unused digit positions. For example, if the number has only three digits, X6 and X7 will contain 0, and bits 24 through 63 in X5 will all contain 0.</p>&#13;
<p class="TX">A separate sequence of divide/remainder instructions is used for each possible output digit in the conversion (hence the name <i>expanded/straight-line code</i>) <span class="CodeAnnotation" aria-label="annotation4">❹</span>. The sequence is roughly the same for each digit conversion, though two variants alternate between the value in X1 and X2, as the quotient from the division becomes the value to divide in the next step. Whenever the quotient becomes 0, the conversion is complete, and control transfers to a different location to write the converted digits to the buffer. Only a single branch in the function will be taken, as these branches fall through to the next instruction sequence until the conversion is complete. Additionally, these digit conversion sequences may place the converted digit into a different output register based on the digit’s final position.</p>&#13;
<p class="TX">If the code falls all the way through to digit 20, there is no test for a 0 result; the quotient will always be 0 at that point, so the function simply stores away the digits into the buffer and returns <span class="CodeAnnotation" aria-label="annotation5">❺</span>.</p>&#13;
<p class="TX">If the number has six digits or fewer, the function writes the characters in X5 to the buffer <span class="CodeAnnotation" aria-label="annotation6">❻</span>. X5 will always contain the LO digits of the number. By placing a maximum of six characters in X5, the HO 2 bytes of X5 will always be 0 (and provide the zero-terminating byte for larger strings). For numbers with fewer than six digits, the code must explicitly write a zero-terminating byte to the buffer. For values with 7 to 14 digits, the function writes out registers X6 and X5 (in that order) to the buffer <span class="CodeAnnotation" aria-label="annotation7">❼</span>. X5 provides the zero-terminating byte, so the code doesn’t need to explicitly write any 0 bytes. For values with 15 or more digits, the code writes out the data in registers X7, X6, and X5 (X5 provides the zero-terminating byte) <span class="CodeAnnotation" aria-label="annotation8">❽</span>.</p>&#13;
<p class="TX">The actual <span class="SANS_TheSansMonoCd_W5Regular_11">u64ToStr</span> function <span class="CodeAnnotation" aria-label="annotation9">❾</span> is a short facade that preserves all the register values across a call to <span class="SANS_TheSansMonoCd_W5Regular_11">u64ToBuf</span>. By breaking <span class="SANS_TheSansMonoCd_W5Regular_11">u64ToStr</span> into these two functions, it is possible to call <span class="SANS_TheSansMonoCd_W5Regular_11">u64ToBuf</span> directly if you want to leave X0 pointing at the end of the string (though you must preserve X1 through X7 if necessary). Also, putting the register preservation code in <span class="SANS_TheSansMonoCd_W5Regular_11">u64ToStr</span> allows the <span class="SANS_TheSansMonoCd_W5Regular_11">u64ToBuf</span> code to avoid restoring registers before all the <span class="SANS_TheSansMonoCd_W5Regular_11">ret</span> instructions (or avoid yet another branch to code that handles restoring the registers).</p>&#13;
<p class="TX">Here’s the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and sample output from Listing 9-7:</p>&#13;
<pre id="pre-736"><code>$<span class="SANS_TheSansMonoCd_W7Bold_11"> ./build Listing9-7</span> &#13;
$ <span class="SANS_TheSansMonoCd_W7Bold_11">time ./Listing9-7</span> &#13;
Calling Listing9-7: &#13;
low=0, hi=9 &#13;
low=1, hi=9 &#13;
low=10, hi=99 &#13;
low=100, hi=999 &#13;
low=1000, hi=9999 &#13;
low=1000, hi=9999 &#13;
low=100000, hi=999999 &#13;
low=1000000, hi=9999999 &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_509" aria-label="509"/>low=10000000, hi=99999999 &#13;
low=100000000, hi=999999999 &#13;
low=1000000000, hi=9999999999 &#13;
low=10000000000, hi=99999999999 &#13;
low=100000000000, hi=999999999999 &#13;
low=1000000000000, hi=9999999999999 &#13;
low=10000000000000, hi=99999999999999 &#13;
low=100000000000000, hi=999999999999999 &#13;
low=1000000000000000, hi=9999999999999999 &#13;
low=10000000000000000, hi=99999999999999999 &#13;
low=100000000000000000, hi=999999999999999999 &#13;
low=1000000000000000000, hi=9999999999999999999 &#13;
low=10000000000000000000, hi=18446744073709551615 &#13;
Listing9-7 terminated </code></pre>&#13;
<p class="TX">I modified both versions of <span class="SANS_TheSansMonoCd_W5Regular_11">u64toStr</span> in order to time their execution. For the recursive version, I got the following timing on my Mac mini:</p>&#13;
<pre id="pre-737"><code>Listing9-7a  404.58s user 0.42s system 99% cpu 6:46.25 total </code></pre>&#13;
<p class="TX">For the straight-line code, the runtime was as follows:</p>&#13;
<pre id="pre-738"><code>Listing9-7a  173.60s user 0.15s system 99% cpu 2:53.78 total </code></pre>&#13;
<p class="Continued1">The latter code ran about 2.3 times faster than the recursive version, a big win.</p>&#13;
<p class="TX">I also created a version of <span class="SANS_TheSansMonoCd_W5Regular_11">u64ToStr</span> that first counted the number of output digits (using a binary search), then branched to the appropriate code to convert exactly that many digits. Alas, the code ran slightly slower than Listing 9-7. I also tried a variant that emitted the HO digits first (dividing by 1e+19, the successively lower values by 10). It was a little faster than the digit count version, and a little slower than Listing 9-7. I’ve included the source code for both experiments in the online files for your perusal.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h2-170"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">9.1.4 Signed Integer Values to Strings</span></h4>&#13;
<p class="TNI1">To convert a signed integer value to a string, first check whether the number is negative. If it is, emit a hyphen (<span class="SANS_TheSansMonoCd_W5Regular_11">-</span>) character and negate the value, then call the <span class="SANS_TheSansMonoCd_W5Regular_11">u64toStr</span> function to finish the job. Listing 9-8 shows the relevant code.</p>&#13;
<pre id="pre-739"><code>// Listing9-8.S &#13;
&#13;
<var>Code taken from Listing 9-7 goes here.</var> &#13;
&#13;
// i64ToStr &#13;
//&#13;
//  Converts a signed 64-bit integer to a string &#13;
//  If the number is negative, this function will &#13;
//  print a '-' character followed by the conversion &#13;
//  of the absolute value of the number. &#13;
//&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_510" aria-label="510"/>// Inputs: &#13;
//&#13;
//      X0- Pointer to buffer to hold the result. &#13;
//          Buffer should be capable of receiving &#13;
//          as many as 22 bytes (including zero-&#13;
//          terminating byte). &#13;
//      X1- Signed 64-bit integer to convert &#13;
//&#13;
// Outputs: &#13;
//&#13;
//      Buffer- Contains the converted string &#13;
&#13;
            proc    i64ToStr &#13;
&#13;
            locals  i64 &#13;
            dword   i64.x0 &#13;
            byte    i64.stk, 32 &#13;
            endl    i64 &#13;
&#13;
            enter   i64.size &#13;
&#13;
            // Need to preserve X1 in &#13;
            // case this code negates it. &#13;
&#13;
            str     x1, [fp, #i64.x0] &#13;
&#13;
            cmp     x1, #0 &#13;
            bpl     isPositive &#13;
&#13;
            mov     w1, #'-'    // Emit '-' &#13;
            strb    w1, [x0], #1 &#13;
&#13;
            // Negate X0 and convert &#13;
            // unsigned value to integer: &#13;
&#13;
            ldr     x1, [fp, #i64.x0] &#13;
            neg     x1, x1 &#13;
&#13;
isPositive: bl      u64ToStr &#13;
            ldr     x1, [fp, #i64.x0] &#13;
            leave &#13;
            endp    i64ToStr &#13;
&#13;
<var>Code taken from Listing 9-7 goes here.</var> </code></pre>&#13;
<p class="TX">Listing 9-8 shows only the <span class="SANS_TheSansMonoCd_W5Regular_11">i64ToStr</span> function (the rest of the program is taken from Listing 9-7). The full source code is available online.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h2-171"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">9.1.5 Extended-Precision Unsigned Integers to Strings</span></h4>&#13;
<p class="TNI1">The only operation in the entire string-conversion algorithm that requires extended-precision arithmetic is the divide-by-10 operation. Listing 9-9 implements a 128-bit decimal output routine utilizing this technique. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_511" aria-label="511"/>I modified the <span class="SANS_TheSansMonoCd_W5Regular_11">div128</span> algorithm from <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span> to do an explicit divide-by-10 operation (speeding <span class="SANS_TheSansMonoCd_W5Regular_11">div128</span> up a little) and modified the recursive conversion routine from Listing 9-6 to perform the conversion.</p>&#13;
<pre id="pre-740"><code>// Listing9-9.S &#13;
//&#13;
// u128toStr function &#13;
&#13;
            #include    "aoaa.inc"&#13;
&#13;
            .section    .rodata, "" &#13;
ttlStr:     .asciz      "Listing 9-9"&#13;
fmtStr1:    .asciz      "Value = %s\n"&#13;
&#13;
qdata:      .qword      1 &#13;
            .qword      21 &#13;
            .qword      302 &#13;
            .qword      4003 &#13;
            .qword      50004 &#13;
            .qword      600005 &#13;
            .qword      7000006 &#13;
            .qword      80000007 &#13;
            .qword      900000008 &#13;
            .qword      1000000009 &#13;
            .qword      11000000010 &#13;
            .qword      120000000011 &#13;
            .qword      1300000000012 &#13;
            .qword      14000000000013 &#13;
            .qword      150000000000014 &#13;
            .qword      1600000000000015 &#13;
            .qword      17000000000000016 &#13;
            .qword      180000000000000017 &#13;
            .qword      1900000000000000018 &#13;
            .qword      20000000000000000019 &#13;
            .qword      210000000000000000020 &#13;
            .qword      2200000000000000000021 &#13;
            .qword      23000000000000000000022 &#13;
            .qword      240000000000000000000023 &#13;
            .qword      2500000000000000000000024 &#13;
            .qword      26000000000000000000000025 &#13;
            .qword      270000000000000000000000026 &#13;
            .qword      2800000000000000000000000027 &#13;
            .qword      29000000000000000000000000028 &#13;
            .qword      300000000000000000000000000029 &#13;
            .qword      3100000000000000000000000000030 &#13;
            .qword      32000000000000000000000000000031 &#13;
            .qword      330000000000000000000000000000032 &#13;
            .qword      3400000000000000000000000000000033 &#13;
            .qword      35000000000000000000000000000000034 &#13;
            .qword      360000000000000000000000000000000035 &#13;
            .qword      3700000000000000000000000000000000036 &#13;
            .qword      38000000000000000000000000000000000037 &#13;
            .qword      300000000000000000000000000000000000038 &#13;
            .qword      340282366920938463463374607431768211455 &#13;
qcnt        =           (.-qdata)/16 &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_512" aria-label="512"/>            .data &#13;
buffer:     .space      256,0 &#13;
&#13;
            .code &#13;
            .extern     printf &#13;
&#13;
// Return program title to C++ program: &#13;
&#13;
            proc    getTitle, public &#13;
            lea     x0, ttlStr &#13;
            ret &#13;
            endp    getTitle &#13;
&#13;
// div10 &#13;
//&#13;
// This procedure does a general 128-bit / 10 division operation &#13;
// using the following algorithm (assume all variables except &#13;
// Remainder are 128-bit objects; Remainder is 64 bits): &#13;
//&#13;
// Quotient := Dividend; &#13;
// Remainder := 0; &#13;
// for i := 1 to NumberBits do &#13;
//&#13;
//  Remainder:Quotient := Remainder:Quotient SHL 1; &#13;
//  if Remainder &gt;= 10 then &#13;
//&#13;
//     Remainder := Remainder - 10; &#13;
//     Quotient := Quotient + 1; &#13;
//&#13;
//  endif &#13;
// endfor &#13;
//&#13;
// Data passed: &#13;
//&#13;
// 128-bit dividend in X6:X5 &#13;
//&#13;
// Data returned: &#13;
//&#13;
// 128-bit quotient in X6:X5 &#13;
// 64-bit remainder in X4 &#13;
//&#13;
// Modifies X1 &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> proc    div10 &#13;
&#13;
#define remainder  x4 &#13;
#define dividendL  x5 &#13;
#define dividendH  x6 &#13;
#define quotientL  dividendL &#13;
#define quotientH  dividendH &#13;
&#13;
// Initialize remainder with 0: &#13;
&#13;
            mov     remainder, #0 &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_513" aria-label="513"/>// Copy the dividend to local storage: &#13;
&#13;
            mov     w1, #128           // Count off bits in W0. &#13;
&#13;
// Compute Remainder:Quotient := Remainder:Quotient LSL 1 &#13;
//&#13;
// Note: adds x, x, x is equivalent to lsl x, x, #1 &#13;
//       adcs x, x, x is equivalent to rol x, x, #1 &#13;
//                    (if rol existed) &#13;
//&#13;
// The following four instructions perform a 256-bit &#13;
// extended-precision shift (left) dividend through &#13;
// remainder. &#13;
&#13;
repeatLp:   adds    dividendL, dividendL, dividendL &#13;
            adcs    dividendH, dividendH, dividendH &#13;
            adc     remainder, remainder, remainder &#13;
&#13;
// Do a comparison to see if the remainder &#13;
// is greater than or equal to 10: &#13;
&#13;
            cmp     remainder, #10 &#13;
            blo     notGE &#13;
&#13;
// Remainder := Remainder - Divisor &#13;
&#13;
isGE:       sub     remainder, remainder, #10 &#13;
&#13;
// Quotient := Quotient + 1 &#13;
&#13;
            adds    quotientL, quotientL, #1 &#13;
            adc     quotientH, quotientH, xzr &#13;
&#13;
// Repeat for 128 bits: &#13;
&#13;
notGE:      subs    w1, w1, #1 &#13;
            bne     repeatLp &#13;
&#13;
            ret     // Return to caller. &#13;
            endp    div10 &#13;
&#13;
// u128toStr: &#13;
//&#13;
//  Converts a 128-bit unsigned integer to a string &#13;
//&#13;
//  Inputs: &#13;
//      X0-     Pointer to buffer to receive string &#13;
//      X1-     Points at the unsigned 128-bit integer to convert &#13;
//&#13;
//  Outputs: &#13;
//      Buffer- Receives the zero-terminated string &#13;
//&#13;
//  Buffer must have at least 40 bytes allocated for it. &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_514" aria-label="514"/>          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> proc    u128toStr &#13;
            stp     x0, x1, [sp, #-16]! &#13;
            stp     x4, x5, [sp, #-16]! &#13;
            stp     x6, lr, [sp, #-16]! &#13;
&#13;
            ldp     x5, x6, [x1]    // Test value for 0. &#13;
            orr     x4, x5, x6 &#13;
            cmp     x4, xzr         // Z = 1 if X6:X5 is 0. &#13;
            bne     doRec128 &#13;
&#13;
            // Special case for zero, just write &#13;
            // "0" to the buffer &#13;
&#13;
            mov     w4, #'0' &#13;
            strb    w4, [x0], #1 &#13;
            b.al    allDone2 &#13;
&#13;
doRec128:   bl      u128toStrRec    // X6:X5 contain value. &#13;
&#13;
            // Restore registers: &#13;
&#13;
allDone2:   strb    wzr, [x0]       // Zero-terminating byte &#13;
            ldp     x6, lr, [sp], #16 &#13;
            ldp     x4, x5, [sp], #16 &#13;
            ldp     x0, x1, [sp], #16 &#13;
            ret &#13;
            endp    u128toStr &#13;
&#13;
// u128toStrRec is the recursive version that handles &#13;
// nonzero values. &#13;
//&#13;
// Value to convert is passed in X6:X5. &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> proc    u128toStrRec &#13;
            stp     x4, lr, [sp, #-16]! &#13;
&#13;
            // Convert LO digit to a character: &#13;
&#13;
            bl      div10          // Quotient -&gt; X6:X5, Rem -&gt; W4 &#13;
&#13;
            // Make recursive call if quotient is not 0: &#13;
&#13;
            orr     lr, x5, x6     // Use LR as a temporary. &#13;
            cmp     lr, #0 &#13;
            beq     allDone &#13;
&#13;
            // New value is quotient (X6:X5) from above: &#13;
&#13;
            bl      u128toStrRec &#13;
&#13;
            // When this function has processed all the &#13;
            // digits, write them to the buffer: &#13;
&#13;
allDone:    orr     w4, w4, #'0'    // Convert to char. &#13;
            strb    w4, [x0], #1    // Bump pointer after store. &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_515" aria-label="515"/>            // Restore state and return: &#13;
&#13;
            ldp     x4, lr, [sp], #16    // Restore prev char. &#13;
            ret &#13;
            endp    u128toStrRec &#13;
&#13;
// Here is the asmMain function. &#13;
&#13;
            proc    asmMain, public &#13;
&#13;
            locals  am &#13;
            dword   am.x2021 &#13;
            byte    stk, 64 &#13;
            endl    am &#13;
&#13;
            enter   am.size              // Reserve space on stack. &#13;
&#13;
            stp     x20, x21, [fp, #am.x2021] &#13;
&#13;
            lea     x20, qdata &#13;
            mov     x21, #qcnt &#13;
loop:       mov     x1, x20 &#13;
            lea     x0, buffer &#13;
            bl      u128toStr &#13;
&#13;
            lea     x1, buffer &#13;
            mstr    x1, [sp] &#13;
            lea     x0, fmtStr1 &#13;
            bl      printf &#13;
&#13;
            add     x20, x20, #16       // Next value to convert &#13;
            subs    x21, x21, #1 &#13;
            bne     loop &#13;
&#13;
            ldp     x20, x21, [fp, #am.x2021] &#13;
            leave &#13;
            ret &#13;
            endp    asmMain </code></pre>&#13;
<p class="TX">The code includes an optimized version of the 128-bit division function that divides a number by 10 <span class="CodeAnnotation" aria-label="annotation1">❶</span>. This is followed by the nonrecursive entry point for <span class="SANS_TheSansMonoCd_W5Regular_11">u128toStr</span>, which handles 0 as a special case and calls the recursive version for all other values <span class="CodeAnnotation" aria-label="annotation2">❷</span>, and the recursive code for <span class="SANS_TheSansMonoCd_W5Regular_11">u128toStr</span> <span class="CodeAnnotation" aria-label="annotation3">❸</span>. As these functions are nearly identical to the recursive 64-bit string output functions, refer to that code (in Listing 9-6) for more details.</p>&#13;
<p class="TX">One issue with the <span class="SANS_TheSansMonoCd_W5Regular_11">u128toStr</span> function is that it is much slower than the other numeric-to-string functions. This is all due to the performance of the <span class="SANS_TheSansMonoCd_W5Regular_11">div10</span> subroutine. Because the 128-bit divide-by-10 algorithm is so slow, I won’t bother improving the performance of the <span class="SANS_TheSansMonoCd_W5Regular_11">u128toStr</span> conversion function. Unless you can come up with a very high-performance <span class="SANS_TheSansMonoCd_W5Regular_11">div10</span> subroutine (perhaps using multiplication by a reciprocal; see section 9.6, <span class="Xref">“For More Information,”</span> on <span class="Xref"><a href="chapter9.xhtml#pg_603">page 603</a></span>), trying to optimize <span class="SANS_TheSansMonoCd_W5Regular_11">u128toStr</span> is probably <span role="doc-pagebreak" epub:type="pagebreak" id="pg_516" aria-label="516"/>a waste of time. Fortunately, this function likely won’t be called often, so its performance won’t matter much.</p>&#13;
<p class="TX">Here’s the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and sample output from Listing 9-9:</p>&#13;
<pre id="pre-741"><code>$<span class="SANS_TheSansMonoCd_W7Bold_11"> ./build Listing9-9</span> &#13;
$ <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing9-9</span> &#13;
Calling Listing9-9: &#13;
Value = 1 &#13;
Value = 21 &#13;
Value = 302 &#13;
Value = 4003 &#13;
Value = 50004 &#13;
Value = 600005 &#13;
Value = 7000006 &#13;
Value = 80000007 &#13;
Value = 900000008 &#13;
Value = 1000000009 &#13;
Value = 11000000010 &#13;
Value = 120000000011 &#13;
Value = 1300000000012 &#13;
Value = 14000000000013 &#13;
Value = 150000000000014 &#13;
Value = 1600000000000015 &#13;
Value = 17000000000000016 &#13;
Value = 180000000000000017 &#13;
Value = 1900000000000000018 &#13;
Value = 20000000000000000019 &#13;
Value = 210000000000000000020 &#13;
Value = 2200000000000000000021 &#13;
Value = 23000000000000000000022 &#13;
Value = 240000000000000000000023 &#13;
Value = 2500000000000000000000024 &#13;
Value = 26000000000000000000000025 &#13;
Value = 270000000000000000000000026 &#13;
Value = 2800000000000000000000000027 &#13;
Value = 29000000000000000000000000028 &#13;
Value = 300000000000000000000000000029 &#13;
Value = 3100000000000000000000000000030 &#13;
Value = 32000000000000000000000000000031 &#13;
Value = 330000000000000000000000000000032 &#13;
Value = 3400000000000000000000000000000033 &#13;
Value = 35000000000000000000000000000000034 &#13;
Value = 360000000000000000000000000000000035 &#13;
Value = 3700000000000000000000000000000000036 &#13;
Value = 38000000000000000000000000000000000037 &#13;
Value = 300000000000000000000000000000000000038 &#13;
Value = 340282366920938463463374607431768211455 &#13;
Listing9-9 terminated </code></pre>&#13;
<p class="TX">I will leave it to you to create a 128-bit signed-integer conversion function, since the code is almost identical to <span class="SANS_TheSansMonoCd_W5Regular_11">i64toStr</span> (see Listing 9-8); you just have to supply 128-bit negation and comparison operations. As a hint, for the comparison, just check the HO dword to see if the sign bit is set.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_517" aria-label="517"/>&#13;
<h4 class="H2" id="sec7"><span id="h2-172"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">9.1.6 Formatted Conversions</span></h4>&#13;
<p class="TNI1">The code in the previous sections converted signed and unsigned integers to strings by using the minimum number of necessary character positions. To create nicely formatted tables of values, you will need to write functions that provide appropriate padding in front of the string of digits before actually emitting the digits. Once you have the “unformatted” versions of these routines, implementing the formatted versions is easy.</p>&#13;
<p class="TX">The first step is to write <span class="SANS_TheSansMonoCd_W5Regular_11">iSize</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">uSize</span> routines that compute the minimum number of character positions needed to display the value. One algorithm to accomplish this is similar to the numeric string conversion routines. The only difference is that you initialize a counter to 0 upon entry into the routine and increment this counter rather than outputting a digit on each recursive call. (Don’t forget to increment the counter inside <span class="SANS_TheSansMonoCd_W5Regular_11">iSize</span> if the number is negative; you must allow for the output of the minus sign.) After the calculation is complete, these routines should return the size of the operand in the X0 register.</p>&#13;
<p class="TX">However, thanks to its use of recursion and division, such a conversion scheme is slow. A brute-force conversion using a binary search is shown in Listing 9-10.</p>&#13;
<pre id="pre-742"><code>// Listing9-10.S &#13;
//&#13;
// u64Size function: Computes the size &#13;
// of an unsigned 64-bit integer (in &#13;
// print positions) &#13;
&#13;
            #include    "aoaa.inc"&#13;
&#13;
            .section    .rodata, "" &#13;
ttlStr:     .asciz      "Listing 9-10"&#13;
fmtStr:     .asciz      "Value = %llu, size=%d\n"&#13;
&#13;
// Values to test the u64Size function: &#13;
&#13;
dVals:      .dword      1 &#13;
            .dword      10 &#13;
            .dword      100 &#13;
            .dword      1000 &#13;
            .dword      10000 &#13;
            .dword      100000 &#13;
            .dword      1000000 &#13;
            .dword      10000000 &#13;
            .dword      100000000 &#13;
            .dword      1000000000 &#13;
            .dword      10000000000 &#13;
            .dword      100000000000 &#13;
            .dword      1000000000000 &#13;
            .dword      10000000000000 &#13;
            .dword      100000000000000 &#13;
            .dword      1000000000000000 &#13;
            .dword      10000000000000000 &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_518" aria-label="518"/>            .dword      100000000000000000 &#13;
            .dword      1000000000000000000 &#13;
            .dword      10000000000000000000 &#13;
dCnt        =           (.-dVals) / 8 &#13;
&#13;
            .code &#13;
            .extern     printf &#13;
&#13;
// Return program title to C++ program: &#13;
&#13;
            proc    getTitle, public &#13;
            lea     x0, ttlStr &#13;
            ret &#13;
            endp    getTitle &#13;
&#13;
// u64Size &#13;
//&#13;
//  Counts the number of output positions &#13;
//  required for an integer-to-decimal-&#13;
//  string conversion &#13;
//&#13;
//  Uses a binary search to quickly &#13;
//  count the digits required by a value &#13;
//&#13;
// Input: &#13;
//  X1- Unsigned integer to count &#13;
//&#13;
// Output: &#13;
//  X1- Digit count &#13;
//&#13;
// Table of digit counts and values: &#13;
//&#13;
//   1: 1 &#13;
//   2: 10 &#13;
//   3: 100 &#13;
//   4: 1,000 &#13;
//   5: 10,000 &#13;
//   6: 100,000 &#13;
//   7: 1,000,000 &#13;
//   8: 10,000,000 &#13;
//   9: 100,000,000 &#13;
//  10: 1,000,000,000 &#13;
//  11: 10,000,000,000 &#13;
//  12: 100,000,000,000 &#13;
//  13: 1,000,000,000,000 &#13;
//  14: 10,000,000,000,000 &#13;
//  15: 100,000,000,000,000 &#13;
//  16: 1,000,000,000,000,000 &#13;
//  17: 10,000,000,000,000,000 &#13;
//  18: 100,000,000,000,000,000 &#13;
//  19: 1,000,000,000,000,000,000 &#13;
//  20: 10,000,000,000,000,000,000 &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> proc    u64Size &#13;
            stp     x0, x2, [sp, #-16]! &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_519" aria-label="519"/>          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> mov     x2, x1 &#13;
            ldr     x0, =1000000000 // 10: 1,000,000,000 &#13;
            cmp     x2, x0 &#13;
            bhs     ge10 &#13;
&#13;
            ldr     x0, =10000 &#13;
            cmp     x2, x0 &#13;
            bhs     ge5 &#13;
&#13;
            // Must be 1 to 4 digits here: &#13;
&#13;
            mov     x1, #1 &#13;
            cmp     x2, #1000 &#13;
            cinc    x1, x1, hs &#13;
            cmp     x2, #100 &#13;
            cinc    x1, x1, hs &#13;
            cmp     x2, #10 &#13;
            cinc    x1, x1, hs &#13;
            ldp     x0, x2, [sp], #16 &#13;
            ret &#13;
&#13;
// Must be 5 to 9 digits here: &#13;
&#13;
ge5:        ldr     x0, =1000000    // 7: 1,000,000 &#13;
            cmp     x2, x0 &#13;
            bhs     ge7 &#13;
&#13;
            // Must be 5 or 6 digits: &#13;
&#13;
            mov     x1, #5 &#13;
            ldr     x0, =100000     // 6: 100,000 &#13;
            cmp     x2, x0 &#13;
            cinc    x1, x1, hs &#13;
            ldp     x0, x2, [sp], #16 &#13;
            ret &#13;
&#13;
// Must be 7 to 9 digits here: &#13;
&#13;
ge7:        mov     x1, #7 &#13;
            ldr     x0, =10000000   // 8: 10,000,000 &#13;
            cmp     x2, x0 &#13;
            cinc    x1, x1, hs &#13;
            ldr     x0, =100000000  // 9: 100,000,000 &#13;
            cmp     x2, x0 &#13;
            cinc    x1, x1, hs &#13;
            ldp     x0, x2, [sp], #16 &#13;
            ret &#13;
&#13;
// Handle 10 or more digits here: &#13;
&#13;
ge10:       ldr     x0, =100000000000000    // 15: 100,000,000,000,000 &#13;
            cmp     x2, x0 &#13;
            bhs     ge15 &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_520" aria-label="520"/>            // 10 to 14 digits here: &#13;
&#13;
            ldr     x0, =1000000000000      // 13: 1,000,000,000,000 &#13;
            cmp     x2, x0 &#13;
            bhs     ge13 &#13;
&#13;
            // 10 to 12 digits here: &#13;
&#13;
            mov     x1, #10 &#13;
            ldr     x0, =10000000000        // 11: 10,000,000,000 &#13;
            cmp     x2, x0 &#13;
          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> cinc    x1, x1, hs &#13;
            ldr     x0, =100000000000       // 12: 100,000,000,000 &#13;
            cmp     x2, x0 &#13;
            cinc    x1, x1, hs &#13;
            ldp     x0, x2, [sp], #16 &#13;
            ret &#13;
&#13;
// 13 or 14 digits here: &#13;
&#13;
ge13:       mov     x1, #13 &#13;
            ldr     x0, =10000000000000     // 14: 10,000,000,000,000 &#13;
            cmp     x2, x0 &#13;
            cinc    x1, x1, hs &#13;
            ldp     x0, x2, [sp], #16 &#13;
            ret &#13;
&#13;
// 15 to 20 digits here: &#13;
&#13;
ge15:       ldr     x0, =100000000000000000 // 18: 100,000,000,000,000,000 &#13;
            cmp     x2, x0 &#13;
            bhs     ge18 &#13;
&#13;
            // 15, 16, or 17 digits here: &#13;
&#13;
            mov     x1, #15 &#13;
            ldr     x0, =1000000000000000   // 16: 1,000,000,000,000,000 &#13;
            cmp     x2, x0 &#13;
            cinc    x1, x1, hs &#13;
            ldr     x0, =10000000000000000  // 17: 10,000,000,000,000,000 &#13;
            cmp     x2, x0 &#13;
            cinc    x1, x1, hs &#13;
            ldp     x0, x2, [sp], #16 &#13;
            ret &#13;
&#13;
// 18 to 20 digits here: &#13;
&#13;
ge18:       mov     x1, #18 &#13;
            ldr     x0, =1000000000000000000  // 19: 1,000,000,000,000,000,000 &#13;
            cmp     x2, x0 &#13;
            cinc    x1, x1, hs &#13;
            ldr     x0, =10000000000000000000 // 20 digits &#13;
            cmp     x2, x0 &#13;
            cinc    x1, x1, hs &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_521" aria-label="521"/>            ldp     x0, x2, [sp], #16 &#13;
            ret &#13;
            endp    u64Size </code></pre>&#13;
<p class="TX">The actual <span class="SANS_TheSansMonoCd_W5Regular_11">u64Size</span> function <span class="CodeAnnotation" aria-label="annotation1">❶</span> uses a binary search algorithm to quickly scan through all the possible values to determine the digit count. It begins by dividing the search space in half, by comparing the input value (moved to X2) against a 10-digit value <span class="CodeAnnotation" aria-label="annotation2">❷</span>. In the usual binary search fashion, the two sections of code will test for numbers with 1 to 9 digits and 10 to 20 digits. In each of those ranges, the search is (roughly) broken into halves again and again until the algorithm zeros in on the exact number of digits. When the code gets down to 2 to 4 digits, it uses some straight-line code and a series of <span class="SANS_TheSansMonoCd_W5Regular_11">cinc</span> instructions to rapidly handle the last few cases without executing a branch <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">Here’s the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and sample output:</p>&#13;
<pre id="pre-743"><code>$ <span class="SANS_TheSansMonoCd_W7Bold_11">./build Listing9-10</span> &#13;
$ <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing9-10</span> &#13;
Calling Listing9-10: &#13;
Value = 1, size=1 &#13;
Value = 10, size=2 &#13;
Value = 100, size=3 &#13;
Value = 1000, size=4 &#13;
Value = 10000, size=5 &#13;
Value = 100000, size=6 &#13;
Value = 1000000, size=7 &#13;
Value = 10000000, size=8 &#13;
Value = 100000000, size=9 &#13;
Value = 1000000000, size=10 &#13;
Value = 10000000000, size=11 &#13;
Value = 100000000000, size=12 &#13;
Value = 1000000000000, size=13 &#13;
Value = 10000000000000, size=14 &#13;
Value = 100000000000000, size=15 &#13;
Value = 1000000000000000, size=16 &#13;
Value = 10000000000000000, size=17 &#13;
Value = 100000000000000000, size=18 &#13;
Value = 1000000000000000000, size=19 &#13;
Value = 10000000000000000000, size=20 &#13;
Listing9-10 terminated </code></pre>&#13;
<p class="TX">For signed integers, add the function in Listing 9-11 to the code in Listing 9-10 (find a full Listing 9-11 in the book’s downloadable code files at <i><a href="https://artofarm.randallhyde.com">https://<wbr/>artofarm<wbr/>.randallhyde<wbr/>.com</a></i>).</p>&#13;
<pre id="pre-744"><code>// Listing9-11.S &#13;
//&#13;
// i64Size: &#13;
//&#13;
// Computes the number of character positions that &#13;
// the i64toStr function will emit &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_522" aria-label="522"/>            proc    i64Size &#13;
            str     lr, [sp, #-16]! &#13;
&#13;
            cmp     x1, #0          // If less than zero, &#13;
            bge     isPositive      // negate and treat &#13;
                                    // like an uns64. &#13;
            neg     x1, x1 &#13;
&#13;
            bl      u64Size &#13;
            add     x1, x1, #1      // Adjust for "-". &#13;
            ldr     lr, [sp], #16 &#13;
            ret &#13;
&#13;
isPositive: bl      u64Size &#13;
            ldr     lr, [sp], #16 &#13;
            ret &#13;
            endp    i64Size </code></pre>&#13;
<p class="TX">For extended-precision size operations, the binary search approach quickly becomes unwieldy (64 bits is bad enough). The best solution is to divide your extended-precision value by a power of 10 (say, 1e+16). This will reduce the size of the number by 16 digits. Repeat this process as long as the quotient is greater than 64 bits, keeping track of the number of times you’ve divided the number by 1e+16. When the quotient fits into 64 bits (19 or 20 digits), call the 64-bit <span class="SANS_TheSansMonoCd_W5Regular_11">u64Size</span> function and add in the number of digits you eliminated with the division operation (16 for each division by 1e+16). I’ll leave this implementation to you.</p>&#13;
<p class="TX">Once you have the <span class="SANS_TheSansMonoCd_W5Regular_11">i64Size</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">u64Size</span> routines, writing the formatted output routines <span class="SANS_TheSansMonoCd_W5Regular_11">u64toStrSize</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">i64toStrSize</span> is easy. On initial entry, these routines call the corresponding <span class="SANS_TheSansMonoCd_W5Regular_11">i64Size</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">u64Size</span> routine to determine the number of character positions for the number. If the value that the <span class="SANS_TheSansMonoCd_W5Regular_11">i64Size</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">u64Size</span> routine returns is greater than or equal to the value of the minimum size parameter (passed into <span class="SANS_TheSansMonoCd_W5Regular_11">u64toStrSize</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">i64toStrSize</span>), no other formatting is necessary. If the value of the parameter size is greater than the value <span class="SANS_TheSansMonoCd_W5Regular_11">i64Size</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">u64Size</span> returns, the program must compute the difference between these two values and emit that many spaces (or other filler characters) to the output string before the numeric conversion (assuming right-justification of the value, which is what this chapter presents).</p>&#13;
<p class="TX">Listing 9-12 shows the <span class="SANS_TheSansMonoCd_W5Regular_11">utoStrSize</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">itoStrSize</span> functions (full source code appears online); here, I omit everything but the <span class="SANS_TheSansMonoCd_W5Regular_11">utoStrSize</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">itoStrSize</span> functions themselves.</p>&#13;
<pre id="pre-745"><code>// Listing9-12.S (partial) &#13;
//&#13;
// u64ToSizeStr &#13;
//&#13;
//  Converts an unsigned 64-bit integer to &#13;
//  a character string, using a minimum field &#13;
//  width &#13;
//&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_523" aria-label="523"/>//  Inputs: &#13;
//      X0- Pointer to buffer to receive string &#13;
//&#13;
//      X1- Unsigned 64-bit integer to convert &#13;
//          to a string &#13;
//&#13;
//      X2- Minimum field width for the string &#13;
//          (maximum value is 1,024). Note: if &#13;
//          the minimum field width value is less &#13;
//          than the actual output size of the &#13;
//          integer, this function will ignore &#13;
//          the value in X2 and use the correct &#13;
//          number of output positions for the &#13;
//          value. &#13;
//&#13;
//  Outputs: &#13;
//&#13;
//      Buffer- Receives converted characters. &#13;
//              Buffer must be at least 22 bytes &#13;
//              or X1 + 1 bytes long. &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> proc    u64ToStrSize &#13;
            stp     x0, lr, [sp, #-16]! &#13;
            stp     x1, x2, [sp, #-16]! &#13;
            stp     x23, x24, [sp, #-16]! &#13;
            stp     x25, x26, [sp, #-16]! &#13;
&#13;
            // Initialize x25 and x26 with &#13;
            // appropriate functions to call: &#13;
&#13;
            lea     x25, u64Size &#13;
            lea     x26, u64ToStr &#13;
&#13;
            b.al    toSizeStr &#13;
            endp    u64ToStrSize &#13;
&#13;
/////////////////////////////////////////////////////&#13;
//&#13;
// i64ToStrSize: &#13;
//&#13;
//  Just like u64ToStrSize, but handles signed integers &#13;
//&#13;
//  Inputs: &#13;
//      X0- Pointer to buffer to receive string &#13;
//&#13;
//      X1- Signed 64-bit integer to convert &#13;
//          to a string &#13;
//&#13;
//      X2- Minimum field width for the string &#13;
//          (maximum value is 1,024). Note: if &#13;
//          the minimum field width value is less &#13;
//          than the actual output size of the &#13;
//          integer, this function will ignore &#13;
//          the value in X2 and use the correct &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_524" aria-label="524"/>//          number of output positions for the &#13;
//          value. &#13;
//&#13;
//      Note:   Don't forget that if the number &#13;
//              is negative, the '-' consumes &#13;
//              an output position. &#13;
//&#13;
//  Outputs: &#13;
//      Buffer- Receives converted character. &#13;
//              Buffer must be at least 22 bytes &#13;
//              or X2 + 1 bytes long. &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> proc    i64ToStrSize &#13;
            stp     x0, lr, [sp, #-16]! &#13;
            stp     x1, x2, [sp, #-16]! &#13;
            stp     x23, x24, [sp, #-16]! &#13;
            stp     x25, x26, [sp, #-16]! &#13;
&#13;
            // Initialize x25 and x26 with &#13;
            // appropriate functions to call: &#13;
&#13;
            lea     x25, i64Size &#13;
            lea     x26, i64ToStr &#13;
&#13;
            b.al    toSizeStr   // Technically, this could just fall through. &#13;
            endp    i64ToStrSize &#13;
&#13;
///////////////////////////////////////////////////////&#13;
//&#13;
// toSizeStr: &#13;
//&#13;
//  Special function to handle signed and &#13;
//  unsigned conversions for u64ToSize and i64ToSize &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> proc    toSizeStr &#13;
&#13;
            mov     x24, x1 // Save for now. &#13;
          <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> blr     x25     // Compute size of number. &#13;
&#13;
            // Compute difference between actual size &#13;
            // and desired size. Set to the larger of &#13;
            // the two: &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> cmp     x2, x1 &#13;
            csel    x23, x2, x1, ge &#13;
&#13;
            // Just as a precaution, limit the &#13;
            // size to 1,024 characters (including &#13;
            // the zero-terminating byte): &#13;
&#13;
            mov     x2, #1023   // Don't count 0 byte here. &#13;
            cmp     x23, x2 &#13;
            csel    x23, x23, x2, ls &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_525" aria-label="525"/>            // Compute the number of spaces to emit before &#13;
            // the first digit of the number: &#13;
&#13;
            subs    x23, x23, x1 &#13;
            beq     spacesDone &#13;
&#13;
            // Emit that many spaces to the buffer: &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> mov     x1, #0x2020 &#13;
            movk    x1, #0x2020, lsl #16 &#13;
            movk    x1, #0x2020, lsl #32 &#13;
            movk    x1, #0x2020, lsl #48 &#13;
            b.al    tst8 &#13;
&#13;
            // Handle sequences of eight spaces: &#13;
&#13;
whl8:       str     x1, [x0], #8 &#13;
            sub     x23, x23, #8 &#13;
tst8:       cmp     x23, #8 &#13;
            bge     whl8 &#13;
&#13;
            // If four to seven spaces, emit four &#13;
            // spaces here: &#13;
&#13;
            cmp     x23, #4 &#13;
            blt     try2 &#13;
            str     w1, [x0], #4 &#13;
            sub     x23, x23, #4 &#13;
&#13;
            // If two or three spaces, emit two &#13;
            // here: &#13;
&#13;
try2:       cmp     x23, #2 &#13;
            blt     try1 &#13;
            strh    w1, [x0], #2 &#13;
            sub     x23, x23, #2 &#13;
&#13;
            // If one space left, emit it here: &#13;
&#13;
try1:       cmp     x23, #1 &#13;
            blt     spacesDone &#13;
            strb    w1, [x0], #1 &#13;
&#13;
            // Okay, emit the digits here: &#13;
&#13;
spacesDone: mov     x1, x24 // Retrieve value. &#13;
          <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> blr     x26     // XXXToStr &#13;
&#13;
            ldp     x25, x26, [sp], #16 &#13;
            ldp     x23, x24, [sp], #16 &#13;
            ldp     x1, x2,   [sp], #16 &#13;
            ldp     x0, lr,   [sp], #16 &#13;
            ret &#13;
            endp    toSizeStr &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_526" aria-label="526"/>///////////////////////////////////////////////////////&#13;
//&#13;
// printSize &#13;
//&#13;
// Utility used by the main program to &#13;
// compute sizes and print them &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation8">❽</span> proc    printSize &#13;
&#13;
            locals  ps &#13;
            dword   stk, 64 &#13;
            endl    ps &#13;
&#13;
            enter   ps.size &#13;
&#13;
            mov     x6, x1 &#13;
            lea     x0, buffer &#13;
            blr     x27         // Call XXXToStrSize. &#13;
&#13;
            mov     x1, x6 &#13;
            mstr    x1, [sp] &#13;
            mstr    x2, [sp, #8] &#13;
            lea     x3, buffer &#13;
            mstr    x3, [sp, #16] &#13;
            lea     x0, fmtStr &#13;
            bl      printf &#13;
&#13;
            leave &#13;
            endp    printSize &#13;
&#13;
&#13;
values:     .dword  1, 10, 100, 1000, 10000, 100000, 1000000 &#13;
            .dword  10000000, 100000000, 1000000000, 10000000000 &#13;
            .dword  100000000000, 1000000000000, 10000000000000 &#13;
            .dword  100000000000000, 1000000000000000 &#13;
            .dword  10000000000000000, 100000000000000000 &#13;
            .dword  1000000000000000000, 10000000000000000000 &#13;
            .dword  0x7fffffffffffffff &#13;
            .set    valSize, (.-values)/8 &#13;
&#13;
negValues:  .dword  -1, -10, -100, -1000, -10000, -100000, -1000000 &#13;
            .dword  -10000000, -100000000, -1000000000, -10000000000 &#13;
            .dword  -100000000000, -1000000000000, -10000000000000 &#13;
            .dword  -100000000000000, -1000000000000000 &#13;
            .dword  -10000000000000000, -100000000000000000 &#13;
            .dword  -1000000000000000000, -10000000000000000000 &#13;
            .dword  0x8000000000000000 &#13;
&#13;
sizes:      .word   5, 6, 7, 8, 9, 10, 15, 15, 15, 15 &#13;
            .word   20, 20, 20, 20, 20, 25, 25, 25, 25, 25, 30 &#13;
&#13;
///////////////////////////////////////////////////////&#13;
//&#13;
// Here is the asmMain function: &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_527" aria-label="527"/>          <span class="Code_CodeAnnotation" aria-label="annotation9">❾</span> proc    asmMain, public &#13;
&#13;
            locals  am &#13;
            qword   am.x26x27 &#13;
            qword   am.x24x25 &#13;
            byte    am.stk, 64 &#13;
            endl    am &#13;
&#13;
            enter   am.size     // Activation record &#13;
            stp     x26, x27, [fp, #am.x26x27] &#13;
            stp     x24, x25, [fp, #am.x24x25] &#13;
&#13;
// Test unsigned integers: &#13;
&#13;
            lea     x27, u64ToStrSize &#13;
            lea     x24, values &#13;
            lea     x25, sizes &#13;
            mov     x26, #valSize &#13;
tstLp:      ldr     x1, [x24], #8 &#13;
            ldr     w2, [x25], #4 &#13;
            bl      printSize &#13;
            subs    x26, x26, #1 &#13;
            bne     tstLp &#13;
&#13;
            lea     x27, i64ToStrSize &#13;
            lea     x24, negValues &#13;
            lea     x25, sizes &#13;
            mov     x26, #valSize &#13;
ntstLp:     ldr     x1, [x24], #8 &#13;
            ldr     w2, [x25], #4 &#13;
            bl      printSize &#13;
            subs    x26, x26, #1 &#13;
            bne     ntstLp &#13;
&#13;
            ldp     x26, x27, [fp, #am.x26x27] &#13;
            ldp     x24, x25, [fp, #am.x24x25] &#13;
            leave &#13;
            endp    asmMain </code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">u64toStrSize</span> function <span class="CodeAnnotation" aria-label="annotation1">❶</span> simply loads up X25 and X26 with appropriate addresses and branches to the generic <span class="SANS_TheSansMonoCd_W5Regular_11">toSizeStr</span> function to handle the real work. The <span class="SANS_TheSansMonoCd_W5Regular_11">i64ToStrSize</span> function <span class="CodeAnnotation" aria-label="annotation2">❷</span> does the same thing for signed integer conversions.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">toSizeStr</span> function <span class="CodeAnnotation" aria-label="annotation3">❸</span> handles the real work. First, it calls the appropriate <span class="SANS_TheSansMonoCd_W5Regular_11">toSize</span> function (whose address was passed in X25) to compute the minimum number of print positions the value will require <span class="CodeAnnotation" aria-label="annotation4">❹</span>. It then computes the number of fill characters required in front of the digits to right-justify the number in the output field <span class="CodeAnnotation" aria-label="annotation5">❺</span>. It emits the required number of filler characters <span class="CodeAnnotation" aria-label="annotation6">❻</span> before outputting the numeric string <span class="CodeAnnotation" aria-label="annotation7">❼</span>. Probably the only thing worth noting here is that the code attempts to output eight spaces at a time in order to improve performance, as long as there are at least eight padding characters, then four, then two, and finally one.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_528" aria-label="528"/>The <span class="SANS_TheSansMonoCd_W5Regular_11">printSize</span> procedure <span class="CodeAnnotation" aria-label="annotation8">❽</span> is a little utility function that the <span class="SANS_TheSansMonoCd_W5Regular_11">asmMain</span> procedure uses to display values, and the <span class="SANS_TheSansMonoCd_W5Regular_11">asmMain</span> procedure <span class="CodeAnnotation" aria-label="annotation9">❾</span> tests the <span class="SANS_TheSansMonoCd_W5Regular_11">u64ToStrSize</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">i64ToStrSize</span> procedures.</p>&#13;
<p class="TX">Here’s the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and sample output for Listing 9-12 (remember that the actual main program appears only in the online source code):</p>&#13;
<pre id="pre-746"><code>$<span class="SANS_TheSansMonoCd_W7Bold_11"> ./build Listing9-12</span> &#13;
$ <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing9-12</span> &#13;
Calling Listing9-12: &#13;
                   1:   5='    1' &#13;
                  10:   6='    10' &#13;
                 100:   7='    100' &#13;
                1000:   8='    1000' &#13;
               10000:   9='    10000' &#13;
              100000:  10='    100000' &#13;
             1000000:  15='        1000000' &#13;
            10000000:  15='       10000000' &#13;
           100000000:  15='      100000000' &#13;
          1000000000:  15='     1000000000' &#13;
         10000000000:  20='         10000000000' &#13;
        100000000000:  20='        100000000000' &#13;
       1000000000000:  20='       1000000000000' &#13;
      10000000000000:  20='      10000000000000' &#13;
     100000000000000:  20='     100000000000000' &#13;
    1000000000000000:  25='         1000000000000000' &#13;
   10000000000000000:  25='        10000000000000000' &#13;
  100000000000000000:  25='       100000000000000000' &#13;
 1000000000000000000:  25='      1000000000000000000' &#13;
-8446744073709551616:  25='     10000000000000000000' &#13;
 9223372036854775807:  30='           9223372036854775807' &#13;
                  -1:   5='   -1' &#13;
                 -10:   6='   -10' &#13;
                -100:   7='   -100' &#13;
               -1000:   8='   -1000' &#13;
              -10000:   9='   -10000' &#13;
             -100000:  10='   -100000' &#13;
            -1000000:  15='       -1000000' &#13;
           -10000000:  15='      -10000000' &#13;
          -100000000:  15='     -100000000' &#13;
         -1000000000:  15='    -1000000000' &#13;
        -10000000000:  20='        -10000000000' &#13;
       -100000000000:  20='       -100000000000' &#13;
      -1000000000000:  20='      -1000000000000' &#13;
     -10000000000000:  20='     -10000000000000' &#13;
    -100000000000000:  20='    -100000000000000' &#13;
   -1000000000000000:  25='        -1000000000000000' &#13;
  -10000000000000000:  25='       -10000000000000000' &#13;
 -100000000000000000:  25='      -100000000000000000' &#13;
-1000000000000000000:  25='     -1000000000000000000' &#13;
 8446744073709551616:  25='      8446744073709551616' &#13;
-9223372036854775808:  30='          -9223372036854775808' &#13;
Listing9-12 terminated </code></pre>&#13;
<p class="Continued1">The output is <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">value</span><span class="SANS_TheSansMonoCd_W5Regular_11">:</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">size</span><span class="SANS_TheSansMonoCd_W5Regular_11">='</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">conversion</span><span class="SANS_TheSansMonoCd_W5Regular_11">'</span>.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_529" aria-label="529"/>&#13;
<h3 class="H1" id="sec8"><span id="h1-106"/><span class="SANS_Futura_Std_Bold_B_11">9.2 Converting Floating-Point Values to Strings</span></h3>&#13;
<p class="TNI1">Thus far, this chapter has dealt with converting integer numeric values to character strings (typically for output to the user). This section discusses converting floating-point values to a string, which is just as important.</p>&#13;
<p class="TX">Converting floating-point values to strings can take one of two forms:</p>&#13;
<ul class="ul">&#13;
<li class="BL">Decimal notation conversion (such as <span class="SANS_TheSansMonoCd_W5Regular_11">±</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">xxx</span><span class="SANS_TheSansMonoCd_W5Regular_11">.</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">yyy</span> format)</li>&#13;
<li class="BL">Exponential (or scientific) notation conversion (such as <span class="SANS_TheSansMonoCd_W5Regular_11">±</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">x</span><span class="SANS_TheSansMonoCd_W5Regular_11">.</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">yyyyy</span><span class="SANS_TheSansMonoCd_W5Regular_11">e±</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">zz</span> format)</li>&#13;
</ul>&#13;
<p class="TX">Regardless of the final output format, you’ll need two distinct operations to convert a value in floating-point form to a character string. First, you must convert the mantissa to an appropriate string of digits. Second, you convert the exponent to a string of digits.</p>&#13;
<p class="TX">However, this isn’t a simple case of converting two integer values to a decimal string and concatenating them (with an <i>e</i> between the mantissa and exponent). First of all, the mantissa is not an integer value; it is a fixed-point fractional binary value. Simply treating it as an <i>n</i>-bit binary value (where <i>n</i> is the number of mantissa bits) will almost always result in an incorrect conversion. Second, while the exponent is, more or less, an integer value, it represents a power of 2, not a power of 10. Displaying that power of 2 as an integer value is not appropriate for decimal floating-point representation. These two issues (fractional mantissa and binary exponent) are the source of the major complications associated with converting a floating-point value to a string.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>The exponent is actually a biased-exponent value. However, that’s easy to convert to a signed binary integer.</i></p>&#13;
<p class="TX">Double-precision floating-point values have a 53-bit mantissa (including the implied bit). This is not a 53-bit integer. Instead, those 53 bits represent a value from 1.0 to slightly less than 2.0. (See section 2.13, <span class="Xref">“IEEE Floating-Point Formats,”</span> on <span class="Xref"><a href="chapter2.xhtml#pg_93">page 93</a></span> for more details on the IEEE 64-bit floating-point format.) The double-precision format can represent numbers from 0 to about 5 × 10<sup>–324</sup> (around ±1 × 10<sup>±308</sup> using normalized values).</p>&#13;
<p class="TX">To output the mantissa in decimal form with approximately 16 digits of precision, successively multiply or divide the floating-point value by 10 until the number is from 1e+15 to just less than 1e+16 (that is, 9.9999 ... e+15). Once the exponent is in the appropriate range, the mantissa bits form a 16-digit integer value (no fractional part), which can be converted to a decimal string to obtain the 16 digits that make up the mantissa value.</p>&#13;
<p class="TX">To convert the exponent to an appropriate decimal string, track the number of multiplications or divisions by 10. For each division by 10, add 1 to the decimal exponent value; for each multiplication by 10, subtract 1 from the decimal exponent value. At the end of the process, subtract 16 from the decimal exponent value (as this process produces a value whose exponent is 16) and convert the decimal exponent value to a string.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_530" aria-label="530"/>The conversions in the following sections assume that you always want to produce a mantissa with 16 significant digits. To produce formatted output with fewer significant digits, see section 9.2.4, <span class="Xref">“Double-Precision Values to Strings,”</span> on <span class="Xref">the next page</span>.</p>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2" id="sec9"><span id="h2-173"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">9.2.1 Floating-Point Exponent to String of Decimal Digits</span></h4>&#13;
<p class="TNI1">To convert the exponent to a string of decimal digits, use the following algorithm:</p>&#13;
<div class="top">&#13;
<p class="ListNumber">  1.  If the number is 0.0, directly produce the mantissa output string of <span class="SANS_TheSansMonoCd_W5Regular_11">"0000000000000000"</span> (notice the space at the beginning of the string), set the exponent to 0, and you’re done. Otherwise, continue with the following steps.</p>&#13;
<p class="ListNumber">  2.  Initialize the decimal exponent to 0.</p>&#13;
<p class="ListNumber">  3.  If the exponent is negative, emit a hyphen (<span class="SANS_TheSansMonoCd_W5Regular_11">-</span>) character and negate the value; if it is positive, emit a space character.</p>&#13;
<p class="ListNumber">  4.  If the value of the (possibly negated) exponent is less than 1.0, skip to step 8.</p>&#13;
<p class="ListNumber">  5.  Positive exponents: Compare the number against successively smaller powers of 10, starting with 10 <sup>+ 256</sup>, then 10 <sup>+ 128</sup>, then 10 <sup>+ 64</sup>, then ..., then 10<sup>0</sup>. After each comparison, if the current value is greater than the power of 10, divide by that power of 10 and add the power-of-10 exponent (256, 128, ..., 0) to the decimal exponent value.</p>&#13;
<p class="ListNumber">  6.  Repeat step 5 until the exponent is 0 (that is, the value is in the range 1.0 ≤ <i>value</i> &lt; 10.0).</p>&#13;
<p class="ListNumber">  7.  Skip to step 10.</p>&#13;
<p class="ListNumber">  8.  Negative exponents: Compare the number against successful larger powers of 10 starting with 10<sup>–256</sup>, then, 10<sup>–128</sup>, then 10<sup>–64</sup>, then ..., then 10<sup>0</sup>. After each comparison, if the current value is less than the power of 10, divide by that power of 10 and subtract the power-of-10 exponent (256, 128, ..., 0) from the decimal exponent value.</p>&#13;
<p class="ListNumber">  9.  Repeat step 8 until the exponent is 0 (that is, the value is in the range 1.0 ≤ <i>value</i> &lt; 10.0).</p>&#13;
<p class="ListNumber">10.  At this point, the exponent value is a reasonable number that can be converted to an integer value by using standard unsigned-to-string conversions (see section 9.1.3, <span class="listnumber_Xref">“Unsigned Decimal Values to Strings,”</span> on <span class="listnumber_Xref"><a href="chapter9.xhtml#pg_495">page 495</a></span>).</p>&#13;
</div>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2" id="sec10"><span id="h2-174"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">9.2.2 Floating-Point Mantissa to String of Digits</span></h4>&#13;
<p class="TNI1">To convert the mantissa to a string of digits, you can’t simply treat the 53-bit mantissa produced in the previous section as an integer value, since it still represents an integer from 1.0 to just less than 2.0. However, if you multiply that floating-point value (which has been converted to a value from 1.0 to slightly less than 10.0) by 10<sup>+15</sup>, this effectively produces an integer with the digits shifted to the left 15 print positions (16 digits being the number of <span role="doc-pagebreak" epub:type="pagebreak" id="pg_531" aria-label="531"/>output digits possible with a double-precision value). You can then convert this “integer” to a string. The result will consist of the 16 mantissa digits. To convert the mantissa to a string, do the following:</p>&#13;
<div class="top">&#13;
<p class="ListNumber">  1.  Multiply the value produced by the exponent calculation in the previous section by 1e+15. This produces a number with the decimal digits shifted to the left by 15 print positions.</p>&#13;
<p class="ListNumber">  2.  Grab the 52-bit mantissa and OR in an implicit bit 52 equal to 1, and zero-extend this 53-bit value to 64 bits.</p>&#13;
<p class="ListNumber">  3.  Convert the resulting 64-bit value to a string by using the unsigned integer-to-string function given earlier in this chapter (see section 9.1.3, <span class="listnumber_Xref">“Unsigned Decimal Values to Strings,”</span> on <span class="listnumber_Xref"><a href="chapter9.xhtml#pg_495">page 495</a></span>).</p>&#13;
</div>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2" id="sec11"><span id="h2-175"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">9.2.3 Strings in Decimal and Exponential Format</span></h4>&#13;
<p class="TNI1">To produce a decimal string (rather than a number in exponential form), the remaining task is to properly place the decimal point into the string of digits. If the exponent is greater than or equal to 0, you need to insert the decimal point in position <i>exponent</i> + 1, starting from the first mantissa digit produced in the previous section. For example, if the mantissa conversion produced <span class="SANS_TheSansMonoCd_W5Regular_11">1234567890123456</span> and the exponent is 3, then you would insert a decimal point before the character at index 4 (3 + 1), yielding <span class="SANS_TheSansMonoCd_W5Regular_11">1234.567890123456</span> as the result.</p>&#13;
<p class="TX">If the exponent is greater than 16, insert <i>exponent</i> – 16 zero characters at the end of the string (or return an error if you don’t want to allow conversions of values larger than 1e+16 to decimal form). If the exponent is less than 0, insert <span class="SANS_TheSansMonoCd_W5Regular_11">0.</span> followed by <i>abs</i>(<i>exp</i>) – 1 zero characters in front of the string of digits. If the exponent is less than –16 (or another arbitrary value), you might elect to return an error or automatically switch to exponential form.</p>&#13;
<p class="TX">Producing exponential output is slightly easier than decimal output. Always insert a decimal point between the first and second characters in the converted mantissa string and then follow the string with <span class="SANS_TheSansMonoCd_W5Regular_11">e±</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">xxx</span>, where <span class="SANS_TheSansMonoCd_W5Regular_11">±</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">xxx</span> is the exponent value’s string conversion. For example, if the mantissa conversion produces <span class="SANS_TheSansMonoCd_W5Regular_11">1234567890123456</span> and the exponent is –3, the resulting string will be <span class="SANS_TheSansMonoCd_W5Regular_11">1.234567890123456e-003</span> (note the leading 0s on the exponent digits).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2" id="sec12"><span id="h2-176"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">9.2.4 Double-Precision Values to Strings</span></h4>&#13;
<p class="TNI1">This section presents the code that will convert a double-precision value to a string in either decimal or exponential form, with separate functions for the two output formats. As Listing 9-13 is rather long, I’ve broken it into pieces and annotated each section.</p>&#13;
<pre id="pre-747"><code>// Listing9-13.S &#13;
//&#13;
// Floating-point (double) to string conversion &#13;
//&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_532" aria-label="532"/>// Provides both exponential (scientific notation) &#13;
// and decimal output formats &#13;
            #include    "aoaa.inc"&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> .section    .rodata, "" &#13;
ttlStr:     .asciz      "Listing 9-13"&#13;
fmtStr1:    .asciz      "r64ToStr: value='%s'\n"&#13;
fmtStr2:    .asciz      "fpError: code=%lld\n"&#13;
fmtStr3:    .asciz      "e64ToStr: value='%s'\n"&#13;
newlines:   .asciz      "\n\n"&#13;
expStr:     .asciz      "\n\nTesting e64ToStr:\n\n"&#13;
&#13;
// r10str_1: A global character array that will &#13;
// hold the converted string &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> .data &#13;
r64str_1:   .space      32, 0 &#13;
&#13;
            .code &#13;
            .extern     printf &#13;
&#13;
// tenTo15: Used to multiply a value from 1.0 &#13;
// to less than 2.0 in order to convert the mantissa &#13;
// to an actual integer &#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> tenTo15:    .double     1.0e+15 &#13;
&#13;
// potPos, potNeg, and expTbl: &#13;
//&#13;
// Power of 10s tables (pot) used to quickly &#13;
// multiply or divide a floating-point value &#13;
// by powers of 10. expTbl is the power-of-&#13;
// 10 exponent (absolute value) for each of&#13;
// the entries in these tables. &#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> potPos:     .double     1.0e+0 &#13;
            .double     1.0e+1 &#13;
            .double     1.0e+2 &#13;
            .double     1.0e+4 &#13;
            .double     1.0e+8 &#13;
            .double     1.0e+16 &#13;
            .double     1.0e+32 &#13;
            .double     1.0e+64 &#13;
            .double     1.0e+128 &#13;
            .double     1.0e+256 &#13;
expCnt      =           (.-potPos) / 8 &#13;
&#13;
potNeg:     .double     1.0e-0 &#13;
            .double     1.0e-1 &#13;
            .double     1.0e-2 &#13;
            .double     1.0e-4 &#13;
            .double     1.0e-8 &#13;
            .double     1.0e-16 &#13;
            .double     1.0e-32 &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_533" aria-label="533"/>            .double     1.0e-64 &#13;
            .double     1.0e-128 &#13;
            .double     1.0e-256 &#13;
&#13;
expTbl:     .dword      0 &#13;
            .dword      1 &#13;
            .dword      2 &#13;
            .dword      4 &#13;
            .dword      8 &#13;
            .dword      16 &#13;
            .dword      32 &#13;
            .dword      64 &#13;
            .dword      128 &#13;
            .dword      256 &#13;
&#13;
// Maximum number of significant digits for &#13;
// a double-precision value: &#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation5">❺</span> maxDigits   =           16 &#13;
&#13;
// Return program title to C++ program: &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> proc    getTitle, public &#13;
            lea     x0, ttlStr &#13;
            ret &#13;
            endp    getTitle </code></pre>&#13;
<p class="TX">As is typical for sample programs in this chapter, Listing 9-13 begins with a read-only data section <span class="CodeAnnotation" aria-label="annotation1">❶</span> containing the program’s title string and various format strings used by <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span> calls in the main program. The single data variable in this program is <span class="SANS_TheSansMonoCd_W5Regular_11">r64str_1</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span>, a 32-byte character string used to hold the converted string. The program is responsible for ensuring that all conversions will fit into 32 bytes.</p>&#13;
<p class="TX">Listing 9-13 places several read-only constants in the <span class="SANS_TheSansMonoCd_W5Regular_11">.code</span> section so the program can directly access these constants by using the PC-relative addressing mode (rather than using multiple instructions to take the address of the object and access it indirectly). The first such constant is <span class="SANS_TheSansMonoCd_W5Regular_11">tenTo15</span> <span class="CodeAnnotation" aria-label="annotation3">❸</span>, which holds the value 1.0e+15. The conversion code uses this constant to multiply a floating-point value in the range 1.0 to slightly less than 10.0 by 1e+15, thereby obtaining a value slightly less than 1e+16 when converting the mantissa to an integer value.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">potPos</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">potNeg</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">expTbl</span> tables <span class="CodeAnnotation" aria-label="annotation4">❹</span> contain the positive and negative powers of 10 (<i>pot</i>) tables used to multiply the floating-point value by various powers of 10 when massaging the value into the range 1.0 to 10.0. The <span class="SANS_TheSansMonoCd_W5Regular_11">expTbl</span> contains the absolute value of the exponent corresponding to the same entry in the <span class="SANS_TheSansMonoCd_W5Regular_11">potPos</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">potNeg</span> tables. The code adds or subtracts this value from the accumulated decimal exponent while converting the mantissa to the range 1.0 to 10.0.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">maxDigits</span> manifest constant <span class="CodeAnnotation" aria-label="annotation5">❺</span> specifies the number of significant digits supported by this conversion code (16 digits for double-precision <span role="doc-pagebreak" epub:type="pagebreak" id="pg_534" aria-label="534"/>floating-point numbers). Finally, this code section contains the ubiquitous <span class="SANS_TheSansMonoCd_W5Regular_11">getTitle</span> function <span class="CodeAnnotation" aria-label="annotation6">❻</span> that returns the address of the program’s title string to the C++ shell code.</p>&#13;
<p class="TX">The following code converts a floating-point value to a string:</p>&#13;
<pre id="pre-748"><code>// Listing9-13.S (cont.) &#13;
//&#13;
// u53toStr &#13;
//&#13;
//  Converts a 53-bit unsigned integer to a string containing &#13;
//  exactly 16 digits (technically, it does 64-bit arithmetic, &#13;
//  but is limited to 53 bits because of the 16-digit output &#13;
//  format) &#13;
//&#13;
// Inputs: &#13;
//  X0-     Pointer to buffer to receive string &#13;
//  X1-     Unsigned 53-bit integer to convert &#13;
//&#13;
// Outputs: &#13;
//  Buffer- Receives the zero-terminated string &#13;
//  X0-     Points at zero-terminating byte in string &#13;
//&#13;
//  Buffer must have at least 17 bytes allocated for it. &#13;
//&#13;
// This code is a bit simplified from the u64toStr function &#13;
// because it always emits exactly 16 digits &#13;
// (never any leading 0s). &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> proc    u53toStr &#13;
&#13;
            stp     x1, x2, [sp, #-16]! &#13;
            stp     x3, x4, [sp, #-16]! &#13;
            str     x5, [sp, #-16]! &#13;
&#13;
            mov     x4, #10     // Mul/div by 10 using X4 &#13;
            mov     x5, xzr     // Holds string of 8 chars &#13;
&#13;
            // Handle LO digit here. Note that the LO &#13;
            // digit will ultimately be moved into &#13;
            // bit positions 56-63 of X5 because numeric &#13;
            // strings are, intrinsically, big-endian (with &#13;
            // the HO digit appearing first in memory). &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> udiv    x2, x1, x4      // X2 = quotient &#13;
            msub    x3, x2, x4, x1  // X3 = remainder &#13;
            orr     x3, x3, #'0' &#13;
            orr     x5, x3, x5, lsl #8 &#13;
&#13;
            // The following is an unrolled loop &#13;
            // (for speed) that processes the &#13;
            // remaining 15 digits. &#13;
            // &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_535" aria-label="535"/>            // Handle digit 1 here: &#13;
&#13;
            udiv    x1, x2, x4      // X1 = quotient &#13;
            msub    x3, x1, x4, x2  // X3 = remainder &#13;
            orr     x3, x3, #'0' &#13;
            orr     x5, x3, x5, lsl #8 &#13;
&#13;
            // Handle digit 2 here: &#13;
&#13;
            udiv    x2, x1, x4      // X2 = quotient &#13;
            msub    x3, x2, x4, x1  // X3 = remainder &#13;
            orr     x3, x3, #'0' &#13;
            orr     x5, x3, x5, lsl #8 &#13;
&#13;
            // Handle digit 3 here: &#13;
&#13;
            udiv    x1, x2, x4      // X1 = quotient &#13;
            msub    x3, x1, x4, x2  // X3 = remainder &#13;
            orr     x3, x3, #'0' &#13;
            orr     x5, x3, x5, lsl #8 &#13;
&#13;
            // Handle digit 4 here: &#13;
&#13;
            udiv    x2, x1, x4      // X2 = quotient &#13;
            msub    x3, x2, x4, x1  // X3 = remainder &#13;
            orr     x3, x3, #'0' &#13;
            orr     x5, x3, x5, lsl #8 &#13;
&#13;
            // Handle digit 5 here: &#13;
&#13;
            udiv    x1, x2, x4      // X1 = quotient &#13;
            msub    x3, x1, x4, x2  // X3 = remainder &#13;
            orr     x3, x3, #'0' &#13;
            orr     x5, x3, x5, lsl #8 &#13;
&#13;
            // Handle digit 6 here: &#13;
&#13;
            udiv    x2, x1, x4      // X2 = quotient &#13;
            msub    x3, x2, x4, x1  // X3 = remainder &#13;
            orr     x3, x3, #'0' &#13;
            orr     x5, x3, x5, lsl #8 &#13;
&#13;
            // Handle digit 7 here: &#13;
&#13;
            udiv    x1, x2, x4      // X1 = quotient &#13;
            msub    x3, x1, x4, x2  // X3 = remainder &#13;
            orr     x3, x3, #'0' &#13;
            orr     x5, x3, x5, lsl #8 &#13;
&#13;
            // Store away LO 8 digits: &#13;
&#13;
            str     x5, [x0, #8] &#13;
            mov     x5, xzr &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_536" aria-label="536"/>            // Handle digit 8 here: &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> udiv    x2, x1, x4      // X2 = quotient &#13;
            msub    x3, x2, x4, x1  // X3 = remainder &#13;
            orr     x3, x3, #'0' &#13;
            orr     x5, x3, x5, lsl #8 &#13;
&#13;
            // Handle digit 9 here: &#13;
&#13;
            udiv    x1, x2, x4      // X1 = quotient &#13;
            msub    x3, x1, x4, x2  // X3 = remainder &#13;
            orr     x3, x3, #'0' &#13;
            orr     x5, x3, x5, lsl #8 &#13;
&#13;
            // Handle digit 10 here: &#13;
&#13;
            udiv    x2, x1, x4      // X2 = quotient &#13;
            msub    x3, x2, x4, x1  // X3 = remainder &#13;
            orr     x3, x3, #'0' &#13;
            orr     x5, x3, x5, lsl #8 &#13;
&#13;
            // Handle digit 11 here: &#13;
&#13;
            udiv    x1, x2, x4      // X1 = quotient &#13;
            msub    x3, x1, x4, x2  // X3 = remainder &#13;
            orr     x3, x3, #'0' &#13;
            orr     x5, x3, x5, lsl #8 &#13;
&#13;
            // Handle digit 12 here: &#13;
&#13;
            udiv    x2, x1, x4      // X2 = quotient &#13;
            msub    x3, x2, x4, x1  // X3 = remainder &#13;
            orr     x3, x3, #'0' &#13;
            orr     x5, x3, x5, lsl #8 &#13;
&#13;
            // Handle digit 13 here: &#13;
&#13;
            udiv    x1, x2, x4      // X1 = quotient &#13;
            msub    x3, x1, x4, x2  // X3 = remainder &#13;
            orr     x3, x3, #'0' &#13;
            orr     x5, x3, x5, lsl #8 &#13;
&#13;
            // Handle digit 14 here: &#13;
&#13;
            udiv    x2, x1, x4      // X2 = quotient &#13;
            msub    x3, x2, x4, x1  // X3 = remainder &#13;
            orr     x3, x3, #'0' &#13;
            orr     x5, x3, x5, lsl #8 &#13;
&#13;
            // Handle digit 15 here: &#13;
&#13;
            udiv    x1, x2, x4      // X1 = quotient &#13;
            msub    x3, x1, x4, x2  // X3 = remainder &#13;
            orr     x3, x3, #'0' &#13;
            orr     x5, x3, x5, lsl #8 &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_537" aria-label="537"/>            // Store away HO 8 digits: &#13;
&#13;
            str     x5, [x0] &#13;
            strb    wzr, [x0, #maxDigits]!  // Zero-terminating byte &#13;
&#13;
            ldr     x5, [sp], #16 &#13;
            ldp     x3, x4, [sp], #16 &#13;
            ldp     x1, x2, [sp], #16 &#13;
            ret &#13;
            endp    u53toStr </code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">u53ToStr</span> function <span class="CodeAnnotation" aria-label="annotation1">❶</span> is responsible for converting a 53-bit unsigned integer to a string of exactly 16 digits. In theory, this code could have used the <span class="SANS_TheSansMonoCd_W5Regular_11">u64toSizeStr</span> function from Listing 9-12 to convert the 53-bit value (zero-extended to 64 bits) into a string. However, the conversion of floating-point mantissa to string always produces a 16-character string (with leading 0s, if necessary), so the decimal integer-to-string conversion can be more efficient than the <span class="SANS_TheSansMonoCd_W5Regular_11">u64toSizeStr</span> function, which could produce variable-length strings. To prioritize saving space, if you’re already using the <span class="SANS_TheSansMonoCd_W5Regular_11">u64toSizeStr</span> function in your code, you could remove <span class="SANS_TheSansMonoCd_W5Regular_11">u53ToStr</span> and substitute a call to <span class="SANS_TheSansMonoCd_W5Regular_11">u64toSizeStr</span> (specifying <span class="SANS_TheSansMonoCd_W5Regular_11">'0'</span> as the fill character).</p>&#13;
<p class="TX">The conversion algorithm <span class="SANS_TheSansMonoCd_W5Regular_11">u53ToStr</span> uses is straightforward and brute-force: it converts the LO eight digits to a sequence of eight characters and emits them <span class="CodeAnnotation" aria-label="annotation2">❷</span>, then converts the HO eight digits to a sequence of eight characters and emits them <span class="CodeAnnotation" aria-label="annotation3">❸</span>. It both cases, it uses the divide-by-10 and remainder of division-by-10 algorithms to convert each digit to a character (see the discussion of <span class="SANS_TheSansMonoCd_W5Regular_11">u64ToStr</span> in Listing 9-6 for more details).</p>&#13;
<p class="TX">This function is used by <span class="SANS_TheSansMonoCd_W5Regular_11">FPDigits</span> to convert the mantissa to a string of decimal digits:</p>&#13;
<pre id="pre-749"><code>// Listing9-13.S (cont.) &#13;
//&#13;
// FPDigits &#13;
//&#13;
//  Used to convert a floating-point value &#13;
//  in D0 to a string of digits &#13;
//&#13;
// Inputs: &#13;
//  D0-     Double-precision value to convert &#13;
//  X0-     Pointer to buffer to receive chars &#13;
//&#13;
// Outputs: &#13;
//  X0-     Still points at buffer &#13;
//  X1-     Contains exponent of the number &#13;
//  X2-     Contains sign (space or '-') &#13;
&#13;
            proc    FPDigits &#13;
            str     lr,       [sp, #-16]! &#13;
            str     d0,       [sp, #-16]! &#13;
            stp     d1, d2,   [sp, #-16]! &#13;
            stp     x22, x23, [sp, #-16]! &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_538" aria-label="538"/>            stp     x24, x25, [sp, #-16]! &#13;
            stp     x26, x27, [sp, #-16]! &#13;
&#13;
            mov     x2, #' '        // Assume sign is +. &#13;
&#13;
#define fp1 d2                      // D2 holds 1.0. &#13;
&#13;
            fmov    fp1, #1.0 &#13;
&#13;
             // Special case for 0.0: &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> fcmp    d0, #0.0 &#13;
            bne     d0not0 &#13;
&#13;
            // Check for -0.0: &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> fmov    x1, d0 &#13;
            ands    x1, x1, #0x8000000000000000 &#13;
            beq     posZero &#13;
            mov     x2, #'-' &#13;
&#13;
posZero: &#13;
            mov     x1, #0x3030 &#13;
            movk    x1, #0x3030, lsl #16 &#13;
            movk    x1, #0x3030, lsl #32 &#13;
            movk    x1, #0x3030, lsl #48 &#13;
            str     x1, [x0] &#13;
            str     x1, [x0, #8] &#13;
            mov     x1, #0          // Exponent = 0 &#13;
&#13;
            // For debugging purposes, zero-terminate this &#13;
            // string (the actual code just grabs 16 bytes, &#13;
            // so this isn't strictly necessary): &#13;
&#13;
            strb    w0, [x0, #16] &#13;
            b.al    fpdDone &#13;
&#13;
// If the number is nonzero, deal with it here. Note &#13;
// that the flags were set by comparing D0 to 0.0 earlier. &#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> d0not0:     bge     fpIsPositive    // See if positive or negative. &#13;
&#13;
            // If negative, negate and change the sign &#13;
            // character to '-'. &#13;
&#13;
            fabs    d0, d0 &#13;
            mov     x2, #'-' &#13;
&#13;
// Get the number from 1.0 to &lt;10.0 so you can figure out &#13;
// what the exponent is. Begin by checking to see if you have &#13;
// a positive or negative exponent. &#13;
&#13;
fpIsPositive: &#13;
            mov     x1, xzr         // Initialize exponent. &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_539" aria-label="539"/>          <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> fcmp    d0, fp1 &#13;
            bge     posExp &#13;
&#13;
            // The value is in the range 0.0 to 1.0, &#13;
            // exclusive, at this point. That means this &#13;
            // number has a negative exponent. Multiply &#13;
            // the number by an appropriate power of 10 &#13;
            // until you get it in the range 1 through 10. &#13;
&#13;
            lea     x27, potNeg &#13;
            lea     x26, potPos &#13;
            lea     x25, expTbl &#13;
            mov     x24, #expCnt &#13;
&#13;
// Search through the potNeg table until you find a power &#13;
// of 10 that is less than the value in D0: &#13;
&#13;
cmpNegExp: &#13;
          <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> subs    x24, x24, #1 &#13;
            blt     test1       // Branch if X24 &lt; 1. &#13;
&#13;
            ldr     d1, [x27, x24, lsl #3]  // D1 = potNeg[X24 * 8] &#13;
            fcmp    d1, d0      // Repeat while &#13;
            ble     cmpNegExp   // table &lt;= value. &#13;
&#13;
            // Eliminate the current exponent indexed by &#13;
            // X24 by multiplying by the corresponding &#13;
            // entry in potPos: &#13;
&#13;
            ldr     x22, [x25, x24, lsl #3] // X22 = expTbl[X24 * 8] &#13;
            sub     x1, x1, x22 &#13;
            ldr     d1, [x26, x24, lsl #3]  // D1 = potPos[X24 * 8] &#13;
            fmul    d0, d0, d1 &#13;
            b.al    cmpNegExp &#13;
&#13;
// If you get to this point, you've indexed through &#13;
// all the elements in the potNeg and it's time to stop. &#13;
//&#13;
// If the remainder is *exactly* 1.0, you can branch &#13;
// on to InRange1_10; otherwise, you still have to multiply &#13;
// by 10.0 because you've overshot the mark a bit. &#13;
&#13;
test1:      fcmp    d0, fp1 &#13;
            beq     inRange1_10 &#13;
&#13;
            fmov    d1, #10.0 &#13;
            fmul    d0, d0, d1 &#13;
            sub     x1, x1, #1      // Decrement exponent. &#13;
            b.al    inRange1_10 &#13;
&#13;
// At this point, you have a number that is 1 or greater. &#13;
// Once again, your task is to get the value from 1.0 to &lt;10.0. &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_540" aria-label="540"/>posExp: &#13;
            lea     x26, potPos &#13;
            lea     x25, expTbl &#13;
            mov     x24, #expCnt &#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation6">❻</span> cmpPosExp:  subs    x24, x24, #1 &#13;
            blt     inRange1_10     // If X24 &lt; 1 &#13;
&#13;
            ldr     d1, [x26, x24, lsl #3]  // D1 = potPos[X24 * 8] &#13;
            fcmp    d1, d0 &#13;
            bgt     cmpPosExp &#13;
&#13;
            ldr     x22, [x25, x24, lsl #3] // X22 = expTbl[X24 * 8] &#13;
            add     x1, x1, x22 &#13;
            fdiv    d0, d0, d1 &#13;
            b.al    cmpPosExp &#13;
&#13;
// Okay, at this point the number is in the range 1 &lt;= x &lt; 10. &#13;
// Let's multiply it by 1e+15 to put the most significant digit &#13;
// into the 16th print position, then convert the result to &#13;
// a string and store away in memory. &#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation7">❼</span> inRange1_10: &#13;
            ldr     d1, tenTo15 &#13;
            fmul    d0, d0, d1 &#13;
            fcvtau  x22, d0     // Convert to unsigned integer. &#13;
&#13;
            // Convert the integer mantissa to a &#13;
            // string of digits: &#13;
&#13;
            stp     x0, x1, [sp, #-16]! &#13;
            mov     x1, x22 &#13;
            bl      u53toStr &#13;
            ldp     x0, x1, [sp], #16 &#13;
&#13;
fpdDone: &#13;
            ldp     x26, x27,   [sp], #16 &#13;
            ldp     x24, x25,   [sp], #16 &#13;
            ldp     x22, x23,   [sp], #16 &#13;
            ldp     d1, d2,     [sp], #16 &#13;
            ldr     d0,         [sp], #16 &#13;
            ldr     lr,         [sp], #16 &#13;
            ret &#13;
            endp    FPDigits </code></pre>&#13;
<p class="TX"><span class="SANS_TheSansMonoCd_W5Regular_11">FPDigits</span> converts an arbitrary double-precision mantissa to a string of decimal digits. It assumes that the floating-point value to convert is held in the D0 register and that X0 contains a pointer to the buffer that will hold the string conversion. This function also converts the binary (power-of-2) exponent to a decimal integer, returns the exponent value in the X1 register, and returns the value’s sign (a space character, indicating a nonnegative value, or <span class="SANS_TheSansMonoCd_W5Regular_11">-</span>) in the X2 register.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_541" aria-label="541"/><span class="SANS_TheSansMonoCd_W5Regular_11">FPDigits</span> begins by first checking for the special case of 0.0 <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If D0 contains <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>, this function initializes the string buffer to <span class="SANS_TheSansMonoCd_W5Regular_11">0000000000000000</span> (sixteen <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> characters) and returns with X0 containing <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> and X2 containing a space character. The code checks for the special case of <span class="SANS_TheSansMonoCd_W5Regular_11">-0.0</span> and returns X2 containing a minus sign if the result is <span class="SANS_TheSansMonoCd_W5Regular_11">-0.0</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Next, <span class="SANS_TheSansMonoCd_W5Regular_11">FPDigits</span> checks the sign of the floating-point value and sets X2 to a <span class="SANS_TheSansMonoCd_W5Regular_11">'-'</span>, if appropriate <span class="CodeAnnotation" aria-label="annotation3">❸</span>. The code also initializes the decimal exponent accumulator (held in X0) to 0.</p>&#13;
<p class="TX">After setting the sign, the <span class="SANS_TheSansMonoCd_W5Regular_11">FPDigits</span> function checks the floating-point value’s exponent to see if it is positive or negative <span class="CodeAnnotation" aria-label="annotation4">❹</span>. The code handles values with positive or negative exponents independently. If the exponent is negative, the <span class="SANS_TheSansMonoCd_W5Regular_11">cmpNegExp</span> loop searches through the <span class="SANS_TheSansMonoCd_W5Regular_11">potNeg</span> table looking for the value that is greater than the value in D0 <span class="CodeAnnotation" aria-label="annotation5">❺</span>. When the loop finds such a value, it multiplies D0 by that entry in <span class="SANS_TheSansMonoCd_W5Regular_11">potNeg</span> and then subtracts the corresponding entry in <span class="SANS_TheSansMonoCd_W5Regular_11">expTbl</span> from the decimal exponent value held in X1. The <span class="SANS_TheSansMonoCd_W5Regular_11">cmpNegExp</span> loop repeats this process until the value in D0 is greater than 1.0. Whenever the result isn’t greater than 1.0, the code multiplies the value in D0 by 10.0, because the code needs to adjust for the multiplication by 0.1 that has taken place. If, on the other hand, the exponent was positive <span class="CodeAnnotation" aria-label="annotation6">❻</span>, the <span class="SANS_TheSansMonoCd_W5Regular_11">cmpPosExp</span> loop does the same task but divides by entries in the <span class="SANS_TheSansMonoCd_W5Regular_11">potPos</span> table and adds the corresponding entry in <span class="SANS_TheSansMonoCd_W5Regular_11">expTbl</span> to the decimal exponent value held in X1.</p>&#13;
<p class="TX">Once the <span class="SANS_TheSansMonoCd_W5Regular_11">cmpPosExp</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">cmpNegExp</span> loop gets the value into the range 1.0 to just less than 10.0, it multiplies the value by 10<sup>15</sup> and converts it to an integer (in X22) <span class="CodeAnnotation" aria-label="annotation7">❼</span>. Then <span class="SANS_TheSansMonoCd_W5Regular_11">FPDigits</span> calls the <span class="SANS_TheSansMonoCd_W5Regular_11">u53toStr</span> function to convert this integer to a string of exactly 16 digits. The function returns the sign character (space for nonnegative values, <span class="SANS_TheSansMonoCd_W5Regular_11">'-'</span> for negative values) in X2 and the decimal exponent in X1.</p>&#13;
<p class="TX">Note that <span class="SANS_TheSansMonoCd_W5Regular_11">FPDigits</span> converts only the mantissa to a string of digits. This is the base code used by the <span class="SANS_TheSansMonoCd_W5Regular_11">r64ToStr</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">e64ToStr</span> functions that convert floating-point values into recognizable strings. Before presenting those functions, there is one utility function to explain: <span class="SANS_TheSansMonoCd_W5Regular_11">chkNaNINF</span>.</p>&#13;
<p class="TX">Certain floating-point operations produce invalid results. The IEEE 754 floating-point standard defines three special values to represent these invalid results: <span class="SANS_TheSansMonoCd_W5Regular_11">NaN</span> (not a number), <span class="SANS_TheSansMonoCd_W5Regular_11">+INF</span> (infinity), and <span class="SANS_TheSansMonoCd_W5Regular_11">-INF</span> (negative infinity). Because the ARM floating-point hardware can produce these results, it is important that the conversions of floating-point to string handle these three special values. <span class="SANS_TheSansMonoCd_W5Regular_11">NaN</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">+INF</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">-INF</span> all have an exponent value containing 0x7FF (and no other valid values use this exponent). If the exponent is 0x7FF and the mantissa bits are all 0s, the value is <span class="SANS_TheSansMonoCd_W5Regular_11">+INF</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">-INF</span> (determined by the sign bit). If the mantissa is nonzero, the value is <span class="SANS_TheSansMonoCd_W5Regular_11">NaN</span> (and you can ignore the sign bit). The <span class="SANS_TheSansMonoCd_W5Regular_11">chkNaNINF</span> function checks for these values and outputs the strings <span class="SANS_TheSansMonoCd_W5Regular_11">NaN</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">INF</span>, or <span class="SANS_TheSansMonoCd_W5Regular_11">-INF</span> if the number is invalid:</p>&#13;
<pre id="pre-750"><code>// Listing9-13.S (cont.) &#13;
//&#13;
// chkNaNINF &#13;
//&#13;
// Utility function used by r64ToStr and e64ToStr to check &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_542" aria-label="542"/>// for NaN and INF &#13;
//&#13;
// Inputs: &#13;
//  D0-     Number to check against NaN and INF &#13;
//  X19-    Field width for output &#13;
//  X21-    Fill character &#13;
//  X22-    (outBuf) Pointer to output buffer &#13;
//  X25-    Return address to use if number is invalid &#13;
//&#13;
// Outputs: &#13;
//  Buffer- Will be set to the string NaN, INF, &#13;
//          or -INF if the number is not valid &#13;
//&#13;
//  Note: Modifies value in X0 &#13;
&#13;
            proc    chkNaNINF &#13;
&#13;
            // Handle NaN and INF special cases: &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> fmov    x0, d0 &#13;
            lsr     x0, x0, #52 &#13;
            and     x0, x0, #0x7ff &#13;
            cmp     x0, #0x7ff &#13;
            blo     notINFNaN &#13;
&#13;
            // At this point, it's NaN or INF. INF has a &#13;
            // mantissa containing 0, NaN has a nonzero &#13;
            // mantissa: &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> fmov    x0, d0 &#13;
            ands    x0, x0, #0x000fffffffffffff &#13;
            beq     isINF &#13;
&#13;
            // Is NaN here: &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> ldr     w0, ='N' + ('a' &lt;&lt; 8) + ('N' &lt;&lt; 16) &#13;
            str     w0, [x22] &#13;
            mov     x0, #3 &#13;
            b.al    fillSpecial &#13;
&#13;
            // INF can be positive or negative. Must output a &#13;
            // '-' character if it is -INF: &#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> isINF:      fmov    x0, d0 &#13;
            ands    x0, x0, #0x8000000000000000 // See if -INF. &#13;
            bne     minusINF &#13;
&#13;
            ldr     w0, ='I' + ('N' &lt;&lt; 8) + ('F' &lt;&lt; 16) &#13;
            str     w0, [x22] &#13;
            mov     x0, #3 &#13;
            b.al    fillSpecial &#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation5">❺</span> minusINF:   ldr     w0, ='-' + ('I' &lt;&lt; 8) + ('N' &lt;&lt; 16) + ('F' &lt;&lt; 24) &#13;
            str     w0, [x22] &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_543" aria-label="543"/>            strb    wzr, [x22, #4] &#13;
            mov     x0, #4 &#13;
&#13;
// For NaN and INF, fill the remainder of the string, as appropriate: &#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation6">❻</span> fillSpecial: &#13;
            b.al    whlLTwidth &#13;
&#13;
fsLoop:     strb    w21, [x22, x0] &#13;
            add     x0, x0, #1 &#13;
 whlLTwidth: &#13;
            cmp     x0, x19 &#13;
            blo     fsLoop &#13;
          <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> mov     lr, x25         // Return to alternate address. &#13;
&#13;
notINFNaN:  ret &#13;
            endp    chkNaNINF </code></pre>&#13;
<p class="TX">The code moves the floating-point value in D0 into X0 and then checks the exponent bits to see if they contain 0x7FF <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If the exponent does not contain this value, the procedure returns to the caller (using the return address in LR).</p>&#13;
<p class="TX">If the exponent bits are 0x7FF, the code checks the mantissa to see if it is 0 or nonzero <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If it’s nonzero, the code emits the character string <span class="SANS_TheSansMonoCd_W5Regular_11">NaN</span> to the buffer pointed at by X22 <span class="CodeAnnotation" aria-label="annotation3">❸</span>. If the mantissa is nonzero, the code checks whether the sign bit is set <span class="CodeAnnotation" aria-label="annotation4">❹</span>. If not, this code emits <span class="SANS_TheSansMonoCd_W5Regular_11">INF</span> to the output buffer. If the sign bit is set, the code emits <span class="SANS_TheSansMonoCd_W5Regular_11">-INF</span> to the output buffer <span class="CodeAnnotation" aria-label="annotation5">❺</span>.</p>&#13;
<p class="TX">In all three cases (<span class="SANS_TheSansMonoCd_W5Regular_11">NaN</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">INF</span>, or <span class="SANS_TheSansMonoCd_W5Regular_11">-INF</span>), the code transfers to <span class="SANS_TheSansMonoCd_W5Regular_11">fillSpecial</span> <span class="CodeAnnotation" aria-label="annotation6">❻</span>, where it adds sufficient padding characters (the padding character is in W21, and the field width is in X19). Rather than return to the caller, this code transfers control to the address held in X25 <span class="CodeAnnotation" aria-label="annotation7">❼</span>. The caller (<span class="SANS_TheSansMonoCd_W5Regular_11">r64ToStr</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">e64ToStr</span>) loads the invalid value return address into X25 prior to calling <span class="SANS_TheSansMonoCd_W5Regular_11">chkNaNINF</span>. I could have set a flag, such as the carry flag, and tested it on return. However, I wanted to demonstrate another way to achieve this, and this approach is slightly more elegant (though arguably less readable).</p>&#13;
<p class="TX">With <span class="SANS_TheSansMonoCd_W5Regular_11">chkNaNINF</span> out of the way, it’s time to take a look at the <span class="SANS_TheSansMonoCd_W5Regular_11">r64ToStr</span> function that the user calls to convert floating-point values into strings:</p>&#13;
<pre id="pre-751"><code>// Listing9-13.S (cont.) &#13;
//&#13;
// r64ToStr &#13;
//&#13;
// Converts a REAL64 floating-point number to the &#13;
// corresponding string of digits. Note that this &#13;
// function always emits the string using decimal &#13;
// notation. For scientific notation, use the e10ToBuf &#13;
// routine. &#13;
//&#13;
// On entry: &#13;
//&#13;
//  D0-         (r64) Real64 value to convert &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_544" aria-label="544"/>//&#13;
//  X0-         (outBuf) r64ToStr stores the resulting &#13;
//              characters in this string. &#13;
//&#13;
//  X1-         (fWidth) Field width for the number (note &#13;
//              that this is an *exact* field width, not a &#13;
//              minimum field width) &#13;
//&#13;
//  X2-         (decDigits) # of digits to display after the &#13;
//              decimal pt &#13;
//&#13;
//  X3-         (fill) Padding character if the number of &#13;
//              digits is smaller than the specified field &#13;
//              width &#13;
//&#13;
//  X4-         (maxLength) Maximum string length &#13;
//&#13;
// On exit: &#13;
//&#13;
// Buffer contains the newly formatted string. If the &#13;
// formatted value does not fit in the width specified, &#13;
// r64ToStr will store "#" characters into this string. &#13;
//&#13;
// Carry-    Clear if success, set if an exception occurs. &#13;
//           If width is larger than the maximum length of &#13;
//           the string specified by buffer, this routine &#13;
//           will return with the carry set. &#13;
//&#13;
//***********************************************************&#13;
&#13;
            proc    r64ToStr &#13;
&#13;
            // Local variables: &#13;
&#13;
            locals  rts &#13;
            qword   rts.x0x1 &#13;
            qword   rts.x2x3 &#13;
            qword   rts.x4x5 &#13;
            qword   rts.x19x20 &#13;
            qword   rts.x21x22 &#13;
            qword   rts.x23x24 &#13;
&#13;
            dword   rts.x25 &#13;
            byte    rts.digits, 80 &#13;
            byte    rts.stk, 64 &#13;
            endl    rts &#13;
&#13;
            enter   rts.size &#13;
&#13;
            // Use meaningful names for the nonvolatile &#13;
            // registers that hold local/parameter values: &#13;
&#13;
            #define fpVal d0 &#13;
            #define fWidth x19      // chkNaNINF expects this here. &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_545" aria-label="545"/>            #define decDigits x20 &#13;
            #define fill w21        // chkNaNINF expects this here. &#13;
            #define outBuf x22      // chkNaNINF expects this here. &#13;
            #define maxLength x23 &#13;
            #define exponent x24 &#13;
            #define sign w25 &#13;
            #define failAdrs x25    // chkNaNINF expects this here. &#13;
&#13;
            // Preserve registers: &#13;
&#13;
            stp     x0,   x1, [fp, #rts.x0x1] &#13;
            stp     x2,   x3, [fp, #rts.x2x3] &#13;
            stp     x4,   x5, [fp, #rts.x4x5] &#13;
            stp     x19, x20, [fp, #rts.x19x20] &#13;
            stp     x21, x22, [fp, #rts.x21x22] &#13;
            stp     x23, x24, [fp, #rts.x23x24] &#13;
            str     x25,      [fp, #rts.x25] &#13;
&#13;
            // Move parameter values to nonvolatile &#13;
            // storage: &#13;
&#13;
            mov     outBuf, x0 &#13;
            mov     fWidth, x1 &#13;
            mov     decDigits, x2 &#13;
            mov     fill, w3 &#13;
            mov     maxLength, x4 &#13;
&#13;
            // First, make sure the number will fit into &#13;
            // the specified string. &#13;
&#13;
            cmp     fWidth, maxLength &#13;
            bhs     strOverflow &#13;
&#13;
            // If the width is 0, return an error: &#13;
&#13;
            cmp     fWidth, #0 &#13;
            beq     valOutOfRange &#13;
&#13;
            // Handle NaN and INF special cases. &#13;
            // Note: if the value is invalid, control &#13;
            // transfers to clcAndRet rather than simply &#13;
            // returning. &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> lea     failAdrs, clcAndRet &#13;
            bl      chkNaNINF &#13;
&#13;
            // Okay, do the conversion. Begin by &#13;
            // processing the mantissa digits: &#13;
&#13;
            add     x0, fp, #rts.digits // lea x0, rts.digits &#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> bl      FPDigits            // Convert r64 to string. &#13;
            mov     exponent, x1        // Save away exponent result. &#13;
            mov     sign, w2            // Save mantissa sign char. &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_546" aria-label="546"/>// Round the string of digits to the number of significant &#13;
// digits you want to display for this number. Note that &#13;
// a maximum of 16 digits are produced for a 53-bit value. &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> cmp     exponent, #maxDigits &#13;
            ble     dontForceWidthZero &#13;
            mov     x0, xzr         // If the exponent is negative or &#13;
                                    // too large, set width to 0. &#13;
dontForceWidthZero: &#13;
            add     x2, x0, decDigits // Compute rounding position. &#13;
            cmp     x2, #maxDigits &#13;
            bhs     dontRound       // Don't bother if a big #. &#13;
&#13;
            // To round the value to the number of &#13;
            // significant digits, go to the digit just &#13;
            // beyond the last one you are considering (X2 &#13;
            // currently contains the number of decimal &#13;
            // positions) and add 5 to that digit. &#13;
            // Propagate any overflow into the remaining &#13;
            // digit positions. &#13;
&#13;
            add     x2, x2, #1          // Index + 1 of last sig digit &#13;
            ldrb    w0, [x1, x2]        // Get that digit. &#13;
&#13;
            add     w0, w0, #5          // Round (for example, +0.5) &#13;
            cmp     w0, #'9' &#13;
            bls     dontRound &#13;
&#13;
            mov     x0, #('0' + 10)     // Force to 0. &#13;
whileDigitGT9: &#13;
            sub     w0, w0, #10         // Sub out overflow, &#13;
            strb    w0, [x1, x2]        // carry, into prev &#13;
            subs    x2, x2, #1          // digit (until first &#13;
            bmi     hitFirstDigit       // digit in the #). &#13;
&#13;
            ldrb    w0, [x1, x2]        // Increment previous &#13;
            add     w0, w0, #1          // digit. &#13;
            strb    w0, [x1, x2] &#13;
&#13;
            cmp     w0, #'9'            // Overflow if &gt; '9' &#13;
            bhi     whileDigitGT9 &#13;
            b.al    dontRound &#13;
&#13;
hitFirstDigit: &#13;
&#13;
            // If you get to this point, you've hit the &#13;
            // first digit in the number, so you have to &#13;
            // shift all the characters down one position &#13;
            // in the string of bytes and put a "1" in the &#13;
            // first character position. &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> mov     x2, #maxDigits      // Max digits in value &#13;
repeatUntilX2eq0: &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_547" aria-label="547"/>            ldrb    w0, [x1, x2] &#13;
            add     x2, x2, #1 &#13;
            strb    w0, [x1, x2] &#13;
            subs    x2, x2, #2 &#13;
            bne     repeatUntilX2eq0 &#13;
&#13;
            mov     w0, #'1' &#13;
            strb    w0, [x1, x2] &#13;
&#13;
            add     exponent, exponent, #1 // Increment exponent because &#13;
                                           // you added a digit. &#13;
&#13;
dontRound: &#13;
&#13;
            // Handle positive and negative exponents separately. &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> mov     x5, xzr             // Index into output buf. &#13;
            cmp     exponent, #0 &#13;
            bge     positiveExponent &#13;
&#13;
            // Negative exponents: &#13;
            // Handle values from 0 to 1.0 here (negative &#13;
            // exponents imply negative powers of 10). &#13;
            // &#13;
            // Compute the number's width. Since this &#13;
            // value is from 0 to 1, the width &#13;
            // calculation is easy: it's just the number of &#13;
            // decimal positions they've specified plus &#13;
            // 3 (since you need to allow room for a &#13;
            // leading "-0."). X2 = number of digits to emit &#13;
            // after "." &#13;
&#13;
            mov     x4, #4 &#13;
            add     x2, decDigits, #3 &#13;
            cmp     x2, x4 &#13;
            csel    x2, x2, x4, hs  // If X2 &lt; X4, X2 = X4 &#13;
&#13;
            cmp     x2, fWidth &#13;
            bhi     widthTooBig &#13;
&#13;
            // This number will fit in the specified field &#13;
            // width, so output any necessary leading pad &#13;
            // characters. X3 = number of padding characters &#13;
            // to output. &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> sub     x3, fWidth, x2 &#13;
            b.al    testWhileX3ltWidth &#13;
&#13;
whileX3ltWidth: &#13;
            strb    fill, [outBuf, x5] &#13;
            add     x5, x5, #1          // Index &#13;
            add     x2, x2, #1          // Digits processed &#13;
testWhileX3ltWidth: &#13;
            cmp     x2, fWidth &#13;
            blo     whileX3ltWidth &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_548" aria-label="548"/>            // Output " 0." or "-0.", depending on &#13;
            // the sign of the number: &#13;
&#13;
            strb    sign, [outBuf, x5] &#13;
            add     x5, x5, #1 &#13;
            mov     w0, #'0' &#13;
            strb    w0, [outBuf, x5] &#13;
            add     x5, x5, #1 &#13;
            mov     w0, #'.' &#13;
            strb    w0, [outBuf, x5] &#13;
            add     x5, x5, #1 &#13;
            add     x3, x3, #3 &#13;
&#13;
            // Now output the digits after the decimal point: &#13;
&#13;
            mov     x2, xzr             // Count the digits here. &#13;
            add     x1, fp, #rts.digits // lea x1, rts.digits &#13;
&#13;
// If the exponent is currently negative, or if &#13;
// you've output more than 16 significant digits, &#13;
// just output a 0 character. &#13;
&#13;
repeatUntilX3geWidth: &#13;
            mov     x0, #'0' &#13;
            adds    exponent, exponent, #1 &#13;
            bmi     noMoreOutput &#13;
&#13;
            cmp     x2, #maxDigits &#13;
            bge     noMoreOutput &#13;
&#13;
            ldrb    w0, [x1] &#13;
            add     x1, x1, #1 &#13;
&#13;
noMoreOutput: &#13;
            strb    w0, [outBuf, x5] &#13;
            add     x5, x5, #1          // Index &#13;
            add     x2, x2, #1          // Digits processed &#13;
            add     x3, x3, #1          // Digit count &#13;
            cmp     x3, fWidth &#13;
            blo     repeatUntilX3geWidth &#13;
            b.al    r64BufDone &#13;
&#13;
// If the number's actual width was bigger than the width &#13;
// specified by the caller, emit a sequence of '#' characters &#13;
// to denote the error. &#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation7">❼</span> widthTooBig: &#13;
&#13;
            // The number won't fit in the specified field &#13;
            // width, so fill the string with the "#" &#13;
            // character to indicate an error. &#13;
&#13;
            mov     x2, fWidth &#13;
            mov     w0, #'#' &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_549" aria-label="549"/>fillPound:  strb    w0, [outBuf, x5] &#13;
            add     x5, x5, #1          // Index &#13;
            subs    x2, x2, #1 &#13;
            bne     fillPound &#13;
            b.al    r64BufDone &#13;
&#13;
// Handle numbers with a positive exponent here. &#13;
//&#13;
// Compute # of print positions consumed by output string. &#13;
// This is given by: &#13;
//&#13;
//                   Exponent     // # of digits to left of "." &#13;
//           +       2            // Sign + 1's digit &#13;
//           +       decDigits    // Add in digits right of "." &#13;
//           +       1            // If there is a decimal point &#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation8">❽</span> positiveExponent: &#13;
&#13;
            mov     x3, exponent    // Digits to left of "." &#13;
            add     x3, x3, #2      // sign posn &#13;
            cmp     decDigits, #0   // See if any fractional &#13;
            beq     decPtsIs0       // part. &#13;
&#13;
            add     x3, x3, decDigits // Digits to right of "." &#13;
            add     x3, x3, #1        // Make room for the "." &#13;
&#13;
decPtsIs0: &#13;
&#13;
            // Make sure the result will fit in the &#13;
            // specified field width. &#13;
&#13;
            cmp     x3, fWidth &#13;
            bhi     widthTooBig &#13;
            beq     noFillChars &#13;
&#13;
            // If the actual number of print positions &#13;
            // is less than the specified field width, &#13;
            // output leading pad characters here. &#13;
&#13;
            subs    x2, fWidth, x3 &#13;
            beq     noFillChars &#13;
&#13;
fillChars:  strb    fill, [outBuf, x5] &#13;
            add     x5, x5, #1 &#13;
            subs    x2, x2, #1 &#13;
            bne     fillChars &#13;
&#13;
noFillChars: &#13;
&#13;
            // Output the sign character: &#13;
&#13;
            strb    sign, [outBuf, x5] &#13;
            add     x5, x5, #1 &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_550" aria-label="550"/>            // Okay, output the digits for the number here: &#13;
&#13;
            mov     x2, xzr             // Counts # of output chars &#13;
            add     x1, fp, #rts.digits // lea x1, rts.digits &#13;
&#13;
            // Calculate the number of digits to output &#13;
            // before and after the decimal point: &#13;
&#13;
            add     x3, decDigits, exponent &#13;
            add     x3, x3, #1          // Always one digit before "." &#13;
&#13;
// If we've output fewer than 16 digits, go ahead &#13;
// and output the next digit. Beyond 16 digits, &#13;
// output 0s. &#13;
&#13;
repeatUntilX3eq0: &#13;
&#13;
            mov     w0, #'0' &#13;
            cmp     x2, #maxDigits &#13;
            bhs     putChar &#13;
&#13;
            ldrb    w0, [x1] &#13;
            add     x1, x1, #1 &#13;
&#13;
putChar:    strb    w0, [outBuf, x5] &#13;
            add     x5, x5, #1 &#13;
&#13;
            // If the exponent decrements down to 0, &#13;
            // output a decimal point: &#13;
&#13;
            cmp     exponent, #0 &#13;
            bne     noDecimalPt &#13;
&#13;
            cmp     decDigits, #0 &#13;
            beq     noDecimalPt &#13;
&#13;
            mov     w0, #'.' &#13;
            strb    w0, [outBuf, x5] &#13;
            add     x5, x5, #1 &#13;
&#13;
noDecimalPt: &#13;
            sub     exponent, exponent, #1  // Count down to "." output. &#13;
            add     x2, x2, #1    // # of digits thus far &#13;
            subs    x3, x3, #1    // Total # of digits to output &#13;
            bne     repeatUntilX3eq0 &#13;
&#13;
// Zero-terminate string and leave: &#13;
&#13;
r64BufDone: strb    wzr, [outBuf, x5] &#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation9">❾</span> clcAndRet:  msr     nzcv, xzr    // clc = no error &#13;
            b.al    popRet &#13;
&#13;
strOverflow: &#13;
            mov     x0, #-3 // String overflow &#13;
            b.al    ErrorExit &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_551" aria-label="551"/>valOutOfRange: &#13;
            mov     x0, #-1 // Range error &#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation10">❿</span> ErrorExit:  mrs     x1, nzcv &#13;
            orr     x1, x1, #(1 &lt;&lt; 29) &#13;
            msr     nzcv, x1        // stc = error &#13;
            strb    wzr, [outBuf]   // Just to be safe &#13;
&#13;
            // Change X0 on return: &#13;
&#13;
            str     x0, [fp, #rts.x0x1] &#13;
&#13;
popRet: &#13;
            ldp     x0, x1,   [fp, #rts.x0x1] &#13;
            ldp     x2, x3,   [fp, #rts.x2x3] &#13;
            ldp     x4, x5,   [fp, #rts.x4x5] &#13;
            ldp     x19, x20, [fp, #rts.x19x20] &#13;
            ldp     x21, x22, [fp, #rts.x21x22] &#13;
            ldp     x23, x24, [fp, #rts.x23x24] &#13;
            ldr     x25,      [fp, #rts.x25] &#13;
            leave &#13;
            endp    r64ToStr </code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">r64ToStr</span> function converts the floating-point value in D0 to a string in standard decimal form, supporting output field widths, number of digits after the decimal point, and fill character for leading positions that would normally be blank.</p>&#13;
<p class="TX">After appropriate initialization, <span class="SANS_TheSansMonoCd_W5Regular_11">r64ToStr</span> first checks for the values <span class="SANS_TheSansMonoCd_W5Regular_11">NaN</span> (not a number), <span class="SANS_TheSansMonoCd_W5Regular_11">INF</span> (infinity), and <span class="SANS_TheSansMonoCd_W5Regular_11">-INF</span> (minus infinity) <span class="CodeAnnotation" aria-label="annotation1">❶</span>; these values require special nonnumeric output strings, which must still be padded to <span class="SANS_TheSansMonoCd_W5Regular_11">fWidth</span> characters. The <span class="SANS_TheSansMonoCd_W5Regular_11">r64ToStr</span> calls <span class="SANS_TheSansMonoCd_W5Regular_11">FPDigits</span> to convert the mantissa to a string of decimal digit characters (and obtain the power-of-10 exponent in integer form) <span class="CodeAnnotation" aria-label="annotation2">❷</span>. The next step is to round the number based on the number of digits to appear after the decimal point <span class="CodeAnnotation" aria-label="annotation3">❸</span>. This code computes the index into the string produced by <span class="SANS_TheSansMonoCd_W5Regular_11">FPDigits</span> one character beyond the number of digits specified by the <span class="SANS_TheSansMonoCd_W5Regular_11">decDigits</span> parameter. It fetches this character (which will be <span class="SANS_TheSansMonoCd_W5Regular_11">'0'</span> through <span class="SANS_TheSansMonoCd_W5Regular_11">'9'</span>) and adds 5 to its ASCII code. If the result is greater than the ASCII code of <span class="SANS_TheSansMonoCd_W5Regular_11">'9'</span>, the code has to bump the previous digit in the string by 1. Of course, if that character contains <span class="SANS_TheSansMonoCd_W5Regular_11">'9'</span>, overflow will occur and the carry has to ripple through to previous digit(s). If the carry ripples all the way to the first character of the string, the code must shift all the characters one position to the right and insert a <span class="SANS_TheSansMonoCd_W5Regular_11">'1'</span> at the beginning of the string <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
<p class="TX">Next, the code emits the characters associated with the final decimal string. The algorithm splits into two sections <span class="CodeAnnotation" aria-label="annotation5">❺</span>, with one section handling positive (and 0) exponents and the other handling negative exponents. For negative exponents, the code will emit any fill characters, the sign of the number (still held in X2), and the <span class="SANS_TheSansMonoCd_W5Regular_11">decDigits</span> digits from the mantissa string conversion <span class="CodeAnnotation" aria-label="annotation6">❻</span>. If the field width and <span class="SANS_TheSansMonoCd_W5Regular_11">decDigits</span> are sufficiently large, the code will simply output the <span class="SANS_TheSansMonoCd_W5Regular_11">'0'</span> character for all characters beyond the 16th significant digit. If the number of output digits would exceed the field width <span role="doc-pagebreak" epub:type="pagebreak" id="pg_552" aria-label="552"/>the caller passes, the <span class="SANS_TheSansMonoCd_W5Regular_11">widthTooBig</span> code <span class="CodeAnnotation" aria-label="annotation7">❼</span> will emit <span class="SANS_TheSansMonoCd_W5Regular_11">#</span> characters to indicate a formatting error (the standard HLL approach to format errors in floating-point conversions).</p>&#13;
<p class="TX">The code handles floating-point conversions of values greater than or equal to 1.0 (positive exponents) <span class="CodeAnnotation" aria-label="annotation8">❽</span>. This code emits necessary padding characters and the value’s sign, then calculates the position of the decimal point in the output string and rounds the last digit throughout the string, as previously described. It then outputs the characters returned by <span class="SANS_TheSansMonoCd_W5Regular_11">FPDigits</span> up to that position. Finally, it outputs the decimal point, followed by the remaining fractional digits. If it turns out that the code cannot fit the number into the field width (and decimal digits) specified, it transfers control to <span class="SANS_TheSansMonoCd_W5Regular_11">widthTooBig</span> to produce the error string.</p>&#13;
<p class="TX">To notify the caller of possible errors, this code clears the carry flag upon return <span class="CodeAnnotation" aria-label="annotation9">❾</span> if the conversion was successful, or sets the carry flag on return if there was an error <span class="CodeAnnotation" aria-label="annotation10">❿</span>. This allows the caller to easily test for success/ failure with a single <span class="SANS_TheSansMonoCd_W5Regular_11">bcs</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">bcc</span> instruction after the call to <span class="SANS_TheSansMonoCd_W5Regular_11">r64ToStr</span>.</p>&#13;
<p class="TX">The final output format handled by Listing 9-13 is exponential (scientific) form. Two functions handle this conversion: <span class="SANS_TheSansMonoCd_W5Regular_11">expToBuf</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">e64ToStr</span>. The former handles the formatting of the exponent portion of the output string:</p>&#13;
<pre id="pre-752"><code>// Listing9-13.S (cont.) &#13;
//&#13;
// expToBuf &#13;
//&#13;
// Unsigned integer to buffer &#13;
// Used to output up to three-digit exponents &#13;
//&#13;
// Inputs: &#13;
//&#13;
//  X0-   Unsigned integer to convert &#13;
//  X1-   Exponent print width 1-3 &#13;
//  X2-   Points at buffer (must have at least 4 bytes) &#13;
//&#13;
// Outputs: &#13;
//&#13;
//  Buffer contains the string representing the converted &#13;
//  exponent. &#13;
//&#13;
//  Carry is clear on success, set on error. &#13;
&#13;
            proc    expToBuf &#13;
            stp     x0, lr, [sp, #-16]! &#13;
            stp     x1, x3, [sp, #-16]! &#13;
            stp     x4, x5, [sp, #-16]! &#13;
&#13;
            mov     x5, xzr     // Initialize output string. &#13;
            mov     x4, #10     // For division by 10 &#13;
&#13;
// Verify exponent digit count is in the range 1-3: &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_553" aria-label="553"/>          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> cmp     x1, #1 &#13;
            blo     badExp &#13;
            cmp     x1, #3 &#13;
            bhi     badExp &#13;
&#13;
// Verify the actual exponent will fit in the number of digits: &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> cmp     x1, #2 &#13;
            blo     oneDigit &#13;
            beq     twoDigits &#13;
&#13;
            // Must be 3: &#13;
&#13;
            cmp     x0, #1000 &#13;
            bhs     badExp &#13;
&#13;
// Convert three-digit value to a string: &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> udiv    x1, x0, x4      // X1 = quotient &#13;
            msub    x3, x1, x4, x0  // X3 = remainder &#13;
            orr     x3, x3, #'0' &#13;
            orr     x5, x3, x5, lsl #8 &#13;
&#13;
            udiv    x0, x1, x4      // X0 = quotient &#13;
            msub    x3, x0, x4, x1  // X3 = remainder &#13;
            orr     x3, x3, #'0' &#13;
            orr     x5, x3, x5, lsl #8 &#13;
&#13;
            udiv    x1, x0, x4      // X1 = quotient &#13;
            msub    x3, x1, x4, x0  // X3 = remainder &#13;
            orr     x3, x3, #'0' &#13;
            orr     x5, x3, x5, lsl #8 &#13;
&#13;
            b.al    outputExp &#13;
&#13;
// Single digit is easy: &#13;
&#13;
oneDigit: &#13;
          <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> cmp     x0, #10 &#13;
            bhs     badExp &#13;
&#13;
            orr     x5, x0, #'0' &#13;
            b.al    outputExp &#13;
&#13;
// Convert value in the range 10-99 to a string &#13;
// containing two characters: &#13;
&#13;
twoDigits: &#13;
          <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> cmp     x0, #100 &#13;
            bhs     badExp &#13;
&#13;
            udiv    x1, x0, x4      // X1 = quotient &#13;
            msub    x3, x1, x4, x0  // X3 = remainder &#13;
            orr     x3, x3, #'0' &#13;
            orr     x5, x3, x5, lsl #8 &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_554" aria-label="554"/>            udiv    x0, x1, x4      // X0 = quotient &#13;
            msub    x3, x0, x4, x1  // X3 = remainder &#13;
            orr     x3, x3, #'0' &#13;
            orr     x5, x3, x5, lsl #8 &#13;
&#13;
// Store the string into the buffer (includes a 0 &#13;
// byte in the HO positions of W5): &#13;
&#13;
outputExp: &#13;
          <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> str     w5, [x2] &#13;
            ldp     x4, x5, [sp], #16 &#13;
            ldp     x1, x3, [sp], #16 &#13;
            ldp     x0, lr, [sp], #16 &#13;
            msr     nzcv, xzr    // clc = no error &#13;
            ret &#13;
            leave &#13;
&#13;
badExp: &#13;
            ldp     x4, x5, [sp], #16 &#13;
            ldp     x1, x3, [sp], #16 &#13;
            ldp     x0, lr, [sp], #16 &#13;
            mrs     x0, nzcv &#13;
            orr     x0, x0, #(1 &lt;&lt; 29) &#13;
            msr     nzcv, x0        // stc = error &#13;
            mov     x0, #-1         // Value out of range ... &#13;
            ret &#13;
            endp    expToBuf </code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">expToBuf</span> function produces a string of exactly one, two, or three digits (based on the parameters the caller passes in X0 and X1). The <span class="SANS_TheSansMonoCd_W5Regular_11">expToBuf</span> function begins by verifying that the exponent digit count is within range <span class="CodeAnnotation" aria-label="annotation1">❶</span> and that the actual exponent will fit in the number of digits specified <span class="CodeAnnotation" aria-label="annotation2">❷</span>. The code branches to three separate output conversion code sequences if the exponent output is three digits (the normal case <span class="CodeAnnotation" aria-label="annotation3">❸</span>), one digit <span class="CodeAnnotation" aria-label="annotation4">❹</span>, or two digits <span class="CodeAnnotation" aria-label="annotation5">❺</span>. The code stores those characters into the buffer where X2 points <span class="CodeAnnotation" aria-label="annotation6">❻</span>.</p>&#13;
<p class="TX">The function returns the error status in the carry flag, returning with the carry clear for a successful operation, or the carry set if the exponent is too large or the converted number will not fit in the number of character positions that X1 specifies. Other than this, <span class="SANS_TheSansMonoCd_W5Regular_11">expToBuf</span> is basically a <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> statement (implemented using <span class="SANS_TheSansMonoCd_W5Regular_11">if...then...else</span> logic) that has three cases: one for each exponent size (one, two, or three characters).</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">e64ToStr</span> function handles the conversion from double-precision to string using exponential format:</p>&#13;
<pre id="pre-753"><code>// Listing9-13.S (cont.) &#13;
//&#13;
// e64ToStr &#13;
//&#13;
// Converts a REAL64 floating-point number to the &#13;
// corresponding string of digits. Note that this &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_555" aria-label="555"/>// function always emits the string using scientific &#13;
// notation; use the r64ToStr routine for decimal notation. &#13;
//&#13;
// On entry: &#13;
//&#13;
//  D0-     (e64) Double-precision value to convert &#13;
//&#13;
//  X0-     (buffer) e64ToStr stores the resulting characters in &#13;
//          this buffer. &#13;
//&#13;
//  X1-     (width) Field width for the number (note that this &#13;
//          is an *exact* field width, not a minimum &#13;
//          field width) &#13;
//&#13;
//  X2-     (fill) Padding character if the number is smaller &#13;
//          than the specified field width &#13;
//&#13;
//  X3-     (expDigs) Number of exponent digits (2 for real32 &#13;
//          and 3 for real64) &#13;
//&#13;
//  X4-     (maxLength) Maximum buffer size &#13;
//&#13;
// On exit: &#13;
//&#13;
//  Buffer contains the newly formatted string. If the &#13;
//  formatted value does not fit in the width specified, &#13;
//  e64ToStr will store "#" characters into this string. &#13;
//&#13;
//  Carry-  Clear if no error, set if error. &#13;
//          If error, X0 is &#13;
//              -3 if string overflow &#13;
//              -2 if bad width &#13;
//              -1 if value out of range &#13;
//&#13;
//-----------------------------------------------------------&#13;
//&#13;
// Unlike the integer-to-string conversions, this routine &#13;
// always right-justifies the number in the specified &#13;
// string. Width must be a positive number; negative &#13;
// values are illegal (actually, they are treated as &#13;
// *really* big positive numbers that will always raise &#13;
// a string overflow exception). &#13;
//&#13;
//***********************************************************&#13;
&#13;
            proc       e64ToStr &#13;
&#13;
#define     e2sWidth   x19      // chkNaNINF expects this here. &#13;
#define     e2sExp     x20 &#13;
#define     e2sFill    x21      // chkNaNINF expects this here. &#13;
#define     e2sBuffer  x22      // chkNaNINF expects this here. &#13;
#define     e2sMaxLen  x23 &#13;
#define     e2sExpDigs x24 &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_556" aria-label="556"/>#define     e2sSign    w25 &#13;
#define     eFailAdrs  x25      // chkNaNINF expects this here. &#13;
#define     e2sMantSz  x26 &#13;
&#13;
            locals  e2s &#13;
            qword   e2s.x1x2 &#13;
            qword   e2s.x3x4 &#13;
            qword   e2s.x5x19 &#13;
            qword   e2s.x20x21 &#13;
            qword   e2s.x22x23 &#13;
            qword   e2s.x24x25 &#13;
            qword   e2s.x26x27 &#13;
            dword   e2s.x0 &#13;
            dword   e2s.d0 &#13;
            byte    e2s.digits, 64 &#13;
            byte    e2s.stack, 64 &#13;
            endl    e2s &#13;
&#13;
            // Build activation record and preserve registers: &#13;
&#13;
            enter   e2s.size &#13;
            str     x0,       [fp, #e2s.x0] &#13;
            stp     x1,  x2,  [fp, #e2s.x1x2] &#13;
            stp     x3,  x4,  [fp, #e2s.x3x4] &#13;
            stp     x5,  x19, [fp, #e2s.x5x19] &#13;
            stp     x20, x21, [fp, #e2s.x20x21] &#13;
            stp     x22, x23, [fp, #e2s.x22x23] &#13;
            stp     x24, x25, [fp, #e2s.x24x25] &#13;
            stp     x26, x27, [fp, #e2s.x26x27] &#13;
            str     d0,       [fp, #e2s.d0] &#13;
&#13;
            // Move important data to nonvolatile registers: &#13;
&#13;
            mov     e2sBuffer, x0 &#13;
            mov     e2sWidth, x1 &#13;
            mov     e2sFill, x2 &#13;
            mov     e2sExpDigs, x3 &#13;
            mov     e2sMaxLen, x4 &#13;
&#13;
            // See if the width is greater than the buffer size: &#13;
&#13;
            cmp     e2sWidth, e2sMaxLen &#13;
            bhs     strOvfl &#13;
&#13;
            strb    wzr, [e2sBuffer, e2sWidth]  // Zero-terminate str. &#13;
&#13;
// First, make sure the width isn't 0: &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> cmp     e2sWidth, #0 &#13;
            beq     valOutOfRng &#13;
&#13;
// Just to be on the safe side, don't allow widths greater &#13;
// than 1024: &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_557" aria-label="557"/>            cmp     e2sWidth, #1024 &#13;
            bhi     badWidth &#13;
&#13;
// Check for NaN and INF: &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> lea     failAdrs, exit_eToBuf   // Note: X25, used before &#13;
            bl      chkNaNINF               // e2sSign (also X25) &#13;
&#13;
// Okay, do the conversion: &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> add     x0, fp, #e2s.digits // lea x1, e2s.digits &#13;
            bl      FPDigits        // Convert D0 to digit str. &#13;
            mov     e2sExp, x1      // Save away exponent result. &#13;
            mov     e2sSign, w2     // Save mantissa sign char. &#13;
&#13;
// Verify that there is sufficient room for the mantissa's sign, &#13;
// the decimal point, two mantissa digits, the "E",&#13;
// and the exponent's sign. Also add in the number of digits &#13;
// required by the exponent (2 for single, 3 for double). &#13;
//&#13;
// -1.2e+00    :real4 &#13;
// -1.2e+000   :real8 &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> add     x2, e2sExpDigs, #6    // Minimum number of posns &#13;
            cmp     x2, e2sWidth &#13;
            bls     goodWidth &#13;
&#13;
// Output a sequence of "#...#" chars (to the specified width) &#13;
// if the width value is not large enough to hold the &#13;
// conversion: &#13;
&#13;
            mov     x2, e2sWidth &#13;
            mov     x0, #'#' &#13;
            mov     x1, e2sBuffer &#13;
fillPnd:    strb    w0, [x1] &#13;
            add     x1, x1, #1 &#13;
            subs    x2, x2, #1 &#13;
            bne     fillPnd &#13;
            b.al    exit_eToBuf &#13;
&#13;
// Okay, the width is sufficient to hold the number; do the &#13;
// conversion and output the string here: &#13;
&#13;
goodWidth: &#13;
            // Compute the # of mantissa digits to display, &#13;
            // not counting mantissa sign, decimal point, &#13;
            // "E", and exponent sign: &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> sub     e2sMantSz, e2sWidth, e2sExpDigs &#13;
            sub     e2sMantSz, e2sMantSz, #4 &#13;
&#13;
            // Round the number to the specified number of &#13;
            // print positions. (Note: since there are a &#13;
            // maximum of 16 significant digits, don't &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_558" aria-label="558"/>            // bother with the rounding if the field width &#13;
            // is greater than 16 digits.) &#13;
&#13;
            cmp     e2sMantSz, #maxDigits &#13;
            bhs     noNeedToRound &#13;
&#13;
            // To round the value to the number of &#13;
            // significant digits, go to the digit just &#13;
            // beyond the last one you are considering (e2sMantSz &#13;
            // currently contains the number of decimal &#13;
            // positions) and add 5 to that digit. &#13;
            // Propagate any overflow into the remaining &#13;
            // digit positions. &#13;
&#13;
            add     x1, e2sMantSz, #1 &#13;
            add     x2, fp, #e2s.digits // lea x2, e2s.digits &#13;
            ldrb    w0, [x2, x1]        // Get least sig digit + 1. &#13;
            add     w0, w0, #5          // Round (for example, +0.5). &#13;
            cmp     w0, #'9' &#13;
            bhi     whileDigGT9 &#13;
            b.al    noNeedToRound &#13;
&#13;
// Sneak this code in here, after a branch, so the &#13;
// loop below doesn't get broken up. &#13;
&#13;
firstDigitInNumber: &#13;
&#13;
            // If you get to this point, you've hit the &#13;
            // first digit in the number, so you have to &#13;
            // shift all the characters down one position &#13;
            // in the string of bytes and put a "1" in the &#13;
            // first character position. &#13;
&#13;
            ldr     x0, [x2, #8] &#13;
            str     x0, [x2, #9] &#13;
            ldr     x0, [x2] &#13;
            str     x0, [x2, #1] &#13;
&#13;
            mov     x0, #'1'        // Store '1' in 1st &#13;
            strb    w0, [x2]        // digit position. &#13;
&#13;
            // Bump exponent by 1, as the shift did &#13;
            // a divide by 10. &#13;
&#13;
            add     e2sExp, e2sExp, #1 &#13;
            b.al    noNeedToRound &#13;
&#13;
// Subtract out overflow and add the carry into the previous &#13;
// digit (unless you hit the first digit in the number): &#13;
&#13;
whileDigGT9: &#13;
            sub     w0, w0, #10 &#13;
            strb    w0, [x2, x1] &#13;
            subs    x1, x1, #1 &#13;
            bmi     firstDigitInNumber &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_559" aria-label="559"/>            // Add in carry to previous digit: &#13;
&#13;
            ldrb    w0, [x2, x1] &#13;
            add     w0, w0, #1 &#13;
            strb    w0, [x2, x1] &#13;
            cmp     w0, #'9'        // Overflow if char &gt; '9' &#13;
            bhi     whileDigGT9 &#13;
&#13;
noNeedToRound: &#13;
            add     x2, fp, #e2s.digits // lea x2, e2s.digits &#13;
&#13;
// Okay, emit the string at this point. This is pretty easy, &#13;
// since all you really need to do is copy data from the &#13;
// digits array and add an exponent (plus a few other simple chars). &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> mov     x1, #0      // Count output mantissa digits. &#13;
            strb    e2sSign, [e2sBuffer], #1 &#13;
&#13;
// Output the first character and a following decimal point &#13;
// if there are more than two mantissa digits to output. &#13;
&#13;
            ldrb    w0, [x2] &#13;
            strb    w0, [e2sBuffer], #1 &#13;
            add     x1, x1, #1 &#13;
            cmp     x1, e2sMantSz &#13;
            beq     noDecPt &#13;
&#13;
            mov     w0, #'.' &#13;
            strb    w0, [e2sBuffer], #1 &#13;
&#13;
noDecPt: &#13;
&#13;
// Output any remaining mantissa digits here. &#13;
// Note that if the caller requests the output of &#13;
// more than 16 digits, this routine will output 0s &#13;
// for the additional digits. &#13;
&#13;
            b.al    whileX2ltMantSizeTest &#13;
&#13;
whileX2ltMantSize: &#13;
&#13;
            mov     w0, #'0' &#13;
            cmp     x1, #maxDigits &#13;
            bhs     justPut0 &#13;
&#13;
            ldrb    w0, [x2, x1] &#13;
&#13;
justPut0: &#13;
            strb    w0, [e2sBuffer], #1 &#13;
            add     x1, x1, #1 &#13;
&#13;
whileX2ltMantSizeTest: &#13;
&#13;
            cmp     x1, e2sMantSz &#13;
            blo     whileX2ltMantSize &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_560" aria-label="560"/>// Output the exponent: &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> mov     w0, #'e' &#13;
            strb    w0, [e2sBuffer], #1 &#13;
            mov     w0, #'+' &#13;
            mov     w4, #'-' &#13;
            neg     x5, e2sExp &#13;
&#13;
            cmp     e2sExp, #0 &#13;
            csel    w0, w0, w4, ge &#13;
            csel    e2sExp, e2sExp, x5, ge &#13;
&#13;
            strb    w0, [e2sBuffer], #1 &#13;
&#13;
            mov     x0, e2sExp &#13;
            mov     x1, e2sExpDigs &#13;
            mov     x2, e2sBuffer &#13;
            bl      expToBuf &#13;
            bcs     error &#13;
&#13;
exit_eToBuf: &#13;
            msr     nzcv, xzr    // clc = no error &#13;
            ldr     x0, [fp, #e2s.x0] &#13;
&#13;
returnE64: &#13;
            ldp     x1,  x2,  [fp, #e2s.x1x2] &#13;
            ldp     x3,  x4,  [fp, #e2s.x3x4] &#13;
            ldp     x5,  x19, [fp, #e2s.x5x19] &#13;
            ldp     x20, x21, [fp, #e2s.x20x21] &#13;
            ldp     x22, x23, [fp, #e2s.x22x23] &#13;
            ldp     x24, x25, [fp, #e2s.x24x25] &#13;
            ldp     x26, x27, [fp, #e2s.x26x27] &#13;
            ldr     d0,       [fp, #e2s.d0] &#13;
            leave &#13;
&#13;
strOvfl:    mov     x0, #-3 &#13;
            b.al    error &#13;
&#13;
badWidth:   mov     x0, #-2 &#13;
            b.al    error &#13;
&#13;
valOutOfRng: &#13;
            mov     x0, #-1 &#13;
error: &#13;
            mrs     x1, nzcv &#13;
            orr     x1, x1, #(1 &lt;&lt; 29) &#13;
            msr     nzcv, x1        // stc = error &#13;
            b.al    returnE64 &#13;
&#13;
            endp    e64ToStr </code></pre>&#13;
<p class="TX">Converting the mantissa to a string is very similar to the routine in <span class="SANS_TheSansMonoCd_W5Regular_11">r64ToStr</span>, though exponential form is a little easier, as the format always places the decimal point immediately after the first mantissa digit. As with <span role="doc-pagebreak" epub:type="pagebreak" id="pg_561" aria-label="561"/><span class="SANS_TheSansMonoCd_W5Regular_11">r64ToStr</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">e64ToStr</span> begins by checking the input parameters to see if they are valid <span class="CodeAnnotation" aria-label="annotation1">❶</span> (returning with the carry flag set and an error code in X0 if an error occurred). After parameter validation, the code checks for <span class="SANS_TheSansMonoCd_W5Regular_11">NaN</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">INF</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. It then calls <span class="SANS_TheSansMonoCd_W5Regular_11">FPDigits</span> to convert the mantissa to a string of digits <span class="CodeAnnotation" aria-label="annotation3">❸</span> (held in a local buffer). This call also returns the sign of the value as well as a decimal integer exponent.</p>&#13;
<p class="TX">After calculating the decimal exponent value, the <span class="SANS_TheSansMonoCd_W5Regular_11">e64ToStr</span> function checks whether the converted value will fit into the space specified by the <span class="SANS_TheSansMonoCd_W5Regular_11">Width</span> input parameter <span class="CodeAnnotation" aria-label="annotation4">❹</span>. If the converted number would be too large, <span class="SANS_TheSansMonoCd_W5Regular_11">e64ToStr</span> emits a string of <span class="SANS_TheSansMonoCd_W5Regular_11">#</span> characters to denote an error.</p>&#13;
<p class="TX">Note that this situation is not considered an error in the sense of returning the carry flag set. If the caller specifies an insufficient field width, the function still succeeds in creating a string conversion; that string just happens to be filled with <span class="SANS_TheSansMonoCd_W5Regular_11">#</span> characters. The carry flag is set, on error, when <span class="SANS_TheSansMonoCd_W5Regular_11">e64ToStr</span> cannot produce an output string.</p>&#13;
<p class="TX">After verifying that the string will fit in the specified field width, the <span class="SANS_TheSansMonoCd_W5Regular_11">e64ToStr</span> function rounds the result to the specified number of decimal digits <span class="CodeAnnotation" aria-label="annotation5">❺</span>. This algorithm is identical to that used by <span class="SANS_TheSansMonoCd_W5Regular_11">r64ToStr</span>. Next, the code outputs the mantissa digits <span class="CodeAnnotation" aria-label="annotation6">❻</span>. Again, this is similar to the way <span class="SANS_TheSansMonoCd_W5Regular_11">r64ToStr</span> works, except that the decimal point is always placed after the first digit (no need to calculate its position). Finally, the code emits <span class="SANS_TheSansMonoCd_W5Regular_11">e</span> followed by the exponent’s sign character <span class="CodeAnnotation" aria-label="annotation7">❼</span> and then calls <span class="SANS_TheSansMonoCd_W5Regular_11">expToBuf</span> to convert the exponent to a one-, two-, or three-digit character sequence (specified by the <span class="SANS_TheSansMonoCd_W5Regular_11">expDigs</span> parameter the caller passes in X3).</p>&#13;
<p class="TX">The remaining code in Listing 9-13 provides utility functions used by the main program to display data (<span class="SANS_TheSansMonoCd_W5Regular_11">r64Print</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">e64Print</span>), along with the <span class="SANS_TheSansMonoCd_W5Regular_11">asmMain</span> procedure that demonstrates floating-point output using the functions in this section:</p>&#13;
<pre id="pre-754"><code>// Listing9-13.S (cont.) &#13;
//&#13;
            proc    r64Print &#13;
&#13;
            stp     x0, x1, [sp, #-16]! &#13;
            stp     x2, x3, [sp, #-16]! &#13;
            stp     x4, x5, [sp, #-16]! &#13;
            stp     x6, x7, [sp, #-16]! &#13;
            stp     x8, lr, [sp, #-16]! &#13;
            sub     sp, sp, #64 &#13;
&#13;
            lea     x0, fmtStr1 &#13;
            lea     x1, r64str_1 &#13;
            mstr    x1, [sp] &#13;
            bl      printf &#13;
&#13;
            add     sp, sp, #64 &#13;
            ldp     x8, lr, [sp], #16 &#13;
            ldp     x6, x7, [sp], #16 &#13;
            ldp     x4, x5, [sp], #16 &#13;
            ldp     x2, x3, [sp], #16 &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_562" aria-label="562"/>            ldp     x0, x1, [sp], #16 &#13;
            ret &#13;
            endp    r64Print &#13;
&#13;
            proc    e64Print &#13;
            stp     x0, x1, [sp, #-16]! &#13;
            stp     x2, x3, [sp, #-16]! &#13;
            stp     x4, x5, [sp, #-16]! &#13;
            stp     x6, x7, [sp, #-16]! &#13;
            stp     x8, lr, [sp, #-16]! &#13;
            sub     sp, sp, #64 &#13;
&#13;
            lea     x0, fmtStr3 &#13;
            lea     x1, r64str_1 &#13;
            mstr    x1, [sp] &#13;
            bl      printf &#13;
&#13;
            add     sp, sp, #64 &#13;
            ldp     x8, lr, [sp], #16 &#13;
            ldp     x6, x7, [sp], #16 &#13;
            ldp     x4, x5, [sp], #16 &#13;
            ldp     x2, x3, [sp], #16 &#13;
            ldp     x0, x1, [sp], #16 &#13;
            ret &#13;
            endp    e64Print </code></pre>&#13;
<p class="TX">Note that these functions preserve all the nonvolatile registers because <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span> can modify them.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">asmMain</span> function is a typical demonstration program for the floating- point string-conversion functions. It calls the <span class="SANS_TheSansMonoCd_W5Regular_11">r64ToStr</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">e64ToStr</span> functions with various input parameters to demonstrate the use of these functions:</p>&#13;
<pre id="pre-755"><code>// Listing9-13.S (cont.) &#13;
//&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> r64_1:      .double  1.234567890123456 &#13;
            .double  0.0000000000000001 &#13;
            .double  1234567890123456.0 &#13;
            .double  1234567890.123456 &#13;
            .double  99499999999999999.0 &#13;
            .dword   0x7ff0000000000000 &#13;
            .dword   0xfff0000000000000 &#13;
            .dword   0x7fffffffffffffff &#13;
            .dword   0xffffffffffffffff &#13;
            .double  0.0 &#13;
            .double  -0.0 &#13;
fCnt         =       (. - r64_1) &#13;
&#13;
rSizes:     .word    12, 12, 2, 7, 0, 0, 0, 0, 0, 2, 2 &#13;
&#13;
e64_1:      .double  1.234567890123456e123 &#13;
            .double  1.234567890123456e-123 &#13;
e64_3:      .double  1.234567890123456e1 &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_563" aria-label="563"/>            .double  1.234567890123456e-1 &#13;
            .double  1.234567890123456e10 &#13;
            .double  1.234567890123456e-10 &#13;
            .double  1.234567890123456e100 &#13;
            .double  1.234567890123456e-100 &#13;
            .dword   0x7ff0000000000000 &#13;
            .dword   0xfff0000000000000 &#13;
            .dword   0x7fffffffffffffff &#13;
            .dword   0xffffffffffffffff &#13;
            .double  0.0 &#13;
            .double  -0.0 &#13;
eCnt         =       (. - e64_1) &#13;
&#13;
eSizes:     .word    6, 9, 8, 12, 14, 16, 18, 20, 12, 12, 12, 12, 8, 8 &#13;
expSizes:   .word    3, 3, 2, 2, 2, 2, 3, 3, 2, 2, 2, 2, 2, 2 &#13;
&#13;
// Here is the asmMain function: &#13;
&#13;
            proc    asmMain, public &#13;
&#13;
            locals  am &#13;
            dword   am.x8x9 &#13;
            dword   am.x27 &#13;
            byte    am.stk, 64 &#13;
            endl    am &#13;
&#13;
            enter   am.size     // Activation record &#13;
            stp     x8, x9, [fp, #am.x8x9] &#13;
            str     x27,    [fp, #am.x27] &#13;
&#13;
// F output &#13;
&#13;
            mov     x2, #16         // decDigits &#13;
fLoop: &#13;
            ldr     d0, r64_1 &#13;
            lea     x0, r64str_1    // Buffer &#13;
            mov     x1, #30         // fWidth &#13;
            mov     x3, #'.'        // Fill &#13;
            mov     x4, 32          // maxLength &#13;
            bl      r64ToStr &#13;
            bcs     fpError &#13;
            bl      r64Print &#13;
            subs    x2, x2, #1 &#13;
            bpl     fLoop &#13;
&#13;
            lea     x0, newlines &#13;
            bl      printf &#13;
&#13;
            lea     x5, r64_1 &#13;
            lea     x6, rSizes &#13;
            mov     x7, #fCnt/8 &#13;
f2Loop:     ldr     d0, [x5], #8 &#13;
            lea     x0, r64str_1    // Buffer &#13;
            mov     x1, #30         // fWidth &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_564" aria-label="564"/>            ldr     w2, [x6], #4    // decDigits &#13;
            mov     x3, #'.'        // Fill &#13;
            mov     x4, #32         // maxLength &#13;
            bl      r64ToStr &#13;
            bcs     fpError &#13;
            bl      r64Print &#13;
            subs    x7, x7, #1 &#13;
            bne     f2Loop &#13;
&#13;
// E output &#13;
&#13;
            lea     x0, expStr &#13;
            bl      printf &#13;
&#13;
            lea     x5, e64_1 &#13;
            lea     x6, eSizes &#13;
            lea     x7, expSizes &#13;
            mov     x8, #eCnt/8 &#13;
eLoop: &#13;
            ldr     d0, [x5], #8 &#13;
            lea     x0, r64str_1    // Buffer &#13;
            ldr     w1, [x6], #4    // fWidth &#13;
            mov     x2, #'.'        // Fill &#13;
            ldr     w3, [x7], #4    // expDigits &#13;
            mov     x4, #32         // maxLength &#13;
            bl      e64ToStr &#13;
            bcs     fpError &#13;
            bl      e64Print &#13;
            subs    x8, x8, #1 &#13;
            bne     eLoop &#13;
            b.al    allDone &#13;
&#13;
fpError: &#13;
            mov     x1, x0 &#13;
            lea     x0, fmtStr2 &#13;
            mstr    x1, [sp] &#13;
            bl      printf &#13;
&#13;
allDone: &#13;
            ldp     x8, x9, [fp, #am.x8x9] &#13;
            ldr     x27,    [fp, #am.x27] &#13;
            leave &#13;
            endp    asmMain </code></pre>&#13;
<p class="TX">Listing 9-13 places the floating-point constant values in the code section rather than a read-only data section <span class="CodeAnnotation" aria-label="annotation1">❶</span>, making it easier to modify them when looking at the main program.</p>&#13;
<p class="TX">The following is the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and sample output for Listing 9-13:</p>&#13;
<pre id="pre-756"><code>% <span class="SANS_TheSansMonoCd_W7Bold_11">./build Listing9-13</span> &#13;
% <span class="SANS_TheSansMonoCd_W7Bold_11">1G</span> &#13;
Calling Listing9-13: &#13;
r64ToStr: value='........... 1.2345678901234560' &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_565" aria-label="565"/>r64ToStr: value='............ 1.234567890123456' &#13;
r64ToStr: value='............. 1.23456789012345' &#13;
r64ToStr: value='.............. 1.2345678901234' &#13;
r64ToStr: value='............... 1.234567890123' &#13;
r64ToStr: value='................ 1.23456789012' &#13;
r64ToStr: value='................. 1.2345678901' &#13;
r64ToStr: value='.................. 1.234567890' &#13;
r64ToStr: value='................... 1.23456789' &#13;
r64ToStr: value='.................... 1.2345678' &#13;
r64ToStr: value='..................... 1.234567' &#13;
r64ToStr: value='...................... 1.23456' &#13;
r64ToStr: value='....................... 1.2345' &#13;
r64ToStr: value='........................ 1.234' &#13;
r64ToStr: value='......................... 1.23' &#13;
r64ToStr: value='.......................... 1.2' &#13;
r64ToStr: value='............................ 1' &#13;
&#13;
&#13;
r64ToStr: value='............... 1.234567890123' &#13;
r64ToStr: value='............... 0.000000000000' &#13;
r64ToStr: value='.......... 1234567890123456.00' &#13;
r64ToStr: value='........... 1234567890.1234560' &#13;
r64ToStr: value='............ 99500000000000000' &#13;
r64ToStr: value='INF                           ' &#13;
r64ToStr: value='-INF                          ' &#13;
r64ToStr: value='NaN                           ' &#13;
r64ToStr: value='NaN                           ' &#13;
r64ToStr: value='......................... 0.00' &#13;
r64ToStr: value='.........................-0.00' &#13;
&#13;
&#13;
Testing e64ToStr: &#13;
&#13;
e64ToStr: value='######' &#13;
e64ToStr: value=' 1.2e-123' &#13;
e64ToStr: value=' 1.2e+01' &#13;
e64ToStr: value=' 1.23456e-01' &#13;
e64ToStr: value=' 1.2345678e+10' &#13;
e64ToStr: value=' 1.234567890e-10' &#13;
e64ToStr: value=' 1.2345678901e+100' &#13;
e64ToStr: value=' 1.234567890123e-100' &#13;
e64ToStr: value='INF         ' &#13;
e64ToStr: value='-INF        ' &#13;
e64ToStr: value='NaN         ' &#13;
e64ToStr: value='NaN         ' &#13;
e64ToStr: value=' 0.0e+00' &#13;
e64ToStr: value='-0.0e+00' &#13;
Listing9-13 terminated </code></pre>&#13;
<p class="TX">This output demonstrates double-precision floating-point output. If you want to convert a single-precision value to a string, first convert the single-precision value to double-precision and use this code to translate the resulting double-precision value to a string.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_566" aria-label="566"/>&#13;
<h3 class="H1" id="sec13"><span id="h1-107"/><span class="SANS_Futura_Std_Bold_B_11">9.3 String-to-Numeric Conversions</span></h3>&#13;
<p class="TNI1">The routines converting numeric values to strings, and strings to numeric values, have two fundamental differences. First of all, numeric-to-string conversions generally occur without possibility of error (assuming you have allocated a sufficiently large buffer so that the conversion routines don’t write data beyond the end of the buffer). String-to-numeric conversions, on the other hand, must handle the real possibility of errors like illegal characters and numeric overflow.</p>&#13;
<p class="TX">A typical numeric input operation consists of reading a string of characters from the user and then translating this string of characters into an internal numeric representation. For example, in C++ a statement like <span class="SANS_TheSansMonoCd_W5Regular_11">cin &gt;&gt; i32;</span> reads a line of text from the user and converts a sequence of digits appearing at the beginning of that line of text into a 32-bit signed integer (assuming <span class="SANS_TheSansMonoCd_W5Regular_11">i32</span> is a 32-bit <span class="SANS_TheSansMonoCd_W5Regular_11">int</span> object). The <span class="SANS_TheSansMonoCd_W5Regular_11">cin &gt;&gt; i32;</span> statement skips over certain characters, like leading spaces, in the string that may appear before the actual numeric characters. The input string may also contain additional data beyond the end of the numeric input (for example, it is possible to read two integer values from the same input line), and therefore the input conversion routine must determine where the numeric data ends in the input stream.</p>&#13;
<p class="TX">Typically, C++ achieves this by looking for a character from a set of <i>delimiter</i> characters. The delimiter character set could be something as simple as any character that is not a numeric digit; or the set could be the whitespace characters (space, tab, and so on) along with perhaps a few other characters such as a comma (<span class="SANS_TheSansMonoCd_W5Regular_11">,</span>) or another punctuation character. For the sake of example, the code in this section assumes that any leading spaces or tab characters (ASCII code 9) may precede the first numeric digit and that the conversion stops on the first non-digit character it encounters. Possible error conditions are as follows:</p>&#13;
<ul class="ul">&#13;
<li class="BL">No numeric digits at all at the beginning of the string (following any spaces or tabs).</li>&#13;
<li class="BL">The string of digits is a value that would be too large for the intended numeric size (for example, 64 bits).</li>&#13;
</ul>&#13;
<p class="TX">It will be up to the caller to determine whether the numeric string ends with an invalid character upon return from the function call.</p>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h4 class="H2" id="sec14"><span id="h2-177"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">9.3.1 Decimal Strings to Integers</span></h4>&#13;
<p class="TNI1">The basic algorithm to convert a string containing decimal digits to a number is the following:</p>&#13;
<div class="top">&#13;
<p class="ListNumber">  1.  Initialize an accumulator variable to 0.</p>&#13;
<p class="ListNumber">  2.  Skip any leading spaces or tabs in the string.</p>&#13;
<p class="ListNumber">  3.  Fetch the first character after the spaces/tabs.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_567" aria-label="567"/>&#13;
<p class="ListNumber">  4.  If the character is not a numeric digit, return an error. If the character is a numeric digit, fall through to step 5.</p>&#13;
<p class="ListNumber">  5.  Convert the numeric character to a numeric value (using AND 0xf).</p>&#13;
<p class="ListNumber">  6.  Set the accumulator = (accumulator × 10) + current numeric value.</p>&#13;
<p class="ListNumber">  7.  If overflow occurs, return and report an error. If no overflow occurs, fall through to step 8.</p>&#13;
<p class="ListNumber">  8.  Fetch the next character from the string.</p>&#13;
<p class="ListNumber">  9.  If the character is a numeric digit, go back to step 5; otherwise, fall through to step 10.</p>&#13;
<p class="ListNumber">10.  Return success, with the accumulator containing the converted value.</p>&#13;
</div>&#13;
<p class="TX">For signed integer input, you use this same algorithm with the following modifications:</p>&#13;
<ul class="ul">&#13;
<li class="BL">If the first non-space/tab character is a hyphen (<span class="SANS_TheSansMonoCd_W5Regular_11">-</span>), set a flag denoting that the number is negative and skip the <span class="SANS_TheSansMonoCd_W5Regular_11">-</span> character. If the first character is not <span class="SANS_TheSansMonoCd_W5Regular_11">-</span>, clear the flag.</li>&#13;
<li class="BL">At the end of a successful conversion, if the flag is set, negate the integer result before returning (you must check for overflow on the negate operation).</li>&#13;
</ul>&#13;
<p class="TX">Listing 9-14 implements the conversion algorithm; I’ve again broken this listing into several sections to better annotate it. The first section contains the usual format strings, along with various sample strings the main program uses to test the <span class="SANS_TheSansMonoCd_W5Regular_11">strtou</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">strtoi</span> functions.</p>&#13;
<pre id="pre-757"><code>// Listing9-14.S &#13;
//&#13;
// String-to-numeric conversion &#13;
&#13;
            #include    "aoaa.inc"&#13;
&#13;
false       =           0 &#13;
true        =           1 &#13;
tab         =           9 &#13;
&#13;
            .section    .rodata, "" &#13;
ttlStr:     .asciz      "Listing 9-14"&#13;
fmtStr1:    .ascii      "strtou: String='%s'\n"&#13;
            .asciz      "    value=%llu\n"&#13;
&#13;
fmtStr2:    .ascii      "Overflow: String='%s'\n"&#13;
            .asciz      "    value=%llx\n"&#13;
&#13;
fmtStr3:    .ascii      "strtoi: String='%s'\n"&#13;
            .asciz      "    value=%lli\n"&#13;
&#13;
unexError:  .asciz      "Unexpected error in program\n"&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_568" aria-label="568"/>value1:     .asciz      "  1"&#13;
value2:     .asciz      "12 " &#13;
value3:     .asciz      " 123 " &#13;
value4:     .asciz      "1234"&#13;
value5:     .asciz      "1234567890123456789"&#13;
value6:     .asciz      "18446744073709551615"&#13;
OFvalue:    .asciz      "18446744073709551616"&#13;
OFvalue2:   .asciz      "999999999999999999999"&#13;
&#13;
ivalue1:    .asciz      "  -1"&#13;
ivalue2:    .asciz      "-12 " &#13;
ivalue3:    .asciz      " -123 " &#13;
ivalue4:    .asciz      "-1234"&#13;
ivalue5:    .asciz      "-1234567890123456789"&#13;
ivalue6:    .asciz      "-18446744073709551615"&#13;
OFivalue:   .asciz      "18446744073709551616"&#13;
OFivalue2:  .asciz      "-18446744073709551616"&#13;
&#13;
            .code &#13;
            .extern     printf &#13;
&#13;
////////////////////////////////////////////////////////////////////&#13;
//&#13;
// Return program title to C++ program: &#13;
&#13;
            proc        getTitle, public &#13;
            lea         x0, ttlStr &#13;
            ret &#13;
            endp        getTitle </code></pre>&#13;
<p class="TX">This program doesn’t have any static, writable data; all variable data is kept in registers or in local variables.</p>&#13;
<p class="TX">The following code is the <span class="SANS_TheSansMonoCd_W5Regular_11">strtou</span> function, which converts strings containing decimal digits to an unsigned integer:</p>&#13;
<pre id="pre-758"><code>// Listing9-14.S (cont.) &#13;
//&#13;
////////////////////////////////////////////////////////////////////&#13;
//&#13;
// strtou &#13;
//&#13;
// Converts string data to a 64-bit unsigned integer &#13;
//&#13;
// Input: &#13;
//&#13;
//   X1-    Pointer to buffer containing string to convert &#13;
//&#13;
// Outputs: &#13;
//&#13;
//   X0-    Contains converted string (if success), error code &#13;
//          if an error occurs &#13;
//&#13;
//   X1-    Points at first char beyond end of numeric string &#13;
//          If error, X1's value is restored to original value. &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_569" aria-label="569"/>//          Caller can check character at [X1] after a &#13;
//          successful result to see if the character following &#13;
//          the numeric digits is a legal numeric delimiter. &#13;
//&#13;
//   C-     (carry flag) Set if error occurs, clear if &#13;
//          conversion was successful. On error, X0 will &#13;
//          contain 0 (illegal initial character) or &#13;
//          0ffffffffffffffffh (overflow). &#13;
&#13;
            proc    strtou &#13;
&#13;
            str     x5, [sp, #-16]! &#13;
            stp     x3, x4, [sp, #-16]! &#13;
            stp     x1, x2, [sp, #-16]! &#13;
&#13;
            mov     x3, xzr &#13;
            mov     x0, xzr &#13;
            mov     x4, #10     // Used to mul by 10 &#13;
&#13;
            // The following loop skips over any whitespace (spaces and &#13;
            // tabs) that appear at the beginning of the string: &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> sub     x1, x1, #1      // Incremented below &#13;
skipWS:     ldrb    w2, [x1, #1]!   // Fetch next (first) char. &#13;
            cmp     w2, #' ' &#13;
            beq     skipWS &#13;
            cmp     w2, #tab &#13;
            beq     skipWS &#13;
&#13;
            // If you don't have a numeric digit at this &#13;
            // point, return an error. &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> cmp     w2, #'0'  // Note: '0' &lt; '1' &lt; ... &lt; '9' &#13;
            blo     badNumber &#13;
            cmp     w2, #'9' &#13;
            bhi     badNumber &#13;
&#13;
// Okay, the first digit is good. Convert the string &#13;
// of digits to numeric form. &#13;
//&#13;
// Have to check for unsigned integer overflow here. &#13;
// Unfortunately, madd does not set the carry or &#13;
// overflow flag, so you have to use umulh to see if &#13;
// overflow occurs after a multiplication and do &#13;
// an explicit add (rather than madd) to add the &#13;
// digit into the accumulator (X0). &#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> convert:    umulh   x5, x0, x4      // Acc * 10 &#13;
            cmp     x5, xzr &#13;
            bne     overflow &#13;
            and     x2, x2, #0xf    // Char -&gt; numeric in X2 &#13;
            mul     x0, x0, x4      // Can't use madd! &#13;
            adds    x0, x0, x2      // Add in digit. &#13;
            bcs     overflow &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_570" aria-label="570"/>          <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> ldrb    w2, [x1, #1]!   // Get next char. &#13;
            cmp     w2, #'0'        // Check for digit. &#13;
            blo     endOfNum &#13;
            cmp     w2, #'9' &#13;
            bls     convert &#13;
&#13;
// If you get to this point, you've successfully converted &#13;
// the string to numeric form. Return without restoring &#13;
// the value in X1 (X1 points at end of digits). &#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation5">❺</span> endOfNum:   ldp     x3, x4, [sp], #16   // Really X1, X2 &#13;
            mov     x2, x4 &#13;
            ldp     x3, x4, [sp], #16 &#13;
            ldr     x5, [sp], #16 &#13;
&#13;
            // Because the conversion was successful, this &#13;
            // procedure leaves X1 pointing at the first &#13;
            // character beyond the converted digits. &#13;
            // Therefore, we don't restore X1 from the stack. &#13;
&#13;
            msr     nzcv, xzr    // clr c = no error &#13;
            ret &#13;
&#13;
// badNumber- Drop down here if the first character in &#13;
//            the string was not a valid digit. &#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation6">❻</span> badNumber:  mov     x0, xzr &#13;
errorRet:   mrs     x1, nzcv    // Return error in carry flag. &#13;
            orr     x1, x1, #(1 &lt;&lt; 29) &#13;
            msr     nzcv, x1    // Set c = error. &#13;
&#13;
            ldp     x1, x2, [sp], #16 &#13;
            ldp     x3, x4, [sp], #16 &#13;
            ldr     x5, [sp], #16 &#13;
            ret &#13;
&#13;
// overflow- Drop down here if the accumulator overflowed &#13;
//           while adding in the current character. &#13;
&#13;
overflow:   mov     x0, #-1  // 0xFFFFFFFFFFFFFFFF &#13;
            b.al    errorRet &#13;
            endp    strtou </code></pre>&#13;
<p class="TX">On entry into <span class="SANS_TheSansMonoCd_W5Regular_11">strtou</span>, the X1 register points at the first character of the string to convert. This function begins by skipping over any whitespace characters (spaces and tabs) in the string, leaving X1 pointing at the first non-space/non-tab character <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</p>&#13;
<p class="TX">After any whitespace characters, the first character must be a decimal digit, or <span class="SANS_TheSansMonoCd_W5Regular_11">strtou</span> must return a conversion error. Therefore, after finding a non-whitespace character, the code checks to see that the character is in the range <span class="SANS_TheSansMonoCd_W5Regular_11">'0'</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">'9'</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">After verifying that the first character is a digit, the code enters the main conversion loop <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Normally, you’d just convert the character to an <span role="doc-pagebreak" epub:type="pagebreak" id="pg_571" aria-label="571"/>integer (by ANDing with 0xF), multiply the accumulator in X0 by 10, and add in the character’s value. This could be done using two instructions:</p>&#13;
<pre id="pre-759"><code>and  x2, x2, #0xf &#13;
madd x0, x0, x4, x2 // X4 contains 10. </code></pre>&#13;
<p class="TX">The only problem is that you cannot detect overflow by using these two instructions (something that the <span class="SANS_TheSansMonoCd_W5Regular_11">strtou</span> function must do). To detect an overflow due to the multiplication by 10, the code must use the <span class="SANS_TheSansMonoCd_W5Regular_11">umulh</span> instruction and check the result for 0 (if it is not 0, overflow occurs) <span class="CodeAnnotation" aria-label="annotation3">❸</span>. If the <span class="SANS_TheSansMonoCd_W5Regular_11">umulh</span> result is 0, the code can multiply the accumulator (X0) by 10 without fear of overflow. Of course, overflow can still occur when adding the character’s value to the product of X0 and 10, so you still cannot use <span class="SANS_TheSansMonoCd_W5Regular_11">madd</span>; instead, you must multiply the accumulator by 10, then use the <span class="SANS_TheSansMonoCd_W5Regular_11">adds</span> instruction to add in the character value and check the carry flag immediately thereafter.</p>&#13;
<p class="TX">The convert loop repeats this process until either an overflow occurs or it encounters a nondigit character. Once it encounters a nondigit character <span class="CodeAnnotation" aria-label="annotation4">❹</span>, the converted integer value is in the X0 register, and the function returns with the carry clear. Note that if the conversion is successful, the <span class="SANS_TheSansMonoCd_W5Regular_11">strtou</span> function does not restore the X1 register; instead, it returns with X1 pointing at the first nondigit character <span class="CodeAnnotation" aria-label="annotation5">❺</span>. It is the caller’s responsibility to check this character to see if it is legitimate.</p>&#13;
<p class="TX">In the event of an overflow or an illegal starting character, the function returns with the carry flag set and an error code in X0 <span class="CodeAnnotation" aria-label="annotation6">❻</span>.</p>&#13;
<p class="TX">The following code is the <span class="SANS_TheSansMonoCd_W5Regular_11">strtoi</span> procedure, which is the signed-integer version of the <span class="SANS_TheSansMonoCd_W5Regular_11">strtou</span> procedure:</p>&#13;
<pre id="pre-760"><code>// Listing9-14.S (cont.) &#13;
//&#13;
// strtoi &#13;
//&#13;
// Converts string data to a 64-bit signed integer &#13;
//&#13;
// Input: &#13;
//&#13;
//   X1-    Pointer to buffer containing string to convert &#13;
//&#13;
// Outputs: &#13;
//&#13;
//   X0-    Contains converted string (if success), error code &#13;
//          if an error occurs &#13;
//&#13;
//   X1-    Points at first char beyond end of numeric string. &#13;
//          If error, X1's value is restored to original value. &#13;
//          Caller can check character at [X1] after a &#13;
//          successful result to see if the character following &#13;
//          the numeric digits is a legal numeric delimiter. &#13;
//&#13;
//   C-    (carry flag) Set if error occurs, clear if &#13;
//         conversion was successful. On error, X0 will &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_572" aria-label="572"/>//         contain 0 (illegal initial character) or &#13;
//         -1 (overflow). &#13;
&#13;
tooBig:     .dword  0x7fffffffffffffff &#13;
&#13;
            proc    strtoi &#13;
&#13;
            locals  si &#13;
            qword   si.saveX1X2 &#13;
            endl    si &#13;
&#13;
            enter   si.size &#13;
&#13;
            // Preserve X1 in case you have to restore it; &#13;
            // X2 is the sign flag: &#13;
&#13;
            stp     x1, x2, [fp, #si.saveX1X2] &#13;
&#13;
            // Assume you have a nonnegative number: &#13;
&#13;
            mov     x2, #false &#13;
&#13;
// The following loop skips over any whitespace (spaces and &#13;
// tabs) that appear at the beginning of the string: &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> sub     x1, x1, #1  // Adjust for +1 below. &#13;
skipWSi:    ldrb    w0, [x1, #1]! &#13;
            cmp     w0, #' ' &#13;
            beq     skipWSi &#13;
            cmp     w0, #tab &#13;
            beq     skipWSi &#13;
&#13;
            // If the first character you've encountered is &#13;
            // '-', then skip it, but remember that this is &#13;
            // a negative number: &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> cmp     w0, #'-' &#13;
            bne     notNeg &#13;
            mov     w2, #true &#13;
            add     x1, x1, #1  // Skip '-' &#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> notNeg:     bl      strtou       // Convert string to integer. &#13;
            bcs     hadError &#13;
&#13;
            // strtou returned success. Check the negative &#13;
            // flag and negate the input if the flag &#13;
            // contains true: &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> cmp     w2, #true &#13;
            bne     itsPosOr0 &#13;
&#13;
            negs    x0, x0 &#13;
            bvs     overflowi &#13;
            ldr     x2, [fp, #si.saveX1X2+8] &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_573" aria-label="573"/>            msr     nzcv, xzr   // clr c = no error &#13;
            leave &#13;
&#13;
// Success, so don't restore X1: &#13;
&#13;
itsPosOr0: &#13;
            ldr     x2, tooBig &#13;
            cmp     x0, x2     // Number is too big. &#13;
            bhi     overflowi &#13;
            ldr     x2, [fp, #si.saveX1X2+8] &#13;
            msr     nzcv, xzr  // clr c = no error &#13;
            leave &#13;
&#13;
// If you have an error, you need to restore RDI from the stack: &#13;
&#13;
overflowi:  mov     x0, #-1     // Indicate overflow. &#13;
hadError: &#13;
            mrs     x2, nzcv    // Return error in carry flag. &#13;
            orr     x2, x2, #(1 &lt;&lt; 29) &#13;
            msr     nzcv, x2    // Set c = error. &#13;
            ldp     x1, x2, [fp, #si.saveX1X2] &#13;
            leave &#13;
            endp    strtoi </code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">strtoi</span> function converts a string containing a signed integer to the corresponding value in X0. The code begins by eliminating whitespace <span class="CodeAnnotation" aria-label="annotation1">❶</span>, then checks for a <span class="SANS_TheSansMonoCd_W5Regular_11">'-'</span> character <span class="CodeAnnotation" aria-label="annotation2">❷</span>. The function maintains a “negative flag” in the X2 register (<span class="SANS_TheSansMonoCd_W5Regular_11">0</span> = nonnegative, <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> = negative). After skipping the optional sign character, the code calls the <span class="SANS_TheSansMonoCd_W5Regular_11">strtou</span> function to convert the following string to an unsigned value <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">Upon return from <span class="SANS_TheSansMonoCd_W5Regular_11">strtou</span>, the <span class="SANS_TheSansMonoCd_W5Regular_11">strtoi</span> function checks the sign flag in X2 and negates the number if it’s supposed to be negative <span class="CodeAnnotation" aria-label="annotation4">❹</span>. In both cases (negative or nonnegative), the code also checks for an overflow condition and returns an error if an overflow occurred.</p>&#13;
<p class="TX">As for <span class="SANS_TheSansMonoCd_W5Regular_11">strtou</span>, the <span class="SANS_TheSansMonoCd_W5Regular_11">strtoi</span> function does not restore X1 if the conversion was successful. However, it will restore X1 if an overflow occurred or if <span class="SANS_TheSansMonoCd_W5Regular_11">strtou</span> reported an error.</p>&#13;
<p class="TX">When you call <span class="SANS_TheSansMonoCd_W5Regular_11">strtou</span> to convert the string to an integer, <span class="SANS_TheSansMonoCd_W5Regular_11">strtoi</span> will allow an arbitrary amount of whitespace between the minus sign and the first digit of a string representing a negative number. If this is a problem for you, modify <span class="SANS_TheSansMonoCd_W5Regular_11">strtou</span> to skip whitespace and then call a subservient routine to do the conversion; next, have <span class="SANS_TheSansMonoCd_W5Regular_11">strtoi</span> call that subservient routine (which will return an illegal initial character error, if appropriate) in place of <span class="SANS_TheSansMonoCd_W5Regular_11">strtou</span>.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">asmMain</span> function demonstrates calling the <span class="SANS_TheSansMonoCd_W5Regular_11">strtou</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">strtoi</span> functions:</p>&#13;
<pre id="pre-761"><code>// Listing9-14.S (cont.) &#13;
//&#13;
////////////////////////////////////////////////////////////////////&#13;
//&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_574" aria-label="574"/>// Here is the asmMain function: &#13;
&#13;
            proc    asmMain, public &#13;
&#13;
            locals  am &#13;
            byte    am.shadow, 64 &#13;
            endl    am &#13;
&#13;
            enter   am.size &#13;
&#13;
// Test unsigned conversions: &#13;
&#13;
            lea     x1, value1 &#13;
            bl      strtou &#13;
            bcs     UnexpectedError &#13;
&#13;
            mov     x2, x0 &#13;
            lea     x0, fmtStr1 &#13;
            lea     x1, value1 &#13;
            mstr    x1, [sp] &#13;
            mstr    x2, [sp, #8] &#13;
            bl      printf &#13;
&#13;
            lea     x1, value2 &#13;
            bl      strtou &#13;
            bcs     UnexpectedError &#13;
&#13;
            mov     x2, x0 &#13;
            lea     x0, fmtStr1 &#13;
            lea     x1, value2 &#13;
            mstr    x1, [sp] &#13;
            mstr    x2, [sp, #8] &#13;
            bl      printf &#13;
&#13;
            lea     x1, value3 &#13;
            bl      strtou &#13;
            bcs     UnexpectedError &#13;
&#13;
            mov     x2, x0 &#13;
            lea     x0, fmtStr1 &#13;
            lea     x1, value3 &#13;
            mstr    x1, [sp] &#13;
            mstr    x2, [sp, #8] &#13;
            bl      printf &#13;
&#13;
            lea     x1, value4 &#13;
            bl      strtou &#13;
            bcs     UnexpectedError &#13;
&#13;
            mov     x2, x0 &#13;
            lea     x0, fmtStr1 &#13;
            lea     x1, value4 &#13;
            mstr    x1, [sp] &#13;
            mstr    x2, [sp, #8] &#13;
            bl      printf &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_575" aria-label="575"/>            lea     x1, value5 &#13;
            bl      strtou &#13;
            bcs     UnexpectedError &#13;
&#13;
            mov     x2, x0 &#13;
            lea     x0, fmtStr1 &#13;
            lea     x1, value5 &#13;
            mstr    x1, [sp] &#13;
            mstr    x2, [sp, #8] &#13;
            bl      printf &#13;
&#13;
            lea     x1, value6 &#13;
            bl      strtou &#13;
            bcs     UnexpectedError &#13;
&#13;
            mov     x2, x0 &#13;
            lea     x0, fmtStr1 &#13;
            lea     x1, value6 &#13;
            mstr    x1, [sp] &#13;
            mstr    x2, [sp, #8] &#13;
            bl      printf &#13;
&#13;
            lea     x1, OFvalue &#13;
            bl      strtou &#13;
            bcc     UnexpectedError &#13;
            cmp     x0, xzr        // Nonzero for overflow &#13;
            beq     UnexpectedError &#13;
&#13;
            mov     x2, x0 &#13;
            lea     x0, fmtStr2 &#13;
            lea     x1, OFvalue &#13;
            mstr    x1, [sp] &#13;
            mstr    x2, [sp, #8] &#13;
            bl      printf &#13;
&#13;
            lea     x1, OFvalue2 &#13;
            bl      strtou &#13;
            bcc     UnexpectedError &#13;
            cmp     x0, xzr        // Nonzero for overflow &#13;
            beq     UnexpectedError &#13;
&#13;
            mov     x2, x0 &#13;
            lea     x0, fmtStr2 &#13;
            lea     x1, OFvalue2 &#13;
            mstr    x1, [sp] &#13;
            mstr    x2, [sp, #8] &#13;
            bl      printf &#13;
&#13;
// Test signed conversions: &#13;
&#13;
            lea     x1, ivalue1 &#13;
            bl      strtoi &#13;
            bcs     UnexpectedError &#13;
&#13;
            mov     x2, x0 &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_576" aria-label="576"/>            lea     x0, fmtStr3 &#13;
            lea     x1, ivalue1 &#13;
            mstr    x1, [sp] &#13;
            mstr    x2, [sp, #8] &#13;
            bl      printf &#13;
&#13;
            lea     x1, ivalue2 &#13;
            bl      strtoi &#13;
            bcs     UnexpectedError &#13;
&#13;
            mov     x2, x0 &#13;
            lea     x0, fmtStr3 &#13;
            lea     x1, ivalue2 &#13;
            mstr    x1, [sp] &#13;
            mstr    x2, [sp, #8] &#13;
            bl      printf &#13;
&#13;
            lea     x1, ivalue3 &#13;
            bl      strtoi &#13;
            bcs     UnexpectedError &#13;
&#13;
            mov     x2, x0 &#13;
            lea     x0, fmtStr3 &#13;
            lea     x1, ivalue3 &#13;
            mstr    x1, [sp] &#13;
            mstr    x2, [sp, #8] &#13;
            bl      printf &#13;
&#13;
            lea     x1, ivalue4 &#13;
            bl      strtoi &#13;
            bcs     UnexpectedError &#13;
&#13;
            mov     x2, x0 &#13;
            lea     x0, fmtStr3 &#13;
            lea     x1, ivalue4 &#13;
            mstr    x1, [sp] &#13;
            mstr    x2, [sp, #8] &#13;
            bl      printf &#13;
&#13;
            lea     x1, ivalue5 &#13;
            bl      strtoi &#13;
            bcs     UnexpectedError &#13;
&#13;
            mov     x2, x0 &#13;
            lea     x0, fmtStr3 &#13;
            lea     x1, ivalue5 &#13;
            mstr    x1, [sp] &#13;
            mstr    x2, [sp, #8] &#13;
            bl      printf &#13;
&#13;
            lea     x1, ivalue6 &#13;
            bl      strtoi &#13;
            bcs     UnexpectedError &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_577" aria-label="577"/>            mov     x2, x0 &#13;
            lea     x0, fmtStr3 &#13;
            lea     x1, ivalue6 &#13;
            mstr    x1, [sp] &#13;
            mstr    x2, [sp, #8] &#13;
            bl      printf &#13;
&#13;
            lea     x1, OFivalue &#13;
            bl      strtoi &#13;
            bcc     UnexpectedError &#13;
            cmp     x0, xzr        // Nonzero for overflow &#13;
            beq     UnexpectedError &#13;
&#13;
            mov     x2, x0 &#13;
            lea     x0, fmtStr2 &#13;
            lea     x1, OFivalue &#13;
            mstr    x1, [sp] &#13;
            mstr    x2, [sp, #8] &#13;
            bl      printf &#13;
&#13;
            lea     x1, OFivalue2 &#13;
            bl      strtoi &#13;
            bcc     UnexpectedError &#13;
            cmp     x0, xzr        // Nonzero for overflow &#13;
            beq     UnexpectedError &#13;
&#13;
            mov     x2, x0 &#13;
            lea     x0, fmtStr2 &#13;
            lea     x1, OFivalue2 &#13;
            mstr    x1, [sp] &#13;
            mstr    x2, [sp, #8] &#13;
            bl      printf &#13;
&#13;
            b.al    allDone &#13;
&#13;
UnexpectedError: &#13;
            lea     x0, unexError &#13;
            bl      printf &#13;
&#13;
allDone:    leave   // Returns to caller &#13;
            endp    asmMain </code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">asmMain</span> function in Listing 9-14 is a typical test program; it converts various strings appearing in the read-only data section to their corresponding integer values and displays them. It also tests a couple of overflow conditions to verify that the routines properly handle overflow.</p>&#13;
<p class="TX">The following is the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and sample output for the program in Listing 9-14:</p>&#13;
<pre id="pre-762"><code>% <span class="SANS_TheSansMonoCd_W7Bold_11">./build Listing9-14</span> &#13;
% <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing9-14</span> &#13;
Calling Listing9-14: &#13;
strtou: String='  1' &#13;
    value=1 &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_578" aria-label="578"/>strtou: String='12 ' &#13;
    value=12 &#13;
strtou: String=' 123 ' &#13;
    value=123 &#13;
strtou: String='1234' &#13;
    value=1234 &#13;
strtou: String='1234567890123456789' &#13;
    value=1234567890123456789 &#13;
strtou: String='18446744073709551615' &#13;
    value=18446744073709551615 &#13;
Overflow: String='18446744073709551616' &#13;
    value=ffffffffffffffff &#13;
Overflow: String='999999999999999999999' &#13;
    value=ffffffffffffffff &#13;
strtoi: String='  -1' &#13;
    value=-1 &#13;
strtoi: String='-12 ' &#13;
    value=-12 &#13;
strtoi: String=' -123 ' &#13;
    value=-123 &#13;
strtoi: String='-1234' &#13;
    value=-1234 &#13;
strtoi: String='-1234567890123456789' &#13;
    value=-1234567890123456789 &#13;
strtoi: String='-18446744073709551615' &#13;
    value=1 &#13;
Overflow: String='18446744073709551616' &#13;
    value=ffffffffffffffff &#13;
Overflow: String='-18446744073709551616' &#13;
    value=ffffffffffffffff &#13;
Listing9-14 terminated </code></pre>&#13;
<p class="TX">For an extended-precision string-to-numeric conversion, simply modify the <span class="SANS_TheSansMonoCd_W5Regular_11">strtou</span> function to include an extended-precision accumulator, then do an extended-precision multiplication by 10 (rather than a standard multiplication).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h4 class="H2" id="sec15"><span id="h2-178"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">9.3.2 Hexadecimal Strings to Numeric Form</span></h4>&#13;
<p class="TNI1">As was the case for numeric output, hexadecimal input is the easiest numeric input routine to write. The basic algorithm for converting hexadecimal strings to numeric form is the following:</p>&#13;
<div class="top">&#13;
<p class="ListNumber">  1.  Initialize an accumulator value to 0.</p>&#13;
<p class="ListNumber">  2.  For each input character that is a valid hexadecimal digit, repeat steps 3 through 6; skip down to step 7 when the character is not a valid hexadecimal digit.</p>&#13;
<p class="ListNumber">  3.  Convert the hexadecimal character to a value in the range 0 to 15 (0h to 0Fh).</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_579" aria-label="579"/>&#13;
<p class="ListNumber">  4.  If the HO 4 bits of the accumulator value are nonzero, raise an exception.</p>&#13;
<p class="ListNumber">  5.  Multiply the current value by 16 (that is, shift left 4 bits).</p>&#13;
<p class="ListNumber">  6.  Add the converted hexadecimal digit value to the accumulator.</p>&#13;
<p class="ListNumber">  7.  Check the current input character to ensure that it is a valid delimiter. Raise an exception if it is not.</p>&#13;
</div>&#13;
<p class="TX">Listing 9-15 implements this hexadecimal input routine for 64-bit values.</p>&#13;
<pre id="pre-763"><code>// Listing9-15.S &#13;
//&#13;
// Hexadecimal-string-to-numeric conversion &#13;
&#13;
            #include    "aoaa.inc"&#13;
&#13;
false       =           0 &#13;
true        =           1 &#13;
tab         =           9 &#13;
&#13;
            .section    .rodata, "" &#13;
ttlStr:     .asciz      "Listing 9-15"&#13;
fmtStr1:    .ascii      "strtoh: String='%s' " &#13;
            .asciz      "value=%llx\n"&#13;
&#13;
fmtStr2:    .asciz      "Error, str='%s', x0=%lld\n"&#13;
&#13;
fmtStr3:    .ascii      "Error, expected overflow: x0=%llx, " &#13;
            .asciz      "str='%s'\n"&#13;
&#13;
fmtStr4:    .ascii      "Error, expected bad char: x0=%llx, " &#13;
            .asciz      "str='%s'\n"&#13;
&#13;
hexStr:     .asciz      "1234567890abcdef"&#13;
hexStrOVFL: .asciz      "1234567890abcdef0"&#13;
hexStrBAD:  .asciz      "x123"&#13;
&#13;
            .code &#13;
            .extern     printf &#13;
&#13;
/////////////////////////////////////////////////////////////&#13;
//&#13;
// Return program title to C++ program: &#13;
&#13;
            proc    getTitle, public &#13;
            lea     x0, ttlStr &#13;
            ret &#13;
            endp    getTitle &#13;
&#13;
/////////////////////////////////////////////////////////////&#13;
//&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_580" aria-label="580"/>// strtoh: &#13;
//&#13;
// Converts string data to a 64-bit unsigned integer &#13;
//&#13;
// Input: &#13;
//&#13;
//   X1-    Pointer to buffer containing string to convert &#13;
//&#13;
// Outputs: &#13;
//&#13;
//   X0-    Contains converted string (if success), error code &#13;
//          if an error occurs &#13;
//&#13;
//   X1-    Points at first char beyond end of hexadecimal string. &#13;
//          If error, X1's value is restored to original value. &#13;
//          Caller can check character at [X1] after a &#13;
//          successful result to see if the character following &#13;
//          the hexadecimal digits is a legal delimiter. &#13;
//&#13;
//   C-     (carry flag) Set if error occurs, clear if &#13;
//          conversion was successful. On error, X0 will &#13;
//          contain 0 (illegal initial character) or &#13;
//          -1 = 0xffffffffffffffff (overflow). &#13;
&#13;
            proc    strtoh &#13;
&#13;
            stp     x3, x4, [sp, #-16]! &#13;
            stp     x1, x2, [sp, #-16]! &#13;
&#13;
            // This code will use the value in X3 to test &#13;
            // whether overflow will occur in X0 when &#13;
            // shifting to the left 4 bits: &#13;
&#13;
            mov     x3, 0xF000000000000000 &#13;
            mov     x0, xzr // Zero out accumulator. &#13;
&#13;
            // 0x5f is used to convert lowercase to &#13;
            // uppercase: &#13;
&#13;
            mov     x4, 0x5f &#13;
&#13;
// The following loop skips over any whitespace (spaces and &#13;
// tabs) that appear at the beginning of the string: &#13;
&#13;
            sub     x1, x1, #1  // Because of inc below &#13;
skipWS:     ldrb    w2, [x1, #1]! &#13;
            cmp     w2, #' ' &#13;
            beq     skipWS &#13;
            cmp     w2, #tab &#13;
            beq     skipWS &#13;
&#13;
            // If you don't have a hexadecimal digit at this &#13;
            // point, return an error: &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_581" aria-label="581"/>          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> cmp     w2, #'0'    // Note: '0' &lt; '1' &lt; ... &lt; '9' &#13;
            blo     badNumber &#13;
            cmp     w2, #'9' &#13;
            bls     convert &#13;
            and     x2, x2, x4  // Cheesy LC -&gt; UC conversion &#13;
            cmp     w2, #'A' &#13;
            blo     badNumber &#13;
            cmp     w2, #'F' &#13;
            bhi     badNumber &#13;
            sub     w2, w2, #7  // Maps 41h..46h -&gt; 3ah..3fh &#13;
&#13;
            // Okay, the first digit is good. Convert the &#13;
            // string of digits to numeric form: &#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> convert:    ands    xzr, x3, x0  // See if adding in the current &#13;
            bne     overflow     // digit will cause an overflow. &#13;
&#13;
            and     x2, x2, #0xf // Convert to numeric in X2. &#13;
&#13;
            // Multiply 64-bit accumulator by 16 and add in &#13;
            // new digit: &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> lsl     x0, x0, #4 &#13;
            add     x0, x0, x2  // Never overflows &#13;
&#13;
            // Move on to next character: &#13;
&#13;
            ldrb    w2, [x1, #1]! &#13;
            cmp     w2, #'0' &#13;
            blo     endOfNum &#13;
            cmp     w2, #'9' &#13;
            bls     convert &#13;
&#13;
            and     x2, x2, x4  // Cheesy LC -&gt; UC conversion &#13;
            cmp     x2, #'A' &#13;
            blo     endOfNum &#13;
            cmp     x2, #'F' &#13;
            bhi     endOfNum &#13;
            sub     x2, x2, #7  // Maps 41h..46h -&gt; 3ah..3fh &#13;
            b.al    convert &#13;
&#13;
// If you get to this point, you've successfully converted &#13;
// the string to numeric form: &#13;
&#13;
endOfNum: &#13;
&#13;
            // Because the conversion was successful, this &#13;
            // procedure leaves X1 pointing at the first &#13;
            // character beyond the converted digits. &#13;
            // Therefore, don't restore X1 from the stack. &#13;
&#13;
            ldp     x3, x2, [sp], #16   // X3 holds old X1 &#13;
            ldp     x3, x4, [sp], #16 &#13;
            msr     nzcv, xzr   // clr c = no error &#13;
            ret &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_582" aria-label="582"/>// badNumber- Drop down here if the first character in &#13;
//            the string was not a valid digit. &#13;
&#13;
badNumber:  mov     x0, xzr &#13;
            b.al    errorExit &#13;
&#13;
overflow:   mov     x0, #-1     // Return -1 as error on overflow. &#13;
errorExit: &#13;
            mrs     x1, nzcv    // Return error in carry flag. &#13;
            orr     x1, x1, #(1 &lt;&lt; 29) &#13;
            msr     nzcv, x1    // Set c = error. &#13;
&#13;
            ldp     x1, x2, [sp], #16 &#13;
            ldp     x3, x4, [sp], #16 &#13;
            ret &#13;
            endp    strtoh &#13;
&#13;
/////////////////////////////////////////////////////////////&#13;
//&#13;
// Here is the asmMain function: &#13;
&#13;
            proc    asmMain, public &#13;
&#13;
            locals  am &#13;
            byte    am.stack, 64 &#13;
            endl    am &#13;
&#13;
            enter   am.size &#13;
&#13;
            // Test hexadecimal conversion: &#13;
&#13;
            lea     x1, hexStr &#13;
            bl      strtoh &#13;
            bcs     error &#13;
&#13;
            mov     x2, x0 &#13;
            lea     x1, hexStr &#13;
            lea     x0, fmtStr1 &#13;
            mstr    x1, [sp] &#13;
            mstr    x2, [sp, #8] &#13;
            bl      printf &#13;
&#13;
 // Test overflow conversion: &#13;
&#13;
            lea     x1, hexStrOVFL &#13;
            bl      strtoh &#13;
            bcc     unexpected &#13;
&#13;
            mov     x2, x0 &#13;
            lea     x0, fmtStr2 &#13;
            mstr    x1, [sp] &#13;
            mstr    x2, [sp, #8] &#13;
            bl      printf &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_583" aria-label="583"/>// Test bad character: &#13;
&#13;
            lea     x1, hexStrBAD &#13;
            bl      strtoh &#13;
            bcc     unexp2 &#13;
&#13;
            mov     x2, x0 &#13;
            lea     x0, fmtStr2 &#13;
            mstr    x1, [sp] &#13;
            mstr    x2, [sp, #8] &#13;
            bl      printf &#13;
&#13;
            b.al    allDone &#13;
&#13;
unexpected: mov     x3, x0 &#13;
            lea     x0, fmtStr3 &#13;
            mstr    x1, [sp] &#13;
            mstr    x2, [sp, #8] &#13;
            mstr    x3, [sp, #16] &#13;
            bl      printf &#13;
            b.al    allDone &#13;
&#13;
unexp2:     mov     x3, x0 &#13;
            lea     x0, fmtStr4 &#13;
            mstr    x1, [sp] &#13;
            mstr    x2, [sp, #8] &#13;
            mstr    x3, [sp, #16] &#13;
            bl      printf &#13;
            b.al    allDone &#13;
&#13;
error:      mov     x2, x0 &#13;
            lea     x0, fmtStr2 &#13;
            mstr    x1, [sp] &#13;
            mstr    x2, [sp, #8] &#13;
            bl      printf &#13;
&#13;
allDone:    leave &#13;
            endp    asmMain </code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">strtoh</span> function is similar to <span class="SANS_TheSansMonoCd_W5Regular_11">strtou</span>, except that it tests for hexadecimal digits <span class="CodeAnnotation" aria-label="annotation1">❶</span> (rather than just decimal digits), tests the HO 4 bits to determine whether an overflow occurs <span class="CodeAnnotation" aria-label="annotation2">❷</span> (much easier than the decimal case), and multiplies by the hexadecimal radix (16) rather than by 10 <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">Here’s the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and sample output for the program in Listing 9-15:</p>&#13;
<pre id="pre-764"><code>% <span class="SANS_TheSansMonoCd_W7Bold_11">./build Listing9-15</span> &#13;
% <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing9-15</span> &#13;
Calling Listing9-15: &#13;
strtoh: String='1234567890abcdef' value=1234567890abcdef &#13;
Error, str='1234567890abcdef0', x0=-1 &#13;
Error, str='x123', x0 = 0 &#13;
Listing9-15 terminated </code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_584" aria-label="584"/>For hexadecimal string conversions that handle numbers greater than 64 bits, you have to use an extended-precision shift left by 4 bits. Listing 9-16 demonstrates the necessary modifications to the <span class="SANS_TheSansMonoCd_W5Regular_11">strtoh</span> function for a 128-bit conversion.</p>&#13;
<pre id="pre-765"><code>// Listing9-16.S &#13;
//&#13;
// 128-bit Hexadecimal-string-to-numeric conversion &#13;
&#13;
            #include    "aoaa.inc"&#13;
&#13;
false       =           0 &#13;
true        =           1 &#13;
tab         =           9 &#13;
&#13;
            .section    .rodata, "" &#13;
 tlStr:     .asciz      "Listing 9-16"&#13;
&#13;
fmtStr1:    .asciz      "strtoh128: value=%llx%llx, String='%s'\n"&#13;
&#13;
hexStr:     .asciz      "1234567890abcdeffedcba0987654321"&#13;
&#13;
&#13;
            .code &#13;
            .extern     printf &#13;
&#13;
/////////////////////////////////////////////////////////////&#13;
//&#13;
// Return program title to C++ program: &#13;
&#13;
            proc    getTitle, public &#13;
            lea     x0, ttlStr &#13;
            ret &#13;
            endp    getTitle &#13;
&#13;
/////////////////////////////////////////////////////////////&#13;
//&#13;
// strtoh128 &#13;
//&#13;
// Converts string data to a 128-bit unsigned integer &#13;
//&#13;
// Input: &#13;
//&#13;
//   X2-    Pointer to buffer containing string to convert &#13;
//&#13;
// Outputs: &#13;
//&#13;
//   X1:X0- Contains converted string (if success), error code &#13;
//          if an error occurs &#13;
//&#13;
//   X2-    Points at first char beyond end of hexadecimal &#13;
//          string. If error, X2's value is restored to &#13;
//          original value. &#13;
//          Caller can check character at [X2] after a &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_585" aria-label="585"/>//          successful result to see if the character following &#13;
//          the hexadecimal digits is a legal delimiter. &#13;
//&#13;
//   C-     (carry flag) Set if error occurs, clear if &#13;
//          conversion was successful. On error, X0 will &#13;
//          contain 0 (illegal initial character) or &#13;
//          -1 = 0xffffffffffffffff (overflow). &#13;
&#13;
            proc    strtoh128 &#13;
&#13;
            stp     x4, x5, [sp, #-16]! &#13;
            stp     x2, x3, [sp, #-16]! &#13;
&#13;
            // This code will use the value in X4 to test &#13;
            // whether overflow will occur in X1 when &#13;
            // shifting to the left 4 bits: &#13;
&#13;
            mov     x4, 0xF000000000000000 &#13;
            mov     x0, xzr // Zero out LO accumulator. &#13;
            mov     x1, xzr // Zero out HO accumulator. &#13;
&#13;
            // 0x5f is used to convert lowercase to &#13;
            // uppercase: &#13;
&#13;
            mov     x5, 0x5f &#13;
&#13;
// The following loop skips over any whitespace (spaces and &#13;
// tabs) that appear at the beginning of the string: &#13;
&#13;
            sub     x2, x2, #1 // Because of inc below &#13;
skipWS:     ldrb    w3, [x2, #1]! &#13;
            cmp     w3, #' ' &#13;
            beq     skipWS &#13;
            cmp     w3, #tab &#13;
            beq     skipWS &#13;
&#13;
            // If you don't have a hexadecimal digit at this &#13;
            // point, return an error: &#13;
&#13;
            cmp     w3, #'0'   // Note: '0' &lt; '1' &lt; ... &lt; '9' &#13;
            blo     badNumber &#13;
            cmp     w3, #'9' &#13;
            bls     convert &#13;
            and     x3, x3, x5 // Cheesy LC -&gt; UC conversion &#13;
            cmp     w3, #'A' &#13;
            blo     badNumber &#13;
            cmp     w3, #'F' &#13;
            bhi     badNumber &#13;
            sub     w3, w3, #7 // Maps 41h..46h -&gt; 3ah..3fh &#13;
&#13;
            // Okay, the first digit is good. Convert the &#13;
            // string of digits to numeric form: &#13;
&#13;
convert:    ands    xzr, x4, x1  // See whether adding in the current &#13;
            bne     overflow     // digit will cause an overflow. &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_586" aria-label="586"/>            and     x3, x3, #0xf // Convert to numeric in X3. &#13;
&#13;
            // Multiply 128-bit accumulator by 16 and add in &#13;
            // new digit (128-bit extended-precision shift &#13;
            // by 4 bits): &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> lsl     x1, x1, #4  // 128 bits shifted left 4 bits &#13;
            orr     x1, x1, x0, lsr #60 &#13;
            lsl     x0, x0, #4 &#13;
            add     x0, x0, x3  // Never overflows &#13;
&#13;
            // Move on to next character: &#13;
&#13;
            ldrb    w3, [x2, #1]! &#13;
            cmp     w3, #'0' &#13;
            blo     endOfNum &#13;
            cmp     w3, #'9' &#13;
            bls     convert &#13;
&#13;
            and     x3, x3, x5  // Cheesy LC -&gt; UC conversion &#13;
            cmp     x3, #'A' &#13;
            blo     endOfNum &#13;
            cmp     x3, #'F' &#13;
            bhi     endOfNum &#13;
            sub     x3, x3, #7 // Maps 41h..46h -&gt; 3ah..3fh &#13;
            b.al    convert &#13;
&#13;
// If you get to this point, you've successfully converted &#13;
// the string to numeric form: &#13;
&#13;
endOfNum: &#13;
&#13;
            // Because the conversion was successful, this &#13;
            // procedure leaves X2 pointing at the first &#13;
            // character beyond the converted digits.&#13;
            // Therefore, we don't restore X2 from the stack. &#13;
&#13;
            ldp     x4, x3, [sp], #16   // X4 holds old X2. &#13;
            ldp     x4, x5, [sp], #16 &#13;
            msr     nzcv, xzr   // clr c = no error &#13;
&#13;
            ret &#13;
&#13;
// badNumber- Drop down here if the first character in &#13;
//            the string was not a valid digit. &#13;
&#13;
badNumber:  mov     x0, xzr &#13;
            b.al    errorExit &#13;
&#13;
overflow:   mov     x0, #-1     // Return -1 as error on overflow. &#13;
errorExit: &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_587" aria-label="587"/>            mrs     x1, nzcv    // Return error in carry flag. &#13;
            orr     x1, x1, #(1 &lt;&lt; 29) &#13;
            msr     nzcv, x1    // Set c = error. &#13;
            ldp     x2, x3, [sp], #16 &#13;
            ldp     x4, x5, [sp], #16 &#13;
            ret &#13;
            endp    strtoh128 &#13;
&#13;
/////////////////////////////////////////////////////////////&#13;
//&#13;
// Here is the asmMain function: &#13;
&#13;
            proc    asmMain, public &#13;
&#13;
            locals  am &#13;
            byte    am.stack, 64 &#13;
            endl    am &#13;
&#13;
            enter   am.size &#13;
&#13;
// Test hexadecimal conversion: &#13;
&#13;
            lea     x2, hexStr &#13;
            bl      strtoh128 &#13;
            &#13;
            lea     x3, hexStr &#13;
            mov     x2, x0 &#13;
            lea     x0, fmtStr1 &#13;
            mstr    x1, [sp] &#13;
            mstr    x2, [sp, #8] &#13;
            mstr    x3, [sp, #16] &#13;
            bl      printf &#13;
&#13;
allDone:    leave &#13;
            endp    asmMain </code></pre>&#13;
<p class="TX">This code works similarly to that in Listing 9-15. The main difference is the 128-bit shift left by 4 bits <span class="CodeAnnotation" aria-label="annotation1">❶</span> in Listing 9-16. The code shifts X0 to the right 60 bits, then ORs this into X1 after shifting it to the left 4 bits, which shifts 4 bits from X0 into X1.</p>&#13;
<p class="TX">Here’s the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and sample output for Listing 9-16:</p>&#13;
<pre id="pre-766"><code>% <span class="SANS_TheSansMonoCd_W7Bold_11">./build Listing9-16</span> &#13;
% <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing9-16</span> &#13;
Calling Listing9-16: &#13;
strtoh128: value=1234567890abcdeffedcba0987654321, String='1234567890abcdeffedcba0987654321' &#13;
Listing9-16 terminated </code></pre>&#13;
<p class="TX">The hexadecimal-string-to-numeric function worked as expected.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_588" aria-label="588"/>&#13;
<h4 class="H2" id="sec16"><span id="h2-179"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">9.3.3 String to Floating-Point</span></h4>&#13;
<p class="TNI1">Converting a string of characters representing a floating-point number to the 64-bit <span class="SANS_TheSansMonoCd_W5Regular_11">double</span> format is slightly easier than the double-to-string conversion that appeared earlier in this chapter. Because decimal conversion (with no exponent) is a subset of the more general scientific notation conversion, if you can handle scientific notation, you get decimal conversion for free. Beyond that, the basic algorithm is to convert the mantissa characters to an integer form in order to convert to floating-point, then read the (optional) exponent and adjust the <span class="SANS_TheSansMonoCd_W5Regular_11">double</span> exponent accordingly. The algorithm for the conversion is the following:</p>&#13;
<div class="top">&#13;
<p class="ListNumber">  1.  Begin by stripping away any leading space or tab characters (and any other delimiters).</p>&#13;
<p class="ListNumber">  2.  Check for a leading plus (<span class="SANS_TheSansMonoCd_W5Regular_11">+</span>) or minus (<span class="SANS_TheSansMonoCd_W5Regular_11">-</span>) sign character. Skip it if one is present. Set a sign flag to true if the number is negative (false if nonnegative).</p>&#13;
<p class="ListNumber">  3.  Initialize an exponent value to –16. The algorithm will create an integer value from the mantissa digits in the string. As double-precision floats support a maximum of 16 significant digits, initializing the exponent to –16 accounts for this.</p>&#13;
<p class="ListNumber">  4.  Initialize a significant-digit-counter variable that counts the number of significant digits processed thus far to 16.</p>&#13;
<p class="ListNumber">  5.  If the number begins with any leading 0s, skip over them (do not change the exponent or significant digit counters for leading 0s to the left of the decimal point).</p>&#13;
<p class="ListNumber">  6.  If the scan encounters a decimal point after processing any leading 0s, go to step 11; otherwise, fall through to step 7.</p>&#13;
<p class="ListNumber">  7.  For each nonzero digit to the left of the decimal point, if the significant digit counter is not 0, multiply the integer accumulator by 10 and add in the numeric equivalent of the digit. This is the standard integer conversion. (If the significant digit counter is 0, the algorithm has already processed 16 significant digits and will ignore any additional digits, since the double format cannot represent more than 16 significant digits.)</p>&#13;
<p class="ListNumber">  8.  For each digit to the left of the decimal point, increment the exponent value (originally initialized to –16) by 1.</p>&#13;
<p class="ListNumber">  9.  If the significant digit counter is not 0, decrement the significant digit counter (which will also provide the index into the digit string array).</p>&#13;
<p class="ListNumber">10.  If the first nondigit encountered is not a decimal point, skip to step 14.</p>&#13;
<p class="ListNumber">11.  Skip over the decimal point character.</p>&#13;
<p class="ListNumber">12.  For each digit encountered to the right of the decimal point, continue adding the digits to the integer accumulator as long as the significant digit counter is not 0. If the significant digit counter is greater than 0, decrement it. Also decrement the exponent value.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_589" aria-label="589"/>&#13;
<p class="ListNumber">13.  If the algorithm hasn’t encountered at least one decimal digit by this point, report an illegal character exception and return.</p>&#13;
<p class="ListNumber">14.  If the current character is not <span class="SANS_TheSansMonoCd_W5Regular_11">e</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">E</span>, go to step 20. Otherwise, skip over the <span class="SANS_TheSansMonoCd_W5Regular_11">e</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">E</span> character and continue with step 15. (Note that some string formats also allow <span class="SANS_TheSansMonoCd_W5Regular_11">d</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">D</span> to denote a double-precision value. You can also choose to allow this, and possibly check the range of the value if the algorithm encounters <span class="SANS_TheSansMonoCd_W5Regular_11">e</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">E</span> versus <span class="SANS_TheSansMonoCd_W5Regular_11">d</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">D</span>.)</p>&#13;
<p class="ListNumber">15.  If the next character is <span class="SANS_TheSansMonoCd_W5Regular_11">+</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">-</span>, skip over it. Set a flag to true if the sign character is <span class="SANS_TheSansMonoCd_W5Regular_11">-</span>; set it to false otherwise (note that this exponent sign flag is different from the mantissa sign flag set earlier in this algorithm).</p>&#13;
<p class="ListNumber">16.  If the next character is not a decimal digit, report an error.</p>&#13;
<p class="ListNumber">17.  Convert the string of digits starting with the current decimal digit character to an integer.</p>&#13;
<p class="ListNumber">18.  Add the converted integer to the exponent value that was initialized to –16 at the start of this algorithm.</p>&#13;
<p class="ListNumber">19.  If the exponent value is outside the range –324 to +308, report an out-of-range exception.</p>&#13;
<p class="ListNumber">20.  Convert the mantissa, which is currently an integer, to a floating-point value.</p>&#13;
<p class="ListNumber">21.  Take the absolute value of the exponent, preserving the exponent’s sign. This value will be 9 bits or less.</p>&#13;
<p class="ListNumber">22.  If the exponent was positive, then for each set bit in the exponent, multiply the current mantissa value by 10 raised to the power specified by that bit’s position. For example, if bits 4, 2, and 1 are set, multiply the mantissa value by 10<sup>16</sup>, 10<sup>4</sup>, and 10<sup>2</sup>.</p>&#13;
<p class="ListNumber">23.  If the exponent was negative, then for each set bit in the exponent, divide the current mantissa value by 10 raised to the power specified by that bit’s position. For example, if bits 4, 3, and 2 are set, divide the mantissa value by 10<sup>16</sup>, 10<sup>8</sup>, and 10<sup>4</sup> (starting with the larger values and working your way down).</p>&#13;
<p class="ListNumber">24.  If the mantissa is negative (the first sign flag set at the beginning of the algorithm), negate the floating-point number.</p>&#13;
</div>&#13;
<p class="TX">Listing 9-17 provides an implementation of this algorithm, explained section by section. The first part is typical for the sample programs in this book, containing some constant declarations, static data, and the <span class="SANS_TheSansMonoCd_W5Regular_11">getTitle</span> function.</p>&#13;
<pre id="pre-767"><code>// Listing9-17.S &#13;
//&#13;
// Real string to floating-point conversion &#13;
&#13;
            #include    "aoaa.inc"&#13;
&#13;
false       =           0 &#13;
true        =           1 &#13;
tab         =           9 &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_590" aria-label="590"/>            .section    .rodata, "" &#13;
ttlStr:     .asciz      "Listing 9-17"&#13;
fmtStr1:    .asciz      "strToR64: str='%s', value=%e\n"&#13;
errFmtStr:  .asciz      "strToR64 error, code=%ld\n"&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> fStr1a:     .asciz      " 1.234e56"&#13;
fStr1b:     .asciz      "\t-1.234e+56"&#13;
fStr1c:     .asciz      "1.234e-56"&#13;
fStr1d:     .asciz      "-1.234e-56"&#13;
fStr2a:     .asciz      "1.23"&#13;
fStr2b:     .asciz      "-1.23"&#13;
fStr2c:     .asciz      "001.23"&#13;
fStr2d:     .asciz      "-001.23"&#13;
fStr3a:     .asciz      "1"&#13;
fStr3b:     .asciz      "-1"&#13;
fStr4a:     .asciz      "0.1"&#13;
fStr4b:     .asciz      "-0.1"&#13;
fStr4c:     .asciz      "0000000.1"&#13;
fStr4d:     .asciz      "-0000000.1"&#13;
fStr4e:     .asciz      "0.1000000"&#13;
fStr4f:     .asciz      "-0.1000000"&#13;
fStr4g:     .asciz      "0.0000001"&#13;
fStr4h:     .asciz      "-0.0000001"&#13;
fStr4i:     .asciz      ".1"&#13;
fStr4j:     .asciz      "-.1"&#13;
fStr5a:     .asciz      "123456"&#13;
fStr5b:     .asciz      "12345678901234567890"&#13;
fStr5c:     .asciz      "0"&#13;
fStr5d:     .asciz      "1." &#13;
fStr6a:     .asciz      "0.000000000000000000001"&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> .align      3 &#13;
values:     .dword      fStr1a, fStr1b, fStr1c, fStr1d &#13;
            .dword      fStr2a, fStr2b, fStr2c, fStr2d &#13;
            .dword      fStr3a, fStr3b &#13;
            .dword      fStr4a, fStr4b, fStr4c, fStr4d &#13;
            .dword      fStr4e, fStr4f, fStr4g, fStr4h &#13;
            .dword      fStr4i, fStr4j &#13;
            .dword      fStr5a, fStr5b, fStr5c, fStr5d &#13;
            .dword      fStr6a &#13;
            .dword      0 &#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> PotTbl:     .double     1.0e+256 &#13;
            .double     1.0e+128 &#13;
            .double     1.0e+64 &#13;
            .double     1.0e+32 &#13;
            .double     1.0e+16 &#13;
            .double     1.0e+8 &#13;
            .double     1.0e+4 &#13;
            .double     1.0e+2 &#13;
            .double     1.0e+1 &#13;
            .double     1.0e+0 &#13;
&#13;
            .data &#13;
r8Val:      .double     0.0 &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_591" aria-label="591"/>            .code &#13;
            .extern     printf &#13;
&#13;
///////////////////////////////////////////////////////////&#13;
//&#13;
// Return program title to C++ program: &#13;
&#13;
            proc    getTitle, public &#13;
            lea     x0, ttlStr &#13;
            ret &#13;
            endp    getTitle </code></pre>&#13;
<p class="TX">The read-only section contains various test strings that this program will convert into floating-point values <span class="CodeAnnotation" aria-label="annotation1">❶</span>. These test strings were carefully chosen to test most of the (successful) paths through the <span class="SANS_TheSansMonoCd_W5Regular_11">strToR64</span> function. To reduce the size of the main program, Listing 9-17 processes these strings in a loop. The array of pointers <span class="CodeAnnotation" aria-label="annotation2">❷</span> points at each of the test strings, with a NULL pointer (<span class="SANS_TheSansMonoCd_W5Regular_11">0</span>) marking the end of the list. The main program will iterate through these pointers in a loop to test the input strings.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">PotTbl</span> (powers-of-10 table) array <span class="CodeAnnotation" aria-label="annotation3">❸</span> contains various powers of 10. The <span class="SANS_TheSansMonoCd_W5Regular_11">strToR64</span> function uses this table to convert a decimal exponent (in integer format) to an appropriate power of 10:</p>&#13;
<pre id="pre-768"><code>// Listing9-17.S (cont.) &#13;
//&#13;
// strToR64 &#13;
//&#13;
// On entry: &#13;
//&#13;
//  X0- Points at a string of characters that represent a &#13;
//      floating-point value &#13;
//&#13;
// On return: &#13;
//&#13;
//  D0- Converted result &#13;
//  X0- On return, X0 points at the first character this &#13;
//      routine couldn't convert (if no error). &#13;
//&#13;
//  C-  Carry flag is clear if no error, set if error. &#13;
//      X7 is preserved if an error, X1 contains an &#13;
//      error code if an error occurs (else X1 is &#13;
//      preserved). &#13;
&#13;
            proc    strToR64 &#13;
&#13;
            locals  sr &#13;
            qword   sr.x1x2 &#13;
            qword   sr.x3x4 &#13;
            qword   sr.x5x6 &#13;
            qword   sr.x7x0 &#13;
            dword   sr.d1 &#13;
            byte    sr.stack, 64    // Not really needed, but ... &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_592" aria-label="592"/>            endl    sr &#13;
&#13;
            enter   sr.size &#13;
&#13;
// Defines to give registers more &#13;
// meaningful names: &#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> #define mant    x1      // Mantissa value &#13;
#define sigDig  x2      // Mantissa significant digits &#13;
#define expAcc  x2      // Exponent accumulator &#13;
#define sign    w3      // Mantissa sign &#13;
#define fpExp   x4      // Exponent &#13;
#define expSign w5      // Exponent sign &#13;
#define ch      w6      // Current character &#13;
#define xch     x6      // Current character (64 bits) &#13;
#define ten     x7      // The value 10 &#13;
&#13;
            // Preserve the registers this &#13;
            // code modifies: &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> stp     x1, x2, [fp, #sr.x1x2] &#13;
            stp     x3, x4, [fp, #sr.x3x4] &#13;
            stp     x5, x6, [fp, #sr.x5x6] &#13;
            stp     x7, x0, [fp, #sr.x7x0] &#13;
            str     d1,     [fp, #sr.d1  ] &#13;
&#13;
            // Useful initialization: &#13;
&#13;
            mov     fpExp, xzr      // X3 Decimal exponent value &#13;
            mov     mant, xzr       // X0 Mantissa value   &#13;
            mov     sign, wzr       // W2 Assume nonnegative. &#13;
&#13;
            // Initialize sigDig with 16, the number of &#13;
            // significant digits left to process. &#13;
&#13;
            mov     sigDig, #16     // X1 &#13;
&#13;
            // Verify that X0 is not NULL. &#13;
&#13;
            cmp     x0, xzr &#13;
            beq     refNULL </code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">strToR64</span> function uses <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span> statements <span class="CodeAnnotation" aria-label="annotation1">❶</span> to create meaningful, more readable names for the local variables it maintains in various registers.</p>&#13;
<p class="TX">Although this function uses only registers X0 through X7 and D1 (which are all volatile in the ARM ABI), this function preserves all the registers it modifies <span class="CodeAnnotation" aria-label="annotation2">❷</span>. In assembly language, it’s always good programming style to preserve modified registers. This code does not preserve X0 (assuming a successful conversion) because it returns X0 pointing at the end of the (successfully) converted string as a function result. Note that this code returns the main function result in D0.</p>&#13;
<p class="TX">After function initialization, the <span class="SANS_TheSansMonoCd_W5Regular_11">strToR64</span> function begins by skipping all whitespace (spaces and tabs) at the beginning of the string:</p>&#13;
<pre id="pre-769"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_593" aria-label="593"/>// Listing9-17.S (cont.) &#13;
&#13;
            sub     x0, x0, #1      // Will inc'd in loop &#13;
whileWSLoop: &#13;
            ldrb    ch, [x0, #1]!   // W5 &#13;
            cmp     ch, #' ' &#13;
            beq     whileWSLoop &#13;
            cmp     ch, #tab &#13;
            beq     whileWSLoop </code></pre>&#13;
<p class="TX">This code exits with <span class="SANS_TheSansMonoCd_W5Regular_11">ch</span> (W6) containing the first non-whitespace character and X0 pointing at that character in memory.</p>&#13;
<p class="TX">Immediately after any whitespace characters, the string may optionally contain a single <span class="SANS_TheSansMonoCd_W5Regular_11">+</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">-</span>character. This code skips either of these characters (if present) and sets the mantissa sign flag (<span class="SANS_TheSansMonoCd_W5Regular_11">sign</span>) to 1 if a <span class="SANS_TheSansMonoCd_W5Regular_11">-</span> character is present:</p>&#13;
<pre id="pre-770"><code>// Listing9-17.S (cont.) &#13;
&#13;
            // Check for + or - &#13;
&#13;
            cmp     ch, #'+' &#13;
            beq     skipSign &#13;
&#13;
            cmp     ch, #'-' &#13;
            cinc    sign, sign, eq  // W2 &#13;
            bne     noSign &#13;
&#13;
skipSign:   ldrb    ch, [x0, #1]!   // Skip '-' &#13;
noSign: </code></pre>&#13;
<p class="TX">Immediately after a sign character (or if there isn’t an optional sign character), the string must contain a decimal digit character or a decimal point. This code tests for one of these two conditions and reports a conversion error if the condition fails:</p>&#13;
<pre id="pre-771"><code>// Listing9-17.S (cont.) &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> sub     ch, ch, #'0'    // Quick test for '0' to '9' &#13;
            cmp     ch, #9 &#13;
            bls     scanDigits      // Branch if '0' to '9' &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> cmp     ch, #'.'-'0'    // Check for '.' &#13;
            bne     convError &#13;
&#13;
            // If the first character is a decimal point, &#13;
            // the second character needs to be a &#13;
            // decimal digit. &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> ldrb    ch, [x0, #1]!   // W5 Skip period. &#13;
            cmp     ch, #'0' &#13;
            blo     convError &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_594" aria-label="594"/>            cmp     ch, #'9' &#13;
            bhi     convError &#13;
            b.al    whileDigit2 </code></pre>&#13;
<p class="TX">This code uses a common trick to compare for a character in the range <span class="SANS_TheSansMonoCd_W5Regular_11">'0'</span> through <span class="SANS_TheSansMonoCd_W5Regular_11">'9'</span>. It subtracts the ASCII code for <span class="SANS_TheSansMonoCd_W5Regular_11">'0'</span> from the character <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If the character was in the range <span class="SANS_TheSansMonoCd_W5Regular_11">'0'</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">'9'</span>, this translates its value to the range 0 to 9. A single <i>unsigned</i> comparison against the value 9 tells us whether the character value was in the range <span class="SANS_TheSansMonoCd_W5Regular_11">'0'</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">'9'</span>. If so, this code transfers control to the code that will process digits to the left of the decimal point.</p>&#13;
<p class="TX">Because the code has subtracted <span class="SANS_TheSansMonoCd_W5Regular_11">'0'</span> from the character’s ASCII code, it cannot simply compare the character against a period. The <span class="SANS_TheSansMonoCd_W5Regular_11">cmp ch, #'.'-'0'</span> instruction correctly compares the character against a period by subtracting the character code for <span class="SANS_TheSansMonoCd_W5Regular_11">'0'</span> from <span class="SANS_TheSansMonoCd_W5Regular_11">'.'</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If the character was a period, the code will verify that the following character is also a digit <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">Next, the code starting at <span class="SANS_TheSansMonoCd_W5Regular_11">scanDigits</span> processes the mantissa digits to the left of the decimal point (if present):</p>&#13;
<pre id="pre-772"><code>// Listing9-17.S (cont.) &#13;
//&#13;
// Scan for digits at the beginning of the number: &#13;
&#13;
scanDigits: mov     ten, #10        // X7 used to multiply by 10 &#13;
            add     ch, ch, #'0'    // Restore character. &#13;
 whileADigit: &#13;
            sub     ch, ch, #'0'    // Quick way to test for &#13;
            cmp     ch, #10         // a range and convert &#13;
            bhs     notDigit        // to an integer &#13;
&#13;
            // Ignore any leading 0s in the number. &#13;
            // You have a leading '0' if the mantissa is 0 &#13;
            // and the current character is '0'. &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> cmp     mant, xzr       // Ignore leading 0s. &#13;
            ccmp    ch, #0, #0, eq &#13;
            beq     Beyond16 &#13;
&#13;
            // Each digit to the left of the decimal &#13;
            // point increases the number by an &#13;
            // additional power of 10. Deal with that &#13;
            // here. &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> add     fpExp, fpExp, #1 &#13;
&#13;
            // Save all the significant digits but ignore &#13;
            // any digits beyond the 16th digit. &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> cmp     sigDig, xzr     // X1 &#13;
            beq     Beyond16 &#13;
&#13;
            // Count down the number of significant digits. &#13;
&#13;
            sub     sigDig, sigDig, #1 &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_595" aria-label="595"/>            // Multiply the accumulator (mant) by 10 and &#13;
            // add in the current digit. Note that ch &#13;
            // has already been converted to an integer. &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> madd    mant, mant, ten, xch    // X0, X6, X5 &#13;
&#13;
            // Because you multiplied the exponent by 10, &#13;
            // you need to undo the increment of fpExp. &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> sub     fpExp, fpExp, #1 &#13;
&#13;
Beyond16:   ldrb    ch, [x0, #1]!   // Get next char. &#13;
            b.al    whileADigit </code></pre>&#13;
<p class="TX">This code skips over leading 0s by noting that if the mantissa value is 0 and the current character is <span class="SANS_TheSansMonoCd_W5Regular_11">'0'</span>, it’s a leading 0 <span class="CodeAnnotation" aria-label="annotation1">❶</span>. For each mantissa digit the code fetches, it adjusts the mantissa value by multiplying the mantissa by 10 and adding in the numeric equivalent of the digit <span class="CodeAnnotation" aria-label="annotation4">❹</span>. However, if the loop processes more than 16 significant digits <span class="CodeAnnotation" aria-label="annotation3">❸</span>, it does not add in the character to the <span class="SANS_TheSansMonoCd_W5Regular_11">mant</span> accumulator (because double-precision objects support a maximum of 16 significant digits). If the input string exceeds 16 significant digits, the code increments the <span class="SANS_TheSansMonoCd_W5Regular_11">fpExp</span> variable <span class="CodeAnnotation" aria-label="annotation2">❷</span> to track the eventual exponent of the number. The code undoes this increment <span class="CodeAnnotation" aria-label="annotation5">❺</span> if the mantissa was multiplied by 10 (in which case the exponent does not need to be incremented).</p>&#13;
<p class="TX">The next section of code handles the digits after a decimal point:</p>&#13;
<pre id="pre-773"><code>// Listing9-17.S (cont.) &#13;
//&#13;
// If you encountered a nondigit character, &#13;
// check for a decimal point: &#13;
&#13;
notDigit: &#13;
            cmp     ch, #'.'-'0'    // See if a decimal point. &#13;
            bne     whileDigit2 &#13;
&#13;
// Okay, process any digits to the right of the decimal point. &#13;
// If this code falls through from the above, it skips the &#13;
// decimal point. &#13;
&#13;
getNextChar: &#13;
            ldrb    ch, [x0, #1]!   // Get the next character. &#13;
whileDigit2: &#13;
            sub     ch, ch, #'0' &#13;
            cmp     ch, #10 &#13;
            bhs     noDigit2 &#13;
&#13;
            // Ignore digits after the 16th significant &#13;
            // digit but don't count leading 0s &#13;
            // as significant digits: &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> cmp     mant, xzr            // Ignore leading 0s. &#13;
            ccmp    ch, wzr, #0, eq &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_596" aria-label="596"/>            ccmp    sigDig, xzr, #0, eq  // X2 &#13;
            beq     getNextChar &#13;
&#13;
            // Each digit to the right of the decimal point decreases &#13;
            // the number by an additional power of 10. Deal with &#13;
            // that here. &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> sub     fpExp, fpExp, #1 &#13;
&#13;
            // Count down the number of significant digits: &#13;
&#13;
            sub     sigDig, sigDig, #1 &#13;
&#13;
            // Multiply the accumulator (mant) by 10 and &#13;
            // add in the current digit. Note that ch &#13;
            // has already been converted to an integer: &#13;
&#13;
            Madd    mant, mant, ten, xch    // X1, X7, X6 &#13;
            b.al    getNextChar </code></pre>&#13;
<p class="TX">The code is similar to the digits to the left, except that it decrements the running exponent value for each digit <span class="CodeAnnotation" aria-label="annotation2">❷</span>. This is because the mantissa is being maintained as an integer, and the code continues to insert the fractional digits into the mantissa by multiplying by 10 and adding in the digit’s value. Should the total number of significant digits exceed 16 (not including leading 0s <span class="CodeAnnotation" aria-label="annotation1">❶</span>), this function ignores any further digits.</p>&#13;
<p class="TX">Next up is processing the string’s optional exponent:</p>&#13;
<pre id="pre-774"><code>// Listing9-17.S (cont.) &#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> noDigit2: &#13;
            mov     expSign, wzr    // W5 Initialize exp sign. &#13;
            mov     expAcc, xzr     // X2 Initialize exponent. &#13;
            cmp     ch, #'e'-'0' &#13;
            beq     hasExponent &#13;
            cmp     ch, #'E'-'0' &#13;
            bne     noExponent &#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> hasExponent: &#13;
            ldrb    ch, [x0, #1]!           // Skip the "E".&#13;
            cmp     ch, #'-'                // W6 &#13;
            cinc    expSign, expSign, eq    // W5 &#13;
            beq     doNextChar_2 &#13;
            cmp     ch, #'+' &#13;
            bne     getExponent &#13;
&#13;
doNextChar_2: &#13;
            ldrb    ch, [x0, #1]!   // Skip '+' or '-'. &#13;
&#13;
// Okay, you're past the "E" and the optional sign at this &#13;
// point. You must have at least one decimal digit. &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_597" aria-label="597"/><span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> getExponent: &#13;
            sub     ch, ch, #'0'    // W5 &#13;
            cmp     ch, #10 &#13;
            bhs     convError &#13;
&#13;
            mov     expAcc, xzr     // Compute exponent value in X2. &#13;
ExpLoop:    ldrb    ch, [x0], #1 &#13;
            sub     ch, ch, #'0' &#13;
            cmp     ch, #10 &#13;
            bhs     ExpDone &#13;
&#13;
            madd    expAcc, expAcc, ten, xch    // X2, X7, X6 &#13;
            b.al    ExpLoop &#13;
&#13;
// If the exponent was negative, negate your computed result: &#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> ExpDone: &#13;
            cmp     expSign, #false // W5 &#13;
            beq     noNegExp &#13;
&#13;
            neg     expAcc, expAcc  // X2 &#13;
&#13;
noNegExp: &#13;
&#13;
// Add in the computed decimal exponent with the exponent &#13;
// accumulator: &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> add     fpExp, fpExp, expAcc    // X4, X2 &#13;
&#13;
noExponent: &#13;
&#13;
// Verify that the exponent is from -324 to +308 (which &#13;
// is the maximum dynamic range for a 64-bit FP value): &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> mov     x5, #308        // Reuse expSign here. &#13;
            cmp     fpExp, x5 &#13;
            bgt     voor            // Value out of range &#13;
            mov     x5, #-324 &#13;
            cmp     fpExp, x5 &#13;
            blt     voor &#13;
          <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> ucvtf   d0, mant        // X1 </code></pre>&#13;
<p class="TX">This code first checks for an <span class="SANS_TheSansMonoCd_W5Regular_11">e</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">E</span> character denoting the start of an exponent <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If the string has an exponent, the code checks for an optional sign character <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If a <span class="SANS_TheSansMonoCd_W5Regular_11">-</span> character is present, the code sets <span class="SANS_TheSansMonoCd_W5Regular_11">expSign</span> to 1 (default is 0) to specify a negative exponent.</p>&#13;
<p class="TX">After processing the exponent sign, the code expects decimal digits <span class="CodeAnnotation" aria-label="annotation3">❸</span> and converts these digits to an integer (held in the <span class="SANS_TheSansMonoCd_W5Regular_11">expAcc</span> variable). If <span class="SANS_TheSansMonoCd_W5Regular_11">expSign</span> is true (nonzero), the code negates the value in <span class="SANS_TheSansMonoCd_W5Regular_11">expAcc</span> <span class="CodeAnnotation" aria-label="annotation4">❹</span>. The exponent code then adds <span class="SANS_TheSansMonoCd_W5Regular_11">expAcc</span> to the exponent value obtained when processing the mantissa digits to obtain the actual exponent value <span class="CodeAnnotation" aria-label="annotation5">❺</span>.</p>&#13;
<p class="TX">Finally, the code checks the exponent to verify it’s in the range –324 to +308 <span class="CodeAnnotation" aria-label="annotation6">❻</span>. This is the maximum dynamic range of a 64-bit double-precision <span role="doc-pagebreak" epub:type="pagebreak" id="pg_598" aria-label="598"/>floating-point value. If the exponent is out of this range, the code returns a value-out-of-range error.</p>&#13;
<p class="TX">At this point, the code has completely processed the string data, and the X0 register points at the first byte in memory that is not part of the floating-point value. To convert the mantissa and exponent values from integers into a double-precision value, first convert the mantissa value (in <span class="SANS_TheSansMonoCd_W5Regular_11">mant</span>) to a floating-point value by using the <span class="SANS_TheSansMonoCd_W5Regular_11">ucvtf</span> instruction <span class="CodeAnnotation" aria-label="annotation7">❼</span>.</p>&#13;
<p class="TX">Next, processing the exponent is somewhat tricky. The <span class="SANS_TheSansMonoCd_W5Regular_11">fpExp</span> variable contains the decimal exponent, but this is an integer value representing a power of 10. You must multiply the value in D0 (the mantissa) by 10<i><sup>fpExp</sup></i>, but unfortunately, the ARM instruction set does not provide an instruction that computes 10 raised to some integer power. You’ll have to write your own code to do this:</p>&#13;
<pre id="pre-775"><code>// Listing9-17.S (cont.) &#13;
//&#13;
// Okay, you have the mantissa into D0. Now multiply &#13;
// D0 by 10 raised to the value of the computed exponent &#13;
// (currently in fpExp). &#13;
//&#13;
// This code uses power-of-10 tables to help make the &#13;
// computation a little more accurate. &#13;
//&#13;
// You want to determine which power of 10 is just less than the &#13;
// value of our exponent. The powers of 10 you are checking are &#13;
// 10**256, 10**128, 10**64, 10**32, and so on. A slick way to &#13;
// check is by shifting the bits in the exponent &#13;
// to the left. Bit #8 is the 256 bit, so if this bit is set, &#13;
// your exponent is &gt;= 10**256. If not, check the next bit down &#13;
// to see if your exponent &gt;= 10**128, and so on. &#13;
&#13;
            mov     x1, -8      // Initial index into power-of-10 table &#13;
            cmp     fpExp, xzr  // X4 &#13;
            bpl     positiveExponent &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> // Handle negative exponents here: &#13;
&#13;
            neg     fpExp, fpExp &#13;
            lsl     fpExp, fpExp, #55   // Bits 0..8 -&gt; 55..63 &#13;
            lea     x6, PotTbl &#13;
 <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> whileExpNE0: &#13;
            add     x1, x1, #8          // Next index into PotTbl. &#13;
            adds    fpExp, fpExp, fpExp // (LSL) Need current POT? &#13;
            bcc     testExp0 &#13;
&#13;
            ldr     d1, [x6, x1] &#13;
            fdiv    d0, d0, d1 &#13;
&#13;
testExp0:   cmp     fpExp, xzr &#13;
            bne     whileExpNE0 &#13;
            b.al    doMantissaSign &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_599" aria-label="599"/>// Handle positive exponents here. &#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> positiveExponent: &#13;
            lea     x6, PotTbl &#13;
            lsl     fpExp, fpExp, #55       // Bits 0..8 -&gt; 55..63 &#13;
            b.al    testExpis0_2 &#13;
&#13;
whileExpNE0_2: &#13;
            add     x1, x1, #8 &#13;
            adds    fpExp, fpExp, fpExp     // (LSL) &#13;
            bcc     testExpis0_2 &#13;
&#13;
            ldr     d1, [x6, x1] &#13;
            fmul    d0, d0, d1 &#13;
&#13;
testExpis0_2: &#13;
            cmp     fpExp, xzr &#13;
            bne     whileExpNE0_2 </code></pre>&#13;
<p class="TX">This code uses two nearly identical sections of code to handle negative <span class="CodeAnnotation" aria-label="annotation1">❶</span> and positive <span class="CodeAnnotation" aria-label="annotation3">❸</span> exponents. The difference between the two pieces of code is the choice of an <span class="SANS_TheSansMonoCd_W5Regular_11">fdiv</span> instruction (for negative exponents) or an <span class="SANS_TheSansMonoCd_W5Regular_11">fmul</span> instruction (for positive exponents). Each section contains a loop <span class="CodeAnnotation" aria-label="annotation2">❷</span> that steps through each entry of the <span class="SANS_TheSansMonoCd_W5Regular_11">PotTbl</span> (powers-of-10) table. The exponent is a 9-bit value, as the maximum unsigned exponent value is 324, which fits in 9 bits or fewer.</p>&#13;
<p class="TX">For each set bit in this integer, the code must multiply the floating-point result by the corresponding power of 10 from <span class="SANS_TheSansMonoCd_W5Regular_11">PotTbl</span>. For example, if bit 9 is set, multiply or divide the mantissa by 10<sup>256</sup> (the first entry in <span class="SANS_TheSansMonoCd_W5Regular_11">PotTbl</span>); if bit 8 is set, multiply or divide the mantissa by 10<sup>128</sup> (the second entry in <span class="SANS_TheSansMonoCd_W5Regular_11">PotTbl</span>), ...; if bit 0 is set, multiply or divide the mantissa by 10<sup>0</sup> (the last entry in <span class="SANS_TheSansMonoCd_W5Regular_11">PotTbl</span>). The two loops in the code accomplish this by moving the 9 bits into the HO positions of <span class="SANS_TheSansMonoCd_W5Regular_11">fpExp</span>, then shifting the bits out one at a time and doing the multiplication (for positive exponents) or division (for negative exponents) if the carry flag is set, using successive entries from <span class="SANS_TheSansMonoCd_W5Regular_11">PotTbl</span>.</p>&#13;
<p class="TX">Next, the code negates the value if it was negative (the flag is held in the sign variable) and returns the floating-point value to the caller in the D0 register:</p>&#13;
<pre id="pre-776"><code>// Listing9-17.S (cont.) &#13;
&#13;
doMantissaSign: &#13;
            cmp     sign, #false            // W3 &#13;
            beq     mantNotNegative &#13;
&#13;
            fneg    d0, d0 &#13;
&#13;
// Successful return here. Note: does not restore X0 &#13;
// on successful conversion. &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_600" aria-label="600"/>mantNotNegative: &#13;
            msr     nzcv, xzr   // clr c = no error &#13;
            ldp     x1, x2, [fp, #sr.x1x2] &#13;
            ldp     x3, x4, [fp, #sr.x3x4] &#13;
            ldp     x5, x6, [fp, #sr.x5x6] &#13;
            ldr     x7,     [fp, #sr.x7x0] &#13;
            ldr     d1,     [fp, #sr.d1  ] &#13;
            leave </code></pre>&#13;
<p class="TX">On a successful conversion, this function returns X0 pointing at the first character beyond the floating-point string. This code does not restore X0 to its original value on a successful conversion.</p>&#13;
<p class="TX">The last part of the <span class="SANS_TheSansMonoCd_W5Regular_11">strToR64</span> function is the error-handling code:</p>&#13;
<pre id="pre-777"><code>// Listing9-17.S (cont.) &#13;
//&#13;
// Error returns down here. Returns error code in X0: &#13;
&#13;
refNULL:    mov     x1, #-3 &#13;
            b.al    ErrorExit &#13;
&#13;
convError:  mov     x1, #-2 &#13;
            b.al    ErrorExit &#13;
&#13;
voor:       mov     x1, #-1 // Value out of range &#13;
            b.al    ErrorExit &#13;
&#13;
illChar:    mov     x1, #-4 &#13;
&#13;
// Note: on error, this code restores X0. &#13;
&#13;
ErrorExit: &#13;
            str     x1, [fp, #sr.x1x2]  // Return error code in X1. &#13;
            mrs     x1, nzcv            // Return error in carry flag. &#13;
            orr     x1, x1, #(1 &lt;&lt; 29) &#13;
            msr     nzcv, x1            // Set c = error. &#13;
            ldp     x1, x2, [fp, #sr.x1x2] &#13;
            ldp     x3, x4, [fp, #sr.x3x4] &#13;
            ldp     x5, x6, [fp, #sr.x5x6] &#13;
            ldp     x7, x0, [fp, #sr.x7x0] &#13;
            ldr     d1,     [fp, #sr.d1  ] &#13;
            leave &#13;
&#13;
            endp    strToR64 </code></pre>&#13;
<p class="TX">Each error returns a special error code in X1. So this code does not restore X1 upon return. Unlike the successful return, the error return code will restore X0 to its original value.</p>&#13;
<p class="TX">Finally, the <span class="SANS_TheSansMonoCd_W5Regular_11">asmMain</span> function consists of a loop that processes each of the strings by using the pointers found in the <span class="SANS_TheSansMonoCd_W5Regular_11">values</span> array. It simply steps through each pointer, passing it along to <span class="SANS_TheSansMonoCd_W5Regular_11">strToR64</span>, until it encounters a NULL (0) value:</p>&#13;
<pre id="pre-778"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_601" aria-label="601"/>// Listing9-17.S (cont.) &#13;
&#13;
// Here is the asmMain function: &#13;
&#13;
            proc    asmMain, public &#13;
&#13;
            locals  am &#13;
            dword   am.x20 &#13;
            byte    stack, 64 &#13;
            endl    am &#13;
&#13;
            enter   am.size &#13;
            str     x20, [fp, #am.x20] &#13;
&#13;
// Test floating-point conversion: &#13;
&#13;
            lea     x20, values &#13;
ValuesLp:   ldr     x0, [x20] &#13;
            cmp     x0, xzr &#13;
            beq     allDone &#13;
            bl      strToR64 &#13;
&#13;
            lea     x0, fmtStr1 &#13;
            ldr     x1, [x20] &#13;
            mstr    x1, [sp] &#13;
            mstr    d0, [sp, #8] &#13;
            bl      printf &#13;
            add     x20, x20, #8 &#13;
            b.al    ValuesLp &#13;
&#13;
allDone:    ldr     x20, [fp, #am.x20] &#13;
            leave &#13;
            endp    asmMain </code></pre>&#13;
<p class="TX">Here’s the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and sample output for Listing 9-17:</p>&#13;
<pre id="pre-779"><code>% <span class="SANS_TheSansMonoCd_W7Bold_11">./build Listing9-17</span> &#13;
% <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing9-17</span> &#13;
Calling Listing9-17: &#13;
strToR64: str=' 1.234e56', value=1.234000e+56 &#13;
strToR64: str='    -1.234e+56', value=-1.234000e+56 &#13;
strToR64: str='1.234e-56', value=1.234000e-56 &#13;
strToR64: str='-1.234e-56', value=-1.234000e-56 &#13;
strToR64: str='1.23', value=1.230000e+00 &#13;
strToR64: str='-1.23', value=-1.230000e+00 &#13;
strToR64: str='001.23', value=1.230000e+00 &#13;
strToR64: str='-001.23', value=-1.230000e+00 &#13;
strToR64: str='1', value=1.000000e+00 &#13;
strToR64: str='-1', value=-1.000000e+00 &#13;
strToR64: str='0.1', value=1.000000e-01 &#13;
strToR64: str='-0.1', value=-1.000000e-01 &#13;
strToR64: str='0000000.1', value=1.000000e-01 &#13;
strToR64: str='-0000000.1', value=-1.000000e-01 &#13;
strToR64: str='0.1000000', value=1.000000e-01 &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_602" aria-label="602"/>strToR64: str='-0.1000000', value=-1.000000e-01 &#13;
strToR64: str='0.0000001', value=1.000000e-07 &#13;
strToR64: str='-0.0000001', value=-1.000000e-07 &#13;
strToR64: str='.1', value=1.000000e-01 &#13;
strToR64: str='-.1', value=-1.000000e-01 &#13;
strToR64: str='123456', value=1.234560e+05 &#13;
strToR64: str='12345678901234567890', value=1.234568e+19 &#13;
strToR64: str='0', value=0.000000e+00 &#13;
strToR64: str='1.', value=1.000000e+00 &#13;
strToR64: str='0.000000000000000000001', value=1.000000e-17 &#13;
Listing9-17 terminated </code></pre>&#13;
<p class="TX">It would be interesting to modify the real-to-string and string-to-real programs to perform a “round-trip” conversion from real to string to real, to see whether you get roughly the same result back that you put in. (Because of rounding and truncation errors, you won’t always get the same exact value back, but it should be close.) I will leave it up to you to try this out.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h3 class="H1" id="sec17"><span id="h1-108"/><span class="SANS_Futura_Std_Bold_B_11">9.4 Other Numeric Conversions</span></h3>&#13;
<p class="TNI1">This chapter has presented the more common numeric conversion algorithms: decimal integer, hexadecimal integer, and floating-point. Other conversions are sometimes useful. For example, some applications might need octal (base-8) conversions or conversions in an arbitrary base. For bases 2 through 9, the algorithm is virtually the same as for decimal integer conversions, except that rather than dividing by 10 (and taking the remainder), you divide by the desired base. Indeed, it would be fairly simple to write a generic function to which you pass the radix (base) to get the appropriate conversion.</p>&#13;
<p class="TX">Of course, base-2 output is nearly trivial because the ARM CPU stores values internally in binary. All you need do is shift bits out of the number (into the carry flag) and output a <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> based on the state of the carry. Base-4 and base-8 conversions are also fairly simple, working with groups of 2 or 3 bits (respectively).</p>&#13;
<p class="TX">Some floating-point formats do not follow the IEEE standard. To handle these cases, write a function that converts such formats to the IEEE form, if possible, then use the examples from this chapter to convert between floating-point and string. If you need to work with such formats directly, the algorithms in this chapter should prove sufficiently general and easy to modify for your use.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h3 class="H1" id="sec18"><span id="h1-109"/><span class="SANS_Futura_Std_Bold_B_11">9.5 Moving On</span></h3>&#13;
<p class="TNI1">This long chapter covered two main topics: converting numeric values to strings and converting strings to numeric values. For the former, this chapter covered numeric-to-hexadecimal conversion (bytes, hwords, words, dwords, and qwords), numeric-to-unsigned decimal conversion (64- and 128-bit), and numeric-to-signed decimal conversion (64- and 128-bit). It <span role="doc-pagebreak" epub:type="pagebreak" id="pg_603" aria-label="603"/>also discussed formatted conversion for controlling the output format when doing numeric-to-string conversions, and formatted floating-point-to-string conversions for decimal and exponential formats, as well as computing the number of print positions a conversion requires.</p>&#13;
<p class="TX">While discussing string-to-numeric conversions, this chapter covered converting unsigned decimal strings to numeric forms, signed decimal strings to numeric forms, hexadecimal strings to numeric forms, and floating-point strings to double-precision numeric forms. Finally, the chapter briefly discussed other possible numeric output formats.</p>&#13;
<p class="TX">Although this book will continue to use the C <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span> function for formatted output, you can use the procedures in this chapter to avoid relying on C when writing your own assembly code. These procedures also form the basis for an assembly language library you can use to simplify writing assembly code.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h3 class="H1" id="sec19"><span id="h1-110"/><span class="SANS_Futura_Std_Bold_B_11">9.6 For More Information</span></h3>&#13;
<ul class="ul">&#13;
<li class="BL">Donald Knuth’s <i>The Art of Computer Programming, Volume 2: Seminumerical Algorithms</i>, 3rd edition (Addison-Wesley Professional, 1997) contains lots of useful information about decimal arithmetic and extended-precision arithmetic, though the text is generic and doesn’t describe how to do this in ARM assembly language.</li>&#13;
<li class="BL">For more information on division via multiplication by a reciprocal, see the University of Iowa tutorial at <i><a href="http://homepage.cs.uiowa.edu/~jones/bcd/divide.html">http://<wbr/>homepage<wbr/>.cs<wbr/>.uiowa<wbr/>.edu<wbr/>/~jones<wbr/>/bcd<wbr/>/divide<wbr/>.html</a></i>.</li>&#13;
</ul>&#13;
<aside class="box" aria-label="box-27">&#13;
<p class="BH" id="box-27"><span class="SANS_Dogma_OT_Bold_B_11">TEST YOURSELF</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  1.  How many hexadecimal digits will</span> <span class="SANS_TheSansMonoCd_W5Regular_11">hwtoStr</span> <span class="SANS_Futura_Std_Book_11">produce?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  2.  Explain how to use</span> <span class="SANS_TheSansMonoCd_W5Regular_11">qToStr</span> <span class="SANS_Futura_Std_Book_11">to write a 128-bit hexadecimal output routine.</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  3.  How do you write a signed decimal-to-string conversion if you’re given a function that does an unsigned decimal-to-string conversion?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  4.  What are the parameters for the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">u64toSizeStr</span> <span class="SANS_Futura_Std_Book_11">function?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  5.  What string will</span> <span class="SANS_TheSansMonoCd_W5Regular_11">u64toSizeStr</span> <span class="SANS_Futura_Std_Book_11">produce if the number requires more print positions than specified by the minimum field-width parameter?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  6.  What are the parameters for the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">r64ToStr</span> <span class="SANS_Futura_Std_Book_11">function?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  7.  What string will</span> <span class="SANS_TheSansMonoCd_W5Regular_11">r64ToStr</span> <span class="SANS_Futura_Std_Book_11">produce if the output won’t fit in the string size specified by the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">fWidth</span> <span class="SANS_Futura_Std_Book_11">argument?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  8.  What are the arguments to the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">e64ToStr</span> <span class="SANS_Futura_Std_Book_11">function?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  9.  What is a delimiter character?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">10. What are two possible errors that could occur during a string-to-numeric conversion?</span></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>