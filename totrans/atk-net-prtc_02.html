<html><head></head><body>
<h2 class="h2a" id="ch02"><span epub:type="pagebreak" id="page_11"/><strong><span class="big">2</span></strong><br/><strong>CAPTURING APPLICATION TRAFFIC</strong></h2>&#13;
<p class="noindent_first">Surprisingly, capturing useful traffic can be a challenging aspect of protocol analysis. This chapter describes two different capture techniques: <em>passive</em> and <em>active</em>. Passive capture doesn’t directly interact with the traffic. Instead, it extracts the data as it <em>travels on the wire</em>, which should be familiar from tools like Wireshark. You’ll find that different applications provide different mechanisms (which have their own advantages and disadvantages) to redirect traffic. Active capture interferes with traffic between a client application and the server; this has great power but can cause some complications. You can think of active capture in terms of proxies or even a man-in-the-middle attack. Let’s look at both active and passive techniques in more depth.</p>&#13;
<h3 class="h3" id="ch00lev1sec16"><span epub:type="pagebreak" id="page_12"/><strong>Passive Network Traffic Capture</strong></h3>&#13;
<p class="noindent">Passive capture is a relatively easy technique: it doesn’t typically require any specialist hardware, nor do you usually need to write your own code. <a href="../Text/ch02.xhtml#ch2fig1">Figure 2-1</a> shows a common scenario: a client and server communicating via Ethernet over a network.</p>&#13;
<div class="image"><img alt="image" src="../Images/f02-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch2fig1"/><em>Figure 2-1: An example of passive network capture</em></p>&#13;
<p class="indent">Passive network capture can take place either on the network by tapping the traffic as it passes in some way or by sniffing directly on either the client or server host.</p>&#13;
<h3 class="h3" id="ch00lev1sec17"><strong>Quick Primer for Wireshark</strong></h3>&#13;
<p class="noindent">Wireshark is perhaps the most popular packet-sniffing application available. It’s cross platform and easy to use, and it comes with many built-in protocol analysis features. In <a href="../Text/ch05.xhtml#ch05">Chapter 5</a> you’ll learn how to write a dissector to aid in protocol analysis, but for now, let’s set up Wireshark to capture IP traffic from the network.</p>&#13;
<p class="indent">To capture traffic from an Ethernet interface (wired or wireless), the capturing device must be in <em>promiscuous mode</em>. A device in promiscuous mode receives and processes any Ethernet frame it sees, even if that frame wasn’t destined for that interface. Capturing an application running on the same computer is easy: just monitor the outbound network interface or the local loopback interface (better known as localhost). Otherwise, you might need to use networking hardware, such as a hub or a configured switch, to ensure traffic is sent to your network interface.</p>&#13;
<p class="indent"><a href="../Text/ch02.xhtml#ch2fig2">Figure 2-2</a> shows the default view when capturing traffic from an Ethernet interface.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_13"/><img alt="image" src="../Images/f02-02.jpg"/></div>&#13;
<p class="figcap"><a id="ch2fig2"/><em>Figure 2-2: The default Wireshark view</em></p>&#13;
<p class="indent">There are three main view areas. Area <span class="ent">➊</span> shows a timeline of raw packets captured off the network. The timeline provides a list of the source and destination IP addresses as well as decoded protocol summary information. Area <span class="ent">➋</span> provides a dissected view of the packet, separated into distinct protocol layers that correspond to the OSI network stack model. Area <span class="ent">➌</span> shows the captured packet in its raw form.</p>&#13;
<p class="indent">The TCP network protocol is stream based and designed to recover from dropped packets or data corruption. Due to the nature of networks and IP, there is no guarantee that packets will be received in a particular order. Therefore, when you are capturing packets, the timeline view might be difficult to interpret. Fortunately, Wireshark offers dissectors for known protocols that will normally reassemble the entire stream and provide all the information in one place. For example, highlight a packet in a TCP connection in the timeline view and then select <strong>Analyze</strong> ▸ <strong>Follow TCP Stream</strong> from the main menu. A dialog similar to <a href="../Text/ch02.xhtml#ch2fig3">Figure 2-3</a> should appear. For protocols without a dissector, Wireshark can decode the stream and present it in an easy-to-view dialog.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_14"/><img alt="image" src="../Images/f02-03.jpg"/></div>&#13;
<p class="figcap"><a id="ch2fig3"/><em>Figure 2-3: Following a TCP stream</em></p>&#13;
<p class="indent">Wireshark is a comprehensive tool, and covering all of its features is beyond the scope of this book. If you’re not familiar with it, obtain a good reference, such as <em>Practical Packet Analysis, 3rd Edition</em> (No Starch Press, 2017), and learn many of its useful features. Wireshark is indispensable for analyzing application network traffic, and it’s free under the General Public License (GPL).</p>&#13;
<h3 class="h3" id="ch00lev1sec18"><strong>Alternative Passive Capture Techniques</strong></h3>&#13;
<p class="noindent">Sometimes using a packet sniffer isn’t appropriate, for example, in situations when you don’t have permission to capture traffic. You might be doing a penetration test on a system with no administrative access or a mobile device with a limited privilege shell. You might also just want to ensure that you look at traffic only for the application you’re testing. That’s not always easy to do with packet sniffing unless you correlate the traffic based on time. In this section, I’ll describe a few techniques for extracting network traffic from a local application without using a packet-sniffing tool.</p>&#13;
<h4 class="h4" id="ch00lev1sec19"><strong><em>System Call Tracing</em></strong></h4>&#13;
<p class="noindent">Many modern operating systems provide two modes of execution. <em>Kernel mode</em> runs with a high level of privilege and contains code implementing the OS’s core functionality. <em>User mode</em> is where everyday processes run. The kernel provides services to user mode by exporting a collection of special system calls (see <a href="../Text/ch02.xhtml#ch2fig4">Figure 2-4</a>), allowing users to access files, create processes—and most important for our purposes—connect to networks.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_15"/><img alt="image" src="../Images/f02-04.jpg"/></div>&#13;
<p class="figcap"><a id="ch2fig4"/><em>Figure 2-4: An example of user-to-kernel network communication via system calls</em></p>&#13;
<p class="indent">When an application wants to connect to a remote server, it issues special system calls to the OS’s kernel to open a connection. The app then reads and writes the network data. Depending on the operating system running your network applications, you can monitor these calls directly to passively extract data from an application.</p>&#13;
<p class="indent">Most Unix-like systems implement system calls resembling the Berkeley Sockets model for network communication. This isn’t surprising, because the IP protocol was originally implemented in the Berkeley Software Distribution (BSD) 4.2 Unix operating system. This socket implementation is also part of POSIX, making it the de facto standard. <a href="../Text/ch02.xhtml#ch2tab1">Table 2-1</a> shows some of the more important system calls in the Berkeley Sockets API.</p>&#13;
<p class="tabcap"><a id="ch2tab1"/><strong>Table 2-1:</strong> Common Unix System Calls for Networking</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr class="table_w">&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Name</strong></p>&#13;
</td>&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Description</strong></p>&#13;
</td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table"><code>socket</code></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Creates a new socket file descriptor.</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table"><code>connect</code></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Connects a socket to a known IP address and port.</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table"><code>bind</code></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Binds the socket to a local known IP address and port.</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table"><code>recv</code>, <code>read</code>, <code>recvfrom</code></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Receives data from the network via the socket. The generic function <code>read</code> is for reading from a file descriptor, whereas <code>recv</code> and <code>recvfrom</code> are specific to the socket’s API.</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table"><code>send</code>, <code>write</code>, <code>sendfrom</code></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Sends data over the network via the socket.</p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_16"/>To learn more about how these system calls work, a great resource is <em>The TCP/IP Guide</em> (No Starch Press, 2005). Plenty of online resources are also available, and most Unix-like operating systems include manuals you can view at a terminal using the command <code>man 2 syscall_name</code>. Now let’s look at how to monitor system calls.</p>&#13;
<h4 class="h4" id="ch00lev1sec20"><strong><em>The strace Utility on Linux</em></strong></h4>&#13;
<p class="noindent">In Linux, you can directly monitor system calls from a user program without special permissions, unless the application you want to monitor runs as a privileged user. Many Linux distributions include the handy utility <code>strace</code>, which does most of the work for you. If it isn’t installed by default, download it from your distribution’s package manager or compile it from source.</p>&#13;
<p class="indent">Run the following command, replacing <code>/path/to/app</code> with the application you’re testing and <code>args</code> with the necessary parameters, to log the network system calls used by that application:</p>&#13;
<pre>$ <span class="codestrong">strace –e trace=network,read,write <span class="codeitalic">/path/to/app args</span></span></pre>&#13;
<p class="indent">Let’s monitor a networking application that reads and writes a few strings and look at the output from <code>strace</code>. <a href="../Text/ch02.xhtml#ch2list1">Listing 2-1</a> shows four log entries (extraneous logging has been removed from the listing for brevity).</p>&#13;
<pre>   $ <span class="codestrong">strace -e trace=network,read,write customapp</span><br/>   --<span class="codeitalic">snip</span>--<br/><span class="ent">➊</span> socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 3<br/><span class="ent">➋</span> connect(3, {sa_family=AF_INET, sin_port=htons(5555),<br/>                        sin_addr=inet_addr("192.168.10.1")}, 16) = 0<br/><span class="ent">➌</span> write(3, "Hello World!\n", 13)          = 13<br/><span class="ent">➍</span> read(3, "Boo!\n", 2048)                 = 5</pre>&#13;
<p class="listing"><a id="ch2list1"/><em>Listing 2-1: Example output of the <code><span class="codeitalic">strace</code></span> utility</em></p>&#13;
<p class="indent">The first entry <span class="ent">➊</span> creates a new TCP socket, which is assigned the handle 3. The next entry <span class="ent">➋</span> shows the <code>connect</code> system call used to make a TCP connection to IP address 192.168.10.1 on port 5555. The application then writes the string <code>Hello World!</code> <span class="ent">➌</span> before reading out a string <code>Boo!</code> <span class="ent">➍</span>. The output shows it’s possible to get a good idea of what an application is doing at the system call level using this utility, even if you don’t have high levels of privilege.</p>&#13;
<h4 class="h4" id="ch00lev1sec21"><strong><em>Monitoring Network Connections with DTrace</em></strong></h4>&#13;
<p class="noindent">DTrace is a very powerful tool available on many Unix-like systems, including Solaris (where it was originally developed), macOS, and FreeBSD. It allows you to set system-wide probes on special trace providers, including system calls. You configure DTrace by writing scripts in a language with a C-like syntax. For more details on this tool, refer to the DTrace Guide online at <em><a href="http://www.dtracebook.com/index.php/DTrace_Guide">http://www.dtracebook.com/index.php/DTrace_Guide</a></em>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_17"/><a href="../Text/ch02.xhtml#ch2list2">Listing 2-2</a> shows an example of a script that monitors outbound IP connections using DTrace.</p>&#13;
<p class="literal"><span class="codeitalic">traceconnect.d</span></p>&#13;
<pre>   /* traceconnect.d - A simple DTrace script to monitor a connect system call */<br/><span class="ent">➊</span> struct sockaddr_in {<br/>       short            sin_family;<br/>       unsigned short   sin_port;<br/>       in_addr_t        sin_addr;<br/>       char             sin_zero[8];<br/>   };<br/><br/><span class="ent">➋</span> syscall::connect:entry<br/><span class="ent">➌</span> /arg2 == sizeof(struct sockaddr_in)/<br/>   {<br/>    <span class="ent">➍</span> addr = (struct sockaddr_in*)copyin(arg1, arg2);<br/>    <span class="ent">➎</span> printf("process:'%s' %s:%d", execname, inet_ntop(2, &amp;addr-&gt;sin_addr),<br/>         ntohs(addr-&gt;sin_port));<br/>   }</pre>&#13;
<p class="listing"><a id="ch2list2"/><em>Listing 2-2: A simple DTrace script to monitor a <code><span class="codeitalic">connect</code></span> system call</em></p>&#13;
<p class="indent">This simple script monitors the <code>connect</code> system call and outputs IPv4 TCP and UDP connections. The system call takes three parameters, represented by <code>arg0</code>, <code>arg1</code>, and <code>arg2</code> in the DTrace script language, that are initialized for us in the kernel. The <code>arg0</code> parameter is the socket file descriptor (that we don’t need), <code>arg1</code> is the address of the socket we’re connecting to, and <code>arg2</code> is the length of that address. Parameter <code>0</code> is the socket handle, which is not needed in this case. The next parameter is the user process memory address of a socket address structure, which is the address to connect to and can be different sizes depending on the socket type. (For example, IPv4 addresses are smaller than IPv6.) The final parameter is the length of the socket address structure in bytes.</p>&#13;
<p class="indent">The script defines a <code>sockaddr_in</code> structure that is used for IPv4 connections at <span class="ent">➊</span>; in many cases these structures can be directly copied from the system’s C header files. The system call to monitor is specified at <span class="ent">➋</span>. At <span class="ent">➌</span>, a DTrace-specific filter is used to ensure we trace only connect calls where the socket address is the same size as <code>sockaddr_in</code>. At <span class="ent">➍</span>, the <code>sockaddr_in</code> structure is copied from your process into a local structure for DTrace to inspect. At <span class="ent">➎</span>, the process name, the destination IP address, and the port are printed to the console.</p>&#13;
<p class="indent">To run this script, copy it to a file called <em>traceconnect.d</em> and then run the command <code><span class="codestrong">dtrace -s traceconnect.d</code></span> as the root user. When you use a network-connected application, the output should look like <a href="../Text/ch02.xhtml#ch2list3">Listing 2-3</a>.</p>&#13;
<pre>process:'Google Chrome'    173.194.78.125:5222<br/>process:'Google Chrome'    173.194.66.95:443<br/>process:'Google Chrome'    217.32.28.199:80<br/>process:'ntpd'             17.72.148.53:123<br/>process:'Mail'             173.194.67.109:993<br/><span epub:type="pagebreak" id="page_18"/><br/>process:'syncdefaultsd'    17.167.137.30:443<br/>process:'AddressBookSour'  17.172.192.30:443</pre>&#13;
<p class="listing"><a id="ch2list3"/><em>Listing 2-3: Example output from</em> traceconnect.d <em>script</em></p>&#13;
<p class="indent">The output shows individual connections to IP addresses, printing out the process name, for example <code>'Google Chrome'</code>, the IP address, and the port connected to. Unfortunately, the output isn’t always as useful as the output from <code>strace</code> on Linux, but DTrace is certainly a valuable tool. This demonstration only scratches the surface of what DTrace can do.</p>&#13;
<h4 class="h4" id="ch00lev1sec22"><strong><em>Process Monitor on Windows</em></strong></h4>&#13;
<p class="noindent">In contrast to Unix-like systems, Windows implements its user-mode network functions without direct system calls. The networking stack is exposed through a driver, and establishing a connection uses the file <code>open</code>, <code>read</code>, and <code>write</code> system calls to configure a network socket for use. Even if Windows supported a facility similar to <code>strace</code>, this implementation makes it more difficult to monitor network traffic at the same level as other platforms.</p>&#13;
<p class="indent">Windows, starting with Vista and later, has supported an event generation framework that allows applications to monitor network activity. Writing your own implementation of this would be quite complex, but fortunately, someone has already written a tool to do it for you: Microsoft’s Process Monitor tool. <a href="../Text/ch02.xhtml#ch2fig5">Figure 2-5</a> shows the main interface when filtering only on network connection events.</p>&#13;
<div class="image"><img alt="image" src="../Images/f02-05.jpg"/></div>&#13;
<p class="figcap"><a id="ch2fig5"/><em>Figure 2-5: An example Process Monitor capture</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_19"/>Selecting the filter circled in <a href="../Text/ch02.xhtml#ch2fig5">Figure 2-5</a> displays only events related to network connections from a monitored process. Details include the hosts involved as well as the protocol and port being used. Although the capture doesn’t provide any data associated with the connections, it does offer valuable insight into the network communications the application is establishing. Process Monitor can also capture the state of the current calling stack, which helps you determine where in an application network connections are being made. This will become important in <a href="../Text/ch06.xhtml#ch06">Chapter 6</a> when we start reverse engineering binaries to work out the network protocol. <a href="../Text/ch02.xhtml#ch2fig6">Figure 2-6</a> shows a single HTTP connection to a remote server in detail.</p>&#13;
<div class="image"><img alt="image" src="../Images/f02-06.jpg"/></div>&#13;
<p class="figcap"><a id="ch2fig6"/><em>Figure 2-6: A single captured connection</em></p>&#13;
<p class="indent">Column <span class="ent">➊</span> shows the name of the process that established the connection. Column <span class="ent">➋</span> shows the operation, which in this case is connecting to a remote server, sending the initial HTTP request and receiving a response. Column <span class="ent">➌</span> indicates the source and destination addresses, and column <span class="ent">➍</span> provides more in-depth information about the captured event.</p>&#13;
<p class="indent">Although this solution isn’t as helpful as monitoring system calls on other platforms, it’s still useful in Windows when you just want to determine the network protocols a particular application is using. You can’t capture data using this technique, but once you determine the protocols in use, you can add that information to your analysis through more active network traffic capture.</p>&#13;
<h3 class="h3" id="ch00lev1sec23"><strong>Advantages and Disadvantages of Passive Capture</strong></h3>&#13;
<p class="noindent">The greatest advantage of using passive capture is that it doesn’t disrupt the client and server applications’ communication. It will not change the destination or source address of traffic, and it doesn’t require any modifications or reconfiguration of the applications.</p>&#13;
<p class="indent">Passive capture might also be the only technique you can use when you don’t have direct control over the client or the server. You can usually find a way to listen to the network traffic and capture it with a limited amount of effort. After you’ve collected your data, you can determine which active capture techniques to use and the best way to attack the protocol you want to analyze.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_20"/>One major disadvantage of passive network traffic capture is that capture techniques like packet sniffing run at such a low level that it can difficult to interpret what an application received. Tools such as Wireshark certainly help, but if you’re analyzing a custom protocol, it might not be possible to easily take apart the protocol without interacting with it directly.</p>&#13;
<p class="indent">Passive capture also doesn’t always make it easy to modify the traffic an application produces. Modifying traffic isn’t always necessary, but it’s useful when you encounter encrypted protocols, want to disable compression, or need to change the traffic for exploitation.</p>&#13;
<p class="indent">When analyzing traffic and injecting new packets doesn’t yield results, switch tactics and try using active capture techniques.</p>&#13;
<h3 class="h3" id="ch00lev1sec24"><strong>Active Network Traffic Capture</strong></h3>&#13;
<p class="noindent">Active capture differs from passive in that you’ll try to influence the flow of the traffic, usually by using a man-in-the-middle attack on the network communication. As shown in <a href="../Text/ch02.xhtml#ch2fig7">Figure 2-7</a>, the device capturing traffic usually sits between the client and server applications, acting as a bridge. This approach has several advantages, including the ability to modify traffic and disable features like encryption or compression, which can make it easier to analyze and exploit a network protocol.</p>&#13;
<div class="image"><img alt="image" src="../Images/f02-07.jpg"/></div>&#13;
<p class="figcap"><a id="ch2fig7"/><em>Figure 2-7: A man-in-the-middle proxy</em></p>&#13;
<p class="indent">A disadvantage of this approach is that it’s usually more difficult because you need to reroute the application’s traffic through your active capture system. Active capture can also have unintended, undesirable effects. For example, if you change the network address of the server or client to the proxy, this can cause confusion, resulting in the application sending traffic to the wrong place. Despite these issues, active capture is probably the most valuable technique for analyzing and exploiting application network protocols.</p>&#13;
<h3 class="h3" id="ch00lev1sec25"><strong>Network Proxies</strong></h3>&#13;
<p class="noindent">The most common way to perform a man-in-the-middle attack on network traffic is to force the application to communicate through a proxy service. In this section, I’ll explain the relative advantages and disadvantages of some of the common proxy types you can use to capture traffic, analyze that data, and exploit a network protocol. I’ll also show you how to get traffic from typical client applications into a proxy.</p>&#13;
<h4 class="h4" id="ch00lev1sec26"><span epub:type="pagebreak" id="page_21"/><strong><em>Port-Forwarding Proxy</em></strong></h4>&#13;
<p class="noindent">Port forwarding is the easiest way to proxy a connection. Just set up a listening server (TCP or UDP) and wait for a new connection. When that new connection is made to the proxy server, it will open a forwarding connection to the real service and logically connect the two, as shown in <a href="../Text/ch02.xhtml#ch2fig8">Figure 2-8</a>.</p>&#13;
<div class="image"><img alt="image" src="../Images/f02-08.jpg"/></div>&#13;
<p class="figcap"><a id="ch2fig8"/><em>Figure 2-8: Overview of a TCP port-forwarding proxy</em></p>&#13;
<h5 class="h5" id="ch00lev1sec27"><strong>Simple Implementation</strong></h5>&#13;
<p class="noindent">To create our proxy, we’ll use the built-in TCP port forwarder included with the Canape Core libraries. Place the code in <a href="../Text/ch02.xhtml#ch2list4">Listing 2-4</a> into a C# script file, changing <code><span class="codeitalic">LOCALPORT</code></span> <span class="ent">➋</span>, <code><span class="codeitalic">REMOTEHOST</code></span> <span class="ent">➌</span>, and <code><span class="codeitalic">REMOTEPORT</code></span> <span class="ent">➍</span> to appropriate values for your network.</p>&#13;
<p class="literal"><span class="codeitalic">PortFormat</span><br/><span class="codeitalic">Proxy.csx</span></p>&#13;
<pre>   // PortFormatProxy.csx – Simple TCP port-forwarding proxy<br/>   // Expose methods like WriteLine and WritePackets<br/>   using static System.Console;<br/>   using static CANAPE.Cli.ConsoleUtils;<br/><br/>   // Create proxy template<br/>   var template = new <span class="ent">➊</span>FixedProxyTemplate();<br/>   template.LocalPort = <span class="ent">➋</span><span class="codeitalic">LOCALPORT</span>;<br/>   template.Host = <span class="ent">➌</span>"<span class="codeitalic">REMOTEHOST</span>";<br/>   template.Port = <span class="ent">➍</span><span class="codeitalic">REMOTEPORT</span>;<br/><br/>   // Create proxy instance and start<br/><span class="ent">➎</span> var service = template.Create();<br/>   service.Start();<br/><br/>   WriteLine("Created {0}", service);<br/>   WriteLine("Press Enter to exit...");<br/>   ReadLine();<br/><span class="ent">➏</span> service.Stop();<br/><br/>   // Dump packets<br/>   var packets = service.Packets;<br/>   WriteLine("Captured {0} packets:",<br/>       packets.Count);<br/><span class="ent">➐</span> { WritePackets(packets);</pre>&#13;
<p class="listing"><a id="ch2list4"/><em>Listing 2-4: A simple TCP port-forwarding proxy example</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_22"/>This very simple script creates an instance of a <code>FixedProxyTemplate</code> <span class="ent">➊</span>. Canape Core works on a template model, although if required you can get down and dirty with the low-level network configuration. The script configures the template with the desired local and remote network information. The template is used to create a service instance at <span class="ent">➎</span>; you can think of documents in the framework acting as templates for services. The newly created service is then started; at this point, the network connections are configured. After waiting for a key press, the service is stopped at <span class="ent">➏</span>. Then all the captured packets are written to the console using the <code>WritePackets()</code> method <span class="ent">➐</span>.</p>&#13;
<p class="indent">Running this script should bind an instance of our forwarding proxy to the <code><span class="codeitalic">LOCALPORT</code></span> number for the localhost interface only. When a new TCP connection is made to that port, the proxy code should establish a new connection to <code><span class="codeitalic">REMOTEHOST</code></span> with TCP port <code><span class="codeitalic">REMOTEPORT</code></span> and link the two connections together.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">WARNING</span></strong></p>&#13;
<p class="notep"><em>Binding a proxy to all network addresses can be risky from a security perspective because proxies written for testing protocols rarely implement robust security mechanisms. Unless you have complete control over the network you are connected to or have no choice, only bind your proxy to the local loopback interface. In <a href="../Text/ch02.xhtml#ch2list4">Listing 2-4</a>, the default is <code><span class="codeitalic">LOCALHOST</code></span>; to bind to all interfaces, set the <code><span class="codeitalic">AnyBind</code></span> property to <code><span class="codeitalic">true</code></span>.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch00lev1sec28"><strong>Redirecting Traffic to Proxy</strong></h5>&#13;
<p class="noindent">With our simple proxy application complete, we now need to direct our application traffic through it.</p>&#13;
<p class="indent">For a web browser, it’s simple enough: to capture a specific request, instead of using the URL form <em>http://www.domain.com/resource</em>, use <em>http://<strong>localhost:localport</strong>/resource</em>, which pushes the request through your port-forwarding proxy.</p>&#13;
<p class="indent">Other applications are trickier: you might have to dig into the application’s configuration settings. Sometimes, the only setting an application allows you to change is the destination IP address. But this can lead to a chicken-and-egg scenario where you don’t know which TCP or UDP ports the application might be using with that address, especially if the application contains complex functions running over multiple different service connections. This occurs with <em>Remote Procedure Call (RPC)</em> protocols, such as the Common Object Request Broker Architecture (CORBA). This protocol usually makes an initial network connection to a broker, which acts as a directory of available services. A second connection is then made to the requested service over an instance-specific TCP port.</p>&#13;
<p class="indent">In this case, a good approach is to use as many network-connected features of the application as possible while monitoring it using passive capture techniques. By doing so, you should uncover the connections that application typically makes, which you can then easily replicate with forwarding proxies.</p>&#13;
<p class="indent">If the application doesn’t support changing its destination, you need to be a bit more creative. If the application resolves the destination server <span epub:type="pagebreak" id="page_23"/>address via a hostname, you have more options. You could set up a custom DNS server that responds to name requests with the IP address of your proxy. Or you could use the <em>hosts</em> file facility, which is available on most operating systems, including Windows, assuming you have control over system files on the device the application is running on.</p>&#13;
<p class="indent">During hostname resolving, the OS (or the resolving library) first refers to the <em>hosts</em> file to see if any local entries exist for that name, making a DNS request only if one is not found. For example, the hosts file in <a href="../Text/ch02.xhtml#ch2list5">Listing 2-5</a> redirects the hostnames <em><a href="http://www.badgers.com">www.badgers.com</a></em> and <em><a href="http://www.domain.com">www.domain.com</a></em> to <em>localhost</em>.</p>&#13;
<pre># Standard Localhost addresses<br/>127.0.0.1       localhost<br/>::1             localhost<br/><br/># Following are dummy entries to redirect traffic through the proxy<br/>127.0.0.1       www.badgers.com<br/>127.0.0.1       www.domain.com</pre>&#13;
<p class="listing"><a id="ch2list5"/><em>Listing 2-5: An example</em> hosts <em>file</em></p>&#13;
<p class="indent">The standard location of the <em>hosts</em> file on Unix-like OSes is <em>/etc/hosts</em>, whereas on Windows it is <em>C:\Windows\System32\Drivers\etc\hosts</em>. Obviously, you’ll need to replace the path to the Windows folder as necessary for your environment.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Some antivirus and security products track changes to the system’s hosts, because changes are a sign of malware. You might need to disable the product’s protection if you want to change the</em> hosts <em>file.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch00lev1sec29"><strong>Advantages of a Port-Forwarding Proxy</strong></h5>&#13;
<p class="noindent">The main advantage of a port-forwarding proxy is its simplicity: you wait for a connection, open a new connection to the original destination, and then pass traffic back and forth between the two. There is no protocol associated with the proxy to deal with, and no special support is required by the application from which you are trying to capture traffic.</p>&#13;
<p class="indent">A port-forwarding proxy is also the primary way of proxying UDP traffic; because it isn’t connection oriented, the implementation of a forwarder for UDP is considerably simpler.</p>&#13;
<h5 class="h5" id="ch00lev1sec30"><strong>Disadvantages of a Port-Forwarding Proxy</strong></h5>&#13;
<p class="noindent">Of course, the simplicity of a port-forwarding proxy also contributes to its disadvantages. Because you are only forwarding traffic from a listening connection to a single destination, multiple instances of a proxy would be required if the application uses multiple protocols on different ports.</p>&#13;
<p class="indent">For example, consider an application that has a single hostname or IP address for its destination, which you can control either directly by changing it in the application’s configuration or by spoofing the hostname. The application then attempts to connect to TCP ports 443 and 1234. Because <span epub:type="pagebreak" id="page_24"/>you can control the address it connects to, not the ports, you need to set up forwarding proxies for both, even if you are only interested in the traffic running over port 1234.</p>&#13;
<p class="indent">This proxy can also make it difficult to handle more than one connection to a well-known port. For example, if the port-forwarding proxy is listening on port 1234 and making a connection to <em><a href="http://www.domain.com">www.domain.com</a></em> port 1234, only redirected traffic for the original domain will work as expected. If you wanted to also redirect <em><a href="http://www.badgers.com">www.badgers.com</a></em>, things would be more difficult. You can mitigate this if the application supports specifying the destination address and port or by using other techniques, such as Destination Network Address Translation (DNAT), to redirect specific connections to unique forwarding proxies. (<a href="../Text/ch05.xhtml#ch05">Chapter 5</a> contains more details on DNAT as well as numerous other more advanced network capture techniques.)</p>&#13;
<p class="indent">Additionally, the protocol might use the destination address for its own purposes. For example, the Host header in HyperText Transport Protocol (HTTP) can be used for Virtual Host decisions, which might make a port-forwarded protocol work differently, or not at all, from a redirected connection. Still, at least for HTTP, I will discuss a workaround for this limitation in “<a href="../Text/ch02.xhtml#ch00lev1sec42">Reverse HTTP Proxy</a>” on <a href="../Text/ch02.xhtml#page_32">page 32</a>.</p>&#13;
<h4 class="h4" id="ch00lev1sec31"><strong><em>SOCKS Proxy</em></strong></h4>&#13;
<p class="noindent">Think of a SOCKS proxy as a port-forwarding proxy on steroids. Not only does it forward TCP connections to the desired network location, but all new connections start with a simple handshake protocol that informs the proxy of the ultimate destination rather than having it fixed. It can also support listening connections, which is important for protocols like File Transfer Protocol (FTP) that need to open new local ports for the server to send data to. <a href="../Text/ch02.xhtml#ch2fig9">Figure 2-9</a> provides an overview of SOCKS proxy.</p>&#13;
<div class="image"><img alt="image" src="../Images/f02-09.jpg"/></div>&#13;
<p class="figcap"><a id="ch2fig9"/><em>Figure 2-9: Overview of SOCKS proxy</em></p>&#13;
<p class="indent">Three common variants of the protocol are currently in use—SOCKS 4, 4a, and 5—and each has its own use. Version 4 is the most commonly supported version of the protocol; however, it supports only IPv4 connections, and the destination address must be specified as a 32-bit IP address. An <span epub:type="pagebreak" id="page_25"/>update to version 4, version 4a allowed connections by hostname (which is useful if you don’t have a DNS server that can resolve IP addresses). Version 5 introduced hostname support, IPv6, UDP forwarding, and improved authentication mechanisms; it is also the only one specified in an RFC (1928).</p>&#13;
<p class="indent">As an example, a client will send the request shown in <a href="../Text/ch02.xhtml#ch2fig10">Figure 2-10</a> to establish a SOCKS connection to IP address 10.0.0.1 on port 12345. The <code>USERNAME</code> component is the only method of authentication in SOCKS version 4 (not especially secure, I know). <code>VER</code> represents the version number, which in this case is 4. <code>CMD</code> indicates it wants to connect out (binding to an address is <code>CMD</code> 2), and the TCP port and address are specified in binary form.</p>&#13;
<div class="image"><img alt="image" src="../Images/f02-10.jpg"/></div>&#13;
<p class="figcap"><a id="ch2fig10"/><em>Figure 2-10: A SOCKS version 4 request</em></p>&#13;
<p class="indent">If the connection is successful, it will send back the appropriate response, as shown in <a href="../Text/ch02.xhtml#ch2fig11">Figure 2-11</a>. The <code>RESP</code> field indicates the status of the response; the TCP port and address fields are only significant for binding requests. Then the connection becomes transparent and the client and server directly negotiate with each other; the proxy server only acts to forward traffic in either direction.</p>&#13;
<div class="image"><img alt="image" src="../Images/f02-11.jpg"/></div>&#13;
<p class="figcap"><a id="ch2fig11"/><em>Figure 2-11: A SOCKS version 4 successful response</em></p>&#13;
<h5 class="h5" id="ch00lev1sec32"><strong>Simple Implementation</strong></h5>&#13;
<p class="noindent">The Canape Core libraries have built-in support for SOCKS 4, 4a, and 5. Place <a href="../Text/ch02.xhtml#ch2list6">Listing 2-6</a> into a C# script file, changing <code><span class="codeitalic">LOCALPORT</code></span> <span class="ent">➋</span> to the local TCP port you want to listen on for the SOCKS proxy.</p>&#13;
<p class="literal"><span class="codeitalic">SocksProxy.csx</span></p>&#13;
<pre>   // SocksProxy.csx – Simple SOCKS proxy<br/>   // Expose methods like WriteLine and WritePackets<br/>   using static System.Console;<br/>   using static CANAPE.Cli.ConsoleUtils;<br/><br/>   // Create the SOCKS proxy template<br/><span class="ent">➊</span> var template = new SocksProxyTemplate();<br/>   template.LocalPort = <span class="ent">➋</span><span class="codeitalic">LOCALPORT</span>;<br/><br/>   // Create proxy instance and start<br/>   var service = template.Create();<br/>   service.Start();<br/><span epub:type="pagebreak" id="page_26"/><br/>   WriteLine("Created {0}", service);<br/>   WriteLine("Press Enter to exit...");<br/>   ReadLine();<br/>   service.Stop();<br/><br/>   // Dump packets<br/>   var packets = service.Packets;<br/>   WriteLine("Captured {0} packets:",<br/>       packets.Count);<br/>   WritePackets(packets);</pre>&#13;
<p class="listing"><a id="ch2list6"/><em>Listing 2-6: A simple SOCKS proxy example</em></p>&#13;
<p class="indent"><a href="../Text/ch02.xhtml#ch2list6">Listing 2-6</a> follows the same pattern established with the TCP port-forwarding proxy in <a href="../Text/ch02.xhtml#ch2list4">Listing 2-4</a>. But in this case, the code at <span class="ent">➊</span> creates a SOCKS proxy template. The rest of the code is exactly the same.</p>&#13;
<h5 class="h5" id="ch00lev1sec33"><strong>Redirecting Traffic to Proxy</strong></h5>&#13;
<p class="noindent">To determine a way of pushing an application’s network traffic through a SOCKS proxy, look in the application first. For example, when you open the proxy settings in Mozilla Firefox, the dialog in <a href="../Text/ch02.xhtml#ch2fig12">Figure 2-12</a> appears. From there, you can configure Firefox to use a SOCKS proxy.</p>&#13;
<div class="image"><img alt="image" src="../Images/f02-12.jpg"/></div>&#13;
<p class="figcap"><a id="ch2fig12"/><em>Figure 2-12: Firefox proxy configuration</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_27"/>But sometimes SOCKS support is not immediately obvious. If you are testing a Java application, the Java Runtime accepts command line parameters that enable SOCKS support for any outbound TCP connection. For example, consider the very simple Java application in <a href="../Text/ch02.xhtml#ch2list7">Listing 2-7</a>, which connects to IP address 192.168.10.1 on port 5555.</p>&#13;
<p class="literal"><span class="codeitalic">SocketClient.java</span></p>&#13;
<pre>// SocketClient.java – A simple Java TCP socket client<br/>import java.io.PrintWriter;<br/>import java.net.Socket;<br/><br/>public class SocketClient {<br/>    public static void main(String[] args) {<br/>        try {<br/>            Socket s = new Socket("192.168.10.1", 5555);<br/>            PrintWriter out = new PrintWriter(s.getOutputStream(), true);<br/>            out.println("Hello World!");<br/>            s.close();<br/>        } catch(Exception e) {<br/>        }<br/>    }<br/>}</pre>&#13;
<p class="listing"><a id="ch2list7"/><em>Listing 2-7: A simple Java TCP client</em></p>&#13;
<p class="indent">When you run this compiled program normally, it would do as you expect. But if on the command line you pass two special system properties, <code>socksProxyHost</code> and <code>socksProxyPort</code>, you can specify a SOCKS proxy for any TCP connection:</p>&#13;
<pre>java –DsocksProxyHost=localhost –DsocksProxyPort=1080 SocketClient</pre>&#13;
<p class="indent">This will make the TCP connection through the SOCKS proxy on localhost port 1080.</p>&#13;
<p class="indent">Another place to look to determine how to push an application’s network traffic through a SOCKS proxy is the OS’s default proxy. On macOS, navigate to <strong>System Preferences</strong> ▸ <strong>Network</strong> ▸ <strong>Advanced</strong> ▸ <strong>Proxies</strong>. The dialog shown in <a href="../Text/ch02.xhtml#ch2fig13">Figure 2-13</a> appears. From here, you can configure a system-wide SOCKS proxy or general proxies for other protocols. This won’t always work, but it’s an easy option worth trying out.</p>&#13;
<p class="indent">In addition, if the application just will not support a SOCKS proxy natively, certain tools will add that function to arbitrary applications. These tools range from free and open source tools, such as Dante (<em><a href="https://www.inet.no/dante/">https://www.inet.no/dante/</a></em>) on Linux, to commercial tools, such as Proxifier (<em><a href="https://www.proxifier.com/">https://www.proxifier.com/</a></em>), which runs on Windows and macOS. In one way or another, they all inject into the application to add SOCKS support and modify the operation of the socket functions.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_28"/><img alt="image" src="../Images/f02-13.jpg"/></div>&#13;
<p class="figcap"><a id="ch2fig13"/><em>Figure 2-13: A proxy configuration dialog on macOS</em></p>&#13;
<h5 class="h5" id="ch00lev1sec34"><strong>Advantages of a SOCKS Proxy</strong></h5>&#13;
<p class="noindent">The clear advantage of using a SOCKS proxy, as opposed to using a simple port forwarder, is that it should capture all TCP connections (and potentially some UDP if you are using SOCKS version 5) that an application makes. This is an advantage as long as the OS socket layer is wrapped to effectively push all connections through the proxy.</p>&#13;
<p class="indent">A SOCKS proxy also generally preserves the destination of the connection from the point of view of the client application. Therefore, if a client application sends in-band data that refers to its endpoint, then the endpoint will be what the server expects. However, this does not preserve the source address. Some protocols, such as FTP, assume they can request ports to be opened on the originating client. The SOCKS protocol provides a facility for binding listening connections but adds to the complexity of the implementation. This makes capture and analysis more difficult because you must consider many different streams of data to and from a server.</p>&#13;
<h5 class="h5" id="ch00lev1sec35"><strong>Disadvantages of a SOCKS Proxy</strong></h5>&#13;
<p class="noindent">The main disadvantage of SOCKS is that support can be inconsistent between applications and platforms. The Windows system proxy supports only SOCKS version 4 proxies, which means it will resolve only local <span epub:type="pagebreak" id="page_29"/>hostnames. It does not support IPv6 and does not have a robust authentication mechanism. Generally, you get better support by using a SOCKS tool to add to an existing application, but this doesn’t always work well.</p>&#13;
<h4 class="h4" id="ch00lev1sec36"><strong><em>HTTP Proxies</em></strong></h4>&#13;
<p class="noindent">HTTP powers the World Wide Web as well as a myriad of web services and RESTful protocols. <a href="../Text/ch02.xhtml#ch2fig14">Figure 2-14</a> provides an overview of an HTTP proxy. The protocol can also be co-opted as a transport mechanism for non-web protocols, such as Java’s Remote Method Invocation (RMI) or Real Time Messaging Protocol (RTMP), because it can tunnel though the most restrictive firewalls. It is important to understand how HTTP proxying works in practice, because it will almost certainly be useful for protocol analysis, even if a web service is not being tested. Existing web application–testing tools rarely do an ideal job when HTTP is being used out of its original environment. Sometimes rolling your own implementation of an HTTP proxy is the only solution.</p>&#13;
<div class="image"><img alt="image" src="../Images/f02-14.jpg"/></div>&#13;
<p class="figcap"><a id="ch2fig14"/><em>Figure 2-14: Overview of an HTTP proxy</em></p>&#13;
<p class="indent">The two main types of HTTP proxy are the forwarding proxy and the reverse proxy. Each has advantages and disadvantages for the prospective network protocol analyzer.</p>&#13;
<h4 class="h4" id="ch00lev1sec37"><strong><em>Forwarding an HTTP Proxy</em></strong></h4>&#13;
<p class="noindent">The HTTP protocol is specified in RFC 1945 for version 1.0 and RFC 2616 for version 1.1; both versions provide a simple mechanism for proxying HTTP requests. For example, HTTP 1.1 specifies that the first full line of a request, the <em>request line</em>, has the following format:</p>&#13;
<pre><span class="ent">➊</span>GET <span class="ent">➋</span>/image.jpg HTTP/1.1</pre>&#13;
<p class="indent">The method <span class="ent">➊</span> specifies what to do in that request using familiar verbs, such as <code>GET</code>, <code>POST</code>, and <code>HEAD</code>. In a proxy request, this does not change from a normal HTTP connection. The path <span class="ent">➋</span> is where the proxy request gets interesting. As is shown, an absolute path indicates the resource that <span epub:type="pagebreak" id="page_30"/>the method will act upon. Importantly, the path can also be an absolute Uniform Request Identifier (URI). By specifying an absolute URI, a proxy server can establish a new connection to the destination, forwarding all traffic on and returning data back to the client. The proxy can even manipulate the traffic, in a limited fashion, to add authentication, hide version 1.0 servers from 1.1 clients, and add transfer compression along with all manner of other things. However, this flexibility comes with a cost: the proxy server must be able to process the HTTP traffic, which adds massive complexity. For example, the following request line accesses an image resource on a remote server through a proxy:</p>&#13;
<pre>GET http://www.domain.com/image.jpg HTTP/1.1</pre>&#13;
<p class="indent">You, the attentive reader, might have identified an issue with this approach to proxying HTTP communication. Because the proxy must be able to access the underlying HTTP protocol, what about HTTPS, which transports HTTP over an encrypted TLS connection? You could break out the encrypted traffic; however, in a normal environment, it is unlikely the HTTP client would trust whatever certificate you provided. Also, TLS is intentionally designed to make it virtually impossible to use a man-in-the-middle attack any other way. Fortunately, this was anticipated, and RFC 2817 provides two solutions: it includes the ability to upgrade an HTTP connection to encryption (there is no need for more details here), and more importantly for our purposes, it specifies the <code>CONNECT</code> HTTP method for creating transparent, tunneled connections over HTTP proxies. As an example, a web browser that wants to establish a proxy connection to an HTTPS site can issue the following request to the proxy:</p>&#13;
<pre>CONNECT www.domain.com:443 HTTP/1.1</pre>&#13;
<p class="indent">If the proxy accepts this request, it will make a new TCP connection to the server. On success, it should return the following response:</p>&#13;
<pre>HTTP/1.1 200 Connection Established</pre>&#13;
<p class="indent">The TCP connection to the proxy now becomes transparent, and the browser is able to establish the negotiated TLS connection without the proxy getting in the way. Of course, it’s worth noting that the proxy is unlikely to verify that TLS is actually being used on this connection. It could be any protocol you like, and this fact is abused by some applications to tunnel out their own binary protocols through HTTP proxies. For this reason, it’s common to find deployments of HTTP proxies restricting the ports that can be tunneled to a very limited subset.</p>&#13;
<h5 class="h5" id="ch00lev1sec38"><strong>Simple Implementation</strong></h5>&#13;
<p class="noindent">Once again, the Canape Core libraries include a simple implementation of an HTTP proxy. Unfortunately, they don’t support the <code>CONNECT</code> method to <span epub:type="pagebreak" id="page_31"/>create a transparent tunnel, but it will suffice for demonstration purposes. Place <a href="../Text/ch02.xhtml#ch2list8">Listing 2-8</a> into a C# script file, changing <code><span class="codeitalic">LOCALPORT</code></span> <span class="ent">➋</span> to the local TCP port you want to listen on.</p>&#13;
<p class="literal"><span class="codeitalic">HttpProxy.csx</span></p>&#13;
<pre>   // HttpProxy.csx – Simple HTTP proxy<br/>   // Expose methods like WriteLine and WritePackets<br/>   using static System.Console;<br/>   using static CANAPE.Cli.ConsoleUtils;<br/><br/>   // Create proxy template<br/><span class="ent">➊</span> var template = new HttpProxyTemplate();<br/>   template.LocalPort = <span class="ent">➋</span><span class="codeitalic">LOCALPORT</span>;<br/><br/>   // Create proxy instance and start<br/>   var service = template.Create();<br/>   service.Start();<br/><br/>   WriteLine("Created {0}", service);<br/>   WriteLine("Press Enter to exit...");<br/>   ReadLine();<br/>   service.Stop();<br/><br/>   // Dump packets<br/>   var packets = service.Packets;<br/>   WriteLine("Captured {0} packets:", packets.Count);<br/>   WritePackets(packets);</pre>&#13;
<p class="listing"><a id="ch2list8"/><em>Listing 2-8: A simple forward HTTP proxy example</em></p>&#13;
<p class="indent">Here we created a forward HTTP Proxy. The code at line <span class="ent">➊</span> is again only a slight variation from the previous examples, creating an HTTP proxy template.</p>&#13;
<h5 class="h5" id="ch00lev1sec39"><strong>Redirecting Traffic to Proxy</strong></h5>&#13;
<p class="noindent">As with SOCKS proxies, the first port of call will be the application. It’s rare for an application that uses the HTTP protocol to not have some sort of proxy configuration. If the application has no specific settings for HTTP proxy support, try the OS configuration, which is in the same place as the SOCKS proxy configuration. For example, on Windows you can access the system proxy settings by selecting Control Panel ▸ Internet Options ▸ Connections ▸ LAN Settings.</p>&#13;
<p class="indent">Many command line utilities on Unix-like systems, such as <code>curl</code>, <code>wget</code>, and <code>apt</code>, also support setting HTTP proxy configuration through environment variables. If you set the environment variable <code>http_proxy</code> to the URL for the HTTP proxy to use—for example, <em>http://localhost:3128</em>—the application will use it. For secure traffic, you can also use <em>https_proxy</em>. Some implementations allow special URL schemes, such as <em>socks4://</em>, to specify that you want to use a SOCKS proxy.</p>&#13;
<h5 class="h5" id="ch00lev1sec40"><span epub:type="pagebreak" id="page_32"/><strong>Advantages of a Forwarding HTTP Proxy</strong></h5>&#13;
<p class="noindent">The main advantage of a forwarding HTTP proxy is that if the application uses the HTTP protocol exclusively, all it needs to do to add proxy support is to change the absolute path in the Request Line to an absolute URI and send the data to a listening proxy server. Also, only a few applications that use the HTTP protocol for transport do not already support proxying.</p>&#13;
<h5 class="h5" id="ch00lev1sec41"><strong>Disadvantages of a Forwarding HTTP Proxy</strong></h5>&#13;
<p class="noindent">The requirement of a forwarding HTTP proxy to implement a full HTTP parser to handle the many idiosyncrasies of the protocol adds significant complexity; this complexity might introduce processing issues or, in the worst case, security vulnerabilities. Also, the addition of the proxy destination within the protocol means that it can be more difficult to retrofit HTTP proxy support to an existing application through external techniques, unless you convert connections to use the <code>CONNECT</code> method (which even works for unencrypted HTTP).</p>&#13;
<p class="indent">Due to the complexities of handling a full HTTP 1.1 connection, it is common for proxies to either disconnect clients after a single request or downgrade communications to version 1.0 (which always closes the response connection after all data has been received). This might break a higher-level protocol that expects to use version 1.1 or request <em>pipelining</em>, which is the ability to have multiple requests <em>in flight</em> to improve performance or state locality.</p>&#13;
<h4 class="h4" id="ch00lev1sec42"><strong><em>Reverse HTTP Proxy</em></strong></h4>&#13;
<p class="noindent">Forwarding proxies are fairly common in environments where an internal client is connecting to an outside network. They act as a security boundary, limiting outbound traffic to a small subset of protocol types. (Let’s just ignore the potential security implications of the <code>CONNECT</code> proxy for a moment.) But sometimes you might want to proxy inbound connections, perhaps for load-balancing or security reasons (to prevent exposing your servers directly to the outside world). However, a problem arises if you do this. You have no control over the client. In fact, the client probably doesn’t even realize it’s connecting to a proxy. This is where the <em>reverse HTTP proxy</em> comes in.</p>&#13;
<p class="indent">Instead of requiring the destination host to be specified in the request line, as with a forwarding proxy, you can abuse the fact that all HTTP 1.1–compliant clients <em>must</em> send a Host HTTP header in the request that specifies the original hostname used in the URI of the request. (Note that HTTP 1.0 has no such requirement, but most clients using that version will send the header anyway.) With the Host header information, you can infer the original destination of the request, making a proxy connection to that server, as shown in <a href="../Text/ch02.xhtml#ch2list9">Listing 2-9</a>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_33"/><br/>GET /image.jpg HTTP/1.1<br/>User-Agent: Super Funky HTTP Client v1.0<br/>Host: <span class="ent">➊</span>www.domain.com<br/>Accept: */*</pre>&#13;
<p class="listing"><a id="ch2list9"/><em>Listing 2-9: An example HTTP request</em></p>&#13;
<p class="indent"><a href="../Text/ch02.xhtml#ch2list9">Listing 2-9</a> shows a typical Host header <span class="ent">➊</span> where the HTTP request was to the URL <em><a href="http://www.domain.com/image.jpg">http://www.domain.com/image.jpg</a></em>. The reverse proxy can easily take this information and reuse it to construct the original destination. Again, because there is a requirement for parsing the HTTP headers, it is more difficult to use for HTTPS traffic that is protected by TLS. Fortunately, most TLS implementations take wildcard certificates where the subject is in the form of <em>*.domain.com</em> or similar, which would match any subdomain of <em><a href="http://domain.com">domain.com</a></em>.</p>&#13;
<h5 class="h5" id="ch00lev1sec43"><strong>Simple Implementation</strong></h5>&#13;
<p class="noindent">Unsurprisingly, the Canape Core libraries include a built-in HTTP reverse proxy implementation, which you can access by changing the template object to <em>HttpReverseProxyTemplate</em> from <em>HttpProxyTemplate</em>. But for completeness, <a href="../Text/ch02.xhtml#ch2list10">Listing 2-10</a> shows a simple implementation. Place the following code in a C# script file, changing <code><span class="codeitalic">LOCALPORT</code></span> <span class="ent">➊</span> to the local TCP port you want to listen on. If <code><span class="codeitalic">LOCALPORT</code></span> is less than 1024 and you’re running this on a Unix-style system, you’ll also need to run the script as root.</p>&#13;
<p class="literal"><span class="codeitalic">ReverseHttp</span><br/><span class="codeitalic">Proxy.csx</span></p>&#13;
<pre>// ReverseHttpProxy.csx – Simple reverse HTTP proxy<br/>// Expose methods like WriteLine and WritePackets<br/>using static System.Console;<br/>using static CANAPE.Cli.ConsoleUtils;<br/><br/>// Create proxy template<br/>var template = new HttpReverseProxyTemplate();<br/>template.LocalPort = <span class="ent">➊</span><span class="codeitalic">LOCALPORT</span>;<br/><br/>// Create proxy instance and start<br/>var service = template.Create();<br/>service.Start();<br/><br/>WriteLine("Created {0}", service);<br/>WriteLine("Press Enter to exit...");<br/>ReadLine();<br/>service.Stop();<br/><br/>// Dump packets<br/>var packets = service.Packets;<br/>WriteLine("Captured {0} packets:",<br/>    packets.Count);<br/>WritePackets(packets);</pre>&#13;
<p class="listing"><a id="ch2list10"/><em>Listing 2-10: A simple reverse HTTP proxy example</em></p>&#13;
<h5 class="h5" id="ch00lev1sec44"><span epub:type="pagebreak" id="page_34"/><strong>Redirecting Traffic to Your Proxy</strong></h5>&#13;
<p class="noindent">The approach to redirecting traffic to a reverse HTTP proxy is similar to that employed for TCP port-forwarding, which is by redirecting the connection to the proxy. But there is a big difference; you can’t just change the destination hostname. This would change the Host header, shown in Listing 2-10. If you’re not careful, you could cause a proxy loop.<sup><a id="ch02nt_01"/><a href="../Text/footnote.xhtml#ch02nt01">1</a></sup> Instead, it’s best to change the IP address associated with a hostname using the <em>hosts</em> file.</p>&#13;
<p class="indent">But perhaps the application you’re testing is running on a device that doesn’t allow you to change the <em>hosts</em> file. Therefore, setting up a custom DNS server might be the easiest approach, assuming you’re able to change the DNS server configuration.</p>&#13;
<p class="indent">You could use another approach, which is to configure a full DNS server with the appropriate settings. This can be time consuming and error prone; just ask anyone who has ever set up a bind server. Fortunately, existing tools are available to do what we want, which is to return our proxy’s IP address in response to a DNS request. Such a tool is <em>dnsspoof</em>. To avoid installing another tool, you can do it using Canape’s DNS server. The basic DNS server spoofs only a single IP address to all DNS requests (see <a href="../Text/ch02.xhtml#ch2list11">Listing 2-11</a>). Replace <code><span class="codeitalic">IPV4ADDRESS</code></span> <span class="ent">➊</span>, <code><span class="codeitalic">IPV6ADDRESS</code></span> <span class="ent">➋</span>, and <code><span class="codeitalic">REVERSEDNS</code></span> <span class="ent">➌</span> with appropriate strings. As with the HTTP Reverse Proxy, you’ll need to run this as root on a Unix-like system, as it will try to bind to port 53, which is not usually allowed for normal users. On Windows, there’s no such restriction on binding to ports less than 1024.</p>&#13;
<p class="literal"><span class="codeitalic">DnsServer.csx</span></p>&#13;
<pre>// DnsServer.csx – Simple DNS Server<br/>// Expose console methods like WriteLine at global level.<br/>using static System.Console;<br/><br/>// Create the DNS server template<br/>var template = new DnsServerTemplate();<br/><br/>// Setup the response addresses<br/>template.ResponseAddress = <span class="ent">➊</span>"IPV4ADDRESS";<br/>template.ResponseAddress6 = <span class="ent">➋</span>"IPV6ADDRESS";<br/>template.ReverseDns = <span class="ent">➌</span>"REVERSEDNS";<br/><br/>// Create DNS server instance and start<br/>var service = template.Create();<br/>service.Start();<br/>WriteLine("Created {0}", service);<br/>WriteLine("Press Enter to exit...");<br/>ReadLine();<br/>service.Stop();</pre>&#13;
<p class="listing"><a id="ch2list11"/><em>Listing 2-11: A simple DNS server</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_35"/>Now if you configure the DNS server for your application to point to your spoofing DNS server, the application should send its traffic through.</p>&#13;
<h5 class="h5" id="ch00lev1sec45"><strong>Advantage of a Reverse HTTP Proxy</strong></h5>&#13;
<p class="noindent">The advantage of a reverse HTTP proxy is that it doesn’t require a client application to support a typical forwarding proxy configuration. This is especially useful if the client application is not under your direct control or has a fixed configuration that cannot be easily changed. As long as you can force the original TCP connections to be redirected to the proxy, it’s possible to handle requests to multiple different hosts with little difficulty.</p>&#13;
<h5 class="h5" id="ch00lev1sec46"><strong>Disadvantages of a Reverse HTTP Proxy</strong></h5>&#13;
<p class="noindent">The disadvantages of a reverse HTTP proxy are basically the same as for a forwarding proxy. The proxy must be able to parse the HTTP request and handle the idiosyncrasies of the protocol.</p>&#13;
<h3 class="h3" id="ch00lev1sec47"><strong>Final Words</strong></h3>&#13;
<p class="noindent">You’ve read about passive and active capture techniques in this chapter, but is one better than the other? That depends on the application you’re trying to test. Unless you are just monitoring network traffic, it pays to take an active approach. As you continue through this book, you’ll realize that active capture has significant benefits for protocol analysis and exploitation. If you have a choice in your application, use SOCKS because it’s the easiest approach in many circumstances.<span epub:type="pagebreak" id="page_36"/></p>&#13;
</body></html>