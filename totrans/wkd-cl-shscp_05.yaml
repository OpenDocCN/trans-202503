- en: '**4**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**TWEAKING UNIX**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An outsider might imagine Unix as a nice, uniform command line experience across
    many different systems, helped by their compliance with the POSIX standards. But
    anyone who’s ever used more than one Unix system knows how much they can vary
    within these broad parameters. You’d be hard-pressed to find a Unix or Linux box
    that doesn’t have `ls` as a standard command, for example, but does your version
    support the `--color` flag? Does your version of the Bourne shell support variable
    slicing (like `${var:0:2}`)?
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps one of the most valuable uses of shell scripts is tweaking your particular
    flavor of Unix to make it more like other systems. Although most modern GNU utilities
    run just fine on non-Linux Unixes (for example, you can replace clunky old `tar`
    with the newer GNU `tar`), often the system updates involved in tweaking Unix
    don’t need to be so drastic, and it’s possible to avoid the potential problems
    inherent in adding new binaries to a supported system. Instead, shell scripts
    can be used to map popular flags to their local equivalents, to use core Unix
    capabilities to create a smarter version of an existing command, or even to address
    the longtime lack of certain functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '**#27 Displaying a File with Line Numbers**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are several ways to add line numbers to a displayed file, many of which
    are quite short. For example, here’s one solution using `awk`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: On some Unix implementations, the `cat` command has an `-n` flag, and on others,
    the `more` (or `less`, or `pg`) pager has a flag for specifying that each line
    of output should be numbered. But on some Unix flavors, none of these methods
    will work, in which case the simple script in [Listing 4-1](ch04.xhtml#ch4ex1)
    can do the job.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-1: The* `*numberlines*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a trick to the main loop in this program: it looks like a regular `while`
    loop, but the important part is actually `done < $filename` ➌. It turns out that
    every major block construct acts as its own virtual subshell, so this file redirection
    is not only valid but also an easy way to have a loop that iterates line by line
    with the content of `$filename`. Couple that with the `read` statement at ➊—an
    inner loop that loads each line, iteration by iteration, into the `line` variable—and
    it’s then easy to output the line with its line number as a preface and increment
    the `linecount` variable ➋.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can feed as many filenames as you want into this script. You can’t feed
    it input via a pipe, though that wouldn’t be too hard to fix by invoking a `cat
    -` sequence if no starting parameters are given.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 4-2](ch04.xhtml#ch4ex2) shows a file displayed with line numbers using
    the `numberlines` script.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-2: Testing the* `*numberlines*` *script on an excerpt from* Alice
    in Wonderland'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Once you have a file with numbered lines, you can reverse the order of all
    the lines in the file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This does the trick on systems supporting the `-n` flag to `cat`, for example.
    Where might this be useful? One obvious situation is when displaying a log file
    in newest-to-oldest order.
  prefs: []
  type: TYPE_NORMAL
- en: '**#28 Wrapping Only Long Lines**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One limitation of the `fmt` command and its shell script equivalent, [Script
    #14](ch02.xhtml#ch02lev1sec01) on [page 53](ch02.xhtml#page_53), is that they
    wrap and fill every line they encounter, whether or not it makes sense to do so.
    This can mess up email (wrapping your `.signature` is not good, for example) and
    any input file format where line breaks matter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What if you have a document in which you want to wrap just the long lines but
    leave everything else intact? With the default set of commands available to a
    Unix user, there’s only one way to accomplish this: explicitly step through each
    line in an editor, feeding the long ones to `fmt` individually. (You could accomplish
    this in `vi` by moving the cursor onto the line in question and using `!$fmt`.)'
  prefs: []
  type: TYPE_NORMAL
- en: The script in [Listing 4-3](ch04.xhtml#ch4ex3) automates that task, making use
    of the shell `${#*varname*}` construct, which returns the length of the contents
    of the data stored in the variable `*varname*`.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-3: The* `*toolong*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice that the file is fed to the `while` loop with a simple `< $1` associated
    with the end of the loop ➋ and that each line can then be analyzed by reading
    it with `read input` ➊, which assigns each line of the file to the `input` variable,
    line by line.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your shell doesn’t have the `${#*var*}` notation, you can emulate its behavior
    with the super useful “word count” command `wc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'However, `wc` has an annoying habit of prefacing its output with spaces to
    get values to align nicely in the output listing. To sidestep that pesky problem,
    a slight modification is necessary to let only digits through the final pipe step,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This script accepts exactly one filename as input, as [Listing 4-4](ch04.xhtml#ch4ex4)
    shows.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-4: Testing the* `*toolong*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that unlike a standard invocation of `fmt`, `toolong` has retained line
    breaks where possible, so the word *sneeze*, which is on a line by itself in the
    input file, is also on a line by itself in the output.
  prefs: []
  type: TYPE_NORMAL
- en: '**#29 Displaying a File with Additional Information**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Many of the most common Unix and Linux commands were originally designed for
    slow, barely interactive output environments (we did talk about Unix being an
    ancient OS, right?) and therefore offer minimal output and interactivity. An example
    is `cat`: when used to view a short file, it doesn’t give much helpful output.
    It would be nice to have more information about the file, though, so let’s get
    it! [Listing 4-5](ch04.xhtml#ch4ex5) details the `showfile` command, an alternative
    to `cat`.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-5: The* `*showfile*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To simultaneously read the input line by line and add head and foot information,
    this script uses a handy shell trick: near the end of the script, it redirects
    the input to the `while` loop with the snippet `done < $input` ➊. Perhaps the
    most complex element in this script, however, is the invocation of `sed` for lines
    longer than the specified length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Lines greater than the maximum allowable length are wrapped with `fmt` (or
    its shell script replacement, [Script #14](ch02.xhtml#ch02lev1sec01) on [page
    53](ch02.xhtml#page_53)). To visually denote which lines are continuations and
    which are retained intact from the original file, the first output line of the
    excessively long line has the usual two-space indent, but subsequent lines are
    prefixed with a plus sign and a single space instead. Finally, piping the output
    into `${PAGER:more}` displays the file with the pagination program set with the
    system variable `$PAGER` or, if that’s not set, the `more` program ➋.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can run `showfile` by specifying one or more filenames when the program
    is invoked, as [Listing 4-6](ch04.xhtml#ch4ex6) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-6: Testing the* `*showfile*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '**#30 Emulating GNU-Style Flags with quota**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The inconsistency across the command flags of various Unix and Linux systems
    is a perpetual problem that causes lots of grief for users who switch between
    any of the major releases, particularly between a commercial Unix system (SunOS/Solaris,
    HP-UX, and so on) and an open source Linux system. One command that demonstrates
    this problem is `quota`, which supports full-word flags on some Unix systems but
    accepts only one-letter flags on others.
  prefs: []
  type: TYPE_NORMAL
- en: A succinct shell script (shown in [Listing 4-7](ch04.xhtml#ch4ex7)) solves the
    problem by mapping any full-word flags specified to the equivalent single-letter
    alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-7: The* `*newquota*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This script really boils down to a `while` statement that steps through every
    argument specified to the script, identifying any of the matching full-word flags
    and adding the associated one-letter flag to the `flags` variable. When done,
    it simply invokes the original quota program ➊ and adds the user-specified flags
    as needed.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are a couple of ways to integrate a wrapper of this nature into your
    system. The most obvious is to rename this script `quota`, then place this script
    in a local directory (say, */usr/local/bin*), and ensure that users have a default
    `PATH` that looks in this directory before looking in the standard Linux binary
    distro directories (*/bin* and */usr/bin*). Another way is to add system-wide
    aliases so that a user entering `quota` actually invokes the `newquota` script.
    (Some Linux distros ship with utilities for managing system aliases, such as Debian’s
    `alternatives` system.) This last strategy could be risky, however, if users call
    `quota` with the new flags in their own shell scripts: if those scripts don’t
    use the user’s interactive login shell, they might not see the specified alias
    and will end up calling the base `quota` command rather than `newquota`.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 4-8](ch04.xhtml#ch4ex8) details running `newquota` with the `--verbose`
    and `--quiet` arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-8: Testing the* `*newquota*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: The `--quiet` mode emits output only if the user is over quota. You can see
    that this is working correctly from the last result, where we’re not over quota.
    Phew!
  prefs: []
  type: TYPE_NORMAL
- en: '**#31 Making sftp Look More Like ftp**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The secure version of the File Transfer Protocol `ftp` program is included as
    part of `ssh`, the Secure Shell package, but its interface can be a bit confusing
    for users who are making the switch from the crusty old `ftp` client. The basic
    problem is that `ftp` is invoked as `ftp remotehost` and it then prompts for account
    and password information. By contrast, `sftp` wants to know the account and remote
    host on the command line and won’t work properly (or as expected) if only the
    host is specified.
  prefs: []
  type: TYPE_NORMAL
- en: To address this, the simple wrapper script detailed in [Listing 4-9](ch04.xhtml#ch4ex9)
    allows users to invoke `mysftp` exactly as they would have invoked the `ftp` program
    and be prompted for the necessary fields.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-9: The* `*mysftp*` *script, a friendlier version of* `*sftp*`'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a trick in this script worth mentioning. It’s actually something we’ve
    done in previous scripts, though we haven’t highlighted it for you before: the
    last line is an `exec` call ➊. What this does is *replace* the currently running
    shell with the application specified. Because you know there’s nothing left to
    do after calling the `sftp` command, this method of ending our script is much
    more resource efficient than having the shell hanging around waiting for `sftp`
    to finish using a separate subshell, which is what would happen if we just invoked
    `sftp` instead.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As with the `ftp` client, if users omit the remote host, the script continues
    by prompting for a remote host. If the script is invoked as `mysftp remotehost`,
    the `remotehost` provided is used instead.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s see what happens when you invoke this script without any arguments versus
    invoking `sftp` without any arguments. [Listing 4-10](ch04.xhtml#ch4ex10) shows
    running `sftp`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-10: Running the* `*sftp*` *utility with no arguments yields very
    cryptic help output.*'
  prefs: []
  type: TYPE_NORMAL
- en: That’s useful but confusing. By contrast, with the `mysftp` script you can proceed
    to make an actual connection, as [Listing 4-11](ch04.xhtml#ch4ex11) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-11: Running the* `*mysftp*` *script with no arguments is much clearer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Invoke the script as if it were an `ftp` session by supplying the remote host,
    and it’ll prompt for the remote account name (detailed in [Listing 4-12](ch04.xhtml#ch4ex12))
    and then invisibly invoke `sftp`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-12: Running the* `*mysftp*` *script with a single argument: the
    host to connect to*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One thing to always think about when you have a script like this is whether
    it can be the basis of an automated backup or sync tool, and `mysftp` is a perfect
    candidate. So a great hack would be to designate a directory on your system, for
    example, then write a wrapper that would create a ZIP archive of key files, and
    use `mysftp` to copy them up to a server or cloud storage system. In fact, we’ll
    do just that later in the book with [Script #72](ch09.xhtml#ch09lev1sec04) on
    [page 229](ch09.xhtml#page_229).'
  prefs: []
  type: TYPE_NORMAL
- en: '**#32 Fixing grep**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some versions of `grep` offer a remarkable range of capabilities, including
    the particularly useful ability to show the context (a line or two above and below)
    of a matching line in the file. Additionally, some versions of `grep` can highlight
    the region in the line (for simple patterns, at least) that matches the specified
    pattern. You might already have such a version of `grep`. Then again, you might
    not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, both of these features can be emulated with a shell script, so
    you can still use them even if you’re on an older commercial Unix system with
    a relatively primitive `grep` command. To specify the number of lines of context
    both above and below the line matching the pattern that you specified, use `-c
    *value*`, followed by the pattern to match. This script (shown in [Listing 4-13](ch04.xhtml#ch4ex13))
    also borrows from the ANSI color script, [Script #11](ch01.xhtml#ch01lev1sec12)
    on [page 40](ch01.xhtml#page_40), to do region highlighting.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-13: The* `*cgrep*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This script uses `grep -n` to get the line numbers of all matching lines in
    the file ➋ and then, using the specified number of lines of context to include,
    identifies a starting ➌ and ending ➍ line for displaying each match. These are
    written out to the temporary `sed` script defined at ➊, which executes a word
    substitution command that wraps the specified pattern in bold-on and bold-off
    ANSI sequences. That’s 90 percent of the script, in a nutshell.
  prefs: []
  type: TYPE_NORMAL
- en: The other thing worth mentioning in this script is the useful `trap` command
    ➎, which lets you tie events into the shell’s script execution system itself.
    The first argument is the command or sequence of commands you want invoked, and
    all subsequent arguments are the specific signals (events). In this case, we’re
    telling the shell that when the script exits, invoke `rm` to remove the two temp
    files.
  prefs: []
  type: TYPE_NORMAL
- en: What’s particularly nice about working with `trap` is that it works regardless
    of where you exit the script, not just at the very bottom. In subsequent scripts,
    you’ll see that `trap` can be tied to a wide variety of signals, not just `SIGEXIT`
    (or `EXIT`, or the numeric equivalent of `SIGEXIT`, which is `0`). In fact, you
    can have different `trap` commands associated with different signals, so you might
    output a “cleaned-up temp files” message if someone sends a `SIGQUIT` (CTRL-C)
    to a script, while that wouldn’t be displayed on a regular (`SIGEXIT`) event.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This script works either with an input stream, in which case it saves the input
    to a temp file and then processes the temp file as if its name had been specified
    on the command line, or with a list of one or more files on the command line.
    [Listing 4-14](ch04.xhtml#ch4ex14) shows passing a single file via the command
    line.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-14: Testing the* `*cgrep*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A useful refinement to this script would return line numbers along with the
    matched lines.
  prefs: []
  type: TYPE_NORMAL
- en: '**#33 Working with Compressed Files**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Throughout the years of Unix development, few programs have been reconsidered
    and redeveloped more times than `compress`. On most Linux systems, three significantly
    different compression programs are available: `compress`, `gzip`, and `bzip2`.
    Each uses a different suffix (*.z*, *.gz*, and *.bz2*, respectively), and the
    degree of compression can vary among the three programs, depending on the layout
    of data within a file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless of the level of compression, and regardless of which compression
    programs you have installed, working with compressed files on many Unix systems
    requires decompressing them by hand, accomplishing the desired tasks, and recompressing
    them when finished. Tedious, and thus a perfect job for a shell script! The script
    detailed in [Listing 4-15](ch04.xhtml#ch4ex15) acts as a convenient compression/decompression
    wrapper for three functions you’ll often find yourself wanting to use on compressed
    files: `cat`, `more`, and `grep`.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-15: The* `*zcat*`*/*`*zmore*`*/*`*zgrep*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For any given suffix, three steps are necessary: decompress the file, rename
    the filename to remove the suffix, and add it to the list of files to recompress
    at the end of the script. By keeping three separate lists, one for each compression
    program, this script also lets you easily `grep` across files compressed using
    different compression utilities.'
  prefs: []
  type: TYPE_NORMAL
- en: The most important trick is the use of the `eval` directive when recom-pressing
    the files ➊➋➌. This is necessary to ensure that filenames with spaces are treated
    properly. When the `Zlist`, `gzlist,` and `bzlist` variables are instantiated,
    each argument is surrounded by quotes, so a typical value might be `""sample.c"
    "test.pl" "penny.jar""`. Because the list has nested quotes, invoking a command
    like `cat $Zlist` results in `cat` complaining that file `"sample.c"` wasn’t found.
    To force the shell to act as if the command were typed at a command line (where
    the quotes are stripped once they have been utilized for `arg` parsing), use `eval`,
    and all will work as desired.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To work properly, this script should have three names. How do you do that in
    Linux? Simple: links. You can use either symbolic links, which are special files
    that store the names of link destinations, or hard links, which are actually assigned
    the same inode as the linked file. We prefer symbolic links. These can easily
    be created (here the script is already called `zcat`), as [Listing 4-16](ch04.xhtml#ch4ex16)
    shows.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-16: Symbolically linking the* `*zcat*` *script to the* `*zmore*`
    *and* `*zgrep*` *commands*'
  prefs: []
  type: TYPE_NORMAL
- en: Once that’s done, you have three new commands that have the same actual (shared)
    contents, and each accepts a list of files to process as needed, decompressing
    and then recompressing them when done.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The ubiquitous `compress` utility quickly shrinks down *ragged.txt* and gives
    it a *.z* suffix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With *ragged.txt* in its compressed state, we can view the file with `zcat`,
    as [Listing 4-17](ch04.xhtml#ch4ex17) details.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-17: Using* `*zcat*` *to print the compressed text file*'
  prefs: []
  type: TYPE_NORMAL
- en: And then search for *teacup* again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: All the while, the file starts and ends in its original compressed state, shown
    in [Listing 4-18](ch04.xhtml#ch4ex18).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-18: The results of* `*ls*`*, showing only that the compressed file
    exists*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Probably the biggest weakness of this script is that if it is canceled in midstream,
    the file isn’t guaranteed to recompress. A nice addition would be to fix this
    with a smart use of the `trap` capability and a recompress function that does
    error checking.
  prefs: []
  type: TYPE_NORMAL
- en: '**#34 Ensuring Maximally Compressed Files**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As highlighted in [Script #33](ch04.xhtml#ch04lev1sec07) on [page 109](ch04.xhtml#page_109),
    most Linux implementations include more than one compression method, but the onus
    is on the user to figure out which one does the best job of compressing a given
    file. As a result, users typically learn how to work with just one compression
    program without realizing that they could attain better results with a different
    one. Even more confusing is the fact that some files compress better with one
    algorithm than with another, and there’s no way to know which is better without
    experimentation.'
  prefs: []
  type: TYPE_NORMAL
- en: The logical solution is to have a script that compresses files using each of
    the tools and then selects the smallest resultant file as the best. That’s exactly
    what `bestcompress` does, shown in [Listing 4-19](ch04.xhtml#ch4ex19)!
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-19: The* `*bestcompress*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The most interesting line in this script is at ➋. This line has `ls` output
    the size of each file (the original and the three compressed files, in a known
    order), chops out just the file sizes with `awk`, sorts these numerically, and
    ends up with the line number of the smallest resultant file. If the compressed
    versions are all bigger than the original file, the result is `1`, and an appropriate
    message is printed out ➌. Otherwise, `smallest` will indicate which of `compress`,
    `gzip`, or `bzip2` did the best job. Then it’s just a matter of moving the appropriate
    file into the current directory and removing the original file.
  prefs: []
  type: TYPE_NORMAL
- en: The three compression calls starting at ➊ are also worth pointing out. These
    calls are done in parallel by using the trailing `&` to drop each of them into
    its own subshell, followed by the call to `wait`, which stops the script until
    all the calls are completed. On a uniprocessor, this might not offer much performance
    benefit, but with multiple processors, it should spread the task out and potentially
    complete quite a bit faster.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This script should be invoked with a list of filenames to compress. If some
    of them are already compressed and you want to try compressing them further, use
    the `-a` flag; otherwise they’ll be skipped.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The best way to demonstrate this script is with a file that needs to be compressed,
    as [Listing 4-20](ch04.xhtml#ch4ex20) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-20: Showing the* `*ls*` *output of a copy of* Alice in Wonderland*.
    Note the file size of 154872 bytes.*'
  prefs: []
  type: TYPE_NORMAL
- en: The script hides the process of compressing the file with each of the three
    compression tools and instead simply displays the results, shown in [Listing 4-21](ch04.xhtml#ch4ex21).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-21: Running the* `*bestcompress*` *script on* alice.txt'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-22](ch04.xhtml#ch4ex22) demonstrates that the file is now quite
    a bit smaller.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-22: Demonstrating the much-reduced file size of the compressed file
    (66287 bytes) compared to [Listing 4-20](ch04.xhtml#ch4ex20)*'
  prefs: []
  type: TYPE_NORMAL
