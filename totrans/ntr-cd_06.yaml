- en: '**5 Autonomous Agents**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**5 自主代理**'
- en: '*Life is a journey, not a destination.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*生活是一场旅程，而非目的地。*'
- en: —Ralph Waldo Emerson
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: —拉尔夫·沃尔多·爱默生
- en: '![Image](../images/pg253_Image_364.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg253_Image_364.jpg)'
- en: '**Mo’i fish (photo courtesy of the US National Oceanic and Atmospheric Administration)**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**莫伊鱼（图片由美国国家海洋和大气管理局提供）**'
- en: Six-finger threadfins (*Polydactylus sexfilis*), also known as fish of kings,
    or *mo*’*i*, in Hawaiian, are shown swimming in a shoal. The mo’i fish held a
    special status for Hawaiian royalty and were raised in dedicated ponds to ensure
    their population growth and prevent their extinction. The fish display a delicate
    and coordinated dance in their collective movement, with each individual mo’i
    subtly influencing and being influenced by its neighboring fish.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 六指丝鳞鱼（*Polydactylus sexfilis*），也叫“王鱼”，或在夏威夷语中称为*mo’i*，它们在群体中游动。莫伊鱼在夏威夷王室中享有特殊地位，专门在养殖池中培育，以确保它们的种群增长并防止灭绝。这些鱼在集体运动中展示出精妙而协调的舞蹈，每条莫伊鱼都在微妙地影响并被邻近的鱼所影响。
- en: 'So far, I’ve been demonstrating inanimate objects, lifeless shapes sitting
    on the canvas that flop around when affected by forces in their environment. But
    this is *The **Nature** of Code*. What if I could breathe life into those shapes?
    What if those shapes could live by their own rules? Can shapes have hopes and
    dreams and fears? These sorts of questions are the domain of this chapter. They’re
    what separate unthinking objects from something much more interesting: autonomous
    agents.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我一直在展示没有生命的物体、静止的形状，它们在外界力量的作用下摇摆不定。但这就是*代码的**本质**。*如果我能为这些形状注入生命呢？如果这些形状能够按照自己的规则生存呢？形状能有希望、梦想和恐惧吗？这些问题是本章的主题。它们是将无意识的物体与更有趣的事物区分开来的关键：自主代理。
- en: '**Forces from Within**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**来自内部的力量**'
- en: An **autonomous agent** is an entity that makes its own choices about how to
    act in its environment, without any influence from a leader or global plan. In
    this book, *acting* typically means moving. For example, instead of simulating
    a particle that’s passively drawn toward or repelled by another shape because
    of a force like gravity, I’d now like to design an entity that has the ability—or
    even the “desire”—to make decisions about its movements. It could *decide* to
    move toward or away from a target, like a moth drawn to a flame or a small fish
    evading a predator.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**自主代理**是一个能够在其环境中做出自己行动决定的实体，而不受任何领导者或全球计划的影响。在本书中，*行动*通常指的是移动。例如，我不再模拟一个被重力等力吸引或排斥的粒子，而是希望设计一个具有能力——甚至是“愿望”——做出自己移动决策的实体。它可以*决定*朝着某个目标移动或远离目标，就像一只飞蛾被火焰吸引，或一条小鱼躲避捕食者一样。'
- en: The switch from inanimate objects to autonomous agents is a significant conceptual
    leap, but the codebase will barely change. The desire for an autonomous agent
    to move is just another force, like the force of gravity or the force of the wind.
    It’s just that now the force is coming *from within*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 从无生命物体到自主代理的转变是一个重要的概念飞跃，但代码本身几乎没有变化。自主代理想要移动的欲望只是另一种力，就像重力或风力一样。只不过现在这种力是*来自内部*的。
- en: 'Here are three key components of autonomous agents to keep in mind as I build
    this chapter’s examples:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我构建本章示例时，有三个自主代理的关键组成部分需要牢记：
- en: '**An autonomous agent has a limited ability to perceive its environment.**
    It makes sense that a living, breathing being should be aware of its environment.
    However, this awareness doesn’t refer to just the external environment but also
    to the agent’s internal state—its position, velocity, and potentially other properties
    or even simulated emotions. Throughout the chapter, I’ll explore ways agents can
    take their own state into account when making decisions. I’ll also cover programming
    techniques for objects to store references to other objects and therefore “perceive”
    their surroundings. It’s important to consider the word *limited* here. Are you
    designing an all-knowing circle that flies around a canvas, aware of everything
    else in that canvas? Or are you creating a shape that can examine other shapes
    only within 15 pixels of itself? Of course, there’s no right answer to this question;
    it all depends on what you want. I’ll explore several possibilities throughout
    this chapter, but in general, limitations are good for creating a simulation that
    feels more “natural.” An insect, for example, may be aware of only the sights
    and smells that immediately surround it. To model a real-world creature, you could
    study the exact science of these limitations. Luckily, I can just make stuff up
    and try it out.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自主智能体对其环境的感知能力是有限的。** 生活和呼吸的生物应该能够意识到其环境的存在是合理的。然而，这种意识不仅仅指外部环境，还包括智能体的内部状态——如位置、速度，甚至可能包括其他属性或模拟的情感。在本章中，我将探讨智能体在做出决策时如何考虑自身状态。我还将介绍一些编程技术，使对象能够存储对其他对象的引用，从而“感知”其周围环境。这里的*有限*一词很重要。你是在设计一个全知的圆形对象，它可以在画布上飞行，意识到画布中的一切吗？还是你在创建一个只能观察到自己15像素范围内其他形状的形状？当然，这个问题没有唯一的正确答案；一切取决于你的需求。在本章中，我将探讨几种可能性，但总的来说，局限性有助于创建一个更“自然”的模拟。例如，一只昆虫可能只会感知到立即围绕它的景象和气味。要模拟一种真实的生物，你可以研究这些局限性的确切科学。幸运的是，我只需凭空想象并进行尝试。'
- en: '**An autonomous agent processes the information from its environment and calculates
    an action.** This will be the easy part, as the action is a force. The environment
    might tell the agent that there’s a big, scary-looking shark swimming right at
    it, and the action will be a powerful force in the opposite direction.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自主智能体处理来自环境的信息并计算出一个行动。** 这一部分相对简单，因为行动本身就是一种力。环境可能会告诉智能体，有一只巨大的、看起来很可怕的鲨鱼正向它游来，那么它的行动将是朝相反方向施加的强大力量。'
- en: '**An autonomous agent has no leader.** This third principle is something I
    care a little less about, depending on the context. For example, if you’re designing
    a system for which it makes sense to have a leader barking commands at various
    entities, then that’s what you’ll want to implement. Nevertheless, many of the
    chapter’s examples will have no leader for an important reason: toward the end
    of this chapter, I’ll examine group behaviors and look at designing collections
    of autonomous agents that exhibit the properties of **complex systems**. These
    are intelligent and structured group dynamics that emerge not from a leader, but
    from the local interactions of the elements themselves.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自主智能体没有领导者。** 这个第三条原则根据上下文，我可能不太关心。例如，如果你在设计一个系统，在这个系统中让领导者向各个实体发号施令是合适的，那么你就可以这样实现。然而，本章中的许多示例将没有领导者，这是有重要原因的：在本章的最后，我将研究群体行为，并探讨如何设计表现出**复杂系统**特性的自主智能体集合。这些是智能的、有结构的群体动态，它们并非来自领导者，而是来自元素之间局部互动的结果。'
- en: 'I could start my exploration of autonomous agents in many places. Artificial
    simulations of ant and termite colonies are fantastic demonstrations of systems
    of agents, for example. For more on this topic, I encourage you to read *Turtles,
    Termites, and Traffic Jams* by Mitchel Resnick (Bradford Books, 1997). However,
    I want to begin by examining agent behaviors that build on the work in the first
    four chapters of this book: modeling motion with vectors and forces. And so I’ll
    return to the book’s ever-changing hero class—once `Walker`, then `Mover`, then
    `Particle`—and give it yet another incarnation.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以从许多地方开始探索自主智能体。例如，人工模拟的蚂蚁和白蚁群体是智能体系统的极好示范。关于这个话题，我鼓励你阅读Mitchel Resnick的《*乌龟、白蚁与交通堵塞*》（Bradford
    Books，1997）。然而，我想从本书前四章的工作基础上出发，首先探讨建立在向量和力的运动建模上的智能体行为。因此，我将回到本书那本不断变化的英雄类——最初是`Walker`，然后是`Mover`，再到`Particle`——并赋予它全新的形式。
- en: '**Vehicles and Steering**'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**车辆与转向**'
- en: 'In the late 1980s, computer scientist Craig Reynolds (*[https://www.red3d.com/cwr](https://www.red3d.com/cwr)*)
    developed algorithmic **steering** behaviors for animated characters. These behaviors
    allowed individual elements to navigate their digital environments in a lifelike
    manner, with strategies for fleeing, wandering, arriving, pursuing, evading, and
    more. Later, in his 1999 paper “Steering Behaviors for Autonomous Characters,”
    Reynolds uses the word *vehicle* to describe his autonomous agents. I’ll follow
    suit, calling my autonomous agent class `Vehicle`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在1980年代末，计算机科学家 Craig Reynolds (*[https://www.red3d.com/cwr](https://www.red3d.com/cwr)*)
    为动画角色开发了算法化的 **转向** 行为。这些行为允许个体元素以生动的方式在其数字环境中导航，拥有逃跑、徘徊、到达、追踪、躲避等策略。后来，在他1999年的论文《自主角色的转向行为》中，Reynolds
    使用 *车辆* 一词来描述他的自主代理。我将效仿他，称我的自主代理类为 `Vehicle`：
- en: '![Image](../images/pg255_Image_364a.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg255_Image_364a.jpg)'
- en: Like the `Mover` and `Particle` classes before it, the `Vehicle` class’s motion
    is controlled through its position, velocity, and acceleration vectors. This will
    make the steering behaviors of a single autonomous agent straightforward to implement.
    Yet by building a system of multiple vehicles that steer themselves according
    to simple, locally based rules, surprising levels of complexity emerge. The most
    famous example is Reynolds’s boids model for flocking or swarming behavior, which
    I’ll demonstrate in [Example 5.11](ch05.xhtml#ch5ex11).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前的 `Mover` 类和 `Particle` 类一样，`Vehicle` 类的运动是通过其位置、速度和加速度向量来控制的。这将使单个自主代理的转向行为变得易于实现。然而，通过构建一个由多个车辆组成的系统，这些车辆根据简单的局部规则自行转向，会产生惊人的复杂性。最著名的例子是
    Reynolds 的鸟群模型，它展示了群体或集群行为，我将在 [示例 5.11](ch05.xhtml#ch5ex11) 中展示。
- en: '![Image](../images/zoom.jpg) **Why Vehicles?**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/zoom.jpg) **为什么是车辆？**'
- en: 'In his book *Vehicles: Experiments in Synthetic Psychology* (Bradford Books,
    1986), Italian neuroscientist and cyberneticist Valentino Braitenberg describes
    a series of hypothetical vehicles with simple internal structures, writing, “This
    is an exercise in fictional science, or science fiction, if you like that better.”
    Braitenberg argues that his extraordinarily simple mechanical vehicles manifest
    behaviors such as fear, aggression, love, foresight, and optimism. Reynolds took
    his inspiration from Braitenberg, and I’ll take mine from Reynolds.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在他的书《车辆：合成心理学实验》（Bradford Books，1986年）中，意大利神经科学家和控制论学者 Valentino Braitenberg
    描述了一系列假设的车辆，具有简单的内部结构，他写道：“这是一个虚构科学的练习，或者如果你更喜欢，可以称之为科幻小说。”Braitenberg 认为，他那些极其简单的机械车辆展现了诸如恐惧、攻击、爱情、预见和乐观等行为。Reynolds
    从 Braitenberg 中汲取了灵感，而我将从 Reynolds 中获得我的灵感。
- en: 'Reynolds describes the motion of *idealized* vehicles—idealized because he
    wasn’t concerned with their actual engineering, but rather started with the assumption
    that they work and respond to the rules defined. These vehicles have three layers:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Reynolds 描述了 *理想化* 车辆的运动——理想化是因为他不关心它们的实际工程，而是从它们能够正常工作并响应所定义规则的假设出发。这些车辆有三个层次：
- en: '**Action selection:** A vehicle has a goal (or goals) and can choose an action
    (or a combination of actions) based on that goal. This is essentially where I
    left off in the discussion of autonomous agents. The vehicle takes a look at its
    environment and *selects* an action based on a desire: “I see a zombie marching
    toward me. Since I don’t want my brains to be eaten, I’m going to flee from the
    zombie.” The goal is to keep one’s brains, and the action is to flee. Reynolds’s
    paper describes many goals and associated actions, such as seeking a target, avoiding
    an obstacle, and following a path. In a moment, I’ll start building out these
    examples with p5.js code.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**动作选择：** 一辆车有一个目标（或多个目标），并可以根据该目标选择一个动作（或多个动作的组合）。这本质上是我在讨论自主代理时的停顿点。车辆观察环境并基于一种欲望来*选择*一个动作：“我看到一个僵尸朝我走来。因为我不想让我的大脑被吃掉，我要从僵尸那里逃跑。”目标是保住自己的大脑，动作是逃跑。Reynolds
    的论文描述了许多目标和相关的动作，比如寻找目标、避开障碍物和跟踪路径。稍后，我将用 p5.js 代码展开这些示例。'
- en: '**Steering:** Once an action has been selected, the vehicle has to calculate
    its next move. That next move will be a force—more specifically, a steering force.
    Luckily, Reynolds has developed a simple steering force formula that I’ll use
    throughout the examples in this chapter: **steering force = desired velocity –
    current velocity**. I’ll get into the details of this formula and why it works
    so effectively in the next section.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**转向：** 一旦选择了一个动作，车辆就必须计算其下一步行动。下一步将是一个力——更具体地说，是一个转向力。幸运的是，Reynolds提出了一个简单的转向力公式，我将在本章的例子中使用：**转向力
    = 期望速度 - 当前速度**。我将在下一节详细讨论这个公式以及它为何如此有效。'
- en: '**Locomotion:** For the most part, I’m going to ignore this third layer. In
    the case of fleeing from zombies, the locomotion could be described as “left foot,
    right foot, left foot, right foot, as fast as you can.” In a canvas, however,
    a rectangle, circle, or triangle’s actual movement across a window is irrelevant,
    given that the motion is all an illusion in the first place. This isn’t to say
    that you should ignore locomotion entirely, however. You’ll find great value in
    thinking about the locomotive design of your vehicle and how you choose to animate
    it. The examples in this chapter will remain visually bare; a good exercise would
    be to elaborate on the animation style. For example, could you add spinning wheels,
    oscillating paddles, or shuffling legs?'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**运动方式：** 大多数情况下，我将忽略这一第三层。在逃避僵尸的情况下，运动方式可以描述为“左脚，右脚，左脚，右脚，尽可能快。”然而，在画布中，一个矩形、圆形或三角形在窗口中的实际运动并不重要，因为运动本身就是一种幻觉。但这并不是说你应该完全忽视运动方式。你会发现，思考你车辆的运动设计以及如何选择动画呈现它会非常有价值。本章中的示例将保持视觉上的简洁；一个不错的练习是展开动画风格。例如，你能为它添加旋转的轮子、摆动的桨板，或者是走动的腿吗？'
- en: 'Ultimately, the most important layer for you to consider is the first one,
    action selection. What are the elements of your system, and what are their goals?
    In this chapter, I’m going to cover a series of steering behaviors (that is, actions):
    seeking, fleeing, following a path, following a flow field, flocking with your
    neighbors, and so on. As I’ve said in other chapters, however, the point isn’t
    that you should use these exact behaviors in all your projects. Rather, the point
    is to show you *how* to model a steering behavior—*any* steering behavior—in code,
    and to provide a foundation for designing and developing your own vehicles with
    new and exciting goals and behaviors.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，最重要的层次是你需要考虑的第一层，动作选择。你的系统元素是什么，它们的目标是什么？在本章中，我将涵盖一系列转向行为（即动作）：寻找目标、逃避、跟随路径、跟随流场、与邻居集群等等。然而，正如我在其他章节中所说，重点不是你在所有项目中都使用这些具体的行为。而是，重点是教你*如何*在代码中建模转向行为——*任何*转向行为——并为你设计和开发具有新目标和行为的车辆提供基础。
- en: What’s more, even though the examples in this chapter are highly literal (follow
    that pixel!), you should allow yourself to think more abstractly (like Braitenberg).
    What would it mean for your vehicle to have “love” as its goal or “fear” as its
    driving force? Finally (and I’ll address this in “Combining Behaviors” on [page
    265](ch05.xhtml#ch00lev2sec36)), you won’t get very far by developing simulations
    with only one action. Yes, the first example’s action will be to seek a target.
    But by being creative—by making these steering behaviors *your own*—it will all
    come down to mixing and matching multiple actions within the same vehicle. View
    the coming examples not as singular behaviors to be emulated, but as pieces of
    a larger puzzle that you’ll eventually assemble.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，尽管本章中的示例非常直观（跟着那个像素走！），你应该允许自己更加抽象地思考（就像Braitenberg一样）。如果你的车辆的目标是“爱”或者其驱动力是“恐惧”，那会意味着什么呢？最后（我将在[第265页](ch05.xhtml#ch00lev2sec36)的“结合行为”部分讨论这个问题），仅仅通过开发一个单一动作的模拟，你是走不远的。是的，第一个示例的动作将是寻找目标。但通过发挥创意——通过让这些转向行为*成为你自己的*——最终的关键是将多个动作结合在同一辆车中。将接下来的示例视为一个更大拼图中的一部分，而不是单一的行为模仿。
- en: '**The Steering Force**'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**转向力**'
- en: 'What exactly is a steering force? To answer, consider the following scenario:
    a vehicle with a current velocity is seeking a target. For fun, let’s think of
    the vehicle as a bug-like creature that desires to savor a delicious strawberry,
    as in [Figure 5.1](ch05.xhtml#ch5fig1).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是转向力？为了回答这个问题，考虑以下情境：一辆具有当前速度的车辆正在寻找目标。为了趣味，我们可以把这辆车想象成一只像虫子一样的生物，想要品尝一颗美味的草莓，如[图5.1](ch05.xhtml#ch5fig1)所示。
- en: '![Image](../images/pg257_Image_365.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg257_Image_365.jpg)'
- en: 'Figure 5.1: A vehicle with a velocity and a target'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：具有速度和目标的车辆
- en: The vehicle’s goal and subsequent action is to seek the target. Thinking back
    to [Chapter 2](ch02.xhtml#ch02), you might begin by making the target an attractor
    and applying a gravitational force that pulls the vehicle to the target. This
    would be a perfectly reasonable solution, but conceptually it’s not what I’m looking
    for here.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 该车辆的目标和后续行动是寻找目标。回想一下[第2章](ch02.xhtml#ch02)，你可能会从将目标设为吸引物并应用引力将车辆拉向目标开始。这是一个完全合理的解决方案，但从概念上讲，这并不是我在这里想要的。
- en: 'I don’t want to simply calculate a force that pushes the vehicle toward its
    target; rather, I want to ask the vehicle to make an intelligent decision to steer
    toward the target based on its perception of its own state (its speed and the
    direction in which it’s currently moving) and its environment (the location of
    the target). The vehicle should consider how it desires to move (a vector pointing
    to the target), compare that goal with how it’s currently moving (its velocity),
    and apply a force accordingly. That’s exactly what Reynolds’s steering force formula
    says:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我不想简单地计算一个推动车辆向目标移动的力；相反，我希望要求车辆根据它对自身状态（其速度和当前运动的方向）以及环境（目标的位置）的感知做出智能决策，朝向目标行驶。车辆应考虑它希望如何移动（指向目标的向量），将这个目标与当前的运动状态（其速度）进行比较，并相应地施加力。这正是Reynolds的转向力公式所表达的：
- en: steering force = desired velocity − current velocity
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 转向力 = 期望速度 − 当前速度
- en: 'Or, as you might write in p5.js:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以在p5.js中这样写：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The *current* velocity isn’t a problem: the `Vehicle` class already has a variable
    for that. However, the *desired* velocity has to be calculated. Take a look at
    [Figure 5.2](ch05.xhtml#ch5fig2). If the vehicle’s goal is defined as *seeking
    the target*, then its desired velocity is a vector that points from its current
    position to the target position.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*当前*速度并不是问题：`Vehicle`类已经有一个变量来表示这一点。然而，*期望*速度需要计算。看看[图5.2](ch05.xhtml#ch5fig2)。如果车辆的目标定义为*寻找到目标*，那么它的期望速度就是一个从当前位置指向目标位置的向量。'
- en: '![Image](../images/pg258_Image_366.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg258_Image_366.jpg)'
- en: 'Figure 5.2: The vehicle’s desired velocity points from its position to the
    target. (The desired vector should point from the vehicle’s center to the target’s
    center but is shortened for illustration purposes.)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：车辆期望的速度从其当前位置指向目标。（期望的向量应该从车辆的中心指向目标的中心，但为了说明简化了长度。）
- en: 'Assuming a `p5.Vector` called `target` defining the target’s position, I then
    have this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个`p5.Vector`变量叫做`target`，定义了目标的位置，那么我就有了：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There’s more to the story, however. What if it is a high-resolution canvas
    and the target is thousands of pixels away? Sure, the vehicle might desire to
    teleport itself instantly to the target position with a massive velocity, but
    this won’t make for an effective animation. I’ll restate the desire as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，故事还有更多的内容。如果这是一个高分辨率的画布，而目标距离数千个像素远呢？当然，车辆可能希望以极大的速度瞬间传送到目标位置，但这不会产生有效的动画。我将愿望重新表述如下：
- en: '*The vehicle desires to move toward the target at the maximum possible speed*.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*车辆希望以最大可能的速度朝向目标移动*。'
- en: In other words, the `desired` vector should point from the vehicle’s current
    position to the target position, with a magnitude equal to the maximum speed of
    the vehicle, as shown in [Figure 5.3](ch05.xhtml#ch5fig3).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`期望`向量应该从车辆的当前位置指向目标位置，大小等于车辆的最大速度，如[图5.3](ch05.xhtml#ch5fig3)所示。
- en: '![Image](../images/pg259_Image_367.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg259_Image_367.jpg)'
- en: 'Figure 5.3: The magnitude of the vehicle’s desired velocity is *max speed*.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：车辆期望速度的大小是*最大速度*。
- en: The concept of maximum speed was introduced in [Chapter 1](ch01.xhtml#ch01)
    to ensure that a mover’s speed remained within a reasonable range. However, I
    didn’t always use it in the subsequent chapters. In [Chapter 2](ch02.xhtml#ch02),
    other forces such as friction and drag kept the speed in check, while in [Chapter
    3](ch03.xhtml#ch03), oscillation was caused by opposing forces that kept the speed
    limited. In this chapter, maximum speed is a key parameter for controlling the
    behavior of a steering agent, so I’ll include it in all the examples.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最大速度的概念在[第1章](ch01.xhtml#ch01)中被引入，用以确保移动者的速度保持在合理范围内。然而，在随后的章节中我并未始终使用这一概念。在[第2章](ch02.xhtml#ch02)中，摩擦力和阻力等其他力量限制了速度，而在[第3章](ch03.xhtml#ch03)中，相反的力量导致了振荡，从而保持了速度限制。在本章中，最大速度是控制转向代理行为的关键参数，因此我将在所有示例中包含它。
- en: 'While I encourage you to consider how other forces such as friction and drag
    could be combined with steering behaviors, I’m going to focus only on steering
    forces for the time being. As such, I can include the concept of maximum speed
    as a limiting factor in the force calculation. First, I need to add a property
    to the `Vehicle` class setting the maximum speed:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我鼓励你思考如何将摩擦力和阻力等其他力与转向行为结合起来，但目前我将只关注转向力。因此，我可以将最大速度的概念作为力计算中的限制因素。首先，我需要在`Vehicle`类中添加一个属性，设置最大速度：
- en: '![Image](../images/pg259_Image_368.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg259_Image_368.jpg)'
- en: 'Then, in the desired velocity calculation, I’ll scale according to maximum
    speed:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在期望速度的计算中，我将根据最大速度进行缩放：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Putting this all together, I can now write a method called `seek()` that receives
    a `p5.Vector` target and calculates a steering force toward that target:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 综合这些内容，我现在可以编写一个名为`seek()`的方法，该方法接收一个`p5.Vector`目标并计算指向该目标的转向力：
- en: '![Image](../images/pg259_Image_369.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg259_Image_369.jpg)'
- en: Notice that I finish the method by passing the steering force into `applyForce()`.
    This assumes that the code is built on top of the foundation I developed in [Chapter
    2](ch02.xhtml#ch02).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我在方法结束时将转向力传递给`applyForce()`。这假设代码是建立在我在[第2章](ch02.xhtml#ch02)中开发的基础之上的。
- en: To see why Reynolds’s steering formula works so well, take a look at [Figure
    5.4](ch05.xhtml#ch5fig4). It shows what the steering force looks like relative
    to the vehicle and target positions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解为什么Reynolds的转向公式如此有效，看看[图5.4](ch05.xhtml#ch5fig4)。它展示了转向力相对于车辆和目标位置的表现。
- en: '![Image](../images/pg260_Image_371.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg260_Image_371.jpg)'
- en: 'Figure 5.4: The vehicle applies a steering force equal to its desired velocity
    minus its current velocity.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4：车辆施加的转向力等于期望速度减去当前速度。
- en: 'This force looks quite different from gravitational attraction. Remember one
    of the principles of autonomous agents: an autonomous agent has a *limited* ability
    to perceive its environment, including its own state. Here’s that ability, subtly
    but powerfully embedded into Reynolds’s steering formula. In the case of gravitational
    attraction, the force pulling an object toward another is the same regardless
    of how that object is moving. But here, the vehicle is actively aware of its own
    velocity, and its steering force compensates accordingly. This adds a lifelike
    quality to the simulation, as the way in which the vehicle moves toward the target
    depends on its own understanding of its current motion.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这种力与引力的吸引力看起来有很大的不同。记住自主代理的一个原则：自主代理有*有限*的感知环境的能力，包括对自身状态的感知。这个能力被巧妙而有力地嵌入到Reynolds的转向公式中。在引力吸引的情况下，吸引物体的力是相同的，无论物体如何运动。但在这里，车辆是主动感知自己速度的，并且其转向力会做出相应的补偿。这为模拟增加了一种逼真的质量，因为车辆向目标移动的方式依赖于它对当前运动状态的理解。
- en: 'In all this excitement, I’ve missed one last step. What sort of vehicle is
    this? Is it a super-sleek race car with amazing handling? Or a large city bus
    that needs a lot of advance notice to turn? A graceful panda or a lumbering elephant?
    The example code, as it stands, has no feature to account for this variation in
    steering ability. For that, I need to limit the magnitude of the steering force.
    I’ll call this limit the maximum force (or `maxforce` for short):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一切兴奋之中，我错过了最后一步。这个车辆是什么类型的？是拥有惊人操控性能的超级跑车吗？还是需要大量预警才能转弯的大型城市公交车？是一只优雅的熊猫，还是一只笨拙的大象？目前的示例代码并没有考虑到这一转向能力的差异。为此，我需要限制转向力的大小。我将这个限制称为最大转向力（或简称`maxforce`）：
- en: '![Image](../images/pg260_Image_372.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg260_Image_372.jpg)'
- en: 'Now I just need to impose that limit before applying the steering force:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我只需要在施加转向力之前设定这个限制：
- en: '![Image](../images/pg261_Image_374.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg261_Image_374.jpg)'
- en: 'Limiting the steering force brings up an important point: the goal isn’t to
    get the vehicle to the target as fast as possible. If it were, I would just say,
    “Set position equal to target,” and the vehicle would instantly teleport to that
    location! Instead, as Reynolds puts it, the goal is to move the vehicle in a “lifelike
    and improvisational manner.”'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 限制转向力提出了一个重要的观点：目标不是尽可能快地将车辆送到目标位置。如果是这样，我只需要说，“将位置设置为目标”，车辆就会立刻传送到那个位置！相反，正如雷诺兹所说，目标是让车辆以一种“逼真且即兴的方式”移动。
- en: 'I’m trying to make the vehicle appear to be steering its way to the target,
    so it’s up to me to play with the forces and variables of the system to simulate
    a given behavior. For example, a large maximum steering force would result in
    a very different path than a small one (see [Figure 5.5](ch05.xhtml#ch5fig5)).
    One isn’t inherently better or worse than the other; it depends on the desired
    effect. (And of course, these values need not be fixed and could change based
    on other conditions. Perhaps a vehicle has an *energy* property: the higher the
    energy, the better it can steer.)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我试图让车辆看起来像是在朝目标方向转向，所以我需要调整系统中的力和变量来模拟给定的行为。例如，较大的最大转向力会导致与较小转向力截然不同的路径（见[图5.5](ch05.xhtml#ch5fig5)）。这两者并没有哪一个天生更好或更差；它取决于所需的效果。（当然，这些值不必是固定的，可以根据其他条件变化。也许车辆有一个*能量*属性：能量越高，转向性能越好。）
- en: '![Image](../images/pg261_Image_375.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg261_Image_375.jpg)'
- en: 'Figure 5.5: The path for a stronger maximum force (left) versus a weaker one
    (right)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5：更强的最大力（左）与较弱的最大力（右）路径对比
- en: Here’s the full `Vehicle` class, incorporating the rest of the elements from
    the [Chapter 2](ch02.xhtml#ch02) `Mover` class.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的`Vehicle`类，包含了来自[第2章](ch02.xhtml#ch02) `Mover`类的其余部分。
- en: '![Image](../images/pg262_Image_376.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg262_Image_376.jpg)'
- en: Note that, unlike the circles used to represent movers and particles in previous
    chapters, the `Vehicle` object is drawn as a triangle, defined as three custom
    vertices set with `beginShape()` and `endShape()`. This allows the vehicle to
    be represented in a way that indicates its direction, determined using the `heading()`
    method, as demonstrated in [Chapter 3](ch03.xhtml#ch03).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与之前章节中用来表示移动器和粒子的圆形不同，`Vehicle`对象被绘制为一个三角形，定义为使用`beginShape()`和`endShape()`设置的三个自定义顶点。这允许车辆以一种能够表示其方向的方式呈现，方向是通过`heading()`方法确定的，正如在[第3章](ch03.xhtml#ch03)中展示的那样。
- en: '![Image](../images/pencil.jpg) **Exercise 5.1**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/pencil.jpg) **练习 5.1**'
- en: Implement a *fleeing* steering behavior (the desired velocity is the same as
    *seek*, but pointed in the opposite direction).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个*逃避*转向行为（期望的速度与*寻求*相同，但指向相反的方向）。
- en: '![Image](../images/pencil.jpg) **Exercise 5.2**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/pencil.jpg) **练习 5.2**'
- en: Create a sketch in which a vehicle’s maximum force and maximum speed don’t remain
    constant but vary according to environmental factors.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个草图，在其中，车辆的最大力和最大速度不是保持不变的，而是根据环境因素发生变化。
- en: '![Image](../images/pencil.jpg) **Exercise 5.3**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/pencil.jpg) **练习 5.3**'
- en: Implement a seeking behavior with a moving target, often referred to as *pursuit*.
    In this case, your desired vector won’t point toward the object’s current position,
    but rather its future position as extrapolated from its current velocity. You’ll
    see this ability for a vehicle to “predict the future” in later examples. The
    solution is covered in the “Pursue & Evade” video on the Coding Train website
    (*[https://thecodingtrain.com/pursuit](https://thecodingtrain.com/pursuit)*).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个带有移动目标的追寻行为，通常称为*追逐*。在这种情况下，你的目标向量不会指向物体的当前位置，而是指向从其当前速度推算出的未来位置。你将在后续的示例中看到车辆如何“预测未来”。解决方案在《追逐与逃避》视频中有介绍，视频链接为(*[https://thecodingtrain.com/pursuit](https://thecodingtrain.com/pursuit)*).
- en: '![Image](../images/pg264_Image_378.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg264_Image_378.jpg)'
- en: '**The Arrive Behavior**'
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**到达行为**'
- en: After working for a bit with the seeking behavior, you’re probably asking yourself,
    “What if I want the vehicle to slow down as it approaches the target?” Before
    I can even begin to answer this question, I should explain why the seek behavior
    causes the vehicle to fly past the target in the first place, forcing it to turn
    around and go back. Consider the brain of a seeking vehicle. What is it thinking
    at each frame of the animation?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用寻路行为工作了一段时间后，你可能会问自己：“如果我希望车辆在接近目标时减速呢？”在我开始回答这个问题之前，我应该先解释为什么寻路行为会导致车辆飞越目标，迫使它转身回去。考虑一下寻路车辆的大脑。在每一帧动画中，它在想什么？
- en: I want to go as fast as possible toward the target.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我想尽可能快地朝目标前进。
- en: I want to go as fast as possible toward the target.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我想尽可能快地朝目标前进。
- en: I want to go as fast as possible toward the target.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我想尽可能快地朝目标前进。
- en: I want to go as fast as possible toward the target.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我想尽可能快地朝目标前进。
- en: I want to go as fast as possible toward the target.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我想尽可能快地朝目标前进。
- en: and so on . . .
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依此类推……
- en: The vehicle is so gosh darn excited about getting to the target that it doesn’t
    bother to make any intelligent decisions about its speed. No matter the distance
    to the target, it always wants to go as fast as possible. When the vehicle is
    very close, it will therefore end up overshooting the target (see [Figure 5.6](ch05.xhtml#ch5fig6),
    top).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这辆车对到达目标感到非常兴奋，以至于它不去做任何关于速度的智能决策。不管离目标多远，它总是想尽可能快地行驶。当车辆非常接近目标时，它最终会超越目标（见[图
    5.6](ch05.xhtml#ch5fig6)，顶部）。
- en: '![Image](../images/pg265_Image_379.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg265_Image_379.jpg)'
- en: 'Figure 5.6: The top vehicle has a desired velocity at maximum speed and will
    overshoot the target. The bottom vehicle illustrates scaling the desired velocity
    according to the distance from the target. (While I encourage you to continue
    thinking about the vehicle as a cute, bug-like creature, from this point it’s
    drawn as a triangle to keep things simple.)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6：上方的车辆目标速度设为最大速度，并且会超越目标。下方的车辆示范了根据与目标的距离来缩放目标速度。（虽然我鼓励你继续将车辆想象成一只可爱的虫子，但从这一点开始，它被画成三角形，以简化问题。）
- en: 'In some cases, this is the desired behavior. (Consider a puppy going after
    its favorite toy: it’s not slowing down, no matter how close it gets!) However,
    in many other cases (a car pulling into a parking spot, a bee landing on a flower),
    the vehicle’s thought process needs to consider its speed relative to the distance
    from its target (see [Figure 5.6](ch05.xhtml#ch5fig6), bottom). For example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，这是期望的行为。（想想小狗去追它最喜欢的玩具：无论离玩具多近，它都不会减速！）然而，在许多其他情况下（如汽车驶入停车位、蜜蜂停在花上），车辆的思维过程需要考虑与目标之间的距离相对的速度（见[图
    5.6](ch05.xhtml#ch5fig6)，底部）。例如：
- en: I’m very far away. I want to go as fast as possible toward the target.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我离得很远。我想尽可能快地朝目标前进。
- en: I’m somewhat far away. I still want to go as fast as possible toward the target.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我离目标还有一段距离。我仍然希望尽可能快地朝目标前进。
- en: I’m getting close. I want to go more slowly toward the target.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我快接近了。我想更慢地朝目标前进。
- en: I’m almost there. I want to go very slowly toward the target.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我快到了。我想很慢地朝目标前进。
- en: I’m there. I want to stop!
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我到了。我想停下来！
- en: How can you implement this *arriving* behavior in code? Think back to the `seek()`
    method. Which part of the code sets the magnitude of the desired velocity?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如何在代码中实现这种*到达*行为？回想一下`seek()`方法。代码中的哪部分设置了目标速度的大小？
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This always sets the magnitude of the `desired` vector to `maxspeed`, as in
    [Figure 5.7](ch05.xhtml#ch5fig7).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这总是将`desired`向量的大小设置为`maxspeed`，如[图 5.7](ch05.xhtml#ch5fig7)所示。
- en: '![Image](../images/pg266_Image_380.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg266_Image_380.jpg)'
- en: 'Figure 5.7: The vehicles have a desired velocity with a magnitude set to maximum
    speed, regardless of their relative distance to the target.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7：车辆的目标速度的大小设置为最大速度，无论它们与目标的相对距离如何。
- en: What if instead the desired velocity’s magnitude were equal to half the distance?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果相反，目标速度的大小等于距离的一半呢？
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: I’d still want to limit the magnitude of `desired` to no more than the maximum
    speed, to keep vehicles that are very far away from going ridiculously fast ([Figure
    5.8](ch05.xhtml#ch5fig8)).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我仍然希望将`desired`的大小限制在最大速度之内，以防止那些远距离的车辆行驶得过快（见[图 5.8](ch05.xhtml#ch5fig8)）。
- en: '![Image](../images/pg266_Image_381.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg266_Image_381.jpg)'
- en: 'Figure 5.8: The magnitude of each vehicle’s desired velocity is equal to half
    the distance to the target. In the case of the leftmost vehicle, the velocity
    is constrained to the maximum speed.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8：每个车辆的期望速度大小等于到目标的距离的一半。在最左侧的车辆的情况下，速度被限制为最大速度。
- en: 'While this change nicely demonstrates the goal of tying the desired speed to
    the distance from the target, it’s not a particularly good solution. After all,
    10 pixels away is rather close, and a desired speed of 5 is rather large. Something
    like a desired velocity with a magnitude equal to 5 percent of the distance might
    work better:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这一变化很好地展示了将期望速度与目标距离相联系的目标，但它并不是一个特别好的解决方案。毕竟，10 像素的距离已经相当近，而期望速度为 5 则显得太大。像期望速度的大小等于距离的
    5% 这样的方式可能效果更好：
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Reynolds describes an even more sophisticated approach. Imagine a circle around
    the target with a given radius *r*. If the vehicle is within that circle, it gradually
    slows down—from the maximum speed at the very edge of the circle to zero speed
    at the target ([Figure 5.9](ch05.xhtml#ch5fig9)).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Reynolds 描述了一种更为复杂的方法。设想在目标周围画一个半径为 *r* 的圆。如果车辆在该圆内，它会逐渐减速——从圆的最边缘的最大速度到目标处的零速度（[图
    5.9](ch05.xhtml#ch5fig9)）。
- en: '![Image](../images/pg267_Image_382.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg267_Image_382.jpg)'
- en: 'Figure 5.9: Outside the circle, the magnitude of a vehicle’s desired velocity
    is set to the maximum speed. As vehicles enter the circle and approach the target,
    their desired velocity magnitude decreases.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9：在圆外，车辆的期望速度大小设置为最大速度。随着车辆进入圆内并接近目标，其期望速度的大小逐渐减小。
- en: In other words, if the distance from the target is less than *r*, the desired
    speed ranges from 0 to the maximum speed mapped according to that distance.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果目标的距离小于*r*，期望速度的范围从 0 到根据该距离映射的最大速度。
- en: '![Image](../images/pg267_Image_383.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg267_Image_383.jpg)'
- en: 'The arrive behavior is a great demonstration of an autonomous agent’s perception
    of the environment—including its own state. This model differs from the inanimate
    forces of [Chapter 2](ch02.xhtml#ch02): a celestial body attracted to another
    body doesn’t know it is experiencing gravity, whereas a cheetah chasing its prey
    knows it’s chasing.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到达行为是一个很好的示范，展示了自主体对环境的感知——包括自身的状态。这个模型不同于[第二章](ch02.xhtml#ch02)中的无生命力：一个天体被另一个天体吸引时并不知道自己正在经历引力，而一只猎豹追逐它的猎物时则知道自己正在追赶。
- en: The key is in the way the forces are calculated. For instance, in the gravitational
    attraction sketch ([Example 2.6](ch02.xhtml#ch2ex6)), the force always points
    directly from the object to the target—the exact direction of the desired velocity.
    Here, by contrast, the vehicle perceives its distance to the target and adjusts
    its desired speed accordingly, slowing as it gets closer. The force on the vehicle
    itself is therefore based not just on the desired velocity but also on the desired
    velocity *relative to its current velocity*. The vehicle accounts for its own
    state as part of its assessment of the environment.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于力的计算方式。例如，在引力吸引示意图中（[示例 2.6](ch02.xhtml#ch2ex6)），力总是直接从物体指向目标——也就是期望速度的确切方向。与此相反，这里车辆感知到与目标的距离，并根据该距离调整期望速度，随着接近目标而减速。因此，车辆所受的力不仅基于期望速度，还基于*相对于当前速度的期望速度*。车辆在评估环境时考虑到自身的状态。
- en: 'Put another way, the magic of Reynolds’s *desired minus velocity* equation
    is that it essentially makes the steering force a manifestation of the current
    velocity’s *error*: “I’m supposed to be going this fast in this direction, but
    I’m actually going this fast in another direction. My error is the difference
    between where I want to go and where I’m currently going.” Sometimes this can
    lead to seemingly unexpected results, as in [Figure 5.10](ch05.xhtml#ch5fig10).'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，Reynolds 的 *期望速度减去当前速度* 方程的神奇之处在于，它本质上将转向力表现为当前速度的*误差*：“我应该朝这个方向以这个速度前进，但实际上我在朝另一个方向以这个速度前进。我的误差就是我想去的地方和我目前去的地方之间的差距。”有时这会导致看似意外的结果，如[图
    5.10](ch05.xhtml#ch5fig10)所示。
- en: '![Image](../images/pg269_Image_385.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg269_Image_385.jpg)'
- en: 'Figure 5.10: A vehicle moving toward its target faster than its desired velocity
    will result in a steering force pointing away from the target.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10：一个朝目标移动的车辆，如果速度快于其期望速度，将导致一个指向远离目标的转向力。
- en: In this example of the arrive behavior, the vehicle is moving too fast toward
    the target. The steering force, or error, tells it to slow down by actually pointing
    in the opposite direction, away from the target. By contrast, with gravitational
    attraction, you would never have a force pointing away from the target, no matter
    how close the target is. Taking the error and applying it as a steering force
    results in more dynamic, lifelike simulations.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个“到达”行为的示例中，车辆朝目标移动的速度过快。转向力或误差告诉车辆通过实际上朝相反方向（远离目标）来减速。相比之下，利用引力吸引时，无论目标多么接近，力都不会指向远离目标的方向。通过将误差应用为转向力，结果是更加动态、逼真的模拟。
- en: '**Your Own Behaviors**'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**你自己的行为**'
- en: 'The first two examples I’ve covered—seek and arrive—boil down to calculating
    a single vector for each behavior: the *desired* velocity. In fact, every single
    one of Reynolds’s steering behaviors follows this same pattern. In this chapter,
    I’m going to walk through more of Reynolds’s behaviors—flow-field following, path
    following, and flocking. First, however, I want to emphasize again that these
    are *examples*—demonstrations of common steering behaviors that are useful in
    procedural animation. They aren’t the be-all and end-all of what *you* can do.
    As long as you can come up with a vector that describes a vehicle’s *desired*
    velocity, you’ve created your own steering behavior.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我所讨论的前两个示例——“寻路”和“到达”——归结为为每个行为计算一个单一的矢量：*期望*速度。事实上，雷诺兹的每一个转向行为都遵循相同的模式。在本章中，我将介绍更多雷诺兹的行为——流场跟随、路径跟随和集群行为。然而，首先，我想再次强调，这些是*示例*——展示了常见的转向行为，这些行为在程序化动画中非常有用。它们并不是你能做的事情的全部。只要你能够提出一个描述车辆*期望*速度的矢量，你就创造了自己的转向行为。
- en: 'For example, let’s see how Reynolds defines the desired velocity for his wandering
    behavior:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看看雷诺兹是如何定义游荡行为的期望速度的：
- en: '*Wandering is a type of random steering which has some long-term order: the
    steering direction on one frame is related to the steering direction on the next
    frame. This produces more interesting motion than, for example, simply generating
    a random steering direction each frame.*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*游荡是一种具有一定长期规律的随机转向：一帧中的转向方向与下一帧中的转向方向相关。这比例如每帧都生成一个随机转向方向更能产生有趣的运动。*'
- en: For Reynolds, the goal of wandering isn’t random motion, but rather a sense
    of moving in one direction for a little while, wandering off in the next direction
    for a little bit, and so on. [Figure 5.11](ch05.xhtml#ch5fig11) illustrates how
    Reynolds calculates a target to seek in order to achieve such an effect.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对雷诺兹来说，游荡的目标不是随机运动，而是希望车辆先朝一个方向移动一段时间，然后再朝下一个方向游荡一段时间，如此循环。[图 5.11](ch05.xhtml#ch5fig11)展示了雷诺兹如何计算一个目标来实现这种效果。
- en: '![Image](../images/pg270_Image_386.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg270_Image_386.jpg)'
- en: 'Figure 5.11: The wandering steering behavior is calculated as seeking a target
    that moves randomly along the perimeter of a circle projected in front of the
    vehicle.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11：游荡转向行为被计算为寻求一个目标，该目标在车辆前方的圆形周围随机移动。
- en: First, the vehicle predicts its future position as a fixed distance in front
    of it (in the direction of its current velocity). Then it draws a circle with
    radius *r* centered on that position and picks a random point along the circumference
    of the circle. That point, which moves randomly around the circle for each frame
    of animation, is the vehicle’s target, so its desired velocity points in that
    direction.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，车辆预测其未来位置，距离其当前速度方向固定的距离。然后，它在该位置画一个半径为 *r* 的圆，并从圆的周长上随机选择一个点。这个点会在每一帧动画中沿着圆周随机移动，它就是车辆的目标，因此它的期望速度指向那个方向。
- en: Sounds absurd, right? Or, at the very least, a bit arbitrary. In fact, this
    is a clever and thoughtful solution—it uses randomness to drive a vehicle’s steering,
    but constrains that randomness along the path of a circle to keep the vehicle’s
    movement from appearing jittery and, well, totally random.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来荒谬，对吧？或者至少有些任意。事实上，这是一种巧妙且深思熟虑的解决方案——它利用随机性来驱动车辆的转向，但将这种随机性限制在一个圆形路径上，以防止车辆的运动看起来颤抖或完全随机。
- en: 'The seemingly random and arbitrary nature of this solution should drive home
    the point I’m trying to make: these are *made-up* behaviors, even if they’re inspired
    by real-life motion. You can just as easily concoct another elaborate scenario
    to compute a desired velocity. And you should!'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个看似随机和任意的解决方案应该强调我想表达的观点：这些是*虚构*的行为，尽管它们受现实世界运动的启发。你完全可以编造另一个复杂的场景来计算期望速度。而且你应该这样做！
- en: '![Image](../images/pencil.jpg) **Exercise 5.4**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/pencil.jpg) **练习 5.4**'
- en: Write the code for Reynolds’s wandering behavior. Use polar coordinates to calculate
    the vehicle’s target along a circular path.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 编写Reynolds的漫游行为代码。使用极坐标来计算车辆沿圆形路径的目标。
- en: '![Image](../images/pg271_Image_387.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg271_Image_387.jpg)'
- en: 'To give another example, say I want to create a steering behavior called *stay
    within walls*. To define the desired velocity, I’ll make a rule: if a vehicle
    comes within a distance *d* of a wall, that vehicle desires to move at maximum
    speed in the opposite direction of the wall (see [Figure 5.12](ch05.xhtml#ch5fig12)).'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是，假设我想创建一个叫做*保持在墙内*的转向行为。为了定义期望的速度，我将制定一个规则：如果车辆接近墙壁的距离为*d*，那么该车辆希望以最大速度朝向墙壁的反方向移动（参见[图5.12](ch05.xhtml#ch5fig12)）。
- en: '![Image](../images/pg271_Image_388.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg271_Image_388.jpg)'
- en: 'Figure 5.12: The desired velocity points away from the wall if the vehicle
    gets too close.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.12：如果车辆靠得太近，期望的速度会远离墙壁。
- en: If I define the walls of the space as the edges of a canvas and an `offset`
    distance equal to 25, I can write the code for this with a series of `if` statements.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我将空间的墙壁定义为画布的边缘，并且将`offset`距离设置为25，我可以通过一系列的`if`语句编写这段代码。
- en: '![Image](../images/pg272_Image_389.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg272_Image_389.jpg)'
- en: In this `boundaries()` method, you might be wondering why I set the `desired`
    velocity to `null` at the outset. Why not just set `desired` to a vector of 0?
    Remember, the steering force equals the desired velocity minus the current velocity!
    If the vehicle desires to move at 0 velocity, the resulting force would slow the
    vehicle to a stop. By initializing `desired` to `null` and checking that it’s
    non-null before applying the steering force, the vehicle won’t be affected at
    all when it’s comfortably away from the edges of the canvas.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`boundaries()`方法中，你可能会想知道为什么我一开始将`desired`速度设置为`null`。为什么不直接将`desired`设置为一个零向量呢？记住，转向力等于期望速度减去当前速度！如果车辆希望以0速度移动，产生的力将使车辆减速至停止。通过将`desired`初始化为`null`，并在应用转向力之前检查它是否为非`null`，车辆在远离画布边缘时就不会受到任何影响。
- en: '![Image](../images/pencil.jpg) **Exercise 5.5**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/pencil.jpg) **练习 5.5**'
- en: Come up with your own arbitrary scheme for calculating a desired velocity.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 想出你自己任意的方案来计算期望的速度。
- en: '**Flow Fields**'
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**流场**'
- en: Another one of Reynolds’s steering behaviors is **flow-field following**. But
    what is a flow field? Think of the canvas as a grid ([Figure 5.13](ch05.xhtml#ch5fig13)).
    In each cell of the grid lives an arrow pointing in a certain direction—you know,
    a vector. As a vehicle moves around the canvas, it asks, “Hey, what arrow is beneath
    me? That’s my desired velocity!”
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Reynolds的另一个转向行为是**流场跟随**。但什么是流场呢？将画布看作是一个网格（[图5.13](ch05.xhtml#ch5fig13)）。在网格的每个单元格里，都有一个指向某个方向的箭头——你知道，就是一个向量。当车辆在画布上移动时，它会问：“嘿，下面的箭头是什么？那就是我期望的速度！”
- en: '![Image](../images/pg273_Image_390.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg273_Image_390.jpg)'
- en: 'Figure 5.13: A 2D grid full of unit vectors pointing in random directions'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.13：一个充满指向随机方向的单位向量的二维网格
- en: Reynolds’s own flow-field example involves the vehicle looking ahead to its
    future position and following the vector at that spot. For simplicity’s sake,
    however, I’ll instead have the vehicle follow the vector at its current position.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Reynolds的流场示例中，车辆会查看其未来位置并跟随该位置的向量。然而，为了简单起见，我将让车辆跟随当前所在位置的向量。
- en: Before I can write the additional code for the `Vehicle` class to follow a flow
    field, I first need a class that describes the flow field. Since a flow field
    is essentially a grid of vectors, a 2D array is a convenient data structure to
    represent it, as I can reference each element with two indices, the cell’s column
    and row in the grid. If you aren’t familiar with 2D arrays, I suggest reviewing
    my video tutorial on “2D Arrays in JavaScript” (*[https://thecodingtrain.com/2d-array](https://thecodingtrain.com/2d-array)*).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在我编写`Vehicle`类的附加代码，使其跟随流场之前，我首先需要一个描述流场的类。由于流场本质上是一个向量网格，2D数组是一个方便的数据结构，可以用来表示流场，因为我可以通过两个索引来引用每个元素，即网格中单元格的列和行。如果你不熟悉2D数组，建议你查看我关于“JavaScript中的2D数组”的视频教程（*[https://thecodingtrain.com/2d-array](https://thecodingtrain.com/2d-array)*）。
- en: '![Image](../images/pg273_Image_391.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg273_Image_391.jpg)'
- en: 'How should I fill in the missing values? Let’s say I have a canvas that’s 200
    pixels wide by 200 pixels high. In theory, I could make a flow field that has
    a vector for every single pixel, meaning 40,000 vectors total (200 × 200). This
    isn’t a terribly unreasonable number, but in this context, one vector per pixel
    is overkill. I can easily get by with, say, one vector every 10 pixels (20 × 20
    = 400). My `resolution` variable sets the size of each cell in pixels. Then I
    can calculate the number of columns and rows based on the size of the canvas divided
    by the resolution:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该如何填充缺失的值呢？假设我有一个宽度为200像素，高度为200像素的画布。理论上，我可以创建一个流场，每个像素都有一个向量，也就是说，总共有40,000个向量（200
    × 200）。这个数字并不是特别不合理，但在这个上下文中，每个像素一个向量有些过头了。我完全可以通过每隔10个像素设置一个向量来解决问题（20 × 20 =
    400）。我的`resolution`变量设置了每个单元格的像素大小。然后，我可以根据画布的大小除以分辨率来计算列和行的数量：
- en: '![Image](../images/pg274_Image_393.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg274_Image_393.jpg)'
- en: Now that I’ve set up the data structure for the flow field, it’s time to compute
    the flow field’s vectors. How do I do that? However I want! Perhaps I’d like every
    vector in the flow field pointing to the right ([Figure 5.14](ch05.xhtml#ch5fig14)).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我已经为流场设置了数据结构，是时候计算流场的向量了。我该怎么做呢？随我怎么想吧！也许我希望流场中的每个向量都指向右侧（[图5.14](ch05.xhtml#ch5fig14)）。
- en: '![Image](../images/pg275_Image_394.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg275_Image_394.jpg)'
- en: 'Figure 5.14: A flow field with all vectors pointing to the right'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.14：一个所有向量指向右侧的流场
- en: For that, I can just set each vector to `(1, 0)`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对此，我可以直接将每个向量设置为`(1, 0)`。
- en: '![Image](../images/pg275_Image_395.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg275_Image_395.jpg)'
- en: Maybe I’d prefer the vectors to point in random directions ([Figure 5.15](ch05.xhtml#ch5fig15)).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我更喜欢让向量朝随机方向指向（[图5.15](ch05.xhtml#ch5fig15)）。
- en: '![Image](../images/pg275_Image_396.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg275_Image_396.jpg)'
- en: 'Figure 5.15: A flow field with vectors pointing in random directions'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.15：一个向量指向随机方向的流场
- en: 'Easy. Just use the `p5.Vector` class’s `random2D()` method to assign each vector:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单。只需使用`p5.Vector`类的`random2D()`方法为每个向量分配值：
- en: '![Image](../images/pg275_Image_397.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg275_Image_397.jpg)'
- en: What about using 2D Perlin noise ([Figure 5.16](ch05.xhtml#ch5fig16))?
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用2D Perlin噪声怎么样呢？（[图5.16](ch05.xhtml#ch5fig16)）
- en: '![Image](../images/pg276_Image_398.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg276_Image_398.jpg)'
- en: 'Figure 5.16: A flow field calculated with Perlin noise'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.16：一个使用Perlin噪声计算的流场
- en: 'Just map each noise value to an angle from 0 to 2π and create a vector from
    that angle:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将每个噪声值映射到从0到2π的角度，然后根据该角度创建一个向量：
- en: '![Image](../images/pg276_Image_399.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg276_Image_399.jpg)'
- en: Now I’m getting somewhere. Calculating the direction of the vectors by using
    Perlin noise is a great way to simulate a variety of natural effects, such as
    irregular gusts of wind or the meandering path of a river. I’ll note, however,
    that this noise mapping generates a field that prefers flowing left. Since Perlin
    noise has a Gaussian-like distribution, angles near π are more likely to be selected.
    For [Figure 5.16](ch05.xhtml#ch5fig16), I used a range of 0 to 4π to counteract
    this tendency, similarly to the way I applied 4π in [Chapter 4](ch04.xhtml#ch04)
    to represent a range of angles for spinning confetti particles. Ultimately, of
    course, there’s no one correct way to calculate the vectors of a flow field; it’s
    up to you to decide what you’re looking to simulate.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我有了一些进展。通过使用Perlin噪声计算向量的方向是一种很好的方法来模拟各种自然效果，比如不规则的阵风或河流的蜿蜒路径。然而，我要指出的是，这种噪声映射生成了一个偏好向左流动的场。由于Perlin噪声具有类似高斯分布的特性，靠近π的角度更容易被选择。对于[图5.16](ch05.xhtml#ch5fig16)，我使用了0到4π的范围来抵消这种倾向，类似于我在[第4章](ch04.xhtml#ch04)中应用4π来表示旋转纸屑粒子的角度范围。当然，最终并没有一种计算流场向量的正确方法；这取决于你希望模拟的内容。
- en: '![Image](../images/pencil.jpg) **Exercise 5.6**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 5.6**'
- en: Write the code to calculate a flow field so that the vectors swirl in circles
    around the center of the canvas.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码以计算流场，使得向量围绕画布中心旋转。
- en: '![Image](../images/pg277_Image_400.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg277_Image_400.jpg)'
- en: '[PRE6]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now that I have a 2D array storing the flow-field vectors, I need a way for
    the vehicle to look up its desired velocity. For that, I simply divide the vehicle’s
    x- and y-position by the resolution of the grid. This gives me the indices of
    the desired vector in the 2D array. For example, if the resolution is 10 and the
    vehicle is at (100, 50), I’ll want to look up column 10 and row 5:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我有一个存储流场向量的二维数组，我需要一种方法让车辆查找它所需的速度。为此，我简单地将车辆的x和y坐标除以网格的分辨率。这将给我二维数组中所需向量的索引。例如，如果分辨率为10，车辆位于(100,
    50)位置，我想查找第10列和第5行：
- en: '[PRE7]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Because a vehicle could theoretically wander off the p5.js canvas, employing
    the `constrain()` function helps ensure that I don’t look outside the bounds of
    the flow-field array. Here’s a method called `lookup()`, which I’ll add to the
    `FlowField` class, that receives a vector (the position of the vehicle) and returns
    the corresponding flow-field vector for that position:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 因为车辆理论上可能会偏离p5.js画布，使用`constrain()`函数有助于确保我不会在流场数组的边界之外查找。下面是一个名为`lookup()`的方法，我将把它添加到`FlowField`类中，该方法接收一个向量（车辆的位置）并返回该位置对应的流场向量：
- en: '![Image](../images/pg277_Image_401.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg277_Image_401.jpg)'
- en: 'Before moving on to the `Vehicle` class, let’s look at the `FlowField` class
    code all together, this time using Perlin noise to compute the vector directions:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续讨论`Vehicle`类之前，让我们将`FlowField`类的代码全部放在一起，这次使用Perlin噪声来计算向量的方向：
- en: '![Image](../images/pg278_Image_402.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg278_Image_402.jpg)'
- en: Now let’s assume there’s a `FlowField` object called `flow`. Using that object’s
    `lookup()` method, a vehicle can then retrieve a desired velocity from the flow
    field and use Reynolds’s steering formula to calculate a force.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设有一个名为`flow`的`FlowField`对象。通过该对象的`lookup()`方法，车辆可以从流场中检索所需的速度，并使用雷诺兹的转向公式计算一个力。
- en: '![Image](../images/pg279_Image_403.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg279_Image_403.jpg)'
- en: Notice that `lookup()` is a method of the `FlowField` class, rather than of
    `Vehicle`. While you certainly could place `lookup()` within the `Vehicle` class
    instead, from my perspective, placing it in `FlowField` aligns best with the OOP
    principle of encapsulation. The lookup task, which retrieves a vector based on
    a position from the flow field, is inherently tied to the data of the `FlowField`
    object.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`lookup()`是`FlowField`类的方法，而不是`Vehicle`类的方法。虽然你完全可以将`lookup()`放到`Vehicle`类中，但从我的角度来看，将它放在`FlowField`中最符合面向对象编程的封装原则。查找任务是基于流场中的位置检索向量的，它本质上与`FlowField`对象的数据密切相关。
- en: You may also notice some familiar elements from [Chapter 4](ch04.xhtml#ch04),
    such as the use of an array of vehicles. Although the vehicles here operate independently,
    this is a great first step toward thinking about the group behaviors that I’ll
    introduce later in this chapter.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你也许会注意到一些来自[第4章](ch04.xhtml#ch04)的熟悉元素，比如使用车辆数组。尽管这里的车辆独立运行，但这是朝着思考群体行为迈出的重要第一步，这些群体行为我将在本章稍后介绍。
- en: '![Image](../images/pencil.jpg) **Exercise 5.7**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 5.7**'
- en: 'Adapt the flow-field example so the vectors change over time. (Hint: Try using
    the third dimension of Perlin noise!)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 修改流场示例，使向量随时间变化。（提示：试着使用 Perlin 噪声的第三维！）
- en: '![Image](../images/pencil.jpg) **Exercise 5.8**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 5.8**'
- en: Can you create a flow field from an image? For example, try having the vectors
    point from dark to light colors (or vice versa).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你能从一张图像中创建一个流场吗？例如，试着让向量从暗色到亮色（或反之）指向。
- en: '**Path Following**'
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**路径跟随**'
- en: 'The next steering behavior formulated by Reynolds that I’d like to explore
    is path following. But let me quickly clarify something first: the behavior here
    is path *following*, not path *finding*. Pathfinding refers to an algorithm that
    solves for the shortest distance between two points, often in a maze. With **path
    following**, a predefined route, or path, already exists, and the vehicle simply
    tries to follow it.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我想探讨的 Reynolds 提出的另一个引导行为是路径跟随。但让我先澄清一件事：这里的行为是路径 *跟随*，而不是路径 *寻找*。路径寻找指的是一种算法，用于解决两点之间最短距离的问题，通常在迷宫中使用。而
    **路径跟随**，则是指预定义的路线或路径已经存在，车辆只需要尝试跟随它。
- en: 'In this section, I will work through the algorithm, including the corresponding
    mathematics and code. However, before doing so, it’s important to cover a key
    concept in vector math that I skipped over in [Chapter 1](ch01.xhtml#ch01): **the
    dot product**. I haven’t needed it yet, but it’s necessary here and likely will
    prove quite useful for you beyond just this example.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我将讲解算法，包括相关的数学和代码。然而，在此之前，重要的是要介绍一个我在[第1章](ch01.xhtml#ch01)中跳过的向量数学关键概念：**点积**。到目前为止我还没有用到它，但在这里它是必要的，并且很可能不仅在这个示例中对你非常有用。
- en: '**The Dot Product**'
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**点积**'
- en: Remember all the vector math covered in [Chapter 1](ch01.xhtml#ch01)? Add, subtract,
    multiply, and divide? [Figure 5.17](ch05.xhtml#ch5fig17) has a recap of some of
    these operations.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得[第1章](ch01.xhtml#ch01)中讲过的所有向量数学吗？加法、减法、乘法和除法？[图 5.17](ch05.xhtml#ch5fig17)回顾了其中的一些操作。
- en: '![Image](../images/pg280_Image_404.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg280_Image_404.jpg)'
- en: 'Figure 5.17: Adding vectors and multiplying a vector by a scalar'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.17：向量相加和将向量与标量相乘
- en: Notice that multiplication involves multiplying a vector by a scalar value.
    This makes sense; when you want a vector to be twice as large (but facing the
    same direction), multiply it by 2\. When you want it to be half the size, multiply
    it by 0.5\. However, several other *multiplication-like* operations involve a
    pair of vectors that are useful in certain scenarios—the dot product, the cross
    product, and something called the Hadamard product. For now, I’m going to focus
    on the dot product.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，乘法涉及将向量与标量值相乘。这是有道理的；当你想让一个向量变成原来两倍大（但方向不变）时，将它乘以 2；当你想让它变为原来的一半大小时，将它乘以
    0.5。然而，还有一些其他类似乘法的操作，涉及一对向量，在某些情况下非常有用——点积、叉积和一种叫做 Hadamard 乘积的运算。目前，我将专注于点积。
- en: 'Assume vectors ![Image](../images/pg280_Image_405.jpg) and ![Image](../images/pg280_Image_406.jpg):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有向量 ![Image](../images/pg280_Image_405.jpg) 和 ![Image](../images/pg280_Image_406.jpg)：
- en: '![Image](../images/pg280_Image_407.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg280_Image_407.jpg)'
- en: 'The formula for the dot product (represented by the · character) is as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 点积的公式（用 · 符号表示）如下：
- en: '![Image](../images/pg281_Image_408.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg281_Image_408.jpg)'
- en: 'Crucially, the result of the dot product is a scalar value (a single number)
    and not a vector, even though the inputs are two vectors. For example, say you
    have these two vectors:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 至关重要的是，点积的结果是一个标量值（一个单一的数字），而不是一个向量，即使输入的是两个向量。例如，假设你有这两个向量：
- en: '![Image](../images/pg281_Image_409.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg281_Image_409.jpg)'
- en: 'Their dot product is shown here:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的点积如图所示：
- en: '![Image](../images/pg281_Image_410.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg281_Image_410.jpg)'
- en: 'In p5.js, this translates to the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在 p5.js 中，这转换为以下内容：
- en: '![Image](../images/pg281_Image_411.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg281_Image_411.jpg)'
- en: 'If you look in the guts of the `p5.Vector` source code, you’ll find a pretty
    simple implementation of this `dot()` method:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 `p5.Vector` 源代码的核心部分，你会发现一个相当简单的 `dot()` 方法实现：
- en: '![Image](../images/pg281_Image_412.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg281_Image_412.jpg)'
- en: 'This formula is simple enough, but why is the dot product necessary, and when
    is it useful in coding? Well, one of the more common uses of the dot product is
    to find the angle between two vectors. In fact, the dot product can also be expressed
    as shown here:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个公式足够简单，但点积为什么是必要的，什么时候在编码中有用呢？好吧，点积的一个常见用途是找出两个向量之间的角度。事实上，点积也可以表达为如下形式：
- en: '![Image](../images/pg281_Image_413.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg281_Image_413.jpg)'
- en: In other words, the dot product of ![Image](../images/pg281_Image_414.jpg) and
    ![Image](../images/pg281_Image_415.jpg) is equal to the magnitude of ![Image](../images/pg281_Image_414.jpg)
    times the magnitude of ![Image](../images/pg281_Image_415.jpg) times the cosine
    of theta (with theta being the angle between the two vectors ![Image](../images/pg281_Image_414.jpg)
    and ![Image](../images/pg281_Image_415.jpg)).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，![Image](../images/pg281_Image_414.jpg)和![Image](../images/pg281_Image_415.jpg)的点积等于![Image](../images/pg281_Image_414.jpg)的大小乘以![Image](../images/pg281_Image_415.jpg)的大小，再乘以theta的余弦值（其中theta是两个向量![Image](../images/pg281_Image_414.jpg)和![Image](../images/pg281_Image_415.jpg)之间的角度）。
- en: 'The two dot-product formulas can be derived from each other with trigonometry
    (*[https://mathworld.wolfram.com/DotProduct.html](https://mathworld.wolfram.com/DotProduct.html)*),
    but I’m happy not to follow that path and instead just operate on the following
    assumption:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个点积公式可以通过三角学（*[https://mathworld.wolfram.com/DotProduct.html](https://mathworld.wolfram.com/DotProduct.html)*）相互推导出来，但我很高兴不走这条路，而是基于以下假设进行操作：
- en: '![Image](../images/pg281_Image_416.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg281_Image_416.jpg)'
- en: 'This works since both sides of the equation equal ![Image](../images/pg282_Image_417.jpg).
    What does that assumption do for me? Say I have two vectors ![Image](../images/pg281_Image_414.jpg)
    and ![Image](../images/pg281_Image_415.jpg):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这样是可行的，因为方程的两边都等于![Image](../images/pg282_Image_417.jpg)。这个假设对我有什么帮助呢？假设我有两个向量![Image](../images/pg281_Image_414.jpg)和![Image](../images/pg281_Image_415.jpg)：
- en: '![Image](../images/pg282_Image_418.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg282_Image_418.jpg)'
- en: 'In this scenario, I know the components of the vectors but don’t know the angle
    *θ* between them (see [Figure 5.18](ch05.xhtml#ch5fig18)). Using the dot-product
    formula, I can solve for the cosine of *θ*:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我知道向量的分量，但不知道它们之间的角度*θ*（见[图 5.18](ch05.xhtml#ch5fig18)）。使用点积公式，我可以解出*θ*的余弦值：
- en: '![Image](../images/pg282_Image_419.jpg)![Image](../images/pg282_Image_422.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg282_Image_419.jpg)![Image](../images/pg282_Image_422.jpg)'
- en: 'Figure 5.18: The angle between two vectors ![Image](../images/pg282_Image_423.jpg)
    and ![Image](../images/pg282_Image_424.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.18：两个向量![Image](../images/pg282_Image_423.jpg)和![Image](../images/pg282_Image_424.jpg)之间的角度
- en: 'To solve for *θ*, I can take the inverse cosine, or arccosine ( `acos` in p5.js
    ), of the right side of the equation:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解出*θ*，我可以对方程右侧取反余弦，或者说反余弦（p5.js中的`acos`）：
- en: '![Image](../images/pg282_Image_420.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg282_Image_420.jpg)'
- en: 'I’ll do the math now with actual numbers:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我用实际的数字来做一下数学计算：
- en: '![Image](../images/pg282_Image_421.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg282_Image_421.jpg)'
- en: 'Here’s the p5.js version:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这是p5.js的版本：
- en: '[PRE8]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Turns out, if you again dig into the guts of the p5.js source code, you’ll find
    a method called `angleBetween` that implements this exact algorithm.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 结果证明，如果你再次深入查看p5.js的源代码，你会找到一个叫做`angleBetween`的方法，它实现了这个精确的算法。
- en: '[PRE9]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Sure, I could have told you about this `angleBetween()` method to begin with,
    but understanding the dot product in detail will better prepare you for the upcoming
    path-following examples and help you see how the dot product fits into a concept
    called *scalar projection*.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我本可以一开始就告诉你这个`angleBetween()`方法，但详细理解点积会更好地为你接下来的路径跟踪示例做准备，并帮助你理解点积如何融入一个叫做*标量投影*的概念中。
- en: '![Image](../images/pencil.jpg) **Exercise 5.9**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 5.9**'
- en: Create a sketch that shows the angle between two vectors.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个草图，展示两个向量之间的角度。
- en: '![Image](../images/pg283_Image_425.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg283_Image_425.jpg)'
- en: 'There are a couple of things to note about dot products:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 关于点积有几点需要注意：
- en: If two vectors (![Image](../images/pg281_Image_414.jpg) and ![Image](../images/pg281_Image_415.jpg))
    are orthogonal (that is, perpendicular), their dot product (![Image](../images/pg282_Image_417.jpg))
    is equal to 0.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个向量（![Image](../images/pg281_Image_414.jpg)和![Image](../images/pg281_Image_415.jpg)）是正交的（即垂直的），它们的点积（![Image](../images/pg282_Image_417.jpg)）等于0。
- en: If two vectors are unit vectors, their dot product is equal to the cosine of
    the angle between them. In other words, ![Image](../images/pg283_Image_427.jpg)
    if ![Image](../images/pg281_Image_414.jpg) and ![Image](../images/pg281_Image_415.jpg)
    are of length 1.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个向量是单位向量，它们的点积等于它们之间夹角的余弦值。换句话说，![Image](../images/pg283_Image_427.jpg)，如果![Image](../images/pg281_Image_414.jpg)和![Image](../images/pg281_Image_415.jpg)的长度都是1。
- en: Now that I’ve covered the fundamentals of the dot product, I can return to Reynolds’s
    path-following algorithm.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经讲解了点积的基础知识，可以回到雷诺兹的路径跟踪算法。
- en: '**Simple Path Following**'
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**简单的路径跟踪**'
- en: '[Figure 5.19](ch05.xhtml#ch5fig19) depicts all the ingredients of the path-following
    behavior. A lot of components are at play here beyond just a vehicle and target,
    so take some time to review the full diagram. I’ll then slowly unpack the algorithm
    piece by piece.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.19](ch05.xhtml#ch5fig19)描述了路径跟踪行为的所有组成部分。这里有很多组件不仅仅是车辆和目标，因此请花些时间查看完整的图表。然后，我将慢慢地逐步解释算法。'
- en: '![Image](../images/pg284_Image_428.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg284_Image_428.jpg)'
- en: 'Figure 5.19: Path following requires a path, a vehicle, a future position,
    a *normal* to the path, and a target.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.19：路径跟踪需要路径、车辆、未来位置、*法线*和目标。
- en: First, what do I mean by a *path*? Many techniques can be used to implement
    a path, but one simple way is to define a path as a series of connected points,
    as in [Figure 5.20](ch05.xhtml#ch5fig20).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，*路径*是什么意思？可以使用多种技术来实现路径，但一种简单的方法是将路径定义为一系列连接的点，如[图5.20](ch05.xhtml#ch5fig20)所示。
- en: '![Image](../images/pg284_Image_429.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg284_Image_429.jpg)'
- en: 'Figure 5.20: A path is a sequence of connected points.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.20：路径是由连接点组成的序列。
- en: The simplest version of this path would be a line between two points ([Figure
    5.21](ch05.xhtml#ch5fig21)).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这条路径的最简单版本将是两点之间的直线（[图5.21](ch05.xhtml#ch5fig21)）。
- en: '![Image](../images/pg285_Image_430.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg285_Image_430.jpg)'
- en: 'Figure 5.21: A path with a start, end, and radius'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.21：一条具有起点、终点和半径的路径
- en: I’m also going to consider a path to have a *radius*. If the path is a road,
    the radius is the road’s width. With a smaller radius, vehicles have to follow
    the path more closely; a wider radius allows them to stray a bit more to either
    side of the path.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我还将考虑路径具有*半径*。如果路径是一条道路，半径就是道路的宽度。半径越小，车辆必须更紧密地跟随路径；较大的半径则允许它们稍微偏离路径的两侧。
- en: Now I’ll put this into a class.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我将把它放入一个类中。
- en: '![Image](../images/pg285_Image_431.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg285_Image_431.jpg)'
- en: Now, assume that a vehicle is outside the path’s radius, moving with a velocity,
    as in [Figure 5.22](ch05.xhtml#ch5fig22).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设一辆车在路径的半径之外，以一定速度行驶，如[图5.22](ch05.xhtml#ch5fig22)所示。
- en: '![Image](../images/pg286_Image_433.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg286_Image_433.jpg)'
- en: 'Figure 5.22: Adding a vehicle moving off and away from the path'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.22：添加一辆偏离路径并远离路径行驶的车辆
- en: 'The first step is to predict (assuming a constant velocity) where that vehicle
    will be in the future:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是预测（假设恒定速度）那个车辆未来将会在哪里：
- en: '![Image](../images/pg286_Image_434.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg286_Image_434.jpg)'
- en: Once I have that position, it’s time to determine the distance from that predicted
    position to the path. If it’s very far away, the vehicle has strayed from the
    path and needs to steer back toward it. If the vehicle is on the path, all is
    well and the vehicle can continue on its way.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我得到那个位置，就该确定从预测位置到路径的距离。如果它远离路径，说明车辆已经偏离，需要重新调整方向。如果车辆在路径上，一切正常，车辆可以继续行驶。
- en: Essentially, I need to calculate the distance between a point (the future position)
    and a line (the path). That distance is defined as the length of the **normal**,
    a vector that extends from the point to the line and is perpendicular to the line
    ([Figure 5.23](ch05.xhtml#ch5fig23)).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，我需要计算一个点（未来位置）和一条线（路径）之间的距离。这个距离定义为**法线**的长度，法线是一个从点到线并垂直于线的向量（[图5.23](ch05.xhtml#ch5fig23)）。
- en: '![Image](../images/pg287_Image_435.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg287_Image_435.jpg)'
- en: 'Figure 5.23: The normal is a vector that extends from the future position to
    the path and is perpendicular to the path.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.23：法线是一个从未来位置到路径并垂直于路径的向量。
- en: 'How do I find the normal? First, I can define a vector (call it ![Image](../images/pg281_Image_414.jpg))
    that extends from the path’s starting point to the vehicle’s future position:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如何找到法线？首先，我可以定义一个向量（称之为 ![图片](../images/pg281_Image_414.jpg)），它从路径的起点延伸到车辆的未来位置：
- en: '[PRE10]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, I can define a vector (call it ![Image](../images/pg281_Image_415.jpg))
    that points from the start of the path to the end:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我可以定义一个向量（称之为 ![图片](../images/pg281_Image_415.jpg)），它指向路径的起点到终点：
- en: '[PRE11]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, with a little trigonometry (the *cah* in *sohcahtoa*), I can calculate
    the distance from the path’s start to the normal point. As shown in [Figure 5.24](ch05.xhtml#ch5fig24),
    it’s ![Image](../images/pg287_Image_436.jpg).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过一点三角学（*cah* 在 *sohcahtoa* 中），我可以计算从路径的起点到法线点的距离。如[图5.24](ch05.xhtml#ch5fig24)所示，距离是
    ![图片](../images/pg287_Image_436.jpg)。
- en: '![Image](../images/pg287_Image_437.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg287_Image_437.jpg)'
- en: 'Figure 5.24: The distance from the start of the path to the normal is ![Image](../images/pg287_Image_438.jpg).'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.24：从路径起点到法线的距离是![Image](../images/pg287_Image_438.jpg)。
- en: If I only knew *θ*, I could find that normal point with the code shown next.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我只知道*θ*，我可以通过下面显示的代码找到那个法线点。
- en: '![Image](../images/pg288_Image_439.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg288_Image_439.jpg)'
- en: Luckily, if the dot product has taught me anything, it’s that given two vectors,
    I can calculate the angle between those vectors!
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，如果点积教会了我什么，那就是给定两个向量，我可以计算这两个向量之间的角度！
- en: '![Image](../images/pg288_Image_440.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg288_Image_440.jpg)'
- en: 'While this code will work, I can make one more simplification. Looking again,
    you’ll see that the magnitude for vector ![Image](../images/pg281_Image_415.jpg)
    is set to `a.mag() * cos(theta)`, which is the code translation of the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码能工作，但我可以再做一个简化。再次查看，你会看到向量![Image](../images/pg281_Image_415.jpg)的大小被设置为`a.mag()
    * cos(theta)`，这是下面代码的翻译：
- en: '![Image](../images/pg288_Image_441.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg288_Image_441.jpg)'
- en: 'And, recall this:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，回想一下这个：
- en: '![Image](../images/pg288_Image_442.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg288_Image_442.jpg)'
- en: 'Now, what if ![Image](../images/pg280_Image_406.jpg) is a unit vector of length
    1? Then you have this:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设![Image](../images/pg280_Image_406.jpg)是长度为1的单位向量？那么你将得到以下结果：
- en: '![Image](../images/pg288_Image_443.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg288_Image_443.jpg)'
- en: 'Or, more simply:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，更简单地：
- en: '![Image](../images/pg288_Image_444.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg288_Image_444.jpg)'
- en: 'When ![Image](../images/pg281_Image_415.jpg) is a unit vector, ![Image](../images/pg288_Image_445.jpg)
    is the same as the dot product of ![Image](../images/pg281_Image_414.jpg) and
    ![Image](../images/pg281_Image_415.jpg). Turning `b` into a unit vector is as
    simple as calling `normalize()`. I can therefore bypass calculating `theta` with
    `angleBetween()` and simplify the code as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当![Image](../images/pg281_Image_415.jpg)是单位向量时，![Image](../images/pg288_Image_445.jpg)等于![Image](../images/pg281_Image_414.jpg)和![Image](../images/pg281_Image_415.jpg)的点积。将`b`转换为单位向量只需调用`normalize()`。因此，我可以绕过使用`angleBetween()`计算`theta`，并将代码简化如下：
- en: '![Image](../images/pg288_Image_446.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg288_Image_446.jpg)'
- en: This process of scaling ![Image](../images/pg281_Image_415.jpg) according to
    the normal point is commonly known as **scalar projection**. We say that ![Image](../images/pg289_Image_447.jpg)
    *is the scalar projection of* ![Image](../images/pg281_Image_414.jpg) *onto* ![Image](../images/pg281_Image_415.jpg),
    as in [Figure 5.25](ch05.xhtml#ch5fig25).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 根据法线点缩放![Image](../images/pg281_Image_415.jpg)的过程通常被称为**标量投影**。我们说![Image](../images/pg289_Image_447.jpg)
    *是*![Image](../images/pg281_Image_414.jpg) *在*![Image](../images/pg281_Image_415.jpg)
    *上的标量投影*，如[图5.25](ch05.xhtml#ch5fig25)所示。
- en: '![Image](../images/pg289_Image_448.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg289_Image_448.jpg)'
- en: 'Figure 5.25: The scalar projection of ![Image](../images/pg282_Image_423.jpg)
    onto ![Image](../images/pg282_Image_424.jpg) is equal to ![Image](../images/pg289_Image_449.jpg).'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.25：![Image](../images/pg282_Image_423.jpg)在![Image](../images/pg282_Image_424.jpg)上的标量投影等于![Image](../images/pg289_Image_449.jpg)。
- en: Once I have the normal point along the path, the next step is to decide whether
    and how the vehicle should steer toward the path. Reynolds’s algorithm states
    that the vehicle should steer toward the path only if it’s in danger of straying
    beyond the path—that is, if the distance between the normal point and the predicted
    future position is greater than the path’s radius. This is illustrated in [Figure
    5.26](ch05.xhtml#ch5fig26).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我沿着路径找到了法线点，下一步就是决定车辆是否应该朝路径方向转向以及如何转向。雷诺兹算法指出，只有当车辆有可能偏离路径时——即法线点与预测的未来位置之间的距离大于路径的半径时——车辆才应朝路径转向。如[图5.26](ch05.xhtml#ch5fig26)所示。
- en: '![Image](../images/pg289_Image_450.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg289_Image_450.jpg)'
- en: 'Figure 5.26: A vehicle with a future position on the path (top) and one that’s
    outside the path (bottom)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.26：一辆在路径上的未来位置的车辆（上图）和一辆在路径外的车辆（下图）
- en: I can encode that logic with a simple `if` statement and use my earlier `seek()`
    method to steer the vehicle when necessary.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以通过一个简单的`if`语句编码这个逻辑，并在必要时使用我之前的`seek()`方法来引导车辆。
- en: '![Image](../images/pg290_Image_451.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg290_Image_451.jpg)'
- en: But what’s the target that the path follower is seeking? Reynolds’s algorithm
    involves picking a point ahead of the normal on the path. Since I know the vector
    that defines the path (![Image](../images/pg281_Image_415.jpg)), I can implement
    this point ahead by adding a vector that points in ![Image](../images/pg281_Image_415.jpg)’s
    direction to the vector representing the normal point, as in [Figure 5.27](ch05.xhtml#ch5fig27).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 但路径跟随者寻找到的目标是什么呢？Reynolds的算法包括在路径的法线前方选择一个点。由于我知道定义路径的向量 (![Image](../images/pg281_Image_415.jpg))，我可以通过将指向![Image](../images/pg281_Image_415.jpg)方向的向量添加到表示法线点的向量，来实现这个前方点，如[图5.27](ch05.xhtml#ch5fig27)所示。
- en: '![Image](../images/pg290_Image_452.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg290_Image_452.jpg)'
- en: 'Figure 5.27: The target is 25 pixels (an arbitrary choice) ahead of the normal
    point along the path.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.27：目标点在路径的法线点前方25像素（一个任意选择的值）。
- en: 'I’ll arbitrarily say the target should be 25 pixels ahead of the normal:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我随便说目标点应该在法线前方25像素：
- en: '![Image](../images/pg290_Image_453.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg290_Image_453.jpg)'
- en: Putting it all together, here’s the path-following method in the `Vehicle` class.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 把这一切整合起来，下面是`Vehicle`类中的路径跟随方法。
- en: '![Image](../images/pg291_Image_454.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg291_Image_454.jpg)'
- en: 'Notice that instead of using all that dot-product and scalar projection code
    to find the normal point, I call the `getNormalPoint()` function. In cases like
    this, it’s useful to break out the code that performs a specific task (finding
    a normal point) into a function that can be called when required. The function
    takes three vector arguments (see [Figure 5.28](ch05.xhtml#ch5fig28)): the first
    defines a point *p* in Cartesian space (the vehicle’s future position), and the
    second and third define a line segment between two points *a* and *b* (the path).'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，和以前使用所有点积和标量投影代码来找到法线点不同，我现在调用了`getNormalPoint()`函数。在这种情况下，将执行特定任务（如寻找法线点）的代码拆分成一个函数，并在需要时调用是很有用的。这个函数接受三个向量参数（见[图5.28](ch05.xhtml#ch5fig28)）：第一个定义了一个点*p*在笛卡尔空间中的位置（即车辆的未来位置），第二和第三个则定义了两个点*a*和*b*之间的线段（即路径）。
- en: '![Image](../images/pg292_Image_455.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg292_Image_455.jpg)'
- en: 'Figure 5.28: The elements of the `getNormalPoint()` function: `position`, `a`,
    and `b`'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.28：`getNormalPoint()`函数的元素：`position`、`a`和`b`
- en: '![Image](../images/pg292_Image_456.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg292_Image_456.jpg)'
- en: What do I have so far? I have a `Path` class that defines a path as a line between
    two points. I have a `Vehicle` class with a method to follow the path (using steering
    to seek a target along the path). In all, this makes for a decent example, and
    yet it’s pretty darn limiting. What’s missing?
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我有什么？我有一个`Path`类，它将路径定义为两点之间的线。我还有一个`Vehicle`类，里面有一个方法可以沿路径行驶（通过转向来寻找沿路径的目标）。总的来说，这是一个不错的示例，但它仍然有些局限。缺少了什么？
- en: Take a deep breath. You’re almost there.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 深呼吸一下，你快完成了。
- en: '**Path Following with Multiple Segments**'
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**多个线段的路径跟随**'
- en: What if I want a vehicle to follow a more complex path than just a single straight
    line? Perhaps a curved path that moves in a variety of directions, as in [Figure
    5.29](ch05.xhtml#ch5fig29)?
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想让一辆车跟随比单一直线更复杂的路径呢？也许是一条曲线路径，沿着多个方向移动，像[图5.29](ch05.xhtml#ch5fig29)中那样？
- en: '![Image](../images/pg293_Image_457.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg293_Image_457.jpg)'
- en: 'Figure 5.29: A more complex path'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.29：更复杂的路径
- en: Maybe I’m being a little too ambitious. I *could* investigate algorithms for
    following a curved path, but I’m much less likely to end up needing a cool compress
    on my forehead if I stick with straight line segments, like those in [Figure 5.30](ch05.xhtml#ch5fig30).
    I could always still *draw* the path as a curve, but it’s best to approximate
    it behind the scenes with simplified geometric forms for the necessary calculations.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我有点太雄心勃勃了。我*可以*研究跟随曲线路径的算法，但如果我坚持使用直线段，比如[图5.30](ch05.xhtml#ch5fig30)中的那些，我可能更不容易需要在额头上敷上冰袋。即使我仍然*画*出路径作为曲线，但最好在后台用简化的几何形状来近似它，以进行必要的计算。
- en: '![Image](../images/pg293_Image_458.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg293_Image_458.jpg)'
- en: 'Figure 5.30: The same curved path, but approximated as connected line segments'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.30：相同的曲线路径，但近似为连接的线段
- en: If I made path following work with one line segment, how do I make it work with
    a series of connected line segments? The key is in the way I find the target point
    along the path.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我让路径跟随只在一段线段上工作，那我怎么才能让它在一系列连接的线段上工作呢？关键在于我如何沿路径找到目标点。
- en: To find the target with just one line segment, I had to compute the normal to
    that line segment. Now that I have a series of line segments, I also have a series
    of normal points to be computed—one for each segment (see [Figure 5.31](ch05.xhtml#ch5fig31)).
    Which one does the vehicle choose? The solution Reynolds proposed is to pick the
    normal point that is (a) closest and (b) on the path.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 为了仅通过一条线段找到目标，我需要计算该线段的法线。现在我有了一系列的线段，我也有了一系列需要计算的法线点——每个线段一个（见[图5.31](ch05.xhtml#ch5fig31)）。车辆该选择哪一个呢？Reynolds提出的解决方案是选择（a）最近的法线点，并且（b）在路径上的那个点。
- en: '![Image](../images/pg294_Image_459.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg294_Image_459.jpg)'
- en: 'Figure 5.31: Finding the closest normal point along a series of connected line
    segments'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.31：在一系列连接的线段中找到最近的法线点
- en: If you have a point and an infinitely long line, you’ll always have a normal
    point that touches the line. But if you have a point and a finite line segment,
    you won’t necessarily find a normal that’s on the line segment. If this happens
    for any of the segments, I can disqualify those normals. Once I’m left with just
    those normals that are on the path (only two in [Figure 5.31](ch05.xhtml#ch5fig31)),
    I pick the one that’s shortest.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个点和一条无限长的直线，你总能找到一个与直线相交的法线点。但如果你有一个点和一条有限的线段，你不一定能找到一个位于线段上的法线。如果在任何线段上发生这种情况，我可以排除这些法线。一旦只剩下那些位于路径上的法线（在[图5.31](ch05.xhtml#ch5fig31)中只有两个），我选择最短的那个。
- en: To write the code for this, I’ll expand the `Path` class to have an array of
    points (rather than just the start and end).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写这段代码，我将扩展`Path`类，使其拥有一个点的数组（而不仅仅是起点和终点）。
- en: '![Image](../images/pg294_Image_460.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg294_Image_460.jpg)'
- en: 'Now that the `Path` class has been updated, it’s the vehicle’s turn to learn
    how to accommodate multiple line segments. All it did before was find the normal
    for one line. Using a loop, it can find the normals for all the segments:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`Path`类已经更新，轮到车辆学习如何适应多个线段了。它之前只是在一条线上找到法线。通过使用循环，它可以为所有线段找到法线：
- en: '![Image](../images/pg295_Image_462.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg295_Image_462.jpg)'
- en: The next step is to test whether the normal point is actually between points
    `a` and `b`. Since I know the path goes from left to right in this example, I
    can test whether the `x` component of `normalPoint` is outside the `x` components
    of `a` and `b`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是测试法线点是否确实位于点`a`和`b`之间。由于在这个示例中我知道路径是从左到右的，所以我可以测试`normalPoint`的`x`分量是否超出了`a`和`b`的`x`分量范围。
- en: '![Image](../images/pg296_Image_463.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg296_Image_463.jpg)'
- en: If the normal point is not within the line segment, I’ll just pretend the end
    point of that line segment is the normal. (You might also try the beginning point,
    depending on the particulars of your path.) This will ensure that the vehicle
    always stays on the path, even if it strays beyond the bounds of the line segments.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果法线点不在线段内，我会假设该线段的终点就是法线。（你也可以尝试起始点，具体取决于你的路径特点。）这将确保车辆始终保持在路径上，即使它偏离了线段的边界。
- en: '![Image](../images/pencil.jpg) **Exercise 5.10**'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习5.10**'
- en: A more general-purpose way to test whether the normal point lies on the segment
    is to sum the distances between `normalPoint` and `a` and `b`. If the result is
    greater than the length of the line segment, the normal is outside the segment.
    Can you write this algorithm with p5.js?
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更通用的方式来测试法线点是否位于线段上，是将`normalPoint`与`a`和`b`之间的距离相加。如果结果大于线段的长度，则法线点在该线段之外。你能用p5.js编写这个算法吗？
- en: Finally, I need to find the closest normal point to the vehicle. To accomplish
    this, I can start with a very high “world record” distance and iterate through
    each normal point to see if it beats (is less than) the record. Each time a normal
    point beats the record, the world record is updated, and the winning point is
    stored in a variable named `target`. At the end of the loop, `target` will hold
    the closest normal point.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我需要找到离车辆最近的法线点。为此，我可以从一个非常高的“世界纪录”距离开始，逐个检查每个法线点，看它是否打破（小于）纪录。每当一个法线点打破纪录时，世界纪录会被更新，获胜的点会存储在名为`target`的变量中。在循环结束时，`target`将保存离车辆最近的法线点。
- en: '![Image](../images/pg296_Image_464.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg296_Image_464.jpg)'
- en: You may have noticed the use of `Infinity` to initialize `worldRecord`. In JavaScript,
    `Infinity` is a special numeric value that represents, well, infinity. It works
    in this case because I need a starting value that will always be higher than any
    plausible distance calculated in the code. The first calculated distance will
    always set a new world record, against which all the others will be compared.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，`Infinity` 被用来初始化 `worldRecord`。在 JavaScript 中，`Infinity` 是一个特殊的数值，表示无限大。之所以这样做，是因为我需要一个起始值，这个值始终大于代码中计算出的任何可能的距离。第一个计算出的距离将总是设定新的世界纪录，所有其他的距离都会以此为基准进行比较。
- en: I also want to highlight the hardcoded value of `25`, which sets the distance
    ahead on the path from the normal for the target. Reynolds indicates that this
    value should be dynamic and calculated based on the vehicle’s distance to the
    path and its speed. Give this a try and see how it improves the accuracy or responsiveness
    of the path-following behavior!
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我还想强调 `25` 的硬编码值，它设置了目标路径上正常位置前方的距离。Reynolds 指出，这个值应该是动态的，并且基于车辆到路径的距离和速度进行计算。试试看这个改动，看看它是如何改善路径跟随行为的准确性或响应性的！
- en: '![Image](../images/pencil.jpg) **Exercise 5.11**'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/pencil.jpg) **练习 5.11**'
- en: Create a path that changes over time. Can the points that define the path have
    their own steering behaviors?
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个随着时间变化的路径。定义路径的各个点能否拥有各自的引导行为？
- en: '**Complex Systems**'
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**复杂系统**'
- en: I said the purpose of this chapter is to breathe life into the things that move
    around p5.js canvases. You’ve come a long way by learning to write the code for
    an autonomous agent and playing with examples of that agent’s individual behaviors.
    But this is no place to stop. Yes, a vehicle is a simulated being that makes decisions
    about how to seek and flow and follow. But what is a life led alone, without the
    love and support of others?
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾说过，本章的目的是为在 p5.js 画布上移动的事物赋予生命。通过学习编写自主代理的代码并玩弄该代理的个体行为示例，你已经取得了很大的进展。但这还不是结束。是的，车辆是一个模拟存在，它会做出如何寻求、流动和跟随的决策。但一个独自生活的生命，能没有他人的爱与支持吗？
- en: And so, as a logical next step, I’ll take the work I’ve done developing behaviors
    for individual autonomous agents and apply it to simulations that involve *many*
    autonomous agents operating in parallel—agents that have an ability to perceive
    not only their physical environment but also the actions of their fellow agents,
    and then act accordingly. In other words, I want to create complex systems with
    p5.js.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，作为一个逻辑上的下一步，我将把我在开发单个自主代理行为方面所做的工作，应用到涉及 *多个* 自主代理并行操作的仿真中——这些代理不仅能感知它们的物理环境，还能感知其他代理的行为，并相应地做出反应。换句话说，我想用
    p5.js 创建复杂系统。
- en: A **complex system** is typically defined as a system that’s more than the sum
    of its parts. While the individual elements of the system may be incredibly simple
    and easily understood, the behavior of the system as a whole can be highly complex,
    intelligent, and difficult to predict.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '**复杂系统** 通常被定义为一个整体大于其部分之和的系统。虽然系统中的单个元素可能非常简单且易于理解，但作为一个整体，系统的行为可以是高度复杂的、智能的，且难以预测。'
- en: Think, for example, about a tiny, crawling ant—one single ant. An ant is an
    autonomous agent; it can perceive its environment (using antennae to gather information
    about the direction and strength of chemical signals) and make decisions about
    how to move based on those signals. But can a single ant acting alone build a
    nest, gather food, or defend its queen? An ant is a simple unit that can perceive
    only its immediate environment. A *colony* of ants, however, is a sophisticated,
    complex system, a superorganism of components that work together to accomplish
    difficult, complicated goals.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，想象一只微小的、爬行的蚂蚁——一只蚂蚁。蚂蚁是一个自主代理；它能感知环境（通过触角收集关于化学信号的方向和强度的信息），并根据这些信号做出如何移动的决策。但单独一只蚂蚁能建造巢穴、收集食物或保护它的女王吗？蚂蚁是一个只能感知其周围环境的简单单元。然而，一群蚂蚁（*蚁群*）是一个复杂的系统，是由多个组件组成的超有机体，这些组件协同工作以完成困难且复杂的目标。
- en: 'Here are three key principles that will guide my work with complex systems:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是三个将指导我处理复杂系统的关键原则：
- en: '**Simple units have short-range relationships.** This is what I’ve been building
    all along: vehicles that have a limited perception of their environment.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单的单元具有短程关系。** 这正是我一直在构建的内容：具有有限环境感知能力的车辆。'
- en: '**Simple units operate in parallel.** For every cycle through the `draw()`
    loop, each unit will calculate its own steering forces. This will create the appearance
    of all the units working in parallel.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单单元并行工作。** 每次通过`draw()`循环时，每个单元都会计算自己的驱动力。这将产生所有单元并行工作的效果。'
- en: '**Systems as a whole exhibit emergent phenomena.** Complex behaviors, patterns,
    and intelligence can emerge from the interactions among simple units. This phenomenon
    occurs in nature, such as in ant colonies, migration patterns, earthquakes, and
    snowflakes. The question is whether the same results can be achieved in a p5.js
    sketch.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统整体表现出涌现现象。** 复杂的行为、模式和智能可以通过简单单元之间的相互作用涌现出来。这一现象在自然界中普遍存在，例如蚁群、迁徙模式、地震和雪花。问题是，是否能够在p5.js草图中实现相同的结果。'
- en: 'Beyond these core principles, three additional qualities of complex systems
    will help frame the discussion, as well as provide guidelines for features to
    include in a software simulation. It’s important to acknowledge that this is a
    fuzzy set of characteristics, and not all complex systems have all of them:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些核心原则外，复杂系统的三个额外特性将帮助框定讨论，并为软件模拟中应包括的功能提供指导。需要注意的是，这是一组模糊的特征，并非所有复杂系统都具备这些特性：
- en: '**Nonlinearity:** This aspect of complex systems is often casually referred
    to as the *butterfly effect*, coined by mathematician and meteorologist Edward
    Norton Lorenz, a pioneer in the study of chaos theory. In 1961, Lorenz was running
    a computer weather simulation for the second time and, perhaps to save a little
    time, typed in a starting value of 0.506 instead of 0.506127\. The end result
    was completely different from the first result of the simulation. Stated more
    evocatively, the theory is that a single butterfly flapping its wings on the other
    side of the world could cause a massive weather shift and ruin your weekend at
    the beach. It’s called *nonlinear* because there isn’t a linear relationship between
    a change in initial conditions and a change in outcome. A small change in initial
    conditions can have a massive effect on the outcome. Nonlinear systems are a superset
    of chaotic systems. In [Chapter 7](ch07.xhtml#ch07), you’ll see how even in a
    system of many 0s and 1s, if you change just one bit, the result will be completely
    different.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非线性：** 复杂系统的这个特性通常被随意称为*蝴蝶效应*，该术语由数学家和气象学家爱德华·诺顿·洛伦兹（Edward Norton Lorenz）提出，洛伦兹是混沌理论研究的先驱。1961年，洛伦兹第二次运行计算机天气模拟时，可能为了节省一点时间，他输入了0.506作为初始值，而不是0.506127。最终结果与第一次模拟的结果完全不同。更具表现力地说，这一理论认为，在世界的另一端，一只蝴蝶扇动翅膀，可能引起巨大的天气变化，最终影响到你在海滩度过的周末。它被称为*非线性*，因为初始条件的变化与结果之间没有线性关系。初始条件的微小变化可能会对结果产生巨大的影响。非线性系统是混沌系统的超集。在[第七章](ch07.xhtml#ch07)中，你将看到即便是在一个由许多0和1组成的系统中，只要改变一个比特，结果也会完全不同。'
- en: '**Competition and cooperation:** One ingredient that often makes a complex
    system tick is the presence of both competition and cooperation among the elements.
    The upcoming flocking system will have three rules: alignment, cohesion, and separation.
    Alignment and cohesion will ask the elements to “cooperate” by trying to stay
    together and move together. Separation, however, will ask the elements to “compete”
    for space. When the time comes, try taking out just the cooperation or just the
    competition, and you’ll see how the system loses its complexity. Competition and
    cooperation are found together in living complex systems, but not in nonliving
    complex systems like the weather.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**竞争与合作：** 使复杂系统运转的一个重要因素是元素之间同时存在竞争和合作。即将实现的群体行为系统将有三个规则：对齐、凝聚和分离。对齐和凝聚将要求元素“合作”，尽量保持在一起并共同移动。然而，分离将要求元素“竞争”空间。当这个时刻来临时，可以尝试去除合作或竞争中的任何一个，你会看到系统失去了其复杂性。竞争与合作共同存在于生物的复杂系统中，但在非生物复杂系统（如天气）中并不存在。'
- en: '**Feedback:** Complex systems often include a loop that feeds the output of
    the system back into the system to influence its behavior in a positive or negative
    direction. Let’s say you decide to take public transportation to work each day
    because it’s the most reliable and cost-effective solution, and you’re put off
    by the traffic congestion and environmental impact of driving. You aren’t alone;
    others turn to public transportation too. The system grows more efficient and
    attractive, serving more people with the same resources, and meanwhile, vehicle
    traffic is reduced. Over time, however, the system may struggle to accommodate
    the rising demand, leading to overcrowding, delays, and increased fares to fund
    infrastructure improvements. As a result, you and others start to switch back
    to driving, thereby increasing traffic congestion once again and reducing public
    transport’s efficiency. As traffic worsens, the funds from increased fares are
    (hopefully) used to improve public transport infrastructure, making it more appealing
    once again. In this way, the cost and efficiency of public transportation are
    both the input of the system (determining whether you choose to use it or not)
    and the output (the degree of traffic congestion and subsequent cost and efficiency).
    Economic models are just one example of a human complex system. Others include
    fads and trends, elections, crowds, and traffic flow.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反馈：** 复杂系统通常包括一个反馈循环，将系统的输出反馈到系统中，以积极或消极的方向影响其行为。假设你决定每天乘坐公共交通工具上班，因为它是最可靠且成本效益最好的解决方案，而你又对交通拥堵和驾车的环境影响感到厌烦。你并不孤单，其他人也选择了公共交通。这个系统变得更高效、更具吸引力，能够用相同的资源服务更多的人，同时减少了车辆交通。然而，随着时间的推移，系统可能会难以适应日益增长的需求，导致过度拥挤、延误，以及提高票价以资助基础设施改善。因此，你和其他人开始重新选择开车，从而再次增加交通拥堵，减少公共交通的效率。随着交通状况的恶化，票价上涨的资金（希望）被用来改善公共交通基础设施，使其再次变得更具吸引力。通过这种方式，公共交通的成本和效率既是系统的输入（决定你是否选择使用它），也是输出（交通拥堵的程度以及随之而来的成本和效率）。经济模型只是人类复杂系统的一个例子，其他例子包括时尚潮流、选举、群众行为和交通流动。'
- en: 'Complexity will serve as a key theme for much of the remainder of the book.
    In this section, I’ll begin by introducing an additional feature to the `Vehicle`
    class: the ability to perceive neighboring vehicles. This enhancement will pave
    the way for a culminating example of a complex system in which the interplay of
    simple individual behaviors results in an emergent behavior: flocking.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂性将作为本书剩余部分的一个关键主题。在这一部分，我将开始为`Vehicle`类引入一个新特性：感知邻近车辆的能力。这个增强功能将为一个复杂系统的终极示例铺平道路，在这个系统中，简单的个体行为相互作用，产生了一个涌现行为：群体飞行。
- en: '**Implementing Group Behaviors (or: Let’s Not Run Into Each Other)**'
  id: totrans-331
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**实现群体行为（或者：我们不要互相撞上）**'
- en: 'Managing a group of objects is certainly not a new concept. You’ve seen this
    before—in [Chapter 4](ch04.xhtml#ch04), where I developed the `Emitter` class
    to represent an overall particle system. There, I used an array to store a list
    of individual particles. I’ll start with the same technique here and store `Vehicle`
    objects in an array:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 管理一组对象无疑不是一个新概念。你之前见过这个概念——在[第4章](ch04.xhtml#ch04)中，我开发了`Emitter`类来表示一个整体粒子系统。在那里，我使用数组来存储单个粒子的列表。在这里，我也会用相同的技术，并将`Vehicle`对象存储在数组中：
- en: '![Image](../images/pg299_Image_466.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg299_Image_466.jpg)'
- en: 'Now, when it comes time to manipulate all the vehicles in `draw()`, I can loop
    through the array and call the necessary methods:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当需要在`draw()`中操作所有车辆时，我可以遍历数组并调用必要的方法：
- en: '[PRE12]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Maybe I want to add a behavior, a force to be applied to all the vehicles.
    This could be seeking the mouse:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我想加入一个行为，即应用于所有车辆的力。这可能是寻求鼠标的位置：
- en: '[PRE13]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: But that’s an *individual* behavior, and I’ve already spent the bulk of this
    chapter worrying about individual behaviors. You’re here because you want to apply
    a *group* behavior. I’ll begin with **separation**, a behavior that commands,
    “Avoid colliding with your neighbors!”
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 但那是*个体*行为，而我已经在本章的大部分内容中讨论了个体行为。你之所以在这里，是因为你想应用*群体*行为。我将从**分离**行为开始，这种行为的命令是：“避免与邻居发生碰撞！”
- en: '[PRE14]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'That looks good but is not quite right. What’s missing? In the case of `seek()`,
    I said, “Seek `mouseX` and `mouseY`.” In the case of `separate()`, I’m saying,
    “Separate from *everyone else*.” Who is everyone else? It’s the list of all the
    other vehicles:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错，但还不完全正确。缺少了什么呢？在`seek()`的情况下，我说，“寻求`mouseX`和`mouseY`。”在`separate()`的情况下，我说，“与*其他所有人*分开。”谁是其他所有人？就是所有其他车辆的列表：
- en: '[PRE15]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is the big leap beyond what you saw before with particle systems. Instead
    of each element (particle or vehicle) operating on its own, I’m now saying, “Hey
    you, that vehicle there! When it comes time for you to operate, you need to operate
    with an awareness of everyone else. So I’m going to go ahead and pass you the
    list of everyone else.”
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这是超越之前粒子系统的重大进展。与每个元素（粒子或车辆）独立操作不同，我现在说，“嘿，你，那辆车！当你该操作的时候，你需要在意识到其他所有人的情况下操作。所以我将把所有其他人的列表传给你。”
- en: 'Putting together what I’ve done so far, here are the `setup()` and `draw()`
    functions for a sketch that exhibits group behavior:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 把到目前为止做的整理一下，这里是展示群体行为的草图的`setup()`和`draw()`函数：
- en: '![Image](../images/pg301_Image_468.jpg)![Image](../images/pg301_Image_469.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg301_Image_468.jpg)![Image](../images/pg301_Image_469.jpg)'
- en: 'Figure 5.32: The desired velocity for separation (equivalent to fleeing) is
    a vector that points in the opposite direction of a target.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.32：分离所需的速度（相当于逃离）是一个指向目标相反方向的向量。
- en: Of course, this is just the beginning. The real work happens inside the `separate()`
    method. Reynolds defines the separation behavior as “steer to avoid crowding.”
    In other words, if a given vehicle is too close to you, steer away from that vehicle.
    Sound familiar? Remember the seek behavior, steering a vehicle toward a target?
    Reverse that force and you have the flee behavior, which is what should be applied
    here to achieve separation (see [Figure 5.32](ch05.xhtml#ch5fig32)).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是开始。真正的工作发生在`separate()`方法内部。Reynolds将分离行为定义为“调整方向以避免拥挤”。换句话说，如果某辆车离你太近，向那辆车的反方向转向。听起来熟悉吗？记得寻求行为吗，车辆向目标驶去？把那个力反转，你就得到了逃离行为，这就是在这里实现分离所需要的行为（见[图5.32](ch05.xhtml#ch5fig32)）。
- en: But what if more than one vehicle is too close? In that case, I’ll define separation
    as the average of all the vectors pointing away from any close vehicles ([Figure
    5.33](ch05.xhtml#ch5fig33)).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果有多个车辆太近呢？在这种情况下，我会将分离定义为所有指向远离任何近距离车辆的向量的平均值（[图5.33](ch05.xhtml#ch5fig33)）。
- en: '![Image](../images/pg302_Image_470.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg302_Image_470.jpg)'
- en: 'Figure 5.33: Desired velocity for separation is the average of multiple fleeing
    desired velocities.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.33：分离所需的速度是多个逃离速度的平均值。
- en: 'How do I turn that into code? Remember, I’m writing a method called `separate()`
    that receives an array of `Vehicle` objects as an argument:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我如何把它转化为代码呢？记住，我正在写一个叫做`separate()`的方法，它接收一个`Vehicle`对象数组作为参数：
- en: '[PRE16]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Inside this method, I’ll loop through all the vehicles and see if any are too
    close:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我将循环遍历所有车辆，看看是否有任何车辆离得太近：
- en: '![Image](../images/pg302_Image_471.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg302_Image_471.jpg)'
- en: Notice that I’m checking not only whether the distance is less than a desired
    separation but also whether `this` is not equal to `other`. This is a key element.
    Remember, all the vehicles are in the array; without this extra check, the vehicle
    will attempt to flee from itself!
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我不仅在检查距离是否小于所需的分离距离，还在检查`this`是否不等于`other`。这是一个关键要素。记住，所有的车辆都在数组中；如果没有这个额外的检查，车辆将试图从自己身边逃离！
- en: 'If the vehicles are too close, I compute a vector that points away from the
    offending vehicle:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如果车辆太近，我会计算一个指向远离干扰车辆的向量：
- en: '![Image](../images/pg302_Image_472.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg302_Image_472.jpg)'
- en: 'This isn’t enough. I have a fleeing vector now, but what I really need is the
    average of the fleeing vectors for all the vehicles that are too close. How do
    I compute an average? Add up all the vectors and divide by the total:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不够。我现在有了一个逃离向量，但我真正需要的是所有离得太近的车辆的逃离向量的平均值。我该如何计算平均值呢？将所有向量加起来，然后除以总数：
- en: '![Image](../images/pg303_Image_473.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg303_Image_473.jpg)'
- en: 'Once I have the average vector (stored in the variable `sum`), that vector
    can be scaled to the maximum speed and become the desired velocity—the vehicle
    *desires* to move in that direction at maximum speed! (In fact, I really don’t
    have to divide by `count` anymore since the magnitude is set manually.) And once
    I have the desired velocity, it’s the same old Reynolds story—steering equals
    desired minus velocity:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我获得了平均向量（存储在变量`sum`中），这个向量可以被缩放到最大速度，成为所需的速度——车辆*希望*以最大速度朝那个方向移动！（实际上，我真的不需要再除以`count`，因为大小是手动设置的。）一旦我得到所需的速度，就进入了典型的Reynolds模型——转向等于所需速度减去当前速度：
- en: '![Image](../images/pg303_Image_474.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg303_Image_474.jpg)'
- en: The following example shows the method in its entirety.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了方法的完整实现。
- en: '![Image](../images/pg304_Image_475.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg304_Image_475.jpg)'
- en: The `separate()` method includes two extra improvements. First, the desired
    separation now depends on the size of the vehicle, as opposed to an arbitrary
    constant. This way, the separation behavior adapts dynamically to the individual
    characteristics of the vehicles. Second, the magnitude of the vector pointing
    away from a neighboring vehicle is set to be inversely proportional to the distance.
    This means that the closer the neighbor, the more the vehicle wants to flee, and
    vice versa.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`separate()`方法包含了两个额外的改进。首先，所需的分离距离现在依赖于车辆的大小，而不是一个任意常数。这样，分离行为会根据车辆的个体特征动态适应。其次，指向邻近车辆的向量的大小被设置为与距离成反比。这意味着邻居越近，车辆越想逃离，反之亦然。'
- en: '![Image](../images/pencil.jpg) **Exercise 5.12**'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 5.12**'
- en: 'Create a `cohere()` method that follows the opposite logic of `separate()`:
    if a vehicle is beyond a certain distance, steer toward that vehicle. This will
    keep the group together. (In a moment, I’ll look at what happens when both cohesion
    and separation play out together in the same simulation.)'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`cohere()`方法，它遵循与`separate()`相反的逻辑：如果一辆车与其他车的距离超过某个值，则向该车方向转向。这将保持群体的整体性。（稍后，我将查看当凝聚力和分离力同时在同一模拟中发挥作用时会发生什么。）
- en: '![Image](../images/pencil.jpg) **Exercise 5.13**'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 5.13**'
- en: Add the separation force to path following to create a simulation of Reynolds’s
    group path following.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 将分离力添加到路径跟随中，创建一个模拟Reynolds群体路径跟随的效果。
- en: '![Image](../images/pg305_Image_476.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg305_Image_476.jpg)'
- en: '**Combining Behaviors**'
  id: totrans-369
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**结合行为**'
- en: The most exciting and intriguing group behaviors come from mixing and matching
    multiple steering forces. After all, how could I even begin to simulate emergence
    in a complex system through a sketch that has only one rule?
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 最令人兴奋和有趣的群体行为来自于混合和匹配多种转向力。毕竟，如何通过只有一个规则的草图来模拟一个复杂系统中的涌现现象呢？
- en: 'When multiple steering forces are at play, I need a mechanism for managing
    them all. You may be thinking, “This is nothing new. We juggle multiple forces
    all the time.” You would be right. In fact, this technique appeared as early as
    [Chapter 2](ch02.xhtml#ch02):'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个转向力同时作用时，我需要一种机制来管理它们。你可能会想：“这没什么新鲜的。我们一直在处理多个力。”你说得对。事实上，这种技术早在[第二章](ch02.xhtml#ch02)中就出现过：
- en: '[PRE17]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, a `Mover` object responds to two forces. This all works nicely because
    of the way the `Mover` class was designed to accumulate the force vectors into
    its acceleration vector. In this chapter, however, the forces stem from the internal
    desires of the movers (now called *vehicles*). And those desires can be weighted
    so that some hold more sway than others. For example, consider a sketch in which
    all vehicles have two desires:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一个`Mover`对象响应两种力。之所以能顺利工作，是因为`Mover`类的设计使得力向量能够汇聚到它的加速度向量中。然而，在本章中，这些力来源于`mover`（现在称为*车辆*）的内部需求。这些需求可以赋予不同的权重，使某些需求比其他需求更具影响力。例如，考虑一个草图，其中所有车辆都有两个需求：
- en: Seek the mouse position.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找老鼠的位置。
- en: Separate from any vehicles that are too close.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与任何过于接近的车辆保持分离。
- en: Imagine the vehicles represent a school of fish. Although the fish want to avoid
    colliding with one another, their primary concern is seeking out a food source
    (the mouse). Being able to adjust the weights of the two steering forces is crucial
    to achieving this effect.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 想象这些车辆代表着一群鱼。尽管鱼类希望避免彼此碰撞，但它们的首要任务是寻找食物来源（例如老鼠）。能够调整两种转向力的权重对实现这一效果至关重要。
- en: 'To begin, I’ll add a method called `applyBehaviors()` to the `Vehicle` class
    to manage all the behaviors:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将在`Vehicle`类中添加一个名为`applyBehaviors()`的方法来管理所有行为：
- en: '[PRE18]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, a single method takes care of calling the other methods that apply the
    forces—`separate()` and `seek()`. I could start mucking around within those methods
    to adjust the strength of the forces they’re calculating, but it might be easier
    to instead ask those methods to simply calculate and return the forces. Then I
    can adjust the forces’ strength and apply them to the vehicle’s acceleration within
    `applyBehaviors()`:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，单一的方法负责调用其他应用力的方法——`separate()` 和 `seek()`。我本可以开始调整这些方法中计算的力的强度，但不如让这些方法简单地计算并返回这些力。然后，我可以在
    `applyBehaviors()` 中调整这些力的强度，并将它们应用于车辆的加速度：
- en: '![Image](../images/pg306_Image_477.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg306_Image_477.jpg)'
- en: 'Here’s how this new approach changes the `seek()` method:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是新方法如何改变 `seek()` 方法的方式：
- en: '![Image](../images/pg306_Image_478.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg306_Image_478.jpg)'
- en: 'This change is subtle but incredibly important: it allows the strength of these
    forces to be weighted all in one place.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变化微妙但极其重要：它允许在一个地方对这些力的强度进行加权。
- en: '![Image](../images/pg307_Image_480.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg307_Image_480.jpg)'
- en: In this code, I use `mult()` to adjust the forces. By multiplying each force
    vector by a factor, its magnitude is scaled accordingly. These factors (in this
    case, 1.5 for `separate` and 0.5 for `seek`) represent the weight assigned to
    each force. However, the weights don’t have to be constants. Think about how they
    might vary dynamically based on conditions within the environment or properties
    of the vehicle. For example, what if the `seek` weight increases when the vehicle
    detects food nearby (imagine the vehicle as a creature with a `hunger` property)
    or the `separate` weight becomes larger if the vehicle enters a crowded area?
    This flexibility in adjusting the weights allows for more sophisticated and nuanced
    behaviors to emerge.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我使用 `mult()` 来调整各个力的大小。通过将每个力向量乘以一个系数，它的大小会相应地缩放。这些系数（在这种情况下，`separate`
    的系数是 1.5，`seek` 的系数是 0.5）代表了分配给每个力的权重。然而，权重并不一定是常数。你可以考虑它们如何根据环境条件或车辆的特性动态变化。例如，当车辆探测到附近有食物时，`seek`
    的权重可能会增加（可以将车辆想象成一个拥有 `hunger` 属性的生物），或者当车辆进入拥挤区域时，`separate` 的权重可能会变大。这种动态调整权重的灵活性允许出现更加复杂和微妙的行为。
- en: '![Image](../images/pencil.jpg) **Exercise 5.14**'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 5.14**'
- en: Modify [Example 5.10](ch05.xhtml#ch5ex10) so that the behavior weights change
    over time. For example, what if the weights were calculated according to a sine
    wave or Perlin noise? Or what if some vehicles are more concerned with seeking
    and others are more concerned with separating? Can you introduce other steering
    behaviors as well?
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 [示例 5.10](ch05.xhtml#ch5ex10)，使得行为权重随时间变化。例如，假设权重是根据正弦波或 Perlin 噪声计算的呢？或者假设某些车辆更关注寻求行为，而其他车辆则更关注分离行为？你能引入其他转向行为吗？
- en: '**Flocking**'
  id: totrans-388
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**集群行为**'
- en: '**Flocking** is a group animal behavior found in many living creatures, such
    as birds, fish, and insects. In 1986, Reynolds created a computer simulation of
    flocking behavior and documented the algorithm in his paper “Flocks, Herds, and
    Schools: A Distributed Behavioral Model.” Re-creating this simulation in p5.js
    will bring together all the concepts in this chapter:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '**集群行为**是许多生物中都能观察到的一种群体行为，如鸟类、鱼类和昆虫等。1986年，Reynolds 创建了一个关于集群行为的计算机模拟，并在他的论文《群体、兽群和鱼群：一种分布式行为模型》中详细记录了这个算法。在
    p5.js 中重新创建这个模拟将结合本章中的所有概念：'
- en: I will use the steering force formula (steer = desired – velocity) to implement
    the rules of flocking.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我将使用转向力公式（steer = desired – velocity）来实现集群行为的规则。
- en: These steering forces will be group behaviors and will require each vehicle
    to perceive all the other vehicles.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些转向力将形成群体行为，需要每个车辆感知到所有其他车辆。
- en: I will combine and weight multiple forces.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我将结合并加权多个力。
- en: The result will be a complex system—intelligent group behavior will emerge from
    the simple rules of flocking without the presence of a centralized system or leader.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果将是一个复杂的系统——智能群体行为将从简单的集群规则中涌现出来，而无需集中系统或领导者的存在。
- en: The good news is, I’ve already demonstrated items 1 through 3 in this chapter,
    so this section can just be about putting it all together and seeing the result.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，我已经在本章中演示了第1到第3项内容，所以这一部分只需要将这些内容整合起来并查看结果。
- en: Before I begin, I should mention that I’m going to change the name of the `Vehicle`
    class (yet again). Reynolds uses the term *boid* (a made-up word that refers to
    a birdlike object) to describe the elements of a flocking system. I’ll do the
    same.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我应该提一下，我将再次更改`Vehicle`类的名称。Reynolds使用了*boid*这个术语（一个虚构的词，指代类似鸟的物体）来描述鸟群系统中的元素。我也将采用这个术语。
- en: 'Three rules govern flocking:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 鸟群聚集有三条规则：
- en: '**Separation** (aka avoidance): Steer to avoid colliding with your neighbors.'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分离**（又称避让）：引导避免与邻居发生碰撞。'
- en: '**Alignment** (aka copy): Steer in the same direction as your neighbors.'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对齐**（又称复制）：朝着与邻居相同的方向引导。'
- en: '**Cohesion** (aka center): Steer toward the center of your neighbors (stay
    with the group).'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**凝聚**（又称中心）：朝着邻居的中心引导（保持与群体在一起）。'
- en: '[Figure 5.34](ch05.xhtml#ch5fig34) illustrates these rules.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.34](ch05.xhtml#ch5fig34)说明了这些规则。'
- en: '![Image](../images/pg309_Image_481.jpg)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/pg309_Image_481.jpg)'
- en: 'Figure 5.34: The three rules of flocking: separation, alignment, and cohesion.
    The example vehicle and desired velocity are bold.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.34：鸟群聚集的三条规则：分离、对齐和凝聚。示例车辆和期望速度为粗体。
- en: 'Just as with [Example 5.10](ch05.xhtml#ch5ex10), in which I combined separation
    and seeking, I want the `Boid` objects to have a single method that manages all
    three behaviors. I’ll call it `flock()`:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在[示例 5.10](ch05.xhtml#ch5ex10)中，我将分离和寻求结合在一起一样，我希望`Boid`对象有一个方法来管理这三种行为。我将其命名为`flock()`：
- en: '![Image](../images/pg309_Image_482.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/pg309_Image_482.jpg)'
- en: 'Now, it’s just a matter of implementing the three rules. I applied separation
    already; it’s identical to the previous example. Instead, I’ll focus on alignment,
    or steering in the same direction as the neighboring boids. As with all other
    steering behaviors, I have to express this concept as a desire: the boid’s desired
    velocity is the average velocity of its neighbors. The algorithm is therefore
    to calculate the average velocity of all the other boids and set that to the desired
    velocity:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，问题只是如何实现这三条规则。我已经应用了分离规则；它与前面的示例相同。接下来，我将重点关注对齐，或者说是与相邻的鸟群保持相同的方向。和其他所有的引导行为一样，我需要将这个概念表达为一种愿望：鸟群的期望速度是其邻居的平均速度。因此，算法就是计算所有其他鸟群的平均速度，并将其设置为期望速度：
- en: '![Image](../images/pg309_Image_483.jpg)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/pg309_Image_483.jpg)'
- en: This is pretty good but is missing one rather crucial detail. One of the key
    principles behind complex systems like flocking is that the elements (in this
    case, boids) have *short-range* relationships. Thinking about ants again, it’s
    easy to imagine an ant being able to sense its immediate environment, but less
    so an ant having an awareness of what another ant is doing hundreds of feet away.
    Indeed, the ants’ ability to manifest such complex collective behavior from only
    these neighboring relationships is what makes them so exciting in the first place.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经相当不错，但缺少一个非常关键的细节。复杂系统（如鸟群聚集）的一个关键原理是，系统中的元素（在这里是鸟群）具有*短程*关系。再想想蚂蚁，想象蚂蚁能够感知它的直接环境是容易的，但要想象一只蚂蚁能够知道几百英尺外另一只蚂蚁的行为就不那么容易了。实际上，正是蚂蚁通过这些邻近关系展现出复杂的集体行为的能力，才使得它们如此令人兴奋。
- en: In the `align()` method, I’m currently taking the average velocity of *all*
    the boids, whereas I should really be looking at only the boids within a certain
    distance (see [Figure 5.35](ch05.xhtml#ch5fig35)). That distance threshold can
    be variable, of course. You could design boids that can see only 20 pixels away
    or boids that can see 100 pixels away.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在`align()`方法中，我目前正在计算*所有*鸟群的平均速度，而我实际上应该只考虑某个特定距离内的鸟群（见[图 5.35](ch05.xhtml#ch5fig35)）。当然，这个距离阈值是可以变化的。你可以设计只看到20像素远的鸟群，也可以设计看到100像素远的鸟群。
- en: '![Image](../images/pg310_Image_485.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/pg310_Image_485.jpg)'
- en: 'Figure 5.35: The example vehicle (bold) interacts with only the vehicles within
    its neighborhood (the circle).'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.35：示例车辆（粗体）只与其邻域内的车辆互动（圆圈内）。
- en: 'I already applied similar logic when I implemented separation, calculating
    a force based only on other vehicles within a certain distance. Now I want to
    do the same for alignment (and eventually, cohesion):'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现分离时，我已经应用了类似的逻辑，只计算一定距离内其他车辆的作用力。现在，我希望对对齐做同样的处理（最终还包括凝聚）：
- en: '![Image](../images/pg311_Image_486.jpg)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/pg311_Image_486.jpg)'
- en: As with the `separate()` method, I’ve included the condition `this !== other`
    to ensure that a boid doesn’t consider itself when calculating the average velocity.
    It would probably work regardless, but having each boid constantly be influenced
    by its own velocity could lead to a feedback loop that would disrupt the overall
    behavior.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 与`separate()`方法一样，我加入了条件`this !== other`，以确保鸟群在计算平均速度时不会考虑自己。虽然不加这个条件可能也能工作，但如果每只鸟群不断受到自身速度的影响，可能会导致一个反馈循环，从而破坏整体行为。
- en: '![Image](../images/pencil.jpg) **Exercise 5.15**'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 5.15**'
- en: Can you rewrite the `align()` method so that boids see only other boids that
    fall within a direct line of sight?
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 你能重新编写`align()`方法，使得鸟群只会看到那些在直接视线范围内的其他鸟群吗？
- en: '![Image](../images/pg311_Image_487.jpg)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg311_Image_487.jpg)'
- en: The code for cohesion is quite similar to that for alignment. The only difference
    is that instead of calculating the average *velocity* of the boid’s neighbors,
    I want to calculate the average *position* of the boid’s neighbors (and use that
    as a target to seek).
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 凝聚的代码与对齐的代码非常相似。唯一的区别是，我不再计算鸟群邻居的平均*速度*，而是计算鸟群邻居的平均*位置*（并将其作为目标进行寻求）。
- en: '![Image](../images/pg312_Image_488.jpg)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg312_Image_488.jpg)'
- en: 'It’s also worth taking the time to write a class called `Flock` that manages
    the whole group of boids. It will be virtually identical to the `ParticleSystem`
    class from [Chapter 4](ch04.xhtml#ch04), with only one tiny change: when I call
    `run()` on each `Boid` object (as I did to each `Particle` object), I’ll pass
    in a reference to the entire array of boids:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以花些时间编写一个名为`Flock`的类来管理整个鸟群。它将与[第4章](ch04.xhtml#ch04)中的`ParticleSystem`类几乎完全相同，唯一的微小变化是：当我对每个`Boid`对象调用`run()`时（就像对每个`Particle`对象做的一样），我将传入整个鸟群数组的引用：
- en: '![Image](../images/pg312_Image_489.jpg)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg312_Image_489.jpg)'
- en: All that remains is to initialize the flock in `setup()` and run it in `draw()`.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是在`setup()`中初始化鸟群，并在`draw()`中运行它。
- en: '![Image](../images/pg313_Image_490.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg313_Image_490.jpg)'
- en: Just as with the particle systems from [Chapter 4](ch04.xhtml#ch04), you can
    see the elegance of OOP in simplifying the `setup()` and `draw()` functions.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 就像[第4章](ch04.xhtml#ch04)中的粒子系统一样，你可以看到面向对象编程（OOP）在简化`setup()`和`draw()`函数方面的优雅。
- en: '![Image](../images/pencil.jpg) **Exercise 5.16**'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 5.16**'
- en: Combine flocking with other steering behaviors.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 将鸟群行为与其他控制行为结合起来。
- en: '![Image](../images/pencil.jpg) **Exercise 5.17**'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 5.17**'
- en: 'In his book *The Computational Beauty of Nature* (Bradford Books, 2000), Gary
    Flake describes a fourth rule for flocking, **view**: “Move laterally away from
    any boid that blocks the view.” Have your boids follow this rule.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在他的书《*自然的计算美*》（Bradford Books，2000年）中，Gary Flake描述了鸟群行为的第四条规则，**视野**：“从任何挡住视线的鸟群那里横向移动。”让你的鸟群遵循这一规则。
- en: '![Image](../images/pg314_Image_491.jpg)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg314_Image_491.jpg)'
- en: '![Image](../images/pencil.jpg) **Exercise 5.18**'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 5.18**'
- en: Create a flocking simulation in which all the parameters (*separation weight*,
    *cohesion weight*, *alignment weight*, *maximum force*, *maximum speed*) change
    over time. They could be controlled by Perlin noise or by user interaction. (For
    example, you could use the p5.js `createSlider()` function to tie the values to
    slider positions that can be adjusted in real time.)
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个鸟群模拟，其中所有参数（*分离权重*、*凝聚权重*、*对齐权重*、*最大力*、*最大速度*）随时间变化。它们可以通过Perlin噪声或用户交互来控制。（例如，你可以使用p5.js的`createSlider()`函数将这些值与可以实时调整的滑块位置绑定。）
- en: '![Image](../images/pencil.jpg) **Exercise 5.19**'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 5.19**'
- en: Visualize the flock in an entirely different way.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 以完全不同的方式可视化鸟群。
- en: '**Algorithmic Efficiency (or: Why Does My Sketch Run So Slowly?)**'
  id: totrans-433
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**算法效率（或：为什么我的草图运行这么慢？）**'
- en: Group behaviors are wonderful, but it’s with a heavy heart that I must admit
    that they can also be slow. In fact, the bigger the group, the slower the sketch
    can be. I’d love to hide this dark truth from you, because I’d like you to be
    happy and live a fulfilling and meaningful life, free from concerns about the
    efficiency of your code. But I’d also like to be able to sleep at night without
    worrying about your inevitable disappointment when you try to run your flocking
    simulation with too many boids.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 群体行为非常有趣，但我必须带着沉重的心情承认，它们也可能很慢。事实上，群体越大，草图的运行速度就越慢。我很想隐藏这个黑暗的真相，因为我希望你能快乐，过上充实而有意义的生活，不必为代码的效率而烦恼。但我也希望能在晚上安心入睡，而不是担心当你尝试运行包含太多boid的集群模拟时，你会感到无法避免的失望。
- en: 'Usually, when I talk about p5.js sketches running slowly, it’s because drawing
    to the canvas can be slow—the more you draw, the slower your sketch runs. As you
    may recall from [Chapter 4](ch04.xhtml#ch04), switching to a different renderer
    like WebGL can sometimes alleviate this issue, allowing for faster drawing of
    larger particle systems. With something like a flocking simulation, however, the
    slowness derives from the algorithm. Computer scientists put this problem in terms
    of something called **big** *Ο* **notation**, where the *O* stands for *order*.
    This is shorthand for describing the efficiency of an algorithm: How many computational
    cycles does the algorithm require to complete?'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我谈到p5.js草图运行缓慢时，原因是绘制到画布可能会很慢——你绘制的越多，草图运行就越慢。正如你可能从[第4章](ch04.xhtml#ch04)回忆到的那样，切换到WebGL这样的不同渲染器有时可以缓解这个问题，从而允许更快速地绘制更大的粒子系统。然而，对于像集群模拟这样的东西，慢速的根本原因来自于算法。计算机科学家用一种叫做**大**
    *Ο* **记法**的术语来描述这个问题，其中的*O*代表“阶”。这是描述算法效率的简写：算法完成所需的计算周期数是多少？
- en: Consider a simple search problem. You have a basket containing 100 chocolate
    treats, only one of which is pure dark chocolate. That’s the one you want to eat.
    To find it, you pick the chocolates out of the basket one by one. You might be
    lucky and find it on the first try, but in the worst-case scenario, you have to
    check all 100 before you find the dark chocolate. To find one thing in 100, you
    have to check 100 things (or to find one thing in *N* things, you have to check
    *N* times). The big *O* notation here is *O(N*). This, incidentally, is also the
    big *O* notation that describes a simple particle system. If you have *N* particles,
    you have to run and display those particles *N* times.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个简单的搜索问题。你有一个装有100个巧克力糖果的篮子，只有一个是纯黑巧克力。那是你想吃的。为了找到它，你一颗颗挑出巧克力糖果。你可能很幸运，一开始就找到它，但在最坏的情况下，你必须检查所有100个糖果才能找到黑巧克力。在100个物品中找到一个，你必须检查100个物品（或者在*N*个物品中找到一个，你必须检查*N*次）。这里的大
    *O* 记法是 *O(N*)。顺便提一下，这也是描述一个简单粒子系统的大 *O* 记法。如果你有*N*个粒子，你就必须运行并显示这些粒子*N*次。
- en: Now, let’s think about a group behavior such as flocking. For every `Boid` object,
    you have to check the velocity and position of every other `Boid` object before
    you can calculate its steering force. Let’s say you have 100 boids. For boid 1,
    you need to check 100 boids; for boid 2, you need to check 100 boids; and so on.
    In all, for 100 boids, you need to perform 10,000 checks (100 × 100 = 10,000).
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们思考一种群体行为，比如集群。对于每一个`Boid`对象，你需要在计算其转向力之前，检查每一个其他`Boid`对象的速度和位置。假设你有100只boid。对于boid
    1，你需要检查100只boid；对于boid 2，你需要检查100只boid；以此类推。总之，对于100只boid，你需要进行10,000次检查（100 ×
    100 = 10,000）。
- en: 'You might be thinking, “No problem. Computers are fast. They can do 10,000
    things pretty easily.” But what if there are 1,000 boids? Then you have this:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，“没问题，计算机很快。它们可以很轻松地处理10,000个任务。”但如果有1,000只boid呢？那你就得这样处理：
- en: 1,000 × 1,000 = 1,000,000 cycles
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 1,000 × 1,000 = 1,000,000次循环
- en: This is getting rather slow but is still somewhat manageable. What about 10,000
    elements?
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 这开始变得相当慢，但仍然可以勉强应付。那么，10,000个元素呢？
- en: 10,000 × 10,000 = 100,000,000 cycles
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 10,000 × 10,000 = 100,000,000次循环
- en: Now things are getting really slow. Really, really, really slow.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 现在事情变得真的很慢，真的，真的，非常慢。
- en: Notice a pattern? As the number of elements increases by a factor of 10, the
    number of required cycles increases by a factor of 100\. More broadly, as the
    number of elements increases by a factor of *N*, the cycles increase by a factor
    of *N* × *N*, or *N*². In big *O* notation, this is known as *O*(*N*²).
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到一个规律了吗？随着元素数量增加10倍，所需的循环次数增加100倍。更广泛地说，当元素数量增加*N*倍时，循环次数增加*N* × *N*，即*N*²。在大
    *O* 记法中，这被称为 *O*(*N*²)。
- en: Perhaps you’re thinking, “No problem. With flocking, I need to consider only
    the boids that are close to the current boid. So even if I have 1,000 boids, I
    can just look at, say, the 5 closest boids to each one, and then I only have 5,000
    cycles.” You pause for a moment and then start thinking, “So for each boid, I
    just need to check all the boids and find the 5 closest ones and I’m good!” See
    the catch-22? Even if you want to look at only the close ones, the only way to
    know what the close ones are would be to check all of them.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你在想，“没问题，使用群集时，我只需要考虑靠近当前个体的其他个体。所以即使我有1000个个体，我也可以只看每个个体的5个最近邻，这样我总共就只需要5,000个周期。”你停顿了一下，开始思考，“所以对于每个个体，我只需要检查所有个体，找出5个最近的就好了！”看到了问题所在了吗？即使你只想查看最近的个体，唯一知道哪些是最近的方式就是检查所有的个体。
- en: Or is there another way?
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 或者有没有其他方法？
- en: '**Spatial Subdivisions**'
  id: totrans-446
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**空间划分**'
- en: In his 2000 paper “Interaction with Groups of Autonomous Characters” (*[https://www.red3d.com/cwr/papers/2000/pip.pdf](https://www.red3d.com/cwr/papers/2000/pip.pdf)*),
    Reynolds (surprise, surprise) suggests a technique known as **bin-lattice spatial
    subdivision** (often called *binning* for short) for optimizing flocking algorithms
    and other group behaviors. This technique hinges on dividing the simulation space
    into a grid of smaller cells (or bins).
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在他2000年的论文《与自主角色群体的互动》（* [https://www.red3d.com/cwr/papers/2000/pip.pdf](https://www.red3d.com/cwr/papers/2000/pip.pdf)
    *）中，Reynolds（意料之中）提出了一种被称为**bin-lattice空间划分**（通常简称为*binning*）的技术，用于优化群集算法和其他群体行为。该技术的关键是将仿真空间划分为一个更小单元（或称“箱子”）的网格。
- en: To demonstrate, imagine the canvas is divided into a grid of 10 rows and 10
    columns, for a total of 100 cells (10 × 10 = 100). And let’s say you have 2,000
    boids—a number small enough for you to realistically want, but large enough to
    run too slowly (2,000 × 2,000 = 4,000,000 cycles). At any given moment, each boid
    falls within a cell in the grid, as shown in [Figure 5.36](ch05.xhtml#ch5fig36).
    With 2,000 boids and 100 cells, on average there will be approximately 20 boids
    per cell (2,000 ÷ 100 = 20).
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，假设画布被划分为10行10列的网格，总共有100个单元格（10 × 10 = 100）。假设你有2,000个个体——这个数量足够小，以便你实际希望它，但又足够大，以致运行得太慢（2,000
    × 2,000 = 4,000,000个周期）。在任何给定时刻，每个个体都会落在网格中的一个单元格内，如[图5.36](ch05.xhtml#ch5fig36)所示。对于2,000个个体和100个单元格，平均每个单元格大约会有20个个体（2,000
    ÷ 100 = 20）。
- en: '![Image](../images/pg316_Image_492.jpg)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg316_Image_492.jpg)'
- en: 'Figure 5.36: A square canvas full of vehicles, subdivided into a grid of square
    cells'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.36：一个充满车辆的方形画布，划分为一个方形单元格的网格
- en: Now say that in order to apply the flocking rules to a given boid, you need
    to look at only the other boids that are in that boid’s cell. With an average
    of 20 boids per cell, each cell would require 400 cycles (20 × 20 = 400), and
    with 100 cells, that’s 40,000 cycles total (400 × 100 = 40,000). That’s a massive
    savings of over 4,000,000 cycles!
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设，为了将群集规则应用到给定的个体，你只需要查看该个体所在单元格中的其他个体。每个单元格平均包含20个个体，那么每个单元格将需要400个周期（20
    × 20 = 400），而有100个单元格时，总共需要40,000个周期（400 × 100 = 40,000）。这将节省超过4,000,000个周期！
- en: 'To implement the bin-lattice spatial subdivision algorithm in p5.js, I’ll need
    multiple arrays. The first array keeps track of all the boids, just as in the
    original flocking example:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 p5.js 中实现 bin-lattice 空间划分算法，我需要多个数组。第一个数组用于跟踪所有个体，就像原始的群集示例一样：
- en: '[PRE19]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The second is a 2D array (repurposing the code from [Example 5.4](ch05.xhtml#ch5ex4))
    representing the cells in the grid:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是一个二维数组（重新使用[示例 5.4](ch05.xhtml#ch5ex4)中的代码），表示网格中的单元格：
- en: '![Image](../images/pg316_Image_493.jpg)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg316_Image_493.jpg)'
- en: 'Each value in the 2D array is itself an array that will hold references to
    the `Boid` objects currently inside that cell in the grid. If you’re keeping score,
    that’s an array within an array within an array:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 该二维数组中的每个值本身是一个数组，里面包含当前在该单元格内的`Boid`对象的引用。如果你在记录的话，这就是一个嵌套数组：数组中的数组中的数组：
- en: '![Image](../images/pg317_Image_495.jpg)'
  id: totrans-457
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg317_Image_495.jpg)'
- en: 'Every cycle through `draw()`, the array for each grid cell is first cleared.
    Then each boid registers itself in the appropriate cell according to its position.
    This way, the boids’ cell assignments are updated as the boids move:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 每次通过`draw()`时，每个网格单元的数组都会首先被清除。然后，每个个体根据其位置将自己注册到适当的单元格中。这样，随着个体的移动，其所在单元格的分配会被更新：
- en: '![Image](../images/pg317_Image_496.jpg)'
  id: totrans-459
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg317_Image_496.jpg)'
- en: Finally, when it comes time to have the boids check their neighbors, they can
    look at only those in their particular cell.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当需要让群体检查它们的邻居时，它们只需查看自己所在单元格中的群体。
- en: '![Image](../images/pg318_Image_497.jpg)'
  id: totrans-461
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg318_Image_497.jpg)'
- en: I’m covering only the basics of the bin-lattice algorithm here. In practice,
    each boid should also check the boids in the neighboring cells (above, below,
    left, right, and diagonals), as well as the boids in its own cell. (To find out
    how that’s done, see the full code on the book’s website.) Even with that extra
    checking, however, the algorithm is still much more efficient than checking every
    single boid.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 我这里只介绍了bin-lattice算法的基础知识。在实际应用中，每个群体还应该检查相邻单元格（上、下、左、右以及对角线方向）中的群体，以及它自己单元格中的群体。（如果想了解如何实现这一点，可以查看本书网站上的完整代码。）然而，即使增加了这种额外的检查，算法仍然比检查每一个群体更高效。
- en: This approach still has flaws, however. For example, what if all the boids congregate
    in the corner and live in the same cell? Doesn’t that take me right back to checking
    all 2,000 against all 2,000? In fact, bin-lattice spatial subdivision is most
    effective when the elements are evenly distributed throughout the canvas. A data
    structure known as a **quadtree**, however, can handle unevenly distributed systems,
    preventing the worst-case scenario of all the boids crowding into a single cell.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法仍然存在缺陷。例如，如果所有的群体聚集在角落并生活在同一个单元格中呢？这不就意味着我又回到了检查所有2,000个群体与所有2,000个群体吗？事实上，bin-lattice空间细分在元素均匀分布于画布时最有效。然而，一种名为**四叉树**的数据结构可以处理不均匀分布的系统，避免了所有群体都挤进一个单元格的最坏情况。
- en: The quadtree expands the spatial subdivision strategy by dynamically adapting
    the grid according to the distribution of the boids. Instead of a fixed grid,
    a quadtree starts with a single large cell that encompasses the entire space.
    If too many boids are found within this cell, it splits into four smaller cells.
    This process can repeat for each new cell that gets too crowded, creating a flexible
    grid that provides finer resolution when and where it’s needed.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 四叉树通过根据群体（boids）的分布动态调整网格，扩展了空间细分策略。与固定网格不同，四叉树从一个大的单元格开始，这个单元格包含整个空间。如果这个单元格内的群体太多，它会分裂成四个更小的单元格。这个过程会对每个新的单元格进行重复，当它变得过于拥挤时，就会继续分裂，从而创建一个灵活的网格，在需要时提供更精细的分辨率。
- en: '![Image](../images/pg319_Image_498.jpg)'
  id: totrans-465
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg319_Image_498.jpg)'
- en: 'The quadtree data structure is key to the Barnes-Hut algorithm, which I referenced
    briefly when building an *n*-body simulation in [Chapter 2](ch02.xhtml#ch02).
    This method uses a quadtree to approximate groups of bodies into a single one
    when calculating gravitational forces. This drastically reduces the number of
    calculations needed, allowing simulations with large numbers of bodies to run
    more efficiently. You can learn more about building a quadtree and applying it
    to a flocking system as part of Coding Challenge #98 on the Coding Train website
    (*[https://thecodingtrain.com/quadtree](https://thecodingtrain.com/quadtree)*).'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 四叉树数据结构是Barnes-Hut算法的关键，我在构建[n-body模拟](ch02.xhtml#ch02)时简要提到过这个算法。该方法使用四叉树将一组物体近似为一个单独的物体，从而在计算引力时减少计算量。这大大减少了所需的计算次数，使得拥有大量物体的模拟运行得更加高效。你可以通过访问Coding
    Train网站的[挑战98](https://thecodingtrain.com/quadtree)了解更多关于构建四叉树并将其应用于群体系统的内容。
- en: '![Image](../images/pencil.jpg) **Exercise 5.20**'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 5.20**'
- en: Expand the bin-lattice spatial subdivision flocking sketch from [Example 5.12](ch05.xhtml#ch5ex12)
    to use a quadtree.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展bin-lattice空间细分群体模拟，参考[示例 5.12](ch05.xhtml#ch5ex12)，使用四叉树。
- en: '**More Optimization Tricks**'
  id: totrans-469
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**更多优化技巧**'
- en: 'While I’m at it, here are a few more tips related to keeping your code in tip-top,
    speedy shape:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，这里还有一些与保持代码高效、快速相关的额外提示：
- en: Use the magnitude squared (or sometimes the distance squared).
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用平方的大小（magnitude squared）（有时也称为平方的距离）。
- en: Calculate the sine and cosine lookup tables.
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算正弦和余弦查找表。
- en: Don’t make gazillions of unnecessary p5.Vector objects.
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要创建无数不必要的p5.Vector对象。
- en: Each of these tips is detailed next.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来将详细介绍这些技巧。
- en: '**Use the Magnitude Squared**'
  id: totrans-475
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用平方的大小**'
- en: What is magnitude squared, and when should you use it? Think back to how the
    magnitude of a vector is calculated.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是平方的大小（magnitude squared），以及何时使用它？回想一下如何计算一个向量的大小。
- en: '[PRE20]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Magnitude requires the square-root operation. And so it should! After all, if
    you want the magnitude of a vector, you have to break out the Pythagorean theorem
    (we did this in [Chapter 1](ch01.xhtml#ch01)). However, if you could somehow skip
    taking the square root, your code would run faster.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 大小需要平方根运算。这是应该的！毕竟，如果你想要一个向量的大小，你得用到勾股定理（我们在[第一章](ch01.xhtml#ch01)中做过）。然而，如果你能
    somehow 跳过平方根的计算，你的代码将运行得更快。
- en: Say you just want to know the *relative* magnitude of a vector `v`. For example,
    is the magnitude greater than 10?
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你只想知道一个向量`v`的*相对*大小。例如，大小是否大于10？
- en: '[PRE21]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Well, that is equivalent to saying the following:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这等价于以下说法：
- en: '[PRE22]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: And how is magnitude squared calculated?
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何计算平方后的大小呢？
- en: '[PRE23]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It’s calculated the same as magnitude, but without the square root. In the case
    of a single vector, using `magSq()` rather than `mag()` will never significantly
    improve the performance of a p5.js sketch. However, if you’re computing the magnitude
    of thousands of vectors each time through `draw()`, working with the magnitude
    squared could help your code run a wee bit faster.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 它的计算方式与大小相同，但不包含平方根。对于单个向量而言，使用`magSq()`而不是`mag()`不会显著提高p5.js草图的性能。然而，如果你每次通过`draw()`计算成千上万个向量的大小，使用平方后的大小可能会让你的代码运行稍微更快一点。
- en: '**Calculate Sine and Cosine Lookup Tables**'
  id: totrans-486
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**计算正弦和余弦查找表**'
- en: Taking the square root isn’t the only mathematical function that’s slow to compute.
    Trig functions like sine, cosine, and tangent are also slow. If you just need
    an individual sine or cosine value here or there in your code, you’re never going
    to run into a problem. But what if you had something like this?
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 取平方根并不是唯一计算上慢的数学函数。正弦、余弦和正切等三角函数也很慢。如果你只是在代码中偶尔需要一个单独的正弦或余弦值，你永远不会遇到问题。但是，如果你有类似下面的情况呢？
- en: '[PRE24]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Sure, this is a totally ridiculous code snippet that you would never write.
    But it illustrates a certain point: if you’re calculating the sine of pi 10,000
    times, why not just calculate it once, save that value, and refer to it whenever
    necessary?'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一个完全荒谬的代码片段，你永远不会写出来。但它说明了一个问题：如果你要计算π的正弦10,000次，为什么不一次性计算，保存该值，并在需要时引用它呢？
- en: 'This is the principle behind sine and cosine **lookup tables**. Instead of
    calling the sine and cosine functions in your code whenever you need them, you
    can build an array that stores the results of sine and cosine at angles from 0
    to 2π, and then just look up the precalculated values when you need them. For
    example, here are two arrays that store the sine and cosine values for every integer
    angle from 0 to 359 degrees. I’ll use `angleMode(DEGREES)` here to simplify the
    discussion, but the same technique can be applied with radians:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是正弦和余弦**查找表**的原理。你可以通过构建一个数组，存储从0到2π之间的角度对应的正弦和余弦结果，而不是每次在代码中调用正弦和余弦函数。然后，在需要时，只需查找预计算的值。例如，以下是两个数组，分别存储从0到359度的每个整数角度对应的正弦和余弦值。我在这里使用`angleMode(DEGREES)`来简化讨论，但同样的技术也可以应用于弧度：
- en: '[PRE25]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, what if you need to print the sine of pi (or 180 degrees)?
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你需要打印π的正弦值（或180度的正弦）呢？
- en: '[PRE26]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The key here is that looking up a precalculated value from an array is incredibly
    fast compared to a complex operation like sine or cosine.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于，从数组中查找一个预计算的值比进行像正弦或余弦这样的复杂操作要快得多。
- en: '![Image](../images/pg322_Image_499.jpg)'
  id: totrans-495
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg322_Image_499.jpg)'
- en: The code accompanying [Example 5.14](ch05.xhtml#ch5ex14) enhances the initial
    snippets by incorporating variables for the lookup table’s precision, allowing
    it to store values at increments of less than 1 degree.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5.14](ch05.xhtml#ch5ex14)中的代码通过引入查找表精度的变量，增强了初始代码片段，使其能够以小于1度的增量存储值。'
- en: '**Don’t Make Gazillions of Unnecessary p5.Vector Objects**'
  id: totrans-497
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**不要创建成千上万不必要的p5.Vector对象**'
- en: In any sketch, every object you create occupies space in the computer’s memory.
    This might not be a concern with just a few objects, but when sketches generate
    many objects, especially in loops or over time, it can slow performance. Sometimes
    it turns out that not all the objects are really necessary.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何草图中，你创建的每个对象都会占用计算机内存的空间。对于少量对象，这可能不会构成问题，但当草图生成大量对象时，尤其是在循环或时间推移中，可能会影响性能。有时，事实证明并非所有的对象都是必需的。
- en: 'I have to admit, I’m perhaps the biggest culprit when it comes to creating
    excessive objects. In the interest of writing clear and understandable examples,
    I often choose to make extra `p5.Vector` objects when I absolutely don’t need
    to. For the most part, this isn’t a problem at all. But sometimes it can be. Take
    a look at this example:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须承认，当涉及到创建过多对象时，我可能是最大的罪魁祸首。为了编写清晰易懂的示例，我经常在完全不需要的情况下创建额外的`p5.Vector`对象。大多数情况下，这根本不是问题。但有时它可能会成为问题。看看这个例子：
- en: '[PRE27]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Say the `vehicles` array contains 1,000 vehicles. That means I’m also making
    1,000 new `p5.Vector` objects for the mouse’s position every single time through
    `draw()`. On any standard laptop or desktop computer purchased in recent times,
    this sketch likely won’t register a complaint, run slowly, or have any problems.
    After all, modern computers have tons of RAM, and JavaScript will be able to handle
    making and disposing of 1,000 or so temporary objects without much of a problem.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`vehicles`数组包含1,000辆车。这意味着每次通过`draw()`时，我都会为鼠标的位置创建1,000个新的`p5.Vector`对象。在最近购买的任何标准笔记本或台式电脑上，这个草图很可能不会出现任何问题，运行也不会变慢。毕竟，现代计算机有大量的内存，JavaScript能够处理创建和销毁大约1,000个临时对象的问题。
- en: 'If, however, the number of objects grows larger (and it easily could), a problem
    will almost certainly arise. As such, you should look for ways to reduce the number
    of `p5.Vector` objects you make. In this case, here’s a simple fix:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果对象的数量变得更大（而且它很可能会变大），几乎肯定会出现问题。因此，你应该寻找减少创建`p5.Vector`对象数量的方法。在这种情况下，这里有一个简单的解决方法：
- en: '[PRE28]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now I’ve made just 1 vector instead of 1,000\. Even better, I could turn the
    vector into a global variable and then just assign the `x` and `y` values within
    `draw()` with `set()`:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我只创建了一个向量，而不是1,000个。更好的是，我可以将这个向量变成一个全局变量，然后在`draw()`中仅通过`set()`赋值`x`和`y`：
- en: '[PRE29]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now I never make a new `p5.Vector` object after the sketch starts; I just use
    the same one over the whole length of the sketch!
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在草图开始后，我再也不会创建新的`p5.Vector`对象；我只是使用同一个对象贯穿整个草图！
- en: 'Throughout the book’s examples, you’ll find lots of opportunities to reduce
    the number of temporary objects. (I told you, I’m a major offender.) For example,
    here’s a snippet from this chapter’s `seek()` method:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的示例中，你会发现有很多机会可以减少临时对象的数量。（我告诉过你，我是个重大罪犯。）例如，以下是本章`seek()`方法中的一段代码：
- en: '![Image](../images/pg323_Image_500.jpg)'
  id: totrans-508
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg323_Image_500.jpg)'
- en: 'See how I’ve made two vector objects? First, I calculate the desired velocity
    vector, then the steering force. To be more efficient, I could rewrite this to
    create only one vector:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我是如何创建两个向量对象的？首先，我计算出所需的速度向量，然后是转向力。为了提高效率，我可以重写代码，仅创建一个向量：
- en: '![Image](../images/pg324_Image_501.jpg)'
  id: totrans-510
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg324_Image_501.jpg)'
- en: I don’t actually need a second vector called `steer`. I can reuse the `desired`
    vector object and turn it into the steering force by subtracting `velocity`. I
    didn’t do this in my example because it makes the code more confusing to read.
    But in some cases, changes like this may improve efficiency.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 我其实不需要一个名为`steer`的第二个向量。我可以重用`desired`向量对象，并通过减去`velocity`将其转变为转向力。我在示例中没有这么做，因为这样会让代码变得更难阅读。但在某些情况下，像这样的改动可能会提高效率。
- en: '![Image](../images/pencil.jpg) **Exercise 5.21**'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 5.21**'
- en: Eliminate as many temporary `p5.Vector` objects from the flocking example as
    possible. Also use `magSq()` where possible.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能减少在群体行为示例中创建临时的`p5.Vector`对象。并且尽可能使用`magSq()`。
- en: '![Image](../images/bird.jpg) **The Ecosystem Project**'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/bird.jpg) **生态系统项目**'
- en: 'Use steering forces to drive the behavior of the creatures in your ecosystem.
    Here are some possibilities:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 使用转向力来驱动你生态系统中生物的行为。以下是一些可能性：
- en: Create schools or flocks of creatures.
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建生物的群体或鸟群。
- en: Use a seeking behavior for creatures to search for food (for chasing moving
    prey, consider *pursuit*).
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用寻求行为让生物寻找食物（对于追逐移动猎物，可以考虑*追击*）。
- en: Use a flow field for the ecosystem environment. For example, how does your system
    behave if the creatures live in a flowing river?
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为生态系统环境使用流场。例如，如果生物生活在一条流动的河流中，你的系统将如何表现？
- en: Build a creature with countless steering behaviors (as many as you can reasonably
    add). Think about ways to vary the weights of the behaviors so you can dial them
    up and down, mixing and matching on the fly. How are creatures’ initial weights
    set? What rules drive how the weights change over time?
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个具有无数转向行为的生物（尽可能多地添加）。思考如何改变这些行为的权重，以便可以随时调节它们，灵活地混合和匹配。生物的初始权重是如何设置的？有哪些规则驱动权重随时间变化？
- en: Complex systems can be nested. Can you design a single creature out of a flock
    of boids? And can you then make a flock of those creatures?
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂系统可以是嵌套的。你能否设计出由一群鸟群组成的单个生物？然后你能否再让这些生物组成一群？
- en: Complex systems can have memory (and be adaptive). Can the history of your ecosystem
    affect the behavior in its current state? (This could be the driving force behind
    how the creatures adjust their steering force weights.)
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂系统可以具有记忆（并且具有适应性）。你的生态系统的历史是否会影响其当前状态下的行为？（这可能是生物如何调整其转向力权重的驱动力。）
- en: '![Image](../images/pg325_Image_502.jpg)'
  id: totrans-522
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg325_Image_502.jpg)'
