- en: '**5 Autonomous Agents**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**5 自主代理**'
- en: '*Life is a journey, not a destination.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*生活是一场旅程，而非目的地。*'
- en: —Ralph Waldo Emerson
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: —拉尔夫·沃尔多·爱默生
- en: '![Image](../images/pg253_Image_364.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg253_Image_364.jpg)'
- en: '**Mo’i fish (photo courtesy of the US National Oceanic and Atmospheric Administration)**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**莫伊鱼（图片由美国国家海洋和大气管理局提供）**'
- en: Six-finger threadfins (*Polydactylus sexfilis*), also known as fish of kings,
    or *mo*’*i*, in Hawaiian, are shown swimming in a shoal. The mo’i fish held a
    special status for Hawaiian royalty and were raised in dedicated ponds to ensure
    their population growth and prevent their extinction. The fish display a delicate
    and coordinated dance in their collective movement, with each individual mo’i
    subtly influencing and being influenced by its neighboring fish.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 六指丝鳞鱼（*Polydactylus sexfilis*），也叫“王鱼”，或在夏威夷语中称为*mo’i*，它们在群体中游动。莫伊鱼在夏威夷王室中享有特殊地位，专门在养殖池中培育，以确保它们的种群增长并防止灭绝。这些鱼在集体运动中展示出精妙而协调的舞蹈，每条莫伊鱼都在微妙地影响并被邻近的鱼所影响。
- en: 'So far, I’ve been demonstrating inanimate objects, lifeless shapes sitting
    on the canvas that flop around when affected by forces in their environment. But
    this is *The **Nature** of Code*. What if I could breathe life into those shapes?
    What if those shapes could live by their own rules? Can shapes have hopes and
    dreams and fears? These sorts of questions are the domain of this chapter. They’re
    what separate unthinking objects from something much more interesting: autonomous
    agents.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我一直在展示没有生命的物体、静止的形状，它们在外界力量的作用下摇摆不定。但这就是*代码的**本质**。*如果我能为这些形状注入生命呢？如果这些形状能够按照自己的规则生存呢？形状能有希望、梦想和恐惧吗？这些问题是本章的主题。它们是将无意识的物体与更有趣的事物区分开来的关键：自主代理。
- en: '**Forces from Within**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**来自内部的力量**'
- en: An **autonomous agent** is an entity that makes its own choices about how to
    act in its environment, without any influence from a leader or global plan. In
    this book, *acting* typically means moving. For example, instead of simulating
    a particle that’s passively drawn toward or repelled by another shape because
    of a force like gravity, I’d now like to design an entity that has the ability—or
    even the “desire”—to make decisions about its movements. It could *decide* to
    move toward or away from a target, like a moth drawn to a flame or a small fish
    evading a predator.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**自主代理**是一个能够在其环境中做出自己行动决定的实体，而不受任何领导者或全球计划的影响。在本书中，*行动*通常指的是移动。例如，我不再模拟一个被重力等力吸引或排斥的粒子，而是希望设计一个具有能力——甚至是“愿望”——做出自己移动决策的实体。它可以*决定*朝着某个目标移动或远离目标，就像一只飞蛾被火焰吸引，或一条小鱼躲避捕食者一样。'
- en: The switch from inanimate objects to autonomous agents is a significant conceptual
    leap, but the codebase will barely change. The desire for an autonomous agent
    to move is just another force, like the force of gravity or the force of the wind.
    It’s just that now the force is coming *from within*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 从无生命物体到自主代理的转变是一个重要的概念飞跃，但代码本身几乎没有变化。自主代理想要移动的欲望只是另一种力，就像重力或风力一样。只不过现在这种力是*来自内部*的。
- en: 'Here are three key components of autonomous agents to keep in mind as I build
    this chapter’s examples:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我构建本章示例时，有三个自主代理的关键组成部分需要牢记：
- en: '**An autonomous agent has a limited ability to perceive its environment.**
    It makes sense that a living, breathing being should be aware of its environment.
    However, this awareness doesn’t refer to just the external environment but also
    to the agent’s internal state—its position, velocity, and potentially other properties
    or even simulated emotions. Throughout the chapter, I’ll explore ways agents can
    take their own state into account when making decisions. I’ll also cover programming
    techniques for objects to store references to other objects and therefore “perceive”
    their surroundings. It’s important to consider the word *limited* here. Are you
    designing an all-knowing circle that flies around a canvas, aware of everything
    else in that canvas? Or are you creating a shape that can examine other shapes
    only within 15 pixels of itself? Of course, there’s no right answer to this question;
    it all depends on what you want. I’ll explore several possibilities throughout
    this chapter, but in general, limitations are good for creating a simulation that
    feels more “natural.” An insect, for example, may be aware of only the sights
    and smells that immediately surround it. To model a real-world creature, you could
    study the exact science of these limitations. Luckily, I can just make stuff up
    and try it out.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自主智能体对其环境的感知能力是有限的。** 生活和呼吸的生物应该能够意识到其环境的存在是合理的。然而，这种意识不仅仅指外部环境，还包括智能体的内部状态——如位置、速度，甚至可能包括其他属性或模拟的情感。在本章中，我将探讨智能体在做出决策时如何考虑自身状态。我还将介绍一些编程技术，使对象能够存储对其他对象的引用，从而“感知”其周围环境。这里的*有限*一词很重要。你是在设计一个全知的圆形对象，它可以在画布上飞行，意识到画布中的一切吗？还是你在创建一个只能观察到自己15像素范围内其他形状的形状？当然，这个问题没有唯一的正确答案；一切取决于你的需求。在本章中，我将探讨几种可能性，但总的来说，局限性有助于创建一个更“自然”的模拟。例如，一只昆虫可能只会感知到立即围绕它的景象和气味。要模拟一种真实的生物，你可以研究这些局限性的确切科学。幸运的是，我只需凭空想象并进行尝试。'
- en: '**An autonomous agent processes the information from its environment and calculates
    an action.** This will be the easy part, as the action is a force. The environment
    might tell the agent that there’s a big, scary-looking shark swimming right at
    it, and the action will be a powerful force in the opposite direction.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自主智能体处理来自环境的信息并计算出一个行动。** 这一部分相对简单，因为行动本身就是一种力。环境可能会告诉智能体，有一只巨大的、看起来很可怕的鲨鱼正向它游来，那么它的行动将是朝相反方向施加的强大力量。'
- en: '**An autonomous agent has no leader.** This third principle is something I
    care a little less about, depending on the context. For example, if you’re designing
    a system for which it makes sense to have a leader barking commands at various
    entities, then that’s what you’ll want to implement. Nevertheless, many of the
    chapter’s examples will have no leader for an important reason: toward the end
    of this chapter, I’ll examine group behaviors and look at designing collections
    of autonomous agents that exhibit the properties of **complex systems**. These
    are intelligent and structured group dynamics that emerge not from a leader, but
    from the local interactions of the elements themselves.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自主智能体没有领导者。** 这个第三条原则根据上下文，我可能不太关心。例如，如果你在设计一个系统，在这个系统中让领导者向各个实体发号施令是合适的，那么你就可以这样实现。然而，本章中的许多示例将没有领导者，这是有重要原因的：在本章的最后，我将研究群体行为，并探讨如何设计表现出**复杂系统**特性的自主智能体集合。这些是智能的、有结构的群体动态，它们并非来自领导者，而是来自元素之间局部互动的结果。'
- en: 'I could start my exploration of autonomous agents in many places. Artificial
    simulations of ant and termite colonies are fantastic demonstrations of systems
    of agents, for example. For more on this topic, I encourage you to read *Turtles,
    Termites, and Traffic Jams* by Mitchel Resnick (Bradford Books, 1997). However,
    I want to begin by examining agent behaviors that build on the work in the first
    four chapters of this book: modeling motion with vectors and forces. And so I’ll
    return to the book’s ever-changing hero class—once `Walker`, then `Mover`, then
    `Particle`—and give it yet another incarnation.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以从许多地方开始探索自主智能体。例如，人工模拟的蚂蚁和白蚁群体是智能体系统的极好示范。关于这个话题，我鼓励你阅读Mitchel Resnick的《*乌龟、白蚁与交通堵塞*》（Bradford
    Books，1997）。然而，我想从本书前四章的工作基础上出发，首先探讨建立在向量和力的运动建模上的智能体行为。因此，我将回到本书那本不断变化的英雄类——最初是`Walker`，然后是`Mover`，再到`Particle`——并赋予它全新的形式。
- en: '**Vehicles and Steering**'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**车辆与转向**'
- en: 'In the late 1980s, computer scientist Craig Reynolds (*[https://www.red3d.com/cwr](https://www.red3d.com/cwr)*)
    developed algorithmic **steering** behaviors for animated characters. These behaviors
    allowed individual elements to navigate their digital environments in a lifelike
    manner, with strategies for fleeing, wandering, arriving, pursuing, evading, and
    more. Later, in his 1999 paper “Steering Behaviors for Autonomous Characters,”
    Reynolds uses the word *vehicle* to describe his autonomous agents. I’ll follow
    suit, calling my autonomous agent class `Vehicle`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在1980年代末，计算机科学家 Craig Reynolds (*[https://www.red3d.com/cwr](https://www.red3d.com/cwr)*)
    为动画角色开发了算法化的 **转向** 行为。这些行为允许个体元素以生动的方式在其数字环境中导航，拥有逃跑、徘徊、到达、追踪、躲避等策略。后来，在他1999年的论文《自主角色的转向行为》中，Reynolds
    使用 *车辆* 一词来描述他的自主代理。我将效仿他，称我的自主代理类为 `Vehicle`：
- en: '![Image](../images/pg255_Image_364a.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg255_Image_364a.jpg)'
- en: Like the `Mover` and `Particle` classes before it, the `Vehicle` class’s motion
    is controlled through its position, velocity, and acceleration vectors. This will
    make the steering behaviors of a single autonomous agent straightforward to implement.
    Yet by building a system of multiple vehicles that steer themselves according
    to simple, locally based rules, surprising levels of complexity emerge. The most
    famous example is Reynolds’s boids model for flocking or swarming behavior, which
    I’ll demonstrate in [Example 5.11](ch05.xhtml#ch5ex11).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前的 `Mover` 类和 `Particle` 类一样，`Vehicle` 类的运动是通过其位置、速度和加速度向量来控制的。这将使单个自主代理的转向行为变得易于实现。然而，通过构建一个由多个车辆组成的系统，这些车辆根据简单的局部规则自行转向，会产生惊人的复杂性。最著名的例子是
    Reynolds 的鸟群模型，它展示了群体或集群行为，我将在 [示例 5.11](ch05.xhtml#ch5ex11) 中展示。
- en: '![Image](../images/zoom.jpg) **Why Vehicles?**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/zoom.jpg) **为什么是车辆？**'
- en: 'In his book *Vehicles: Experiments in Synthetic Psychology* (Bradford Books,
    1986), Italian neuroscientist and cyberneticist Valentino Braitenberg describes
    a series of hypothetical vehicles with simple internal structures, writing, “This
    is an exercise in fictional science, or science fiction, if you like that better.”
    Braitenberg argues that his extraordinarily simple mechanical vehicles manifest
    behaviors such as fear, aggression, love, foresight, and optimism. Reynolds took
    his inspiration from Braitenberg, and I’ll take mine from Reynolds.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在他的书《车辆：合成心理学实验》（Bradford Books，1986年）中，意大利神经科学家和控制论学者 Valentino Braitenberg
    描述了一系列假设的车辆，具有简单的内部结构，他写道：“这是一个虚构科学的练习，或者如果你更喜欢，可以称之为科幻小说。”Braitenberg 认为，他那些极其简单的机械车辆展现了诸如恐惧、攻击、爱情、预见和乐观等行为。Reynolds
    从 Braitenberg 中汲取了灵感，而我将从 Reynolds 中获得我的灵感。
- en: 'Reynolds describes the motion of *idealized* vehicles—idealized because he
    wasn’t concerned with their actual engineering, but rather started with the assumption
    that they work and respond to the rules defined. These vehicles have three layers:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Reynolds 描述了 *理想化* 车辆的运动——理想化是因为他不关心它们的实际工程，而是从它们能够正常工作并响应所定义规则的假设出发。这些车辆有三个层次：
- en: '**Action selection:** A vehicle has a goal (or goals) and can choose an action
    (or a combination of actions) based on that goal. This is essentially where I
    left off in the discussion of autonomous agents. The vehicle takes a look at its
    environment and *selects* an action based on a desire: “I see a zombie marching
    toward me. Since I don’t want my brains to be eaten, I’m going to flee from the
    zombie.” The goal is to keep one’s brains, and the action is to flee. Reynolds’s
    paper describes many goals and associated actions, such as seeking a target, avoiding
    an obstacle, and following a path. In a moment, I’ll start building out these
    examples with p5.js code.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**动作选择：** 一辆车有一个目标（或多个目标），并可以根据该目标选择一个动作（或多个动作的组合）。这本质上是我在讨论自主代理时的停顿点。车辆观察环境并基于一种欲望来*选择*一个动作：“我看到一个僵尸朝我走来。因为我不想让我的大脑被吃掉，我要从僵尸那里逃跑。”目标是保住自己的大脑，动作是逃跑。Reynolds
    的论文描述了许多目标和相关的动作，比如寻找目标、避开障碍物和跟踪路径。稍后，我将用 p5.js 代码展开这些示例。'
- en: '**Steering:** Once an action has been selected, the vehicle has to calculate
    its next move. That next move will be a force—more specifically, a steering force.
    Luckily, Reynolds has developed a simple steering force formula that I’ll use
    throughout the examples in this chapter: **steering force = desired velocity –
    current velocity**. I’ll get into the details of this formula and why it works
    so effectively in the next section.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**转向：** 一旦选择了一个动作，车辆就必须计算其下一步行动。下一步将是一个力——更具体地说，是一个转向力。幸运的是，Reynolds提出了一个简单的转向力公式，我将在本章的例子中使用：**转向力
    = 期望速度 - 当前速度**。我将在下一节详细讨论这个公式以及它为何如此有效。'
- en: '**Locomotion:** For the most part, I’m going to ignore this third layer. In
    the case of fleeing from zombies, the locomotion could be described as “left foot,
    right foot, left foot, right foot, as fast as you can.” In a canvas, however,
    a rectangle, circle, or triangle’s actual movement across a window is irrelevant,
    given that the motion is all an illusion in the first place. This isn’t to say
    that you should ignore locomotion entirely, however. You’ll find great value in
    thinking about the locomotive design of your vehicle and how you choose to animate
    it. The examples in this chapter will remain visually bare; a good exercise would
    be to elaborate on the animation style. For example, could you add spinning wheels,
    oscillating paddles, or shuffling legs?'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**运动方式：** 大多数情况下，我将忽略这一第三层。在逃避僵尸的情况下，运动方式可以描述为“左脚，右脚，左脚，右脚，尽可能快。”然而，在画布中，一个矩形、圆形或三角形在窗口中的实际运动并不重要，因为运动本身就是一种幻觉。但这并不是说你应该完全忽视运动方式。你会发现，思考你车辆的运动设计以及如何选择动画呈现它会非常有价值。本章中的示例将保持视觉上的简洁；一个不错的练习是展开动画风格。例如，你能为它添加旋转的轮子、摆动的桨板，或者是走动的腿吗？'
- en: 'Ultimately, the most important layer for you to consider is the first one,
    action selection. What are the elements of your system, and what are their goals?
    In this chapter, I’m going to cover a series of steering behaviors (that is, actions):
    seeking, fleeing, following a path, following a flow field, flocking with your
    neighbors, and so on. As I’ve said in other chapters, however, the point isn’t
    that you should use these exact behaviors in all your projects. Rather, the point
    is to show you *how* to model a steering behavior—*any* steering behavior—in code,
    and to provide a foundation for designing and developing your own vehicles with
    new and exciting goals and behaviors.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，最重要的层次是你需要考虑的第一层，动作选择。你的系统元素是什么，它们的目标是什么？在本章中，我将涵盖一系列转向行为（即动作）：寻找目标、逃避、跟随路径、跟随流场、与邻居集群等等。然而，正如我在其他章节中所说，重点不是你在所有项目中都使用这些具体的行为。而是，重点是教你*如何*在代码中建模转向行为——*任何*转向行为——并为你设计和开发具有新目标和行为的车辆提供基础。
- en: What’s more, even though the examples in this chapter are highly literal (follow
    that pixel!), you should allow yourself to think more abstractly (like Braitenberg).
    What would it mean for your vehicle to have “love” as its goal or “fear” as its
    driving force? Finally (and I’ll address this in “Combining Behaviors” on [page
    265](ch05.xhtml#ch00lev2sec36)), you won’t get very far by developing simulations
    with only one action. Yes, the first example’s action will be to seek a target.
    But by being creative—by making these steering behaviors *your own*—it will all
    come down to mixing and matching multiple actions within the same vehicle. View
    the coming examples not as singular behaviors to be emulated, but as pieces of
    a larger puzzle that you’ll eventually assemble.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，尽管本章中的示例非常直观（跟着那个像素走！），你应该允许自己更加抽象地思考（就像Braitenberg一样）。如果你的车辆的目标是“爱”或者其驱动力是“恐惧”，那会意味着什么呢？最后（我将在[第265页](ch05.xhtml#ch00lev2sec36)的“结合行为”部分讨论这个问题），仅仅通过开发一个单一动作的模拟，你是走不远的。是的，第一个示例的动作将是寻找目标。但通过发挥创意——通过让这些转向行为*成为你自己的*——最终的关键是将多个动作结合在同一辆车中。将接下来的示例视为一个更大拼图中的一部分，而不是单一的行为模仿。
- en: '**The Steering Force**'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**转向力**'
- en: 'What exactly is a steering force? To answer, consider the following scenario:
    a vehicle with a current velocity is seeking a target. For fun, let’s think of
    the vehicle as a bug-like creature that desires to savor a delicious strawberry,
    as in [Figure 5.1](ch05.xhtml#ch5fig1).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是转向力？为了回答这个问题，考虑以下情境：一辆具有当前速度的车辆正在寻找目标。为了趣味，我们可以把这辆车想象成一只像虫子一样的生物，想要品尝一颗美味的草莓，如[图5.1](ch05.xhtml#ch5fig1)所示。
- en: '![Image](../images/pg257_Image_365.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg257_Image_365.jpg)'
- en: 'Figure 5.1: A vehicle with a velocity and a target'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：具有速度和目标的车辆
- en: The vehicle’s goal and subsequent action is to seek the target. Thinking back
    to [Chapter 2](ch02.xhtml#ch02), you might begin by making the target an attractor
    and applying a gravitational force that pulls the vehicle to the target. This
    would be a perfectly reasonable solution, but conceptually it’s not what I’m looking
    for here.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 该车辆的目标和后续行动是寻找目标。回想一下[第2章](ch02.xhtml#ch02)，你可能会从将目标设为吸引物并应用引力将车辆拉向目标开始。这是一个完全合理的解决方案，但从概念上讲，这并不是我在这里想要的。
- en: 'I don’t want to simply calculate a force that pushes the vehicle toward its
    target; rather, I want to ask the vehicle to make an intelligent decision to steer
    toward the target based on its perception of its own state (its speed and the
    direction in which it’s currently moving) and its environment (the location of
    the target). The vehicle should consider how it desires to move (a vector pointing
    to the target), compare that goal with how it’s currently moving (its velocity),
    and apply a force accordingly. That’s exactly what Reynolds’s steering force formula
    says:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我不想简单地计算一个推动车辆向目标移动的力；相反，我希望要求车辆根据它对自身状态（其速度和当前运动的方向）以及环境（目标的位置）的感知做出智能决策，朝向目标行驶。车辆应考虑它希望如何移动（指向目标的向量），将这个目标与当前的运动状态（其速度）进行比较，并相应地施加力。这正是Reynolds的转向力公式所表达的：
- en: steering force = desired velocity − current velocity
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 转向力 = 期望速度 − 当前速度
- en: 'Or, as you might write in p5.js:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以在p5.js中这样写：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The *current* velocity isn’t a problem: the `Vehicle` class already has a variable
    for that. However, the *desired* velocity has to be calculated. Take a look at
    [Figure 5.2](ch05.xhtml#ch5fig2). If the vehicle’s goal is defined as *seeking
    the target*, then its desired velocity is a vector that points from its current
    position to the target position.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*当前*速度并不是问题：`Vehicle`类已经有一个变量来表示这一点。然而，*期望*速度需要计算。看看[图5.2](ch05.xhtml#ch5fig2)。如果车辆的目标定义为*寻找到目标*，那么它的期望速度就是一个从当前位置指向目标位置的向量。'
- en: '![Image](../images/pg258_Image_366.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg258_Image_366.jpg)'
- en: 'Figure 5.2: The vehicle’s desired velocity points from its position to the
    target. (The desired vector should point from the vehicle’s center to the target’s
    center but is shortened for illustration purposes.)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：车辆期望的速度从其当前位置指向目标。（期望的向量应该从车辆的中心指向目标的中心，但为了说明简化了长度。）
- en: 'Assuming a `p5.Vector` called `target` defining the target’s position, I then
    have this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个`p5.Vector`变量叫做`target`，定义了目标的位置，那么我就有了：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There’s more to the story, however. What if it is a high-resolution canvas
    and the target is thousands of pixels away? Sure, the vehicle might desire to
    teleport itself instantly to the target position with a massive velocity, but
    this won’t make for an effective animation. I’ll restate the desire as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，故事还有更多的内容。如果这是一个高分辨率的画布，而目标距离数千个像素远呢？当然，车辆可能希望以极大的速度瞬间传送到目标位置，但这不会产生有效的动画。我将愿望重新表述如下：
- en: '*The vehicle desires to move toward the target at the maximum possible speed*.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*车辆希望以最大可能的速度朝向目标移动*。'
- en: In other words, the `desired` vector should point from the vehicle’s current
    position to the target position, with a magnitude equal to the maximum speed of
    the vehicle, as shown in [Figure 5.3](ch05.xhtml#ch5fig3).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`期望`向量应该从车辆的当前位置指向目标位置，大小等于车辆的最大速度，如[图5.3](ch05.xhtml#ch5fig3)所示。
- en: '![Image](../images/pg259_Image_367.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg259_Image_367.jpg)'
- en: 'Figure 5.3: The magnitude of the vehicle’s desired velocity is *max speed*.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：车辆期望速度的大小是*最大速度*。
- en: The concept of maximum speed was introduced in [Chapter 1](ch01.xhtml#ch01)
    to ensure that a mover’s speed remained within a reasonable range. However, I
    didn’t always use it in the subsequent chapters. In [Chapter 2](ch02.xhtml#ch02),
    other forces such as friction and drag kept the speed in check, while in [Chapter
    3](ch03.xhtml#ch03), oscillation was caused by opposing forces that kept the speed
    limited. In this chapter, maximum speed is a key parameter for controlling the
    behavior of a steering agent, so I’ll include it in all the examples.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最大速度的概念在[第1章](ch01.xhtml#ch01)中被引入，用以确保移动者的速度保持在合理范围内。然而，在随后的章节中我并未始终使用这一概念。在[第2章](ch02.xhtml#ch02)中，摩擦力和阻力等其他力量限制了速度，而在[第3章](ch03.xhtml#ch03)中，相反的力量导致了振荡，从而保持了速度限制。在本章中，最大速度是控制转向代理行为的关键参数，因此我将在所有示例中包含它。
- en: 'While I encourage you to consider how other forces such as friction and drag
    could be combined with steering behaviors, I’m going to focus only on steering
    forces for the time being. As such, I can include the concept of maximum speed
    as a limiting factor in the force calculation. First, I need to add a property
    to the `Vehicle` class setting the maximum speed:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我鼓励你思考如何将摩擦力和阻力等其他力与转向行为结合起来，但目前我将只关注转向力。因此，我可以将最大速度的概念作为力计算中的限制因素。首先，我需要在`Vehicle`类中添加一个属性，设置最大速度：
- en: '![Image](../images/pg259_Image_368.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg259_Image_368.jpg)'
- en: 'Then, in the desired velocity calculation, I’ll scale according to maximum
    speed:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在期望速度的计算中，我将根据最大速度进行缩放：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Putting this all together, I can now write a method called `seek()` that receives
    a `p5.Vector` target and calculates a steering force toward that target:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 综合这些内容，我现在可以编写一个名为`seek()`的方法，该方法接收一个`p5.Vector`目标并计算指向该目标的转向力：
- en: '![Image](../images/pg259_Image_369.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg259_Image_369.jpg)'
- en: Notice that I finish the method by passing the steering force into `applyForce()`.
    This assumes that the code is built on top of the foundation I developed in [Chapter
    2](ch02.xhtml#ch02).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我在方法结束时将转向力传递给`applyForce()`。这假设代码是建立在我在[第2章](ch02.xhtml#ch02)中开发的基础之上的。
- en: To see why Reynolds’s steering formula works so well, take a look at [Figure
    5.4](ch05.xhtml#ch5fig4). It shows what the steering force looks like relative
    to the vehicle and target positions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解为什么Reynolds的转向公式如此有效，看看[图5.4](ch05.xhtml#ch5fig4)。它展示了转向力相对于车辆和目标位置的表现。
- en: '![Image](../images/pg260_Image_371.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg260_Image_371.jpg)'
- en: 'Figure 5.4: The vehicle applies a steering force equal to its desired velocity
    minus its current velocity.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4：车辆施加的转向力等于期望速度减去当前速度。
- en: 'This force looks quite different from gravitational attraction. Remember one
    of the principles of autonomous agents: an autonomous agent has a *limited* ability
    to perceive its environment, including its own state. Here’s that ability, subtly
    but powerfully embedded into Reynolds’s steering formula. In the case of gravitational
    attraction, the force pulling an object toward another is the same regardless
    of how that object is moving. But here, the vehicle is actively aware of its own
    velocity, and its steering force compensates accordingly. This adds a lifelike
    quality to the simulation, as the way in which the vehicle moves toward the target
    depends on its own understanding of its current motion.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这种力与引力的吸引力看起来有很大的不同。记住自主代理的一个原则：自主代理有*有限*的感知环境的能力，包括对自身状态的感知。这个能力被巧妙而有力地嵌入到Reynolds的转向公式中。在引力吸引的情况下，吸引物体的力是相同的，无论物体如何运动。但在这里，车辆是主动感知自己速度的，并且其转向力会做出相应的补偿。这为模拟增加了一种逼真的质量，因为车辆向目标移动的方式依赖于它对当前运动状态的理解。
- en: 'In all this excitement, I’ve missed one last step. What sort of vehicle is
    this? Is it a super-sleek race car with amazing handling? Or a large city bus
    that needs a lot of advance notice to turn? A graceful panda or a lumbering elephant?
    The example code, as it stands, has no feature to account for this variation in
    steering ability. For that, I need to limit the magnitude of the steering force.
    I’ll call this limit the maximum force (or `maxforce` for short):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一切兴奋之中，我错过了最后一步。这个车辆是什么类型的？是拥有惊人操控性能的超级跑车吗？还是需要大量预警才能转弯的大型城市公交车？是一只优雅的熊猫，还是一只笨拙的大象？目前的示例代码并没有考虑到这一转向能力的差异。为此，我需要限制转向力的大小。我将这个限制称为最大转向力（或简称`maxforce`）：
- en: '![Image](../images/pg260_Image_372.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg260_Image_372.jpg)'
- en: 'Now I just need to impose that limit before applying the steering force:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我只需要在施加转向力之前设定这个限制：
- en: '![Image](../images/pg261_Image_374.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg261_Image_374.jpg)'
- en: 'Limiting the steering force brings up an important point: the goal isn’t to
    get the vehicle to the target as fast as possible. If it were, I would just say,
    “Set position equal to target,” and the vehicle would instantly teleport to that
    location! Instead, as Reynolds puts it, the goal is to move the vehicle in a “lifelike
    and improvisational manner.”'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 限制转向力提出了一个重要的观点：目标不是尽可能快地将车辆送到目标位置。如果是这样，我只需要说，“将位置设置为目标”，车辆就会立刻传送到那个位置！相反，正如雷诺兹所说，目标是让车辆以一种“逼真且即兴的方式”移动。
- en: 'I’m trying to make the vehicle appear to be steering its way to the target,
    so it’s up to me to play with the forces and variables of the system to simulate
    a given behavior. For example, a large maximum steering force would result in
    a very different path than a small one (see [Figure 5.5](ch05.xhtml#ch5fig5)).
    One isn’t inherently better or worse than the other; it depends on the desired
    effect. (And of course, these values need not be fixed and could change based
    on other conditions. Perhaps a vehicle has an *energy* property: the higher the
    energy, the better it can steer.)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我试图让车辆看起来像是在朝目标方向转向，所以我需要调整系统中的力和变量来模拟给定的行为。例如，较大的最大转向力会导致与较小转向力截然不同的路径（见[图5.5](ch05.xhtml#ch5fig5)）。这两者并没有哪一个天生更好或更差；它取决于所需的效果。（当然，这些值不必是固定的，可以根据其他条件变化。也许车辆有一个*能量*属性：能量越高，转向性能越好。）
- en: '![Image](../images/pg261_Image_375.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg261_Image_375.jpg)'
- en: 'Figure 5.5: The path for a stronger maximum force (left) versus a weaker one
    (right)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5：更强的最大力（左）与较弱的最大力（右）路径对比
- en: Here’s the full `Vehicle` class, incorporating the rest of the elements from
    the [Chapter 2](ch02.xhtml#ch02) `Mover` class.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的`Vehicle`类，包含了来自[第2章](ch02.xhtml#ch02) `Mover`类的其余部分。
- en: '![Image](../images/pg262_Image_376.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg262_Image_376.jpg)'
- en: Note that, unlike the circles used to represent movers and particles in previous
    chapters, the `Vehicle` object is drawn as a triangle, defined as three custom
    vertices set with `beginShape()` and `endShape()`. This allows the vehicle to
    be represented in a way that indicates its direction, determined using the `heading()`
    method, as demonstrated in [Chapter 3](ch03.xhtml#ch03).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与之前章节中用来表示移动器和粒子的圆形不同，`Vehicle`对象被绘制为一个三角形，定义为使用`beginShape()`和`endShape()`设置的三个自定义顶点。这允许车辆以一种能够表示其方向的方式呈现，方向是通过`heading()`方法确定的，正如在[第3章](ch03.xhtml#ch03)中展示的那样。
- en: '![Image](../images/pencil.jpg) **Exercise 5.1**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/pencil.jpg) **练习 5.1**'
- en: Implement a *fleeing* steering behavior (the desired velocity is the same as
    *seek*, but pointed in the opposite direction).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个*逃避*转向行为（期望的速度与*寻求*相同，但指向相反的方向）。
- en: '![Image](../images/pencil.jpg) **Exercise 5.2**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/pencil.jpg) **练习 5.2**'
- en: Create a sketch in which a vehicle’s maximum force and maximum speed don’t remain
    constant but vary according to environmental factors.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个草图，在其中，车辆的最大力和最大速度不是保持不变的，而是根据环境因素发生变化。
- en: '![Image](../images/pencil.jpg) **Exercise 5.3**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/pencil.jpg) **练习 5.3**'
- en: Implement a seeking behavior with a moving target, often referred to as *pursuit*.
    In this case, your desired vector won’t point toward the object’s current position,
    but rather its future position as extrapolated from its current velocity. You’ll
    see this ability for a vehicle to “predict the future” in later examples. The
    solution is covered in the “Pursue & Evade” video on the Coding Train website
    (*[https://thecodingtrain.com/pursuit](https://thecodingtrain.com/pursuit)*).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个带有移动目标的追寻行为，通常称为*追逐*。在这种情况下，你的目标向量不会指向物体的当前位置，而是指向从其当前速度推算出的未来位置。你将在后续的示例中看到车辆如何“预测未来”。解决方案在《追逐与逃避》视频中有介绍，视频链接为(*[https://thecodingtrain.com/pursuit](https://thecodingtrain.com/pursuit)*).
- en: '![Image](../images/pg264_Image_378.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg264_Image_378.jpg)'
- en: '**The Arrive Behavior**'
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**到达行为**'
- en: After working for a bit with the seeking behavior, you’re probably asking yourself,
    “What if I want the vehicle to slow down as it approaches the target?” Before
    I can even begin to answer this question, I should explain why the seek behavior
    causes the vehicle to fly past the target in the first place, forcing it to turn
    around and go back. Consider the brain of a seeking vehicle. What is it thinking
    at each frame of the animation?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用寻路行为工作了一段时间后，你可能会问自己：“如果我希望车辆在接近目标时减速呢？”在我开始回答这个问题之前，我应该先解释为什么寻路行为会导致车辆飞越目标，迫使它转身回去。考虑一下寻路车辆的大脑。在每一帧动画中，它在想什么？
- en: I want to go as fast as possible toward the target.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我想尽可能快地朝目标前进。
- en: I want to go as fast as possible toward the target.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我想尽可能快地朝目标前进。
- en: I want to go as fast as possible toward the target.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我想尽可能快地朝目标前进。
- en: I want to go as fast as possible toward the target.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我想尽可能快地朝目标前进。
- en: I want to go as fast as possible toward the target.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我想尽可能快地朝目标前进。
- en: and so on . . .
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依此类推……
- en: The vehicle is so gosh darn excited about getting to the target that it doesn’t
    bother to make any intelligent decisions about its speed. No matter the distance
    to the target, it always wants to go as fast as possible. When the vehicle is
    very close, it will therefore end up overshooting the target (see [Figure 5.6](ch05.xhtml#ch5fig6),
    top).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这辆车对到达目标感到非常兴奋，以至于它不去做任何关于速度的智能决策。不管离目标多远，它总是想尽可能快地行驶。当车辆非常接近目标时，它最终会超越目标（见[图
    5.6](ch05.xhtml#ch5fig6)，顶部）。
- en: '![Image](../images/pg265_Image_379.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg265_Image_379.jpg)'
- en: 'Figure 5.6: The top vehicle has a desired velocity at maximum speed and will
    overshoot the target. The bottom vehicle illustrates scaling the desired velocity
    according to the distance from the target. (While I encourage you to continue
    thinking about the vehicle as a cute, bug-like creature, from this point it’s
    drawn as a triangle to keep things simple.)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6：上方的车辆目标速度设为最大速度，并且会超越目标。下方的车辆示范了根据与目标的距离来缩放目标速度。（虽然我鼓励你继续将车辆想象成一只可爱的虫子，但从这一点开始，它被画成三角形，以简化问题。）
- en: 'In some cases, this is the desired behavior. (Consider a puppy going after
    its favorite toy: it’s not slowing down, no matter how close it gets!) However,
    in many other cases (a car pulling into a parking spot, a bee landing on a flower),
    the vehicle’s thought process needs to consider its speed relative to the distance
    from its target (see [Figure 5.6](ch05.xhtml#ch5fig6), bottom). For example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，这是期望的行为。（想想小狗去追它最喜欢的玩具：无论离玩具多近，它都不会减速！）然而，在许多其他情况下（如汽车驶入停车位、蜜蜂停在花上），车辆的思维过程需要考虑与目标之间的距离相对的速度（见[图
    5.6](ch05.xhtml#ch5fig6)，底部）。例如：
- en: I’m very far away. I want to go as fast as possible toward the target.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我离得很远。我想尽可能快地朝目标前进。
- en: I’m somewhat far away. I still want to go as fast as possible toward the target.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我离目标还有一段距离。我仍然希望尽可能快地朝目标前进。
- en: I’m getting close. I want to go more slowly toward the target.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我快接近了。我想更慢地朝目标前进。
- en: I’m almost there. I want to go very slowly toward the target.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我快到了。我想很慢地朝目标前进。
- en: I’m there. I want to stop!
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我到了。我想停下来！
- en: How can you implement this *arriving* behavior in code? Think back to the `seek()`
    method. Which part of the code sets the magnitude of the desired velocity?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如何在代码中实现这种*到达*行为？回想一下`seek()`方法。代码中的哪部分设置了目标速度的大小？
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This always sets the magnitude of the `desired` vector to `maxspeed`, as in
    [Figure 5.7](ch05.xhtml#ch5fig7).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这总是将`desired`向量的大小设置为`maxspeed`，如[图 5.7](ch05.xhtml#ch5fig7)所示。
- en: '![Image](../images/pg266_Image_380.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg266_Image_380.jpg)'
- en: 'Figure 5.7: The vehicles have a desired velocity with a magnitude set to maximum
    speed, regardless of their relative distance to the target.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7：车辆的目标速度的大小设置为最大速度，无论它们与目标的相对距离如何。
- en: What if instead the desired velocity’s magnitude were equal to half the distance?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果相反，目标速度的大小等于距离的一半呢？
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: I’d still want to limit the magnitude of `desired` to no more than the maximum
    speed, to keep vehicles that are very far away from going ridiculously fast ([Figure
    5.8](ch05.xhtml#ch5fig8)).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我仍然希望将`desired`的大小限制在最大速度之内，以防止那些远距离的车辆行驶得过快（见[图 5.8](ch05.xhtml#ch5fig8)）。
- en: '![Image](../images/pg266_Image_381.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg266_Image_381.jpg)'
- en: 'Figure 5.8: The magnitude of each vehicle’s desired velocity is equal to half
    the distance to the target. In the case of the leftmost vehicle, the velocity
    is constrained to the maximum speed.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'While this change nicely demonstrates the goal of tying the desired speed to
    the distance from the target, it’s not a particularly good solution. After all,
    10 pixels away is rather close, and a desired speed of 5 is rather large. Something
    like a desired velocity with a magnitude equal to 5 percent of the distance might
    work better:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Reynolds describes an even more sophisticated approach. Imagine a circle around
    the target with a given radius *r*. If the vehicle is within that circle, it gradually
    slows down—from the maximum speed at the very edge of the circle to zero speed
    at the target ([Figure 5.9](ch05.xhtml#ch5fig9)).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg267_Image_382.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.9: Outside the circle, the magnitude of a vehicle’s desired velocity
    is set to the maximum speed. As vehicles enter the circle and approach the target,
    their desired velocity magnitude decreases.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: In other words, if the distance from the target is less than *r*, the desired
    speed ranges from 0 to the maximum speed mapped according to that distance.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg267_Image_383.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: 'The arrive behavior is a great demonstration of an autonomous agent’s perception
    of the environment—including its own state. This model differs from the inanimate
    forces of [Chapter 2](ch02.xhtml#ch02): a celestial body attracted to another
    body doesn’t know it is experiencing gravity, whereas a cheetah chasing its prey
    knows it’s chasing.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: The key is in the way the forces are calculated. For instance, in the gravitational
    attraction sketch ([Example 2.6](ch02.xhtml#ch2ex6)), the force always points
    directly from the object to the target—the exact direction of the desired velocity.
    Here, by contrast, the vehicle perceives its distance to the target and adjusts
    its desired speed accordingly, slowing as it gets closer. The force on the vehicle
    itself is therefore based not just on the desired velocity but also on the desired
    velocity *relative to its current velocity*. The vehicle accounts for its own
    state as part of its assessment of the environment.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Put another way, the magic of Reynolds’s *desired minus velocity* equation
    is that it essentially makes the steering force a manifestation of the current
    velocity’s *error*: “I’m supposed to be going this fast in this direction, but
    I’m actually going this fast in another direction. My error is the difference
    between where I want to go and where I’m currently going.” Sometimes this can
    lead to seemingly unexpected results, as in [Figure 5.10](ch05.xhtml#ch5fig10).'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg269_Image_385.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.10: A vehicle moving toward its target faster than its desired velocity
    will result in a steering force pointing away from the target.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: In this example of the arrive behavior, the vehicle is moving too fast toward
    the target. The steering force, or error, tells it to slow down by actually pointing
    in the opposite direction, away from the target. By contrast, with gravitational
    attraction, you would never have a force pointing away from the target, no matter
    how close the target is. Taking the error and applying it as a steering force
    results in more dynamic, lifelike simulations.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个“到达”行为的示例中，车辆朝目标移动的速度过快。转向力或误差告诉车辆通过实际上朝相反方向（远离目标）来减速。相比之下，利用引力吸引时，无论目标多么接近，力都不会指向远离目标的方向。通过将误差应用为转向力，结果是更加动态、逼真的模拟。
- en: '**Your Own Behaviors**'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**你自己的行为**'
- en: 'The first two examples I’ve covered—seek and arrive—boil down to calculating
    a single vector for each behavior: the *desired* velocity. In fact, every single
    one of Reynolds’s steering behaviors follows this same pattern. In this chapter,
    I’m going to walk through more of Reynolds’s behaviors—flow-field following, path
    following, and flocking. First, however, I want to emphasize again that these
    are *examples*—demonstrations of common steering behaviors that are useful in
    procedural animation. They aren’t the be-all and end-all of what *you* can do.
    As long as you can come up with a vector that describes a vehicle’s *desired*
    velocity, you’ve created your own steering behavior.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我所讨论的前两个示例——“寻路”和“到达”——归结为为每个行为计算一个单一的矢量：*期望*速度。事实上，雷诺兹的每一个转向行为都遵循相同的模式。在本章中，我将介绍更多雷诺兹的行为——流场跟随、路径跟随和集群行为。然而，首先，我想再次强调，这些是*示例*——展示了常见的转向行为，这些行为在程序化动画中非常有用。它们并不是你能做的事情的全部。只要你能够提出一个描述车辆*期望*速度的矢量，你就创造了自己的转向行为。
- en: 'For example, let’s see how Reynolds defines the desired velocity for his wandering
    behavior:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看看雷诺兹是如何定义游荡行为的期望速度的：
- en: '*Wandering is a type of random steering which has some long-term order: the
    steering direction on one frame is related to the steering direction on the next
    frame. This produces more interesting motion than, for example, simply generating
    a random steering direction each frame.*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*游荡是一种具有一定长期规律的随机转向：一帧中的转向方向与下一帧中的转向方向相关。这比例如每帧都生成一个随机转向方向更能产生有趣的运动。*'
- en: For Reynolds, the goal of wandering isn’t random motion, but rather a sense
    of moving in one direction for a little while, wandering off in the next direction
    for a little bit, and so on. [Figure 5.11](ch05.xhtml#ch5fig11) illustrates how
    Reynolds calculates a target to seek in order to achieve such an effect.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对雷诺兹来说，游荡的目标不是随机运动，而是希望车辆先朝一个方向移动一段时间，然后再朝下一个方向游荡一段时间，如此循环。[图 5.11](ch05.xhtml#ch5fig11)展示了雷诺兹如何计算一个目标来实现这种效果。
- en: '![Image](../images/pg270_Image_386.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg270_Image_386.jpg)'
- en: 'Figure 5.11: The wandering steering behavior is calculated as seeking a target
    that moves randomly along the perimeter of a circle projected in front of the
    vehicle.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11：游荡转向行为被计算为寻求一个目标，该目标在车辆前方的圆形周围随机移动。
- en: First, the vehicle predicts its future position as a fixed distance in front
    of it (in the direction of its current velocity). Then it draws a circle with
    radius *r* centered on that position and picks a random point along the circumference
    of the circle. That point, which moves randomly around the circle for each frame
    of animation, is the vehicle’s target, so its desired velocity points in that
    direction.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，车辆预测其未来位置，距离其当前速度方向固定的距离。然后，它在该位置画一个半径为 *r* 的圆，并从圆的周长上随机选择一个点。这个点会在每一帧动画中沿着圆周随机移动，它就是车辆的目标，因此它的期望速度指向那个方向。
- en: Sounds absurd, right? Or, at the very least, a bit arbitrary. In fact, this
    is a clever and thoughtful solution—it uses randomness to drive a vehicle’s steering,
    but constrains that randomness along the path of a circle to keep the vehicle’s
    movement from appearing jittery and, well, totally random.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来荒谬，对吧？或者至少有些任意。事实上，这是一种巧妙且深思熟虑的解决方案——它利用随机性来驱动车辆的转向，但将这种随机性限制在一个圆形路径上，以防止车辆的运动看起来颤抖或完全随机。
- en: 'The seemingly random and arbitrary nature of this solution should drive home
    the point I’m trying to make: these are *made-up* behaviors, even if they’re inspired
    by real-life motion. You can just as easily concoct another elaborate scenario
    to compute a desired velocity. And you should!'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 5.4**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Write the code for Reynolds’s wandering behavior. Use polar coordinates to calculate
    the vehicle’s target along a circular path.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg271_Image_387.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
- en: 'To give another example, say I want to create a steering behavior called *stay
    within walls*. To define the desired velocity, I’ll make a rule: if a vehicle
    comes within a distance *d* of a wall, that vehicle desires to move at maximum
    speed in the opposite direction of the wall (see [Figure 5.12](ch05.xhtml#ch5fig12)).'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg271_Image_388.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.12: The desired velocity points away from the wall if the vehicle
    gets too close.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: If I define the walls of the space as the edges of a canvas and an `offset`
    distance equal to 25, I can write the code for this with a series of `if` statements.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg272_Image_389.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
- en: In this `boundaries()` method, you might be wondering why I set the `desired`
    velocity to `null` at the outset. Why not just set `desired` to a vector of 0?
    Remember, the steering force equals the desired velocity minus the current velocity!
    If the vehicle desires to move at 0 velocity, the resulting force would slow the
    vehicle to a stop. By initializing `desired` to `null` and checking that it’s
    non-null before applying the steering force, the vehicle won’t be affected at
    all when it’s comfortably away from the edges of the canvas.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 5.5**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Come up with your own arbitrary scheme for calculating a desired velocity.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '**Flow Fields**'
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another one of Reynolds’s steering behaviors is **flow-field following**. But
    what is a flow field? Think of the canvas as a grid ([Figure 5.13](ch05.xhtml#ch5fig13)).
    In each cell of the grid lives an arrow pointing in a certain direction—you know,
    a vector. As a vehicle moves around the canvas, it asks, “Hey, what arrow is beneath
    me? That’s my desired velocity!”
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg273_Image_390.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.13: A 2D grid full of unit vectors pointing in random directions'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Reynolds’s own flow-field example involves the vehicle looking ahead to its
    future position and following the vector at that spot. For simplicity’s sake,
    however, I’ll instead have the vehicle follow the vector at its current position.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Before I can write the additional code for the `Vehicle` class to follow a flow
    field, I first need a class that describes the flow field. Since a flow field
    is essentially a grid of vectors, a 2D array is a convenient data structure to
    represent it, as I can reference each element with two indices, the cell’s column
    and row in the grid. If you aren’t familiar with 2D arrays, I suggest reviewing
    my video tutorial on “2D Arrays in JavaScript” (*[https://thecodingtrain.com/2d-array](https://thecodingtrain.com/2d-array)*).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg273_Image_391.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
- en: 'How should I fill in the missing values? Let’s say I have a canvas that’s 200
    pixels wide by 200 pixels high. In theory, I could make a flow field that has
    a vector for every single pixel, meaning 40,000 vectors total (200 × 200). This
    isn’t a terribly unreasonable number, but in this context, one vector per pixel
    is overkill. I can easily get by with, say, one vector every 10 pixels (20 × 20
    = 400). My `resolution` variable sets the size of each cell in pixels. Then I
    can calculate the number of columns and rows based on the size of the canvas divided
    by the resolution:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg274_Image_393.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
- en: Now that I’ve set up the data structure for the flow field, it’s time to compute
    the flow field’s vectors. How do I do that? However I want! Perhaps I’d like every
    vector in the flow field pointing to the right ([Figure 5.14](ch05.xhtml#ch5fig14)).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg275_Image_394.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.14: A flow field with all vectors pointing to the right'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: For that, I can just set each vector to `(1, 0)`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg275_Image_395.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: Maybe I’d prefer the vectors to point in random directions ([Figure 5.15](ch05.xhtml#ch5fig15)).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg275_Image_396.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.15: A flow field with vectors pointing in random directions'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'Easy. Just use the `p5.Vector` class’s `random2D()` method to assign each vector:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg275_Image_397.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
- en: What about using 2D Perlin noise ([Figure 5.16](ch05.xhtml#ch5fig16))?
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg276_Image_398.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.16: A flow field calculated with Perlin noise'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Just map each noise value to an angle from 0 to 2π and create a vector from
    that angle:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg276_Image_399.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: Now I’m getting somewhere. Calculating the direction of the vectors by using
    Perlin noise is a great way to simulate a variety of natural effects, such as
    irregular gusts of wind or the meandering path of a river. I’ll note, however,
    that this noise mapping generates a field that prefers flowing left. Since Perlin
    noise has a Gaussian-like distribution, angles near π are more likely to be selected.
    For [Figure 5.16](ch05.xhtml#ch5fig16), I used a range of 0 to 4π to counteract
    this tendency, similarly to the way I applied 4π in [Chapter 4](ch04.xhtml#ch04)
    to represent a range of angles for spinning confetti particles. Ultimately, of
    course, there’s no one correct way to calculate the vectors of a flow field; it’s
    up to you to decide what you’re looking to simulate.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 5.6**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Write the code to calculate a flow field so that the vectors swirl in circles
    around the center of the canvas.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg277_Image_400.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
- en: '[PRE6]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now that I have a 2D array storing the flow-field vectors, I need a way for
    the vehicle to look up its desired velocity. For that, I simply divide the vehicle’s
    x- and y-position by the resolution of the grid. This gives me the indices of
    the desired vector in the 2D array. For example, if the resolution is 10 and the
    vehicle is at (100, 50), I’ll want to look up column 10 and row 5:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Because a vehicle could theoretically wander off the p5.js canvas, employing
    the `constrain()` function helps ensure that I don’t look outside the bounds of
    the flow-field array. Here’s a method called `lookup()`, which I’ll add to the
    `FlowField` class, that receives a vector (the position of the vehicle) and returns
    the corresponding flow-field vector for that position:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg277_Image_401.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
- en: 'Before moving on to the `Vehicle` class, let’s look at the `FlowField` class
    code all together, this time using Perlin noise to compute the vector directions:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg278_Image_402.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: Now let’s assume there’s a `FlowField` object called `flow`. Using that object’s
    `lookup()` method, a vehicle can then retrieve a desired velocity from the flow
    field and use Reynolds’s steering formula to calculate a force.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg279_Image_403.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: Notice that `lookup()` is a method of the `FlowField` class, rather than of
    `Vehicle`. While you certainly could place `lookup()` within the `Vehicle` class
    instead, from my perspective, placing it in `FlowField` aligns best with the OOP
    principle of encapsulation. The lookup task, which retrieves a vector based on
    a position from the flow field, is inherently tied to the data of the `FlowField`
    object.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: You may also notice some familiar elements from [Chapter 4](ch04.xhtml#ch04),
    such as the use of an array of vehicles. Although the vehicles here operate independently,
    this is a great first step toward thinking about the group behaviors that I’ll
    introduce later in this chapter.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 5.7**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Adapt the flow-field example so the vectors change over time. (Hint: Try using
    the third dimension of Perlin noise!)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 5.8**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Can you create a flow field from an image? For example, try having the vectors
    point from dark to light colors (or vice versa).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '**Path Following**'
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next steering behavior formulated by Reynolds that I’d like to explore
    is path following. But let me quickly clarify something first: the behavior here
    is path *following*, not path *finding*. Pathfinding refers to an algorithm that
    solves for the shortest distance between two points, often in a maze. With **path
    following**, a predefined route, or path, already exists, and the vehicle simply
    tries to follow it.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, I will work through the algorithm, including the corresponding
    mathematics and code. However, before doing so, it’s important to cover a key
    concept in vector math that I skipped over in [Chapter 1](ch01.xhtml#ch01): **the
    dot product**. I haven’t needed it yet, but it’s necessary here and likely will
    prove quite useful for you beyond just this example.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '**The Dot Product**'
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Remember all the vector math covered in [Chapter 1](ch01.xhtml#ch01)? Add, subtract,
    multiply, and divide? [Figure 5.17](ch05.xhtml#ch5fig17) has a recap of some of
    these operations.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg280_Image_404.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.17: Adding vectors and multiplying a vector by a scalar'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Notice that multiplication involves multiplying a vector by a scalar value.
    This makes sense; when you want a vector to be twice as large (but facing the
    same direction), multiply it by 2\. When you want it to be half the size, multiply
    it by 0.5\. However, several other *multiplication-like* operations involve a
    pair of vectors that are useful in certain scenarios—the dot product, the cross
    product, and something called the Hadamard product. For now, I’m going to focus
    on the dot product.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume vectors ![Image](../images/pg280_Image_405.jpg) and ![Image](../images/pg280_Image_406.jpg):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg280_Image_407.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: 'The formula for the dot product (represented by the · character) is as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg281_Image_408.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
- en: 'Crucially, the result of the dot product is a scalar value (a single number)
    and not a vector, even though the inputs are two vectors. For example, say you
    have these two vectors:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg281_Image_409.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: 'Their dot product is shown here:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg281_Image_410.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
- en: 'In p5.js, this translates to the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg281_Image_411.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
- en: 'If you look in the guts of the `p5.Vector` source code, you’ll find a pretty
    simple implementation of this `dot()` method:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg281_Image_412.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: 'This formula is simple enough, but why is the dot product necessary, and when
    is it useful in coding? Well, one of the more common uses of the dot product is
    to find the angle between two vectors. In fact, the dot product can also be expressed
    as shown here:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg281_Image_413.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
- en: In other words, the dot product of ![Image](../images/pg281_Image_414.jpg) and
    ![Image](../images/pg281_Image_415.jpg) is equal to the magnitude of ![Image](../images/pg281_Image_414.jpg)
    times the magnitude of ![Image](../images/pg281_Image_415.jpg) times the cosine
    of theta (with theta being the angle between the two vectors ![Image](../images/pg281_Image_414.jpg)
    and ![Image](../images/pg281_Image_415.jpg)).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'The two dot-product formulas can be derived from each other with trigonometry
    (*[https://mathworld.wolfram.com/DotProduct.html](https://mathworld.wolfram.com/DotProduct.html)*),
    but I’m happy not to follow that path and instead just operate on the following
    assumption:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg281_Image_416.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
- en: 'This works since both sides of the equation equal ![Image](../images/pg282_Image_417.jpg).
    What does that assumption do for me? Say I have two vectors ![Image](../images/pg281_Image_414.jpg)
    and ![Image](../images/pg281_Image_415.jpg):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg282_Image_418.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
- en: 'In this scenario, I know the components of the vectors but don’t know the angle
    *θ* between them (see [Figure 5.18](ch05.xhtml#ch5fig18)). Using the dot-product
    formula, I can solve for the cosine of *θ*:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg282_Image_419.jpg)![Image](../images/pg282_Image_422.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.18: The angle between two vectors ![Image](../images/pg282_Image_423.jpg)
    and ![Image](../images/pg282_Image_424.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve for *θ*, I can take the inverse cosine, or arccosine ( `acos` in p5.js
    ), of the right side of the equation:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg282_Image_420.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
- en: 'I’ll do the math now with actual numbers:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg282_Image_421.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
- en: 'Here’s the p5.js version:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Turns out, if you again dig into the guts of the p5.js source code, you’ll find
    a method called `angleBetween` that implements this exact algorithm.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Sure, I could have told you about this `angleBetween()` method to begin with,
    but understanding the dot product in detail will better prepare you for the upcoming
    path-following examples and help you see how the dot product fits into a concept
    called *scalar projection*.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 5.9**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Create a sketch that shows the angle between two vectors.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg283_Image_425.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
- en: 'There are a couple of things to note about dot products:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: If two vectors (![Image](../images/pg281_Image_414.jpg) and ![Image](../images/pg281_Image_415.jpg))
    are orthogonal (that is, perpendicular), their dot product (![Image](../images/pg282_Image_417.jpg))
    is equal to 0.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If two vectors are unit vectors, their dot product is equal to the cosine of
    the angle between them. In other words, ![Image](../images/pg283_Image_427.jpg)
    if ![Image](../images/pg281_Image_414.jpg) and ![Image](../images/pg281_Image_415.jpg)
    are of length 1.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that I’ve covered the fundamentals of the dot product, I can return to Reynolds’s
    path-following algorithm.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple Path Following**'
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 5.19](ch05.xhtml#ch5fig19) depicts all the ingredients of the path-following
    behavior. A lot of components are at play here beyond just a vehicle and target,
    so take some time to review the full diagram. I’ll then slowly unpack the algorithm
    piece by piece.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg284_Image_428.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.19: Path following requires a path, a vehicle, a future position,
    a *normal* to the path, and a target.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: First, what do I mean by a *path*? Many techniques can be used to implement
    a path, but one simple way is to define a path as a series of connected points,
    as in [Figure 5.20](ch05.xhtml#ch5fig20).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg284_Image_429.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.20: A path is a sequence of connected points.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: The simplest version of this path would be a line between two points ([Figure
    5.21](ch05.xhtml#ch5fig21)).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg285_Image_430.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.21: A path with a start, end, and radius'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: I’m also going to consider a path to have a *radius*. If the path is a road,
    the radius is the road’s width. With a smaller radius, vehicles have to follow
    the path more closely; a wider radius allows them to stray a bit more to either
    side of the path.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Now I’ll put this into a class.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg285_Image_431.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
- en: Now, assume that a vehicle is outside the path’s radius, moving with a velocity,
    as in [Figure 5.22](ch05.xhtml#ch5fig22).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg286_Image_433.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.22: Adding a vehicle moving off and away from the path'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to predict (assuming a constant velocity) where that vehicle
    will be in the future:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg286_Image_434.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
- en: Once I have that position, it’s time to determine the distance from that predicted
    position to the path. If it’s very far away, the vehicle has strayed from the
    path and needs to steer back toward it. If the vehicle is on the path, all is
    well and the vehicle can continue on its way.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, I need to calculate the distance between a point (the future position)
    and a line (the path). That distance is defined as the length of the **normal**,
    a vector that extends from the point to the line and is perpendicular to the line
    ([Figure 5.23](ch05.xhtml#ch5fig23)).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg287_Image_435.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.23: The normal is a vector that extends from the future position to
    the path and is perpendicular to the path.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'How do I find the normal? First, I can define a vector (call it ![Image](../images/pg281_Image_414.jpg))
    that extends from the path’s starting point to the vehicle’s future position:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, I can define a vector (call it ![Image](../images/pg281_Image_415.jpg))
    that points from the start of the path to the end:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, with a little trigonometry (the *cah* in *sohcahtoa*), I can calculate
    the distance from the path’s start to the normal point. As shown in [Figure 5.24](ch05.xhtml#ch5fig24),
    it’s ![Image](../images/pg287_Image_436.jpg).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg287_Image_437.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.24: The distance from the start of the path to the normal is ![Image](../images/pg287_Image_438.jpg).'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: If I only knew *θ*, I could find that normal point with the code shown next.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg288_Image_439.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
- en: Luckily, if the dot product has taught me anything, it’s that given two vectors,
    I can calculate the angle between those vectors!
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg288_Image_440.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
- en: 'While this code will work, I can make one more simplification. Looking again,
    you’ll see that the magnitude for vector ![Image](../images/pg281_Image_415.jpg)
    is set to `a.mag() * cos(theta)`, which is the code translation of the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg288_Image_441.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
- en: 'And, recall this:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg288_Image_442.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
- en: 'Now, what if ![Image](../images/pg280_Image_406.jpg) is a unit vector of length
    1? Then you have this:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg288_Image_443.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
- en: 'Or, more simply:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg288_Image_444.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
- en: 'When ![Image](../images/pg281_Image_415.jpg) is a unit vector, ![Image](../images/pg288_Image_445.jpg)
    is the same as the dot product of ![Image](../images/pg281_Image_414.jpg) and
    ![Image](../images/pg281_Image_415.jpg). Turning `b` into a unit vector is as
    simple as calling `normalize()`. I can therefore bypass calculating `theta` with
    `angleBetween()` and simplify the code as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg288_Image_446.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
- en: This process of scaling ![Image](../images/pg281_Image_415.jpg) according to
    the normal point is commonly known as **scalar projection**. We say that ![Image](../images/pg289_Image_447.jpg)
    *is the scalar projection of* ![Image](../images/pg281_Image_414.jpg) *onto* ![Image](../images/pg281_Image_415.jpg),
    as in [Figure 5.25](ch05.xhtml#ch5fig25).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg289_Image_448.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.25: The scalar projection of ![Image](../images/pg282_Image_423.jpg)
    onto ![Image](../images/pg282_Image_424.jpg) is equal to ![Image](../images/pg289_Image_449.jpg).'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Once I have the normal point along the path, the next step is to decide whether
    and how the vehicle should steer toward the path. Reynolds’s algorithm states
    that the vehicle should steer toward the path only if it’s in danger of straying
    beyond the path—that is, if the distance between the normal point and the predicted
    future position is greater than the path’s radius. This is illustrated in [Figure
    5.26](ch05.xhtml#ch5fig26).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg289_Image_450.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.26: A vehicle with a future position on the path (top) and one that’s
    outside the path (bottom)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: I can encode that logic with a simple `if` statement and use my earlier `seek()`
    method to steer the vehicle when necessary.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg290_Image_451.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
- en: But what’s the target that the path follower is seeking? Reynolds’s algorithm
    involves picking a point ahead of the normal on the path. Since I know the vector
    that defines the path (![Image](../images/pg281_Image_415.jpg)), I can implement
    this point ahead by adding a vector that points in ![Image](../images/pg281_Image_415.jpg)’s
    direction to the vector representing the normal point, as in [Figure 5.27](ch05.xhtml#ch5fig27).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg290_Image_452.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.27: The target is 25 pixels (an arbitrary choice) ahead of the normal
    point along the path.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll arbitrarily say the target should be 25 pixels ahead of the normal:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg290_Image_453.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
- en: Putting it all together, here’s the path-following method in the `Vehicle` class.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg291_Image_454.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
- en: 'Notice that instead of using all that dot-product and scalar projection code
    to find the normal point, I call the `getNormalPoint()` function. In cases like
    this, it’s useful to break out the code that performs a specific task (finding
    a normal point) into a function that can be called when required. The function
    takes three vector arguments (see [Figure 5.28](ch05.xhtml#ch5fig28)): the first
    defines a point *p* in Cartesian space (the vehicle’s future position), and the
    second and third define a line segment between two points *a* and *b* (the path).'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg292_Image_455.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.28: The elements of the `getNormalPoint()` function: `position`, `a`,
    and `b`'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg292_Image_456.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
- en: What do I have so far? I have a `Path` class that defines a path as a line between
    two points. I have a `Vehicle` class with a method to follow the path (using steering
    to seek a target along the path). In all, this makes for a decent example, and
    yet it’s pretty darn limiting. What’s missing?
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Take a deep breath. You’re almost there.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '**Path Following with Multiple Segments**'
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What if I want a vehicle to follow a more complex path than just a single straight
    line? Perhaps a curved path that moves in a variety of directions, as in [Figure
    5.29](ch05.xhtml#ch5fig29)?
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg293_Image_457.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.29: A more complex path'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Maybe I’m being a little too ambitious. I *could* investigate algorithms for
    following a curved path, but I’m much less likely to end up needing a cool compress
    on my forehead if I stick with straight line segments, like those in [Figure 5.30](ch05.xhtml#ch5fig30).
    I could always still *draw* the path as a curve, but it’s best to approximate
    it behind the scenes with simplified geometric forms for the necessary calculations.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg293_Image_458.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.30: The same curved path, but approximated as connected line segments'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: If I made path following work with one line segment, how do I make it work with
    a series of connected line segments? The key is in the way I find the target point
    along the path.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: To find the target with just one line segment, I had to compute the normal to
    that line segment. Now that I have a series of line segments, I also have a series
    of normal points to be computed—one for each segment (see [Figure 5.31](ch05.xhtml#ch5fig31)).
    Which one does the vehicle choose? The solution Reynolds proposed is to pick the
    normal point that is (a) closest and (b) on the path.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg294_Image_459.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.31: Finding the closest normal point along a series of connected line
    segments'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: If you have a point and an infinitely long line, you’ll always have a normal
    point that touches the line. But if you have a point and a finite line segment,
    you won’t necessarily find a normal that’s on the line segment. If this happens
    for any of the segments, I can disqualify those normals. Once I’m left with just
    those normals that are on the path (only two in [Figure 5.31](ch05.xhtml#ch5fig31)),
    I pick the one that’s shortest.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: To write the code for this, I’ll expand the `Path` class to have an array of
    points (rather than just the start and end).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg294_Image_460.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
- en: 'Now that the `Path` class has been updated, it’s the vehicle’s turn to learn
    how to accommodate multiple line segments. All it did before was find the normal
    for one line. Using a loop, it can find the normals for all the segments:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg295_Image_462.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
- en: The next step is to test whether the normal point is actually between points
    `a` and `b`. Since I know the path goes from left to right in this example, I
    can test whether the `x` component of `normalPoint` is outside the `x` components
    of `a` and `b`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg296_Image_463.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
- en: If the normal point is not within the line segment, I’ll just pretend the end
    point of that line segment is the normal. (You might also try the beginning point,
    depending on the particulars of your path.) This will ensure that the vehicle
    always stays on the path, even if it strays beyond the bounds of the line segments.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 5.10**'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: A more general-purpose way to test whether the normal point lies on the segment
    is to sum the distances between `normalPoint` and `a` and `b`. If the result is
    greater than the length of the line segment, the normal is outside the segment.
    Can you write this algorithm with p5.js?
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I need to find the closest normal point to the vehicle. To accomplish
    this, I can start with a very high “world record” distance and iterate through
    each normal point to see if it beats (is less than) the record. Each time a normal
    point beats the record, the world record is updated, and the winning point is
    stored in a variable named `target`. At the end of the loop, `target` will hold
    the closest normal point.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg296_Image_464.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
- en: You may have noticed the use of `Infinity` to initialize `worldRecord`. In JavaScript,
    `Infinity` is a special numeric value that represents, well, infinity. It works
    in this case because I need a starting value that will always be higher than any
    plausible distance calculated in the code. The first calculated distance will
    always set a new world record, against which all the others will be compared.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: I also want to highlight the hardcoded value of `25`, which sets the distance
    ahead on the path from the normal for the target. Reynolds indicates that this
    value should be dynamic and calculated based on the vehicle’s distance to the
    path and its speed. Give this a try and see how it improves the accuracy or responsiveness
    of the path-following behavior!
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 5.11**'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Create a path that changes over time. Can the points that define the path have
    their own steering behaviors?
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '**Complex Systems**'
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I said the purpose of this chapter is to breathe life into the things that move
    around p5.js canvases. You’ve come a long way by learning to write the code for
    an autonomous agent and playing with examples of that agent’s individual behaviors.
    But this is no place to stop. Yes, a vehicle is a simulated being that makes decisions
    about how to seek and flow and follow. But what is a life led alone, without the
    love and support of others?
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: And so, as a logical next step, I’ll take the work I’ve done developing behaviors
    for individual autonomous agents and apply it to simulations that involve *many*
    autonomous agents operating in parallel—agents that have an ability to perceive
    not only their physical environment but also the actions of their fellow agents,
    and then act accordingly. In other words, I want to create complex systems with
    p5.js.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: A **complex system** is typically defined as a system that’s more than the sum
    of its parts. While the individual elements of the system may be incredibly simple
    and easily understood, the behavior of the system as a whole can be highly complex,
    intelligent, and difficult to predict.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Think, for example, about a tiny, crawling ant—one single ant. An ant is an
    autonomous agent; it can perceive its environment (using antennae to gather information
    about the direction and strength of chemical signals) and make decisions about
    how to move based on those signals. But can a single ant acting alone build a
    nest, gather food, or defend its queen? An ant is a simple unit that can perceive
    only its immediate environment. A *colony* of ants, however, is a sophisticated,
    complex system, a superorganism of components that work together to accomplish
    difficult, complicated goals.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are three key principles that will guide my work with complex systems:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple units have short-range relationships.** This is what I’ve been building
    all along: vehicles that have a limited perception of their environment.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simple units operate in parallel.** For every cycle through the `draw()`
    loop, each unit will calculate its own steering forces. This will create the appearance
    of all the units working in parallel.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Systems as a whole exhibit emergent phenomena.** Complex behaviors, patterns,
    and intelligence can emerge from the interactions among simple units. This phenomenon
    occurs in nature, such as in ant colonies, migration patterns, earthquakes, and
    snowflakes. The question is whether the same results can be achieved in a p5.js
    sketch.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Beyond these core principles, three additional qualities of complex systems
    will help frame the discussion, as well as provide guidelines for features to
    include in a software simulation. It’s important to acknowledge that this is a
    fuzzy set of characteristics, and not all complex systems have all of them:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '**Nonlinearity:** This aspect of complex systems is often casually referred
    to as the *butterfly effect*, coined by mathematician and meteorologist Edward
    Norton Lorenz, a pioneer in the study of chaos theory. In 1961, Lorenz was running
    a computer weather simulation for the second time and, perhaps to save a little
    time, typed in a starting value of 0.506 instead of 0.506127\. The end result
    was completely different from the first result of the simulation. Stated more
    evocatively, the theory is that a single butterfly flapping its wings on the other
    side of the world could cause a massive weather shift and ruin your weekend at
    the beach. It’s called *nonlinear* because there isn’t a linear relationship between
    a change in initial conditions and a change in outcome. A small change in initial
    conditions can have a massive effect on the outcome. Nonlinear systems are a superset
    of chaotic systems. In [Chapter 7](ch07.xhtml#ch07), you’ll see how even in a
    system of many 0s and 1s, if you change just one bit, the result will be completely
    different.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Competition and cooperation:** One ingredient that often makes a complex
    system tick is the presence of both competition and cooperation among the elements.
    The upcoming flocking system will have three rules: alignment, cohesion, and separation.
    Alignment and cohesion will ask the elements to “cooperate” by trying to stay
    together and move together. Separation, however, will ask the elements to “compete”
    for space. When the time comes, try taking out just the cooperation or just the
    competition, and you’ll see how the system loses its complexity. Competition and
    cooperation are found together in living complex systems, but not in nonliving
    complex systems like the weather.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feedback:** Complex systems often include a loop that feeds the output of
    the system back into the system to influence its behavior in a positive or negative
    direction. Let’s say you decide to take public transportation to work each day
    because it’s the most reliable and cost-effective solution, and you’re put off
    by the traffic congestion and environmental impact of driving. You aren’t alone;
    others turn to public transportation too. The system grows more efficient and
    attractive, serving more people with the same resources, and meanwhile, vehicle
    traffic is reduced. Over time, however, the system may struggle to accommodate
    the rising demand, leading to overcrowding, delays, and increased fares to fund
    infrastructure improvements. As a result, you and others start to switch back
    to driving, thereby increasing traffic congestion once again and reducing public
    transport’s efficiency. As traffic worsens, the funds from increased fares are
    (hopefully) used to improve public transport infrastructure, making it more appealing
    once again. In this way, the cost and efficiency of public transportation are
    both the input of the system (determining whether you choose to use it or not)
    and the output (the degree of traffic congestion and subsequent cost and efficiency).
    Economic models are just one example of a human complex system. Others include
    fads and trends, elections, crowds, and traffic flow.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Complexity will serve as a key theme for much of the remainder of the book.
    In this section, I’ll begin by introducing an additional feature to the `Vehicle`
    class: the ability to perceive neighboring vehicles. This enhancement will pave
    the way for a culminating example of a complex system in which the interplay of
    simple individual behaviors results in an emergent behavior: flocking.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementing Group Behaviors (or: Let’s Not Run Into Each Other)**'
  id: totrans-331
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Managing a group of objects is certainly not a new concept. You’ve seen this
    before—in [Chapter 4](ch04.xhtml#ch04), where I developed the `Emitter` class
    to represent an overall particle system. There, I used an array to store a list
    of individual particles. I’ll start with the same technique here and store `Vehicle`
    objects in an array:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg299_Image_466.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
- en: 'Now, when it comes time to manipulate all the vehicles in `draw()`, I can loop
    through the array and call the necessary methods:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Maybe I want to add a behavior, a force to be applied to all the vehicles.
    This could be seeking the mouse:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: But that’s an *individual* behavior, and I’ve already spent the bulk of this
    chapter worrying about individual behaviors. You’re here because you want to apply
    a *group* behavior. I’ll begin with **separation**, a behavior that commands,
    “Avoid colliding with your neighbors!”
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'That looks good but is not quite right. What’s missing? In the case of `seek()`,
    I said, “Seek `mouseX` and `mouseY`.” In the case of `separate()`, I’m saying,
    “Separate from *everyone else*.” Who is everyone else? It’s the list of all the
    other vehicles:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is the big leap beyond what you saw before with particle systems. Instead
    of each element (particle or vehicle) operating on its own, I’m now saying, “Hey
    you, that vehicle there! When it comes time for you to operate, you need to operate
    with an awareness of everyone else. So I’m going to go ahead and pass you the
    list of everyone else.”
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting together what I’ve done so far, here are the `setup()` and `draw()`
    functions for a sketch that exhibits group behavior:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg301_Image_468.jpg)![Image](../images/pg301_Image_469.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.32: The desired velocity for separation (equivalent to fleeing) is
    a vector that points in the opposite direction of a target.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this is just the beginning. The real work happens inside the `separate()`
    method. Reynolds defines the separation behavior as “steer to avoid crowding.”
    In other words, if a given vehicle is too close to you, steer away from that vehicle.
    Sound familiar? Remember the seek behavior, steering a vehicle toward a target?
    Reverse that force and you have the flee behavior, which is what should be applied
    here to achieve separation (see [Figure 5.32](ch05.xhtml#ch5fig32)).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: But what if more than one vehicle is too close? In that case, I’ll define separation
    as the average of all the vectors pointing away from any close vehicles ([Figure
    5.33](ch05.xhtml#ch5fig33)).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg302_Image_470.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.33: Desired velocity for separation is the average of multiple fleeing
    desired velocities.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'How do I turn that into code? Remember, I’m writing a method called `separate()`
    that receives an array of `Vehicle` objects as an argument:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Inside this method, I’ll loop through all the vehicles and see if any are too
    close:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg302_Image_471.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
- en: Notice that I’m checking not only whether the distance is less than a desired
    separation but also whether `this` is not equal to `other`. This is a key element.
    Remember, all the vehicles are in the array; without this extra check, the vehicle
    will attempt to flee from itself!
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'If the vehicles are too close, I compute a vector that points away from the
    offending vehicle:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg302_Image_472.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
- en: 'This isn’t enough. I have a fleeing vector now, but what I really need is the
    average of the fleeing vectors for all the vehicles that are too close. How do
    I compute an average? Add up all the vectors and divide by the total:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg303_Image_473.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
- en: 'Once I have the average vector (stored in the variable `sum`), that vector
    can be scaled to the maximum speed and become the desired velocity—the vehicle
    *desires* to move in that direction at maximum speed! (In fact, I really don’t
    have to divide by `count` anymore since the magnitude is set manually.) And once
    I have the desired velocity, it’s the same old Reynolds story—steering equals
    desired minus velocity:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg303_Image_474.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
- en: The following example shows the method in its entirety.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg304_Image_475.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
- en: The `separate()` method includes two extra improvements. First, the desired
    separation now depends on the size of the vehicle, as opposed to an arbitrary
    constant. This way, the separation behavior adapts dynamically to the individual
    characteristics of the vehicles. Second, the magnitude of the vector pointing
    away from a neighboring vehicle is set to be inversely proportional to the distance.
    This means that the closer the neighbor, the more the vehicle wants to flee, and
    vice versa.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 5.12**'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `cohere()` method that follows the opposite logic of `separate()`:
    if a vehicle is beyond a certain distance, steer toward that vehicle. This will
    keep the group together. (In a moment, I’ll look at what happens when both cohesion
    and separation play out together in the same simulation.)'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 5.13**'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Add the separation force to path following to create a simulation of Reynolds’s
    group path following.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg305_Image_476.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
- en: '**Combining Behaviors**'
  id: totrans-369
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The most exciting and intriguing group behaviors come from mixing and matching
    multiple steering forces. After all, how could I even begin to simulate emergence
    in a complex system through a sketch that has only one rule?
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'When multiple steering forces are at play, I need a mechanism for managing
    them all. You may be thinking, “This is nothing new. We juggle multiple forces
    all the time.” You would be right. In fact, this technique appeared as early as
    [Chapter 2](ch02.xhtml#ch02):'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, a `Mover` object responds to two forces. This all works nicely because
    of the way the `Mover` class was designed to accumulate the force vectors into
    its acceleration vector. In this chapter, however, the forces stem from the internal
    desires of the movers (now called *vehicles*). And those desires can be weighted
    so that some hold more sway than others. For example, consider a sketch in which
    all vehicles have two desires:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Seek the mouse position.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separate from any vehicles that are too close.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imagine the vehicles represent a school of fish. Although the fish want to avoid
    colliding with one another, their primary concern is seeking out a food source
    (the mouse). Being able to adjust the weights of the two steering forces is crucial
    to achieving this effect.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, I’ll add a method called `applyBehaviors()` to the `Vehicle` class
    to manage all the behaviors:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, a single method takes care of calling the other methods that apply the
    forces—`separate()` and `seek()`. I could start mucking around within those methods
    to adjust the strength of the forces they’re calculating, but it might be easier
    to instead ask those methods to simply calculate and return the forces. Then I
    can adjust the forces’ strength and apply them to the vehicle’s acceleration within
    `applyBehaviors()`:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg306_Image_477.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
- en: 'Here’s how this new approach changes the `seek()` method:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg306_Image_478.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
- en: 'This change is subtle but incredibly important: it allows the strength of these
    forces to be weighted all in one place.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg307_Image_480.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
- en: In this code, I use `mult()` to adjust the forces. By multiplying each force
    vector by a factor, its magnitude is scaled accordingly. These factors (in this
    case, 1.5 for `separate` and 0.5 for `seek`) represent the weight assigned to
    each force. However, the weights don’t have to be constants. Think about how they
    might vary dynamically based on conditions within the environment or properties
    of the vehicle. For example, what if the `seek` weight increases when the vehicle
    detects food nearby (imagine the vehicle as a creature with a `hunger` property)
    or the `separate` weight becomes larger if the vehicle enters a crowded area?
    This flexibility in adjusting the weights allows for more sophisticated and nuanced
    behaviors to emerge.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 5.14**'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: Modify [Example 5.10](ch05.xhtml#ch5ex10) so that the behavior weights change
    over time. For example, what if the weights were calculated according to a sine
    wave or Perlin noise? Or what if some vehicles are more concerned with seeking
    and others are more concerned with separating? Can you introduce other steering
    behaviors as well?
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '**Flocking**'
  id: totrans-388
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Flocking** is a group animal behavior found in many living creatures, such
    as birds, fish, and insects. In 1986, Reynolds created a computer simulation of
    flocking behavior and documented the algorithm in his paper “Flocks, Herds, and
    Schools: A Distributed Behavioral Model.” Re-creating this simulation in p5.js
    will bring together all the concepts in this chapter:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: I will use the steering force formula (steer = desired – velocity) to implement
    the rules of flocking.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These steering forces will be group behaviors and will require each vehicle
    to perceive all the other vehicles.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I will combine and weight multiple forces.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The result will be a complex system—intelligent group behavior will emerge from
    the simple rules of flocking without the presence of a centralized system or leader.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The good news is, I’ve already demonstrated items 1 through 3 in this chapter,
    so this section can just be about putting it all together and seeing the result.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: Before I begin, I should mention that I’m going to change the name of the `Vehicle`
    class (yet again). Reynolds uses the term *boid* (a made-up word that refers to
    a birdlike object) to describe the elements of a flocking system. I’ll do the
    same.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: 'Three rules govern flocking:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '**Separation** (aka avoidance): Steer to avoid colliding with your neighbors.'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alignment** (aka copy): Steer in the same direction as your neighbors.'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cohesion** (aka center): Steer toward the center of your neighbors (stay
    with the group).'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 5.34](ch05.xhtml#ch5fig34) illustrates these rules.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg309_Image_481.jpg)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.34: The three rules of flocking: separation, alignment, and cohesion.
    The example vehicle and desired velocity are bold.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as with [Example 5.10](ch05.xhtml#ch5ex10), in which I combined separation
    and seeking, I want the `Boid` objects to have a single method that manages all
    three behaviors. I’ll call it `flock()`:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg309_Image_482.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
- en: 'Now, it’s just a matter of implementing the three rules. I applied separation
    already; it’s identical to the previous example. Instead, I’ll focus on alignment,
    or steering in the same direction as the neighboring boids. As with all other
    steering behaviors, I have to express this concept as a desire: the boid’s desired
    velocity is the average velocity of its neighbors. The algorithm is therefore
    to calculate the average velocity of all the other boids and set that to the desired
    velocity:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg309_Image_483.jpg)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
- en: This is pretty good but is missing one rather crucial detail. One of the key
    principles behind complex systems like flocking is that the elements (in this
    case, boids) have *short-range* relationships. Thinking about ants again, it’s
    easy to imagine an ant being able to sense its immediate environment, but less
    so an ant having an awareness of what another ant is doing hundreds of feet away.
    Indeed, the ants’ ability to manifest such complex collective behavior from only
    these neighboring relationships is what makes them so exciting in the first place.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: In the `align()` method, I’m currently taking the average velocity of *all*
    the boids, whereas I should really be looking at only the boids within a certain
    distance (see [Figure 5.35](ch05.xhtml#ch5fig35)). That distance threshold can
    be variable, of course. You could design boids that can see only 20 pixels away
    or boids that can see 100 pixels away.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg310_Image_485.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.35: The example vehicle (bold) interacts with only the vehicles within
    its neighborhood (the circle).'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: 'I already applied similar logic when I implemented separation, calculating
    a force based only on other vehicles within a certain distance. Now I want to
    do the same for alignment (and eventually, cohesion):'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg311_Image_486.jpg)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
- en: As with the `separate()` method, I’ve included the condition `this !== other`
    to ensure that a boid doesn’t consider itself when calculating the average velocity.
    It would probably work regardless, but having each boid constantly be influenced
    by its own velocity could lead to a feedback loop that would disrupt the overall
    behavior.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 5.15**'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: Can you rewrite the `align()` method so that boids see only other boids that
    fall within a direct line of sight?
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg311_Image_487.jpg)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
- en: The code for cohesion is quite similar to that for alignment. The only difference
    is that instead of calculating the average *velocity* of the boid’s neighbors,
    I want to calculate the average *position* of the boid’s neighbors (and use that
    as a target to seek).
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg312_Image_488.jpg)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
- en: 'It’s also worth taking the time to write a class called `Flock` that manages
    the whole group of boids. It will be virtually identical to the `ParticleSystem`
    class from [Chapter 4](ch04.xhtml#ch04), with only one tiny change: when I call
    `run()` on each `Boid` object (as I did to each `Particle` object), I’ll pass
    in a reference to the entire array of boids:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg312_Image_489.jpg)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
- en: All that remains is to initialize the flock in `setup()` and run it in `draw()`.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg313_Image_490.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
- en: Just as with the particle systems from [Chapter 4](ch04.xhtml#ch04), you can
    see the elegance of OOP in simplifying the `setup()` and `draw()` functions.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 5.16**'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: Combine flocking with other steering behaviors.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 5.17**'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: 'In his book *The Computational Beauty of Nature* (Bradford Books, 2000), Gary
    Flake describes a fourth rule for flocking, **view**: “Move laterally away from
    any boid that blocks the view.” Have your boids follow this rule.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg314_Image_491.jpg)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
- en: '![Image](../images/pencil.jpg) **Exercise 5.18**'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: Create a flocking simulation in which all the parameters (*separation weight*,
    *cohesion weight*, *alignment weight*, *maximum force*, *maximum speed*) change
    over time. They could be controlled by Perlin noise or by user interaction. (For
    example, you could use the p5.js `createSlider()` function to tie the values to
    slider positions that can be adjusted in real time.)
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 5.19**'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: Visualize the flock in an entirely different way.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '**Algorithmic Efficiency (or: Why Does My Sketch Run So Slowly?)**'
  id: totrans-433
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Group behaviors are wonderful, but it’s with a heavy heart that I must admit
    that they can also be slow. In fact, the bigger the group, the slower the sketch
    can be. I’d love to hide this dark truth from you, because I’d like you to be
    happy and live a fulfilling and meaningful life, free from concerns about the
    efficiency of your code. But I’d also like to be able to sleep at night without
    worrying about your inevitable disappointment when you try to run your flocking
    simulation with too many boids.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, when I talk about p5.js sketches running slowly, it’s because drawing
    to the canvas can be slow—the more you draw, the slower your sketch runs. As you
    may recall from [Chapter 4](ch04.xhtml#ch04), switching to a different renderer
    like WebGL can sometimes alleviate this issue, allowing for faster drawing of
    larger particle systems. With something like a flocking simulation, however, the
    slowness derives from the algorithm. Computer scientists put this problem in terms
    of something called **big** *Ο* **notation**, where the *O* stands for *order*.
    This is shorthand for describing the efficiency of an algorithm: How many computational
    cycles does the algorithm require to complete?'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: Consider a simple search problem. You have a basket containing 100 chocolate
    treats, only one of which is pure dark chocolate. That’s the one you want to eat.
    To find it, you pick the chocolates out of the basket one by one. You might be
    lucky and find it on the first try, but in the worst-case scenario, you have to
    check all 100 before you find the dark chocolate. To find one thing in 100, you
    have to check 100 things (or to find one thing in *N* things, you have to check
    *N* times). The big *O* notation here is *O(N*). This, incidentally, is also the
    big *O* notation that describes a simple particle system. If you have *N* particles,
    you have to run and display those particles *N* times.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s think about a group behavior such as flocking. For every `Boid` object,
    you have to check the velocity and position of every other `Boid` object before
    you can calculate its steering force. Let’s say you have 100 boids. For boid 1,
    you need to check 100 boids; for boid 2, you need to check 100 boids; and so on.
    In all, for 100 boids, you need to perform 10,000 checks (100 × 100 = 10,000).
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be thinking, “No problem. Computers are fast. They can do 10,000
    things pretty easily.” But what if there are 1,000 boids? Then you have this:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: 1,000 × 1,000 = 1,000,000 cycles
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: This is getting rather slow but is still somewhat manageable. What about 10,000
    elements?
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: 10,000 × 10,000 = 100,000,000 cycles
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: Now things are getting really slow. Really, really, really slow.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: Notice a pattern? As the number of elements increases by a factor of 10, the
    number of required cycles increases by a factor of 100\. More broadly, as the
    number of elements increases by a factor of *N*, the cycles increase by a factor
    of *N* × *N*, or *N*². In big *O* notation, this is known as *O*(*N*²).
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps you’re thinking, “No problem. With flocking, I need to consider only
    the boids that are close to the current boid. So even if I have 1,000 boids, I
    can just look at, say, the 5 closest boids to each one, and then I only have 5,000
    cycles.” You pause for a moment and then start thinking, “So for each boid, I
    just need to check all the boids and find the 5 closest ones and I’m good!” See
    the catch-22? Even if you want to look at only the close ones, the only way to
    know what the close ones are would be to check all of them.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: Or is there another way?
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '**Spatial Subdivisions**'
  id: totrans-446
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In his 2000 paper “Interaction with Groups of Autonomous Characters” (*[https://www.red3d.com/cwr/papers/2000/pip.pdf](https://www.red3d.com/cwr/papers/2000/pip.pdf)*),
    Reynolds (surprise, surprise) suggests a technique known as **bin-lattice spatial
    subdivision** (often called *binning* for short) for optimizing flocking algorithms
    and other group behaviors. This technique hinges on dividing the simulation space
    into a grid of smaller cells (or bins).
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate, imagine the canvas is divided into a grid of 10 rows and 10
    columns, for a total of 100 cells (10 × 10 = 100). And let’s say you have 2,000
    boids—a number small enough for you to realistically want, but large enough to
    run too slowly (2,000 × 2,000 = 4,000,000 cycles). At any given moment, each boid
    falls within a cell in the grid, as shown in [Figure 5.36](ch05.xhtml#ch5fig36).
    With 2,000 boids and 100 cells, on average there will be approximately 20 boids
    per cell (2,000 ÷ 100 = 20).
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg316_Image_492.jpg)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.36: A square canvas full of vehicles, subdivided into a grid of square
    cells'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: Now say that in order to apply the flocking rules to a given boid, you need
    to look at only the other boids that are in that boid’s cell. With an average
    of 20 boids per cell, each cell would require 400 cycles (20 × 20 = 400), and
    with 100 cells, that’s 40,000 cycles total (400 × 100 = 40,000). That’s a massive
    savings of over 4,000,000 cycles!
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the bin-lattice spatial subdivision algorithm in p5.js, I’ll need
    multiple arrays. The first array keeps track of all the boids, just as in the
    original flocking example:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The second is a 2D array (repurposing the code from [Example 5.4](ch05.xhtml#ch5ex4))
    representing the cells in the grid:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg316_Image_493.jpg)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
- en: 'Each value in the 2D array is itself an array that will hold references to
    the `Boid` objects currently inside that cell in the grid. If you’re keeping score,
    that’s an array within an array within an array:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg317_Image_495.jpg)'
  id: totrans-457
  prefs: []
  type: TYPE_IMG
- en: 'Every cycle through `draw()`, the array for each grid cell is first cleared.
    Then each boid registers itself in the appropriate cell according to its position.
    This way, the boids’ cell assignments are updated as the boids move:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg317_Image_496.jpg)'
  id: totrans-459
  prefs: []
  type: TYPE_IMG
- en: Finally, when it comes time to have the boids check their neighbors, they can
    look at only those in their particular cell.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg318_Image_497.jpg)'
  id: totrans-461
  prefs: []
  type: TYPE_IMG
- en: I’m covering only the basics of the bin-lattice algorithm here. In practice,
    each boid should also check the boids in the neighboring cells (above, below,
    left, right, and diagonals), as well as the boids in its own cell. (To find out
    how that’s done, see the full code on the book’s website.) Even with that extra
    checking, however, the algorithm is still much more efficient than checking every
    single boid.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: This approach still has flaws, however. For example, what if all the boids congregate
    in the corner and live in the same cell? Doesn’t that take me right back to checking
    all 2,000 against all 2,000? In fact, bin-lattice spatial subdivision is most
    effective when the elements are evenly distributed throughout the canvas. A data
    structure known as a **quadtree**, however, can handle unevenly distributed systems,
    preventing the worst-case scenario of all the boids crowding into a single cell.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: The quadtree expands the spatial subdivision strategy by dynamically adapting
    the grid according to the distribution of the boids. Instead of a fixed grid,
    a quadtree starts with a single large cell that encompasses the entire space.
    If too many boids are found within this cell, it splits into four smaller cells.
    This process can repeat for each new cell that gets too crowded, creating a flexible
    grid that provides finer resolution when and where it’s needed.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg319_Image_498.jpg)'
  id: totrans-465
  prefs: []
  type: TYPE_IMG
- en: 'The quadtree data structure is key to the Barnes-Hut algorithm, which I referenced
    briefly when building an *n*-body simulation in [Chapter 2](ch02.xhtml#ch02).
    This method uses a quadtree to approximate groups of bodies into a single one
    when calculating gravitational forces. This drastically reduces the number of
    calculations needed, allowing simulations with large numbers of bodies to run
    more efficiently. You can learn more about building a quadtree and applying it
    to a flocking system as part of Coding Challenge #98 on the Coding Train website
    (*[https://thecodingtrain.com/quadtree](https://thecodingtrain.com/quadtree)*).'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 5.20**'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: Expand the bin-lattice spatial subdivision flocking sketch from [Example 5.12](ch05.xhtml#ch5ex12)
    to use a quadtree.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '**More Optimization Tricks**'
  id: totrans-469
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While I’m at it, here are a few more tips related to keeping your code in tip-top,
    speedy shape:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: Use the magnitude squared (or sometimes the distance squared).
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculate the sine and cosine lookup tables.
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t make gazillions of unnecessary p5.Vector objects.
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these tips is detailed next.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: '**Use the Magnitude Squared**'
  id: totrans-475
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: What is magnitude squared, and when should you use it? Think back to how the
    magnitude of a vector is calculated.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Magnitude requires the square-root operation. And so it should! After all, if
    you want the magnitude of a vector, you have to break out the Pythagorean theorem
    (we did this in [Chapter 1](ch01.xhtml#ch01)). However, if you could somehow skip
    taking the square root, your code would run faster.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: Say you just want to know the *relative* magnitude of a vector `v`. For example,
    is the magnitude greater than 10?
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Well, that is equivalent to saying the following:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: And how is magnitude squared calculated?
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It’s calculated the same as magnitude, but without the square root. In the case
    of a single vector, using `magSq()` rather than `mag()` will never significantly
    improve the performance of a p5.js sketch. However, if you’re computing the magnitude
    of thousands of vectors each time through `draw()`, working with the magnitude
    squared could help your code run a wee bit faster.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: '**Calculate Sine and Cosine Lookup Tables**'
  id: totrans-486
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Taking the square root isn’t the only mathematical function that’s slow to compute.
    Trig functions like sine, cosine, and tangent are also slow. If you just need
    an individual sine or cosine value here or there in your code, you’re never going
    to run into a problem. But what if you had something like this?
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Sure, this is a totally ridiculous code snippet that you would never write.
    But it illustrates a certain point: if you’re calculating the sine of pi 10,000
    times, why not just calculate it once, save that value, and refer to it whenever
    necessary?'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the principle behind sine and cosine **lookup tables**. Instead of
    calling the sine and cosine functions in your code whenever you need them, you
    can build an array that stores the results of sine and cosine at angles from 0
    to 2π, and then just look up the precalculated values when you need them. For
    example, here are two arrays that store the sine and cosine values for every integer
    angle from 0 to 359 degrees. I’ll use `angleMode(DEGREES)` here to simplify the
    discussion, but the same technique can be applied with radians:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, what if you need to print the sine of pi (or 180 degrees)?
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The key here is that looking up a precalculated value from an array is incredibly
    fast compared to a complex operation like sine or cosine.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg322_Image_499.jpg)'
  id: totrans-495
  prefs: []
  type: TYPE_IMG
- en: The code accompanying [Example 5.14](ch05.xhtml#ch5ex14) enhances the initial
    snippets by incorporating variables for the lookup table’s precision, allowing
    it to store values at increments of less than 1 degree.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: '**Don’t Make Gazillions of Unnecessary p5.Vector Objects**'
  id: totrans-497
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In any sketch, every object you create occupies space in the computer’s memory.
    This might not be a concern with just a few objects, but when sketches generate
    many objects, especially in loops or over time, it can slow performance. Sometimes
    it turns out that not all the objects are really necessary.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: 'I have to admit, I’m perhaps the biggest culprit when it comes to creating
    excessive objects. In the interest of writing clear and understandable examples,
    I often choose to make extra `p5.Vector` objects when I absolutely don’t need
    to. For the most part, this isn’t a problem at all. But sometimes it can be. Take
    a look at this example:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Say the `vehicles` array contains 1,000 vehicles. That means I’m also making
    1,000 new `p5.Vector` objects for the mouse’s position every single time through
    `draw()`. On any standard laptop or desktop computer purchased in recent times,
    this sketch likely won’t register a complaint, run slowly, or have any problems.
    After all, modern computers have tons of RAM, and JavaScript will be able to handle
    making and disposing of 1,000 or so temporary objects without much of a problem.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: 'If, however, the number of objects grows larger (and it easily could), a problem
    will almost certainly arise. As such, you should look for ways to reduce the number
    of `p5.Vector` objects you make. In this case, here’s a simple fix:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now I’ve made just 1 vector instead of 1,000\. Even better, I could turn the
    vector into a global variable and then just assign the `x` and `y` values within
    `draw()` with `set()`:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now I never make a new `p5.Vector` object after the sketch starts; I just use
    the same one over the whole length of the sketch!
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout the book’s examples, you’ll find lots of opportunities to reduce
    the number of temporary objects. (I told you, I’m a major offender.) For example,
    here’s a snippet from this chapter’s `seek()` method:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg323_Image_500.jpg)'
  id: totrans-508
  prefs: []
  type: TYPE_IMG
- en: 'See how I’ve made two vector objects? First, I calculate the desired velocity
    vector, then the steering force. To be more efficient, I could rewrite this to
    create only one vector:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg324_Image_501.jpg)'
  id: totrans-510
  prefs: []
  type: TYPE_IMG
- en: I don’t actually need a second vector called `steer`. I can reuse the `desired`
    vector object and turn it into the steering force by subtracting `velocity`. I
    didn’t do this in my example because it makes the code more confusing to read.
    But in some cases, changes like this may improve efficiency.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 5.21**'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: Eliminate as many temporary `p5.Vector` objects from the flocking example as
    possible. Also use `magSq()` where possible.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/bird.jpg) **The Ecosystem Project**'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: 'Use steering forces to drive the behavior of the creatures in your ecosystem.
    Here are some possibilities:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: Create schools or flocks of creatures.
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a seeking behavior for creatures to search for food (for chasing moving
    prey, consider *pursuit*).
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a flow field for the ecosystem environment. For example, how does your system
    behave if the creatures live in a flowing river?
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a creature with countless steering behaviors (as many as you can reasonably
    add). Think about ways to vary the weights of the behaviors so you can dial them
    up and down, mixing and matching on the fly. How are creatures’ initial weights
    set? What rules drive how the weights change over time?
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex systems can be nested. Can you design a single creature out of a flock
    of boids? And can you then make a flock of those creatures?
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex systems can have memory (and be adaptive). Can the history of your ecosystem
    affect the behavior in its current state? (This could be the driving force behind
    how the creatures adjust their steering force weights.)
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Image](../images/pg325_Image_502.jpg)'
  id: totrans-522
  prefs: []
  type: TYPE_IMG
