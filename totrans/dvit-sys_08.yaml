- en: '8'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 32-BIT X86 ASSEMBLY (IA32)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we explore the Intel Architecture 32-bit (IA32) instruction
    set architecture. Recall from [Chapter 5](ch05.xhtml#ch05) that an instruction
    set architecture, or ISA, defines the set of instructions and binary encodings
    of a machine-level program. To run the examples in this chapter, you will need
    access to a machine with an x86 processor or a compiler that can create 32-bit
    executables. The term “x86” is often used synonymously with the IA32 architecture.
    The x86 architecture, and its 64-bit variant x86-64, are ubiquitous in modern
    computers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Very few modern machines have 32-bit processors; most Intel and AMD systems
    produced since 2007 have 64-bit processors. To check what type of processor you
    have, use the `uname -p` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If typing `uname -p` returns either `i686` or `i386`, your system has a 32-bit
    processor. However, if the `uname -p` command returns `x86_64`, your system has
    a newer 64-bit processor. Note that because x86-64 is an *extension* of the older
    IA32 ISA, virtually all 64-bit systems contain a 32-bit subsystem that allows
    the execution of 32-bit executables.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have a 64-bit Linux system, additional packages are sometimes required
    to allow users to create 32-bit executables, like we will be doing in this chapter.
    For example, on an Ubuntu machine you will need to install 32-bit development
    libraries and additional packages to augment GCC with cross-compiling features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: x86 SYNTAX BRANCHES
  prefs: []
  type: TYPE_NORMAL
- en: x86 architectures typically follow one of two different syntax branches. Unix
    machines commonly use the AT&T syntax, given that Unix was developed at AT&T Bell
    Labs. The corresponding assembler is GNU Assembler (GAS). Since we use GCC for
    most examples in this book, we cover AT&T syntax in this chapter. Windows machines
    commonly use Intel syntax, which is used by Microsoft’s Macro Assembler (MASM).
    The Netwide Assembler (NASM) is an example of a Linux assembler that uses Intel
    syntax. The argument regarding the superiority of one syntax over the other is
    one of the “holy wars” of the discipline. However, there is value in being familiar
    with both syntaxes, as a programmer may encounter either in various circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: '8.1 Diving into Assembly: Basics'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For a first look at assembly, we modify the `adder` function from [Chapter
    6](ch06.xhtml#ch06) to simplify its behavior. Here’s the modified function (`adder2`):'
  prefs: []
  type: TYPE_NORMAL
- en: modified.c
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile this code, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `-m32` flag tells GCC to compile the code to a 32-bit executable. Forgetting
    to include this flag may result in assembly that is wildly different from the
    examples shown in this chapter; by default, GCC compiles to x86-64 assembly, the
    64-bit variant of x86\. However, virtually all 64-bit architectures have a 32-bit
    operating mode for backward compatibility. This chapter covers IA32; other chapters
    cover x86-64 and ARM. Despite its age, IA32 is still extremely useful for understanding
    how programs work and how to optimize code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s view the corresponding assembly of this code by typing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Search for the code snippet associated with `adder2` by typing `/adder2` while
    examining the file `output` using `less`. The section associated with `adder2`
    should look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Assembly output for the adder2 function*'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry if you don’t understand what’s going on just yet. We will cover
    assembly in greater detail in later sections. For now, we will study the structure
    of these individual instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Each line in the preceding example contains an instruction’s address in program
    memory, the bytes corresponding to the instruction, and the plaintext representation
    of the instruction itself. For example, `55` is the machine code representation
    of the instruction `push %ebp`, and the instruction occurs at address 0x804840b
    in program memory.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that a single line of C code often translates to multiple
    instructions in assembly. The operation `a + 2` is represented by the two instructions
    `mov 0x8(%ebp),%eax` and `add $0x2,%eax`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning YOUR ASSEMBLY MAY LOOK DIFFERENT!**'
  prefs: []
  type: TYPE_NORMAL
- en: If you are compiling your code along with us, you may notice that some of your
    assembly examples look different from what is shown in this book. The precise
    assembly instructions that are output by any compiler depend on that compiler’s
    version and the underlying operating system. Most of the assembly examples in
    this book were generated on systems running Ubuntu or Red Hat Enterprise Linux
    (RHEL).
  prefs: []
  type: TYPE_NORMAL
- en: In the examples that follow, we do not use any optimization flags. For example,
    we compile any example file (`example.c`) using the command `gcc` `-m32 -o example
    example.c`. Consequently, there are many seemingly redundant instructions in the
    examples that follow. Remember that the compiler is not “smart”—it simply follows
    a series of rules to translate human-readable code into machine language. During
    this translation process, it is not uncommon for some redundancy to occur. Optimizing
    compilers remove many of these redundancies during optimization, which is covered
    in [Chapter 12](ch12.xhtml#ch12).
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.1 Registers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Recall that a *register* is a word-sized storage unit located directly on the
    CPU. There may be separate registers for data, instructions, and addresses. For
    example, the Intel CPU has a total of eight registers for storing 32-bit data:
    `%eax`, `%ebx`, `%ecx`, `%edx`, `%edi`, `%esi`, `%esp`, and `%ebp`.'
  prefs: []
  type: TYPE_NORMAL
- en: Programs can read from or write to all eight of these registers. The first six
    registers all hold general-purpose data, whereas the last two are typically reserved
    by the compiler to hold address data. While a program may interpret a general-purpose
    register’s contents as integers or as addresses, the register itself makes no
    distinction. The last two registers (`%esp` and `%ebp`) are known as the *stack
    pointer* and the *frame pointer*, respectively. The compiler reserves these registers
    for operations that maintain the layout of the program stack. Typically, `%esp`
    points to the top of the program stack, whereas `%ebp` points to the base of the
    current stack frame. We discuss stack frames and these two registers in greater
    detail in our discussion on functions (see “Functions in Assembly” on [page 326](ch07.xhtml#lev1_55)).
  prefs: []
  type: TYPE_NORMAL
- en: The last register worth mentioning is `%eip` or the *instruction pointer*, sometimes
    called the *program counter* (PC). It points to the next instruction to be executed
    by the CPU. Unlike the eight registers mentioned previously, programs cannot write
    directly to register `%eip`.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.2 Advanced Register Notation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For the first six registers mentioned, the ISA provides a mechanism to access
    the lower 16 bits of each register. The ISA also provides a separate mechanism
    to access the 8-bit components of the lower 16 bits of the first four of these
    registers. [Table 8-1](ch08.xhtml#ch8tab1) lists each of the six registers and
    the ISA mechanisms (if available) to access their component bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-1:** x86 Registers and Mechanisms for Accessing Lower Bytes'
  prefs: []
  type: TYPE_NORMAL
- en: '| **32-bit Register** **(Bits 31–0)** | **Lower 16 Bits** **(Bits 15–0)** |
    **(Bits 15–8)** | **(Bits 7–0)** |'
  prefs: []
  type: TYPE_TB
- en: '| `%eax` | `%ax` | `%ah` | `%al` |'
  prefs: []
  type: TYPE_TB
- en: '| `%ebx` | `%bx` | `%bh` | `%bl` |'
  prefs: []
  type: TYPE_TB
- en: '| `%ecx` | `%cx` | `%ch` | `%cl` |'
  prefs: []
  type: TYPE_TB
- en: '| `%edx` | `%dx` | `%dh` | `%dl` |'
  prefs: []
  type: TYPE_TB
- en: '| `%edi` | `%di` |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `%esi` | `%si` |  |  |'
  prefs: []
  type: TYPE_TB
- en: The lower 16 bits for any of the aforementioned registers can be accessed by
    referencing the last two letters in the register’s name. For example, use `%ax`
    to access the lower 16 bits of `%eax`.
  prefs: []
  type: TYPE_NORMAL
- en: The *higher* and *lower* bytes within the lower 16 bits of the first four listed
    registers can be accessed by taking the last two letters of the register name
    and replacing the last letter with either an `h` (for *higher*) or an `l` (for
    *lower*) depending on which byte is desired. For example, `%al` references the
    lower eight bits of register `%ax`, whereas `%ah` references the higher eight
    bits of register `%ax`. These eight-bit registers are commonly used by the compiler
    for storing single-byte values for certain operations, such as bitwise shifts
    (a 32-bit register cannot be shifted more than 32 places and the number 32 requires
    only a single byte of storage). In general, the compiler will use the smallest
    component register needed to complete an operation.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.3 Instruction Structure
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each instruction consists of an operation code (or *opcode*) that specifies
    what it does, and one or more *operands* that tell the instruction how to do it.
    For example, the instruction `add $0x2,%eax` has the opcode `add` and the operands
    `$0x2` and `%eax`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each operand corresponds to a source or destination location for a specific
    operation. There are multiple types of operands:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Constant* (*literal*) values are preceded by the `$` sign. For example, in
    the instruction `add $0x2,%eax`, `$0x2` is a literal value that corresponds to
    the hexadecimal value 0x2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Register* forms refer to individual registers. The instruction `add` `$0x2,`
    `%eax` specifies register `%eax` as the destination location where the result
    of the `add` operation will be stored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Memory* forms correspond to some value inside main memory (RAM) and are commonly
    used for address lookups. Memory address forms can contain a combination of registers
    and constant values. For example, in the instruction `mov 0x8(%ebp),%eax`, the
    operand `0x8(%ebp)` is an example of a memory form. It loosely translates to “add
    0x8 to the value in register `%ebp`, and then perform a memory lookup.” If this
    sounds like a pointer dereference, that’s because it is!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.1.4 An Example with Operands
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The best way to explain operands in detail is to present a quick example. Suppose
    that memory contains the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Address** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| 0x804 | 0xCA |'
  prefs: []
  type: TYPE_TB
- en: '| 0x808 | 0xFD |'
  prefs: []
  type: TYPE_TB
- en: '| 0x80c | 0x12 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x810 | 0x1E |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s also assume that the following registers contain values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Address** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| `%eax` | 0x804 |'
  prefs: []
  type: TYPE_TB
- en: '| `%ebx` | 0x10 |'
  prefs: []
  type: TYPE_TB
- en: '| `%ecx` | 0x4 |'
  prefs: []
  type: TYPE_TB
- en: '| `%edx` | 0x1 |'
  prefs: []
  type: TYPE_TB
- en: Then the operands in [Table 8-2](ch08.xhtml#ch8tab2) evaluate to the values
    shown. Each row of the table matches an operand with its form (e.g., constant,
    register, memory), how it is translated, and its value. Note that the notation
    M[x] in this context denotes the value at the memory location specified by address
    x.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-2:** Example Operands'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operand** | **Form** | **Translation** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| `%ecx` | Register | `%ecx` | 0x4 |'
  prefs: []
  type: TYPE_TB
- en: '| `(%eax)` | Memory | M[`%eax`] or M[0x804] | 0xCA |'
  prefs: []
  type: TYPE_TB
- en: '| `$0x808` | Constant | 0x808 | 0x808 |'
  prefs: []
  type: TYPE_TB
- en: '| `0x808` | Memory | M[0x808] | 0xFD |'
  prefs: []
  type: TYPE_TB
- en: '| `0x8(%eax)` | Memory | M[`%eax` + 8] or M[0x80c] | 0x12 |'
  prefs: []
  type: TYPE_TB
- en: '| `(%eax, %ecx)` | Memory | M[`%eax` + `%ecx`] or M[0x808] | 0xFD |'
  prefs: []
  type: TYPE_TB
- en: '| `0x4(%eax, %ecx)` | Memory | M[`%eax` + `%ecx` + 4] or M[0x80c] | 0x12 |'
  prefs: []
  type: TYPE_TB
- en: '| `0x800(,%edx,4)` | Memory | M[0x800 + `%edx`×4] or M[0x804] | 0xCA |'
  prefs: []
  type: TYPE_TB
- en: '| `(%eax, %edx, 8)` | Memory | M[`%eax` + `%edx`×8] or M[0x80c] | 0x12 |'
  prefs: []
  type: TYPE_TB
- en: In [Table 8-2](ch08.xhtml#ch8tab2), the notation `%ecx` indicates the value
    stored in register `%ecx`. In contrast, M[`%eax`] indicates that the value inside
    `%eax` should be treated as an address, and to dereference (look up) the value
    at that address. Therefore, the operand `(%eax)` corresponds to M[0x804], which
    corresponds to the value 0xCA.
  prefs: []
  type: TYPE_NORMAL
- en: A few important notes before continuing. While [Table 8-2](ch08.xhtml#ch8tab2)
    shows many valid operand forms, not all forms can be used interchangeably in all
    circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically:'
  prefs: []
  type: TYPE_NORMAL
- en: Constant forms cannot serve as destination operands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory forms cannot serve as *both* the source and destination operand in a
    single instruction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In cases of scaling operations (refer to the last two operands shown in [Table
    8-2](ch08.xhtml#ch8tab2)), the scaling factor must be one of 1, 2, 4, or 8.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Table 8-2](ch08.xhtml#ch8tab2) is provided as a reference; however, understanding
    key operand forms will help improve the reader’s speed in parsing assembly language.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.5 Instruction Suffixes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In several cases in upcoming examples, common and arithmetic instructions have
    a suffix that indicates the *size* (associated with the *type*) of the data being
    operated on at the code level. The compiler automatically translates code to instructions
    with the appropriate suffix. [Table 8-3](ch08.xhtml#ch8tab3) shows the common
    suffixes for x86 instructions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-3:** Example Instruction Suffixes'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Suffix** | **C Type** | **Size (bytes)** |'
  prefs: []
  type: TYPE_TB
- en: '| b | `char` | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| w | `short` | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| l | `int`, `long`, `unsigned` | 4 |'
  prefs: []
  type: TYPE_TB
- en: Note that instructions involved with conditional execution have different suffixes
    based on the evaluated condition. We cover instructions associated with conditional
    instructions in “Conditional Control and Loops” on [page 310](ch07.xhtml#lev1_54).
  prefs: []
  type: TYPE_NORMAL
- en: 8.2 Common Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we discuss several common x86 assembly instructions. [Table
    8-4](ch08.xhtml#ch8tab4) lists the most foundational instructions in x86 assembly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-4:** Most Common Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Translation** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `mov S,D` | S → D | (copies value of S into D) |'
  prefs: []
  type: TYPE_TB
- en: '| `add S,D` | S + D → D | (adds S to D and stores result in D) |'
  prefs: []
  type: TYPE_TB
- en: '| `sub S,D` | D – S → D | (subtracts S *from* D and stores result in D) |'
  prefs: []
  type: TYPE_TB
- en: Therefore, the sequence of instructions
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'translates to:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the value at location `%ebp` + 0x8 in *memory* (or M[`%ebp` + 0x8]) to
    register `%eax`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the value 0x2 to register `%eax`, and store the result in register `%eax`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The three instructions shown in [Table 8-4](ch08.xhtml#ch8tab4) also form the
    building blocks for instructions that maintain the organization of the program
    stack (i.e., the *call stack*). Recall that registers `%ebp` and `%esp` refer
    to the *frame* pointer and *stack* pointer, respectively, and are reserved by
    the compiler for call stack management. Recall from our earlier discussion on
    program memory in “Parts of Program Memory and Scope” on [page 64](ch02.xhtml#lev1_9)
    that the call stack stores local variables and parameters and helps the program
    track its own execution (see [Figure 8-1](ch08.xhtml#ch8fig1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-1: The parts of a program’s address space*'
  prefs: []
  type: TYPE_NORMAL
- en: On IA32 systems, the execution stack grows toward *lower* addresses. Like all
    stack data structures, operations occur at the “top” of the stack. The x86 ISA
    provides two instructions ([Table 8-5](ch08.xhtml#ch8tab5)) to simplify call stack
    management.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-5:** Stack Management Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Translation** |'
  prefs: []
  type: TYPE_TB
- en: '| `push S` | Pushes a copy of S onto the top of the stack. Equivalent to: |'
  prefs: []
  type: TYPE_TB
- en: '|  | `sub $4,%esp` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `mov S,(%esp)` |'
  prefs: []
  type: TYPE_TB
- en: '| `pop D` | Pops the top element off the stack and places it in location D.
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | Equivalent to: |'
  prefs: []
  type: TYPE_TB
- en: '|  | `mov (%esp),D` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `add $4,%esp` |'
  prefs: []
  type: TYPE_TB
- en: Notice that while the three instructions in [Table 8-4](ch08.xhtml#ch8tab4)
    require two operands, the `push` and `pop` instructions in [Table 8-5](ch08.xhtml#ch8tab5)
    require only one operand apiece.
  prefs: []
  type: TYPE_NORMAL
- en: '8.2.1 Putting It All Together: A More Concrete Example'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s take a closer look at the `adder2` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'and its corresponding assembly code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The assembly code consists of a `push` instruction, followed by a couple of
    `mov` instructions, an `add` instruction, a `pop` instruction, and finally a `ret`
    instruction. To understand how the CPU executes this set of instructions, we need
    to revisit the structure of program memory (see “Parts of Program Memory and Scope”
    on [page 64](ch02.xhtml#lev1_9)). Recall that every time a program executes, the
    operating system allocates the new program’s address space (also known as *virtual
    memory*). Virtual memory and the related concept of processes are covered in greater
    detail in [Chapter 13](ch13.xhtml#ch13); for now, it suffices to think of a process
    as the abstraction of a running program and virtual memory as the memory that
    is allocated to a single process. Every process has its own region of memory called
    the *call stack*. Keep in mind that the call stack is located in process/virtual
    memory, unlike registers (which are located on the CPU).
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-2](ch08.xhtml#ch8fig2) depicts a sample state of the call stack and
    registers prior to the execution of the `adder2` function.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-2: Execution stack prior to execution*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the stack grows toward *lower* addresses. Registers `%eax` and `%edx`
    currently contain junk values. The addresses associated with the instructions
    in the code segment of program memory (0x804840b–0x8048415) have been shortened
    to 0x40b–0x415 to improve figure readability. Likewise, the addresses associated
    with the call stack segment of program memory have been shortened to 0x108–0x110
    from 0xffffd108–0xffffd110\. In truth, call stack addresses occur at higher addresses
    in program memory than code segment addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the initial (made up) values of registers `%esp` and
    `%ebp`: they are 0x10c and 0x12a, respectively. The call stack currently has the
    value 0x28 (or 40) at stack address 0x110 (why and how this got here will be covered
    in our discussion on “Functions in Assembly” on [page 326](ch07.xhtml#lev1_55)).
    The upper-left arrow in the following figures visually indicates the currently
    executing instruction. The `%eip` register (or instruction pointer) shows the
    next instruction to execute. Initially, `%eip` contains address 0x40b, which corresponds
    to the first instruction in the `adder2` function.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0387-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first instruction (`push %ebp`) places a copy of the value in `%ebp` (or
    0x12a) on top of the stack. After it executes, the `%eip` register advances to
    the address of the next instruction to execute (or 0x40c). The `push` instruction
    decrements the stack pointer by 4 (“growing” the stack by 4 bytes), resulting
    in a new `%esp` value of 0x108\. Recall that the `push %ebp` instruction is equivalent
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In other words, subtract 4 from the stack pointer and place a copy of the contents
    of `%ebp` in the location pointed to by the dereferenced stack pointer, `(%esp)`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0388-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Recall that the structure of the `mov` instruction is `mov S,D`, where S is
    the source location, and D is the destination. Thus, the next instruction (`mov`
    `%esp,%ebp`) updates the value of `%ebp` to 0x108\. The register `%eip` advances
    to the address of the next instruction to execute, or 0x40e.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0388-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, `mov 0x8(%ebp),%eax` is executed. This is a bit more complicated than
    the last `mov` instruction. Let’s parse it by consulting the operand table from
    the previous section. First, `0x8(%ebp)` translates to M[`%ebp` + 0x8]. Since
    `%ebp` contains the value 0x108, adding 8 to it yields 0x110\. Performing a (stack)
    memory lookup on 0x110 yields the value 0x28 (recall that 0x28 was placed on the
    stack by previous code). So, the value 0x28 is copied into register `%eax`. The
    instruction pointer advances to address 0x411, the next address to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0389-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Afterward, `add $0x2,%eax` is executed. Recall that the `add` instruction has
    the form `add S,D` and places the quantity S + D in the destination D. So, `add`
    `$0x2,%eax` adds the constant value 0x2 to the value stored in `%eax` (or 0x28),
    resulting in 0x2A being stored in register `%eax`. Register `%eip` advances to
    point to the next instruction to be executed, or 0x414.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0389-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next instruction that executes is `pop %ebp`. This instruction “pops” a
    value off the call stack and places it in destination register `%ebp`. Recall
    that this instruction is equivalent to the following sequence of two instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: After this instruction executes, the value at the top of the stack `(%esp)`
    or M[0x108] is copied into register `%ebp`. Thus, `%ebp` now contains the value
    0x12a. The stack pointer *increments* by 4, since the stack grows toward lower
    addresses (and consequently, *shrinks* toward higher ones). The new value of `%esp`
    is 0x10c, and `%eip` now points to the address of the last instruction to execute
    in this code snippet (0x415).
  prefs: []
  type: TYPE_NORMAL
- en: The last instruction executed is `ret`. We will talk more about what happens
    with `ret` in future sections when we discuss function calls, but for now it suffices
    to know that it prepares the call stack for returning from a function. By convention,
    the register `%eax` always contains the return value (if one exists). In this
    case, the function returns the value 0x2A, which corresponds to the decimal value
    42.
  prefs: []
  type: TYPE_NORMAL
- en: Before we continue, note that the final values in registers `%esp` and `%ebp`
    are 0x10c and 0x12a, respectively, which are the *same values as when the function
    started executing*! This is normal and expected behavior with the call stack.
    The purpose of the call stack is to store the temporary variables and data of
    each function as it executes in the context of a program. Once a function completes
    executing, the stack returns to the state it was in prior to the function call.
    As a result, you will commonly see the following two instructions at the beginning
    of a function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'and the following two instructions at the end of every function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 8.3 Arithmetic Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The IA32 ISA implements several instructions that correspond to arithmetic operations
    performed by the ALU. [Table 8-6](ch08.xhtml#ch8tab6) lists several arithmetic
    instructions that one may encounter when reading assembly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-6:** Common Arithmetic Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Translation** |'
  prefs: []
  type: TYPE_TB
- en: '| `add S, D` | S + D → D |'
  prefs: []
  type: TYPE_TB
- en: '| `sub S, D` | D – S → D |'
  prefs: []
  type: TYPE_TB
- en: '| `inc D` | D + 1 → D |'
  prefs: []
  type: TYPE_TB
- en: '| `dec D` | D – 1 → D |'
  prefs: []
  type: TYPE_TB
- en: '| `neg D` | –D → D |'
  prefs: []
  type: TYPE_TB
- en: '| `imul S, D` | S × D → D |'
  prefs: []
  type: TYPE_TB
- en: '| `idiv S` | `%eax` / S: quotient → `%eax`, remainder → `%edx` |'
  prefs: []
  type: TYPE_TB
- en: The `add` and `sub` instructions correspond to addition and subtraction and
    take two operands each. The next three entries show the single-register instructions
    for the increment (`x++`), decrement (`x--`), and negation (`-x`) operations in
    C. The multiplication instruction operates on two operands and places the product
    in the destination. If the product requires more than 32 bits to represent, the
    value will be truncated to 32 bits.
  prefs: []
  type: TYPE_NORMAL
- en: The division instruction works a little differently. Prior to the execution
    of the `idiv` instruction, it is assumed that register `%eax` contains the dividend.
    Calling `idiv` on operand S divides the contents of `%eax` by S and places the
    quotient in register `%eax`, and the remainder in register `%edx`.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.1 Bit Shifting Instructions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Bit shifting instructions enable the compiler to perform bit shifting operations.
    Multiplication and division instructions typically take a long time to execute.
    Bit shifting offers the compiler a shortcut for multiplicands and divisors that
    are powers of 2\. For example, to compute `77 * 4`, most compilers will translate
    this operation to `77 ≪ 2` to avoid the use of an `imul` instruction. Likewise,
    to compute `77 / 4`, a compiler typically translates this operation to `77 ≫ 2`
    to avoid using the `idiv` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that left and right bit shift translate to different instructions
    based on whether the goal is an arithmetic (signed) or logical (unsigned) shift.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-7:** Bit Shift Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Translation** | **Arithmetic or logical?** |'
  prefs: []
  type: TYPE_TB
- en: '| `sal v, D` | D `≪` v → D | arithmetic |'
  prefs: []
  type: TYPE_TB
- en: '| `shl v, D` | D `≪` v → D | logical |'
  prefs: []
  type: TYPE_TB
- en: '| `sar v, D` | D `≫` v → D | arithmetic |'
  prefs: []
  type: TYPE_TB
- en: '| `shr v, D` | D `≫` v → D | logical |'
  prefs: []
  type: TYPE_TB
- en: Each shift instruction take two operands, one which is usually a register (denoted
    by D), and the other which is a shift value (*v*). On 32-bit systems, the shift
    value is encoded as a single byte (since it doesn’t make sense to shift past 31).
    The shift value *v* must either be a constant or stored in register `%cl`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note DIFFERENT VERSIONS OF INSTRUCTIONS HELP DISTINGUISH TYPES AT AN ASSEMBLY
    LEVEL**'
  prefs: []
  type: TYPE_NORMAL
- en: At the assembly level, there is no notion of types. However, recall that shift
    right works differently depending on whether or not the value is signed. At the
    assembly level, the compiler uses separate instructions to distinguish between
    logical and arithmetic shifts!
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.2 Bitwise Instructions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Bitwise instructions enable the compiler to perform bitwise operations on data.
    One way the compiler uses bitwise operations is for certain optimizations. For
    example, a compiler may choose to implement 77 mod 4 with the operation `77 &`
    `3` in lieu of the more expensive `idiv` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 8-8](ch08.xhtml#ch8tab8) lists common bitwise instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-8:** Bitwise Operations'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Translation** |'
  prefs: []
  type: TYPE_TB
- en: '| `and S,D` | S `&` D → D |'
  prefs: []
  type: TYPE_TB
- en: '| `or S,D` | S `&#124;` D → D |'
  prefs: []
  type: TYPE_TB
- en: '| `xor S,D` | S `^` D → D |'
  prefs: []
  type: TYPE_TB
- en: '| `not D` | `~`D → D |'
  prefs: []
  type: TYPE_TB
- en: Remember that bitwise `not` is distinct from negation (`neg`). The `not` instruction
    flips the bits, but does not add 1\. Be careful not to confuse these two instructions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning USE BITWISE OPERATIONS ONLY WHEN NEEDED IN YOUR C CODE!**'
  prefs: []
  type: TYPE_NORMAL
- en: After reading this section, it may be tempting to replace common arithmetic
    operations in your C code with bitwise shifts and other operations. This is *not*
    recommended. Most modern compilers are smart enough to replace simple arithmetic
    operations with bitwise operations when it makes sense, making it unnecessary
    for the programmer to do so. As a general rule, programmers should prioritize
    code readability whenever possible and avoid premature optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.3 The Load Effective Address Instruction
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*What’s lea got to do (got to do) with it?*'
  prefs: []
  type: TYPE_NORMAL
- en: '*What’s lea, but an effective address loading?*'
  prefs: []
  type: TYPE_NORMAL
- en: —With apologies to Tina Turner
  prefs: []
  type: TYPE_NORMAL
- en: We finally come to the *load effective address* or `lea` instruction, which
    is probably the arithmetic instruction that causes students the most consternation.
    It is traditionally used as a fast way to compute the address of a location in
    memory. The `lea` instruction operates on the same operand structure that we’ve
    seen thus far but does *not* include a memory lookup. Regardless of the type of
    data contained in the operand (whether it be a constant value or an address),
    `lea` simply performs arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose that register `%eax` contains the constant value 0x5, register
    `%edx` contains the constant value 0x4, and register `%ecx` contains the value
    0x808 (which happens to be an address). [Table 8-9](ch08.xhtml#ch8tab9) gives
    some example `lea` operations, their translations, and corresponding values.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-9:** Example lea Operations'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Translation** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| `lea 8(%eax), %eax` | 8 + `%eax` → `%eax` | 13 → `%eax` |'
  prefs: []
  type: TYPE_TB
- en: '| `lea (%eax, %edx), %eax` | `%eax` + `%edx` → `%eax` | 9 → `%eax` |'
  prefs: []
  type: TYPE_TB
- en: '| `lea (,%eax,4), %eax` | `%eax` × 4 → `%eax` | 20 → `%eax` |'
  prefs: []
  type: TYPE_TB
- en: '| `lea -0x8(%ecx), %eax` | `%ecx` – `8` → `%eax` | 0x800 → `%eax` |'
  prefs: []
  type: TYPE_TB
- en: '| `lea -0x4(%ecx, %edx, 2), %eax` | `%ecx` + `%edx` × 2 – 4 → `%eax` | 0x80c
    → `%eax` |'
  prefs: []
  type: TYPE_TB
- en: In all cases, the `lea` instruction performs arithmetic on the operand specified
    by the source S and places the result in the destination operand D. The `mov`
    instruction is identical to the `lea` instruction *except* that the `mov` instruction
    is *required* to treat the contents in the source operand as a memory location
    if it is in a memory form. In contrast, `lea` performs the same (sometimes complicated)
    operand arithmetic *without* the memory lookup, enabling the compiler to cleverly
    use `lea` as a substitution for some types of arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: 8.4 Conditional Control and Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section covers assembly instructions for conditionals and loops (see “Conditionals
    and Loops” on [page 30](ch01.xhtml#lev1_3)). Recall that conditional statements
    enable coders to modify program execution based on the result of a conditional
    expression. The compiler translates conditionals into assembly instructions that
    modify the instruction pointer (`%eip`) to point to an address that is not the
    next one in the program sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 8.4.1 Preliminaries
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Conditional Comparison Instructions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Comparison instructions perform an arithmetic operation for the purpose of guiding
    the conditional execution of a program. [Table 8-10](ch08.xhtml#ch8tab10) lists
    the basic instructions associated with conditional control.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-10:** Conditional Control Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Translation** |'
  prefs: []
  type: TYPE_TB
- en: '| `cmp R1, R2` | Compares R2 with R1 (i.e., evaluates R2 – R1) |'
  prefs: []
  type: TYPE_TB
- en: '| `test R1, R2` | Computes R1 & R2 |'
  prefs: []
  type: TYPE_TB
- en: 'The `cmp` instruction compares the values of two registers, R2 and R1\. Specifically,
    it subtracts R1 from R2\. The `test` instruction performs bitwise AND. It is common
    to see an instruction like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the bitwise AND of `%eax` with itself is zero only when `%eax`
    contains zero. In other words, this is a test for a zero value and is equivalent
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the arithmetic instructions covered thus far, `cmp` and `test` do not
    modify the destination register. Instead, both instructions modify a series of
    single-bit values known as *condition code flags*. For example, `cmp` will modify
    condition code flags based on whether the value R2 – R1 results in a positive
    (greater), negative (less), or zero (equal) value. Recall that condition code
    values encode information about an operation in the ALU (see “The ALU” on [page
    261](ch05.xhtml#lev2_100)). The condition code flags are part of the `FLAGS` register
    on x86 systems.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-11:** Common Condition Code Flags'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Flag** | **Translation** |'
  prefs: []
  type: TYPE_TB
- en: '| `ZF` | Is equal to zero (1: yes; 0: no) |'
  prefs: []
  type: TYPE_TB
- en: '| `SF` | Is negative (1: yes; 0: no) |'
  prefs: []
  type: TYPE_TB
- en: '| `OF` | Overflow has occurred (1: yes; 0: no) |'
  prefs: []
  type: TYPE_TB
- en: '| `CF` | Arithmetic carry has occurred (1: yes; 0: no) |'
  prefs: []
  type: TYPE_TB
- en: '[Table 8-11](ch08.xhtml#ch8tab11) depicts the common flags used for condition
    code operations. Revisiting the `cmp R1, R2` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: The `ZF` flag is set to 1 if R1 and R2 are equal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SF` flag is set to 1 if R2 is *less* than `R1` (R2 – R1 results in a negative
    value).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `OF` flag is set to 1 if the operation R2 – R1 results in an integer overflow
    (useful for signed comparisons).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CF` flag is set to 1 if the operation R2 – R1 results in a carry operation
    (useful for unsigned comparisons).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SF` and `OF` flags are used for comparison operations on signed integers,
    whereas the `CF` flag is used for comparisons on unsigned integers. Although an
    in-depth discussion of condition code flags is beyond the scope of this book,
    the setting of these registers by `cmp` and `test` enables the next set of instructions
    we cover (the *jump* instructions) to operate correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Jump Instructions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A jump instruction enables a program’s execution to “jump” to a new position
    in the code. In the assembly programs we have traced through thus far, `%eip`
    always points to the next instruction in program memory. The jump instructions
    enable `%eip` to be set to either a new instruction not yet seen (as in the case
    of an `if` statement) or to a previously executed instruction (as in the case
    of a loop).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-12:** Direct Jump Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `jmp L` | Jump to location specified by L |'
  prefs: []
  type: TYPE_TB
- en: '| `jmp *addr` | Jump to specified address |'
  prefs: []
  type: TYPE_TB
- en: '**Direct jump instructions.**   [Table 8-12](ch08.xhtml#ch8tab12) lists the
    set of direct jump instructions; `L` refers to a *symbolic label*, which serves
    as an identifier in the program’s object file. All labels consist of some letters
    and digits followed by a colon. Labels can be *local* or *global* to an object
    file’s scope. Function labels tend to be *global* and usually consist of the function
    name and a colon. For example, `main:` (or `<main>:`) is used to label a user-defined
    `main` function. In contrast, labels whose scope are *local* are preceded by a
    period. For example, `.L1:` is a local label one may encounter in the context
    of an `if` statement or loop.'
  prefs: []
  type: TYPE_NORMAL
- en: All labels have an associated address. When the CPU executes a `jmp` instruction,
    it modifies `%eip` to reflect the program address specified by label `L`. A programmer
    writing assembly can also specify a particular address to jump to using the `jmp
    *` instruction. Sometimes, local labels are shown as an offset from the start
    of a function. Therefore, an instruction whose address is 28 bytes away from the
    start of `main` may be represented with the label `<main+28>`.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the instruction `jmp 0x8048427 <main+28>` indicates a jump to address
    0x8048427, which has the associated label `<main+28>`, representing that it is
    28 bytes away from the starting address of the `main` function. Executing this
    instruction sets `%eip` to 0x8048427.
  prefs: []
  type: TYPE_NORMAL
- en: '**Conditional jump instructions.**   The behavior of conditional jump instructions
    depends on the condition code registers set by the `cmp` instruction. [Table 8-13](ch08.xhtml#ch8tab13)
    lists the set of common conditional jump instructions. Each instruction starts
    with the letter `j` denoting that it is a jump instruction. The suffix of each
    instruction indicates the *condition* for the jump. The jump instruction suffixes
    also determine whether to interpret numerical comparisons as signed or unsigned.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-13:** Conditional Jump Instructions; Synonyms Shown in Parentheses'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Signed Comparison** | **Unsigned Comparison** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `je` (`jz`) |  | jump if equal (==) or jump if zero |'
  prefs: []
  type: TYPE_TB
- en: '| `jne` (`jnz`) |  | jump if not equal (!=) |'
  prefs: []
  type: TYPE_TB
- en: '| `js` |  | jump if negative |'
  prefs: []
  type: TYPE_TB
- en: '| `jns` |  | jump if non-negative |'
  prefs: []
  type: TYPE_TB
- en: '| `jg` (`jnle`) | `ja` (`jnbe`) | jump if greater (>) |'
  prefs: []
  type: TYPE_TB
- en: '| `jge` (`jnl`) | `jae` (`jnb`) | jump if greater than or equal (>=) |'
  prefs: []
  type: TYPE_TB
- en: '| `jl` (`jnge`) | `jb` (`jnae`) | jump if less (<) |'
  prefs: []
  type: TYPE_TB
- en: '| `jle` (`jng`) | `jbe` (`jna`) | jump if less than or equal (<=) |'
  prefs: []
  type: TYPE_TB
- en: Instead of memorizing these different conditional jump instructions, it is more
    helpful to sound out the instruction suffixes. [Table 8-14](ch08.xhtml#ch8tab14)
    lists the letters commonly found in jump instructions and their word correspondence.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-14:** Jump Instruction Suffixes'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Letter** | **Word** |'
  prefs: []
  type: TYPE_TB
- en: '| `j` | jump |'
  prefs: []
  type: TYPE_TB
- en: '| `n` | not |'
  prefs: []
  type: TYPE_TB
- en: '| `e` | equal |'
  prefs: []
  type: TYPE_TB
- en: '| `s` | signed |'
  prefs: []
  type: TYPE_TB
- en: '| `g` | greater (signed interpretation) |'
  prefs: []
  type: TYPE_TB
- en: '| `l` | less (signed interpretation) |'
  prefs: []
  type: TYPE_TB
- en: '| `a` | above (unsigned interpretation) |'
  prefs: []
  type: TYPE_TB
- en: '| `b` | below (unsigned interpretation) |'
  prefs: []
  type: TYPE_TB
- en: Sounding it out, we can see that `jg` corresponds to *jump greater* and that
    its signed synonym `jnl` stands for *jump not less*. Likewise, the unsigned version
    `ja` stands for *jump above*, while its synonym `jnbe` stands for *jump not below
    or equal*.
  prefs: []
  type: TYPE_NORMAL
- en: If you sound out the instructions, it helps to explain why certain synonyms
    correspond to particular instructions. The other thing to remember is that the
    terms *greater* and *less* instruct the CPU to interpret the numerical comparison
    as a signed value, whereas *above* and *below* indicate that the numerical comparison
    is unsigned.
  prefs: []
  type: TYPE_NORMAL
- en: The goto Statement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In the following subsections, we look at conditionals and loops in assembly
    and reverse engineer them back to C. When translating assembly code of conditionals
    and loops back into C, it is useful to understand the corresponding C language
    `goto` forms. The `goto` statement is a C primitive that forces program execution
    to switch to another line in the code. The assembly instruction associated with
    the `goto` statement is `jmp`.
  prefs: []
  type: TYPE_NORMAL
- en: The `goto` statement consists of the `goto` keyword followed by a *goto label*,
    a type of program label that indicates where execution should continue. So, `goto
    done` means that the program execution should jump to the line marked by label
    `done`. Other examples of program labels in C include the `switch` statement labels
    previously covered in “switch Statements” on [page 122](ch02.xhtml#lev2_36).
  prefs: []
  type: TYPE_NORMAL
- en: The following code listings depict a function `getSmallest` written in regular
    C code (first) and its associated `goto` form in C (second). The `getSmallest`
    function compares the values of two integers (`x` and `y`), and assigns the smaller
    value to variable `smallest`.
  prefs: []
  type: TYPE_NORMAL
- en: Regular C version
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: goto version
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `goto` form of this function may seem counterintuitive, but let’s discuss
    what exactly is going on. The conditional checks to see whether variable `x` is
    less than or equal to `y`.
  prefs: []
  type: TYPE_NORMAL
- en: If `x` is less than or equal to `y`, the program transfers control to the label
    marked by `else_statement`, which contains the single statement `smallest = x`.
    Since the program executes linearly, the program continues on to execute the code
    under the label `done`, which returns the value of `smallest` (`x`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `x` is greater than `y`, then `smallest` is assigned the value `y`. The program
    then executes the statement `goto done`, which transfers control to the `done`
    label, which returns the value of `smallest` (`y`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although `goto` statements were commonly used in the early days of programming,
    their use in modern code is considered bad practice because it reduces the overall
    readability of code. In fact, computer scientist Edsger Dijkstra wrote a famous
    paper lambasting the use of `goto` statements called “Go To Statement Considered
    Harmful.”^([1](ch08.xhtml#fn8_1))
  prefs: []
  type: TYPE_NORMAL
- en: In general, well-designed C programs do not use `goto` statements, and programmers
    are discouraged from using them to avoid writing code that is difficult to read,
    debug, and maintain. However, the C `goto` statement is important to understand,
    as GCC typically changes C code with conditionals into a `goto` form prior to
    translating it to assembly, including code that contains `if` statements and loops.
  prefs: []
  type: TYPE_NORMAL
- en: The following subsections cover the assembly representation of `if` statements
    and loops in greater detail.
  prefs: []
  type: TYPE_NORMAL
- en: 8.4.2 if Statements in Assembly
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s take a look at the `getSmallest` function in assembly. For convenience,
    the function is reproduced here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding assembly code extracted from GDB looks similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is a different view of the assembly code than we have seen before. Here,
    we can see the *address* associated with each instruction, but not the *bytes*.
    Note that this assembly segment has been lightly edited for the sake of simplicity.
    The instructions that are normally part of function creation/termination (i.e.,
    `push %ebp` and `mov %esp,%ebp`) and for allocating space on the stack are removed.
    By convention, GCC places the first and second parameters of a function at locations
    `%ebp+8` and `%ebp+0xc` (or `%ebp+12`), respectively. For the sake of clarity,
    we refer to these parameters as `x` and `y`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s trace through the first few lines of the previous assembly code snippet.
    Note that we will not draw out the stack explicitly in this example. We leave
    this as an exercise for the reader, and encourage you to practice your stack tracing
    skills by drawing it out yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The first `mov` instruction copies the value located at address `%ebp+8` (the
    first parameter, `x`) and places it in register `%eax`. The instruction pointer
    (`%eip`) is set to the address of the next instruction, or 0x08048414.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `cmp` instruction compares the value at location `%ebp+12` (the second parameter,
    `y`) to `x` and sets appropriate condition code flag registers. Register `%eip`
    advances to the address of the next instruction, or 0x08048417.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `jle` instruction on the third line indicates that if `x` is less than or
    equal to `y`, the next instruction that executes is at location `<getSmallest+22>`
    (or `mov 0x8(%ebp),%eax`) and that `%eip` should be set to address 0x8048421\.
    Otherwise, `%eip` is set to the next instruction in sequence, or 0x8048419.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next instructions to execute depend on whether the program follows the
    branch (i.e., executes the jump) on line 3 (`<getSmallest+12>`). Let’s first suppose
    that the branch was *not* followed. In this case, `%eip` is set to 0x8048419 (i.e.,
    `<getSmallest+14>`) and the following sequence of instructions executes:'
  prefs: []
  type: TYPE_NORMAL
- en: The `mov 0xc(%ebp),%eax` instruction at `<getSmallest+14>` copies `y` to register
    `%eax`. Register `%eip` advances to 0x804841f.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `jmp` instruction sets register `%eip` to address 0x8048427.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last instruction to execute is the `ret` instruction, signifying the end
    of the function. In this case, `%eax` contains `y`, and `getSmallest` returns
    `y`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, suppose that the branch was taken at `<getSmallest+12>`. In other words,
    the `jle` instruction sets register `%eip` to 0x8048421 (i.e., `<getSmallest+22>`).
    Then, the next instructions to execute are:'
  prefs: []
  type: TYPE_NORMAL
- en: The `mov 0x8(%ebp),%eax` instruction at address 0x8048421, which copies `x`
    to register `%eax`. Register `%eip` advances to 0x8048427.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last instruction that executes is `ret`, signifying the end of the function.
    In this case, `%eax` contains `x`, and `getSmallest` returns `x`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can then annotate the preceding assembly as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Translating this back to C code yields:'
  prefs: []
  type: TYPE_NORMAL
- en: goto form
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Translated C code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In these code listings, the variable `smallest` corresponds to register `%eax`.
    If `x` is less than or equal to `y`, the code executes the statement `smallest
    = x`, which is associated with the `goto` label `assign_x` in our `goto` form
    of this function. Otherwise, the statement `smallest = y` is executed. The `goto`
    label `done` is used to indicate that the value in `smallest` should be returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the preceding C translation of the assembly code is a bit different
    from the original `getSmallest` function. These differences don’t matter; a close
    inspection of both functions reveals that the two programs are logically equivalent.
    However, the compiler first converts any `if` statementinto an equivalent `goto`
    form, which results in the slightly different, but equivalent, version. The following
    code examples show the standard `if` statement format and its equivalent `goto`
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: C if statement
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Compiler’s equivalent goto form
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Compilers translating code into assembly designate a jump when a condition is
    true. Contrast this behavior with the structure of an `if` statement, where a
    “jump” (to the `else`) occurs when conditions are *not* true. The `goto` form
    captures this difference in logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering the original `goto` translation of the `getSmallest` function,
    we can see that:'
  prefs: []
  type: TYPE_NORMAL
- en: '`x >= y` corresponds to `!*<condition>*`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`smallest = x` is the <else_statement>.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The line `smallest = y` is the <then_statement>.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last line in the function is `return smallest`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rewriting the original version of the function with the preceding annotations
    yields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This version is identical to the original `getSmallest` function. Keep in mind
    that a function written in different ways in the C language can translate to the
    same set of assembly instructions.
  prefs: []
  type: TYPE_NORMAL
- en: The cmov Instructions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The last set of conditional instructions we cover are *conditional move* (`cmov`)
    instructions. The `cmp`, `test`, and `jmp` instructions implement a *conditional
    transfer of control* in a program. In other words, the execution of the program
    branches in many directions. This can be very problematic for optimizing code
    because these branches are very expensive.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, the `cmov` instruction implements a *conditional transfer of data*.
    In other words, both the <then_statement> and <else_statement> of the conditional
    are executed, and the data is placed in the appropriate register based on the
    result of the condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of C’s *ternary expression* often results in the compiler generating
    a `cmov` instruction in place of jumps. For the standard if–then–else statement,
    the ternary expression has the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s use this format to rewrite the `getSmallest` function as a ternary expression.
    Keep in mind that this new version of the function behaves exactly as the original
    `getSmallest` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Although this may not seem like a big change, let’s look at the resulting assembly.
    Recall that the first and second parameters (`x` and `y`) are stored at stack
    addresses `%ebp` + 0x8 and `%ebp` + 0xc, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This assembly code has no jumps. After the comparison of `x` and `y`, `x` moves
    into the return register only if `x` is less than or equal to `y`. Like the jump
    instructions, the suffix of the `cmov` instructions indicates the condition on
    which the conditional move occurs. [Table 8-15](ch08.xhtml#ch8tab15) lists the
    set of conditional move instructions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-15:** The cmov Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Signed** | **Unsigned** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `cmove` (`cmovz`) |  | move if equal (==) |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovne` (`cmovnz`) |  | move if not equal (!=) |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovs` |  | move if negative |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovns` |  | move if non-negative |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovg` (`cmovnle`) | `cmova` (`cmovnbe`) | move if greater (>) |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovge` (`cmovnl`) | `cmovae` (`cmovnb`) | move if greater than or equal
    (>=) |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovl` (`cmovnge`) | `cmovb` (`cmovnae`) | move if less (<) |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovle` (`cmovng`) | `cmovbe` (`cmovna`) | move if less than or equal (<=)
    |'
  prefs: []
  type: TYPE_TB
- en: 'The compiler is very cautious about converting jump instructions into `cmov`
    instructions, especially in cases where side effects and pointer values are involved.
    Here, we show two equivalent ways of writing a function, `incrementX`:'
  prefs: []
  type: TYPE_NORMAL
- en: C code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: C ternary form
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Each function takes a pointer to an integer as input and checks whether it is
    `NULL`. If `x` is not `NULL`, the function increments and returns the dereferenced
    value of `x`. Otherwise, the function returns the value 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is tempting to think that `incrementX2` uses a `cmov` instruction because
    it uses a ternary expression. However, both functions yield the exact same assembly
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Recall that the `cmov` instruction *executes both branches of the conditional*.
    In other words, `x` gets dereferenced no matter what. Consider the case where
    `x` is a null pointer. Recall that dereferencing a null pointer leads to a null
    pointer exception in the code, causing a segmentation fault. To prevent any chance
    of this happening, the compiler takes the safe road and uses jumps.
  prefs: []
  type: TYPE_NORMAL
- en: 8.4.3 Loops in Assembly
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Like `if` statements, loops in assembly are also implemented using jump instructions.
    However, loops enable instructions to be *revisited* based on the result of an
    evaluated condition.
  prefs: []
  type: TYPE_NORMAL
- en: The `sumUp` function shown in the following example sums up all the positive
    integers from 1 to a user-defined integer. This code is intentionally written
    suboptimally to illustrate a `while` loop in C.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling this code with the `-m32` option and disassembling it using GDB yields
    the following assembly code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Again, we will not draw out the stack explicitly in this example. However, we
    encourage readers to draw the stack out themselves.
  prefs: []
  type: TYPE_NORMAL
- en: The First Five Instructions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The first five instructions of this function prepare the stack for function
    execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Recall that stack locations store *temporary variables* in a function. For simplicity
    we will refer to the location marked by `%ebp - 0x8` as `total`, and `%ebp - 0x4`
    as `i`. The input parameter to `sumUp` is located at `%ebp` + 0x8.
  prefs: []
  type: TYPE_NORMAL
- en: The Heart of the Loop
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The next seven instructions in the `sumUp` function represent the heart of
    the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The first instruction is a direct jump to `<sumUp+32>`, which sets the instruction
    pointer (`%eip`) to address 0x804842b.
  prefs: []
  type: TYPE_NORMAL
- en: The next instructions that execute (`<sumUp+32>` and `<sumUp+35>`) copy the
    value of `i` to register `%eax` and compare `i` with the first parameter to the
    `sumUp` function (or `n`). The `cmp` instruction sets the appropriate condition
    codes in preparation for the `jle` instruction at `<sumUp+38>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `jle` instruction at `<sumUp+38>` then executes. If `i` is less than or
    equal to `n`, the branch is taken and program execution jumps to `<sumUp+22>`,
    and `%eip` is set to 0x8048421\. The following instructions then execute in sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mov -0x4(%ebp),%eax` copies `i` to register `%eax`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`add %eax,-0x8(%ebp)` adds `i` to `total` (i.e., `total+=i`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`add $0x1,-0x4(%ebp)` increments `i` by 1 (i.e., `i+=1`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mov -0x4(%ebp),%eax` copies `i` to register `%eax`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmp 0x8(%ebp),%eax` compares `i` to `n`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jle 0x8048421 <sumUp+22>` jumps back to the beginning of this instruction
    sequence if `i` is less than or equal to `n`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the branch is not taken at `<sumUp+38>` (i.e., `i` is *not* less than or
    equal to `n`), `total` is placed in the return register, and the function exits.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code listings show the assembly and then the C `goto` forms of
    the `sumUp` function:'
  prefs: []
  type: TYPE_NORMAL
- en: Assembly
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Translated goto form
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is also equivalent to the following C code without `goto`
    statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: for Loops in Assembly
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The primary loop in the `sumUp` function can also be written as a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This version yields assembly code identical to our `while` loop example. We
    repeat the assembly code here and annotate each line with its English translation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: To understand why the `for` loop version of this code results in identical assembly
    to the `while` loop version of the code, recall that the `for` loop has the following
    representation
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'and is equivalent to the following `while` loop representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Since every `for` loop can be represented by a `while` loop (see “for Loops”
    on [page 35](ch01.xhtml#lev3_5)), the following two C programs are equivalent
    representations for the previous assembly:'
  prefs: []
  type: TYPE_NORMAL
- en: for loop
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: while loop
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 8.5 Functions in Assembly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, we traced through simple functions in assembly. In
    this section, we discuss the interaction between multiple functions in assembly
    in the context of a larger program. We also introduce some new instructions involved
    with function management.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin with a refresher on how the call stack is managed. Recall that `%esp`
    is the *stack pointer* and always points to the top of the stack. The register
    `%ebp` represents the base pointer (also known as the *frame pointer*) and points
    to the base of the current stack frame. The *stack frame* (also known as the *activation
    frame* or the *activation record*) refers to the portion of the stack allocated
    to a single function call. The currently executing function is always at the top
    of the stack, and its stack frame is referred to as the *active frame*. The active
    frame is bounded by the stack pointer (at the top of stack) and the frame pointer
    (at the bottom of the frame). The activation record typically holds local variables
    and parameters for a function.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-3](ch08.xhtml#ch8fig3) shows the stack frames for `main` and a function
    it calls named `fname`. We will refer to the `main` function as the *caller* function
    and `fname` as the *callee* function.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-3: Stack frame management*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 8-3](ch08.xhtml#ch8fig3), the current active frame belongs to the
    callee function (`fname`). The memory between the stack pointer and the frame
    pointer is used for local variables. The stack pointer moves as local values are
    pushed and popped from the stack. In contrast, the frame pointer remains relatively
    constant, pointing to the beginning (the bottom) of the current stack frame. As
    a result, compilers like GCC commonly reference values on the stack relative to
    the frame pointer. In [Figure 8-3](ch08.xhtml#ch8fig3), the active frame is bounded
    below by the base pointer of `fname`, which contains the stack address 0x418\.
    The value stored at this address is the “saved” `%ebp` value (0x42c), which itself
    indicates the bottom of the activation frame for the `main` function. The top
    of the activation frame of `main` is bounded by the *return address*, which indicates
    the program address at which `main` resumes execution as soon as the callee function
    finishes executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning THE RETURN ADDRESS POINTS TO PROGRAM MEMORY, NOT STACK MEMORY**'
  prefs: []
  type: TYPE_NORMAL
- en: Recall that the call stack region (stack memory) of a program is different from
    its code region (code memory). Whereas `%ebp` and `%esp` point to locations in
    the stack memory, `%eip` points to a location in *code* memory. In other words,
    the return address is an address in code memory, not stack memory (see [Figure
    8-4](ch08.xhtml#ch8fig4)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-4: The parts of a program’s address space*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 8-16](ch08.xhtml#ch8tab16) contains several additional instructions
    that the compiler uses for basic function management.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-16:** Common Function Management Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Translation** |'
  prefs: []
  type: TYPE_TB
- en: '| `leave` | Prepares the stack for leaving a function. Equivalent to: |'
  prefs: []
  type: TYPE_TB
- en: '|  | `mov %ebp,%esp` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `pop %ebp` |'
  prefs: []
  type: TYPE_TB
- en: '| `call addr <fname>` | Switches active frame to callee function. Equivalent
    to: |'
  prefs: []
  type: TYPE_TB
- en: '|  | `push %eip` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `mov addr,%eip` |'
  prefs: []
  type: TYPE_TB
- en: '| `ret` | Restores active frame to caller function. Equivalent to: |'
  prefs: []
  type: TYPE_TB
- en: '|  | `pop %eip` |'
  prefs: []
  type: TYPE_TB
- en: For example, the `leave` instruction is a shorthand that the compiler uses to
    restore the stack and frame pointers as it prepares to leave a function. When
    the callee function finishes execution, `leave` ensures that the frame pointer
    is *restored* to its previous value.
  prefs: []
  type: TYPE_NORMAL
- en: The `call` and `ret` instructions play a prominent role in the process where
    one function calls another. Both instructions modify the instruction pointer (register
    `%eip`). When the caller function executes the `call` instruction, the current
    value of `%eip` is saved on the stack to represent the return address, or the
    program address at which the caller resumes executing once the callee function
    finishes. The `call` instruction also replaces the value of `%eip` with the address
    of the callee function.
  prefs: []
  type: TYPE_NORMAL
- en: The `ret` instruction restores the value of `%eip` to the value saved on the
    stack, ensuring that the program resumes execution at the program address specified
    in the caller function. Any value returned by the callee is stored in `%eax`.
    The `ret` instruction is usually the last instruction that executes in any function.
  prefs: []
  type: TYPE_NORMAL
- en: 8.5.1 Tracing Through an Example
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using our knowledge of function management, let’s trace through the code example
    first introduced at the beginning of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We compile the code with the `-m32` flag and use `objdump -d` to view the underlying
    assembly. The latter command outputs a pretty big file that contains a lot of
    information that we don’t need. Use `less` and the search functionality to extract
    the `adder`, `assign`, and `main` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Each function begins with a symbolic label that corresponds to its declared
    name in the program. For example, `<main>:` is the symbolic label for the `main`
    function. The address of a function label is also the address of the first instruction
    in that function. To save space in the figures that follow, we truncate addresses
    to the lower 12 bits. So, program address 0x804842d is shown as 0x42d.
  prefs: []
  type: TYPE_NORMAL
- en: 8.5.2 Tracing Through main
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 8-5](ch08.xhtml#ch8fig5) shows the execution stack immediately prior
    to the execution of `main`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-5: The initial state of the CPU registers and call stack prior to
    executing the main function*'
  prefs: []
  type: TYPE_NORMAL
- en: Recall that the stack grows toward lower addresses. In this example, `%ebp`
    is address 0x140, and `%esp` is address 0x130 (both of these values are made up
    for this example). Registers `%eax` and `%edx` initially contain junk values.
    The upper-left arrow indicates the currently executing instruction. Initially,
    `%eip` contains address 0x42d, which is the program memory address of the first
    line in the `main` function. Let’s trace through the program’s execution together.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0412-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first instruction pushes the value of `ebp` onto the stack, saving address
    0x140\. Since the stack grows toward lower addresses, the stack pointer `%esp`
    updates to 0x12c, which is four bytes less than 0x130\. Register `%eip` advances
    to the next instruction in sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0413-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The next instruction (`mov %esp,%ebp`) updates the value of `%ebp` to be the
    same as `%esp`. The frame pointer (`%ebp`) now points to the start of the stack
    frame for the `main` function. `%eip` advances to the next instruction in sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0413-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `sub` instruction subtracts 0x14 from the address of our stack pointer,
    “growing” the stack by 20 bytes. Register `%eip` advances to the next instruction,
    which is the first `call` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0414-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `call <assign>` instruction pushes the value inside register `%eip` (which
    denotes the address of the *next* instruction to execute) onto the stack. Since
    the next instruction after `call <assign>` has the address 0x43b, that value is
    pushed onto the stack as the return address. Recall that the return address indicates
    the program address where execution should resume when program execution returns
    to `main`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `call` instruction moves the address of the `assign` function (0x40d)
    into register `%eip`, signifying that program execution should continue into the
    callee function `assign` and not the next instruction in `main`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0415-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first two instructions that execute in the `assign` function are the usual
    book-keeping that every function performs. The first instruction pushes the value
    stored in `%ebp` (memory address 0x12c) onto the stack. Recall that this address
    points to the beginning of the stack frame for `main`. `%eip` advances to the
    second instruction in `assign`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0416-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The next instruction (`mov %esp,%ebp`) updates `%ebp` to point to the top of
    the stack, marking the beginning of the stack frame for `assign`. The instruction
    pointer (`%eip`) advances to the next instruction in the `assign` function.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0416-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `sub` instruction at address 0x410 grows the stack by 16 bytes, creating
    extra space on the stack frame to store local values and updating `%esp`. The
    instruction pointer again advances to the next instruction in the `assign` function.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0417-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `mov` instruction at address 0x413 moves the value `$0x28` (or 40) onto
    the stack at address `-0x4(%ebp)`, which is four bytes above the frame pointer.
    Recall that the frame pointer is commonly used to reference locations on the stack.
    `%eip` advances to the next instruction in the `assign` function.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0418-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `mov` instruction at address 0x41a places the value `$0x28` into register
    `%eax`, which holds the return value of the function. `%eip` advances to the `leave`
    instruction in the `assign` function.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0419-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point, the `assign` function has almost completed execution. The next
    instruction that executes is the `leave` instruction, which prepares the stack
    for returning from the function call. Recall that `leave` is analogous to the
    following pair of instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In other words, the CPU overwrites the stack pointer with the frame pointer.
    In our example, the stack pointer is initially updated from 0x100 to 0x110\. Next,
    the CPU executes `pop %ebp`, which takes the value located at 0x110 (in our example,
    the address 0x12c) and places it in `%ebp`. Recall that 0x12c is the start of
    the stack frame for `main`. `%esp` becomes 0x114, and `%eip` points to the `ret`
    instruction in the `assign` function.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0420-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last instruction in `assign` is a `ret` instruction. When `ret` executes,
    the return address is popped off the stack into register `%eip`. In our example,
    `%eip` now advances to the call to the `adder` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some important things to notice at this juncture:'
  prefs: []
  type: TYPE_NORMAL
- en: The stack pointer and frame pointer have been restored to their values prior
    to the call to `assign`, reflecting that the stack frame for `main` is again the
    active frame.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The old values on the stack from the prior active stack frame are *not* removed.
    They still exist on the call stack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](../images/f0421-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The call to `adder` *overwrites* the old return address on the stack with a
    new return address (0x440). This return address points to the next instruction
    to be executed after `adder` returns, or `mov %eax,0xc(%ebp)`. `%eip` reflects
    the first instruction to execute in `adder`, which is at address 0x41f.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0422-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first instruction in the `adder` function saves the caller’s frame pointer
    (`%ebp` of `main`) on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0422-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The next instruction updates `%ebp` with the current value of `%esp`, or address
    0x110\. Together, these last two instructions establish the beginning of the stack
    frame for `adder`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0423-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `sub` instruction at address 0x422 “grows” the stack by 16 bytes. Notice
    again that growing the stack does not affect any previously created values on
    the stack. Again, old values will litter the stack until they are overwritten.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0424-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Pay close attention to the next instruction that executes: `mov $-0x4(%ebp),`
    `%eax`. This moves an *old* value that is on the stack into register `%eax`! This
    is a direct result of the fact that the programmer forgot to initialize `a` in
    the function `adder`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0425-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `add` instruction at address 0x428 adds 2 to register `%eax`. Recall that
    IA32 passes the return value through register `%eax`. Together, the last two instructions
    are equivalent to the following code in `adder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '![image](../images/f0426-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After `leave` executes, the frame pointer again points to the beginning of the
    stack frame for `main`, or address 0x12c. The stack pointer now stores the address
    0x114.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0427-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The execution of `ret` pops the return address off the stack, restoring the
    instruction pointer back to 0x440, or the address of the next instruction to execute
    in `main`. The address of `%esp` is now 0x118.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0428-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `mov %eax,0xc(%esp)` instruction places the value in `%eax` in a location
    12 bytes (three spaces) below `%esp`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0428-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Skipping ahead a little, the `mov` instructions at addresses 0x444 and 0x448
    set `%eax` to the value saved at location `%esp+12` (or 0x2A) and places 0x2A
    one spot below the top of the stack (address `%esp + 4`, or 0x11c).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0429-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The next instruction (`mov $0x80484f4, (%esp)`) copies a constant value that
    is a memory address to the top of the stack. This particular memory address, 0x80484f4,
    contains the string `"x is %d\n"`. The instruction pointer advances to the call
    to the `printf` function (which is denoted with the label `<printf@plt>`).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0430-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For the sake of brevity, we will not trace the `printf` function, which is
    part of `stdio.h`. However, we know from the manual page (`man -s3 printf`) that
    `printf` has the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In other words, the first argument is a pointer to a string specifying the
    format, and the second argument onward specify the values that are used in that
    format. The instructions specified by addresses 0x444–0x45c correspond to the
    following line in the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `printf` function is called:'
  prefs: []
  type: TYPE_NORMAL
- en: A return address specifying the instruction that executes after the call to
    `printf` is pushed onto the stack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value of `%ebp` is pushed onto the stack, and `%ebp` is updated to point
    to the top of the stack, indicating the beginning of the stack frame for `printf`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At some point, `printf` references its arguments, which are the string `"x is
    %d\n"` and the value 0x2A. Recall that the return address is located directly
    below `%ebp` at location `%ebp` + 4\. The first argument is thus located at `%ebp`
    + 8 (i.e., directly *below* the return address), and the second argument is located
    at `%ebp` + 12.
  prefs: []
  type: TYPE_NORMAL
- en: For any function with *n* arguments, GCC places the first argument at location
    `%ebp` + 8, the second at `%ebp` + 12, and the *n*th argument at location (`%ebp`
    + 8) + (4 × (*n –* 1)).
  prefs: []
  type: TYPE_NORMAL
- en: After the call to `printf`, the value 0x2A is output to the user in integer
    format. Thus, the value 42 is printed to the screen!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0431-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After the call to `printf`, the last few instructions clean up the stack and
    prepare a clean exit from the `main` function. First, the value 0x0 is placed
    in register `%eax`, signifying that the value 0 is returned from `main`. Recall
    that a program returns 0 to indicate correct termination.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0432-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After `leave` and `ret` are executed, the stack and frame pointers revert to
    their original values prior to the execution of `main`. With 0x0 in the return
    register `%eax`, the program returns 0.
  prefs: []
  type: TYPE_NORMAL
- en: If you have carefully read through this section, you should understand why our
    program prints out the value 42\. In essence, the program inadvertently uses old
    values on the stack to cause it to behave in a way that we didn’t expect. While
    this example was pretty harmless, we discuss in future sections how hackers have
    misused function calls to make programs misbehave in truly malicious ways.
  prefs: []
  type: TYPE_NORMAL
- en: 8.6 Recursion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Recursive functions are a special class of functions that call themselves (also
    known as *self-referential* functions) to compute a value. Like their nonrecursive
    counterparts, recursive functions create new stack frames for each function call.
    Unlike standard functions, recursive functions contain function calls to themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s revisit the problem of summing up the set of positive integers from 1
    to *n*. In previous sections, we discussed the `sumUp` function to achieve this
    task. The following code shows a related function called `sumDown`, which adds
    the numbers in reverse (*n* to 1), and its recursive equivalent `sumr`:'
  prefs: []
  type: TYPE_NORMAL
- en: Iterative
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Recursive
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The base case in the recursive function `sumr` accounts for any values of *n*
    that are less than one, and the recursive step adds the current value of *n* to
    the result of the function call to `sumr` with the value *n –* 1\. Compiling `sumr`
    with the `-m32` flag and disassembling it with GDB yields the following assembly
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Each line in the preceding assembly code is annotated with its English translation.
    Here, we show the corresponding `goto` form (first) and C program without `goto`
    statements (second):'
  prefs: []
  type: TYPE_NORMAL
- en: C goto form
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: C version without goto
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Although this translation may not initially appear to be identical to the original
    `sumr` function, close inspection reveals that the two functions are indeed equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: '8.6.1 Animation: Observing How the Call Stack Changes'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As an exercise, we encourage you to draw out the stack and see how the values
    change. We have provided an animation online that depicts how the stack is updated
    when we run this function with the value 3.^([2](ch08.xhtml#fn8_2))
  prefs: []
  type: TYPE_NORMAL
- en: 8.7 Arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Recall that arrays (see “Introduction to Arrays” on [page 44](ch01.xhtml#lev2_9))
    are ordered collections of data elements of the same type that are contiguously
    stored in memory. Statically allocated single-dimension arrays (see the section
    “Single-Dimensional Arrays” on [page 81](ch02.xhtml#lev2_22)) have the form <type>
    `arr[N]`, where <type> is the data type, `arr` is the identifier associated with
    the array, and `N` is the number of data elements. Declaring an array statically
    as <type> `arr[N]` or dynamically as `arr = malloc(N*sizeof(` <type>`))` allocates
    `N` × `sizeof(` <type>`)` total bytes of memory, with `arr` pointing to it.
  prefs: []
  type: TYPE_NORMAL
- en: To access the element at index `i` in array `arr`, use the syntax `arr[i]`.
    Compilers commonly convert array references into pointer arithmetic (see “Pointer
    Variables” on [page 67](ch02.xhtml#lev1_10)) prior to translating to assembly.
    So, `arr+i` is equivalent to `&arr[i]`, and `*(arr+i)` is equivalent to `arr[i]`.
    Since each data element in `arr` is of type <type>, `arr+i` implies that element
    `i` is stored at address `arr` + `sizeof(` <type>`)` × `i`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 8-17](ch08.xhtml#ch8tab17) outlines some common array operations and
    their corresponding assembly instructions. Assume that register `%edx` stores
    the address of `arr`, register `%ecx` stores the value `i`, and register `%eax`
    represents some variable `x`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-17:** Common Array Operations and Their Corresponding Assembly Representations'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **Type** | **Assembly Representation** |'
  prefs: []
  type: TYPE_TB
- en: '| `x = arr` | `int *` | `movl %edx,%eax` |'
  prefs: []
  type: TYPE_TB
- en: '| `x = arr[0]` | `int` | `movl (%edx),%eax` |'
  prefs: []
  type: TYPE_TB
- en: '| `x = arr[i]` | `int` | `movl (%edx,%ecx,4),%eax` |'
  prefs: []
  type: TYPE_TB
- en: '| `x = &arr[3]` | `int *` | `leal 0xc(%edx),%eax` |'
  prefs: []
  type: TYPE_TB
- en: '| `x = arr+3` | `int *` | `leal 0xc(%edx),%eax` |'
  prefs: []
  type: TYPE_TB
- en: '| `x = *(arr+3)` | `int` | `movl 0xc(%edx),%eax` |'
  prefs: []
  type: TYPE_TB
- en: Pay close attention to the *type* of each expression in [Table 8-17](ch08.xhtml#ch8tab17).
    In general, the compiler uses `movl` instructions to dereference pointers and
    the `leal` instruction to compute addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that to access element `arr[3]` (or `*(arr+3)` using pointer arithmetic),
    the compiler performs a memory lookup on address `arr+3*4` instead of `arr+3`.
    To understand why this is necessary, recall that any element at index `i` in an
    array is stored at address `arr + sizeof(` <type>`) * i`. The compiler must therefore
    multiply the index by the size of the data type to compute the correct offset.
    Recall also that memory is byte-addressable; offsetting by the correct number
    of bytes is the same as computing an address.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, consider a sample array (`array`) with five integer elements
    ([Figure 8-6](ch08.xhtml#ch8fig6)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-6: The layout of a five-integer array in memory. Each *x*[*i*]-labeled
    box represents one byte, each `int` is four bytes.*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that since `array` is an array of integers, each element takes up exactly
    four bytes. Thus, an integer array with five elements consumes 20 bytes of contiguous
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: To compute the address of element 3, the compiler multiplies the index 3 by
    the data size of the integer type (4) to yield an offset of 12\. Sure enough,
    element 3 in [Figure 8-6](ch08.xhtml#ch8fig6) is located at byte offset *x*[12].
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at a simple C function called `sumArray` that sums up all
    the elements in an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sumArray` function takes the address of an array and the array’s associated
    length and sums up all the elements in the array. Now take a look at the corresponding
    assembly for the `sumArray` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: When tracing this assembly code, consider whether the data being accessed represents
    an address or a value. For example, the instruction at `<sumArray+13>` results
    in `%ebp-4` containing a variable of type `int`, which is initially set to 0\.
    In contrast, the argument stored at `%ebp+8` is the first argument to the function
    (`array`) which is of type `int *` and corresponds to the base address of the
    array. A different variable (which we call `total`) is stored at location `%ebp-8`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at the five instructions between locations `<sumArray+22>`
    and `<sumArray+39>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Recall that the compiler commonly uses `lea` to perform simple arithmetic on
    operands. The operand `0x0(,%eax,4)` translates to `%eax*4 + 0x0`. Since `%eax`
    holds the value `i`, this operation copies the value `i*4` to `%edx`. At this
    point, `%edx` contains the number of bytes that must be added to calculate the
    correct offset of `array[i]`.
  prefs: []
  type: TYPE_NORMAL
- en: The next instruction (`mov 0x8(%ebp),%eax`) copies the first argument (the base
    address of `array`) into `%eax`. Adding `%edx` to `%eax` in the next instruction
    causes `%eax` to contain `array+i*4`. Recall that the element at index `i` in
    `array` is stored at address `array + sizeof(` <type>`) * i`. Therefore, `%eax`
    now contains the assembly-level computation of the address `&array[i]`.
  prefs: []
  type: TYPE_NORMAL
- en: The instruction at `<sumArray+37>` *dereferences* the value located at `%eax`,
    placing the value `array[i]` into `%eax`. Lastly, `%eax` is added to the value
    in `%ebp-8`, or `total`. Thus, the five instructions between locations `<sumArray+22>`
    and `<sumArray+39>` correspond to the line `total += array[i]` in the `sumArray`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 8.8 Matrices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A matrix is a 2D array. A matrix in the C language can be statically allocated
    as a 2D array (`M[n][m]`), dynamically allocated with a single call to `malloc`,
    or dynamically allocated as an array of arrays. Let’s consider the array of arrays
    implementation. The first array contains `n` elements (`M[n]`), and each element
    `M[i]` in our matrix contains an array of `m` elements. The following code snippets
    each declare matrices of size 4 × 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In the case of the dynamically allocated matrix, the main array contains a contiguous
    array of `int` pointers. Each integer pointer points to a different array in memory.
    [Figure 8-7](ch08.xhtml#ch8fig7) illustrates how we would normally visualize each
    of these matrices.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-7: Illustration of a statically allocated (`M1`) and dynamically
    allocated (`M2`) 3 × 4 matrix*'
  prefs: []
  type: TYPE_NORMAL
- en: For both of these matrix declarations, element (*i*, *j*) can be accessed using
    the double-indexing syntax `M[i][j]`, where `M` is either `M1` or `M2`. However,
    these matrices are organized differently in memory. Even though both store the
    elements in their primary array contiguously in memory, our statically allocated
    matrix also stores all the rows contiguously in memory, as shown in [Figure 8-8](ch08.xhtml#ch8fig8).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-8: Matrix `M1`’s memory layout in row-major order*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This contiguous ordering is not guaranteed for `M2`. Recall (from “Two-Dimensional
    Array Memory Layout” on [page 86](ch02.xhtml#lev3_13)) that to contiguously allocate
    an *n* × *m* matrix on the heap, we should use a single call to `malloc` that
    allocates *n* × *m* elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Recall that with the declaration of `M3`, element (*i*, *j*) *cannot* be accessed
    using the `M[i][j]` notation. Instead, we must index the element using the format
    `M3[i*cols + j]`.
  prefs: []
  type: TYPE_NORMAL
- en: 8.8.1 Contiguous Two-Dimensional Arrays
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Consider a function `sumMat` that takes a pointer to a contiguously allocated
    (either statically allocated or memory-efficiently dynamically allocated) matrix
    as its first parameter, along with the numbers of rows and columns, and returns
    the sum of all the elements inside the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: We use scaled indexing in the code snippet that follows because it applies to
    both statically and dynamically allocated contiguous matrices. Recall that the
    syntax `m[i][j]` does not work with the memory-efficient contiguous dynamic allocation
    previously discussed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the corresponding assembly. Each line is annotated with its English
    translation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The local variables `i`, `j`, and `total` are loaded at addresses `%ebp-4`,
    `%ebp-8`, and `%ebp-12` on the stack, respectively. The input parameters `m`,
    `row`, and `cols` are located at locations `%ebp+8`, `%ebp+12`, and `%ebp+16`,
    respectively. Using this knowledge, let’s zoom in on the component that just deals
    with the access of element (*i*, *j*) in our matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The first set of instructions computes `i * cols` and places the result in register
    `%edx`. Recall that for a matrix named `matrix`, `matrix + (i * cols)` is equivalent
    to `&matrix[i]`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The next set of instructions computes `(i * cols + j) * 4`. The compiler multiplies
    the index `(i * cols) + j` by four because each element in the matrix is a four-byte
    integer, and this multiplication enables the compiler to calculate the correct
    offset.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last set of instructions adds the calculated offset to the matrix pointer
    and dereferences it to yield the value of element (*i*, *j*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The first instruction loads the address of matrix `m` into register `%eax`.
    The `add` instruction adds the offset `(i*cols + j)*4` to the address of `m` to
    correctly calculate the address of element (*i*, *j*) and then places this address
    in register `%eax`. The third instruction dereferences `%eax` and places the resulting
    value in register `%eax`. The last instruction adds the value in `%eax` to the
    accumulator `total`, which is located at stack address `%ebp-0xc`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider how element (1,2) is accessed in [Figure 8-9](ch08.xhtml#ch8fig9).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-9: Matrix `M1`’s memory layout in row-major order*'
  prefs: []
  type: TYPE_NORMAL
- en: Element (1,2) is located at address `M1 + (1 * COLS) + 2`. Since `COLS` = 3,
    element (1,2) corresponds to `M1+5`. To access the element at this location, the
    compiler must multiply 5 by the size of the `int` data type (four bytes), yielding
    the offset `M1+20`, which corresponds to byte *x*[20] in the figure. Dereferencing
    this location yields element 5, which is indeed element (1,2) in the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 8.8.2 Noncontiguous Matrix
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The noncontiguous matrix implementation is a bit more complicated. [Figure 8-10](ch08.xhtml#ch8fig10)
    visualizes how `M2` may be laid out in memory.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-10: Matrix `M2`’s noncontiguous layout in memory*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the array of pointers is contiguous, and that each array pointed
    to by an element of `M2` (e.g., `M2[i]`) is contiguous. However, the individual
    arrays are not contiguous with one another.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sumMatrix` function in the following example takes an array of integer
    pointers (called `matrix`) as its first parameter, and a number of rows and columns
    as its second and third parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Even though this function looks nearly identical to the `sumMat` function shown
    earlier, the matrix accepted by this function consists of a contiguous array of
    *pointers*. Each pointer contains the address of a separate contiguous array,
    which corresponds to a separate row in the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: The corresponding assembly for `sumMatrix` follows. Each line is annotated with
    its English translation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Again, the variables `i`, `j`, and `total` are at stack addresses `%ebp-4`,
    `%ebp-8`, and `%ebp-12`, respectively. The input parameters `m`, `row`, and `cols`
    are located at stack addresses `%ebp+8`, `%ebp+12`, and `%ebp+16`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s zoom in on the section that deals specifically with an access to element
    (*i*, *j*), or `matrix[i][j]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The five instructions between `<sumMatrix+31>` and `<sumMatrix+46>` compute
    `matrix[i]`, or `*(matrix+i)`. Note that the compiler needs to multiply `i` by
    four prior to adding it to `matrix` to calculate the correct offset (recall that
    pointers are four bytes in size). The instruction at `<sumMatrix+46>` then dereferences
    the calculated address to get the element `matrix[i]`.
  prefs: []
  type: TYPE_NORMAL
- en: Since `matrix` is an array of `int` pointers, the element located at `matrix[i]`
    is itself an `int` pointer. The *j*th element in `matrix[i]` is located at offset
    *j* × 4 in the `matrix[i]` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next set of instructions extract the *j*th element in array `matrix[i]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The first instruction in this snippet loads variable `j` into register `%edx`.
    The compiler uses the left shift (`shl`) instruction to multiply `j` by four and
    stores the result in register `%edx`. The compiler then adds the resulting value
    to the address located in `matrix[i]` to get the address of `matrix[i][j]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s revisit [Figure 8-10](ch08.xhtml#ch8fig10) and consider an example access
    to `M2[1][2]` For convenience, we reproduce the figure in [Figure 8-11](ch08.xhtml#ch8fig11):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-11: Matrix `M2`’s noncontiguous layout in memory*'
  prefs: []
  type: TYPE_NORMAL
- en: Note that `M2` starts at memory location *x*[0]. The compiler first computes
    the address of `M2[1]` by multiplying 1 by 4 (`sizeof(int *)`) and adding it to
    the address of `M2` (*x*[0]), yielding the new address *x*[4]. A dereference of
    this address yields the address associated with `M2[1]`, or *x*[36]. The compiler
    then multiplies index 2 by 4 (`sizeof(int)`), and adds the result (8) to *x*[36],
    yielding a final address of *x*[44]. The address *x*[44] is dereferenced, yielding
    the value 5\. Sure enough, the element in [Figure 8-11](ch08.xhtml#ch8fig11) that
    corresponds to `M2[1][2]` has the value 5.
  prefs: []
  type: TYPE_NORMAL
- en: 8.9 structs in Assembly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `struct` (see “C Structs” on [page 103](ch02.xhtml#lev1_15)) is another way
    to create a collection of data types in C. Unlike arrays, structs enable different
    data types to be grouped together. C stores a `struct` like a single-dimension
    array, where the data elements (fields) are stored contiguously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s revisit the `struct studentT` from [Chapter 1](ch01.xhtml#ch01):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 8-12](ch08.xhtml#ch8fig12) shows how `student` is laid out in memory.
    For the sake of example, assume that `student` starts at address *x*[0]. Each
    *x*[*i*] denotes the address of a field.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-12: The memory layout of `struct studentT`*'
  prefs: []
  type: TYPE_NORMAL
- en: The fields are stored contiguously next to one another in memory in the order
    in which they are declared. In [Figure 8-12](ch08.xhtml#ch8fig12), the `age` field
    is allocated at the memory location directly after the `name` field (at byte offset
    *x*[64]) and is followed by the `grad_yr` (byte offset *x*[68]) and `gpa` (byte
    offset *x*[72]) fields. This organization enables memory-efficient access to the
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how the compiler generates assembly code to work with a `struct`,
    consider the function `initStudent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The `initStudent` function uses the base address of a `struct studentT` as its
    first parameter, and the desired values for each field as its remaining parameters.
    The listing that follows depicts this function in assembly. In general, parameter
    *i* to function `initStudent` is located at stack address `(ebp+8)` + 4 × *i*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Being mindful of the byte offsets of each field is key to understanding this
    code. Here are a few things to keep in mind.
  prefs: []
  type: TYPE_NORMAL
- en: The `strncpy` call takes the base address of the `name` field of `s`, the address
    of array `nm`, and a length specifier as its three arguments. Recall that because
    `name` is the first field in `struct studentT`, the address of `s` is synonymous
    with the address of `s->name`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The next part (instructions `<initStudent+28>` through `<initStudent+35>`) places
    the value of the `gr` parameter at an offset of 68 from the start of `s`. Revisiting
    the memory layout in [Figure 8-12](ch08.xhtml#ch8fig12) shows that this address
    corresponds to `s->grad_yr`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The next section (instructions `<initStudent+38>` through `<initStudent+53>`)
    copies the `ag` parameter to the `s->age` field. Afterward, the `g` parameter
    value is copied to the `s->gpa` field (byte offset 72):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 8.9.1 Data Alignment and structs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider the following modified declaration of `struct studentT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The size of the `name` field is modified to be 63 bytes, instead of the original
    64\. Consider how this affects the way the `struct` is laid out in memory. It
    may be tempting to visualize it as in [Figure 8-13](ch08.xhtml#ch8fig13).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-13: An incorrect memory layout for the updated `struct` `studentTM`.
    Note that the `name` field is reduced from 64 to 63 bytes.*'
  prefs: []
  type: TYPE_NORMAL
- en: In this depiction, the `age` field occupies the byte immediately following the
    `name` field. But this is incorrect. [Figure 8-14](ch08.xhtml#ch8fig14) depicts
    the actual layout in memory.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-14: The correct memory layout for the updated `struct` `studentTM`.
    Byte *x*[63] is added by the compiler to satisfy memory alignment constraints,
    but it doesn’t correspond to any of the fields.*'
  prefs: []
  type: TYPE_NORMAL
- en: IA32’s alignment policy requires that two-byte data types (i.e., `short`) reside
    at a two-byte-aligned address, whereas four-byte data types (`int`, `float`, `long`,
    and pointer types) reside at four-byte-aligned addresses, and eight-byte data
    types (`double`, `long long`) reside at eight-byte-aligned addresses. For a `struct`,
    the compiler adds empty bytes as *padding* between fields to ensure that each
    field satisfies its alignment requirements. For example, in the `struct` declared
    in the previous code snippet, the compiler adds a byte of empty space (or padding)
    at byte *x*[63] to ensure that the `age` field starts at an address that is at
    a multiple of four. Values aligned properly in memory can be read or written in
    a single operation, enabling greater efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider what happens when a `struct` is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Moving the `name` array to the end ensures that `age`, `grad_yr`, and `gpa`
    are four-byte aligned. Most compilers will remove the filler byte at the end of
    the `struct`. However, if the `struct` is ever used in the context of an array
    (e.g., `struct studentTM courseSection[20];`) the compiler will again add the
    filler byte as padding between each `struct` in the array to ensure that alignment
    requirements are properly met.
  prefs: []
  type: TYPE_NORMAL
- en: '8.10 Real World: Buffer Overflow'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The C language does not perform automatic array bounds checking. Accessing memory
    outside of the bounds of an array is problematic and often results in errors such
    as segmentation faults. However, a clever attacker can inject malicious code that
    intentionally overruns the boundary of an array (also known as a *buffer*) to
    force the program to execute in an unintended manner. In the worst cases, the
    attacker can run code that allows them to gain *root privilege*, or OS-level access
    to the computer system. A piece of software that takes advantage of the existence
    of a known buffer overrun error in a program is known as a *buffer overflow exploit*.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we use GDB and assembly language to fully characterize the
    mechanics of a buffer overflow exploit. Prior to reading this chapter we encourage
    you to explore “Debugging Assembly Code” on [page 177](ch03.xhtml#lev1_24).
  prefs: []
  type: TYPE_NORMAL
- en: 8.10.1 Famous Examples of Buffer Overflow
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Buffer overflow exploits emerged in the 1980s and remained a chief scourge of
    the computing industry through the early parts of the 2000s. While many modern
    operating systems have protections against the simplest buffer overflow attacks,
    careless programming errors can still leave modern programs wide open to attack.
    Buffer overflow exploits have recently been discovered in Skype,^([3](ch08.xhtml#fn8_3))
    Android,^([4](ch08.xhtml#fn8_4)) Google Chrome,^([5](ch08.xhtml#fn8_5)) and others.
    Here are some notable historic examples of buffer overflow exploits.
  prefs: []
  type: TYPE_NORMAL
- en: The Morris Worm
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Morris Worm^([6](ch08.xhtml#fn8_6)) was released in 1998 on ARPANet from
    MIT (to hide that it was written by a student at Cornell) and exploited a buffer
    overrun vulnerability that existed in the Unix finger daemon (`fingerd`). In Linux
    and other Unix-like systems, a *daemon* is a type of process that continuously
    executes in the background, usually performing clean-up and monitoring tasks.
    The `fingerd` daemon returns a user-friendly report on a computer or person. Most
    crucially, the worm had a replication mechanism that caused it to be sent to the
    same computer multiple times, bogging down the system to an unusable state. Even
    though the author claimed that the worm was meant as a harmless intellectual exercise,
    the replication mechanism enabled the worm to spread easily and made it difficult
    to remove. In future years, other worms would employ buffer overflow exploits
    to gain unauthorized access into systems. Notable examples include Code Red (2001),
    MS-SQLSlammer (2003), and W32/Blaster (2003).
  prefs: []
  type: TYPE_NORMAL
- en: AOL Chat Wars
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: David Auerbach,^([7](ch08.xhtml#fn8_7)) a former Microsoft engineer, detailed
    his experience with a buffer overflow during his efforts to integrate Microsoft’s
    Messenger Service (MMS) with AOL Instant Messenger in the late 1990s. Back then,
    AOL Instant Messenger (AIM) was *the* service to use if you wanted to instant
    message (or IM) friends and family. Microsoft tried to gain a foothold in this
    market by designing a feature in MMS that enabled MMS users to talk to their AIM
    “buddies.” Displeased, AOL patched their servers so that MMS could no longer connect
    to them. Microsoft engineers figured out a way for MMS clients to mimic the messages
    sent by AIM clients to AOL servers, making it difficult for AOL to distinguish
    between messages received by MMS and AIM. AOL responded by changing the way AIM
    sent messages, and MMS engineers duly changed their client’s messages to once
    again match AIM’s. This “chat war” continued until AOL started using a buffer
    overflow error *in their own client* to verify that sent messages came from AIM
    clients. Since MMS clients did not have the same vulnerability, the chat wars
    ended, with AOL as the victor.
  prefs: []
  type: TYPE_NORMAL
- en: '8.10.2 A First Look: The Guessing Game'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To help you understand the mechanism of the buffer overflow attack, we provide
    a 32-bit executable of a simple program that enables the user to play a guessing
    game with the program. Download the `secret` executable^([8](ch08.xhtml#fn8_8))
    and extract it using the `tar` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we provide a copy of the main file associated with the executable:'
  prefs: []
  type: TYPE_NORMAL
- en: main.c
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: This game prompts the user to enter first a secret number and then a secret
    string to win the guessing game. The header file `other.h` contains the definition
    of the `getSecretCode` and `calculateValue` functions, but it is unavailable to
    us. How then can a user beat the program? Brute forcing the solution will take
    too long. One strategy is to analyze the `secret` executable in GDB and step through
    the assembly to reveal the secret number and string. The process of examining
    assembly code to reveal knowledge of how it works is commonly referred to as *reverse
    engineering*. Readers comfortable enough with GDB and reading assembly should
    be able to use GDB to reverse engineer the secret number and the secret string.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a different, sneakier way to win.
  prefs: []
  type: TYPE_NORMAL
- en: 8.10.3 Taking a Closer Look (Under the C)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The program contains a potential buffer overrun vulnerability at the first call
    to `scanf`. To understand what is going on, let’s inspect the assembly code of
    the `main` function using GDB. Let’s also place a breakpoint at address 0x0804859f,
    which is the address of the instruction immediately before the call to `scanf`
    (placing the breakpoint at the address of `scanf` causes program execution to
    halt *inside* the call to `scanf`, not in `main`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 8-15](ch08.xhtml#ch8fig15) depicts the stack immediately before the
    call to `scanf`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-15: The call stack immediately before the call to `scanf`*'
  prefs: []
  type: TYPE_NORMAL
- en: Prior to the call to `scanf`, the arguments for `scanf` are preloaded onto the
    stack, with the first argument at the top of the stack, and the second argument
    one address below. The `lea` instruction at location `<main+21>` creates the reference
    for array `buf`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, suppose that the user enters `12345678` at the prompt. [Figure 8-16](ch08.xhtml#ch8fig16)
    illustrates what the stack looks like immediately after the call to `scanf` completes.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-16: The call stack immediately after the call to `scanf` with input
    `12345678`*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that the hex values for the ASCII encodings of the digits 0 to 9 are
    0x30 to 0x39, and that each stack memory location is four bytes long. The frame
    pointer is 56 bytes away from the stack pointer. Readers tracing along can confirm
    the value of `%ebp` by using GDB to print its value (`p` `$ebp`). In the example
    shown, the value of `%ebp` is 0xffffd428\. The following command allows the reader
    to inspect the 64 bytes (in hex) below register `%esp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'This GDB command yields output that looks similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Each line represents two 32-bit words. So, the first line represents the words
    at addresses 0xffffd3f0 and 0xffffd3f4\. Looking at the top of the stack, we can
    see the memory address associated with the string `"%s"` (or 0x0804871c) followed
    by the address of `buf` (or 0xffffd40c). Note that the address for `buf` is simply
    represented as 0x40c in the figures in this section.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note MULTIBYTE VALUES ARE STORED IN LITTLE-ENDIAN ORDER**'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding assembly segment, the byte at address 0xfffffd3f0 is 0x1c,
    the byte at address 0xfffffd3f1 is 0x87, the byte at address 0xfffffd3f2 is 0x04,
    and the byte at address 0xfffffd3f3 is 0x08\. However, the 32-bit *value* (which
    corresponds to the memory address of the string `"%s"`) at address 0xfffffd3f0
    is in fact 0x0804871c. Remember that because x86 is a little-endian system (see
    “Integer Byte Order on [page 224](ch04.xhtml#lev1_34)), the bytes for multibyte
    values such as addresses are stored in reverse order. Similarly, the bytes corresponding
    to the address of array `buf` (0xffffd40c) are stored in reverse order at address
    0xfffffd3f4.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bytes associated with address 0xffffd40c are located on the same line as
    those associated with address 0xffffd408 and are the second word on that line.
    Since the `buf` array is 12 bytes long, the elements associated with `buf` span
    the 12 bytes from address 0xffffd40c to 0xffffd417\. Inspecting the bytes at those
    addresses yields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: At these locations, we can clearly see the hex representation of the input string
    12345678\. The null termination byte `\0` appears in the leftmost byte location
    at address 0xffffd414\. Recall that `scanf` terminates all strings with a null
    byte.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, 12345678 is not the secret number. Here is the output when we try
    to run `secret` with input string 12345678:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The `echo $?` command prints out the return value of the last executed command
    in the shell. In this case, the program returned 1 because the secret number we
    entered is wrong. Recall that by convention, programs return 0 when there are
    no errors. Our goal going forward is to trick the program to exit with a return
    value of 0, indicating that we won the game.
  prefs: []
  type: TYPE_NORMAL
- en: '8.10.4 Buffer Overflow: First Attempt'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, let’s try typing in the string 1234567890123456789012345678901234:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Interesting! Now the program crashes with a segmentation fault, with return
    code 139\. [Figure 8-17](ch08.xhtml#ch8fig17) shows what the call stack for `main`
    looks like immediately after the call to `scanf` with this new input.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-17: The call stack immediately after the call to `scanf` with input
    1234567890123456789012345678901234*'
  prefs: []
  type: TYPE_NORMAL
- en: The input string is so long that it not only overwrote the value stored at address
    0x428, but it spilled over into the return address below the stack frame for `main`.
    Recall that when a function returns, the program tries to resume execution at
    the address specified by the return address. In this example, the program tries
    to resume execution at address 0xf7003433 after exiting `main`, which does not
    exist. So the program crashes with a segmentation fault.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rerunning the program in GDB (`input.txt` contains the input string above)
    reveals this devilry in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Notice that our input string blew past the stated limits of the array `buf`,
    overwriting all the other values stored on the stack. In other words, our string
    created a buffer overrun and corrupted the call stack, causing the program to
    crash. This process is also known as *smashing the stack*.
  prefs: []
  type: TYPE_NORMAL
- en: '8.10.5 A Smarter Buffer Overflow: Second Attempt'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our first example smashed the stack by overwriting the `%ebp` register and return
    address with junk, causing the program to crash. An attacker whose goal is to
    simply crash a program would be satisfied at this point. However, our goal is
    to trick the guessing game to return 0, indicating that we won the game. We accomplish
    this by filling the call stack with data more meaningful than junk values. For
    example, we could overwrite the stack so that the return address is replaced with
    the address of `endGame`. Then, when the program attempts to return from `main`,
    it will instead execute `endGame` rather than crashing with a segmentation fault.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find out the address of `endGame`, let’s inspect `secret` again in GDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Observe that `endGame` starts at address 0x08048564\. [Figure 8-18](ch08.xhtml#ch8fig18)
    illustrates a sample exploit that forces `secret` to run the `endGame` function.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-18: A sample string that can force `secret` to execute the `endGame`
    function*'
  prefs: []
  type: TYPE_NORMAL
- en: Again, since x86 is a little-endian system in which the stack grows toward lower
    addresses, the bytes in the return address appear to be in reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following program illustrates how an attacker could construct the preceding
    exploit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The `\x` before each number indicates that the number is formatted as the hexadecimal
    representation of a character. After defining `ebuff[]`, the `main` function simply
    prints it out, character by character. To get the associated byte string, compile
    and run this program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the file `exploit` as input to `scanf`, it suffices to run `secret`
    with `exploit` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: The program prints out “You are so wrong!” because the string contained in `exploit`
    is *not* the secret number. However, the program also prints out the string “You
    win!” Recall, though, that our goal is to trick the program to return 0\. In a
    larger system, where the notion of “success” is tracked by an external program,
    it is often most important what a program returns, not what it prints out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Checking the return value yields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Our exploit works! We won the game!
  prefs: []
  type: TYPE_NORMAL
- en: 8.10.6 Protecting Against Buffer Overflow
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The example we showed changed the control flow of the `secret` executable,
    forcing it to return a zero value associated with success. However, an exploit
    like this could do some real damage. Furthermore, some older computer systems
    *executed* bytes from stack memory. If an attacker placed bytes associated with
    assembly instructions on the call stack, the CPU would interpret the bytes as
    *real* instructions, enabling the attacker to force the CPU to execute *any arbitrary
    code of their choosing*. Fortunately, there are strategies that modern computer
    systems employ to make it more difficult for attackers to run buffer overflow
    exploits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stack randomization.**   The OS allocates the starting address of the stack
    at a random location in stack memory, causing the position/size of the call stack
    to vary from one run of a program to another. Multiple machines running the same
    code would have different stack addresses. Modern Linux systems use stack randomization
    as a standard practice. However, a determined attacker can brute force the attack,
    by attempting to repeat attacks with different addresses. A common trick is to
    use a *NOP sled* (or slide), i.e., a large number of `nop` instructions, before
    the actual exploit code. Executing the `nop` instruction (`0x90`) has no effect,
    other than causing the program counter to increment to the next instruction. As
    long as the attacker can get the CPU to execute somewhere in the NOP sled, the
    NOP sled will eventually lead to the exploit code that follows it. Aleph One’s
    writeup^([9](ch08.xhtml#fn8_9)) details the mechanism of this type of attack.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stack corruption detection.**   Another line of defense is to try to detect
    when the stack is corrupted. Recent versions of GCC use a stack protector known
    as a *canary* that acts as a guard between the buffer and the other elements of
    the stack. A canary is a value stored in a nonwriteable section of memory that
    can be compared to a value put on the stack. If the canary “dies” during a program’s
    execution, the program knows that it is under attack and aborts with an error
    message. A clever attacker can, however, replace the canary to prevent the program
    from detecting stack corruption.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Limiting executable regions.**   In this line of defense, executable code
    is restricted to only particular regions of memory. In other words, the call stack
    is no longer executable. However, even this defense can be defeated. In an attack
    utilizing *return-oriented programming* (ROP), an attacker can “cherry-pick” instructions
    in executable regions and jump from instruction to instruction to build an exploit.
    There are some famous examples of this online, especially in video games.^([10](ch08.xhtml#fn8_10))'
  prefs: []
  type: TYPE_NORMAL
- en: However, the best line of defense is always the programmer. To prevent buffer
    overflow attacks on your programs, use C functions with *length specifiers* whenever
    possible and add code that performs array bounds checking. It is crucial that
    any defined arrays match the chosen length specifiers. [Table 8-18](ch08.xhtml#ch8tab18)
    lists some common “bad” C functions that are vulnerable to buffer overflow and
    the corresponding “good” function to use (assume that `buf` is allocated 12 bytes).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-18:** C Functions with Length Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instead of** | **Use** |'
  prefs: []
  type: TYPE_TB
- en: '| `gets(buf)` | `fgets(buf, 12, stdin)` |'
  prefs: []
  type: TYPE_TB
- en: '| `scanf("%s", buf)` | `scanf("%12s", buf)` |'
  prefs: []
  type: TYPE_TB
- en: '| `strcpy(buf2, buf)` | `strncpy(buf2, buf, 12)` |'
  prefs: []
  type: TYPE_TB
- en: '| `strcat(buf2, buf)` | `strncat(buf2, buf, 12)` |'
  prefs: []
  type: TYPE_TB
- en: '| `sprintf(buf, "%d", num)` | `snprintf(buf, 12, "%d", num)` |'
  prefs: []
  type: TYPE_TB
- en: 'The `secret2` binary^([11](ch08.xhtml#fn8_11)) no longer has the buffer overflow
    vulnerability. Here’s the `main` function of this new binary:'
  prefs: []
  type: TYPE_NORMAL
- en: main2.c
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we added a length specifier to all calls of `scanf`, causing the
    `scanf` function to stop reading from the input after the first 12 bytes are read.
    The exploit string no longer breaks the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Of course, any reader with basic reverse-engineering skills can still win the
    guessing game by analyzing the assembly code. If you haven’t tried to beat the
    program yet with reverse engineering, we encourage you to do so now.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[1.](ch08.xhtml#rfn8_1) Edsger Dijkstra,“Go To Statement Considered Harmful,”
    *Communications of the ACM* 11(3), pp. 147–148, 1968.'
  prefs: []
  type: TYPE_NORMAL
- en: '[2.](ch08.xhtml#rfn8_2) *[https://diveintosystems.org/book/C8-IA32/recursion.html](https://diveintosystems.org/book/C8-IA32/recursion.html)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[3.](ch08.xhtml#rfn8_3) Mohit Kumar, “Critical Skype Bug Lets Hackers Remotely
    Execute Malicious Code,” *[https://thehackernews.com/2017/06/skype-crash-bug.html](https://thehackernews.com/2017/06/skype-crash-bug.html)*,
    2017.'
  prefs: []
  type: TYPE_NORMAL
- en: '[4.](ch08.xhtml#rfn8_4) Tamir Zahavi-Brunner, “CVE-2017-13253: Buffer overflow
    in multiple Android DRM services,” *[https://blog.zimperium.com/cve-2017-13253-buffer-overflow-multiple-android-drm-services/](https://blog.zimperium.com/cve-2017-13253-buffer-overflow-multiple-android-drm-services/)*,
    2018.'
  prefs: []
  type: TYPE_NORMAL
- en: '[5.](ch08.xhtml#rfn8_5) Tom Spring, “Google Patches ‘High Severity’ Browser
    Bug,” *[https://threatpost.com/google-patches-high-severity-browser-bug/128661/](https://threatpost.com/google-patches-high-severity-browser-bug/128661/)*,
    2017.'
  prefs: []
  type: TYPE_NORMAL
- en: '[6.](ch08.xhtml#rfn8_6) Christopher Kelty, “The Morris Worm,” *Limn Magazine*,
    Issue 1: Systemic Risk, 2011\. *[https://limn.it/articles/the-morris-worm/](https://limn.it/articles/the-morris-worm/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[7.](ch08.xhtml#rfn8_7) David Auerbach, “Chat Wars: Microsoft vs. AOL,” *NplusOne
    Magazine*, Issue 19, Spring 2014\. *[https://nplusonemag.com/issue-19/essays/chat-wars/](https://nplusonemag.com/issue-19/essays/chat-wars/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[8.](ch08.xhtml#rfn8_8) *[https://diveintosystems.org/book/C8-IA32/_attachments/secret.tar.gz](https://diveintosystems.org/book/C8-IA32/_attachments/secret.tar.gz)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[9.](ch08.xhtml#rfn8_9) Aleph One, “Smashing the Stack for Fun and Profit,”
    *[http://insecure.org/stf/smashstack.html](http://insecure.org/stf/smashstack.html)*,
    1996.'
  prefs: []
  type: TYPE_NORMAL
- en: '[10.](ch08.xhtml#rfn8_10) DotsAreCool, “Super Mario World Credit Warp” (Nintendo
    ROP example), *[https://youtu.be/vAHXK2wut_I](https://youtu.be/vAHXK2wut_I)*,
    2015.'
  prefs: []
  type: TYPE_NORMAL
- en: '[11.](ch08.xhtml#rfn8_11) *[https://diveintosystems.org/book/C8-IA32/_attachments/secret2.tar.gz](https://diveintosystems.org/book/C8-IA32/_attachments/secret2.tar.gz)*'
  prefs: []
  type: TYPE_NORMAL
