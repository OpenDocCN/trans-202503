- en: '8'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '8'
- en: 32-BIT X86 ASSEMBLY (IA32)
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 32 位 x86 汇编（IA32）
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: In this chapter, we explore the Intel Architecture 32-bit (IA32) instruction
    set architecture. Recall from [Chapter 5](ch05.xhtml#ch05) that an instruction
    set architecture, or ISA, defines the set of instructions and binary encodings
    of a machine-level program. To run the examples in this chapter, you will need
    access to a machine with an x86 processor or a compiler that can create 32-bit
    executables. The term “x86” is often used synonymously with the IA32 architecture.
    The x86 architecture, and its 64-bit variant x86-64, are ubiquitous in modern
    computers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索 Intel 架构 32 位（IA32）指令集架构。回想一下 [第 5 章](ch05.xhtml#ch05)，指令集架构（ISA）定义了机器级程序的指令集和二进制编码。要运行本章中的示例，你需要一台配有
    x86 处理器的机器或一个可以创建 32 位可执行文件的编译器。术语“x86”通常与 IA32 架构互换使用。x86 架构及其 64 位变种 x86-64
    在现代计算机中无处不在。
- en: 'Very few modern machines have 32-bit processors; most Intel and AMD systems
    produced since 2007 have 64-bit processors. To check what type of processor you
    have, use the `uname -p` command:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有现代机器配备 32 位处理器；自 2007 年以来，大多数 Intel 和 AMD 系统都配备了 64 位处理器。要检查你的处理器类型，可以使用
    `uname -p` 命令：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If typing `uname -p` returns either `i686` or `i386`, your system has a 32-bit
    processor. However, if the `uname -p` command returns `x86_64`, your system has
    a newer 64-bit processor. Note that because x86-64 is an *extension* of the older
    IA32 ISA, virtually all 64-bit systems contain a 32-bit subsystem that allows
    the execution of 32-bit executables.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入 `uname -p` 返回 `i686` 或 `i386`，说明你的系统配备的是 32 位处理器。然而，如果 `uname -p` 返回 `x86_64`，说明你的系统配备的是较新的
    64 位处理器。请注意，因为 x86-64 是较旧的 IA32 ISA 的 *扩展*，几乎所有 64 位系统都包含一个 32 位子系统，允许执行 32 位可执行文件。
- en: 'If you have a 64-bit Linux system, additional packages are sometimes required
    to allow users to create 32-bit executables, like we will be doing in this chapter.
    For example, on an Ubuntu machine you will need to install 32-bit development
    libraries and additional packages to augment GCC with cross-compiling features:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 64 位 Linux 系统，有时需要额外的包来允许用户创建 32 位可执行文件，就像我们在本章中将要做的那样。例如，在 Ubuntu 系统上，你需要安装
    32 位开发库和其他包，以增强 GCC 的交叉编译功能：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: x86 SYNTAX BRANCHES
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: x86 语法分支
- en: x86 architectures typically follow one of two different syntax branches. Unix
    machines commonly use the AT&T syntax, given that Unix was developed at AT&T Bell
    Labs. The corresponding assembler is GNU Assembler (GAS). Since we use GCC for
    most examples in this book, we cover AT&T syntax in this chapter. Windows machines
    commonly use Intel syntax, which is used by Microsoft’s Macro Assembler (MASM).
    The Netwide Assembler (NASM) is an example of a Linux assembler that uses Intel
    syntax. The argument regarding the superiority of one syntax over the other is
    one of the “holy wars” of the discipline. However, there is value in being familiar
    with both syntaxes, as a programmer may encounter either in various circumstances.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: x86 架构通常遵循两种不同的语法分支之一。由于 Unix 在 AT&T 贝尔实验室开发，Unix 机器通常使用 AT&T 语法。相应的汇编器是 GNU
    汇编器（GAS）。由于我们在本书中大多数示例都使用 GCC，因此我们在本章中讲解 AT&T 语法。Windows 机器通常使用 Intel 语法，这是微软宏汇编器（MASM）使用的语法。Netwide
    汇编器（NASM）是一个使用 Intel 语法的 Linux 汇编器。关于哪种语法更优的争论，是该学科的“圣战”之一。然而，熟悉这两种语法是有价值的，因为程序员在不同的情况下可能会遇到其中的任何一种。
- en: '8.1 Diving into Assembly: Basics'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1 探索汇编语言：基础知识
- en: 'For a first look at assembly, we modify the `adder` function from [Chapter
    6](ch06.xhtml#ch06) to simplify its behavior. Here’s the modified function (`adder2`):'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在初次接触汇编时，我们将修改 [第 6 章](ch06.xhtml#ch06) 中的 `adder` 函数，简化其行为。这里是修改后的函数（`adder2`）：
- en: modified.c
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: modified.c
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To compile this code, use the following command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译这段代码，请使用以下命令：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `-m32` flag tells GCC to compile the code to a 32-bit executable. Forgetting
    to include this flag may result in assembly that is wildly different from the
    examples shown in this chapter; by default, GCC compiles to x86-64 assembly, the
    64-bit variant of x86\. However, virtually all 64-bit architectures have a 32-bit
    operating mode for backward compatibility. This chapter covers IA32; other chapters
    cover x86-64 and ARM. Despite its age, IA32 is still extremely useful for understanding
    how programs work and how to optimize code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`-m32` 标志告诉 GCC 编译器将代码编译为 32 位可执行文件。如果忘记包含这个标志，生成的汇编代码可能与本章中的示例有很大不同；默认情况下，GCC
    编译为 x86-64 汇编，即 x86 的 64 位变体。然而，几乎所有的 64 位架构都具有用于向后兼容的 32 位操作模式。本章介绍 IA32，其他章节则涵盖
    x86-64 和 ARM。尽管 IA32 已有些年头，但它仍然对于理解程序如何运行和如何优化代码非常有用。'
- en: 'Next, let’s view the corresponding assembly of this code by typing the following
    command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过输入以下命令查看这段代码的对应汇编：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Search for the code snippet associated with `adder2` by typing `/adder2` while
    examining the file `output` using `less`. The section associated with `adder2`
    should look similar to the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `less` 查看文件 `output` 时，输入 `/adder2` 查找与 `adder2` 相关的代码片段。与 `adder2` 相关的部分应类似于以下内容：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Assembly output for the adder2 function*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*adder2 函数的汇编输出*'
- en: Don’t worry if you don’t understand what’s going on just yet. We will cover
    assembly in greater detail in later sections. For now, we will study the structure
    of these individual instructions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还不明白发生了什么，也不用担心。我们将在后面的章节中更详细地讲解汇编内容。目前，我们将研究这些单独指令的结构。
- en: Each line in the preceding example contains an instruction’s address in program
    memory, the bytes corresponding to the instruction, and the plaintext representation
    of the instruction itself. For example, `55` is the machine code representation
    of the instruction `push %ebp`, and the instruction occurs at address 0x804840b
    in program memory.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 上面示例中的每一行都包含了指令在程序内存中的地址、与指令对应的字节以及指令本身的明文表示。例如，`55` 是指令 `push %ebp` 的机器码表示，且该指令出现在程序内存地址
    0x804840b 处。
- en: It is important to note that a single line of C code often translates to multiple
    instructions in assembly. The operation `a + 2` is represented by the two instructions
    `mov 0x8(%ebp),%eax` and `add $0x2,%eax`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，一行 C 代码通常会翻译成多条汇编指令。操作 `a + 2` 由两条指令 `mov 0x8(%ebp),%eax` 和 `add $0x2,%eax`
    表示。
- en: '**Warning YOUR ASSEMBLY MAY LOOK DIFFERENT!**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告：你的汇编代码可能会有所不同！**'
- en: If you are compiling your code along with us, you may notice that some of your
    assembly examples look different from what is shown in this book. The precise
    assembly instructions that are output by any compiler depend on that compiler’s
    version and the underlying operating system. Most of the assembly examples in
    this book were generated on systems running Ubuntu or Red Hat Enterprise Linux
    (RHEL).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在与我们一起编译代码，你可能会注意到你的某些汇编示例与本书中展示的有所不同。任何编译器输出的精确汇编指令取决于该编译器的版本和底层操作系统。本书中的大部分汇编示例是在运行
    Ubuntu 或 Red Hat Enterprise Linux (RHEL) 系统上生成的。
- en: In the examples that follow, we do not use any optimization flags. For example,
    we compile any example file (`example.c`) using the command `gcc` `-m32 -o example
    example.c`. Consequently, there are many seemingly redundant instructions in the
    examples that follow. Remember that the compiler is not “smart”—it simply follows
    a series of rules to translate human-readable code into machine language. During
    this translation process, it is not uncommon for some redundancy to occur. Optimizing
    compilers remove many of these redundancies during optimization, which is covered
    in [Chapter 12](ch12.xhtml#ch12).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，我们没有使用任何优化标志。例如，我们使用命令 `gcc -m32 -o example example.c` 编译任何示例文件（`example.c`）。因此，接下来的示例中有许多看似冗余的指令。请记住，编译器并不“智能”——它只是按照一系列规则将人类可读的代码翻译成机器语言。在这个翻译过程中，出现某些冗余是很常见的。优化编译器在优化过程中会去除这些冗余，优化内容将在[第12章](ch12.xhtml#ch12)中详细介绍。
- en: 8.1.1 Registers
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.1 寄存器
- en: 'Recall that a *register* is a word-sized storage unit located directly on the
    CPU. There may be separate registers for data, instructions, and addresses. For
    example, the Intel CPU has a total of eight registers for storing 32-bit data:
    `%eax`, `%ebx`, `%ecx`, `%edx`, `%edi`, `%esi`, `%esp`, and `%ebp`.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，*寄存器*是直接位于 CPU 上的字长存储单元。可能会有不同的寄存器用于存储数据、指令和地址。例如，Intel CPU 有八个用于存储 32
    位数据的寄存器：`%eax`、`%ebx`、`%ecx`、`%edx`、`%edi`、`%esi`、`%esp` 和 `%ebp`。
- en: Programs can read from or write to all eight of these registers. The first six
    registers all hold general-purpose data, whereas the last two are typically reserved
    by the compiler to hold address data. While a program may interpret a general-purpose
    register’s contents as integers or as addresses, the register itself makes no
    distinction. The last two registers (`%esp` and `%ebp`) are known as the *stack
    pointer* and the *frame pointer*, respectively. The compiler reserves these registers
    for operations that maintain the layout of the program stack. Typically, `%esp`
    points to the top of the program stack, whereas `%ebp` points to the base of the
    current stack frame. We discuss stack frames and these two registers in greater
    detail in our discussion on functions (see “Functions in Assembly” on [page 326](ch07.xhtml#lev1_55)).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 程序可以读取或写入这八个寄存器的内容。前六个寄存器都用于存储通用数据，而最后两个寄存器通常被编译器保留用于存储地址数据。虽然程序可以将通用寄存器的内容解释为整数或地址，但寄存器本身并不区分这些类型。最后两个寄存器（`%esp`和`%ebp`）分别被称为*栈指针*和*帧指针*。编译器保留这些寄存器用于维护程序栈的布局。通常，`%esp`指向程序栈的顶部，而`%ebp`指向当前栈帧的底部。我们将在“汇编中的函数”（见[第326页](ch07.xhtml#lev1_55)）的讨论中更详细地探讨栈帧和这两个寄存器。
- en: The last register worth mentioning is `%eip` or the *instruction pointer*, sometimes
    called the *program counter* (PC). It points to the next instruction to be executed
    by the CPU. Unlike the eight registers mentioned previously, programs cannot write
    directly to register `%eip`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个值得提及的寄存器是`%eip`，也称为*指令指针*，有时也叫*程序计数器*（PC）。它指向CPU即将执行的下一条指令。与之前提到的八个寄存器不同，程序不能直接写入`%eip`寄存器。
- en: 8.1.2 Advanced Register Notation
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.2 高级寄存器符号
- en: For the first six registers mentioned, the ISA provides a mechanism to access
    the lower 16 bits of each register. The ISA also provides a separate mechanism
    to access the 8-bit components of the lower 16 bits of the first four of these
    registers. [Table 8-1](ch08.xhtml#ch8tab1) lists each of the six registers and
    the ISA mechanisms (if available) to access their component bytes.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前六个寄存器，指令集架构（ISA）提供了一种机制来访问每个寄存器的低16位。ISA还提供了另一种机制，用于访问前四个寄存器的低16位中的8位组件。[表
    8-1](ch08.xhtml#ch8tab1)列出了每个寄存器及其访问组件字节的ISA机制（如果有的话）。
- en: '**Table 8-1:** x86 Registers and Mechanisms for Accessing Lower Bytes'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-1：** x86寄存器及访问低字节的机制'
- en: '| **32-bit Register** **(Bits 31–0)** | **Lower 16 Bits** **(Bits 15–0)** |
    **(Bits 15–8)** | **(Bits 7–0)** |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| **32位寄存器** **(位 31–0)** | **低16位** **(位 15–0)** | **(位 15–8)** | **(位 7–0)**
    |'
- en: '| `%eax` | `%ax` | `%ah` | `%al` |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `%eax` | `%ax` | `%ah` | `%al` |'
- en: '| `%ebx` | `%bx` | `%bh` | `%bl` |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `%ebx` | `%bx` | `%bh` | `%bl` |'
- en: '| `%ecx` | `%cx` | `%ch` | `%cl` |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `%ecx` | `%cx` | `%ch` | `%cl` |'
- en: '| `%edx` | `%dx` | `%dh` | `%dl` |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `%edx` | `%dx` | `%dh` | `%dl` |'
- en: '| `%edi` | `%di` |  |  |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `%edi` | `%di` |  |  |'
- en: '| `%esi` | `%si` |  |  |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `%esi` | `%si` |  |  |'
- en: The lower 16 bits for any of the aforementioned registers can be accessed by
    referencing the last two letters in the register’s name. For example, use `%ax`
    to access the lower 16 bits of `%eax`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 任何上述寄存器的低16位可以通过引用寄存器名称中的最后两个字母来访问。例如，使用`%ax`来访问`%eax`的低16位。
- en: The *higher* and *lower* bytes within the lower 16 bits of the first four listed
    registers can be accessed by taking the last two letters of the register name
    and replacing the last letter with either an `h` (for *higher*) or an `l` (for
    *lower*) depending on which byte is desired. For example, `%al` references the
    lower eight bits of register `%ax`, whereas `%ah` references the higher eight
    bits of register `%ax`. These eight-bit registers are commonly used by the compiler
    for storing single-byte values for certain operations, such as bitwise shifts
    (a 32-bit register cannot be shifted more than 32 places and the number 32 requires
    only a single byte of storage). In general, the compiler will use the smallest
    component register needed to complete an operation.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过获取寄存器名称中的最后两个字母，并根据需要的字节，将最后一个字母替换为`h`（表示*高字节*）或`l`（表示*低字节*）来访问前四个列出的寄存器的低16位中的*高字节*和*低字节*。例如，`%al`引用`%ax`寄存器的低8位，而`%ah`引用`%ax`寄存器的高8位。这些8位寄存器通常由编译器用于存储某些操作的单字节值，例如按位移位操作（32位寄存器不能被移位超过32位，而数字32只需要一个字节的存储）。通常，编译器会使用完成操作所需的最小组件寄存器。
- en: 8.1.3 Instruction Structure
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.3 指令结构
- en: Each instruction consists of an operation code (or *opcode*) that specifies
    what it does, and one or more *operands* that tell the instruction how to do it.
    For example, the instruction `add $0x2,%eax` has the opcode `add` and the operands
    `$0x2` and `%eax`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每条指令由操作码（或 *操作码*）和一个或多个 *操作数* 组成，操作数指定指令如何执行操作。例如，指令 `add $0x2,%eax` 中，操作码是
    `add`，操作数是 `$0x2` 和 `%eax`。
- en: 'Each operand corresponds to a source or destination location for a specific
    operation. There are multiple types of operands:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作数对应特定操作的源或目标位置。操作数有多种类型：
- en: '*Constant* (*literal*) values are preceded by the `$` sign. For example, in
    the instruction `add $0x2,%eax`, `$0x2` is a literal value that corresponds to
    the hexadecimal value 0x2.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*常量*（*字面量*）值前面有 `$` 符号。例如，在指令 `add $0x2,%eax` 中，`$0x2` 是一个字面量值，对应十六进制值 0x2。'
- en: '*Register* forms refer to individual registers. The instruction `add` `$0x2,`
    `%eax` specifies register `%eax` as the destination location where the result
    of the `add` operation will be stored.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*寄存器*形式指的是各个独立的寄存器。指令 `add` `$0x2,%eax` 指定寄存器 `%eax` 为目标位置，其中将存储 `add` 操作的结果。'
- en: '*Memory* forms correspond to some value inside main memory (RAM) and are commonly
    used for address lookups. Memory address forms can contain a combination of registers
    and constant values. For example, in the instruction `mov 0x8(%ebp),%eax`, the
    operand `0x8(%ebp)` is an example of a memory form. It loosely translates to “add
    0x8 to the value in register `%ebp`, and then perform a memory lookup.” If this
    sounds like a pointer dereference, that’s because it is!'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*内存*形式指的是主内存（RAM）中的某个值，通常用于地址查找。内存地址形式可以包含寄存器和常量值的组合。例如，在指令 `mov 0x8(%ebp),%eax`
    中，操作数 `0x8(%ebp)` 就是内存形式的一个例子。它大致翻译为“将 0x8 加到寄存器 `%ebp` 的值上，然后执行内存查找。”如果这听起来像是指针解引用，那是因为它确实是！'
- en: 8.1.4 An Example with Operands
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.4 操作数示例
- en: 'The best way to explain operands in detail is to present a quick example. Suppose
    that memory contains the following values:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 解释操作数的最佳方法是通过一个快速示例。假设内存中包含以下值：
- en: '| **Address** | **Value** |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **地址** | **值** |'
- en: '| 0x804 | 0xCA |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 0x804 | 0xCA |'
- en: '| 0x808 | 0xFD |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 0x808 | 0xFD |'
- en: '| 0x80c | 0x12 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 0x80c | 0x12 |'
- en: '| 0x810 | 0x1E |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 0x810 | 0x1E |'
- en: 'Let’s also assume that the following registers contain values:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 假设以下寄存器包含值：
- en: '| **Address** | **Value** |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| **地址** | **值** |'
- en: '| `%eax` | 0x804 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `%eax` | 0x804 |'
- en: '| `%ebx` | 0x10 |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `%ebx` | 0x10 |'
- en: '| `%ecx` | 0x4 |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `%ecx` | 0x4 |'
- en: '| `%edx` | 0x1 |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `%edx` | 0x1 |'
- en: Then the operands in [Table 8-2](ch08.xhtml#ch8tab2) evaluate to the values
    shown. Each row of the table matches an operand with its form (e.g., constant,
    register, memory), how it is translated, and its value. Note that the notation
    M[x] in this context denotes the value at the memory location specified by address
    x.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，[表 8-2](ch08.xhtml#ch8tab2) 中的操作数会计算出所示的值。表中的每一行将一个操作数与其形式（例如，常量、寄存器、内存）进行匹配，显示如何翻译以及其值。请注意，在此上下文中，符号
    M[x] 表示位于地址 x 的内存位置中的值。
- en: '**Table 8-2:** Example Operands'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-2：** 操作数示例'
- en: '| **Operand** | **Form** | **Translation** | **Value** |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| **操作数** | **形式** | **翻译** | **值** |'
- en: '| `%ecx` | Register | `%ecx` | 0x4 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `%ecx` | 寄存器 | `%ecx` | 0x4 |'
- en: '| `(%eax)` | Memory | M[`%eax`] or M[0x804] | 0xCA |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `(%eax)` | 内存 | M[`%eax`] 或 M[0x804] | 0xCA |'
- en: '| `$0x808` | Constant | 0x808 | 0x808 |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `$0x808` | 常量 | 0x808 | 0x808 |'
- en: '| `0x808` | Memory | M[0x808] | 0xFD |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `0x808` | 内存 | M[0x808] | 0xFD |'
- en: '| `0x8(%eax)` | Memory | M[`%eax` + 8] or M[0x80c] | 0x12 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `0x8(%eax)` | 内存 | M[`%eax` + 8] 或 M[0x80c] | 0x12 |'
- en: '| `(%eax, %ecx)` | Memory | M[`%eax` + `%ecx`] or M[0x808] | 0xFD |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `(%eax, %ecx)` | 内存 | M[`%eax` + `%ecx`] 或 M[0x808] | 0xFD |'
- en: '| `0x4(%eax, %ecx)` | Memory | M[`%eax` + `%ecx` + 4] or M[0x80c] | 0x12 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `0x4(%eax, %ecx)` | 内存 | M[`%eax` + `%ecx` + 4] 或 M[0x80c] | 0x12 |'
- en: '| `0x800(,%edx,4)` | Memory | M[0x800 + `%edx`×4] or M[0x804] | 0xCA |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `0x800(,%edx,4)` | 内存 | M[0x800 + `%edx`×4] 或 M[0x804] | 0xCA |'
- en: '| `(%eax, %edx, 8)` | Memory | M[`%eax` + `%edx`×8] or M[0x80c] | 0x12 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `(%eax, %edx, 8)` | 内存 | M[`%eax` + `%edx`×8] 或 M[0x80c] | 0x12 |'
- en: In [Table 8-2](ch08.xhtml#ch8tab2), the notation `%ecx` indicates the value
    stored in register `%ecx`. In contrast, M[`%eax`] indicates that the value inside
    `%eax` should be treated as an address, and to dereference (look up) the value
    at that address. Therefore, the operand `(%eax)` corresponds to M[0x804], which
    corresponds to the value 0xCA.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [表 8-2](ch08.xhtml#ch8tab2) 中，符号 `%ecx` 表示寄存器 `%ecx` 中存储的值。相比之下，M[`%eax`]
    表示将 `%eax` 中的值作为地址进行处理，并查找该地址中的值。因此，操作数 `(%eax)` 对应于 M[0x804]，其值为 0xCA。
- en: A few important notes before continuing. While [Table 8-2](ch08.xhtml#ch8tab2)
    shows many valid operand forms, not all forms can be used interchangeably in all
    circumstances.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，有几点重要说明。虽然 [表 8-2](ch08.xhtml#ch8tab2) 显示了许多有效的操作数形式，但并非所有形式都能在所有情况下互换使用。
- en: 'Specifically:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说：
- en: Constant forms cannot serve as destination operands.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量形式不能作为目标操作数。
- en: Memory forms cannot serve as *both* the source and destination operand in a
    single instruction.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存形式不能作为单条指令中的*源操作数*和*目标操作数*同时使用。
- en: In cases of scaling operations (refer to the last two operands shown in [Table
    8-2](ch08.xhtml#ch8tab2)), the scaling factor must be one of 1, 2, 4, or 8.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在缩放操作的情况下（参考 [表 8-2](ch08.xhtml#ch8tab2) 中显示的最后两个操作数），缩放因子必须是 1、2、4 或 8 之一。
- en: '[Table 8-2](ch08.xhtml#ch8tab2) is provided as a reference; however, understanding
    key operand forms will help improve the reader’s speed in parsing assembly language.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 8-2](ch08.xhtml#ch8tab2) 提供了参考，但理解关键的操作数形式将帮助读者提高解析汇编语言的速度。'
- en: 8.1.5 Instruction Suffixes
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.5 指令后缀
- en: In several cases in upcoming examples, common and arithmetic instructions have
    a suffix that indicates the *size* (associated with the *type*) of the data being
    operated on at the code level. The compiler automatically translates code to instructions
    with the appropriate suffix. [Table 8-3](ch08.xhtml#ch8tab3) shows the common
    suffixes for x86 instructions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个例子中，常见的算术指令会有一个后缀，表示在代码层面上操作的数据的 *大小*（与 *类型* 相关）。编译器会自动将代码翻译为带有适当后缀的指令。[表
    8-3](ch08.xhtml#ch8tab3) 展示了 x86 指令的常见后缀。
- en: '**Table 8-3:** Example Instruction Suffixes'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-3：** 示例指令后缀'
- en: '| **Suffix** | **C Type** | **Size (bytes)** |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| **后缀** | **C 类型** | **大小（字节）** |'
- en: '| b | `char` | 1 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| b | `char` | 1 |'
- en: '| w | `short` | 2 |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| w | `short` | 2 |'
- en: '| l | `int`, `long`, `unsigned` | 4 |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| l | `int`，`long`，`unsigned` | 4 |'
- en: Note that instructions involved with conditional execution have different suffixes
    based on the evaluated condition. We cover instructions associated with conditional
    instructions in “Conditional Control and Loops” on [page 310](ch07.xhtml#lev1_54).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，涉及条件执行的指令会根据评估的条件使用不同的后缀。我们将在“条件控制和循环”部分中讨论与条件指令相关的内容，详见 [第310页](ch07.xhtml#lev1_54)。
- en: 8.2 Common Instructions
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2 常见指令
- en: In this section, we discuss several common x86 assembly instructions. [Table
    8-4](ch08.xhtml#ch8tab4) lists the most foundational instructions in x86 assembly.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了几条常见的 x86 汇编指令。 [表 8-4](ch08.xhtml#ch8tab4) 列出了 x86 汇编中最基础的指令。
- en: '**Table 8-4:** Most Common Instructions'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-4：** 最常见的指令'
- en: '| **Instruction** | **Translation** |  |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **翻译** |  |'
- en: '| `mov S,D` | S → D | (copies value of S into D) |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `mov S,D` | S → D | （将 S 的值复制到 D） |'
- en: '| `add S,D` | S + D → D | (adds S to D and stores result in D) |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `add S,D` | S + D → D | （将 S 加到 D 并将结果存储到 D） |'
- en: '| `sub S,D` | D – S → D | (subtracts S *from* D and stores result in D) |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `sub S,D` | D – S → D | （从 D 中减去 S 并将结果存储到 D） |'
- en: Therefore, the sequence of instructions
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，指令序列
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'translates to:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译为：
- en: Copy the value at location `%ebp` + 0x8 in *memory* (or M[`%ebp` + 0x8]) to
    register `%eax`.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将内存中 `%ebp` + 0x8 位置的值（或 M[`%ebp` + 0x8]）复制到寄存器 `%eax`。
- en: Add the value 0x2 to register `%eax`, and store the result in register `%eax`.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将值 0x2 加到寄存器 `%eax`，并将结果存储到寄存器 `%eax` 中。
- en: The three instructions shown in [Table 8-4](ch08.xhtml#ch8tab4) also form the
    building blocks for instructions that maintain the organization of the program
    stack (i.e., the *call stack*). Recall that registers `%ebp` and `%esp` refer
    to the *frame* pointer and *stack* pointer, respectively, and are reserved by
    the compiler for call stack management. Recall from our earlier discussion on
    program memory in “Parts of Program Memory and Scope” on [page 64](ch02.xhtml#lev1_9)
    that the call stack stores local variables and parameters and helps the program
    track its own execution (see [Figure 8-1](ch08.xhtml#ch8fig1)).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 8-4](ch08.xhtml#ch8tab4) 中展示的三条指令也是构建保持程序堆栈结构的指令（即 *调用堆栈*）的基础模块。回想一下，寄存器
    `%ebp` 和 `%esp` 分别表示 *帧* 指针和 *栈* 指针，并由编译器保留用于调用堆栈管理。回顾我们在“程序内存及作用域”部分中讨论的内容（见
    [第64页](ch02.xhtml#lev1_9)），调用堆栈存储局部变量和参数，并帮助程序跟踪自身执行过程（见 [图 8-1](ch08.xhtml#ch8fig1)）。'
- en: '![image](../images/08fig01.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig01.jpg)'
- en: '*Figure 8-1: The parts of a program’s address space*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-1：程序地址空间的组成部分*'
- en: On IA32 systems, the execution stack grows toward *lower* addresses. Like all
    stack data structures, operations occur at the “top” of the stack. The x86 ISA
    provides two instructions ([Table 8-5](ch08.xhtml#ch8tab5)) to simplify call stack
    management.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IA32 系统中，执行栈朝 *较低* 地址方向增长。像所有栈数据结构一样，操作发生在栈的“顶部”。x86 ISA 提供了两条指令（[表 8-5](ch08.xhtml#ch8tab5)）来简化调用栈管理。
- en: '**Table 8-5:** Stack Management Instructions'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-5：** 栈管理指令'
- en: '| **Instruction** | **Translation** |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **翻译** |'
- en: '| `push S` | Pushes a copy of S onto the top of the stack. Equivalent to: |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `push S` | 将 S 的副本压入栈顶。等价于： |'
- en: '|  | `sub $4,%esp` |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '|  | `sub $4,%esp` |'
- en: '|  | `mov S,(%esp)` |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '|  | `mov S,(%esp)` |'
- en: '| `pop D` | Pops the top element off the stack and places it in location D.
    |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `pop D` | 弹出栈顶元素并将其放入位置 D。 |'
- en: '|  | Equivalent to: |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '|  | 等价于： |'
- en: '|  | `mov (%esp),D` |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '|  | `mov (%esp),D` |'
- en: '|  | `add $4,%esp` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '|  | `add $4,%esp` |'
- en: Notice that while the three instructions in [Table 8-4](ch08.xhtml#ch8tab4)
    require two operands, the `push` and `pop` instructions in [Table 8-5](ch08.xhtml#ch8tab5)
    require only one operand apiece.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，[表 8-4](ch08.xhtml#ch8tab4) 中的三条指令需要两个操作数，而[表 8-5](ch08.xhtml#ch8tab5)中的
    `push` 和 `pop` 指令每条只需要一个操作数。
- en: '8.2.1 Putting It All Together: A More Concrete Example'
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.1 将所有内容整合：一个更具体的例子
- en: Let’s take a closer look at the `adder2` function.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下 `adder2` 函数。
- en: '[PRE7]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'and its corresponding assembly code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以及其对应的汇编代码：
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The assembly code consists of a `push` instruction, followed by a couple of
    `mov` instructions, an `add` instruction, a `pop` instruction, and finally a `ret`
    instruction. To understand how the CPU executes this set of instructions, we need
    to revisit the structure of program memory (see “Parts of Program Memory and Scope”
    on [page 64](ch02.xhtml#lev1_9)). Recall that every time a program executes, the
    operating system allocates the new program’s address space (also known as *virtual
    memory*). Virtual memory and the related concept of processes are covered in greater
    detail in [Chapter 13](ch13.xhtml#ch13); for now, it suffices to think of a process
    as the abstraction of a running program and virtual memory as the memory that
    is allocated to a single process. Every process has its own region of memory called
    the *call stack*. Keep in mind that the call stack is located in process/virtual
    memory, unlike registers (which are located on the CPU).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编代码由一条 `push` 指令开始，接着是几条 `mov` 指令、一个 `add` 指令、一条 `pop` 指令，最后是一个 `ret` 指令。为了理解
    CPU 如何执行这组指令，我们需要回顾程序内存的结构（参见[第 64 页](ch02.xhtml#lev1_9)的“程序内存的各个部分与作用域”）。回想一下，每次程序执行时，操作系统都会为新程序分配地址空间（也称为
    *虚拟内存*）。虚拟内存和相关的进程概念将在[第 13 章](ch13.xhtml#ch13)中更详细地介绍；目前，只需把进程看作是正在运行的程序的抽象，虚拟内存看作是为单个进程分配的内存。每个进程都有自己的一块内存区域，称为
    *调用栈*。请记住，调用栈位于进程/虚拟内存中，而寄存器则位于 CPU 上。
- en: '[Figure 8-2](ch08.xhtml#ch8fig2) depicts a sample state of the call stack and
    registers prior to the execution of the `adder2` function.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-2](ch08.xhtml#ch8fig2) 展示了 `adder2` 函数执行前调用栈和寄存器的示例状态。'
- en: '![image](../images/08fig02.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig02.jpg)'
- en: '*Figure 8-2: Execution stack prior to execution*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-2：执行前的执行栈*'
- en: Notice that the stack grows toward *lower* addresses. Registers `%eax` and `%edx`
    currently contain junk values. The addresses associated with the instructions
    in the code segment of program memory (0x804840b–0x8048415) have been shortened
    to 0x40b–0x415 to improve figure readability. Likewise, the addresses associated
    with the call stack segment of program memory have been shortened to 0x108–0x110
    from 0xffffd108–0xffffd110\. In truth, call stack addresses occur at higher addresses
    in program memory than code segment addresses.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，栈朝 *较低* 地址方向增长。寄存器 `%eax` 和 `%edx` 当前包含垃圾值。程序内存中代码段的指令地址（0x804840b–0x8048415）已缩短为
    0x40b–0x415，以提高图示的可读性。同样，程序内存中调用栈段的地址已从 0xffffd108–0xffffd110 缩短为 0x108–0x110。实际上，调用栈的地址位于程序内存中比代码段地址更高的位置。
- en: 'Pay close attention to the initial (made up) values of registers `%esp` and
    `%ebp`: they are 0x10c and 0x12a, respectively. The call stack currently has the
    value 0x28 (or 40) at stack address 0x110 (why and how this got here will be covered
    in our discussion on “Functions in Assembly” on [page 326](ch07.xhtml#lev1_55)).
    The upper-left arrow in the following figures visually indicates the currently
    executing instruction. The `%eip` register (or instruction pointer) shows the
    next instruction to execute. Initially, `%eip` contains address 0x40b, which corresponds
    to the first instruction in the `adder2` function.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请特别注意寄存器 `%esp` 和 `%ebp` 的初始（假设）值：分别为 0x10c 和 0x12a。当前调用栈在栈地址 0x110 处存储着值 0x28（或
    40）（为什么和如何存储到这里的将在我们关于“汇编中的函数”讨论中，详见 [第 326 页](ch07.xhtml#lev1_55)）。以下图中的左上箭头直观地表示当前正在执行的指令。`%eip`
    寄存器（或指令指针）显示下一条要执行的指令。最初，`%eip` 包含地址 0x40b，这对应于 `adder2` 函数中的第一条指令。
- en: '![image](../images/f0387-01.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0387-01.jpg)'
- en: 'The first instruction (`push %ebp`) places a copy of the value in `%ebp` (or
    0x12a) on top of the stack. After it executes, the `%eip` register advances to
    the address of the next instruction to execute (or 0x40c). The `push` instruction
    decrements the stack pointer by 4 (“growing” the stack by 4 bytes), resulting
    in a new `%esp` value of 0x108\. Recall that the `push %ebp` instruction is equivalent
    to:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条指令（`push %ebp`）将 `%ebp`（或 0x12a）中的值复制到栈顶。执行后，`%eip` 寄存器指向下一条要执行的指令的地址（或 0x40c）。`push`
    指令将栈指针减小 4（即栈“增长”了 4 字节），导致新的 `%esp` 值为 0x108。回想一下，`push %ebp` 指令等同于：
- en: '[PRE9]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In other words, subtract 4 from the stack pointer and place a copy of the contents
    of `%ebp` in the location pointed to by the dereferenced stack pointer, `(%esp)`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，从栈指针中减去 4，并将 `%ebp` 寄存器的内容复制到栈指针所指向的位置 `(%esp)` 中。
- en: '![image](../images/f0388-01.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0388-01.jpg)'
- en: Recall that the structure of the `mov` instruction is `mov S,D`, where S is
    the source location, and D is the destination. Thus, the next instruction (`mov`
    `%esp,%ebp`) updates the value of `%ebp` to 0x108\. The register `%eip` advances
    to the address of the next instruction to execute, or 0x40e.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`mov` 指令的结构是 `mov S,D`，其中 S 是源位置，D 是目标位置。因此，下一条指令（`mov` `%esp,%ebp`）将 `%ebp`
    的值更新为 0x108。寄存器 `%eip` 前进到下一条要执行的指令的地址，即 0x40e。
- en: '![image](../images/f0388-02.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0388-02.jpg)'
- en: Next, `mov 0x8(%ebp),%eax` is executed. This is a bit more complicated than
    the last `mov` instruction. Let’s parse it by consulting the operand table from
    the previous section. First, `0x8(%ebp)` translates to M[`%ebp` + 0x8]. Since
    `%ebp` contains the value 0x108, adding 8 to it yields 0x110\. Performing a (stack)
    memory lookup on 0x110 yields the value 0x28 (recall that 0x28 was placed on the
    stack by previous code). So, the value 0x28 is copied into register `%eax`. The
    instruction pointer advances to address 0x411, the next address to be executed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来执行的是 `mov 0x8(%ebp),%eax`。这比上条 `mov` 指令要复杂一些。让我们通过查阅上一节的操作数表来解析它。首先，`0x8(%ebp)`
    解释为 M[`%ebp` + 0x8]。由于 `%ebp` 包含 0x108，将 8 加到它上面得到 0x110。对 0x110 进行（栈）内存查找得到的值是
    0x28（回想一下，0x28 是之前的代码将其放置到栈上的）。因此，0x28 被复制到寄存器 `%eax` 中。指令指针 `%eip` 前进到地址 0x411，即下一条要执行的地址。
- en: '![image](../images/f0389-01.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0389-01.jpg)'
- en: Afterward, `add $0x2,%eax` is executed. Recall that the `add` instruction has
    the form `add S,D` and places the quantity S + D in the destination D. So, `add`
    `$0x2,%eax` adds the constant value 0x2 to the value stored in `%eax` (or 0x28),
    resulting in 0x2A being stored in register `%eax`. Register `%eip` advances to
    point to the next instruction to be executed, or 0x414.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 随后执行的是 `add $0x2,%eax`。回想一下，`add` 指令的形式是 `add S,D`，它将 S + D 的结果存放到目标 D 中。所以，`add`
    `$0x2,%eax` 将常量值 0x2 加到存储在 `%eax` 中的值（或 0x28）上，结果是 0x2A 被存入寄存器 `%eax` 中。寄存器 `%eip`
    前进到指向下一条要执行的指令的地址，即 0x414。
- en: '![image](../images/f0389-02.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0389-02.jpg)'
- en: 'The next instruction that executes is `pop %ebp`. This instruction “pops” a
    value off the call stack and places it in destination register `%ebp`. Recall
    that this instruction is equivalent to the following sequence of two instructions:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条执行的指令是 `pop %ebp`。这条指令将从调用栈中“弹出”一个值，并将其放入目标寄存器 `%ebp` 中。回想一下，这条指令等同于以下两条指令的序列：
- en: '[PRE10]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After this instruction executes, the value at the top of the stack `(%esp)`
    or M[0x108] is copied into register `%ebp`. Thus, `%ebp` now contains the value
    0x12a. The stack pointer *increments* by 4, since the stack grows toward lower
    addresses (and consequently, *shrinks* toward higher ones). The new value of `%esp`
    is 0x10c, and `%eip` now points to the address of the last instruction to execute
    in this code snippet (0x415).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此指令后，栈顶（`%esp`）或M[0x108]的值被复制到寄存器`%ebp`中。因此，`%ebp`现在包含值0x12a。由于栈向较低地址增长（因此，*向上缩小*），栈指针`%esp`*增加*了4。`%esp`的新值是0x10c，`%eip`现在指向此代码片段中最后一条要执行的指令的地址（0x415）。
- en: The last instruction executed is `ret`. We will talk more about what happens
    with `ret` in future sections when we discuss function calls, but for now it suffices
    to know that it prepares the call stack for returning from a function. By convention,
    the register `%eax` always contains the return value (if one exists). In this
    case, the function returns the value 0x2A, which corresponds to the decimal value
    42.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后执行的指令是`ret`。我们将在未来的章节中讨论`ret`的执行情况，特别是在讲解函数调用时，但现在需要知道的是，它为从函数返回准备了调用栈。根据惯例，寄存器`%eax`始终包含返回值（如果存在）。在本例中，函数返回值是0x2A，对应的十进制值是42。
- en: Before we continue, note that the final values in registers `%esp` and `%ebp`
    are 0x10c and 0x12a, respectively, which are the *same values as when the function
    started executing*! This is normal and expected behavior with the call stack.
    The purpose of the call stack is to store the temporary variables and data of
    each function as it executes in the context of a program. Once a function completes
    executing, the stack returns to the state it was in prior to the function call.
    As a result, you will commonly see the following two instructions at the beginning
    of a function.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请注意，寄存器`%esp`和`%ebp`的最终值分别为0x10c和0x12a，这些值*与函数开始执行时相同*！这是调用栈的正常行为。调用栈的目的是在函数执行过程中存储每个函数的临时变量和数据。一旦函数执行完成，栈将恢复到函数调用前的状态。因此，您通常会在函数的开头看到以下两个指令。
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'and the following two instructions at the end of every function:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 并且在每个函数的结尾处有以下两个指令：
- en: '[PRE12]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 8.3 Arithmetic Instructions
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3 算术指令
- en: The IA32 ISA implements several instructions that correspond to arithmetic operations
    performed by the ALU. [Table 8-6](ch08.xhtml#ch8tab6) lists several arithmetic
    instructions that one may encounter when reading assembly.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: IA32指令集架构（ISA）实现了几条与算术运算相关的指令，这些运算由算术逻辑单元（ALU）执行。[表8-6](ch08.xhtml#ch8tab6)列出了在阅读汇编时可能会遇到的几条算术指令。
- en: '**Table 8-6:** Common Arithmetic Instructions'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**表8-6：** 常见的算术指令'
- en: '| **Instruction** | **Translation** |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **翻译** |'
- en: '| `add S, D` | S + D → D |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `add S, D` | S + D → D |'
- en: '| `sub S, D` | D – S → D |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `sub S, D` | D - S → D |'
- en: '| `inc D` | D + 1 → D |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `inc D` | D + 1 → D |'
- en: '| `dec D` | D – 1 → D |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `dec D` | D - 1 → D |'
- en: '| `neg D` | –D → D |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `neg D` | -D → D |'
- en: '| `imul S, D` | S × D → D |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `imul S, D` | S × D → D |'
- en: '| `idiv S` | `%eax` / S: quotient → `%eax`, remainder → `%edx` |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `idiv S` | `%eax` / S: 商 → `%eax`, 余数 → `%edx` |'
- en: The `add` and `sub` instructions correspond to addition and subtraction and
    take two operands each. The next three entries show the single-register instructions
    for the increment (`x++`), decrement (`x--`), and negation (`-x`) operations in
    C. The multiplication instruction operates on two operands and places the product
    in the destination. If the product requires more than 32 bits to represent, the
    value will be truncated to 32 bits.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`add`和`sub`指令对应加法和减法，每个指令需要两个操作数。接下来的三条条目显示了单寄存器指令，分别对应C语言中的自增（`x++`）、自减（`x--`）和取负（`-x`）操作。乘法指令作用于两个操作数，将积存入目标寄存器。如果积需要超过32位来表示，结果将被截断为32位。'
- en: The division instruction works a little differently. Prior to the execution
    of the `idiv` instruction, it is assumed that register `%eax` contains the dividend.
    Calling `idiv` on operand S divides the contents of `%eax` by S and places the
    quotient in register `%eax`, and the remainder in register `%edx`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 除法指令的工作方式略有不同。在执行`idiv`指令之前，假定寄存器`%eax`包含被除数。对操作数S执行`idiv`时，将`%eax`的内容除以S，并将商存入寄存器`%eax`，余数存入寄存器`%edx`。
- en: 8.3.1 Bit Shifting Instructions
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.1 位移指令
- en: Bit shifting instructions enable the compiler to perform bit shifting operations.
    Multiplication and division instructions typically take a long time to execute.
    Bit shifting offers the compiler a shortcut for multiplicands and divisors that
    are powers of 2\. For example, to compute `77 * 4`, most compilers will translate
    this operation to `77 ≪ 2` to avoid the use of an `imul` instruction. Likewise,
    to compute `77 / 4`, a compiler typically translates this operation to `77 ≫ 2`
    to avoid using the `idiv` instruction.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 位移指令使编译器能够执行位移操作。乘法和除法指令通常需要较长时间才能执行。位移为编译器提供了一种针对2的幂次方的乘法因子和除数的快捷方式。例如，要计算`77
    * 4`，大多数编译器会将此操作转换为`77 ≪ 2`，以避免使用`imul`指令。同样，要计算`77 / 4`，编译器通常将此操作转换为`77 ≫ 2`，以避免使用`idiv`指令。
- en: Keep in mind that left and right bit shift translate to different instructions
    based on whether the goal is an arithmetic (signed) or logical (unsigned) shift.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，左位移和右位移根据目标是算术（有符号）还是逻辑（无符号）位移，翻译为不同的指令。
- en: '**Table 8-7:** Bit Shift Instructions'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-7：** 位移指令'
- en: '| **Instruction** | **Translation** | **Arithmetic or logical?** |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **翻译** | **算术或逻辑？** |'
- en: '| `sal v, D` | D `≪` v → D | arithmetic |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `sal v, D` | D `≪` v → D | 算术 |'
- en: '| `shl v, D` | D `≪` v → D | logical |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `shl v, D` | D `≪` v → D | 逻辑 |'
- en: '| `sar v, D` | D `≫` v → D | arithmetic |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `sar v, D` | D `≫` v → D | 算术 |'
- en: '| `shr v, D` | D `≫` v → D | logical |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `shr v, D` | D `≫` v → D | 逻辑 |'
- en: Each shift instruction take two operands, one which is usually a register (denoted
    by D), and the other which is a shift value (*v*). On 32-bit systems, the shift
    value is encoded as a single byte (since it doesn’t make sense to shift past 31).
    The shift value *v* must either be a constant or stored in register `%cl`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 每个位移指令都有两个操作数，其中一个通常是寄存器（用 D 表示），另一个是位移值（*v*）。在32位系统上，位移值作为单个字节进行编码（因为位移超过31是没有意义的）。位移值
    *v* 必须是常量或存储在寄存器`%cl`中。
- en: '**Note DIFFERENT VERSIONS OF INSTRUCTIONS HELP DISTINGUISH TYPES AT AN ASSEMBLY
    LEVEL**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：不同版本的指令帮助区分汇编层级的类型**'
- en: At the assembly level, there is no notion of types. However, recall that shift
    right works differently depending on whether or not the value is signed. At the
    assembly level, the compiler uses separate instructions to distinguish between
    logical and arithmetic shifts!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编层级，没有类型的概念。然而，请记住，右移操作的行为取决于值是否有符号。在汇编层级，编译器使用不同的指令来区分逻辑位移和算术位移！
- en: 8.3.2 Bitwise Instructions
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.2 位运算指令
- en: Bitwise instructions enable the compiler to perform bitwise operations on data.
    One way the compiler uses bitwise operations is for certain optimizations. For
    example, a compiler may choose to implement 77 mod 4 with the operation `77 &`
    `3` in lieu of the more expensive `idiv` instruction.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 位运算指令使编译器能够对数据执行按位操作。编译器使用位运算的一种方式是进行某些优化。例如，编译器可能选择用操作`77 &` `3`来实现77除以4，而不是使用更昂贵的`idiv`指令。
- en: '[Table 8-8](ch08.xhtml#ch8tab8) lists common bitwise instructions.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 8-8](ch08.xhtml#ch8tab8)列出了常见的位运算指令。'
- en: '**Table 8-8:** Bitwise Operations'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-8：** 位运算'
- en: '| **Instruction** | **Translation** |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **翻译** |'
- en: '| `and S,D` | S `&` D → D |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `与 S,D` | S `&` D → D |'
- en: '| `or S,D` | S `&#124;` D → D |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `或 S,D` | S `&#124;` D → D |'
- en: '| `xor S,D` | S `^` D → D |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `异或 S,D` | S `^` D → D |'
- en: '| `not D` | `~`D → D |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `not D` | `~`D → D |'
- en: Remember that bitwise `not` is distinct from negation (`neg`). The `not` instruction
    flips the bits, but does not add 1\. Be careful not to confuse these two instructions.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，位运算的`not`与否定（`neg`）是不同的。`not`指令翻转位，但不加1。小心不要混淆这两条指令。
- en: '**Warning USE BITWISE OPERATIONS ONLY WHEN NEEDED IN YOUR C CODE!**'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告：仅在需要时在 C 代码中使用位运算！**'
- en: After reading this section, it may be tempting to replace common arithmetic
    operations in your C code with bitwise shifts and other operations. This is *not*
    recommended. Most modern compilers are smart enough to replace simple arithmetic
    operations with bitwise operations when it makes sense, making it unnecessary
    for the programmer to do so. As a general rule, programmers should prioritize
    code readability whenever possible and avoid premature optimization.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本节后，可能会有冲动想将 C 代码中的常见算术运算替换为位移和其他位运算。*不*推荐这样做。大多数现代编译器足够智能，能够在合适的时候将简单的算术运算替换为位运算，因此程序员无需手动做这些替换。一般而言，程序员应尽可能优先考虑代码可读性，避免过早优化。
- en: 8.3.3 The Load Effective Address Instruction
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.3 加载有效地址指令
- en: '*What’s lea got to do (got to do) with it?*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*“lea 和它有什么关系呢？”*'
- en: '*What’s lea, but an effective address loading?*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*`lea`是什么？不过是有效地址加载而已！*'
- en: —With apologies to Tina Turner
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: —致歉，Tina Turner
- en: We finally come to the *load effective address* or `lea` instruction, which
    is probably the arithmetic instruction that causes students the most consternation.
    It is traditionally used as a fast way to compute the address of a location in
    memory. The `lea` instruction operates on the same operand structure that we’ve
    seen thus far but does *not* include a memory lookup. Regardless of the type of
    data contained in the operand (whether it be a constant value or an address),
    `lea` simply performs arithmetic.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于来到了*加载有效地址*（load effective address）指令，简称`lea`，这可能是让学生最困惑的算术指令。它通常用作快速计算内存位置地址的方式。`lea`指令与我们到目前为止见过的操作数结构相同，但*不*包括内存查找。无论操作数中包含的是常量值还是地址，`lea`仅执行算术运算。
- en: For example, suppose that register `%eax` contains the constant value 0x5, register
    `%edx` contains the constant value 0x4, and register `%ecx` contains the value
    0x808 (which happens to be an address). [Table 8-9](ch08.xhtml#ch8tab9) gives
    some example `lea` operations, their translations, and corresponding values.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设寄存器`%eax`包含常量值0x5，寄存器`%edx`包含常量值0x4，寄存器`%ecx`包含值0x808（恰好是一个地址）。[表 8-9](ch08.xhtml#ch8tab9)给出了一些`lea`操作的示例，它们的翻译以及相应的值。
- en: '**Table 8-9:** Example lea Operations'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-9：** `lea` 操作示例'
- en: '| **Instruction** | **Translation** | **Value** |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **翻译** | **值** |'
- en: '| `lea 8(%eax), %eax` | 8 + `%eax` → `%eax` | 13 → `%eax` |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `lea 8(%eax), %eax` | 8 + `%eax` → `%eax` | 13 → `%eax` |'
- en: '| `lea (%eax, %edx), %eax` | `%eax` + `%edx` → `%eax` | 9 → `%eax` |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `lea (%eax, %edx), %eax` | `%eax` + `%edx` → `%eax` | 9 → `%eax` |'
- en: '| `lea (,%eax,4), %eax` | `%eax` × 4 → `%eax` | 20 → `%eax` |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `lea (,%eax,4), %eax` | `%eax` × 4 → `%eax` | 20 → `%eax` |'
- en: '| `lea -0x8(%ecx), %eax` | `%ecx` – `8` → `%eax` | 0x800 → `%eax` |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `lea -0x8(%ecx), %eax` | `%ecx` – `8` → `%eax` | 0x800 → `%eax` |'
- en: '| `lea -0x4(%ecx, %edx, 2), %eax` | `%ecx` + `%edx` × 2 – 4 → `%eax` | 0x80c
    → `%eax` |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `lea -0x4(%ecx, %edx, 2), %eax` | `%ecx` + `%edx` × 2 – 4 → `%eax` | 0x80c
    → `%eax` |'
- en: In all cases, the `lea` instruction performs arithmetic on the operand specified
    by the source S and places the result in the destination operand D. The `mov`
    instruction is identical to the `lea` instruction *except* that the `mov` instruction
    is *required* to treat the contents in the source operand as a memory location
    if it is in a memory form. In contrast, `lea` performs the same (sometimes complicated)
    operand arithmetic *without* the memory lookup, enabling the compiler to cleverly
    use `lea` as a substitution for some types of arithmetic.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，`lea`指令对由源操作数 S 指定的操作数执行算术运算，并将结果放入目标操作数 D 中。`mov`指令与`lea`指令相同，*唯一的区别*是`mov`指令*必须*将源操作数中的内容视为内存位置，如果它是内存形式。而`lea`执行相同（有时复杂的）操作数算术，*无需*内存查找，从而使得编译器可以巧妙地将`lea`作为某些类型算术运算的替代。
- en: 8.4 Conditional Control and Loops
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4 条件控制与循环
- en: This section covers assembly instructions for conditionals and loops (see “Conditionals
    and Loops” on [page 30](ch01.xhtml#lev1_3)). Recall that conditional statements
    enable coders to modify program execution based on the result of a conditional
    expression. The compiler translates conditionals into assembly instructions that
    modify the instruction pointer (`%eip`) to point to an address that is not the
    next one in the program sequence.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了与条件语句和循环相关的汇编指令（参见[第30页](ch01.xhtml#lev1_3)的“条件语句与循环”）。回想一下，条件语句使得程序员可以根据条件表达式的结果修改程序执行。编译器将条件语句转换为汇编指令，这些指令会修改指令指针（`%eip`），使其指向一个不同于程序顺序下一个地址的地址。
- en: 8.4.1 Preliminaries
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.1 前提条件
- en: Conditional Comparison Instructions
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 条件比较指令
- en: Comparison instructions perform an arithmetic operation for the purpose of guiding
    the conditional execution of a program. [Table 8-10](ch08.xhtml#ch8tab10) lists
    the basic instructions associated with conditional control.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 比较指令执行算术运算，目的是指导程序的条件执行。[表 8-10](ch08.xhtml#ch8tab10)列出了与条件控制相关的基本指令。
- en: '**Table 8-10:** Conditional Control Instructions'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-10：** 条件控制指令'
- en: '| **Instruction** | **Translation** |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **翻译** |'
- en: '| `cmp R1, R2` | Compares R2 with R1 (i.e., evaluates R2 – R1) |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `cmp R1, R2` | 比较 R2 与 R1（即，计算 R2 – R1） |'
- en: '| `test R1, R2` | Computes R1 & R2 |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `test R1, R2` | 计算 R1 & R2 |'
- en: 'The `cmp` instruction compares the values of two registers, R2 and R1\. Specifically,
    it subtracts R1 from R2\. The `test` instruction performs bitwise AND. It is common
    to see an instruction like:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmp` 指令比较两个寄存器 R2 和 R1 的值。具体来说，它将 R1 从 R2 中减去。`test` 指令执行按位与运算。常见的指令形式如下：'
- en: '[PRE13]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this example, the bitwise AND of `%eax` with itself is zero only when `%eax`
    contains zero. In other words, this is a test for a zero value and is equivalent
    to the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`%eax` 和其自身的按位与运算仅当 `%eax` 为零时结果为零。换句话说，这是对零值的测试，等价于以下内容：
- en: '[PRE14]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Unlike the arithmetic instructions covered thus far, `cmp` and `test` do not
    modify the destination register. Instead, both instructions modify a series of
    single-bit values known as *condition code flags*. For example, `cmp` will modify
    condition code flags based on whether the value R2 – R1 results in a positive
    (greater), negative (less), or zero (equal) value. Recall that condition code
    values encode information about an operation in the ALU (see “The ALU” on [page
    261](ch05.xhtml#lev2_100)). The condition code flags are part of the `FLAGS` register
    on x86 systems.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前介绍的算术指令不同，`cmp` 和 `test` 不会修改目标寄存器。相反，这两个指令会修改一系列被称为 *条件码标志* 的单比特值。例如，`cmp`
    会根据 R2 – R1 的结果是正值（大于）、负值（小于）还是零（相等）来修改条件码标志。回想一下，条件码值编码了 ALU 操作的信息（详见 [第261页](ch05.xhtml#lev2_100)的“ALU”）。这些条件码标志是
    x86 系统上 `FLAGS` 寄存器的一部分。
- en: '**Table 8-11:** Common Condition Code Flags'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-11：** 常见条件码标志'
- en: '| **Flag** | **Translation** |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| **标志** | **翻译** |'
- en: '| `ZF` | Is equal to zero (1: yes; 0: no) |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `ZF` | 等于零（1：是；0：否） |'
- en: '| `SF` | Is negative (1: yes; 0: no) |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `SF` | 为负（1：是；0：否） |'
- en: '| `OF` | Overflow has occurred (1: yes; 0: no) |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `OF` | 已发生溢出（1：是；0：否） |'
- en: '| `CF` | Arithmetic carry has occurred (1: yes; 0: no) |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `CF` | 已发生算术进位（1：是；0：否） |'
- en: '[Table 8-11](ch08.xhtml#ch8tab11) depicts the common flags used for condition
    code operations. Revisiting the `cmp R1, R2` instruction:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 8-11](ch08.xhtml#ch8tab11) 展示了常用的条件码操作标志。回顾一下 `cmp R1, R2` 指令：'
- en: The `ZF` flag is set to 1 if R1 and R2 are equal.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 R1 和 R2 相等，则 `ZF` 标志被设置为 1。
- en: The `SF` flag is set to 1 if R2 is *less* than `R1` (R2 – R1 results in a negative
    value).
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 R2 小于 `R1`（R2 – R1 结果为负值），则 `SF` 标志被设置为 1，且 R2 *小于* `R1`。
- en: The `OF` flag is set to 1 if the operation R2 – R1 results in an integer overflow
    (useful for signed comparisons).
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果操作 R2 – R1 结果为整数溢出（对有符号比较有用），则 `OF` 标志被设置为 1。
- en: The `CF` flag is set to 1 if the operation R2 – R1 results in a carry operation
    (useful for unsigned comparisons).
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果操作 R2 – R1 结果为进位操作（对无符号比较有用），则 `CF` 标志被设置为 1。
- en: The `SF` and `OF` flags are used for comparison operations on signed integers,
    whereas the `CF` flag is used for comparisons on unsigned integers. Although an
    in-depth discussion of condition code flags is beyond the scope of this book,
    the setting of these registers by `cmp` and `test` enables the next set of instructions
    we cover (the *jump* instructions) to operate correctly.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`SF` 和 `OF` 标志用于有符号整数的比较操作，而 `CF` 标志用于无符号整数的比较。虽然深入讨论条件码标志超出了本书的范围，但 `cmp`
    和 `test` 指令的设置使得我们接下来要讲解的指令（*跳转*指令）能够正确运行。'
- en: Jump Instructions
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 跳转指令
- en: A jump instruction enables a program’s execution to “jump” to a new position
    in the code. In the assembly programs we have traced through thus far, `%eip`
    always points to the next instruction in program memory. The jump instructions
    enable `%eip` to be set to either a new instruction not yet seen (as in the case
    of an `if` statement) or to a previously executed instruction (as in the case
    of a loop).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 跳转指令使程序的执行能够“跳跃”到代码中的新位置。在我们到目前为止追踪的汇编程序中，`%eip` 始终指向程序内存中的下一条指令。跳转指令使得 `%eip`
    可以被设置为一个新的尚未执行的指令（如 `if` 语句的情况），或是一个之前已执行过的指令（如循环的情况）。
- en: '**Table 8-12:** Direct Jump Instructions'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-12：** 直接跳转指令'
- en: '| **Instruction** | **Description** |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **描述** |'
- en: '| `jmp L` | Jump to location specified by L |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| `jmp L` | 跳转到由 L 指定的位置 |'
- en: '| `jmp *addr` | Jump to specified address |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `jmp *addr` | 跳转到指定的地址 |'
- en: '**Direct jump instructions.**   [Table 8-12](ch08.xhtml#ch8tab12) lists the
    set of direct jump instructions; `L` refers to a *symbolic label*, which serves
    as an identifier in the program’s object file. All labels consist of some letters
    and digits followed by a colon. Labels can be *local* or *global* to an object
    file’s scope. Function labels tend to be *global* and usually consist of the function
    name and a colon. For example, `main:` (or `<main>:`) is used to label a user-defined
    `main` function. In contrast, labels whose scope are *local* are preceded by a
    period. For example, `.L1:` is a local label one may encounter in the context
    of an `if` statement or loop.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**直接跳转指令。** [表 8-12](ch08.xhtml#ch8tab12)列出了直接跳转指令集；`L`代表*符号标签*，它是程序目标文件中的标识符。所有标签由字母和数字组成，后跟冒号。标签可以是*本地*的，也可以是*全局*的，取决于目标文件的作用域。函数标签通常是*全局*的，通常由函数名和冒号组成。例如，`main:`（或`<main>:`）用于标记用户定义的`main`函数。相比之下，作用域为*本地*的标签前面会有一个句点。例如，`.L1:`是一个可能出现在`if`语句或循环中的本地标签。'
- en: All labels have an associated address. When the CPU executes a `jmp` instruction,
    it modifies `%eip` to reflect the program address specified by label `L`. A programmer
    writing assembly can also specify a particular address to jump to using the `jmp
    *` instruction. Sometimes, local labels are shown as an offset from the start
    of a function. Therefore, an instruction whose address is 28 bytes away from the
    start of `main` may be represented with the label `<main+28>`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 所有标签都有一个关联的地址。当CPU执行`jmp`指令时，它会修改`%eip`以反映标签`L`所指定的程序地址。编写汇编代码的程序员也可以使用`jmp
    *`指令指定要跳转到的特定地址。有时，本地标签显示为相对于函数开始的偏移量。因此，地址距离`main`开始28字节的指令可以用标签`<main+28>`表示。
- en: For example, the instruction `jmp 0x8048427 <main+28>` indicates a jump to address
    0x8048427, which has the associated label `<main+28>`, representing that it is
    28 bytes away from the starting address of the `main` function. Executing this
    instruction sets `%eip` to 0x8048427.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，指令`jmp 0x8048427 <main+28>`表示跳转到地址0x8048427，该地址具有关联标签`<main+28>`，表示它距离`main`函数的起始地址28字节。执行该指令会将`%eip`设置为0x8048427。
- en: '**Conditional jump instructions.**   The behavior of conditional jump instructions
    depends on the condition code registers set by the `cmp` instruction. [Table 8-13](ch08.xhtml#ch8tab13)
    lists the set of common conditional jump instructions. Each instruction starts
    with the letter `j` denoting that it is a jump instruction. The suffix of each
    instruction indicates the *condition* for the jump. The jump instruction suffixes
    also determine whether to interpret numerical comparisons as signed or unsigned.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**条件跳转指令。** 条件跳转指令的行为取决于由`cmp`指令设置的条件码寄存器。[表 8-13](ch08.xhtml#ch8tab13)列出了常见的条件跳转指令集。每条指令以字母`j`开头，表示它是一条跳转指令。每条指令的后缀表示跳转的*条件*。跳转指令的后缀还决定了是否将数值比较解释为有符号或无符号。'
- en: '**Table 8-13:** Conditional Jump Instructions; Synonyms Shown in Parentheses'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-13：** 条件跳转指令；括号中的同义词'
- en: '| **Signed Comparison** | **Unsigned Comparison** | **Description** |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| **有符号比较** | **无符号比较** | **描述** |'
- en: '| `je` (`jz`) |  | jump if equal (==) or jump if zero |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `je` (`jz`) |  | 等于时跳转 (==) 或零时跳转 |'
- en: '| `jne` (`jnz`) |  | jump if not equal (!=) |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `jne` (`jnz`) |  | 不等时跳转 (!=) |'
- en: '| `js` |  | jump if negative |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `js` |  | 负数时跳转 |'
- en: '| `jns` |  | jump if non-negative |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `jns` |  | 非负时跳转 |'
- en: '| `jg` (`jnle`) | `ja` (`jnbe`) | jump if greater (>) |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `jg` (`jnle`) | `ja` (`jnbe`) | 大于时跳转 (>) |'
- en: '| `jge` (`jnl`) | `jae` (`jnb`) | jump if greater than or equal (>=) |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `jge` (`jnl`) | `jae` (`jnb`) | 大于或等于时跳转 (>=) |'
- en: '| `jl` (`jnge`) | `jb` (`jnae`) | jump if less (<) |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `jl` (`jnge`) | `jb` (`jnae`) | 小于时跳转 (<) |'
- en: '| `jle` (`jng`) | `jbe` (`jna`) | jump if less than or equal (<=) |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `jle` (`jng`) | `jbe` (`jna`) | 小于或等于时跳转 (<=) |'
- en: Instead of memorizing these different conditional jump instructions, it is more
    helpful to sound out the instruction suffixes. [Table 8-14](ch08.xhtml#ch8tab14)
    lists the letters commonly found in jump instructions and their word correspondence.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 与其记住这些不同的条件跳转指令，不如通过发音来记住指令后缀。[表 8-14](ch08.xhtml#ch8tab14)列出了常见的跳转指令中的字母及其对应的单词。
- en: '**Table 8-14:** Jump Instruction Suffixes'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-14：** 跳转指令后缀'
- en: '| **Letter** | **Word** |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| **字母** | **单词** |'
- en: '| `j` | jump |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `j` | 跳转 |'
- en: '| `n` | not |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `n` | 不 |'
- en: '| `e` | equal |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `e` | 等于 |'
- en: '| `s` | signed |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `s` | 有符号 |'
- en: '| `g` | greater (signed interpretation) |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `g` | 大于（有符号解释） |'
- en: '| `l` | less (signed interpretation) |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `l` | 小于（有符号解释） |'
- en: '| `a` | above (unsigned interpretation) |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `a` | 高于（无符号解释） |'
- en: '| `b` | below (unsigned interpretation) |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| `b` | below（无符号解释） |'
- en: Sounding it out, we can see that `jg` corresponds to *jump greater* and that
    its signed synonym `jnl` stands for *jump not less*. Likewise, the unsigned version
    `ja` stands for *jump above*, while its synonym `jnbe` stands for *jump not below
    or equal*.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 读出来后，我们可以看到`jg`对应于*jump greater*，而它的有符号同义词`jnl`代表*jump not less*。同样，无符号版本`ja`代表*jump
    above*，而它的同义词`jnbe`代表*jump not below or equal*。
- en: If you sound out the instructions, it helps to explain why certain synonyms
    correspond to particular instructions. The other thing to remember is that the
    terms *greater* and *less* instruct the CPU to interpret the numerical comparison
    as a signed value, whereas *above* and *below* indicate that the numerical comparison
    is unsigned.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你把指令读出来，它有助于解释为什么某些同义词对应特定的指令。另一个需要记住的点是，术语*greater*和*less*指示CPU将数值比较解释为有符号值，而*above*和*below*则表示数值比较是无符号的。
- en: The goto Statement
  id: totrans-257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`goto`语句'
- en: In the following subsections, we look at conditionals and loops in assembly
    and reverse engineer them back to C. When translating assembly code of conditionals
    and loops back into C, it is useful to understand the corresponding C language
    `goto` forms. The `goto` statement is a C primitive that forces program execution
    to switch to another line in the code. The assembly instruction associated with
    the `goto` statement is `jmp`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的子节中，我们将查看汇编语言中的条件语句和循环，并将其反向工程为C语言。当将汇编代码的条件语句和循环转换回C语言时，了解相应的C语言`goto`形式是很有帮助的。`goto`语句是C语言中的一种原语，它强制程序执行跳转到代码中的另一行。与`goto`语句相关的汇编指令是`jmp`。
- en: The `goto` statement consists of the `goto` keyword followed by a *goto label*,
    a type of program label that indicates where execution should continue. So, `goto
    done` means that the program execution should jump to the line marked by label
    `done`. Other examples of program labels in C include the `switch` statement labels
    previously covered in “switch Statements” on [page 122](ch02.xhtml#lev2_36).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`goto`语句由`goto`关键字后跟一个*goto标签*组成，后者是一种程序标签，指示执行应继续到何处。因此，`goto done`意味着程序执行应跳到标记为`done`的行。C语言中的其他程序标签示例包括前面在《switch语句》一章中介绍的`switch`语句标签，[第122页](ch02.xhtml#lev2_36)。'
- en: The following code listings depict a function `getSmallest` written in regular
    C code (first) and its associated `goto` form in C (second). The `getSmallest`
    function compares the values of two integers (`x` and `y`), and assigns the smaller
    value to variable `smallest`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例展示了一个`getSmallest`函数，首先是普通C代码（第一段），其次是其对应的C语言`goto`形式（第二段）。`getSmallest`函数比较两个整数（`x`和`y`）的值，并将较小的值赋给变量`smallest`。
- en: Regular C version
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 普通C版本
- en: '[PRE15]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: goto version
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 转到版本
- en: '[PRE16]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `goto` form of this function may seem counterintuitive, but let’s discuss
    what exactly is going on. The conditional checks to see whether variable `x` is
    less than or equal to `y`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的`goto`形式可能看起来有些反直觉，但让我们来讨论一下究竟发生了什么。条件语句检查变量`x`是否小于或等于`y`。
- en: If `x` is less than or equal to `y`, the program transfers control to the label
    marked by `else_statement`, which contains the single statement `smallest = x`.
    Since the program executes linearly, the program continues on to execute the code
    under the label `done`, which returns the value of `smallest` (`x`).
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`x`小于或等于`y`，程序将控制权转移到标记为`else_statement`的标签，该标签包含唯一的语句`smallest = x`。由于程序按顺序执行，程序接着执行`done`标签下的代码，返回`smallest`的值（`x`）。
- en: If `x` is greater than `y`, then `smallest` is assigned the value `y`. The program
    then executes the statement `goto done`, which transfers control to the `done`
    label, which returns the value of `smallest` (`y`).
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`x`大于`y`，则将`smallest`赋值为`y`。然后程序执行语句`goto done`，将控制权转移到`done`标签，返回`smallest`的值（`y`）。
- en: Although `goto` statements were commonly used in the early days of programming,
    their use in modern code is considered bad practice because it reduces the overall
    readability of code. In fact, computer scientist Edsger Dijkstra wrote a famous
    paper lambasting the use of `goto` statements called “Go To Statement Considered
    Harmful.”^([1](ch08.xhtml#fn8_1))
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`goto`语句在编程早期常常使用，但在现代代码中它的使用被认为是不良的实践，因为它降低了代码的可读性。事实上，计算机科学家Edsger Dijkstra写了一篇著名的论文，猛烈抨击了`goto`语句的使用，名为《Go
    To 语句被认为有害》。^([1](ch08.xhtml#fn8_1))
- en: In general, well-designed C programs do not use `goto` statements, and programmers
    are discouraged from using them to avoid writing code that is difficult to read,
    debug, and maintain. However, the C `goto` statement is important to understand,
    as GCC typically changes C code with conditionals into a `goto` form prior to
    translating it to assembly, including code that contains `if` statements and loops.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，设计良好的C程序不使用`goto`语句，并且不鼓励程序员使用它们，以避免编写难以阅读、调试和维护的代码。然而，理解C语言中的`goto`语句非常重要，因为GCC通常会在将C代码翻译成汇编之前，将包含条件语句和循环的C代码转换为`goto`形式。
- en: The following subsections cover the assembly representation of `if` statements
    and loops in greater detail.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节将更详细地讲解`if`语句和循环的汇编表示。
- en: 8.4.2 if Statements in Assembly
  id: totrans-271
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.2 汇编中的`if`语句
- en: Let’s take a look at the `getSmallest` function in assembly. For convenience,
    the function is reproduced here.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下汇编中的`getSmallest`函数。为了方便起见，函数在这里被重新展示。
- en: '[PRE17]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The corresponding assembly code extracted from GDB looks similar to the following:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 从GDB提取的相应汇编代码如下所示：
- en: '[PRE18]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is a different view of the assembly code than we have seen before. Here,
    we can see the *address* associated with each instruction, but not the *bytes*.
    Note that this assembly segment has been lightly edited for the sake of simplicity.
    The instructions that are normally part of function creation/termination (i.e.,
    `push %ebp` and `mov %esp,%ebp`) and for allocating space on the stack are removed.
    By convention, GCC places the first and second parameters of a function at locations
    `%ebp+8` and `%ebp+0xc` (or `%ebp+12`), respectively. For the sake of clarity,
    we refer to these parameters as `x` and `y`, respectively.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们之前看到的汇编代码的不同视图。在这里，我们可以看到与每条指令相关联的*地址*，但看不到*字节*。请注意，为了简化起见，这段汇编代码已做轻微编辑。通常用于函数创建/终止（即`push
    %ebp`和`mov %esp,%ebp`）以及为堆栈分配空间的指令被移除。根据惯例，GCC将函数的第一个和第二个参数分别放置在`%ebp+8`和`%ebp+0xc`（或`%ebp+12`）的位置。为了清晰起见，我们将这些参数分别称为`x`和`y`。
- en: Let’s trace through the first few lines of the previous assembly code snippet.
    Note that we will not draw out the stack explicitly in this example. We leave
    this as an exercise for the reader, and encourage you to practice your stack tracing
    skills by drawing it out yourself.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跟踪前面汇编代码片段的前几行。请注意，我们在这个例子中不会显式地绘制堆栈。我们将这部分留给读者作为练习，并鼓励你通过自己绘制堆栈来练习堆栈追踪技巧。
- en: The first `mov` instruction copies the value located at address `%ebp+8` (the
    first parameter, `x`) and places it in register `%eax`. The instruction pointer
    (`%eip`) is set to the address of the next instruction, or 0x08048414.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个`mov`指令将位于地址`%ebp+8`（第一个参数，`x`）的值复制到寄存器`%eax`中。指令指针（`%eip`）被设置为下一个指令的地址，或者是0x08048414。
- en: The `cmp` instruction compares the value at location `%ebp+12` (the second parameter,
    `y`) to `x` and sets appropriate condition code flag registers. Register `%eip`
    advances to the address of the next instruction, or 0x08048417.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmp`指令将位置`%ebp+12`（第二个参数，`y`）的值与`x`进行比较，并设置适当的条件码标志寄存器。寄存器`%eip`向下一个指令的地址推进，即0x08048417。'
- en: The `jle` instruction on the third line indicates that if `x` is less than or
    equal to `y`, the next instruction that executes is at location `<getSmallest+22>`
    (or `mov 0x8(%ebp),%eax`) and that `%eip` should be set to address 0x8048421\.
    Otherwise, `%eip` is set to the next instruction in sequence, or 0x8048419.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三行的`jle`指令表示，如果`x`小于或等于`y`，则执行的下一条指令位于`<getSmallest+22>`（或`mov 0x8(%ebp),%eax`）的位置，且`%eip`应设置为地址0x8048421。否则，`%eip`被设置为顺序中的下一条指令，即0x8048419。
- en: 'The next instructions to execute depend on whether the program follows the
    branch (i.e., executes the jump) on line 3 (`<getSmallest+12>`). Let’s first suppose
    that the branch was *not* followed. In this case, `%eip` is set to 0x8048419 (i.e.,
    `<getSmallest+14>`) and the following sequence of instructions executes:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 执行的下一条指令取决于程序是否遵循第3行（`<getSmallest+12>`）的分支（即是否执行跳转）。首先假设没有遵循分支。在这种情况下，`%eip`被设置为0x8048419（即`<getSmallest+14>`），并执行以下指令序列：
- en: The `mov 0xc(%ebp),%eax` instruction at `<getSmallest+14>` copies `y` to register
    `%eax`. Register `%eip` advances to 0x804841f.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<getSmallest+14>`位置的`mov 0xc(%ebp),%eax`指令将`y`复制到寄存器`%eax`中。寄存器`%eip`向0x804841f推进。'
- en: The `jmp` instruction sets register `%eip` to address 0x8048427.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jmp`指令将寄存器`%eip`设置为地址0x8048427。'
- en: The last instruction to execute is the `ret` instruction, signifying the end
    of the function. In this case, `%eax` contains `y`, and `getSmallest` returns
    `y`.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行的最后一条指令是 `ret` 指令，表示函数的结束。在这种情况下，`%eax` 包含 `y`，`getSmallest` 返回 `y`。
- en: 'Now, suppose that the branch was taken at `<getSmallest+12>`. In other words,
    the `jle` instruction sets register `%eip` to 0x8048421 (i.e., `<getSmallest+22>`).
    Then, the next instructions to execute are:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设分支是在 `<getSmallest+12>` 被采取的。换句话说，`jle` 指令将寄存器 `%eip` 设置为 0x8048421（即 `<getSmallest+22>`）。接下来要执行的指令是：
- en: The `mov 0x8(%ebp),%eax` instruction at address 0x8048421, which copies `x`
    to register `%eax`. Register `%eip` advances to 0x8048427.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地址 0x8048421 处的 `mov 0x8(%ebp),%eax` 指令将 `x` 复制到寄存器 `%eax` 中。寄存器 `%eip` 随后进展到
    0x8048427。
- en: The last instruction that executes is `ret`, signifying the end of the function.
    In this case, `%eax` contains `x`, and `getSmallest` returns `x`.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行的最后一条指令是 `ret`，表示函数的结束。在这种情况下，`%eax` 包含 `x`，`getSmallest` 返回 `x`。
- en: 'We can then annotate the preceding assembly as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以按如下方式注释前面的汇编：
- en: '[PRE19]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Translating this back to C code yields:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 将其反向翻译回 C 代码得到：
- en: goto form
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: goto 形式
- en: '[PRE20]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Translated C code
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译后的 C 代码
- en: '[PRE21]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In these code listings, the variable `smallest` corresponds to register `%eax`.
    If `x` is less than or equal to `y`, the code executes the statement `smallest
    = x`, which is associated with the `goto` label `assign_x` in our `goto` form
    of this function. Otherwise, the statement `smallest = y` is executed. The `goto`
    label `done` is used to indicate that the value in `smallest` should be returned.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些代码清单中，变量 `smallest` 对应于寄存器 `%eax`。如果 `x` 小于或等于 `y`，则执行语句 `smallest = x`，该语句与我们在
    `goto` 形式的函数中对应的 `goto` 标签 `assign_x` 相关联。否则，将执行语句 `smallest = y`。`goto` 标签 `done`
    用于表示应该返回 `smallest` 中的值。
- en: 'Notice that the preceding C translation of the assembly code is a bit different
    from the original `getSmallest` function. These differences don’t matter; a close
    inspection of both functions reveals that the two programs are logically equivalent.
    However, the compiler first converts any `if` statementinto an equivalent `goto`
    form, which results in the slightly different, but equivalent, version. The following
    code examples show the standard `if` statement format and its equivalent `goto`
    form:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的 C 语言翻译的汇编代码与原始的 `getSmallest` 函数略有不同。这些差异并不重要；仔细检查这两个函数可以发现，它们在逻辑上是等效的。然而，编译器首先将任何
    `if` 语句转换为等效的 `goto` 形式，结果是略有不同但等效的版本。以下代码示例展示了标准的 `if` 语句格式及其等效的 `goto` 形式：
- en: C if statement
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: C 的 `if` 语句
- en: '[PRE22]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Compiler’s equivalent goto form
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器的等效 `goto` 形式
- en: '[PRE23]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Compilers translating code into assembly designate a jump when a condition is
    true. Contrast this behavior with the structure of an `if` statement, where a
    “jump” (to the `else`) occurs when conditions are *not* true. The `goto` form
    captures this difference in logic.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将代码翻译成汇编时，会在条件为真时指定跳转。将这种行为与 `if` 语句的结构进行对比，在条件 *不* 满足时会发生“跳转”（到 `else`）。`goto`
    形式捕获了这种逻辑差异。
- en: 'Considering the original `goto` translation of the `getSmallest` function,
    we can see that:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到原始的 `goto` 翻译版本的 `getSmallest` 函数，我们可以看到：
- en: '`x >= y` corresponds to `!*<condition>*`.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x >= y` 对应于 `!*<condition>*`。'
- en: '`smallest = x` is the <else_statement>.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`smallest = x` 是 <else_statement>。'
- en: The line `smallest = y` is the <then_statement>.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语句 `smallest = y` 是 <then_statement>。
- en: The last line in the function is `return smallest`.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数中的最后一行是 `return smallest`。
- en: 'Rewriting the original version of the function with the preceding annotations
    yields:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 用前面的注释重写函数的原始版本后，得到的代码是：
- en: '[PRE24]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This version is identical to the original `getSmallest` function. Keep in mind
    that a function written in different ways in the C language can translate to the
    same set of assembly instructions.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本与原始的 `getSmallest` 函数完全相同。请记住，在 C 语言中以不同方式编写的函数，最终可能会转换为相同的汇编指令集。
- en: The cmov Instructions
  id: totrans-310
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: cmov 指令
- en: The last set of conditional instructions we cover are *conditional move* (`cmov`)
    instructions. The `cmp`, `test`, and `jmp` instructions implement a *conditional
    transfer of control* in a program. In other words, the execution of the program
    branches in many directions. This can be very problematic for optimizing code
    because these branches are very expensive.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要介绍的最后一组条件指令是 *条件移动* (`cmov`) 指令。`cmp`、`test` 和 `jmp` 指令实现了程序中的 *条件控制转移*。换句话说，程序的执行会分支到多个方向。这对于优化代码来说是非常棘手的，因为这些分支非常昂贵。
- en: In contrast, the `cmov` instruction implements a *conditional transfer of data*.
    In other words, both the <then_statement> and <else_statement> of the conditional
    are executed, and the data is placed in the appropriate register based on the
    result of the condition.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`cmov` 指令实现了 *条件数据传输*。换句话说，条件语句的 <then_statement> 和 <else_statement> 都会被执行，数据会根据条件的结果被放入相应的寄存器。
- en: 'The use of C’s *ternary expression* often results in the compiler generating
    a `cmov` instruction in place of jumps. For the standard if–then–else statement,
    the ternary expression has the form:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: C 语言的 *三元表达式* 通常会导致编译器在跳转指令的地方生成 `cmov` 指令。对于标准的 if–then–else 语句，三元表达式的形式是：
- en: '[PRE25]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let’s use this format to rewrite the `getSmallest` function as a ternary expression.
    Keep in mind that this new version of the function behaves exactly as the original
    `getSmallest` function:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这种格式，将 `getSmallest` 函数重写为一个三元表达式。请记住，这个新版本的函数行为和原始的 `getSmallest` 函数完全相同：
- en: '[PRE26]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Although this may not seem like a big change, let’s look at the resulting assembly.
    Recall that the first and second parameters (`x` and `y`) are stored at stack
    addresses `%ebp` + 0x8 and `%ebp` + 0xc, respectively.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这看起来可能没有太大的变化，但让我们看看结果汇编代码。回想一下，第一和第二个参数（`x` 和 `y`）分别存储在堆栈地址 `%ebp` + 0x8
    和 `%ebp` + 0xc。
- en: '[PRE27]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This assembly code has no jumps. After the comparison of `x` and `y`, `x` moves
    into the return register only if `x` is less than or equal to `y`. Like the jump
    instructions, the suffix of the `cmov` instructions indicates the condition on
    which the conditional move occurs. [Table 8-15](ch08.xhtml#ch8tab15) lists the
    set of conditional move instructions.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这个汇编代码没有跳转指令。在比较 `x` 和 `y` 之后，只有当 `x` 小于或等于 `y` 时，`x` 才会被移动到返回寄存器中。像跳转指令一样，`cmov`
    指令的后缀表示条件移动发生的条件。[表 8-15](ch08.xhtml#ch8tab15) 列出了条件移动指令的集合。
- en: '**Table 8-15:** The cmov Instructions'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-15：** cmov 指令'
- en: '| **Signed** | **Unsigned** | **Description** |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| **有符号** | **无符号** | **描述** |'
- en: '| `cmove` (`cmovz`) |  | move if equal (==) |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| `cmove` (`cmovz`) |  | 如果相等（==）则移动 |'
- en: '| `cmovne` (`cmovnz`) |  | move if not equal (!=) |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| `cmovne` (`cmovnz`) |  | 如果不等（!=）则移动 |'
- en: '| `cmovs` |  | move if negative |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| `cmovs` |  | 如果负数则移动 |'
- en: '| `cmovns` |  | move if non-negative |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| `cmovns` |  | 如果非负则移动 |'
- en: '| `cmovg` (`cmovnle`) | `cmova` (`cmovnbe`) | move if greater (>) |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| `cmovg` (`cmovnle`) | `cmova` (`cmovnbe`) | 如果大于（>）则移动 |'
- en: '| `cmovge` (`cmovnl`) | `cmovae` (`cmovnb`) | move if greater than or equal
    (>=) |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| `cmovge` (`cmovnl`) | `cmovae` (`cmovnb`) | 如果大于或等于（>=）则移动 |'
- en: '| `cmovl` (`cmovnge`) | `cmovb` (`cmovnae`) | move if less (<) |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| `cmovl` (`cmovnge`) | `cmovb` (`cmovnae`) | 如果小于（<）则移动 |'
- en: '| `cmovle` (`cmovng`) | `cmovbe` (`cmovna`) | move if less than or equal (<=)
    |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| `cmovle` (`cmovng`) | `cmovbe` (`cmovna`) | 如果小于或等于（<=）则移动 |'
- en: 'The compiler is very cautious about converting jump instructions into `cmov`
    instructions, especially in cases where side effects and pointer values are involved.
    Here, we show two equivalent ways of writing a function, `incrementX`:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器在将跳转指令转换为 `cmov` 指令时非常小心，尤其是在涉及副作用和指针值的情况下。在这里，我们展示了两种等效的写法来定义函数 `incrementX`：
- en: C code
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: C 代码
- en: '[PRE28]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: C ternary form
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: C 语言三元形式
- en: '[PRE29]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Each function takes a pointer to an integer as input and checks whether it is
    `NULL`. If `x` is not `NULL`, the function increments and returns the dereferenced
    value of `x`. Otherwise, the function returns the value 1.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数接受一个整数指针作为输入，并检查它是否为 `NULL`。如果 `x` 不是 `NULL`，函数会递增并返回 `x` 解引用后的值。否则，函数返回值
    1。
- en: 'It is tempting to think that `incrementX2` uses a `cmov` instruction because
    it uses a ternary expression. However, both functions yield the exact same assembly
    code:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有人认为 `incrementX2` 使用了 `cmov` 指令，因为它使用了三元表达式。然而，这两个函数生成的是完全相同的汇编代码：
- en: '[PRE30]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Recall that the `cmov` instruction *executes both branches of the conditional*.
    In other words, `x` gets dereferenced no matter what. Consider the case where
    `x` is a null pointer. Recall that dereferencing a null pointer leads to a null
    pointer exception in the code, causing a segmentation fault. To prevent any chance
    of this happening, the compiler takes the safe road and uses jumps.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，`cmov` 指令 *执行条件语句的两个分支*。换句话说，`x` 无论如何都会被解引用。假设 `x` 是一个空指针。回想一下，解引用空指针会导致代码中的空指针异常，从而引发段错误。为了防止这种情况的发生，编译器选择了更安全的方式，使用了跳转指令。
- en: 8.4.3 Loops in Assembly
  id: totrans-339
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.3 汇编中的循环
- en: Like `if` statements, loops in assembly are also implemented using jump instructions.
    However, loops enable instructions to be *revisited* based on the result of an
    evaluated condition.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `if` 语句类似，汇编中的循环也使用跳转指令实现。然而，循环使得指令能够根据评估条件的结果被*重新访问*。
- en: The `sumUp` function shown in the following example sums up all the positive
    integers from 1 to a user-defined integer. This code is intentionally written
    suboptimally to illustrate a `while` loop in C.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例中所示的 `sumUp` 函数将从 1 到用户定义的整数的所有正整数相加。该代码故意写得不够优化，用来展示 C 语言中的 `while` 循环。
- en: '[PRE31]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Compiling this code with the `-m32` option and disassembling it using GDB yields
    the following assembly code:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-m32` 选项编译这段代码，并通过 GDB 反汇编后，得到以下汇编代码：
- en: '[PRE32]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Again, we will not draw out the stack explicitly in this example. However, we
    encourage readers to draw the stack out themselves.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，本例中我们不会明确绘出栈的结构。但我们鼓励读者自己绘制栈的结构。
- en: The First Five Instructions
  id: totrans-346
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 前五条指令
- en: 'The first five instructions of this function prepare the stack for function
    execution:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的前五条指令为函数执行准备栈：
- en: '[PRE33]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Recall that stack locations store *temporary variables* in a function. For simplicity
    we will refer to the location marked by `%ebp - 0x8` as `total`, and `%ebp - 0x4`
    as `i`. The input parameter to `sumUp` is located at `%ebp` + 0x8.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，栈中的位置用于存储函数中的*临时变量*。为了简化，我们将标记为 `%ebp - 0x8` 的位置称为 `total`，将 `%ebp - 0x4`
    称为 `i`。`sumUp` 的输入参数位于 `%ebp` + 0x8 处。
- en: The Heart of the Loop
  id: totrans-350
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 循环的核心
- en: 'The next seven instructions in the `sumUp` function represent the heart of
    the loop:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`sumUp` 函数中的接下来的七条指令代表了循环的核心：'
- en: '[PRE34]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The first instruction is a direct jump to `<sumUp+32>`, which sets the instruction
    pointer (`%eip`) to address 0x804842b.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条指令直接跳转到 `<sumUp+32>`，这将指令指针（`%eip`）设置为地址 0x804842b。
- en: The next instructions that execute (`<sumUp+32>` and `<sumUp+35>`) copy the
    value of `i` to register `%eax` and compare `i` with the first parameter to the
    `sumUp` function (or `n`). The `cmp` instruction sets the appropriate condition
    codes in preparation for the `jle` instruction at `<sumUp+38>`.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 执行的下一条指令（`<sumUp+32>` 和 `<sumUp+35>`）将 `i` 的值复制到寄存器 `%eax` 并比较 `i` 与 `sumUp`
    函数的第一个参数（即 `n`）。`cmp` 指令设置适当的条件码，为 `<sumUp+38>` 处的 `jle` 指令做准备。
- en: 'The `jle` instruction at `<sumUp+38>` then executes. If `i` is less than or
    equal to `n`, the branch is taken and program execution jumps to `<sumUp+22>`,
    and `%eip` is set to 0x8048421\. The following instructions then execute in sequence:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`<sumUp+38>` 处的 `jle` 指令执行。如果 `i` 小于或等于 `n`，则进入分支，程序执行跳转到 `<sumUp+22>`，并将 `%eip`
    设置为 0x8048421。随后，以下指令依次执行：'
- en: '`mov -0x4(%ebp),%eax` copies `i` to register `%eax`.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mov -0x4(%ebp),%eax` 将 `i` 复制到寄存器 `%eax`。'
- en: '`add %eax,-0x8(%ebp)` adds `i` to `total` (i.e., `total+=i`).'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add %eax,-0x8(%ebp)` 将 `i` 加到 `total` 上（即 `total+=i`）。'
- en: '`add $0x1,-0x4(%ebp)` increments `i` by 1 (i.e., `i+=1`).'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add $0x1,-0x4(%ebp)` 将 `i` 增加 1（即 `i+=1`）。'
- en: '`mov -0x4(%ebp),%eax` copies `i` to register `%eax`.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mov -0x4(%ebp),%eax` 将 `i` 复制到寄存器 `%eax`。'
- en: '`cmp 0x8(%ebp),%eax` compares `i` to `n`.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmp 0x8(%ebp),%eax` 比较 `i` 与 `n`。'
- en: '`jle 0x8048421 <sumUp+22>` jumps back to the beginning of this instruction
    sequence if `i` is less than or equal to `n`.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jle 0x8048421 <sumUp+22>` 会在 `i` 小于或等于 `n` 时跳回到该指令序列的开头。'
- en: If the branch is not taken at `<sumUp+38>` (i.e., `i` is *not* less than or
    equal to `n`), `total` is placed in the return register, and the function exits.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 `<sumUp+38>` 处未进入分支（即 `i` *不* 小于或等于 `n`），则将 `total` 存入返回寄存器，并退出函数。
- en: 'The following code listings show the assembly and then the C `goto` forms of
    the `sumUp` function:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码列表显示了 `sumUp` 函数的汇编和 `goto` 形式的 C 代码：
- en: Assembly
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编
- en: '[PRE35]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Translated goto form
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 转换后的 `goto` 形式
- en: '[PRE36]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The preceding code is also equivalent to the following C code without `goto`
    statements:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码等价于以下没有 `goto` 语句的 C 代码：
- en: '[PRE37]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: for Loops in Assembly
  id: totrans-370
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 汇编中的 `for` 循环
- en: 'The primary loop in the `sumUp` function can also be written as a `for` loop:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`sumUp` 函数中的主要循环也可以写成一个 `for` 循环：'
- en: '[PRE38]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This version yields assembly code identical to our `while` loop example. We
    repeat the assembly code here and annotate each line with its English translation:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 该版本生成的汇编代码与我们的 `while` 循环示例相同。我们在此重复汇编代码，并为每一行加上其英文翻译：
- en: '[PRE39]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: To understand why the `for` loop version of this code results in identical assembly
    to the `while` loop version of the code, recall that the `for` loop has the following
    representation
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解为什么这段代码的 `for` 循环版本与 `while` 循环版本生成相同的汇编代码，请回忆一下，`for` 循环有以下表现形式：
- en: '[PRE40]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'and is equivalent to the following `while` loop representation:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 并且等价于以下的 `while` 循环表示：
- en: '[PRE41]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Since every `for` loop can be represented by a `while` loop (see “for Loops”
    on [page 35](ch01.xhtml#lev3_5)), the following two C programs are equivalent
    representations for the previous assembly:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个 `for` 循环都可以通过 `while` 循环来表示（参见[第 35 页](ch01.xhtml#lev3_5)的“for 循环”），以下两个
    C 程序是与之前的汇编代码等价的表示：
- en: for loop
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: for 循环
- en: '[PRE42]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: while loop
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: while 循环
- en: '[PRE43]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 8.5 Functions in Assembly
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5 汇编中的函数
- en: In the previous section, we traced through simple functions in assembly. In
    this section, we discuss the interaction between multiple functions in assembly
    in the context of a larger program. We also introduce some new instructions involved
    with function management.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们回顾了汇编中的简单函数。在本节中，我们将讨论在更大程序背景下，多个函数之间的交互。我们还将介绍一些与函数管理相关的新指令。
- en: Let’s begin with a refresher on how the call stack is managed. Recall that `%esp`
    is the *stack pointer* and always points to the top of the stack. The register
    `%ebp` represents the base pointer (also known as the *frame pointer*) and points
    to the base of the current stack frame. The *stack frame* (also known as the *activation
    frame* or the *activation record*) refers to the portion of the stack allocated
    to a single function call. The currently executing function is always at the top
    of the stack, and its stack frame is referred to as the *active frame*. The active
    frame is bounded by the stack pointer (at the top of stack) and the frame pointer
    (at the bottom of the frame). The activation record typically holds local variables
    and parameters for a function.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先复习一下调用堆栈是如何管理的。回想一下，`%esp` 是 *堆栈指针*，始终指向堆栈的顶部。寄存器 `%ebp` 代表基指针（也称为 *帧指针*），指向当前堆栈帧的底部。*堆栈帧*（也称为
    *激活帧* 或 *激活记录*）是指为单个函数调用分配的堆栈区域。当前正在执行的函数总是位于堆栈的顶部，其堆栈帧称为 *活动帧*。活动帧的边界由堆栈指针（位于堆栈顶部）和帧指针（位于帧底部）决定。激活记录通常包含函数的局部变量和参数。
- en: '[Figure 8-3](ch08.xhtml#ch8fig3) shows the stack frames for `main` and a function
    it calls named `fname`. We will refer to the `main` function as the *caller* function
    and `fname` as the *callee* function.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-3](ch08.xhtml#ch8fig3) 显示了 `main` 函数和它调用的名为 `fname` 的函数的堆栈帧。我们将 `main`
    函数称为 *调用者* 函数，将 `fname` 称为 *被调用者* 函数。'
- en: '![image](../images/08fig03.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig03.jpg)'
- en: '*Figure 8-3: Stack frame management*'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-3：堆栈帧管理*'
- en: In [Figure 8-3](ch08.xhtml#ch8fig3), the current active frame belongs to the
    callee function (`fname`). The memory between the stack pointer and the frame
    pointer is used for local variables. The stack pointer moves as local values are
    pushed and popped from the stack. In contrast, the frame pointer remains relatively
    constant, pointing to the beginning (the bottom) of the current stack frame. As
    a result, compilers like GCC commonly reference values on the stack relative to
    the frame pointer. In [Figure 8-3](ch08.xhtml#ch8fig3), the active frame is bounded
    below by the base pointer of `fname`, which contains the stack address 0x418\.
    The value stored at this address is the “saved” `%ebp` value (0x42c), which itself
    indicates the bottom of the activation frame for the `main` function. The top
    of the activation frame of `main` is bounded by the *return address*, which indicates
    the program address at which `main` resumes execution as soon as the callee function
    finishes executing.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 8-3](ch08.xhtml#ch8fig3) 中，当前的活动帧属于被调用者函数（`fname`）。堆栈指针和帧指针之间的内存用于存储局部变量。随着局部值被推入和弹出堆栈，堆栈指针会发生变化。与此相反，帧指针相对恒定，指向当前堆栈帧的起始位置（底部）。因此，像
    GCC 这样的编译器通常会相对于帧指针引用堆栈上的值。在 [图 8-3](ch08.xhtml#ch8fig3) 中，活动帧的下边界由 `fname` 的基指针限定，该基指针的堆栈地址为
    0x418。存储在该地址的值是“保存的”`%ebp` 值（0x42c），它本身指示 `main` 函数的激活帧底部。`main` 函数的激活帧顶部由 *返回地址*
    确定，返回地址指示程序地址，`main` 在被调用函数执行完毕后将在该地址恢复执行。
- en: '**Warning THE RETURN ADDRESS POINTS TO PROGRAM MEMORY, NOT STACK MEMORY**'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告 返回地址指向程序内存，而非堆栈内存**'
- en: Recall that the call stack region (stack memory) of a program is different from
    its code region (code memory). Whereas `%ebp` and `%esp` point to locations in
    the stack memory, `%eip` points to a location in *code* memory. In other words,
    the return address is an address in code memory, not stack memory (see [Figure
    8-4](ch08.xhtml#ch8fig4)).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，程序的调用栈区域（栈内存）与代码区域（代码内存）是不同的。`%ebp`和`%esp`指向栈内存中的位置，而`%eip`指向*代码*内存中的位置。换句话说，返回地址是代码内存中的一个地址，而不是栈内存中的地址（见[图
    8-4](ch08.xhtml#ch8fig4)）。
- en: '![image](../images/08fig04.jpg)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig04.jpg)'
- en: '*Figure 8-4: The parts of a program’s address space*'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-4：程序地址空间的组成部分*'
- en: '[Table 8-16](ch08.xhtml#ch8tab16) contains several additional instructions
    that the compiler uses for basic function management.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 8-16](ch08.xhtml#ch8tab16)包含了编译器用于基本函数管理的几条额外指令。'
- en: '**Table 8-16:** Common Function Management Instructions'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-16：** 常见的函数管理指令'
- en: '| **Instruction** | **Translation** |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **翻译** |'
- en: '| `leave` | Prepares the stack for leaving a function. Equivalent to: |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| `leave` | 为离开一个函数准备栈。等同于： |'
- en: '|  | `mov %ebp,%esp` |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '|  | `mov %ebp,%esp` |'
- en: '|  | `pop %ebp` |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '|  | `pop %ebp` |'
- en: '| `call addr <fname>` | Switches active frame to callee function. Equivalent
    to: |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| `call addr <fname>` | 切换活动帧到被调用函数。等同于： |'
- en: '|  | `push %eip` |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '|  | `push %eip` |'
- en: '|  | `mov addr,%eip` |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '|  | `mov addr,%eip` |'
- en: '| `ret` | Restores active frame to caller function. Equivalent to: |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| `ret` | 恢复活动帧到调用者函数。等同于： |'
- en: '|  | `pop %eip` |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '|  | `pop %eip` |'
- en: For example, the `leave` instruction is a shorthand that the compiler uses to
    restore the stack and frame pointers as it prepares to leave a function. When
    the callee function finishes execution, `leave` ensures that the frame pointer
    is *restored* to its previous value.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`leave`指令是编译器用来恢复栈指针和帧指针的简写，它准备离开一个函数。当被调用函数执行完毕时，`leave`确保帧指针被*恢复*到先前的值。
- en: The `call` and `ret` instructions play a prominent role in the process where
    one function calls another. Both instructions modify the instruction pointer (register
    `%eip`). When the caller function executes the `call` instruction, the current
    value of `%eip` is saved on the stack to represent the return address, or the
    program address at which the caller resumes executing once the callee function
    finishes. The `call` instruction also replaces the value of `%eip` with the address
    of the callee function.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '`call`和`ret`指令在一个函数调用另一个函数的过程中起着重要作用。两者都修改了指令指针（寄存器`%eip`）。当调用函数执行`call`指令时，`%eip`的当前值被保存到栈中，表示返回地址，即在被调用函数执行完毕后，调用函数继续执行的程序地址。`call`指令还将`%eip`的值替换为被调用函数的地址。'
- en: The `ret` instruction restores the value of `%eip` to the value saved on the
    stack, ensuring that the program resumes execution at the program address specified
    in the caller function. Any value returned by the callee is stored in `%eax`.
    The `ret` instruction is usually the last instruction that executes in any function.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '`ret`指令将`%eip`的值恢复为保存在栈中的值，确保程序在调用函数指定的程序地址处继续执行。被调用函数返回的任何值都会存储在`%eax`中。`ret`指令通常是任何函数中执行的最后一条指令。'
- en: 8.5.1 Tracing Through an Example
  id: totrans-409
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.5.1 追踪一个示例
- en: Using our knowledge of function management, let’s trace through the code example
    first introduced at the beginning of this chapter.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 运用我们对函数管理的知识，让我们追踪一下本章开始时介绍的代码示例。
- en: '[PRE44]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We compile the code with the `-m32` flag and use `objdump -d` to view the underlying
    assembly. The latter command outputs a pretty big file that contains a lot of
    information that we don’t need. Use `less` and the search functionality to extract
    the `adder`, `assign`, and `main` functions:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`-m32`标志编译代码，并用`objdump -d`查看底层汇编代码。后者命令会输出一个非常大的文件，包含很多我们不需要的信息。可以使用`less`和搜索功能提取`adder`、`assign`和`main`函数：
- en: '[PRE45]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Each function begins with a symbolic label that corresponds to its declared
    name in the program. For example, `<main>:` is the symbolic label for the `main`
    function. The address of a function label is also the address of the first instruction
    in that function. To save space in the figures that follow, we truncate addresses
    to the lower 12 bits. So, program address 0x804842d is shown as 0x42d.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都以一个符号标签开始，该标签对应程序中声明的函数名。例如，`<main>:`是`main`函数的符号标签。函数标签的地址也是该函数中第一条指令的地址。为了节省后续图示的空间，我们将地址截断为低12位。因此，程序地址0x804842d显示为0x42d。
- en: 8.5.2 Tracing Through main
  id: totrans-415
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.5.2 追踪 `main`
- en: '[Figure 8-5](ch08.xhtml#ch8fig5) shows the execution stack immediately prior
    to the execution of `main`.'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-5](ch08.xhtml#ch8fig5) 显示了 `main` 函数执行前的栈的状态。'
- en: '![image](../images/08fig05.jpg)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig05.jpg)'
- en: '*Figure 8-5: The initial state of the CPU registers and call stack prior to
    executing the main function*'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-5：执行 `main` 函数前，CPU 寄存器和调用栈的初始状态*'
- en: Recall that the stack grows toward lower addresses. In this example, `%ebp`
    is address 0x140, and `%esp` is address 0x130 (both of these values are made up
    for this example). Registers `%eax` and `%edx` initially contain junk values.
    The upper-left arrow indicates the currently executing instruction. Initially,
    `%eip` contains address 0x42d, which is the program memory address of the first
    line in the `main` function. Let’s trace through the program’s execution together.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，栈是向较低地址增长的。在此示例中，`%ebp` 的地址为 0x140，`%esp` 的地址为 0x130（这两个值是为了本示例而虚构的）。寄存器
    `%eax` 和 `%edx` 最初包含垃圾值。左上角的箭头表示当前正在执行的指令。最初，`%eip` 包含地址 0x42d，这是 `main` 函数中第一行代码的程序内存地址。让我们一起追踪程序的执行。
- en: '![image](../images/f0412-01.jpg)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0412-01.jpg)'
- en: The first instruction pushes the value of `ebp` onto the stack, saving address
    0x140\. Since the stack grows toward lower addresses, the stack pointer `%esp`
    updates to 0x12c, which is four bytes less than 0x130\. Register `%eip` advances
    to the next instruction in sequence.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条指令将 `ebp` 的值压入栈中，保存了地址 0x140。由于栈是向较低地址增长的，栈指针 `%esp` 更新为 0x12c，这比 0x130 少了
    4 个字节。寄存器 `%eip` 会指向下一条指令。
- en: '![image](../images/f0413-01.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0413-01.jpg)'
- en: The next instruction (`mov %esp,%ebp`) updates the value of `%ebp` to be the
    same as `%esp`. The frame pointer (`%ebp`) now points to the start of the stack
    frame for the `main` function. `%eip` advances to the next instruction in sequence.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条指令（`mov %esp,%ebp`）将 `%ebp` 的值更新为与 `%esp` 相同。帧指针（`%ebp`）现在指向 `main` 函数栈帧的起始位置。`%eip`
    将指向下一个指令。
- en: '![image](../images/f0413-02.jpg)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0413-02.jpg)'
- en: The `sub` instruction subtracts 0x14 from the address of our stack pointer,
    “growing” the stack by 20 bytes. Register `%eip` advances to the next instruction,
    which is the first `call` instruction.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '`sub` 指令将 0x14 从栈指针地址中减去，“增长”了栈 20 个字节。寄存器 `%eip` 会前进到下一条指令，即第一条 `call` 指令。'
- en: '![image](../images/f0414-01.jpg)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0414-01.jpg)'
- en: The `call <assign>` instruction pushes the value inside register `%eip` (which
    denotes the address of the *next* instruction to execute) onto the stack. Since
    the next instruction after `call <assign>` has the address 0x43b, that value is
    pushed onto the stack as the return address. Recall that the return address indicates
    the program address where execution should resume when program execution returns
    to `main`.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '`call <assign>` 指令将寄存器 `%eip` 中的值（表示 *下一* 个要执行的指令的地址）压入栈中。由于 `call <assign>`
    后的下一条指令地址为 0x43b，这个值会作为返回地址压入栈中。回想一下，返回地址表示当程序执行返回到 `main` 时，程序应从哪个地址继续执行。'
- en: Next, the `call` instruction moves the address of the `assign` function (0x40d)
    into register `%eip`, signifying that program execution should continue into the
    callee function `assign` and not the next instruction in `main`.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`call` 指令将 `assign` 函数的地址（0x40d）移入寄存器 `%eip`，表示程序执行应继续进入被调用的 `assign` 函数，而不是
    `main` 中的下一条指令。
- en: '![image](../images/f0415-01.jpg)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0415-01.jpg)'
- en: The first two instructions that execute in the `assign` function are the usual
    book-keeping that every function performs. The first instruction pushes the value
    stored in `%ebp` (memory address 0x12c) onto the stack. Recall that this address
    points to the beginning of the stack frame for `main`. `%eip` advances to the
    second instruction in `assign`.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '`assign` 函数中执行的前两条指令是每个函数执行时的常规记录操作。第一条指令将 `%ebp` 中存储的值（内存地址 0x12c）压入栈中。回想一下，这个地址指向
    `main` 函数的栈帧开始位置。`%eip` 指向 `assign` 中的第二条指令。'
- en: '![image](../images/f0416-01.jpg)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0416-01.jpg)'
- en: The next instruction (`mov %esp,%ebp`) updates `%ebp` to point to the top of
    the stack, marking the beginning of the stack frame for `assign`. The instruction
    pointer (`%eip`) advances to the next instruction in the `assign` function.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条指令（`mov %esp,%ebp`）将 `%ebp` 更新为指向栈顶，标志着 `assign` 函数栈帧的开始。指令指针（`%eip`）会前进到
    `assign` 函数中的下一条指令。
- en: '![image](../images/f0416-02.jpg)'
  id: totrans-433
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0416-02.jpg)'
- en: The `sub` instruction at address 0x410 grows the stack by 16 bytes, creating
    extra space on the stack frame to store local values and updating `%esp`. The
    instruction pointer again advances to the next instruction in the `assign` function.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 地址 0x410 处的 `sub` 指令将栈空间扩大了 16 字节，为栈帧中的局部值创建额外的空间，并更新了 `%esp`。指令指针再次跳转到 `assign`
    函数中的下一条指令。
- en: '![image](../images/f0417-01.jpg)'
  id: totrans-435
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0417-01.jpg)'
- en: The `mov` instruction at address 0x413 moves the value `$0x28` (or 40) onto
    the stack at address `-0x4(%ebp)`, which is four bytes above the frame pointer.
    Recall that the frame pointer is commonly used to reference locations on the stack.
    `%eip` advances to the next instruction in the `assign` function.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 地址 0x413 处的 `mov` 指令将值 `$0x28`（即 40）移动到栈中地址 `-0x4(%ebp)` 处，这个位置距离帧指针上方四个字节。回忆一下，帧指针通常用于引用栈上的位置。`%eip`
    继续执行 `assign` 函数中的下一条指令。
- en: '![image](../images/f0418-01.jpg)'
  id: totrans-437
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0418-01.jpg)'
- en: The `mov` instruction at address 0x41a places the value `$0x28` into register
    `%eax`, which holds the return value of the function. `%eip` advances to the `leave`
    instruction in the `assign` function.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 地址 0x41a 处的 `mov` 指令将值 `$0x28` 存入寄存器 `%eax` 中，该寄存器存储函数的返回值。`%eip` 继续执行 `assign`
    函数中的 `leave` 指令。
- en: '![image](../images/f0419-01.jpg)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0419-01.jpg)'
- en: 'At this point, the `assign` function has almost completed execution. The next
    instruction that executes is the `leave` instruction, which prepares the stack
    for returning from the function call. Recall that `leave` is analogous to the
    following pair of instructions:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 到此时，`assign` 函数的执行几乎完成。接下来执行的指令是 `leave` 指令，它为从函数调用返回做准备。回忆一下，`leave` 相当于以下一对指令：
- en: '[PRE46]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In other words, the CPU overwrites the stack pointer with the frame pointer.
    In our example, the stack pointer is initially updated from 0x100 to 0x110\. Next,
    the CPU executes `pop %ebp`, which takes the value located at 0x110 (in our example,
    the address 0x12c) and places it in `%ebp`. Recall that 0x12c is the start of
    the stack frame for `main`. `%esp` becomes 0x114, and `%eip` points to the `ret`
    instruction in the `assign` function.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，CPU 用帧指针覆盖了栈指针。在我们的示例中，栈指针最初从 0x100 更新为 0x110。接下来，CPU 执行 `pop %ebp`，将位于
    0x110 处的值（在我们的示例中，地址是 0x12c）放入 `%ebp` 中。回忆一下，0x12c 是 `main` 函数的栈帧起始地址。`%esp` 变为
    0x114，`%eip` 指向 `assign` 函数中的 `ret` 指令。
- en: '![image](../images/f0420-01.jpg)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0420-01.jpg)'
- en: The last instruction in `assign` is a `ret` instruction. When `ret` executes,
    the return address is popped off the stack into register `%eip`. In our example,
    `%eip` now advances to the call to the `adder` function.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '`assign` 中的最后一条指令是 `ret` 指令。当 `ret` 执行时，返回地址会从栈中弹出，并加载到寄存器 `%eip` 中。在我们的示例中，`%eip`
    会跳转到对 `adder` 函数的调用。'
- en: 'Some important things to notice at this juncture:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在此时，需要注意的一些重要事项：
- en: The stack pointer and frame pointer have been restored to their values prior
    to the call to `assign`, reflecting that the stack frame for `main` is again the
    active frame.
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈指针和帧指针已经恢复为调用 `assign` 之前的值，表明 `main` 函数的栈帧再次成为活动栈帧。
- en: The old values on the stack from the prior active stack frame are *not* removed.
    They still exist on the call stack.
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之前活动栈帧中的旧值并未从栈中移除。它们仍然存在于调用栈中。
- en: '![image](../images/f0421-01.jpg)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0421-01.jpg)'
- en: The call to `adder` *overwrites* the old return address on the stack with a
    new return address (0x440). This return address points to the next instruction
    to be executed after `adder` returns, or `mov %eax,0xc(%ebp)`. `%eip` reflects
    the first instruction to execute in `adder`, which is at address 0x41f.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `adder` *覆盖* 栈上旧的返回地址，替换为新的返回地址（0x440）。这个返回地址指向 `adder` 返回后执行的下一条指令，或 `mov
    %eax,0xc(%ebp)`。`%eip` 反映出 `adder` 中第一条将要执行的指令，它位于地址 0x41f。
- en: '![image](../images/f0422-01.jpg)'
  id: totrans-450
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0422-01.jpg)'
- en: The first instruction in the `adder` function saves the caller’s frame pointer
    (`%ebp` of `main`) on the stack.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '`adder` 函数中的第一条指令将调用者的帧指针（即 `main` 函数中的 `%ebp`）保存在栈上。'
- en: '![image](../images/f0422-02.jpg)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0422-02.jpg)'
- en: The next instruction updates `%ebp` with the current value of `%esp`, or address
    0x110\. Together, these last two instructions establish the beginning of the stack
    frame for `adder`.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条指令将 `%ebp` 更新为 `%esp` 的当前值，即地址 0x110。这两条指令共同建立了 `adder` 函数栈帧的起始位置。
- en: '![image](../images/f0423-01.jpg)'
  id: totrans-454
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0423-01.jpg)'
- en: The `sub` instruction at address 0x422 “grows” the stack by 16 bytes. Notice
    again that growing the stack does not affect any previously created values on
    the stack. Again, old values will litter the stack until they are overwritten.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 地址 0x422 处的 `sub` 指令“扩展”了栈，增加了 16 字节。请再次注意，扩展栈并不会影响栈上之前创建的任何值。旧的值会遗留在栈上，直到被覆盖。
- en: '![image](../images/f0424-01.jpg)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0424-01.jpg)'
- en: 'Pay close attention to the next instruction that executes: `mov $-0x4(%ebp),`
    `%eax`. This moves an *old* value that is on the stack into register `%eax`! This
    is a direct result of the fact that the programmer forgot to initialize `a` in
    the function `adder`.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 请特别注意接下来执行的指令：`mov $-0x4(%ebp), %eax`。这将栈上的一个*旧*值移入寄存器 `%eax`！这是因为程序员忘记在 `adder`
    函数中初始化 `a` 变量的直接后果。
- en: '![image](../images/f0425-01.jpg)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0425-01.jpg)'
- en: 'The `add` instruction at address 0x428 adds 2 to register `%eax`. Recall that
    IA32 passes the return value through register `%eax`. Together, the last two instructions
    are equivalent to the following code in `adder`:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 地址 0x428 处的 `add` 指令将 2 加到寄存器 `%eax` 中。回想一下，IA32 通过寄存器 `%eax` 传递返回值。最后两条指令等同于
    `adder` 中的以下代码：
- en: '[PRE47]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '![image](../images/f0426-01.jpg)'
  id: totrans-461
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0426-01.jpg)'
- en: After `leave` executes, the frame pointer again points to the beginning of the
    stack frame for `main`, or address 0x12c. The stack pointer now stores the address
    0x114.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 执行完 `leave` 后，帧指针再次指向 `main` 的栈帧起始位置，地址 0x12c。栈指针现在存储着地址 0x114。
- en: '![image](../images/f0427-01.jpg)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0427-01.jpg)'
- en: The execution of `ret` pops the return address off the stack, restoring the
    instruction pointer back to 0x440, or the address of the next instruction to execute
    in `main`. The address of `%esp` is now 0x118.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `ret` 指令将返回地址从栈中弹出，恢复指令指针到 0x440，或者说恢复到 `main` 中下一条要执行的指令的地址。此时 `%esp` 的地址为
    0x118。
- en: '![image](../images/f0428-01.jpg)'
  id: totrans-465
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0428-01.jpg)'
- en: The `mov %eax,0xc(%esp)` instruction places the value in `%eax` in a location
    12 bytes (three spaces) below `%esp`.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '`mov %eax,0xc(%esp)` 指令将 `%eax` 中的值放置在 `%esp` 下方 12 字节（即三个位置）的位置。'
- en: '![image](../images/f0428-02.jpg)'
  id: totrans-467
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0428-02.jpg)'
- en: Skipping ahead a little, the `mov` instructions at addresses 0x444 and 0x448
    set `%eax` to the value saved at location `%esp+12` (or 0x2A) and places 0x2A
    one spot below the top of the stack (address `%esp + 4`, or 0x11c).
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微跳过一点，地址 0x444 和 0x448 处的 `mov` 指令将 `%eax` 设置为存储在位置 `%esp+12`（或 0x2A）中的值，并将
    0x2A 放置在栈顶下方一个位置（地址 `%esp + 4`，即 0x11c）。
- en: '![image](../images/f0429-01.jpg)'
  id: totrans-469
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0429-01.jpg)'
- en: The next instruction (`mov $0x80484f4, (%esp)`) copies a constant value that
    is a memory address to the top of the stack. This particular memory address, 0x80484f4,
    contains the string `"x is %d\n"`. The instruction pointer advances to the call
    to the `printf` function (which is denoted with the label `<printf@plt>`).
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条指令（`mov $0x80484f4, (%esp)`）将一个常数值（一个内存地址）复制到栈顶。这个内存地址 0x80484f4 存储了字符串 `"x
    is %d\n"`。指令指针跳转到对 `printf` 函数的调用（通过标签 `<printf@plt>` 表示）。
- en: '![image](../images/f0430-01.jpg)'
  id: totrans-471
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0430-01.jpg)'
- en: 'For the sake of brevity, we will not trace the `printf` function, which is
    part of `stdio.h`. However, we know from the manual page (`man -s3 printf`) that
    `printf` has the following format:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我们将不追踪 `printf` 函数，它是 `stdio.h` 的一部分。然而，我们从手册页（`man -s3 printf`）知道，`printf`
    有以下格式：
- en: '[PRE48]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In other words, the first argument is a pointer to a string specifying the
    format, and the second argument onward specify the values that are used in that
    format. The instructions specified by addresses 0x444–0x45c correspond to the
    following line in the `main` function:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，第一个参数是一个指向字符串的指针，指定了格式，第二个及之后的参数指定了格式中使用的值。由地址 0x444–0x45c 指定的指令对应于 `main`
    函数中的以下一行：
- en: '[PRE49]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'When the `printf` function is called:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `printf` 函数时：
- en: A return address specifying the instruction that executes after the call to
    `printf` is pushed onto the stack.
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个返回地址，指定了在调用 `printf` 后执行的指令，这个地址被压入栈中。
- en: The value of `%ebp` is pushed onto the stack, and `%ebp` is updated to point
    to the top of the stack, indicating the beginning of the stack frame for `printf`.
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%ebp` 的值被压入栈中，且 `%ebp` 被更新为指向栈顶，标志着 `printf` 的栈帧的起始位置。'
- en: At some point, `printf` references its arguments, which are the string `"x is
    %d\n"` and the value 0x2A. Recall that the return address is located directly
    below `%ebp` at location `%ebp` + 4\. The first argument is thus located at `%ebp`
    + 8 (i.e., directly *below* the return address), and the second argument is located
    at `%ebp` + 12.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时刻，`printf` 引用它的参数，这些参数是字符串 `"x is %d\n"` 和值 0x2A。回想一下，返回地址位于 `%ebp` 下方的位置
    `%ebp` + 4。第一个参数位于 `%ebp` + 8（即直接在返回地址下方），第二个参数位于 `%ebp` + 12。
- en: For any function with *n* arguments, GCC places the first argument at location
    `%ebp` + 8, the second at `%ebp` + 12, and the *n*th argument at location (`%ebp`
    + 8) + (4 × (*n –* 1)).
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何具有 *n* 个参数的函数，GCC 将第一个参数放置在位置 `%ebp` + 8，第二个放在 `%ebp` + 12，第 *n* 个参数放在位置
    (`%ebp` + 8) + (4 × (*n –* 1))。
- en: After the call to `printf`, the value 0x2A is output to the user in integer
    format. Thus, the value 42 is printed to the screen!
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `printf` 后，值 0x2A 以整数格式输出给用户。因此，值 42 被打印到屏幕上！
- en: '![image](../images/f0431-01.jpg)'
  id: totrans-482
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0431-01.jpg)'
- en: After the call to `printf`, the last few instructions clean up the stack and
    prepare a clean exit from the `main` function. First, the value 0x0 is placed
    in register `%eax`, signifying that the value 0 is returned from `main`. Recall
    that a program returns 0 to indicate correct termination.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `printf` 后，最后几条指令清理堆栈并准备从 `main` 函数干净地退出。首先，值 0x0 被放入寄存器 `%eax`，表示从 `main`
    返回值 0。回想一下，程序返回 0 表示正常终止。
- en: '![image](../images/f0432-01.jpg)'
  id: totrans-484
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0432-01.jpg)'
- en: After `leave` and `ret` are executed, the stack and frame pointers revert to
    their original values prior to the execution of `main`. With 0x0 in the return
    register `%eax`, the program returns 0.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行完 `leave` 和 `ret` 后，堆栈和帧指针会恢复到 `main` 执行前的原始值。返回寄存器 `%eax` 中的 0x0，程序返回 0。
- en: If you have carefully read through this section, you should understand why our
    program prints out the value 42\. In essence, the program inadvertently uses old
    values on the stack to cause it to behave in a way that we didn’t expect. While
    this example was pretty harmless, we discuss in future sections how hackers have
    misused function calls to make programs misbehave in truly malicious ways.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细阅读了本节内容，你应该明白为什么我们的程序会打印出值 42。实际上，程序不小心使用了堆栈上的旧值，导致它以我们没有预料到的方式执行。虽然这个例子相对无害，但我们将在后续章节中讨论黑客如何滥用函数调用，使程序以真正恶意的方式行为不端。
- en: 8.6 Recursion
  id: totrans-487
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.6 递归
- en: Recursive functions are a special class of functions that call themselves (also
    known as *self-referential* functions) to compute a value. Like their nonrecursive
    counterparts, recursive functions create new stack frames for each function call.
    Unlike standard functions, recursive functions contain function calls to themselves.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数是一类特殊的函数，它们通过调用自身（也称为 *自引用* 函数）来计算一个值。与非递归函数一样，递归函数会为每次函数调用创建新的堆栈帧。与标准函数不同，递归函数包含对自身的函数调用。
- en: 'Let’s revisit the problem of summing up the set of positive integers from 1
    to *n*. In previous sections, we discussed the `sumUp` function to achieve this
    task. The following code shows a related function called `sumDown`, which adds
    the numbers in reverse (*n* to 1), and its recursive equivalent `sumr`:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视从 1 到 *n* 的正整数求和问题。在前面的章节中，我们讨论了 `sumUp` 函数来实现这个任务。以下代码展示了一个相关的函数 `sumDown`，它按逆序（*n*
    到 1）加和，以及其递归等效函数 `sumr`：
- en: Iterative
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代的
- en: '[PRE50]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Recursive
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 递归
- en: '[PRE51]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The base case in the recursive function `sumr` accounts for any values of *n*
    that are less than one, and the recursive step adds the current value of *n* to
    the result of the function call to `sumr` with the value *n –* 1\. Compiling `sumr`
    with the `-m32` flag and disassembling it with GDB yields the following assembly
    code:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数 `sumr` 中的基本情况处理了任何小于 1 的 *n* 值，递归步骤将当前值 *n* 加到递归调用 `sumr`（值为 *n –* 1）的结果中。用
    `-m32` 标志编译 `sumr` 并用 GDB 反汇编得到以下汇编代码：
- en: '[PRE52]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Each line in the preceding assembly code is annotated with its English translation.
    Here, we show the corresponding `goto` form (first) and C program without `goto`
    statements (second):'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 上述汇编代码的每一行都注释了它的英文翻译。在这里，我们展示了对应的 `goto` 形式（第一种）和没有 `goto` 语句的 C 程序（第二种）：
- en: C goto form
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: C `goto` 形式
- en: '[PRE53]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: C version without goto
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 无 `goto` 的 C 版本
- en: '[PRE54]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Although this translation may not initially appear to be identical to the original
    `sumr` function, close inspection reveals that the two functions are indeed equivalent.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个翻译最初看起来可能与原始的 `sumr` 函数不完全相同，但仔细检查后会发现，两个函数实际上是等效的。
- en: '8.6.1 Animation: Observing How the Call Stack Changes'
  id: totrans-502
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.6.1 动画：观察调用栈如何变化
- en: As an exercise, we encourage you to draw out the stack and see how the values
    change. We have provided an animation online that depicts how the stack is updated
    when we run this function with the value 3.^([2](ch08.xhtml#fn8_2))
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，我们鼓励你绘制栈的变化，并查看值如何变化。我们已经在线提供了一个动画，展示了当我们以值3运行此函数时，栈如何更新。^([2](ch08.xhtml#fn8_2))
- en: 8.7 Arrays
  id: totrans-504
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.7 数组
- en: Recall that arrays (see “Introduction to Arrays” on [page 44](ch01.xhtml#lev2_9))
    are ordered collections of data elements of the same type that are contiguously
    stored in memory. Statically allocated single-dimension arrays (see the section
    “Single-Dimensional Arrays” on [page 81](ch02.xhtml#lev2_22)) have the form <type>
    `arr[N]`, where <type> is the data type, `arr` is the identifier associated with
    the array, and `N` is the number of data elements. Declaring an array statically
    as <type> `arr[N]` or dynamically as `arr = malloc(N*sizeof(` <type>`))` allocates
    `N` × `sizeof(` <type>`)` total bytes of memory, with `arr` pointing to it.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，数组（参见[第44页](ch01.xhtml#lev2_9)的“数组简介”）是同一类型数据元素的有序集合，并连续存储在内存中。静态分配的一维数组（参见[第81页](ch02.xhtml#lev2_22)的“一维数组”部分）形式为`<type>
    arr[N]`，其中`<type>`是数据类型，`arr`是与数组关联的标识符，`N`是数据元素的数量。声明一个静态数组为`<type> arr[N]`或动态声明为`arr
    = malloc(N*sizeof(<type>))`会分配`N` × `sizeof(<type>)`字节的总内存，并且`arr`指向它。
- en: To access the element at index `i` in array `arr`, use the syntax `arr[i]`.
    Compilers commonly convert array references into pointer arithmetic (see “Pointer
    Variables” on [page 67](ch02.xhtml#lev1_10)) prior to translating to assembly.
    So, `arr+i` is equivalent to `&arr[i]`, and `*(arr+i)` is equivalent to `arr[i]`.
    Since each data element in `arr` is of type <type>, `arr+i` implies that element
    `i` is stored at address `arr` + `sizeof(` <type>`)` × `i`.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问数组`arr`中索引为`i`的元素，可以使用语法`arr[i]`。编译器通常在转换为汇编语言之前，将数组引用转换为指针运算（参见[第67页](ch02.xhtml#lev1_10)的“指针变量”）。因此，`arr+i`等同于`&arr[i]`，`*(arr+i)`等同于`arr[i]`。由于`arr`中的每个数据元素都是类型`<type>`，因此`arr+i`意味着元素`i`存储在地址`arr
    + sizeof(<type>) × i`处。
- en: '[Table 8-17](ch08.xhtml#ch8tab17) outlines some common array operations and
    their corresponding assembly instructions. Assume that register `%edx` stores
    the address of `arr`, register `%ecx` stores the value `i`, and register `%eax`
    represents some variable `x`.'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '[表8-17](ch08.xhtml#ch8tab17)列出了常见的数组操作及其对应的汇编指令。假设寄存器`%edx`存储`arr`的地址，寄存器`%ecx`存储值`i`，寄存器`%eax`表示某个变量`x`。'
- en: '**Table 8-17:** Common Array Operations and Their Corresponding Assembly Representations'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '**表8-17：** 常见数组操作及其对应的汇编表示'
- en: '| **Operation** | **Type** | **Assembly Representation** |'
  id: totrans-509
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **类型** | **汇编表示** |'
- en: '| `x = arr` | `int *` | `movl %edx,%eax` |'
  id: totrans-510
  prefs: []
  type: TYPE_TB
  zh: '| `x = arr` | `int *` | `movl %edx,%eax` |'
- en: '| `x = arr[0]` | `int` | `movl (%edx),%eax` |'
  id: totrans-511
  prefs: []
  type: TYPE_TB
  zh: '| `x = arr[0]` | `int` | `movl (%edx),%eax` |'
- en: '| `x = arr[i]` | `int` | `movl (%edx,%ecx,4),%eax` |'
  id: totrans-512
  prefs: []
  type: TYPE_TB
  zh: '| `x = arr[i]` | `int` | `movl (%edx,%ecx,4),%eax` |'
- en: '| `x = &arr[3]` | `int *` | `leal 0xc(%edx),%eax` |'
  id: totrans-513
  prefs: []
  type: TYPE_TB
  zh: '| `x = &arr[3]` | `int *` | `leal 0xc(%edx),%eax` |'
- en: '| `x = arr+3` | `int *` | `leal 0xc(%edx),%eax` |'
  id: totrans-514
  prefs: []
  type: TYPE_TB
  zh: '| `x = arr+3` | `int *` | `leal 0xc(%edx),%eax` |'
- en: '| `x = *(arr+3)` | `int` | `movl 0xc(%edx),%eax` |'
  id: totrans-515
  prefs: []
  type: TYPE_TB
  zh: '| `x = *(arr+3)` | `int` | `movl 0xc(%edx),%eax` |'
- en: Pay close attention to the *type* of each expression in [Table 8-17](ch08.xhtml#ch8tab17).
    In general, the compiler uses `movl` instructions to dereference pointers and
    the `leal` instruction to compute addresses.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 请特别注意[表8-17](ch08.xhtml#ch8tab17)中每个表达式的*类型*。通常，编译器使用`movl`指令来解引用指针，使用`leal`指令来计算地址。
- en: Notice that to access element `arr[3]` (or `*(arr+3)` using pointer arithmetic),
    the compiler performs a memory lookup on address `arr+3*4` instead of `arr+3`.
    To understand why this is necessary, recall that any element at index `i` in an
    array is stored at address `arr + sizeof(` <type>`) * i`. The compiler must therefore
    multiply the index by the size of the data type to compute the correct offset.
    Recall also that memory is byte-addressable; offsetting by the correct number
    of bytes is the same as computing an address.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，要访问元素`arr[3]`（或使用指针运算`*(arr+3)`），编译器会在地址`arr+3*4`上执行内存查找，而不是`arr+3`。为了理解为什么这样做是必要的，回想一下，数组中索引为`i`的任何元素都存储在地址`arr
    + sizeof(<type>) * i`上。因此，编译器必须将索引乘以数据类型的大小，以计算正确的偏移量。还要记住，内存是按字节寻址的；按正确字节数偏移等同于计算地址。
- en: As an example, consider a sample array (`array`) with five integer elements
    ([Figure 8-6](ch08.xhtml#ch8fig6)).
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，考虑一个包含五个整数元素的数组（`array`）（参见[图8-6](ch08.xhtml#ch8fig6)）。
- en: '![image](../images/08fig06.jpg)'
  id: totrans-519
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig06.jpg)'
- en: '*Figure 8-6: The layout of a five-integer array in memory. Each *x*[*i*]-labeled
    box represents one byte, each `int` is four bytes.*'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-6：内存中五个整数数组的布局。每个标记为*x*[i]的框代表一个字节，每个`int`占四个字节。*'
- en: Notice that since `array` is an array of integers, each element takes up exactly
    four bytes. Thus, an integer array with five elements consumes 20 bytes of contiguous
    memory.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到由于`array`是一个整数数组， 每个元素占用四个字节。因此，一个包含五个元素的整数数组会占用20个字节的连续内存。
- en: To compute the address of element 3, the compiler multiplies the index 3 by
    the data size of the integer type (4) to yield an offset of 12\. Sure enough,
    element 3 in [Figure 8-6](ch08.xhtml#ch8fig6) is located at byte offset *x*[12].
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算元素3的地址，编译器将索引3乘以整数类型的数据大小（4），得到偏移量12。果然，图[8-6](ch08.xhtml#ch8fig6)中的元素3位于字节偏移量*x*[12]。
- en: 'Let’s take a look at a simple C function called `sumArray` that sums up all
    the elements in an array:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个简单的C函数`sumArray`，它对数组中的所有元素进行求和：
- en: '[PRE55]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `sumArray` function takes the address of an array and the array’s associated
    length and sums up all the elements in the array. Now take a look at the corresponding
    assembly for the `sumArray` function:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '`sumArray`函数接受一个数组的地址和数组的长度，并对数组中的所有元素进行求和。现在，看看`sumArray`函数对应的汇编代码：'
- en: '[PRE56]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: When tracing this assembly code, consider whether the data being accessed represents
    an address or a value. For example, the instruction at `<sumArray+13>` results
    in `%ebp-4` containing a variable of type `int`, which is initially set to 0\.
    In contrast, the argument stored at `%ebp+8` is the first argument to the function
    (`array`) which is of type `int *` and corresponds to the base address of the
    array. A different variable (which we call `total`) is stored at location `%ebp-8`.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 在跟踪这些汇编代码时，要考虑所访问的数据是表示地址还是值。例如，位于`<sumArray+13>`的指令导致`%ebp-4`包含一个`int`类型的变量，该变量最初被设置为0。与此不同，存储在`%ebp+8`的参数是函数的第一个参数（`array`），它是`int
    *`类型，表示数组的基地址。另一个变量（我们称之为`total`）存储在`%ebp-8`的位置。
- en: 'Let’s take a closer look at the five instructions between locations `<sumArray+22>`
    and `<sumArray+39>`:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看位于`<sumArray+22>`和`<sumArray+39>`之间的五条指令：
- en: '[PRE57]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Recall that the compiler commonly uses `lea` to perform simple arithmetic on
    operands. The operand `0x0(,%eax,4)` translates to `%eax*4 + 0x0`. Since `%eax`
    holds the value `i`, this operation copies the value `i*4` to `%edx`. At this
    point, `%edx` contains the number of bytes that must be added to calculate the
    correct offset of `array[i]`.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，编译器通常使用`lea`来对操作数执行简单的算术运算。操作数`0x0(,%eax,4)`可以转换为`%eax*4 + 0x0`。由于`%eax`存储的是`i`的值，这个操作将值`i*4`复制到`%edx`。此时，`%edx`包含必须添加的字节数，以便计算出`array[i]`的正确偏移量。
- en: The next instruction (`mov 0x8(%ebp),%eax`) copies the first argument (the base
    address of `array`) into `%eax`. Adding `%edx` to `%eax` in the next instruction
    causes `%eax` to contain `array+i*4`. Recall that the element at index `i` in
    `array` is stored at address `array + sizeof(` <type>`) * i`. Therefore, `%eax`
    now contains the assembly-level computation of the address `&array[i]`.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条指令（`mov 0x8(%ebp),%eax`）将第一个参数（`array`的基地址）复制到`%eax`中。在下一条指令中将`%edx`加到`%eax`中，使得`%eax`包含`array+i*4`。回想一下，`array`中索引为`i`的元素存储在地址`array
    + sizeof(<type>) * i`处。因此，`%eax`现在包含`&array[i]`的汇编级别计算地址。
- en: The instruction at `<sumArray+37>` *dereferences* the value located at `%eax`,
    placing the value `array[i]` into `%eax`. Lastly, `%eax` is added to the value
    in `%ebp-8`, or `total`. Thus, the five instructions between locations `<sumArray+22>`
    and `<sumArray+39>` correspond to the line `total += array[i]` in the `sumArray`
    function.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 位于`<sumArray+37>`的指令*解引用*了位于`%eax`的值，将`array[i]`的值放入`%eax`中。最后，`%eax`被加到`%ebp-8`中的值，或者叫做`total`。因此，位于`<sumArray+22>`和`<sumArray+39>`之间的五条指令对应于`sumArray`函数中的行`total
    += array[i]`。
- en: 8.8 Matrices
  id: totrans-533
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.8 矩阵
- en: 'A matrix is a 2D array. A matrix in the C language can be statically allocated
    as a 2D array (`M[n][m]`), dynamically allocated with a single call to `malloc`,
    or dynamically allocated as an array of arrays. Let’s consider the array of arrays
    implementation. The first array contains `n` elements (`M[n]`), and each element
    `M[i]` in our matrix contains an array of `m` elements. The following code snippets
    each declare matrices of size 4 × 3:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵是一个二维数组。在C语言中，矩阵可以作为二维数组（`M[n][m]`）静态分配内存，或者通过一次调用`malloc`动态分配内存，或者作为数组的数组进行动态分配。我们来考虑数组的数组实现。第一个数组包含`n`个元素（`M[n]`），我们的矩阵中每个元素`M[i]`包含一个`m`个元素的数组。以下代码片段声明了大小为4
    × 3的矩阵：
- en: '[PRE58]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In the case of the dynamically allocated matrix, the main array contains a contiguous
    array of `int` pointers. Each integer pointer points to a different array in memory.
    [Figure 8-7](ch08.xhtml#ch8fig7) illustrates how we would normally visualize each
    of these matrices.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 在动态分配的矩阵中，主数组包含一个连续的`int`指针数组。每个整数指针指向内存中的不同数组。[图 8-7](ch08.xhtml#ch8fig7)说明了我们通常如何可视化每个矩阵。
- en: '![image](../images/08fig07.jpg)'
  id: totrans-537
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig07.jpg)'
- en: '*Figure 8-7: Illustration of a statically allocated (`M1`) and dynamically
    allocated (`M2`) 3 × 4 matrix*'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-7：静态分配（`M1`）和动态分配（`M2`）的 3 × 4 矩阵示意图*'
- en: For both of these matrix declarations, element (*i*, *j*) can be accessed using
    the double-indexing syntax `M[i][j]`, where `M` is either `M1` or `M2`. However,
    these matrices are organized differently in memory. Even though both store the
    elements in their primary array contiguously in memory, our statically allocated
    matrix also stores all the rows contiguously in memory, as shown in [Figure 8-8](ch08.xhtml#ch8fig8).
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两种矩阵声明，元素（*i*，*j*）可以通过双重索引语法`M[i][j]`来访问，其中`M`可以是`M1`或`M2`。然而，这些矩阵在内存中的组织方式不同。尽管两者都将元素在主数组中连续存储，但我们的静态分配矩阵还将所有行在内存中连续存储，如[图
    8-8](ch08.xhtml#ch8fig8)所示。
- en: '![image](../images/08fig08.jpg)'
  id: totrans-540
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig08.jpg)'
- en: '*Figure 8-8: Matrix `M1`’s memory layout in row-major order*'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-8：矩阵`M1`按行优先顺序的内存布局*'
- en: 'This contiguous ordering is not guaranteed for `M2`. Recall (from “Two-Dimensional
    Array Memory Layout” on [page 86](ch02.xhtml#lev3_13)) that to contiguously allocate
    an *n* × *m* matrix on the heap, we should use a single call to `malloc` that
    allocates *n* × *m* elements:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`M2`，这种连续排序无法得到保证。回想一下（在[第86页](ch02.xhtml#lev3_13)的“二维数组内存布局”中）提到的，要在堆上连续分配一个*n*
    × *m* 矩阵，我们应该使用一次`malloc`调用来分配*n* × *m* 个元素：
- en: '[PRE59]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Recall that with the declaration of `M3`, element (*i*, *j*) *cannot* be accessed
    using the `M[i][j]` notation. Instead, we must index the element using the format
    `M3[i*cols + j]`.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在声明`M3`时，元素（*i*，*j*）*不能*通过`M[i][j]`符号来访问。相反，我们必须使用格式`M3[i*cols + j]`来索引该元素。
- en: 8.8.1 Contiguous Two-Dimensional Arrays
  id: totrans-545
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.8.1 连续二维数组
- en: Consider a function `sumMat` that takes a pointer to a contiguously allocated
    (either statically allocated or memory-efficiently dynamically allocated) matrix
    as its first parameter, along with the numbers of rows and columns, and returns
    the sum of all the elements inside the matrix.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个函数`sumMat`，它将指向一个连续分配的矩阵（无论是静态分配还是内存高效的动态分配矩阵）作为第一个参数，另外还需要行数和列数，并返回矩阵内所有元素的和。
- en: We use scaled indexing in the code snippet that follows because it applies to
    both statically and dynamically allocated contiguous matrices. Recall that the
    syntax `m[i][j]` does not work with the memory-efficient contiguous dynamic allocation
    previously discussed.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在接下来的代码片段中使用了缩放索引，因为它适用于静态和动态分配的连续矩阵。回想一下，语法`m[i][j]`在之前讨论的内存高效的连续动态分配方式中不起作用。
- en: '[PRE60]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Here is the corresponding assembly. Each line is annotated with its English
    translation:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是相应的汇编代码。每一行都附有其英文翻译：
- en: '[PRE61]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The local variables `i`, `j`, and `total` are loaded at addresses `%ebp-4`,
    `%ebp-8`, and `%ebp-12` on the stack, respectively. The input parameters `m`,
    `row`, and `cols` are located at locations `%ebp+8`, `%ebp+12`, and `%ebp+16`,
    respectively. Using this knowledge, let’s zoom in on the component that just deals
    with the access of element (*i*, *j*) in our matrix:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量`i`、`j`和`total`分别存储在栈的地址`%ebp-4`、`%ebp-8`和`%ebp-12`中。输入参数`m`、`row`和`cols`分别存储在`%ebp+8`、`%ebp+12`和`%ebp+16`的位置。利用这些知识，让我们聚焦于仅处理矩阵中元素（*i*，*j*）访问的部分：
- en: '[PRE62]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The first set of instructions computes `i * cols` and places the result in register
    `%edx`. Recall that for a matrix named `matrix`, `matrix + (i * cols)` is equivalent
    to `&matrix[i]`.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组指令计算`i * cols`并将结果存入寄存器`%edx`。回想一下，对于名为`matrix`的矩阵，`matrix + (i * cols)`等同于`&matrix[i]`。
- en: '[PRE63]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The next set of instructions computes `(i * cols + j) * 4`. The compiler multiplies
    the index `(i * cols) + j` by four because each element in the matrix is a four-byte
    integer, and this multiplication enables the compiler to calculate the correct
    offset.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 下一组指令计算`(i * cols + j) * 4`。编译器将索引`(i * cols) + j`乘以四，因为矩阵中的每个元素是一个四字节的整数，这个乘法使编译器能够计算出正确的偏移量。
- en: 'The last set of instructions adds the calculated offset to the matrix pointer
    and dereferences it to yield the value of element (*i*, *j*):'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The first instruction loads the address of matrix `m` into register `%eax`.
    The `add` instruction adds the offset `(i*cols + j)*4` to the address of `m` to
    correctly calculate the address of element (*i*, *j*) and then places this address
    in register `%eax`. The third instruction dereferences `%eax` and places the resulting
    value in register `%eax`. The last instruction adds the value in `%eax` to the
    accumulator `total`, which is located at stack address `%ebp-0xc`.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider how element (1,2) is accessed in [Figure 8-9](ch08.xhtml#ch8fig9).
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig09.jpg)'
  id: totrans-560
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-9: Matrix `M1`’s memory layout in row-major order*'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: Element (1,2) is located at address `M1 + (1 * COLS) + 2`. Since `COLS` = 3,
    element (1,2) corresponds to `M1+5`. To access the element at this location, the
    compiler must multiply 5 by the size of the `int` data type (four bytes), yielding
    the offset `M1+20`, which corresponds to byte *x*[20] in the figure. Dereferencing
    this location yields element 5, which is indeed element (1,2) in the matrix.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: 8.8.2 Noncontiguous Matrix
  id: totrans-563
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The noncontiguous matrix implementation is a bit more complicated. [Figure 8-10](ch08.xhtml#ch8fig10)
    visualizes how `M2` may be laid out in memory.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig10.jpg)'
  id: totrans-565
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-10: Matrix `M2`’s noncontiguous layout in memory*'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the array of pointers is contiguous, and that each array pointed
    to by an element of `M2` (e.g., `M2[i]`) is contiguous. However, the individual
    arrays are not contiguous with one another.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sumMatrix` function in the following example takes an array of integer
    pointers (called `matrix`) as its first parameter, and a number of rows and columns
    as its second and third parameters:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Even though this function looks nearly identical to the `sumMat` function shown
    earlier, the matrix accepted by this function consists of a contiguous array of
    *pointers*. Each pointer contains the address of a separate contiguous array,
    which corresponds to a separate row in the matrix.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: The corresponding assembly for `sumMatrix` follows. Each line is annotated with
    its English translation.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Again, the variables `i`, `j`, and `total` are at stack addresses `%ebp-4`,
    `%ebp-8`, and `%ebp-12`, respectively. The input parameters `m`, `row`, and `cols`
    are located at stack addresses `%ebp+8`, `%ebp+12`, and `%ebp+16`, respectively.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s zoom in on the section that deals specifically with an access to element
    (*i*, *j*), or `matrix[i][j]`:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The five instructions between `<sumMatrix+31>` and `<sumMatrix+46>` compute
    `matrix[i]`, or `*(matrix+i)`. Note that the compiler needs to multiply `i` by
    four prior to adding it to `matrix` to calculate the correct offset (recall that
    pointers are four bytes in size). The instruction at `<sumMatrix+46>` then dereferences
    the calculated address to get the element `matrix[i]`.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: Since `matrix` is an array of `int` pointers, the element located at `matrix[i]`
    is itself an `int` pointer. The *j*th element in `matrix[i]` is located at offset
    *j* × 4 in the `matrix[i]` array.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `matrix` 是一个 `int` 指针数组，位于 `matrix[i]` 位置的元素本身是一个 `int` 指针。`matrix[i]` 中的第
    *j* 个元素位于 `matrix[i]` 数组的偏移量 *j* × 4 处。
- en: 'The next set of instructions extract the *j*th element in array `matrix[i]`:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的一组指令提取了 `matrix[i]` 数组中的第 *j* 个元素：
- en: '[PRE68]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The first instruction in this snippet loads variable `j` into register `%edx`.
    The compiler uses the left shift (`shl`) instruction to multiply `j` by four and
    stores the result in register `%edx`. The compiler then adds the resulting value
    to the address located in `matrix[i]` to get the address of `matrix[i][j]`.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的第一条指令将变量 `j` 加载到寄存器 `%edx` 中。编译器使用左移（`shl`）指令将 `j` 乘以 4，并将结果存储到寄存器 `%edx`
    中。然后，编译器将该值加到 `matrix[i]` 的地址上，以获取 `matrix[i][j]` 的地址。
- en: 'Let’s revisit [Figure 8-10](ch08.xhtml#ch8fig10) and consider an example access
    to `M2[1][2]` For convenience, we reproduce the figure in [Figure 8-11](ch08.xhtml#ch8fig11):'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下 [图 8-10](ch08.xhtml#ch8fig10)，并考虑对 `M2[1][2]` 的访问示例。为了方便，我们在 [图 8-11](ch08.xhtml#ch8fig11)
    中重新呈现了该图：
- en: '![image](../images/08fig11.jpg)'
  id: totrans-582
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig11.jpg)'
- en: '*Figure 8-11: Matrix `M2`’s noncontiguous layout in memory*'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-11: 矩阵 `M2` 在内存中的非连续布局*'
- en: Note that `M2` starts at memory location *x*[0]. The compiler first computes
    the address of `M2[1]` by multiplying 1 by 4 (`sizeof(int *)`) and adding it to
    the address of `M2` (*x*[0]), yielding the new address *x*[4]. A dereference of
    this address yields the address associated with `M2[1]`, or *x*[36]. The compiler
    then multiplies index 2 by 4 (`sizeof(int)`), and adds the result (8) to *x*[36],
    yielding a final address of *x*[44]. The address *x*[44] is dereferenced, yielding
    the value 5\. Sure enough, the element in [Figure 8-11](ch08.xhtml#ch8fig11) that
    corresponds to `M2[1][2]` has the value 5.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`M2` 从内存位置 *x*[0] 开始。编译器首先通过将 1 乘以 4（`sizeof(int *)`），然后加到 `M2` 的地址（*x*[0]）来计算
    `M2[1]` 的地址，得出新的地址 *x*[4]。对这个地址进行解引用，得到与 `M2[1]` 相关联的地址，即 *x*[36]。然后，编译器将索引 2
    乘以 4（`sizeof(int)`），并将结果（8）加到 *x*[36]，得到最终地址 *x*[44]。对 *x*[44] 进行解引用，得到值 5。果然，在
    [图 8-11](ch08.xhtml#ch8fig11) 中，与 `M2[1][2]` 对应的元素值为 5。
- en: 8.9 structs in Assembly
  id: totrans-585
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.9 汇编中的结构体
- en: A `struct` (see “C Structs” on [page 103](ch02.xhtml#lev1_15)) is another way
    to create a collection of data types in C. Unlike arrays, structs enable different
    data types to be grouped together. C stores a `struct` like a single-dimension
    array, where the data elements (fields) are stored contiguously.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct`（请参阅 [第 103 页](ch02.xhtml#lev1_15) 中的“C 结构”）是 C 中创建数据类型集合的另一种方式。与数组不同，结构体允许将不同的数据类型组合在一起。C
    语言将 `struct` 存储为一个一维数组，数据元素（字段）按顺序连续存储。'
- en: 'Let’s revisit the `struct studentT` from [Chapter 1](ch01.xhtml#ch01):'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下 [第一章](ch01.xhtml#ch01) 中的 `struct studentT`：
- en: '[PRE69]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[Figure 8-12](ch08.xhtml#ch8fig12) shows how `student` is laid out in memory.
    For the sake of example, assume that `student` starts at address *x*[0]. Each
    *x*[*i*] denotes the address of a field.'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-12](ch08.xhtml#ch8fig12) 显示了 `student` 在内存中的布局。为了举例说明，假设 `student` 从地址
    *x*[0] 开始。每个 *x*[*i*] 表示某个字段的地址。'
- en: '![image](../images/08fig12.jpg)'
  id: totrans-590
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig12.jpg)'
- en: '*Figure 8-12: The memory layout of `struct studentT`*'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-12: `struct studentT` 的内存布局*'
- en: The fields are stored contiguously next to one another in memory in the order
    in which they are declared. In [Figure 8-12](ch08.xhtml#ch8fig12), the `age` field
    is allocated at the memory location directly after the `name` field (at byte offset
    *x*[64]) and is followed by the `grad_yr` (byte offset *x*[68]) and `gpa` (byte
    offset *x*[72]) fields. This organization enables memory-efficient access to the
    fields.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 字段按声明的顺序连续存储在内存中。在 [图 8-12](ch08.xhtml#ch8fig12) 中，`age` 字段分配在 `name` 字段之后的内存位置（字节偏移量
    *x*[64]），然后是 `grad_yr`（字节偏移量 *x*[68]）和 `gpa`（字节偏移量 *x*[72]）字段。这种组织方式使得访问字段更加高效节省内存。
- en: 'To understand how the compiler generates assembly code to work with a `struct`,
    consider the function `initStudent`:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解编译器如何生成汇编代码以操作 `struct`，请考虑函数 `initStudent`：
- en: '[PRE70]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The `initStudent` function uses the base address of a `struct studentT` as its
    first parameter, and the desired values for each field as its remaining parameters.
    The listing that follows depicts this function in assembly. In general, parameter
    *i* to function `initStudent` is located at stack address `(ebp+8)` + 4 × *i*.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Being mindful of the byte offsets of each field is key to understanding this
    code. Here are a few things to keep in mind.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: The `strncpy` call takes the base address of the `name` field of `s`, the address
    of array `nm`, and a length specifier as its three arguments. Recall that because
    `name` is the first field in `struct studentT`, the address of `s` is synonymous
    with the address of `s->name`.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The next part (instructions `<initStudent+28>` through `<initStudent+35>`) places
    the value of the `gr` parameter at an offset of 68 from the start of `s`. Revisiting
    the memory layout in [Figure 8-12](ch08.xhtml#ch8fig12) shows that this address
    corresponds to `s->grad_yr`.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The next section (instructions `<initStudent+38>` through `<initStudent+53>`)
    copies the `ag` parameter to the `s->age` field. Afterward, the `g` parameter
    value is copied to the `s->gpa` field (byte offset 72):'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 8.9.1 Data Alignment and structs
  id: totrans-604
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider the following modified declaration of `struct studentT`:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The size of the `name` field is modified to be 63 bytes, instead of the original
    64\. Consider how this affects the way the `struct` is laid out in memory. It
    may be tempting to visualize it as in [Figure 8-13](ch08.xhtml#ch8fig13).
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig13.jpg)'
  id: totrans-608
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-13: An incorrect memory layout for the updated `struct` `studentTM`.
    Note that the `name` field is reduced from 64 to 63 bytes.*'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: In this depiction, the `age` field occupies the byte immediately following the
    `name` field. But this is incorrect. [Figure 8-14](ch08.xhtml#ch8fig14) depicts
    the actual layout in memory.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig14.jpg)'
  id: totrans-611
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-14: The correct memory layout for the updated `struct` `studentTM`.
    Byte *x*[63] is added by the compiler to satisfy memory alignment constraints,
    but it doesn’t correspond to any of the fields.*'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: IA32’s alignment policy requires that two-byte data types (i.e., `short`) reside
    at a two-byte-aligned address, whereas four-byte data types (`int`, `float`, `long`,
    and pointer types) reside at four-byte-aligned addresses, and eight-byte data
    types (`double`, `long long`) reside at eight-byte-aligned addresses. For a `struct`,
    the compiler adds empty bytes as *padding* between fields to ensure that each
    field satisfies its alignment requirements. For example, in the `struct` declared
    in the previous code snippet, the compiler adds a byte of empty space (or padding)
    at byte *x*[63] to ensure that the `age` field starts at an address that is at
    a multiple of four. Values aligned properly in memory can be read or written in
    a single operation, enabling greater efficiency.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider what happens when a `struct` is defined as follows:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Moving the `name` array to the end ensures that `age`, `grad_yr`, and `gpa`
    are four-byte aligned. Most compilers will remove the filler byte at the end of
    the `struct`. However, if the `struct` is ever used in the context of an array
    (e.g., `struct studentTM courseSection[20];`) the compiler will again add the
    filler byte as padding between each `struct` in the array to ensure that alignment
    requirements are properly met.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: '8.10 Real World: Buffer Overflow'
  id: totrans-617
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The C language does not perform automatic array bounds checking. Accessing memory
    outside of the bounds of an array is problematic and often results in errors such
    as segmentation faults. However, a clever attacker can inject malicious code that
    intentionally overruns the boundary of an array (also known as a *buffer*) to
    force the program to execute in an unintended manner. In the worst cases, the
    attacker can run code that allows them to gain *root privilege*, or OS-level access
    to the computer system. A piece of software that takes advantage of the existence
    of a known buffer overrun error in a program is known as a *buffer overflow exploit*.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we use GDB and assembly language to fully characterize the
    mechanics of a buffer overflow exploit. Prior to reading this chapter we encourage
    you to explore “Debugging Assembly Code” on [page 177](ch03.xhtml#lev1_24).
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: 8.10.1 Famous Examples of Buffer Overflow
  id: totrans-620
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Buffer overflow exploits emerged in the 1980s and remained a chief scourge of
    the computing industry through the early parts of the 2000s. While many modern
    operating systems have protections against the simplest buffer overflow attacks,
    careless programming errors can still leave modern programs wide open to attack.
    Buffer overflow exploits have recently been discovered in Skype,^([3](ch08.xhtml#fn8_3))
    Android,^([4](ch08.xhtml#fn8_4)) Google Chrome,^([5](ch08.xhtml#fn8_5)) and others.
    Here are some notable historic examples of buffer overflow exploits.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: The Morris Worm
  id: totrans-622
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Morris Worm^([6](ch08.xhtml#fn8_6)) was released in 1998 on ARPANet from
    MIT (to hide that it was written by a student at Cornell) and exploited a buffer
    overrun vulnerability that existed in the Unix finger daemon (`fingerd`). In Linux
    and other Unix-like systems, a *daemon* is a type of process that continuously
    executes in the background, usually performing clean-up and monitoring tasks.
    The `fingerd` daemon returns a user-friendly report on a computer or person. Most
    crucially, the worm had a replication mechanism that caused it to be sent to the
    same computer multiple times, bogging down the system to an unusable state. Even
    though the author claimed that the worm was meant as a harmless intellectual exercise,
    the replication mechanism enabled the worm to spread easily and made it difficult
    to remove. In future years, other worms would employ buffer overflow exploits
    to gain unauthorized access into systems. Notable examples include Code Red (2001),
    MS-SQLSlammer (2003), and W32/Blaster (2003).
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: AOL Chat Wars
  id: totrans-624
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: David Auerbach,^([7](ch08.xhtml#fn8_7)) a former Microsoft engineer, detailed
    his experience with a buffer overflow during his efforts to integrate Microsoft’s
    Messenger Service (MMS) with AOL Instant Messenger in the late 1990s. Back then,
    AOL Instant Messenger (AIM) was *the* service to use if you wanted to instant
    message (or IM) friends and family. Microsoft tried to gain a foothold in this
    market by designing a feature in MMS that enabled MMS users to talk to their AIM
    “buddies.” Displeased, AOL patched their servers so that MMS could no longer connect
    to them. Microsoft engineers figured out a way for MMS clients to mimic the messages
    sent by AIM clients to AOL servers, making it difficult for AOL to distinguish
    between messages received by MMS and AIM. AOL responded by changing the way AIM
    sent messages, and MMS engineers duly changed their client’s messages to once
    again match AIM’s. This “chat war” continued until AOL started using a buffer
    overflow error *in their own client* to verify that sent messages came from AIM
    clients. Since MMS clients did not have the same vulnerability, the chat wars
    ended, with AOL as the victor.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: '8.10.2 A First Look: The Guessing Game'
  id: totrans-626
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To help you understand the mechanism of the buffer overflow attack, we provide
    a 32-bit executable of a simple program that enables the user to play a guessing
    game with the program. Download the `secret` executable^([8](ch08.xhtml#fn8_8))
    and extract it using the `tar` command:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Here, we provide a copy of the main file associated with the executable:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: main.c
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This game prompts the user to enter first a secret number and then a secret
    string to win the guessing game. The header file `other.h` contains the definition
    of the `getSecretCode` and `calculateValue` functions, but it is unavailable to
    us. How then can a user beat the program? Brute forcing the solution will take
    too long. One strategy is to analyze the `secret` executable in GDB and step through
    the assembly to reveal the secret number and string. The process of examining
    assembly code to reveal knowledge of how it works is commonly referred to as *reverse
    engineering*. Readers comfortable enough with GDB and reading assembly should
    be able to use GDB to reverse engineer the secret number and the secret string.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a different, sneakier way to win.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: 8.10.3 Taking a Closer Look (Under the C)
  id: totrans-634
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The program contains a potential buffer overrun vulnerability at the first call
    to `scanf`. To understand what is going on, let’s inspect the assembly code of
    the `main` function using GDB. Let’s also place a breakpoint at address 0x0804859f,
    which is the address of the instruction immediately before the call to `scanf`
    (placing the breakpoint at the address of `scanf` causes program execution to
    halt *inside* the call to `scanf`, not in `main`).
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[Figure 8-15](ch08.xhtml#ch8fig15) depicts the stack immediately before the
    call to `scanf`.'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig15.jpg)'
  id: totrans-638
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-15: The call stack immediately before the call to `scanf`*'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: Prior to the call to `scanf`, the arguments for `scanf` are preloaded onto the
    stack, with the first argument at the top of the stack, and the second argument
    one address below. The `lea` instruction at location `<main+21>` creates the reference
    for array `buf`.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: Now, suppose that the user enters `12345678` at the prompt. [Figure 8-16](ch08.xhtml#ch8fig16)
    illustrates what the stack looks like immediately after the call to `scanf` completes.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig16.jpg)'
  id: totrans-642
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-16: The call stack immediately after the call to `scanf` with input
    `12345678`*'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that the hex values for the ASCII encodings of the digits 0 to 9 are
    0x30 to 0x39, and that each stack memory location is four bytes long. The frame
    pointer is 56 bytes away from the stack pointer. Readers tracing along can confirm
    the value of `%ebp` by using GDB to print its value (`p` `$ebp`). In the example
    shown, the value of `%ebp` is 0xffffd428\. The following command allows the reader
    to inspect the 64 bytes (in hex) below register `%esp`:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This GDB command yields output that looks similar to the following:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Each line represents two 32-bit words. So, the first line represents the words
    at addresses 0xffffd3f0 and 0xffffd3f4\. Looking at the top of the stack, we can
    see the memory address associated with the string `"%s"` (or 0x0804871c) followed
    by the address of `buf` (or 0xffffd40c). Note that the address for `buf` is simply
    represented as 0x40c in the figures in this section.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: '**Note MULTIBYTE VALUES ARE STORED IN LITTLE-ENDIAN ORDER**'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding assembly segment, the byte at address 0xfffffd3f0 is 0x1c,
    the byte at address 0xfffffd3f1 is 0x87, the byte at address 0xfffffd3f2 is 0x04,
    and the byte at address 0xfffffd3f3 is 0x08\. However, the 32-bit *value* (which
    corresponds to the memory address of the string `"%s"`) at address 0xfffffd3f0
    is in fact 0x0804871c. Remember that because x86 is a little-endian system (see
    “Integer Byte Order on [page 224](ch04.xhtml#lev1_34)), the bytes for multibyte
    values such as addresses are stored in reverse order. Similarly, the bytes corresponding
    to the address of array `buf` (0xffffd40c) are stored in reverse order at address
    0xfffffd3f4.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: 'The bytes associated with address 0xffffd40c are located on the same line as
    those associated with address 0xffffd408 and are the second word on that line.
    Since the `buf` array is 12 bytes long, the elements associated with `buf` span
    the 12 bytes from address 0xffffd40c to 0xffffd417\. Inspecting the bytes at those
    addresses yields:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: At these locations, we can clearly see the hex representation of the input string
    12345678\. The null termination byte `\0` appears in the leftmost byte location
    at address 0xffffd414\. Recall that `scanf` terminates all strings with a null
    byte.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, 12345678 is not the secret number. Here is the output when we try
    to run `secret` with input string 12345678:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The `echo $?` command prints out the return value of the last executed command
    in the shell. In this case, the program returned 1 because the secret number we
    entered is wrong. Recall that by convention, programs return 0 when there are
    no errors. Our goal going forward is to trick the program to exit with a return
    value of 0, indicating that we won the game.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: '8.10.4 Buffer Overflow: First Attempt'
  id: totrans-657
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, let’s try typing in the string 1234567890123456789012345678901234:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Interesting! Now the program crashes with a segmentation fault, with return
    code 139\. [Figure 8-17](ch08.xhtml#ch8fig17) shows what the call stack for `main`
    looks like immediately after the call to `scanf` with this new input.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig17.jpg)'
  id: totrans-661
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-17: The call stack immediately after the call to `scanf` with input
    1234567890123456789012345678901234*'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: The input string is so long that it not only overwrote the value stored at address
    0x428, but it spilled over into the return address below the stack frame for `main`.
    Recall that when a function returns, the program tries to resume execution at
    the address specified by the return address. In this example, the program tries
    to resume execution at address 0xf7003433 after exiting `main`, which does not
    exist. So the program crashes with a segmentation fault.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: 'Rerunning the program in GDB (`input.txt` contains the input string above)
    reveals this devilry in action:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Notice that our input string blew past the stated limits of the array `buf`,
    overwriting all the other values stored on the stack. In other words, our string
    created a buffer overrun and corrupted the call stack, causing the program to
    crash. This process is also known as *smashing the stack*.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: '8.10.5 A Smarter Buffer Overflow: Second Attempt'
  id: totrans-667
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our first example smashed the stack by overwriting the `%ebp` register and return
    address with junk, causing the program to crash. An attacker whose goal is to
    simply crash a program would be satisfied at this point. However, our goal is
    to trick the guessing game to return 0, indicating that we won the game. We accomplish
    this by filling the call stack with data more meaningful than junk values. For
    example, we could overwrite the stack so that the return address is replaced with
    the address of `endGame`. Then, when the program attempts to return from `main`,
    it will instead execute `endGame` rather than crashing with a segmentation fault.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: 'To find out the address of `endGame`, let’s inspect `secret` again in GDB:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Observe that `endGame` starts at address 0x08048564\. [Figure 8-18](ch08.xhtml#ch8fig18)
    illustrates a sample exploit that forces `secret` to run the `endGame` function.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig18.jpg)'
  id: totrans-672
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-18: A sample string that can force `secret` to execute the `endGame`
    function*'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: Again, since x86 is a little-endian system in which the stack grows toward lower
    addresses, the bytes in the return address appear to be in reverse order.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: 'The following program illustrates how an attacker could construct the preceding
    exploit:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The `\x` before each number indicates that the number is formatted as the hexadecimal
    representation of a character. After defining `ebuff[]`, the `main` function simply
    prints it out, character by character. To get the associated byte string, compile
    and run this program as follows:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'To use the file `exploit` as input to `scanf`, it suffices to run `secret`
    with `exploit` as follows:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The program prints out “You are so wrong!” because the string contained in `exploit`
    is *not* the secret number. However, the program also prints out the string “You
    win!” Recall, though, that our goal is to trick the program to return 0\. In a
    larger system, where the notion of “success” is tracked by an external program,
    it is often most important what a program returns, not what it prints out.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: 'Checking the return value yields:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Our exploit works! We won the game!
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: 8.10.6 Protecting Against Buffer Overflow
  id: totrans-685
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The example we showed changed the control flow of the `secret` executable,
    forcing it to return a zero value associated with success. However, an exploit
    like this could do some real damage. Furthermore, some older computer systems
    *executed* bytes from stack memory. If an attacker placed bytes associated with
    assembly instructions on the call stack, the CPU would interpret the bytes as
    *real* instructions, enabling the attacker to force the CPU to execute *any arbitrary
    code of their choosing*. Fortunately, there are strategies that modern computer
    systems employ to make it more difficult for attackers to run buffer overflow
    exploits:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: '**Stack randomization.**   The OS allocates the starting address of the stack
    at a random location in stack memory, causing the position/size of the call stack
    to vary from one run of a program to another. Multiple machines running the same
    code would have different stack addresses. Modern Linux systems use stack randomization
    as a standard practice. However, a determined attacker can brute force the attack,
    by attempting to repeat attacks with different addresses. A common trick is to
    use a *NOP sled* (or slide), i.e., a large number of `nop` instructions, before
    the actual exploit code. Executing the `nop` instruction (`0x90`) has no effect,
    other than causing the program counter to increment to the next instruction. As
    long as the attacker can get the CPU to execute somewhere in the NOP sled, the
    NOP sled will eventually lead to the exploit code that follows it. Aleph One’s
    writeup^([9](ch08.xhtml#fn8_9)) details the mechanism of this type of attack.'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: '**Stack corruption detection.**   Another line of defense is to try to detect
    when the stack is corrupted. Recent versions of GCC use a stack protector known
    as a *canary* that acts as a guard between the buffer and the other elements of
    the stack. A canary is a value stored in a nonwriteable section of memory that
    can be compared to a value put on the stack. If the canary “dies” during a program’s
    execution, the program knows that it is under attack and aborts with an error
    message. A clever attacker can, however, replace the canary to prevent the program
    from detecting stack corruption.'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: '**Limiting executable regions.**   In this line of defense, executable code
    is restricted to only particular regions of memory. In other words, the call stack
    is no longer executable. However, even this defense can be defeated. In an attack
    utilizing *return-oriented programming* (ROP), an attacker can “cherry-pick” instructions
    in executable regions and jump from instruction to instruction to build an exploit.
    There are some famous examples of this online, especially in video games.^([10](ch08.xhtml#fn8_10))'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: However, the best line of defense is always the programmer. To prevent buffer
    overflow attacks on your programs, use C functions with *length specifiers* whenever
    possible and add code that performs array bounds checking. It is crucial that
    any defined arrays match the chosen length specifiers. [Table 8-18](ch08.xhtml#ch8tab18)
    lists some common “bad” C functions that are vulnerable to buffer overflow and
    the corresponding “good” function to use (assume that `buf` is allocated 12 bytes).
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-18:** C Functions with Length Specifiers'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instead of** | **Use** |'
  id: totrans-692
  prefs: []
  type: TYPE_TB
- en: '| `gets(buf)` | `fgets(buf, 12, stdin)` |'
  id: totrans-693
  prefs: []
  type: TYPE_TB
- en: '| `scanf("%s", buf)` | `scanf("%12s", buf)` |'
  id: totrans-694
  prefs: []
  type: TYPE_TB
- en: '| `strcpy(buf2, buf)` | `strncpy(buf2, buf, 12)` |'
  id: totrans-695
  prefs: []
  type: TYPE_TB
- en: '| `strcat(buf2, buf)` | `strncat(buf2, buf, 12)` |'
  id: totrans-696
  prefs: []
  type: TYPE_TB
- en: '| `sprintf(buf, "%d", num)` | `snprintf(buf, 12, "%d", num)` |'
  id: totrans-697
  prefs: []
  type: TYPE_TB
- en: 'The `secret2` binary^([11](ch08.xhtml#fn8_11)) no longer has the buffer overflow
    vulnerability. Here’s the `main` function of this new binary:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: main2.c
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Notice that we added a length specifier to all calls of `scanf`, causing the
    `scanf` function to stop reading from the input after the first 12 bytes are read.
    The exploit string no longer breaks the program:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Of course, any reader with basic reverse-engineering skills can still win the
    guessing game by analyzing the assembly code. If you haven’t tried to beat the
    program yet with reverse engineering, we encourage you to do so now.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  id: totrans-704
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[1.](ch08.xhtml#rfn8_1) Edsger Dijkstra,“Go To Statement Considered Harmful,”
    *Communications of the ACM* 11(3), pp. 147–148, 1968.'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: '[2.](ch08.xhtml#rfn8_2) *[https://diveintosystems.org/book/C8-IA32/recursion.html](https://diveintosystems.org/book/C8-IA32/recursion.html)*'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: '[3.](ch08.xhtml#rfn8_3) Mohit Kumar, “Critical Skype Bug Lets Hackers Remotely
    Execute Malicious Code,” *[https://thehackernews.com/2017/06/skype-crash-bug.html](https://thehackernews.com/2017/06/skype-crash-bug.html)*,
    2017.'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: '[4.](ch08.xhtml#rfn8_4) Tamir Zahavi-Brunner, “CVE-2017-13253: Buffer overflow
    in multiple Android DRM services,” *[https://blog.zimperium.com/cve-2017-13253-buffer-overflow-multiple-android-drm-services/](https://blog.zimperium.com/cve-2017-13253-buffer-overflow-multiple-android-drm-services/)*,
    2018.'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: '[5.](ch08.xhtml#rfn8_5) Tom Spring, “Google Patches ‘High Severity’ Browser
    Bug,” *[https://threatpost.com/google-patches-high-severity-browser-bug/128661/](https://threatpost.com/google-patches-high-severity-browser-bug/128661/)*,
    2017.'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: '[6.](ch08.xhtml#rfn8_6) Christopher Kelty, “The Morris Worm,” *Limn Magazine*,
    Issue 1: Systemic Risk, 2011\. *[https://limn.it/articles/the-morris-worm/](https://limn.it/articles/the-morris-worm/)*'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: '[7.](ch08.xhtml#rfn8_7) David Auerbach, “Chat Wars: Microsoft vs. AOL,” *NplusOne
    Magazine*, Issue 19, Spring 2014\. *[https://nplusonemag.com/issue-19/essays/chat-wars/](https://nplusonemag.com/issue-19/essays/chat-wars/)*'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: '[8.](ch08.xhtml#rfn8_8) *[https://diveintosystems.org/book/C8-IA32/_attachments/secret.tar.gz](https://diveintosystems.org/book/C8-IA32/_attachments/secret.tar.gz)*'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: '[9.](ch08.xhtml#rfn8_9) Aleph One, “Smashing the Stack for Fun and Profit,”
    *[http://insecure.org/stf/smashstack.html](http://insecure.org/stf/smashstack.html)*,
    1996.'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: '[10.](ch08.xhtml#rfn8_10) DotsAreCool, “Super Mario World Credit Warp” (Nintendo
    ROP example), *[https://youtu.be/vAHXK2wut_I](https://youtu.be/vAHXK2wut_I)*,
    2015.'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: '[11.](ch08.xhtml#rfn8_11) *[https://diveintosystems.org/book/C8-IA32/_attachments/secret2.tar.gz](https://diveintosystems.org/book/C8-IA32/_attachments/secret2.tar.gz)*'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
