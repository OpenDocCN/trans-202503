["```\n`--snip--`\n 50\n 51 int **userauth_passwd**(Authctxt *authctxt)\n 52 {\n 53         char *password, *newpass;\n 54         int authenticated = 0;\n 55         int change;\n 56         u_int len, newlen;\n 57\n 58         change = packet_get_char();\n 59         password = packet_get_string(&len);\n 60         if (change) {\n 61                 /* discard new password from packet */\n 62                 newpass = packet_get_string(&newlen);\n 63                 explicit_bzero(newpass, newlen);\n 64                 free(newpass);\n 65         }\n 66         packet_check_eom();\n 67\n 68         if (change)\n 69                 logit(\"password change not supported\");\n 70         else if (PRIVSEP(auth_password(authctxt, password)) == 1)\n 71                 authenticated = 1;\n 72         explicit_bzero(password, len);\n 73         free(password);\n 74         return authenticated;\n 75 }\n`--snip--`\n```", "```\n// SOURCE: loop.c\n\n// Since you're actually reading source code, here's a treat. Note the 'volatile'\n// keyword and guess why it's there. Hint: compile with and without 'volatile' and\n// check the difference in the disassembly.\nint main() {\n        volatile int count = 0;\n        const int MAX = 1000;\n        const int factor = 7;\n        int i;\n        gpio_set(1); // Trigger high\n        for (i = 0; i < MAX; i++) {\n                count+=factor;\n        }\n        gpio_set(0); // Trigger low\n        if (i != MAX || count != MAX*factor) {\n                printf(\"Glitch! %d %d %d\\n\", i, count, MAX);\n        } else {\n                printf(\"No luck, try again\\n\");\n        }\n        return 0;\n}\n```", "```\nmemcpy:\nLDMIA R1!,{R4-R7} ; Load registers R4,R5,R6,R7 with data at address in R1\n                  ; inc R1\nSTMIA R2!,{R4-R7} ; Store register content in R4,R5,R6,R7 at address in R2\n                  ; inc R2\nCMP R1,R3         ; End address in R3; are we done?\nBNE memcpy        ; Not done: jump to memcpy\n```", "```\nAddress 0000: 00001000 00001000 00001000 00001000\n`--snip--`\nAddress 0ff0: 00001000 00001000 00001000 00001000\nAddress 1000: <`attack code`>\n```", "```\n# Pseudocode for a clock fault injection test setup\n\nfor id in range(0, 19):\n     # Generate random fault parameters\n   1 wait_cycles = random.randint(0,1000)\n   2 glitch_cycles = random.randint(1,4)\n   3 freq = random.randrange(25,123,25)\n     basefreq = 25\n     # Program external glitcher\n     program_clock_glitcher(wait_cycles, glitch_cycles, freq)\n\n     # Make glitcher wait for trigger\n     arm_glitcher()\n\n     # Start target\n     run_looptest_on_target()\n\n     # Read response\n   4 output = read_count_from_target()\n   5 reset_target()\n\n     # Report\n     print(id, wait_cycles, glitch_cycles, freq, output)\n```"]