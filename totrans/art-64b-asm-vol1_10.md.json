["```\n    adc `dest`, `source` ; `dest` := `dest` + `source` + `C`\n    ```", "```\n .data\nX       oword   ?\nY       oword   ?\n```", "```\nmov rax, qword ptr X    ; Add together the LO 64 bits\nadd rax, qword ptr Y    ; of the numbers and store the\nmov qword ptr Z, rax    ; result into the LO qword of Z\n\nmov rax, qword ptr X[8] ; Add together (with carry) the\nadc rax, qword ptr Y[8] ; HO 64 bits and store the result\nmov qword ptr Z[8], rax ; into the HO qword of Z\n```", "```\n .data\nBigVal1 qword  4 dup (?)\nBigVal2 qword  4 dup (?)\nBigVal3 qword  4 dup (?)   ; Holds the sum\n     .\n     .\n     .\n; Note that there is no need for \"qword ptr\"\n; because the base type of BitVal`x` is qword.\n\n    mov rax, BigVal1[0]\n    add rax, BigVal2[0]\n    mov BigVal3[0], rax\n\n    mov rax, BigVal1[8]\n    adc rax, BigVal2[8]\n    mov BigVal3[8], rax\n\n    mov rax, BigVal1[16]\n    adc rax, BigVal2[16]\n    mov BigVal3[16], rax\n\n    mov rax, BigVal1[24]\n    adc rax, BigVal2[24]\n    mov BigVal3[24], rax\n```", "```\n .data\nLeft    oword   ?\nRight   oword   ?\nDiff    oword   ?\n         .\n         .\n         .\n    mov rax, qword ptr Left\n    sub rax, qword ptr Right\n    mov qword ptr Diff, rax\n\n    mov rax, qword ptr Left[8]\n    sbb rax, qword ptr Right[8]\n    mov qword ptr Diff[8], rax\n```", "```\n .data\nBigVal1  qword 4 dup (?)\nBigVal2  qword 4 dup (?)\nBigVal3  qword 4 dup (?)\n .\n     .\n     .\n\n; Compute BigVal3 := BigVal1 - BigVal2.\n\n; Note: don't need to coerce types of\n; BigVa1, BigVal2, or BigVal3 because\n; their base types are already qword.\n\n    mov rax, BigVal1[0]\n    sub rax, BigVal2[0]\n    mov BigVal3[0], rax\n\n    mov rax, BigVal1[8]\n    sbb rax, BigVal2[8]\n    mov BigVal3[8], rax\n\n    mov rax, BigVal1[16]\n    sbb rax, BigVal2[16]\n    mov BigVal3[16], rax\n\n    mov rax, BigVal1[24]\n    sbb rax, BigVal2[24]\n    mov BigVal3[24], rax\n```", "```\n; This sequence transfers control to location \"IsGreater\" if\n; QwordValue > QwordValue2\\. It transfers control to \"IsLess\" if\n; QwordValue < QwordValue2\\. It falls through to the instruction\n; following this sequence if QwordValue = QwordValue2\\. \n; To test for inequality, change the \"IsGreater\" and \"IsLess\"\n; operands to \"NotEqual\" in this code.\n\n mov rax, qword ptr QWordValue[8]  ; Get HO qword\n        cmp rax, qword ptr QWordValue2[8]\n        jg  IsGreater\n        jl  IsLess;\n\n        mov rax, qword ptr QWordValue[0]  ; If HO qwords equal,\n        cmp rax, qword ptr QWordValue2[0] ; then we must compare\n        jg  IsGreater;                    ; the LO dwords\n        jl  IsLess;\n\n; Fall through to this point if the two values were equal.\n```", "```\n .data\nOW1     oword  ?\nOW2     oword  ?\n\nOW1q    textequ <qword ptr OW1>\nOW2q    textequ <qword ptr OW2>\n```", "```\n mov rax, OW1q[8]    ; Get HO dword\n    cmp rax, OW2q[8]\n    jg  NotLess\n    jl  IsLess\n\n    mov rax, OW1q[0]    ; Fall through to here if the HO\n    cmp rax, OW2q[0]    ; qwords are equal\n    jl  IsLess\nNotLess:\n```", "```\n mov rax, OW1q[8]    ; Get HO dword\n    cmp rax, OW2q[8]\n    jg  NotLessEQ\n    jl  IsLessEQ\n\n mov rax, QW1q[0]    ; Fall through to here if the HO\n    cmp rax, QW2q[0]    ; qwords are equal\n    jle IsLessEQ\nNotLessEQ:\n```", "```\n mov rax, QW1q[8]    ; Get HO dword\n    cmp rax, QW2q[8]\n    jg  IsGtr\n    jl  NotGtr\n\n    mov rax, QW1q[0]    ; Fall through to here if the HO\n    cmp rax, QW2q[0]    ; qwords are equal\n    jg  IsGtr\nNotGtr:\n```", "```\n mov rax, QW1q[8]    ; Get HO dword\n    cmp rax, QW2q[8]\n    jg  IsGtrEQ\n    jl  NotGtrEQ\n\n    mov rax, QW1q[0]    ; Fall through to here if the HO\n    cmp rax, QW2q[0]    ; qwords are equal\n    jge IsGtrEQ\nNotGtrEQ:\n```", "```\n mov rax, QW1q[8]    ; Get HO dword\n    cmp rax, QW2q[8]\n    jne NotEqual\n\n    mov rax, QW1q[0]    ; Fall through to here if the HO\n    cmp rax, QW2q[0]    ; qwords are equal\n    je  IsEqual\nNotEqual:\n```", "```\n mov rax, QW1q[8]    ; Get HO dword\n    cmp rax, QW2q[8]\n    jne IsNotEqual\n\n mov rax, QW1q[0]    ; Fall through to here if the HO\n    cmp rax, QW2q[0]    ; qwords are equal\n    jne IsNotEqual\n\n; Fall through to this point if they are equal.\n```", "```\n .data\nBig1    qword  4 dup (?)\nBig2    qword  4 dup (?)\n         .\n         .\n         .\n        mov rax, Big1[24]\n        cmp rax, Big2[24]\n        jb  isLE\n        ja  notLE\n\n        mov rax, Big1[16]\n        cmp rax, Big2[16]\n        jb  isLE\n        ja  notLE\n\n        mov rax, Big1[8]\n        cmp rax, Big2[8]\n        jb  isLE\n        ja  notLE\n\n        mov  rax, Big1[0]\n        cmp  rax, Big2[0]\n        jnbe notLE\nisLE:\n        `Code to execute if Big1 <= Big2`\n          .\n          .\n          .\nnotLE:\n        `Code to execute if Big1 > Big2`\n```", "```\n; Listing 8-1\n\n; 128-bit multiplication.\n\n        option  casemap:none\n\nnl          =       10\n\n            .const\nttlStr      byte    \"Listing 8-1\", 0\nfmtStr1     byte    \"%d * %d = %I64d (verify:%I64d)\", nl, 0\n\n .data\nop1         qword   123456789\nop2         qword   234567890\nproduct     oword   ?\nproduct2    oword   ?\n\n            .code\n            externdef printf:proc\n\n; Return program title to C++ program:\n\n            public  getTitle\ngetTitle    proc\n            lea     rax, ttlStr\n            ret\ngetTitle    endp\n\n; mul64 - Multiplies two 64-bit values passed in RDX and RAX by\n;         doing a 64x64-bit multiplication, producing a 128-bit result.\n;         Algorithm is easily extended to 128x128 bits by switching the\n;         32-bit registers for 64-bit registers.\n\n; Stores result to location pointed at by R8.\n\nmul64       proc\nmp          equ     <dword ptr [rbp - 8]>     ; Multiplier\nmc          equ     <dword ptr [rbp - 16]>    ; Multiplicand\nprd         equ     <dword ptr [r8]>          ; Result\n\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 24\n\n            push    rbx     ; Preserve these register values\n            push    rcx\n\n; Save parameters passed in registers:\n\n            mov     qword ptr mp, rax\n            mov     qword ptr mc, rdx\n\n; Multiply the LO dword of multiplier times multiplicand.\n\n            mov eax, mp\n            mul mc          ; Multiply LO dwords\n            mov prd, eax    ; Save LO dword of product\n            mov ecx, edx    ; Save HO dword of partial product result\n\n            mov eax, mp\n            mul mc[4]       ; Multiply mp(LO) * mc(HO)\n            add eax, ecx    ; Add to the partial product\n            adc edx, 0      ; Don't forget the carry!\n mov ebx, eax    ; Save partial product for now\n            mov ecx, edx\n\n; Multiply the HO word of multiplier with multiplicand.\n\n            mov eax, mp[4]  ; Get HO dword of multiplier\n            mul mc          ; Multiply by LO word of multiplicand\n            add eax, ebx    ; Add to the partial product\n            mov prd[4], eax ; Save the partial product\n            adc ecx, edx    ; Add in the carry!\n\n            mov eax, mp[4]  ; Multiply the two HO dwords together\n            mul mc[4]\n            add eax, ecx    ; Add in partial product\n            adc edx, 0      ; Don't forget the carry!\n\n            mov prd[8], eax ; Save HO qword of result\n            mov prd[12], edx\n\n; EDX:EAX contains 64-bit result at this point.\n\n            pop     rcx     ; Restore these registers\n            pop     rbx\n            leave\n            ret    \nmul64       endp\n\n; Here is the \"asmMain\" function.\n\n            public  asmMain\nasmMain     proc\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 64         ; Shadow storage\n\n; Test the mul64 function:\n\n            mov     rax, op1\n            mov     rdx, op2\n            lea     r8, product\n            call    mul64\n\n; Use a 64-bit multiply to test the result:\n\n            mov     rax, op1\n            mov     rdx, op2\n            imul    rax, rdx\n            mov     qword ptr product2, rax\n\n; Print the results:\n\n            lea     rcx, fmtStr1\n            mov     rdx, op1\n mov     r8,  op2\n            mov     r9,  qword ptr product\n            mov     rax, qword ptr product2\n            mov     [rsp + 32], rax\n            call    printf\n\n            leave\n            ret     ; Returns to caller\n\nasmMain     endp\n            end\n```", "```\n; This code does *NOT* work!\n\nmov rax, qword ptr dividend[0]    ; Get dividend into EDX:EAX\nmov rdx, qword ptr dividend[8]\ndiv divisor                       ; Divide RDX:RAX by divisor\n```", "```\n .data\ndividend  qword    1234h, 4\ndivisor   qword    2      ; dividend/divisor = 2_0000_091Ah\nquotient  qword    2 dup (?)\nremainder qword    ?\n     .\n     .\n     .\n    mov rax, dividend[8]\n    xor edx, edx          ; Zero-extend for unsigned division\n    div divisor\n    mov quotient[8], rax  ; Save HO qword of the quotient\n    mov rax, dividend[0]  ; This code doesn't zero-extend\n    div divisor           ; RAX into RDX before div instr\n    mov quotient[0], rax  ; Save LO qword of the quotient (91Ah)\n    mov remainder, rdx    ; Save the remainder\n```", "```\n; Listing 8-2\n\n; 256-bit by 64-bit division.\n\n        option  casemap:none\n\nnl          =       10\n\n            .const\nttlStr      byte    \"Listing 8-2\", 0\nfmtStr1     byte    \"quotient  = \"\n            byte    \"%08x_%08x_%08x_%08x_%08x_%08x_%08x_%08x\"\n            byte    nl, 0\n\nfmtStr2     byte    \"remainder = %I64x\", nl, 0\n\n            .data\n\n; op1 is a 256-bit value. Initial values were chosen\n; to make it easy to verify the result.\n\nop1         oword   2222eeeeccccaaaa8888666644440000h\n            oword   2222eeeeccccaaaa8888666644440000h\n\nop2         qword   2\nresult      oword   2 dup (0) ; Also 256 bits\nremain      qword   0\n\n            .code\n            externdef printf:proc\n\n; Return program title to C++ program:\n\n            public  getTitle\ngetTitle    proc\n            lea     rax, ttlStr\n            ret\ngetTitle    endp\n\n; div256 - Divides a 256-bit number by a 64-bit number.\n\n; Dividend  - passed by reference in RCX.\n; Divisor   - passed in RDX.\n\n; Quotient  - passed by reference in R8.\n; Remainder - passed by reference in R9.\n\ndiv256      proc\ndivisor     equ     <qword ptr [rbp - 8]>\ndividend    equ     <qword ptr [rcx]>\nquotient    equ     <qword ptr [r8]>\nremainder   equ     <qword ptr [r9]>\n\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 8\n\n            mov     divisor, rdx\n\n            mov     rax, dividend[24]  ; Begin div with HO qword\n            xor     rdx, rdx           ; Zero-extend into RDS\n            div     divisor            ; Divide HO word\n            mov     quotient[24], rax  ; Save HO result\n\n            mov     rax, dividend[16]  ; Get dividend qword #2\n            div     divisor            ; Continue with division\n            mov     quotient[16], rax  ; Store away qword #2\n\n            mov     rax, dividend[8]   ; Get dividend qword #1\n            div     divisor            ; Continue with division\n            mov     quotient[8], rax   ; Store away qword #1\n\n            mov     rax, dividend[0]   ; Get LO dividend qword\n            div     divisor            ; Continue with division\n            mov     quotient[0], rax   ; Store away LO qword\n\n            mov     remainder, rdx     ; Save remainder\n\n            leave\n            ret\ndiv256      endp\n\n; Here is the \"asmMain\" function.\n\n            public  asmMain\nasmMain     proc\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 80         ; Shadow storage\n\n; Test the div256 function:\n\n            lea     rcx, op1\n            mov     rdx, op2\n lea     r8, result\n            lea     r9, remain\n            call    div256\n\n; Print the results:\n\n            lea     rcx, fmtStr1\n            mov     edx, dword ptr result[28]\n            mov     r8d, dword ptr result[24]\n            mov     r9d, dword ptr result[20]\n            mov     eax, dword ptr result[16]\n            mov     [rsp + 32], rax\n            mov     eax, dword ptr result[12]\n            mov     [rsp + 40], rax\n            mov     eax, dword ptr result[8]\n            mov     [rsp + 48], rax\n            mov     eax, dword ptr result[4]\n            mov     [rsp + 56], rax\n            mov     eax, dword ptr result[0]\n            mov     [rsp + 64], rax\n            call    printf\n\n            lea     rcx, fmtStr2\n            mov     rdx, remain\n            call    printf\n\n            leave\n            ret    ; Returns to caller\n\nasmMain     endp\n            end\n```", "```\nC:\\>**build listing8-2**\n\nC:\\>**echo off**\n Assembling: listing8-2.asm\nc.cpp\n\nC:\\>**listing8-2**\nCalling Listing 8-2:\nquotient  = 11117777_66665555_44443333_22220000_11117777_66665555_44443333_22220000\nremainder = 0\nListing 8-2 terminated\n```", "```\nQuotient := Dividend;\nRemainder := 0;\nfor i := 1 to NumberBits do\n\n    Remainder:Quotient := Remainder:Quotient SHL 1;\n    if Remainder >= Divisor then\n\n        Remainder := Remainder - Divisor;\n        Quotient := Quotient + 1;\n\n    endif\nendfor\n```", "```\n; Listing 8-3\n\n; 128-bit by 128-bit division.\n\n        option  casemap:none\n\nnl          =       10\n\n            .const\nttlStr      byte    \"Listing 8-3\", 0\nfmtStr1     byte    \"quotient  = \"\n            byte    \"%08x_%08x_%08x_%08x\"\n            byte    nl, 0\n\nfmtStr2     byte    \"remainder = \"\n            byte    \"%08x_%08x_%08x_%08x\"\n            byte    nl, 0\n\nfmtStr3     byte    \"quotient (2)  = \"\n            byte    \"%08x_%08x_%08x_%08x\"\n            byte    nl, 0\n\n             .data\n\n; op1 is a 128-bit value. Initial values were chosen\n; to make it easy to verify the result.\n\nop1         oword   2222eeeeccccaaaa8888666644440000h\nop2         oword   2\nop3         oword   11117777666655554444333322220000h\nresult      oword   ?\nremain      oword   ?\n\n            .code\n            externdef printf:proc\n\n; Return program title to C++ program:\n\n            public  getTitle\ngetTitle    proc\n            lea     rax, ttlStr\n            ret\ngetTitle    endp\n\n; div128 - This procedure does a general 128 / 128 division operation\n;          using the following algorithm (all variables are assumed\n;          to be 128-bit objects).\n\n; Quotient := Dividend;\n; Remainder := 0;\n; for i := 1 to NumberBits do\n\n;    Remainder:Quotient := Remainder:Quotient SHL 1;\n;    if Remainder >= Divisor then\n\n;      Remainder := Remainder - Divisor;\n;      Quotient := Quotient + 1;\n\n; endif\n; endfor\n\n; Data passed:\n\n; 128-bit dividend, by reference in RCX.\n; 128-bit divisor, by reference in RDX.\n\n; Data returned:\n\n; Pointer to 128-bit quotient in R8.\n; Pointer to 128-bit remainder in R9.\n\ndiv128      proc\nremainder   equ     <[rbp - 16]>\ndividend    equ     <[rbp - 32]>\nquotient    equ     <[rbp - 32]>    ; Aliased to dividend\ndivisor     equ     <[rbp - 48]>\n\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 48\n\n            push    rax\n            push    rcx\n\n            xor     rax, rax        ; Initialize remainder to 0\n            mov     remainder, rax\n            mov     remainder[8], rax\n\n; Copy the dividend to local storage:\n\n            mov     rax, [rcx]\n            mov     dividend, rax\n            mov     rax, [rcx+8]\n            mov     dividend[8], rax\n\n; Copy the divisor to local storage:\n\n            mov     rax, [rdx]\n            mov     divisor, rax\n            mov     rax, [rdx + 8]\n            mov     divisor[8], rax\n\n            mov     cl, 128         ; Count off bits in CL\n\n; Compute Remainder:Quotient := Remainder:Quotient SHL 1:\n\nrepeatLp:   shl     qword ptr dividend[0], 1  ; 256-bit extended-\n            rcl     qword ptr dividend[8], 1  ; precision shift\n            rcl     qword ptr remainder[0], 1 ; through remainder\n            rcl     qword ptr remainder[8], 1\n\n; Do a 128-bit comparison to see if the remainder\n; is greater than or equal to the divisor.\n\n            mov     rax, remainder[8]\n            cmp     rax, divisor[8]\n            ja      isGE\n            jb      notGE\n\n            mov     rax, remainder\n            cmp     rax, divisor\n            ja      isGE\n            jb      notGE\n\n; Remainder := Remainder - Divisor;\n\nisGE:       mov     rax, divisor\n            sub     remainder, rax\n            mov     rax, divisor[8]\n            sbb     remainder[8], rax\n\n; Quotient := Quotient + 1;\n\n            add     qword ptr quotient, 1\n            adc     qword ptr quotient[8], 0\n\nnotGE:      dec     cl\n            jnz     repeatLp\n\n; Okay, copy the quotient (left in the dividend variable)\n; and the remainder to their return locations.\n\n            mov     rax, quotient[0]\n            mov     [r8], rax\n            mov     rax, quotient[8]\n            mov     [r8][8], rax\n\n            mov     rax, remainder[0]\n            mov     [r9], rax\n            mov     rax, remainder[8]\n            mov     [r9][8], rax\n\n            pop     rcx\n            pop     rax\n            leave\n            ret\n\ndiv128      endp\n\n; Here is the \"asmMain\" function.\n\n            public  asmMain\nasmMain     proc\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 64        ; Shadow storage\n\n; Test the div128 function:\n\n            lea     rcx, op1\n            lea     rdx, op2\n            lea     r8, result\n            lea     r9, remain\n            call    div128\n\n; Print the results:\n\n            lea     rcx, fmtStr1\n            mov     edx, dword ptr result[12]\n            mov     r8d, dword ptr result[8]\n            mov     r9d, dword ptr result[4]\n            mov     eax, dword ptr result[0]\n            mov     [rsp + 32], rax\n            call    printf\n\n            lea     rcx, fmtStr2\n            mov     edx, dword ptr remain[12]\n            mov     r8d, dword ptr remain[8]\n            mov     r9d, dword ptr remain[4]\n            mov     eax, dword ptr remain[0]\n            mov     [rsp + 32], rax\n            call    printf\n\n; Test the div128 function:\n\n            lea     rcx, op1\n            lea     rdx, op3\n            lea     r8, result\n            lea     r9, remain\n            call    div128\n\n; Print the results:\n\n            lea     rcx, fmtStr3\n            mov     edx, dword ptr result[12]\n            mov     r8d, dword ptr result[8]\n            mov     r9d, dword ptr result[4]\n            mov     eax, dword ptr result[0]\n            mov     [rsp + 32], rax\n            call    printf\n\n            lea     rcx, fmtStr2\n            mov     edx, dword ptr remain[12]\n mov     r8d, dword ptr remain[8]\n            mov     r9d, dword ptr remain[4]\n            mov     eax, dword ptr remain[0]\n            mov     [rsp + 32], rax\n            call    printf\n\n            leave\n            ret    ; Returns to caller\n\nasmMain     endp\n            end\n```", "```\nC:\\>**build listing8-3**\n\nC:\\>**echo off**\n Assembling: listing8-3.asm\nc.cpp\n\nC:\\>**listing8-3**\nCalling Listing 8-3:\nquotient  = 11117777_66665555_44443333_22220000\nremainder = 00000000_00000000_00000000_00000000\nquotient (2)  = 00000000_00000000_00000000_00000002\nremainder = 00000000_00000000_00000000_00000000\nListing 8-3 terminated\n```", "```\n .data\nValue  qword 5 dup (?) ; 320-bit value\n        .\n        .\n        .\n    xor rax, rax       ; RAX = 0\n    sub rax, Value\n    mov Value, rax\n\n    mov eax, 0         ; Cannot use XOR here:\n    sbb rax , Value[8] ; must preserve carry!\n    mov Value[8], rax\n\n    mov eax, 0         ; Zero-extends!\n    sbb rax, Value[16]\n    mov Value[16], rax\n\n    mov eax, 0\n    sbb rax, Value[24]\n    mov Value[24], rax\n\n    mov rax, 0\n    sbb rax, Value[32]\n    mov Value[32], rax\n```", "```\nneg rdx\nneg rax\nsbb rdx, 0\n```", "```\nmov rax,  qword ptr source1\nand rax,  qword ptr source2\nmov qword ptr dest, rax\n\nmov rax,  qword ptr source1[8]\nand rax,  qword ptr source2[8]\nmov qword ptr dest[8], rax\n```", "```\nmov rax,  qword ptr source1\nor  rax,  qword ptr source2\nmov qword ptr dest, rax\n\nmov rax,  qword ptr source1[8]\nor  rax,  qword ptr source2[8]\nmov qword ptr dest[8], rax\n\nmov rax,  qword ptr source1[16]\nor  rax,  qword ptr source2[16]\nmov qword ptr dest[16], rax\n```", "```\nmov rax,  qword ptr source1\nxor rax,  qword ptr source2\nmov qword ptr dest, rax\n\nmov rax,  qword ptr source1[8]\nxor rax,  qword ptr source2[8]\nmov qword ptr dest[8], rax\n```", "```\nnot rax\nnot rdx\n```", "```\nshl rax, 1\nrcl rdx, 1\n```", "```\nshl qword ptr Operand[0], 1\nrcl qword ptr Operand[8], 1\nrcl qword ptr Operand[16], 1\n```", "```\nShiftLoop:\n    shl qword ptr Operand[0], 1\n    rcl qword ptr Operand[8], 1\n    rcl qword ptr Operand[16], 1\n    dec cl\n    jnz ShiftLoop\n```", "```\n; Extended-precision SAR:\n\n    sar qword ptr Operand[16], 1\n    rcr qword ptr Operand[8], 1\n    rcr qword ptr Operand[0], 1\n\n; Extended-precision SHR:\n\n    shr qword ptr Operand[16], 1\n    rcr qword ptr Operand[8], 1\n    rcr qword ptr Operand[0], 1\n```", "```\nshld `Operand`[1], `Operand`[2], `constant`\nshld `Operand`[1], `Operand`[2], `cl`\nshrd `Operand`[1], `Operand`[2], `constant`\nshrd `Operand`[1], `Operand`[2], `cl`\n```", "```\n .data\nShiftMe qword   012345678h, 90123456h, 78901234h\n     .\n     .\n     .\n    mov  rax, ShiftMe[8]\n    shld ShiftMe[16], rax, 6\n mov  rax, ShiftMe[0]\n    shld ShiftMe[8], rax, 6\n    shl  ShiftMe[0], 6\n```", "```\nrcl qword ptr Operand[0], 1\nrcl qword ptr Operand[8], 1\nrcl qword ptr Operand[16], 1\n\nrcr qword ptr Operand[16], 1\nrcr qword ptr Operand[8], 1\nrcr qword ptr Operand[0], 1\n```", "```\n; Compute rol RDX:RAX, 4:\n\n        mov  rbx, rdx\n        shld rdx, rax, 4\n        shld rax, rbx, 4\n        bt   rbx, 28        ; Set carry flag, if desired\n```", "```\n .data\nvar1    byte    ?\nvar2    word    ?\n         .\n         .\n         .\n; Unsigned addition:\n\n        movzx   ax, var1\n        add     ax, var2\n\n; Signed addition:\n\n        movsx   ax, var1\n        add     ax, var2\n```", "```\n mov ax, var2    ; Load 16-bit value into AX\n    .               ; Do some other operations, leaving\n    .               ; a 16-bit quantity in AX\n    add al, var1    ; Add in the 8-bit value\n    adc ah, 0       ; Add carry into the HO word\n```", "```\nmov   bx, ax      ; BX is the available register\nmovsx ax, var1\nadd   ax, bx\n```", "```\npush  ax          ; Save word value\nmovsx ax, var1    ; Sign-extend 8-bit operand to 16 bits\nadd   ax, [rsp]   ; Add in previous word value\nadd   rsp, 2      ; Pop junk from stack\n```", "```\nmov   temp, ax\nmovsx ax, var1\nadd   ax, temp\n```", "```\n .data\nOVal  qword   ?\nBVal  byte    ?\n     .\n     .\n     .\nmovsx rax, BVal\ncqo\nadd   rax, qword ptr OVal\nadc   rdx, qword ptr OVal[8]\n```", "```\nmov al, 99h\n```", "```\n .data\ntb        tbyte    654321h\ntwo       real8    2.0\none       dword    1\n\n          fbld     tb \n          fmul     two\n          fiadd    one\n          fbstp    tb\n\n; TB now contains: 1308643h.\n```"]