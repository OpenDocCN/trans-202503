["```\n(module\n;; Imported JavaScript function (below) takes position and length\n1 (import \"env\" \"str_pos_len\" (func $str_pos_len (param i32 i32)))\n2 (import \"env\" \"buffer\"   (memory 1))\n;; 30 character string\n3 (data (i32.const 256) \"Know the length of this string\")\n;; 35 characters\n4 (data (i32.const 384) \"Also know the length of this string\")\n\n5 (func (export \"main\")\n;; length of the first string is 30 characters\n 6 (call $str_pos_len (i32.const 256) (i32.const 30))\n;; length of the second string is 35 characters\n 7 (call $str_pos_len (i32.const 384) (i32.const 35))\n )\n)\n```", "```\nwat2wasm strings.wat\n```", "```\nconst fs = require('fs');\nconst bytes = fs.readFileSync(__dirname + '/strings.wasm');\n\nlet memory = new WebAssembly.Memory( {initial: 1 });\n\nlet importObject = {\n  env: {\n    buffer: memory,\n  1 str_pos_len: function(str_pos, str_len) {\n    2 const bytes = new Uint8Array( memory.buffer,\n                                    str_pos, str_len );\n    3 const log_string = new TextDecoder('utf8').decode(bytes);\n      4 console.log(log_string);\n    }\n  }\n};\n\n( async () => {\n  let obj = await WebAssembly.instantiate( new Uint8Array(bytes),\n                                           importObject );\n\n  let main = obj.instance.exports.main;\n\n  main();\n})();\n```", "```\nKnow the length of this string\nAlso know the length of this string\n```", "```\n(module\n1 (import \"env\" \"str_pos_len\" (func $str_pos_len (param i32 i32)))\n;; add line below\n2 (import \"env\" \"null_str\" (func $null_str (param i32)))\n...\n```", "```\n...\n  (import \"env\" \"buffer\" (memory 1))\n;; add the two lines below\n1 (data (i32.const 0) \"null-terminating string\\00\")\n2 (data (i32.const 128) \"another null-terminating string\\00\")\n\n  (data (i32.const 256) \"Know the length of this string\")\n...\n```", "```\n...\n(func (export \"main\")\n1 (call $null_str (i32.const 0)) ;; add this line\n2 (call $null_str (i32.const 128)) ;; add this line\n\n    (call $str_pos_len (i32.const 256) (i32.const 30))\n...\n```", "```\n...\n1 const max_mem = 65535;// add this line\n\n  let importObject = {\n  env: {\n    buffer: memory,\n    // add the null_str function to the importObject here\n  2 null_str: function(str_pos) **{** // add this function\n    3 let bytes = new Uint8Array( memory.buffer,\n                                  str_pos, max_mem-str_pos );\n\n    4 let log_string = new TextDecoder('utf8').decode(bytes);\n    5 log_string = log_string.split(\"\\0\")[0];\n    6 console.log(log_string);\n    }, // end of function\n    str_pos_len: function(str_pos, str_len) {\n...\n```", "```\nnull-terminating string\nanother null-terminating string\nKnow the length of this string\nAlso know the length of this string\n```", "```\n(module\n  (import \"env\" \"str_pos_len\" (func $str_pos_len (param i32 i32)))\n  (import \"env\" \"null_str\" (func $null_str (param i32)))\n ;; add the line below\n1(import \"env\" \"len_prefix\" (func $len_prefix (param i32)))\n...\n```", "```\n...\n  (data (i32.const 384) \"Also know the length of this string\")\n\n  ;; add the next four lines.  Two data elements and two comments\n ;; length is 22 in decimal, which is 16 in hex\n1 (data (i32.const 512) \"\\16length-prefixed string\")\n ;; length is 30 in decimal, which is 1e in hex\n2 (data (i32.const 640) \"\\1eanother length-prefixed string\")\n\n (func (export \"main\")\n...\n```", "```\n...\n  (func (export \"main\")\n    (call $null_str (i32.const 0))\n    (call $null_str (i32.const 128))\n\n    (call $str_pos_len (i32.const 256) (i32.const 30))\n    (call $str_pos_len (i32.const 384) (i32.const 35))\n\n  1 (call $len_prefix (i32.const 512))    ;; add this line\n  2 (call $len_prefix (i32.const 640))    ;; add this line\n\n )\n...\n```", "```\n...\nlet importObject = {\n  env: {\n    buffer: memory,\n    null_str: function (str_pos) {\n      let bytes = new Uint8Array(memory.buffer, str_pos,\n                                 max_mem - str_pos);\n\n      let log_string = new TextDecoder('utf8').decode(bytes);\n      log_string = log_string.split(\"\\0\")[0];\n      console.log(log_string);\n    }, // end null_str function \n    str_pos_len: function (str_pos, str_len) {\n      const bytes = new Uint8Array(memory.buffer,\n        str_pos, str_len);\n      const log_string = new TextDecoder('utf8').decode(bytes);\n      console.log(log_string);\n },\n1 len_prefix: function (str_pos) {\n    2 const str_len = new Uint8Array(memory.buffer, str_pos, 1)[0];\n    3 const bytes = new Uint8Array(memory.buffer,\n                                   str_pos + 1, str_len);\n    4 const log_string = new TextDecoder('utf8').decode(bytes);\n      console.log(log_string);\n    }\n  }\n};\n...\n```", "```\nwat2wasm strings.wat\n```", "```\nnode strings.js\n```", "```\nnull-terminating string\nanother null-terminating string\nKnow the length of this string\nAlso know the length of this string\nlength-prefixed string\nanother length-prefixed string\n```", "```\n...\n(func $byte_copy\n  (param $source i32) (param $dest i32) (param $len i32)\n  (local $last_source_byte i32)\n\n1 local.get $source\n  local.get $len\n2 i32.add   ;; $source + $len\n\n  local.set $last_source_byte         ;; $last_source_byte = $source + $len\n\n  (loop $copy_loop (block $break\n  3 local.get $dest    ;; push $dest on stack for use in i32.store8 call\n  4 (i32.load8_u (local.get $source)) ;; load a single byte from $source\n  5 i32.store8                        ;; store a single byte in $dest\n\n  6 local.get $dest\n    i32.const 1\n    i32.add\n  7 local.set $dest                   ;; $dest = $dest + 1\n\n    local.get $source\n    i32.const 1\n    i32.add\n  8 local.tee $source                 ;; $source = $source + 1\n\n    local.get $last_source_byte\n    i32.eq\n    br_if $break\n    br $copy_loop\n  )) ;; end $copy_loop\n)\n...\n```", "```\n...\n;; add this block of code to the `strings.wat` file\n(func $byte_copy_i64\n  (param $source i32) (param $dest i32) (param $len i32)\n  (local $last_source_byte i32)\n\n  local.get $source\n  local.get $len\n  i32.add\n\n  local.set $last_source_byte\n\n**(loop $copy_loop (block $break**\n  1 (i64.store (local.get $dest) (i64.load (local.get $source)))\n\nlocal.get $dest\n  2 i32.const 8\n    i32.add\n    local.set $dest;; $dest = $dest + 8\n\nlocal.get $source\n  3 i32.const 8\n    i32.add\n    local.tee $source;; $source = $source + 8\n\n    local.get $last_source_byte\n    i32.ge_u\n br_if $break\n    br $copy_loop\n  ));; end $copy_loop\n)\n...\n```", "```\n...\n(func $string_copy\n  (param $source i32) (param $dest i32) (param $len i32)\n  (local $start_source_byte i32)\n  (local $start_dest_byte   i32)\n  (local $singles           i32)\n  (local $len_less_singles  i32)\n\n  local.get $len\n1 local.set $len_less_singles  ;; value without singles\n\n  local.get $len\n  i32.const 7                  ;; 7 = 0111 in binary\n2 i32.and\n  local.tee $singles           ;; set $singles to last 3 bits of length\n\n3 if                           ;; if the last 3 bits of $len is not 000\n    local.get $len\n    local.get $singles\n    i32.sub\n  4 local.tee $len_less_singles  ;; $len_less_singles = $len - $singles\n\n    local.get $source\n    i32.add\n    ;; $start_source_byte=$source+$len_less_singles\n  5 local.set $start_source_byte\n\n    local.get $len_less_singles\n    local.get $dest\n    i32.add\n  6 local.set $start_dest_byte  ;; $start_dest_byte=$dest+$len_less_singles\n\n  7 (call $byte_copy (local.get $start_source_byte)\n (local.get $start_dest_byte)(local.get $singles))\n  end\n\n  local.get $len\n8 i32.const 0xff_ff_ff_f8 ;; all bits are 1 except the last three which are 0\n9 i32.and                 ;; set the last three bits of the length to 0\n  local.set $len\na (call $byte_copy_i64 (local.get $source) (local.get $dest) (local.get $len))\n)\n...\n```", "```\n...\n(func (export \"main\")\n  1 (call $str_pos_len (i32.const 256) (i32.const 30))\n  2 (call $str_pos_len (i32.const 384) (i32.const 35))\n\n  3 (call $string_copy\n        (i32.const 256) (i32.const 384) (i32.const 30))\n\n  4 (call $str_pos_len (i32.const 384) (i32.const 35))\n  5 (call $str_pos_len (i32.const 384) (i32.const 30))\n  )\n```", "```\nwat2wasm strings.wat\n```", "```\nKnow the length of this string\nAlso know the length of this string\nKnow the length of this stringtring\nKnow the length of this string\n```", "````In the next section, you’ll learn how to turn numbers into strings.    ### Creating Number Strings    When you’re working with strings, converting numeric data into string data is frequently required. High-level languages like JavaScript have functions that can do this for you, but in WAT you’ll need to build your own functions. Let’s look at what it takes to create strings from numbers in decimal, hexadecimal, and binary.    Create a WAT file named *number_string.wat* and add the code in [Listing 5-23](#listing5-23) to the beginning of the file.    **number_string.wat (part 1 of 7)**    ``` (module 1 (import \"env\" \"print_string\" (func $print_string (param i32 i32))) 2 (import \"env\" \"buffer\" (memory 1))  3 (data (i32.const 128) \"0123456789ABCDEF\")  4 (data (i32.const 256) \"               0\") 5 (global $dec_string_len  i32 (i32.const 16)) ... ```    Listing 5-23: Imported objects and data in the WebAssembly module    The beginning of this module imports a `$print_string` 1 function and one page of linear memory 2 from JavaScript. Next, we define a `data` 3 element with an array of characters that contains every hexadecimal character. Then we define a data element that will hold our string `data` 4, followed by the length of that `data` string 5.    In the next few listings, we define three functions that create number strings in three different formats. We use the first of these functions, `$set_dec_string`, to set the `$dec_string` linear memory area.    [Listing 5-24](#listing5-24) contains the code that turns an integer into a decimal string. The code can be a bit challenging to follow, so I’ll give you an overview before showing the code. At a high level, when we assemble a string from a number, we need to look at the number one digit at a time and add the character form of that digit to our string. Let’s say the number we’re looking at is 9876\\. In the 1s place is the digit 6\\. We can find this digit by dividing the full number by 10 and using the remainder (called a *modulo*). In WAT, that code would be the type `i32.rem_u` (`rem` for remainder). Next, you use the character form of the number 6 and add it to your string. Other digits need to move along as if on a conveyor belt (illustrated in [Figure 5-2](#figure5-2)). The way you do this in code is to divide by 10\\. Because this divide is on an integer, you don’t get a fractional number, and the 6 is simply thrown away. You then use the remainder to get the next digit (7) and add that to the string. You continue on until all the digits are gone. [Listing 5-24](#listing5-24) shows the source code for the `$set_dec_string` function.    **number_string.wat (part 2 of 7)**    ``` ... (func $set_dec_string (param $num i32) (param $string_len i32)   (local $index      i32)   (local $digit_char  i32)   (local $digit_val   i32)    local.get $string_len 1 local.set $index    ;; set $index to the string length    local.get $num   i32.eqz             ;; is $num is equal to zero   if                  ;; if the number is 0, I don't want all spaces     local.get $index     i32.const 1     i32.sub     local.set $index  ;; $index--      ;; store ascii '0' to memory location 256 + $index     (i32.store8 offset=256 (local.get $index) (i32.const 48))   end    (loop $digit_loop (block $break ;; loop converts number to a string     local.get $index  ;; set $index to end of string, decrement to 0     i32.eqz           ;; is the $index 0?     br_if $break      ;; if so break out of loop      local.get $num     i32.const 10   2 i32.rem_u         ;; decimal digit is remainder of divide by 10    3 local.set $digit_val ;; replaces call above     local.get $num     i32.eqz              ;; check to see if the $num is now 0     if       i32.const 32           ;; 32 is ascii space character       local.set $digit_char  ;; if $num is 0, left pad spaces     else     4 (i32.load8_u offset=128 (local.get $digit_val))       local.set $digit_char  ;; set $digit_char to ascii digit  end        local.get $index     i32.const 1     i32.sub     local.set $index     ;; store ascii digit in 256 + $index   5 (i32.store8 offset=256       (local.get $index) (local.get $digit_char))        local.get $num     i32.const 10     i32.div_u   6 local.set $num     ;; remove last decimal digit, dividing by 10      br $digit_loop     ;; loop   )) ;; end of $block and $loop ) ```    Listing 5-24: A WebAssembly function that creates a decimal string from an integer    We start the function with `$index` 1, a variable that points to the last byte in `$dec_string`. We set the values of this string from right to left, so the `$index` variable needs to be decremented every pass through the loop. Each pass through the loop, the number value set in `$dec_string` is the final base-10 digit. To get this value, we divide the `$num` 6 value by `10` and get the remainder 2 with modulo 10\\. This value is stored in the local variable `$digit_val` 3 so we can later use it to set an ASCII character in the `$dec_string` data. We use `$digit_val` as an offset into the `$digit_char` string to load a character with `i32.load8_u` 4. That character is then written to an address that is `$dec_string+$index` using `i32.store8` 5. [Figure 5-2](#figure5-2) illustrates the process.  ![f05002](Images/f05002.png)    Figure 5-2: Look at digits one at a time and append characters one at a time.      Now that we have the function that does most of the work in our WebAssembly module, let’s add a function to export to the JavaScript, as shown in [Listing 5-25](#listing5-25).    **number_string.wat (part 3 of 7)**    ``` ...   (func (export \"to_string\") (param $num i32)   1 (call $set_dec_string       (local.get $num) (global.get $dec_string_len))   2 (call $print_string       (i32.const 256) (global.get $dec_string_len))   ) ) ```    Listing 5-25: The `to_string` function    The function is very simple. It calls `$set_dec_string` 1 passing in the number we want to convert to a string and the length of the string we want including the left padding. It then calls the JavaScript `print_string` 2 function passing in the location of the string we created in linear memory `(i32.const` `256)` and the length of that string.    Now that we’ve completed the *number_string.wat* file, we can compile it using `wat2wasm` in [Listing 5-26](#listing5-26).    ``` wat2wasm number_string.wat ```    Listing 5-26: Compiling *number_string.wat*    Next, we need to write the JavaScript that will run our WebAssembly module. Create a file named *number_string.js* and add the code in [Listing 5-27](#listing5-27).    **number_string.js**    ```  const fs = require('fs');   const bytes = fs.readFileSync(__dirname + '/number_string.wasm'); 1 const value = parseInt(process.argv[2]);   let memory = new WebAssembly.Memory({ initial: 1 });    (async () => {     const obj =       await WebAssembly.instantiate(new Uint8Array(bytes), {         env: {           buffer: memory,         2 print_string: function (str_pos, str_len) {             const bytes = new Uint8Array(memory.buffer,               str_pos, str_len);             const log_string = new TextDecoder('utf8').decode(bytes);             // log_string is left padded.            3 console.log(`>${log_string}!`);           }         }       });       obj.instance.exports.to_string(value);   })(); ```    Listing 5-27: The JavaScript that calls the WebAssembly module to convert the number to a string    The JavaScript code loads the WebAssembly module and takes an additional argument 1 that we’ll convert into a number string and left pads the string up to 16 characters. The WebAssembly module will call the `print_string` 2JavaScript function, which writes the string to the console, appending a `>` character to the beginning of the string and a `!` character to the end. We place these extra characters into the `console.log` 3 output to show where the string coming from the WebAssembly module begins and ends. You can run the JavaScript using the `node` command in [Listing 5-28](#listing5-28).    ``` node number_string.js 1229 ```    Listing 5-28: Use `node` to call the *number_string.js* file, passing in `1229`.    The result is that the number `1229` is converted to a string, and the output in [Listing 5-29](#listing5-29) is logged to the console.    ``` >            1229! ```    Listing 5-29: The number `1229` is left padded to 16 characters, beginning with `>` and ending with `!`.    In the next section, we’ll use similar techniques to create a hexadecimal string.    ### Setting a Hexadecimal String    Converting an integer to a hexadecimal string is very similar to converting an integer to a decimal number, as we did in the preceding section. We use a bit mask to look at specific hex digits and a shift to remove the digit, similar to our decimal conveyor belt (see [Figure 5-2](#figure5-2)).    Recall from Chapter 4 that four bits of data is called a nibble and a hexadecimal digit corresponds to one nibble of data. At a high level, the code needs to look at the integer one nibble at a time as one hexadecimal digit. We look at the lowest order nibble, also the lowest order hex digit, and then add that digit to the string. Rather than finding the remainder, we use a mask to only look at the last digit. Instead of dividing by 10, we remove the last hex digit by shifting off four bits (one nibble).    In hexadecimal, each digit represents a number from 0 to 15 instead of 0 to 9, so each digit in hex must be one of the following: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F where the value of A = 10, B = 11, C = 12, D = 13, E = 14, and F = 15\\. We often use hexadecimal as an alternative to binary numbers, which can get extremely long to represent; for example, the number 233 in decimal is 11101001 in binary. We can shorten 233 in the binary form into the hexadecimal E9 because 1110 is 14 or E in hex, and 1001 is 9 in both decimal and hex.    We mask E9 (binary 1110 1001) using `(i32.and``)` with a value of binary 0000 1111 (0F) to find the least significant nibble. Using `i32.and` in that way results in E9 masked into 09, as shown in [Figure 5-3](#figure5-3).  ![f05003](Images/f05003.png)    Figure 5-3: E9 byte masked to 09 with a mask of 0F (0000 1111)      We use a combination of a bit shift and an AND mask to convert the integer data into a hexadecimal string. Here, we create a hexadecimal version of the `$set_dec_string` function called `$set_hex_string`. This function sets a hexadecimal string based on a number passed into it. We can make this loop simpler than the loop in `$set_dec_string` because we can use simple bit manipulation to find the offset into `$digits`. The end of the function adds the extra ASCII characters `0x` to indicate that the display string is in a hexadecimal format. [Listing 5-30](#listing5-30) shows what the `$set_hex_string` function looks like.   **number_string.wat (part 4 of 7)**    ``` ... ;; add this code before the $set_dec_string function   (global $hex_string_len  i32 (i32.const 16)) ;; hex character count   (data (i32.const 384) \"             0x0\")    ;; hex string data    (func $set_hex_string (param $num i32) (param $string_len i32)     (local $index       i32)     (local $digit_char  i32)     (local $digit_val   i32)     (local $x_pos       i32)      global.get $hex_string_len     local.set $index ;; set the index to the number of hex characters      (loop $digit_loop (block $break       local.get $index       i32.eqz           br_if $break        local.get $num       i32.const 0xf ;; last 4 bits are 1     1 i32.and       ;; the offset into $digits is in the last 4 bits of number      2 local.set $digit_val  ;; the digit value is the last 4 bits       local.get $num       i32.eqz     3 if                    ;; if $num == 0         local.get $x_pos         i32.eqz         if           local.get $index         4 local.set $x_pos  ;; position of 'x' in the \"0x\" hex prefix         else           i32.const 32      ;; 32 is ascii space character           local.set $digit_char         end       else         ;; load character from 128 + $digit_val       5 (i32.load8_u offset=128 (local.get $digit_val))         local.set $digit_char       end          local.get $index       i32.const 1       i32.sub     6 local.tee $index  ;; $index = $index - 1       local.get $digit_char        ;; store $digit_char at location 384+$index     7 i32.store8 offset=384   local.get $num       i32.const 4     8 i32.shr_u            ;; shifts 1 hexadecimal digit off $num       local.set $num        br $digit_loop     ))      local.get $x_pos     i32.const 1     i32.sub      i32.const 120          ;; ascii x   9 i32.store8 offset=384  ;; store 'x' in string      local.get $x_pos     i32.const 2     i32.sub      i32.const 48           ;; ascii '0'   a i32.store8 offset=384  ;; store \"0x\" at front of string   ) ;; end $set_hex_string ... ```    Listing 5-30: Create a hexadecimal string from an integer. Add this before the `$set_dec_string` function.    In the `$set_dec_string` function, we use a modulo 10 to find each digit, and then shift that digit off by dividing it by 10\\. Instead of finding a remainder, the `$set_hex_string` function can use `i32.and` 1 to mask all but the last four bits of `$num`. The value of that nibble is a single hexadecimal digit and is used to set `$digit_val` 2.    If all remaining digits are `0` 3, we set the position to put the hexadecimal string prefix of `0x` in the local variable `$x_pos` 4. Otherwise, if any remaining digits are `1` or greater, we use the value in `$digit_val` to load 5 an ASCII value for that hexadecimal digit from the `$digits` string and store it into `$digit_char`. Then we decrement `$offset` 6 and use that value to store the character in `$digit_char` into the `$hex_string` data 7.    The loop then shifts off one hexadecimal digit (four bits) using `i32.shr_u` 8, which shifts bits to the right. The last task this function does is append the `0x` prefix to the string by using the value we set earlier in `$x_pos` as an offset and storing an ASCII `x` character in that position 9. It then decrements the `$x_pos` position and stores the ASCII `0` a. The process looks a bit like [Figure 5-4](#figure5-4).  ![f05004](Images/f05004.png)    Figure 5-4: Creating a hexadecimal string from an integer      After adding the `$set_hex_string` function, we need to update the `to_string` function to call `$set_hex_string` and print the resulting string to the console. Update the `to_string` function to look like the code in [Listing 5-31](#listing5-31).    **number_string.wat (part 5 of 7)**    ``` ...   (func (export \"to_string\") (param $num i32)     (call $set_dec_string       (local.get $num) (global.get $dec_string_len))     (call $print_string (i32.const 256) (global.get $dec_string_len))    1 (call $set_hex_string (local.get $num)       (global.get $hex_string_len))   2 (call $print_string (i32.const 384) (global.get $hex_string_len))   )   ) ```    Listing 5-31: Update to the `to_string` function calling `$set_hex_string` and `$print_string`    These two new statements call `$set_hex_string` 1 to set the hexadecimal string in linear memory. We then call `$print_string` 2 passing in the memory location of the hexadecimal string `(i32.const` `384)` and the length of the string. No changes to the JavaScript file are necessary. All we need to do is recompile our WAT file, as shown in [Listing 5-32](#listing5-32).    ``` wat2wasm number_string.wat ```    Listing 5-32: Compiling *number_string.wat* with `wat2wasm`    Once you’ve recompiled the WebAssembly module, you can run the *number_string.js* file using `node`, as shown in [Listing 5-33](#listing5-33).    ``` node number_string.js 2049 ```    Listing 5-33: Running *number_string.js* passing in the value `2049`    [Listing 5-34](#listing5-34) shows the output.    ``` >            2049! >           0x801! ```    Listing 5-34: The second line is the output of the hexadecimal string conversion.    In the next section, we’ll add a function to generate a string of binary digits from a 32-bit integer.    ### Setting a Binary String    The final format we’ll cover is converting an integer to a string that represents the binary data. It’s best to get an intuitive sense for binary numbers when you’re working with low-level code. Having a better conceptual grasp on the numbers can sometimes help you create improvements in your code’s performance by using bit manipulation as an alternative to decimal math. Computers work with binary, even if your code is working with decimal. Understanding what the computer is doing is often helpful when you’re trying to improve your code’s performance.    We’ll create the `$set_bin_string` function, which uses a double loop to separate every 4-bit nibble with a space character to make it more readable. We’ll use `(i32.and``)` against the number `1` to see whether the last bit is a `1` or a `0`, and then shift a single bit off the number every pass through the inner loop of the function. [Listing 5-35](#listing5-35) shows what the code looks like.    **number_string.wat (part 6 of 7)**    ``` ... ;; add this code before the $set_hex_string function (global $bin_string_len  i32 (i32.const 40)) (data (i32.const 512) \" 0000 0000 0000 0000 0000 0000 0000 0000\")  (func $set_bin_string (param $num i32) (param $string_len i32)   (local $index i32)   (local $loops_remaining i32)   (local $nibble_bits i32)    global.get $bin_string_len   local.set $index  1 i32.const 8  ;; there are 8 nibbles in 32 bits (32/4 = 8)   local.set $loops_remaining  ;; outer loop separates nibbles  2 (loop $bin_loop (block $outer_break  ;; outer loop for spaces     local.get $index       i32.eqz  br_if $outer_break        ;; stop looping when $index is 0      i32.const 4   3 local.set $nibble_bits    ;; 4 bits in each nibble    4 (loop $nibble_loop (block $nibble_break ;; inner loop for digits       local.get $index         i32.const 1       i32.sub       local.set $index        ;; decrement $index        local.get $num       i32.const 1     5 i32.and   ;; i32.and 1 results in 1 if last bit is 1 else 0       if        ;; if the last bit is a 1         local.get $index         i32.const 49           ;; ascii '1' is 49       6 i32.store8 offset=512  ;; store '1' at 512 + $index        else                     ;; else executes if last bit was 0         local.get $index         i32.const 48           ;; ascii '0' is 48       7 i32.store8 offset=512  ;; store '0' at 512 + $index       end        local.get $num       i32.const 1     8 i32.shr_u                ;; $num shifted right 1 bit       local.set $num           ;; shift off the last bit of $num        local.get $nibble_bits       i32.const 1       i32.sub       local.tee $nibble_bits   ;; decrement $nibble_bits       i32.eqz                  ;; $nibble_bits == 0     9 br_if $nibble_break      ;; break when $nibble_bits == 0        br $nibble_loop     )) ;; end $nibble_loop      local.get $index       i32.const 1     i32.sub     local.tee $index           ;; decrement $index     i32.const 32               ;; ascii space   a i32.store8 offset=512      ;; store ascii space at 512+$index      br $bin_loop   )) ;; end $bin_loop ) ... ```    Listing 5-35: Create a binary string from an integer. Add this code before the `$set_hex_string` function.    The `$set_bin_string` function has two loops. The outer loop puts a space between each of the nibbles. Because we are working with 32-bit numbers in this code, there are eight nibbles 1 that we need to loop over. We label the outer loop `$bin_loop` 2, and the block we break from is called `$outer_break` 2.    Before the inner loop, we need to set the local variable `$nibble_bits` to `4` 3. The code loops over four bits for each nibble in the inner loop. Inside the inner loop `$nibble_loop` 4, we place a `$nibble_block` block that can break out of the inner loop 4. Inside `$nibble_loop`, we use an `(i32.and``)` 5 expression along with an `if`/`else` statement to determine whether the last bit in the `$num` variable is `1` or `0`. If it’s `1`, we use an `i32.store8` 6 statement to store an ASCII `1` in the linear memory address `$index` + `512`. If it isn’t `1`, we store an ASCII `0` in that location 7.    Next, we need to shift that bit off for the next pass through the loop. As we did in the `$set_hex_string` function, we’re using a `(i32.shr_u``)` 8 expression for this shifting, but this time we’re shifting off a single bit instead of four bits. After looping through the `$nibble` loop four times, we break 9 out of it and store an ASCII space character at the linear memory position `$offset` + `$bin_string` a.    Now we can call `$set_bin_string` to print the value of our string from the `to_string` function. Update the `to_string` function with the code in [Listing 5-36](#listing5-36).    **number_string.wat (part 7 of 7)**    ``` ... (func (export \"to_string\") (param $num i32)   (call $set_dec_string     (local.get $num) (global.get $dec_string_len))   (call $print_string (i32.const 256) (global.get $dec_string_len))   (call $set_hex_string     (local.get $num) (global.get $hex_string_len))   (call $print_string (i32.const 384) (global.get $hex_string_len))   1 (call $set_bin_string     (local.get $num) (global.get $bin_string_len))   2 (call $print_string (i32.const 512) (global.get $bin_string_len))   )   ) ```    Listing 5-36: Adding `$set_bin_string` to the `to_string` function    The first of the two `call` statements we just added (`call $set_bin_string` 1) sets the binary string using the function defined in [Listing 5-35](#listing5-35). The second `call` statement (`call $print_string` 2) prints the binary string to the console. Now let’s recompile the WebAssembly module, as shown in [Listing 5-37](#listing5-37).    ``` wat2wasm number_string.wat ```    Listing 5-37: Recompiling *number_string.wat* with the binary string function    We can now run the *number_string.js* file using the `node` command in [Listing 5-38](#listing5-38).    ``` node number_string.js 4103 ```    Listing 5-38: Running *number_string.js* with the binary string WebAssembly module    The output in [Listing 5-39](#listing5-39) will be logged to the console.    ``` >            4103! >          0x1007! > 0000 0000 0000 0000 0001 0000 0000 0111! ```    Listing 5-39: The binary string logged to the console    ## Summary    This chapter focused on how to work with strings in WAT. You learned about the ASCII and Unicode character formats. You stored string objects in linear memory and learned how to use JavaScript to retrieve the strings and output them to the command line. We covered how to pass string data from WebAssembly to JavaScript and examined two popular methods for string management, null-terminated strings and length-prefixed strings. You copied a string from one location in linear memory to another, using a byte-by-byte copy and a 64-bit copy. Then we explored how to convert integer data into number strings in decimal, hexadecimal, and binary format. In the next chapter, we’ll focus on using linear memory in WAT.````"]