- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction to SQL
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: To select data from a MySQL database, you’ll use *Structured Query Language*
    *(SQL)*. SQL is the standard language for querying and managing data in an RDBMS
    like MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: SQL commands can be categorized into *Data Definition Language* *(DDL)* statements
    and *Data Manipulation Language* *(DML)* statements. So far, you’ve been using
    DDL commands like `create database`, `create table`, and `drop table` to *define*
    your databases and tables.
  prefs: []
  type: TYPE_NORMAL
- en: DML commands, on the other hand, are used to *manipulate* the data in your existing
    databases and tables. In this chapter, you’ll use the DML `select` command to
    retrieve data from a table. You’ll also learn how to specify an order for MySQL
    to sort your results and how to deal with null values in your table columns.
  prefs: []
  type: TYPE_NORMAL
- en: Querying Data from a Table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *query* is a request for information from a database table or group of tables.
    To specify the information you want to retrieve from the table, use the `select`
    command, as shown in [Listing 3-1](#listing3-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-1: Using `select` to display data from the `continent` table'
  prefs: []
  type: TYPE_NORMAL
- en: Here you’re querying the `continent` table (as indicated by the `from` keyword),
    which contains information about each continent’s name and population. Using the
    `select` command, you specify that you want to return data from the `continent_id`,
    `continent_name`, and `population` columns. This is known as a `select` statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-2](#listing3-2) shows the results of running the `select` statement.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-2: Results of running the `select` statement'
  prefs: []
  type: TYPE_NORMAL
- en: The query returned a list of all seven continents, displaying each continent’s
    ID, name, and population.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to show the data from only one continent—Asia, for example—you can
    add a `where` clause to the end of your previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A `where` clause filters the results by applying conditions to the `select`
    statement. This query finds the only row in the table where the value of the `continent_name`
    column equals `Asia` and displays the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now change the `select` statement to select only the `population` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The query now returns one column (`population`) for one row (`Asia`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `continent_id` and `continent_name` values don’t appear in your result set
    because you didn’t select them in the SQL query.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Wildcard Character
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The asterisk wildcard character (`*`) in SQL allows you to select all of the
    columns in a table without having to type all of their names in your query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This query returns all three columns from the `continent` table. The results
    are the same as those for [Listing 3-1](#listing3-1), where you individually listed
    the three column names.
  prefs: []
  type: TYPE_NORMAL
- en: Ordering Rows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you query data from your database, you’ll often want to see the results
    in a particular order. To do that, add an `order by` clause to your SQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here you select all of the columns in the `continent` table and order the results
    alphabetically by the values in the `continent_name` column.
  prefs: []
  type: TYPE_NORMAL
- en: 'The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Adding `order by` `continent_name` results in an alphabetized list, regardless
    of the values of the `continent_id` or `population` columns. MySQL ordered the
    rows alphabetically because `continent_name` is defined as a column that stores
    alphanumeric characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'MySQL can also order columns with integer data types. You can specify whether
    you want your results sorted in ascending (lowest to highest) or descending (highest
    to lowest) order using the `asc` and `desc` keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this example, you have MySQL order the results by `population` and sort the
    values in descending order (`desc`) order.
  prefs: []
  type: TYPE_NORMAL
- en: 'The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The query returns all seven rows because you didn’t filter the results with
    a `where` clause. Now the data is displayed in descending order based on the `population`
    column instead of alphabetically based on the `continent_name` column.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting SQL Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, the SQL you’ve seen has been in a nice, readable format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how the column names and the table name all align vertically. It’s a
    good idea to write SQL statements in a neat, maintainable format like this, but
    MySQL will also allow you to write SQL statements in less organized ways. For
    example, you can write the code from [Listing 3-1](#listing3-1) on only one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can separate the `select` and `from` statements, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Both options return the same results as [Listing 3-1](#listing3-1), though your
    SQL might be a little harder for people to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Readable code is important for the maintainability of your codebase, even though
    MySQL will run less readable code without issue. It might be tempting to just
    get the code working and then move on to the next task, but writing the code is
    only the first part of your job. Take the time to make your code readable, and
    your future self (or whoever will be maintaining the code) will thank you.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at some other SQL code conventions you might see.
  prefs: []
  type: TYPE_NORMAL
- en: Uppercase Keywords
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some developers use uppercase for MySQL keywords. For example, they might write
    [Listing 3-1](#listing3-1) like this, with the words `select` and `from` in uppercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, some developers might format a `create table` statement with multiple
    phrases in uppercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, `create` `table`, `unique`, `primary` `key`, `foreign` `key`, and `references`
    have all been capitalized for readability. Some MySQL developers would capitalize
    the data types `int` and `varchar` as well. If you find using uppercase for keywords
    is beneficial, feel free to do so.
  prefs: []
  type: TYPE_NORMAL
- en: If you are working with an existing codebase, it’s best to be consistent and
    follow the coding style precedent that has been set. If you work at a company
    that has formal style conventions, you should follow them. Otherwise, choose what
    works best for you. You’ll get the same results either way.
  prefs: []
  type: TYPE_NORMAL
- en: Backticks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you maintain SQL that other developers have written, you may encounter SQL
    statements that use backticks (`` ` ``):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This query selects all of the columns in the `continent` table, surrounding
    the column names and the table name with backticks. In this example, the statement
    runs just as well without the backticks.
  prefs: []
  type: TYPE_NORMAL
- en: Backticks allow you to get around some of MySQL’s rules for naming tables and
    columns. For example, you might have noticed that when column names consist of
    more than one word, I’ve used an underscore between the words instead of a space,
    like `continent_id`. If you wrap column names in backticks, however, you don’t
    need to use underscores; you can name a column `continent id` rather than `continent_id`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, if you were to name a table or column `select`, you’d receive an
    error message because `select` is a MySQL *reserved word*; that is, it has a dedicated
    meaning in SQL. However, if you wrap `select` in backticks, the query will run
    without error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this `select * from` statement, you’re selecting all columns within the `select`
    table.
  prefs: []
  type: TYPE_NORMAL
- en: Although MySQL will run code like this, I recommend avoiding backticks, as your
    code will be more maintainable and easier to type without them. In the future,
    another developer who needs to make a change to this query might be confused by
    a table named `select` or a table with spaces in its name. Your goal should always
    be to write code that is simple and well organized.
  prefs: []
  type: TYPE_NORMAL
- en: Code Comments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Comments are lines of explanatory text that you can add to your code to make
    it easier to understand. They can help you or other developers maintain the code
    in the future. Oftentimes, comments clarify complex SQL statements or point out
    anything about the table or data that’s out of the ordinary.
  prefs: []
  type: TYPE_NORMAL
- en: To add single-line comments, use two hyphens followed by a space (`--` ). This
    syntax tells MySQL that the rest of the line is a comment.
  prefs: []
  type: TYPE_NORMAL
- en: 'This SQL query includes a one-line comment at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the same syntax to add a comment at the end of a line of SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this code, the comment for the `continent_name` column lets developers know
    that the names are displayed in English.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add multiline comments, use `/*` at the beginning of the comment and `*/`
    at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This two-line comment explains the query and says how often the table is updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for inline comments is similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'There are some special uses for inline comments. For example, if you maintain
    code that has been written by others, you might notice what looks like cryptic
    inline comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `/*+ no_index(employee idx1) */` in the first line is an *optimizer hint*,
    which uses the inline comment syntax with a plus sign after the `/*`.
  prefs: []
  type: TYPE_NORMAL
- en: When you run a query, MySQL’s query optimizer tries to determine the fastest
    way to execute it. For example, if there are indexes on the `employee` table,
    would it be faster to use the indexes to access the data, or do the tables have
    so few rows that using the indexes would actually be slower?
  prefs: []
  type: TYPE_NORMAL
- en: The query optimizer usually does a good job of coming up with query plans, comparing
    them, and then executing the fastest plan. But there are times when you’ll want
    to give your own instructions—hints—about the most efficient way to execute the
    query.
  prefs: []
  type: TYPE_NORMAL
- en: The hint in the preceding example tells the optimizer not to use the `idx1`
    index on the `employee` table.
  prefs: []
  type: TYPE_NORMAL
- en: Query optimization is a vast topic and we’ve barely scratched the surface, but
    if you encounter the `/*+` . . . `*/` syntax, just know that it allows you to
    provide hints to MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, a well-placed, descriptive comment will save time and aggravation.
    A quick explanation about why you used a particular approach can spare another
    developer from having to research the same issue, or jog your own memory if you’ll
    be the one maintaining the code. However, avoid the temptation to add comments
    that state the obvious; if a comment won’t make the SQL more understandable, you
    shouldn’t add it. Also, it’s important to update comments as you update your code.
    Comments that aren’t up to date and are no longer relevant don’t serve a purpose,
    and might confuse other developers or your future self.
  prefs: []
  type: TYPE_NORMAL
- en: Null Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed in [Chapter 2](c02.xhtml), `null` represents a missing or unknown
    value. MySQL has special syntax, including `is null` and `is not null`, to help
    handle null values in your data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a table called `unemployed` that has two columns: `region_id` and
    `unemployed`. Each row represents a region and tells you how many people are unemployed
    in that region. Look at the full table using `select * from`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Regions 1 and 2 have reported their number of unemployed people, but region
    3 hasn’t done so yet, so the `unemployed` column for region 3 is set to the `null`
    value. You wouldn’t want to use `0` here, because that would mean there are no
    unemployed people in region 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'To show only the rows for regions that have an `unemployed` value of `null`,
    use the `where` clause with `is null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, if you wanted to *exclude* rows that have an `unemployed`
    value of `null` in order to see only the data that has already been reported,
    replace `is null` with `is not null` in the `where` clause, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Using this syntax with null values can help you filter your table data so that
    MySQL returns only the most meaningful results.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use the `select` statement and the wildcard
    character to retrieve data from a table, and you saw that MySQL can return results
    in an order you specify. You also looked at ways to format your code for readability
    and clarity, including adding comments to your SQL statements to make maintaining
    the code easier. Finally, you saw how you might handle null values in your data.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 4](c04.xhtml) is all about MySQL data types. So far, the tables you’ve
    created have mainly used `int` to accept integer data or `varchar` to accept character
    data. Next, you’ll learn more about other MySQL data types for numeric and character
    data, as well as data types for dates and very large values.'
  prefs: []
  type: TYPE_NORMAL
