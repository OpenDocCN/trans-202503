- en: '**4**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**DIRECTORY LAYOUT AND FORENSIC ANALYSIS OF LINUX FILES**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The previous chapter described forensic analysis of storage and filesystems,
    the low-level building blocks that create the illusion of a hierarchical file
    tree. This chapter focuses on the layout of that file tree, takes a closer look
    at individual files, and identifies specific areas of interest to digital forensic
    examiners.
  prefs: []
  type: TYPE_NORMAL
- en: '**Linux Directory Layout**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When performing a forensic examination of a Linux system, understanding the
    organization of files and directories on a drive helps the investigator to locate
    areas and artifacts of interest quickly and ignore areas that are less likely
    to contain evidence.
  prefs: []
  type: TYPE_NORMAL
- en: Linux adopted its tree-like structure from traditional Unix, which starts with
    the *root* directory, represented by a forward slash (/). Additional filesystems
    on local storage or remote network servers can be attached (mounted) to any subdirectory
    in the tree.
  prefs: []
  type: TYPE_NORMAL
- en: Original Unix systems organized the filesystem hierarchy into directories to
    separate executable programs, shared libraries, configuration files, devices,
    documentation, user directories, and so on.^([1](footnotes.xhtml#ch04foot_01))
    Linux systems today still use most of the names those directories were given.
  prefs: []
  type: TYPE_NORMAL
- en: '***Filesystem Hierarchy***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The top of this hierarchical tree is called the root directory, or */* (not
    to be confused with the root user’s home directory, */root/*). All subdirectories,
    mounted storage media, mounted network shares, or other mounted virtual filesystems,
    are attached to this “upside down” tree below the root, as illustrated in [Figure
    4-1](ch04.xhtml#ch04fig01). This process is called *mounting* a filesystem, and
    the directory (typically empty) where it is mounted is called the *mount point*.
    The PC DOS world differs in that attached filesystems (local or remote) are represented
    as individual drive letters (A:, B:,. . ., Z:).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/ch04fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Filesystem tree structure*'
  prefs: []
  type: TYPE_NORMAL
- en: The POSIX and Open Group UNIX standards didn’t define a detailed directory layout^([2](footnotes.xhtml#ch04foot_02))
    for Unix vendors to follow. Unix systems and Linux distributions document their
    directory hierarchy in the hier(7) or hier(5) man pages. The Linux community developed
    the *Filesystem Hierarchy Standard (FHS)*^([3](footnotes.xhtml#ch04foot_03)) to
    encourage a common layout across distributions. Modern Linux systems also have
    a file-hierarchy(7) man page with additional information related to systemd. The
    rest of this section describes each of the top-level directories commonly used
    in Linux and their relevance to forensics.
  prefs: []
  type: TYPE_NORMAL
- en: '**/boot/ and efi/**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The */boot/*and *efi/* directories^([4](footnotes.xhtml#ch04foot_04)) contain
    files for booting the system. Boot configuration (kernel parameters and so on)
    can be found here. Current and previous kernels can be found here together with
    the initial ramfs, which can be examined. On EFI systems, the EFI partition (a
    FAT filesystem) is often mounted inside the */boot/* directory. Non-standard and
    non-default files that have been added to the */boot/*and *efi/* directories should
    be examined. [Chapter 6](ch06.xhtml) on forensic analysis of Linux system initialization
    describes these directories in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: '**/etc/**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The */etc/* directory is the traditional location for system-wide configuration
    files and other data. The majority of these files are easily examined plaintext
    files. Configuration files may have a corresponding directory with a *.d* extension
    for drop-in files that are included as part of the configuration.^([5](footnotes.xhtml#ch04foot_05))
    The creation and modification timestamps of these files may be interesting in
    an investigation, as they indicate when a particular configuration file was added
    or changed. In addition, user-specific configuration files in a user’s */home/*
    directory may override system-wide */etc/* files. Deviations from the distro or
    software defaults are often found here and may be of forensic interest. Copies
    of the distro default files are sometimes found in */usr/share/factory/etc/**
    and can be compared with those in the */etc/* directory. When some distros perform
    upgrades to config files in */etc/*, they may create a backup copy of the old
    files or add the new file with an extension (Arch’s Pacman uses the extension
    **.pacnew*). Various files in */etc/* are explained in more detail throughout
    the book.
  prefs: []
  type: TYPE_NORMAL
- en: '**/srv/**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The */srv/* directory is available for use by server application content, such
    as FTP or HTTP files. This is a good directory to examine in case it contains
    files that were published or otherwise accessible over a network. This directory
    is unused on many distributions and may be empty.
  prefs: []
  type: TYPE_NORMAL
- en: '**/tmp/**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The */tmp/* directory is for storing temporary files. These files may be deleted
    periodically or during boot, depending on the distro or system’s configuration.
    In some Linux distros, the contents of */tmp/* may reside in RAM using the tmpfs
    virtual memory filesystem. On a forensic image, systems using tmpfs to mount */tmp/*
    will likely be empty. See the systemd-tmpfiles(8) man page for more information
    about how a system manages temporary files, and see the tmpfs(5) man page for
    more details regarding virtual memory filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: '**/run/**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The */run/* directory is a tmpfs-mounted directory residing in RAM and will
    likely be empty on a forensic image. On a running system, this directory contains
    runtime information like PID and lock files, systemd runtime configuration, and
    more. There may be references to files and directories in */run/* found in logs
    or configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: '**/home/ and /root/**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The */home/* directory is the default location for user home directories. A
    user’s home directory contains files the user created or downloaded, including
    configuration, cache, data, documents, media, desktop contents, and other files
    the user owns. The */etc/skel/*directory (which might only contain hidden “.”
    files) contains the default contents of a newly created */home/** directory. The
    root user’s home directory is typically */root/* of the root filesystem. This
    is intentional so that root can log in even when */home/* is not mounted. These
    home directories are of significant interest to forensic investigators because
    they provide information about a system’s human users. If */home/* is empty on
    a forensic image, it’s likely the user’s home directories are mounted from another
    filesystem or over a network. The creation (birth) timestamp of a user’s home
    directory may indicate when the user account was first added. [Chapter 10](ch10.xhtml)
    covers the */home/* directory contents in detail.
  prefs: []
  type: TYPE_NORMAL
- en: '**/bin/, /sbin/, /usr/bin/, and /usr/sbin/**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The standard locations for executable programs are */bin/*, */sbin/*, */usr/bin/*,
    and */usr/sbin/*. These directories originally were intended to separate groups
    of programs for users, administrators, the boot process, or for separately mounted
    filesystems. Today, */bin/* and */sbin/* are often symlinked to their corresponding
    directory in */usr/*, and in some cases, */bin/*, */sbin/*, and */usr/ sbin/*
    are symlinked to a single */usr/bin/* directory containing all programs. Be careful
    examining symlinked directories on a suspect drive mounted on your own Linux analysis
    machine. The symlinks might be pointing to your own directories and not the suspect
    drive.
  prefs: []
  type: TYPE_NORMAL
- en: '**/lib/ and /usr/lib/**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The */lib/* directory is generally symlinked to */usr/lib/* on most Linux systems
    today. This includes shared library code (also for multiple platforms), kernel
    modules, support for programming environments (header files), and more. The */lib/*
    directory also contains the default configuration files for many software packages.
  prefs: []
  type: TYPE_NORMAL
- en: '**/usr/**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The */usr/* directory contains the bulk of the system’s static read-only data.
    This includes binaries, libraries, documentation, and more. Most Linux systems
    will symlink */bin/*, */sbin/*, and */lib/* to their equivalents in the */usr/*
    subdirectory. Files located here that are not part of any installed package may
    be of forensic interest because they were added outside the normal software installation
    process. These might be manually installed files by a user with root access, or
    unauthorized files placed by a malicious actor.
  prefs: []
  type: TYPE_NORMAL
- en: '**/var/**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The */var/* directory contains system data that is changing (variable) and usually
    persistent across reboots. The subdirectories below */var/* are especially interesting
    from a forensics perspective because they contain logs, cache, historical data,
    persistent temporary files, the mail and printing subsystems, and much more. A
    significant portion of this book deals with files and directories in the */var/*
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: '**/dev/, /sys/, and /proc/**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Linux has several other tmpfs and pseudo-filesystems that appear to contain
    files when the system is running, which include */dev/*, */sys/*, and */proc/*.
    These directories provide representations of devices or kernel data structures
    but the contents don’t actually exist on a normal filesystem. When examining a
    forensic image, these directories will likely be empty. See the procfs(5) and
    sysfs(5) man pages for more details.
  prefs: []
  type: TYPE_NORMAL
- en: '**/media/**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The */media/* directory is intended to hold dynamically created mount points
    for mounting external removable storage, such as CDROMs or USB drives. When examining
    a forensic image, this directory will likely be empty. References to */media/*
    in logs, filesystem metadata, or other persistent data may provide information
    about user attached (mounted) external storage devices.
  prefs: []
  type: TYPE_NORMAL
- en: '**/opt/**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The */opt/* directory contains add-on packages, which typically are grouped
    by vendor name or package name. These packages may create a self-contained directory
    tree to organize their own files (for example, *bin/*, *etc/*, and other common
    subdirectories).
  prefs: []
  type: TYPE_NORMAL
- en: '**/lost+found/**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A */lost+found/* directory may exist on the root of every filesystem. If a filesystem
    repair is run (using the `fsck` command) and a file is found without a parent
    directory, that file (sometimes called an *orphan*) is placed in the */lost+found/*
    directory where it can be recovered. Such files don’t have their original names
    because the directory that contained the filename is unknown or missing.
  prefs: []
  type: TYPE_NORMAL
- en: '**./ and ../**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Two hidden subdirectories (./ and ../) are found in every directory. The single
    dot (.) represents the current directory, and the double dot (..) represents the
    parent directory. At the top of the tree, these two files also exist, and both
    represent the root (/) directory (and have the same inode number). From a low-level
    filesystem perspective, these dot files are needed to link a directory to its
    parent, creating the illusion of a hierarchical tree.
  prefs: []
  type: TYPE_NORMAL
- en: '***User Home Directory***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A forensic investigation typically involves analysis of human user activity
    (where the user could be either a victim or a suspect). All users on a Linux system
    have a home directory where they have permission to save files and documents,
    customize their environment, store persistent and cached data, and retain historical
    data (browser cookies, shell history, or email, for example). The user’s home
    directory contains significant amounts of potential evidence investigators can
    use to reconstruct past events and activity. The location of a user’s home directory
    is defined in the */etc/passwd* file and typically defaults to a subdirectory
    in */home/* with their username (for example, */home/sam/*). A user’s home directory
    can also be abbreviated with a tilde (*~/*) for use on the command line or in
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hidden Dot Files and XDG Base Directories**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'It is common practice to save user configuration data in hidden files and directories
    that begin with a dot and are named after the program being configured. Several
    examples of information found in a home directory’s hidden files include:'
  prefs: []
  type: TYPE_NORMAL
- en: '***.bash_history*** History of shell commands the user typed'
  prefs: []
  type: TYPE_NORMAL
- en: '***.lesshst*** Search history of the `less` command'
  prefs: []
  type: TYPE_NORMAL
- en: '***.viminfo*** Search and command history, and traces of vim-edited files'
  prefs: []
  type: TYPE_NORMAL
- en: '***.wget-hsts*** List of `wget` hosts visited^([6](footnotes.xhtml#ch04foot_06))
    with timestamps'
  prefs: []
  type: TYPE_NORMAL
- en: '***.forward*** File containing email addresses for auto-forwarding'
  prefs: []
  type: TYPE_NORMAL
- en: '***.apvlvinfo*** History of PDFs viewed using the apvlv PDF viewer'
  prefs: []
  type: TYPE_NORMAL
- en: 'For more complex user configuration, cache, history, and persistent data, an
    application may create a dedicated hidden directory containing multiple files
    and subdirectories to organize data. Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '***.ssh/*** Secure shell configuration, keys, and list of known hosts visited'
  prefs: []
  type: TYPE_NORMAL
- en: '***.gnupg/*** GPG configuration, keys, and other people’s added public keys'
  prefs: []
  type: TYPE_NORMAL
- en: '***.thunderbird/*** Email and calendar accounts, and synchronized email and
    calendar content for offline access'
  prefs: []
  type: TYPE_NORMAL
- en: '***.mozilla/*** Firefox configuration, cookies, bookmarks, browsing history,
    and plug-ins'
  prefs: []
  type: TYPE_NORMAL
- en: '***.zoom/*** Zoom configuration, logs, call history, and shared data'
  prefs: []
  type: TYPE_NORMAL
- en: '***.john/*** John the Ripper password-cracking history with discovered passwords'
  prefs: []
  type: TYPE_NORMAL
- en: '***.ICAClient/*** Citrix client configuration, cache, logs, and other data'
  prefs: []
  type: TYPE_NORMAL
- en: The developers of any software package are free to choose what to save and where
    to save it. Storing information using hidden files and directories was never required,
    but it became common practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Over time, the number of dot files in a typical user’s home directory became
    unwieldy, driving the need for standardization. The former X Desktop Group (known
    today as [freedesktop.org](http://freedesktop.org)) created the *XDG Base Directory
    Specification* (*[https://www.freedesktop.org/wiki/Specifications/basedir-spec/](https://www.freedesktop.org/wiki/Specifications/basedir-spec/)*),
    which defined standard locations for storing user-specific data.^([7](footnotes.xhtml#ch04foot_07))
    The specification defines environment variables and default locations that operating
    systems and applications may use instead of creating their own proprietary files
    and directories in the user’s home directory. These location environment variables
    and associated default locations are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Data files: `$XDG_DATA_HOME` or default *~/.local/share/**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Configuration files: `$XDG_CONFIG_HOME` or default *~/.config/**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Non-essential cache data: `$XDG_CACHE_HOME` or default *~/.cache*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Runtime files: `$XDG_RUNTIME_DIR` or typically */run/user/*UID (where *UID*
    is the numeric ID of the user)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, the specification defines two search variables, `$XDG_DATA_DIRS`
    and `$XDG_CONFIG_DIRS`, which contain paths for additional configuration (this
    is often to include system-wide, or Flatpak and snap, directories). The */run/*
    directory is mounted on a temporary RAM-based filesystem (tmpfs), so user runtime
    files exist only when the system is running and the user is logged in. The */run/*
    directory will be empty when examining a forensic image.
  prefs: []
  type: TYPE_NORMAL
- en: '**Location of User Application and System Information**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When performing a postmortem forensic analysis, the data, configuration, and
    cache directories contain significant amounts of information about applications
    and system components related to a user’s activity. Many of these locations are
    described in more detail in the rest of the book, but let’s look at some examples.
  prefs: []
  type: TYPE_NORMAL
- en: Programs placing data in the *~/.cache/* directory expect that it might be deleted.
    It is considered “non-essential” but remains persistent over time and across login
    sessions and reboots. Any program can create files or directories in *~/.cache/*
    to store data for performance and efficiency reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are examples of information and the programs that may save them:'
  prefs: []
  type: TYPE_NORMAL
- en: Browsers cache HTML, images, JavaScript, and safe browsing information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A separate directory for web favicons exists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software Center caches file lists, images, ratings, and information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some mail clients store cached email and calendars
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package managers save downloaded software packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programs store thumbnails, images, and album art
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Window managers and desktop environments save session information and logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some programs use *.cache* as the location to auto-save open files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Temporary screenshot data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any other cache data stored by programs for performance or efficiency reasons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *~/.cache/* directory stores anything that can be re-downloaded, locally
    generated, or otherwise recovered and re-created. These files contain information
    about the use of the system and different applications. The creation and modification
    timestamps may help reconstruct a timeline of past activity.
  prefs: []
  type: TYPE_NORMAL
- en: The user’s *~/.config/* directory is supposed to contain only configuration
    data, but many application developers use it for other things, like history and
    cached information. Files in *~/.config/* may end in **rc* or have extensions
    of *.conf*, *.ini*, *.xml*, *.yaml*, or other configuration formats. Most files
    found here are regular text files and are easy to view with any text editor or
    viewer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, configuration information is stored in databases and must be
    extracted. Because this is the free and open source world, tools and specifications
    usually exist to facilitate analysis of those databases. Some examples of data
    stored in the *~/.config/* directory include:'
  prefs: []
  type: TYPE_NORMAL
- en: General configuration of applications (not including data)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Desktop artifacts (trash, session configuration, autostart, and dconf)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application extensions and plug-ins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Files containing unique identifiers and license data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cookies for some browsers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application state data (first time run, initial welcome banners)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration of user accounts and remote servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication application (Wire, Jitsi) logs, persistence, and cache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default applications specified in a *mimeapps.list* file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any other arbitrary configuration data stored by programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aside from the usual configuration data from applications, the *~/.config/*
    directory is interesting to search for usernames, email addresses, and hostnames
    that indicate remote connections and activity. In some cases, you also can find
    passwords or password hashes in user configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *~/.local/share/* directory is intended to store persistent data accumulated
    or generated by applications. Examples of data saved here include:'
  prefs: []
  type: TYPE_NORMAL
- en: Distro-specific configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graphical login session configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Desktop-specific configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Desktop-bundled apps (readers, notes, file managers, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commonly shared thumbnails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Desktop trashcan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cookies for some browsers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calendar and contact databases for some applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recently used files and places (**.xbel* files)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Snap and Flatpak application information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Baloo file index and search for KDE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracker file index and search for GNOME
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secret keyrings and password wallets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clipboard manager data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Xorg logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any other persistent data stored by programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most distributions and applications are starting to follow the XDG specifications,
    and thus provide common locations for artifacts of interest to forensic investigators.
    However, some applications do not follow the XDG Base Directory Specification
    correctly or at all. This may be historic, for backward compatibility, or for
    other reasons. The Arch Linux wiki maintains a list (*[https://wiki.archlinux.org/index.php/XDG_Base_Directory](https://wiki.archlinux.org/index.php/XDG_Base_Directory)*)
    of application compatibility with the XDG Base Directory Specification. As you
    can see, every application is free to choose what to save, how to save it, and
    where to save it. Even across desktop environments and distributions, only the
    XDG base directories are consistent, but even that is not a requirement. When
    analyzing user home directories, be sure to examine each hidden file and directory
    in the */home/* and the XDG base directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Independent of applications, the XDG standards suggest a list of common directories
    in a user’s */home/* directory to store user files based on category. These directories
    are defined in */etc/xdg/user-dirs.defaults* and may be created on login if they
    don’t already exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Desktop/*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Downloads/*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Templates/*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Public/*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Documents/*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Music/*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Pictures/*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Videos/*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Desktop/* directory is for files that will appear on the user’s desktop,
    and the *Downloads/* directory is a default location for applications to save
    downloaded files. Applications (like office suites) reference the *Templates/*
    directory to suggest template files when a user is creating a new document. The
    *Public/* directory can be used as an open share for other users (typically on
    a local LAN) to access files. The remaining directories are self-explanatory,
    and relevant applications can use those directories as default locations to store
    documents and media files.
  prefs: []
  type: TYPE_NORMAL
- en: 'These directory names are created with local language translations depending
    on the locale’s settings. For example, on my German test system, the following
    folders corresponding to the English equivalents: *Schreibtisch/*, *Vorlagen/*,
    *Downloads/*, *Öffentlich/*, *Dokumente/*, *Musik/*, *Bilder/*, and *Videos/*.'
  prefs: []
  type: TYPE_NORMAL
- en: The *~/Downloads/* directory can be interesting to analyze. When some browsers
    begin downloading a file, they create a temporary file and then move it to the
    correct filename when the download completes (Firefox uses **.part* as the temporary
    file). This means the birth (`crtime`) timestamp represents when the download
    started, and the contents’ last modified (`mtime`) timestamp is when the download
    finished. Because we know the size of the file, we can even calculate the approximate
    speed of the download over the network connection at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, a 7GB DVD download started at 8:51 and finished at 9:12:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Knowing the start and end time of a file download could be interesting in a
    forensic investigation, especially when reconstructing timelines of user activity.
  prefs: []
  type: TYPE_NORMAL
- en: This book does not focus on Linux application analysis, so these examples are
    brief and incomplete. Some of the files and directories (*.ssh* and *.gnupg*,
    for example) are covered in more detail elsewhere in the book. The other examples
    shown here illustrate the commonly used locations and contents of application
    data stored on Linux systems. Good sources of information for forensic analysis
    techniques for individual applications are Forensic Science International’s *Digital
    Investigation* journal, the DFRWS conference, and *[https://www.ForensicFocus.com/](https://www.ForensicFocus.com/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Hashsets and NSRL for Linux***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A common method of identifying files in digital forensics is to use cryptographic
    hashes (MD5, SHA-1, and so on) to create a unique fingerprint or signature. You
    can create lists of cryptographic hashes from software packages or other known
    collections of files. These lists of known file hashes are called *hashsets* or
    *hash databases*. In digital forensics, hashsets are typically used either to
    ignore uninteresting files or to identify especially interesting files.
  prefs: []
  type: TYPE_NORMAL
- en: 'When used to ignore uninteresting files, hashsets can reduce the number of
    files to be examined. For instance, if an investigator is interested only in files
    created, modified, or downloaded apart from the installation of an operating system,
    they can use hashsets to filter out the files known to belong to that operating
    system. Examples of known files typically ignored during forensic analysis include:'
  prefs: []
  type: TYPE_NORMAL
- en: Operating systems and all supporting files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Device drivers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Company-generated hashsets of standard server or client installations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hashsets identify only the contents of files, not the metadata of the installed
    files on the filesystem. Timestamps, permissions, ownership, and so on are part
    of the filesystem, and aren’t included in a hashset.
  prefs: []
  type: TYPE_NORMAL
- en: 'When identifying especially interesting files, investigators use hashsets to
    search for the existence of files in a forensic drive image. For example, if an
    investigator has a list of hashes for files involved in a particular cyberattack,
    they can search an affected machine specifically for the existence of those files.
    Examples of known files typically of interest during forensic analysis include:'
  prefs: []
  type: TYPE_NORMAL
- en: Indicators of compromise (IOCs), which may include hashes of malware components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Certain classifications of software (keyloggers or bitcoin miners, for example)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Known illicit material (these hashsets are usually available only to law enforcement)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Known leaked or sensitive documents in a corporate environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hashsets also are used to find modified or trojaned versions of binary executables
    by comparing installed files with the expected vendor-supplied hash values.
  prefs: []
  type: TYPE_NORMAL
- en: You can find hashsets of known files in several places. The security community
    often shares IOCs and security-related hashsets, and cybersecurity companies sell
    them as threat intelligence data feeds. Law enforcement agencies share hashsets
    of illicit material, which are made available only to other police forensic labs.
    Large companies may create hashsets of their internally developed software packages
    or standard server/client installations.
  prefs: []
  type: TYPE_NORMAL
- en: 'NIST maintains the National Software Reference Library (NSRL),^([8](footnotes.xhtml#ch04foot_08))
    which is a collection of known software packages. NIST provides hashsets from
    the NSRL for free (*[http://www.nsrl.nist.gov/](http://www.nsrl.nist.gov/)*).
    The NSRL hashsets are a compressed list of files with hashes, the filename, product,
    and other information; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The format of NSRL data sets is defined at *[https://www.nist.gov/system/files/data-formats-of-the-nsrl-reference-data-set-16.pdf/](https://www.nist.gov/system/files/data-formats-of-the-nsrl-reference-data-set-16.pdf/)*.
  prefs: []
  type: TYPE_NORMAL
- en: Hashsets are also available as commercial products. These typically include
    the NSRL hashsets, additional hashes that could be extracted from commercial products
    (not included in the NSRL), and other sources. A popular example is *[https://www.hashsets.com/](https://www.hashsets.com/)*,
    which provides hashset subscriptions that augment the NSRL data.
  prefs: []
  type: TYPE_NORMAL
- en: Most digital forensic software (including free open source tools like Autopsy
    and The Sleuth Kit) support the inclusion and exclusion of hashsets for analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Maintaining hashsets for Linux systems and free and open source software (FOSS)
    in general causes some difficulties. Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Rolling distributions like Arch Linux update on a daily basis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some software packages are compiled from source and may produce files that are
    unique to the system where they are installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some software runs installation scripts that may generate files unique to the
    system where they are installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many different Linux distributions provide their own software re-positories
    that are constantly changing and updating (see *[https://distrowatch.com/](https://distrowatch.com/)*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux users may download software directly from developers and then compile
    and install manually on their own systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This dynamic landscape of change and development makes maintaining hashsets
    more difficult. In contrast, commercial software vendors have release cycles with
    well-defined software product packages.
  prefs: []
  type: TYPE_NORMAL
- en: Most open source software developers provide hashes or GPG signatures of the
    source code to verify integrity. But these hashes are for the code, not the compiled
    binaries. Most Linux distributions provide hashes or GPG signatures of the compiled
    binary software packages they provide, and some even include hashes of each individual
    file (see [Chapter 7](ch07.xhtml) on software installation for more information).
  prefs: []
  type: TYPE_NORMAL
- en: '**Linux File Types and Identification**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The phrase *file type* can have one of two meanings. In the context of lower-layer
    filesystems, it refers to Unix or POSIX file types. In the context of higher-layer
    applications, it refers to the file content type. Understanding this difference
    is important when conducting a forensic examination. In addition, “hidden” files
    (which are usually just normal files and not actually hidden) can provide important
    information for an investigation.
  prefs: []
  type: TYPE_NORMAL
- en: '***POSIX File Types***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Linux was developed with the Unix philosophy of “everything is a file.” To
    implement this concept, special file types were needed to extend functionality
    beyond regular files and directories. Linux has adopted the seven fundamental
    file types as defined by the POSIX standard, allowing the representation of special
    objects as files. These file types are:'
  prefs: []
  type: TYPE_NORMAL
- en: Regular file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symbolic link
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Named pipe or FIFO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Block special
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Character special
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Socket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Every “file” on a Linux system is categorized into one of these types and can
    be determined with the `ls -l` or `file` commands (and others). Understanding
    the difference between these file types is important to forensic investigators
    because not all files are related to data storage (and potentially contain evidence).
    Some files provide access to hardware devices or facilitate the flow of data between
    programs. Understanding this system behavior helps to reconstruct past events
    and locate potential evidence stored in other locations. Let’s take a closer look
    at the seven file types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Regular files** A regular file is exactly that: a file containing data such
    as text, pictures, videos, office documents, executable programs, databases, encrypted
    data, or any other content normally stored in a file. Data in a regular file is
    stored in filesystem blocks on the storage medium.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Directory files** These are special files that contain a list of the directory’s
    contents, including filenames and their corresponding inodes. They allow files
    and directories to be organized hierarchically in a tree structure. However, this
    is only an abstraction because, at lower layers, the file blocks can be located
    anywhere on a drive. Directories are also known as folders and are created with
    commands like `mkdir`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Symbolic links** This type of file represents a pointer to another file (similar
    to LNK files in Windows, but without the additional metadata). A symbolic link
    is a small file containing the path and name of another file (depending on the
    filesystem, this information may be stored in the link’s inode). The size of a
    symbolic link file is the same as the length of the filename it points to. Symbolic
    links are allowed to point to files that don’t exist, and this may be interesting
    from a forensics perspective. This indicates that a file existed in the past or
    was on a filesystem mounted in the past. Symbolic links are also called symlinks
    and are created with the `ln -s` command.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Character and block special files** These files provide access to hardware
    devices (and pseudo-devices) through device drivers or kernel modules. These files
    are usually located in the */dev/* directory. Modern Linux systems create and
    remove them dynamically, but they can be created manually with the `mknod` command.
    Block devices are typically used to access storage media, and can be buffered,
    cached, or otherwise abstracted. Both character and block special files are associated
    with devices by a major and minor number specified when the device file is created.
    Use the `ls -l` or `stat` commands to identify the major and minor numbers. For
    a list of the assigned major and minor numbers on a running Linux system, look
    in the */sys/dev/block/* and */sys/dev/char/* directories. You can list block
    devices with the `lsblk` command. The file size of a character or block file is
    zero bytes.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Named pipe or FIFO** These files provide unidirectional interprocess communication
    between two programs. One program writing to a pipe can transfer data to another
    program that is reading from the same pipe. The `mkfifo` or `mknod` commands are
    used to create pipes. A pipe’s file size is zero bytes.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Socket files** Also providing interprocess communication, these files are
    bi-directional, and multiple programs may use them at the same time. They are
    often created by a daemon providing local services (instead of using TCP/IP sockets)
    and are removed on exit. Socket files can also be created by systemd socket activation.'
  prefs: []
  type: TYPE_NORMAL
- en: Why are hard links not on this list of file types? Hard links are not considered
    to be a file type. A *hard link* is simply an additional filename linked to an
    existing inode (the inode represents the actual file, as described in [Chapter
    3](ch03.xhtml)).
  prefs: []
  type: TYPE_NORMAL
- en: A *sparse file* is also not a file type, but rather a feature of the filesystem
    that allows a regular file containing continuous sequences of zeros to be written
    to disk in a compact form.
  prefs: []
  type: TYPE_NORMAL
- en: 'When examining different file types in a postmortem forensic analysis, be aware
    of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Block and character special files are created (and removed) in the */dev/* or
    */sys/* directories dynamically while the system is running. These directories
    will likely be empty during a forensic examination.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Named pipes (FIFOs) and sockets will not contain any data (anything written
    to them is received by another running process). A program or daemon can also
    remove the pipe or socket file from the filesystem when it exits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A symbolic link is not required to point to an existing file. The link file
    will contain a filename, but the file it’s pointing to may or may not be there.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you have a forensic image of a suspect Linux system directly mounted to
    your Linux analysis workstation, symbolic links from the drive under analysis
    may point to files and directories* on your own analysis machine*. Make sure that
    you are always analyzing the intended filesystem.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Magic Strings and File Extensions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The POSIX definition of a *regular file* refers to a filesystem file type, but
    the contents of this regular file can be text, pictures, videos, office documents,
    executable programs, databases, encrypted files, or any other content. The file
    content is also referred to as a file type, but at the application layer. There
    are several ways to identify the application file type of regular files. The phrase
    *file type* used in this section refers to application file types, not POSIX file
    types.
  prefs: []
  type: TYPE_NORMAL
- en: The terms *magic string*, *magic type*, *magic signature*, or *magic bytes*
    all refer to a string of bytes at the beginning of a file. Linux shells and file
    managers use magic strings to identify the file type and choose which program
    to run for the file in question. These strings are typically part of the file
    format and are difficult to modify or remove maliciously without breaking functionality.
    You can use the Linux `file` command to determine the file type (`file -l` lists
    around 3,000 supported types). Forensic carving tools also use magic strings to
    help identify files that can be carved from unstructured data. See the file(1)
    and magic(5) man pages for more information about magic strings and Linux. More
    information about forensic carving is described in [Chapter 3](ch03.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: File extensions are commonly used to indicate the contents of a file. For example,
    filenames ending with *.pdf*, *.docx*, or *.odt* are most likely office documents,
    whereas those ending with *.jpg*, *.png*, or *.gif* are probably images, and so
    on. Applications use these file extensions to determine how to open a particular
    file. For example, email clients use them for opening attachments, web browsers
    for downloads, file managers for file open requests, and so on. The simplicity
    of file extensions is sometimes abused to hide file content merely by changing
    the file extension. For example, malware may attempt to hide executable files,
    corporate data theft may involve attempts to hide office documents, and people
    in possession of illicit material may attempt to hide the existence of media files.
    Although this is trivial to detect with modern forensic software, it is still
    commonplace.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike in the Windows world, having multiple extensions for a single file is
    common in Linux and usually indicates several operations to a file (or group of
    files). For example, *files.tar.gz* refers to an archive (extension *.tar*) that
    has been compressed (extension *.gz*). Another example, *files.tar.gz.md5*, refers
    to a file containing the MD5 hash of the compressed archive file. When examining
    a Linux environment, digital forensic software must understand how to process
    files with multiple extensions.
  prefs: []
  type: TYPE_NORMAL
- en: '***Hidden Files***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Linux uses the Unix naming convention for hidden files. A hidden file is simply
    a normal file or directory name starting with a dot (.). Files starting with dots
    indicate to programs that they don’t need to show the file in a directory listing.
    The use of an initial dot for hiding files was somewhat accidental. An early version
    of the `ls` command was written to ignore the directory “.” and “..” files, but
    ended up ignoring any file starting with a dot. Since then, developers have used
    it to hide things like configuration files that the user normally doesn’t need
    to see.
  prefs: []
  type: TYPE_NORMAL
- en: Hidden files using a dot in their filename are not really hidden. The hiding
    mechanism is not a technical method like a kernel or filesystem flag. It is only
    a naming convention that programs and applications may use (if they want) to filter
    out files from view. Most programs, file managers in particular, provide an option
    to show hidden files. When performing analysis with forensic tools, hidden files
    appear as normal files (because they are normal files). You don’t need to take
    additional steps to “unhide” them. Attempts to hide files and directories using
    a dot in unconventional locations may indicate suspicious activity.
  prefs: []
  type: TYPE_NORMAL
- en: Another method of hiding a file is by opening it and then deleting it without
    closing. This removes the directory entry with the filename (that is, the file
    is unlinked), but the inode will stay allocated until the file is closed. This
    method of file hiding is not persistent across reboots or if the process holding
    it open dies. Filesystem forensic tools should find inodes without filenames (for
    example, The Sleuth Kit’s `ils -O` or `-p`).
  prefs: []
  type: TYPE_NORMAL
- en: Malicious code can potentially hide files. Trojaned versions of programs like
    `ls` can be patched to prevent showing certain filenames or directories. Malicious
    kernel modules or rootkits can also intercept file operations and prevent viewing
    or accessing specific files. Kernel module rootkits can also hide processes, sockets,
    and kernel modules themselves (search for Linux rootkits on GitHub or other public
    source code repositories).
  prefs: []
  type: TYPE_NORMAL
- en: Simple hiding of files can also be done using filesystem permissions. Files
    can be hidden from other users by placing them in a read-protected directory.
    Users without read access won’t be able to read the contents of the directory,
    effectively hiding the filenames from view.
  prefs: []
  type: TYPE_NORMAL
- en: Hiding files using trojaned binaries, rootkits, or filesystem permissions is
    effective only on a running system. When performing an offline postmortem forensic
    analysis, these files should appear normal and not hidden. Also, knowing which
    users had access to files and directories may be relevant to an investigation.
  prefs: []
  type: TYPE_NORMAL
- en: A section on file hiding should at least mention *steganography*. Multiple tools
    are available for hiding files using steganography, many of which can be compiled
    and run under Linux. As these tools are not specific to Linux systems, they are
    considered beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: '**Linux File Analysis**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Analyzing the contents of files found on Linux systems is generally easier than
    in more proprietary environments. File formats tend to be open and well documented.
    Many files, especially configuration files, are simple ASCII text files. Very
    few file formats are inherently proprietary to Linux.
  prefs: []
  type: TYPE_NORMAL
- en: '***Application Metadata***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In digital forensics, file metadata may refer to either the metadata stored
    in the filesystem inode or to the metadata stored inside the file contents. In
    this section, we focus on the latter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The metadata from applications found on Linux systems is generally easier to
    analyze than that found in proprietary environments. Common open file formats
    are well documented and well supported by forensic tools. Applications running
    on Linux systems (and FOSS in general) use files falling into several categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Open standards (JPEG images, for example)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proprietary but reverse-engineered by open source developers (many Microsoft
    file formats, for example)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defined by open source application developers but specific to that application
    (a good example is the GIMP XCF file format)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specific to a Linux distribution (Red Hat RPM software package files, for example)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specific to a common Linux system component (systemd’s journal format, for example)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open source and Linux-specific formats are of particular interest in Linux forensics.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting metadata from Linux-specific files may require the use of a Linux
    analysis machine for best results (even if a commercial forensic tool claims to
    support it). Often, Linux software packages will include tools for troubleshooting,
    repair, data extraction, conversion, and querying. You can use these tools (often
    simple command line utilities) to extract both metadata and content. To find ways
    of displaying file metadata using Linux tools, the best source of information
    is the tool’s own man page.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, you can also use the application itself (on a read-only copy
    of the file) to examine metadata. For example, [Figure 4-2](ch04.xhtml#ch04fig02)
    shows a GIMP dialog displaying the metadata of an XCF file.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/ch04fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: GIMP dialog displaying the metadata of an XCF file*'
  prefs: []
  type: TYPE_NORMAL
- en: Source code repositories like GitHub or GitLab often have small tools for extracting
    metadata from open formats. These tools may be written by students, hobbyists,
    professional programmers, or even companies. They may or may not provide accurate
    results, and I recommend comparing the results with other similar tools.
  prefs: []
  type: TYPE_NORMAL
- en: If all else fails, looking at the application’s source code may help. The file
    formats may be documented in header files or documentation included with the source
    software package. For example, take a look at the contents of */usr/include/*.h*,
    and you’ll find many file formats (among other things). Knowing a file format’s
    data structures allows you to write a tool or possibly use a hex editor to extract
    or decode metadata from a particular file.
  prefs: []
  type: TYPE_NORMAL
- en: '***Content Analysis***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As mentioned in the previous section, files found in Linux environments tend
    to be open and well documented. Because of this, tools are easily written to examine
    the content of files. Often, you can examine file contents with tools developed
    for data recovery, data export, or conversion to other formats, or using simple
    file readers.
  prefs: []
  type: TYPE_NORMAL
- en: If a file format is unknown, use the `file` command to try to identify the content.
    If no tools are available specifically for that file, try the `strings` command
    to extract the human-readable character strings contained in the file. See the
    file(1) and strings(1) man pages for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Another possibility for extracting content from files, in particular compound
    files with other embedded files, is to use standard forensic carving tools on
    them. Such tools may extract files or fragments of files that may be of interest.
  prefs: []
  type: TYPE_NORMAL
- en: Some files found on Linux systems are backup or archive files. Traditional (but
    still common) examples of this are *tar*, *cpio*, and *dump*. Examples of more
    recent Linux backup solutions for end users include *duplicity* and *timeshift*.
    Common Linux enterprise backup systems include Bacula and Amanda. The forensic
    analysis of backup solutions is beyond the scope of this book. However, backups
    can be an excellent evidence source, and even the backup index databases will
    contain lists of filenames and directories that were backed up in the past, often
    together with timestamps (tar incremental backups use *.snar* files, for example).
  prefs: []
  type: TYPE_NORMAL
- en: 'Extracting the content of encrypted files is always a challenge for digital
    forensic investigators. Even though the encryption format may be open and documented,
    the data will remain inaccessible unless the cryptographic keys are recovered.
    Some examples of encrypted file formats you might encounter on a Linux system
    include:'
  prefs: []
  type: TYPE_NORMAL
- en: Encrypted email using GnuPG
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Encryption built in to applications (office documents: PDF, DOC, and so on)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GnuPG encrypted files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypted ZIP files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypted file containers like Veracrypt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In most cases, native files found on Linux systems will have an identifiable
    and documented format, tools available to view metadata, and tools for viewing
    or extracting their contents. Proprietary file formats may have FOSS tools, but
    those will be the result of best-effort reverse engineering by volunteers.
  prefs: []
  type: TYPE_NORMAL
- en: '***Executable Files***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When high-level programming code (readable by humans) is compiled into machine
    code (readable by CPUs), it is stored in an *executable* file format (readable
    by operating systems). This format gives the operating system all the information
    it needs to load the code into memory, set up various things (like dynamic linking
    with other code libraries), and run the program. Linux uses the *Executable and
    Linkable Format (ELF)* files taken from Unix. ELF executable files can be identified
    by the magic string in the first four bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A number of tools can provide information about ELF files on a Linux system.
    The `file` command provides a basic summary of executable files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In forensics, there are several areas of interest when analyzing executable
    files. In the case of malware, where no source code is available, executable files
    must be reverse-engineered to understand precisely what they are doing. This process
    involves disassembling and decompiling binaries into human-readable code, a method
    known as *static analysis*. Another method, called *dynamic analysis*, involves
    running code in a sandbox with debugging and tracing tools to understand live
    behavior. In the case of traditional computer forensic investigations (non-malware),
    the focus is on metadata from the executable. Reverse engineering of executables
    is beyond the scope of this book, but this section explores metadata useful for
    investigations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some executable formats (like MS-Windows PE/COFF) have a timestamp embedded
    in the file indicating when the binary was built. The ELF format doesn’t define
    a build timestamp, but Linux executables compiled with GCC contain a unique identifier
    called the *build ID* (optional, but default). The build ID is an SHA-1 hash of
    portions of code in the executable, and most ELF analysis tools can extract it.
    The `file` command (shown in the preceding example) displays the `build-id` (`BuildID[sha1]=`),
    and the `readelf` command can display it, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This ID is unique to the version of compiled code and to the build environment,
    but when analyzing the build ID, note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The build ID will be the same whether the binary is stripped or not (symbol
    information is removed).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s not always unique across machines. Two identical installations of Linux
    compiling the same version of code may generate the same build ID.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This string can be removed or maliciously modified and there are no validity
    checks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executables compiled at a central location and then copied to multiple machines
    will all have the same build ID.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This build ID may be useful for linking executable files found on multiple machines
    in some cases, but in other cases, it may have little or no value.
  prefs: []
  type: TYPE_NORMAL
- en: Other tools (such as `dumpelf` from the `pax-utils` package, `objdump`, and
    `readelf`) provide information about the internal structure of ELF executables,
    including the different headers and sections of the file. The `objdump` `-d` command
    also provides a disassembled output of the machine code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing which additional files are dynamically linked into an executable at
    runtime is also interesting to investigators. You normally can check this with
    the `ldd` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you are analyzing a suspicious file (potential malware), using
    `ldd` is not recommended. The man page explicitly states “you should never employ
    `ldd` on an untrusted executable, since this may result in the execution of arbitrary
    code.” A safe alternative to finding the shared objects required is the `objdump`
    tool, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The examples shown here are from popular 64-bit x86 (Intel/AMD) architectures,
    but the Linux kernel supports dozens of different CPU architectures. Other CPUs
    in use at the very high end of computing (mainframes and supercomputers) and the
    very low end (Raspberry Pi and IoT embedded systems) can be very different. Here’s
    an example `file` output from a Raspberry Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A Linux architecture can be 32 or 64 bits, big or little endian, and support
    a variety of CPU instruction sets (x86, ARM, PPC, Sparc, and so on). Knowing the
    architecture is important when using forensic tools. Unless tools automatically
    detect these architectural characteristics, they may need to be made aware of
    them to produce sensible and accurate results.
  prefs: []
  type: TYPE_NORMAL
- en: '**Crash and Core Dumps**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Computers crash. Software crashes. Normally these events are upsetting, especially
    when data is lost. But for the forensic examiner, these events can be a good thing,
    as volatile memory data might be preserved during a crash. Crashed kernels, crashed
    processes, and other application crash data saved to the local disk have potential
    forensic value.
  prefs: []
  type: TYPE_NORMAL
- en: When computers or programs crash, they may attempt to save crash data on the
    local disk for programmers to analyze for debugging purposes. In some cases, those
    files are even uploaded to the developer’s servers for analysis. Some information
    saved in these crash data files may contain forensic artifacts that are useful
    in an investigation.
  prefs: []
  type: TYPE_NORMAL
- en: A kernel crash, process crash, and higher-level application and distro-specific
    crashes use different handling mechanisms. In each of these cases, data relevant
    to a forensic investigation may be saved.
  prefs: []
  type: TYPE_NORMAL
- en: Forensic analysis of memory dumps may either refer to recovering traces of content
    information from memory dump files, or to understanding code execution and reasons
    for the dump. Understanding code execution is often used in the analysis of malware
    and technical exploitation (stack and buffer overflows, and so on). Analyzing
    such attacks involves static and dynamic code analysis, reverse engineering, decompilation,
    and disassembly. This analysis requires in-depth knowledge of C, assembly, and
    Linux memory management. All of these concepts are beyond the intended scope of
    this book (in fact, this topic could easily fill an entire book on its own). Here
    we’ll explore a superficial analysis of memory dumps and the extraction of basic
    string information.
  prefs: []
  type: TYPE_NORMAL
- en: '***Process Core Dumps***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a Linux program is executed, the process resides in memory and runs until
    it completes, terminates from a signal (kill), or crashes. When a process crashes,
    the system can be configured to save a memory image or core file to disk for debugging
    purposes. This is called a *core dump* or *dumping core*. Let’s look at where
    to find core files and how to examine them in a forensic context.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, the saved core from a crashed process is written to a file called
    core or *core.*PID, where *PID* is the numeric process ID. Later kernels used
    a template to create the *core.** filename. These core files are saved in the
    same directory (if writable) where they crashed, and are owned by the user ID
    of the crashed process. You can find a system’s core files by searching the filesystem
    for all files named *core*, *core.*PID, or *core.** if using a template. See the
    core(5) man page for more information about core files and templates.
  prefs: []
  type: TYPE_NORMAL
- en: If managed by systemd, which may require installation of a separate `systemd-coredump`
    package, core files are saved to a single directory */var/lib/ systemd/coredump/*.
    Here the core dump is sent to the `systemd-coredump` program, which logs it in
    the journal and saves a core file (see the systemd-coredump(8) man page). You
    can use the `coredumpctl` command to list systemd core dumps found in a suspect
    machine’s journal. The coredumpctl(1) and coredump.conf(5) man pages have more
    information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows one line of a core dump log from an offline journal
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here we see a list of available (`present` ➋ ) core dumps, including the time
    and information about the crashed program (`mousepad`) used in this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'By specifying the PID from a particular crash in this list (`157004` ➊ ), we
    can view more information and a backtrace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `mousepad` application ➊ (a graphical text editor) dumped
    core, and `systemd-coredump` logged the output and saved the core file ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'The core file was saved to the */var/lib/systemd/coredump/* directory and can
    be copied to a forensic analysis machine. The filename starts with `core.`, followed
    by the name of the program (`mousepad`), the numeric user ID (`1000`), the boot
    ID, the PID, a timestamp, and, lastly, an extension with the compression used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Depending on the distro or configuration, the compression may be *zst*, *lz4*,
    or some other systemd-supported algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can uncompress the core file’s contents with tools like `zstdcat` or `lz4cat`.
    Here is an example of a shell pipeline where a core file is uncompressed and strings
    are extracted to a pager for manual analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The output from this `zstdcat` and strings example contains all the human-readable
    strings from the core dump, including the environment variables and even the unsaved
    text that was typed into the editor at the moment it crashed. Core dumps from
    programs will contain whatever data they had in memory at the time of the crash.
  prefs: []
  type: TYPE_NORMAL
- en: Tools such as `bulk_extractor` can carve the core file for the usual search
    strings and also create a wordlist of possible passwords insecurely stored in
    memory. You can use this wordlist with password recovery programs to attempt decryption
    of any encrypted files found. You can also perform forensic carving for files
    or file fragments (images, HTML, and so on) on the uncompressed core dump.
  prefs: []
  type: TYPE_NORMAL
- en: You could also use a debugger like `gdb` to further analyze the executable code.
  prefs: []
  type: TYPE_NORMAL
- en: '***Application and Distro-Specific Crash Data***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Crash information helps developers debug and fix problems in their software.
    Crash reporting systems (which can be opt-in or opt-out) can monitor for local
    crashes and then send the data to developer servers for analysis.
  prefs: []
  type: TYPE_NORMAL
- en: A Linux distribution can have its own system crash reporting. Desktop environments
    can have crash reporting specific to their library toolkits, and applications
    can implement their own crash reporting. Let’s look at some examples.
  prefs: []
  type: TYPE_NORMAL
- en: Fedora and Red Hat distros use `abrt` (automated bug reporting tool). The `abrtd`
    daemon watches for crash events and takes appropriate action, which may include
    informing the user or uploading to a server managed by the distro maintainers.
    The `abrt` system uses plug-ins that can monitor multiple types of crashes, such
    as process core dumps, Python, Java, Xorg, and others. During a forensic examination,
    you can check several directories for the existence of crash data handled by `abrt`,
    such as */var/spool/abrt/*, */var/spool/abrt-upload/*, and */var/tmp/abrt/*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output differs depending on the crash information’s origin. The following
    is an example of core dump crash data stored in */var/spool/abrt/*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Each of these files contain some information about the crashed process, including
    the reason for the crash, open files, environment variables, and other data. The
    `abrt` system is a competitor of `systemd-coredump` as a core-dump handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity from `abrt` is also logged in the systemd journal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You can find the abrt system’s configuration, actions, and plug-ins in the */etc/abrt/**
    directory. For more details, see the abrt(1) and abrtd(8) man pages. The abrt
    system has several man pages describing various parts of the system (from a Fedora/Red
    Hat Linux shell, enter apropos abrt for a list). The authoritative online documentation
    is available at *[https://abrt.readthedocs.io/en/latest/](https://abrt.readthedocs.io/en/latest/)*.
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu-based systems have a daemon called Whoopsie (which sends data to a server
    called Daisy) and a handling system called `apport`. The `apport` program can
    manage crash data from core dumps, Python, package managers, and more (for more
    information, see *[https://wiki.ubuntu.com/Apport/](https://wiki.ubuntu.com/Apport/)*).
  prefs: []
  type: TYPE_NORMAL
- en: When a process crashes, the core is sent to the `apport` program, which generates
    a report and saves it in */var/crash/*. The `whoopsie` daemon watches this directory
    for new crash data.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Ubuntu, you can find crash evidence in the journal and in a dedicated log,
    */var/log/apport.log*, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The crash report is a normal text file located in the */var/crash/* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This report contains various information about the crash, including base64-encoded
    core dump data. A unique identifier is stored in the */var/ lib/whoopsie/whoopsie-id*
    file. This is an SHA-512 hash of the BIOS DMI UUID (found with `dmidecode`). This
    string is sent to Ubuntu (Canonical) servers to distinguish between individual
    machines in their logs and statistics.
  prefs: []
  type: TYPE_NORMAL
- en: Desktop environments may handle crashed applications on their own. For example,
    you can invoke the KDE crash handler through libraries and
  prefs: []
  type: TYPE_NORMAL
- en: save crash information to files with the *.kcrash* extension. This can also
    generate a crash pop-up from `drkonqi` for the desktop user (Dr. Konqi is similar
    to Dr. Watson on Windows). See *[https://api.kde.org/frameworks/kcrash/html/namespaceKCrash.html](https://api.kde.org/frameworks/kcrash/html/namespaceKCrash.html)*
    and *[https://github.com/KDE/drkonqi/](https://github.com/KDE/drkonqi/)* for more
    information on KCrash and `drkonqi`. GNOME has similar functionality with `bug-buddy`.
    The `abrt` crash system can also support GNOME applications.
  prefs: []
  type: TYPE_NORMAL
- en: Distributions may implement their own crash and bug reporting mechanisms. For
    example, `mintreport` creates report files in */tmp/mintreport* about detected
    problems. These files contain information about the system (*/tmp/mintreport/inxi*)
    and a set of report subdirectories (*/tmp/mintreport/ reports/**). These directories
    each contain different reports in the form of Python scripts (**/MintReportInfo.py*).
    See the inxi(1) man page for more information on the `inxi` information gathering
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: Crash reports are not only managed by the system or desktop environments. Applications
    can generate them, as well. This information is typically saved in the user’s
    home directory by user-run application processes. For example, Firefox will save
    crash data in the *~/.mozilla/firefox/Crash Reports/* subdirectory. This directory
    contains information about the reporting configuration (*crashreporter.ini*),
    a file with the time of last crash (*LastCrash*), and pending reports. The reports
    contain information saved by the application (Firefox, in this example). Other
    applications may manage their own crash logs and save data in the XDG base directories
    (*.cache/*, *.local/share/*, and *.config/*) in the user’s home.
  prefs: []
  type: TYPE_NORMAL
- en: '***Kernel Crashes***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As we saw in the previous section, when a process crashes, only that process
    is affected. But when the Linux kernel (including kernel modules) crashes, the
    entire system is affected. A kernel crash can manifest itself as a panic or an
    oops. A *panic* is a condition in which the kernel is unable to continue and will
    halt or reboot the system. An *oops* will log error information to the ring buffer
    (which is captured and possibly saved by the journal or syslog), and the system
    will continue running. The system’s stability after an oops depends on the error,
    and a reboot may still be a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'A kernel may crash in the following situations:'
  prefs: []
  type: TYPE_NORMAL
- en: Bugs in the kernel code (including drivers or modules)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Severe resource exhaustion (out of memory)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physical hardware problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Malicious activity affecting or targeting the kernel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find a kernel oops in the systemd journal together with an `Oops` number
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of a kernel oops is similar to a kernel warning message. The following
    is an example of a kernel warning that was observed in the systemd journal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This shows a problem with the `amdgpu` kernel module ➊, but not one severe enough
    to cause a panic. The kernel logged information about the warning to the journal,
    including the CPU ➋, information about the kernel ➌ and hardware ➍, and a backtrace
    ➎. Aside from the log entry, this kernel warning didn’t write any crash dump data
    on the disk. A kernel setting `kernel` `.panic_on_oops` can tell the kernel to
    panic (and possibly reboot) whenever an oops occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of kernel panic output to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the panic was purposely generated (`echo c > /proc/sysrq` `-trigger`)
    and caused the system to halt immediately. The logs have no evidence of the crash
    because the kernel crashed before it could write anything.
  prefs: []
  type: TYPE_NORMAL
- en: When performing a postmortem forensic examination of a Linux system, we are
    looking for evidence of a crash and any potential data saved from the crash. This
    data may give insight into the reason for crashing (stack trace, code that can
    be analyzed, and so on) and memory images can be forensically carved for file
    fragments and strings.
  prefs: []
  type: TYPE_NORMAL
- en: A running kernel resides in volatile memory. When the kernel panics and halts
    or reboots, that memory is lost. For debugging purposes, the kernel developers
    created methods to save the contents of memory in the event of a kernel panic.
    We can use these methods as a form of forensic readiness, and configure them to
    preserve kernel memory as digital evidence.
  prefs: []
  type: TYPE_NORMAL
- en: Saving data from a crashed kernel is a chicken-or-egg problem. You need a functioning
    kernel to save the data, but a crashed kernel is not necessarily functional. Two
    software methods, `kdump` and `pstore`, attempt to solve this problem and preserve
    information after a kernel crash. Some hardware devices also use DMA to dump memory
    via PCI or Thunderbolt, but these are not Linux specific and thus not covered
    here.
  prefs: []
  type: TYPE_NORMAL
- en: The `pstore` method (if enabled) saves trace and `dmesg` information from a
    crash for retrieval after a reboot. Several `pstore` “backends” can save information
    persistently after a crash. Storage on the mainboard firmware is possible using
    EFI variables or ACPI error serialization. Data can also be stored in a reserved
    area of RAM that remains untouched after a reboot, and local block devices (partition
    or disk) can be used. If storage size is limited, only things like the backtrace
    of a crash or the tail of `dmesg` are saved. On a running system, you can find
    this information in */sys/fs/pstore/* (for EFI, this is a decompressed representation
    of the corresponding variables in */sys/firmware/efi/efivars/*). Recent systemd
    versions (as of version 243) include the `systemd-pstore` service that copies
    `pstore` data to disk and clears the firmware storage so that it can be used again.
    It is stored in */var/lib/ systemd/pstore/* and should be checked during an examination.
    If the mainboard of the suspect machine is available, you can read the EFI variables
    and data separately.
  prefs: []
  type: TYPE_NORMAL
- en: The `kdump` method employs a second kernel, loaded at boot time, that attempts
    to recover the memory of the first kernel when a crash occurs. Execution is handed
    over to the functional second kernel using `kexec` (part of the `kexec-tools`
    software package), which boots with a separate initrd capable of saving a full
    memory image to a predefined location. [Figure 4-3](ch04.xhtml#ch04fig03) is a
    visual description of this process.^([9](footnotes.xhtml#ch04foot_09))
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/ch04fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Saving a kernel image with* kdump'
  prefs: []
  type: TYPE_NORMAL
- en: 'A common place to save kernel memory images and other information from `kdump`
    is */var/crash/*. For example, a `kdump` crash directory from an Ubuntu system
    creates a timestamp subdirectory and looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the */var/crash/202011150957/* directory contains the file
    `dmesg` output (text file) and the compressed kernel dump file, all with a timestamp
    as part of the filename. Other distros may use *vmcore* as a filename.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kernel dump images in */var/crash/* will likely be compressed. If you want
    to run carving tools, strings, or a hex editor against an image, it must be uncompressed
    first. You can copy the dump file to an analysis system and use the `makedumpfile`
    command to uncompress it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, the resulting file is roughly the same size as the physical RAM of the
    system under examination (assuming that all memory pages were included at the
    time of dump).
  prefs: []
  type: TYPE_NORMAL
- en: The `kdump` method was intended for debugging and doesn’t necessarily save the
    entire memory image. Developers are primarily interested in the kernel code and
    stack trace information, and the `makedumpfile` command may be configured to exclude
    certain memory pages. However, forensic examiners are interested in completeness,
    which includes the data and contents of all processes, even unused memory. When
    setting up `kdump` for evidence purposes (that is, forensic readiness), `makedumpfile`
    can be configured to save an entire memory image (using the `makedumpfile` flag
    `-d 0`). See the makedumpfile(8) and makedumpfile.conf(5) man pages for instructions
    on changing how kernel dump files are made.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use forensic carving tools (for strings or file fragments), a debugger
    like `gdb`, or a memory forensics tool like `Volatility` to analyze the uncompressed
    dump file. Here are some examples of information that you can retrieve from carving:'
  prefs: []
  type: TYPE_NORMAL
- en: Files and file fragments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EXIF data from media files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Credit card numbers and track 2 information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Domain names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Email addresses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IP addresses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ethernet MAC addresses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: URLs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Telephone numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom specified regex strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples of information that debuggers and memory forensic tools
    can extract:'
  prefs: []
  type: TYPE_NORMAL
- en: Process list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ARP table (MAC addresses and associated IPs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network connections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loaded kernel modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory-based Bash history
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suspicious processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cached TrueCrypt passphrase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A full memory analysis using `gdb` or `Volatility` is beyond the scope of this
    book. However, enough information has been provided here to help you identify
    full kernel memory dumps if they reside on the disk. A free book titled *Linux
    Kernel Crash Book* (*[https://www.dedoimedo.com/computers/www.dedoimedo.com-crash-book.pdf](https://www.dedoimedo.com/computers/www.dedoimedo.com-crash-book.pdf)*)
    describes kernel crashing in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter covers the origin and current directory layout of a typical Linux
    system, highlighting the areas of interest to forensic investigators. It also
    describes the challenges of creating hashsets and the NSRL for free and open source
    software. After reading this chapter, you should be able to identify Linux file
    types and understand the difference between POSIX file types in the filesystem
    and application content file types. In addition, this chapter provides analysis
    of file metadata and content, including hidden files, executables, and files containing
    memory dumps. You now should have the foundation to explore userspace artifacts
    like logs, software installation, and other user-generated activity.
  prefs: []
  type: TYPE_NORMAL
