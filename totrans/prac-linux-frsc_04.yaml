- en: '**4**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**4**'
- en: '**DIRECTORY LAYOUT AND FORENSIC ANALYSIS OF LINUX FILES**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**Linux 文件的目录布局与法医分析**'
- en: '![Image](Images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common01.jpg)'
- en: The previous chapter described forensic analysis of storage and filesystems,
    the low-level building blocks that create the illusion of a hierarchical file
    tree. This chapter focuses on the layout of that file tree, takes a closer look
    at individual files, and identifies specific areas of interest to digital forensic
    examiners.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章描述了存储和文件系统的法医分析，这些是创建层次文件树幻象的低级构建模块。本章重点讨论该文件树的布局，详细查看各个文件，并识别数字法医检查员感兴趣的特定区域。
- en: '**Linux Directory Layout**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Linux 目录布局**'
- en: When performing a forensic examination of a Linux system, understanding the
    organization of files and directories on a drive helps the investigator to locate
    areas and artifacts of interest quickly and ignore areas that are less likely
    to contain evidence.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在对 Linux 系统进行法医检查时，了解磁盘上文件和目录的组织结构可以帮助调查员快速定位感兴趣的区域和证据，忽略那些不太可能包含证据的区域。
- en: Linux adopted its tree-like structure from traditional Unix, which starts with
    the *root* directory, represented by a forward slash (/). Additional filesystems
    on local storage or remote network servers can be attached (mounted) to any subdirectory
    in the tree.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 采用了传统 Unix 的树状结构，从 *根* 目录开始，根目录由正斜杠（/）表示。额外的文件系统可以通过挂载（mount）附加到树中任何子目录下，这些文件系统可以位于本地存储或远程网络服务器上。
- en: Original Unix systems organized the filesystem hierarchy into directories to
    separate executable programs, shared libraries, configuration files, devices,
    documentation, user directories, and so on.^([1](footnotes.xhtml#ch04foot_01))
    Linux systems today still use most of the names those directories were given.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的 Unix 系统将文件系统层次结构组织为不同的目录，用以区分可执行程序、共享库、配置文件、设备、文档、用户目录等内容。^([1](footnotes.xhtml#ch04foot_01))
    如今，Linux 系统仍然使用那些目录的原始名称。
- en: '***Filesystem Hierarchy***'
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***文件系统层次结构***'
- en: The top of this hierarchical tree is called the root directory, or */* (not
    to be confused with the root user’s home directory, */root/*). All subdirectories,
    mounted storage media, mounted network shares, or other mounted virtual filesystems,
    are attached to this “upside down” tree below the root, as illustrated in [Figure
    4-1](ch04.xhtml#ch04fig01). This process is called *mounting* a filesystem, and
    the directory (typically empty) where it is mounted is called the *mount point*.
    The PC DOS world differs in that attached filesystems (local or remote) are represented
    as individual drive letters (A:, B:,. . ., Z:).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这个层次树的顶部称为根目录，或者 */*（不要与根用户的主目录 */root/* 混淆）。所有的子目录、挂载的存储媒体、挂载的网络共享或其他挂载的虚拟文件系统都被附加到这个“倒立”的树下，如
    [图 4-1](ch04.xhtml#ch04fig01) 所示。这个过程被称为 *挂载* 文件系统，而文件系统挂载的目录（通常为空）称为 *挂载点*。PC
    DOS 世界的区别在于，附加的文件系统（无论是本地的还是远程的）都是通过独立的驱动器字母（A:、B:、...、Z:）来表示的。
- en: '![Image](Images/ch04fig01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/ch04fig01.jpg)'
- en: '*Figure 4-1: Filesystem tree structure*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-1：文件系统树结构*'
- en: The POSIX and Open Group UNIX standards didn’t define a detailed directory layout^([2](footnotes.xhtml#ch04foot_02))
    for Unix vendors to follow. Unix systems and Linux distributions document their
    directory hierarchy in the hier(7) or hier(5) man pages. The Linux community developed
    the *Filesystem Hierarchy Standard (FHS)*^([3](footnotes.xhtml#ch04foot_03)) to
    encourage a common layout across distributions. Modern Linux systems also have
    a file-hierarchy(7) man page with additional information related to systemd. The
    rest of this section describes each of the top-level directories commonly used
    in Linux and their relevance to forensics.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX 和 Open Group UNIX 标准并未为 Unix 厂商定义一个详细的目录布局^([2](footnotes.xhtml#ch04foot_02))。Unix
    系统和 Linux 发行版在 hier(7) 或 hier(5) 手册页中记录了它们的目录层次结构。Linux 社区开发了 *文件系统层次标准（FHS）*^([3](footnotes.xhtml#ch04foot_03))，以鼓励发行版之间采用统一的布局。现代的
    Linux 系统也有一个 file-hierarchy(7) 手册页，其中包含与 systemd 相关的额外信息。本节其余部分将描述 Linux 中常用的各个顶级目录及其与法医分析的相关性。
- en: '**/boot/ and efi/**'
  id: totrans-13
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**/boot/ 和 efi/**'
- en: The */boot/*and *efi/* directories^([4](footnotes.xhtml#ch04foot_04)) contain
    files for booting the system. Boot configuration (kernel parameters and so on)
    can be found here. Current and previous kernels can be found here together with
    the initial ramfs, which can be examined. On EFI systems, the EFI partition (a
    FAT filesystem) is often mounted inside the */boot/* directory. Non-standard and
    non-default files that have been added to the */boot/*and *efi/* directories should
    be examined. [Chapter 6](ch06.xhtml) on forensic analysis of Linux system initialization
    describes these directories in more detail.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*/boot/* 和 *efi/* 目录^([4](footnotes.xhtml#ch04foot_04)) 包含用于启动系统的文件。启动配置（内核参数等）可以在这里找到。当前和之前的内核文件也可以在此找到，以及初始的
    ramfs，它们可以被检查。在 EFI 系统中，EFI 分区（一个 FAT 文件系统）通常挂载在 */boot/* 目录内。应当检查任何非标准或非默认的文件，这些文件可能已经被添加到
    */boot/* 和 *efi/* 目录中。[第6章](ch06.xhtml)关于 Linux 系统初始化的取证分析会详细描述这些目录。'
- en: '**/etc/**'
  id: totrans-15
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**/etc**'
- en: The */etc/* directory is the traditional location for system-wide configuration
    files and other data. The majority of these files are easily examined plaintext
    files. Configuration files may have a corresponding directory with a *.d* extension
    for drop-in files that are included as part of the configuration.^([5](footnotes.xhtml#ch04foot_05))
    The creation and modification timestamps of these files may be interesting in
    an investigation, as they indicate when a particular configuration file was added
    or changed. In addition, user-specific configuration files in a user’s */home/*
    directory may override system-wide */etc/* files. Deviations from the distro or
    software defaults are often found here and may be of forensic interest. Copies
    of the distro default files are sometimes found in */usr/share/factory/etc/**
    and can be compared with those in the */etc/* directory. When some distros perform
    upgrades to config files in */etc/*, they may create a backup copy of the old
    files or add the new file with an extension (Arch’s Pacman uses the extension
    **.pacnew*). Various files in */etc/* are explained in more detail throughout
    the book.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*/etc/* 目录是系统范围配置文件和其他数据的传统位置。大多数这些文件都是可以直接检查的纯文本文件。配置文件可能有一个对应的目录，使用 *.d*
    扩展名，用于存放作为配置一部分的附加文件^([5](footnotes.xhtml#ch04foot_05))。这些文件的创建和修改时间戳可能在调查中非常有用，因为它们显示了特定配置文件何时被添加或更改。此外，用户在
    */home/* 目录下的用户特定配置文件可能会覆盖系统范围的 */etc/* 文件。此处常常可以发现与发行版或软件默认设置不同的情况，这些偏差可能对取证有价值。发行版的默认文件副本有时会存放在
    */usr/share/factory/etc/** 目录中，可以与 */etc/* 目录中的文件进行比较。当一些发行版对 */etc/* 中的配置文件进行升级时，可能会创建旧文件的备份副本，或者将新文件添加带有扩展名（例如
    Arch 的 Pacman 使用 **.pacnew*）。本书中会更详细地解释 */etc/* 目录中的各种文件。'
- en: '**/srv/**'
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**/srv**'
- en: The */srv/* directory is available for use by server application content, such
    as FTP or HTTP files. This is a good directory to examine in case it contains
    files that were published or otherwise accessible over a network. This directory
    is unused on many distributions and may be empty.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*/srv/* 目录用于服务器应用程序内容，例如 FTP 或 HTTP 文件。这个目录在检查时可以查看是否包含已发布或通过网络可访问的文件。许多发行版没有使用此目录，因此它可能是空的。'
- en: '**/tmp/**'
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**/tmp/**'
- en: The */tmp/* directory is for storing temporary files. These files may be deleted
    periodically or during boot, depending on the distro or system’s configuration.
    In some Linux distros, the contents of */tmp/* may reside in RAM using the tmpfs
    virtual memory filesystem. On a forensic image, systems using tmpfs to mount */tmp/*
    will likely be empty. See the systemd-tmpfiles(8) man page for more information
    about how a system manages temporary files, and see the tmpfs(5) man page for
    more details regarding virtual memory filesystems.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*/tmp/* 目录用于存储临时文件。根据发行版或系统配置，这些文件可能会定期删除或在启动时删除。在某些 Linux 发行版中，*/tmp/* 的内容可能会存储在
    RAM 中，使用 tmpfs 虚拟内存文件系统。在取证镜像中，使用 tmpfs 挂载 */tmp/* 的系统可能会为空。有关系统如何管理临时文件的更多信息，请参见
    systemd-tmpfiles(8) 手册页，关于虚拟内存文件系统的更多细节，请参见 tmpfs(5) 手册页。'
- en: '**/run/**'
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**/run/**'
- en: The */run/* directory is a tmpfs-mounted directory residing in RAM and will
    likely be empty on a forensic image. On a running system, this directory contains
    runtime information like PID and lock files, systemd runtime configuration, and
    more. There may be references to files and directories in */run/* found in logs
    or configuration files.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*/run/* 目录是一个 tmpfs 挂载的目录，位于 RAM 中，在取证镜像中通常是空的。在运行中的系统中，这个目录包含运行时信息，如 PID 文件、锁文件、systemd
    运行时配置等。可能会在日志或配置文件中发现对 */run/* 目录中文件和目录的引用。'
- en: '**/home/ and /root/**'
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**/home/ 和 /root**'
- en: The */home/* directory is the default location for user home directories. A
    user’s home directory contains files the user created or downloaded, including
    configuration, cache, data, documents, media, desktop contents, and other files
    the user owns. The */etc/skel/*directory (which might only contain hidden “.”
    files) contains the default contents of a newly created */home/** directory. The
    root user’s home directory is typically */root/* of the root filesystem. This
    is intentional so that root can log in even when */home/* is not mounted. These
    home directories are of significant interest to forensic investigators because
    they provide information about a system’s human users. If */home/* is empty on
    a forensic image, it’s likely the user’s home directories are mounted from another
    filesystem or over a network. The creation (birth) timestamp of a user’s home
    directory may indicate when the user account was first added. [Chapter 10](ch10.xhtml)
    covers the */home/* directory contents in detail.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*/home/* 目录是用户主目录的默认位置。用户的主目录包含该用户创建或下载的文件，包括配置文件、缓存、数据、文档、媒体、桌面内容以及其他该用户拥有的文件。*/etc/skel/*
    目录（可能仅包含隐藏的“.”文件）包含新创建的 */home/* 目录的默认内容。root 用户的主目录通常是根文件系统中的 */root/*。这是故意这样设计的，以便即使
    */home/* 没有挂载，root 仍然可以登录。这些主目录对于法医调查员来说非常重要，因为它们提供了关于系统人类用户的信息。如果法医镜像中的 */home/*
    目录为空，可能意味着用户的主目录挂载自另一个文件系统或通过网络挂载。用户主目录的创建（出生）时间戳可能指示用户帐户首次添加的时间。[第10章](ch10.xhtml)详细介绍了
    */home/* 目录的内容。'
- en: '**/bin/, /sbin/, /usr/bin/, and /usr/sbin/**'
  id: totrans-25
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**/bin/, /sbin/, /usr/bin/, 和 /usr/sbin/**'
- en: The standard locations for executable programs are */bin/*, */sbin/*, */usr/bin/*,
    and */usr/sbin/*. These directories originally were intended to separate groups
    of programs for users, administrators, the boot process, or for separately mounted
    filesystems. Today, */bin/* and */sbin/* are often symlinked to their corresponding
    directory in */usr/*, and in some cases, */bin/*, */sbin/*, and */usr/ sbin/*
    are symlinked to a single */usr/bin/* directory containing all programs. Be careful
    examining symlinked directories on a suspect drive mounted on your own Linux analysis
    machine. The symlinks might be pointing to your own directories and not the suspect
    drive.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行程序的标准位置是 */bin/*、*/sbin/*、*/usr/bin/* 和 */usr/sbin/*。这些目录最初是为了区分不同组的程序：供用户、管理员、启动过程或单独挂载的文件系统使用。今天，*/bin/*
    和 */sbin/* 通常会符号链接到 */usr/* 中相应的目录，有时 */bin/*、*/sbin/* 和 */usr/sbin/* 甚至会符号链接到一个包含所有程序的单一
    */usr/bin/* 目录。在检查挂载到你自己 Linux 分析机上的可疑驱动器中的符号链接目录时要小心，这些符号链接可能指向你自己的目录，而非可疑驱动器。
- en: '**/lib/ and /usr/lib/**'
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**/lib/ 和 /usr/lib/**'
- en: The */lib/* directory is generally symlinked to */usr/lib/* on most Linux systems
    today. This includes shared library code (also for multiple platforms), kernel
    modules, support for programming environments (header files), and more. The */lib/*
    directory also contains the default configuration files for many software packages.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*/lib/* 目录在今天的大多数 Linux 系统中通常是符号链接到 */usr/lib/*。该目录包含共享库代码（也适用于多个平台）、内核模块、编程环境的支持（头文件）等。*/lib/*
    目录还包含许多软件包的默认配置文件。'
- en: '**/usr/**'
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**/usr/**'
- en: The */usr/* directory contains the bulk of the system’s static read-only data.
    This includes binaries, libraries, documentation, and more. Most Linux systems
    will symlink */bin/*, */sbin/*, and */lib/* to their equivalents in the */usr/*
    subdirectory. Files located here that are not part of any installed package may
    be of forensic interest because they were added outside the normal software installation
    process. These might be manually installed files by a user with root access, or
    unauthorized files placed by a malicious actor.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*/usr/* 目录包含系统大部分静态的只读数据。这包括二进制文件、库、文档等。大多数 Linux 系统会将 */bin/*、*/sbin/* 和 */lib/*
    符号链接到 */usr/* 子目录中的相应目录。此处的文件，如果不是任何已安装包的一部分，可能具有法医调查意义，因为它们是在正常软件安装过程中之外添加的。这些文件可能是具有
    root 权限的用户手动安装的文件，或者是恶意行为者放置的未授权文件。'
- en: '**/var/**'
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**/var/**'
- en: The */var/* directory contains system data that is changing (variable) and usually
    persistent across reboots. The subdirectories below */var/* are especially interesting
    from a forensics perspective because they contain logs, cache, historical data,
    persistent temporary files, the mail and printing subsystems, and much more. A
    significant portion of this book deals with files and directories in the */var/*
    directory.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*/var/* 目录包含变化中的系统数据（可变的），并且通常在重启后保持持久性。*/var/* 下面的子目录从取证的角度来看尤其有趣，因为它们包含日志、缓存、历史数据、持久化的临时文件、邮件和打印子系统等内容。本书的一个重要部分涉及
    */var/* 目录中的文件和目录。'
- en: '**/dev/, /sys/, and /proc/**'
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**/dev/、/sys/ 和 /proc/**'
- en: Linux has several other tmpfs and pseudo-filesystems that appear to contain
    files when the system is running, which include */dev/*, */sys/*, and */proc/*.
    These directories provide representations of devices or kernel data structures
    but the contents don’t actually exist on a normal filesystem. When examining a
    forensic image, these directories will likely be empty. See the procfs(5) and
    sysfs(5) man pages for more details.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 还有几个其他的 tmpfs 和伪文件系统，这些文件系统在系统运行时看起来包含文件，包括 */dev/*、*/sys/* 和 */proc/*。这些目录提供设备或内核数据结构的表示，但内容实际上并不存在于普通文件系统中。在检查取证镜像时，这些目录可能为空。有关更多详细信息，请参见
    procfs(5) 和 sysfs(5) 手册页。
- en: '**/media/**'
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**/media/**'
- en: The */media/* directory is intended to hold dynamically created mount points
    for mounting external removable storage, such as CDROMs or USB drives. When examining
    a forensic image, this directory will likely be empty. References to */media/*
    in logs, filesystem metadata, or other persistent data may provide information
    about user attached (mounted) external storage devices.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*/media/* 目录用于存放动态创建的挂载点，用于挂载外部可移动存储设备，如 CD-ROM 或 USB 驱动器。在检查取证镜像时，这个目录可能为空。日志、文件系统元数据或其他持久数据中的
    */media/* 引用可能提供关于用户附加（挂载）外部存储设备的信息。'
- en: '**/opt/**'
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**/opt/**'
- en: The */opt/* directory contains add-on packages, which typically are grouped
    by vendor name or package name. These packages may create a self-contained directory
    tree to organize their own files (for example, *bin/*, *etc/*, and other common
    subdirectories).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*/opt/* 目录包含附加包，这些包通常按供应商名称或包名称分组。这些包可能会创建一个自包含的目录树来组织它们自己的文件（例如，*bin/*、*etc/*
    和其他常见子目录）。'
- en: '**/lost+found/**'
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**/lost+found/**'
- en: A */lost+found/* directory may exist on the root of every filesystem. If a filesystem
    repair is run (using the `fsck` command) and a file is found without a parent
    directory, that file (sometimes called an *orphan*) is placed in the */lost+found/*
    directory where it can be recovered. Such files don’t have their original names
    because the directory that contained the filename is unknown or missing.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件系统的根目录下可能会存在一个 */lost+found/* 目录。如果运行文件系统修复（使用 `fsck` 命令），并且发现一个没有父目录的文件，那么该文件（有时称为
    *孤儿文件*）将被放入 */lost+found/* 目录中，以便进行恢复。这些文件没有原始名称，因为包含文件名的目录未知或丢失。
- en: '**./ and ../**'
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**./ 和 ../**'
- en: Two hidden subdirectories (./ and ../) are found in every directory. The single
    dot (.) represents the current directory, and the double dot (..) represents the
    parent directory. At the top of the tree, these two files also exist, and both
    represent the root (/) directory (and have the same inode number). From a low-level
    filesystem perspective, these dot files are needed to link a directory to its
    parent, creating the illusion of a hierarchical tree.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 每个目录中都有两个隐藏的子目录（./ 和 ../）。单个点（.）表示当前目录，双点（..）表示父目录。在树的顶部，这两个文件也存在，并且都表示根目录（/）（并且具有相同的inode编号）。从低级文件系统的角度来看，这些点文件用于将目录与其父目录链接，创建出层级树的假象。
- en: '***User Home Directory***'
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***用户主目录***'
- en: A forensic investigation typically involves analysis of human user activity
    (where the user could be either a victim or a suspect). All users on a Linux system
    have a home directory where they have permission to save files and documents,
    customize their environment, store persistent and cached data, and retain historical
    data (browser cookies, shell history, or email, for example). The user’s home
    directory contains significant amounts of potential evidence investigators can
    use to reconstruct past events and activity. The location of a user’s home directory
    is defined in the */etc/passwd* file and typically defaults to a subdirectory
    in */home/* with their username (for example, */home/sam/*). A user’s home directory
    can also be abbreviated with a tilde (*~/*) for use on the command line or in
    documentation.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 法医调查通常涉及对人类用户活动的分析（其中用户可能是受害者或嫌疑人）。Linux 系统上的所有用户都有一个主目录，在该目录中他们可以保存文件和文档、自定义环境、存储持久和缓存数据，并保留历史数据（例如浏览器
    cookie、shell 历史或电子邮件）。用户的主目录包含大量潜在的证据，调查人员可以利用这些证据重建过去的事件和活动。用户主目录的位置在 */etc/passwd*
    文件中定义，通常默认位于 */home/* 目录下，并以用户的用户名命名（例如，*/home/sam/*）。用户的主目录也可以用波浪号（`~`）简写，供命令行或文档中使用。
- en: '**Hidden Dot Files and XDG Base Directories**'
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**隐藏点文件和 XDG 基础目录**'
- en: 'It is common practice to save user configuration data in hidden files and directories
    that begin with a dot and are named after the program being configured. Several
    examples of information found in a home directory’s hidden files include:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通常的做法是将用户配置数据保存在以点（`.`）开头的隐藏文件和目录中，并且这些文件和目录的名称通常与被配置的程序相同。以下是一些常见的保存在主目录中隐藏文件里的信息示例：
- en: '***.bash_history*** History of shell commands the user typed'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '***.bash_history*** 用户输入的 shell 命令历史'
- en: '***.lesshst*** Search history of the `less` command'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '***.lesshst*** `less` 命令的搜索历史'
- en: '***.viminfo*** Search and command history, and traces of vim-edited files'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '***.viminfo*** 搜索和命令历史，以及 vim 编辑过的文件痕迹'
- en: '***.wget-hsts*** List of `wget` hosts visited^([6](footnotes.xhtml#ch04foot_06))
    with timestamps'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '***.wget-hsts*** `wget` 访问过的主机列表^([6](footnotes.xhtml#ch04foot_06))，带时间戳'
- en: '***.forward*** File containing email addresses for auto-forwarding'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '***.forward*** 包含自动转发的电子邮件地址的文件'
- en: '***.apvlvinfo*** History of PDFs viewed using the apvlv PDF viewer'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '***.apvlvinfo*** 使用 apvlv PDF 查看器查看的 PDF 历史'
- en: 'For more complex user configuration, cache, history, and persistent data, an
    application may create a dedicated hidden directory containing multiple files
    and subdirectories to organize data. Here are a few examples:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的用户配置、缓存、历史和持久数据，某个应用程序可能会创建一个专用的隐藏目录，包含多个文件和子目录来组织数据。以下是一些例子：
- en: '***.ssh/*** Secure shell configuration, keys, and list of known hosts visited'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '***.ssh/*** 安全外壳配置、密钥和访问过的已知主机列表'
- en: '***.gnupg/*** GPG configuration, keys, and other people’s added public keys'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '***.gnupg/*** GPG 配置、密钥以及其他人添加的公钥'
- en: '***.thunderbird/*** Email and calendar accounts, and synchronized email and
    calendar content for offline access'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '***.thunderbird/*** 电子邮件和日历账户，以及用于离线访问的同步电子邮件和日历内容'
- en: '***.mozilla/*** Firefox configuration, cookies, bookmarks, browsing history,
    and plug-ins'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '***.mozilla/*** Firefox 配置、cookie、书签、浏览历史和插件'
- en: '***.zoom/*** Zoom configuration, logs, call history, and shared data'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '***.zoom/*** Zoom 配置、日志、通话历史和共享数据'
- en: '***.john/*** John the Ripper password-cracking history with discovered passwords'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '***.john/*** John the Ripper 密码破解历史和已发现的密码'
- en: '***.ICAClient/*** Citrix client configuration, cache, logs, and other data'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '***.ICAClient/*** Citrix 客户端配置、缓存、日志及其他数据'
- en: The developers of any software package are free to choose what to save and where
    to save it. Storing information using hidden files and directories was never required,
    but it became common practice.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 任何软件包的开发者都可以自由选择保存什么内容以及保存在哪里。虽然使用隐藏文件和目录来存储信息并不是必需的，但它已经成为一种常见的做法。
- en: 'Over time, the number of dot files in a typical user’s home directory became
    unwieldy, driving the need for standardization. The former X Desktop Group (known
    today as [freedesktop.org](http://freedesktop.org)) created the *XDG Base Directory
    Specification* (*[https://www.freedesktop.org/wiki/Specifications/basedir-spec/](https://www.freedesktop.org/wiki/Specifications/basedir-spec/)*),
    which defined standard locations for storing user-specific data.^([7](footnotes.xhtml#ch04foot_07))
    The specification defines environment variables and default locations that operating
    systems and applications may use instead of creating their own proprietary files
    and directories in the user’s home directory. These location environment variables
    and associated default locations are:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间推移，典型用户的主目录中的点文件数量变得庞大，这促使了标准化的需求。前X桌面组（今天称为 [freedesktop.org](http://freedesktop.org)）创建了
    *XDG 基目录规范* (*[https://www.freedesktop.org/wiki/Specifications/basedir-spec/](https://www.freedesktop.org/wiki/Specifications/basedir-spec/)*)，该规范定义了用于存储用户特定数据的标准位置。^[7](footnotes.xhtml#ch04foot_07)
    该规范定义了操作系统和应用程序可以使用的环境变量和默认位置，而不是在用户的主目录中创建自己的专有文件和目录。这些位置环境变量和相关的默认位置是：
- en: 'Data files: `$XDG_DATA_HOME` or default *~/.local/share/**'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据文件：`$XDG_DATA_HOME` 或默认的 *~/.local/share/*
- en: 'Configuration files: `$XDG_CONFIG_HOME` or default *~/.config/**'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置文件：`$XDG_CONFIG_HOME` 或默认的 *~/.config/*
- en: 'Non-essential cache data: `$XDG_CACHE_HOME` or default *~/.cache*'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非必要的缓存数据：`$XDG_CACHE_HOME` 或默认的 *~/.cache*
- en: 'Runtime files: `$XDG_RUNTIME_DIR` or typically */run/user/*UID (where *UID*
    is the numeric ID of the user)'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时文件：`$XDG_RUNTIME_DIR` 或通常是 */run/user/*UID（其中 *UID* 是用户的数字ID）
- en: In addition, the specification defines two search variables, `$XDG_DATA_DIRS`
    and `$XDG_CONFIG_DIRS`, which contain paths for additional configuration (this
    is often to include system-wide, or Flatpak and snap, directories). The */run/*
    directory is mounted on a temporary RAM-based filesystem (tmpfs), so user runtime
    files exist only when the system is running and the user is logged in. The */run/*
    directory will be empty when examining a forensic image.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，规范定义了两个搜索变量，`$XDG_DATA_DIRS` 和 `$XDG_CONFIG_DIRS`，它们包含额外配置的路径（通常是为了包含系统范围的，或
    Flatpak 和 snap 目录）。*/run/* 目录挂载在一个基于临时RAM文件系统（tmpfs）的文件系统上，因此用户的运行时文件仅在系统运行且用户已登录时存在。在检查法医镜像时，*/run/*
    目录将为空。
- en: '**Location of User Application and System Information**'
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**用户应用程序和系统信息的位置**'
- en: When performing a postmortem forensic analysis, the data, configuration, and
    cache directories contain significant amounts of information about applications
    and system components related to a user’s activity. Many of these locations are
    described in more detail in the rest of the book, but let’s look at some examples.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行事后法医分析时，数据、配置和缓存目录包含了关于应用程序和系统组件的大量信息，这些信息与用户的活动有关。本书的其余部分会详细描述这些位置，但让我们来看一些示例。
- en: Programs placing data in the *~/.cache/* directory expect that it might be deleted.
    It is considered “non-essential” but remains persistent over time and across login
    sessions and reboots. Any program can create files or directories in *~/.cache/*
    to store data for performance and efficiency reasons.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据放置在 *~/.cache/* 目录中的程序预计这些数据可能会被删除。它被认为是“非必要的”，但会在时间上和跨登录会话与重启之间保持持久性。任何程序都可以在
    *~/.cache/* 中创建文件或目录，用于存储出于性能和效率原因的数据。
- en: 'Here are examples of information and the programs that may save them:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些信息的示例以及可能保存它们的程序：
- en: Browsers cache HTML, images, JavaScript, and safe browsing information
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器缓存 HTML、图片、JavaScript 和安全浏览信息
- en: A separate directory for web favicons exists
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在一个用于网页图标的单独目录
- en: Software Center caches file lists, images, ratings, and information
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件中心缓存文件列表、图片、评分和信息
- en: Some mail clients store cached email and calendars
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些邮件客户端存储缓存的电子邮件和日历
- en: Package managers save downloaded software packages
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包管理器保存下载的软件包
- en: Programs store thumbnails, images, and album art
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序存储缩略图、图片和专辑封面
- en: Window managers and desktop environments save session information and logs
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 窗口管理器和桌面环境保存会话信息和日志
- en: Some programs use *.cache* as the location to auto-save open files
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些程序将 *.cache* 作为自动保存打开文件的位置
- en: Temporary screenshot data
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临时屏幕截图数据
- en: Any other cache data stored by programs for performance or efficiency reasons
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他由程序为提高性能或效率而存储的缓存数据
- en: The *~/.cache/* directory stores anything that can be re-downloaded, locally
    generated, or otherwise recovered and re-created. These files contain information
    about the use of the system and different applications. The creation and modification
    timestamps may help reconstruct a timeline of past activity.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*~/.cache/*目录存储可以重新下载、在本地生成或以其他方式恢复和重新创建的任何内容。这些文件包含关于系统和不同应用程序使用的信息。创建和修改时间戳可能有助于重建过去活动的时间线。'
- en: The user’s *~/.config/* directory is supposed to contain only configuration
    data, but many application developers use it for other things, like history and
    cached information. Files in *~/.config/* may end in **rc* or have extensions
    of *.conf*, *.ini*, *.xml*, *.yaml*, or other configuration formats. Most files
    found here are regular text files and are easy to view with any text editor or
    viewer.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 用户的*~/.config/*目录本应只包含配置数据，但许多应用程序开发人员也将其用于其他用途，如历史记录和缓存信息。*~/.config/*中的文件可能以**rc*结尾，或具有*.conf*、*.ini*、*.xml*、*.yaml*等配置格式的扩展名。此处找到的大多数文件是普通文本文件，可以使用任何文本编辑器或查看器轻松查看。
- en: 'In some cases, configuration information is stored in databases and must be
    extracted. Because this is the free and open source world, tools and specifications
    usually exist to facilitate analysis of those databases. Some examples of data
    stored in the *~/.config/* directory include:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，配置信息存储在数据库中，需要提取。由于这是自由和开源的世界，通常会有工具和规范来帮助分析这些数据库。一些存储在*~/.config/*目录中的数据示例包括：
- en: General configuration of applications (not including data)
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的常规配置（不包括数据）
- en: Desktop artifacts (trash, session configuration, autostart, and dconf)
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桌面工件（垃圾、会话配置、自动启动和dconf）
- en: Application extensions and plug-ins
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序扩展和插件
- en: Files containing unique identifiers and license data
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含唯一标识符和许可证数据的文件
- en: Cookies for some browsers
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些浏览器的Cookies
- en: Application state data (first time run, initial welcome banners)
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序状态数据（首次运行、初始欢迎横幅）
- en: Configuration of user accounts and remote servers
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户账户和远程服务器的配置
- en: Communication application (Wire, Jitsi) logs, persistence, and cache
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通信应用程序（Wire、Jitsi）日志、持久性和缓存
- en: Default applications specified in a *mimeapps.list* file
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*mimeapps.list*文件中指定的默认应用程序
- en: Any other arbitrary configuration data stored by programs
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序存储的任何其他任意配置数据
- en: Aside from the usual configuration data from applications, the *~/.config/*
    directory is interesting to search for usernames, email addresses, and hostnames
    that indicate remote connections and activity. In some cases, you also can find
    passwords or password hashes in user configuration files.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 除了来自应用程序的常规配置数据外，*~/.config/*目录在搜索用户名、电子邮件地址和主机名方面也很有意思，这些信息可能表明远程连接和活动。在某些情况下，您还可以在用户配置文件中找到密码或密码哈希。
- en: 'The *~/.local/share/* directory is intended to store persistent data accumulated
    or generated by applications. Examples of data saved here include:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*~/.local/share/*目录用于存储应用程序积累或生成的持久数据。此处保存的数据示例包括：'
- en: Distro-specific configuration
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发行版特定的配置
- en: Graphical login session configuration
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形登录会话配置
- en: Desktop-specific configuration
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桌面特定配置
- en: Desktop-bundled apps (readers, notes, file managers, and so on)
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桌面捆绑应用程序（阅读器、笔记、文件管理器等）
- en: Commonly shared thumbnails
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的共享缩略图
- en: Desktop trashcan
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桌面回收站
- en: Cookies for some browsers
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些浏览器的Cookies
- en: Calendar and contact databases for some applications
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些应用程序的日历和联系人数据库
- en: Recently used files and places (**.xbel* files)
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最近使用的文件和位置（**.xbel*文件）
- en: Snap and Flatpak application information
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Snap和Flatpak应用程序信息
- en: Baloo file index and search for KDE
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KDE的Baloo文件索引和搜索
- en: Tracker file index and search for GNOME
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNOME的跟踪文件索引和搜索
- en: Secret keyrings and password wallets
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秘密钥匙环和密码钱包
- en: Clipboard manager data
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剪贴板管理器数据
- en: Xorg logs
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xorg日志
- en: Any other persistent data stored by programs
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序存储的任何其他持久数据
- en: Most distributions and applications are starting to follow the XDG specifications,
    and thus provide common locations for artifacts of interest to forensic investigators.
    However, some applications do not follow the XDG Base Directory Specification
    correctly or at all. This may be historic, for backward compatibility, or for
    other reasons. The Arch Linux wiki maintains a list (*[https://wiki.archlinux.org/index.php/XDG_Base_Directory](https://wiki.archlinux.org/index.php/XDG_Base_Directory)*)
    of application compatibility with the XDG Base Directory Specification. As you
    can see, every application is free to choose what to save, how to save it, and
    where to save it. Even across desktop environments and distributions, only the
    XDG base directories are consistent, but even that is not a requirement. When
    analyzing user home directories, be sure to examine each hidden file and directory
    in the */home/* and the XDG base directories.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数发行版和应用程序开始遵循 XDG 规范，因此为取证调查人员提供了常见的感兴趣文物位置。然而，一些应用程序并没有正确地遵循 XDG 基础目录规范，或者根本没有遵循。这可能是历史原因、向后兼容性，或其他原因。Arch
    Linux 的维基维护了一个列表 (*[https://wiki.archlinux.org/index.php/XDG_Base_Directory](https://wiki.archlinux.org/index.php/XDG_Base_Directory)*)，列出了应用程序与
    XDG 基础目录规范的兼容性。如你所见，每个应用程序都可以自由选择保存什么、如何保存以及保存在哪里。即使在不同的桌面环境和发行版之间，只有 XDG 基础目录是统一的，但这也不是强制性的要求。在分析用户的主目录时，务必检查
    */home/* 和 XDG 基础目录中的每个隐藏文件和目录。
- en: 'Independent of applications, the XDG standards suggest a list of common directories
    in a user’s */home/* directory to store user files based on category. These directories
    are defined in */etc/xdg/user-dirs.defaults* and may be created on login if they
    don’t already exist:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 独立于应用程序，XDG 标准建议在用户的 */home/* 目录中，根据类别存储用户文件的常见目录列表。这些目录在 */etc/xdg/user-dirs.defaults*
    中定义，如果这些目录不存在，它们可能会在登录时创建：
- en: '*Desktop/*'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Desktop/*'
- en: '*Downloads/*'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Downloads/*'
- en: '*Templates/*'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模板/*'
- en: '*Public/*'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Public/*'
- en: '*Documents/*'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Documents/*'
- en: '*Music/*'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Music/*'
- en: '*Pictures/*'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Pictures/*'
- en: '*Videos/*'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Videos/*'
- en: The *Desktop/* directory is for files that will appear on the user’s desktop,
    and the *Downloads/* directory is a default location for applications to save
    downloaded files. Applications (like office suites) reference the *Templates/*
    directory to suggest template files when a user is creating a new document. The
    *Public/* directory can be used as an open share for other users (typically on
    a local LAN) to access files. The remaining directories are self-explanatory,
    and relevant applications can use those directories as default locations to store
    documents and media files.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*Desktop/* 目录用于存放将在用户桌面上显示的文件，*Downloads/* 目录是应用程序保存下载文件的默认位置。应用程序（如办公套件）引用
    *Templates/* 目录，在用户创建新文档时建议模板文件。*Public/* 目录可以作为其他用户（通常在本地局域网内）访问文件的开放共享。其余目录不言自明，相关应用程序可以使用这些目录作为存储文档和媒体文件的默认位置。'
- en: 'These directory names are created with local language translations depending
    on the locale’s settings. For example, on my German test system, the following
    folders corresponding to the English equivalents: *Schreibtisch/*, *Vorlagen/*,
    *Downloads/*, *Öffentlich/*, *Dokumente/*, *Musik/*, *Bilder/*, and *Videos/*.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这些目录名称根据本地语言的设置而创建。例如，在我的德语测试系统上，以下文件夹对应英文名称：*Schreibtisch/*，*Vorlagen/*，*Downloads/*，*Öffentlich/*，*Dokumente/*，*Musik/*，*Bilder/*，和
    *Videos/*。
- en: The *~/Downloads/* directory can be interesting to analyze. When some browsers
    begin downloading a file, they create a temporary file and then move it to the
    correct filename when the download completes (Firefox uses **.part* as the temporary
    file). This means the birth (`crtime`) timestamp represents when the download
    started, and the contents’ last modified (`mtime`) timestamp is when the download
    finished. Because we know the size of the file, we can even calculate the approximate
    speed of the download over the network connection at the time.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*~/下载/* 目录可能值得分析。当一些浏览器开始下载文件时，它们会创建一个临时文件，然后在下载完成后将其移动到正确的文件名（Firefox 使用 **.part*
    作为临时文件）。这意味着出生时间戳（`crtime`）表示下载开始的时间，而内容的最后修改时间戳（`mtime`）表示下载完成的时间。因为我们知道文件的大小，我们甚至可以计算出当时通过网络连接下载的近似速度。'
- en: 'Here, a 7GB DVD download started at 8:51 and finished at 9:12:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，一个 7GB 的 DVD 下载从 8:51 开始，9:12 完成：
- en: '[PRE0]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Knowing the start and end time of a file download could be interesting in a
    forensic investigation, especially when reconstructing timelines of user activity.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 知道文件下载的开始和结束时间在取证调查中可能非常有用，特别是在重建用户活动时间线时。
- en: This book does not focus on Linux application analysis, so these examples are
    brief and incomplete. Some of the files and directories (*.ssh* and *.gnupg*,
    for example) are covered in more detail elsewhere in the book. The other examples
    shown here illustrate the commonly used locations and contents of application
    data stored on Linux systems. Good sources of information for forensic analysis
    techniques for individual applications are Forensic Science International’s *Digital
    Investigation* journal, the DFRWS conference, and *[https://www.ForensicFocus.com/](https://www.ForensicFocus.com/)*.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 本书并不专注于Linux应用分析，因此这些示例简短且不完整。某些文件和目录（例如*.ssh*和*.gnupg*）在本书的其他地方有更详细的介绍。此处展示的其他示例说明了存储在Linux系统上的应用数据的常用位置和内容。有关单个应用程序的取证分析技巧的良好信息来源包括《法医科学国际》期刊的*数字调查*，DFRWS大会和*[https://www.ForensicFocus.com/](https://www.ForensicFocus.com/)*。
- en: '***Hashsets and NSRL for Linux***'
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Linux的哈希集和NSRL***'
- en: A common method of identifying files in digital forensics is to use cryptographic
    hashes (MD5, SHA-1, and so on) to create a unique fingerprint or signature. You
    can create lists of cryptographic hashes from software packages or other known
    collections of files. These lists of known file hashes are called *hashsets* or
    *hash databases*. In digital forensics, hashsets are typically used either to
    ignore uninteresting files or to identify especially interesting files.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 数字取证中常用的一种识别文件的方法是使用加密哈希值（MD5、SHA-1 等）来创建唯一的指纹或签名。你可以从软件包或其他已知的文件集合中创建加密哈希值列表。这些已知文件哈希值的列表被称为*哈希集*或*哈希数据库*。在数字取证中，哈希集通常用于忽略无关文件或识别特别重要的文件。
- en: 'When used to ignore uninteresting files, hashsets can reduce the number of
    files to be examined. For instance, if an investigator is interested only in files
    created, modified, or downloaded apart from the installation of an operating system,
    they can use hashsets to filter out the files known to belong to that operating
    system. Examples of known files typically ignored during forensic analysis include:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在用哈希集忽略无关文件时，可以减少需要检查的文件数量。例如，如果调查人员只对创建、修改或下载的文件感兴趣，而不涉及操作系统的安装文件，他们可以使用哈希集过滤掉已知属于该操作系统的文件。在取证分析中，通常会忽略的已知文件示例包括：
- en: Operating systems and all supporting files
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统及其所有支持文件
- en: Device drivers
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备驱动程序
- en: Application software
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用软件
- en: Company-generated hashsets of standard server or client installations
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公司生成的标准服务器或客户端安装的哈希集
- en: Hashsets identify only the contents of files, not the metadata of the installed
    files on the filesystem. Timestamps, permissions, ownership, and so on are part
    of the filesystem, and aren’t included in a hashset.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希集只识别文件的内容，而不是文件系统上已安装文件的元数据。时间戳、权限、所有权等是文件系统的一部分，不包括在哈希集中。
- en: 'When identifying especially interesting files, investigators use hashsets to
    search for the existence of files in a forensic drive image. For example, if an
    investigator has a list of hashes for files involved in a particular cyberattack,
    they can search an affected machine specifically for the existence of those files.
    Examples of known files typically of interest during forensic analysis include:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在识别特别重要的文件时，调查人员使用哈希集来搜索取证磁盘镜像中是否存在这些文件。例如，如果调查人员有一份涉及某个特定网络攻击的文件哈希列表，他们可以专门搜索受影响的机器是否存在这些文件。在取证分析中，通常需要关注的已知文件包括：
- en: Indicators of compromise (IOCs), which may include hashes of malware components
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 妥协指示器（IOCs），可能包括恶意软件组件的哈希值
- en: Certain classifications of software (keyloggers or bitcoin miners, for example)
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某些分类的软件（例如键盘记录器或比特币挖矿程序）
- en: Known illicit material (these hashsets are usually available only to law enforcement)
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已知的非法材料（这些哈希集通常仅供执法机关使用）
- en: Known leaked or sensitive documents in a corporate environment
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在企业环境中已知的泄露或敏感文件
- en: Hashsets also are used to find modified or trojaned versions of binary executables
    by comparing installed files with the expected vendor-supplied hash values.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希集还用于通过将安装的文件与预期的供应商提供的哈希值进行比较，来查找修改过的或植入木马的二进制可执行文件。
- en: You can find hashsets of known files in several places. The security community
    often shares IOCs and security-related hashsets, and cybersecurity companies sell
    them as threat intelligence data feeds. Law enforcement agencies share hashsets
    of illicit material, which are made available only to other police forensic labs.
    Large companies may create hashsets of their internally developed software packages
    or standard server/client installations.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在多个地方找到已知文件的哈希集。安全社区经常分享IOC和安全相关的哈希集，网络安全公司将其作为威胁情报数据流出售。执法机构分享非法材料的哈希集，这些哈希集仅供其他警方取证实验室使用。大型公司可能会创建内部开发的软件包或标准服务器/客户端安装的哈希集。
- en: 'NIST maintains the National Software Reference Library (NSRL),^([8](footnotes.xhtml#ch04foot_08))
    which is a collection of known software packages. NIST provides hashsets from
    the NSRL for free (*[http://www.nsrl.nist.gov/](http://www.nsrl.nist.gov/)*).
    The NSRL hashsets are a compressed list of files with hashes, the filename, product,
    and other information; for example:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: NIST维护国家软件参考库（NSRL），^([8](footnotes.xhtml#ch04foot_08))这是一个已知软件包的集合。NIST提供NSRL哈希集的免费下载
    (*[http://www.nsrl.nist.gov/](http://www.nsrl.nist.gov/)*)。NSRL哈希集是一个压缩文件列表，包含哈希值、文件名、产品和其他信息；例如：
- en: '[PRE1]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The format of NSRL data sets is defined at *[https://www.nist.gov/system/files/data-formats-of-the-nsrl-reference-data-set-16.pdf/](https://www.nist.gov/system/files/data-formats-of-the-nsrl-reference-data-set-16.pdf/)*.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: NSRL数据集的格式定义见 *[https://www.nist.gov/system/files/data-formats-of-the-nsrl-reference-data-set-16.pdf/](https://www.nist.gov/system/files/data-formats-of-the-nsrl-reference-data-set-16.pdf/)*。
- en: Hashsets are also available as commercial products. These typically include
    the NSRL hashsets, additional hashes that could be extracted from commercial products
    (not included in the NSRL), and other sources. A popular example is *[https://www.hashsets.com/](https://www.hashsets.com/)*,
    which provides hashset subscriptions that augment the NSRL data.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希集也作为商业产品提供。这些通常包括NSRL哈希集、可以从商业产品中提取的额外哈希（未包含在NSRL中）以及其他来源。一个流行的例子是 *[https://www.hashsets.com/](https://www.hashsets.com/)*，它提供增补NSRL数据的哈希集订阅。
- en: Most digital forensic software (including free open source tools like Autopsy
    and The Sleuth Kit) support the inclusion and exclusion of hashsets for analysis.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数数字取证软件（包括像Autopsy和The Sleuth Kit这样的免费开源工具）支持在分析中包含和排除哈希集。
- en: 'Maintaining hashsets for Linux systems and free and open source software (FOSS)
    in general causes some difficulties. Here are a few examples:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 维护Linux系统和自由及开源软件（FOSS）的一致性哈希集会带来一些困难。以下是几个例子：
- en: Rolling distributions like Arch Linux update on a daily basis
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似Arch Linux这样的滚动发行版会每天更新。
- en: Some software packages are compiled from source and may produce files that are
    unique to the system where they are installed
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些软件包是从源代码编译的，可能会生成仅与安装系统相关的文件。
- en: Some software runs installation scripts that may generate files unique to the
    system where they are installed
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些软件运行安装脚本，这些脚本可能会生成仅与安装系统相关的文件。
- en: Many different Linux distributions provide their own software re-positories
    that are constantly changing and updating (see *[https://distrowatch.com/](https://distrowatch.com/)*)
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多不同的Linux发行版提供自己的软件仓库，这些仓库不断变化和更新（请参见 *[https://distrowatch.com/](https://distrowatch.com/)*）。
- en: Linux users may download software directly from developers and then compile
    and install manually on their own systems
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux用户可能直接从开发者处下载软件，然后手动编译和安装到他们自己的系统中。
- en: This dynamic landscape of change and development makes maintaining hashsets
    more difficult. In contrast, commercial software vendors have release cycles with
    well-defined software product packages.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这种动态的变化和开发环境使得维护哈希集变得更加困难。相比之下，商业软件供应商有明确的软件发布周期和产品包。
- en: Most open source software developers provide hashes or GPG signatures of the
    source code to verify integrity. But these hashes are for the code, not the compiled
    binaries. Most Linux distributions provide hashes or GPG signatures of the compiled
    binary software packages they provide, and some even include hashes of each individual
    file (see [Chapter 7](ch07.xhtml) on software installation for more information).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开源软件开发者提供源代码的哈希值或GPG签名以验证完整性。但这些哈希值是针对源代码的，而不是编译后的二进制文件。大多数Linux发行版会提供已编译的二进制软件包的哈希值或GPG签名，甚至有些会包含每个单独文件的哈希值（请参见[第7章](ch07.xhtml)有关软件安装的更多信息）。
- en: '**Linux File Types and Identification**'
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Linux文件类型和识别**'
- en: The phrase *file type* can have one of two meanings. In the context of lower-layer
    filesystems, it refers to Unix or POSIX file types. In the context of higher-layer
    applications, it refers to the file content type. Understanding this difference
    is important when conducting a forensic examination. In addition, “hidden” files
    (which are usually just normal files and not actually hidden) can provide important
    information for an investigation.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*文件类型* 这个词组有两种含义。在低层文件系统的上下文中，它指的是 Unix 或 POSIX 文件类型。在高层应用的上下文中，它指的是文件内容类型。在进行取证检查时，理解这个区别非常重要。此外，“隐藏”文件（通常只是普通文件，并非真正隐藏）可以为调查提供重要信息。'
- en: '***POSIX File Types***'
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***POSIX 文件类型***'
- en: 'Linux was developed with the Unix philosophy of “everything is a file.” To
    implement this concept, special file types were needed to extend functionality
    beyond regular files and directories. Linux has adopted the seven fundamental
    file types as defined by the POSIX standard, allowing the representation of special
    objects as files. These file types are:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 是按照 Unix 的“凡事皆文件”哲学开发的。为了实现这一概念，需要特殊的文件类型来扩展功能，超越普通文件和目录。Linux 采纳了 POSIX
    标准定义的七种基本文件类型，允许将特殊对象表示为文件。这些文件类型包括：
- en: Regular file
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 普通文件
- en: Directory
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录
- en: Symbolic link
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号链接
- en: Named pipe or FIFO
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名管道或 FIFO
- en: Block special
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 块特殊文件
- en: Character special
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符特殊文件
- en: Socket
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 套接字
- en: 'Every “file” on a Linux system is categorized into one of these types and can
    be determined with the `ls -l` or `file` commands (and others). Understanding
    the difference between these file types is important to forensic investigators
    because not all files are related to data storage (and potentially contain evidence).
    Some files provide access to hardware devices or facilitate the flow of data between
    programs. Understanding this system behavior helps to reconstruct past events
    and locate potential evidence stored in other locations. Let’s take a closer look
    at the seven file types:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 系统中，每个“文件”都被分类为这些类型之一，可以通过 `ls -l` 或 `file` 命令（以及其他命令）来确定。理解这些文件类型之间的区别对取证调查人员来说非常重要，因为并非所有文件都与数据存储有关（并可能包含证据）。有些文件提供对硬件设备的访问，或促进程序之间数据的流动。理解这一系统行为有助于重构过去的事件，并定位存储在其他位置的潜在证据。让我们更详细地看看这七种文件类型：
- en: '**Regular files** A regular file is exactly that: a file containing data such
    as text, pictures, videos, office documents, executable programs, databases, encrypted
    data, or any other content normally stored in a file. Data in a regular file is
    stored in filesystem blocks on the storage medium.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**普通文件** 普通文件就是字面意思：一个包含数据的文件，如文本、图片、视频、办公文档、可执行程序、数据库、加密数据或任何其他通常存储在文件中的内容。普通文件中的数据存储在存储介质的文件系统块中。'
- en: '**Directory files** These are special files that contain a list of the directory’s
    contents, including filenames and their corresponding inodes. They allow files
    and directories to be organized hierarchically in a tree structure. However, this
    is only an abstraction because, at lower layers, the file blocks can be located
    anywhere on a drive. Directories are also known as folders and are created with
    commands like `mkdir`.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**目录文件** 这些是特殊的文件，包含目录内容的列表，包括文件名及其对应的 inode。它们允许文件和目录以树形结构进行层次化组织。然而，这只是一个抽象，因为在低层次上，文件块可以位于驱动器的任何位置。目录也叫做文件夹，通常通过
    `mkdir` 等命令创建。'
- en: '**Symbolic links** This type of file represents a pointer to another file (similar
    to LNK files in Windows, but without the additional metadata). A symbolic link
    is a small file containing the path and name of another file (depending on the
    filesystem, this information may be stored in the link’s inode). The size of a
    symbolic link file is the same as the length of the filename it points to. Symbolic
    links are allowed to point to files that don’t exist, and this may be interesting
    from a forensics perspective. This indicates that a file existed in the past or
    was on a filesystem mounted in the past. Symbolic links are also called symlinks
    and are created with the `ln -s` command.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**符号链接** 这种类型的文件表示指向另一个文件的指针（类似于 Windows 中的 LNK 文件，但没有附加的元数据）。符号链接是一个小文件，包含另一个文件的路径和名称（根据文件系统的不同，这些信息可能存储在链接的
    inode 中）。符号链接文件的大小与它指向的文件名的长度相同。符号链接允许指向不存在的文件，从取证的角度来看这可能很有趣。这表明某个文件曾经存在过，或曾经在一个挂载的文件系统中。符号链接也叫做
    symlink，可以通过 `ln -s` 命令创建。'
- en: '**Character and block special files** These files provide access to hardware
    devices (and pseudo-devices) through device drivers or kernel modules. These files
    are usually located in the */dev/* directory. Modern Linux systems create and
    remove them dynamically, but they can be created manually with the `mknod` command.
    Block devices are typically used to access storage media, and can be buffered,
    cached, or otherwise abstracted. Both character and block special files are associated
    with devices by a major and minor number specified when the device file is created.
    Use the `ls -l` or `stat` commands to identify the major and minor numbers. For
    a list of the assigned major and minor numbers on a running Linux system, look
    in the */sys/dev/block/* and */sys/dev/char/* directories. You can list block
    devices with the `lsblk` command. The file size of a character or block file is
    zero bytes.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '**Named pipe or FIFO** These files provide unidirectional interprocess communication
    between two programs. One program writing to a pipe can transfer data to another
    program that is reading from the same pipe. The `mkfifo` or `mknod` commands are
    used to create pipes. A pipe’s file size is zero bytes.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '**Socket files** Also providing interprocess communication, these files are
    bi-directional, and multiple programs may use them at the same time. They are
    often created by a daemon providing local services (instead of using TCP/IP sockets)
    and are removed on exit. Socket files can also be created by systemd socket activation.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Why are hard links not on this list of file types? Hard links are not considered
    to be a file type. A *hard link* is simply an additional filename linked to an
    existing inode (the inode represents the actual file, as described in [Chapter
    3](ch03.xhtml)).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: A *sparse file* is also not a file type, but rather a feature of the filesystem
    that allows a regular file containing continuous sequences of zeros to be written
    to disk in a compact form.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'When examining different file types in a postmortem forensic analysis, be aware
    of the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Block and character special files are created (and removed) in the */dev/* or
    */sys/* directories dynamically while the system is running. These directories
    will likely be empty during a forensic examination.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Named pipes (FIFOs) and sockets will not contain any data (anything written
    to them is received by another running process). A program or daemon can also
    remove the pipe or socket file from the filesystem when it exits.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A symbolic link is not required to point to an existing file. The link file
    will contain a filename, but the file it’s pointing to may or may not be there.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '*If you have a forensic image of a suspect Linux system directly mounted to
    your Linux analysis workstation, symbolic links from the drive under analysis
    may point to files and directories* on your own analysis machine*. Make sure that
    you are always analyzing the intended filesystem.*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '***Magic Strings and File Extensions***'
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The POSIX definition of a *regular file* refers to a filesystem file type, but
    the contents of this regular file can be text, pictures, videos, office documents,
    executable programs, databases, encrypted files, or any other content. The file
    content is also referred to as a file type, but at the application layer. There
    are several ways to identify the application file type of regular files. The phrase
    *file type* used in this section refers to application file types, not POSIX file
    types.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX 中对*常规文件*的定义是指文件系统中的一种文件类型，但该常规文件的内容可以是文本、图片、视频、办公文档、可执行程序、数据库、加密文件或任何其他内容。文件内容也被称为文件类型，但这是在应用层面上的。识别常规文件的应用文件类型有多种方法。本节中使用的*文件类型*一词指的是应用文件类型，而非
    POSIX 文件类型。
- en: The terms *magic string*, *magic type*, *magic signature*, or *magic bytes*
    all refer to a string of bytes at the beginning of a file. Linux shells and file
    managers use magic strings to identify the file type and choose which program
    to run for the file in question. These strings are typically part of the file
    format and are difficult to modify or remove maliciously without breaking functionality.
    You can use the Linux `file` command to determine the file type (`file -l` lists
    around 3,000 supported types). Forensic carving tools also use magic strings to
    help identify files that can be carved from unstructured data. See the file(1)
    and magic(5) man pages for more information about magic strings and Linux. More
    information about forensic carving is described in [Chapter 3](ch03.xhtml).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*魔术字符串*、*魔术类型*、*魔术签名*或*魔术字节*这些术语都指的是文件开头的一串字节。Linux shell 和文件管理器使用魔术字符串来识别文件类型，并选择哪个程序来运行该文件。这些字符串通常是文件格式的一部分，很难恶意修改或移除而不破坏功能。你可以使用
    Linux 的 `file` 命令来确定文件类型（`file -l` 列出大约 3,000 种支持的类型）。取证挖掘工具也使用魔术字符串来帮助识别可以从非结构化数据中提取的文件。有关魔术字符串和
    Linux 的更多信息，请参阅 file(1) 和 magic(5) 手册页。更多关于取证挖掘的信息，请参见 [第 3 章](ch03.xhtml)。'
- en: File extensions are commonly used to indicate the contents of a file. For example,
    filenames ending with *.pdf*, *.docx*, or *.odt* are most likely office documents,
    whereas those ending with *.jpg*, *.png*, or *.gif* are probably images, and so
    on. Applications use these file extensions to determine how to open a particular
    file. For example, email clients use them for opening attachments, web browsers
    for downloads, file managers for file open requests, and so on. The simplicity
    of file extensions is sometimes abused to hide file content merely by changing
    the file extension. For example, malware may attempt to hide executable files,
    corporate data theft may involve attempts to hide office documents, and people
    in possession of illicit material may attempt to hide the existence of media files.
    Although this is trivial to detect with modern forensic software, it is still
    commonplace.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 文件扩展名通常用于指示文件的内容。例如，文件名以*.pdf*、*.docx* 或 *.odt* 结尾的文件很可能是办公文档，而以*.jpg*、*.png*
    或 *.gif* 结尾的文件可能是图片，等等。应用程序使用这些文件扩展名来决定如何打开特定的文件。例如，电子邮件客户端使用它们来打开附件，网页浏览器用于下载，文件管理器用于文件打开请求，等等。文件扩展名的简便性有时被滥用，通过更改文件扩展名来隐藏文件内容。例如，恶意软件可能试图隐藏可执行文件，企业数据盗窃可能涉及尝试隐藏办公文档，而持有非法材料的人可能会尝试隐藏媒体文件的存在。尽管使用现代取证软件可以轻松检测到这一点，但它仍然是常见的现象。
- en: Unlike in the Windows world, having multiple extensions for a single file is
    common in Linux and usually indicates several operations to a file (or group of
    files). For example, *files.tar.gz* refers to an archive (extension *.tar*) that
    has been compressed (extension *.gz*). Another example, *files.tar.gz.md5*, refers
    to a file containing the MD5 hash of the compressed archive file. When examining
    a Linux environment, digital forensic software must understand how to process
    files with multiple extensions.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Windows 环境不同，在 Linux 中，一个文件有多个扩展名是常见的，这通常表示对文件（或一组文件）进行了多个操作。例如，*files.tar.gz*
    表示一个已被压缩（扩展名为*.gz*）的归档文件（扩展名为*.tar*）。另一个例子，*files.tar.gz.md5* 表示一个包含已压缩归档文件 MD5
    哈希值的文件。在检查 Linux 环境时，数字取证软件必须了解如何处理具有多个扩展名的文件。
- en: '***Hidden Files***'
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***隐藏文件***'
- en: Linux uses the Unix naming convention for hidden files. A hidden file is simply
    a normal file or directory name starting with a dot (.). Files starting with dots
    indicate to programs that they don’t need to show the file in a directory listing.
    The use of an initial dot for hiding files was somewhat accidental. An early version
    of the `ls` command was written to ignore the directory “.” and “..” files, but
    ended up ignoring any file starting with a dot. Since then, developers have used
    it to hide things like configuration files that the user normally doesn’t need
    to see.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Hidden files using a dot in their filename are not really hidden. The hiding
    mechanism is not a technical method like a kernel or filesystem flag. It is only
    a naming convention that programs and applications may use (if they want) to filter
    out files from view. Most programs, file managers in particular, provide an option
    to show hidden files. When performing analysis with forensic tools, hidden files
    appear as normal files (because they are normal files). You don’t need to take
    additional steps to “unhide” them. Attempts to hide files and directories using
    a dot in unconventional locations may indicate suspicious activity.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Another method of hiding a file is by opening it and then deleting it without
    closing. This removes the directory entry with the filename (that is, the file
    is unlinked), but the inode will stay allocated until the file is closed. This
    method of file hiding is not persistent across reboots or if the process holding
    it open dies. Filesystem forensic tools should find inodes without filenames (for
    example, The Sleuth Kit’s `ils -O` or `-p`).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Malicious code can potentially hide files. Trojaned versions of programs like
    `ls` can be patched to prevent showing certain filenames or directories. Malicious
    kernel modules or rootkits can also intercept file operations and prevent viewing
    or accessing specific files. Kernel module rootkits can also hide processes, sockets,
    and kernel modules themselves (search for Linux rootkits on GitHub or other public
    source code repositories).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Simple hiding of files can also be done using filesystem permissions. Files
    can be hidden from other users by placing them in a read-protected directory.
    Users without read access won’t be able to read the contents of the directory,
    effectively hiding the filenames from view.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Hiding files using trojaned binaries, rootkits, or filesystem permissions is
    effective only on a running system. When performing an offline postmortem forensic
    analysis, these files should appear normal and not hidden. Also, knowing which
    users had access to files and directories may be relevant to an investigation.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: A section on file hiding should at least mention *steganography*. Multiple tools
    are available for hiding files using steganography, many of which can be compiled
    and run under Linux. As these tools are not specific to Linux systems, they are
    considered beyond the scope of this book.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '**Linux File Analysis**'
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Analyzing the contents of files found on Linux systems is generally easier than
    in more proprietary environments. File formats tend to be open and well documented.
    Many files, especially configuration files, are simple ASCII text files. Very
    few file formats are inherently proprietary to Linux.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 分析Linux系统上的文件内容通常比在更封闭的环境中更容易。文件格式通常是开放的并且文档完善。许多文件，特别是配置文件，都是简单的ASCII文本文件。极少有文件格式是Linux专有的。
- en: '***Application Metadata***'
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***应用程序元数据***'
- en: In digital forensics, file metadata may refer to either the metadata stored
    in the filesystem inode or to the metadata stored inside the file contents. In
    this section, we focus on the latter.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在数字取证中，文件元数据可以指代存储在文件系统inode中的元数据，也可以指代存储在文件内容中的元数据。本节重点讨论后者。
- en: 'The metadata from applications found on Linux systems is generally easier to
    analyze than that found in proprietary environments. Common open file formats
    are well documented and well supported by forensic tools. Applications running
    on Linux systems (and FOSS in general) use files falling into several categories:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux系统上找到的应用程序的元数据通常比在封闭环境中找到的更容易分析。常见的开放文件格式文档完善，取证工具也对其支持良好。运行在Linux系统上的应用程序（以及一般的自由开源软件）使用的文件可分为几类：
- en: Open standards (JPEG images, for example)
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开放标准（例如，JPEG图像）
- en: Proprietary but reverse-engineered by open source developers (many Microsoft
    file formats, for example)
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专有格式，但被开源开发者逆向工程（例如，许多Microsoft文件格式）
- en: Defined by open source application developers but specific to that application
    (a good example is the GIMP XCF file format)
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由开源应用程序开发者定义，但特定于该应用程序（一个很好的例子是GIMP的XCF文件格式）
- en: Specific to a Linux distribution (Red Hat RPM software package files, for example)
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定于Linux发行版（例如，Red Hat的RPM软件包文件）
- en: Specific to a common Linux system component (systemd’s journal format, for example)
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定于常见的Linux系统组件（例如，systemd的日志格式）
- en: Open source and Linux-specific formats are of particular interest in Linux forensics.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 开源和Linux特定格式在Linux取证中尤为重要。
- en: Extracting metadata from Linux-specific files may require the use of a Linux
    analysis machine for best results (even if a commercial forensic tool claims to
    support it). Often, Linux software packages will include tools for troubleshooting,
    repair, data extraction, conversion, and querying. You can use these tools (often
    simple command line utilities) to extract both metadata and content. To find ways
    of displaying file metadata using Linux tools, the best source of information
    is the tool’s own man page.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 从Linux特定的文件中提取元数据可能需要使用Linux分析机器来获得最佳结果（即使商业取证工具声称支持该功能）。通常，Linux软件包会包含用于故障排除、修复、数据提取、转换和查询的工具。你可以使用这些工具（通常是简单的命令行工具）来提取元数据和内容。要找到使用Linux工具显示文件元数据的方法，最好的信息来源是该工具的man页。
- en: In many cases, you can also use the application itself (on a read-only copy
    of the file) to examine metadata. For example, [Figure 4-2](ch04.xhtml#ch04fig02)
    shows a GIMP dialog displaying the metadata of an XCF file.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，你还可以使用应用程序本身（在文件的只读副本上）来检查元数据。例如，[图4-2](ch04.xhtml#ch04fig02)展示了一个GIMP对话框，显示了XCF文件的元数据。
- en: '![Image](Images/ch04fig02.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/ch04fig02.jpg)'
- en: '*Figure 4-2: GIMP dialog displaying the metadata of an XCF file*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-2：GIMP对话框显示XCF文件的元数据*'
- en: Source code repositories like GitHub or GitLab often have small tools for extracting
    metadata from open formats. These tools may be written by students, hobbyists,
    professional programmers, or even companies. They may or may not provide accurate
    results, and I recommend comparing the results with other similar tools.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 像GitHub或GitLab这样的源代码仓库通常提供一些小工具，用于从开放格式中提取元数据。这些工具可能是由学生、爱好者、专业程序员，甚至公司编写的。它们可能提供准确或不准确的结果，我建议将结果与其他类似工具进行比较。
- en: If all else fails, looking at the application’s source code may help. The file
    formats may be documented in header files or documentation included with the source
    software package. For example, take a look at the contents of */usr/include/*.h*,
    and you’ll find many file formats (among other things). Knowing a file format’s
    data structures allows you to write a tool or possibly use a hex editor to extract
    or decode metadata from a particular file.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其他方法都失败了，查看应用程序的源代码可能会有所帮助。文件格式可能在头文件或随源代码软件包提供的文档中有所说明。例如，查看*/usr/include/*.h*的内容，你将会发现许多文件格式（其中还有其他内容）。了解文件格式的数据结构可以帮助你编写工具，或者可能使用十六进制编辑器从特定文件中提取或解码元数据。
- en: '***Content Analysis***'
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***内容分析***'
- en: As mentioned in the previous section, files found in Linux environments tend
    to be open and well documented. Because of this, tools are easily written to examine
    the content of files. Often, you can examine file contents with tools developed
    for data recovery, data export, or conversion to other formats, or using simple
    file readers.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: If a file format is unknown, use the `file` command to try to identify the content.
    If no tools are available specifically for that file, try the `strings` command
    to extract the human-readable character strings contained in the file. See the
    file(1) and strings(1) man pages for more information.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Another possibility for extracting content from files, in particular compound
    files with other embedded files, is to use standard forensic carving tools on
    them. Such tools may extract files or fragments of files that may be of interest.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Some files found on Linux systems are backup or archive files. Traditional (but
    still common) examples of this are *tar*, *cpio*, and *dump*. Examples of more
    recent Linux backup solutions for end users include *duplicity* and *timeshift*.
    Common Linux enterprise backup systems include Bacula and Amanda. The forensic
    analysis of backup solutions is beyond the scope of this book. However, backups
    can be an excellent evidence source, and even the backup index databases will
    contain lists of filenames and directories that were backed up in the past, often
    together with timestamps (tar incremental backups use *.snar* files, for example).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'Extracting the content of encrypted files is always a challenge for digital
    forensic investigators. Even though the encryption format may be open and documented,
    the data will remain inaccessible unless the cryptographic keys are recovered.
    Some examples of encrypted file formats you might encounter on a Linux system
    include:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Encrypted email using GnuPG
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Encryption built in to applications (office documents: PDF, DOC, and so on)'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GnuPG encrypted files
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypted ZIP files
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypted file containers like Veracrypt
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In most cases, native files found on Linux systems will have an identifiable
    and documented format, tools available to view metadata, and tools for viewing
    or extracting their contents. Proprietary file formats may have FOSS tools, but
    those will be the result of best-effort reverse engineering by volunteers.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '***Executable Files***'
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When high-level programming code (readable by humans) is compiled into machine
    code (readable by CPUs), it is stored in an *executable* file format (readable
    by operating systems). This format gives the operating system all the information
    it needs to load the code into memory, set up various things (like dynamic linking
    with other code libraries), and run the program. Linux uses the *Executable and
    Linkable Format (ELF)* files taken from Unix. ELF executable files can be identified
    by the magic string in the first four bytes:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A number of tools can provide information about ELF files on a Linux system.
    The `file` command provides a basic summary of executable files:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种工具可以提供关于Linux系统中ELF文件的信息。`file`命令提供了可执行文件的基本摘要：
- en: '[PRE3]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In forensics, there are several areas of interest when analyzing executable
    files. In the case of malware, where no source code is available, executable files
    must be reverse-engineered to understand precisely what they are doing. This process
    involves disassembling and decompiling binaries into human-readable code, a method
    known as *static analysis*. Another method, called *dynamic analysis*, involves
    running code in a sandbox with debugging and tracing tools to understand live
    behavior. In the case of traditional computer forensic investigations (non-malware),
    the focus is on metadata from the executable. Reverse engineering of executables
    is beyond the scope of this book, but this section explores metadata useful for
    investigations.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在取证工作中，分析可执行文件时存在几个感兴趣的领域。在恶意软件的情况下，没有源代码可用，必须对可执行文件进行反向工程，以准确理解其功能。此过程涉及将二进制文件反汇编和反编译为人类可读的代码，这种方法称为*静态分析*。另一种方法称为*动态分析*，涉及在带有调试和跟踪工具的沙盒中运行代码，以理解实时行为。在传统的计算机取证调查（非恶意软件）中，重点是来自可执行文件的元数据。反向工程可执行文件超出了本书的范围，但本节探讨了对调查有用的元数据。
- en: 'Some executable formats (like MS-Windows PE/COFF) have a timestamp embedded
    in the file indicating when the binary was built. The ELF format doesn’t define
    a build timestamp, but Linux executables compiled with GCC contain a unique identifier
    called the *build ID* (optional, but default). The build ID is an SHA-1 hash of
    portions of code in the executable, and most ELF analysis tools can extract it.
    The `file` command (shown in the preceding example) displays the `build-id` (`BuildID[sha1]=`),
    and the `readelf` command can display it, as shown here:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一些可执行格式（如MS-Windows PE/COFF）在文件中嵌入了一个时间戳，指示二进制文件构建的时间。ELF格式不定义构建时间戳，但使用GCC编译的Linux可执行文件包含一个称为*构建ID*（可选，但默认）的唯一标识符。构建ID是可执行文件中部分代码的SHA-1哈希，大多数ELF分析工具可以提取它。`file`命令（如前面的示例所示）显示了`build-id`（`BuildID[sha1]=`），而`readelf`命令可以显示它，如下所示：
- en: '[PRE4]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This ID is unique to the version of compiled code and to the build environment,
    but when analyzing the build ID, note the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 此ID对于编译代码版本和构建环境是唯一的，但在分析构建ID时，请注意以下内容：
- en: The build ID will be the same whether the binary is stripped or not (symbol
    information is removed).
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论是否剥离了二进制文件（删除了符号信息），构建ID都将相同。
- en: It’s not always unique across machines. Two identical installations of Linux
    compiling the same version of code may generate the same build ID.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在不同机器上并不总是唯一。两个相同版本的Linux安装编译相同版本的代码可能生成相同的构建ID。
- en: This string can be removed or maliciously modified and there are no validity
    checks.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以删除此字符串或恶意修改它，并且没有有效性检查。
- en: Executables compiled at a central location and then copied to multiple machines
    will all have the same build ID.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个中央位置编译然后复制到多台机器的可执行文件将具有相同的构建ID。
- en: This build ID may be useful for linking executable files found on multiple machines
    in some cases, but in other cases, it may have little or no value.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，此构建ID对于链接在多台计算机上找到的可执行文件可能会有用，但在其他情况下，它可能没有或者价值不大。
- en: Other tools (such as `dumpelf` from the `pax-utils` package, `objdump`, and
    `readelf`) provide information about the internal structure of ELF executables,
    including the different headers and sections of the file. The `objdump` `-d` command
    also provides a disassembled output of the machine code.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 其他工具（如`pax-utils`包中的`dumpelf`，`objdump`和`readelf`）提供关于ELF可执行文件内部结构的信息，包括文件的不同头部和部分。`objdump`的`-d`命令还提供了机器代码的反汇编输出。
- en: 'Knowing which additional files are dynamically linked into an executable at
    runtime is also interesting to investigators. You normally can check this with
    the `ldd` command, as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 知道在运行时动态链接到可执行文件中的其他文件是对调查人员也很有趣。通常可以使用`ldd`命令来检查，如下所示：
- en: '[PRE5]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'However, if you are analyzing a suspicious file (potential malware), using
    `ldd` is not recommended. The man page explicitly states “you should never employ
    `ldd` on an untrusted executable, since this may result in the execution of arbitrary
    code.” A safe alternative to finding the shared objects required is the `objdump`
    tool, as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您正在分析可疑文件（可能是恶意软件），不建议使用`ldd`。man页面明确指出“绝不能对不受信任的可执行文件使用`ldd`，因为这可能导致执行任意代码。”查找所需的共享对象的安全替代方法是`objdump`工具，如下所示：
- en: '[PRE6]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The examples shown here are from popular 64-bit x86 (Intel/AMD) architectures,
    but the Linux kernel supports dozens of different CPU architectures. Other CPUs
    in use at the very high end of computing (mainframes and supercomputers) and the
    very low end (Raspberry Pi and IoT embedded systems) can be very different. Here’s
    an example `file` output from a Raspberry Pi:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的示例来自流行的64位x86（Intel/AMD）架构，但Linux内核支持多达几十种不同的CPU架构。在计算的最顶端（大型主机和超级计算机）和最低端（树莓派和物联网嵌入式系统）使用的其他CPU可能差异很大。以下是树莓派的一个示例`file`输出：
- en: '[PRE7]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A Linux architecture can be 32 or 64 bits, big or little endian, and support
    a variety of CPU instruction sets (x86, ARM, PPC, Sparc, and so on). Knowing the
    architecture is important when using forensic tools. Unless tools automatically
    detect these architectural characteristics, they may need to be made aware of
    them to produce sensible and accurate results.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Linux架构可以是32位或64位、大端或小端，并且支持多种CPU指令集（如x86、ARM、PPC、Sparc等）。了解架构对于使用法医工具至关重要。除非工具能够自动检测这些架构特征，否则可能需要手动告知工具这些特征，以便生成合理且准确的结果。
- en: '**Crash and Core Dumps**'
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**崩溃与核心转储**'
- en: Computers crash. Software crashes. Normally these events are upsetting, especially
    when data is lost. But for the forensic examiner, these events can be a good thing,
    as volatile memory data might be preserved during a crash. Crashed kernels, crashed
    processes, and other application crash data saved to the local disk have potential
    forensic value.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机会崩溃，软件会崩溃。通常这些事件令人不安，特别是当数据丢失时。但对于法医检查员而言，这些事件可能是好事，因为崩溃过程中，易失性内存数据可能会被保留。崩溃的内核、崩溃的进程以及保存到本地磁盘的其他应用程序崩溃数据可能具有潜在的法医价值。
- en: When computers or programs crash, they may attempt to save crash data on the
    local disk for programmers to analyze for debugging purposes. In some cases, those
    files are even uploaded to the developer’s servers for analysis. Some information
    saved in these crash data files may contain forensic artifacts that are useful
    in an investigation.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算机或程序崩溃时，它们可能会尝试将崩溃数据保存到本地磁盘，以便程序员进行调试分析。在某些情况下，这些文件甚至会被上传到开发者的服务器进行分析。这些崩溃数据文件中保存的某些信息可能包含对调查有用的法医痕迹。
- en: A kernel crash, process crash, and higher-level application and distro-specific
    crashes use different handling mechanisms. In each of these cases, data relevant
    to a forensic investigation may be saved.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 内核崩溃、进程崩溃以及更高层次的应用程序和发行版特定崩溃使用不同的处理机制。在这些情况下，与法医调查相关的数据可能会被保存。
- en: Forensic analysis of memory dumps may either refer to recovering traces of content
    information from memory dump files, or to understanding code execution and reasons
    for the dump. Understanding code execution is often used in the analysis of malware
    and technical exploitation (stack and buffer overflows, and so on). Analyzing
    such attacks involves static and dynamic code analysis, reverse engineering, decompilation,
    and disassembly. This analysis requires in-depth knowledge of C, assembly, and
    Linux memory management. All of these concepts are beyond the intended scope of
    this book (in fact, this topic could easily fill an entire book on its own). Here
    we’ll explore a superficial analysis of memory dumps and the extraction of basic
    string information.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 内存转储的法医分析可能指的是从内存转储文件中恢复内容信息的痕迹，或者理解代码执行和转储的原因。理解代码执行通常用于恶意软件分析和技术利用（如栈溢出、缓冲区溢出等）。分析此类攻击涉及静态和动态代码分析、逆向工程、反编译和反汇编。此类分析需要深入了解C语言、汇编语言和Linux内存管理。所有这些概念都超出了本书的范围（事实上，这个话题本身就足以填满一本书）。在这里，我们将探讨内存转储的表面分析和基本字符串信息的提取。
- en: '***Process Core Dumps***'
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***进程核心转储***'
- en: When a Linux program is executed, the process resides in memory and runs until
    it completes, terminates from a signal (kill), or crashes. When a process crashes,
    the system can be configured to save a memory image or core file to disk for debugging
    purposes. This is called a *core dump* or *dumping core*. Let’s look at where
    to find core files and how to examine them in a forensic context.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当Linux程序执行时，进程驻留在内存中并一直运行，直到完成、因信号（kill）终止或崩溃。当进程崩溃时，系统可以被配置为将内存映像或核心文件保存到磁盘以供调试使用。这被称为*核心转储*或*转储核心*。让我们来看一下如何在法医上下文中查找核心文件并进行检查。
- en: Traditionally, the saved core from a crashed process is written to a file called
    core or *core.*PID, where *PID* is the numeric process ID. Later kernels used
    a template to create the *core.** filename. These core files are saved in the
    same directory (if writable) where they crashed, and are owned by the user ID
    of the crashed process. You can find a system’s core files by searching the filesystem
    for all files named *core*, *core.*PID, or *core.** if using a template. See the
    core(5) man page for more information about core files and templates.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: If managed by systemd, which may require installation of a separate `systemd-coredump`
    package, core files are saved to a single directory */var/lib/ systemd/coredump/*.
    Here the core dump is sent to the `systemd-coredump` program, which logs it in
    the journal and saves a core file (see the systemd-coredump(8) man page). You
    can use the `coredumpctl` command to list systemd core dumps found in a suspect
    machine’s journal. The coredumpctl(1) and coredump.conf(5) man pages have more
    information.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows one line of a core dump log from an offline journal
    file:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here we see a list of available (`present` ➋ ) core dumps, including the time
    and information about the crashed program (`mousepad`) used in this example.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'By specifying the PID from a particular crash in this list (`157004` ➊ ), we
    can view more information and a backtrace:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, the `mousepad` application ➊ (a graphical text editor) dumped
    core, and `systemd-coredump` logged the output and saved the core file ➋ .
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'The core file was saved to the */var/lib/systemd/coredump/* directory and can
    be copied to a forensic analysis machine. The filename starts with `core.`, followed
    by the name of the program (`mousepad`), the numeric user ID (`1000`), the boot
    ID, the PID, a timestamp, and, lastly, an extension with the compression used:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Depending on the distro or configuration, the compression may be *zst*, *lz4*,
    or some other systemd-supported algorithm.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'You can uncompress the core file’s contents with tools like `zstdcat` or `lz4cat`.
    Here is an example of a shell pipeline where a core file is uncompressed and strings
    are extracted to a pager for manual analysis:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The output from this `zstdcat` and strings example contains all the human-readable
    strings from the core dump, including the environment variables and even the unsaved
    text that was typed into the editor at the moment it crashed. Core dumps from
    programs will contain whatever data they had in memory at the time of the crash.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Tools such as `bulk_extractor` can carve the core file for the usual search
    strings and also create a wordlist of possible passwords insecurely stored in
    memory. You can use this wordlist with password recovery programs to attempt decryption
    of any encrypted files found. You can also perform forensic carving for files
    or file fragments (images, HTML, and so on) on the uncompressed core dump.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: You could also use a debugger like `gdb` to further analyze the executable code.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '***Application and Distro-Specific Crash Data***'
  id: totrans-271
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Crash information helps developers debug and fix problems in their software.
    Crash reporting systems (which can be opt-in or opt-out) can monitor for local
    crashes and then send the data to developer servers for analysis.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: A Linux distribution can have its own system crash reporting. Desktop environments
    can have crash reporting specific to their library toolkits, and applications
    can implement their own crash reporting. Let’s look at some examples.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Fedora and Red Hat distros use `abrt` (automated bug reporting tool). The `abrtd`
    daemon watches for crash events and takes appropriate action, which may include
    informing the user or uploading to a server managed by the distro maintainers.
    The `abrt` system uses plug-ins that can monitor multiple types of crashes, such
    as process core dumps, Python, Java, Xorg, and others. During a forensic examination,
    you can check several directories for the existence of crash data handled by `abrt`,
    such as */var/spool/abrt/*, */var/spool/abrt-upload/*, and */var/tmp/abrt/*.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'The output differs depending on the crash information’s origin. The following
    is an example of core dump crash data stored in */var/spool/abrt/*:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Each of these files contain some information about the crashed process, including
    the reason for the crash, open files, environment variables, and other data. The
    `abrt` system is a competitor of `systemd-coredump` as a core-dump handler.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity from `abrt` is also logged in the systemd journal:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can find the abrt system’s configuration, actions, and plug-ins in the */etc/abrt/**
    directory. For more details, see the abrt(1) and abrtd(8) man pages. The abrt
    system has several man pages describing various parts of the system (from a Fedora/Red
    Hat Linux shell, enter apropos abrt for a list). The authoritative online documentation
    is available at *[https://abrt.readthedocs.io/en/latest/](https://abrt.readthedocs.io/en/latest/)*.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu-based systems have a daemon called Whoopsie (which sends data to a server
    called Daisy) and a handling system called `apport`. The `apport` program can
    manage crash data from core dumps, Python, package managers, and more (for more
    information, see *[https://wiki.ubuntu.com/Apport/](https://wiki.ubuntu.com/Apport/)*).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: When a process crashes, the core is sent to the `apport` program, which generates
    a report and saves it in */var/crash/*. The `whoopsie` daemon watches this directory
    for new crash data.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'On Ubuntu, you can find crash evidence in the journal and in a dedicated log,
    */var/log/apport.log*, as shown here:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The crash report is a normal text file located in the */var/crash/* directory:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This report contains various information about the crash, including base64-encoded
    core dump data. A unique identifier is stored in the */var/ lib/whoopsie/whoopsie-id*
    file. This is an SHA-512 hash of the BIOS DMI UUID (found with `dmidecode`). This
    string is sent to Ubuntu (Canonical) servers to distinguish between individual
    machines in their logs and statistics.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Desktop environments may handle crashed applications on their own. For example,
    you can invoke the KDE crash handler through libraries and
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: save crash information to files with the *.kcrash* extension. This can also
    generate a crash pop-up from `drkonqi` for the desktop user (Dr. Konqi is similar
    to Dr. Watson on Windows). See *[https://api.kde.org/frameworks/kcrash/html/namespaceKCrash.html](https://api.kde.org/frameworks/kcrash/html/namespaceKCrash.html)*
    and *[https://github.com/KDE/drkonqi/](https://github.com/KDE/drkonqi/)* for more
    information on KCrash and `drkonqi`. GNOME has similar functionality with `bug-buddy`.
    The `abrt` crash system can also support GNOME applications.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Distributions may implement their own crash and bug reporting mechanisms. For
    example, `mintreport` creates report files in */tmp/mintreport* about detected
    problems. These files contain information about the system (*/tmp/mintreport/inxi*)
    and a set of report subdirectories (*/tmp/mintreport/ reports/**). These directories
    each contain different reports in the form of Python scripts (**/MintReportInfo.py*).
    See the inxi(1) man page for more information on the `inxi` information gathering
    tool.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Crash reports are not only managed by the system or desktop environments. Applications
    can generate them, as well. This information is typically saved in the user’s
    home directory by user-run application processes. For example, Firefox will save
    crash data in the *~/.mozilla/firefox/Crash Reports/* subdirectory. This directory
    contains information about the reporting configuration (*crashreporter.ini*),
    a file with the time of last crash (*LastCrash*), and pending reports. The reports
    contain information saved by the application (Firefox, in this example). Other
    applications may manage their own crash logs and save data in the XDG base directories
    (*.cache/*, *.local/share/*, and *.config/*) in the user’s home.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '***Kernel Crashes***'
  id: totrans-292
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As we saw in the previous section, when a process crashes, only that process
    is affected. But when the Linux kernel (including kernel modules) crashes, the
    entire system is affected. A kernel crash can manifest itself as a panic or an
    oops. A *panic* is a condition in which the kernel is unable to continue and will
    halt or reboot the system. An *oops* will log error information to the ring buffer
    (which is captured and possibly saved by the journal or syslog), and the system
    will continue running. The system’s stability after an oops depends on the error,
    and a reboot may still be a good idea.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'A kernel may crash in the following situations:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Bugs in the kernel code (including drivers or modules)
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Severe resource exhaustion (out of memory)
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physical hardware problems
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Malicious activity affecting or targeting the kernel
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find a kernel oops in the systemd journal together with an `Oops` number
    like this:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output of a kernel oops is similar to a kernel warning message. The following
    is an example of a kernel warning that was observed in the systemd journal:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This shows a problem with the `amdgpu` kernel module ➊, but not one severe enough
    to cause a panic. The kernel logged information about the warning to the journal,
    including the CPU ➋, information about the kernel ➌ and hardware ➍, and a backtrace
    ➎. Aside from the log entry, this kernel warning didn’t write any crash dump data
    on the disk. A kernel setting `kernel` `.panic_on_oops` can tell the kernel to
    panic (and possibly reboot) whenever an oops occurs.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of kernel panic output to the console:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example, the panic was purposely generated (`echo c > /proc/sysrq` `-trigger`)
    and caused the system to halt immediately. The logs have no evidence of the crash
    because the kernel crashed before it could write anything.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: When performing a postmortem forensic examination of a Linux system, we are
    looking for evidence of a crash and any potential data saved from the crash. This
    data may give insight into the reason for crashing (stack trace, code that can
    be analyzed, and so on) and memory images can be forensically carved for file
    fragments and strings.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: A running kernel resides in volatile memory. When the kernel panics and halts
    or reboots, that memory is lost. For debugging purposes, the kernel developers
    created methods to save the contents of memory in the event of a kernel panic.
    We can use these methods as a form of forensic readiness, and configure them to
    preserve kernel memory as digital evidence.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Saving data from a crashed kernel is a chicken-or-egg problem. You need a functioning
    kernel to save the data, but a crashed kernel is not necessarily functional. Two
    software methods, `kdump` and `pstore`, attempt to solve this problem and preserve
    information after a kernel crash. Some hardware devices also use DMA to dump memory
    via PCI or Thunderbolt, but these are not Linux specific and thus not covered
    here.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: The `pstore` method (if enabled) saves trace and `dmesg` information from a
    crash for retrieval after a reboot. Several `pstore` “backends” can save information
    persistently after a crash. Storage on the mainboard firmware is possible using
    EFI variables or ACPI error serialization. Data can also be stored in a reserved
    area of RAM that remains untouched after a reboot, and local block devices (partition
    or disk) can be used. If storage size is limited, only things like the backtrace
    of a crash or the tail of `dmesg` are saved. On a running system, you can find
    this information in */sys/fs/pstore/* (for EFI, this is a decompressed representation
    of the corresponding variables in */sys/firmware/efi/efivars/*). Recent systemd
    versions (as of version 243) include the `systemd-pstore` service that copies
    `pstore` data to disk and clears the firmware storage so that it can be used again.
    It is stored in */var/lib/ systemd/pstore/* and should be checked during an examination.
    If the mainboard of the suspect machine is available, you can read the EFI variables
    and data separately.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: The `kdump` method employs a second kernel, loaded at boot time, that attempts
    to recover the memory of the first kernel when a crash occurs. Execution is handed
    over to the functional second kernel using `kexec` (part of the `kexec-tools`
    software package), which boots with a separate initrd capable of saving a full
    memory image to a predefined location. [Figure 4-3](ch04.xhtml#ch04fig03) is a
    visual description of this process.^([9](footnotes.xhtml#ch04foot_09))
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/ch04fig03.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Saving a kernel image with* kdump'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'A common place to save kernel memory images and other information from `kdump`
    is */var/crash/*. For example, a `kdump` crash directory from an Ubuntu system
    creates a timestamp subdirectory and looks like this:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this example, the */var/crash/202011150957/* directory contains the file
    `dmesg` output (text file) and the compressed kernel dump file, all with a timestamp
    as part of the filename. Other distros may use *vmcore* as a filename.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'Kernel dump images in */var/crash/* will likely be compressed. If you want
    to run carving tools, strings, or a hex editor against an image, it must be uncompressed
    first. You can copy the dump file to an analysis system and use the `makedumpfile`
    command to uncompress it:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, the resulting file is roughly the same size as the physical RAM of the
    system under examination (assuming that all memory pages were included at the
    time of dump).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: The `kdump` method was intended for debugging and doesn’t necessarily save the
    entire memory image. Developers are primarily interested in the kernel code and
    stack trace information, and the `makedumpfile` command may be configured to exclude
    certain memory pages. However, forensic examiners are interested in completeness,
    which includes the data and contents of all processes, even unused memory. When
    setting up `kdump` for evidence purposes (that is, forensic readiness), `makedumpfile`
    can be configured to save an entire memory image (using the `makedumpfile` flag
    `-d 0`). See the makedumpfile(8) and makedumpfile.conf(5) man pages for instructions
    on changing how kernel dump files are made.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use forensic carving tools (for strings or file fragments), a debugger
    like `gdb`, or a memory forensics tool like `Volatility` to analyze the uncompressed
    dump file. Here are some examples of information that you can retrieve from carving:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Files and file fragments
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EXIF data from media files
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Credit card numbers and track 2 information
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Domain names
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Email addresses
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IP addresses
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ethernet MAC addresses
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: URLs
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Telephone numbers
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom specified regex strings
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples of information that debuggers and memory forensic tools
    can extract:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Process list
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ARP table (MAC addresses and associated IPs)
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open files
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network interfaces
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network connections
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loaded kernel modules
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory-based Bash history
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suspicious processes
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cached TrueCrypt passphrase
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A full memory analysis using `gdb` or `Volatility` is beyond the scope of this
    book. However, enough information has been provided here to help you identify
    full kernel memory dumps if they reside on the disk. A free book titled *Linux
    Kernel Crash Book* (*[https://www.dedoimedo.com/computers/www.dedoimedo.com-crash-book.pdf](https://www.dedoimedo.com/computers/www.dedoimedo.com-crash-book.pdf)*)
    describes kernel crashing in more detail.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter covers the origin and current directory layout of a typical Linux
    system, highlighting the areas of interest to forensic investigators. It also
    describes the challenges of creating hashsets and the NSRL for free and open source
    software. After reading this chapter, you should be able to identify Linux file
    types and understand the difference between POSIX file types in the filesystem
    and application content file types. In addition, this chapter provides analysis
    of file metadata and content, including hidden files, executables, and files containing
    memory dumps. You now should have the foundation to explore userspace artifacts
    like logs, software installation, and other user-generated activity.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
