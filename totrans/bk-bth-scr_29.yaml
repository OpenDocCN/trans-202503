- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 26 AUTOMATIC RESTARTS AND MULTITHREADING
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 26 自动重启与多线程
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/chapter.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/chapter.jpg)'
- en: 'In this chapter, I’ll explore solutions to a couple of vexing issues for any
    coder: intermittent failures and hangs, specifically the type that usually execute
    successfully if restarted. I’ll detail how to automatically restart an intermittent
    failure of any process in a bat file. Hangs are a little trickier, but I’ll introduce
    a technique for terminating or killing the hung process before restarting it.
    For both types of issues, I’ll step through how to create a solution, including
    design considerations, specifications, coding, and even testing.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将探讨程序员常遇到的两个令人头疼的问题：间歇性故障和挂起，特别是那种通常在重启后可以成功执行的类型。我将详细介绍如何在批处理文件中自动重启任何进程的间歇性故障。挂起问题稍微复杂一些，但我会介绍一种在重启前终止或杀死挂起进程的技巧。对于这两种问题，我将一步步展示如何创建解决方案，包括设计考虑、规格、编码，甚至是测试。
- en: Along the way, I’ll introduce some interesting commands that have applications
    beyond automatic restarts. One puts a bat file to sleep for a defined period of
    time. Another one monitors all of the processes running on a computer (think of
    it as Task Manager inside a bat file). Yet another command terminates any specific
    process or multiple processes on a computer. Ultimately, this discussion will
    lead to the seemingly unrelated technique of multithreading or concurrency.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在过程中，我还会介绍一些有趣的命令，它们的应用不仅仅限于自动重启。其中一个命令可以让批处理文件在定义的时间段内“休眠”。另一个命令监控计算机上运行的所有进程（可以把它看作是批处理文件中的任务管理器）。还有一个命令可以终止计算机上的任何特定进程或多个进程。最终，这个讨论将引出一个看似无关的技巧——多线程或并发处理。
- en: Five Stages of Intermittent Failures
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 间歇性故障的五个阶段
- en: 'The bane of a coder’s existence is the intermittent failure. It might be a
    simple xcopy command that fails because of a temporary network or server communication
    issue. You might have to call a program written by someone else that sometimes
    fails to connect to a web service or simply fails for no apparent reason from
    time to time. Simply rerunning the process “fixes” the issue, but doing so wastes
    resources and causes delays. I’ve been involved in a number of these episodes,
    and every last one has followed these “Five Stages of Intermittent Failures” (loosely
    based on the “Five Stages of Grief”):'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员最头痛的事情之一就是间歇性故障。这可能是一个简单的xcopy命令，由于暂时的网络或服务器通信问题而失败。你可能需要调用一个由别人编写的程序，这个程序有时会因为无法连接到网络服务或莫名其妙地失败而无法正常运行。只需重新运行该进程就能“修复”问题，但这么做浪费了资源并造成了延迟。我曾参与过许多类似的情况，而且每次都遵循了这些“间歇性故障的五个阶段”（大致根据“悲伤的五个阶段”改编）：
- en: '**Stage 1: Denial**    “This looks like a fluke. I can’t find anything wrong.
    Just rerun it.”'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**第一阶段：否认**    “这看起来像是偶发的。我找不到任何问题。就重试一下吧。”'
- en: '**Stage 2: Anger**    The operator who’s tasked with tracking down and restarting
    the failures is peeved; the Batch coder who has no control over the network or
    the executable they’re invoking is cross; the mid-level manager with even less
    control is vexed. Each failure makes the situation worse until everybody is just
    plain angry.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**第二阶段：愤怒**    被分配负责追踪和重启故障的操作员感到恼火；没有控制网络或被调用的可执行文件的批处理程序员感到愤怒；控制更少的中层管理人员则感到烦躁。每一次故障都让情况变得更糟，直到每个人都怒不可遏。'
- en: '**Stage 3: Finger Pointing**    “It’s the fault of networking. Our servers
    are held together with duct tape and chicken wire.” “No, the vendor product is
    malfunctioning.” “No, your environment can’t support our product.” “It’s a problem
    with our internet provider.” “That guy who retired a couple of months ago left
    us with junk.”'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**第三阶段：指责**    “是网络的问题，我们的服务器是用胶带和铁丝连起来的。” “不，是供应商的产品出了问题。” “不，你的环境无法支持我们的产品。”
    “是我们互联网服务提供商的问题。” “那个几个月前退休的人留下的都是废品。”'
- en: '**Stage 4: Exploration**    A manager harrumphs, “I don’t want a Band-Aid.
    We need to find the root cause.” This is something everyone can agree on, because
    no one wants to be the lone member of the Band-Aid caucus—at least initially.
    Extra logging is put in place and diagnostic tools are installed on any piece
    of hardware that might be remotely involved in the issue. Different groups dive
    into their codebase and develop theories. Sometimes the root cause is found, sparing
    everyone the last stage, but more often than not the ghost in the machine remains
    an enigma.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**阶段 4：探索**    一位经理哼了一声，“我不需要创可贴，我们需要找到根本原因。”这是每个人都能认同的，因为没有人愿意成为创可贴派的唯一成员——至少最初是如此。额外的日志记录被启用，诊断工具被安装到任何可能与问题远程相关的硬件上。不同的团队深入到他们的代码库中并提出理论。有时根本原因被找到，从而避免了最后阶段，但更多时候，机器中的幽灵依然是一个谜。'
- en: '**Stage 5: Acceptance**    Finally heeding Voltaire’s proverb, “The best is
    the enemy of the good,” the Batch coder fixes the issue with an automatic restart
    of the suspect process.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**阶段 5：接受**    最终听从伏尔泰的格言：“最好的往往是敌人，好的。”Batch 编码员通过自动重启可疑进程解决了问题。'
- en: As long as one person holds onto the hope of finding the root cause, it’s difficult
    to move on to the final stage of acceptance. It might take days, weeks, or months,
    but when it becomes obvious that a root cause won’t be forthcoming or would be
    exceedingly expensive or difficult to fix, the only option is to attack the problem
    at its manifestation. Notice that in the fifth stage I didn’t put the word *fixes*
    in quotes. Some holdouts will still call it a Band-Aid or a work-around, but a
    well-designed automatic restart process will correct the problem so that no one
    will be bothered by it again. I call that a *fix*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 只要一个人坚持寻找根本原因，就很难进入最终的接受阶段。这可能需要几天、几周或几个月，但当显而易见地发现根本原因不会出现，或者修复起来异常昂贵或困难时，唯一的选择就是从问题的表现着手。请注意，在第五阶段，我没有把*修复*一词放在引号里。尽管有些坚持的人仍然会称之为创可贴或权宜之计，但一个设计良好的自动重启过程会解决问题，确保再也不会被打扰。我称之为*修复*。
- en: The timeout Command
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超时命令
- en: Before building an automatic restart, I’ll introduce a new command that’ll be
    very helpful in its design. Prior to initiating an automatic restart, I’ll want
    to put the bat file to sleep for a short period of time to allow any momentary
    server or connectivity issues to clear. Doing nothing is easy for humans; for
    some it’s our default state, but a computer program is designed to execute as
    fast as possible. Fortunately, Batch has given us the timeout command, possibly
    modeled after the timeout taken in sports or enforced upon a misbehaving youth.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建自动重启之前，我将介绍一个在设计中非常有用的新命令。在启动自动重启之前，我会希望将 bat 文件暂时睡眠一段时间，以便清除任何瞬时的服务器或连接问题。什么都不做对人类来说是容易的；对一些人来说，这是我们的默认状态，但计算机程序的设计目的是尽可能快速地执行。幸运的是，Batch
    提供了超时命令，这可能是模仿运动中暂停的概念，或者是对不听话的孩子强制执行的。
- en: 'It’s a simple command that accepts a single argument: the length of the timeout
    in seconds. This command will sleep for one minute:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的命令，接受一个参数：超时的长度，以秒为单位。这个命令将会睡眠一分钟：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Batch allows for a maximum timeout of 99,999 seconds, which translates to more
    than 27 hours. When this command is used interactively, the user sees a countdown
    on the console until processing resumes and has the option of pressing any key
    to end the timeout early and continue.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Batch 允许最大超时为 99,999 秒，这相当于超过 27 小时。当这个命令以交互方式使用时，用户会在控制台上看到一个倒计时，直到处理恢复，并且可以按任意键提前结束超时并继续。
- en: 'There are a couple of mild oddities with the timeout command. First, it accepts
    an argument of 0. This would make no sense as a hardcoded value, but consider
    this command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 超时命令有几个轻微的怪异之处。首先，它接受一个值为 0 的参数。作为硬编码值，这没有意义，但考虑一下这个命令：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you are determining the sleep time in the code, it offers an easy way of
    essentially turning off the command without wrapping it up in an if command. Set
    sleepSeconds to 300 for a five-minute break or to 0 if you want to skip the command.
    An argument of -1 results in an indefinite wait time until any key is pressed,
    which is really just a glorified pause command.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在代码中确定睡眠时间，它提供了一种简单的方式来实质上关闭命令，而无需用 if 命令包裹它。将 sleepSeconds 设置为 300 可以获得五分钟的休息，设置为
    0 则跳过命令。-1 的参数会导致无限等待，直到按下任意键，这实际上是一个华丽的暂停命令。
- en: The Automatic Restart
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动重启
- en: Let’s step through the process of building an automatic restart of some process
    that fails intermittently. Design considerations will inform the specifications
    that’ll lead to writing and testing the code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步分析构建一个自动重启的过程，该过程偶尔会失败。设计考虑因素将指导规格的制定，从而进行代码编写和测试。
- en: The Design Considerations
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设计考虑因素
- en: The basic concept of an auto-restart is straightforward. When any process generates
    a bad return code, the main logic normally aborts the execution in an orderly
    fashion. An auto-restart instead circles back and reruns the offending process.
    In Batch, that might sound like nothing more than an if command and a goto command,
    but the details quickly become involved and in need of a well-thought-out design.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 自动重启的基本概念很简单。当任何进程生成错误的返回码时，主逻辑通常会有序地中止执行。自动重启则会回到原点，重新运行出错的进程。在批处理（Batch）中，这可能听起来仅仅是一个if命令和一个goto命令，但细节很快就变得复杂，需要精心设计。
- en: Ideally the restart works, and the process continues to completion, but sometimes
    the auto-restart also fails, and if it continues to fail, the prospect of an endless
    loop mounts. Someone has to make a decision concerning the number of times to
    restart the process before conceding defeat and initiating an abort.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，重启会成功，过程会继续直到完成，但有时自动重启也会失败，如果继续失败，陷入无限循环的前景就愈加明显。必须有人决定在承认失败并启动中止之前，重启过程的次数。
- en: If a process fails without explanation one time in 100, the restarted process
    will likely fail one time in 100 as well. Basic probability theory dictates that
    if an event occurs once in 100 attempts, the odds are 1/100\. To find the odds
    of this randomly occurring twice in succession, the ratio is squared, giving us
    1/10,000\. Cubing the original odds gives us one chance in a million of the event
    occurring in three consecutive attempts. An exponent of five tells us that just
    one in 10 billion events should see this fail five straight times.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个进程在100次中无解释地失败一次，重启后的进程可能也会在100次中失败一次。基础概率理论表明，如果某个事件在100次尝试中发生一次，那么发生的概率是1/100。要找到这个事件连续两次随机发生的概率，比例需要平方，结果是1/10,000。将原始概率立方后，我们就得到三次连续尝试发生该事件的概率为1/1,000,000。指数为5时，意味着10亿次尝试中仅有一次会出现连续五次失败。
- en: This means that five or six attempts should get us to a point where the failures
    will realistically no longer happen if—and this is an enormous if—the one failure
    in 100 attempts is truly random.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，五到六次尝试应该能让我们达到一个实际的情况，即如果——这是一个巨大的如果——100次尝试中的一次失败真的是随机的，那么这些失败就不会再发生了。
- en: Oftentimes failures are not random, and that also factors into the design considerations.
    Failures might happen when a server or a database is busy during peak processing
    times. Occasionally, for no apparent reason two servers will lose connectivity
    for a split second or a couple of seconds or several minutes. If a copy from one
    of these boxes to another one fails, the next 10 auto-restarts might happen in
    less time than it takes you to read this sentence, meaning that all 10 happen
    during the window of lost connectivity. This isn’t random.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候失败并非随机发生，这也会影响设计考虑。失败可能发生在服务器或数据库在高峰处理期间很忙的时候。偶尔，两个服务器会在没有明显原因的情况下断开连接，可能是片刻、几秒钟或几分钟。如果从其中一台服务器到另一台服务器的复制失败，那么接下来的10次自动重启可能会在你读完这句话之前发生，意味着这10次都发生在连接丢失的窗口期内。这并不是随机的。
- en: For that type of failure, you’ll need more analysis. How long does it take for
    the issue to typically clear itself? In most situations, it’s best to go to sleep
    for a few seconds before the first auto-restart, as mentioned previously. After
    subsequent failures, we can initiate longer and longer wait times. If the issue
    typically clears in a minute, the total restart attempts should finish up in about
    three or four minutes, with the time frame adjusted from there.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种类型的失败，你需要进行更多的分析。问题通常需要多长时间才能自行解决？在大多数情况下，最好在第一次自动重启之前睡几秒钟，正如之前提到的那样。在随后的失败之后，我们可以设置越来越长的等待时间。如果问题通常在一分钟内清除，总的重启尝试应该在大约三到四分钟内完成，并且从那里调整时间框架。
- en: If this seems overwhelming, does it make sense to just go with hundreds of auto-restart
    attempts over the course of several hours? No, it doesn’t. If the auto-restart
    process makes an excessive number of attempts or if the sleep time between attempts
    is too great, the solution can become self-defeating. If a server loses connectivity
    at noon on a Friday, excessively generous auto-restarts might mask the problem
    until the evening. Processes might be hours behind schedule before anyone is even
    aware of the problem. A compromise is needed.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这一切看起来令人不知所措，那么是否有意义在几个小时内进行数百次自动重启尝试呢？不，没意义。如果自动重启过程尝试的次数过多，或者每次尝试之间的睡眠时间过长，解决方案反而会适得其反。如果一个服务器在周五中午失去连接，过于慷慨的自动重启可能会掩盖问题，直到晚上才被发现。处理过程可能会在几小时后才意识到问题，远远落后于预定计划。需要找到一个折衷方案。
- en: Another consideration is the nature of the failure. You should make every effort
    to differentiate between legitimate failures and restartable failures. If a program
    aborts because of a data condition that won’t differ on a restart, an auto-restart
    will simply be a waste of time and CPU cycles. Sometimes you can divine the nature
    of the error from the return code. If so, you can use it to determine the next
    course of action. If not, that also factors into the calculus; maybe you should
    attempt fewer restarts.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的因素是故障的性质。你应该尽力区分合法的失败和可重启的失败。如果一个程序因为数据条件导致中止，而这个数据条件在重启后不会发生变化，那么自动重启只会浪费时间和CPU周期。有时候，你可以通过返回代码推测错误的性质。如果可以，你可以根据返回代码来决定下一步行动。如果不能，这也会影响决策；也许你应该尝试减少重启次数。
- en: The Specifications
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 规格说明
- en: For this exercise, I’ll invent a scenario requiring an auto-restart and write
    some specifications with all of the just-considered design considerations in mind.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我将编造一个需要自动重启的场景，并在考虑到刚才讨论的所有设计要素后编写一些规格说明。
- en: A compiled executable communicating with a database on a remote server works
    great most of the time. It runs more than 30 times daily, but every three days
    or so it fails, returning an errorlevel of 7. The first few times it happened,
    someone restarted it, but a couple failures a week became a nuisance. Then a Sunday
    morning failure that went unnoticed until later in the week became a huge embarrassment
    for everyone involved. Something had to be done.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一个与远程服务器上的数据库通信的已编译可执行文件大多数时候运行良好。它每天运行超过30次，但大约每三天会发生一次故障，返回错误级别为7。最初几次发生时，有人重启了它，但每周几次的失败逐渐成为一种困扰。直到某个星期天早上的故障未被及时注意到，直到本周稍晚才成为了大家的巨大尴尬。必须采取一些措施了。
- en: The fictitious failure happens about once in every 100 attempts, which is fortuitous
    because I just did some math assuming that exact frequency. After we have gathered
    all of the statistics, some failures appear to be truly random, but the unexplained
    connectivity with the database seems to clear up in less than five seconds, so
    we won’t need long sleep times.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种虚拟故障大约每100次尝试发生一次，这其实是幸运的，因为我刚好进行了假设这种频率的数学计算。在收集了所有统计数据之后，某些失败似乎确实是随机的，但数据库连接问题似乎会在不到五秒钟内恢复，因此我们不需要很长的休眠时间。
- en: Fortunately, whoever wrote the executable did a good job with the return code.
    Other failures, such as the inability to find certain entries in the database,
    generate return codes other than 7, and a successful invocation always returns
    0.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，编写可执行文件的人在返回代码上做得很好。其他失败情况，比如无法在数据库中找到某些条目，返回的错误代码不是7，而成功调用则总是返回0。
- en: 'We now have what we need to write the specifications. The first one is obvious,
    but the other two require a little finesse, as you might come up with slightly
    different numbers:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了编写规格说明所需的所有信息。第一个规格是显而易见的，但另外两个需要一点技巧，因为你可能会得出略有不同的数字：
- en: 1.  Initiate an auto-restart if errorlevel is 7. Continue if 0, and abort for
    all other returned values.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  如果错误级别是7，则启动自动重启。如果是0，则继续；对于所有其他返回值，则中止。
- en: 2.  Attempt up to four auto-restarts for a total of five executions of the program,
    aborting after the fifth.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  尝试最多四次自动重启，总共执行五次程序，超过第五次则中止。
- en: 3.  Pause for 2 seconds after the first attempt and double it for each subsequent
    attempt, meaning that the wait times will be 2, 4, 8, and 16 seconds.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  第一次尝试后暂停2秒钟，之后每次尝试将暂停时间加倍，即等待时间将是2秒、4秒、8秒和16秒。
- en: After little more than 30 seconds (plus however long the executable runs), the
    fifth failure will initiate an abort. In an endeavor that is as much computer
    art as computer science, this should be a good compromise. Now, we’re ready to
    code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微超过30秒后（加上可执行文件运行的时间），第五次失败将触发中止。在计算机艺术与计算机科学同样重要的工作中，这应该是一个不错的折衷。现在，我们准备好编码了。
- en: The Auto-Restart Code
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自动重启代码
- en: '[Listing 26-1](#Lis26-1) meets the defined specifications. The only prerequisite
    to this code executing is that we must set the flakyExe variable to the program
    or process experiencing the intermittent failure.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 26-1](#Lis26-1)符合定义的规范。执行此代码的唯一前提是我们必须将flakyExe变量设置为正在经历间歇性故障的程序或进程。'
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 26-1: Code that initiates up to four auto-restarts of a flaky executable'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 26-1：启动最多四次自动重启不稳定可执行文件的代码
- en: In the first section of the code, the prompt command ❶ (introduced in [Chapter
    21](chapter21.xhtml)) embeds the time into the prompt string that’s prepended
    to each executed line in stdout, making it easier to verify that the process is
    pausing for the requisite amount of time. I define the variable for the sleep
    increment as 2 seconds and the variable for the maximum attempts as 5 attempts.
    I also initialize the attempt variable, which tracks the attempt being executed,
    to 0.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的第一部分，提示命令❶（在[第21章](chapter21.xhtml)中介绍）将时间嵌入到提示字符串中，该字符串会添加到stdout中每个执行的行之前，从而更容易验证进程是否暂停了所需的时间。我将休眠增量的变量定义为2秒，将最大尝试次数的变量定义为5次尝试。我还初始化了尝试变量，该变量跟踪正在执行的尝试，初始值为0。
- en: To add flexibility to the code, I use the technique of setting sleepIncrmt and
    maxAttempts only if they aren’t already defined. Much effort has been put into
    the specifications, but if the compromise between averting an abort and minimizing
    the time it takes to perform the auto-restarts isn’t quite right, a user can set
    these variables prior to calling this logic or set them globally on the computer.
    If one abort is still occurring each month, anyone can increase the sleep increment
    or the maximum attempts without changing this code, but I’ll assume the defaults
    for this exercise.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加代码的灵活性，我使用了仅在sleepIncrmt和maxAttempts尚未定义时才设置它们的技巧。尽管已经为规格付出了很多努力，但如果避免中止与最小化自动重启所需时间之间的折衷不完全合适，用户可以在调用此逻辑之前设置这些变量，或者在计算机上全局设置它们。如果每个月仍然发生一次中止，任何人都可以在不更改代码的情况下增加休眠增量或最大尝试次数，但为了本练习的方便，我将假设默认值。
- en: The logic proceeds past the :Restart label ❷ and increments the attempt variable
    to 1, before resolving flakyExe and thus executing the program. (In this exercise,
    the variable contains the flaky executable that’s failing, but this invocation
    could instead be an xcopy command to or from a remote server; it could be a call
    to a flaky bat file or whatever process might fail and need restarting.)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑继续经过:Restart标签❷并将尝试变量增加到1，然后解析flakyExe，从而执行程序。（在此练习中，变量包含正在失败的不稳定可执行文件，但此调用可以是向远程服务器的xcopy命令，也可以是对一个不稳定的bat文件或任何可能失败并需要重启的进程的调用。）
- en: I next evaluate the errorlevel the executable returned. If the code encounters
    the bad return code of 7 ❸, I look to see whether I’ve made the requisite 5 attempts
    ❹. Since this is the first attempt, the execution enters the code block ❺ and
    executes the timeout command to sleep for 2 seconds. Then I double the increment,
    sleepIncrmt, so that the process will sleep for 4 seconds if invoked again. Next,
    I break out of this logic, backward, via the goto command.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我评估可执行文件返回的错误级别。如果代码遇到错误返回码7❸，我检查是否已进行所需的5次尝试❹。由于这是第一次尝试，执行将进入代码块❺并执行timeout命令，休眠2秒钟。然后，我将休眠增量sleepIncrmt加倍，以便如果再次调用该进程时，进程将休眠4秒钟。接下来，我通过goto命令向后跳出此逻辑。
- en: This brings us back to the :Restart label ❷ that the execution processed past
    just a moment ago. Here’s a great application of the do...while command from [Chapter
    9](chapter9.xhtml). Notice the strategic placement of the label. I increment the
    total number of attempts to 2 after invoking the first restart and then execute
    the flaky process again.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这将我们带回到刚刚执行过的:Restart标签❷。这是[第9章](chapter9.xhtml)中do...while命令的一个很好的应用。注意标签的战略性放置。在调用第一次重启后，我将总尝试次数增加到2，然后再次执行不稳定的进程。
- en: If 7 is again the return code ❸, the same process executes another restart,
    this time upping attempt to 3, which is still less than 5 ❹. Back in the code
    block ❺ and after taking the four-second timeout, I double the sleep increment
    to 8 and return again to the :Restart label ❷.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果返回码是 7 ❸，相同的过程将执行另一次重启，这次尝试次数增加到 3，仍然小于 5 ❹。回到代码块 ❺ 并在等待四秒超时后，我将睡眠时间增量加倍至
    8，然后再次返回到 :Restart 标签 ❷。
- en: If this fails four times, I’ll sleep for 16 seconds ❺ and make one last attempt.
    If this also fails, attempt resolves to 5 and is no longer less than the target
    value in maxAttempts ❹, so the code will abort via the :Abort routine ❻ that isn’t
    shown.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这失败了四次，我将睡眠 16 秒 ❺ 并进行最后一次尝试。如果这次也失败，则尝试次数变为 5，并且不再小于 maxAttempts 中的目标值 ❹，因此代码将通过未显示的
    :Abort 程序 ❻ 中止。
- en: We need to think like the interpreter for two more scenarios. You already know
    what happens when errorlevel is 7. Now imagine that the flaky process returns
    anything but 0 or 7. The else if clause, %errorlevel% neq 0, is true, and the
    code invokes the :Abort routine ❼.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要像解释器一样思考另外两种情况。你已经知道错误级别为 7 时会发生什么。现在想象一下，那个不稳定的进程返回的不是 0 或 7。else if 子句
    %errorlevel% neq 0 为真，代码会调用 :Abort 程序 ❼。
- en: As the final scenario, imagine that 0 is the return code. This is the only possible
    way to get to the code block ❽ after the default else clause that verifies that
    the execution was successful.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的情况是，假设返回码为 0。这是到达代码块 ❽ 的唯一可能途径，在默认的 else 子句之后，它验证执行是否成功。
- en: The abort routine should distinguish between the two types of aborts. One failed
    after multiple auto-restarts ❻, and the other failed due to something unrelated
    to the restarts ❼ after just a single failure.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 中止程序应区分两种类型的中止。一种是在多次自动重启后失败 ❻，另一种则是在仅发生一次失败后，由与重启无关的原因导致的失败 ❼。
- en: The Testing
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试
- en: 'This is clearly some advanced Batch coding, but after you’ve grasped the concept
    and coded up something such as what’s in [Listing 26-1](#Lis26-1), what might
    seem like an even more difficult task awaits: testing. If you run this code 100
    times, you’re likely to see at least one failure, but there’s still a better than
    one chance in three of seeing no failures at all. Billions of executions wouldn’t
    even guarantee seeing five failures. (Look up the Poisson distribution if you’re
    curious about the math.)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是一些高级的批处理编码，但在你掌握了这个概念并编写了类似[Listing 26-1](#Lis26-1)中的代码后，可能看起来更难的任务会随之而来：测试。如果你运行这段代码
    100 次，你可能会看到至少一次失败，但仍然有超过三分之一的概率完全没有失败。即使执行十亿次，也不能保证看到五次失败。（如果你对数学感兴趣，可以查阅泊松分布。）
- en: 'We need a means of simulating the failure, and entering this command prior
    to [Listing 26-1](#Lis26-1) will do exactly that:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种模拟故障的方法，在[Listing 26-1](#Lis26-1)之前输入此命令将实现这一目的：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When the interpreter resolves flakyExe in the code, the cmd command (introduced
    in [Chapter 21](chapter21.xhtml)) executes, running the exit command that sets
    errorlevel to 7. If the main logic was coded correctly, this’ll trigger an auto-restart,
    and then it’ll repeat the same process a total of five times before aborting.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当解释器解析代码中的 flakyExe 时，cmd 命令（在[第 21 章](chapter21.xhtml)中介绍）执行，运行 exit 命令，将 errorlevel
    设置为 7。如果主逻辑编写正确，这将触发自动重启，然后它将重复相同的过程，总共进行五次后中止。
- en: After you are satisfied with that testing, change exit 7 to exit 4 and run it
    again; expect to see a different abort, one that doesn’t invoke a restart. Change
    it again to exit 0, and you should see a successful run (or at least a simulated
    successful run).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在你对测试结果满意后，将 exit 7 改为 exit 4，并重新运行；预期会看到一个不同的中止，且不会触发重启。再将其更改为 exit 0，你应该看到一个成功的运行结果（或至少是一个模拟的成功运行）。
- en: 'An ideal test might invoke two auto-restarts after two failures return 7 and
    then succeed with a return code of 0 on the third call. You could replace the
    cmd command in this setting with a call command of a simple bat file containing
    some conditional logic to set the return code based on the attempt being executed.
    Better yet, just use this setting:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 理想的测试可能在两次失败后触发两次自动重启，返回码为 7，然后在第三次调用时成功，返回码为 0。你可以在此设置中将 cmd 命令替换为一个简单的 bat
    文件调用命令，该文件包含一些条件逻辑，根据正在执行的尝试来设置返回码。更好的是，直接使用此设置：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you learned in [Chapter 14](chapter14.xhtml), I escape the exclamation marks
    so they’ll be stored in the variable. Then when the code resolves flakyExe, the
    value contained in the attempt variable will be part of the conditional clause.
    It’ll be true the first two times it executes, resulting in a return code of 7;
    then on the third execution, the conditional clause will be false. Hence, the
    return code will be 0. I recommended against messy if commands like this in [Chapter
    4](chapter4.xhtml), but it’s perfect for this type of testing.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在[第14章](chapter14.xhtml)中所学，我会转义感叹号，以便它们能存储在变量中。然后，当代码解析flakyExe时，attempt变量中包含的值将成为条件子句的一部分。它将在前两次执行时为真，导致返回代码为7；然后在第三次执行时，条件子句将为假。因此，返回代码将为0。我在[第4章](chapter4.xhtml)中曾建议避免像这样的混乱if命令，但它非常适合这种类型的测试。
- en: The Central Log
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 中央日志
- en: The previous example is stripped down and perfectly functional, but when actually
    implemented, another key feature is a central log of each auto-restart. When this
    process completes, we can interrogate attempt; anything greater than 1 means that
    the code executed at least one auto-restart. With this information we can write
    a timestamped entry to a logfile with details about the auto-restart, especially
    the number of attempts.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子已经简化并且完全可用，但在实际实施时，另一个关键特性是每次自动重启的中央日志。当此过程完成时，我们可以查询attempt；任何大于1的值都意味着代码至少执行了一次自动重启。通过这些信息，我们可以将带有时间戳的条目写入日志文件，记录有关自动重启的详细信息，尤其是尝试次数。
- en: You might become a victim of your own success if the auto-restart completely
    masks the failures. There’s still an underlying and unresolved issue, so it’s
    important to keep a record of the aborts avoided. After a month, you can use the
    log to definitively state that some number of processes would have aborted without
    the auto-restart. It might be just two or three or a dozen or maybe hundreds.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果自动重启完全掩盖了故障，你可能会成为自己成功的受害者。依然存在一个潜在的未解决问题，因此，保持已避免的中止记录很重要。一个月后，你可以利用日志明确说明没有自动重启的情况下，某些进程会中止。可能只有两三个，也可能是十几个，甚至几百个。
- en: Whatever the number, you can use this log as a testament to the successful implementation
    of the auto-restart process. It’ll also monitor the underlying root problem. The
    frequency of the issue might decrease or vanish after the installation of new
    hardware, or it might happen more as existing hardware ages. This information
    can help determine the urgency of a solution targeting the root cause. (It may
    also be hard numbers for your annual review.)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 无论数字是多少，你都可以使用这个日志作为自动重启过程成功实施的证明。它还将监控潜在的根本问题。问题的频率可能在安装新硬件后减少或消失，或者随着现有硬件的老化而发生得更多。这些信息有助于确定针对根本原因解决方案的紧迫性。（它也可能成为你年度评估中的硬性指标。）
- en: Hangs
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挂起
- en: I’ve discussed automatically restarting a failed process that returns a certain
    value or set of values for errorlevel. An even bigger challenger is a hang; a
    *hang* occurs when a called process fails to terminate and never returns a value
    for errorlevel—even worse, hangs never return control to the Batch code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经讨论过自动重启失败的进程，它返回特定的值或错误级别值的集合。一个更大的挑战是挂起；*挂起*发生在一个调用的进程未能终止且永远不返回错误级别的值——更糟糕的是，挂起从不将控制权交回批处理代码。
- en: A hang can be the result of an endless loop that would happen again on a restart,
    but sometimes a faulty process will hang when a connection drops or it can’t find
    a resource. In short, if you can go into Task Manager, kill the hung process,
    restart it, and have it process successfully with no other intervention, then
    the process is a great candidate for an automatic kill and restart.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 挂起可能是由于一个无限循环造成的，该循环在重启时会再次发生，但有时当连接断开或无法找到资源时，一个有缺陷的进程也会挂起。简而言之，如果你可以进入任务管理器，杀死挂起的进程，重启它，并且它能够在没有其他干预的情况下成功处理，那么该进程就是一个非常适合自动终止和重启的候选者。
- en: 'But any auto-kill-and-restart process has one major obstacle. An auto-restart
    is fairly straightforward in concept. When you get back certain bad return codes,
    you simply invoke the restart logic. But with a hang, the Batch code is, well,
    hanging. The process has taken its ball home and promised never to share it again.
    By definition, a hang will not return control to the Batch code, so the bat file
    that called it can’t do anything, much less kill and restart the process. But
    there’s always a way: something or someone must kill the hung process. Hence,
    the coder must anticipate and code for the possibility of a hang.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 但任何自动杀死并重启进程的过程都面临一个重大障碍。自动重启在概念上是相当直接的。当你收到某些错误的返回代码时，你只需调用重启逻辑。但在挂起的情况下，Batch
    代码是……挂起的。进程已经“拿着球回家”，并承诺再也不与任何人分享它了。根据定义，挂起不会将控制权交还给 Batch 代码，因此调用它的 bat 文件无法执行任何操作，更不用说杀死并重启该进程了。但总是有办法的：必须有某个东西或某个人来杀死挂起的进程。因此，程序员必须预见到并为挂起的可能性进行编码。
- en: To accomplish this, we’ll need some important commands that aren’t in an everyday
    bat file. The start command (detailed in [Chapter 10](chapter10.xhtml)) will spawn
    a second command window that’ll actually run the process that might hang. The
    tasklist command will monitor the spawned bat file that may possibly hang, and
    the taskkill command will ... I think this one is self-explanatory.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个任务，我们需要一些在日常 bat 文件中没有的命令。start 命令（详见[第10章](chapter10.xhtml)）将打开一个第二个命令窗口，实际运行可能会挂起的进程。tasklist
    命令将监控可能挂起的 bat 文件，而 taskkill 命令则...我想这个命令就不需要解释了。
- en: Just listing these commands sketches out the broad underpinnings of the plan,
    but before getting into details, I must properly introduce these two new commands.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅列出这些命令大致勾画了计划的框架，但在深入细节之前，我必须正式介绍这两个新命令。
- en: Retrieving a List of Processes
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检索进程列表
- en: 'The tasklist command provides much of the information that you can find on
    a Windows machine “manually” with Task Manager. It retrieves a list of all or
    some of the current processes running on a machine. We’ll be using it in a bat
    file, but first bring up a command prompt and type tasklist and you’ll get a list
    of everything running on the machine, including the memory usage, session information,
    and process indicator (PID). Scores of processes will be running at any given
    time, but here’s an example of just a few rows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: tasklist 命令提供了你可以通过任务管理器在 Windows 机器上“手动”获取的大部分信息。它检索当前在机器上运行的所有或部分进程列表。我们将在
    bat 文件中使用它，但首先打开命令提示符并输入 tasklist，你将获得一份正在机器上运行的所有程序的列表，包括内存使用情况、会话信息和进程标识符（PID）。在任何给定时间，成百上千的进程会在运行，但以下是其中几行的示例：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The PID is a number that the operating system assigns to a process when its
    execution starts. The System Idle Process is always running, and its PID is always
    0; System usually runs with a PID of 4 or 8, depending on the operating system,
    and all other processes are assigned a unique number divisible by 4\. At some
    point PIDs are reused, but not until thousands of different processes have run
    on the machine. The tasklist command displays each executing bat file with an
    image name of *cmd.exe* as seen in the fourth and final entry.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: PID 是操作系统在进程执行开始时分配给该进程的一个数字。系统空闲进程始终在运行，其 PID 始终为 0；System 通常使用 PID 4 或 8，具体取决于操作系统，所有其他进程都会分配一个可以被
    4 整除的唯一数字。PID 会在某个时刻重新使用，但直到机器上运行了成千上万的不同进程之后才会发生。tasklist 命令显示每个执行中的 bat 文件，其映像名称为
    *cmd.exe*，如第四行和最后一行所示。
- en: The command has some very useful parameters. When parsing through the output
    of the command (which we’ll be doing shortly), we’ll want to avoid the first two
    header lines of the output. The /NH option (for *no headers*) removes the first
    line of header information as well as the cosmetic second line of equal signs.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令具有一些非常有用的参数。在解析命令输出时（我们很快会这么做），我们需要避免输出的前两行标题信息。/NH 选项（表示 *no headers*）会移除第一行标题信息，以及第二行的装饰性等号。
- en: The /FO option (for *format*) alters the presentation of the data. The available
    formats are comma-delimited (/FO:CSV), list (/FO:LIST), and table (/FO:TABLE),
    which is also the default shown in the sample output.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: /FO 选项（表示 *format*）会改变数据的显示格式。可用的格式有逗号分隔（/FO:CSV）、列表（/FO:LIST）和表格（/FO:TABLE），后者也是示例输出中显示的默认格式。
- en: 'The /FI option will *filter* out unwanted entries or include only wanted entries.
    You can include or exclude certain window titles or build filters involving the
    CPU time, PID, image name, and more. For example, the following command brings
    up all instances of Notepad++ running on a machine:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: /FI选项将*过滤*掉不需要的条目或仅包含所需的条目。你可以包括或排除某些窗口标题，或者构建涉及CPU时间、PID、镜像名称等的过滤器。例如，以下命令列出机器上所有正在运行的记事本++实例：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: (Please don’t ask why this option uses the equality operator eq instead of equ,
    but it does.)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: （请不要问为什么这个选项使用等号操作符eq而不是equ，但它确实是这样。）
- en: 'Using the wildcard (*) brings up all instances of Notepad, Notepad++, and anything
    else that might start with those seven letters:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用通配符(*)会列出所有记事本、记事本++以及可能以这七个字母开头的任何其他程序：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following command uses the greater-than operator to display all processes
    currently being memory hogs:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令使用大于符号来显示当前占用大量内存的所有进程：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Use the help for more details on the /FI option; what I’ve shown here is just
    a sampling of the operands and operators.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用帮助命令查看更多关于/FI选项的详细信息；我展示的只是操作符和操作数的一部分。
- en: Killing Processes
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 终止进程
- en: 'The taskkill command can terminate a specific process or several at one time.
    Some of its parameters are shared with the tasklist command, most important, the
    /FI option. The following command attempts to kill all instances of Notepad running
    on a machine:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: taskkill命令可以一次终止一个或多个特定进程。它的一些参数与tasklist命令共享，最重要的是/FI选项。以下命令尝试终止机器上所有正在运行的记事本实例：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This command tries to close all opened Notepad files, immediately doing so for
    all that are saved. Notepad generates a pop-up window for all unsaved work, kindly
    asking the user to save the file, but the /F option *forcefully* kills the processes.
    Using the option will unapologetically terminate the processes unsaved. The /T
    option kills not only a process but also any processes that it may have started.
    Before long, we’ll kill the spawned bat file with both of these options to ensure
    that it, and everything associated with it, is truly terminated.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令尝试关闭所有打开的记事本文件，对于所有已保存的文件，立即执行此操作。对于所有未保存的文件，记事本会生成一个弹窗，友好地提示用户保存文件，但/F选项会*强制*终止进程。使用此选项会毫不留情地终止未保存的进程。/T选项不仅会终止一个进程，还会终止它可能启动的任何进程。很快，我们将使用这两个选项来终止生成的bat文件，以确保它及其相关的所有进程都被真正终止。
- en: 'Used with the /PID option, the taskkill command terminates one or more specific
    processes based on the process indicator. For instance, this’ll terminate two
    processes:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 与/PID选项一起使用时，taskkill命令基于进程指示符终止一个或多个特定进程。例如，以下命令会终止两个进程：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can also forcefully kill processes with very specific window titles. (Foreshadowing
    isn’t just for fiction.)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过非常具体的窗口标题强制终止进程。（预示并不仅仅是小说中的技巧。）
- en: The Automatic Kill and Restart
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动关闭与重启
- en: Just as we did with the automatic restart, let’s step through the building of
    an automatic kill and restart of a process prone to occasional hangs, including
    design, specifications, coding, and testing.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们进行自动重启一样，让我们逐步构建一个自动杀死并重启偶尔会挂起的进程的过程，包括设计、规格、编码和测试。
- en: In this fictitious scenario, the flaky executable will continue to work perfectly
    well 99.9 percent of the time, but one time in 1,000 it hangs. We know that the
    root cause isn’t a simple endless loop, because we can manually kill and restart
    it and see it run successfully. The team theorizes about how interacting with
    the database could cause the problem, or maybe it has nothing to do with the database.
    It happens so infrequently, it’s nearly impossible to troubleshoot, but it happens
    frequently enough to be a problem, and no one can find the root cause.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个虚构的场景中，那个不稳定的可执行文件99.9%的时间会完美运行，但每千次中有一次会挂起。我们知道根本原因不是一个简单的死循环，因为我们可以手动终止并重启它，并且看到它成功运行。团队推测与数据库的交互可能会导致问题，或者也许与数据库无关。它发生得如此罕见，几乎无法进行故障排除，但发生得足够频繁，成为一个问题，并且没人能找到根本原因。
- en: After cycling through the five stages, we’ve decided to fix the issue with an
    auto-kill-and-restart. We’ll put the call to the offending process into a dynamically
    created bat file and spawn it in lieu of calling the process directly. The spawned
    process will execute completely independently of the main bat file, which will
    then monitor the spawned bat file, killing and restarting it if we determine that
    it’s hung.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在经历了五个阶段之后，我们决定通过自动终止并重启来修复问题。我们将把有问题的进程调用放入一个动态创建的 bat 文件中，并生成它来代替直接调用该进程。生成的进程将完全独立于主
    bat 文件执行，然后主文件会监控生成的 bat 文件，如果检测到挂起，则会终止并重启它。
- en: The Design Considerations
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设计考虑因素
- en: By far the trickiest part of the design is determining exactly how long to wait
    for the executable to finish up before assuming a hang. How long does it typically
    take? What’s the maximum time that it can take when there isn’t a hang? Is the
    execution time consistent, or does it fluctuate? If it fluctuates, can we predict
    it by the size of an input file, or is it more random? If a process typically
    takes 3 or 4 minutes to execute, it’s reasonable to set the maximum execution
    time to 10 minutes. But this will kill and restart a particularly slow-running
    execution that needs 10 minutes and a second to complete just as it’s about to
    finish up.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 设计中最棘手的部分无疑是确定在假设挂起之前，究竟应该等多长时间让执行文件完成。通常需要多长时间？在没有挂起的情况下，最大时间是多少？执行时间是一致的吗，还是会波动？如果波动，我们能否根据输入文件的大小预测，还是完全随机的？如果一个进程通常需要
    3 或 4 分钟来执行，将最大执行时间设置为 10 分钟是合理的。但这将会终止并重启一个特别慢的执行，导致它刚好在完成之前被终止，完成时需要 10 分钟零一秒。
- en: We must complete a great deal of analysis before settling on a length of time.
    I usually set this to be three times the length of time of a typical run if the
    execution times are fairly consistent. If the execution time is dictated by an
    input file size, you can wait longer for larger files. If the execution times
    seem to be random, add even more time, but don’t make the maximum time so long
    that it’s self-defeating.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定时间长度之前，我们必须进行大量分析。如果执行时间比较一致，我通常将其设置为典型运行时间的三倍。如果执行时间由输入文件的大小决定，对于较大的文件可以等待更长时间。如果执行时间看起来是随机的，可以增加更多的时间，但不要设置过长的最大时间，以免适得其反。
- en: The number of attempted restarts before aborting is another factor you must
    determine. The same considerations that applied with the auto-restart process
    also apply here. In short, how frequent and random are the hangs?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在放弃之前尝试重启的次数是你必须确定的另一个因素。与自动重启进程时应用的相同考虑因素同样适用于这里。简而言之，挂起的频率和随机性有多大？
- en: An additional design consideration of a proposed auto-kill-and-restart is how
    often to check the status of the spawned bat file. If a process usually takes
    3 or 4 minutes and the maximum execution time is set at 10 minutes, it doesn’t
    make sense to wait the full 10 minutes before checking on it. We can check on
    it every 15 seconds; if it’s done, we can move on without waiting any longer;
    if it isn’t done, we can wait another 15 seconds for up to a total of 10 minutes.
    It’s important to note that the interval selected is the maximum amount of time
    that we might add to any one execution.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 提议的自动终止并重启设计的另一个考虑因素是检查生成的 bat 文件状态的频率。如果一个进程通常需要 3 或 4 分钟，而最大执行时间设置为 10 分钟，那么在检查之前等满
    10 分钟是没有意义的。我们可以每 15 秒检查一次；如果完成了，我们可以继续，不用再等；如果没有完成，我们可以再等 15 秒，最多等到 10 分钟。需要注意的是，所选的间隔是我们可能在单次执行中增加的最大时间。
- en: The Specifications
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 规范
- en: Continuing with this imagined scenario, the executable typically runs in 10
    or 20 seconds. After much testing, even concurrent testing, 35 seconds is the
    maximum runtime we’ve observed. A reasonable maximum wait time seems to be 60
    seconds; it’s three times longer than a typical long execution and comfortably
    exceeds the longest observed execution time.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 继续这个假设的场景，执行文件通常在 10 或 20 秒内完成。经过大量测试，甚至是并行测试，我们观察到的最大运行时间是 35 秒。一个合理的最大等待时间似乎是
    60 秒；这是典型长时间执行的三倍，并且轻松超过了观察到的最长执行时间。
- en: Checking the spawned bat file every 10 seconds seems to make sense. A quick
    run will finish up just before the first check, most others will be done by the
    second check, and all but a few will be completed by the third, which will add
    no more than 10 seconds to any execution compared to a direct call of the flaky
    executable.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 每隔10秒检查一次生成的bat文件似乎是合理的。一次快速运行将在第一次检查前完成，大多数其他任务将在第二次检查时完成，所有任务中只有少数将在第三次完成，相较于直接调用不稳定的可执行文件，这种方式最多会增加10秒的执行时间。
- en: A total of four attempts before aborting should also work. Since it fails once
    in 1,000 attempts, four completely random failures would happen once in a trillion
    attempts. This might sound like overkill, but we’ve observed multiple hangs at
    roughly the same time, meaning that these failures aren’t truly random. They might
    be happening during a period of lost connectivity.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 总共四次尝试后再中止应该也能奏效。因为它每1000次尝试中会失败一次，四次完全随机的失败在万亿次尝试中才会发生一次。听起来这可能是过度的，但我们已经观察到多个几乎同时发生的卡死，这意味着这些失败并非完全随机。它们可能发生在网络连接丢失的时期。
- en: At worst, four failed attempts will take a little over four minutes before we
    initiate an abort. This process aims to mitigate the threat of a hang in as short
    of a timeframe as possible. As with the auto-restart, there is an art to these
    specifications. Reasonable co-workers might want longer or shorter wait times,
    or more or fewer restarts.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最糟的情况是，四次失败的尝试将耗时略多于四分钟，然后我们会启动中止操作。这个过程旨在尽可能在短时间内减轻卡死的风险。就像自动重启一样，这些规格的制定也有一定的艺术性。合理的同事可能希望设置更长或更短的等待时间，或者更多或更少的重启次数。
- en: The Core Auto-Kill-and-Restart Logic
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 核心自动杀死与重启逻辑
- en: Before sharing the code, I’ll discuss the process that’s at the heart of this
    entire enterprise—the spawning, tracking, and possible killing of a second bat
    file.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在分享代码之前，我会讨论这个整个过程的核心——生成、跟踪和可能终止第二个bat文件的过程。
- en: At a very high level, I’ll launch the spawned bat file via the start command,
    not the call command, so that the two bat files will execute independently. The
    spawned bat file will change its title to some unique text also known to the main
    process. This’ll allow the main process to track or monitor the spawned bat file
    with the tasklist command, and if it’s taking an excessive amount of time to finish
    up, we’ll kill it with the taskkill command. Then we’ll spawn the dynamically
    created bat file again, monitor it again ... and possibly kill it again.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，我将通过`start`命令启动生成的bat文件，而不是使用`call`命令，这样两个bat文件就会独立执行。生成的bat文件会将其标题更改为一些主进程也知道的唯一文本。这将使得主进程能够通过`tasklist`命令跟踪或监视生成的bat文件，如果它花费的时间过长，我们将使用`taskkill`命令将其终止。然后我们会再次生成这个动态创建的bat文件，再次监控它……并可能再次终止它。
- en: In [Chapter 15](chapter15.xhtml), I introduced the title command to change the
    title displayed in the top-left corner of the command window when we ran an interactive
    bat file. It never hurts to title the command window so that we humans can differentiate
    one window from another, but the uses of the title command go beyond cosmetic.
    I’ll use it here to attach a tracking device.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第15章](chapter15.xhtml)中，我介绍了`title`命令，用来更改我们运行交互式bat文件时在命令窗口左上角显示的标题。为命令窗口命名总是有益的，这样我们可以区分不同的窗口，但`title`命令的用途不仅仅是外观上的。我将在这里使用它来附加一个跟踪设备。
- en: Just as marine biologists might attach an electronic tracking device to the
    shell of a sea turtle, we’ll attach a tracking device to the spawned bat file.
    The biologist uses satellite telemetry to track the sea turtle’s movements for
    many years throughout the world’s oceans and beaches, following them as they mate,
    forage, and lay eggs. Our goal is less ambitious; we’re simply tracking the life
    of an executing bat file on one machine.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 就像海洋生物学家可能会在海龟的壳上安装电子跟踪设备一样，我们也会为生成的bat文件附加一个跟踪设备。生物学家利用卫星遥感追踪海龟在全球海洋和海滩上的运动，追踪它们交配、觅食和产卵的过程。我们的目标则没那么宏大；我们只是简单地跟踪在一台机器上执行的bat文件的生命周期。
- en: 'If the title command attaches the tracking device, then the tasklist command
    is analogous to the satellite tracking the sea turtle. In the main bat file, the
    tasklist command will use the same unique title used by the title command in the
    spawned bat file. The following command will track the spawned bat file with the
    unique title contained in the uniqTitle variable:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`title`命令附加了跟踪设备，那么`tasklist`命令就类似于卫星追踪海龟。在主bat文件中，`tasklist`命令将使用生成的bat文件中`title`命令所用的相同唯一标题。以下命令将使用`uniqTitle`变量中包含的唯一标题来跟踪生成的bat文件：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The /FI option allows us to filter on many different characteristics of the
    various processes running on a machine. For example, the ImageName of the spawned
    bat file will be *cmd.exe*, but this is true of all bat files, including the main
    bat file doing the tracking, so that’s of no use here. But filtering on the WindowTitle
    will return the one and only process with that title. (For this reason, it’s critical
    that the unique title truly be unique in this design.)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: /FI 选项允许我们根据机器上运行的各种进程的不同特征进行筛选。例如，生成的 bat 文件的 ImageName 将是 *cmd.exe*，但这对于所有
    bat 文件（包括进行跟踪的主 bat 文件）来说都是正确的，因此在这里并无用处。但筛选 WindowTitle 将返回唯一的一个具有该标题的进程。（因此，在这种设计中，确保唯一标题的确具有唯一性至关重要。）
- en: 'The /NH option gets rid of those pesky headers, so if the spawned bat file
    is running when the previous command executes, it will return something such as
    this to stdout:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: /NH 选项去除了那些讨厌的标题，因此如果在执行前一个命令时生成的 bat 文件正在运行，它将向 stdout 返回类似如下内容：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This shows the image name, PID, session name, session number, and memory usage.
    We aren’t interested in most of this information, but we do care about how this
    entry contrasts to what this command returns if the process isn’t running:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了镜像名称、PID、会话名称、会话编号和内存使用情况。我们对大多数信息不感兴趣，但我们确实关心的是这个条目与该进程未运行时该命令返回的内容的对比：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The obvious differences will tell us whether the spawned bat file is still running.
    A for /F command can pull out the first token for interrogation; if it’s *cmd.exe*,
    the bat file with the unique title is running, and if it’s INFO:, nothing with
    the title is running.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 显而易见的区别会告诉我们生成的 bat 文件是否仍在运行。可以使用 for /F 命令提取第一个标记进行检查；如果是 *cmd.exe*，则带有唯一标题的
    bat 文件正在运行；如果是 INFO:，则没有带有该标题的进程在运行。
- en: 'After taking great care to positively identify the hung process, the following
    taskkill command will kill or terminate it with surgical precision. Using the
    same /FI option looking for the same WindowTitle from the tasklist command ensures
    that we don’t overreach and kill anything else:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在小心地确认挂起的进程后，以下 taskkill 命令将以精准的方式终止它。使用相同的 /FI 选项，并查找来自 tasklist 命令的相同 WindowTitle，确保我们不会过度操作并杀死其他进程：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The /F and /T options will forcefully kill the spawned bat file and any child
    processes that it might have initiated.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: /F 和 /T 选项会强制终止生成的 bat 文件及其可能启动的任何子进程。
- en: By the way, this is where I end my sea turtle analogy. We don’t want to harm
    sea turtles in any way. They’re some of the most beautiful and fascinating animals
    in existence, other than bats, of course.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，这就是我结束海龟类比的地方。我们不想以任何方式伤害海龟。它们是世上最美丽、最迷人的动物之一，当然，蝙蝠除外。
- en: Now let’s put this all together.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们把这一切结合起来。
- en: The Auto-Kill-and-Restart Code
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自动终止并重启代码
- en: '[Listing 26-2](#Lis26-2) is clearly one of the most complex in the book, but
    even so I’ve stripped it down of most error handling and used hardcoded values
    that really should be parameterized. I’ll address these concerns a bit later,
    but [Listing 26-2](#Lis26-2) meets all of the specifications assuming that flakyExe
    is assigned the executable that occasionally hangs.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 26-2](#Lis26-2)显然是书中最复杂的代码之一，但即便如此，我已经去除了大部分错误处理，并使用了硬编码的值，这些值实际上应该被参数化。我稍后会讨论这些问题，但假设
    flakyExe 被分配给偶尔挂起的可执行文件，[清单 26-2](#Lis26-2) 满足所有规格。'
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 26-2: Code that initiates up to three auto-kill-and-restarts of a flaky
    executable'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 26-2：启动最多三次自动终止并重启 flaky 可执行文件的代码
- en: 'There are three main sections to this code centered around the spawned bat
    file: creating it, starting or executing it, and monitoring it. I’ll take a closer
    look at each section.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的主要部分围绕着生成的 bat 文件展开：创建它、启动或执行它，以及监控它。我将更仔细地查看每个部分。
- en: '1.  Create *Spawned.bat*: Using the bat-building-bat technique from [Chapter
    25](chapter25.xhtml), I’m creating *Spawned.bat* with four echo commands ❶. It’s
    a simple bat file that does little more than define a unique title, uniqTitle,
    and invoke the flaky executable. There isn’t even any error handling.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 创建 *Spawned.bat*：使用 [第 25 章](chapter25.xhtml) 中的 bat 创建 bat 技巧，我通过四个 echo
    命令 ❶ 创建了 *Spawned.bat*。这是一个简单的 bat 文件，除了定义一个唯一标题 uniqTitle 并调用 flaky 执行文件外，几乎没有做其他事情。甚至没有错误处理。
- en: 'The complete contents of *Spawned.bat* might look like the following, depending
    on the contents of date, time, and flakyExe:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 *Spawned.bat* 内容可能如下所示，具体取决于 date、time 和 flakyExe 的内容：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We assign the unique title its value before creating the spawned bat file so
    that both bat files know what it is. By using the date and time in the uniqTitle
    variable, I’m assuming that two processes won’t be invoked within one hundredth
    of a second, but ideally, there should be some unique variable in each execution
    of the bat file that you can add to the title. (For the purposes of this example,
    I’m assuming that this title is truly unique.)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在创建生成的 bat 文件之前为唯一标题赋值，以便两个 bat 文件都知道它是什么。通过使用 uniqTitle 变量中的日期和时间，我假设不会有两个进程在百分之一秒内被调用，但理想情况下，每次执行
    bat 文件时应该有一个唯一的变量可以添加到标题中。（为了本示例，我假设这个标题是真正唯一的。）
- en: '2.  Start *Spawned.bat*: The :Restart label ❷ has no impact on the code as
    of now, but we’ll eventually use it to restart the process after terminating the
    hang. I initialize the total number of hangs, totHangs, to 0 prior to the label,
    ensuring that a restart won’t reset it. I’m also setting the total sleep time
    measured in seconds, totSleep, to 0, but after the label. If and when this builds
    up to 60 seconds of wait time, I’ll initiate a restart and re-execute this command,
    thus reinitializing totSleep to 0.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  启动 *Spawned.bat*：目前 :Restart 标签 ❷ 对代码没有影响，但最终我们会使用它在终止挂起后重新启动进程。我在标签之前将挂起的总次数
    totHangs 初始化为 0，确保重启不会重置它。我还将总睡眠时间（以秒为单位）totSleep 设置为 0，但它在标签之后。如果此值累积到 60 秒的等待时间，我将启动重启并重新执行此命令，从而重新初始化
    totSleep 为 0。
- en: The start command ❸ starts, spawns, or launches the dynamically created bat
    file independently of the main process. So as not to inundate the desktop with
    extra windows, the /MIN option immediately minimizes the spawned window.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: start 命令 ❸ 启动、生成或独立于主进程启动动态创建的 bat 文件。为了不让桌面被额外的窗口淹没，/MIN 选项会立即最小化生成的窗口。
- en: To verify that the spawned bat file is off and running, I’ll pause for just
    a second to give it time to execute its title command, allowing this code to find
    it. This assumes that the spawned process will run for at least a second. (If
    there’s even the remotest possibility that this isn’t true, I can always add the
    timeout 1 command to the end of spawned bat file, ensuring that it runs for at
    least a second.)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证生成的 bat 文件是否已启动并运行，我会暂停一秒钟，给它时间执行其标题命令，从而让这段代码能够找到它。这假设生成的进程会至少运行一秒钟。（如果有丝毫可能不成立，我可以在生成的
    bat 文件末尾添加 timeout 1 命令，确保它至少运行一秒钟。）
- en: The input to the for command ❹ is the same tasklist command detailed earlier,
    by default passing just the first token into the code block. If that token is
    equal to INFO:, something is wrong—the spawned bat file hasn’t started, and it’s
    far too soon for it to be done—and we go to the abort routine passing it an appropriate
    error message; otherwise, we continue.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: for 命令 ❹ 的输入与前面详细介绍的 tasklist 命令相同，默认只将第一个令牌传入代码块。如果该令牌等于 INFO:，说明出现问题——生成的
    bat 文件尚未启动，而且距离它完成还为时过早——我们会转到中止例程并传递适当的错误信息；否则，我们继续执行。
- en: '3.  Monitor *Spawned.bat*: Finally, we get to the core logic. Another timeout
    command ❺ sleeps for 10 seconds as defined in our specifications, and we add those
    10 seconds to totSleep, which represents the total time spent waiting for the
    spawned bat file to finish. Next, another for command ❻ similar to the prior one
    executes, but the code block is now looking for the first token to be equal to
    *cmd.exe*, an indication that the process is still running. If so and if evaluating
    the next if command ❼ shows that we haven’t slept for 60 seconds, the goto command
    circles back to the :WaitMore label ❺.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  监控 *Spawned.bat*：最后，我们进入核心逻辑。另一个 timeout 命令 ❺ 按照我们的规范睡眠 10 秒，并将这 10 秒加到
    totSleep 中，表示等待生成的 bat 文件完成的总时间。接下来，另一个与之前相似的 for 命令 ❻ 执行，但代码块现在查找第一个令牌是否等于 *cmd.exe*，这表示该进程仍在运行。如果是，并且如果评估下一个
    if 命令 ❼ 时显示我们还没有等待 60 秒，那么 goto 命令会返回到 :WaitMore 标签 ❺。
- en: After the total wait time has reached or exceeded 60 seconds ❼, the taskkill
    command ❽ terminates the spawned bat file. We increment and interrogate the total
    number of hangs, totHangs. After four attempts ❾, there must be a larger issue
    at play, so we initiate an abort. But otherwise, we go back to the :Restart label
    ❷ and restart the entire process again.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当总等待时间达到或超过 60 秒 ❼ 时，taskkill 命令 ❽ 会终止生成的 bat 文件。我们增加并检查挂起的总次数 totHangs。经过四次尝试
    ❾ 后，如果仍然没有解决问题，就会发生更大的问题，因此我们启动中止操作。否则，我们会返回 :Restart 标签 ❷，重新启动整个过程。
- en: Notice that the code contains two overlapping do...while commands, a twist on
    the technique introduced in [Chapter 9](chapter9.xhtml). The more modest one goes
    back to wait another 10 seconds until a minute has passed (:WaitMore ❺❼). The
    other restarts the entire process after it encounters a hang (:Restart ❷❾).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，代码中包含了两个重叠的 do...while 命令，这是 [第 9 章](chapter9.xhtml) 中介绍的技术的一种变体。较简单的命令会等待
    10 秒钟，直到过去一分钟（:WaitMore ❺❼）。另一个命令则在遇到挂起时重新启动整个进程（:Restart ❷❾）。
- en: If all goes well, the tasklist command embedded in the for command ❻ eventually
    won’t find the instance of *cmd.exe* running with the specific title. This indicates
    that the spawned bat file has finished up, and we fall through to the echo command
    noting its completion ❿.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，for 命令 ❻ 中嵌入的 tasklist 命令最终将找不到带有特定标题的 *cmd.exe* 实例。这表明生成的 bat 文件已经完成，我们将继续执行
    echo 命令来记录它的完成 ❿。
- en: The Testing
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试
- en: 'If testing an intermittent failure that occurs 1 percent of the time is difficult,
    then testing an intermittent hang that occurs 0.1 percent of the time is nearly
    impossible without some intervention. To fix a hang, we first need to create a
    hang for testing. You could write a program that occasionally executes an endless
    loop (at one time or another every coder has done this without even trying). But
    since this is a book about Batch, let’s write a bat file that’ll go into an endless
    loop about 20 percent of the time. *OccasionalHang.bat* will do just this; here
    are its complete contents:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试一个发生频率为 1% 的间歇性故障已经很困难，那么测试一个发生频率为 0.1% 的间歇性挂起几乎是不可能的，除非进行一些干预。要修复挂起问题，我们首先需要创建一个用于测试的挂起。你可以编写一个偶尔执行无限循环的程序（每个程序员在不经意间都会做过这个事情）。但由于这是一本关于批处理的书，让我们编写一个
    bat 文件，让它在大约 20% 的情况下进入无限循环。*OccasionalHang.bat* 就是做这个的；以下是它的完整内容：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The timeout command simulates a program that runs for 15 seconds. Without this,
    the bat file would usually complete in a small fraction of a second. The set /A
    command captures a pseudo-random number between 0 and 4 in the rand variable by
    modulo dividing the random pseudo-environment variable ([Chapter 21](chapter21.xhtml))
    by 5. If rand is greater than 0, we exit the bat file successfully, but roughly
    one time in five the value will be 0, and we’ll fall into an endless loop. If
    rand equals 0, the goto command repeatedly loops back to the :EndlessLoop label
    on the prior line with no hope of liberation. To make this bat file hang more
    often, you can tweak the modulo division; for instance, %% 2 will hang about half
    of the time.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: timeout 命令模拟了一个运行 15 秒的程序。如果没有这个命令，bat 文件通常会在短短的几分之一秒内完成。set /A 命令通过对随机伪环境变量（[第
    21 章](chapter21.xhtml)）进行取余操作，捕获 0 到 4 之间的伪随机数，并将其存储在 rand 变量中。如果 rand 大于 0，我们就成功退出
    bat 文件，但大约每五次中会有一次 rand 等于 0，这时我们会进入无限循环。如果 rand 等于 0，goto 命令会不断回到上一行的 :EndlessLoop
    标签，无法逃脱。要让这个 bat 文件更频繁地挂起，你可以调整取余操作，例如 %% 2 会让程序大约一半的时间挂起。
- en: 'To call this bat file instead of the flaky executable, simply enter the following
    command into the main bat file prior to the code in [Listing 26-2](#Lis26-2):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用这个 bat 文件而不是那个不稳定的可执行文件，只需在主 bat 文件中输入以下命令，放在 [Listing 26-2](#Lis26-2) 中代码之前：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The call command is part of the variable’s value, so when flakyExe resolves,
    the interpreter calls *OccasionalHang.bat*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: call 命令是变量值的一部分，因此当 flakyExe 被解析时，解释器会调用 *OccasionalHang.bat*。
- en: Real-World Tweaks
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 现实世界的调整
- en: Even though [Listing 26-2](#Lis26-2) is extremely involved, I’ve left out some
    error handling and used hardcoded values where I normally wouldn’t, all to keep
    the focus on the auto-kill-and-restart logic, but I have a number of suggested
    tweaks or enhancements for a real-world application.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 [Listing 26-2](#Lis26-2) 的内容非常复杂，我还是省略了一些错误处理，并且在通常情况下不会使用硬编码值，所有这些都是为了专注于自动终止和重启的逻辑，但我有一些关于现实应用的调整建议或改进。
- en: 'Three hardcoded values in the code should have been variables. I hardcoded
    them purely for the sake of readability, but I should have set up the sleep interval,
    maximum number of hangs, and maximum sleep time with overridable defaults like
    this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中有三个硬编码的值应该是变量。我硬编码它们纯粹是为了可读性，但我应该像这样设置休眠间隔、最大挂起次数和最大休眠时间，使用可重写的默认值：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Just as with the auto-restart, these variables should replace the hardcoded
    numbers in the code. If a user wants to change any of these values, they can do
    so with a set command prior to executing this logic.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 就像自动重启一样，这些变量应该替换代码中的硬编码数字。如果用户想更改任何这些值，可以在执行逻辑之前使用 set 命令进行更改。
- en: 'I mentioned earlier that you might be able to predict the expected execution
    time of the process based on the size of an input file. The following code will
    set the maximum sleep time to a baseline of 30 seconds, adding 1 second for every
    1,000 bytes of data in the input file, but only if someone hasn’t defined it already:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，你可能可以根据输入文件的大小预测进程的预期执行时间。以下代码将最大休眠时间设置为基准的30秒，并根据输入文件中每1,000字节的数据增加1秒，前提是没有人已经定义过它：
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can fine-tune this algorithm with a little analysis comparing file sizes
    and typical runtimes.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过一些分析，比较文件大小和典型运行时间来微调这个算法。
- en: Sometimes you can identify a hang by looking at the expected output file. If
    it doesn’t appear after so many seconds, you may already know the process is hung.
    You can capture the size of the file periodically, and if it doesn’t get any larger
    during some interval, that might also be an indication of a hang. A little analysis
    will greatly enhance the process, finding the balance between not killing a good
    yet long-running execution versus pausing the execution for as little time as
    is necessary.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可以通过查看预期的输出文件来识别程序是否挂起。如果经过了这么多秒文件仍然没有出现，你可能已经知道进程挂起了。你可以定期捕获文件的大小，如果在某个时间段内它没有变大，这也可能是挂起的一个迹象。进行一些小的分析将极大地提升进程的效率，找到在不终止一个良好但长时间运行的执行与仅暂停必要时间之间的平衡。
- en: Another possible tweak is to increase the maximum sleep time before the last
    attempt. Even after all the analysis done in the scenario we’ve tackled here,
    one execution might legitimately require more than a minute to execute. If you’ve
    killed the process three times after 60 seconds each, it might not be a bad idea
    to allow 2 minutes for the final attempt. Just multiply maxSleep by 2 if the values
    of attempt and maxHangs are equal. If future logging shows that a number of failures
    are succeeding on the final attempt, you can reevaluate the maximum sleep time.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能的调整是增加最后一次尝试之前的最大休眠时间。即使在我们处理的这个场景中做了所有分析，一个执行可能确实需要超过一分钟。如果你已经在每次60秒后终止了进程三次，允许最终尝试有2分钟的时间也许并不是坏主意。如果尝试次数和最大挂起次数相等，只需将maxSleep乘以2。如果未来的日志显示多次失败最终在最后一次尝试中成功，你可以重新评估最大休眠时间。
- en: If the hangs seem to happen when two runs kick off simultaneously, there’s a
    good chance of a contention issue, and if we kill and restart the two runs on
    the same schedule, it might just happen again because they’ll still be synced
    up. A way around that situation is to put in a wait of a few seconds just after
    the kill. Staggering the sleep times can be tricky because the random pseudo-environment
    variables will also be in sync in the two bat files if they were started at the
    same instant, but with a little effort, you can ideally find a unique number in
    each of these executions.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果挂起现象似乎发生在两次运行同时启动时，很可能是一个竞争问题。如果我们在相同的时间表上终止并重启这两次运行，它可能再次发生，因为它们仍然同步。一种解决方法是在终止后稍等几秒钟。错开休眠时间可能会有些棘手，因为如果它们在同一时刻启动，两个bat文件中的随机伪环境变量也会同步，但通过一些努力，你可以理想地在每次执行中找到一个唯一的数字。
- en: A glaring omission in [Listing 26-2](#Lis26-2) is the error handling inside
    the spawned bat file. The code in the main bat file can tell us when the spawned
    bat file has finished, but it has zero visibility into whether it executed successfully.
    It’s tantamount to running a program and not checking the return code. One solution
    is for the spawned bat file to write errorlevel and maybe even a status message
    to a small file. The main logic can then read the file and proceed based on its
    contents.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单26-2](#Lis26-2)中的一个明显遗漏是生成的bat文件内部的错误处理。主bat文件中的代码可以告诉我们生成的bat文件何时完成，但它无法知道是否成功执行。这就相当于运行一个程序但不检查返回码。一个解决方案是让生成的bat文件将errorlevel甚至状态信息写入一个小文件。主逻辑然后可以读取该文件并根据其内容继续执行。'
- en: A good solid design will make the end product much more usable and stable. This
    is the type of process that really needs to be thought out in great detail with
    all the possibilities of what can happen in both threads as they run simultaneously.
    Speaking of threads ...
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一个良好的设计会使最终产品更易用、更稳定。这种类型的进程真的需要非常详细地思考，考虑到在两个线程同时运行时可能发生的所有情况。说到线程...
- en: Multithreading
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多线程
- en: 'Before moving on to the next chapter, let’s take the components we’ve used
    to build the automatic kill and restart process and reimagine them as pieces for
    something completely different: *multithreading* or *concurrency*.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一章之前，让我们将我们用来构建自动杀死和重启过程的组件，重新构思成完全不同的东西：*多线程*或*并发*。
- en: This is another feature of Batch not envisioned by its creators but realized
    by later coders. To fully implement the multithreading found in other languages,
    we’ll need to perform three tasks. First, we’ll need to spawn two or more processes
    called *threads*. Second, we’ll need to monitor those processes to determine when
    each completes. Third, we’ll need to allow those spawned processes to communicate
    with each other and the main process, even sharing data.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Batch 的另一个功能，虽然它的创建者并未预见到，但后来由开发者实现。要完全实现其他语言中的多线程，我们需要执行三项任务。首先，我们需要创建两个或更多的被称为*线程*的进程。第二，我们需要监控这些进程，确定每个进程何时完成。第三，我们需要允许这些创建的进程彼此之间以及与主进程进行通信，甚至共享数据。
- en: You can perform the first two tasks with what you’ve learned in this chapter.
    The start command will start or spawn any number of other bat files, which I’ll
    now refer to as threads. You can use the title and tasklist commands to track
    the uniquely named threads in the same way you tracked a spawned process prone
    to hanging. The only difference is that you’ll now spawn and monitor multiple
    processes instead of just one. If the number of processes might vary, you can
    keep track of them in an array. (I’ll get to arrays in [Chapter 29](chapter29.xhtml).)
    Languages with built-in multithreading tools often have a means of killing all
    threads if they’re still running after a certain amount of time, and you can do
    the same in Batch with the timeout the taskkill commands.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过本章所学完成前两项任务。`start`命令将启动或创建任何数量的其他批处理文件，我现在将这些称为线程。你可以使用`title`和`tasklist`命令跟踪具有唯一名称的线程，就像你跟踪容易挂起的进程一样。唯一的区别是，现在你将启动并监控多个进程，而不仅仅是一个。如果进程的数量可能变化，你可以将它们保存在一个数组中。（我将在[第29章](chapter29.xhtml)中讲解数组。）带有内置多线程工具的语言通常提供一种方法，能在一定时间后杀死所有仍在运行的线程，你也可以在
    Batch 中使用`timeout`和`taskkill`命令实现同样的功能。
- en: Admittedly, the one piece that is difficult to fully implement is the ability
    for the main process and the threads to talk to each other. It should come as
    no surprise that there is no such thing as a block of asynchronous Batch code
    accessible from multiple threads, but some communication is possible. Each thread
    can record its status and high-level information such as the number of records
    processed in a simple text file named after its title. Since the main process
    also knows the title for each thread, that main process can find and process this
    information as each thread completes or even as each thread executes.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，完全实现的一个难点是主进程和线程之间的通信能力。毫无疑问，不存在可以被多个线程访问的异步 Batch 代码块，但某些通信是可能的。每个线程可以在一个以其标题命名的简单文本文件中记录其状态和高层信息，如已处理记录的数量。由于主进程也知道每个线程的标题，主进程可以在每个线程完成时，甚至在每个线程执行时找到并处理这些信息。
- en: Multithreading is a wonderful technique for breaking down time-consuming processes
    into more manageable chunks, and with a little work, you can make it happen in
    Batch.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程是一种很棒的技术，可以将耗时的过程拆分成更易管理的块，通过一些努力，你可以在 Batch 中实现这一点。
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: Coders can rate all intermittent failures and hangs on a scale of irritant to
    catastrophe. In this chapter, you’ve learned some advanced Batch coding techniques
    to mitigate these issues. I’ve detailed the auto-restart and the auto-kill-and-restart
    processes to deal with them. For both, I walked through design considerations,
    specifications, the coding, and even the testing. You also learned about some
    new and useful commands and new applications for others already discussed, and
    I even introduced multithreading.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员可以将所有间歇性故障和挂起情况按从恼人到灾难的等级进行评分。在这一章中，你学习了一些高级 Batch 编程技巧来缓解这些问题。我详细介绍了自动重启和自动杀死与重启过程的设计、规范、编码，甚至是测试。你还学习了一些新的有用命令，以及对之前讨论的命令进行的新应用，甚至介绍了多线程。
- en: Above all else, I hope you have gained an appreciation for the nuance required
    to build these solutions. Even before getting into the many details of a particular
    solution, we had to perform much analysis just to determine if an automatic restart
    is appropriate. And remember, it’s a real fix, not a “fix.”
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，我希望你能理解构建这些解决方案所需的细致入微的技巧。即使在深入讨论具体解决方案的细节之前，我们也需要进行大量分析，仅仅为了确定自动重启是否适用。并且记住，这是真正的修复，而不是一个“修复”。
- en: In the next chapter, I’ll delve into a topic that sounds like something that
    should have been a very short section in [Chapter 4](chapter4.xhtml), namely,
    using the and and or operators in the conditional clause of an if command. I won’t
    spoil here why this is [Part III](part3.xhtml) material.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将深入探讨一个听起来应该是[第4章](chapter4.xhtml)中非常简短一节的主题，即在 if 命令的条件语句中使用 and 和 or
    运算符。我在这里不剧透为什么这是[第三部分](part3.xhtml)的内容。
