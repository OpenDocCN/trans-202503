- en: '2'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '2'
- en: A DEEPER DIVE INTO C PROGRAMMING
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 深入探索 C 编程
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: With many of the basics of C programming covered in the previous chapter, we
    now dive deeper into the details of C. In this chapter we revisit many of the
    topics from the previous chapter, such as arrays, strings, and structs, discussing
    them in more detail. We also introduce C’s pointer variables and dynamic memory
    allocation. *Pointers* provide a level of indirection to accessing program state,
    and *dynamic memory allocation* allows a program to adjust to changes in size
    and space needs as it runs, allocating more space as it needs it and freeing space
    it no longer needs. By understanding how and when to use pointer variables and
    dynamic memory allocation, a C programmer can design programs that are both powerful
    and efficient.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章涵盖了 C 编程的许多基础内容后，我们现在将更深入地探讨 C 的细节。在本章中，我们将重新审视上一章中的许多主题，如数组、字符串和结构体，并对它们进行更详细的讨论。我们还将介绍
    C 的指针变量和动态内存分配。*指针*为访问程序状态提供了间接性，而*动态内存分配*则允许程序根据运行时的大小和空间需求进行调整，在需要时分配更多空间，并释放不再需要的空间。通过理解如何以及何时使用指针变量和动态内存分配，C
    程序员可以设计出既强大又高效的程序。
- en: We begin with a discussion of the parts of program memory, as this will help
    in understanding many of the topics presented later. As the chapter progresses,
    we cover C file I/O and some advanced C topics including library linking and compiling
    to assembly code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先讨论程序内存的各个部分，因为这将有助于理解后续介绍的许多主题。随着章节的进展，我们将涵盖 C 文件 I/O 以及一些高级 C 话题，包括库链接和编译成汇编代码。
- en: 2.1 Parts of Program Memory and Scope
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1 程序内存的组成和作用域
- en: 'The following C program shows examples of functions, parameters, and local
    and global variables (function comments are omitted to shorten this code listing):'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 C 程序展示了函数、参数以及局部和全局变量的示例（为简化代码列表，省略了函数注释）：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This example shows program variables with different scope. A variable’s *scope*
    defines when its name has meaning. In other words, scope defines the set of program
    code blocks in which a variable is bound to (associated with) a program memory
    location and can be used by program code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了具有不同作用域的程序变量。一个变量的*作用域*定义了其名称何时具有意义。换句话说，作用域定义了程序代码块的集合，在这些代码块中，变量与程序内存位置绑定并可以被程序代码使用。
- en: Declaring a variable outside of any function body creates a *global variable*.
    Global variables remain permanently in scope and can be used by any code in the
    program because they’re always bound to one specific memory location. Every global
    variable must have a unique name—its name uniquely identifies a specific storage
    location in program memory for the entire duration of the program.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何函数体外声明一个变量会创建一个*全局变量*。全局变量始终存在于作用域内，并且可以被程序中任何代码使用，因为它们始终绑定到一个特定的内存位置。每个全局变量必须有一个唯一的名称——它的名称在程序运行期间唯一地标识程序内存中的特定存储位置。
- en: '*Local variables and parameters* are only in scope inside the function in which
    they are defined. For example, the `amt` parameter is in scope only inside the
    `change` function. This means that only statements within the `change` function
    body can access the `amt` parameter, and an instance of the `amt` parameter is
    bound to a specific memory storage location only within a specific active execution
    of the function. Space to store a parameter’s value is allocated on the stack
    when the function gets called, and it is deallocated from the stack when the function
    returns. Each activation of a function gets its own bindings for its parameters
    and local variables. Thus, for recursive function calls, each call (or activation)
    gets a separate stack frame containing space for its parameters and local variables.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*局部变量和参数*仅在它们被定义的函数内有效。例如，`amt` 参数只在 `change` 函数内有效。这意味着只有 `change` 函数体内的语句能够访问
    `amt` 参数，并且 `amt` 参数的实例仅在特定的函数执行期间绑定到一个特定的内存存储位置。当函数被调用时，存储参数值的空间会在栈上分配，并在函数返回时从栈中释放。每次函数激活时都会为其参数和局部变量分配独立的绑定。因此，对于递归函数调用，每次调用（或激活）都会获得一个包含其参数和局部变量空间的独立栈帧。'
- en: Because parameters and local variables are only in scope inside the function
    that defines them, different functions can use the same names for local variables
    and parameters. For example, both the `change` and the `max` functions have a
    local variable named `val`. When code in the `max` function refers to `val` it
    refers to its local variable `val` and not to the `change` function’s local variable
    `val` (which is not in scope inside the `max` function).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于参数和局部变量仅在定义它们的函数内部有效，不同的函数可以使用相同的名字来命名局部变量和参数。例如，`change`函数和`max`函数都有一个名为`val`的局部变量。当`max`函数中的代码引用`val`时，它指的是该函数的局部变量`val`，而不是`change`函数的局部变量`val`（后者在`max`函数的作用域内不可用）。
- en: While there may occasionally be times when using global variables in C programs
    is necessary, we strongly recommend that you *avoid programming with global variables
    whenever possible*. Using only local variables and parameters yields code that’s
    more modular, more general-purpose, and easier to debug. Also, because a function’s
    parameters and local variables are only allocated in program memory when the function
    is active, they may result in more space-efficient programs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在C程序中有时需要使用全局变量，但我们强烈建议你*尽可能避免使用全局变量编程*。仅使用局部变量和参数可以让代码更加模块化、通用，且更容易调试。而且，由于函数的参数和局部变量仅在函数激活时才分配到程序内存中，它们可能导致程序更加节省空间。
- en: Upon launching a new program, the operating system allocates the new program’s
    address space. A program’s *address space* (or memory space) represents storage
    locations for everything it needs in its execution, namely storage for its instructions
    and data. A program’s address space can be thought of as an array of addressable
    bytes; each used address in the program’s address space stores all or part of
    a program instruction or data value (or some additional state necessary for the
    program’s execution).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 启动新程序时，操作系统为新程序分配地址空间。程序的*地址空间*（或内存空间）代表了程序执行所需的所有存储位置，即用于存储指令和数据的存储区。程序的地址空间可以看作是一个可寻址字节的数组；程序地址空间中每个使用的地址存储了程序指令或数据值的全部或部分（或程序执行所需的其他状态）。
- en: A program’s memory space is divided into several parts, each of which is used
    to store a different kind of entity in the process’s address space. [Figure 2-1](ch02.xhtml#ch2fig1)
    illustrates the parts of a program’s memory space.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的内存空间被分为几个部分，每个部分用于存储进程地址空间中的不同类型的实体。[图 2-1](ch02.xhtml#ch2fig1)展示了程序内存空间的各个部分。
- en: '![image](../images/02fig01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig01.jpg)'
- en: '*Figure 2-1: The parts of a program’s address space*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-1：程序地址空间的各个部分*'
- en: The top of a program’s memory is reserved for use by the operating system, but
    the remaining parts are usable by the running program. The program’s instructions
    are stored in the *code* section of the memory. For example, the program listed
    earlier stores instructions for the `main`, `max`, and `change` functions in this
    region of memory.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 程序内存的顶部保留供操作系统使用，而其余部分则可供正在运行的程序使用。程序的指令存储在内存的*代码*部分。例如，前面提到的程序将`main`、`max`和`change`函数的指令存储在该内存区域。
- en: Local variables and parameters reside in the portion of memory for the *stack*.
    Because the amount of stack space grows and shrinks over the program’s execution
    as functions are called and returned from, the stack part of memory is typically
    allocated near the bottom of memory (at the highest memory addresses) to leave
    space for it to change. Stack storage space for local variables and parameters
    exists only when the function is active (within the stack frame for the function’s
    activation on the stack).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量和参数存储在*栈*的内存部分中。由于栈空间随着函数调用和返回而增大和缩小，栈的内存部分通常会分配在内存的底部（即最高的内存地址），以便为栈的变化留出空间。局部变量和参数的栈存储空间仅在函数活动时存在（即在函数激活的栈帧内）。
- en: Global variables are stored in the *data* section. Unlike the stack, the data
    region does not grow or shrink—storage space for globals persists for the entire
    run of the program.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量存储在*数据*部分。与栈不同，数据区域不会增长或缩小——全局变量的存储空间在程序运行的整个过程中都持续存在。
- en: Finally, the *heap* portion of memory is the part of a program’s address space
    associated with dynamic memory allocation. The heap is typically located far from
    stack memory and grows into higher addresses as more space is dynamically allocated
    by the running program.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，内存的*堆*部分是程序地址空间中与动态内存分配相关的部分。堆通常位于远离栈内存的位置，随着程序动态分配更多空间，它会向更高的地址增长。
- en: 2.2 C’s Pointer Variables
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2 C语言的指针变量
- en: 'C’s pointer variables provide a level of indirection to accessing program memory.
    By understanding how to use pointer variables, a programmer can write C programs
    that are both powerful and efficient. For example, through pointer variables,
    a C programmer can:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: C语言的指针变量为访问程序内存提供了间接性。通过理解如何使用指针变量，程序员可以编写既强大又高效的C程序。例如，通过指针变量，C程序员可以：
- en: implement functions whose parameters can modify values in the caller’s stack
    frame
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现能够修改调用者栈帧中值的函数
- en: dynamically allocate (and deallocate) program memory at runtime when the program
    needs it
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在程序运行时，根据需要动态分配（和释放）程序内存
- en: efficiently pass large data structures to functions
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效地将大型数据结构传递给函数
- en: create linked dynamic data structures
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建链式动态数据结构
- en: interpret bytes of program memory in different ways.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以不同方式解释程序内存的字节。
- en: In this section, we introduce the syntax and semantics of C’s pointer variables
    and introduce common examples of how to use them in C programs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍C语言指针变量的语法和语义，并介绍如何在C程序中使用它们的常见示例。
- en: 2.2.1 Pointer Variables
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.1 指针变量
- en: 'A *pointer variable* stores the address of a memory location in which a value
    of a specific type can be stored. For example, a pointer variable can store the
    value of an `int` address at which the integer value 12 is stored. The pointer
    variable *points to* (refers to) the value. A pointer provides *a level of indirection*
    for accessing values stored in memory. [Figure 2-2](ch02.xhtml#ch2fig2) illustrates
    an example of what a pointer variable might look like in memory:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*指针变量*存储一个内存位置的地址，特定类型的值可以存储在该地址中。例如，指针变量可以存储一个`int`地址，该地址中存储整数值12。指针变量*指向*（引用）该值。指针为访问存储在内存中的值提供了*间接性*。[图
    2-2](ch02.xhtml#ch2fig2)展示了指针变量在内存中的示例：'
- en: '![image](../images/02fig02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig02.jpg)'
- en: '*Figure 2-2: A pointer variable stores the address of a location in memory.
    Here, the pointer stores the address of an integer variable that holds the number
    12.*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-2：指针变量存储内存中某个位置的地址。这里，指针存储一个整数变量的地址，该变量保存数字12。*'
- en: 'Through the pointer variable, `ptr`, the value (`12`) stored in the memory
    location it points to can be indirectly accessed. C programs most frequently use
    pointer variables for:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指针变量`ptr`，可以间接访问它指向的内存位置中存储的值（例如`12`）。C程序最常用指针变量的方式包括：
- en: 1\. *“pass by pointer” parameters*, for writing functions that can modify their
    argument’s value through a pointer parameter
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 1. *“按指针传递”参数*，用于编写可以通过指针参数修改其参数值的函数
- en: 2\. *dynamic memory allocation*, for writing programs that allocate (and free)
    space as the program runs. Dynamic memory is commonly used for dynamically allocating
    arrays. It is useful when a programmer doesn’t know the size of a data structure
    at compile time (e.g., the array size depends on user input at runtime). It also
    enables data structures to be resized as the program runs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 2. *动态内存分配*，用于编写能够在程序运行时分配（和释放）内存空间的程序。动态内存通常用于动态分配数组。它在程序员不知道数据结构大小的情况下特别有用（例如，数组的大小取决于运行时用户输入）。它还使数据结构能够在程序运行时调整大小。
- en: Rules for Using Pointer Variables
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用指针变量的规则
- en: 'The rules for using pointer variables are similar to regular variables, except
    that you need to think about two types: the type of the pointer variable, and
    the type stored in the memory address to which the pointer variable points.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用指针变量的规则与常规变量类似，唯一不同的是你需要考虑两种类型：指针变量的类型，以及指针变量指向的内存地址中存储的类型。
- en: 'First, *declare a pointer variable* using <type_name> `*`<var_name>:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，*声明一个指针变量*，使用<类型名> `*`<变量名>：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Note POINTER TYPES**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意 指针类型**'
- en: 'Although `ptr` and `cptr` are both pointers, they refer to different types:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`ptr`和`cptr`都是指针，但它们指向不同的类型：
- en: The type of `ptr` is *pointer to int* (`int *`). It can point to a memory location
    that stores an `int` value.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ptr`的类型是*指向整数的指针*（`int *`）。它可以指向存储`int`值的内存位置。'
- en: The type of `cptr` is *pointer to char* (`char *`). It can point to a memory
    location that stores a `char` value.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cptr`的类型是*指向字符的指针*（`char *`）。它可以指向存储`char`值的内存位置。'
- en: 'Next, *initialize the pointer variable* (make it point to something). Pointer
    variables *store address values*. A pointer should be initialized to store the
    address of a memory location whose type matches the type to which the pointer
    variable points. One way to initialize a pointer is to use the *address operator*
    (`&`) with a variable to get the variable’s address value:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，*初始化指针变量*（使其指向某个地方）。指针变量*存储地址值*。指针应该初始化为存储与指针变量指向的类型匹配的内存位置的地址值。初始化指针的一种方式是使用*地址操作符*（`&`）与变量一起获取该变量的地址值：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![image](../images/02fig03.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig03.jpg)'
- en: '*Figure 2-3: A program can initialize a pointer by assigning it the address
    of an existing variable of the appropriate type.*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-3：程序可以通过将指针赋值为现有变量的地址来初始化指针。*'
- en: 'Here’s an example of an invalid pointer initialization due to mismatched types:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个由于类型不匹配导致的无效指针初始化示例：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Even though the C compiler may allow this type of assignment (with a warning
    about incompatible types), the behavior of accessing and modifying `x` through
    `cptr` will likely not behave as the programmer expects. Instead, the programmer
    should use an `int *` variable to point to an `int` storage location.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 C 编译器可能允许这种类型的赋值（并给出关于不兼容类型的警告），通过`cptr`访问和修改`x`的行为可能不会像程序员预期的那样工作。相反，程序员应该使用`int
    *`类型的变量指向一个`int`存储位置。
- en: 'All pointer variables can also be assigned a special value, `NULL`, which represents
    an invalid address. While a *null pointer* (one whose value is `NULL`) should
    never be used to access memory, the value `NULL` is useful for testing a pointer
    variable to see if it points to a valid memory address. That is, C programmers
    will commonly check a pointer to ensure that its value isn’t `NULL` before attempting
    to access the memory location to which it points. To set a pointer to `NULL`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 所有指针变量也可以被赋予特殊值`NULL`，表示无效地址。虽然*空指针*（值为`NULL`的指针）不应被用于访问内存，但`NULL`值对于测试指针变量是否指向有效内存地址非常有用。也就是说，C
    程序员通常会检查指针，确保它的值不是`NULL`，然后再尝试访问它所指向的内存位置。要将指针设置为`NULL`：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![image](../images/02fig04.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig04.jpg)'
- en: '*Figure 2-4: Any pointer can be given the special value `NULL`, which indicates
    that it doesn’t refer to any particular address. Null pointers should never be
    dereferenced.*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-4：任何指针都可以赋予特殊值`NULL`，表示它不指向任何特定地址。空指针不应被解引用。*'
- en: 'Finally, *use the pointer variable*. The *dereference operator* (`*`) follows
    a pointer variable to the location in memory that it points to and accesses the
    value at that location:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*使用指针变量*。*解引用操作符*（`*`）跟随指针变量，指向它在内存中所指向的位置，并访问该位置的值：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![image](../images/02fig05.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig05.jpg)'
- en: '*Figure 2-5: Dereferencing a pointer accesses the value to which the pointer
    refers.*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-5：解引用指针可以访问指针所指向的值。*'
- en: Pointer Examples
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 指针示例
- en: 'Here’s an example sequence of C statements using two pointer variables:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用两个指针变量的 C 语句示例：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![image](../images/f0069-01.jpg) [PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![image](../images/f0069-01.jpg) [PRE7]'
- en: '![image](../images/f0070-01.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0070-01.jpg)'
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![image](../images/f0070-02.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0070-02.jpg)'
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![image](../images/f0070-03.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0070-03.jpg)'
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![image](../images/f0070-04.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0070-04.jpg)'
- en: 'When using pointer variables, carefully consider the types of the relevant
    variables. Drawing pictures of memory (like those shown above) can help with understanding
    what pointer code is doing. Some common errors involve misusing the dereference
    operator (`*`) or the address operator (`&`). For example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用指针变量时，要仔细考虑相关变量的类型。绘制内存图像（如上所示）有助于理解指针代码的作用。一些常见的错误涉及错误使用解引用操作符（`*`）或地址操作符（`&`）。例如：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If your program dereferences a pointer variable that does not contain a valid
    address, the program crashes:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序解引用一个不包含有效地址的指针变量，程序会崩溃：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'These types of errors exemplify one reason to initialize pointer variables
    to `NULL`; a program can then test a pointer’s value for `NULL` before dereferencing
    it:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的错误展示了为什么需要将指针变量初始化为`NULL`；程序可以在解引用指针之前，先测试指针的值是否为`NULL`：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 2.3 Pointers and Functions
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3 指针与函数
- en: Pointer parameters provide a mechanism through which functions can modify argument
    values. The commonly used *pass by pointer* pattern uses a pointer function parameter
    that *gets the value of the address of some storage location* passed to it by
    the caller. For example, the caller could pass the address of one of its local
    variables. By dereferencing the pointer parameter inside the function, the function
    can modify the value at the storage location to which it points.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 指针参数提供了一种机制，通过它函数可以修改参数值。常用的*按指针传递*模式使用一个指针函数参数，该指针函数参数*获取调用者传递给它的某个存储位置的地址值*。例如，调用者可以传递它的一个局部变量的地址。通过在函数内取消引用指针参数，函数可以修改指针所指向存储位置的值。
- en: We have already seen similar functionality with array parameters, where an array
    function parameter gets the value of the base address of the passed array (the
    parameter refers to the same set of array elements as its argument), and the function
    can modify the values stored in the array. In general, this same idea can be applied
    by passing pointer parameters to functions that point to the memory locations
    in the caller’s scope.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了类似的功能，使用数组参数时，数组函数参数会获取传入数组的基地址的值（该参数引用的数组元素集与其参数相同），并且函数可以修改数组中存储的值。通常，这个想法可以通过将指针参数传递给指向调用者作用域中内存位置的函数来应用。
- en: '**Note PASS BY VALUE**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：按值传递**'
- en: 'All arguments in C are passed by value and follow pass-by-value semantics:
    the parameter gets a copy of its argument value, and modifying the parameter’s
    value does not change its argument’s value. When passing base type values, like
    the value of an `int` variable, the function parameter gets a copy of its argument
    value (the specific `int` value), and changing the value stored in the parameter
    cannot change the value stored in its argument.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 C 语言的参数都是按值传递的，并遵循按值传递的语义：参数获取其参数值的副本，修改参数的值不会改变其参数值。在传递基本类型值时，像`int`变量的值，函数参数获取的是其参数值的副本（具体的`int`值），并且改变参数中存储的值不会改变其参数中的值。
- en: In the pass-by-pointer pattern, the parameter still gets the value of its argument,
    but it is passed *the value of an address*. Just like in passing base types, changing
    a pointer parameter’s value will not change its argument’s value (i.e., assigning
    the parameter to point to a different address will not change the argument’s address
    value). However, by dereferencing a pointer parameter, the function can change
    the contents of memory that both the parameter and its argument refer to; through
    a pointer parameter, a function can modify a variable that is visible to the caller
    after the function returns.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在按指针传递的模式中，参数仍然获取其参数的值，但它被传递的是*地址的值*。就像传递基本类型一样，改变指针参数的值不会改变其参数的值（即，赋值使参数指向不同的地址不会改变参数的地址值）。然而，通过取消引用指针参数，函数可以改变参数和其参数所引用的内存内容；通过指针参数，函数可以修改一个在函数返回后调用者仍然可见的变量。
- en: 'Here are the steps for implementing and calling a function with a pass-by-pointer
    parameter, with example code snippets showing each step:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是实现和调用带有按指针传递参数的函数的步骤，其中包含显示每个步骤的示例代码片段：
- en: '1\. Declare the function parameter to be a pointer to the variable type:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 声明函数参数为指向变量类型的指针：
- en: '/* input: an int pointer that stores the address of a memory'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: /* 输入：存储内存地址的 int 指针
- en: '*        location that can store an int value (it points to an int)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*        可以存储 int 值的位置（指向一个 int）'
- en: '*/'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*/'
- en: int change_value(int *input) {
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: int change_value(int *input) {
- en: '2\. When making the function call, pass in the address of a variable as the
    argument:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 调用函数时，将变量的地址作为参数传入：
- en: int x;
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: int x;
- en: change_value(&x);
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: change_value(&x);
- en: In the preceding example, since the parameter’s type is `int *`, the address
    passed must be the address of an `int` variable.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，由于参数类型是`int *`，因此传递的地址必须是一个`int`变量的地址。
- en: '3\. In the body of the function, dereference the pointer parameter to change
    the argument’s value:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 在函数体内，取消引用指针参数来改变参数值：
- en: '*input = 100;  // the location input points to (x''s memory)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*input = 100;  // input 指向的位置（x 的内存）'
- en: // is assigned 100
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: // 被赋值为 100
- en: 'Next, let’s examine a larger example program:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看一个更大的示例程序：
- en: passbypointer.c
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: passbypointer.c
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When run, the output is:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，输出结果是：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[Figure 2-6](ch02.xhtml#ch2fig6) shows what the call stack looks like before
    executing the return in `change_value`.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-6](ch02.xhtml#ch2fig6) 显示了 `change_value` 执行返回前的调用栈。'
- en: '![image](../images/02fig06.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig06.jpg)'
- en: '*Figure 2-6: A snapshot of the call stack prior to returning from `change_value`*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-6：在从`change_value`返回之前调用栈的快照*'
- en: The input parameter gets a copy of the value of its argument (the address of
    `x`). The value of `x` is 30 when the function call is made. Inside the `change_value`
    function, the parameter is dereferenced to assign the value 100 to the memory
    location pointed to by the parameter (`*input = 100;`, meaning “the location `input`
    points to gets the value 100”). Since the parameter stores the address of a local
    variable in the `main` function’s stack frame, through dereferencing the parameter,
    the value stored in the caller’s local variable can be changed. When the function
    returns, the argument’s value reflects the change made to it through the pointer
    parameter (the value of `x` in `main` was changed to 100 by the `change_value`
    function through its `input` parameter).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 输入参数获得其参数值的副本（即`x`的地址）。当函数调用时，`x`的值为30。在`change_value`函数内部，通过解引用参数将100赋值给参数指向的内存位置（`*input
    = 100;`，意味着“`input`指向的位置将得到100”）。由于参数存储的是`main`函数栈帧中局部变量的地址，因此通过解引用该参数，可以更改调用者局部变量中存储的值。当函数返回时，参数值反映了通过指针参数所做的更改（`main`中的`x`值通过`change_value`函数的`input`参数被更改为100）。
- en: 2.4 Dynamic Memory Allocation
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4 动态内存分配
- en: In addition to pass-by-pointer parameters, programs commonly use pointer variables
    to dynamically allocate memory. Such *dynamic memory allocation* allows a C program
    to request more memory as it’s running, and a pointer variable stores the address
    of the dynamically allocated space. Programs often allocate memory dynamically
    to tailor the size of an array for a particular run.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过指针传递参数外，程序通常还使用指针变量来动态分配内存。这种*动态内存分配*允许C程序在运行时请求更多的内存，而指针变量存储着动态分配空间的地址。程序通常会动态分配内存，以便根据特定运行定制数组的大小。
- en: 'Dynamic memory allocation grants flexibility to programs that:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 动态内存分配为程序提供了灵活性，能够：
- en: do not know the size of arrays or other data structures until runtime (e.g.,
    the size depends on user input)
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时之前无法知道数组或其他数据结构的大小（例如，大小取决于用户输入）
- en: need to allow for a variety of input sizes (not just up to some fixed capacity)
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要允许多种输入大小（不仅仅是某个固定的容量）
- en: want to allocate exactly the size of data structures needed for a particular
    execution (don’t waste capacity)
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想要为特定的执行精确分配所需的数据结构大小（不要浪费容量）
- en: grow or shrink the sizes of memory allocated as the program runs, reallocating
    more space when needed and freeing up space when it’s no longer required.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在程序运行时根据需要增长或缩小已分配的内存大小，当需要时重新分配更多空间，当不再需要时释放空间。
- en: 2.4.1 Heap Memory
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.1 堆内存
- en: Every byte of memory in a program’s memory space has an associated address.
    Everything the program needs to run is in its memory space, and different types
    of entities reside in different parts of a program’s memory space. For example,
    the *code* region contains the program’s instructions, global variables reside
    in the *data* region, local variables and parameters occupy the *stack*, and dynamically
    allocated memory comes from the *heap*. Because the stack and the heap grow at
    runtime (as functions are called and return and as dynamic memory is allocated
    and freed), they are typically far apart in a program’s address space to leave
    a large amount of space for each to grow into as the program runs.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 程序内存空间中的每个字节都有一个相关的地址。程序运行所需的所有内容都在其内存空间中，不同类型的实体驻留在程序内存空间的不同部分。例如，*代码*区域包含程序的指令，全局变量驻留在*数据*区域，局部变量和参数占据*栈*，而动态分配的内存来自*堆*。由于栈和堆在运行时增长（随着函数的调用和返回以及动态内存的分配和释放），它们通常在程序的地址空间中相距较远，以便为它们各自的增长预留大量空间。
- en: Dynamically allocated memory occupies the heap memory region of a program’s
    address space (see [page 66](ch02.xhtml#lev1_10)). When a program dynamically
    requests memory at runtime, the heap provides a chunk of memory whose address
    must be assigned to a pointer variable.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分配的内存占据程序地址空间中的堆内存区域（参见[第66页](ch02.xhtml#lev1_10)）。当程序在运行时动态请求内存时，堆会提供一块内存，其地址必须分配给一个指针变量。
- en: '[Figure 2-7](ch02.xhtml#ch2fig7) illustrates the parts of a running program’s
    memory with an example of a pointer variable (`ptr`) on the stack that stores
    the address of dynamically allocated heap memory (it points to heap memory).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-7](ch02.xhtml#ch2fig7) 通过一个示例展示了正在运行的程序内存的各个部分，其中堆栈上的指针变量（`ptr`）存储着动态分配的堆内存的地址（它指向堆内存）。'
- en: '![image](../images/02fig07.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig07.jpg)'
- en: '*Figure 2-7: A pointer on the stack points to a block of memory that was allocated
    from the heap.*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-7：堆栈上的指针指向从堆中分配的内存块。*'
- en: It’s important to remember that heap memory is anonymous memory, where “anonymous”
    means that addresses in the heap are not bound to variable names. Declaring a
    named program variable allocates it on the stack or in the data part of program
    memory. A local or global pointer variable can store the address of an anonymous
    heap memory location (e.g., a local pointer variable on the stack can point to
    heap memory), and dereferencing such a pointer enables a program to store data
    in the heap.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，堆内存是匿名内存，其中“匿名”意味着堆中的地址没有绑定到变量名。声明一个具名程序变量会将其分配到堆栈或程序内存的数据部分。一个局部或全局指针变量可以存储指向匿名堆内存位置的地址（例如，堆栈上的局部指针变量可以指向堆内存），并且解引用这样的指针使得程序能够在堆中存储数据。
- en: 2.4.2 malloc and free
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.2 malloc 和 free
- en: '*malloc* and *free* are functions in the standard C library (`stdlib`) that
    a program can call to allocate and deallocate memory in the *heap*. Heap memory
    must be explicitly allocated (malloc’ed) and deallocated (freed) by a C program.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*malloc* 和 *free* 是标准 C 库（`stdlib`）中的函数，程序可以调用它们在 *堆* 上分配和释放内存。堆内存必须由 C 程序显式分配（malloc）和释放（free）。'
- en: 'To allocate heap memory, call `malloc`, passing in the total number of bytes
    of contiguous heap memory to allocate. Use the `sizeof` *operator* to compute
    the number of bytes to request. For example, to allocate space on the heap to
    store a single integer, a program could call:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要分配堆内存，调用 `malloc`，并传入要分配的连续堆内存的总字节数。使用 `sizeof` *运算符* 来计算请求的字节数。例如，要在堆上分配存储单个整数的空间，程序可以调用：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `malloc` function returns the base address of the allocated heap memory
    to the caller (or `NULL` if an error occurs). Here’s a full example program with
    a call to `malloc` to allocate heap space to store a single `int` value:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`malloc` 函数将分配的堆内存的基地址返回给调用者（如果发生错误，则返回 `NULL`）。以下是一个完整的示例程序，使用 `malloc` 来分配堆空间存储一个
    `int` 值：'
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `malloc` function returns a `void *` type, which represents a generic pointer
    to a non-specified type (or to any type). When a program calls `malloc` and assigns
    the result to a pointer variable, the program associates the allocated memory
    with the type of the pointer variable.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`malloc` 函数返回一个 `void *` 类型，它表示一个指向未指定类型（或任何类型）的通用指针。当程序调用 `malloc` 并将结果赋值给指针变量时，程序将分配的内存与指针变量的类型关联起来。'
- en: 'Sometimes you may see calls to `malloc` that explicitly recast its return type
    from `void *` to match the type of the pointer variable. For example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能会看到 `malloc` 调用，显式地将其返回类型从 `void *` 转换为匹配指针变量的类型。例如：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `(int *)` before `malloc` tells the compiler that the `void *` type returned
    by `malloc` will be used as an `int *` in this call (it recasts the return type
    of `malloc` to an `int *`). We discuss type recasting and the `void *` type in
    more detail later in this chapter, on [page 126](ch02.xhtml#lev2_38).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `malloc` 前面的 `(int *)` 告诉编译器，`malloc` 返回的 `void *` 类型将在此调用中作为 `int *` 使用（它将
    `malloc` 的返回类型重新转换为 `int *`）。我们将在本章稍后更详细地讨论类型重 cast 和 `void *` 类型，参见 [第126页](ch02.xhtml#lev2_38)。
- en: 'A call to `malloc` fails if there is not enough free heap memory to satisfy
    the requested number of bytes to allocate. Usually, `malloc` failing indicates
    an error in the program such as passing `malloc` a very large request, passing
    a negative number of bytes, or calling `malloc` in an infinite loop and running
    out of heap memory. Because any call to `malloc` can fail, you should *always
    test its return value for* NULL (indicating `malloc` failed) before dereferencing
    the pointer value. Dereferencing a null pointer will cause your program to crash!
    For example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有足够的空闲堆内存来满足请求分配的字节数，则 `malloc` 调用会失败。通常，`malloc` 失败表示程序中出现错误，例如传递给 `malloc`
    一个非常大的请求，传递一个负数字节数，或者在无限循环中调用 `malloc` 并耗尽了堆内存。由于任何 `malloc` 调用都有可能失败，因此在解引用指针值之前，*始终检查其返回值是否为*
    NULL（表示 `malloc` 失败）。解引用空指针会导致程序崩溃！例如：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When a program no longer needs the heap memory it dynamically allocated with
    `malloc`, it should explicitly deallocate the memory by calling the `free` function.
    It’s also a good idea to set the pointer’s value to `NULL` after calling `free`,
    so that if an error in the program causes it to be accidentally dereferenced after
    the call to `free`, the program will crash rather than modify parts of heap memory
    that have been reallocated by subsequent calls to `malloc`. Such unintended memory
    references can result in undefined program behavior that is often very difficult
    to debug, whereas a null pointer dereference will fail immediately, making it
    a relatively easy bug to find and to fix.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序不再需要通过`malloc`动态分配的堆内存时，应该通过调用`free`函数显式地释放该内存。调用`free`后，将指针的值设置为`NULL`也是一个好主意，这样如果程序中的错误导致它在`free`调用后被意外解引用，程序将崩溃，而不是修改已被后续`malloc`调用重新分配的堆内存。这种无意的内存引用可能会导致未定义的程序行为，通常非常难以调试，而空指针解引用会立即失败，从而使其成为一个相对容易发现和修复的bug。
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 2.4.3 Dynamically Allocated Arrays and Strings
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.3 动态分配的数组和字符串
- en: C programmers often dynamically allocate memory to store arrays. A successful
    call to `malloc` allocates one contiguous chunk of heap memory of the requested
    size. It returns the address of the start of this chunk of memory to the caller,
    making the returned address value suitable for the base address of a dynamically
    allocated array in heap memory.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: C程序员经常动态分配内存以存储数组。成功调用`malloc`会分配一个请求大小的连续堆内存块，并将该内存块的起始地址返回给调用者，从而使返回的地址值适合用于堆内存中动态分配数组的基地址。
- en: 'To dynamically allocate space for an array of elements, pass `malloc` the total
    number of bytes in the desired array. That is, the program should request from
    `malloc` the total number of bytes in each array element times the number of elements
    in the array. Pass `malloc` an expression for the total number of bytes in the
    form of `sizeof(` <type>`) *` <number of elements>. For example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要为元素数组动态分配空间，传递给`malloc`的是所需数组的总字节数。也就是说，程序应向`malloc`请求每个数组元素的字节数乘以数组元素的数量。传递给`malloc`的参数应该是总字节数的表达式，形式为`sizeof(<type>)
    * <number of elements>`。例如：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: After the calls to `malloc` in this example, the `int` pointer variable `arr`
    stores the base address of an array of 20 contiguous integer storage locations
    in heap memory, and the `c_arr` char pointer variable stores the base address
    of an array of 10 contiguous char storage locations in heap memory. [Figure 2-8](ch02.xhtml#ch2fig8)
    depicts what this might look like.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`malloc`调用后，`int`指针变量`arr`存储了堆内存中一个包含20个连续整数存储位置的数组的基地址，而`c_arr`字符指针变量存储了堆内存中一个包含10个连续字符存储位置的数组的基地址。[图
    2-8](ch02.xhtml#ch2fig8)展示了这可能是什么样子。
- en: '![image](../images/02fig08.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig08.jpg)'
- en: '*Figure 2-8: A 20-element integer array and 10-element character array allocated
    on the heap*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-8：在堆上分配的20元素整数数组和10元素字符数组*'
- en: Note that while `malloc` returns a pointer to dynamically allocated space in
    heap memory, C programs store the pointer to heap locations on the stack. The
    pointer variables contain *only the base address* (the starting address) of the
    array storage space in the heap. Just like statically declared arrays, the memory
    locations for dynamically allocated arrays are in contiguous memory locations.
    While a single call to `malloc` results in a chunk of memory of the requested
    number of bytes being allocated, multiple calls to `malloc` *will not* result
    in heap addresses that are contiguous (on most systems). In the previous example,
    the `char` array elements and the `int` array elements may be at addresses that
    are far apart in the heap.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管`malloc`返回的是指向堆内存中动态分配空间的指针，但C程序将指向堆位置的指针存储在栈上。指针变量只包含数组存储空间在堆中的*基地址*（起始地址）。就像静态声明的数组一样，动态分配的数组的内存位置也是连续的。虽然一次`malloc`调用会分配一个请求大小的内存块，但多次调用`malloc`*不会*导致堆地址连续（在大多数系统上）。在前面的示例中，`char`数组元素和`int`数组元素可能位于堆中相距很远的地址。
- en: 'After dynamically allocating heap space for an array, a program can access
    the array through the pointer variable. Because the pointer variable’s value represents
    the base address of the array in the heap, we can use the same syntax to access
    elements in dynamically allocated arrays as we use to access elements in statically
    declared arrays (see [page 44](ch01.xhtml#lev1_5)). Here’s an example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在动态分配堆内存空间后，程序可以通过指针变量访问数组。因为指针变量的值表示数组在堆中的基地址，我们可以使用与访问静态声明数组元素相同的语法来访问动态分配数组的元素（参见[第44页](ch01.xhtml#lev1_5)）。以下是一个示例：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It may not be obvious why the same syntax can be used for accessing elements
    in dynamically allocated arrays as is used in accessing elements in statically
    declared arrays. However, even though their types are different, the values of
    `s_array` and `d_array` both evaluate to the base address of the array in memory
    (see [Table 2-1](ch02.xhtml#ch2tab1)).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 可能不太容易理解为什么可以使用相同的语法来访问动态分配数组中的元素，就像访问静态声明数组中的元素一样。然而，尽管它们的类型不同，`s_array`和`d_array`的值都求值为数组在内存中的基地址（参见[表2-1](ch02.xhtml#ch2tab1)）。
- en: '**Table 2-1:** Comparison of Statically Allocated `s_array` and Dynamically
    Allocated `d_array`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-1：** 静态分配的`s_array`和动态分配的`d_array`比较'
- en: '| **Expression** | **Value** | **Type** |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** | **值** | **类型** |'
- en: '| `s_array` | base address of array in memory | (static) array of integers
    |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `s_array` | 数组在内存中的基地址 | （静态）整型数组 |'
- en: '| `d_array` | base address of array in memory | integer pointer (`int *`) |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `d_array` | 数组在内存中的基地址 | 整型指针（`int *`） |'
- en: 'Because the names of both variables evaluate to the base address of the array
    in memory (the address of the first element memory), the semantics of the `[i]`
    syntax following the name of the variable remain the same for both: `[i]` *dereferences
    the* int *storage location at offset* i *from the base address of the array in
    memory*—it’s accessing the `i`th element.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 因为两个变量的名称都求值为数组在内存中的基地址（即第一个元素的地址），所以在变量名称后面的`[i]`语法对于两者的语义保持一致：`[i]` *解引用*
    int *存储位置，偏移量为* i *，从数组的基地址开始访问内存*——这就是在访问数组的第`i`个元素。
- en: 'For most purposes, we recommend using the `[i]` syntax to access the elements
    of a dynamically allocated array. However, programs can also use the pointer dereferencing
    syntax (the `*` operator) to access array elements. For example, placing a `*`
    in front of a pointer that refers to a dynamically allocated array will dereference
    the pointer to access element 0 of the array:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数情况，我们建议使用`[i]`语法来访问动态分配数组的元素。然而，程序也可以使用指针解引用语法（`*`操作符）来访问数组元素。例如，将`*`放在指向动态分配数组的指针前面，将解引用该指针来访问数组的第0个元素：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The “Arrays in C” section on [page 81](ch02.xhtml#lev1_13) describes arrays
    in more detail, and the “Pointer Arithmetic” section on [page 224](ch02.xhtml#lev2_39)
    discusses accessing array elements through pointer variables.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[第81页](ch02.xhtml#lev1_13)的“C语言中的数组”一节更详细地描述了数组， [第224页](ch02.xhtml#lev2_39)的“指针运算”一节讨论了如何通过指针变量访问数组元素。'
- en: 'When a program is finished using a dynamically allocated array, it should call
    `free` to deallocate the heap space. As mentioned earlier, we recommend setting
    the pointer to `NULL` after freeing it:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序完成使用动态分配的数组时，应调用`free`来释放堆内存。如前所述，我们建议在释放后将指针设置为`NULL`：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: HEAP MEMORY MANAGEMENT, MALLOC AND FREE
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 堆内存管理、MALLOC 和 FREE
- en: The C standard library implements `malloc` and `free`, which are the programming
    interface to its heap memory manager. When called, `malloc` needs to find a contiguous
    chunk of unallocated heap memory space that can satisfy the size of the request.
    The heap memory manager maintains a *free list* of unallocated *extents* of heap
    memory, where each extent specifies the start address and size of a contiguous
    unallocated chunk of heap space.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: C标准库实现了`malloc`和`free`，它们是堆内存管理器的编程接口。当调用`malloc`时，它需要找到一个连续的、未分配的堆内存块，大小满足请求。堆内存管理器维护一个*空闲列表*，该列表记录了未分配的堆内存块，每个块指定了一个未分配的连续堆内存块的起始地址和大小。
- en: Initially, all of heap memory is empty, meaning that the free list has a single
    extent consisting of the entire heap region. After a program has made some calls
    to `malloc` and `free`, heap memory can become *fragmented*, meaning that there
    are chunks of free heap space interspersed with chunks of allocated heap space.
    The heap memory manager typically keeps lists of different ranges of sizes of
    heap space to enable fast searching for a free extent of a particular size. In
    addition, it implements one or more policies for choosing among multiple free
    extents that could be used to satisfy a request.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，所有的堆内存都是空的，这意味着空闲列表中有一个包含整个堆区域的单一区段。在程序进行了一些`malloc`和`free`调用后，堆内存可能会变得*碎片化*，即堆内存中有一些空闲区域夹杂在已分配的堆空间中。堆内存管理器通常会保持不同大小区段的堆空间列表，以便快速查找特定大小的空闲区段。此外，它还实现了一个或多个策略，用于在多个可用的空闲区段中选择一个来满足请求。
- en: The `free` function may seem odd in that it only expects to receive the address
    of the heap space to free without needing the size of the heap space to free at
    that address. That’s because `malloc` not only allocates the requested memory
    bytes, but it also allocates a few additional bytes right before the allocated
    chunk to store a header structure. The header stores metadata about the allocated
    chunk of heap space, such as the size. As a result, a call to `free` only needs
    to pass the address of heap memory to free. The implementation of `free` can get
    the size of the memory to free from the header information that is in memory right
    before the address passed to `free`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`free`函数可能看起来有些奇怪，因为它只期望接收要释放的堆空间的地址，而不需要知道释放该地址的堆空间的大小。这是因为`malloc`不仅分配了请求的内存字节，还在分配的块前面额外分配了几个字节来存储头结构。头结构存储有关已分配堆空间块的元数据，例如大小。因此，`free`的调用只需要传递要释放的堆内存的地址。`free`的实现可以通过地址前的头信息获取要释放的内存大小。'
- en: For more information about heap memory management, see an OS textbook (for example,
    Chapter 17, “Free Space Management,” in *OS in Three Easy Pieces* covers these
    details).^([1](ch02.xhtml#fn2_1))
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于堆内存管理的信息，请参考操作系统教材（例如，《*OS in Three Easy Pieces*》第17章“空闲空间管理”详细介绍了这些内容）。^([1](ch02.xhtml#fn2_1))
- en: 2.4.4 Pointers to Heap Memory and Functions
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.4 指向堆内存的指针和函数
- en: 'When passing a dynamically allocated array to a function, the pointer variable
    argument’s *value* is passed to the function (i.e., the base address of the array
    in the heap is passed to the function). Thus, when passing either statically declared
    or dynamically allocated arrays to functions, the parameter gets exactly the same
    value—the base address of the array in memory. As a result, the same function
    can be used for statically and dynamically allocated arrays of the same type,
    and identical syntax can be used inside the function for accessing array elements.
    The parameter declarations `int *arr` and `int` `arr[]` are equivalent. However,
    by convention, the pointer syntax tends to be used for functions that may be called
    with dynamically allocated arrays:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当将动态分配的数组传递给一个函数时，指针变量参数的*值*被传递给函数（即数组在堆中的基地址被传递给函数）。因此，无论是将静态声明的数组还是动态分配的数组传递给函数，参数得到的值都是完全相同的——数组在内存中的基地址。因此，同一个函数可以用于静态和动态分配的相同类型数组，并且可以在函数内部使用相同的语法访问数组元素。参数声明`int
    *arr`和`int arr[]`是等价的。然而，按照约定，指针语法通常用于可能使用动态分配数组的函数：
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: At the point just before returning from the `init_array` function, the contents
    of memory will look like [Figure 2-9](ch02.xhtml#ch2fig9). Note that `main` only
    passes the base address of the array to `init_array`. The array’s large block
    of contiguous memory remains on the heap, but the function can access it by dereferencing
    the `arr` pointer parameter.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在`init_array`函数即将返回时，内存的内容将如下图所示 [图2-9](ch02.xhtml#ch2fig9)。请注意，`main`只将数组的基地址传递给`init_array`。数组的大块连续内存仍然位于堆上，但该函数可以通过解引用`arr`指针参数来访问它。
- en: '![image](../images/02fig09.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig09.jpg)'
- en: '*Figure 2-9: The contents of memory prior to returning from `init_array`. Both
    `main`’s `arr1` and `init_array`’s `arr` variable point to the same block of heap
    memory.*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-9：`init_array`函数返回前的内存内容。`main`的`arr1`和`init_array`的`arr`变量指向同一块堆内存。*'
- en: 2.5 Arrays in C
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5 C语言中的数组
- en: In “Introduction to Arrays” on [page 44](ch01.xhtml#lev2_9), we introduced statically
    declared one-dimensional C arrays and discussed the semantics of passing arrays
    to functions. In “Dynamic Memory Allocation” on [page 136](ch02.xhtml#lev1_12),
    we introduced dynamically allocated one-dimensional arrays and discussed the semantics
    of passing them to functions.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在《数组简介》一节中（[第44页](ch01.xhtml#lev2_9)），我们介绍了静态声明的一维C数组，并讨论了将数组传递给函数的语义。在《动态内存分配》一节（[第136页](ch02.xhtml#lev1_12)），我们介绍了动态分配的一维数组，并讨论了将其传递给函数的语义。
- en: In this section, we take a more in-depth look at arrays in C. We describe both
    statically and dynamically allocated arrays in more detail and discuss two-dimensional
    arrays.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更深入地探讨C语言中的数组。我们将更详细地描述静态和动态分配的数组，并讨论二维数组。
- en: 2.5.1 Single-Dimensional Arrays
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.5.1 一维数组
- en: Statically Allocated
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 静态分配
- en: Before jumping into new content, we briefly summarize static arrays with an
    example. See “Introduction to Arrays” on [page 44](ch01.xhtml#lev2_9) for more
    detail on statically declared one-dimensional arrays.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解新内容之前，我们简要总结一下静态数组，并给出一个示例。有关静态声明的一维数组的更多细节，请参见[第44页](ch01.xhtml#lev2_9)的《数组简介》。
- en: Statically declared arrays are allocated either on the stack (for local variables)
    or in the data region of memory (for global variables). A programmer can declare
    an array variable by specifying its type (the type stored at each index) and its
    total capacity (number of elements).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 静态声明的数组要么在栈上分配（用于局部变量），要么在内存的数据区分配（用于全局变量）。程序员可以通过指定数组的类型（每个索引处存储的类型）和总容量（元素数量）来声明一个数组变量。
- en: When passing an array to a function, C copies the value of the base address
    to the parameter. That is, both the parameter and the argument refer to the same
    memory locations—the parameter pointer points to the argument’s array elements
    in memory. As a result, modifying the values stored in the array through an array
    parameter modifies the values stored in the argument array.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当将数组传递给函数时，C语言会将基地址的值复制到参数中。也就是说，参数和实参引用的是相同的内存位置——参数指针指向实参数组元素在内存中的位置。因此，通过数组参数修改数组中的值会修改实参数组中存储的值。
- en: 'Here are some examples of static array declaration and use:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些静态数组声明和使用的示例：
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Dynamically Allocated
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 动态分配
- en: In “Dynamic Memory Allocation” on [page 74](ch02.xhtml#lev1_12), we introduced
    dynamically allocated one-dimensional arrays, including their access syntax and
    the syntax and semantics of passing dynamically allocated arrays to functions.
    Here, we present a short recap of that information with an example.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在《动态内存分配》一节（[第74页](ch02.xhtml#lev1_12)），我们介绍了动态分配的一维数组，包括其访问语法，以及将动态分配的数组传递给函数的语法和语义。在这里，我们将用一个示例简要回顾这些信息。
- en: 'Calling the `malloc` function dynamically allocates an array on the heap at
    runtime. The address of the allocated heap space can be assigned to a global or
    local pointer variable, which then points to the first element of the array. To
    dynamically allocate space, pass `malloc` the total number of bytes to allocate
    for the array (using the `sizeof` operator to get the size of a specific type).
    A single call to `malloc` allocates a contiguous chunk of heap space of the requested
    size. For example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`malloc`函数会在运行时动态地在堆上分配一个数组。分配的堆空间的地址可以赋给全局或局部指针变量，该指针变量指向数组的第一个元素。要动态分配空间，需要将要分配的总字节数传递给`malloc`（使用`sizeof`运算符来获取特定类型的大小）。一次`malloc`调用会在堆上分配一个请求大小的连续内存块。例如：
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Array Memory Layout
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 数组内存布局
- en: 'Whether an array is statically declared or dynamically allocated via a single
    call to `malloc`, array elements represent contiguous memory locations (addresses):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是静态声明的数组，还是通过单次调用`malloc`动态分配的数组，数组元素都代表着连续的内存位置（地址）：
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The location of element `i` is at an offset `i` from the base address of the
    array. The exact address of the `i`th element depends on the number of bytes of
    the type stored in the array. For example, consider the following array declarations:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 元素`i`的位置位于数组基地址的偏移量`i`处。第`i`个元素的确切地址取决于数组中存储的类型所占的字节数。例如，考虑以下数组声明：
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The addresses of their individual array elements might look something like
    this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 它们各个数组元素的地址可能如下所示：
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this example, `1230` is the base address of `iarray` and `1280` the base
    address of `carray`. Note that individual elements of each array are allocated
    to contiguous memory addresses: each element of `iarray` stores a four-byte `int`
    value, so its element addresses differ by four, and each element of `carray` stores
    a one-byte `char` value, so its addresses differ by one. There is no guarantee
    that the set of local variables are allocated to contiguous memory locations on
    the stack (hence, there could be a gap in the addresses between the end of `iarray`
    and the start of `carray`, as shown in this example).'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`1230` 是 `iarray` 的基地址，`1280` 是 `carray` 的基地址。请注意，每个数组的单个元素分配到连续的内存地址：`iarray`
    的每个元素存储一个四字节的 `int` 值，因此其元素地址相差四，而 `carray` 的每个元素存储一个一字节的 `char` 值，因此其地址相差一。需要注意的是，局部变量的集合并不保证在栈上分配到连续的内存位置（因此，在
    `iarray` 末尾和 `carray` 开始之间可能会有一个地址间隔，如本例所示）。
- en: 2.5.2 Two-Dimensional Arrays
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.5.2 二维数组
- en: C supports multidimensional arrays, but we limit our discussion of multidimensional
    arrays to two-dimensional (2D) arrays, since 1D and 2D arrays are the most commonly
    used by C programmers.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: C 支持多维数组，但我们将多维数组的讨论限制为二维数组（2D），因为 1D 和 2D 数组是 C 程序员最常用的。
- en: Statically Allocated 2D Arrays
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 静态分配的二维数组
- en: 'To statically declare a multidimensional array variable, specify the size of
    each dimension. For example:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要静态声明一个多维数组变量，必须指定每个维度的大小。例如：
- en: '[PRE31]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, `matrix` is a 2D array of `int` values with 50 rows and 100 columns, and
    `little` is a 2D array of `short` values with 10 rows and 10 columns.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`matrix` 是一个具有 50 行 100 列的 `int` 类型二维数组，`little` 是一个具有 10 行 10 列的 `short`
    类型二维数组。
- en: 'To access an individual element, indicate both the row and the column index:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问单个元素，必须同时指定行和列索引：
- en: '[PRE32]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[Figure 2-10](ch02.xhtml#ch2fig10) illustrates the 2D array as a matrix of
    integer values, where a specific element in the 2D array is indexed by row and
    column index values.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-10](ch02.xhtml#ch2fig10) 演示了将二维数组表示为整数值矩阵的情况，其中二维数组中的特定元素是通过行索引和列索引值来索引的。'
- en: '![image](../images/02fig10.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig10.jpg)'
- en: '*Figure 2-10: A two-dimensional array represented as a matrix. Accessing matrix[2][3]
    is like indexing into a grid at row 2 and column 3.*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-10：一个二维数组表示为矩阵。访问 `matrix[2][3]` 就像在第 2 行第 3 列索引网格一样。*'
- en: 'Programs often access the elements of a 2D array by iterating with nested loops.
    For example, the following nested loop initializes all elements in `matrix` to
    0:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 程序通常通过嵌套循环迭代来访问二维数组的元素。例如，下面的嵌套循环将 `matrix` 中的所有元素初始化为 0：
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Two-Dimensional Array Parameters
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 二维数组参数
- en: 'The same rules for passing one-dimensional array arguments to functions apply
    to passing two-dimensional array arguments: the parameter gets the value of the
    base address of the 2D array (`&arr[0][0]`). In other words, the parameter points
    to the argument’s array elements and therefore the function can change values
    stored in the passed array.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 将一维数组作为参数传递给函数的规则同样适用于将二维数组作为参数传递：参数获取二维数组的基地址的值（`&arr[0][0]`）。换句话说，参数指向传入数组的元素，因此该函数可以修改传入数组中存储的值。
- en: 'For multidimensional array parameters, you must indicate that the parameter
    is a multidimensional array, but you can leave the size of the first dimension
    unspecified (for good generic design). The sizes of other dimensions must be fully
    specified so that the compiler can generate the correct offsets into the array.
    Here’s a 2D example:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多维数组参数，必须指明该参数是多维数组，但可以不指定第一个维度的大小（以便于良好的通用设计）。其他维度的大小必须完全指定，以便编译器能够生成正确的偏移量。下面是一个二维的例子：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Both the `matrix` and the `bigger` arrays can be passed as arguments to the
    `init_matrix` function because they have the same column dimension as the parameter
    definition.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`matrix` 和 `bigger` 数组可以作为参数传递给 `init_matrix` 函数，因为它们的列维度与参数定义相同。'
- en: '**Note**'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The column dimension must be specified in the parameter definition of a 2D array
    so that the compiler can calculate the offset from the base address of the 2D
    array to the start of a particular row of elements. The offset calculation follows
    from the layout of 2D arrays in memory.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 必须在二维数组的参数定义中指定列维度，以便编译器能够计算从二维数组基地址到特定行元素起始位置的偏移量。偏移量的计算遵循二维数组在内存中的布局。
- en: Two-Dimensional Array Memory Layout
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 二维数组内存布局
- en: Statically allocated 2D arrays are arranged in memory in *row-major order*,
    meaning that all of row 0’s elements come first, followed by all of row 1’s elements,
    and so on. For example, given the following declaration of a 2D array of integers
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分配的二维数组在内存中的排列是 *行主序*，意味着首先存储第 0 行的所有元素，然后是第 1 行的所有元素，依此类推。例如，给定以下声明的整数类型二维数组：
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: its layout in memory might look like [Figure 2-11](ch02.xhtml#ch2fig11).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 它在内存中的布局可能如下所示：[图 2-11](ch02.xhtml#ch2fig11)。
- en: '![image](../images/02fig11.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig11.jpg)'
- en: '*Figure 2-11: The layout of a two-dimensional array in row-major order*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-11：二维数组的行主序内存布局*'
- en: Note that all array elements are allocated to contiguous memory addresses. That
    is, the base address of the 2D array is the memory address of the `[0][0]` element
    (`&arr[0][0]`), and subsequent elements are stored contiguously in row-major order
    (e.g., the entirety of row 1 is followed immediately by the entirety of row 2,
    and so on).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有数组元素都会被分配到连续的内存地址中。也就是说，二维数组的基地址是 `[0][0]` 元素的内存地址（`&arr[0][0]`），其后的元素按照行主序连续存储（例如，第
    1 行的所有元素紧跟着第 2 行的所有元素，依此类推）。
- en: Dynamically Allocated 2D Arrays
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 动态分配的二维数组
- en: 'Dynamically allocated 2D arrays can be allocated in two ways. For an *N* ×
    *M* 2D array, either:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分配的二维数组可以通过两种方式进行分配。对于一个 *N* × *M* 的二维数组，可以选择以下两种方式：
- en: 1\. Make a single call to `malloc`, allocating one large chunk of heap space
    to store all *N* × *M* array elements.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 通过一次调用 `malloc`，分配一个大块的堆空间来存储所有 *N* × *M* 数组元素。
- en: 2\. Make multiple calls to `malloc`, allocating an array of arrays. First, allocate
    a 1D array of *N* pointers to the element type, with a 1D array of pointers for
    each row in the 2D array. Then, allocate *N* 1D arrays of size *M* to store the
    set of column values for each row in the 2D array. Assign the addresses of each
    of these *N* arrays to the elements of the first array of *N* pointers.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 多次调用 `malloc`，分配一个数组的数组。首先，分配一个包含 *N* 个指向元素类型的指针的 1D 数组，每一行在二维数组中对应一个指针数组。然后，为每一行分配
    *N* 个大小为 *M* 的 1D 数组，以存储每一行的列值。将这 *N* 个数组的地址赋值给第一个指针数组的 *N* 个元素。
- en: The variable declarations, allocation code, and array element access syntax
    differ depending on which of these two methods a programmer chooses to use.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 变量声明、内存分配代码和数组元素访问语法根据程序员选择的两种方法有所不同。
- en: 'Method 1: Memory-Efficient Allocation'
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 方法 1：内存高效分配
- en: In this method, a single call to `malloc` allocates the total number of bytes
    needed to store the *N* × *M* array of values. This method has the benefit of
    being more memory efficient because the entire space for all *N* × *M* elements
    will be allocated at once, in contiguous memory locations.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，通过一次调用 `malloc` 分配所需的字节数来存储 *N* × *M* 的数组值。此方法的优点是更节省内存，因为所有 *N* × *M*
    元素的整个空间会一次性分配，并存储在连续的内存地址中。
- en: 'The call to `malloc` returns the starting address of the allocated space (the
    base address of the array), which (like a 1D array) should be stored in a pointer
    variable. In fact, there is no semantic difference between allocating a 1D or
    2D array using this method: the call to `malloc` returns the starting address
    of a contiguously allocated chunk of heap memory of the requested number of bytes.
    Because allocation of a 2D array using this method looks just like allocation
    for a 1D array, the programmer has to explicitly map 2D row and column indexing
    on top of this single chunk of heap memory space (the compiler has no implicit
    notion of rows or columns and thus cannot interpret double indexing syntax into
    this malloc’ed space).'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `malloc` 会返回分配空间的起始地址（即数组的基地址），该地址应该像 1D 数组一样存储在指针变量中。实际上，使用这种方法分配 1D 或 2D
    数组在语义上没有区别：`malloc` 返回的是一块连续分配的堆内存空间的起始地址，大小为请求的字节数。由于通过这种方法分配二维数组看起来就像是分配 1D
    数组，程序员必须显式地将二维的行列索引映射到这块连续的堆内存空间上（编译器没有行或列的隐式概念，因此无法将双重索引语法解释为分配给这块内存的 `malloc`
    空间）。
- en: 'Here’s an example C code snippet that dynamically allocates a 2D array using
    method 1:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用方法 1 动态分配二维数组的 C 语言代码示例：
- en: '[PRE36]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[Figure 2-12](ch02.xhtml#ch2fig12) shows an example of allocating a 2D array
    using this method and illustrates what memory might look like after the call to
    `malloc`.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-12](ch02.xhtml#ch2fig12) 展示了使用此方法分配二维数组的示例，并说明了 `malloc` 调用后的内存布局。'
- en: '![image](../images/02fig12.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig12.jpg)'
- en: '*Figure 2-12: The results of allocating a 2D array with a single call to `malloc`*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-12：通过一次调用 `malloc` 分配二维数组的结果*'
- en: Like 1D dynamically allocated arrays, the pointer variable for a 2D array is
    allocated on the stack. That pointer is then assigned the value returned by the
    call to `malloc`, which represents the base address of the contiguous chunk of
    *N* × *M* `int` storage locations in the heap memory.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 与一维动态分配数组类似，二维数组的指针变量也是在栈上分配的。然后将返回的`malloc`值赋给该指针，该值表示堆内存中连续的*N* × *M* `int`存储位置的基地址。
- en: Because this method uses a single chunk of malloc’ed space for the 2D array,
    the memory allocation is as efficient as possible (it only requires one call to
    `malloc` for the entire 2D array). It’s the more efficient way to access memory
    due to all elements being located close together in contiguous memory, with each
    access requiring only a single level of indirection from the pointer variable.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此方法使用一个单一的`malloc`分配空间来存储二维数组，因此内存分配效率是最高的（整个二维数组只需要一次`malloc`调用）。由于所有元素都在连续的内存空间中，访问内存的效率更高，每次访问只需要通过指针变量进行一级间接访问。
- en: However, the C compiler does not know the difference between a 2D or 1D array
    allocation using this method. As a result, the double indexing syntax (`[i][j]`)
    of statically declared 2D arrays *cannot* be used when allocating a 2D array using
    this method. Instead, the programmer must explicitly compute the offset into the
    contiguous chunk of heap memory using a function of row and column index values
    (`[i*M + j]`, where `M` is the column dimension).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，C编译器并不区分使用此方法分配的二维数组和一维数组。因此，在使用此方法分配二维数组时，静态声明的二维数组的双重索引语法（`[i][j]`）*无法*使用。相反，程序员必须显式地使用行和列索引值来计算堆内存连续块中的偏移量（`[i*M
    + j]`，其中`M`是列数）。
- en: 'Here’s an example of how a programmer would structure code to initialize all
    the elements of a 2D array:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是程序员初始化二维数组中所有元素的代码结构示例：
- en: '[PRE37]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Method 1 (Single malloc) and Function Parameters
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 方法1（单次malloc）与函数参数
- en: 'The base address of an array of `int` types allocated via a single `malloc`
    is a pointer to an `int`, so it can be passed to a function with an (`int *`)
    parameter. Additionally, the function must be passed row and column dimensions
    so that it can correctly compute offsets into the 2D array. For example:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 通过单次`malloc`分配的`int`类型数组的基地址是指向`int`的指针，因此可以将其传递给一个`int *`类型的函数参数。此外，函数还必须传递行和列的维度，以便它能够正确计算二维数组中的偏移量。例如：
- en: '[PRE38]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Method 2: The Programmer-Friendly Way'
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 方法2：更适合程序员的方式
- en: 'The second method for dynamically allocating a 2D array stores the array as
    an array of *N* 1D arrays (one 1D array per row). It requires *N* + 1 calls to
    `malloc`: one `malloc` for the array of row arrays, and one `malloc` for each
    of the *N* row’s column arrays. As a result, the element locations *within a row*
    are contiguous, but elements are not contiguous across rows of the 2D array. Allocation
    and element access are not as efficient as in method 1, and the type definitions
    for variables can be a bit more confusing. However, using this method, a programmer
    can use double indexing syntax to access individual elements of the 2D array (the
    first index is an index into the array of rows, the second index is an index into
    the array of column elements within that row).'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种动态分配二维数组的方法是将数组存储为*N*个一维数组的数组（每行一个一维数组）。它需要*N* + 1次调用`malloc`：一次`malloc`用于行数组的数组，另外*N*次`malloc`用于每一行的列数组。因此，*在一行内*的元素位置是连续的，但二维数组的各行之间的元素不连续。分配和访问元素的效率不如方法1，且变量的类型定义可能稍微复杂。不过，使用这种方法，程序员可以使用双重索引语法来访问二维数组的各个元素（第一个索引是行数组的索引，第二个索引是该行内列元素的索引）。
- en: 'Here is an example of allocating a 2D array using method 2 (with the error
    detection and handling code removed for readability):'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用方法2分配二维数组的示例（为了可读性，省略了错误检测和处理代码）：
- en: '[PRE39]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this example, note the types of the variables and the sizes passed to the
    calls to `malloc`. To refer to the dynamically allocated 2D array, the programmer
    declares a variable (`two_d_array`) of type `int **` that will store the address
    of a dynamically allocated array of `int *` element values. Each element in `two_d_array`
    stores the address of a dynamically allocated array of `int` values (the type
    of `two_d_array[i]` is `int *`).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，注意变量的类型以及传递给`malloc`调用的大小。为了引用动态分配的二维数组，程序员声明一个`int **`类型的变量（`two_d_array`），它将存储动态分配的`int
    *`元素值数组的地址。`two_d_array`中的每个元素存储一个动态分配的`int`类型数组的地址（`two_d_array[i]`的类型是`int *`）。
- en: '[Figure 2-13](ch02.xhtml#ch2fig13) shows what memory might look like after
    the preceding example’s *N* + 1 calls to `malloc`.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-13](ch02.xhtml#ch2fig13) 显示了在前面的例子中调用 *N* + 1 次 `malloc` 后内存的可能样子。'
- en: '![image](../images/02fig13.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig13.jpg)'
- en: '*Figure 2-13: The arrangement of memory after allocating a 2D array with N
    + 1 `malloc` calls*'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-13：通过 N + 1 次 `malloc` 调用分配二维数组后的内存布局*'
- en: Note that when using this method, only the elements allocated as part of a single
    call to `malloc` are contiguous in memory. That is, elements within each row are
    contiguous, but elements from different rows (even neighboring rows) are not.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在使用此方法时，只有作为单次 `malloc` 调用一部分分配的元素才在内存中是连续的。也就是说，每一行中的元素是连续的，但不同的行（甚至相邻的行）中的元素不是连续的。
- en: Once allocated, individual elements of the 2D array can be accessed using double-indexing
    notation. The first index specifies an element in the outer array of `int *` pointers
    (which row), and the second index specifies an element in the inner `int` array
    (which column within the row).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦分配，二维数组的单个元素可以使用双重索引表示法进行访问。第一个索引指定外部 `int *` 指针数组中的一个元素（即行），第二个索引指定内部 `int`
    数组中的一个元素（即该行内的列）。
- en: '[PRE40]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To understand how double indexing is evaluated, consider the type and value
    of the following parts of the expression:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解双重索引是如何被求值的，请考虑以下表达式各部分的类型和值：
- en: '[PRE41]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Method 2 (An Array of Arrays) and Function Parameters
  id: totrans-247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 方法 2（数组的数组）与函数参数
- en: The array argument’s type is `int **` (a pointer to a pointer to an `int`),
    and the function parameter matches its argument’s type. Additionally, row and
    column sizes should be passed to the function. Because this is a different type
    from method 1, both array types cannot use a common function (they are not the
    same C type).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 数组参数的类型是 `int **`（指向 `int` 的指针的指针），并且函数参数与其参数的类型匹配。此外，行和列的大小应该传递给函数。因为这是与方法
    1 不同的类型，所以这两种数组类型不能使用通用函数（它们不是相同的 C 类型）。
- en: 'Here’s an example function that takes a method 2 (array of arrays) 2D array
    as a parameter:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例函数，它以方法 2（数组的数组）二维数组作为参数：
- en: '[PRE42]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here, the function implementation can use double-indexing syntax. Unlike statically
    declared 2D arrays, both the row and column dimensions need to be passed as parameters:
    the `rows` parameter specifies the bounds on the outermost array (the array of
    row arrays), and the `cols` parameter specifies the bounds on the inner arrays
    (the array column values for each row).'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，函数实现可以使用双重索引语法。与静态声明的二维数组不同，行和列的维度都需要作为参数传递：`rows` 参数指定最外层数组（行数组数组）的边界，`cols`
    参数指定内部数组（每行的列值）的边界。
- en: 2.6 Strings and the String Library
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6 字符串与字符串库
- en: In the previous chapter, we introduced “Arrays and Strings” ([page 44](ch01.xhtml#lev1_5)).
    In this chapter, we discuss dynamically allocated C strings and their use with
    the C string library. We first give a brief overview of statically declared strings.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了“数组和字符串” ([第 44 页](ch01.xhtml#lev1_5))。在本章中，我们将讨论动态分配的 C 字符串及其与 C
    字符串库的使用。我们首先简要概述静态声明的字符串。
- en: 2.6.1 C’s Support for Statically Allocated Strings (Arrays of char)
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.6.1 C 对静态分配字符串（字符数组）的支持
- en: C does not support a separate string type, but a string can be implemented in
    C programs using an array of `char` values that is terminated by a special null
    character value `’\0’`. The terminating null character identifies the end of the
    sequence of character values that make up a string. Not every character array
    is a C string, but every C string is an array of `char` values.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: C 不支持单独的字符串类型，但可以使用由 `char` 值组成的数组来实现 C 程序中的字符串，该数组以特殊的空字符值 `'\0'` 结束。终止空字符标识了构成字符串的字符值序列的结束。并非每个字符数组都是
    C 字符串，但每个 C 字符串都是 `char` 值的数组。
- en: Because strings frequently appear in programs, C provides libraries with functions
    for manipulating strings. Programs that use the C string library need to include
    `string.h`. Most string library functions require the programmer to allocate space
    for the array of characters that the functions manipulate. When printing out the
    value of a string, use the `%s` placeholder.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字符串在程序中经常出现，C 提供了带有字符串操作函数的库。使用 C 字符串库的程序需要包含 `string.h`。大多数字符串库函数要求程序员为这些函数操作的字符数组分配空间。在打印字符串的值时，使用
    `%s` 占位符。
- en: 'Here’s an example program that uses strings and some string library functions:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用字符串和一些字符串库函数的示例程序：
- en: '[PRE43]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 2.6.2 Dynamically Allocating Strings
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.6.2 动态分配字符串
- en: Arrays of characters can be dynamically allocated (as discussed in “C’s Pointer
    Variables” on [page 66](ch02.xhtml#lev1_10) and “Arrays in C” on [page 81](ch02.xhtml#lev1_13)).
    When dynamically allocating space to store a string, it’s important to remember
    to allocate space in the array for the terminating `'\0'` character at the end
    of the string.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 字符数组可以动态分配（如在[第 66 页](ch02.xhtml#lev1_10)的“C 的指针变量”及[第 81 页](ch02.xhtml#lev1_13)的“C
    中的数组”中所讨论）。在动态分配用于存储字符串的空间时，重要的是要记得为字符串末尾的终止 `'\0'` 字符分配数组空间。
- en: 'The following example program demonstrates static and dynamically allocated
    strings (note the value passed to `malloc`):'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例程序演示了静态和动态分配的字符串（注意传递给 `malloc` 的值）：
- en: '[PRE44]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '**Warning C STRING FUNCTIONS AND DESTINATION MEMORY**'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告 C 字符串函数与目标内存**'
- en: Many C string functions (notably `strcpy` and `strcat`) store their results
    by following a *destination* string pointer (`char *`) parameter and writing to
    the location it points to. Such functions assume that the destination contains
    enough memory to store the result. Thus, as a programmer, you must ensure that
    sufficient memory is available at the destination prior to calling these functions.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 C 字符串函数（特别是 `strcpy` 和 `strcat`）通过跟随一个*目标*字符串指针（`char *`）参数并向其指向的位置写入结果来存储它们的结果。这些函数假设目标有足够的内存来存储结果。因此，作为程序员，你必须确保在调用这些函数之前，目标处有足够的内存可用。
- en: 'Failure to allocate enough memory will yield undefined results that range from
    program crashes to major security vulnerabilities (see “Real World: Buffer Overflow”
    on [page 362](ch07.xhtml#lev1_60)). For example, the following calls to `strcpy`
    and `strcat` demonstrate mistakes that novice C programmers often make:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 未分配足够的内存会导致未定义的结果，范围从程序崩溃到严重的安全漏洞（请参见[第 362 页](ch07.xhtml#lev1_60)的“实际案例：缓冲区溢出”）。例如，以下对
    `strcpy` 和 `strcat` 的调用展示了初学 C 语言的程序员常犯的错误：
- en: // Attempt to write a 12-byte string into a 5-character array.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: // 尝试将一个 12 字节的字符串写入一个 5 字符的数组。
- en: char mystr[5];
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: char mystr[5];
- en: strcpy(mystr, "hello world");
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: strcpy(mystr, "hello world");
- en: // Attempt to write to a string with a NULL destination.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: // 尝试向一个 NULL 目标的字符串写入数据。
- en: char *mystr = NULL;
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: char *mystr = NULL;
- en: strcpy(mystr, "try again");
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: strcpy(mystr, "再试一次");
- en: // Attempt to modify a read-only string literal.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: // 尝试修改一个只读的字符串常量。
- en: char *mystr = "string literal value";
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: char *mystr = "字符串常量值";
- en: strcat(mystr, "string literals aren't writable");
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: strcat(mystr, "字符串常量不可写");
- en: 2.6.3 Libraries for Manipulating C Strings and Characters
  id: totrans-275
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.6.3 操作 C 字符串和字符的库
- en: C provides several libraries with functions for manipulating strings and characters.
    The string library (`string.h`) is particularly useful when writing programs that
    use C strings. The `stdlib.h` and `stdio.h` libraries also contain functions for
    string manipulation, and the `ctype.h` library contains functions for manipulating
    individual character values.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: C 提供了几个操作字符串和字符的库。字符串库（`string.h`）在编写使用 C 字符串的程序时尤其有用。`stdlib.h` 和 `stdio.h`
    库也包含用于字符串操作的函数，而 `ctype.h` 库则包含操作单个字符值的函数。
- en: When using C string library functions, it’s important to remember that most
    do not allocate space for the strings they manipulate, nor do they check that
    you pass in valid strings; your program must allocate space for the strings that
    the C string library will use. Furthermore, if the library function modifies the
    passed string, then the caller needs to ensure that the string is correctly formatted
    (i.e., that it has a terminating `’\0’` character at the end). Calling string
    library functions with bad array argument values will often cause a program to
    crash. The documentation (e.g., manual pages) for different library functions
    specifies whether the library function allocates space or if the caller is responsible
    for passing in allocated space to the library function.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 C 字符串库函数时，重要的是要记住，大多数函数不会为它们操作的字符串分配空间，也不会检查你传入的字符串是否有效；你的程序必须为 C 字符串库将使用的字符串分配空间。此外，如果库函数修改了传入的字符串，则调用者需要确保字符串格式正确（即，在字符串末尾有一个终止的
    `'\0'` 字符）。如果传递给字符串库函数的数组参数无效，通常会导致程序崩溃。不同库函数的文档（例如手册页）会指定该函数是否分配空间，或者调用者是否需要将已分配的空间传递给库函数。
- en: '**Note CHAR[] AND CHAR * PARAMETERS AND CHAR * RETURN TYPE**'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意 CHAR[] 和 CHAR * 参数及 CHAR * 返回类型**'
- en: Both statically declared and dynamically allocated arrays of characters can
    be passed to a `char *` parameter because the name of either type of variable
    evaluates to the base address of the array in memory. Declaring the parameter
    as type `char []` will also work for both statically and dynamically allocated
    argument values, but `char *` is more commonly used for specifying the type of
    string (array of `char`) parameters.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 静态声明的字符数组和动态分配的字符数组都可以传递给`char *`参数，因为这两种类型的变量的名称都会被求值为数组在内存中的基地址。将参数声明为类型`char
    []`也适用于静态和动态分配的参数值，但`char *`更常用于指定字符串（`char`数组）参数的类型。
- en: If a function returns a string (its return type is a `char *`), its return value
    can only be assigned to a variable whose type is also `char *`; it cannot be assigned
    to a statically allocated array variable. This restriction exists because the
    name of a statically declared array variable is not a valid *lvalue* (its base
    address in memory cannot be changed; see “Accessing Field Values” on [page 57](ch01.xhtml#lev2_15)),
    so it cannot be assigned a `char *` return value.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数返回一个字符串（其返回类型为`char *`），则它的返回值只能赋给类型为`char *`的变量；不能赋给静态分配的数组变量。这个限制存在是因为静态声明的数组变量的名称不是有效的*lvalue*（其在内存中的基地址不能更改；参见[第57页](ch01.xhtml#lev2_15)的“访问字段值”），因此不能将`char
    *`返回值赋给它。
- en: strlen, strcpy, strncpy
  id: totrans-281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: strlen, strcpy, strncpy
- en: 'The string library provides functions for copying strings and finding the length
    of a string:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串库提供了用于复制字符串和查找字符串长度的函数：
- en: '[PRE45]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `strcpy` function is unsafe to use in situations when the source string
    might be longer than the total capacity of the destination string. In this case,
    one should use `strncpy`. The size parameter stops `strncpy` from copying more
    than `size` characters from the `src` string into the `dst` string. When the length
    of the `src` string is greater than or equal to `size`, `strncpy` copies the first
    `size` characters from `src` to `dst` and does not add a null character to the
    end of the `dst`. As a result, the programmer should explicitly add a null character
    to the end of `dst` after calling `strncpy`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 当源字符串的长度可能大于目标字符串的总容量时，使用`strcpy`函数是非常不安全的。在这种情况下，应使用`strncpy`。`strncpy`的大小参数会限制从`src`字符串复制到`dst`字符串的字符数，不会超过`size`个字符。如果`src`字符串的长度大于或等于`size`，`strncpy`会将`src`的前`size`个字符复制到`dst`，并且不会在`dst`的末尾添加空字符。因此，程序员在调用`strncpy`后，应该显式地在`dst`的末尾添加空字符。
- en: 'Here are some example uses of these functions in a program:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这些函数在程序中的一些示例用法：
- en: '[PRE46]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: strcmp, strncmp
  id: totrans-287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: strcmp, strncmp
- en: The string library also provides a function to compare two strings. Comparing
    string variables using the `==` operator *does not* compare the characters in
    the strings—it compares only the base addresses of the two strings. For example,
    the expression
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串库还提供了一个函数用于比较两个字符串。使用`==`运算符比较字符串变量*并不*比较字符串中的字符——它仅比较两个字符串的基地址。例如，表达式
- en: '[PRE47]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: compares the base address of the `char` array in the heap pointed to by `d_str`
    to the base address of the `str char` array allocated on the stack.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 比较`d_str`指向的堆中`char`数组的基地址与栈上分配的`str char`数组的基地址。
- en: 'To compare the values of the strings, a programmer needs to either write code
    by hand to compare corresponding element values, or use the `strcmp` or `strncmp`
    functions from the string library:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较字符串的值，程序员需要手动编写代码来比较对应的元素值，或者使用字符串库中的`strcmp`或`strncmp`函数：
- en: '[PRE48]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `strcmp` function compares strings character by character based on their
    *ASCII representation* (see “Notes” on [page 189](ch01.xhtml#lev1_8)). In other
    words, it compares the `char` values in corresponding positions of the two parameter
    arrays to produce the result of the string comparison, which occasionally yields
    unintuitive results. For example, the ASCII encoding for the `char` value `’a’`
    is *larger* than the encoding for the `char` value `’Z’`. Thus, `strcmp("aaa",
    "Zoo")` returns a positive value indicating that `"aaa"` is greater than `"Zoo"`,
    and a call to `strcmp("aaa", "zoo")` returns a negative value indicating that
    `"aaa"` is less than `"zoo"`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`strcmp`函数通过比较字符的*ASCII表示*来逐字符比较字符串（参见[第189页](ch01.xhtml#lev1_8)的“注释”）。换句话说，它比较两个参数数组中对应位置的`char`值，得出字符串比较的结果，这有时会产生一些不直观的结果。例如，`char`值`''a''`的ASCII编码*大于*`char`值`''Z''`的编码。因此，`strcmp("aaa",
    "Zoo")`返回一个正值，表示`"aaa"`大于`"Zoo"`，而`strcmp("aaa", "zoo")`返回一个负值，表示`"aaa"`小于`"zoo"`。'
- en: 'Here are some string comparison examples:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些字符串比较的示例：
- en: '[PRE49]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: strcat, strstr, strchr
  id: totrans-296
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: strcat, strstr, strchr
- en: 'String library functions can concatenate strings (note that it’s up to the
    caller to ensure that the destination string has enough space to store the result):'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串库函数可以连接字符串（请注意，确保目标字符串有足够的空间存储结果是调用者的责任）：
- en: '[PRE50]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'It also provides functions for finding substrings or character values in strings:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 它还提供了用于在字符串中查找子字符串或字符值的函数：
- en: '[PRE51]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here are some examples using these functions (we omit some error handling for
    the sake of readability):'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些使用这些函数的示例（为了可读性，我们省略了一些错误处理）：
- en: '[PRE52]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Calls to `strchr` and `strstr` return the address of the first element in the
    parameter array with a matching character value or a matching substring value,
    respectively. This element address is the start of an array of `char` values terminated
    by a `’\0’` character. In other words, `ptr` points to the beginning of a substring
    inside another string. When printing the value of `ptr` as a string with `printf`,
    the character values starting at the index pointed to by `ptr` are printed, yielding
    the results listed in the preceding example.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`strchr`和`strstr`分别返回参数数组中第一个匹配字符值或匹配子字符串值的元素地址。这个元素地址是一个以`'\0'`字符终止的`char`类型值数组的起始地址。换句话说，`ptr`指向另一个字符串中的子字符串的开头。当使用`printf`将`ptr`作为字符串打印时，从`ptr`指向的索引位置开始的字符值将被打印，输出与前面示例中列出的结果相同。
- en: strtok, strtok_r
  id: totrans-304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: strtok, strtok_r
- en: The string library also provides functions that divide a string into tokens.
    A *token* refers to a subsequence of characters in a string separated by any number
    of delimiter characters of the programmer’s choosing.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串库还提供了将字符串划分为标记的函数。*标记*是指字符串中由程序员选择的分隔符字符分隔的字符子序列。
- en: '[PRE53]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `strtok` (or `strtok_r`) functions find individual tokens within a larger
    string. For example, setting `strtok`’s delimiters to the set of whitespace characters
    yields words in a string that originally contains an English sentence. That is,
    each word in the sentence is a token in the string.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`strtok`（或`strtok_r`）函数在较大的字符串中查找单个标记。例如，将`strtok`的分隔符设置为空白字符集合，就会得到一个原本包含英语句子的字符串中的单词。也就是说，句子中的每个单词都是字符串中的一个标记。'
- en: Following is an example program that uses `strtok` to find individual words
    as the tokens in an input string.^([2](ch02.xhtml#fn2_2))
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用`strtok`查找输入字符串中的单个单词作为标记的示例程序。^([2](ch02.xhtml#fn2_2))
- en: '[PRE54]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: sprintf
  id: totrans-310
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: sprintf
- en: 'The C `stdio` library also provides functions that manipulate C strings. Perhaps
    the most useful is the `sprintf` function, which “prints” into a string rather
    than printing output to a terminal:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: C的`stdio`库还提供了操作C字符串的函数。也许最有用的函数是`sprintf`，它将内容“打印”到一个字符串中，而不是将输出打印到终端：
- en: '[PRE55]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`sprintf` initializes the contents of a string from values of various types.
    Its parameter `format` resembles those of `printf` and `scanf`. Here are some
    examples:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`sprintf`通过各种类型的值初始化字符串的内容。它的参数`format`类似于`printf`和`scanf`的参数。以下是一些示例：'
- en: '[PRE56]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Functions for Individual Character Values
  id: totrans-315
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 用于单个字符值的函数
- en: 'The standard C library (`stdlib.h`) contains a set of functions for manipulating
    and testing individual `char` values, including:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 标准C库（`stdlib.h`）包含一组操作和测试单个`char`值的函数，包括：
- en: '[PRE57]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here are some examples of their use:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是它们使用的一些示例：
- en: '[PRE58]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Functions to Convert Strings to Other Types
  id: totrans-320
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将字符串转换为其他类型的函数
- en: '`stdlib.h` also contains functions to convert between strings and other C types.
    For example:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdlib.h`还包含将字符串与其他C类型之间转换的函数。例如：'
- en: '[PRE59]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Here’s an example:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: '[PRE60]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'For more information about these and other C library functions (including what
    they do, their parameter format, what they return, and which headers need to be
    included to use them), see their *man pages*.^([3](ch02.xhtml#fn2_3)) For example,
    to view the `strcpy` man page, run:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这些和其他C库函数的更多信息（包括它们的功能、参数格式、返回值以及需要包含哪些头文件才能使用它们），请参阅它们的*man页面*。^([3](ch02.xhtml#fn2_3))
    例如，要查看`strcpy`的man页面，可以运行：
- en: '[PRE61]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 2.7 C Structs
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.7 C 结构体
- en: In the previous chapter, we introduced C structures in “Structs” on [page 52](ch01.xhtml#lev1_6).
    In this chapter, we dive deeper into C structs, examine statically and dynamically
    allocated structs, and combine structs and pointers to create more complex data
    types and data structures.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们在“结构体”一节（[第52页](ch01.xhtml#lev1_6)）介绍了C结构体。在本章中，我们将深入探讨C结构体，分析静态和动态分配的结构体，并结合结构体和指针创建更复杂的数据类型和数据结构。
- en: We begin with a quick overview of statically declared structs. See the previous
    chapter for more details.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先快速概述静态声明的结构体。更多细节请参见上一章。
- en: 2.7.1 Review of the C struct Type
  id: totrans-330
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.7.1 C结构体类型回顾
- en: A `struct` type represents a heterogeneous collection of data; it’s a mechanism
    for treating a set of different types as a single, coherent unit.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct`类型表示一组异构数据；它是一种将不同类型的数据作为单一统一体处理的机制。'
- en: 'There are three steps to defining and using `struct` types in C programs:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在C程序中定义和使用`struct`类型有三个步骤：
- en: 1\. Define a `struct` type that defines the field values and their types.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 定义一个`struct`类型，该类型定义字段值及其类型。
- en: 2\. Declare variables of the `struct` type.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 声明`struct`类型的变量。
- en: 3\. Use *dot notation* to access individual field values in the variable.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 使用*点符号*来访问变量中的单个字段值。
- en: In C, structs are lvalues (they can appear on the left-hand side of an assignment
    statement; see “Accessing Field Values” on [page 57](ch01.xhtml#lev2_15)). The
    value of a `struct` variable is the contents of its memory (all of the bytes making
    up its field values). When calling functions with `struct` parameters, the value
    of the `struct` argument (a copy of all of the bytes of all of its fields) gets
    copied to the `struct` function parameter.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中，结构体是左值（它们可以出现在赋值语句的左边；详见[第57页](ch01.xhtml#lev2_15)的“访问字段值”）。`struct`变量的值是其内存内容（即构成其字段值的所有字节）。当调用带有`struct`参数的函数时，`struct`参数的值（即参数所有字段字节的副本）会被复制到函数的`struct`参数中。
- en: When programming with structs, and in particular when combining structs and
    arrays, it’s critical to carefully consider the type of every expression. Each
    field in a `struct` represents a specific type, and the syntax for accessing field
    values and the semantics of passing individual field values to functions follow
    those of their specific type.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用结构体编程，特别是当结构体与数组结合使用时，仔细考虑每个表达式的类型至关重要。`struct`中的每个字段代表一个特定的类型，访问字段值的语法和将单个字段值传递给函数的语义遵循其特定类型的规则。
- en: 'The following full example program demonstrates defining a `struct` type, declaring
    variables of that type, accessing field values, and passing structs and individual
    field values to functions (we omit some error handling and comments for readability):'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 以下完整的示例程序演示了如何定义`struct`类型，声明该类型的变量，访问字段值，并将结构体和单个字段值传递给函数（为了可读性，我们省略了一些错误处理和注释）：
- en: struct_review.c
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: struct_review.c
- en: '[PRE62]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'When run, the program produces:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 程序运行时，输出如下：
- en: '[PRE63]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: When working with structs, it’s particularly important to think about the types
    of the `struct` and its fields. For example, when passing a `struct` to a function,
    the parameter gets a copy of the `struct`’s value (a copy of all the bytes from
    the argument). Consequently, changes to the parameter’s field values *do not*
    change the argument’s value. This behavior is illustrated in the preceding program
    in the call to `checkID`, which modifies the parameter’s age field. The changes
    in `checkID` have no effect on the corresponding argument’s age field value.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用结构体时，特别需要考虑`struct`及其字段的类型。例如，在将`struct`传递给函数时，参数会得到`struct`值的副本（即所有字段字节的副本）。因此，对参数字段值的更改*不会*影响原始参数的值。这个行为在之前的程序中通过调用`checkID`得以体现，`checkID`修改了参数的年龄字段，但在`checkID`中的修改并未影响对应参数的年龄字段值。
- en: When passing a field of a `struct` to a function, the semantics match the type
    of the field (the type of the function’s parameter). For example, in the call
    to `changeName`, the value of the `name` field (the base address of the `name`
    array inside the `student2` struct) gets copied to the parameter `old`, meaning
    that the parameter refers to the same set of array elements in memory as its argument.
    Thus, changing an element of the array in the function also changes the element’s
    value in the argument; the semantics of passing the `name` field match the type
    of the `name` field.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 当将`struct`的字段传递给函数时，其语义与字段的类型（函数参数的类型）相匹配。例如，在调用`changeName`时，`name`字段的值（即`student2`结构体中`name`数组的基地址）会被复制到参数`old`中，这意味着该参数引用了与其参数相同的一组内存中的数组元素。因此，在函数中更改数组元素时，也会改变参数中的数组元素值；传递`name`字段的语义与`name`字段的类型相匹配。
- en: 2.7.2 Pointers and Structs
  id: totrans-345
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.7.2 指针与结构体
- en: Just like other C types, programmers can declare a variable as a pointer to
    a user-defined `struct` type. The semantics of using a `struct` pointer variable
    resemble those of other pointer types such as `int *`.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他 C 类型一样，程序员可以声明一个变量作为用户定义的 `struct` 类型的指针。使用 `struct` 指针变量的语义类似于其他指针类型，如
    `int *`。
- en: 'Consider the `struct studentT` type introduced in the previous program example:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑之前程序示例中引入的 `struct studentT` 类型：
- en: '[PRE64]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'A programmer can declare variables of type `struct studentT` or `struct` `studentT
    *` (a pointer to a `struct studentT`):'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员可以声明类型为 `struct studentT` 或 `struct` `studentT *`（指向 `struct studentT` 的指针）的变量：
- en: '[PRE65]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note that the call to `malloc` initializes `sptr` to point to a dynamically
    allocated struct in heap memory. Using the `sizeof` operator to compute `malloc`’s
    size request (e.g., `sizeof(struct studentT)`) ensures that `malloc` allocates
    space for *all* of the field values in the struct.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，调用 `malloc` 会初始化 `sptr`，使其指向堆内存中动态分配的结构体。使用 `sizeof` 运算符计算 `malloc` 的大小请求（例如，`sizeof(struct
    studentT)`）可确保 `malloc` 为结构体中的*所有*字段值分配空间。
- en: 'To access individual fields in a pointer to a `struct`, the pointer variable
    first needs to be *dereferenced*. Based on the rules for pointer dereferencing
    (see “C’s Pointer Variables” on [page 66](ch02.xhtml#lev1_10)), you may be tempted
    to access `struct` fields like so:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问指向 `struct` 的指针中的各个字段，首先需要*解引用*指针变量。根据指针解引用的规则（请参见[第 66 页](ch02.xhtml#lev1_10)的“C
    的指针变量”），你可能会试图像这样访问 `struct` 字段：
- en: '[PRE66]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'However, because pointers to structs are so commonly used, C provides a special
    operator (`->`) that both dereferences a `struct` pointer and accesses one of
    its field values. For example, `sptr->year` is equivalent to `(*sptr).year`. Here
    are some examples of accessing field values using this notation:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于指向结构体的指针使用非常广泛，C 提供了一种特殊运算符（`->`），它同时解引用 `struct` 指针并访问其字段值。例如，`sptr->year`
    相当于 `(*sptr).year`。以下是一些使用此表示法访问字段值的示例：
- en: '[PRE67]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[Figure 2-14](ch02.xhtml#ch2fig14) sketches what the variables `s` and `sptr`
    may look like in memory after the preceding code executes. Recall that `malloc`
    allocates memory from the heap, and local variables are allocated on the stack.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-14](ch02.xhtml#ch2fig14) 描述了在前面的代码执行后，变量 `s` 和 `sptr` 在内存中的可能布局。回想一下，`malloc`
    从堆中分配内存，而局部变量则分配在栈上。'
- en: '![image](../images/02fig14.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig14.jpg)'
- en: '*Figure 2-14: The differences in memory layout between a statically allocated
    struct (data on the stack) and a dynamically allocated struct (data on the heap)*'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-14：静态分配的结构体（栈上的数据）和动态分配的结构体（堆上的数据）在内存布局上的差异*'
- en: 2.7.3 Pointer Fields in Structs
  id: totrans-359
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.7.3 结构体中的指针字段
- en: 'Structs can also be defined to have pointer types as field values. Here’s an
    example:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体也可以定义为具有指针类型的字段值。以下是一个示例：
- en: '[PRE68]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In memory, these variables will look like [Figure 2-15](ch02.xhtml#ch2fig15)
    (note which parts are allocated on the stack and which are on the heap).
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存中，这些变量将类似于[图 2-15](ch02.xhtml#ch2fig15)（请注意哪些部分分配在栈上，哪些分配在堆上）。
- en: '![image](../images/02fig15.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig15.jpg)'
- en: '*Figure 2-15: The layout in memory of a struct with a pointer field*'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-15：具有指针字段的结构体在内存中的布局*'
- en: As structs and the types of their fields increase in complexity, be careful
    with their syntax. To access field values appropriately, start from the outermost
    variable type and use its type syntax to access individual parts. For example,
    the types of the `struct` variables shown in [Table 2-2](ch02.xhtml#ch2tab2) govern
    how a programmer should access their fields.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 随着结构体及其字段类型的复杂性增加，请注意它们的语法。为了正确访问字段值，从最外层的变量类型开始，使用其类型语法来访问各个部分。例如，[表 2-2](ch02.xhtml#ch2tab2)中显示的
    `struct` 变量类型决定了程序员应如何访问它们的字段。
- en: '**Table 2-2:** Struct Field Access Examples'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-2：** 结构体字段访问示例'
- en: '| **Expression** | **Type** | **Field access syntax** |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** | **类型** | **字段访问语法** |'
- en: '| `p1` | `struct personT` | `p1.age, p1.name` |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| `p1` | `struct personT` | `p1.age, p1.name` |'
- en: '| `p2` | `struct personT *` | `p2->age, p2->name` |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| `p2` | `struct personT *` | `p2->age, p2->name` |'
- en: Further, knowing the types of field values allows a program to use the correct
    syntax in accessing them, as shown by the examples in [Table 2-3](ch02.xhtml#ch2tab3).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，了解字段值的类型可以让程序使用正确的语法来访问它们，如[表 2-3](ch02.xhtml#ch2tab3)中的示例所示。
- en: '**Table 2-3:** Accessing Different Struct Field Types'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-3：** 访问不同结构体字段类型'
- en: '| **Expression** | **Type** | **Example access syntax** |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** | **类型** | **示例访问语法** |'
- en: '| `p1.age` | `int` | `p1.age = 18;` |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| `p1.age` | `int` | `p1.age = 18;` |'
- en: '| `p2->age` | `int *` | `p2->age = 18;` |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| `p2->age` | `int *` | `p2->age = 18;` |'
- en: '| `p1.name` | `char *` | `printf("%s", p1.name);` |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| `p1.name` | `char *` | `printf("%s", p1.name);` |'
- en: '| `p2->name` | `char *` | `printf("%s", p2->name);` |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| `p2->name` | `char *` | `printf("%s", p2->name);` |'
- en: '| `p2->name[2]` | `char` | `p2->name[2] = ’a’;` |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| `p2->name[2]` | `char` | `p2->name[2] = ’a’;` |'
- en: 'In examining the last example, start by considering the type of the outermost
    variable (`p2` is a pointer to a `struct personT`). Therefore, to access a field
    value in the struct, the programmer needs to use `->` syntax (`p2->name`). Next,
    consider the type of the `name` field, which is a `char *`, used in this program
    to point to an array of `char` values. To access a specific `char` storage location
    through the `name` field, use array indexing notation: `p2->name[2] =` `’a’`.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查最后一个示例时，首先考虑最外层变量的类型（`p2` 是指向 `struct personT` 的指针）。因此，要访问结构体中的字段值，程序员需要使用
    `->` 语法（`p2->name`）。接下来，考虑 `name` 字段的类型，它是一个 `char *`，在本程序中用于指向一个 `char` 类型值的数组。要通过
    `name` 字段访问特定的 `char` 存储位置，使用数组索引表示法：`p2->name[2] =` `’a’`。
- en: 2.7.4 Arrays of Structs
  id: totrans-379
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.7.4 结构体数组
- en: 'Arrays, pointers, and structs can be combined to create more complex data structures.
    Here are some examples of declaring variables of different types of arrays of
    structs:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 数组、指针和结构体可以结合在一起创建更复杂的数据结构。以下是声明不同类型结构体数组变量的一些示例：
- en: '[PRE69]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Again, thinking very carefully about variable and field types is necessary
    for understanding the syntax and semantics of using these variables in a program.
    Here are some examples of the correct syntax for accessing these variables:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，仔细思考变量和字段的类型对于理解在程序中使用这些变量的语法和语义至关重要。以下是一些正确访问这些变量的语法示例：
- en: '[PRE70]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'A function that takes an array of type `struct studentT *` as a parameter might
    look like this:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 一个接受类型为 `struct studentT *` 的数组作为参数的函数可能是这样的：
- en: '[PRE71]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'A program could pass this function either a statically or dynamically allocated
    array of `struct studentT`:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 一个程序可以将静态或动态分配的 `struct studentT` 数组传递给此函数：
- en: '[PRE72]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The semantics of passing `classroom1` (or `classroom2`) to `updateAges` match
    the semantics of passing a statically declared (or dynamically allocated) array
    to a function: the parameter refers to the same set of elements as the argument
    and thus changes to the array’s values within the function affect the argument’s
    elements.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `classroom1`（或 `classroom2`）传递给 `updateAges` 函数的语义与将静态声明（或动态分配）的数组传递给函数的语义相匹配：参数引用与实参相同的元素集，因此函数中对数组值的更改会影响实参的元素。
- en: '[Figure 2-16](ch02.xhtml#ch2fig16) shows what the stack might look like for
    the second call to the `updateAges` function (showing the passed `classroom2`
    array with example field values for the struct in each of its elements).'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-16](ch02.xhtml#ch2fig16) 显示了第二次调用 `updateAges` 函数时栈的样子（显示传递的 `classroom2`
    数组及每个元素中结构体字段的示例值）。'
- en: '![image](../images/02fig16.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig16.jpg)'
- en: '*Figure 2-16: The memory layout of an array of `struct studentT` passed to
    a function*'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-16：传递给函数的 `struct studentT` 数组的内存布局*'
- en: As always, the parameter gets a copy of the value of its argument (the memory
    address of the array in heap memory). Thus, modifying the array’s elements in
    the function will persist to its argument’s values (both the parameter and the
    argument refer to the same array in memory).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常一样，参数会获得其实参的值的副本（数组在堆内存中的地址）。因此，在函数中修改数组的元素会影响实参的值（参数和实参都指向内存中的同一个数组）。
- en: 'The `updateAges` function cannot be passed the `classroom3` array because its
    type is not the same as the parameter’s type: `classroom3` is an array of `struct`
    `studentT *`, not an array of `struct studentT`.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateAges` 函数不能传递 `classroom3` 数组，因为它的类型与参数的类型不同：`classroom3` 是一个 `struct
    studentT *` 数组，而不是 `struct studentT` 数组。'
- en: 2.7.5 Self-Referential Structs
  id: totrans-394
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.7.5 自引用结构体
- en: A struct can be defined with fields whose type is a pointer to the same `struct`
    type. These self-referential `struct` types can be used to build linked implementations
    of data structures, such as linked lists, trees, and graphs.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 可以定义一个结构体，其字段类型是指向同一 `struct` 类型的指针。这些自引用的 `struct` 类型可用于构建数据结构的链式实现，例如链表、树和图。
- en: The details of these data types and their linked implementations are beyond
    the scope of this book. However, we briefly show one example of how to define
    and use a self-referential `struct` type to create a linked list in C. Refer to
    a textbook on data structures and algorithms for more information about linked
    lists.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据类型及其链式实现的细节超出了本书的范围。然而，我们简要展示了如何定义和使用自引用的`struct`类型来创建一个链表。有关链表的更多信息，请参阅数据结构和算法的教材。
- en: A *linked list* is one way to implement a *list abstract data type*. A list
    represents a sequence of elements that are ordered by their position in the list.
    In C, a list data structure could be implemented as an array or as a linked list
    using a self-referential `struct` type for storing individual nodes in the list.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '*链表*是一种实现*列表抽象数据类型*的方法。列表表示按位置顺序排列的元素序列。在 C 语言中，列表数据结构可以通过数组或使用自引用的`struct`类型来实现，以存储链表中的各个节点。'
- en: 'To build the latter, a programmer would define a `node` struct to contain one
    list element and a link to the next node in the list. Here’s an example that could
    store a linked list of integer values:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建后者，程序员需要定义一个`node`结构体来包含一个列表元素以及指向列表中下一个节点的链接。以下是一个示例，它可以存储一个包含整数值的链表：
- en: '[PRE73]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Instances of this `struct` type can be linked together through the `next` field
    to create a linked list.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这种`struct`类型的实例可以通过`next`字段相互链接，形成一个链表。
- en: 'This example code snippet creates a linked list containing three elements (the
    list itself is referred to by the `head` variable that points to the first node
    in the list):'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码片段创建了一个包含三个元素的链表（该链表本身通过`head`变量指向链表中的第一个节点）：
- en: '[PRE74]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Note that the `temp` variable temporarily points to a malloc’ed `node` that
    gets initialized and then added to the beginning of the list by setting its `next`
    field to point to the node currently pointed to by `head`, and then by changing
    the `head` to point to this new node.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`temp`变量暂时指向一个通过`malloc`分配的`node`，该节点会被初始化并添加到链表的开头，方法是将其`next`字段指向当前由`head`指向的节点，然后将`head`更改为指向这个新节点。
- en: The result of executing this code would look like [Figure 2-17](ch02.xhtml#ch2fig17)
    in memory.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此代码的结果将在内存中呈现如[图 2-17](ch02.xhtml#ch2fig17)所示。
- en: '![image](../images/02fig17.jpg)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig17.jpg)'
- en: '*Figure 2-17: The layout in memory of three example linked list nodes*'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-17：三个示例链表节点在内存中的布局*'
- en: 2.8 I/O in C (Standard and File)
  id: totrans-407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.8 C 语言中的 I/O（标准和文件）
- en: C supports many functions for performing standard I/O as well as file I/O. In
    this section, we discuss some of the most commonly used interfaces for I/O in
    C.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: C 语言支持许多用于执行标准 I/O 以及文件 I/O 的函数。在本节中，我们将讨论一些 C 语言中最常用的 I/O 接口。
- en: 2.8.1 Standard Input/Output
  id: totrans-409
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.8.1 标准输入/输出
- en: 'Every running program begins with three default I/O streams: standard out (`stdout`),
    standard in (`stdin`), and standard error (`stderr`). A program can write (print)
    output to `stdout` and `stderr`, and it can read input values from `stdin`. `stdin`
    is usually defined to read in input from the keyboard, whereas `stdout` and `stderr`
    output to the terminal.'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 每个运行中的程序都从三个默认的 I/O 流开始：标准输出(`stdout`)、标准输入(`stdin`)和标准错误(`stderr`)。程序可以将输出写入`stdout`和`stderr`，并且可以从`stdin`读取输入值。`stdin`通常定义为从键盘读取输入，而`stdout`和`stderr`则输出到终端。
- en: The C `stdio.h` library provides the `printf` function used for printing to
    standard out and the `scanf` function that can be used to read in values from
    standard in. C also has functions to read and write one character at a time (`getchar`
    and `putchar`) as well as other functions and libraries for reading and writing
    characters to standard I/O streams. A C program must explicitly include `stdio.h`
    to call these functions.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: C 语言的`stdio.h`库提供了用于打印输出到标准输出的`printf`函数，以及用于从标准输入读取值的`scanf`函数。C 语言还提供了按字符逐个读取和写入的函数（`getchar`和`putchar`），以及其他用于读写字符到标准
    I/O 流的函数和库。C 程序必须显式地包含`stdio.h`以调用这些函数。
- en: 'You can change the location that a running program’s `stdin`, `stdout` and/
    or `stderr` read from or write to. One way to do this is by redirecting one or
    all of these to read or write to a file. Here are some example shell commands
    for redirecting a program’s `stdin`, `stdout`, or `stderr` to a file (`$` is the
    shell prompt):'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以更改正在运行的程序的`stdin`、`stdout`和/或`stderr`读取或写入的位置。一个方法是将其中一个或全部重定向到文件进行读取或写入。以下是一些示例
    shell 命令，用于将程序的`stdin`、`stdout`或`stderr`重定向到文件（`$`是 shell 提示符）：
- en: '[PRE75]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: printf
  id: totrans-414
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: printf
- en: 'C’s `printf` function resembles formatted `print` calls in Python, where the
    caller specifies a format string to print. The format string often contains special
    format specifiers, including special characters that will print tabs (`\t`) or
    newlines (`\n`), or that specify placeholders for values in the output (`%` followed
    by a type specifier). When adding placeholders in a format string passed to `printf`,
    pass their corresponding values as additional arguments following the format string.
    Here are some example calls to `printf`:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: C语言的`printf`函数类似于Python中的格式化`print`调用，在其中调用者指定一个格式字符串进行输出。格式字符串通常包含特殊的格式说明符，包括可以打印制表符（`\t`）或换行符（`\n`）的特殊字符，或者指定输出值的占位符（`%`后跟类型说明符）。在传递给`printf`的格式字符串中添加占位符时，需将它们相应的值作为附加参数传递给格式字符串。以下是一些`printf`调用的示例：
- en: printf.c
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: printf.c
- en: '[PRE76]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'When run, these `printf` statements output:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 程序运行时，这些`printf`语句的输出为：
- en: '[PRE77]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Note how the tab characters (`\t`) get printed in the second call, and the different
    formatting placeholders for different types of values (`%g`, `%s`, and `%d`).
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在第二次调用中，制表符字符（`\t`）的打印效果，以及不同类型值的不同格式占位符（`%g`、`%s`和`%d`）。
- en: Here’s a set of formatting placeholders for common C types. Note that placeholders
    for `long` and `long long` values include an `l` or `ll` prefix.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于常见C类型的格式占位符集合。请注意，`long`和`long long`类型的占位符包含`l`或`ll`前缀。
- en: '[PRE78]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Here are some examples of their use:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是它们用法的一些示例：
- en: '[PRE79]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'When run, the output will look like this:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 程序运行时，输出将如下所示：
- en: '[PRE80]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'C also allows you to specify the field width with format placeholders. Here
    are some examples:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: C语言还允许你通过格式占位符指定字段宽度。以下是一些示例：
- en: '[PRE81]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Here’s a larger example that uses field width specifiers with placeholders
    in the format string:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个更大的示例，它在格式字符串中使用字段宽度说明符与占位符一起使用：
- en: printf_format.c
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: printf_format.c
- en: '[PRE82]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'When run, the program output looks like this:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 程序运行时，输出将如下所示：
- en: '[PRE83]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Note how the use of tabs and field width in the last three `printf` statements
    result in a tabular output.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 注意最后三个`printf`语句中使用制表符和字段宽度的效果，它们会产生表格形式的输出。
- en: 'Finally, C defines placeholders for displaying values in different representations:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，C语言定义了用于以不同表示形式显示值的占位符：
- en: '[PRE84]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Here is an example using placeholders to print values in different representations:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用占位符打印不同表示形式值的示例：
- en: '[PRE85]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'When run, the program output looks like this:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 程序运行时，输出将如下所示：
- en: '[PRE86]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: scanf
  id: totrans-441
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: scanf
- en: The `scanf` function provides one method for reading in values from `stdin`
    (usually from the user entering them via the keyboard) and storing them in program
    variables. The `scanf` function is a bit picky about the exact format in which
    the user enters data, which can make it sensitive to badly formed user input.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '`scanf`函数提供了一种从`stdin`（通常是用户通过键盘输入）读取值并将其存储到程序变量中的方法。`scanf`函数对用户输入数据的确切格式比较挑剔，这可能导致它对格式不正确的用户输入很敏感。'
- en: 'The arguments to the `scanf` function are similar to those of `printf`: `scanf`
    takes a format string that specifies the number and type of input values to read
    in, followed by the *locations* of program variables into which the values should
    be stored. Programs typically combine the *address of* (`&`) operator with a variable
    name to produce the location of the variable in the program’s memory—the memory
    address of the variable. Here’s an example call to `scanf` that reads in two values
    (an `int` and a `float`):'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '`scanf`函数的参数类似于`printf`函数的参数：`scanf`接受一个格式字符串，该字符串指定要读取的输入值的数量和类型，后跟程序变量的*位置*，即存储这些值的变量地址。程序通常将*地址运算符*（`&`）与变量名结合使用，以产生变量在程序内存中的位置——即变量的内存地址。下面是一个调用`scanf`的示例，它读取两个值（一个`int`类型和一个`float`类型）：'
- en: scanf_ex.c
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: scanf_ex.c
- en: '[PRE87]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Individual input values must be separated by at least one whitespace character
    (e.g., spaces, tabs, newlines). However, `scanf` skips over leading and trailing
    whitespace characters as it finds the start and end of each numeric literal value.
    As a result, a user could enter the value 8 and 3.14 with any amount of whitespace
    before or after the two values (and at least one or more whitespace characters
    between), and `scanf` will always read in 8 and assign it to `x` and read in 3.14
    and assign it to `pi`. For example, this input with lots of spaces between the
    two values will result in reading in 8 and storing it in `x`, and 3.14 and storing
    in `pi`:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 各个输入值必须至少由一个空白字符（如空格、制表符、换行符）分隔。然而，`scanf` 会跳过前导和尾随的空白字符，来确定每个数字字面值的开始和结束。因此，用户可以在输入值
    8 和 3.14 之前或之后任意添加空白字符（并且至少需要在两个值之间有一个或多个空白字符），`scanf` 将始终读取 8 并将其赋值给 `x`，并读取
    3.14 并将其赋值给 `pi`。例如，以下输入包含大量空格分隔的两个值，最终会将 8 读取并存储到 `x` 中，3.14 读取并存储到 `pi` 中：
- en: '[PRE88]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Programmers often write format strings for `scanf` that only consist of placeholder
    specifiers without any other characters between them. For reading in the two numbers
    in the preceding example, the format string might look like:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员经常为 `scanf` 编写仅由占位符说明符组成的格式字符串，其中没有其他字符。在前面的示例中，读取两个数字的格式字符串可能如下所示：
- en: '[PRE89]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: getchar and putchar
  id: totrans-450
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: getchar 和 putchar
- en: The C functions `getchar` and `putchar` respectively read or write a single
    character value from `stdin` and to `stdout`. `getchar` is particularly useful
    in C programs that need to support careful error detection and handling of badly
    formed user input (`scanf` is not robust in this way).
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: C 函数 `getchar` 和 `putchar` 分别从 `stdin` 读取或写入一个字符值到 `stdout`。`getchar` 在需要支持精确错误检测和处理格式不正确的用户输入的
    C 程序中尤其有用（`scanf` 在这方面不够健壮）。
- en: '[PRE90]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 2.8.2 File Input/Output
  id: totrans-453
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.8.2 文件输入/输出
- en: 'The C standard I/O library (`stdio.h`) includes a stream interface for file
    I/O. A *file* stores persistent data: data that lives beyond the execution of
    the program that created it. A text file represents a stream of characters, and
    each open file tracks its current position in the character stream. When opening
    a file, the current position starts at the very first character in the file, and
    it moves as a result of every character read (or written) to the file. To read
    the 10th character in a file, the first nine characters need to first be read
    (or the current position must be explicitly moved to the 10th character using
    the `fseek` function).'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: C 标准 I/O 库（`stdio.h`）包含一个文件 I/O 的流接口。*文件* 存储持久数据：即超越创建它的程序执行生命周期的数据。文本文件表示一个字符流，每个打开的文件会跟踪其在字符流中的当前位置。打开文件时，当前位置从文件中的第一个字符开始，并且每次读取（或写入）字符时，当前位置都会发生变化。要读取文件中的第
    10 个字符，首先需要读取前九个字符（或者可以通过 `fseek` 函数显式地将当前位置移动到第 10 个字符）。
- en: C’s file interface views a file as an input or output stream, and library functions
    read from or write to the next position in the file stream. The `fprintf` and
    `fscanf` functions serve as the file I/O counterparts to `printf` and `scanf`.
    They use a format string to specify what to write or read, and they include arguments
    that provide values or storage for the data that gets written or read. Similarly,
    the library provides the `fputc`, `fgetc`, `fputs`, and `fgets` functions for
    reading and writing individual characters or strings to file streams. Although
    there are many libraries that support file I/O in C, we present only the `stdio.h`
    library’s stream interface to text files in detail.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: C 的文件接口将文件视为输入或输出流，库函数从文件流的下一个位置读取或写入数据。`fprintf` 和 `fscanf` 函数是 `printf` 和
    `scanf` 的文件 I/O 对应函数。它们使用格式字符串来指定要写入或读取的内容，并且包含提供值或存储空间的参数，这些值或存储空间用于存储写入或读取的数据。同样，库还提供了
    `fputc`、`fgetc`、`fputs` 和 `fgets` 函数，用于从文件流中读取和写入单个字符或字符串。虽然有许多库支持 C 的文件 I/O，但我们仅详细介绍
    `stdio.h` 库对文本文件的流接口。
- en: 'Text files may contain special chars like the `stdin` and `stdout` streams:
    newlines (`’\n’`), tabs (`’\t’`), etc. Additionally, upon reaching the end of
    a file’s data, C’s I/O library generates a special end-of-file character (`EOF`)
    that represents the end of the file. Functions reading from a file can test for
    `EOF` to determine when they have reached the end of the file stream.'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 文本文件可能包含特殊字符，如 `stdin` 和 `stdout` 流：换行符（`’\n’`）、制表符（`’\t’`）等。此外，当到达文件数据的末尾时，C
    的 I/O 库会生成一个特殊的文件结束符字符（`EOF`），表示文件的结束。读取文件的函数可以通过测试 `EOF` 来确定何时到达文件流的末尾。
- en: 2.8.3 Using Text Files in C
  id: totrans-457
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.8.3 在 C 中使用文本文件
- en: To read or write a file in C, follow these steps.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 C 语言中读取或写入文件，按照以下步骤操作。
- en: 'First, *declare* a `FILE *` variable:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，*声明*一个 `FILE *` 变量：
- en: '[PRE91]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: These declarations create pointer variables to a library-defined `FILE` type.
    These pointers cannot be dereferenced in an application program. Instead, they
    refer to a specific file stream when passed to I/O library functions.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 这些声明创建了指向库定义的 `FILE` 类型的指针变量。这些指针不能在应用程序中解引用。相反，当传递给 I/O 库函数时，它们指向特定的文件流。
- en: 'Second, *open* the file: associate the variable with an actual file stream
    by calling `fopen`. When opening a file, the *mode* parameter determines whether
    the program opens it for reading (`"r"`), writing (`"w"`), or appending (`"a"`):'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，*打开*文件：通过调用 `fopen` 将变量与实际的文件流关联。当打开文件时，*模式*参数决定程序是以读取（`"r"`）、写入（`"w"`）还是追加（`"a"`）模式打开文件：
- en: '[PRE92]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The `fopen` function returns `NULL` to report errors, which may occur if it’s
    given an invalid filename or the user doesn’t have permission to open the specified
    file (e.g., not having write permission to the `output.txt` file).
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '`fopen` 函数返回 `NULL` 来报告错误，如果提供了无效的文件名或用户没有权限打开指定的文件（例如，没有写入 `output.txt` 文件的权限），可能会发生此类错误。'
- en: 'Third, *use* I/O operations to read, write, or move the current position in
    the file:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，*使用* I/O 操作来读取、写入或移动文件中的当前位置：
- en: '[PRE93]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Finally, *close* the file: use `fclose` to close the file when the program
    no longer needs it:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*关闭*文件：当程序不再需要文件时，使用 `fclose` 关闭文件：
- en: '[PRE94]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The `stdio` library also provides functions to change the current position
    in a file:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdio` 库还提供了更改文件中当前位置的函数：'
- en: '[PRE95]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 2.8.4 Standard and File I/O Functions in stdio.h
  id: totrans-471
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.8.4 stdio.h 中的标准和文件 I/O 函数
- en: 'The C `stdio.h` library has many functions for reading and writing to files
    and to the standard file-like streams (`stdin`, `stdout`, and `stderr`). These
    functions can be classified into character-based, string-based, and formatted
    I/O functions. Here’s some additional details about a subset of these functions:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: C 语言的 `stdio.h` 库提供了许多用于读取和写入文件以及标准文件流（`stdin`、`stdout` 和 `stderr`）的函数。这些函数可以分为基于字符、基于字符串和格式化的
    I/O 函数。以下是这些函数的一个子集的详细信息：
- en: '[PRE96]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: In general, `scanf` and `fscanf` are sensitive to badly formed input. However,
    for file I/O, often programmers can assume that an input file is well formatted,
    so `fscanf` may be robust enough in such cases. With `scanf`, badly formed user
    input will often cause a program to crash. Reading in one character at a time
    and including code to test values before converting them to different types is
    more robust, but it requires the programmer to implement more complex I/O functionality.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，`scanf` 和 `fscanf` 对格式不正确的输入非常敏感。然而，对于文件 I/O，程序员通常可以假设输入文件格式良好，因此在这种情况下，`fscanf`
    可能足够健壮。而 `scanf` 在处理格式不正确的用户输入时，通常会导致程序崩溃。逐字符读取并在转换为不同类型之前检查值的代码更为健壮，但它需要程序员实现更复杂的
    I/O 功能。
- en: 'The format string for `fscanf` can include the following syntax specifying
    different types of values and ways of reading from the file stream:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '`fscanf` 的格式字符串可以包含以下语法，指定不同类型的值以及从文件流中读取数据的方式：'
- en: '[PRE97]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: It can be tricky to get the `fscanf` format string correct, particularly when
    reading a mix of numeric and string or character types from a file.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 获取正确的 `fscanf` 格式字符串可能会很棘手，特别是在从文件中读取混合了数字、字符串或字符类型的数据时。
- en: 'Here are a few example calls to `fscanf` (and one to `fprintf`) with different
    format strings (let’s assume that the `fopen` calls from the previous example
    have executed successfully):'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些调用 `fscanf`（以及一次调用 `fprintf`）的示例，使用了不同的格式字符串（假设之前示例中的 `fopen` 调用已成功执行）：
- en: '[PRE98]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: In the final example in the preceding code, the format string explicitly reads
    in a character value after a number to ensure that the file stream’s current position
    gets properly advanced for any subsequent calls to `fscanf`. For example, this
    pattern is often used to explicitly read in (and discard) a whitespace character
    (like *\n*), to ensure that the next call to `fscanf` begins from the next line
    in the file. Reading an additional character is necessary if the *next* call to
    `fscanf` attempts to read in a character value. Otherwise, having not consumed
    the newline, the next call to `fscanf` will read the newline rather than the intended
    character. If the next call reads in a numeric type value, then leading whitespace
    chars are automatically discarded by `fscanf` and the programmer does not need
    to explicitly read the `\n` character from the file stream.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，格式字符串明确地在数字后读取一个字符值，以确保文件流的当前位置被正确地推进，以便后续的 `fscanf` 调用能够正常进行。例如，这种模式常常用于显式地读取（并丢弃）一个空白字符（如
    *\n*），以确保下一次调用 `fscanf` 从文件中的下一行开始。如果下一次调用 `fscanf` 尝试读取一个字符值，那么读取额外的字符是必要的。否则，如果没有消耗换行符，下一次调用
    `fscanf` 将会读取换行符，而不是预期的字符。如果下一次调用读取的是一个数值类型，`fscanf` 会自动丢弃前导的空白字符，程序员无需显式地从文件流中读取
    `\n` 字符。
- en: 2.9 Some Advanced C Features
  id: totrans-481
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.9 一些高级 C 特性
- en: 'Almost all of the C programming language has been presented in previous sections.
    In this section, we cover a few remaining advanced C language features and some
    advanced C programming and compiling topics:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: C 编程语言的大部分内容已经在前面的章节中介绍过。在本节中，我们将讨论一些剩余的高级 C 语言特性以及一些高级 C 编程和编译话题：
- en: the C `switch` statement ([page 122](ch02.xhtml#lev2_36))
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C 中的 `switch` 语句（[第 122 页](ch02.xhtml#lev2_36)）
- en: command line arguments ([page 125](ch02.xhtml#lev2_37))
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行参数（[第 125 页](ch02.xhtml#lev2_37)）
- en: the `void *` type and type recasting ([page 126](ch02.xhtml#lev2_38))
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void *` 类型和类型转换（[第 126 页](ch02.xhtml#lev2_38)）'
- en: pointer arithmetic ([page 128](ch02.xhtml#lev2_39))
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针运算（[第 128 页](ch02.xhtml#lev2_39)）
- en: 'C libraries: using, compiling, and linking ([page 133](ch02.xhtml#lev2_40))'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C 库：使用、编译和链接（[第 133 页](ch02.xhtml#lev2_40)）
- en: writing and using your own C libraries (and dividing your program into multiple
    modules (`.c` and `.h` files); [page 139](ch02.xhtml#lev2_41))
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写和使用你自己的 C 库（并将程序划分为多个模块（`.c` 和 `.h` 文件）；[第 139 页](ch02.xhtml#lev2_41)）
- en: compiling C source to assembly code ([page 145](ch02.xhtml#lev2_42)).
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 C 源代码编译为汇编代码（[第 145 页](ch02.xhtml#lev2_42)）。
- en: 2.9.1 switch Statements
  id: totrans-490
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.9.1 `switch` 语句
- en: The C `switch` statement can be used in place of some, but not all, chaining
    `if`–`else if` code sequences. While `switch` doesn’t provide any additional expressive
    power to the C programming language, it often yields more concise code branching
    sequences. It may also allow the compiler to produce branching code that executes
    more efficiently than equivalent chaining `if`–`else if` code.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: C 的 `switch` 语句可以用来替代部分（但不是所有）链式的 `if`–`else if` 代码序列。虽然 `switch` 并没有为 C 编程语言提供额外的表达能力，但它通常能够生成更简洁的代码分支序列。它也可能允许编译器生成比等效的链式
    `if`–`else if` 代码更高效的分支代码。
- en: 'The C syntax for a `switch` statement looks like:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: C 语言中 `switch` 语句的语法如下：
- en: '[PRE99]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'A switch statement is executed as follows:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 语句的执行过程如下：'
- en: 1\. The <expression> evaluates first.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 1. <expression> 先进行求值。
- en: 2\. Next, the `switch` searches for a `case` literal value that matches the
    value of the expression.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 接下来，`switch` 会查找与表达式值匹配的 `case` 字面量值。
- en: 3\. Upon finding a matching `case` literal, it begins executing the <statements>
    that immediately follow it.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 找到匹配的 `case` 字面量后，开始执行紧随其后的 <statements>。
- en: 4\. If no matching `case` is found, it will begin executing the <statements>
    in the `default` label if one is present.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 如果没有找到匹配的 `case`，并且存在 `default` 标签，则开始执行 `default` 标签下的 <statements>。
- en: 5\. Otherwise, no statements in the body of the `switch` statement get executed.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 否则，`switch` 语句体中的语句将不会被执行。
- en: 'A few rules about `switch` statements:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `switch` 语句的几个规则：
- en: The value associated with each `case` must be a literal value—it *cannot* be
    an expression. The original expression gets matched for *equality* only with the
    literal values associated with each `case`.
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个 `case` 关联的值必须是字面量值——它*不能*是一个表达式。原始的表达式只会与每个 `case` 关联的字面量值进行*相等*匹配。
- en: Reaching a `break` statement stops the execution of all remaining statements
    inside the body of the `switch` statement. That is, `break` breaks out of the
    body of the `switch` statement and continues execution with the next statement
    after the entire `switch` block.
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到达`break`语句会停止执行`switch`语句体内所有剩余的语句。也就是说，`break`会跳出`switch`语句体，并继续执行`switch`块后的下一个语句。
- en: The `case` statement with a matching value marks the starting point into the
    sequence of C statements that will be executed—execution jumps to a location inside
    the `switch` body to start executing code. Thus, if there is no `break` statement
    at the end of a particular `case`, then the statements under the subsequent `case`
    statements execute in order until either a `break` statement is executed or the
    end of the body of the `switch` statement is reached.
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有匹配值的`case`语句标记了进入一系列C语句的起始点——执行会跳转到`switch`体内的某个位置，开始执行代码。因此，如果某个`case`语句末尾没有`break`语句，后续`case`语句下的语句将按顺序执行，直到执行了`break`语句或者到达`switch`语句体的末尾。
- en: The `default` label is optional. If present, it must be at the end.
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default`标签是可选的。如果存在，它必须位于最后。'
- en: 'Here’s an example program with a `switch` statement:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个带有`switch`语句的示例程序：
- en: '[PRE100]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Here are some example runs of this code:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这段代码的一些示例运行：
- en: '[PRE101]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 2.9.2 Command Line Arguments
  id: totrans-509
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.9.2 命令行参数
- en: A program can be made more general purpose by reading command line arguments,
    which are included as part of the command entered by the user to run a binary
    executable program. They specify input values or options that change the runtime
    behavior of the program. In other words, running the program with different command
    line argument values results in a program’s behavior changing from run to run
    without having to modify the program code and recompile it. For example, if a
    program takes the name of an input filename as a command line argument, a user
    can run it with any input filename as opposed to a program that refers to a specific
    input filename in the code.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 通过读取命令行参数，可以使程序变得更具通用性。命令行参数作为用户输入的命令的一部分，用于运行一个二进制可执行程序。它们指定了输入值或选项，改变程序的运行时行为。换句话说，使用不同的命令行参数值运行程序，程序的行为会随每次运行而变化，而无需修改程序代码并重新编译。例如，如果一个程序需要命令行参数中的输入文件名，用户可以使用任何输入文件名来运行它，而不是程序代码中指定的特定输入文件名。
- en: 'Any command line arguments the user provides get passed to the `main` function
    as parameter values. To write a program that takes command line arguments, the
    `main` function’s definition must include two parameters, `argc` and `argv`:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 用户提供的任何命令行参数都会作为参数值传递给`main`函数。为了编写一个接受命令行参数的程序，`main`函数的定义必须包含两个参数，`argc`和`argv`：
- en: '[PRE102]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Note that the type of the second parameter could also be represented as `char`
    `**argv`.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第二个参数的类型也可以表示为`char` `**argv`。
- en: The first parameter, `argc`, stores the argument count. Its value represents
    the number of command line arguments passed to the main function (including the
    name of the program). For example, if the user enters
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数`argc`存储了参数个数。它的值表示传递给`main`函数的命令行参数的数量（包括程序名）。例如，如果用户输入
- en: '[PRE103]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: then `argc` will hold the value 4 (`a.out` counts as the first command line
    argument, and `10`, `11`, and `200` as the other three).
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 那么`argc`将保存值4（`a.out`算作第一个命令行参数，`10`、`11`和`200`是另外三个参数）。
- en: The second parameter, `argv`, stores the argument vector. It contains the value
    of each command line argument. Each command line argument gets passed in as a
    string value, thus `argv`’s type is an array of strings (or an array of `char`
    arrays). The `argv` array contains `argc + 1` elements. The first `argc` elements
    store the command line argument strings, and the last element stores `NULL`, signifying
    the end of the command line argument list. For example, in the command line entered
    in the previous example, the `argv` array would look like [Figure 2-18](ch02.xhtml#ch2fig18).
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数`argv`存储了参数向量。它包含了每个命令行参数的值。每个命令行参数作为字符串传递，因此`argv`的类型是一个字符串数组（或者是一个`char`数组的数组）。`argv`数组包含`argc
    + 1`个元素。前`argc`个元素存储命令行参数字符串，最后一个元素存储`NULL`，表示命令行参数列表的结束。例如，在前面示例中输入的命令行中，`argv`数组看起来像[图2-18](ch02.xhtml#ch2fig18)。
- en: '![image](../images/02fig18.jpg)'
  id: totrans-518
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig18.jpg)'
- en: '*Figure 2-18: The `argv` parameter passed to `main` is an array of strings.
    Each command line argument is passed as a separate string element in the array.
    The value of the last element is `NULL`, signifying the end of the list of command
    line arguments.*'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-18：传递给`main`的`argv`参数是一个字符串数组。每个命令行参数作为数组中的单独字符串元素传递。最后一个元素的值为`NULL`，表示命令行参数列表的结尾。*'
- en: The strings in an `argv` array are *immutable*, meaning that they are stored
    in read-only memory. As a result, if a program wants to modify the value of one
    of its command line arguments, it needs to make a local copy of the command line
    argument and modify the copy.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '`argv` 数组中的字符串是*不可变*的，意味着它们存储在只读内存中。因此，如果程序想要修改其中一个命令行参数的值，它需要制作该命令行参数的本地副本并修改副本。'
- en: 'Often, a program wants to interpret a command line argument passed to `main`
    as a type other than a string. In the previous example, the program may want to
    extract the integer value `10` from the string value `"10"` of its first command
    line argument. C’s standard library provides functions for converting strings
    to other types. For example, the `atoi` (“a to i,” for “ASCII to integer”) function
    converts a string of digit characters to its corresponding integer value:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，程序希望将传递给`main`的命令行参数解释为除字符串以外的类型。在前面的示例中，程序可能希望从其第一个命令行参数的字符串值`"10"`中提取整数值`10`。C标准库提供了将字符串转换为其他类型的函数。例如，`atoi`（“a
    to i”，即“ASCII转整数”）函数将一串数字字符转换为相应的整数值：
- en: '[PRE104]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: See “Functions to Convert Strings to Other Types” on [page 103](ch02.xhtml#lev3_25)
    for more information about these functions, and the `commandlineargs.c` program^([4](ch02.xhtml#fn2_4))
    for another example of C command line arguments.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 有关这些函数的更多信息，请参见第103页的“将字符串转换为其他类型的函数”，以及C命令行参数的另一个示例“commandlineargs.c”程序^([4](ch02.xhtml#fn2_4))。
- en: 2.9.3 The void * Type and Type Recasting
  id: totrans-524
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.9.3 `void *`类型和类型重构
- en: 'The C type `void *` represents a generic pointer—a pointer to any type, or
    a pointer to an unspecified type. C allows for a generic pointer type because
    memory addresses on a system are always stored in the same number of bytes (e.g.,
    addresses are four bytes on 32-bit systems and eight bytes on 64-bit systems).
    As a result, every pointer variable requires the same number of storage bytes,
    and because they’re all the same size, the compiler can allocate space for a `void
    *` variable without knowing the type it points to. Here’s an example:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: C类型`void *`表示通用指针——指向任何类型或未指定类型的指针。C允许通用指针类型，因为系统上的内存地址始终以相同的字节数存储（例如，在32位系统上地址为四字节，在64位系统上为八字节）。因此，每个指针变量需要相同数量的存储字节，并且因为它们都是相同大小的，编译器可以分配`void
    *`变量的空间而不知道它指向的类型。以下是一个示例：
- en: '[PRE105]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Typically, programmers do not declare variables of type `void *` as in the preceding
    example. Instead, it’s commonly used to specify generic return types from functions
    or generic parameters to functions. The `void *` type is often used as a return
    type by functions that return newly allocated memory that can be used to store
    any type (e.g., `malloc`). It’s also used as a function parameter for functions
    that can take any type of value. In this case, individual calls to the function
    pass in a pointer to some specific type, which can be passed to the function’s
    `void *` parameter because it can store the address of any type.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，程序员不像前面的示例中那样声明`void *`类型的变量。相反，它通常用于指定函数的通用返回类型或函数的通用参数。`void *`类型经常被用作函数的返回类型，该函数返回新分配的内存，可用于存储任何类型（例如，`malloc`）。它也用作函数的函数参数，用于接受任何类型的值。在这种情况下，函数的各个调用将某种特定类型的指针传递给函数的`void
    *`参数，因为它可以存储任何类型的地址。
- en: Because `void *` is a generic pointer type, it cannot be directly dereferenced—the
    compiler does not know the size of memory that the address points to. For example,
    the address could refer to an `int` storage location of four bytes or it could
    refer to a `char` storage location in memory of one byte. Therefore, the programmer
    must explicitly *recast* the `void *` pointer to a pointer of a specific type
    before dereferencing it. Recasting tells the compiler the specific type of pointer
    variable, allowing the compiler to generate the correct memory access code for
    pointer dereferences.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`void *`是一个通用指针类型，无法直接解引用——编译器不知道地址指向的内存大小。例如，该地址可能指向一个占用四个字节的`int`存储位置，或者可能指向一个占用一个字节的`char`存储位置。因此，程序员必须在解引用之前显式地将`void
    *`指针重新转换为特定类型的指针。重新转换告诉编译器指针变量的具体类型，从而允许编译器生成正确的内存访问代码来处理指针解引用。
- en: 'Here are two examples of `void *` use. First, a call to `malloc` recasts its
    `void` `*` return type to the specific pointer type of the variable used to store
    its returned heap memory address:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`void *`使用的两个例子。首先，`malloc`的调用将其返回的`void *`类型转换为用于存储返回堆内存地址的变量的特定指针类型：
- en: '[PRE106]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Second, students often encounter the `void *` when creating threads (see “Hello
    Threading! Writing Your First Multithreaded Program” on [page 677](ch14.xhtml#lev1_106)).
    Using a `void *` parameter type in a thread function allows the thread to take
    any type of application-specific pointer. The `pthread_create` function has a
    parameter for the thread main function and a `void *` parameter for the argument
    value that it passes to the thread main function that the newly created thread
    will execute. The use of the `void *` parameter makes `pthread_create` a generic
    thread creation function; it can be used to point to any type of memory location.
    For a specific program that calls `pthread_create`, the programmer knows the type
    of the argument passed to the `void *` parameter, so the programmer must recast
    it to its known type before dereferencing it. In this example, suppose that the
    address passed to the `args` parameter contains the address of an integer variable:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，学生们在创建线程时经常遇到`void *`（请参见[第677页](ch14.xhtml#lev1_106)的“你好，线程！编写你的第一个多线程程序”）。在线程函数中使用`void
    *`参数类型可以使线程接收任何类型的特定应用程序指针。`pthread_create`函数有一个用于线程主函数的参数，并且有一个`void *`类型的参数，用于传递给线程主函数的参数值，后者将由新创建的线程执行。使用`void
    *`参数使得`pthread_create`成为一个通用的线程创建函数；它可以用于指向任何类型的内存位置。对于调用`pthread_create`的特定程序，程序员知道传递给`void
    *`参数的参数类型，因此程序员必须在解引用之前将其重新转换为已知类型。在这个例子中，假设传递给`args`参数的地址包含一个整数变量的地址：
- en: '[PRE107]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 2.9.4 Pointer Arithmetic
  id: totrans-533
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.9.4 指针运算
- en: 'If a pointer variable points to an array, a program can perform arithmetic
    on the pointer to access any of the array’s elements. In most cases, we recommend
    against using pointer arithmetic to access array elements: it’s easy to make errors
    and more difficult to debug when you do. However, occasionally it may be convenient
    to successively increment a pointer to iterate over an array of elements.'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个指针变量指向一个数组，程序可以对该指针进行运算，以访问数组中的任何元素。在大多数情况下，我们建议避免使用指针运算来访问数组元素：这样容易出错，调试时也更困难。然而，有时通过递增指针逐个访问数组元素可能会更加方便。
- en: When incremented, a pointer points to the next storage location *of the type
    it points to*. For example, incrementing an integer pointer (`int *`) makes it
    point to the next `int` storage address (the address four bytes beyond its current
    value), and incrementing a character pointer makes it point to the next `char`
    storage address (the address one byte beyond its current value).
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 当指针递增时，它指向下一个存储位置*其指向的类型*。例如，递增一个整数指针（`int *`）会使它指向下一个`int`存储地址（比当前值大四个字节的地址），递增一个字符指针则会使它指向下一个`char`存储地址（比当前值大一个字节的地址）。
- en: 'In the following example program, we demonstrate how to use pointer arithmetic
    to manipulate an array. First declare pointer variables whose type matches the
    array’s element type:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例程序中，我们演示了如何使用指针运算来操作一个数组。首先声明与数组元素类型匹配的指针变量：
- en: pointerarith.c
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: pointerarith.c
- en: '[PRE108]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Next, initialize the pointer variables to the base address of the arrays over
    which they will iterate:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将指针变量初始化为它们将要遍历的数组的基地址：
- en: pointerarith.c
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: pointerarith.c
- en: '[PRE109]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Then, using pointer dereferencing, our program can access the array’s elements.
    Here, we’re dereferencing to assign a value to an array element and then incrementing
    the pointer variable by one to advance it to point to the next element:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用指针解引用，我们的程序可以访问数组的元素。在这里，我们通过解引用为数组元素赋值，然后将指针变量递增1，以使其指向下一个元素：
- en: pointerarith.c
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: pointerarith.c
- en: '[PRE110]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Note that in this example, the pointer values are incremented inside the loop.
    Thus, incrementing their value makes them point to the next element in the array.
    This pattern effectively walks through each element of an array in the same way
    that accessing `cptr[i]` or `iptr[i]` at each iteration would.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个例子中，指针的值是在循环内部递增的。因此，递增它们的值使得它们指向数组中的下一个元素。这种模式有效地遍历了数组中的每个元素，和在每次迭代中访问`cptr[i]`或`iptr[i]`的方式相同。
- en: '**Note THE SEMANTICS OF POINTER ARITHMETIC AND THE UNDERLYING ARITHMETIC FUNCTION**'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意指针算术的语义和底层算术功能**'
- en: 'The semantics of pointer arithmetic are type independent: changing any type
    of pointer’s value by `N` (`ptr = ptr + N`) makes the pointer point `N` storage
    locations beyond its current value (or makes it point to `N` elements beyond the
    current element it points to). As a result, incrementing a pointer of any type
    makes it point to the very next memory location of the type it points to.'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 指针算术的语义与类型无关：改变任何类型指针的值`N`（`ptr = ptr + N`）会使指针指向当前值之后`N`个存储位置（或使它指向当前元素之后`N`个元素）。因此，递增任何类型的指针都会使它指向它所指向类型的下一个内存位置。
- en: However, the actual arithmetic function that the compiler generates for a pointer
    arithmetic expression varies depending on the type of the pointer variable (depending
    on the number of bytes the system uses to store the type to which it points).
    For example, incrementing a `char` pointer will increase its value by one because
    the very next valid `char` address is one byte from the current location. Incrementing
    an `int` pointer will increase its value by four because the next valid integer
    address is four bytes from the current location.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，编译器为指针算术表达式生成的实际算术功能会根据指针变量的类型有所不同（取决于系统用于存储指针所指向类型的字节数）。例如，递增一个`char`指针会使其值增加1，因为下一个有效的`char`地址距离当前位置1个字节。递增一个`int`指针会使其值增加4，因为下一个有效的整数地址距离当前位置4个字节。
- en: A programmer can simply write `ptr++` to make a pointer point to the next element
    value. The compiler generates code to add the appropriate number of bytes for
    the corresponding type it points to. The addition effectively sets its value to
    the next valid address in memory of that type.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员可以简单地写`ptr++`，使指针指向下一个元素的值。编译器会生成代码，以添加与其指向的对应类型相关的字节数。这种加法有效地将其值设置为该类型在内存中的下一个有效地址。
- en: 'You can see how the previous code modified array elements by printing out their
    values (we show this first using array indexing and then using pointer arithmetic
    to access each array element’s value):'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过打印它们的值来查看先前的代码是如何修改数组元素的（我们首先使用数组索引访问，然后使用指针算术来访问每个数组元素的值）：
- en: '[PRE111]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Here’s what the output looks like:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出的样子：
- en: '[PRE112]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Pointer arithmetic can be used to iterate over any contiguous chunk of memory.
    Here’s an example using pointer arithmetic to initialize a statically declared
    2D array:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 指针算术可以用来遍历任何连续的内存块。以下是一个使用指针算术初始化静态声明的二维数组的例子：
- en: '[PRE113]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The output will look like:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE114]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Pointer arithmetic can access contiguous memory locations in any pattern, starting
    and ending anywhere in a contiguous chunk of memory. For example, after initializing
    a pointer to the address of an array element, its value can be changed by more
    than one. For example:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 指针算术可以以任何模式访问连续的内存位置，从连续内存块中的任何位置开始和结束。例如，在初始化指向数组元素的指针后，可以通过增加指针值来改变它的值。示例如下：
- en: '[PRE115]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'After executing the preceding code, printing the `numbers` array’s values would
    look like this (note that the values at index 2 and index 6 have changed):'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述代码后，打印`numbers`数组的值会如下所示（请注意索引2和索引6的值已发生变化）：
- en: '[PRE116]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Pointer arithmetic works on dynamically allocated arrays, too. However, programmers
    must be careful working with dynamically allocated multidimensional arrays. If,
    for example, a program uses multiple `malloc` calls to dynamically allocate individual
    rows of a 2D array (see “Method 2: The Programmer-Friendly Way” on [page 90](ch02.xhtml#lev3_17)),
    then the pointer must be reset to point to the address of the starting element
    of every row. Resetting the pointer is necessary because only elements within
    a row are located in contiguous memory addresses. On the other hand, if the 2D
    array is allocated as a single `malloc` of total rows times columns space (see
    “Method 1: Memory-Efficient Allocation” on [page 88](ch02.xhtml#lev3_15)), then
    all the rows are in contiguous memory (like in the statically declared 2D array
    from the previous example). In the latter case, the pointer only needs to be initialized
    to point to the base address, and then pointer arithmetic will correctly access
    any element in the 2D array.'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 指针运算也适用于动态分配的数组。然而，程序员在处理动态分配的多维数组时必须小心。例如，如果一个程序使用多个 `malloc` 调用来动态分配 2D 数组的各个行（见第
    90 页的“方法 2：对程序员友好的方式”），那么每一行的指针都必须重置为指向该行的起始元素的地址。重置指针是必要的，因为只有同一行的元素位于连续的内存地址中。另一方面，如果
    2D 数组是通过一次 `malloc` 调用为总行数乘以列数的空间分配的（见第 88 页的“方法 1：内存高效分配”），那么所有行都在连续的内存中（就像前面示例中的静态声明的
    2D 数组一样）。在后者的情况下，只需要将指针初始化为指向基地址，然后指针运算就可以正确访问 2D 数组中的任何元素。
- en: '2.9.5 C Libraries: Using, Compiling, and Linking'
  id: totrans-563
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.9.5 C 库：使用、编译和链接
- en: 'A *library* implements a collection of functions and definitions that can be
    used by other programs. A C library consists of two parts:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '*库*实现了一组可以被其他程序使用的函数和定义。C 库由两部分组成：'
- en: The *application programming interface* (API) to the library, which gets defined
    in one or more header files (`.h` files) that must be included in C source code
    files that plan to use the library. The headers define what the library exports
    to its users. These definitions usually include library function prototypes, and
    they may also include type, constant, or global variable declarations.
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*应用程序编程接口*（API），它在一个或多个头文件（`.h` 文件）中定义，必须在计划使用该库的 C 源代码文件中包含这些头文件。头文件定义了库向其用户提供的内容。这些定义通常包括库函数原型，并且可能还包括类型、常量或全局变量的声明。'
- en: The *implementation* of the library’s functionality, often made available to
    programs in a precompiled binary format that gets *linked* (added) into the binary
    executable created by `gcc`. Precompiled library code might be in an archive file
    (`libsomelib.a`) containing several `.o` files that can be statically linked into
    the executable file at compile time. Alternatively, it may consist of a shared
    object file (`libsomelib.so`) that can be dynamically linked at runtime into a
    running program.
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现*库功能的代码，通常以预编译的二进制格式提供给程序，这些代码会在 `gcc` 创建的二进制可执行文件中进行*链接*（添加）。预编译的库代码可能存储在一个包含多个
    `.o` 文件的归档文件（`libsomelib.a`）中，这些文件可以在编译时静态链接到可执行文件中。或者，它可能是一个共享对象文件（`libsomelib.so`），可以在运行时动态链接到正在运行的程序中。'
- en: For example, the C string library implements a set of functions to manipulate
    C strings. The `string.h` header file defines its interface, so any program that
    wants to use string library functions must `#include <string.h>`. The implementation
    of the C string library is part of the larger standard C library (`libc`) that
    the `gcc` compiler automatically links into every executable file it creates.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，C 字符串库实现了一组用于操作 C 字符串的函数。`string.h` 头文件定义了它的接口，因此任何想要使用字符串库函数的程序都必须 `#include
    <string.h>`。C 字符串库的实现是更大标准 C 库（`libc`）的一部分，`gcc` 编译器会自动将其链接到它创建的每个可执行文件中。
- en: A library’s implementation consists of one or more modules (`.c` files), and
    may additionally include header files that are internal to the library implementation;
    internal header files are not part of the library’s API but are part of well-designed,
    modular library code. Often the C source code implementation of a library is not
    exported to the user of the library. Instead, the library is made available in
    a precompiled binary form. These binary formats are not executable programs (they
    cannot be run on their own), but they provide executable code that can be *linked*
    into (added into) an executable file by `gcc` at compilation time.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 库的实现由一个或多个模块（`.c` 文件）组成，并可能包括库实现内部使用的头文件；这些内部头文件不是库的 API 的一部分，但它们是设计良好、模块化的库代码的一部分。通常，库的
    C 源代码实现并不会对库的用户公开。相反，库以预编译的二进制形式提供。这些二进制格式不是可执行程序（它们不能单独运行），但它们提供了可执行的代码，可以通过
    `gcc` 在编译时被*链接*到可执行文件中。
- en: There are numerous libraries available for C programmers to use. For example,
    the POSIX thread library (discussed in [Chapter 10](ch10.xhtml#ch10)) enables
    multithreaded C programs. C programmers can also implement and use their own libraries
    (see “Writing and Using Your Own C Libraries” on [page 133](ch02.xhtml#lev2_41)).
    Large C programs tend to use many C libraries, some of which `gcc` links implicitly,
    whereas others require explicit linking with the `-l` command line option to `gcc`.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: C 程序员可以使用许多可用的库。例如，POSIX 线程库（在[第 10 章](ch10.xhtml#ch10)中讨论）使得多线程 C 程序成为可能。C
    程序员还可以实现并使用自己的库（参见[第 133 页](ch02.xhtml#lev2_41)上的“编写和使用你自己的 C 库”）。
- en: 'Standard C libraries normally do not need to be explicitly linked in with the
    `-l` option, but other libraries do. The documentation for a library function
    often specifies whether the library needs to be explicitly linked in when compiling.
    For example, the POSIX threads library (`pthread`) and the `readline` library
    require explicit linking on the `gcc` command line:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 标准 C 库通常不需要通过 `-l` 选项显式链接，但其他库则需要。库函数的文档通常会指定在编译时是否需要显式链接该库。例如，POSIX 线程库（`pthread`）和
    `readline` 库在 `gcc` 命令行上需要显式链接：
- en: '[PRE117]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Note that the full name of the library file should not be included in the `-l`
    argument to `gcc`; the library files are named something like `libpthread.so`
    or `libreadline.a`, but the `lib` prefix and `.so` or `.a` suffix of the filenames
    are not included. The actual library filename may also contain version numbers
    (e.g., `libreadline.so.8.0`), which are also not included in the `-l` command
    line option (`-lreadline`). By not forcing the user to specify (or even know)
    the exact name and location of the library files to link in, `gcc` is free to
    find the most recent version of a library in a user’s library path. It also allows
    the compiler to choose to dynamically link when both a shared object (`.so`) and
    an archive (`.a`) version of a library are available. If users want to statically
    link libraries, then they can explicitly specify static linking in the `gcc` command
    line. The `--static` option provides one method for requesting static linking:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，库文件的完整名称不应包含在 `-l` 参数中；库文件的命名类似于 `libpthread.so` 或 `libreadline.a`，但文件名中的
    `lib` 前缀和 `.so` 或 `.a` 后缀不应包括在内。实际的库文件名可能还包含版本号（例如 `libreadline.so.8.0`），这些版本号也不包含在
    `-l` 命令行选项中（`-lreadline`）。通过不强制用户指定（甚至不知道）要链接的库文件的确切名称和位置，`gcc` 可以自由地在用户的库路径中找到最新版本的库。它还允许编译器在存在共享对象（`.so`）和静态库（`.a`）版本的库时选择动态链接。如果用户想要静态链接库，则可以在
    `gcc` 命令行中显式指定静态链接。`--static` 选项提供了一种请求静态链接的方法：
- en: '[PRE118]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Compilation Steps
  id: totrans-574
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编译步骤
- en: Characterizing C’s program compilation steps will help to illustrate how library
    code gets linked into an executable binary file. We first present the compilation
    steps and then discuss (with examples) different types of errors that can occur
    when compiling programs that use libraries.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 描述 C 程序的编译步骤有助于说明库代码如何被链接到可执行二进制文件中。我们首先介绍编译步骤，然后通过示例讨论在编译使用库的程序时可能出现的不同类型的错误。
- en: The C compiler translates a C source file (e.g., `myprog.c`) into an executable
    binary file (e.g., `a.out`) in four distinct steps (plus a fifth step that occurs
    at runtime).
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: C 编译器将 C 源文件（例如 `myprog.c`）转换为可执行的二进制文件（例如 `a.out`），这一过程分为四个独立的步骤（以及在运行时发生的第五个步骤）。
- en: 'The *precompiler* step runs first and expands *preprocessor directives*: the
    `#` directives that appear in the C program, such as `#define` and `#include`.
    Compilation errors at this step include syntax errors in preprocessor directives
    or `gcc` not finding header files associated with `#include` directives. To view
    the intermediate results of the precompiler step, pass the `-E` flag to `gcc`
    (the output can be redirected to a file that can be viewed by a text editor):'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '*预编译*步骤首先运行，并展开*预处理指令*：C 程序中出现的`#`指令，例如`#define`和`#include`。此步骤的编译错误包括预处理指令中的语法错误，或`gcc`未能找到与`#include`指令相关的头文件。要查看预编译步骤的中间结果，可以将`-E`标志传递给`gcc`（输出可以重定向到一个文件，文件可以通过文本编辑器查看）：'
- en: '[PRE119]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The *compile* step runs next and does the bulk of the compilation task. It
    translates the C program source code (`myprog.c`) to machine-specific assembly
    code (`myprog.s`). Assembly code is a human-readable form of the binary machine
    code instructions that a computer can execute. Compilation errors at this step
    include C language syntax errors, undefined symbol warnings, and errors from missing
    definitions and function prototypes. To view the intermediate results of the compile
    step, pass the `-S` flag to `gcc` (this option creates a text file named `myprog.s`
    with the assembly translation of `myprog.c`, which can be viewed in a text editor):'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '*编译*步骤接下来运行，并完成大部分编译任务。它将 C 程序源代码（`myprog.c`）翻译为特定于机器的汇编代码（`myprog.s`）。汇编代码是计算机可以执行的二进制机器代码指令的可读形式。此步骤的编译错误包括
    C 语言语法错误、未定义符号警告，以及缺失定义和函数原型的错误。要查看编译步骤的中间结果，可以将`-S`标志传递给`gcc`（该选项会生成一个名为`myprog.s`的文本文件，其中包含`myprog.c`的汇编翻译，可以通过文本编辑器查看）：'
- en: '[PRE120]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'The *assembly* step converts the assembly code into relocatable binary object
    code (`myprog.o`). The resulting object file contains machine code instructions,
    but it is not a complete executable program that can run on its own. The `gcc`
    compiler on Unix and Linux systems produces binary files in a specific format
    called ELF (Executable and Linkable Format).^([5](ch02.xhtml#fn2_5)) To stop compilation
    after this step, pass the `-c` flag to `gcc` (this produces a file named `myprog.o`).
    Binary files (e.g., `a.out` and `.o` files) can be viewed using `objdump` or similar
    tools for displaying binary files:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '*汇编*步骤将汇编代码转换为可重定位的二进制目标代码（`myprog.o`）。生成的目标文件包含机器代码指令，但它不是一个可以独立运行的完整可执行程序。Unix
    和 Linux 系统上的`gcc`编译器生成特定格式的二进制文件，称为 ELF（可执行与可链接格式）。^([5](ch02.xhtml#fn2_5)) 若要在此步骤后停止编译，可以将`-c`标志传递给`gcc`（这会生成名为`myprog.o`的文件）。可以使用`objdump`或类似工具查看二进制文件（例如，`a.out`和`.o`文件）：'
- en: '[PRE121]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The *link editing* step runs last and creates a single executable file (`a.out`)
    from relocatable binaries (`.o`) and libraries (`.a` or `.so`). In this step,
    the linker verifies that any references to names (symbols) in a `.o` file are
    present in other `.o`, `.a`, or `.so` files. For example, the linker will find
    the `printf` function in the standard C library (`libc.so`). If the linker cannot
    find the definition of a symbol, this step fails with an error stating that a
    symbol is undefined. Running `gcc` without flags for partial compilation performs
    all four steps of compiling a C source code file (`myprog.c`) to an executable
    binary file (`a.out`) that can be run:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '*链接编辑*步骤最后运行，并从可重定位的二进制文件（`.o`）和库文件（`.a`或`.so`）创建一个单一的可执行文件（`a.out`）。在此步骤中，链接器会验证`.o`文件中对符号名称的引用是否存在于其他`.o`、`.a`或`.so`文件中。例如，链接器会在标准
    C 库（`libc.so`）中找到`printf`函数。如果链接器找不到符号的定义，步骤将失败，并显示符号未定义的错误。运行不带标志的`gcc`进行部分编译时，会执行编译
    C 源代码文件（`myprog.c`）到可执行二进制文件（`a.out`）的所有四个步骤，可以运行：'
- en: '[PRE122]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: If the binary executable file (`a.out`) statically links in library code (from
    `.a` library files), then `gcc` embeds copies of library functions from the `.a`
    file in the resulting `a.out` file. All calls to library functions by the application
    are *bound* to the locations in the `a.out` file to which the library function
    is copied. Binding associates a name with a location in the program memory. For
    example, binding a call to a library function named `gofish` means replacing the
    use of the function name with the address in memory of the function (in later
    chapters we discuss memory addresses in more detail—see, for example, “Memory
    Addresses” on [page 642](ch13.xhtml#lev2_227)).
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 如果二进制可执行文件（`a.out`）静态链接了库代码（来自`.a`库文件），则`gcc`会将库函数从`.a`文件复制到生成的`a.out`文件中。应用程序对库函数的所有调用都被*绑定*到`a.out`文件中复制库函数的地址位置。绑定将名称与程序内存中的位置关联起来。例如，绑定对名为`gofish`的库函数的调用意味着用该函数在内存中的地址替代函数名称（在后面的章节中我们将更详细地讨论内存地址——例如，参见“内存地址”在[第642页](ch13.xhtml#lev2_227)）。
- en: If, however, the `a.out` was created by dynamically linking a library (from
    library shared object, `.so`, files), then `a.out` does not contain a copy of
    the library function code from these libraries. Instead, it contains information
    about which dynamically linked libraries are needed by the `a.out` file to run
    it. Such executables require an additional linking step at runtime.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果`a.out`是通过动态链接库（来自共享库对象文件，`.so`文件）创建的，则`a.out`不包含这些库中的库函数代码副本。相反，它包含关于`a.out`文件运行时需要哪些动态链接库的信息。这类可执行文件在运行时需要额外的链接步骤。
- en: The *runtime linking* step is needed if `a.out` was linked with shared object
    files during link editing. In such cases, the dynamic library code (in `.so` files)
    must be loaded at runtime and linked with the running program. This runtime loading
    and linking of shared object libraries is called *dynamic linking*. When a user
    runs an `a.out` executable with shared object dependencies, the system performs
    dynamic linking before the program begins executing its `main` function.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`a.out`在链接编辑时与共享对象文件链接，那么就需要*运行时链接*步骤。在这种情况下，动态库代码（在`.so`文件中）必须在运行时加载，并与正在运行的程序进行链接。这个运行时加载和链接共享对象库的过程称为*动态链接*。当用户运行一个有共享对象依赖的`a.out`可执行文件时，系统会在程序开始执行`main`函数之前执行动态链接。
- en: The compiler adds information about shared object dependencies into the `a.out`
    file during the link editing compilation step. When the program starts executing,
    the dynamic linker examines the list of shared object dependencies and finds and
    loads the shared object files into the running program. It then updates relocation
    table entries in the `a.out` file, binding the program’s use of symbols in shared
    objects (such as calls to library functions) to their locations in the `.so` file
    loaded at runtime. Runtime linking reports errors if the dynamic linker cannot
    find a shared object (`.so`) file needed by the executable.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器在链接编辑编译步骤中将关于共享对象依赖的信息添加到`a.out`文件中。当程序开始执行时，动态链接器会检查共享对象依赖列表，找到并加载共享对象文件到运行中的程序中。然后，它会更新`a.out`文件中的重定位表条目，将程序对共享对象中符号（例如调用库函数）的使用绑定到运行时加载的`.so`文件中的位置。如果动态链接器无法找到可执行文件所需的共享对象（`.so`）文件，运行时链接会报告错误。
- en: 'The `ldd` utility lists an executable file’s shared object dependencies:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldd`工具列出可执行文件的共享对象依赖：'
- en: '[PRE123]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: The *GNU debugger (GDB)* can examine a running program and show which shared
    object code is loaded and linked at runtime. We cover GDB in [Chapter 3](ch03.xhtml#ch03).
    However, the details of examining the Procedure Lookup Table (PLT), which is used
    for runtime linking of calls to dynamically linked library functions, is beyond
    the scope of this textbook.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '*GNU调试器（GDB）*可以检查正在运行的程序，并显示运行时加载和链接的共享对象代码。我们在[第三章](ch03.xhtml#ch03)中介绍了GDB。然而，检查用于运行时链接调用动态链接库函数的过程查找表（PLT）的细节超出了本教材的范围。'
- en: More details about the phases of compilation and about tools for examining different
    phases can be found online.^([6](ch02.xhtml#fn2_6))
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 有关编译各阶段的更多细节以及检查不同阶段的工具，可以在网上找到。^([6](ch02.xhtml#fn2_6))
- en: Common Compilation Errors Related to Compiling and Linking Libraries
  id: totrans-593
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 与编译和链接库相关的常见编译错误
- en: Several compilation and linking errors can occur due to the programmer forgetting
    to include library header files or forgetting to explicitly link in library code.
    Identifying the `gcc` compiler error or warning associated with each of these
    errors will help in debugging errors related to using C libraries.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 由于程序员忘记包含库头文件或忘记显式链接库代码，可能会发生多个编译和链接错误。识别与这些错误相关的`gcc`编译器错误或警告，有助于调试与使用C库相关的错误。
- en: 'Consider this next C program that makes a call to a function `libraryfunc`
    from the `examplelib` library (available as a shared object file, `libmylib.so`):'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑下一个C程序，它调用了来自`examplelib`库的`libraryfunc`函数（该库以共享对象文件`libmylib.so`的形式提供）：
- en: '[PRE124]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Assume that the header file, `examplelib.h`, contains the definitions in the
    following example:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 假设头文件`examplelib.h`包含如下示例中的定义：
- en: '[PRE125]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: The `extern` prefix to the function prototype means that the function’s definition
    comes from another file—it’s not in the `examplelib.h` file, but instead it’s
    provided by one of the `.c` files in the library’s implementation.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '`extern`前缀表示函数原型的定义来自另一个文件——它不在`examplelib.h`文件中，而是由库实现中的某个`.c`文件提供。'
- en: '**Forgetting to include a header file.** If the programmer forgets to include
    `examplelib.h` in their program, then the compiler produces warnings and errors
    about the program’s use of library functions and constants that it does not know
    about. For example, if the user compiles their program without `#include <examplelib.h>`,
    `gcc` will produce the following output:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '**忘记包含头文件。** 如果程序员忘记在程序中包含`examplelib.h`，那么编译器会产生关于程序使用的库函数和常量的警告和错误，编译器无法识别这些库函数和常量。例如，如果用户在没有`#include
    <examplelib.h>`的情况下编译程序，`gcc`会产生如下输出：'
- en: '[PRE126]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: The first compiler warning (`implicit declaration of function` `libraryfunc`)
    tells the programmer that the compiler cannot find a function prototype for the
    `libraryfunc` function. This is just a compiler warning because `gcc` will guess
    that the function’s return type is an integer and will continue compiling the
    program. However, programmers should *not* ignore such warnings! They indicate
    that the program isn’t including a function prototype before its use in the `myprog.c`
    file, which is often due to not including a header file that contains the function
    prototype.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个编译器警告（`implicit declaration of function` `libraryfunc`）告诉程序员，编译器找不到`libraryfunc`函数的原型。这只是一个编译器警告，因为`gcc`会猜测该函数的返回类型是整数，并继续编译程序。然而，程序员*不应*忽视这些警告！它们表明程序在使用`myprog.c`文件中的函数之前没有包含函数原型，这通常是由于没有包含包含该函数原型的头文件。
- en: The second compiler error (`MAX undeclared (first use in this` `function)`)
    follows from a missing constant definition. The compiler cannot guess at the value
    of the missing constant, so this missing definition fails with an error. This
    type of “undeclared” message often indicates that a header file defining a constant
    or global variable is missing or hasn’t been properly included.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个编译器错误（`MAX undeclared (first use in this` `function)`）是由于缺少常量定义。编译器无法猜测缺失常量的值，因此这个缺失的定义会导致错误。此类“未声明”消息通常表明缺少或未正确包含定义常量或全局变量的头文件。
- en: '**Forgetting to link a library.** If the programmer includes the library header
    file (as shown in the previous listing), but forgets to explicitly link in the
    library during the link editing step of compilation, then `gcc` indicates this
    with an “undefined reference” error:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '**忘记链接库。** 如果程序员包含了库的头文件（如前面的代码所示），但忘记在编译的链接编辑步骤中显式链接该库，那么`gcc`会通过“未定义的引用”错误来提示：'
- en: '[PRE127]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'This error originates from `ld`, the linker component of the compiler. It indicates
    that the linker cannot find the implementation of the library function `libraryfunc`
    that gets called at line 9 in `myprog.c`. An “undefined reference” error indicates
    that a library needs to be explicitly linked into the executable. In this example,
    specifying `-lexamplelib` on the `gcc` command line will fix the error:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误来自`ld`，编译器的链接器组件。它表明链接器无法找到在`myprog.c`文件第9行调用的库函数`libraryfunc`的实现。一个“未定义的引用”错误意味着需要显式地将一个库链接到可执行文件中。在这个例子中，在`gcc`命令行上指定`-lexamplelib`可以解决这个错误：
- en: '[PRE128]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '**gcc can’t find header or library files.** Compilation will also fail with
    errors if a library’s header or implementation files are not present in the directories
    that `gcc` searches by default. For example, if `gcc` cannot find the `examplelib.h`
    file, it will produce an error message like this:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '**gcc找不到头文件或库文件。** 如果库的头文件或实现文件不在`gcc`默认搜索的目录中，编译也会失败并显示错误。例如，如果`gcc`找不到`examplelib.h`文件，它将产生如下错误信息：'
- en: '[PRE129]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'If the linker cannot find a `.a` or `.so` version of the library to link in
    during the link editing step of compilation, `gcc` will exit with an error like
    the following:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 如果链接器在编译的链接编辑步骤中找不到库的`.a`或`.so`版本来进行链接，`gcc`将会因以下类似错误退出：
- en: '[PRE130]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Similarly, if a dynamically linked executable cannot locate a shared object
    file (e.g., `libexamplelib.so`), it will fail to execute at runtime with an error
    like the following:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果一个动态链接的可执行文件无法找到共享对象文件（例如，`libexamplelib.so`），它将在运行时因以下类似错误而无法执行：
- en: '[PRE131]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: To resolve these types of errors, programmers must specify additional options
    to `gcc` to indicate where the library’s files can be found. They may also need
    to modify the `LD_LIBRARY_PATH` environment variable for the runtime linker to
    find a library’s `.so` file.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些类型的错误，程序员必须为`gcc`指定额外的选项，指明库文件的位置。程序员还可能需要修改`LD_LIBRARY_PATH`环境变量，以便运行时链接器能够找到库的`.so`文件。
- en: Library and Include Paths
  id: totrans-615
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 库和包含路径
- en: The compiler automatically searches in standard directory locations for header
    and library files. For example, systems commonly store standard header files in
    `/usr/include`, and library files in `/usr/lib`, and `gcc` automatically looks
    for headers and libraries in these directories; `gcc` also automatically searches
    for header files in the current working directory.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会自动在标准目录位置搜索头文件和库文件。例如，系统通常将标准头文件存储在`/usr/include`，库文件存储在`/usr/lib`，`gcc`会自动在这些目录中查找头文件和库文件；`gcc`也会自动在当前工作目录中查找头文件。
- en: 'If `gcc` cannot find a header or a library file, then the user must explicitly
    provide paths on the command line using `-I` and `-L`. For example, suppose that
    a library named `libexamplelib.so` exists in `/home/me/lib`, and its header file
    `examplelib.h` is in `/home/me/include`. Because `gcc` knows nothing of those
    paths by default, it must be explicitly told to include files there to successfully
    compile a program that uses this library:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`gcc`无法找到头文件或库文件，则用户必须在命令行中显式提供路径，使用`-I`和`-L`选项。例如，假设有一个名为`libexamplelib.so`的库文件存在于`/home/me/lib`中，且它的头文件`examplelib.h`在`/home/me/include`目录下。由于`gcc`默认不知道这些路径，必须明确告知它在这些路径下包含文件，以成功编译使用该库的程序：
- en: '[PRE132]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'To specify the location of a dynamic library (e.g., `libexamplelib.so`) when
    launching a dynamically linked executable, set the `LD_LIBRARY_PATH` environment
    variable to include the path to the library. Here’s an example bash command that
    can be run at a shell prompt or added to a `.bashrc` file:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 要在启动动态链接的可执行文件时指定动态库（例如，`libexamplelib.so`）的位置，可以设置`LD_LIBRARY_PATH`环境变量，包含库文件的路径。以下是一个可以在终端提示符下运行的示例bash命令，或添加到`.bashrc`文件中的命令：
- en: '[PRE133]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: When the `gcc` command lines get long, or when an executable requires many source
    and header files, it helps to simplify compilation by using `make` and a `Makefile`.^([7](ch02.xhtml#fn2_7))
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 当`gcc`命令行变长，或者可执行文件需要许多源文件和头文件时，使用`make`和`Makefile`可以简化编译过程。^([7](ch02.xhtml#fn2_7))
- en: 2.9.6 Writing and Using Your Own C Libraries
  id: totrans-622
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.9.6 编写和使用你自己的C库
- en: Programmers typically divide large C programs into separate *modules* (i.e.,
    separate `.c` files) of related functionality. Definitions shared by more than
    one module are put in header files (`.h` files) that are included by the modules
    that need them. Similarly, C library code is also implemented in one or more modules
    (`.c` files) and one or more header files (`.h` files). C programmers often implement
    their own C libraries of commonly used functionality. By writing a library, a
    programmer implements the functionality once, in the library, and then can use
    this functionality in any subsequent C program that they write.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员通常将大型C程序分成多个相关功能的*模块*（即多个`.c`文件）。多个模块共享的定义放在头文件（`.h`文件）中，模块会包含它们所需的头文件。同样，C库代码也通常由一个或多个模块（`.c`文件）和一个或多个头文件（`.h`文件）实现。C程序员常常实现自己常用功能的C库。通过编写库，程序员一次性实现了库中的功能，然后可以在任何后续的C程序中使用这些功能。
- en: 'In “C Libraries: Using, Compiling, and Linking” on [page 133](ch02.xhtml#lev2_40),
    we describe how to use, compile, and link C library code into C programs. In this
    section, we discuss how to write and use your own libraries in C. What we present
    here also applies to structuring and compiling larger C programs composed of multiple
    C source and header files.'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 在“C 库：使用、编译和链接”章节的[第 133 页](ch02.xhtml#lev2_40)中，我们描述了如何将 C 库代码用于 C 程序，编译并链接。在本节中，我们讨论了如何编写和使用你自己的
    C 库。我们在这里展示的内容也适用于构建和编译由多个 C 源文件和头文件组成的较大型 C 程序。
- en: 'To create a library in C:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 C 库的步骤：
- en: 1\. Define an interface to the library in a header (`.h`) file. This header
    file must be included by any program that wants to use the library.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 在头文件（`.h` 文件）中定义库的接口。任何希望使用该库的程序都必须包含此头文件。
- en: 2\. Create an implementation of the library in one or more `.c` files. This
    set of function definitions implement the library’s functionality. Some functions
    may be interface functions that users of the library will call, and others may
    be internal functions that cannot be called by users of the library (internal
    functions are part of good modular design of the library’s implementation).
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 在一个或多个 `.c` 文件中创建库的实现。这些函数定义实现了库的功能。有些函数可能是库用户将要调用的接口函数，而其他函数可能是库内部的函数，无法被库的用户调用（内部函数是库实现的良好模块化设计的一部分）。
- en: 3\. Compile a binary form of the library that can be linked into programs that
    use the library.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 编译一个可以链接到使用该库的程序中的库的二进制形式。
- en: The binary form of a library could be directly built from its source file(s)
    as part of compiling the application code that uses the library. This method compiles
    the library files into `.o` files and statically links them into the binary executable.
    Including libraries this way often applies to library code that you write for
    your own use (since you have access to its `.c` source files), and it’s also the
    method to build an executable from multiple `.c` modules.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 库的二进制形式可以直接从其源文件编译而来，作为编译使用该库的应用程序代码的一部分。这种方法将库文件编译成 `.o` 文件，并将它们静态链接到二进制可执行文件中。以这种方式包含库通常适用于为自己编写的库代码（因为你可以访问其
    `.c` 源文件），这也是从多个 `.c` 模块构建可执行文件的方法。
- en: Alternatively, a library could be compiled into a binary archive (`.a`) or a
    shared object (`.so`) file for programs that want to use the library. In these
    cases, users of the library often will not have access to the library’s C source
    code files, and thus they are not able to directly compile the library code with
    application code that uses it. When a program uses such a precompiled library
    (e.g., a `.a` or `.so`), the library’s code must be explicitly linked into the
    executable file using `gcc`’s `-l` command line option.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，库也可以被编译成二进制归档文件（`.a`）或共享对象文件（`.so`），供需要使用该库的程序使用。在这些情况下，库的用户通常无法访问库的 C 源代码文件，因此无法直接将库代码与使用它的应用程序代码一起编译。当程序使用这样的预编译库（例如
    `.a` 或 `.so` 文件）时，必须使用 `gcc` 的 `-l` 命令行选项显式地将库代码链接到可执行文件中。
- en: We focus our detailed discussion of writing, compiling, and linking library
    code on the case in which the programmer has access to individual library modules
    (either the `.c` or `.o` files). This focus also applies to designing and compiling
    large C programs that are divided into multiple `.c` and `.h` files. We briefly
    show commands for building archive and shared object forms of libraries. More
    information about building these types of library files is available in the `gcc`
    documentation, including the man pages for `gcc` and `ar`.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 我们详细讨论编写、编译和链接库代码的内容，重点是程序员可以访问单独的库模块（即 `.c` 或 `.o` 文件）的情况。这种重点同样适用于设计和编译被拆分为多个
    `.c` 和 `.h` 文件的大型 C 程序。我们简要介绍了构建归档库和共享对象库形式的命令。有关构建这些类型的库文件的更多信息，可以参考 `gcc` 文档，包括
    `gcc` 和 `ar` 的 man 页面。
- en: In the following, we show some examples of creating and using your own libraries.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们展示了一些创建和使用自己库的例子。
- en: '**Define the library interface** Header files (`.h` file) are text files that
    contain C function prototypes and other definitions—they represent the interface
    of a library. A header file must be included in any application that intends to
    use the library. For example, the C standard library header files are usually
    stored in `/usr/include/` and can be viewed with an editor:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义库接口** 头文件（`.h` 文件）是包含 C 函数原型和其他定义的文本文件——它们代表了库的接口。任何打算使用该库的应用程序必须包含头文件。例如，C
    标准库的头文件通常存储在 `/usr/include/` 目录下，并可以用编辑器查看：'
- en: '[PRE134]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Here’s an example header file^([8](ch02.xhtml#fn2_8)) from a library that contains
    some definitions for users of the library:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个来自库的示例头文件^([8](ch02.xhtml#fn2_8))，它包含一些供库用户使用的定义：
- en: myfile.h
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: myfile.h
- en: '[PRE135]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Header files typically have special “boilerplate” code around their contents.
    For example:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件通常在其内容周围有特殊的“样板”代码。例如：
- en: '[PRE136]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: This boilerplate code ensures that the compiler’s preprocessor only includes
    the contents of `mylib.h` exactly once in any C file that includes it. It is important
    to include `.h` file contents only once to avoid duplicate definition errors at
    compile time. Similarly, if you forget to include a `.h` file in a C program that
    uses the library, the compiler will generate an “undefined symbol” warning.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 这段样板代码确保编译器的预处理器只会在任何包含它的 C 文件中包含`mylib.h`的内容一次。确保只包含 `.h` 文件的内容一次非常重要，以避免在编译时出现重复定义错误。类似地，如果你忘记在使用该库的
    C 程序中包含 `.h` 文件，编译器会生成一个“未定义符号”的警告。
- en: The comments in the `.h` file are part of the interface to the library, written
    for users of the library. These comments should be verbose, explaining definitions
    and describing what each library function does, what parameter values it takes,
    and what it returns. Sometimes a `.h` file will also include a top-level comment
    describing how to use the library.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '`.h` 文件中的注释是库接口的一部分，写给库的用户。这些注释应该是详尽的，解释定义并描述每个库函数的功能，接受的参数值以及返回值。有时，`.h` 文件还会包含一个描述如何使用该库的顶层注释。'
- en: The keyword `extern` before the global variable definition and function prototype
    means that these names are defined somewhere else. It is particularly important
    to include `extern` before any global variables that the library exports, as it
    distinguishes a name and type definition (in the `.h` file) from a variable declaration
    in the library’s implementation. In the previous example, the global variable
    is declared exactly once inside the library, but it’s exported to library users
    through its `extern` definition in the library’s `.h` file.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 在全局变量定义和函数原型前加上关键字`extern`，意味着这些名称在其他地方已经定义。特别是要在库导出的任何全局变量前加上`extern`，因为它将名称和类型定义（在
    `.h` 文件中）与库实现中的变量声明区分开来。在前面的示例中，全局变量在库内部只声明一次，但通过在库的 `.h` 文件中的 `extern` 定义将其导出给库的用户。
- en: '**Implement the library functionality.** Programmers implement libraries in
    one or more `.c` files (and sometimes internal `.h` files). The implementation
    includes definitions of all the function prototypes in the `.h` file as well as
    other functions that are internal to its implementation. These internal functions
    are often defined with the keyword `static`, which scopes their availability to
    the module (`.c` file) in which they are defined. The library implementation should
    also include variable definitions for any `extern` global variable declarations
    in the `.h` file. Here’s an example library implementation:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现库功能。** 程序员在一个或多个 `.c` 文件中实现库（有时还包括内部 `.h` 文件）。实现包括 `.h` 文件中所有函数原型的定义以及库实现中的其他函数。这些内部函数通常使用关键字
    `static` 定义，这将它们的可用范围限定为定义它们的模块（`.c` 文件）。库实现还应该包括 `.h` 文件中任何 `extern` 全局变量声明的变量定义。下面是一个库实现的示例：'
- en: mylib.c
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: mylib.c
- en: '[PRE137]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '**Create a binary form of the library.** To create a binary form of the library
    (a `.o` file), compile with the `-c` option:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建库的二进制形式。** 要创建库的二进制形式（`.o` 文件），可以使用 `-c` 选项进行编译：'
- en: '[PRE138]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'One or more `.o` files can build an archive (`.a`) or shared object (`.so`)
    version of the library. To build a static library use the archiver (`ar`):'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 一个或多个 `.o` 文件可以构建库的归档（`.a`）或共享对象（`.so`）版本。要构建静态库，可以使用归档工具（`ar`）：
- en: '[PRE139]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'To build a dynamically linked library, the `mylib.o` object file(s) in the
    library must be built with *position independent code* (using `-fPIC`). A `libmylib.so`
    shared object file can be created from `mylib.o` by specifying the `-shared` flag
    to `gcc`:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个动态链接库，库中的`mylib.o`目标文件必须使用*位置无关代码*（使用`-fPIC`）。可以通过在`gcc`中指定`-shared`标志从`mylib.o`创建`libmylib.so`共享目标文件：
- en: '[PRE140]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Shared object and archive libraries are often built from multiple `.o` files,
    for example (remember that `.o` for dynamically linked libraries need to be built
    using the `-fPIC` flag):'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 共享对象和存档库通常由多个`.o`文件构建，例如（请记住，动态链接库的`.o`需要使用`-fPIC`标志构建）：
- en: '[PRE141]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '**Use and link the library.** Other `.c` files that use this library should
    `#include` its header file, and the implementation (`.o` file) should be explicitly
    linked during compilation.'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用和链接库**。使用此库的其他`.c`文件应该`#include`其头文件，并且在编译时需要显式地链接其实现（`.o`文件）。'
- en: 'After including the library header file, your code then can call the library’s
    functions:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含库头文件后，您的代码可以调用库的函数：
- en: myprog.c
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: myprog.c
- en: '[PRE142]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '**Note #INCLUDE SYNTAX AND THE PREPROCESSOR**'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意 #INCLUDE 语法和预处理器**'
- en: The `#include` syntax to include `mylib.h` is different from the syntax to include
    `stdio.h`. This is because `mylib.h` is not located with the header files from
    standard libraries. The preprocessor has default places it looks for standard
    header files. When including a file with the `<file.h>` syntax instead of the
    `"file.h"` syntax, the preprocessor searches for the header file in those standard
    places.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '`#include`语法包含`mylib.h`不同于包含`stdio.h`的语法。这是因为`mylib.h`不在标准库的头文件位置。预处理器有默认位置用于查找标准头文件。当使用`<file.h>`语法而不是`"file.h"`语法包含文件时，预处理器在这些标准位置中搜索头文件。'
- en: 'When `mylib.h` is included inside double quotes, the preprocessor first looks
    in the current directory for the `mylib.h` file, and then other places that you
    need to explicitly tell it to look, by specifying an include path (`-I`) to `gcc`.
    For example, if the header file is in the `/home/me/myincludes` directory (and
    not in the same directory as the `myprog.c` file), then the path to this directory
    must be specified in the `gcc` command line for the preprocessor to find the `mylib.h`
    file:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 当`mylib.h`包含在双引号内时，预处理器首先在当前目录中查找`mylib.h`文件，然后需要显式告诉它查找其他位置，通过在`gcc`中指定包含路径(`-I`)。例如，如果头文件位于`/home/me/myincludes`目录中（而不是与`myprog.c`文件相同的目录中），则必须在`gcc`命令行中指定此目录路径以便预处理器找到`mylib.h`文件：
- en: $ gcc -I/home/me/myincludes -c myprog.c
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: $ gcc -I/home/me/myincludes -c myprog.c
- en: 'To compile a program (`myprog.c`) that uses the library (`mylib.o`) into a
    binary executable:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译一个使用库(`mylib.o`)的程序(`myprog.c`)成为一个可执行二进制文件：
- en: '[PRE143]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Or, if the library’s implementation files are available at compile time, then
    the program can be built directly from the program and library `.c` files:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果在编译时库的实现文件可用，那么程序可以直接从程序和库的`.c`文件构建：
- en: '[PRE144]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Or, if the library is available as an archive or shared object file, then it
    can be linked in using `-l` (`-lmylib`: note that the library name is `libmylib.[a,so]`,
    but only the `mylib` part is included in the `gcc` command line):'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果库作为存档文件或共享目标文件可用，则可以使用`-l`（`-lmylib`：注意库名称是`libmylib.[a,so]`，但`gcc`命令行中仅包含`mylib`部分）进行链接：
- en: '[PRE145]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'The `-L.` option specifies the path to the `libmylib.[so,a]` files (the `.`
    after the `-L` indicates that it should search the current directory). By default,
    `gcc` will dynamically link a library if it can find a `.so` version. See “C Libraries:
    Using, Compiling, and Linking” on [page 133](ch02.xhtml#lev2_40) for more information
    about linking and link paths.'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: '`-L.`选项指定路径到`libmylib.[so,a]`文件（`-L`后面的`.`表示应该搜索当前目录）。默认情况下，如果`gcc`找到`.so`版本，它将动态链接库。有关更多关于链接和链接路径的信息，请参阅[第133页](ch02.xhtml#lev2_40)的“C库：使用、编译和链接”。'
- en: 'The program can then be run:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 然后程序可以运行：
- en: '[PRE146]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'If you run the dynamically linked version of `myprog`, you may encounter an
    error that looks like this:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行动态链接版本的`myprog`，可能会遇到如下错误：
- en: '[PRE147]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'This error is saying that the runtime linker cannot find `libmylib.so` at runtime.
    To fix this problem, set your `LD_LIBRARY_PATH` environment variable to include
    the path to the `libmylib.so` file. Subsequent runs of `myprog` use the path you
    add to `LD_LIBRARY_PATH` to find the `libmylib.so` file and load it at runtime.
    For example, if `libmylib.so` is in the `/home/me/mylibs/` subdirectory, run this
    (just once) at the bash shell prompt to set the `LD_LIBRARY_PATH` environment
    variable:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 2.9.7 Compiling C to Assembly, and Compiling and Linking Assembly and C Code
  id: totrans-675
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A compiler can compile C code to assembly code, and it can compile assembly
    code into a binary form that links into a binary executable program. We use IA32
    assembly and `gcc` as our example assembly language and compiler, but this functionality
    is supported by any C compiler, and most compilers support compiling to a number
    of different assembly languages. See [Chapter 8](ch08.xhtml#ch08) for details
    about assembly code and assembly programming.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this very simple C program:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: simpleops.c
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'The `gcc` compiler will compile it into an IA32 assembly text file (`.s`) using
    the `-S` command line option to specify compiling to assembly and the `-m32` command
    line option to specify generating IA32 assembly:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'This command creates a file named `simpleops.s` with the compiler’s IA32 assembly
    translation of the C code. Because the `.s` file is a text file, a user can view
    it (and edit it) using any text editor. For example:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Passing additional compiler flags provides directions to `gcc` that it should
    use certain features or optimizations in its translation of C to IA32 assembly
    code.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: 'An assembly code file, either one generated from `gcc` or one written by hand
    by a programmer, can be compiled by `gcc` into binary machine code form using
    the `-c` option:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'The resulting `simpleops.o` file can then be linked into a binary executable
    file (note: this requires that the 32-bit version of the system libraries are
    installed on your system):'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: This command creates a binary executable file, `simpleops`, for IA32 (and x86-64)
    architectures.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: The `gcc` command line to build an executable file can include `.o` and `.c`
    files that will be compiled and linked together to create the single binary executable.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: 'Systems provide utilities that allow users to view binary files. For example,
    `objdump` displays the machine code and assembly code mappings in `.o` files:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'This output can be compared to the assembly file:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'You should see something like this (we’ve annotated some of the assembly code
    with its corresponding code from the C program):'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Writing and Compiling Assembly Code
  id: totrans-697
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Programmers can write their own assembly code by hand and compile it with `gcc`
    into a binary executable program. For example, to implement a function in assembly,
    add code to a `.s` file and use `gcc` to compile it. The following example shows
    the basic structure of a function in IA32 assembly. Such code would be written
    in a file (e.g., `myfunc.s`) for a function with the prototype `int myfunc(int
    param);`. Functions with more parameters or needing more space for local variables
    may differ slightly in their preamble code.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员可以手动编写汇编代码，并使用`gcc`将其编译为二进制可执行程序。例如，要用汇编实现一个函数，可以将代码添加到`.s`文件中，然后使用`gcc`进行编译。以下示例展示了IA32汇编中函数的基本结构。这种代码会写在一个文件中（例如，`myfunc.s`），用于一个原型为`int
    myfunc(int param);`的函数。具有更多参数或需要更多空间存储局部变量的函数，其前导代码可能略有不同。
- en: '[PRE157]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'A C program that wanted to call this function would need to include its function
    prototype:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 一个想调用此函数的C程序需要包含其函数原型：
- en: '[PRE158]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'The following `gcc` commands build an executable file (`myprog`) from `myfunc.s`
    and `main.c` source files:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`gcc`命令将从`myfunc.s`和`main.c`源文件构建一个可执行文件（`myprog`）：
- en: '[PRE159]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: HANDWRITTEN ASSEMBLY CODE
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 手写汇编代码
- en: Unlike C, which is a high-level language that can be compiled and run on a wide
    variety of systems, assembly code is very low level and specific to a particular
    hardware architecture. Programmers may handwrite assembly code for low-level functions
    or for code sequences that are crucial to the performance of their software. A
    programmer can sometimes write assembly code that runs faster than the compiler-optimized
    assembly translation of C, and sometimes a C programmer wants to access low-level
    parts of the underlying architecture (such as specific registers) in their code.
    Small parts of operating system code are often implemented in assembly code for
    these reasons. However, because C is a portable language and is much higher level
    than assembly languages, the vast majority of operating system code is written
    in C, relying on good optimizing compilers to produce machine code that performs
    well.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 与C语言不同，C是可以在多种系统上编译和运行的高级语言，而汇编代码则是非常底层且特定于某一硬件架构的。程序员可能会手写汇编代码，用于低级功能或对软件性能至关重要的代码序列。程序员有时可以写出比编译器优化的C汇编翻译更快的汇编代码，有时C程序员也想在代码中访问底层架构的某些部分（例如特定寄存器）。由于这些原因，操作系统代码的小部分通常用汇编语言实现。然而，由于C语言是一种便携式语言，且比汇编语言高级得多，绝大多数操作系统代码都是用C编写的，并依赖于优秀的优化编译器生成性能良好的机器代码。
- en: Although most systems programmers rarely write assembly code, being able to
    read and understand a program’s assembly code is an important skill for obtaining
    a deeper understanding of what a program does and how it gets executed. It can
    also help with understanding a program’s performance and with discovering and
    understanding security vulnerabilities in programs.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数系统程序员很少编写汇编代码，但能够阅读和理解程序的汇编代码是获取更深刻理解程序功能和执行过程的重要技能。这也有助于理解程序的性能，并发现和理解程序中的安全漏洞。
- en: 2.10 Summary
  id: totrans-707
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.10 总结
- en: 'In this chapter, we covered the C programming language in depth and discussed
    some advanced C programming topics, as well. In the next chapter, we present two
    very helpful C debugging tools: the GNU GDB debugger for general-purpose C program
    debugging, and the Valgrind memory debugger for finding memory access errors in
    C programs. Equipped with these programming tools and knowledge of the core C
    programming language presented in this chapter, a C programmer can design powerful,
    efficient, and robust software.'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入讲解了C编程语言，并讨论了一些高级C编程主题。在下一章中，我们将介绍两种非常有用的C调试工具：用于通用C程序调试的GNU GDB调试器，以及用于查找C程序内存访问错误的Valgrind内存调试器。通过掌握这些编程工具和本章介绍的C语言核心知识，C程序员可以设计出强大、高效且健壮的软件。
- en: Notes
  id: totrans-709
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: '[1.](ch02.xhtml#rfn2_1) *[http://pages.cs.wisc.edu/~remzi/OSTEP/vm-freespace.pdf](http://pages.cs.wisc.edu/~remzi/OSTEP/vm-freespace.pdf)*'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: '[1.](ch02.xhtml#rfn2_1) *[http://pages.cs.wisc.edu/~remzi/OSTEP/vm-freespace.pdf](http://pages.cs.wisc.edu/~remzi/OSTEP/vm-freespace.pdf)*'
- en: '[2.](ch02.xhtml#rfn2_2) *[https://diveintosystems.org/book/C2-C_depth/_attachments/strtokexample.c](https://diveintosystems.org/book/C2-C_depth/_attachments/strtokexample.c)*'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '[2.](ch02.xhtml#rfn2_2) *[https://diveintosystems.org/book/C2-C_depth/_attachments/strtokexample.c](https://diveintosystems.org/book/C2-C_depth/_attachments/strtokexample.c)*'
- en: '[3.](ch02.xhtml#rfn2_3) *[http://www.cs.swarthmore.edu/~newhall/unixhelp/man.html](http://www.cs.swarthmore.edu/~newhall/unixhelp/man.html)*'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: '[3.](ch02.xhtml#rfn2_3) *[http://www.cs.swarthmore.edu/~newhall/unixhelp/man.html](http://www.cs.swarthmore.edu/~newhall/unixhelp/man.html)*'
- en: '[4.](ch02.xhtml#rfn2_4) *[https://diveintosystems.org/book/C2-C_depth/_attachments/commandlineargs.c](https://diveintosystems.org/book/C2-C_depth/_attachments/commandlineargs.c)*'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: '[4.](ch02.xhtml#rfn2_4) *[https://diveintosystems.org/book/C2-C_depth/_attachments/commandlineargs.c](https://diveintosystems.org/book/C2-C_depth/_attachments/commandlineargs.c)*'
- en: '[5.](ch02.xhtml#rfn2_5) *[https://wikipedia.org/wiki/Executable_and_Linkable_Format](https://wikipedia.org/wiki/Executable_and_Linkable_Format)*'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '[5.](ch02.xhtml#rfn2_5) *[https://wikipedia.org/wiki/Executable_and_Linkable_Format](https://wikipedia.org/wiki/Executable_and_Linkable_Format)*'
- en: '[6.](ch02.xhtml#rfn2_6) *[http://www.cs.swarthmore.edu/~newhall/unixhelp/compilecycle.html](http://www.cs.swarthmore.edu/~newhall/unixhelp/compilecycle.html)*'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '[6.](ch02.xhtml#rfn2_6) *[http://www.cs.swarthmore.edu/~newhall/unixhelp/compilecycle.html](http://www.cs.swarthmore.edu/~newhall/unixhelp/compilecycle.html)*'
- en: '[7.](ch02.xhtml#rfn2_7) *[https://www.cs.swarthmore.edu/~newhall/unixhelp/howto[m]akefiles.html](https://www.cs.swarthmore.edu/~newhall/unixhelp/howto_makefiles.html)*'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '[7.](ch02.xhtml#rfn2_7) *[https://www.cs.swarthmore.edu/~newhall/unixhelp/howto_makefiles.html](https://www.cs.swarthmore.edu/~newhall/unixhelp/howto_makefiles.html)*'
- en: '[8.](ch02.xhtml#rfn2_8) *[https://diveintosystems.org/book/C2-C_depth/_attachments/mylib.h](https://diveintosystems.org/book/C2-C_depth/_attachments/mylib.h)*'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: '[8.](ch02.xhtml#rfn2_8) *[https://diveintosystems.org/book/C2-C_depth/_attachments/mylib.h](https://diveintosystems.org/book/C2-C_depth/_attachments/mylib.h)*'
