- en: '2'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '2'
- en: A DEEPER DIVE INTO C PROGRAMMING
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 深入探索 C 编程
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: With many of the basics of C programming covered in the previous chapter, we
    now dive deeper into the details of C. In this chapter we revisit many of the
    topics from the previous chapter, such as arrays, strings, and structs, discussing
    them in more detail. We also introduce C’s pointer variables and dynamic memory
    allocation. *Pointers* provide a level of indirection to accessing program state,
    and *dynamic memory allocation* allows a program to adjust to changes in size
    and space needs as it runs, allocating more space as it needs it and freeing space
    it no longer needs. By understanding how and when to use pointer variables and
    dynamic memory allocation, a C programmer can design programs that are both powerful
    and efficient.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章涵盖了 C 编程的许多基础内容后，我们现在将更深入地探讨 C 的细节。在本章中，我们将重新审视上一章中的许多主题，如数组、字符串和结构体，并对它们进行更详细的讨论。我们还将介绍
    C 的指针变量和动态内存分配。*指针*为访问程序状态提供了间接性，而*动态内存分配*则允许程序根据运行时的大小和空间需求进行调整，在需要时分配更多空间，并释放不再需要的空间。通过理解如何以及何时使用指针变量和动态内存分配，C
    程序员可以设计出既强大又高效的程序。
- en: We begin with a discussion of the parts of program memory, as this will help
    in understanding many of the topics presented later. As the chapter progresses,
    we cover C file I/O and some advanced C topics including library linking and compiling
    to assembly code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先讨论程序内存的各个部分，因为这将有助于理解后续介绍的许多主题。随着章节的进展，我们将涵盖 C 文件 I/O 以及一些高级 C 话题，包括库链接和编译成汇编代码。
- en: 2.1 Parts of Program Memory and Scope
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1 程序内存的组成和作用域
- en: 'The following C program shows examples of functions, parameters, and local
    and global variables (function comments are omitted to shorten this code listing):'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 C 程序展示了函数、参数以及局部和全局变量的示例（为简化代码列表，省略了函数注释）：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This example shows program variables with different scope. A variable’s *scope*
    defines when its name has meaning. In other words, scope defines the set of program
    code blocks in which a variable is bound to (associated with) a program memory
    location and can be used by program code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了具有不同作用域的程序变量。一个变量的*作用域*定义了其名称何时具有意义。换句话说，作用域定义了程序代码块的集合，在这些代码块中，变量与程序内存位置绑定并可以被程序代码使用。
- en: Declaring a variable outside of any function body creates a *global variable*.
    Global variables remain permanently in scope and can be used by any code in the
    program because they’re always bound to one specific memory location. Every global
    variable must have a unique name—its name uniquely identifies a specific storage
    location in program memory for the entire duration of the program.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何函数体外声明一个变量会创建一个*全局变量*。全局变量始终存在于作用域内，并且可以被程序中任何代码使用，因为它们始终绑定到一个特定的内存位置。每个全局变量必须有一个唯一的名称——它的名称在程序运行期间唯一地标识程序内存中的特定存储位置。
- en: '*Local variables and parameters* are only in scope inside the function in which
    they are defined. For example, the `amt` parameter is in scope only inside the
    `change` function. This means that only statements within the `change` function
    body can access the `amt` parameter, and an instance of the `amt` parameter is
    bound to a specific memory storage location only within a specific active execution
    of the function. Space to store a parameter’s value is allocated on the stack
    when the function gets called, and it is deallocated from the stack when the function
    returns. Each activation of a function gets its own bindings for its parameters
    and local variables. Thus, for recursive function calls, each call (or activation)
    gets a separate stack frame containing space for its parameters and local variables.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*局部变量和参数*仅在它们被定义的函数内有效。例如，`amt` 参数只在 `change` 函数内有效。这意味着只有 `change` 函数体内的语句能够访问
    `amt` 参数，并且 `amt` 参数的实例仅在特定的函数执行期间绑定到一个特定的内存存储位置。当函数被调用时，存储参数值的空间会在栈上分配，并在函数返回时从栈中释放。每次函数激活时都会为其参数和局部变量分配独立的绑定。因此，对于递归函数调用，每次调用（或激活）都会获得一个包含其参数和局部变量空间的独立栈帧。'
- en: Because parameters and local variables are only in scope inside the function
    that defines them, different functions can use the same names for local variables
    and parameters. For example, both the `change` and the `max` functions have a
    local variable named `val`. When code in the `max` function refers to `val` it
    refers to its local variable `val` and not to the `change` function’s local variable
    `val` (which is not in scope inside the `max` function).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于参数和局部变量仅在定义它们的函数内部有效，不同的函数可以使用相同的名字来命名局部变量和参数。例如，`change`函数和`max`函数都有一个名为`val`的局部变量。当`max`函数中的代码引用`val`时，它指的是该函数的局部变量`val`，而不是`change`函数的局部变量`val`（后者在`max`函数的作用域内不可用）。
- en: While there may occasionally be times when using global variables in C programs
    is necessary, we strongly recommend that you *avoid programming with global variables
    whenever possible*. Using only local variables and parameters yields code that’s
    more modular, more general-purpose, and easier to debug. Also, because a function’s
    parameters and local variables are only allocated in program memory when the function
    is active, they may result in more space-efficient programs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在C程序中有时需要使用全局变量，但我们强烈建议你*尽可能避免使用全局变量编程*。仅使用局部变量和参数可以让代码更加模块化、通用，且更容易调试。而且，由于函数的参数和局部变量仅在函数激活时才分配到程序内存中，它们可能导致程序更加节省空间。
- en: Upon launching a new program, the operating system allocates the new program’s
    address space. A program’s *address space* (or memory space) represents storage
    locations for everything it needs in its execution, namely storage for its instructions
    and data. A program’s address space can be thought of as an array of addressable
    bytes; each used address in the program’s address space stores all or part of
    a program instruction or data value (or some additional state necessary for the
    program’s execution).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 启动新程序时，操作系统为新程序分配地址空间。程序的*地址空间*（或内存空间）代表了程序执行所需的所有存储位置，即用于存储指令和数据的存储区。程序的地址空间可以看作是一个可寻址字节的数组；程序地址空间中每个使用的地址存储了程序指令或数据值的全部或部分（或程序执行所需的其他状态）。
- en: A program’s memory space is divided into several parts, each of which is used
    to store a different kind of entity in the process’s address space. [Figure 2-1](ch02.xhtml#ch2fig1)
    illustrates the parts of a program’s memory space.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的内存空间被分为几个部分，每个部分用于存储进程地址空间中的不同类型的实体。[图 2-1](ch02.xhtml#ch2fig1)展示了程序内存空间的各个部分。
- en: '![image](../images/02fig01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig01.jpg)'
- en: '*Figure 2-1: The parts of a program’s address space*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-1：程序地址空间的各个部分*'
- en: The top of a program’s memory is reserved for use by the operating system, but
    the remaining parts are usable by the running program. The program’s instructions
    are stored in the *code* section of the memory. For example, the program listed
    earlier stores instructions for the `main`, `max`, and `change` functions in this
    region of memory.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 程序内存的顶部保留供操作系统使用，而其余部分则可供正在运行的程序使用。程序的指令存储在内存的*代码*部分。例如，前面提到的程序将`main`、`max`和`change`函数的指令存储在该内存区域。
- en: Local variables and parameters reside in the portion of memory for the *stack*.
    Because the amount of stack space grows and shrinks over the program’s execution
    as functions are called and returned from, the stack part of memory is typically
    allocated near the bottom of memory (at the highest memory addresses) to leave
    space for it to change. Stack storage space for local variables and parameters
    exists only when the function is active (within the stack frame for the function’s
    activation on the stack).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量和参数存储在*栈*的内存部分中。由于栈空间随着函数调用和返回而增大和缩小，栈的内存部分通常会分配在内存的底部（即最高的内存地址），以便为栈的变化留出空间。局部变量和参数的栈存储空间仅在函数活动时存在（即在函数激活的栈帧内）。
- en: Global variables are stored in the *data* section. Unlike the stack, the data
    region does not grow or shrink—storage space for globals persists for the entire
    run of the program.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量存储在*数据*部分。与栈不同，数据区域不会增长或缩小——全局变量的存储空间在程序运行的整个过程中都持续存在。
- en: Finally, the *heap* portion of memory is the part of a program’s address space
    associated with dynamic memory allocation. The heap is typically located far from
    stack memory and grows into higher addresses as more space is dynamically allocated
    by the running program.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，内存的*堆*部分是程序地址空间中与动态内存分配相关的部分。堆通常位于远离栈内存的位置，随着程序动态分配更多空间，它会向更高的地址增长。
- en: 2.2 C’s Pointer Variables
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2 C语言的指针变量
- en: 'C’s pointer variables provide a level of indirection to accessing program memory.
    By understanding how to use pointer variables, a programmer can write C programs
    that are both powerful and efficient. For example, through pointer variables,
    a C programmer can:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: C语言的指针变量为访问程序内存提供了间接性。通过理解如何使用指针变量，程序员可以编写既强大又高效的C程序。例如，通过指针变量，C程序员可以：
- en: implement functions whose parameters can modify values in the caller’s stack
    frame
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现能够修改调用者栈帧中值的函数
- en: dynamically allocate (and deallocate) program memory at runtime when the program
    needs it
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在程序运行时，根据需要动态分配（和释放）程序内存
- en: efficiently pass large data structures to functions
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效地将大型数据结构传递给函数
- en: create linked dynamic data structures
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建链式动态数据结构
- en: interpret bytes of program memory in different ways.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以不同方式解释程序内存的字节。
- en: In this section, we introduce the syntax and semantics of C’s pointer variables
    and introduce common examples of how to use them in C programs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍C语言指针变量的语法和语义，并介绍如何在C程序中使用它们的常见示例。
- en: 2.2.1 Pointer Variables
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.1 指针变量
- en: 'A *pointer variable* stores the address of a memory location in which a value
    of a specific type can be stored. For example, a pointer variable can store the
    value of an `int` address at which the integer value 12 is stored. The pointer
    variable *points to* (refers to) the value. A pointer provides *a level of indirection*
    for accessing values stored in memory. [Figure 2-2](ch02.xhtml#ch2fig2) illustrates
    an example of what a pointer variable might look like in memory:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*指针变量*存储一个内存位置的地址，特定类型的值可以存储在该地址中。例如，指针变量可以存储一个`int`地址，该地址中存储整数值12。指针变量*指向*（引用）该值。指针为访问存储在内存中的值提供了*间接性*。[图
    2-2](ch02.xhtml#ch2fig2)展示了指针变量在内存中的示例：'
- en: '![image](../images/02fig02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig02.jpg)'
- en: '*Figure 2-2: A pointer variable stores the address of a location in memory.
    Here, the pointer stores the address of an integer variable that holds the number
    12.*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-2：指针变量存储内存中某个位置的地址。这里，指针存储一个整数变量的地址，该变量保存数字12。*'
- en: 'Through the pointer variable, `ptr`, the value (`12`) stored in the memory
    location it points to can be indirectly accessed. C programs most frequently use
    pointer variables for:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指针变量`ptr`，可以间接访问它指向的内存位置中存储的值（例如`12`）。C程序最常用指针变量的方式包括：
- en: 1\. *“pass by pointer” parameters*, for writing functions that can modify their
    argument’s value through a pointer parameter
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 1. *“按指针传递”参数*，用于编写可以通过指针参数修改其参数值的函数
- en: 2\. *dynamic memory allocation*, for writing programs that allocate (and free)
    space as the program runs. Dynamic memory is commonly used for dynamically allocating
    arrays. It is useful when a programmer doesn’t know the size of a data structure
    at compile time (e.g., the array size depends on user input at runtime). It also
    enables data structures to be resized as the program runs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 2. *动态内存分配*，用于编写能够在程序运行时分配（和释放）内存空间的程序。动态内存通常用于动态分配数组。它在程序员不知道数据结构大小的情况下特别有用（例如，数组的大小取决于运行时用户输入）。它还使数据结构能够在程序运行时调整大小。
- en: Rules for Using Pointer Variables
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用指针变量的规则
- en: 'The rules for using pointer variables are similar to regular variables, except
    that you need to think about two types: the type of the pointer variable, and
    the type stored in the memory address to which the pointer variable points.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用指针变量的规则与常规变量类似，唯一不同的是你需要考虑两种类型：指针变量的类型，以及指针变量指向的内存地址中存储的类型。
- en: 'First, *declare a pointer variable* using <type_name> `*`<var_name>:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，*声明一个指针变量*，使用<类型名> `*`<变量名>：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Note POINTER TYPES**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意 指针类型**'
- en: 'Although `ptr` and `cptr` are both pointers, they refer to different types:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`ptr`和`cptr`都是指针，但它们指向不同的类型：
- en: The type of `ptr` is *pointer to int* (`int *`). It can point to a memory location
    that stores an `int` value.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ptr`的类型是*指向整数的指针*（`int *`）。它可以指向存储`int`值的内存位置。'
- en: The type of `cptr` is *pointer to char* (`char *`). It can point to a memory
    location that stores a `char` value.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cptr`的类型是*指向字符的指针*（`char *`）。它可以指向存储`char`值的内存位置。'
- en: 'Next, *initialize the pointer variable* (make it point to something). Pointer
    variables *store address values*. A pointer should be initialized to store the
    address of a memory location whose type matches the type to which the pointer
    variable points. One way to initialize a pointer is to use the *address operator*
    (`&`) with a variable to get the variable’s address value:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，*初始化指针变量*（使其指向某个地方）。指针变量*存储地址值*。指针应该初始化为存储与指针变量指向的类型匹配的内存位置的地址值。初始化指针的一种方式是使用*地址操作符*（`&`）与变量一起获取该变量的地址值：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![image](../images/02fig03.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig03.jpg)'
- en: '*Figure 2-3: A program can initialize a pointer by assigning it the address
    of an existing variable of the appropriate type.*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-3：程序可以通过将指针赋值为现有变量的地址来初始化指针。*'
- en: 'Here’s an example of an invalid pointer initialization due to mismatched types:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个由于类型不匹配导致的无效指针初始化示例：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Even though the C compiler may allow this type of assignment (with a warning
    about incompatible types), the behavior of accessing and modifying `x` through
    `cptr` will likely not behave as the programmer expects. Instead, the programmer
    should use an `int *` variable to point to an `int` storage location.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 C 编译器可能允许这种类型的赋值（并给出关于不兼容类型的警告），通过`cptr`访问和修改`x`的行为可能不会像程序员预期的那样工作。相反，程序员应该使用`int
    *`类型的变量指向一个`int`存储位置。
- en: 'All pointer variables can also be assigned a special value, `NULL`, which represents
    an invalid address. While a *null pointer* (one whose value is `NULL`) should
    never be used to access memory, the value `NULL` is useful for testing a pointer
    variable to see if it points to a valid memory address. That is, C programmers
    will commonly check a pointer to ensure that its value isn’t `NULL` before attempting
    to access the memory location to which it points. To set a pointer to `NULL`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 所有指针变量也可以被赋予特殊值`NULL`，表示无效地址。虽然*空指针*（值为`NULL`的指针）不应被用于访问内存，但`NULL`值对于测试指针变量是否指向有效内存地址非常有用。也就是说，C
    程序员通常会检查指针，确保它的值不是`NULL`，然后再尝试访问它所指向的内存位置。要将指针设置为`NULL`：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![image](../images/02fig04.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig04.jpg)'
- en: '*Figure 2-4: Any pointer can be given the special value `NULL`, which indicates
    that it doesn’t refer to any particular address. Null pointers should never be
    dereferenced.*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-4：任何指针都可以赋予特殊值`NULL`，表示它不指向任何特定地址。空指针不应被解引用。*'
- en: 'Finally, *use the pointer variable*. The *dereference operator* (`*`) follows
    a pointer variable to the location in memory that it points to and accesses the
    value at that location:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*使用指针变量*。*解引用操作符*（`*`）跟随指针变量，指向它在内存中所指向的位置，并访问该位置的值：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![image](../images/02fig05.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig05.jpg)'
- en: '*Figure 2-5: Dereferencing a pointer accesses the value to which the pointer
    refers.*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-5：解引用指针可以访问指针所指向的值。*'
- en: Pointer Examples
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 指针示例
- en: 'Here’s an example sequence of C statements using two pointer variables:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用两个指针变量的 C 语句示例：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![image](../images/f0069-01.jpg) [PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![image](../images/f0069-01.jpg) [PRE7]'
- en: '![image](../images/f0070-01.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0070-01.jpg)'
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![image](../images/f0070-02.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0070-02.jpg)'
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![image](../images/f0070-03.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0070-03.jpg)'
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![image](../images/f0070-04.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0070-04.jpg)'
- en: 'When using pointer variables, carefully consider the types of the relevant
    variables. Drawing pictures of memory (like those shown above) can help with understanding
    what pointer code is doing. Some common errors involve misusing the dereference
    operator (`*`) or the address operator (`&`). For example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用指针变量时，要仔细考虑相关变量的类型。绘制内存图像（如上所示）有助于理解指针代码的作用。一些常见的错误涉及错误使用解引用操作符（`*`）或地址操作符（`&`）。例如：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If your program dereferences a pointer variable that does not contain a valid
    address, the program crashes:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序解引用一个不包含有效地址的指针变量，程序会崩溃：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'These types of errors exemplify one reason to initialize pointer variables
    to `NULL`; a program can then test a pointer’s value for `NULL` before dereferencing
    it:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的错误展示了为什么需要将指针变量初始化为`NULL`；程序可以在解引用指针之前，先测试指针的值是否为`NULL`：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 2.3 Pointers and Functions
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3 指针与函数
- en: Pointer parameters provide a mechanism through which functions can modify argument
    values. The commonly used *pass by pointer* pattern uses a pointer function parameter
    that *gets the value of the address of some storage location* passed to it by
    the caller. For example, the caller could pass the address of one of its local
    variables. By dereferencing the pointer parameter inside the function, the function
    can modify the value at the storage location to which it points.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 指针参数提供了一种机制，通过它函数可以修改参数值。常用的*按指针传递*模式使用一个指针函数参数，该指针函数参数*获取调用者传递给它的某个存储位置的地址值*。例如，调用者可以传递它的一个局部变量的地址。通过在函数内取消引用指针参数，函数可以修改指针所指向存储位置的值。
- en: We have already seen similar functionality with array parameters, where an array
    function parameter gets the value of the base address of the passed array (the
    parameter refers to the same set of array elements as its argument), and the function
    can modify the values stored in the array. In general, this same idea can be applied
    by passing pointer parameters to functions that point to the memory locations
    in the caller’s scope.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了类似的功能，使用数组参数时，数组函数参数会获取传入数组的基地址的值（该参数引用的数组元素集与其参数相同），并且函数可以修改数组中存储的值。通常，这个想法可以通过将指针参数传递给指向调用者作用域中内存位置的函数来应用。
- en: '**Note PASS BY VALUE**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：按值传递**'
- en: 'All arguments in C are passed by value and follow pass-by-value semantics:
    the parameter gets a copy of its argument value, and modifying the parameter’s
    value does not change its argument’s value. When passing base type values, like
    the value of an `int` variable, the function parameter gets a copy of its argument
    value (the specific `int` value), and changing the value stored in the parameter
    cannot change the value stored in its argument.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 C 语言的参数都是按值传递的，并遵循按值传递的语义：参数获取其参数值的副本，修改参数的值不会改变其参数值。在传递基本类型值时，像`int`变量的值，函数参数获取的是其参数值的副本（具体的`int`值），并且改变参数中存储的值不会改变其参数中的值。
- en: In the pass-by-pointer pattern, the parameter still gets the value of its argument,
    but it is passed *the value of an address*. Just like in passing base types, changing
    a pointer parameter’s value will not change its argument’s value (i.e., assigning
    the parameter to point to a different address will not change the argument’s address
    value). However, by dereferencing a pointer parameter, the function can change
    the contents of memory that both the parameter and its argument refer to; through
    a pointer parameter, a function can modify a variable that is visible to the caller
    after the function returns.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在按指针传递的模式中，参数仍然获取其参数的值，但它被传递的是*地址的值*。就像传递基本类型一样，改变指针参数的值不会改变其参数的值（即，赋值使参数指向不同的地址不会改变参数的地址值）。然而，通过取消引用指针参数，函数可以改变参数和其参数所引用的内存内容；通过指针参数，函数可以修改一个在函数返回后调用者仍然可见的变量。
- en: 'Here are the steps for implementing and calling a function with a pass-by-pointer
    parameter, with example code snippets showing each step:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是实现和调用带有按指针传递参数的函数的步骤，其中包含显示每个步骤的示例代码片段：
- en: '1\. Declare the function parameter to be a pointer to the variable type:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 声明函数参数为指向变量类型的指针：
- en: '/* input: an int pointer that stores the address of a memory'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: /* 输入：存储内存地址的 int 指针
- en: '*        location that can store an int value (it points to an int)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*        可以存储 int 值的位置（指向一个 int）'
- en: '*/'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*/'
- en: int change_value(int *input) {
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: int change_value(int *input) {
- en: '2\. When making the function call, pass in the address of a variable as the
    argument:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 调用函数时，将变量的地址作为参数传入：
- en: int x;
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: int x;
- en: change_value(&x);
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: change_value(&x);
- en: In the preceding example, since the parameter’s type is `int *`, the address
    passed must be the address of an `int` variable.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，由于参数类型是`int *`，因此传递的地址必须是一个`int`变量的地址。
- en: '3\. In the body of the function, dereference the pointer parameter to change
    the argument’s value:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 在函数体内，取消引用指针参数来改变参数值：
- en: '*input = 100;  // the location input points to (x''s memory)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*input = 100;  // input 指向的位置（x 的内存）'
- en: // is assigned 100
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: // 被赋值为 100
- en: 'Next, let’s examine a larger example program:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看一个更大的示例程序：
- en: passbypointer.c
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: passbypointer.c
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When run, the output is:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，输出结果是：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[Figure 2-6](ch02.xhtml#ch2fig6) shows what the call stack looks like before
    executing the return in `change_value`.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-6](ch02.xhtml#ch2fig6) 显示了 `change_value` 执行返回前的调用栈。'
- en: '![image](../images/02fig06.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig06.jpg)'
- en: '*Figure 2-6: A snapshot of the call stack prior to returning from `change_value`*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-6：在从`change_value`返回之前调用栈的快照*'
- en: The input parameter gets a copy of the value of its argument (the address of
    `x`). The value of `x` is 30 when the function call is made. Inside the `change_value`
    function, the parameter is dereferenced to assign the value 100 to the memory
    location pointed to by the parameter (`*input = 100;`, meaning “the location `input`
    points to gets the value 100”). Since the parameter stores the address of a local
    variable in the `main` function’s stack frame, through dereferencing the parameter,
    the value stored in the caller’s local variable can be changed. When the function
    returns, the argument’s value reflects the change made to it through the pointer
    parameter (the value of `x` in `main` was changed to 100 by the `change_value`
    function through its `input` parameter).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 输入参数获得其参数值的副本（即`x`的地址）。当函数调用时，`x`的值为30。在`change_value`函数内部，通过解引用参数将100赋值给参数指向的内存位置（`*input
    = 100;`，意味着“`input`指向的位置将得到100”）。由于参数存储的是`main`函数栈帧中局部变量的地址，因此通过解引用该参数，可以更改调用者局部变量中存储的值。当函数返回时，参数值反映了通过指针参数所做的更改（`main`中的`x`值通过`change_value`函数的`input`参数被更改为100）。
- en: 2.4 Dynamic Memory Allocation
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4 动态内存分配
- en: In addition to pass-by-pointer parameters, programs commonly use pointer variables
    to dynamically allocate memory. Such *dynamic memory allocation* allows a C program
    to request more memory as it’s running, and a pointer variable stores the address
    of the dynamically allocated space. Programs often allocate memory dynamically
    to tailor the size of an array for a particular run.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过指针传递参数外，程序通常还使用指针变量来动态分配内存。这种*动态内存分配*允许C程序在运行时请求更多的内存，而指针变量存储着动态分配空间的地址。程序通常会动态分配内存，以便根据特定运行定制数组的大小。
- en: 'Dynamic memory allocation grants flexibility to programs that:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 动态内存分配为程序提供了灵活性，能够：
- en: do not know the size of arrays or other data structures until runtime (e.g.,
    the size depends on user input)
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时之前无法知道数组或其他数据结构的大小（例如，大小取决于用户输入）
- en: need to allow for a variety of input sizes (not just up to some fixed capacity)
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要允许多种输入大小（不仅仅是某个固定的容量）
- en: want to allocate exactly the size of data structures needed for a particular
    execution (don’t waste capacity)
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想要为特定的执行精确分配所需的数据结构大小（不要浪费容量）
- en: grow or shrink the sizes of memory allocated as the program runs, reallocating
    more space when needed and freeing up space when it’s no longer required.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在程序运行时根据需要增长或缩小已分配的内存大小，当需要时重新分配更多空间，当不再需要时释放空间。
- en: 2.4.1 Heap Memory
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.1 堆内存
- en: Every byte of memory in a program’s memory space has an associated address.
    Everything the program needs to run is in its memory space, and different types
    of entities reside in different parts of a program’s memory space. For example,
    the *code* region contains the program’s instructions, global variables reside
    in the *data* region, local variables and parameters occupy the *stack*, and dynamically
    allocated memory comes from the *heap*. Because the stack and the heap grow at
    runtime (as functions are called and return and as dynamic memory is allocated
    and freed), they are typically far apart in a program’s address space to leave
    a large amount of space for each to grow into as the program runs.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 程序内存空间中的每个字节都有一个相关的地址。程序运行所需的所有内容都在其内存空间中，不同类型的实体驻留在程序内存空间的不同部分。例如，*代码*区域包含程序的指令，全局变量驻留在*数据*区域，局部变量和参数占据*栈*，而动态分配的内存来自*堆*。由于栈和堆在运行时增长（随着函数的调用和返回以及动态内存的分配和释放），它们通常在程序的地址空间中相距较远，以便为它们各自的增长预留大量空间。
- en: Dynamically allocated memory occupies the heap memory region of a program’s
    address space (see [page 66](ch02.xhtml#lev1_10)). When a program dynamically
    requests memory at runtime, the heap provides a chunk of memory whose address
    must be assigned to a pointer variable.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分配的内存占据程序地址空间中的堆内存区域（参见[第66页](ch02.xhtml#lev1_10)）。当程序在运行时动态请求内存时，堆会提供一块内存，其地址必须分配给一个指针变量。
- en: '[Figure 2-7](ch02.xhtml#ch2fig7) illustrates the parts of a running program’s
    memory with an example of a pointer variable (`ptr`) on the stack that stores
    the address of dynamically allocated heap memory (it points to heap memory).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-7](ch02.xhtml#ch2fig7) 通过一个示例展示了正在运行的程序内存的各个部分，其中堆栈上的指针变量（`ptr`）存储着动态分配的堆内存的地址（它指向堆内存）。'
- en: '![image](../images/02fig07.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig07.jpg)'
- en: '*Figure 2-7: A pointer on the stack points to a block of memory that was allocated
    from the heap.*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-7：堆栈上的指针指向从堆中分配的内存块。*'
- en: It’s important to remember that heap memory is anonymous memory, where “anonymous”
    means that addresses in the heap are not bound to variable names. Declaring a
    named program variable allocates it on the stack or in the data part of program
    memory. A local or global pointer variable can store the address of an anonymous
    heap memory location (e.g., a local pointer variable on the stack can point to
    heap memory), and dereferencing such a pointer enables a program to store data
    in the heap.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，堆内存是匿名内存，其中“匿名”意味着堆中的地址没有绑定到变量名。声明一个具名程序变量会将其分配到堆栈或程序内存的数据部分。一个局部或全局指针变量可以存储指向匿名堆内存位置的地址（例如，堆栈上的局部指针变量可以指向堆内存），并且解引用这样的指针使得程序能够在堆中存储数据。
- en: 2.4.2 malloc and free
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.2 malloc 和 free
- en: '*malloc* and *free* are functions in the standard C library (`stdlib`) that
    a program can call to allocate and deallocate memory in the *heap*. Heap memory
    must be explicitly allocated (malloc’ed) and deallocated (freed) by a C program.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*malloc* 和 *free* 是标准 C 库（`stdlib`）中的函数，程序可以调用它们在 *堆* 上分配和释放内存。堆内存必须由 C 程序显式分配（malloc）和释放（free）。'
- en: 'To allocate heap memory, call `malloc`, passing in the total number of bytes
    of contiguous heap memory to allocate. Use the `sizeof` *operator* to compute
    the number of bytes to request. For example, to allocate space on the heap to
    store a single integer, a program could call:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要分配堆内存，调用 `malloc`，并传入要分配的连续堆内存的总字节数。使用 `sizeof` *运算符* 来计算请求的字节数。例如，要在堆上分配存储单个整数的空间，程序可以调用：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `malloc` function returns the base address of the allocated heap memory
    to the caller (or `NULL` if an error occurs). Here’s a full example program with
    a call to `malloc` to allocate heap space to store a single `int` value:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`malloc` 函数将分配的堆内存的基地址返回给调用者（如果发生错误，则返回 `NULL`）。以下是一个完整的示例程序，使用 `malloc` 来分配堆空间存储一个
    `int` 值：'
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `malloc` function returns a `void *` type, which represents a generic pointer
    to a non-specified type (or to any type). When a program calls `malloc` and assigns
    the result to a pointer variable, the program associates the allocated memory
    with the type of the pointer variable.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`malloc` 函数返回一个 `void *` 类型，它表示一个指向未指定类型（或任何类型）的通用指针。当程序调用 `malloc` 并将结果赋值给指针变量时，程序将分配的内存与指针变量的类型关联起来。'
- en: 'Sometimes you may see calls to `malloc` that explicitly recast its return type
    from `void *` to match the type of the pointer variable. For example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能会看到 `malloc` 调用，显式地将其返回类型从 `void *` 转换为匹配指针变量的类型。例如：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `(int *)` before `malloc` tells the compiler that the `void *` type returned
    by `malloc` will be used as an `int *` in this call (it recasts the return type
    of `malloc` to an `int *`). We discuss type recasting and the `void *` type in
    more detail later in this chapter, on [page 126](ch02.xhtml#lev2_38).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `malloc` 前面的 `(int *)` 告诉编译器，`malloc` 返回的 `void *` 类型将在此调用中作为 `int *` 使用（它将
    `malloc` 的返回类型重新转换为 `int *`）。我们将在本章稍后更详细地讨论类型重 cast 和 `void *` 类型，参见 [第126页](ch02.xhtml#lev2_38)。
- en: 'A call to `malloc` fails if there is not enough free heap memory to satisfy
    the requested number of bytes to allocate. Usually, `malloc` failing indicates
    an error in the program such as passing `malloc` a very large request, passing
    a negative number of bytes, or calling `malloc` in an infinite loop and running
    out of heap memory. Because any call to `malloc` can fail, you should *always
    test its return value for* NULL (indicating `malloc` failed) before dereferencing
    the pointer value. Dereferencing a null pointer will cause your program to crash!
    For example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有足够的空闲堆内存来满足请求分配的字节数，则 `malloc` 调用会失败。通常，`malloc` 失败表示程序中出现错误，例如传递给 `malloc`
    一个非常大的请求，传递一个负数字节数，或者在无限循环中调用 `malloc` 并耗尽了堆内存。由于任何 `malloc` 调用都有可能失败，因此在解引用指针值之前，*始终检查其返回值是否为*
    NULL（表示 `malloc` 失败）。解引用空指针会导致程序崩溃！例如：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When a program no longer needs the heap memory it dynamically allocated with
    `malloc`, it should explicitly deallocate the memory by calling the `free` function.
    It’s also a good idea to set the pointer’s value to `NULL` after calling `free`,
    so that if an error in the program causes it to be accidentally dereferenced after
    the call to `free`, the program will crash rather than modify parts of heap memory
    that have been reallocated by subsequent calls to `malloc`. Such unintended memory
    references can result in undefined program behavior that is often very difficult
    to debug, whereas a null pointer dereference will fail immediately, making it
    a relatively easy bug to find and to fix.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序不再需要通过`malloc`动态分配的堆内存时，应该通过调用`free`函数显式地释放该内存。调用`free`后，将指针的值设置为`NULL`也是一个好主意，这样如果程序中的错误导致它在`free`调用后被意外解引用，程序将崩溃，而不是修改已被后续`malloc`调用重新分配的堆内存。这种无意的内存引用可能会导致未定义的程序行为，通常非常难以调试，而空指针解引用会立即失败，从而使其成为一个相对容易发现和修复的bug。
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 2.4.3 Dynamically Allocated Arrays and Strings
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.3 动态分配的数组和字符串
- en: C programmers often dynamically allocate memory to store arrays. A successful
    call to `malloc` allocates one contiguous chunk of heap memory of the requested
    size. It returns the address of the start of this chunk of memory to the caller,
    making the returned address value suitable for the base address of a dynamically
    allocated array in heap memory.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: C程序员经常动态分配内存以存储数组。成功调用`malloc`会分配一个请求大小的连续堆内存块，并将该内存块的起始地址返回给调用者，从而使返回的地址值适合用于堆内存中动态分配数组的基地址。
- en: 'To dynamically allocate space for an array of elements, pass `malloc` the total
    number of bytes in the desired array. That is, the program should request from
    `malloc` the total number of bytes in each array element times the number of elements
    in the array. Pass `malloc` an expression for the total number of bytes in the
    form of `sizeof(` <type>`) *` <number of elements>. For example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要为元素数组动态分配空间，传递给`malloc`的是所需数组的总字节数。也就是说，程序应向`malloc`请求每个数组元素的字节数乘以数组元素的数量。传递给`malloc`的参数应该是总字节数的表达式，形式为`sizeof(<type>)
    * <number of elements>`。例如：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: After the calls to `malloc` in this example, the `int` pointer variable `arr`
    stores the base address of an array of 20 contiguous integer storage locations
    in heap memory, and the `c_arr` char pointer variable stores the base address
    of an array of 10 contiguous char storage locations in heap memory. [Figure 2-8](ch02.xhtml#ch2fig8)
    depicts what this might look like.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`malloc`调用后，`int`指针变量`arr`存储了堆内存中一个包含20个连续整数存储位置的数组的基地址，而`c_arr`字符指针变量存储了堆内存中一个包含10个连续字符存储位置的数组的基地址。[图
    2-8](ch02.xhtml#ch2fig8)展示了这可能是什么样子。
- en: '![image](../images/02fig08.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig08.jpg)'
- en: '*Figure 2-8: A 20-element integer array and 10-element character array allocated
    on the heap*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-8：在堆上分配的20元素整数数组和10元素字符数组*'
- en: Note that while `malloc` returns a pointer to dynamically allocated space in
    heap memory, C programs store the pointer to heap locations on the stack. The
    pointer variables contain *only the base address* (the starting address) of the
    array storage space in the heap. Just like statically declared arrays, the memory
    locations for dynamically allocated arrays are in contiguous memory locations.
    While a single call to `malloc` results in a chunk of memory of the requested
    number of bytes being allocated, multiple calls to `malloc` *will not* result
    in heap addresses that are contiguous (on most systems). In the previous example,
    the `char` array elements and the `int` array elements may be at addresses that
    are far apart in the heap.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管`malloc`返回的是指向堆内存中动态分配空间的指针，但C程序将指向堆位置的指针存储在栈上。指针变量只包含数组存储空间在堆中的*基地址*（起始地址）。就像静态声明的数组一样，动态分配的数组的内存位置也是连续的。虽然一次`malloc`调用会分配一个请求大小的内存块，但多次调用`malloc`*不会*导致堆地址连续（在大多数系统上）。在前面的示例中，`char`数组元素和`int`数组元素可能位于堆中相距很远的地址。
- en: 'After dynamically allocating heap space for an array, a program can access
    the array through the pointer variable. Because the pointer variable’s value represents
    the base address of the array in the heap, we can use the same syntax to access
    elements in dynamically allocated arrays as we use to access elements in statically
    declared arrays (see [page 44](ch01.xhtml#lev1_5)). Here’s an example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在动态分配堆内存空间后，程序可以通过指针变量访问数组。因为指针变量的值表示数组在堆中的基地址，我们可以使用与访问静态声明数组元素相同的语法来访问动态分配数组的元素（参见[第44页](ch01.xhtml#lev1_5)）。以下是一个示例：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It may not be obvious why the same syntax can be used for accessing elements
    in dynamically allocated arrays as is used in accessing elements in statically
    declared arrays. However, even though their types are different, the values of
    `s_array` and `d_array` both evaluate to the base address of the array in memory
    (see [Table 2-1](ch02.xhtml#ch2tab1)).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 可能不太容易理解为什么可以使用相同的语法来访问动态分配数组中的元素，就像访问静态声明数组中的元素一样。然而，尽管它们的类型不同，`s_array`和`d_array`的值都求值为数组在内存中的基地址（参见[表2-1](ch02.xhtml#ch2tab1)）。
- en: '**Table 2-1:** Comparison of Statically Allocated `s_array` and Dynamically
    Allocated `d_array`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-1：** 静态分配的`s_array`和动态分配的`d_array`比较'
- en: '| **Expression** | **Value** | **Type** |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** | **值** | **类型** |'
- en: '| `s_array` | base address of array in memory | (static) array of integers
    |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `s_array` | 数组在内存中的基地址 | （静态）整型数组 |'
- en: '| `d_array` | base address of array in memory | integer pointer (`int *`) |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `d_array` | 数组在内存中的基地址 | 整型指针（`int *`） |'
- en: 'Because the names of both variables evaluate to the base address of the array
    in memory (the address of the first element memory), the semantics of the `[i]`
    syntax following the name of the variable remain the same for both: `[i]` *dereferences
    the* int *storage location at offset* i *from the base address of the array in
    memory*—it’s accessing the `i`th element.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 因为两个变量的名称都求值为数组在内存中的基地址（即第一个元素的地址），所以在变量名称后面的`[i]`语法对于两者的语义保持一致：`[i]` *解引用*
    int *存储位置，偏移量为* i *，从数组的基地址开始访问内存*——这就是在访问数组的第`i`个元素。
- en: 'For most purposes, we recommend using the `[i]` syntax to access the elements
    of a dynamically allocated array. However, programs can also use the pointer dereferencing
    syntax (the `*` operator) to access array elements. For example, placing a `*`
    in front of a pointer that refers to a dynamically allocated array will dereference
    the pointer to access element 0 of the array:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数情况，我们建议使用`[i]`语法来访问动态分配数组的元素。然而，程序也可以使用指针解引用语法（`*`操作符）来访问数组元素。例如，将`*`放在指向动态分配数组的指针前面，将解引用该指针来访问数组的第0个元素：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The “Arrays in C” section on [page 81](ch02.xhtml#lev1_13) describes arrays
    in more detail, and the “Pointer Arithmetic” section on [page 224](ch02.xhtml#lev2_39)
    discusses accessing array elements through pointer variables.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[第81页](ch02.xhtml#lev1_13)的“C语言中的数组”一节更详细地描述了数组， [第224页](ch02.xhtml#lev2_39)的“指针运算”一节讨论了如何通过指针变量访问数组元素。'
- en: 'When a program is finished using a dynamically allocated array, it should call
    `free` to deallocate the heap space. As mentioned earlier, we recommend setting
    the pointer to `NULL` after freeing it:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序完成使用动态分配的数组时，应调用`free`来释放堆内存。如前所述，我们建议在释放后将指针设置为`NULL`：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: HEAP MEMORY MANAGEMENT, MALLOC AND FREE
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 堆内存管理、MALLOC 和 FREE
- en: The C standard library implements `malloc` and `free`, which are the programming
    interface to its heap memory manager. When called, `malloc` needs to find a contiguous
    chunk of unallocated heap memory space that can satisfy the size of the request.
    The heap memory manager maintains a *free list* of unallocated *extents* of heap
    memory, where each extent specifies the start address and size of a contiguous
    unallocated chunk of heap space.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: C标准库实现了`malloc`和`free`，它们是堆内存管理器的编程接口。当调用`malloc`时，它需要找到一个连续的、未分配的堆内存块，大小满足请求。堆内存管理器维护一个*空闲列表*，该列表记录了未分配的堆内存块，每个块指定了一个未分配的连续堆内存块的起始地址和大小。
- en: Initially, all of heap memory is empty, meaning that the free list has a single
    extent consisting of the entire heap region. After a program has made some calls
    to `malloc` and `free`, heap memory can become *fragmented*, meaning that there
    are chunks of free heap space interspersed with chunks of allocated heap space.
    The heap memory manager typically keeps lists of different ranges of sizes of
    heap space to enable fast searching for a free extent of a particular size. In
    addition, it implements one or more policies for choosing among multiple free
    extents that could be used to satisfy a request.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，所有的堆内存都是空的，这意味着空闲列表中有一个包含整个堆区域的单一区段。在程序进行了一些`malloc`和`free`调用后，堆内存可能会变得*碎片化*，即堆内存中有一些空闲区域夹杂在已分配的堆空间中。堆内存管理器通常会保持不同大小区段的堆空间列表，以便快速查找特定大小的空闲区段。此外，它还实现了一个或多个策略，用于在多个可用的空闲区段中选择一个来满足请求。
- en: The `free` function may seem odd in that it only expects to receive the address
    of the heap space to free without needing the size of the heap space to free at
    that address. That’s because `malloc` not only allocates the requested memory
    bytes, but it also allocates a few additional bytes right before the allocated
    chunk to store a header structure. The header stores metadata about the allocated
    chunk of heap space, such as the size. As a result, a call to `free` only needs
    to pass the address of heap memory to free. The implementation of `free` can get
    the size of the memory to free from the header information that is in memory right
    before the address passed to `free`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`free`函数可能看起来有些奇怪，因为它只期望接收要释放的堆空间的地址，而不需要知道释放该地址的堆空间的大小。这是因为`malloc`不仅分配了请求的内存字节，还在分配的块前面额外分配了几个字节来存储头结构。头结构存储有关已分配堆空间块的元数据，例如大小。因此，`free`的调用只需要传递要释放的堆内存的地址。`free`的实现可以通过地址前的头信息获取要释放的内存大小。'
- en: For more information about heap memory management, see an OS textbook (for example,
    Chapter 17, “Free Space Management,” in *OS in Three Easy Pieces* covers these
    details).^([1](ch02.xhtml#fn2_1))
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于堆内存管理的信息，请参考操作系统教材（例如，《*OS in Three Easy Pieces*》第17章“空闲空间管理”详细介绍了这些内容）。^([1](ch02.xhtml#fn2_1))
- en: 2.4.4 Pointers to Heap Memory and Functions
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.4 指向堆内存的指针和函数
- en: 'When passing a dynamically allocated array to a function, the pointer variable
    argument’s *value* is passed to the function (i.e., the base address of the array
    in the heap is passed to the function). Thus, when passing either statically declared
    or dynamically allocated arrays to functions, the parameter gets exactly the same
    value—the base address of the array in memory. As a result, the same function
    can be used for statically and dynamically allocated arrays of the same type,
    and identical syntax can be used inside the function for accessing array elements.
    The parameter declarations `int *arr` and `int` `arr[]` are equivalent. However,
    by convention, the pointer syntax tends to be used for functions that may be called
    with dynamically allocated arrays:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当将动态分配的数组传递给一个函数时，指针变量参数的*值*被传递给函数（即数组在堆中的基地址被传递给函数）。因此，无论是将静态声明的数组还是动态分配的数组传递给函数，参数得到的值都是完全相同的——数组在内存中的基地址。因此，同一个函数可以用于静态和动态分配的相同类型数组，并且可以在函数内部使用相同的语法访问数组元素。参数声明`int
    *arr`和`int arr[]`是等价的。然而，按照约定，指针语法通常用于可能使用动态分配数组的函数：
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: At the point just before returning from the `init_array` function, the contents
    of memory will look like [Figure 2-9](ch02.xhtml#ch2fig9). Note that `main` only
    passes the base address of the array to `init_array`. The array’s large block
    of contiguous memory remains on the heap, but the function can access it by dereferencing
    the `arr` pointer parameter.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在`init_array`函数即将返回时，内存的内容将如下图所示 [图2-9](ch02.xhtml#ch2fig9)。请注意，`main`只将数组的基地址传递给`init_array`。数组的大块连续内存仍然位于堆上，但该函数可以通过解引用`arr`指针参数来访问它。
- en: '![image](../images/02fig09.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig09.jpg)'
- en: '*Figure 2-9: The contents of memory prior to returning from `init_array`. Both
    `main`’s `arr1` and `init_array`’s `arr` variable point to the same block of heap
    memory.*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-9：`init_array`函数返回前的内存内容。`main`的`arr1`和`init_array`的`arr`变量指向同一块堆内存。*'
- en: 2.5 Arrays in C
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5 C语言中的数组
- en: In “Introduction to Arrays” on [page 44](ch01.xhtml#lev2_9), we introduced statically
    declared one-dimensional C arrays and discussed the semantics of passing arrays
    to functions. In “Dynamic Memory Allocation” on [page 136](ch02.xhtml#lev1_12),
    we introduced dynamically allocated one-dimensional arrays and discussed the semantics
    of passing them to functions.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在《数组简介》一节中（[第44页](ch01.xhtml#lev2_9)），我们介绍了静态声明的一维C数组，并讨论了将数组传递给函数的语义。在《动态内存分配》一节（[第136页](ch02.xhtml#lev1_12)），我们介绍了动态分配的一维数组，并讨论了将其传递给函数的语义。
- en: In this section, we take a more in-depth look at arrays in C. We describe both
    statically and dynamically allocated arrays in more detail and discuss two-dimensional
    arrays.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更深入地探讨C语言中的数组。我们将更详细地描述静态和动态分配的数组，并讨论二维数组。
- en: 2.5.1 Single-Dimensional Arrays
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.5.1 一维数组
- en: Statically Allocated
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 静态分配
- en: Before jumping into new content, we briefly summarize static arrays with an
    example. See “Introduction to Arrays” on [page 44](ch01.xhtml#lev2_9) for more
    detail on statically declared one-dimensional arrays.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解新内容之前，我们简要总结一下静态数组，并给出一个示例。有关静态声明的一维数组的更多细节，请参见[第44页](ch01.xhtml#lev2_9)的《数组简介》。
- en: Statically declared arrays are allocated either on the stack (for local variables)
    or in the data region of memory (for global variables). A programmer can declare
    an array variable by specifying its type (the type stored at each index) and its
    total capacity (number of elements).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 静态声明的数组要么在栈上分配（用于局部变量），要么在内存的数据区分配（用于全局变量）。程序员可以通过指定数组的类型（每个索引处存储的类型）和总容量（元素数量）来声明一个数组变量。
- en: When passing an array to a function, C copies the value of the base address
    to the parameter. That is, both the parameter and the argument refer to the same
    memory locations—the parameter pointer points to the argument’s array elements
    in memory. As a result, modifying the values stored in the array through an array
    parameter modifies the values stored in the argument array.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当将数组传递给函数时，C语言会将基地址的值复制到参数中。也就是说，参数和实参引用的是相同的内存位置——参数指针指向实参数组元素在内存中的位置。因此，通过数组参数修改数组中的值会修改实参数组中存储的值。
- en: 'Here are some examples of static array declaration and use:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些静态数组声明和使用的示例：
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Dynamically Allocated
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 动态分配
- en: In “Dynamic Memory Allocation” on [page 74](ch02.xhtml#lev1_12), we introduced
    dynamically allocated one-dimensional arrays, including their access syntax and
    the syntax and semantics of passing dynamically allocated arrays to functions.
    Here, we present a short recap of that information with an example.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在《动态内存分配》一节（[第74页](ch02.xhtml#lev1_12)），我们介绍了动态分配的一维数组，包括其访问语法，以及将动态分配的数组传递给函数的语法和语义。在这里，我们将用一个示例简要回顾这些信息。
- en: 'Calling the `malloc` function dynamically allocates an array on the heap at
    runtime. The address of the allocated heap space can be assigned to a global or
    local pointer variable, which then points to the first element of the array. To
    dynamically allocate space, pass `malloc` the total number of bytes to allocate
    for the array (using the `sizeof` operator to get the size of a specific type).
    A single call to `malloc` allocates a contiguous chunk of heap space of the requested
    size. For example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`malloc`函数会在运行时动态地在堆上分配一个数组。分配的堆空间的地址可以赋给全局或局部指针变量，该指针变量指向数组的第一个元素。要动态分配空间，需要将要分配的总字节数传递给`malloc`（使用`sizeof`运算符来获取特定类型的大小）。一次`malloc`调用会在堆上分配一个请求大小的连续内存块。例如：
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Array Memory Layout
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 数组内存布局
- en: 'Whether an array is statically declared or dynamically allocated via a single
    call to `malloc`, array elements represent contiguous memory locations (addresses):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是静态声明的数组，还是通过单次调用`malloc`动态分配的数组，数组元素都代表着连续的内存位置（地址）：
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The location of element `i` is at an offset `i` from the base address of the
    array. The exact address of the `i`th element depends on the number of bytes of
    the type stored in the array. For example, consider the following array declarations:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 元素`i`的位置位于数组基地址的偏移量`i`处。第`i`个元素的确切地址取决于数组中存储的类型所占的字节数。例如，考虑以下数组声明：
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The addresses of their individual array elements might look something like
    this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 它们各个数组元素的地址可能如下所示：
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this example, `1230` is the base address of `iarray` and `1280` the base
    address of `carray`. Note that individual elements of each array are allocated
    to contiguous memory addresses: each element of `iarray` stores a four-byte `int`
    value, so its element addresses differ by four, and each element of `carray` stores
    a one-byte `char` value, so its addresses differ by one. There is no guarantee
    that the set of local variables are allocated to contiguous memory locations on
    the stack (hence, there could be a gap in the addresses between the end of `iarray`
    and the start of `carray`, as shown in this example).'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`1230` 是 `iarray` 的基地址，`1280` 是 `carray` 的基地址。请注意，每个数组的单个元素分配到连续的内存地址：`iarray`
    的每个元素存储一个四字节的 `int` 值，因此其元素地址相差四，而 `carray` 的每个元素存储一个一字节的 `char` 值，因此其地址相差一。需要注意的是，局部变量的集合并不保证在栈上分配到连续的内存位置（因此，在
    `iarray` 末尾和 `carray` 开始之间可能会有一个地址间隔，如本例所示）。
- en: 2.5.2 Two-Dimensional Arrays
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.5.2 二维数组
- en: C supports multidimensional arrays, but we limit our discussion of multidimensional
    arrays to two-dimensional (2D) arrays, since 1D and 2D arrays are the most commonly
    used by C programmers.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: C 支持多维数组，但我们将多维数组的讨论限制为二维数组（2D），因为 1D 和 2D 数组是 C 程序员最常用的。
- en: Statically Allocated 2D Arrays
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 静态分配的二维数组
- en: 'To statically declare a multidimensional array variable, specify the size of
    each dimension. For example:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要静态声明一个多维数组变量，必须指定每个维度的大小。例如：
- en: '[PRE31]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, `matrix` is a 2D array of `int` values with 50 rows and 100 columns, and
    `little` is a 2D array of `short` values with 10 rows and 10 columns.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`matrix` 是一个具有 50 行 100 列的 `int` 类型二维数组，`little` 是一个具有 10 行 10 列的 `short`
    类型二维数组。
- en: 'To access an individual element, indicate both the row and the column index:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问单个元素，必须同时指定行和列索引：
- en: '[PRE32]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[Figure 2-10](ch02.xhtml#ch2fig10) illustrates the 2D array as a matrix of
    integer values, where a specific element in the 2D array is indexed by row and
    column index values.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-10](ch02.xhtml#ch2fig10) 演示了将二维数组表示为整数值矩阵的情况，其中二维数组中的特定元素是通过行索引和列索引值来索引的。'
- en: '![image](../images/02fig10.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig10.jpg)'
- en: '*Figure 2-10: A two-dimensional array represented as a matrix. Accessing matrix[2][3]
    is like indexing into a grid at row 2 and column 3.*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-10：一个二维数组表示为矩阵。访问 `matrix[2][3]` 就像在第 2 行第 3 列索引网格一样。*'
- en: 'Programs often access the elements of a 2D array by iterating with nested loops.
    For example, the following nested loop initializes all elements in `matrix` to
    0:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 程序通常通过嵌套循环迭代来访问二维数组的元素。例如，下面的嵌套循环将 `matrix` 中的所有元素初始化为 0：
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Two-Dimensional Array Parameters
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 二维数组参数
- en: 'The same rules for passing one-dimensional array arguments to functions apply
    to passing two-dimensional array arguments: the parameter gets the value of the
    base address of the 2D array (`&arr[0][0]`). In other words, the parameter points
    to the argument’s array elements and therefore the function can change values
    stored in the passed array.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 将一维数组作为参数传递给函数的规则同样适用于将二维数组作为参数传递：参数获取二维数组的基地址的值（`&arr[0][0]`）。换句话说，参数指向传入数组的元素，因此该函数可以修改传入数组中存储的值。
- en: 'For multidimensional array parameters, you must indicate that the parameter
    is a multidimensional array, but you can leave the size of the first dimension
    unspecified (for good generic design). The sizes of other dimensions must be fully
    specified so that the compiler can generate the correct offsets into the array.
    Here’s a 2D example:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多维数组参数，必须指明该参数是多维数组，但可以不指定第一个维度的大小（以便于良好的通用设计）。其他维度的大小必须完全指定，以便编译器能够生成正确的偏移量。下面是一个二维的例子：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Both the `matrix` and the `bigger` arrays can be passed as arguments to the
    `init_matrix` function because they have the same column dimension as the parameter
    definition.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`matrix` 和 `bigger` 数组可以作为参数传递给 `init_matrix` 函数，因为它们的列维度与参数定义相同。'
- en: '**Note**'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The column dimension must be specified in the parameter definition of a 2D array
    so that the compiler can calculate the offset from the base address of the 2D
    array to the start of a particular row of elements. The offset calculation follows
    from the layout of 2D arrays in memory.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 必须在二维数组的参数定义中指定列维度，以便编译器能够计算从二维数组基地址到特定行元素起始位置的偏移量。偏移量的计算遵循二维数组在内存中的布局。
- en: Two-Dimensional Array Memory Layout
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 二维数组内存布局
- en: Statically allocated 2D arrays are arranged in memory in *row-major order*,
    meaning that all of row 0’s elements come first, followed by all of row 1’s elements,
    and so on. For example, given the following declaration of a 2D array of integers
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分配的二维数组在内存中的排列是 *行主序*，意味着首先存储第 0 行的所有元素，然后是第 1 行的所有元素，依此类推。例如，给定以下声明的整数类型二维数组：
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: its layout in memory might look like [Figure 2-11](ch02.xhtml#ch2fig11).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 它在内存中的布局可能如下所示：[图 2-11](ch02.xhtml#ch2fig11)。
- en: '![image](../images/02fig11.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig11.jpg)'
- en: '*Figure 2-11: The layout of a two-dimensional array in row-major order*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-11：二维数组的行主序内存布局*'
- en: Note that all array elements are allocated to contiguous memory addresses. That
    is, the base address of the 2D array is the memory address of the `[0][0]` element
    (`&arr[0][0]`), and subsequent elements are stored contiguously in row-major order
    (e.g., the entirety of row 1 is followed immediately by the entirety of row 2,
    and so on).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有数组元素都会被分配到连续的内存地址中。也就是说，二维数组的基地址是 `[0][0]` 元素的内存地址（`&arr[0][0]`），其后的元素按照行主序连续存储（例如，第
    1 行的所有元素紧跟着第 2 行的所有元素，依此类推）。
- en: Dynamically Allocated 2D Arrays
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 动态分配的二维数组
- en: 'Dynamically allocated 2D arrays can be allocated in two ways. For an *N* ×
    *M* 2D array, either:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分配的二维数组可以通过两种方式进行分配。对于一个 *N* × *M* 的二维数组，可以选择以下两种方式：
- en: 1\. Make a single call to `malloc`, allocating one large chunk of heap space
    to store all *N* × *M* array elements.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 通过一次调用 `malloc`，分配一个大块的堆空间来存储所有 *N* × *M* 数组元素。
- en: 2\. Make multiple calls to `malloc`, allocating an array of arrays. First, allocate
    a 1D array of *N* pointers to the element type, with a 1D array of pointers for
    each row in the 2D array. Then, allocate *N* 1D arrays of size *M* to store the
    set of column values for each row in the 2D array. Assign the addresses of each
    of these *N* arrays to the elements of the first array of *N* pointers.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 多次调用 `malloc`，分配一个数组的数组。首先，分配一个包含 *N* 个指向元素类型的指针的 1D 数组，每一行在二维数组中对应一个指针数组。然后，为每一行分配
    *N* 个大小为 *M* 的 1D 数组，以存储每一行的列值。将这 *N* 个数组的地址赋值给第一个指针数组的 *N* 个元素。
- en: The variable declarations, allocation code, and array element access syntax
    differ depending on which of these two methods a programmer chooses to use.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 变量声明、内存分配代码和数组元素访问语法根据程序员选择的两种方法有所不同。
- en: 'Method 1: Memory-Efficient Allocation'
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 方法 1：内存高效分配
- en: In this method, a single call to `malloc` allocates the total number of bytes
    needed to store the *N* × *M* array of values. This method has the benefit of
    being more memory efficient because the entire space for all *N* × *M* elements
    will be allocated at once, in contiguous memory locations.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，通过一次调用 `malloc` 分配所需的字节数来存储 *N* × *M* 的数组值。此方法的优点是更节省内存，因为所有 *N* × *M*
    元素的整个空间会一次性分配，并存储在连续的内存地址中。
- en: 'The call to `malloc` returns the starting address of the allocated space (the
    base address of the array), which (like a 1D array) should be stored in a pointer
    variable. In fact, there is no semantic difference between allocating a 1D or
    2D array using this method: the call to `malloc` returns the starting address
    of a contiguously allocated chunk of heap memory of the requested number of bytes.
    Because allocation of a 2D array using this method looks just like allocation
    for a 1D array, the programmer has to explicitly map 2D row and column indexing
    on top of this single chunk of heap memory space (the compiler has no implicit
    notion of rows or columns and thus cannot interpret double indexing syntax into
    this malloc’ed space).'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `malloc` 会返回分配空间的起始地址（即数组的基地址），该地址应该像 1D 数组一样存储在指针变量中。实际上，使用这种方法分配 1D 或 2D
    数组在语义上没有区别：`malloc` 返回的是一块连续分配的堆内存空间的起始地址，大小为请求的字节数。由于通过这种方法分配二维数组看起来就像是分配 1D
    数组，程序员必须显式地将二维的行列索引映射到这块连续的堆内存空间上（编译器没有行或列的隐式概念，因此无法将双重索引语法解释为分配给这块内存的 `malloc`
    空间）。
- en: 'Here’s an example C code snippet that dynamically allocates a 2D array using
    method 1:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用方法 1 动态分配二维数组的 C 语言代码示例：
- en: '[PRE36]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[Figure 2-12](ch02.xhtml#ch2fig12) shows an example of allocating a 2D array
    using this method and illustrates what memory might look like after the call to
    `malloc`.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-12](ch02.xhtml#ch2fig12) 展示了使用此方法分配二维数组的示例，并说明了 `malloc` 调用后的内存布局。'
- en: '![image](../images/02fig12.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig12.jpg)'
- en: '*Figure 2-12: The results of allocating a 2D array with a single call to `malloc`*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-12：通过一次调用 `malloc` 分配二维数组的结果*'
- en: Like 1D dynamically allocated arrays, the pointer variable for a 2D array is
    allocated on the stack. That pointer is then assigned the value returned by the
    call to `malloc`, which represents the base address of the contiguous chunk of
    *N* × *M* `int` storage locations in the heap memory.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 与一维动态分配数组类似，二维数组的指针变量也是在栈上分配的。然后将返回的`malloc`值赋给该指针，该值表示堆内存中连续的*N* × *M* `int`存储位置的基地址。
- en: Because this method uses a single chunk of malloc’ed space for the 2D array,
    the memory allocation is as efficient as possible (it only requires one call to
    `malloc` for the entire 2D array). It’s the more efficient way to access memory
    due to all elements being located close together in contiguous memory, with each
    access requiring only a single level of indirection from the pointer variable.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此方法使用一个单一的`malloc`分配空间来存储二维数组，因此内存分配效率是最高的（整个二维数组只需要一次`malloc`调用）。由于所有元素都在连续的内存空间中，访问内存的效率更高，每次访问只需要通过指针变量进行一级间接访问。
- en: However, the C compiler does not know the difference between a 2D or 1D array
    allocation using this method. As a result, the double indexing syntax (`[i][j]`)
    of statically declared 2D arrays *cannot* be used when allocating a 2D array using
    this method. Instead, the programmer must explicitly compute the offset into the
    contiguous chunk of heap memory using a function of row and column index values
    (`[i*M + j]`, where `M` is the column dimension).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，C编译器并不区分使用此方法分配的二维数组和一维数组。因此，在使用此方法分配二维数组时，静态声明的二维数组的双重索引语法（`[i][j]`）*无法*使用。相反，程序员必须显式地使用行和列索引值来计算堆内存连续块中的偏移量（`[i*M
    + j]`，其中`M`是列数）。
- en: 'Here’s an example of how a programmer would structure code to initialize all
    the elements of a 2D array:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是程序员初始化二维数组中所有元素的代码结构示例：
- en: '[PRE37]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Method 1 (Single malloc) and Function Parameters
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 方法1（单次malloc）与函数参数
- en: 'The base address of an array of `int` types allocated via a single `malloc`
    is a pointer to an `int`, so it can be passed to a function with an (`int *`)
    parameter. Additionally, the function must be passed row and column dimensions
    so that it can correctly compute offsets into the 2D array. For example:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 通过单次`malloc`分配的`int`类型数组的基地址是指向`int`的指针，因此可以将其传递给一个`int *`类型的函数参数。此外，函数还必须传递行和列的维度，以便它能够正确计算二维数组中的偏移量。例如：
- en: '[PRE38]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Method 2: The Programmer-Friendly Way'
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 方法2：更适合程序员的方式
- en: 'The second method for dynamically allocating a 2D array stores the array as
    an array of *N* 1D arrays (one 1D array per row). It requires *N* + 1 calls to
    `malloc`: one `malloc` for the array of row arrays, and one `malloc` for each
    of the *N* row’s column arrays. As a result, the element locations *within a row*
    are contiguous, but elements are not contiguous across rows of the 2D array. Allocation
    and element access are not as efficient as in method 1, and the type definitions
    for variables can be a bit more confusing. However, using this method, a programmer
    can use double indexing syntax to access individual elements of the 2D array (the
    first index is an index into the array of rows, the second index is an index into
    the array of column elements within that row).'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种动态分配二维数组的方法是将数组存储为*N*个一维数组的数组（每行一个一维数组）。它需要*N* + 1次调用`malloc`：一次`malloc`用于行数组的数组，另外*N*次`malloc`用于每一行的列数组。因此，*在一行内*的元素位置是连续的，但二维数组的各行之间的元素不连续。分配和访问元素的效率不如方法1，且变量的类型定义可能稍微复杂。不过，使用这种方法，程序员可以使用双重索引语法来访问二维数组的各个元素（第一个索引是行数组的索引，第二个索引是该行内列元素的索引）。
- en: 'Here is an example of allocating a 2D array using method 2 (with the error
    detection and handling code removed for readability):'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用方法2分配二维数组的示例（为了可读性，省略了错误检测和处理代码）：
- en: '[PRE39]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this example, note the types of the variables and the sizes passed to the
    calls to `malloc`. To refer to the dynamically allocated 2D array, the programmer
    declares a variable (`two_d_array`) of type `int **` that will store the address
    of a dynamically allocated array of `int *` element values. Each element in `two_d_array`
    stores the address of a dynamically allocated array of `int` values (the type
    of `two_d_array[i]` is `int *`).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，注意变量的类型以及传递给`malloc`调用的大小。为了引用动态分配的二维数组，程序员声明一个`int **`类型的变量（`two_d_array`），它将存储动态分配的`int
    *`元素值数组的地址。`two_d_array`中的每个元素存储一个动态分配的`int`类型数组的地址（`two_d_array[i]`的类型是`int *`）。
- en: '[Figure 2-13](ch02.xhtml#ch2fig13) shows what memory might look like after
    the preceding example’s *N* + 1 calls to `malloc`.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/02fig13.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-13: The arrangement of memory after allocating a 2D array with N
    + 1 `malloc` calls*'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Note that when using this method, only the elements allocated as part of a single
    call to `malloc` are contiguous in memory. That is, elements within each row are
    contiguous, but elements from different rows (even neighboring rows) are not.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Once allocated, individual elements of the 2D array can be accessed using double-indexing
    notation. The first index specifies an element in the outer array of `int *` pointers
    (which row), and the second index specifies an element in the inner `int` array
    (which column within the row).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To understand how double indexing is evaluated, consider the type and value
    of the following parts of the expression:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Method 2 (An Array of Arrays) and Function Parameters
  id: totrans-247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The array argument’s type is `int **` (a pointer to a pointer to an `int`),
    and the function parameter matches its argument’s type. Additionally, row and
    column sizes should be passed to the function. Because this is a different type
    from method 1, both array types cannot use a common function (they are not the
    same C type).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example function that takes a method 2 (array of arrays) 2D array
    as a parameter:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here, the function implementation can use double-indexing syntax. Unlike statically
    declared 2D arrays, both the row and column dimensions need to be passed as parameters:
    the `rows` parameter specifies the bounds on the outermost array (the array of
    row arrays), and the `cols` parameter specifies the bounds on the inner arrays
    (the array column values for each row).'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 2.6 Strings and the String Library
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous chapter, we introduced “Arrays and Strings” ([page 44](ch01.xhtml#lev1_5)).
    In this chapter, we discuss dynamically allocated C strings and their use with
    the C string library. We first give a brief overview of statically declared strings.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 2.6.1 C’s Support for Statically Allocated Strings (Arrays of char)
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: C does not support a separate string type, but a string can be implemented in
    C programs using an array of `char` values that is terminated by a special null
    character value `’\0’`. The terminating null character identifies the end of the
    sequence of character values that make up a string. Not every character array
    is a C string, but every C string is an array of `char` values.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Because strings frequently appear in programs, C provides libraries with functions
    for manipulating strings. Programs that use the C string library need to include
    `string.h`. Most string library functions require the programmer to allocate space
    for the array of characters that the functions manipulate. When printing out the
    value of a string, use the `%s` placeholder.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example program that uses strings and some string library functions:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 2.6.2 Dynamically Allocating Strings
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Arrays of characters can be dynamically allocated (as discussed in “C’s Pointer
    Variables” on [page 66](ch02.xhtml#lev1_10) and “Arrays in C” on [page 81](ch02.xhtml#lev1_13)).
    When dynamically allocating space to store a string, it’s important to remember
    to allocate space in the array for the terminating `'\0'` character at the end
    of the string.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example program demonstrates static and dynamically allocated
    strings (note the value passed to `malloc`):'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '**Warning C STRING FUNCTIONS AND DESTINATION MEMORY**'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Many C string functions (notably `strcpy` and `strcat`) store their results
    by following a *destination* string pointer (`char *`) parameter and writing to
    the location it points to. Such functions assume that the destination contains
    enough memory to store the result. Thus, as a programmer, you must ensure that
    sufficient memory is available at the destination prior to calling these functions.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'Failure to allocate enough memory will yield undefined results that range from
    program crashes to major security vulnerabilities (see “Real World: Buffer Overflow”
    on [page 362](ch07.xhtml#lev1_60)). For example, the following calls to `strcpy`
    and `strcat` demonstrate mistakes that novice C programmers often make:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: // Attempt to write a 12-byte string into a 5-character array.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: char mystr[5];
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: strcpy(mystr, "hello world");
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: // Attempt to write to a string with a NULL destination.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: char *mystr = NULL;
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: strcpy(mystr, "try again");
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: // Attempt to modify a read-only string literal.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: char *mystr = "string literal value";
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: strcat(mystr, "string literals aren't writable");
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 2.6.3 Libraries for Manipulating C Strings and Characters
  id: totrans-275
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: C provides several libraries with functions for manipulating strings and characters.
    The string library (`string.h`) is particularly useful when writing programs that
    use C strings. The `stdlib.h` and `stdio.h` libraries also contain functions for
    string manipulation, and the `ctype.h` library contains functions for manipulating
    individual character values.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: When using C string library functions, it’s important to remember that most
    do not allocate space for the strings they manipulate, nor do they check that
    you pass in valid strings; your program must allocate space for the strings that
    the C string library will use. Furthermore, if the library function modifies the
    passed string, then the caller needs to ensure that the string is correctly formatted
    (i.e., that it has a terminating `’\0’` character at the end). Calling string
    library functions with bad array argument values will often cause a program to
    crash. The documentation (e.g., manual pages) for different library functions
    specifies whether the library function allocates space or if the caller is responsible
    for passing in allocated space to the library function.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '**Note CHAR[] AND CHAR * PARAMETERS AND CHAR * RETURN TYPE**'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Both statically declared and dynamically allocated arrays of characters can
    be passed to a `char *` parameter because the name of either type of variable
    evaluates to the base address of the array in memory. Declaring the parameter
    as type `char []` will also work for both statically and dynamically allocated
    argument values, but `char *` is more commonly used for specifying the type of
    string (array of `char`) parameters.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 静态声明的字符数组和动态分配的字符数组都可以传递给`char *`参数，因为这两种类型的变量的名称都会被求值为数组在内存中的基地址。将参数声明为类型`char
    []`也适用于静态和动态分配的参数值，但`char *`更常用于指定字符串（`char`数组）参数的类型。
- en: If a function returns a string (its return type is a `char *`), its return value
    can only be assigned to a variable whose type is also `char *`; it cannot be assigned
    to a statically allocated array variable. This restriction exists because the
    name of a statically declared array variable is not a valid *lvalue* (its base
    address in memory cannot be changed; see “Accessing Field Values” on [page 57](ch01.xhtml#lev2_15)),
    so it cannot be assigned a `char *` return value.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数返回一个字符串（其返回类型为`char *`），则它的返回值只能赋给类型为`char *`的变量；不能赋给静态分配的数组变量。这个限制存在是因为静态声明的数组变量的名称不是有效的*lvalue*（其在内存中的基地址不能更改；参见[第57页](ch01.xhtml#lev2_15)的“访问字段值”），因此不能将`char
    *`返回值赋给它。
- en: strlen, strcpy, strncpy
  id: totrans-281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: strlen, strcpy, strncpy
- en: 'The string library provides functions for copying strings and finding the length
    of a string:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串库提供了用于复制字符串和查找字符串长度的函数：
- en: '[PRE45]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `strcpy` function is unsafe to use in situations when the source string
    might be longer than the total capacity of the destination string. In this case,
    one should use `strncpy`. The size parameter stops `strncpy` from copying more
    than `size` characters from the `src` string into the `dst` string. When the length
    of the `src` string is greater than or equal to `size`, `strncpy` copies the first
    `size` characters from `src` to `dst` and does not add a null character to the
    end of the `dst`. As a result, the programmer should explicitly add a null character
    to the end of `dst` after calling `strncpy`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 当源字符串的长度可能大于目标字符串的总容量时，使用`strcpy`函数是非常不安全的。在这种情况下，应使用`strncpy`。`strncpy`的大小参数会限制从`src`字符串复制到`dst`字符串的字符数，不会超过`size`个字符。如果`src`字符串的长度大于或等于`size`，`strncpy`会将`src`的前`size`个字符复制到`dst`，并且不会在`dst`的末尾添加空字符。因此，程序员在调用`strncpy`后，应该显式地在`dst`的末尾添加空字符。
- en: 'Here are some example uses of these functions in a program:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这些函数在程序中的一些示例用法：
- en: '[PRE46]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: strcmp, strncmp
  id: totrans-287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: strcmp, strncmp
- en: The string library also provides a function to compare two strings. Comparing
    string variables using the `==` operator *does not* compare the characters in
    the strings—it compares only the base addresses of the two strings. For example,
    the expression
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串库还提供了一个函数用于比较两个字符串。使用`==`运算符比较字符串变量*并不*比较字符串中的字符——它仅比较两个字符串的基地址。例如，表达式
- en: '[PRE47]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: compares the base address of the `char` array in the heap pointed to by `d_str`
    to the base address of the `str char` array allocated on the stack.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 比较`d_str`指向的堆中`char`数组的基地址与栈上分配的`str char`数组的基地址。
- en: 'To compare the values of the strings, a programmer needs to either write code
    by hand to compare corresponding element values, or use the `strcmp` or `strncmp`
    functions from the string library:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较字符串的值，程序员需要手动编写代码来比较对应的元素值，或者使用字符串库中的`strcmp`或`strncmp`函数：
- en: '[PRE48]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `strcmp` function compares strings character by character based on their
    *ASCII representation* (see “Notes” on [page 189](ch01.xhtml#lev1_8)). In other
    words, it compares the `char` values in corresponding positions of the two parameter
    arrays to produce the result of the string comparison, which occasionally yields
    unintuitive results. For example, the ASCII encoding for the `char` value `’a’`
    is *larger* than the encoding for the `char` value `’Z’`. Thus, `strcmp("aaa",
    "Zoo")` returns a positive value indicating that `"aaa"` is greater than `"Zoo"`,
    and a call to `strcmp("aaa", "zoo")` returns a negative value indicating that
    `"aaa"` is less than `"zoo"`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`strcmp`函数通过比较字符的*ASCII表示*来逐字符比较字符串（参见[第189页](ch01.xhtml#lev1_8)的“注释”）。换句话说，它比较两个参数数组中对应位置的`char`值，得出字符串比较的结果，这有时会产生一些不直观的结果。例如，`char`值`''a''`的ASCII编码*大于*`char`值`''Z''`的编码。因此，`strcmp("aaa",
    "Zoo")`返回一个正值，表示`"aaa"`大于`"Zoo"`，而`strcmp("aaa", "zoo")`返回一个负值，表示`"aaa"`小于`"zoo"`。'
- en: 'Here are some string comparison examples:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: strcat, strstr, strchr
  id: totrans-296
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'String library functions can concatenate strings (note that it’s up to the
    caller to ensure that the destination string has enough space to store the result):'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'It also provides functions for finding substrings or character values in strings:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here are some examples using these functions (we omit some error handling for
    the sake of readability):'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Calls to `strchr` and `strstr` return the address of the first element in the
    parameter array with a matching character value or a matching substring value,
    respectively. This element address is the start of an array of `char` values terminated
    by a `’\0’` character. In other words, `ptr` points to the beginning of a substring
    inside another string. When printing the value of `ptr` as a string with `printf`,
    the character values starting at the index pointed to by `ptr` are printed, yielding
    the results listed in the preceding example.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: strtok, strtok_r
  id: totrans-304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The string library also provides functions that divide a string into tokens.
    A *token* refers to a subsequence of characters in a string separated by any number
    of delimiter characters of the programmer’s choosing.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `strtok` (or `strtok_r`) functions find individual tokens within a larger
    string. For example, setting `strtok`’s delimiters to the set of whitespace characters
    yields words in a string that originally contains an English sentence. That is,
    each word in the sentence is a token in the string.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Following is an example program that uses `strtok` to find individual words
    as the tokens in an input string.^([2](ch02.xhtml#fn2_2))
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: sprintf
  id: totrans-310
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The C `stdio` library also provides functions that manipulate C strings. Perhaps
    the most useful is the `sprintf` function, which “prints” into a string rather
    than printing output to a terminal:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`sprintf` initializes the contents of a string from values of various types.
    Its parameter `format` resembles those of `printf` and `scanf`. Here are some
    examples:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Functions for Individual Character Values
  id: totrans-315
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The standard C library (`stdlib.h`) contains a set of functions for manipulating
    and testing individual `char` values, including:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here are some examples of their use:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Functions to Convert Strings to Other Types
  id: totrans-320
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`stdlib.h` also contains functions to convert between strings and other C types.
    For example:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Here’s an example:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'For more information about these and other C library functions (including what
    they do, their parameter format, what they return, and which headers need to be
    included to use them), see their *man pages*.^([3](ch02.xhtml#fn2_3)) For example,
    to view the `strcpy` man page, run:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 2.7 C Structs
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous chapter, we introduced C structures in “Structs” on [page 52](ch01.xhtml#lev1_6).
    In this chapter, we dive deeper into C structs, examine statically and dynamically
    allocated structs, and combine structs and pointers to create more complex data
    types and data structures.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: We begin with a quick overview of statically declared structs. See the previous
    chapter for more details.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 2.7.1 Review of the C struct Type
  id: totrans-330
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A `struct` type represents a heterogeneous collection of data; it’s a mechanism
    for treating a set of different types as a single, coherent unit.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three steps to defining and using `struct` types in C programs:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Define a `struct` type that defines the field values and their types.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Declare variables of the `struct` type.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Use *dot notation* to access individual field values in the variable.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: In C, structs are lvalues (they can appear on the left-hand side of an assignment
    statement; see “Accessing Field Values” on [page 57](ch01.xhtml#lev2_15)). The
    value of a `struct` variable is the contents of its memory (all of the bytes making
    up its field values). When calling functions with `struct` parameters, the value
    of the `struct` argument (a copy of all of the bytes of all of its fields) gets
    copied to the `struct` function parameter.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: When programming with structs, and in particular when combining structs and
    arrays, it’s critical to carefully consider the type of every expression. Each
    field in a `struct` represents a specific type, and the syntax for accessing field
    values and the semantics of passing individual field values to functions follow
    those of their specific type.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'The following full example program demonstrates defining a `struct` type, declaring
    variables of that type, accessing field values, and passing structs and individual
    field values to functions (we omit some error handling and comments for readability):'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: struct_review.c
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'When run, the program produces:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: When working with structs, it’s particularly important to think about the types
    of the `struct` and its fields. For example, when passing a `struct` to a function,
    the parameter gets a copy of the `struct`’s value (a copy of all the bytes from
    the argument). Consequently, changes to the parameter’s field values *do not*
    change the argument’s value. This behavior is illustrated in the preceding program
    in the call to `checkID`, which modifies the parameter’s age field. The changes
    in `checkID` have no effect on the corresponding argument’s age field value.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: When passing a field of a `struct` to a function, the semantics match the type
    of the field (the type of the function’s parameter). For example, in the call
    to `changeName`, the value of the `name` field (the base address of the `name`
    array inside the `student2` struct) gets copied to the parameter `old`, meaning
    that the parameter refers to the same set of array elements in memory as its argument.
    Thus, changing an element of the array in the function also changes the element’s
    value in the argument; the semantics of passing the `name` field match the type
    of the `name` field.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 2.7.2 Pointers and Structs
  id: totrans-345
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Just like other C types, programmers can declare a variable as a pointer to
    a user-defined `struct` type. The semantics of using a `struct` pointer variable
    resemble those of other pointer types such as `int *`.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the `struct studentT` type introduced in the previous program example:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'A programmer can declare variables of type `struct studentT` or `struct` `studentT
    *` (a pointer to a `struct studentT`):'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note that the call to `malloc` initializes `sptr` to point to a dynamically
    allocated struct in heap memory. Using the `sizeof` operator to compute `malloc`’s
    size request (e.g., `sizeof(struct studentT)`) ensures that `malloc` allocates
    space for *all* of the field values in the struct.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: 'To access individual fields in a pointer to a `struct`, the pointer variable
    first needs to be *dereferenced*. Based on the rules for pointer dereferencing
    (see “C’s Pointer Variables” on [page 66](ch02.xhtml#lev1_10)), you may be tempted
    to access `struct` fields like so:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'However, because pointers to structs are so commonly used, C provides a special
    operator (`->`) that both dereferences a `struct` pointer and accesses one of
    its field values. For example, `sptr->year` is equivalent to `(*sptr).year`. Here
    are some examples of accessing field values using this notation:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[Figure 2-14](ch02.xhtml#ch2fig14) sketches what the variables `s` and `sptr`
    may look like in memory after the preceding code executes. Recall that `malloc`
    allocates memory from the heap, and local variables are allocated on the stack.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/02fig14.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-14: The differences in memory layout between a statically allocated
    struct (data on the stack) and a dynamically allocated struct (data on the heap)*'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 2.7.3 Pointer Fields in Structs
  id: totrans-359
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Structs can also be defined to have pointer types as field values. Here’s an
    example:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In memory, these variables will look like [Figure 2-15](ch02.xhtml#ch2fig15)
    (note which parts are allocated on the stack and which are on the heap).
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/02fig15.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-15: The layout in memory of a struct with a pointer field*'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: As structs and the types of their fields increase in complexity, be careful
    with their syntax. To access field values appropriately, start from the outermost
    variable type and use its type syntax to access individual parts. For example,
    the types of the `struct` variables shown in [Table 2-2](ch02.xhtml#ch2tab2) govern
    how a programmer should access their fields.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-2:** Struct Field Access Examples'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** | **Type** | **Field access syntax** |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
- en: '| `p1` | `struct personT` | `p1.age, p1.name` |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
- en: '| `p2` | `struct personT *` | `p2->age, p2->name` |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
- en: Further, knowing the types of field values allows a program to use the correct
    syntax in accessing them, as shown by the examples in [Table 2-3](ch02.xhtml#ch2tab3).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-3:** Accessing Different Struct Field Types'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** | **Type** | **Example access syntax** |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
- en: '| `p1.age` | `int` | `p1.age = 18;` |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
- en: '| `p2->age` | `int *` | `p2->age = 18;` |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
- en: '| `p1.name` | `char *` | `printf("%s", p1.name);` |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
- en: '| `p2->name` | `char *` | `printf("%s", p2->name);` |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
- en: '| `p2->name[2]` | `char` | `p2->name[2] = ’a’;` |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
- en: 'In examining the last example, start by considering the type of the outermost
    variable (`p2` is a pointer to a `struct personT`). Therefore, to access a field
    value in the struct, the programmer needs to use `->` syntax (`p2->name`). Next,
    consider the type of the `name` field, which is a `char *`, used in this program
    to point to an array of `char` values. To access a specific `char` storage location
    through the `name` field, use array indexing notation: `p2->name[2] =` `’a’`.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: 2.7.4 Arrays of Structs
  id: totrans-379
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Arrays, pointers, and structs can be combined to create more complex data structures.
    Here are some examples of declaring variables of different types of arrays of
    structs:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Again, thinking very carefully about variable and field types is necessary
    for understanding the syntax and semantics of using these variables in a program.
    Here are some examples of the correct syntax for accessing these variables:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'A function that takes an array of type `struct studentT *` as a parameter might
    look like this:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'A program could pass this function either a statically or dynamically allocated
    array of `struct studentT`:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The semantics of passing `classroom1` (or `classroom2`) to `updateAges` match
    the semantics of passing a statically declared (or dynamically allocated) array
    to a function: the parameter refers to the same set of elements as the argument
    and thus changes to the array’s values within the function affect the argument’s
    elements.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-16](ch02.xhtml#ch2fig16) shows what the stack might look like for
    the second call to the `updateAges` function (showing the passed `classroom2`
    array with example field values for the struct in each of its elements).'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/02fig16.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-16: The memory layout of an array of `struct studentT` passed to
    a function*'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: As always, the parameter gets a copy of the value of its argument (the memory
    address of the array in heap memory). Thus, modifying the array’s elements in
    the function will persist to its argument’s values (both the parameter and the
    argument refer to the same array in memory).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: 'The `updateAges` function cannot be passed the `classroom3` array because its
    type is not the same as the parameter’s type: `classroom3` is an array of `struct`
    `studentT *`, not an array of `struct studentT`.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: 2.7.5 Self-Referential Structs
  id: totrans-394
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A struct can be defined with fields whose type is a pointer to the same `struct`
    type. These self-referential `struct` types can be used to build linked implementations
    of data structures, such as linked lists, trees, and graphs.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: The details of these data types and their linked implementations are beyond
    the scope of this book. However, we briefly show one example of how to define
    and use a self-referential `struct` type to create a linked list in C. Refer to
    a textbook on data structures and algorithms for more information about linked
    lists.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: A *linked list* is one way to implement a *list abstract data type*. A list
    represents a sequence of elements that are ordered by their position in the list.
    In C, a list data structure could be implemented as an array or as a linked list
    using a self-referential `struct` type for storing individual nodes in the list.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the latter, a programmer would define a `node` struct to contain one
    list element and a link to the next node in the list. Here’s an example that could
    store a linked list of integer values:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Instances of this `struct` type can be linked together through the `next` field
    to create a linked list.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: 'This example code snippet creates a linked list containing three elements (the
    list itself is referred to by the `head` variable that points to the first node
    in the list):'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Note that the `temp` variable temporarily points to a malloc’ed `node` that
    gets initialized and then added to the beginning of the list by setting its `next`
    field to point to the node currently pointed to by `head`, and then by changing
    the `head` to point to this new node.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: The result of executing this code would look like [Figure 2-17](ch02.xhtml#ch2fig17)
    in memory.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/02fig17.jpg)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-17: The layout in memory of three example linked list nodes*'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: 2.8 I/O in C (Standard and File)
  id: totrans-407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C supports many functions for performing standard I/O as well as file I/O. In
    this section, we discuss some of the most commonly used interfaces for I/O in
    C.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: 2.8.1 Standard Input/Output
  id: totrans-409
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Every running program begins with three default I/O streams: standard out (`stdout`),
    standard in (`stdin`), and standard error (`stderr`). A program can write (print)
    output to `stdout` and `stderr`, and it can read input values from `stdin`. `stdin`
    is usually defined to read in input from the keyboard, whereas `stdout` and `stderr`
    output to the terminal.'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: The C `stdio.h` library provides the `printf` function used for printing to
    standard out and the `scanf` function that can be used to read in values from
    standard in. C also has functions to read and write one character at a time (`getchar`
    and `putchar`) as well as other functions and libraries for reading and writing
    characters to standard I/O streams. A C program must explicitly include `stdio.h`
    to call these functions.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'You can change the location that a running program’s `stdin`, `stdout` and/
    or `stderr` read from or write to. One way to do this is by redirecting one or
    all of these to read or write to a file. Here are some example shell commands
    for redirecting a program’s `stdin`, `stdout`, or `stderr` to a file (`$` is the
    shell prompt):'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: printf
  id: totrans-414
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'C’s `printf` function resembles formatted `print` calls in Python, where the
    caller specifies a format string to print. The format string often contains special
    format specifiers, including special characters that will print tabs (`\t`) or
    newlines (`\n`), or that specify placeholders for values in the output (`%` followed
    by a type specifier). When adding placeholders in a format string passed to `printf`,
    pass their corresponding values as additional arguments following the format string.
    Here are some example calls to `printf`:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: printf.c
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'When run, these `printf` statements output:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Note how the tab characters (`\t`) get printed in the second call, and the different
    formatting placeholders for different types of values (`%g`, `%s`, and `%d`).
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a set of formatting placeholders for common C types. Note that placeholders
    for `long` and `long long` values include an `l` or `ll` prefix.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Here are some examples of their use:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'When run, the output will look like this:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'C also allows you to specify the field width with format placeholders. Here
    are some examples:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Here’s a larger example that uses field width specifiers with placeholders
    in the format string:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: printf_format.c
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'When run, the program output looks like this:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Note how the use of tabs and field width in the last three `printf` statements
    result in a tabular output.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, C defines placeholders for displaying values in different representations:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Here is an example using placeholders to print values in different representations:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'When run, the program output looks like this:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: scanf
  id: totrans-441
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `scanf` function provides one method for reading in values from `stdin`
    (usually from the user entering them via the keyboard) and storing them in program
    variables. The `scanf` function is a bit picky about the exact format in which
    the user enters data, which can make it sensitive to badly formed user input.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: 'The arguments to the `scanf` function are similar to those of `printf`: `scanf`
    takes a format string that specifies the number and type of input values to read
    in, followed by the *locations* of program variables into which the values should
    be stored. Programs typically combine the *address of* (`&`) operator with a variable
    name to produce the location of the variable in the program’s memory—the memory
    address of the variable. Here’s an example call to `scanf` that reads in two values
    (an `int` and a `float`):'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: scanf_ex.c
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Individual input values must be separated by at least one whitespace character
    (e.g., spaces, tabs, newlines). However, `scanf` skips over leading and trailing
    whitespace characters as it finds the start and end of each numeric literal value.
    As a result, a user could enter the value 8 and 3.14 with any amount of whitespace
    before or after the two values (and at least one or more whitespace characters
    between), and `scanf` will always read in 8 and assign it to `x` and read in 3.14
    and assign it to `pi`. For example, this input with lots of spaces between the
    two values will result in reading in 8 and storing it in `x`, and 3.14 and storing
    in `pi`:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Programmers often write format strings for `scanf` that only consist of placeholder
    specifiers without any other characters between them. For reading in the two numbers
    in the preceding example, the format string might look like:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: getchar and putchar
  id: totrans-450
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The C functions `getchar` and `putchar` respectively read or write a single
    character value from `stdin` and to `stdout`. `getchar` is particularly useful
    in C programs that need to support careful error detection and handling of badly
    formed user input (`scanf` is not robust in this way).
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 2.8.2 File Input/Output
  id: totrans-453
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The C standard I/O library (`stdio.h`) includes a stream interface for file
    I/O. A *file* stores persistent data: data that lives beyond the execution of
    the program that created it. A text file represents a stream of characters, and
    each open file tracks its current position in the character stream. When opening
    a file, the current position starts at the very first character in the file, and
    it moves as a result of every character read (or written) to the file. To read
    the 10th character in a file, the first nine characters need to first be read
    (or the current position must be explicitly moved to the 10th character using
    the `fseek` function).'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: C’s file interface views a file as an input or output stream, and library functions
    read from or write to the next position in the file stream. The `fprintf` and
    `fscanf` functions serve as the file I/O counterparts to `printf` and `scanf`.
    They use a format string to specify what to write or read, and they include arguments
    that provide values or storage for the data that gets written or read. Similarly,
    the library provides the `fputc`, `fgetc`, `fputs`, and `fgets` functions for
    reading and writing individual characters or strings to file streams. Although
    there are many libraries that support file I/O in C, we present only the `stdio.h`
    library’s stream interface to text files in detail.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: 'Text files may contain special chars like the `stdin` and `stdout` streams:
    newlines (`’\n’`), tabs (`’\t’`), etc. Additionally, upon reaching the end of
    a file’s data, C’s I/O library generates a special end-of-file character (`EOF`)
    that represents the end of the file. Functions reading from a file can test for
    `EOF` to determine when they have reached the end of the file stream.'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: 2.8.3 Using Text Files in C
  id: totrans-457
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To read or write a file in C, follow these steps.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: 'First, *declare* a `FILE *` variable:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: These declarations create pointer variables to a library-defined `FILE` type.
    These pointers cannot be dereferenced in an application program. Instead, they
    refer to a specific file stream when passed to I/O library functions.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, *open* the file: associate the variable with an actual file stream
    by calling `fopen`. When opening a file, the *mode* parameter determines whether
    the program opens it for reading (`"r"`), writing (`"w"`), or appending (`"a"`):'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The `fopen` function returns `NULL` to report errors, which may occur if it’s
    given an invalid filename or the user doesn’t have permission to open the specified
    file (e.g., not having write permission to the `output.txt` file).
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: 'Third, *use* I/O operations to read, write, or move the current position in
    the file:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Finally, *close* the file: use `fclose` to close the file when the program
    no longer needs it:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The `stdio` library also provides functions to change the current position
    in a file:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 2.8.4 Standard and File I/O Functions in stdio.h
  id: totrans-471
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The C `stdio.h` library has many functions for reading and writing to files
    and to the standard file-like streams (`stdin`, `stdout`, and `stderr`). These
    functions can be classified into character-based, string-based, and formatted
    I/O functions. Here’s some additional details about a subset of these functions:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: In general, `scanf` and `fscanf` are sensitive to badly formed input. However,
    for file I/O, often programmers can assume that an input file is well formatted,
    so `fscanf` may be robust enough in such cases. With `scanf`, badly formed user
    input will often cause a program to crash. Reading in one character at a time
    and including code to test values before converting them to different types is
    more robust, but it requires the programmer to implement more complex I/O functionality.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: 'The format string for `fscanf` can include the following syntax specifying
    different types of values and ways of reading from the file stream:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: It can be tricky to get the `fscanf` format string correct, particularly when
    reading a mix of numeric and string or character types from a file.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few example calls to `fscanf` (and one to `fprintf`) with different
    format strings (let’s assume that the `fopen` calls from the previous example
    have executed successfully):'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: In the final example in the preceding code, the format string explicitly reads
    in a character value after a number to ensure that the file stream’s current position
    gets properly advanced for any subsequent calls to `fscanf`. For example, this
    pattern is often used to explicitly read in (and discard) a whitespace character
    (like *\n*), to ensure that the next call to `fscanf` begins from the next line
    in the file. Reading an additional character is necessary if the *next* call to
    `fscanf` attempts to read in a character value. Otherwise, having not consumed
    the newline, the next call to `fscanf` will read the newline rather than the intended
    character. If the next call reads in a numeric type value, then leading whitespace
    chars are automatically discarded by `fscanf` and the programmer does not need
    to explicitly read the `\n` character from the file stream.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: 2.9 Some Advanced C Features
  id: totrans-481
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Almost all of the C programming language has been presented in previous sections.
    In this section, we cover a few remaining advanced C language features and some
    advanced C programming and compiling topics:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: the C `switch` statement ([page 122](ch02.xhtml#lev2_36))
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: command line arguments ([page 125](ch02.xhtml#lev2_37))
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the `void *` type and type recasting ([page 126](ch02.xhtml#lev2_38))
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pointer arithmetic ([page 128](ch02.xhtml#lev2_39))
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C libraries: using, compiling, and linking ([page 133](ch02.xhtml#lev2_40))'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: writing and using your own C libraries (and dividing your program into multiple
    modules (`.c` and `.h` files); [page 139](ch02.xhtml#lev2_41))
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: compiling C source to assembly code ([page 145](ch02.xhtml#lev2_42)).
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.9.1 switch Statements
  id: totrans-490
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The C `switch` statement can be used in place of some, but not all, chaining
    `if`–`else if` code sequences. While `switch` doesn’t provide any additional expressive
    power to the C programming language, it often yields more concise code branching
    sequences. It may also allow the compiler to produce branching code that executes
    more efficiently than equivalent chaining `if`–`else if` code.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: 'The C syntax for a `switch` statement looks like:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'A switch statement is executed as follows:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: 1\. The <expression> evaluates first.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Next, the `switch` searches for a `case` literal value that matches the
    value of the expression.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Upon finding a matching `case` literal, it begins executing the <statements>
    that immediately follow it.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: 4\. If no matching `case` is found, it will begin executing the <statements>
    in the `default` label if one is present.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Otherwise, no statements in the body of the `switch` statement get executed.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: 'A few rules about `switch` statements:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: The value associated with each `case` must be a literal value—it *cannot* be
    an expression. The original expression gets matched for *equality* only with the
    literal values associated with each `case`.
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reaching a `break` statement stops the execution of all remaining statements
    inside the body of the `switch` statement. That is, `break` breaks out of the
    body of the `switch` statement and continues execution with the next statement
    after the entire `switch` block.
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `case` statement with a matching value marks the starting point into the
    sequence of C statements that will be executed—execution jumps to a location inside
    the `switch` body to start executing code. Thus, if there is no `break` statement
    at the end of a particular `case`, then the statements under the subsequent `case`
    statements execute in order until either a `break` statement is executed or the
    end of the body of the `switch` statement is reached.
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `default` label is optional. If present, it must be at the end.
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s an example program with a `switch` statement:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Here are some example runs of this code:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 2.9.2 Command Line Arguments
  id: totrans-509
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A program can be made more general purpose by reading command line arguments,
    which are included as part of the command entered by the user to run a binary
    executable program. They specify input values or options that change the runtime
    behavior of the program. In other words, running the program with different command
    line argument values results in a program’s behavior changing from run to run
    without having to modify the program code and recompile it. For example, if a
    program takes the name of an input filename as a command line argument, a user
    can run it with any input filename as opposed to a program that refers to a specific
    input filename in the code.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: 'Any command line arguments the user provides get passed to the `main` function
    as parameter values. To write a program that takes command line arguments, the
    `main` function’s definition must include two parameters, `argc` and `argv`:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Note that the type of the second parameter could also be represented as `char`
    `**argv`.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter, `argc`, stores the argument count. Its value represents
    the number of command line arguments passed to the main function (including the
    name of the program). For example, if the user enters
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: then `argc` will hold the value 4 (`a.out` counts as the first command line
    argument, and `10`, `11`, and `200` as the other three).
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter, `argv`, stores the argument vector. It contains the value
    of each command line argument. Each command line argument gets passed in as a
    string value, thus `argv`’s type is an array of strings (or an array of `char`
    arrays). The `argv` array contains `argc + 1` elements. The first `argc` elements
    store the command line argument strings, and the last element stores `NULL`, signifying
    the end of the command line argument list. For example, in the command line entered
    in the previous example, the `argv` array would look like [Figure 2-18](ch02.xhtml#ch2fig18).
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/02fig18.jpg)'
  id: totrans-518
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-18: The `argv` parameter passed to `main` is an array of strings.
    Each command line argument is passed as a separate string element in the array.
    The value of the last element is `NULL`, signifying the end of the list of command
    line arguments.*'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: The strings in an `argv` array are *immutable*, meaning that they are stored
    in read-only memory. As a result, if a program wants to modify the value of one
    of its command line arguments, it needs to make a local copy of the command line
    argument and modify the copy.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, a program wants to interpret a command line argument passed to `main`
    as a type other than a string. In the previous example, the program may want to
    extract the integer value `10` from the string value `"10"` of its first command
    line argument. C’s standard library provides functions for converting strings
    to other types. For example, the `atoi` (“a to i,” for “ASCII to integer”) function
    converts a string of digit characters to its corresponding integer value:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: See “Functions to Convert Strings to Other Types” on [page 103](ch02.xhtml#lev3_25)
    for more information about these functions, and the `commandlineargs.c` program^([4](ch02.xhtml#fn2_4))
    for another example of C command line arguments.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: 2.9.3 The void * Type and Type Recasting
  id: totrans-524
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The C type `void *` represents a generic pointer—a pointer to any type, or
    a pointer to an unspecified type. C allows for a generic pointer type because
    memory addresses on a system are always stored in the same number of bytes (e.g.,
    addresses are four bytes on 32-bit systems and eight bytes on 64-bit systems).
    As a result, every pointer variable requires the same number of storage bytes,
    and because they’re all the same size, the compiler can allocate space for a `void
    *` variable without knowing the type it points to. Here’s an example:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Typically, programmers do not declare variables of type `void *` as in the preceding
    example. Instead, it’s commonly used to specify generic return types from functions
    or generic parameters to functions. The `void *` type is often used as a return
    type by functions that return newly allocated memory that can be used to store
    any type (e.g., `malloc`). It’s also used as a function parameter for functions
    that can take any type of value. In this case, individual calls to the function
    pass in a pointer to some specific type, which can be passed to the function’s
    `void *` parameter because it can store the address of any type.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: Because `void *` is a generic pointer type, it cannot be directly dereferenced—the
    compiler does not know the size of memory that the address points to. For example,
    the address could refer to an `int` storage location of four bytes or it could
    refer to a `char` storage location in memory of one byte. Therefore, the programmer
    must explicitly *recast* the `void *` pointer to a pointer of a specific type
    before dereferencing it. Recasting tells the compiler the specific type of pointer
    variable, allowing the compiler to generate the correct memory access code for
    pointer dereferences.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are two examples of `void *` use. First, a call to `malloc` recasts its
    `void` `*` return type to the specific pointer type of the variable used to store
    its returned heap memory address:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Second, students often encounter the `void *` when creating threads (see “Hello
    Threading! Writing Your First Multithreaded Program” on [page 677](ch14.xhtml#lev1_106)).
    Using a `void *` parameter type in a thread function allows the thread to take
    any type of application-specific pointer. The `pthread_create` function has a
    parameter for the thread main function and a `void *` parameter for the argument
    value that it passes to the thread main function that the newly created thread
    will execute. The use of the `void *` parameter makes `pthread_create` a generic
    thread creation function; it can be used to point to any type of memory location.
    For a specific program that calls `pthread_create`, the programmer knows the type
    of the argument passed to the `void *` parameter, so the programmer must recast
    it to its known type before dereferencing it. In this example, suppose that the
    address passed to the `args` parameter contains the address of an integer variable:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 2.9.4 Pointer Arithmetic
  id: totrans-533
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If a pointer variable points to an array, a program can perform arithmetic
    on the pointer to access any of the array’s elements. In most cases, we recommend
    against using pointer arithmetic to access array elements: it’s easy to make errors
    and more difficult to debug when you do. However, occasionally it may be convenient
    to successively increment a pointer to iterate over an array of elements.'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: When incremented, a pointer points to the next storage location *of the type
    it points to*. For example, incrementing an integer pointer (`int *`) makes it
    point to the next `int` storage address (the address four bytes beyond its current
    value), and incrementing a character pointer makes it point to the next `char`
    storage address (the address one byte beyond its current value).
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example program, we demonstrate how to use pointer arithmetic
    to manipulate an array. First declare pointer variables whose type matches the
    array’s element type:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: pointerarith.c
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Next, initialize the pointer variables to the base address of the arrays over
    which they will iterate:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: pointerarith.c
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Then, using pointer dereferencing, our program can access the array’s elements.
    Here, we’re dereferencing to assign a value to an array element and then incrementing
    the pointer variable by one to advance it to point to the next element:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: pointerarith.c
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Note that in this example, the pointer values are incremented inside the loop.
    Thus, incrementing their value makes them point to the next element in the array.
    This pattern effectively walks through each element of an array in the same way
    that accessing `cptr[i]` or `iptr[i]` at each iteration would.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: '**Note THE SEMANTICS OF POINTER ARITHMETIC AND THE UNDERLYING ARITHMETIC FUNCTION**'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: 'The semantics of pointer arithmetic are type independent: changing any type
    of pointer’s value by `N` (`ptr = ptr + N`) makes the pointer point `N` storage
    locations beyond its current value (or makes it point to `N` elements beyond the
    current element it points to). As a result, incrementing a pointer of any type
    makes it point to the very next memory location of the type it points to.'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: However, the actual arithmetic function that the compiler generates for a pointer
    arithmetic expression varies depending on the type of the pointer variable (depending
    on the number of bytes the system uses to store the type to which it points).
    For example, incrementing a `char` pointer will increase its value by one because
    the very next valid `char` address is one byte from the current location. Incrementing
    an `int` pointer will increase its value by four because the next valid integer
    address is four bytes from the current location.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: A programmer can simply write `ptr++` to make a pointer point to the next element
    value. The compiler generates code to add the appropriate number of bytes for
    the corresponding type it points to. The addition effectively sets its value to
    the next valid address in memory of that type.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see how the previous code modified array elements by printing out their
    values (we show this first using array indexing and then using pointer arithmetic
    to access each array element’s value):'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Here’s what the output looks like:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Pointer arithmetic can be used to iterate over any contiguous chunk of memory.
    Here’s an example using pointer arithmetic to initialize a statically declared
    2D array:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The output will look like:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Pointer arithmetic can access contiguous memory locations in any pattern, starting
    and ending anywhere in a contiguous chunk of memory. For example, after initializing
    a pointer to the address of an array element, its value can be changed by more
    than one. For example:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'After executing the preceding code, printing the `numbers` array’s values would
    look like this (note that the values at index 2 and index 6 have changed):'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Pointer arithmetic works on dynamically allocated arrays, too. However, programmers
    must be careful working with dynamically allocated multidimensional arrays. If,
    for example, a program uses multiple `malloc` calls to dynamically allocate individual
    rows of a 2D array (see “Method 2: The Programmer-Friendly Way” on [page 90](ch02.xhtml#lev3_17)),
    then the pointer must be reset to point to the address of the starting element
    of every row. Resetting the pointer is necessary because only elements within
    a row are located in contiguous memory addresses. On the other hand, if the 2D
    array is allocated as a single `malloc` of total rows times columns space (see
    “Method 1: Memory-Efficient Allocation” on [page 88](ch02.xhtml#lev3_15)), then
    all the rows are in contiguous memory (like in the statically declared 2D array
    from the previous example). In the latter case, the pointer only needs to be initialized
    to point to the base address, and then pointer arithmetic will correctly access
    any element in the 2D array.'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: '2.9.5 C Libraries: Using, Compiling, and Linking'
  id: totrans-563
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A *library* implements a collection of functions and definitions that can be
    used by other programs. A C library consists of two parts:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: The *application programming interface* (API) to the library, which gets defined
    in one or more header files (`.h` files) that must be included in C source code
    files that plan to use the library. The headers define what the library exports
    to its users. These definitions usually include library function prototypes, and
    they may also include type, constant, or global variable declarations.
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *implementation* of the library’s functionality, often made available to
    programs in a precompiled binary format that gets *linked* (added) into the binary
    executable created by `gcc`. Precompiled library code might be in an archive file
    (`libsomelib.a`) containing several `.o` files that can be statically linked into
    the executable file at compile time. Alternatively, it may consist of a shared
    object file (`libsomelib.so`) that can be dynamically linked at runtime into a
    running program.
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, the C string library implements a set of functions to manipulate
    C strings. The `string.h` header file defines its interface, so any program that
    wants to use string library functions must `#include <string.h>`. The implementation
    of the C string library is part of the larger standard C library (`libc`) that
    the `gcc` compiler automatically links into every executable file it creates.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: A library’s implementation consists of one or more modules (`.c` files), and
    may additionally include header files that are internal to the library implementation;
    internal header files are not part of the library’s API but are part of well-designed,
    modular library code. Often the C source code implementation of a library is not
    exported to the user of the library. Instead, the library is made available in
    a precompiled binary form. These binary formats are not executable programs (they
    cannot be run on their own), but they provide executable code that can be *linked*
    into (added into) an executable file by `gcc` at compilation time.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: There are numerous libraries available for C programmers to use. For example,
    the POSIX thread library (discussed in [Chapter 10](ch10.xhtml#ch10)) enables
    multithreaded C programs. C programmers can also implement and use their own libraries
    (see “Writing and Using Your Own C Libraries” on [page 133](ch02.xhtml#lev2_41)).
    Large C programs tend to use many C libraries, some of which `gcc` links implicitly,
    whereas others require explicit linking with the `-l` command line option to `gcc`.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: 'Standard C libraries normally do not need to be explicitly linked in with the
    `-l` option, but other libraries do. The documentation for a library function
    often specifies whether the library needs to be explicitly linked in when compiling.
    For example, the POSIX threads library (`pthread`) and the `readline` library
    require explicit linking on the `gcc` command line:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Note that the full name of the library file should not be included in the `-l`
    argument to `gcc`; the library files are named something like `libpthread.so`
    or `libreadline.a`, but the `lib` prefix and `.so` or `.a` suffix of the filenames
    are not included. The actual library filename may also contain version numbers
    (e.g., `libreadline.so.8.0`), which are also not included in the `-l` command
    line option (`-lreadline`). By not forcing the user to specify (or even know)
    the exact name and location of the library files to link in, `gcc` is free to
    find the most recent version of a library in a user’s library path. It also allows
    the compiler to choose to dynamically link when both a shared object (`.so`) and
    an archive (`.a`) version of a library are available. If users want to statically
    link libraries, then they can explicitly specify static linking in the `gcc` command
    line. The `--static` option provides one method for requesting static linking:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Compilation Steps
  id: totrans-574
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Characterizing C’s program compilation steps will help to illustrate how library
    code gets linked into an executable binary file. We first present the compilation
    steps and then discuss (with examples) different types of errors that can occur
    when compiling programs that use libraries.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: The C compiler translates a C source file (e.g., `myprog.c`) into an executable
    binary file (e.g., `a.out`) in four distinct steps (plus a fifth step that occurs
    at runtime).
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: 'The *precompiler* step runs first and expands *preprocessor directives*: the
    `#` directives that appear in the C program, such as `#define` and `#include`.
    Compilation errors at this step include syntax errors in preprocessor directives
    or `gcc` not finding header files associated with `#include` directives. To view
    the intermediate results of the precompiler step, pass the `-E` flag to `gcc`
    (the output can be redirected to a file that can be viewed by a text editor):'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The *compile* step runs next and does the bulk of the compilation task. It
    translates the C program source code (`myprog.c`) to machine-specific assembly
    code (`myprog.s`). Assembly code is a human-readable form of the binary machine
    code instructions that a computer can execute. Compilation errors at this step
    include C language syntax errors, undefined symbol warnings, and errors from missing
    definitions and function prototypes. To view the intermediate results of the compile
    step, pass the `-S` flag to `gcc` (this option creates a text file named `myprog.s`
    with the assembly translation of `myprog.c`, which can be viewed in a text editor):'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'The *assembly* step converts the assembly code into relocatable binary object
    code (`myprog.o`). The resulting object file contains machine code instructions,
    but it is not a complete executable program that can run on its own. The `gcc`
    compiler on Unix and Linux systems produces binary files in a specific format
    called ELF (Executable and Linkable Format).^([5](ch02.xhtml#fn2_5)) To stop compilation
    after this step, pass the `-c` flag to `gcc` (this produces a file named `myprog.o`).
    Binary files (e.g., `a.out` and `.o` files) can be viewed using `objdump` or similar
    tools for displaying binary files:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The *link editing* step runs last and creates a single executable file (`a.out`)
    from relocatable binaries (`.o`) and libraries (`.a` or `.so`). In this step,
    the linker verifies that any references to names (symbols) in a `.o` file are
    present in other `.o`, `.a`, or `.so` files. For example, the linker will find
    the `printf` function in the standard C library (`libc.so`). If the linker cannot
    find the definition of a symbol, this step fails with an error stating that a
    symbol is undefined. Running `gcc` without flags for partial compilation performs
    all four steps of compiling a C source code file (`myprog.c`) to an executable
    binary file (`a.out`) that can be run:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: If the binary executable file (`a.out`) statically links in library code (from
    `.a` library files), then `gcc` embeds copies of library functions from the `.a`
    file in the resulting `a.out` file. All calls to library functions by the application
    are *bound* to the locations in the `a.out` file to which the library function
    is copied. Binding associates a name with a location in the program memory. For
    example, binding a call to a library function named `gofish` means replacing the
    use of the function name with the address in memory of the function (in later
    chapters we discuss memory addresses in more detail—see, for example, “Memory
    Addresses” on [page 642](ch13.xhtml#lev2_227)).
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: If, however, the `a.out` was created by dynamically linking a library (from
    library shared object, `.so`, files), then `a.out` does not contain a copy of
    the library function code from these libraries. Instead, it contains information
    about which dynamically linked libraries are needed by the `a.out` file to run
    it. Such executables require an additional linking step at runtime.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: The *runtime linking* step is needed if `a.out` was linked with shared object
    files during link editing. In such cases, the dynamic library code (in `.so` files)
    must be loaded at runtime and linked with the running program. This runtime loading
    and linking of shared object libraries is called *dynamic linking*. When a user
    runs an `a.out` executable with shared object dependencies, the system performs
    dynamic linking before the program begins executing its `main` function.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: The compiler adds information about shared object dependencies into the `a.out`
    file during the link editing compilation step. When the program starts executing,
    the dynamic linker examines the list of shared object dependencies and finds and
    loads the shared object files into the running program. It then updates relocation
    table entries in the `a.out` file, binding the program’s use of symbols in shared
    objects (such as calls to library functions) to their locations in the `.so` file
    loaded at runtime. Runtime linking reports errors if the dynamic linker cannot
    find a shared object (`.so`) file needed by the executable.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ldd` utility lists an executable file’s shared object dependencies:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: The *GNU debugger (GDB)* can examine a running program and show which shared
    object code is loaded and linked at runtime. We cover GDB in [Chapter 3](ch03.xhtml#ch03).
    However, the details of examining the Procedure Lookup Table (PLT), which is used
    for runtime linking of calls to dynamically linked library functions, is beyond
    the scope of this textbook.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: More details about the phases of compilation and about tools for examining different
    phases can be found online.^([6](ch02.xhtml#fn2_6))
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: Common Compilation Errors Related to Compiling and Linking Libraries
  id: totrans-593
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Several compilation and linking errors can occur due to the programmer forgetting
    to include library header files or forgetting to explicitly link in library code.
    Identifying the `gcc` compiler error or warning associated with each of these
    errors will help in debugging errors related to using C libraries.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this next C program that makes a call to a function `libraryfunc`
    from the `examplelib` library (available as a shared object file, `libmylib.so`):'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Assume that the header file, `examplelib.h`, contains the definitions in the
    following example:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: The `extern` prefix to the function prototype means that the function’s definition
    comes from another file—it’s not in the `examplelib.h` file, but instead it’s
    provided by one of the `.c` files in the library’s implementation.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: '**Forgetting to include a header file.** If the programmer forgets to include
    `examplelib.h` in their program, then the compiler produces warnings and errors
    about the program’s use of library functions and constants that it does not know
    about. For example, if the user compiles their program without `#include <examplelib.h>`,
    `gcc` will produce the following output:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: The first compiler warning (`implicit declaration of function` `libraryfunc`)
    tells the programmer that the compiler cannot find a function prototype for the
    `libraryfunc` function. This is just a compiler warning because `gcc` will guess
    that the function’s return type is an integer and will continue compiling the
    program. However, programmers should *not* ignore such warnings! They indicate
    that the program isn’t including a function prototype before its use in the `myprog.c`
    file, which is often due to not including a header file that contains the function
    prototype.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: The second compiler error (`MAX undeclared (first use in this` `function)`)
    follows from a missing constant definition. The compiler cannot guess at the value
    of the missing constant, so this missing definition fails with an error. This
    type of “undeclared” message often indicates that a header file defining a constant
    or global variable is missing or hasn’t been properly included.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: '**Forgetting to link a library.** If the programmer includes the library header
    file (as shown in the previous listing), but forgets to explicitly link in the
    library during the link editing step of compilation, then `gcc` indicates this
    with an “undefined reference” error:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'This error originates from `ld`, the linker component of the compiler. It indicates
    that the linker cannot find the implementation of the library function `libraryfunc`
    that gets called at line 9 in `myprog.c`. An “undefined reference” error indicates
    that a library needs to be explicitly linked into the executable. In this example,
    specifying `-lexamplelib` on the `gcc` command line will fix the error:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '**gcc can’t find header or library files.** Compilation will also fail with
    errors if a library’s header or implementation files are not present in the directories
    that `gcc` searches by default. For example, if `gcc` cannot find the `examplelib.h`
    file, it will produce an error message like this:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'If the linker cannot find a `.a` or `.so` version of the library to link in
    during the link editing step of compilation, `gcc` will exit with an error like
    the following:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Similarly, if a dynamically linked executable cannot locate a shared object
    file (e.g., `libexamplelib.so`), it will fail to execute at runtime with an error
    like the following:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: To resolve these types of errors, programmers must specify additional options
    to `gcc` to indicate where the library’s files can be found. They may also need
    to modify the `LD_LIBRARY_PATH` environment variable for the runtime linker to
    find a library’s `.so` file.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: Library and Include Paths
  id: totrans-615
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The compiler automatically searches in standard directory locations for header
    and library files. For example, systems commonly store standard header files in
    `/usr/include`, and library files in `/usr/lib`, and `gcc` automatically looks
    for headers and libraries in these directories; `gcc` also automatically searches
    for header files in the current working directory.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: 'If `gcc` cannot find a header or a library file, then the user must explicitly
    provide paths on the command line using `-I` and `-L`. For example, suppose that
    a library named `libexamplelib.so` exists in `/home/me/lib`, and its header file
    `examplelib.h` is in `/home/me/include`. Because `gcc` knows nothing of those
    paths by default, it must be explicitly told to include files there to successfully
    compile a program that uses this library:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'To specify the location of a dynamic library (e.g., `libexamplelib.so`) when
    launching a dynamically linked executable, set the `LD_LIBRARY_PATH` environment
    variable to include the path to the library. Here’s an example bash command that
    can be run at a shell prompt or added to a `.bashrc` file:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: When the `gcc` command lines get long, or when an executable requires many source
    and header files, it helps to simplify compilation by using `make` and a `Makefile`.^([7](ch02.xhtml#fn2_7))
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: 2.9.6 Writing and Using Your Own C Libraries
  id: totrans-622
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Programmers typically divide large C programs into separate *modules* (i.e.,
    separate `.c` files) of related functionality. Definitions shared by more than
    one module are put in header files (`.h` files) that are included by the modules
    that need them. Similarly, C library code is also implemented in one or more modules
    (`.c` files) and one or more header files (`.h` files). C programmers often implement
    their own C libraries of commonly used functionality. By writing a library, a
    programmer implements the functionality once, in the library, and then can use
    this functionality in any subsequent C program that they write.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: 'In “C Libraries: Using, Compiling, and Linking” on [page 133](ch02.xhtml#lev2_40),
    we describe how to use, compile, and link C library code into C programs. In this
    section, we discuss how to write and use your own libraries in C. What we present
    here also applies to structuring and compiling larger C programs composed of multiple
    C source and header files.'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a library in C:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Define an interface to the library in a header (`.h`) file. This header
    file must be included by any program that wants to use the library.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Create an implementation of the library in one or more `.c` files. This
    set of function definitions implement the library’s functionality. Some functions
    may be interface functions that users of the library will call, and others may
    be internal functions that cannot be called by users of the library (internal
    functions are part of good modular design of the library’s implementation).
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Compile a binary form of the library that can be linked into programs that
    use the library.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: The binary form of a library could be directly built from its source file(s)
    as part of compiling the application code that uses the library. This method compiles
    the library files into `.o` files and statically links them into the binary executable.
    Including libraries this way often applies to library code that you write for
    your own use (since you have access to its `.c` source files), and it’s also the
    method to build an executable from multiple `.c` modules.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, a library could be compiled into a binary archive (`.a`) or a
    shared object (`.so`) file for programs that want to use the library. In these
    cases, users of the library often will not have access to the library’s C source
    code files, and thus they are not able to directly compile the library code with
    application code that uses it. When a program uses such a precompiled library
    (e.g., a `.a` or `.so`), the library’s code must be explicitly linked into the
    executable file using `gcc`’s `-l` command line option.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: We focus our detailed discussion of writing, compiling, and linking library
    code on the case in which the programmer has access to individual library modules
    (either the `.c` or `.o` files). This focus also applies to designing and compiling
    large C programs that are divided into multiple `.c` and `.h` files. We briefly
    show commands for building archive and shared object forms of libraries. More
    information about building these types of library files is available in the `gcc`
    documentation, including the man pages for `gcc` and `ar`.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: In the following, we show some examples of creating and using your own libraries.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: '**Define the library interface** Header files (`.h` file) are text files that
    contain C function prototypes and other definitions—they represent the interface
    of a library. A header file must be included in any application that intends to
    use the library. For example, the C standard library header files are usually
    stored in `/usr/include/` and can be viewed with an editor:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Here’s an example header file^([8](ch02.xhtml#fn2_8)) from a library that contains
    some definitions for users of the library:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: myfile.h
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Header files typically have special “boilerplate” code around their contents.
    For example:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: This boilerplate code ensures that the compiler’s preprocessor only includes
    the contents of `mylib.h` exactly once in any C file that includes it. It is important
    to include `.h` file contents only once to avoid duplicate definition errors at
    compile time. Similarly, if you forget to include a `.h` file in a C program that
    uses the library, the compiler will generate an “undefined symbol” warning.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: The comments in the `.h` file are part of the interface to the library, written
    for users of the library. These comments should be verbose, explaining definitions
    and describing what each library function does, what parameter values it takes,
    and what it returns. Sometimes a `.h` file will also include a top-level comment
    describing how to use the library.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: The keyword `extern` before the global variable definition and function prototype
    means that these names are defined somewhere else. It is particularly important
    to include `extern` before any global variables that the library exports, as it
    distinguishes a name and type definition (in the `.h` file) from a variable declaration
    in the library’s implementation. In the previous example, the global variable
    is declared exactly once inside the library, but it’s exported to library users
    through its `extern` definition in the library’s `.h` file.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: '**Implement the library functionality.** Programmers implement libraries in
    one or more `.c` files (and sometimes internal `.h` files). The implementation
    includes definitions of all the function prototypes in the `.h` file as well as
    other functions that are internal to its implementation. These internal functions
    are often defined with the keyword `static`, which scopes their availability to
    the module (`.c` file) in which they are defined. The library implementation should
    also include variable definitions for any `extern` global variable declarations
    in the `.h` file. Here’s an example library implementation:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: mylib.c
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '**Create a binary form of the library.** To create a binary form of the library
    (a `.o` file), compile with the `-c` option:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'One or more `.o` files can build an archive (`.a`) or shared object (`.so`)
    version of the library. To build a static library use the archiver (`ar`):'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'To build a dynamically linked library, the `mylib.o` object file(s) in the
    library must be built with *position independent code* (using `-fPIC`). A `libmylib.so`
    shared object file can be created from `mylib.o` by specifying the `-shared` flag
    to `gcc`:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Shared object and archive libraries are often built from multiple `.o` files,
    for example (remember that `.o` for dynamically linked libraries need to be built
    using the `-fPIC` flag):'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '**Use and link the library.** Other `.c` files that use this library should
    `#include` its header file, and the implementation (`.o` file) should be explicitly
    linked during compilation.'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: 'After including the library header file, your code then can call the library’s
    functions:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: myprog.c
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '**Note #INCLUDE SYNTAX AND THE PREPROCESSOR**'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: The `#include` syntax to include `mylib.h` is different from the syntax to include
    `stdio.h`. This is because `mylib.h` is not located with the header files from
    standard libraries. The preprocessor has default places it looks for standard
    header files. When including a file with the `<file.h>` syntax instead of the
    `"file.h"` syntax, the preprocessor searches for the header file in those standard
    places.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: 'When `mylib.h` is included inside double quotes, the preprocessor first looks
    in the current directory for the `mylib.h` file, and then other places that you
    need to explicitly tell it to look, by specifying an include path (`-I`) to `gcc`.
    For example, if the header file is in the `/home/me/myincludes` directory (and
    not in the same directory as the `myprog.c` file), then the path to this directory
    must be specified in the `gcc` command line for the preprocessor to find the `mylib.h`
    file:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: $ gcc -I/home/me/myincludes -c myprog.c
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: 'To compile a program (`myprog.c`) that uses the library (`mylib.o`) into a
    binary executable:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Or, if the library’s implementation files are available at compile time, then
    the program can be built directly from the program and library `.c` files:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Or, if the library is available as an archive or shared object file, then it
    can be linked in using `-l` (`-lmylib`: note that the library name is `libmylib.[a,so]`,
    but only the `mylib` part is included in the `gcc` command line):'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'The `-L.` option specifies the path to the `libmylib.[so,a]` files (the `.`
    after the `-L` indicates that it should search the current directory). By default,
    `gcc` will dynamically link a library if it can find a `.so` version. See “C Libraries:
    Using, Compiling, and Linking” on [page 133](ch02.xhtml#lev2_40) for more information
    about linking and link paths.'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: 'The program can then be run:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'If you run the dynamically linked version of `myprog`, you may encounter an
    error that looks like this:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'This error is saying that the runtime linker cannot find `libmylib.so` at runtime.
    To fix this problem, set your `LD_LIBRARY_PATH` environment variable to include
    the path to the `libmylib.so` file. Subsequent runs of `myprog` use the path you
    add to `LD_LIBRARY_PATH` to find the `libmylib.so` file and load it at runtime.
    For example, if `libmylib.so` is in the `/home/me/mylibs/` subdirectory, run this
    (just once) at the bash shell prompt to set the `LD_LIBRARY_PATH` environment
    variable:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 2.9.7 Compiling C to Assembly, and Compiling and Linking Assembly and C Code
  id: totrans-675
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A compiler can compile C code to assembly code, and it can compile assembly
    code into a binary form that links into a binary executable program. We use IA32
    assembly and `gcc` as our example assembly language and compiler, but this functionality
    is supported by any C compiler, and most compilers support compiling to a number
    of different assembly languages. See [Chapter 8](ch08.xhtml#ch08) for details
    about assembly code and assembly programming.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this very simple C program:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: simpleops.c
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'The `gcc` compiler will compile it into an IA32 assembly text file (`.s`) using
    the `-S` command line option to specify compiling to assembly and the `-m32` command
    line option to specify generating IA32 assembly:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'This command creates a file named `simpleops.s` with the compiler’s IA32 assembly
    translation of the C code. Because the `.s` file is a text file, a user can view
    it (and edit it) using any text editor. For example:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Passing additional compiler flags provides directions to `gcc` that it should
    use certain features or optimizations in its translation of C to IA32 assembly
    code.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: 'An assembly code file, either one generated from `gcc` or one written by hand
    by a programmer, can be compiled by `gcc` into binary machine code form using
    the `-c` option:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'The resulting `simpleops.o` file can then be linked into a binary executable
    file (note: this requires that the 32-bit version of the system libraries are
    installed on your system):'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: This command creates a binary executable file, `simpleops`, for IA32 (and x86-64)
    architectures.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: The `gcc` command line to build an executable file can include `.o` and `.c`
    files that will be compiled and linked together to create the single binary executable.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: 'Systems provide utilities that allow users to view binary files. For example,
    `objdump` displays the machine code and assembly code mappings in `.o` files:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'This output can be compared to the assembly file:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'You should see something like this (we’ve annotated some of the assembly code
    with its corresponding code from the C program):'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Writing and Compiling Assembly Code
  id: totrans-697
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Programmers can write their own assembly code by hand and compile it with `gcc`
    into a binary executable program. For example, to implement a function in assembly,
    add code to a `.s` file and use `gcc` to compile it. The following example shows
    the basic structure of a function in IA32 assembly. Such code would be written
    in a file (e.g., `myfunc.s`) for a function with the prototype `int myfunc(int
    param);`. Functions with more parameters or needing more space for local variables
    may differ slightly in their preamble code.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'A C program that wanted to call this function would need to include its function
    prototype:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'The following `gcc` commands build an executable file (`myprog`) from `myfunc.s`
    and `main.c` source files:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: HANDWRITTEN ASSEMBLY CODE
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: Unlike C, which is a high-level language that can be compiled and run on a wide
    variety of systems, assembly code is very low level and specific to a particular
    hardware architecture. Programmers may handwrite assembly code for low-level functions
    or for code sequences that are crucial to the performance of their software. A
    programmer can sometimes write assembly code that runs faster than the compiler-optimized
    assembly translation of C, and sometimes a C programmer wants to access low-level
    parts of the underlying architecture (such as specific registers) in their code.
    Small parts of operating system code are often implemented in assembly code for
    these reasons. However, because C is a portable language and is much higher level
    than assembly languages, the vast majority of operating system code is written
    in C, relying on good optimizing compilers to produce machine code that performs
    well.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: Although most systems programmers rarely write assembly code, being able to
    read and understand a program’s assembly code is an important skill for obtaining
    a deeper understanding of what a program does and how it gets executed. It can
    also help with understanding a program’s performance and with discovering and
    understanding security vulnerabilities in programs.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: 2.10 Summary
  id: totrans-707
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, we covered the C programming language in depth and discussed
    some advanced C programming topics, as well. In the next chapter, we present two
    very helpful C debugging tools: the GNU GDB debugger for general-purpose C program
    debugging, and the Valgrind memory debugger for finding memory access errors in
    C programs. Equipped with these programming tools and knowledge of the core C
    programming language presented in this chapter, a C programmer can design powerful,
    efficient, and robust software.'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  id: totrans-709
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[1.](ch02.xhtml#rfn2_1) *[http://pages.cs.wisc.edu/~remzi/OSTEP/vm-freespace.pdf](http://pages.cs.wisc.edu/~remzi/OSTEP/vm-freespace.pdf)*'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: '[2.](ch02.xhtml#rfn2_2) *[https://diveintosystems.org/book/C2-C_depth/_attachments/strtokexample.c](https://diveintosystems.org/book/C2-C_depth/_attachments/strtokexample.c)*'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: '[3.](ch02.xhtml#rfn2_3) *[http://www.cs.swarthmore.edu/~newhall/unixhelp/man.html](http://www.cs.swarthmore.edu/~newhall/unixhelp/man.html)*'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: '[4.](ch02.xhtml#rfn2_4) *[https://diveintosystems.org/book/C2-C_depth/_attachments/commandlineargs.c](https://diveintosystems.org/book/C2-C_depth/_attachments/commandlineargs.c)*'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: '[5.](ch02.xhtml#rfn2_5) *[https://wikipedia.org/wiki/Executable_and_Linkable_Format](https://wikipedia.org/wiki/Executable_and_Linkable_Format)*'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: '[6.](ch02.xhtml#rfn2_6) *[http://www.cs.swarthmore.edu/~newhall/unixhelp/compilecycle.html](http://www.cs.swarthmore.edu/~newhall/unixhelp/compilecycle.html)*'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: '[7.](ch02.xhtml#rfn2_7) *[https://www.cs.swarthmore.edu/~newhall/unixhelp/howto[m]akefiles.html](https://www.cs.swarthmore.edu/~newhall/unixhelp/howto_makefiles.html)*'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: '[8.](ch02.xhtml#rfn2_8) *[https://diveintosystems.org/book/C2-C_depth/_attachments/mylib.h](https://diveintosystems.org/book/C2-C_depth/_attachments/mylib.h)*'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
