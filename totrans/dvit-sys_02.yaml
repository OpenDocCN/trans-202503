- en: '2'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A DEEPER DIVE INTO C PROGRAMMING
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With many of the basics of C programming covered in the previous chapter, we
    now dive deeper into the details of C. In this chapter we revisit many of the
    topics from the previous chapter, such as arrays, strings, and structs, discussing
    them in more detail. We also introduce C’s pointer variables and dynamic memory
    allocation. *Pointers* provide a level of indirection to accessing program state,
    and *dynamic memory allocation* allows a program to adjust to changes in size
    and space needs as it runs, allocating more space as it needs it and freeing space
    it no longer needs. By understanding how and when to use pointer variables and
    dynamic memory allocation, a C programmer can design programs that are both powerful
    and efficient.
  prefs: []
  type: TYPE_NORMAL
- en: We begin with a discussion of the parts of program memory, as this will help
    in understanding many of the topics presented later. As the chapter progresses,
    we cover C file I/O and some advanced C topics including library linking and compiling
    to assembly code.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1 Parts of Program Memory and Scope
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following C program shows examples of functions, parameters, and local
    and global variables (function comments are omitted to shorten this code listing):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This example shows program variables with different scope. A variable’s *scope*
    defines when its name has meaning. In other words, scope defines the set of program
    code blocks in which a variable is bound to (associated with) a program memory
    location and can be used by program code.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a variable outside of any function body creates a *global variable*.
    Global variables remain permanently in scope and can be used by any code in the
    program because they’re always bound to one specific memory location. Every global
    variable must have a unique name—its name uniquely identifies a specific storage
    location in program memory for the entire duration of the program.
  prefs: []
  type: TYPE_NORMAL
- en: '*Local variables and parameters* are only in scope inside the function in which
    they are defined. For example, the `amt` parameter is in scope only inside the
    `change` function. This means that only statements within the `change` function
    body can access the `amt` parameter, and an instance of the `amt` parameter is
    bound to a specific memory storage location only within a specific active execution
    of the function. Space to store a parameter’s value is allocated on the stack
    when the function gets called, and it is deallocated from the stack when the function
    returns. Each activation of a function gets its own bindings for its parameters
    and local variables. Thus, for recursive function calls, each call (or activation)
    gets a separate stack frame containing space for its parameters and local variables.'
  prefs: []
  type: TYPE_NORMAL
- en: Because parameters and local variables are only in scope inside the function
    that defines them, different functions can use the same names for local variables
    and parameters. For example, both the `change` and the `max` functions have a
    local variable named `val`. When code in the `max` function refers to `val` it
    refers to its local variable `val` and not to the `change` function’s local variable
    `val` (which is not in scope inside the `max` function).
  prefs: []
  type: TYPE_NORMAL
- en: While there may occasionally be times when using global variables in C programs
    is necessary, we strongly recommend that you *avoid programming with global variables
    whenever possible*. Using only local variables and parameters yields code that’s
    more modular, more general-purpose, and easier to debug. Also, because a function’s
    parameters and local variables are only allocated in program memory when the function
    is active, they may result in more space-efficient programs.
  prefs: []
  type: TYPE_NORMAL
- en: Upon launching a new program, the operating system allocates the new program’s
    address space. A program’s *address space* (or memory space) represents storage
    locations for everything it needs in its execution, namely storage for its instructions
    and data. A program’s address space can be thought of as an array of addressable
    bytes; each used address in the program’s address space stores all or part of
    a program instruction or data value (or some additional state necessary for the
    program’s execution).
  prefs: []
  type: TYPE_NORMAL
- en: A program’s memory space is divided into several parts, each of which is used
    to store a different kind of entity in the process’s address space. [Figure 2-1](ch02.xhtml#ch2fig1)
    illustrates the parts of a program’s memory space.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/02fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-1: The parts of a program’s address space*'
  prefs: []
  type: TYPE_NORMAL
- en: The top of a program’s memory is reserved for use by the operating system, but
    the remaining parts are usable by the running program. The program’s instructions
    are stored in the *code* section of the memory. For example, the program listed
    earlier stores instructions for the `main`, `max`, and `change` functions in this
    region of memory.
  prefs: []
  type: TYPE_NORMAL
- en: Local variables and parameters reside in the portion of memory for the *stack*.
    Because the amount of stack space grows and shrinks over the program’s execution
    as functions are called and returned from, the stack part of memory is typically
    allocated near the bottom of memory (at the highest memory addresses) to leave
    space for it to change. Stack storage space for local variables and parameters
    exists only when the function is active (within the stack frame for the function’s
    activation on the stack).
  prefs: []
  type: TYPE_NORMAL
- en: Global variables are stored in the *data* section. Unlike the stack, the data
    region does not grow or shrink—storage space for globals persists for the entire
    run of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the *heap* portion of memory is the part of a program’s address space
    associated with dynamic memory allocation. The heap is typically located far from
    stack memory and grows into higher addresses as more space is dynamically allocated
    by the running program.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2 C’s Pointer Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C’s pointer variables provide a level of indirection to accessing program memory.
    By understanding how to use pointer variables, a programmer can write C programs
    that are both powerful and efficient. For example, through pointer variables,
    a C programmer can:'
  prefs: []
  type: TYPE_NORMAL
- en: implement functions whose parameters can modify values in the caller’s stack
    frame
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: dynamically allocate (and deallocate) program memory at runtime when the program
    needs it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: efficiently pass large data structures to functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: create linked dynamic data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: interpret bytes of program memory in different ways.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we introduce the syntax and semantics of C’s pointer variables
    and introduce common examples of how to use them in C programs.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2.1 Pointer Variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A *pointer variable* stores the address of a memory location in which a value
    of a specific type can be stored. For example, a pointer variable can store the
    value of an `int` address at which the integer value 12 is stored. The pointer
    variable *points to* (refers to) the value. A pointer provides *a level of indirection*
    for accessing values stored in memory. [Figure 2-2](ch02.xhtml#ch2fig2) illustrates
    an example of what a pointer variable might look like in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/02fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-2: A pointer variable stores the address of a location in memory.
    Here, the pointer stores the address of an integer variable that holds the number
    12.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Through the pointer variable, `ptr`, the value (`12`) stored in the memory
    location it points to can be indirectly accessed. C programs most frequently use
    pointer variables for:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. *“pass by pointer” parameters*, for writing functions that can modify their
    argument’s value through a pointer parameter
  prefs: []
  type: TYPE_NORMAL
- en: 2\. *dynamic memory allocation*, for writing programs that allocate (and free)
    space as the program runs. Dynamic memory is commonly used for dynamically allocating
    arrays. It is useful when a programmer doesn’t know the size of a data structure
    at compile time (e.g., the array size depends on user input at runtime). It also
    enables data structures to be resized as the program runs.
  prefs: []
  type: TYPE_NORMAL
- en: Rules for Using Pointer Variables
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The rules for using pointer variables are similar to regular variables, except
    that you need to think about two types: the type of the pointer variable, and
    the type stored in the memory address to which the pointer variable points.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, *declare a pointer variable* using <type_name> `*`<var_name>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Note POINTER TYPES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although `ptr` and `cptr` are both pointers, they refer to different types:'
  prefs: []
  type: TYPE_NORMAL
- en: The type of `ptr` is *pointer to int* (`int *`). It can point to a memory location
    that stores an `int` value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of `cptr` is *pointer to char* (`char *`). It can point to a memory
    location that stores a `char` value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, *initialize the pointer variable* (make it point to something). Pointer
    variables *store address values*. A pointer should be initialized to store the
    address of a memory location whose type matches the type to which the pointer
    variable points. One way to initialize a pointer is to use the *address operator*
    (`&`) with a variable to get the variable’s address value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![image](../images/02fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-3: A program can initialize a pointer by assigning it the address
    of an existing variable of the appropriate type.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of an invalid pointer initialization due to mismatched types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Even though the C compiler may allow this type of assignment (with a warning
    about incompatible types), the behavior of accessing and modifying `x` through
    `cptr` will likely not behave as the programmer expects. Instead, the programmer
    should use an `int *` variable to point to an `int` storage location.
  prefs: []
  type: TYPE_NORMAL
- en: 'All pointer variables can also be assigned a special value, `NULL`, which represents
    an invalid address. While a *null pointer* (one whose value is `NULL`) should
    never be used to access memory, the value `NULL` is useful for testing a pointer
    variable to see if it points to a valid memory address. That is, C programmers
    will commonly check a pointer to ensure that its value isn’t `NULL` before attempting
    to access the memory location to which it points. To set a pointer to `NULL`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![image](../images/02fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: Any pointer can be given the special value `NULL`, which indicates
    that it doesn’t refer to any particular address. Null pointers should never be
    dereferenced.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, *use the pointer variable*. The *dereference operator* (`*`) follows
    a pointer variable to the location in memory that it points to and accesses the
    value at that location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![image](../images/02fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Dereferencing a pointer accesses the value to which the pointer
    refers.*'
  prefs: []
  type: TYPE_NORMAL
- en: Pointer Examples
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Here’s an example sequence of C statements using two pointer variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![image](../images/f0069-01.jpg) [PRE7]'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0070-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![image](../images/f0070-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![image](../images/f0070-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![image](../images/f0070-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When using pointer variables, carefully consider the types of the relevant
    variables. Drawing pictures of memory (like those shown above) can help with understanding
    what pointer code is doing. Some common errors involve misusing the dereference
    operator (`*`) or the address operator (`&`). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If your program dereferences a pointer variable that does not contain a valid
    address, the program crashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'These types of errors exemplify one reason to initialize pointer variables
    to `NULL`; a program can then test a pointer’s value for `NULL` before dereferencing
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 2.3 Pointers and Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pointer parameters provide a mechanism through which functions can modify argument
    values. The commonly used *pass by pointer* pattern uses a pointer function parameter
    that *gets the value of the address of some storage location* passed to it by
    the caller. For example, the caller could pass the address of one of its local
    variables. By dereferencing the pointer parameter inside the function, the function
    can modify the value at the storage location to which it points.
  prefs: []
  type: TYPE_NORMAL
- en: We have already seen similar functionality with array parameters, where an array
    function parameter gets the value of the base address of the passed array (the
    parameter refers to the same set of array elements as its argument), and the function
    can modify the values stored in the array. In general, this same idea can be applied
    by passing pointer parameters to functions that point to the memory locations
    in the caller’s scope.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note PASS BY VALUE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'All arguments in C are passed by value and follow pass-by-value semantics:
    the parameter gets a copy of its argument value, and modifying the parameter’s
    value does not change its argument’s value. When passing base type values, like
    the value of an `int` variable, the function parameter gets a copy of its argument
    value (the specific `int` value), and changing the value stored in the parameter
    cannot change the value stored in its argument.'
  prefs: []
  type: TYPE_NORMAL
- en: In the pass-by-pointer pattern, the parameter still gets the value of its argument,
    but it is passed *the value of an address*. Just like in passing base types, changing
    a pointer parameter’s value will not change its argument’s value (i.e., assigning
    the parameter to point to a different address will not change the argument’s address
    value). However, by dereferencing a pointer parameter, the function can change
    the contents of memory that both the parameter and its argument refer to; through
    a pointer parameter, a function can modify a variable that is visible to the caller
    after the function returns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps for implementing and calling a function with a pass-by-pointer
    parameter, with example code snippets showing each step:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Declare the function parameter to be a pointer to the variable type:'
  prefs: []
  type: TYPE_NORMAL
- en: '/* input: an int pointer that stores the address of a memory'
  prefs: []
  type: TYPE_NORMAL
- en: '*        location that can store an int value (it points to an int)'
  prefs: []
  type: TYPE_NORMAL
- en: '*/'
  prefs: []
  type: TYPE_NORMAL
- en: int change_value(int *input) {
  prefs: []
  type: TYPE_NORMAL
- en: '2\. When making the function call, pass in the address of a variable as the
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: int x;
  prefs: []
  type: TYPE_NORMAL
- en: change_value(&x);
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, since the parameter’s type is `int *`, the address
    passed must be the address of an `int` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '3\. In the body of the function, dereference the pointer parameter to change
    the argument’s value:'
  prefs: []
  type: TYPE_NORMAL
- en: '*input = 100;  // the location input points to (x''s memory)'
  prefs: []
  type: TYPE_NORMAL
- en: // is assigned 100
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s examine a larger example program:'
  prefs: []
  type: TYPE_NORMAL
- en: passbypointer.c
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When run, the output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 2-6](ch02.xhtml#ch2fig6) shows what the call stack looks like before
    executing the return in `change_value`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/02fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: A snapshot of the call stack prior to returning from `change_value`*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter gets a copy of the value of its argument (the address of
    `x`). The value of `x` is 30 when the function call is made. Inside the `change_value`
    function, the parameter is dereferenced to assign the value 100 to the memory
    location pointed to by the parameter (`*input = 100;`, meaning “the location `input`
    points to gets the value 100”). Since the parameter stores the address of a local
    variable in the `main` function’s stack frame, through dereferencing the parameter,
    the value stored in the caller’s local variable can be changed. When the function
    returns, the argument’s value reflects the change made to it through the pointer
    parameter (the value of `x` in `main` was changed to 100 by the `change_value`
    function through its `input` parameter).
  prefs: []
  type: TYPE_NORMAL
- en: 2.4 Dynamic Memory Allocation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to pass-by-pointer parameters, programs commonly use pointer variables
    to dynamically allocate memory. Such *dynamic memory allocation* allows a C program
    to request more memory as it’s running, and a pointer variable stores the address
    of the dynamically allocated space. Programs often allocate memory dynamically
    to tailor the size of an array for a particular run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dynamic memory allocation grants flexibility to programs that:'
  prefs: []
  type: TYPE_NORMAL
- en: do not know the size of arrays or other data structures until runtime (e.g.,
    the size depends on user input)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: need to allow for a variety of input sizes (not just up to some fixed capacity)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: want to allocate exactly the size of data structures needed for a particular
    execution (don’t waste capacity)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: grow or shrink the sizes of memory allocated as the program runs, reallocating
    more space when needed and freeing up space when it’s no longer required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.4.1 Heap Memory
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Every byte of memory in a program’s memory space has an associated address.
    Everything the program needs to run is in its memory space, and different types
    of entities reside in different parts of a program’s memory space. For example,
    the *code* region contains the program’s instructions, global variables reside
    in the *data* region, local variables and parameters occupy the *stack*, and dynamically
    allocated memory comes from the *heap*. Because the stack and the heap grow at
    runtime (as functions are called and return and as dynamic memory is allocated
    and freed), they are typically far apart in a program’s address space to leave
    a large amount of space for each to grow into as the program runs.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically allocated memory occupies the heap memory region of a program’s
    address space (see [page 66](ch02.xhtml#lev1_10)). When a program dynamically
    requests memory at runtime, the heap provides a chunk of memory whose address
    must be assigned to a pointer variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-7](ch02.xhtml#ch2fig7) illustrates the parts of a running program’s
    memory with an example of a pointer variable (`ptr`) on the stack that stores
    the address of dynamically allocated heap memory (it points to heap memory).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/02fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: A pointer on the stack points to a block of memory that was allocated
    from the heap.*'
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to remember that heap memory is anonymous memory, where “anonymous”
    means that addresses in the heap are not bound to variable names. Declaring a
    named program variable allocates it on the stack or in the data part of program
    memory. A local or global pointer variable can store the address of an anonymous
    heap memory location (e.g., a local pointer variable on the stack can point to
    heap memory), and dereferencing such a pointer enables a program to store data
    in the heap.
  prefs: []
  type: TYPE_NORMAL
- en: 2.4.2 malloc and free
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*malloc* and *free* are functions in the standard C library (`stdlib`) that
    a program can call to allocate and deallocate memory in the *heap*. Heap memory
    must be explicitly allocated (malloc’ed) and deallocated (freed) by a C program.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To allocate heap memory, call `malloc`, passing in the total number of bytes
    of contiguous heap memory to allocate. Use the `sizeof` *operator* to compute
    the number of bytes to request. For example, to allocate space on the heap to
    store a single integer, a program could call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `malloc` function returns the base address of the allocated heap memory
    to the caller (or `NULL` if an error occurs). Here’s a full example program with
    a call to `malloc` to allocate heap space to store a single `int` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `malloc` function returns a `void *` type, which represents a generic pointer
    to a non-specified type (or to any type). When a program calls `malloc` and assigns
    the result to a pointer variable, the program associates the allocated memory
    with the type of the pointer variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes you may see calls to `malloc` that explicitly recast its return type
    from `void *` to match the type of the pointer variable. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `(int *)` before `malloc` tells the compiler that the `void *` type returned
    by `malloc` will be used as an `int *` in this call (it recasts the return type
    of `malloc` to an `int *`). We discuss type recasting and the `void *` type in
    more detail later in this chapter, on [page 126](ch02.xhtml#lev2_38).
  prefs: []
  type: TYPE_NORMAL
- en: 'A call to `malloc` fails if there is not enough free heap memory to satisfy
    the requested number of bytes to allocate. Usually, `malloc` failing indicates
    an error in the program such as passing `malloc` a very large request, passing
    a negative number of bytes, or calling `malloc` in an infinite loop and running
    out of heap memory. Because any call to `malloc` can fail, you should *always
    test its return value for* NULL (indicating `malloc` failed) before dereferencing
    the pointer value. Dereferencing a null pointer will cause your program to crash!
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: When a program no longer needs the heap memory it dynamically allocated with
    `malloc`, it should explicitly deallocate the memory by calling the `free` function.
    It’s also a good idea to set the pointer’s value to `NULL` after calling `free`,
    so that if an error in the program causes it to be accidentally dereferenced after
    the call to `free`, the program will crash rather than modify parts of heap memory
    that have been reallocated by subsequent calls to `malloc`. Such unintended memory
    references can result in undefined program behavior that is often very difficult
    to debug, whereas a null pointer dereference will fail immediately, making it
    a relatively easy bug to find and to fix.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 2.4.3 Dynamically Allocated Arrays and Strings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: C programmers often dynamically allocate memory to store arrays. A successful
    call to `malloc` allocates one contiguous chunk of heap memory of the requested
    size. It returns the address of the start of this chunk of memory to the caller,
    making the returned address value suitable for the base address of a dynamically
    allocated array in heap memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'To dynamically allocate space for an array of elements, pass `malloc` the total
    number of bytes in the desired array. That is, the program should request from
    `malloc` the total number of bytes in each array element times the number of elements
    in the array. Pass `malloc` an expression for the total number of bytes in the
    form of `sizeof(` <type>`) *` <number of elements>. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: After the calls to `malloc` in this example, the `int` pointer variable `arr`
    stores the base address of an array of 20 contiguous integer storage locations
    in heap memory, and the `c_arr` char pointer variable stores the base address
    of an array of 10 contiguous char storage locations in heap memory. [Figure 2-8](ch02.xhtml#ch2fig8)
    depicts what this might look like.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/02fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: A 20-element integer array and 10-element character array allocated
    on the heap*'
  prefs: []
  type: TYPE_NORMAL
- en: Note that while `malloc` returns a pointer to dynamically allocated space in
    heap memory, C programs store the pointer to heap locations on the stack. The
    pointer variables contain *only the base address* (the starting address) of the
    array storage space in the heap. Just like statically declared arrays, the memory
    locations for dynamically allocated arrays are in contiguous memory locations.
    While a single call to `malloc` results in a chunk of memory of the requested
    number of bytes being allocated, multiple calls to `malloc` *will not* result
    in heap addresses that are contiguous (on most systems). In the previous example,
    the `char` array elements and the `int` array elements may be at addresses that
    are far apart in the heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'After dynamically allocating heap space for an array, a program can access
    the array through the pointer variable. Because the pointer variable’s value represents
    the base address of the array in the heap, we can use the same syntax to access
    elements in dynamically allocated arrays as we use to access elements in statically
    declared arrays (see [page 44](ch01.xhtml#lev1_5)). Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It may not be obvious why the same syntax can be used for accessing elements
    in dynamically allocated arrays as is used in accessing elements in statically
    declared arrays. However, even though their types are different, the values of
    `s_array` and `d_array` both evaluate to the base address of the array in memory
    (see [Table 2-1](ch02.xhtml#ch2tab1)).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Comparison of Statically Allocated `s_array` and Dynamically
    Allocated `d_array`'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** | **Value** | **Type** |'
  prefs: []
  type: TYPE_TB
- en: '| `s_array` | base address of array in memory | (static) array of integers
    |'
  prefs: []
  type: TYPE_TB
- en: '| `d_array` | base address of array in memory | integer pointer (`int *`) |'
  prefs: []
  type: TYPE_TB
- en: 'Because the names of both variables evaluate to the base address of the array
    in memory (the address of the first element memory), the semantics of the `[i]`
    syntax following the name of the variable remain the same for both: `[i]` *dereferences
    the* int *storage location at offset* i *from the base address of the array in
    memory*—it’s accessing the `i`th element.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For most purposes, we recommend using the `[i]` syntax to access the elements
    of a dynamically allocated array. However, programs can also use the pointer dereferencing
    syntax (the `*` operator) to access array elements. For example, placing a `*`
    in front of a pointer that refers to a dynamically allocated array will dereference
    the pointer to access element 0 of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The “Arrays in C” section on [page 81](ch02.xhtml#lev1_13) describes arrays
    in more detail, and the “Pointer Arithmetic” section on [page 224](ch02.xhtml#lev2_39)
    discusses accessing array elements through pointer variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a program is finished using a dynamically allocated array, it should call
    `free` to deallocate the heap space. As mentioned earlier, we recommend setting
    the pointer to `NULL` after freeing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: HEAP MEMORY MANAGEMENT, MALLOC AND FREE
  prefs: []
  type: TYPE_NORMAL
- en: The C standard library implements `malloc` and `free`, which are the programming
    interface to its heap memory manager. When called, `malloc` needs to find a contiguous
    chunk of unallocated heap memory space that can satisfy the size of the request.
    The heap memory manager maintains a *free list* of unallocated *extents* of heap
    memory, where each extent specifies the start address and size of a contiguous
    unallocated chunk of heap space.
  prefs: []
  type: TYPE_NORMAL
- en: Initially, all of heap memory is empty, meaning that the free list has a single
    extent consisting of the entire heap region. After a program has made some calls
    to `malloc` and `free`, heap memory can become *fragmented*, meaning that there
    are chunks of free heap space interspersed with chunks of allocated heap space.
    The heap memory manager typically keeps lists of different ranges of sizes of
    heap space to enable fast searching for a free extent of a particular size. In
    addition, it implements one or more policies for choosing among multiple free
    extents that could be used to satisfy a request.
  prefs: []
  type: TYPE_NORMAL
- en: The `free` function may seem odd in that it only expects to receive the address
    of the heap space to free without needing the size of the heap space to free at
    that address. That’s because `malloc` not only allocates the requested memory
    bytes, but it also allocates a few additional bytes right before the allocated
    chunk to store a header structure. The header stores metadata about the allocated
    chunk of heap space, such as the size. As a result, a call to `free` only needs
    to pass the address of heap memory to free. The implementation of `free` can get
    the size of the memory to free from the header information that is in memory right
    before the address passed to `free`.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about heap memory management, see an OS textbook (for example,
    Chapter 17, “Free Space Management,” in *OS in Three Easy Pieces* covers these
    details).^([1](ch02.xhtml#fn2_1))
  prefs: []
  type: TYPE_NORMAL
- en: 2.4.4 Pointers to Heap Memory and Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When passing a dynamically allocated array to a function, the pointer variable
    argument’s *value* is passed to the function (i.e., the base address of the array
    in the heap is passed to the function). Thus, when passing either statically declared
    or dynamically allocated arrays to functions, the parameter gets exactly the same
    value—the base address of the array in memory. As a result, the same function
    can be used for statically and dynamically allocated arrays of the same type,
    and identical syntax can be used inside the function for accessing array elements.
    The parameter declarations `int *arr` and `int` `arr[]` are equivalent. However,
    by convention, the pointer syntax tends to be used for functions that may be called
    with dynamically allocated arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: At the point just before returning from the `init_array` function, the contents
    of memory will look like [Figure 2-9](ch02.xhtml#ch2fig9). Note that `main` only
    passes the base address of the array to `init_array`. The array’s large block
    of contiguous memory remains on the heap, but the function can access it by dereferencing
    the `arr` pointer parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/02fig09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-9: The contents of memory prior to returning from `init_array`. Both
    `main`’s `arr1` and `init_array`’s `arr` variable point to the same block of heap
    memory.*'
  prefs: []
  type: TYPE_NORMAL
- en: 2.5 Arrays in C
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In “Introduction to Arrays” on [page 44](ch01.xhtml#lev2_9), we introduced statically
    declared one-dimensional C arrays and discussed the semantics of passing arrays
    to functions. In “Dynamic Memory Allocation” on [page 136](ch02.xhtml#lev1_12),
    we introduced dynamically allocated one-dimensional arrays and discussed the semantics
    of passing them to functions.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we take a more in-depth look at arrays in C. We describe both
    statically and dynamically allocated arrays in more detail and discuss two-dimensional
    arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 2.5.1 Single-Dimensional Arrays
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Statically Allocated
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Before jumping into new content, we briefly summarize static arrays with an
    example. See “Introduction to Arrays” on [page 44](ch01.xhtml#lev2_9) for more
    detail on statically declared one-dimensional arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Statically declared arrays are allocated either on the stack (for local variables)
    or in the data region of memory (for global variables). A programmer can declare
    an array variable by specifying its type (the type stored at each index) and its
    total capacity (number of elements).
  prefs: []
  type: TYPE_NORMAL
- en: When passing an array to a function, C copies the value of the base address
    to the parameter. That is, both the parameter and the argument refer to the same
    memory locations—the parameter pointer points to the argument’s array elements
    in memory. As a result, modifying the values stored in the array through an array
    parameter modifies the values stored in the argument array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of static array declaration and use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Dynamically Allocated
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In “Dynamic Memory Allocation” on [page 74](ch02.xhtml#lev1_12), we introduced
    dynamically allocated one-dimensional arrays, including their access syntax and
    the syntax and semantics of passing dynamically allocated arrays to functions.
    Here, we present a short recap of that information with an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling the `malloc` function dynamically allocates an array on the heap at
    runtime. The address of the allocated heap space can be assigned to a global or
    local pointer variable, which then points to the first element of the array. To
    dynamically allocate space, pass `malloc` the total number of bytes to allocate
    for the array (using the `sizeof` operator to get the size of a specific type).
    A single call to `malloc` allocates a contiguous chunk of heap space of the requested
    size. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Array Memory Layout
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Whether an array is statically declared or dynamically allocated via a single
    call to `malloc`, array elements represent contiguous memory locations (addresses):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The location of element `i` is at an offset `i` from the base address of the
    array. The exact address of the `i`th element depends on the number of bytes of
    the type stored in the array. For example, consider the following array declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The addresses of their individual array elements might look something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `1230` is the base address of `iarray` and `1280` the base
    address of `carray`. Note that individual elements of each array are allocated
    to contiguous memory addresses: each element of `iarray` stores a four-byte `int`
    value, so its element addresses differ by four, and each element of `carray` stores
    a one-byte `char` value, so its addresses differ by one. There is no guarantee
    that the set of local variables are allocated to contiguous memory locations on
    the stack (hence, there could be a gap in the addresses between the end of `iarray`
    and the start of `carray`, as shown in this example).'
  prefs: []
  type: TYPE_NORMAL
- en: 2.5.2 Two-Dimensional Arrays
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: C supports multidimensional arrays, but we limit our discussion of multidimensional
    arrays to two-dimensional (2D) arrays, since 1D and 2D arrays are the most commonly
    used by C programmers.
  prefs: []
  type: TYPE_NORMAL
- en: Statically Allocated 2D Arrays
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To statically declare a multidimensional array variable, specify the size of
    each dimension. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here, `matrix` is a 2D array of `int` values with 50 rows and 100 columns, and
    `little` is a 2D array of `short` values with 10 rows and 10 columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access an individual element, indicate both the row and the column index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 2-10](ch02.xhtml#ch2fig10) illustrates the 2D array as a matrix of
    integer values, where a specific element in the 2D array is indexed by row and
    column index values.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/02fig10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-10: A two-dimensional array represented as a matrix. Accessing matrix[2][3]
    is like indexing into a grid at row 2 and column 3.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Programs often access the elements of a 2D array by iterating with nested loops.
    For example, the following nested loop initializes all elements in `matrix` to
    0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Two-Dimensional Array Parameters
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The same rules for passing one-dimensional array arguments to functions apply
    to passing two-dimensional array arguments: the parameter gets the value of the
    base address of the 2D array (`&arr[0][0]`). In other words, the parameter points
    to the argument’s array elements and therefore the function can change values
    stored in the passed array.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For multidimensional array parameters, you must indicate that the parameter
    is a multidimensional array, but you can leave the size of the first dimension
    unspecified (for good generic design). The sizes of other dimensions must be fully
    specified so that the compiler can generate the correct offsets into the array.
    Here’s a 2D example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Both the `matrix` and the `bigger` arrays can be passed as arguments to the
    `init_matrix` function because they have the same column dimension as the parameter
    definition.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The column dimension must be specified in the parameter definition of a 2D array
    so that the compiler can calculate the offset from the base address of the 2D
    array to the start of a particular row of elements. The offset calculation follows
    from the layout of 2D arrays in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Two-Dimensional Array Memory Layout
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Statically allocated 2D arrays are arranged in memory in *row-major order*,
    meaning that all of row 0’s elements come first, followed by all of row 1’s elements,
    and so on. For example, given the following declaration of a 2D array of integers
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: its layout in memory might look like [Figure 2-11](ch02.xhtml#ch2fig11).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/02fig11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-11: The layout of a two-dimensional array in row-major order*'
  prefs: []
  type: TYPE_NORMAL
- en: Note that all array elements are allocated to contiguous memory addresses. That
    is, the base address of the 2D array is the memory address of the `[0][0]` element
    (`&arr[0][0]`), and subsequent elements are stored contiguously in row-major order
    (e.g., the entirety of row 1 is followed immediately by the entirety of row 2,
    and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically Allocated 2D Arrays
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Dynamically allocated 2D arrays can be allocated in two ways. For an *N* ×
    *M* 2D array, either:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Make a single call to `malloc`, allocating one large chunk of heap space
    to store all *N* × *M* array elements.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Make multiple calls to `malloc`, allocating an array of arrays. First, allocate
    a 1D array of *N* pointers to the element type, with a 1D array of pointers for
    each row in the 2D array. Then, allocate *N* 1D arrays of size *M* to store the
    set of column values for each row in the 2D array. Assign the addresses of each
    of these *N* arrays to the elements of the first array of *N* pointers.
  prefs: []
  type: TYPE_NORMAL
- en: The variable declarations, allocation code, and array element access syntax
    differ depending on which of these two methods a programmer chooses to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Method 1: Memory-Efficient Allocation'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In this method, a single call to `malloc` allocates the total number of bytes
    needed to store the *N* × *M* array of values. This method has the benefit of
    being more memory efficient because the entire space for all *N* × *M* elements
    will be allocated at once, in contiguous memory locations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The call to `malloc` returns the starting address of the allocated space (the
    base address of the array), which (like a 1D array) should be stored in a pointer
    variable. In fact, there is no semantic difference between allocating a 1D or
    2D array using this method: the call to `malloc` returns the starting address
    of a contiguously allocated chunk of heap memory of the requested number of bytes.
    Because allocation of a 2D array using this method looks just like allocation
    for a 1D array, the programmer has to explicitly map 2D row and column indexing
    on top of this single chunk of heap memory space (the compiler has no implicit
    notion of rows or columns and thus cannot interpret double indexing syntax into
    this malloc’ed space).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example C code snippet that dynamically allocates a 2D array using
    method 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 2-12](ch02.xhtml#ch2fig12) shows an example of allocating a 2D array
    using this method and illustrates what memory might look like after the call to
    `malloc`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/02fig12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-12: The results of allocating a 2D array with a single call to `malloc`*'
  prefs: []
  type: TYPE_NORMAL
- en: Like 1D dynamically allocated arrays, the pointer variable for a 2D array is
    allocated on the stack. That pointer is then assigned the value returned by the
    call to `malloc`, which represents the base address of the contiguous chunk of
    *N* × *M* `int` storage locations in the heap memory.
  prefs: []
  type: TYPE_NORMAL
- en: Because this method uses a single chunk of malloc’ed space for the 2D array,
    the memory allocation is as efficient as possible (it only requires one call to
    `malloc` for the entire 2D array). It’s the more efficient way to access memory
    due to all elements being located close together in contiguous memory, with each
    access requiring only a single level of indirection from the pointer variable.
  prefs: []
  type: TYPE_NORMAL
- en: However, the C compiler does not know the difference between a 2D or 1D array
    allocation using this method. As a result, the double indexing syntax (`[i][j]`)
    of statically declared 2D arrays *cannot* be used when allocating a 2D array using
    this method. Instead, the programmer must explicitly compute the offset into the
    contiguous chunk of heap memory using a function of row and column index values
    (`[i*M + j]`, where `M` is the column dimension).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how a programmer would structure code to initialize all
    the elements of a 2D array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Method 1 (Single malloc) and Function Parameters
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The base address of an array of `int` types allocated via a single `malloc`
    is a pointer to an `int`, so it can be passed to a function with an (`int *`)
    parameter. Additionally, the function must be passed row and column dimensions
    so that it can correctly compute offsets into the 2D array. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Method 2: The Programmer-Friendly Way'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The second method for dynamically allocating a 2D array stores the array as
    an array of *N* 1D arrays (one 1D array per row). It requires *N* + 1 calls to
    `malloc`: one `malloc` for the array of row arrays, and one `malloc` for each
    of the *N* row’s column arrays. As a result, the element locations *within a row*
    are contiguous, but elements are not contiguous across rows of the 2D array. Allocation
    and element access are not as efficient as in method 1, and the type definitions
    for variables can be a bit more confusing. However, using this method, a programmer
    can use double indexing syntax to access individual elements of the 2D array (the
    first index is an index into the array of rows, the second index is an index into
    the array of column elements within that row).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of allocating a 2D array using method 2 (with the error
    detection and handling code removed for readability):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In this example, note the types of the variables and the sizes passed to the
    calls to `malloc`. To refer to the dynamically allocated 2D array, the programmer
    declares a variable (`two_d_array`) of type `int **` that will store the address
    of a dynamically allocated array of `int *` element values. Each element in `two_d_array`
    stores the address of a dynamically allocated array of `int` values (the type
    of `two_d_array[i]` is `int *`).
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-13](ch02.xhtml#ch2fig13) shows what memory might look like after
    the preceding example’s *N* + 1 calls to `malloc`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/02fig13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-13: The arrangement of memory after allocating a 2D array with N
    + 1 `malloc` calls*'
  prefs: []
  type: TYPE_NORMAL
- en: Note that when using this method, only the elements allocated as part of a single
    call to `malloc` are contiguous in memory. That is, elements within each row are
    contiguous, but elements from different rows (even neighboring rows) are not.
  prefs: []
  type: TYPE_NORMAL
- en: Once allocated, individual elements of the 2D array can be accessed using double-indexing
    notation. The first index specifies an element in the outer array of `int *` pointers
    (which row), and the second index specifies an element in the inner `int` array
    (which column within the row).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand how double indexing is evaluated, consider the type and value
    of the following parts of the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Method 2 (An Array of Arrays) and Function Parameters
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The array argument’s type is `int **` (a pointer to a pointer to an `int`),
    and the function parameter matches its argument’s type. Additionally, row and
    column sizes should be passed to the function. Because this is a different type
    from method 1, both array types cannot use a common function (they are not the
    same C type).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example function that takes a method 2 (array of arrays) 2D array
    as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the function implementation can use double-indexing syntax. Unlike statically
    declared 2D arrays, both the row and column dimensions need to be passed as parameters:
    the `rows` parameter specifies the bounds on the outermost array (the array of
    row arrays), and the `cols` parameter specifies the bounds on the inner arrays
    (the array column values for each row).'
  prefs: []
  type: TYPE_NORMAL
- en: 2.6 Strings and the String Library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous chapter, we introduced “Arrays and Strings” ([page 44](ch01.xhtml#lev1_5)).
    In this chapter, we discuss dynamically allocated C strings and their use with
    the C string library. We first give a brief overview of statically declared strings.
  prefs: []
  type: TYPE_NORMAL
- en: 2.6.1 C’s Support for Statically Allocated Strings (Arrays of char)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: C does not support a separate string type, but a string can be implemented in
    C programs using an array of `char` values that is terminated by a special null
    character value `’\0’`. The terminating null character identifies the end of the
    sequence of character values that make up a string. Not every character array
    is a C string, but every C string is an array of `char` values.
  prefs: []
  type: TYPE_NORMAL
- en: Because strings frequently appear in programs, C provides libraries with functions
    for manipulating strings. Programs that use the C string library need to include
    `string.h`. Most string library functions require the programmer to allocate space
    for the array of characters that the functions manipulate. When printing out the
    value of a string, use the `%s` placeholder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example program that uses strings and some string library functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 2.6.2 Dynamically Allocating Strings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Arrays of characters can be dynamically allocated (as discussed in “C’s Pointer
    Variables” on [page 66](ch02.xhtml#lev1_10) and “Arrays in C” on [page 81](ch02.xhtml#lev1_13)).
    When dynamically allocating space to store a string, it’s important to remember
    to allocate space in the array for the terminating `'\0'` character at the end
    of the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example program demonstrates static and dynamically allocated
    strings (note the value passed to `malloc`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '**Warning C STRING FUNCTIONS AND DESTINATION MEMORY**'
  prefs: []
  type: TYPE_NORMAL
- en: Many C string functions (notably `strcpy` and `strcat`) store their results
    by following a *destination* string pointer (`char *`) parameter and writing to
    the location it points to. Such functions assume that the destination contains
    enough memory to store the result. Thus, as a programmer, you must ensure that
    sufficient memory is available at the destination prior to calling these functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Failure to allocate enough memory will yield undefined results that range from
    program crashes to major security vulnerabilities (see “Real World: Buffer Overflow”
    on [page 362](ch07.xhtml#lev1_60)). For example, the following calls to `strcpy`
    and `strcat` demonstrate mistakes that novice C programmers often make:'
  prefs: []
  type: TYPE_NORMAL
- en: // Attempt to write a 12-byte string into a 5-character array.
  prefs: []
  type: TYPE_NORMAL
- en: char mystr[5];
  prefs: []
  type: TYPE_NORMAL
- en: strcpy(mystr, "hello world");
  prefs: []
  type: TYPE_NORMAL
- en: // Attempt to write to a string with a NULL destination.
  prefs: []
  type: TYPE_NORMAL
- en: char *mystr = NULL;
  prefs: []
  type: TYPE_NORMAL
- en: strcpy(mystr, "try again");
  prefs: []
  type: TYPE_NORMAL
- en: // Attempt to modify a read-only string literal.
  prefs: []
  type: TYPE_NORMAL
- en: char *mystr = "string literal value";
  prefs: []
  type: TYPE_NORMAL
- en: strcat(mystr, "string literals aren't writable");
  prefs: []
  type: TYPE_NORMAL
- en: 2.6.3 Libraries for Manipulating C Strings and Characters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: C provides several libraries with functions for manipulating strings and characters.
    The string library (`string.h`) is particularly useful when writing programs that
    use C strings. The `stdlib.h` and `stdio.h` libraries also contain functions for
    string manipulation, and the `ctype.h` library contains functions for manipulating
    individual character values.
  prefs: []
  type: TYPE_NORMAL
- en: When using C string library functions, it’s important to remember that most
    do not allocate space for the strings they manipulate, nor do they check that
    you pass in valid strings; your program must allocate space for the strings that
    the C string library will use. Furthermore, if the library function modifies the
    passed string, then the caller needs to ensure that the string is correctly formatted
    (i.e., that it has a terminating `’\0’` character at the end). Calling string
    library functions with bad array argument values will often cause a program to
    crash. The documentation (e.g., manual pages) for different library functions
    specifies whether the library function allocates space or if the caller is responsible
    for passing in allocated space to the library function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note CHAR[] AND CHAR * PARAMETERS AND CHAR * RETURN TYPE**'
  prefs: []
  type: TYPE_NORMAL
- en: Both statically declared and dynamically allocated arrays of characters can
    be passed to a `char *` parameter because the name of either type of variable
    evaluates to the base address of the array in memory. Declaring the parameter
    as type `char []` will also work for both statically and dynamically allocated
    argument values, but `char *` is more commonly used for specifying the type of
    string (array of `char`) parameters.
  prefs: []
  type: TYPE_NORMAL
- en: If a function returns a string (its return type is a `char *`), its return value
    can only be assigned to a variable whose type is also `char *`; it cannot be assigned
    to a statically allocated array variable. This restriction exists because the
    name of a statically declared array variable is not a valid *lvalue* (its base
    address in memory cannot be changed; see “Accessing Field Values” on [page 57](ch01.xhtml#lev2_15)),
    so it cannot be assigned a `char *` return value.
  prefs: []
  type: TYPE_NORMAL
- en: strlen, strcpy, strncpy
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The string library provides functions for copying strings and finding the length
    of a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `strcpy` function is unsafe to use in situations when the source string
    might be longer than the total capacity of the destination string. In this case,
    one should use `strncpy`. The size parameter stops `strncpy` from copying more
    than `size` characters from the `src` string into the `dst` string. When the length
    of the `src` string is greater than or equal to `size`, `strncpy` copies the first
    `size` characters from `src` to `dst` and does not add a null character to the
    end of the `dst`. As a result, the programmer should explicitly add a null character
    to the end of `dst` after calling `strncpy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some example uses of these functions in a program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: strcmp, strncmp
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The string library also provides a function to compare two strings. Comparing
    string variables using the `==` operator *does not* compare the characters in
    the strings—it compares only the base addresses of the two strings. For example,
    the expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: compares the base address of the `char` array in the heap pointed to by `d_str`
    to the base address of the `str char` array allocated on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compare the values of the strings, a programmer needs to either write code
    by hand to compare corresponding element values, or use the `strcmp` or `strncmp`
    functions from the string library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `strcmp` function compares strings character by character based on their
    *ASCII representation* (see “Notes” on [page 189](ch01.xhtml#lev1_8)). In other
    words, it compares the `char` values in corresponding positions of the two parameter
    arrays to produce the result of the string comparison, which occasionally yields
    unintuitive results. For example, the ASCII encoding for the `char` value `’a’`
    is *larger* than the encoding for the `char` value `’Z’`. Thus, `strcmp("aaa",
    "Zoo")` returns a positive value indicating that `"aaa"` is greater than `"Zoo"`,
    and a call to `strcmp("aaa", "zoo")` returns a negative value indicating that
    `"aaa"` is less than `"zoo"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some string comparison examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: strcat, strstr, strchr
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'String library functions can concatenate strings (note that it’s up to the
    caller to ensure that the destination string has enough space to store the result):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'It also provides functions for finding substrings or character values in strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some examples using these functions (we omit some error handling for
    the sake of readability):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Calls to `strchr` and `strstr` return the address of the first element in the
    parameter array with a matching character value or a matching substring value,
    respectively. This element address is the start of an array of `char` values terminated
    by a `’\0’` character. In other words, `ptr` points to the beginning of a substring
    inside another string. When printing the value of `ptr` as a string with `printf`,
    the character values starting at the index pointed to by `ptr` are printed, yielding
    the results listed in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: strtok, strtok_r
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The string library also provides functions that divide a string into tokens.
    A *token* refers to a subsequence of characters in a string separated by any number
    of delimiter characters of the programmer’s choosing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The `strtok` (or `strtok_r`) functions find individual tokens within a larger
    string. For example, setting `strtok`’s delimiters to the set of whitespace characters
    yields words in a string that originally contains an English sentence. That is,
    each word in the sentence is a token in the string.
  prefs: []
  type: TYPE_NORMAL
- en: Following is an example program that uses `strtok` to find individual words
    as the tokens in an input string.^([2](ch02.xhtml#fn2_2))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: sprintf
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The C `stdio` library also provides functions that manipulate C strings. Perhaps
    the most useful is the `sprintf` function, which “prints” into a string rather
    than printing output to a terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '`sprintf` initializes the contents of a string from values of various types.
    Its parameter `format` resembles those of `printf` and `scanf`. Here are some
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Functions for Individual Character Values
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The standard C library (`stdlib.h`) contains a set of functions for manipulating
    and testing individual `char` values, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some examples of their use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Functions to Convert Strings to Other Types
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`stdlib.h` also contains functions to convert between strings and other C types.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'For more information about these and other C library functions (including what
    they do, their parameter format, what they return, and which headers need to be
    included to use them), see their *man pages*.^([3](ch02.xhtml#fn2_3)) For example,
    to view the `strcpy` man page, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 2.7 C Structs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous chapter, we introduced C structures in “Structs” on [page 52](ch01.xhtml#lev1_6).
    In this chapter, we dive deeper into C structs, examine statically and dynamically
    allocated structs, and combine structs and pointers to create more complex data
    types and data structures.
  prefs: []
  type: TYPE_NORMAL
- en: We begin with a quick overview of statically declared structs. See the previous
    chapter for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 2.7.1 Review of the C struct Type
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A `struct` type represents a heterogeneous collection of data; it’s a mechanism
    for treating a set of different types as a single, coherent unit.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three steps to defining and using `struct` types in C programs:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Define a `struct` type that defines the field values and their types.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Declare variables of the `struct` type.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Use *dot notation* to access individual field values in the variable.
  prefs: []
  type: TYPE_NORMAL
- en: In C, structs are lvalues (they can appear on the left-hand side of an assignment
    statement; see “Accessing Field Values” on [page 57](ch01.xhtml#lev2_15)). The
    value of a `struct` variable is the contents of its memory (all of the bytes making
    up its field values). When calling functions with `struct` parameters, the value
    of the `struct` argument (a copy of all of the bytes of all of its fields) gets
    copied to the `struct` function parameter.
  prefs: []
  type: TYPE_NORMAL
- en: When programming with structs, and in particular when combining structs and
    arrays, it’s critical to carefully consider the type of every expression. Each
    field in a `struct` represents a specific type, and the syntax for accessing field
    values and the semantics of passing individual field values to functions follow
    those of their specific type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following full example program demonstrates defining a `struct` type, declaring
    variables of that type, accessing field values, and passing structs and individual
    field values to functions (we omit some error handling and comments for readability):'
  prefs: []
  type: TYPE_NORMAL
- en: struct_review.c
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'When run, the program produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: When working with structs, it’s particularly important to think about the types
    of the `struct` and its fields. For example, when passing a `struct` to a function,
    the parameter gets a copy of the `struct`’s value (a copy of all the bytes from
    the argument). Consequently, changes to the parameter’s field values *do not*
    change the argument’s value. This behavior is illustrated in the preceding program
    in the call to `checkID`, which modifies the parameter’s age field. The changes
    in `checkID` have no effect on the corresponding argument’s age field value.
  prefs: []
  type: TYPE_NORMAL
- en: When passing a field of a `struct` to a function, the semantics match the type
    of the field (the type of the function’s parameter). For example, in the call
    to `changeName`, the value of the `name` field (the base address of the `name`
    array inside the `student2` struct) gets copied to the parameter `old`, meaning
    that the parameter refers to the same set of array elements in memory as its argument.
    Thus, changing an element of the array in the function also changes the element’s
    value in the argument; the semantics of passing the `name` field match the type
    of the `name` field.
  prefs: []
  type: TYPE_NORMAL
- en: 2.7.2 Pointers and Structs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Just like other C types, programmers can declare a variable as a pointer to
    a user-defined `struct` type. The semantics of using a `struct` pointer variable
    resemble those of other pointer types such as `int *`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the `struct studentT` type introduced in the previous program example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'A programmer can declare variables of type `struct studentT` or `struct` `studentT
    *` (a pointer to a `struct studentT`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Note that the call to `malloc` initializes `sptr` to point to a dynamically
    allocated struct in heap memory. Using the `sizeof` operator to compute `malloc`’s
    size request (e.g., `sizeof(struct studentT)`) ensures that `malloc` allocates
    space for *all* of the field values in the struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access individual fields in a pointer to a `struct`, the pointer variable
    first needs to be *dereferenced*. Based on the rules for pointer dereferencing
    (see “C’s Pointer Variables” on [page 66](ch02.xhtml#lev1_10)), you may be tempted
    to access `struct` fields like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'However, because pointers to structs are so commonly used, C provides a special
    operator (`->`) that both dereferences a `struct` pointer and accesses one of
    its field values. For example, `sptr->year` is equivalent to `(*sptr).year`. Here
    are some examples of accessing field values using this notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 2-14](ch02.xhtml#ch2fig14) sketches what the variables `s` and `sptr`
    may look like in memory after the preceding code executes. Recall that `malloc`
    allocates memory from the heap, and local variables are allocated on the stack.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/02fig14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-14: The differences in memory layout between a statically allocated
    struct (data on the stack) and a dynamically allocated struct (data on the heap)*'
  prefs: []
  type: TYPE_NORMAL
- en: 2.7.3 Pointer Fields in Structs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Structs can also be defined to have pointer types as field values. Here’s an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: In memory, these variables will look like [Figure 2-15](ch02.xhtml#ch2fig15)
    (note which parts are allocated on the stack and which are on the heap).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/02fig15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-15: The layout in memory of a struct with a pointer field*'
  prefs: []
  type: TYPE_NORMAL
- en: As structs and the types of their fields increase in complexity, be careful
    with their syntax. To access field values appropriately, start from the outermost
    variable type and use its type syntax to access individual parts. For example,
    the types of the `struct` variables shown in [Table 2-2](ch02.xhtml#ch2tab2) govern
    how a programmer should access their fields.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-2:** Struct Field Access Examples'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** | **Type** | **Field access syntax** |'
  prefs: []
  type: TYPE_TB
- en: '| `p1` | `struct personT` | `p1.age, p1.name` |'
  prefs: []
  type: TYPE_TB
- en: '| `p2` | `struct personT *` | `p2->age, p2->name` |'
  prefs: []
  type: TYPE_TB
- en: Further, knowing the types of field values allows a program to use the correct
    syntax in accessing them, as shown by the examples in [Table 2-3](ch02.xhtml#ch2tab3).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-3:** Accessing Different Struct Field Types'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** | **Type** | **Example access syntax** |'
  prefs: []
  type: TYPE_TB
- en: '| `p1.age` | `int` | `p1.age = 18;` |'
  prefs: []
  type: TYPE_TB
- en: '| `p2->age` | `int *` | `p2->age = 18;` |'
  prefs: []
  type: TYPE_TB
- en: '| `p1.name` | `char *` | `printf("%s", p1.name);` |'
  prefs: []
  type: TYPE_TB
- en: '| `p2->name` | `char *` | `printf("%s", p2->name);` |'
  prefs: []
  type: TYPE_TB
- en: '| `p2->name[2]` | `char` | `p2->name[2] = ’a’;` |'
  prefs: []
  type: TYPE_TB
- en: 'In examining the last example, start by considering the type of the outermost
    variable (`p2` is a pointer to a `struct personT`). Therefore, to access a field
    value in the struct, the programmer needs to use `->` syntax (`p2->name`). Next,
    consider the type of the `name` field, which is a `char *`, used in this program
    to point to an array of `char` values. To access a specific `char` storage location
    through the `name` field, use array indexing notation: `p2->name[2] =` `’a’`.'
  prefs: []
  type: TYPE_NORMAL
- en: 2.7.4 Arrays of Structs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Arrays, pointers, and structs can be combined to create more complex data structures.
    Here are some examples of declaring variables of different types of arrays of
    structs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, thinking very carefully about variable and field types is necessary
    for understanding the syntax and semantics of using these variables in a program.
    Here are some examples of the correct syntax for accessing these variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'A function that takes an array of type `struct studentT *` as a parameter might
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'A program could pass this function either a statically or dynamically allocated
    array of `struct studentT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The semantics of passing `classroom1` (or `classroom2`) to `updateAges` match
    the semantics of passing a statically declared (or dynamically allocated) array
    to a function: the parameter refers to the same set of elements as the argument
    and thus changes to the array’s values within the function affect the argument’s
    elements.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-16](ch02.xhtml#ch2fig16) shows what the stack might look like for
    the second call to the `updateAges` function (showing the passed `classroom2`
    array with example field values for the struct in each of its elements).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/02fig16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-16: The memory layout of an array of `struct studentT` passed to
    a function*'
  prefs: []
  type: TYPE_NORMAL
- en: As always, the parameter gets a copy of the value of its argument (the memory
    address of the array in heap memory). Thus, modifying the array’s elements in
    the function will persist to its argument’s values (both the parameter and the
    argument refer to the same array in memory).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `updateAges` function cannot be passed the `classroom3` array because its
    type is not the same as the parameter’s type: `classroom3` is an array of `struct`
    `studentT *`, not an array of `struct studentT`.'
  prefs: []
  type: TYPE_NORMAL
- en: 2.7.5 Self-Referential Structs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A struct can be defined with fields whose type is a pointer to the same `struct`
    type. These self-referential `struct` types can be used to build linked implementations
    of data structures, such as linked lists, trees, and graphs.
  prefs: []
  type: TYPE_NORMAL
- en: The details of these data types and their linked implementations are beyond
    the scope of this book. However, we briefly show one example of how to define
    and use a self-referential `struct` type to create a linked list in C. Refer to
    a textbook on data structures and algorithms for more information about linked
    lists.
  prefs: []
  type: TYPE_NORMAL
- en: A *linked list* is one way to implement a *list abstract data type*. A list
    represents a sequence of elements that are ordered by their position in the list.
    In C, a list data structure could be implemented as an array or as a linked list
    using a self-referential `struct` type for storing individual nodes in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the latter, a programmer would define a `node` struct to contain one
    list element and a link to the next node in the list. Here’s an example that could
    store a linked list of integer values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Instances of this `struct` type can be linked together through the `next` field
    to create a linked list.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example code snippet creates a linked list containing three elements (the
    list itself is referred to by the `head` variable that points to the first node
    in the list):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `temp` variable temporarily points to a malloc’ed `node` that
    gets initialized and then added to the beginning of the list by setting its `next`
    field to point to the node currently pointed to by `head`, and then by changing
    the `head` to point to this new node.
  prefs: []
  type: TYPE_NORMAL
- en: The result of executing this code would look like [Figure 2-17](ch02.xhtml#ch2fig17)
    in memory.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/02fig17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-17: The layout in memory of three example linked list nodes*'
  prefs: []
  type: TYPE_NORMAL
- en: 2.8 I/O in C (Standard and File)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C supports many functions for performing standard I/O as well as file I/O. In
    this section, we discuss some of the most commonly used interfaces for I/O in
    C.
  prefs: []
  type: TYPE_NORMAL
- en: 2.8.1 Standard Input/Output
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Every running program begins with three default I/O streams: standard out (`stdout`),
    standard in (`stdin`), and standard error (`stderr`). A program can write (print)
    output to `stdout` and `stderr`, and it can read input values from `stdin`. `stdin`
    is usually defined to read in input from the keyboard, whereas `stdout` and `stderr`
    output to the terminal.'
  prefs: []
  type: TYPE_NORMAL
- en: The C `stdio.h` library provides the `printf` function used for printing to
    standard out and the `scanf` function that can be used to read in values from
    standard in. C also has functions to read and write one character at a time (`getchar`
    and `putchar`) as well as other functions and libraries for reading and writing
    characters to standard I/O streams. A C program must explicitly include `stdio.h`
    to call these functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can change the location that a running program’s `stdin`, `stdout` and/
    or `stderr` read from or write to. One way to do this is by redirecting one or
    all of these to read or write to a file. Here are some example shell commands
    for redirecting a program’s `stdin`, `stdout`, or `stderr` to a file (`$` is the
    shell prompt):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: printf
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'C’s `printf` function resembles formatted `print` calls in Python, where the
    caller specifies a format string to print. The format string often contains special
    format specifiers, including special characters that will print tabs (`\t`) or
    newlines (`\n`), or that specify placeholders for values in the output (`%` followed
    by a type specifier). When adding placeholders in a format string passed to `printf`,
    pass their corresponding values as additional arguments following the format string.
    Here are some example calls to `printf`:'
  prefs: []
  type: TYPE_NORMAL
- en: printf.c
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'When run, these `printf` statements output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Note how the tab characters (`\t`) get printed in the second call, and the different
    formatting placeholders for different types of values (`%g`, `%s`, and `%d`).
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a set of formatting placeholders for common C types. Note that placeholders
    for `long` and `long long` values include an `l` or `ll` prefix.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some examples of their use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'When run, the output will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'C also allows you to specify the field width with format placeholders. Here
    are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a larger example that uses field width specifiers with placeholders
    in the format string:'
  prefs: []
  type: TYPE_NORMAL
- en: printf_format.c
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'When run, the program output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Note how the use of tabs and field width in the last three `printf` statements
    result in a tabular output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, C defines placeholders for displaying values in different representations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example using placeholders to print values in different representations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'When run, the program output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: scanf
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `scanf` function provides one method for reading in values from `stdin`
    (usually from the user entering them via the keyboard) and storing them in program
    variables. The `scanf` function is a bit picky about the exact format in which
    the user enters data, which can make it sensitive to badly formed user input.
  prefs: []
  type: TYPE_NORMAL
- en: 'The arguments to the `scanf` function are similar to those of `printf`: `scanf`
    takes a format string that specifies the number and type of input values to read
    in, followed by the *locations* of program variables into which the values should
    be stored. Programs typically combine the *address of* (`&`) operator with a variable
    name to produce the location of the variable in the program’s memory—the memory
    address of the variable. Here’s an example call to `scanf` that reads in two values
    (an `int` and a `float`):'
  prefs: []
  type: TYPE_NORMAL
- en: scanf_ex.c
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Individual input values must be separated by at least one whitespace character
    (e.g., spaces, tabs, newlines). However, `scanf` skips over leading and trailing
    whitespace characters as it finds the start and end of each numeric literal value.
    As a result, a user could enter the value 8 and 3.14 with any amount of whitespace
    before or after the two values (and at least one or more whitespace characters
    between), and `scanf` will always read in 8 and assign it to `x` and read in 3.14
    and assign it to `pi`. For example, this input with lots of spaces between the
    two values will result in reading in 8 and storing it in `x`, and 3.14 and storing
    in `pi`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Programmers often write format strings for `scanf` that only consist of placeholder
    specifiers without any other characters between them. For reading in the two numbers
    in the preceding example, the format string might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: getchar and putchar
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The C functions `getchar` and `putchar` respectively read or write a single
    character value from `stdin` and to `stdout`. `getchar` is particularly useful
    in C programs that need to support careful error detection and handling of badly
    formed user input (`scanf` is not robust in this way).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 2.8.2 File Input/Output
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The C standard I/O library (`stdio.h`) includes a stream interface for file
    I/O. A *file* stores persistent data: data that lives beyond the execution of
    the program that created it. A text file represents a stream of characters, and
    each open file tracks its current position in the character stream. When opening
    a file, the current position starts at the very first character in the file, and
    it moves as a result of every character read (or written) to the file. To read
    the 10th character in a file, the first nine characters need to first be read
    (or the current position must be explicitly moved to the 10th character using
    the `fseek` function).'
  prefs: []
  type: TYPE_NORMAL
- en: C’s file interface views a file as an input or output stream, and library functions
    read from or write to the next position in the file stream. The `fprintf` and
    `fscanf` functions serve as the file I/O counterparts to `printf` and `scanf`.
    They use a format string to specify what to write or read, and they include arguments
    that provide values or storage for the data that gets written or read. Similarly,
    the library provides the `fputc`, `fgetc`, `fputs`, and `fgets` functions for
    reading and writing individual characters or strings to file streams. Although
    there are many libraries that support file I/O in C, we present only the `stdio.h`
    library’s stream interface to text files in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Text files may contain special chars like the `stdin` and `stdout` streams:
    newlines (`’\n’`), tabs (`’\t’`), etc. Additionally, upon reaching the end of
    a file’s data, C’s I/O library generates a special end-of-file character (`EOF`)
    that represents the end of the file. Functions reading from a file can test for
    `EOF` to determine when they have reached the end of the file stream.'
  prefs: []
  type: TYPE_NORMAL
- en: 2.8.3 Using Text Files in C
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To read or write a file in C, follow these steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, *declare* a `FILE *` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: These declarations create pointer variables to a library-defined `FILE` type.
    These pointers cannot be dereferenced in an application program. Instead, they
    refer to a specific file stream when passed to I/O library functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, *open* the file: associate the variable with an actual file stream
    by calling `fopen`. When opening a file, the *mode* parameter determines whether
    the program opens it for reading (`"r"`), writing (`"w"`), or appending (`"a"`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The `fopen` function returns `NULL` to report errors, which may occur if it’s
    given an invalid filename or the user doesn’t have permission to open the specified
    file (e.g., not having write permission to the `output.txt` file).
  prefs: []
  type: TYPE_NORMAL
- en: 'Third, *use* I/O operations to read, write, or move the current position in
    the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, *close* the file: use `fclose` to close the file when the program
    no longer needs it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The `stdio` library also provides functions to change the current position
    in a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 2.8.4 Standard and File I/O Functions in stdio.h
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The C `stdio.h` library has many functions for reading and writing to files
    and to the standard file-like streams (`stdin`, `stdout`, and `stderr`). These
    functions can be classified into character-based, string-based, and formatted
    I/O functions. Here’s some additional details about a subset of these functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: In general, `scanf` and `fscanf` are sensitive to badly formed input. However,
    for file I/O, often programmers can assume that an input file is well formatted,
    so `fscanf` may be robust enough in such cases. With `scanf`, badly formed user
    input will often cause a program to crash. Reading in one character at a time
    and including code to test values before converting them to different types is
    more robust, but it requires the programmer to implement more complex I/O functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The format string for `fscanf` can include the following syntax specifying
    different types of values and ways of reading from the file stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: It can be tricky to get the `fscanf` format string correct, particularly when
    reading a mix of numeric and string or character types from a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few example calls to `fscanf` (and one to `fprintf`) with different
    format strings (let’s assume that the `fopen` calls from the previous example
    have executed successfully):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: In the final example in the preceding code, the format string explicitly reads
    in a character value after a number to ensure that the file stream’s current position
    gets properly advanced for any subsequent calls to `fscanf`. For example, this
    pattern is often used to explicitly read in (and discard) a whitespace character
    (like *\n*), to ensure that the next call to `fscanf` begins from the next line
    in the file. Reading an additional character is necessary if the *next* call to
    `fscanf` attempts to read in a character value. Otherwise, having not consumed
    the newline, the next call to `fscanf` will read the newline rather than the intended
    character. If the next call reads in a numeric type value, then leading whitespace
    chars are automatically discarded by `fscanf` and the programmer does not need
    to explicitly read the `\n` character from the file stream.
  prefs: []
  type: TYPE_NORMAL
- en: 2.9 Some Advanced C Features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Almost all of the C programming language has been presented in previous sections.
    In this section, we cover a few remaining advanced C language features and some
    advanced C programming and compiling topics:'
  prefs: []
  type: TYPE_NORMAL
- en: the C `switch` statement ([page 122](ch02.xhtml#lev2_36))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: command line arguments ([page 125](ch02.xhtml#lev2_37))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the `void *` type and type recasting ([page 126](ch02.xhtml#lev2_38))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pointer arithmetic ([page 128](ch02.xhtml#lev2_39))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C libraries: using, compiling, and linking ([page 133](ch02.xhtml#lev2_40))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: writing and using your own C libraries (and dividing your program into multiple
    modules (`.c` and `.h` files); [page 139](ch02.xhtml#lev2_41))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: compiling C source to assembly code ([page 145](ch02.xhtml#lev2_42)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.9.1 switch Statements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The C `switch` statement can be used in place of some, but not all, chaining
    `if`–`else if` code sequences. While `switch` doesn’t provide any additional expressive
    power to the C programming language, it often yields more concise code branching
    sequences. It may also allow the compiler to produce branching code that executes
    more efficiently than equivalent chaining `if`–`else if` code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The C syntax for a `switch` statement looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'A switch statement is executed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. The <expression> evaluates first.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Next, the `switch` searches for a `case` literal value that matches the
    value of the expression.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Upon finding a matching `case` literal, it begins executing the <statements>
    that immediately follow it.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. If no matching `case` is found, it will begin executing the <statements>
    in the `default` label if one is present.
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Otherwise, no statements in the body of the `switch` statement get executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few rules about `switch` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: The value associated with each `case` must be a literal value—it *cannot* be
    an expression. The original expression gets matched for *equality* only with the
    literal values associated with each `case`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reaching a `break` statement stops the execution of all remaining statements
    inside the body of the `switch` statement. That is, `break` breaks out of the
    body of the `switch` statement and continues execution with the next statement
    after the entire `switch` block.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `case` statement with a matching value marks the starting point into the
    sequence of C statements that will be executed—execution jumps to a location inside
    the `switch` body to start executing code. Thus, if there is no `break` statement
    at the end of a particular `case`, then the statements under the subsequent `case`
    statements execute in order until either a `break` statement is executed or the
    end of the body of the `switch` statement is reached.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `default` label is optional. If present, it must be at the end.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s an example program with a `switch` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some example runs of this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 2.9.2 Command Line Arguments
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A program can be made more general purpose by reading command line arguments,
    which are included as part of the command entered by the user to run a binary
    executable program. They specify input values or options that change the runtime
    behavior of the program. In other words, running the program with different command
    line argument values results in a program’s behavior changing from run to run
    without having to modify the program code and recompile it. For example, if a
    program takes the name of an input filename as a command line argument, a user
    can run it with any input filename as opposed to a program that refers to a specific
    input filename in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any command line arguments the user provides get passed to the `main` function
    as parameter values. To write a program that takes command line arguments, the
    `main` function’s definition must include two parameters, `argc` and `argv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Note that the type of the second parameter could also be represented as `char`
    `**argv`.
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter, `argc`, stores the argument count. Its value represents
    the number of command line arguments passed to the main function (including the
    name of the program). For example, if the user enters
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: then `argc` will hold the value 4 (`a.out` counts as the first command line
    argument, and `10`, `11`, and `200` as the other three).
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter, `argv`, stores the argument vector. It contains the value
    of each command line argument. Each command line argument gets passed in as a
    string value, thus `argv`’s type is an array of strings (or an array of `char`
    arrays). The `argv` array contains `argc + 1` elements. The first `argc` elements
    store the command line argument strings, and the last element stores `NULL`, signifying
    the end of the command line argument list. For example, in the command line entered
    in the previous example, the `argv` array would look like [Figure 2-18](ch02.xhtml#ch2fig18).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/02fig18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-18: The `argv` parameter passed to `main` is an array of strings.
    Each command line argument is passed as a separate string element in the array.
    The value of the last element is `NULL`, signifying the end of the list of command
    line arguments.*'
  prefs: []
  type: TYPE_NORMAL
- en: The strings in an `argv` array are *immutable*, meaning that they are stored
    in read-only memory. As a result, if a program wants to modify the value of one
    of its command line arguments, it needs to make a local copy of the command line
    argument and modify the copy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, a program wants to interpret a command line argument passed to `main`
    as a type other than a string. In the previous example, the program may want to
    extract the integer value `10` from the string value `"10"` of its first command
    line argument. C’s standard library provides functions for converting strings
    to other types. For example, the `atoi` (“a to i,” for “ASCII to integer”) function
    converts a string of digit characters to its corresponding integer value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: See “Functions to Convert Strings to Other Types” on [page 103](ch02.xhtml#lev3_25)
    for more information about these functions, and the `commandlineargs.c` program^([4](ch02.xhtml#fn2_4))
    for another example of C command line arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 2.9.3 The void * Type and Type Recasting
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The C type `void *` represents a generic pointer—a pointer to any type, or
    a pointer to an unspecified type. C allows for a generic pointer type because
    memory addresses on a system are always stored in the same number of bytes (e.g.,
    addresses are four bytes on 32-bit systems and eight bytes on 64-bit systems).
    As a result, every pointer variable requires the same number of storage bytes,
    and because they’re all the same size, the compiler can allocate space for a `void
    *` variable without knowing the type it points to. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Typically, programmers do not declare variables of type `void *` as in the preceding
    example. Instead, it’s commonly used to specify generic return types from functions
    or generic parameters to functions. The `void *` type is often used as a return
    type by functions that return newly allocated memory that can be used to store
    any type (e.g., `malloc`). It’s also used as a function parameter for functions
    that can take any type of value. In this case, individual calls to the function
    pass in a pointer to some specific type, which can be passed to the function’s
    `void *` parameter because it can store the address of any type.
  prefs: []
  type: TYPE_NORMAL
- en: Because `void *` is a generic pointer type, it cannot be directly dereferenced—the
    compiler does not know the size of memory that the address points to. For example,
    the address could refer to an `int` storage location of four bytes or it could
    refer to a `char` storage location in memory of one byte. Therefore, the programmer
    must explicitly *recast* the `void *` pointer to a pointer of a specific type
    before dereferencing it. Recasting tells the compiler the specific type of pointer
    variable, allowing the compiler to generate the correct memory access code for
    pointer dereferences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are two examples of `void *` use. First, a call to `malloc` recasts its
    `void` `*` return type to the specific pointer type of the variable used to store
    its returned heap memory address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, students often encounter the `void *` when creating threads (see “Hello
    Threading! Writing Your First Multithreaded Program” on [page 677](ch14.xhtml#lev1_106)).
    Using a `void *` parameter type in a thread function allows the thread to take
    any type of application-specific pointer. The `pthread_create` function has a
    parameter for the thread main function and a `void *` parameter for the argument
    value that it passes to the thread main function that the newly created thread
    will execute. The use of the `void *` parameter makes `pthread_create` a generic
    thread creation function; it can be used to point to any type of memory location.
    For a specific program that calls `pthread_create`, the programmer knows the type
    of the argument passed to the `void *` parameter, so the programmer must recast
    it to its known type before dereferencing it. In this example, suppose that the
    address passed to the `args` parameter contains the address of an integer variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 2.9.4 Pointer Arithmetic
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If a pointer variable points to an array, a program can perform arithmetic
    on the pointer to access any of the array’s elements. In most cases, we recommend
    against using pointer arithmetic to access array elements: it’s easy to make errors
    and more difficult to debug when you do. However, occasionally it may be convenient
    to successively increment a pointer to iterate over an array of elements.'
  prefs: []
  type: TYPE_NORMAL
- en: When incremented, a pointer points to the next storage location *of the type
    it points to*. For example, incrementing an integer pointer (`int *`) makes it
    point to the next `int` storage address (the address four bytes beyond its current
    value), and incrementing a character pointer makes it point to the next `char`
    storage address (the address one byte beyond its current value).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example program, we demonstrate how to use pointer arithmetic
    to manipulate an array. First declare pointer variables whose type matches the
    array’s element type:'
  prefs: []
  type: TYPE_NORMAL
- en: pointerarith.c
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, initialize the pointer variables to the base address of the arrays over
    which they will iterate:'
  prefs: []
  type: TYPE_NORMAL
- en: pointerarith.c
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, using pointer dereferencing, our program can access the array’s elements.
    Here, we’re dereferencing to assign a value to an array element and then incrementing
    the pointer variable by one to advance it to point to the next element:'
  prefs: []
  type: TYPE_NORMAL
- en: pointerarith.c
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Note that in this example, the pointer values are incremented inside the loop.
    Thus, incrementing their value makes them point to the next element in the array.
    This pattern effectively walks through each element of an array in the same way
    that accessing `cptr[i]` or `iptr[i]` at each iteration would.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note THE SEMANTICS OF POINTER ARITHMETIC AND THE UNDERLYING ARITHMETIC FUNCTION**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The semantics of pointer arithmetic are type independent: changing any type
    of pointer’s value by `N` (`ptr = ptr + N`) makes the pointer point `N` storage
    locations beyond its current value (or makes it point to `N` elements beyond the
    current element it points to). As a result, incrementing a pointer of any type
    makes it point to the very next memory location of the type it points to.'
  prefs: []
  type: TYPE_NORMAL
- en: However, the actual arithmetic function that the compiler generates for a pointer
    arithmetic expression varies depending on the type of the pointer variable (depending
    on the number of bytes the system uses to store the type to which it points).
    For example, incrementing a `char` pointer will increase its value by one because
    the very next valid `char` address is one byte from the current location. Incrementing
    an `int` pointer will increase its value by four because the next valid integer
    address is four bytes from the current location.
  prefs: []
  type: TYPE_NORMAL
- en: A programmer can simply write `ptr++` to make a pointer point to the next element
    value. The compiler generates code to add the appropriate number of bytes for
    the corresponding type it points to. The addition effectively sets its value to
    the next valid address in memory of that type.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see how the previous code modified array elements by printing out their
    values (we show this first using array indexing and then using pointer arithmetic
    to access each array element’s value):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s what the output looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Pointer arithmetic can be used to iterate over any contiguous chunk of memory.
    Here’s an example using pointer arithmetic to initialize a statically declared
    2D array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Pointer arithmetic can access contiguous memory locations in any pattern, starting
    and ending anywhere in a contiguous chunk of memory. For example, after initializing
    a pointer to the address of an array element, its value can be changed by more
    than one. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'After executing the preceding code, printing the `numbers` array’s values would
    look like this (note that the values at index 2 and index 6 have changed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Pointer arithmetic works on dynamically allocated arrays, too. However, programmers
    must be careful working with dynamically allocated multidimensional arrays. If,
    for example, a program uses multiple `malloc` calls to dynamically allocate individual
    rows of a 2D array (see “Method 2: The Programmer-Friendly Way” on [page 90](ch02.xhtml#lev3_17)),
    then the pointer must be reset to point to the address of the starting element
    of every row. Resetting the pointer is necessary because only elements within
    a row are located in contiguous memory addresses. On the other hand, if the 2D
    array is allocated as a single `malloc` of total rows times columns space (see
    “Method 1: Memory-Efficient Allocation” on [page 88](ch02.xhtml#lev3_15)), then
    all the rows are in contiguous memory (like in the statically declared 2D array
    from the previous example). In the latter case, the pointer only needs to be initialized
    to point to the base address, and then pointer arithmetic will correctly access
    any element in the 2D array.'
  prefs: []
  type: TYPE_NORMAL
- en: '2.9.5 C Libraries: Using, Compiling, and Linking'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A *library* implements a collection of functions and definitions that can be
    used by other programs. A C library consists of two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The *application programming interface* (API) to the library, which gets defined
    in one or more header files (`.h` files) that must be included in C source code
    files that plan to use the library. The headers define what the library exports
    to its users. These definitions usually include library function prototypes, and
    they may also include type, constant, or global variable declarations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *implementation* of the library’s functionality, often made available to
    programs in a precompiled binary format that gets *linked* (added) into the binary
    executable created by `gcc`. Precompiled library code might be in an archive file
    (`libsomelib.a`) containing several `.o` files that can be statically linked into
    the executable file at compile time. Alternatively, it may consist of a shared
    object file (`libsomelib.so`) that can be dynamically linked at runtime into a
    running program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, the C string library implements a set of functions to manipulate
    C strings. The `string.h` header file defines its interface, so any program that
    wants to use string library functions must `#include <string.h>`. The implementation
    of the C string library is part of the larger standard C library (`libc`) that
    the `gcc` compiler automatically links into every executable file it creates.
  prefs: []
  type: TYPE_NORMAL
- en: A library’s implementation consists of one or more modules (`.c` files), and
    may additionally include header files that are internal to the library implementation;
    internal header files are not part of the library’s API but are part of well-designed,
    modular library code. Often the C source code implementation of a library is not
    exported to the user of the library. Instead, the library is made available in
    a precompiled binary form. These binary formats are not executable programs (they
    cannot be run on their own), but they provide executable code that can be *linked*
    into (added into) an executable file by `gcc` at compilation time.
  prefs: []
  type: TYPE_NORMAL
- en: There are numerous libraries available for C programmers to use. For example,
    the POSIX thread library (discussed in [Chapter 10](ch10.xhtml#ch10)) enables
    multithreaded C programs. C programmers can also implement and use their own libraries
    (see “Writing and Using Your Own C Libraries” on [page 133](ch02.xhtml#lev2_41)).
    Large C programs tend to use many C libraries, some of which `gcc` links implicitly,
    whereas others require explicit linking with the `-l` command line option to `gcc`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Standard C libraries normally do not need to be explicitly linked in with the
    `-l` option, but other libraries do. The documentation for a library function
    often specifies whether the library needs to be explicitly linked in when compiling.
    For example, the POSIX threads library (`pthread`) and the `readline` library
    require explicit linking on the `gcc` command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the full name of the library file should not be included in the `-l`
    argument to `gcc`; the library files are named something like `libpthread.so`
    or `libreadline.a`, but the `lib` prefix and `.so` or `.a` suffix of the filenames
    are not included. The actual library filename may also contain version numbers
    (e.g., `libreadline.so.8.0`), which are also not included in the `-l` command
    line option (`-lreadline`). By not forcing the user to specify (or even know)
    the exact name and location of the library files to link in, `gcc` is free to
    find the most recent version of a library in a user’s library path. It also allows
    the compiler to choose to dynamically link when both a shared object (`.so`) and
    an archive (`.a`) version of a library are available. If users want to statically
    link libraries, then they can explicitly specify static linking in the `gcc` command
    line. The `--static` option provides one method for requesting static linking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Compilation Steps
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Characterizing C’s program compilation steps will help to illustrate how library
    code gets linked into an executable binary file. We first present the compilation
    steps and then discuss (with examples) different types of errors that can occur
    when compiling programs that use libraries.
  prefs: []
  type: TYPE_NORMAL
- en: The C compiler translates a C source file (e.g., `myprog.c`) into an executable
    binary file (e.g., `a.out`) in four distinct steps (plus a fifth step that occurs
    at runtime).
  prefs: []
  type: TYPE_NORMAL
- en: 'The *precompiler* step runs first and expands *preprocessor directives*: the
    `#` directives that appear in the C program, such as `#define` and `#include`.
    Compilation errors at this step include syntax errors in preprocessor directives
    or `gcc` not finding header files associated with `#include` directives. To view
    the intermediate results of the precompiler step, pass the `-E` flag to `gcc`
    (the output can be redirected to a file that can be viewed by a text editor):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'The *compile* step runs next and does the bulk of the compilation task. It
    translates the C program source code (`myprog.c`) to machine-specific assembly
    code (`myprog.s`). Assembly code is a human-readable form of the binary machine
    code instructions that a computer can execute. Compilation errors at this step
    include C language syntax errors, undefined symbol warnings, and errors from missing
    definitions and function prototypes. To view the intermediate results of the compile
    step, pass the `-S` flag to `gcc` (this option creates a text file named `myprog.s`
    with the assembly translation of `myprog.c`, which can be viewed in a text editor):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'The *assembly* step converts the assembly code into relocatable binary object
    code (`myprog.o`). The resulting object file contains machine code instructions,
    but it is not a complete executable program that can run on its own. The `gcc`
    compiler on Unix and Linux systems produces binary files in a specific format
    called ELF (Executable and Linkable Format).^([5](ch02.xhtml#fn2_5)) To stop compilation
    after this step, pass the `-c` flag to `gcc` (this produces a file named `myprog.o`).
    Binary files (e.g., `a.out` and `.o` files) can be viewed using `objdump` or similar
    tools for displaying binary files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'The *link editing* step runs last and creates a single executable file (`a.out`)
    from relocatable binaries (`.o`) and libraries (`.a` or `.so`). In this step,
    the linker verifies that any references to names (symbols) in a `.o` file are
    present in other `.o`, `.a`, or `.so` files. For example, the linker will find
    the `printf` function in the standard C library (`libc.so`). If the linker cannot
    find the definition of a symbol, this step fails with an error stating that a
    symbol is undefined. Running `gcc` without flags for partial compilation performs
    all four steps of compiling a C source code file (`myprog.c`) to an executable
    binary file (`a.out`) that can be run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: If the binary executable file (`a.out`) statically links in library code (from
    `.a` library files), then `gcc` embeds copies of library functions from the `.a`
    file in the resulting `a.out` file. All calls to library functions by the application
    are *bound* to the locations in the `a.out` file to which the library function
    is copied. Binding associates a name with a location in the program memory. For
    example, binding a call to a library function named `gofish` means replacing the
    use of the function name with the address in memory of the function (in later
    chapters we discuss memory addresses in more detail—see, for example, “Memory
    Addresses” on [page 642](ch13.xhtml#lev2_227)).
  prefs: []
  type: TYPE_NORMAL
- en: If, however, the `a.out` was created by dynamically linking a library (from
    library shared object, `.so`, files), then `a.out` does not contain a copy of
    the library function code from these libraries. Instead, it contains information
    about which dynamically linked libraries are needed by the `a.out` file to run
    it. Such executables require an additional linking step at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The *runtime linking* step is needed if `a.out` was linked with shared object
    files during link editing. In such cases, the dynamic library code (in `.so` files)
    must be loaded at runtime and linked with the running program. This runtime loading
    and linking of shared object libraries is called *dynamic linking*. When a user
    runs an `a.out` executable with shared object dependencies, the system performs
    dynamic linking before the program begins executing its `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler adds information about shared object dependencies into the `a.out`
    file during the link editing compilation step. When the program starts executing,
    the dynamic linker examines the list of shared object dependencies and finds and
    loads the shared object files into the running program. It then updates relocation
    table entries in the `a.out` file, binding the program’s use of symbols in shared
    objects (such as calls to library functions) to their locations in the `.so` file
    loaded at runtime. Runtime linking reports errors if the dynamic linker cannot
    find a shared object (`.so`) file needed by the executable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ldd` utility lists an executable file’s shared object dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: The *GNU debugger (GDB)* can examine a running program and show which shared
    object code is loaded and linked at runtime. We cover GDB in [Chapter 3](ch03.xhtml#ch03).
    However, the details of examining the Procedure Lookup Table (PLT), which is used
    for runtime linking of calls to dynamically linked library functions, is beyond
    the scope of this textbook.
  prefs: []
  type: TYPE_NORMAL
- en: More details about the phases of compilation and about tools for examining different
    phases can be found online.^([6](ch02.xhtml#fn2_6))
  prefs: []
  type: TYPE_NORMAL
- en: Common Compilation Errors Related to Compiling and Linking Libraries
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Several compilation and linking errors can occur due to the programmer forgetting
    to include library header files or forgetting to explicitly link in library code.
    Identifying the `gcc` compiler error or warning associated with each of these
    errors will help in debugging errors related to using C libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this next C program that makes a call to a function `libraryfunc`
    from the `examplelib` library (available as a shared object file, `libmylib.so`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Assume that the header file, `examplelib.h`, contains the definitions in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: The `extern` prefix to the function prototype means that the function’s definition
    comes from another file—it’s not in the `examplelib.h` file, but instead it’s
    provided by one of the `.c` files in the library’s implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Forgetting to include a header file.** If the programmer forgets to include
    `examplelib.h` in their program, then the compiler produces warnings and errors
    about the program’s use of library functions and constants that it does not know
    about. For example, if the user compiles their program without `#include <examplelib.h>`,
    `gcc` will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: The first compiler warning (`implicit declaration of function` `libraryfunc`)
    tells the programmer that the compiler cannot find a function prototype for the
    `libraryfunc` function. This is just a compiler warning because `gcc` will guess
    that the function’s return type is an integer and will continue compiling the
    program. However, programmers should *not* ignore such warnings! They indicate
    that the program isn’t including a function prototype before its use in the `myprog.c`
    file, which is often due to not including a header file that contains the function
    prototype.
  prefs: []
  type: TYPE_NORMAL
- en: The second compiler error (`MAX undeclared (first use in this` `function)`)
    follows from a missing constant definition. The compiler cannot guess at the value
    of the missing constant, so this missing definition fails with an error. This
    type of “undeclared” message often indicates that a header file defining a constant
    or global variable is missing or hasn’t been properly included.
  prefs: []
  type: TYPE_NORMAL
- en: '**Forgetting to link a library.** If the programmer includes the library header
    file (as shown in the previous listing), but forgets to explicitly link in the
    library during the link editing step of compilation, then `gcc` indicates this
    with an “undefined reference” error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'This error originates from `ld`, the linker component of the compiler. It indicates
    that the linker cannot find the implementation of the library function `libraryfunc`
    that gets called at line 9 in `myprog.c`. An “undefined reference” error indicates
    that a library needs to be explicitly linked into the executable. In this example,
    specifying `-lexamplelib` on the `gcc` command line will fix the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '**gcc can’t find header or library files.** Compilation will also fail with
    errors if a library’s header or implementation files are not present in the directories
    that `gcc` searches by default. For example, if `gcc` cannot find the `examplelib.h`
    file, it will produce an error message like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'If the linker cannot find a `.a` or `.so` version of the library to link in
    during the link editing step of compilation, `gcc` will exit with an error like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, if a dynamically linked executable cannot locate a shared object
    file (e.g., `libexamplelib.so`), it will fail to execute at runtime with an error
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: To resolve these types of errors, programmers must specify additional options
    to `gcc` to indicate where the library’s files can be found. They may also need
    to modify the `LD_LIBRARY_PATH` environment variable for the runtime linker to
    find a library’s `.so` file.
  prefs: []
  type: TYPE_NORMAL
- en: Library and Include Paths
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The compiler automatically searches in standard directory locations for header
    and library files. For example, systems commonly store standard header files in
    `/usr/include`, and library files in `/usr/lib`, and `gcc` automatically looks
    for headers and libraries in these directories; `gcc` also automatically searches
    for header files in the current working directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `gcc` cannot find a header or a library file, then the user must explicitly
    provide paths on the command line using `-I` and `-L`. For example, suppose that
    a library named `libexamplelib.so` exists in `/home/me/lib`, and its header file
    `examplelib.h` is in `/home/me/include`. Because `gcc` knows nothing of those
    paths by default, it must be explicitly told to include files there to successfully
    compile a program that uses this library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'To specify the location of a dynamic library (e.g., `libexamplelib.so`) when
    launching a dynamically linked executable, set the `LD_LIBRARY_PATH` environment
    variable to include the path to the library. Here’s an example bash command that
    can be run at a shell prompt or added to a `.bashrc` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: When the `gcc` command lines get long, or when an executable requires many source
    and header files, it helps to simplify compilation by using `make` and a `Makefile`.^([7](ch02.xhtml#fn2_7))
  prefs: []
  type: TYPE_NORMAL
- en: 2.9.6 Writing and Using Your Own C Libraries
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Programmers typically divide large C programs into separate *modules* (i.e.,
    separate `.c` files) of related functionality. Definitions shared by more than
    one module are put in header files (`.h` files) that are included by the modules
    that need them. Similarly, C library code is also implemented in one or more modules
    (`.c` files) and one or more header files (`.h` files). C programmers often implement
    their own C libraries of commonly used functionality. By writing a library, a
    programmer implements the functionality once, in the library, and then can use
    this functionality in any subsequent C program that they write.
  prefs: []
  type: TYPE_NORMAL
- en: 'In “C Libraries: Using, Compiling, and Linking” on [page 133](ch02.xhtml#lev2_40),
    we describe how to use, compile, and link C library code into C programs. In this
    section, we discuss how to write and use your own libraries in C. What we present
    here also applies to structuring and compiling larger C programs composed of multiple
    C source and header files.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a library in C:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Define an interface to the library in a header (`.h`) file. This header
    file must be included by any program that wants to use the library.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Create an implementation of the library in one or more `.c` files. This
    set of function definitions implement the library’s functionality. Some functions
    may be interface functions that users of the library will call, and others may
    be internal functions that cannot be called by users of the library (internal
    functions are part of good modular design of the library’s implementation).
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Compile a binary form of the library that can be linked into programs that
    use the library.
  prefs: []
  type: TYPE_NORMAL
- en: The binary form of a library could be directly built from its source file(s)
    as part of compiling the application code that uses the library. This method compiles
    the library files into `.o` files and statically links them into the binary executable.
    Including libraries this way often applies to library code that you write for
    your own use (since you have access to its `.c` source files), and it’s also the
    method to build an executable from multiple `.c` modules.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, a library could be compiled into a binary archive (`.a`) or a
    shared object (`.so`) file for programs that want to use the library. In these
    cases, users of the library often will not have access to the library’s C source
    code files, and thus they are not able to directly compile the library code with
    application code that uses it. When a program uses such a precompiled library
    (e.g., a `.a` or `.so`), the library’s code must be explicitly linked into the
    executable file using `gcc`’s `-l` command line option.
  prefs: []
  type: TYPE_NORMAL
- en: We focus our detailed discussion of writing, compiling, and linking library
    code on the case in which the programmer has access to individual library modules
    (either the `.c` or `.o` files). This focus also applies to designing and compiling
    large C programs that are divided into multiple `.c` and `.h` files. We briefly
    show commands for building archive and shared object forms of libraries. More
    information about building these types of library files is available in the `gcc`
    documentation, including the man pages for `gcc` and `ar`.
  prefs: []
  type: TYPE_NORMAL
- en: In the following, we show some examples of creating and using your own libraries.
  prefs: []
  type: TYPE_NORMAL
- en: '**Define the library interface** Header files (`.h` file) are text files that
    contain C function prototypes and other definitions—they represent the interface
    of a library. A header file must be included in any application that intends to
    use the library. For example, the C standard library header files are usually
    stored in `/usr/include/` and can be viewed with an editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an example header file^([8](ch02.xhtml#fn2_8)) from a library that contains
    some definitions for users of the library:'
  prefs: []
  type: TYPE_NORMAL
- en: myfile.h
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Header files typically have special “boilerplate” code around their contents.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: This boilerplate code ensures that the compiler’s preprocessor only includes
    the contents of `mylib.h` exactly once in any C file that includes it. It is important
    to include `.h` file contents only once to avoid duplicate definition errors at
    compile time. Similarly, if you forget to include a `.h` file in a C program that
    uses the library, the compiler will generate an “undefined symbol” warning.
  prefs: []
  type: TYPE_NORMAL
- en: The comments in the `.h` file are part of the interface to the library, written
    for users of the library. These comments should be verbose, explaining definitions
    and describing what each library function does, what parameter values it takes,
    and what it returns. Sometimes a `.h` file will also include a top-level comment
    describing how to use the library.
  prefs: []
  type: TYPE_NORMAL
- en: The keyword `extern` before the global variable definition and function prototype
    means that these names are defined somewhere else. It is particularly important
    to include `extern` before any global variables that the library exports, as it
    distinguishes a name and type definition (in the `.h` file) from a variable declaration
    in the library’s implementation. In the previous example, the global variable
    is declared exactly once inside the library, but it’s exported to library users
    through its `extern` definition in the library’s `.h` file.
  prefs: []
  type: TYPE_NORMAL
- en: '**Implement the library functionality.** Programmers implement libraries in
    one or more `.c` files (and sometimes internal `.h` files). The implementation
    includes definitions of all the function prototypes in the `.h` file as well as
    other functions that are internal to its implementation. These internal functions
    are often defined with the keyword `static`, which scopes their availability to
    the module (`.c` file) in which they are defined. The library implementation should
    also include variable definitions for any `extern` global variable declarations
    in the `.h` file. Here’s an example library implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: mylib.c
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '**Create a binary form of the library.** To create a binary form of the library
    (a `.o` file), compile with the `-c` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'One or more `.o` files can build an archive (`.a`) or shared object (`.so`)
    version of the library. To build a static library use the archiver (`ar`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'To build a dynamically linked library, the `mylib.o` object file(s) in the
    library must be built with *position independent code* (using `-fPIC`). A `libmylib.so`
    shared object file can be created from `mylib.o` by specifying the `-shared` flag
    to `gcc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Shared object and archive libraries are often built from multiple `.o` files,
    for example (remember that `.o` for dynamically linked libraries need to be built
    using the `-fPIC` flag):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '**Use and link the library.** Other `.c` files that use this library should
    `#include` its header file, and the implementation (`.o` file) should be explicitly
    linked during compilation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After including the library header file, your code then can call the library’s
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: myprog.c
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '**Note #INCLUDE SYNTAX AND THE PREPROCESSOR**'
  prefs: []
  type: TYPE_NORMAL
- en: The `#include` syntax to include `mylib.h` is different from the syntax to include
    `stdio.h`. This is because `mylib.h` is not located with the header files from
    standard libraries. The preprocessor has default places it looks for standard
    header files. When including a file with the `<file.h>` syntax instead of the
    `"file.h"` syntax, the preprocessor searches for the header file in those standard
    places.
  prefs: []
  type: TYPE_NORMAL
- en: 'When `mylib.h` is included inside double quotes, the preprocessor first looks
    in the current directory for the `mylib.h` file, and then other places that you
    need to explicitly tell it to look, by specifying an include path (`-I`) to `gcc`.
    For example, if the header file is in the `/home/me/myincludes` directory (and
    not in the same directory as the `myprog.c` file), then the path to this directory
    must be specified in the `gcc` command line for the preprocessor to find the `mylib.h`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: $ gcc -I/home/me/myincludes -c myprog.c
  prefs: []
  type: TYPE_NORMAL
- en: 'To compile a program (`myprog.c`) that uses the library (`mylib.o`) into a
    binary executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if the library’s implementation files are available at compile time, then
    the program can be built directly from the program and library `.c` files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if the library is available as an archive or shared object file, then it
    can be linked in using `-l` (`-lmylib`: note that the library name is `libmylib.[a,so]`,
    but only the `mylib` part is included in the `gcc` command line):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-L.` option specifies the path to the `libmylib.[so,a]` files (the `.`
    after the `-L` indicates that it should search the current directory). By default,
    `gcc` will dynamically link a library if it can find a `.so` version. See “C Libraries:
    Using, Compiling, and Linking” on [page 133](ch02.xhtml#lev2_40) for more information
    about linking and link paths.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The program can then be run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the dynamically linked version of `myprog`, you may encounter an
    error that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'This error is saying that the runtime linker cannot find `libmylib.so` at runtime.
    To fix this problem, set your `LD_LIBRARY_PATH` environment variable to include
    the path to the `libmylib.so` file. Subsequent runs of `myprog` use the path you
    add to `LD_LIBRARY_PATH` to find the `libmylib.so` file and load it at runtime.
    For example, if `libmylib.so` is in the `/home/me/mylibs/` subdirectory, run this
    (just once) at the bash shell prompt to set the `LD_LIBRARY_PATH` environment
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 2.9.7 Compiling C to Assembly, and Compiling and Linking Assembly and C Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A compiler can compile C code to assembly code, and it can compile assembly
    code into a binary form that links into a binary executable program. We use IA32
    assembly and `gcc` as our example assembly language and compiler, but this functionality
    is supported by any C compiler, and most compilers support compiling to a number
    of different assembly languages. See [Chapter 8](ch08.xhtml#ch08) for details
    about assembly code and assembly programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this very simple C program:'
  prefs: []
  type: TYPE_NORMAL
- en: simpleops.c
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'The `gcc` compiler will compile it into an IA32 assembly text file (`.s`) using
    the `-S` command line option to specify compiling to assembly and the `-m32` command
    line option to specify generating IA32 assembly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'This command creates a file named `simpleops.s` with the compiler’s IA32 assembly
    translation of the C code. Because the `.s` file is a text file, a user can view
    it (and edit it) using any text editor. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: Passing additional compiler flags provides directions to `gcc` that it should
    use certain features or optimizations in its translation of C to IA32 assembly
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'An assembly code file, either one generated from `gcc` or one written by hand
    by a programmer, can be compiled by `gcc` into binary machine code form using
    the `-c` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting `simpleops.o` file can then be linked into a binary executable
    file (note: this requires that the 32-bit version of the system libraries are
    installed on your system):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: This command creates a binary executable file, `simpleops`, for IA32 (and x86-64)
    architectures.
  prefs: []
  type: TYPE_NORMAL
- en: The `gcc` command line to build an executable file can include `.o` and `.c`
    files that will be compiled and linked together to create the single binary executable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Systems provide utilities that allow users to view binary files. For example,
    `objdump` displays the machine code and assembly code mappings in `.o` files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'This output can be compared to the assembly file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something like this (we’ve annotated some of the assembly code
    with its corresponding code from the C program):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: Writing and Compiling Assembly Code
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Programmers can write their own assembly code by hand and compile it with `gcc`
    into a binary executable program. For example, to implement a function in assembly,
    add code to a `.s` file and use `gcc` to compile it. The following example shows
    the basic structure of a function in IA32 assembly. Such code would be written
    in a file (e.g., `myfunc.s`) for a function with the prototype `int myfunc(int
    param);`. Functions with more parameters or needing more space for local variables
    may differ slightly in their preamble code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'A C program that wanted to call this function would need to include its function
    prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'The following `gcc` commands build an executable file (`myprog`) from `myfunc.s`
    and `main.c` source files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: HANDWRITTEN ASSEMBLY CODE
  prefs: []
  type: TYPE_NORMAL
- en: Unlike C, which is a high-level language that can be compiled and run on a wide
    variety of systems, assembly code is very low level and specific to a particular
    hardware architecture. Programmers may handwrite assembly code for low-level functions
    or for code sequences that are crucial to the performance of their software. A
    programmer can sometimes write assembly code that runs faster than the compiler-optimized
    assembly translation of C, and sometimes a C programmer wants to access low-level
    parts of the underlying architecture (such as specific registers) in their code.
    Small parts of operating system code are often implemented in assembly code for
    these reasons. However, because C is a portable language and is much higher level
    than assembly languages, the vast majority of operating system code is written
    in C, relying on good optimizing compilers to produce machine code that performs
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Although most systems programmers rarely write assembly code, being able to
    read and understand a program’s assembly code is an important skill for obtaining
    a deeper understanding of what a program does and how it gets executed. It can
    also help with understanding a program’s performance and with discovering and
    understanding security vulnerabilities in programs.
  prefs: []
  type: TYPE_NORMAL
- en: 2.10 Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, we covered the C programming language in depth and discussed
    some advanced C programming topics, as well. In the next chapter, we present two
    very helpful C debugging tools: the GNU GDB debugger for general-purpose C program
    debugging, and the Valgrind memory debugger for finding memory access errors in
    C programs. Equipped with these programming tools and knowledge of the core C
    programming language presented in this chapter, a C programmer can design powerful,
    efficient, and robust software.'
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[1.](ch02.xhtml#rfn2_1) *[http://pages.cs.wisc.edu/~remzi/OSTEP/vm-freespace.pdf](http://pages.cs.wisc.edu/~remzi/OSTEP/vm-freespace.pdf)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[2.](ch02.xhtml#rfn2_2) *[https://diveintosystems.org/book/C2-C_depth/_attachments/strtokexample.c](https://diveintosystems.org/book/C2-C_depth/_attachments/strtokexample.c)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[3.](ch02.xhtml#rfn2_3) *[http://www.cs.swarthmore.edu/~newhall/unixhelp/man.html](http://www.cs.swarthmore.edu/~newhall/unixhelp/man.html)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[4.](ch02.xhtml#rfn2_4) *[https://diveintosystems.org/book/C2-C_depth/_attachments/commandlineargs.c](https://diveintosystems.org/book/C2-C_depth/_attachments/commandlineargs.c)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[5.](ch02.xhtml#rfn2_5) *[https://wikipedia.org/wiki/Executable_and_Linkable_Format](https://wikipedia.org/wiki/Executable_and_Linkable_Format)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[6.](ch02.xhtml#rfn2_6) *[http://www.cs.swarthmore.edu/~newhall/unixhelp/compilecycle.html](http://www.cs.swarthmore.edu/~newhall/unixhelp/compilecycle.html)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[7.](ch02.xhtml#rfn2_7) *[https://www.cs.swarthmore.edu/~newhall/unixhelp/howto[m]akefiles.html](https://www.cs.swarthmore.edu/~newhall/unixhelp/howto_makefiles.html)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[8.](ch02.xhtml#rfn2_8) *[https://diveintosystems.org/book/C2-C_depth/_attachments/mylib.h](https://diveintosystems.org/book/C2-C_depth/_attachments/mylib.h)*'
  prefs: []
  type: TYPE_NORMAL
