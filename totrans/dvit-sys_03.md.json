["```\n$ gcc -g myprog.c\n```", "```\n$ gdb a.out\n\n(gdb)          # the gdb command prompt\n```", "```\n$ ddd a.out\n```", "```\n$ gdb core a.out\n\n(gdb) where       # the where command shows point of crash\n```", "```\n$ gcc -g badprog.c\n```", "```\n$ gdb ./a.out\n\nGNU gdb (Ubuntu 8.1-0ubuntu3) 8.1.0.20180409-git\n\nCopyright (C) 2018 Free Software Foundation, Inc.\n\n  ...\n\n(gdb)\n```", "```\n(gdb) break main\n\nBreakpoint 1 at 0x8048436: file badprog.c, line 36.\n```", "```\n(gdb) run\n\nStarting program: ./a.out\n```", "```\nBreakpoint 1, main (argc=1, argv=0x7fffffffe398) at badprog.c:36\n\n36     int main(int argc, char *argv[]) {\n\n(gdb)\n```", "```\n(gdb) list\n\n29\t    }\n\n30\t    return 0;\n\n31\t}\n\n32\n\n33\t/***************************************/\n\n34\tint main(int argc, char *argv[]) {\n\n35\n\n36\t    int arr[5] = { 17, 21, 44, 2, 60 };\n\n37\n\n38\t    int max = arr[0];\n```", "```\n(gdb) list findAndReturnMax\n\n12  *  array: array of integer values\n\n13  *  len: size of the array\n\n 14  *  max: set to the largest value in the array\n\n15  *   returns: 0 on success and non-zero on an error\n\n16  */\n\n17 int findAndReturnMax(int *array1, int len, int max) {\n\n18\n\n19     int i;\n\n20\n\n21     if (!array1 || (len <=0) ) {\n```", "```\n(gdb) next\n\n36   int arr[5] = { 17, 21, 44, 2, 60 };\n\n(gdb) next\n\n38   int max = arr[0];\n\n(gdb) print max\n\n$3 = 0\n\n(gdb) print arr[3]\n\n$4 = 2\n\n(gdb) next\n\n40   if ( findAndReturnMax(arr, 5, max) != 0 ) {\n\n(gdb) print max\n\n$5 = 17\n\n(gdb)\n```", "```\n(gdb) next\n\n40   if ( findAndReturnMax(arr, 5, max) != 0 ) {\n\n(gdb) step\n\nfindAndReturnMax (array1=0x7fffffffe290, len=5, max=17) at badprog.c:21\n\n21   if (!array1 || (len <=0) ) {\n\n(gdb)\n```", "```\n(gdb) print array1[0]\n\n$6 = 17\n\n(gdb) print max\n\n$7 = 17\n\n(gdb) list\n\n16  */\n\n17 int findAndReturnMax(int *array1, int len, int max) {\n\n18\n\n19     int i;\n\n20\n\n21     if (!array1 || (len <=0) ) {\n\n22         return -1;\n\n23     }\n\n24     max = array1[0];\n\n25     for (i=1; i <= len; i++) {\n\n(gdb) list\n\n26         if(max < array1[i]) {\n\n27             max = array1[i];\n\n28         }\n\n29     }\n\n30     return 0;\n\n31 }\n\n32\n\n33 /***************************************/\n\n34 int main(int argc, char *argv[]) {\n\n35\n```", "```\n(gdb) break 27\n\nBreakpoint 2 at 0x555555554789: file badprog.c, line 27.\n\n(gdb) cont\n\nContinuing.\n\nBreakpoint 2, findAndReturnMax (array1=0x...e290,len=5,max=17) at badprog.c:27\n\n27       max = array1[i];\n\n(gdb) print max\n\n$10 = 17\n\n(gdb) print i\n\n$11 = 1\n```", "```\n(gdb) display i\n\n1: i = 1\n\n(gdb) display max\n\n2: max = 17\n\n(gdb) display array1[i]\n\n3: array1[i] = 21\n\n(gdb) cont\n\nContinuing.\n\nBreakpoint 2, findAndReturnMax (array1=0x7fffffffe290, len=5, max=21)\n\n    at badprog.c:27\n\n27       max = array1[i];\n\n1: i = 2\n\n2: max = 21\n\n3: array1[i] = 44\n\n(gdb) cont\n\nContinuing.\n\nBreakpoint 2, findAndReturnMax (array1=0x7fffffffe290, len=5, max=21)\n\n    at badprog.c:27\n\n27       max = array1[i];\n\n1: i = 3\n\n2: max = 44\n\n3: array1[i] = 2\n\n(gdb) cont\n Breakpoint 2, findAndReturnMax (array1=0x7fffffffe290, len=5, max=44)\n\n    at badprog.c:27\n\n27       max = array1[i];\n\n1: i = 4\n\n2: max = 44\n\n3: array1[i] = 60\n\n(gdb) cont\n\nBreakpoint 2, findAndReturnMax (array1=0x7fffffffe290, len=5, max=60)\n\n    at badprog.c:27\n\n27       max = array1[i];\n\n1: i = 5\n\n2: max = 60\n\n3: array1[i] = 32767\n\n(gdb)\n```", "```\n(gdb) quit\n\nThe program is running.  Exit anyway? (y or n) y\n\n$\n```", "```\n$ gdb ./a.out\n\n...\n\n(gdb) break main\n\nBreakpoint 1 at 0x7c4: file badprog.c, line 36.\n\n(gdb) break findAndReturnMax\n\nBreakpoint 2 at 0x748: file badprog.c, line 21.\n\n(gdb) run\n\nStarting program: ./a.out\n\nBreakpoint 1, main (argc=1, argv=0x7fffffffe398) at badprog.c:36\n\n36   int main(int argc, char *argv[]) {\n\n(gdb) cont\n\n Continuing.\n\nBreakpoint 2, findAndReturnMax (array1=0x7fffffffe290, len=5, max=17)\n\n    at badprog.c:21\n\n21   if (!array1 || (len <=0) ) {\n\n(gdb)\n```", "```\n(gdb) where\n\n#0  findAndReturnMax (array1=0x7fffffffe290, len=5, max=17) at badprog.c:21\n\n#1  0x0000555555554810 in main (argc=1, argv=0x7fffffffe398) at badprog.c:40\n```", "```\n(gdb) frame 1\n\n#1  0x0000555555554810 in main (argc=1, argv=0x7fffffffe398) at badprog.c:40\n\n40   if ( findAndReturnMax(arr, 5, max) != 0 ) {\n\n(gdb) print arr\n\n$1 = {17, 21, 44, 2, 60}\n\n(gdb) print max\n\n$2 = 17\n\n(gdb)\n```", "```\n(gdb) break 30\n\nBreakpoint 3 at 0x5555555547ae: file badprog.c, line 30.\n\n(gdb) cont\n\nContinuing.\n\nBreakpoint 3, findAndReturnMax (array1=0x7fffffffe290, len=5, max=60)\n\n    at badprog.c:30\n\n30   return 0;\n\n(gdb) print max\n\n$3 = 60\n```", "```\n(gdb) next\n\n31   }\n\n(gdb) next\n\nmain (argc=1, argv=0x7fffffffe398) at badprog.c:44\n\n44   printf(\"max value in the array is %d\\n\", max);\n\n(gdb) where\n\n#0  main (argc=1, argv=0x7fffffffe398) at badprog.c:44\n\n(gdb) print max\n\n$4 = 17\n```", "```\n$ gcc -g -o segfaulter segfaulter.c\n\n$ gdb ./segfaulter\n\n(gdb) run\n\nStarting program: ./segfaulter\n\nProgram received signal SIGSEGV, Segmentation fault.\n\n0x00005555555546f5 in initfunc (array=0x0, len=100) at segfaulter.c:14\n\n14     array[i] = i;\n```", "```\n(gdb) where\n\n#0 0x00005555555546f5 in initfunc (array=0x0, len=100) at segfaulter.c:14\n\n #1 0x00005555555547a0 in main (argc=1, argv=0x7fffffffe378) at segfaulter.c:37\n\n(gdb) list\n\n9 int initfunc(int *array, int len) {\n\n10\n\n11     int i;\n\n12\n\n13     for(i=1; i <= len; i++) {\n\n14         array[i] = i;\n\n15     }\n\n16     return 0;\n\n17 }\n\n18\n```", "```\n(gdb) print i\n\n$2 = 1\n\n(gdb) print array[i]\n\nCannot access memory at address 0x4\n```", "```\n(gdb) print array\n\n$3 = (int *) 0x0\n```", "```\n(gdb) frame 1\n\n#1 0x00005555555547a0 in main (argc=1, argv=0x7fffffffe378) at segfaulter.c:37\n\n37   if(initfunc(arr, 100) != 0 ) {\n\n(gdb) list\n\n32 int main(int argc, char *argv[]) {\n\n33\n\n34     int *arr = NULL;\n\n35     int max = 6;\n\n36\n\n37     if(initfunc(arr, 100) != 0 ) {\n\n38         printf(\"init error\\n\");\n\n39         exit(1);\n\n40     }\n\n 41\n\n(gdb) print arr\n\n$4 = (int *) 0x0\n\n(gdb)\n```", "```\nhelp <topic or command>   Shows help available for topic or command\n\nhelp breakpoints    Shows help information about breakpoints\n\nhelp print        Shows help information about print command\n```", "```\nbreak <func-name>   Set breakpoint at start of function <func-name>\n\nbreak <line>        Set breakpoint at line number <line>\n\nbreak <filename:><line>  Set breakpoint at <line> in file <filename>\n\nbreak main          Set breakpoint at beginning of main\n\nbreak 13            Set breakpoint at line 13\n\nbreak gofish.c:34   Set breakpoint at line 34 in gofish.c\n\nbreak main.c:34     Set breakpoint at line 34 in main.c\n```", "```\nrun <command line arguments>\n\nrun             Run with no command line arguments\n\nrun 2 40 100    Run with 3 command line arguments: 2, 40, 100\n```", "```\ncontinue\n```", "```\nstep          Execute next line (stepping into a function)\n\nstep <count>  Executes next <count> lines of program code\n\nstep 10       Executes the next 10 lines (stepping into functions)\n```", "```\nnext            Execute the next line\n\nnext <count>    Executes next <count> instructions\n```", "```\nuntil <line>    Executes until hit line number <line>\n```", "```\nquit\n```", "```\nlist                Lists next few lines of program source code\n\nlist <line>         Lists lines around line number <line> of program\n\nlist <start> <end>  Lists line numbers <start> through <end>\n\nlist <func-name>    Lists lines around beginning of function <func-name>\n\nlist 30 100         List source code lines 30 to 100\n```", "```\nwhere\n```", "```\nframe <frame-num>   Sets current stack frame to <frame-num>\n\ninfo frame          Show state about current stack frame\n\nframe 3             Move into stack frame 3's context (0 is top frame)\n```", "```\nbreak <func-name>   Set a breakpoint at start of a function\n\nbreak <line>        Set a breakpoint at a line number\n\nbreak main          Set a breakpoint at start of main\n\nbreak 12            Set a breakpoint at line 12\n\nbreak file.c:34     Set a breakpoint at line 34 of file.c\n```", "```\ndisable <bnums ...>    Disable one or more breakpoints\n\nenable  <bnums ...>    Enable one or more breakpoints\n\nignore  <bpnum> <num>  Don't pause at breakpoint <bpnum>\n\n                         the next <num> times it's hit\n\ndelete  <bpnum>        Delete breakpoint number <bpnum>\n\ndelete                 Deletes all breakpoints\n\nclear <line>           Delete breakpoint at line <line>\n\nclear <func-name>      Delete breakpoint at function <func-name>\n\ninfo break      List breakpoint info (including breakpoint bnums)\n\ndisable 3       Disable breakpoint number 3\n\nignore  2  5    Ignore the next 5 times breakpoint 2 is hit\n\nenable  3       Enable breakpoint number 3\n\ndelete  1       Delete breakpoint number 1\n\nclear   124     Delete breakpoint at source code line 124\n```", "```\ncondition <bpnum> <exp>    Sets breakpoint number <bpnum> to break\n\n                           only when expression <exp> is true\n\nbreak 28            Set breakpoint at line 28 (in function play)\n\ninfo break          Lists information about all breakpoints\n\n  Num Type           Disp Enb Address    What\n\n   1   breakpoint    keep y   0x080483a3 in play at gofish.c:28\n\ncondition 1 (i > 1000)     Set condition on breakpoint 1\n```", "```\nprint <exp>     Display the value of expression <exp>\n\np i             print the value of i\n\np i+3           print the value of (i+3)\n```", "```\nprint    <exp>     Print value of the expression as unsigned int\n\nprint/x  <exp>     Print value of the expression in hexadecimal\n\nprint/t  <exp>     Print value of the expression in binary\n\nprint/d  <exp>     Print value of the expression as signed int\n\nprint/c  <exp>     Print ASCII value of the expression\n\nprint  (int)<exp>  Print value of the expression as unsigned int\n\nprint/x 123        Prints  0x7b\n\nprint/t 123        Print  1111011\n\nprint/d 0x1c       Prints 28\n\nprint/c 99         Prints 'c'\n\nprint (int)'c'     Prints  99\n```", "```\n0x prefix for hex: 0x1c\n\n0b prefix for binary: 0b101\n\nprint 0b101        Prints 5 (default format is decimal)\n\nprint 0b101 + 3    Prints 8\n\nprint 0x12  + 2    Prints 20 (hex 12 is 18 in decimal)\n\nprint/x 0x12  + 2  Prints 0x14 (decimal 20 in hexadecimal format)\n```", "```\nprint *(int *)0x8ff4bc10   Print int value at address 0x8ff4bc10\n```", "```\nprint *ptr      Print the int value pointed to by ptr\n```", "```\nprint $eax      Print the value stored in the eax register\n```", "```\ndisplay <exp>   Display value of <exp> at every breakpoint\n\ndisplay i\n\ndisplay array[i]\n```", "```\nx <memory address expression>\n\nx  0x5678       Examine the contents of memory location 0x5678\n\nx  ptr          Examine the contents of memory that ptr points to\n\nx  &temp        Can specify the address of a variable\n\n                 (this command is equivalent to: print temp)\n```", "```\nx/d   ptr      Print value stored at what ptr points to, in decimal\n\nx/a   &ptr     Print value stored at address of ptr, as an address\n\nx/wx  &temp    Print 4-byte value at address of temp, in hexadecimal\n\nx/10dh 0x1234  Print 10 short values starting at address 0x1234, in decimal\n\nx/4c s1        Examine the first 4 chars in s1\n\n    0x40062d   72 'H'  101 'e'  108 'l'  108 'l'\n\nx/s s1         Examine memory location associated with var s1 as a string\n\n    0x40062d   \"Hello There\"\n\nx/wd s1        Examine the memory location assoc with var s1 as an int\n\n               (because formatting is sticky, need to explicitly set\n\n               units to word (w) after x/s command sets units to byte)\n\n    0x40062d   72\n\nx/8d s1        Examine ASCII values of the first 8 chars of s1\n\n    0x40062d:  72  101 108 108 111 32  84  104\n```", "```\nwhatis <exp>       Display the data type of an expression\n\nwhatis (x + 3.4)   Displays:  type = double\n```", "```\nset <variable> = <exp>   Sets variable <variable> to expression <exp>\n\nset x = 123*y            Set var x's value to (123*y)\n```", "```\nhelp info         Shows all the info options\n\nhelp status       Lists more info and show commands\n\ninfo locals       Shows local variables in current stack frame\n\ninfo args         Shows the argument variable of current stack frame\n\ninfo break        Shows breakpoints\n\ninfo frame        Shows information about the current stack frame\n\ninfo registers    Shows register values\n\ninfo breakpoints  Shows the status of all breakpoints\n```", "```\n    int *ptr, x;\n\n    ptr = malloc(sizeof(int) * 10);\n\n    x = ptr[3];    // reading from uninitialized memory\n    ```", "```\n    ptr[11] = 100;  // writing to unallocated memory (no 11th element)\n\n    x = ptr[11];    // reading from unallocated memory\n    ```", "```\n    free(ptr);\n\n    free(ptr); // freeing the same pointer a second time\n    ```", "```\n    ptr = malloc(sizeof(int) * 10);\n\n    ptr = malloc(sizeof(int) * 5);  // memory leak of first malloc of\n\n                                    // 10 ints\n    ```", "```\n 1  #include <stdio.h>\n\n 2  #include <stdlib.h>\n\n 3\n\n 4  /* print size elms of array p with name name */\n\n 5  void print_array(int *p, int size, char *name) ;\n\n 6\n\n 7  int main(int argc, char *argv[]) {\n\n 8      int *bigfish, *littlefish, i;\n\n 9\n\n10      // allocate space for two int arrays\n\n11      bigfish = (int *)malloc(sizeof(int) * 10);\n\n12      littlefish = (int *)malloc(sizeof(int) * 10);\n\n13      if (!bigfish || !littlefish) {\n\n14          printf(\"Error: malloc failed\\n\");\n\n15          exit(1);\n\n16      }\n\n17      for (i=0; i < 10; i++) {\n\n18          bigfish[i] = 10 + i;\n\n19          littlefish[i] = i;\n\n20      }\n\n21      print_array(bigfish,10, \"bigfish\");\n\n22      print_array(littlefish,10, \"littlefish\");\n\n23\n\n24      // here is a heap memory access error\n\n25      // (write beyond bounds of allocated memory):\n\n26      for (i=0; i < 13; i++) {\n\n27          bigfish[i] = 66 + i;\n\n28      }\n\n29      printf(\"\\nafter loop:\\n\");\n\n30      print_array(bigfish,10, \"bigfish\");\n\n31      print_array(littlefish,10, \"littlefish\");\n\n32\n\n33      free(bigfish);\n\n34      free(littlefish);  // program will crash here\n\n35      return 0;\n\n36  }\n```", "```\nbigfish:\n\n 10  11  12  13  14  15  16  17  18  19\n\nlittlefish:\n\n  0   1   2   3   4   5   6   7   8   9\n\nafter loop:\n\nbigfish:\n\n 66  67  68  69  70  71  72  73  74  75\n\nlittlefish:\n\n 78   1   2   3   4   5   6   7   8   9\n\nSegmentation fault (core dumped)\n```", "```\nInvalid write\n\n at main (bigfish.c:27)\n\n Address is 0 bytes after a block of size 40 alloc'd\n\n   by main (bigfish.c:11)\n```", "```\n$ gcc -g valgrindbadprog.c\n\n$ valgrind -v ./a.out\n\n# re-direct valgrind (and a.out) output to file 'output.txt'\n\n$ valgrind -v ./a.out >& output.txt\n\n# view program and valgrind output saved to out file\n\n$ vim output.txt\n```", "```\n==31059== Invalid write of size 1\n\n==31059==    at 0x4006C5: foo (valgrindbadprog.c:29)\n\n==31059==    by 0x40079A: main (valgrindbadprog.c:56)\n\n==31059==  Address 0x52045c5 is 0 bytes after a block of size 5 alloc'd\n\n==31059==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/...)\n\n==31059==    by 0x400660: foo (valgrindbadprog.c:18)\n\n==31059==    by 0x40079A: main (valgrindbadprog.c:56)\n```", "```\n==31059==\n```", "```\n==31059== Invalid write of size 1\n```", "```\n==31059== Invalid write of size 1\n\n==31059==    at 0x4006C5: foo (valgrindbadprog.c:29)\n\n==31059==    by 0x40079A: main (valgrindbadprog.c:56)\n```", "```\n==31059==  Address 0x52045c5 is 0 bytes after a block of size 5 alloc'd\n\n==31059==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/...)\n\n==31059==    by 0x400660: foo (valgrindbadprog.c:18)\n\n==31059==    by 0x40079A: main (valgrindbadprog.c:56)\n```", "```\n 18   c = (char *)malloc(sizeof(char) * 5);\n\n ...\n\n 22   strcpy(c, \"cccc\");\n\n ...\n\n 28   for (i = 0; i <= 5; i++) {\n\n 29       c[i] = str[i];\n\n 30   }\n```", "```\n(gdb) make\n\n(gdb) run\n```", "```\n(gdb) signal SIGCONT\n```", "```\n(gdb) set follow-fork-mode child     # Set gdb to follow child on fork\n\n(gdb) set follow-fork-mode parent    # Set gdb to follow parent on fork\n\n(gdb) show follow-fork-mode          # Display gdb's follow mode\n```", "```\n(gdb) signal SIGCONT\n\n(gdb) signal SIGALRM\n\n...\n```", "```\n(gdb) handle SIGBUS stop    # if program gets a SIGBUS, gdb gets control\n\n(gdb) info signal           # list info on all signals\n\n(gdb) info SIGALRM          # list info just for the SIGALRM signal\n```", "```\n$ rm -rf ~/.ddd  # Be careful when entering this command!\n\n$ ddd ./a.out\n```", "```\nint main() {\n\n    int x, y;\n\n    x = 1;\n\n    x = x + 2;\n\n    x = x - 14;\n\n    y = x * 100;\n\n    x = x + y * 6;\n\n return 0;\n\n}\n```", "```\n$ gcc -m32 -o simpleops simpleops.c\n```", "```\n$ gcc -m32 -fno-asynchronous-unwind-tables -o simpleops simpleops.c\n```", "```\n$ gcc -m32 -fno-asynchronous-unwind-tables -o simpleops simpleops.c\n\n$ gdb ./simpleops\n```", "```\n(gdb) break main\n\n(gdb) run\n```", "```\n(gdb) disass main         # Disassemble the main function\n```", "```\n(gdb) break *0x080483c1     # Set breakpoint at instruction at 0x080483c1\n```", "```\n(gdb) ni      # Execute the next instruction\n\n(gdb) si      # Execute next instruction; if it is a call instruction,\n\n              # step into the function\n```", "```\n(gdb) print $eax    # print the value stored in register eax\n```", "```\n(gdb) display $eax\n\n(gdb) display $edx\n```", "```\n(gdb) info registers\n```", "```\n$ ddd ./simpleops\n```", "```\ndisass <func_name>   # Lists assembly code for function\n\ndisass <start> <end> # Lists instructions between start & end address\n\ndisass main          # Disassemble main function\n\ndisass 0x1234 0x1248 # Disassemble instructions between addr 0x1234 & 0x1248\n```", "```\nbreak *0x80dbef10 # Sets breakpoint at the instruction at address 0x80dbef10\n```", "```\nstepi, si       # Execute next machine code instruction,\n\n                # stepping into function call if it is a call instruction\n\nnexti,  ni      # Execute next machine code instruction,\n\n                # treating function call as a single instruction\n```", "```\nprint $eax               # Print the value stored in the eax register\n\nprint *(int *)0x8ff4bc10 # Print int value stored at memory addr 0x8ff4bc10\n```", "```\n(gdb) x $ebp-4      # Examine memory at address: (contents of register ebp)-4\n\n                    # if the location stores an address x/a, an int x/wd, ...\n\n(gdb) x/s 0x40062d  # Examine the memory location 0x40062d as a string\n\n0x40062d   \"Hello There\"\n\n(gdb) x/4c 0x40062d # Examine the first 4 char memory locations\n\n                    # starting at address 0x40062d\n\n0x40062d   72 'H'  101 'e' 108 'l' 108 'l'\n\n(gdb) x/d 0x40062d  # Examine the memory location 0x40062d in decimal\n\n0x40062d   72       # NOTE: units is 1 byte, set by previous x/4c command\n\n(gdb) x/wd 0x400000 # Examine memory location 0x400000 as 4 bytes in decimal\n\n0x400000   100      # NOTE: units was 1 byte set, need to reset to w\n```", "```\nset $eax = 10               # Set the value of register eax to 10\n\nset $esp = $esp + 4         # Pop a 4-byte value off the stack\n\nset *(int *)0x8ff4bc10 = 44 # Store 44 at address 0x8ff4bc10\n```", "```\ndisplay $eax       # Display value of register eax\n```", "```\n$ ddd ./a.out\n\n(gdb) break main\n\n(gdb) run\n\n(gdb) disass main         # Disassemble the main function\n\n(gdb) break sum           # Set a breakpoint at the beginning of a function\n\n(gdb) cont                # Continue execution of the program\n\n(gdb) break *0x0804851a   # Set a breakpoint at memory address 0x0804851a\n\n(gdb) ni                  # Execute the next instruction\n\n(gdb) si                  # Step into a function call (step instruction)\n\n(gdb) info registers      # List the register contents\n\n(gdb) p $eax              # Print the value stored in register %eax\n\n(gdb) p  *(int *)($ebp+8) # Print out value of an int at addr (%ebp+8)\n\n(gdb) x/d $ebp+8          # Examine the contents of memory at the given\n\n                          # address (/d: prints the value as an int)\n\n(gdb) x/s 0x0800004       # Examine contents of memory at address as a string\n\n(gdb) x/wd 0xff5634       # After x/s, the unit size is 1 byte, so if want\n\n                          # to examine as an int specify both the width w \\& d\n```", "```\nif (my_tid == 1) {\n\n    printf(\"Tid:%d: value of count is %d and my i is %d\\n\", my_tid, count, i);\n\n    fflush(stdout);\n\n}\n```", "```\nset print thread-events\n```", "```\ninfo threads\n```", "```\nthread <threadno>\n\nthread 12        # Switch to thread 12's execution context\n\nwhere            # Thread 12's stack trace\n```", "```\nbreak <where> thread <threadno>\n\nbreak foo thread 12    # Break when thread 12 executes function foo\n```", "```\nthread apply <threadno|all> command\n```", "```\nbreak <where> thread <threadno>\n```", "```\n./a.out 5\n\nhello I'm thread 0 with pthread_id 139673141077760\n\nhello I'm thread 3 with pthread_id 139673115899648\n\nhello I'm thread 4 with pthread_id 139673107506944\n\nhello I'm thread 1 with pthread_id 139673132685056\n\nhello I'm thread 2 with pthread_id 139673124292352\n\ncount = 159276966\n\n./a.out 5\n\nhello I'm thread 0 with pthread_id 140580986918656\n\nhello I'm thread 1 with pthread_id 140580978525952\n\nhello I'm thread 3 with pthread_id 140580961740544\n\nhello I'm thread 2 with pthread_id 140580970133248\n\nhello I'm thread 4 with pthread_id 140580953347840\n\ncount = 132356636\n```", "```\n(gdb) break worker_loop     # Set a breakpoint for all spawned threads\n\n(gdb) break 77 thread 4     # Set a breakpoint just for thread 4\n\n(gdb) info threads          # List information about all threads\n\n(gdb) where                 # List stack of thread that hit the breakpoint\n\n(gdb) print i               # List values of its local variable i\n\n(gdb) thread 2              # Switch to different thread's (2) context\n\n(gdb) print i               # List thread 2's local variables i\n```", "```\n$ gcc -g racecond.c -lpthread\n\n$ gdb ./a.out\n\n(gdb) break main\n\nBreakpoint 1 at 0x919: file racecond.c, line 28.\n\n(gdb) run 3\n\nStarting program: ...\n\n[Thread debugging using libthread_db enabled] ...\n\nBreakpoint 1, main (argc=2, argv=0x7fffffffe388) at racecond.c:28\n\n28     if (argc != 2) {\n\n(gdb) list 76\n\n71   myid = *((int *)arg);\n\n72\n\n73   printf(\"hello I'm thread %d with pthread_id %lu\\n\",\n\n74       myid, pthread_self());\n\n75\n\n76   for (i = 0; i < 10000; i++) {\n\n77       count += i;\n\n78   }\n\n79\n\n80   return (void *)0;\n\n(gdb) break 76\n\nBreakpoint 2 at 0x555555554b06: file racecond.c, line 76.\n\n(gdb) cont\n\nContinuing.\n\n[New Thread 0x7ffff77c4700 (LWP 5833)]\n\nhello I'm thread 0 with pthread_id 140737345505024\n\n[New Thread 0x7ffff6fc3700 (LWP 5834)]\n\nhello I'm thread 1 with pthread_id 140737337112320\n\n[New Thread 0x7ffff67c2700 (LWP 5835)]\n\n[Switching to Thread 0x7ffff77c4700 (LWP 5833)]\n\nThread 2 \"a.out\" hit Breakpoint 2, worker_loop (arg=0x555555757280)\n\n    at racecond.c:76\n\n76   for (i = 0; i < 10000; i++) {\n\n(gdb) delete 2\n\n(gdb) break 77 thread 4\n\nBreakpoint 3 at 0x555555554b0f: file racecond.c, line 77.\n\n(gdb) cont\n\nContinuing.\n\nhello I'm thread 2 with pthread_id 140737328719616\n\n[Switching to Thread 0x7ffff67c2700 (LWP 5835)]\n\nThread 4 \"a.out\" hit Breakpoint 3, worker_loop (arg=0x555555757288)\n\n    at racecond.c:77\n\n77       count += i;\n\n(gdb) print i\n\n$2 = 0\n\n(gdb) cont\n\nContinuing.\n\n[Switching to Thread 0x7ffff67c2700 (LWP 5835)]\n\nThread 4 \"a.out\" hit Breakpoint 3, worker_loop (arg=0x555555757288)\n\n    at racecond.c:77\n\n77       count += i;\n\n(gdb) print i\n\n$4 = 1\n\n(gdb) thread 3\n\n[Switching to thread 3 (Thread 0x7ffff6fc3700 (LWP 5834))]\n\n#0  0x0000555555554b12 in worker_loop (arg=0x555555757284) at racecond.c:77\n\n77       count += i;\n\n(gdb) print i\n\n$5 = 0\n\n(gdb) thread 2\n\n[Switching to thread 2 (Thread 0x7ffff77c4700 (LWP 5833))]\n\n#0  worker_loop (arg=0x555555757280) at racecond.c:77\n\n77       count += i;\n\n(gdb) print i\n\n$6 = 1\n```"]