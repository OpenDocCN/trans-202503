- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp> <samp class="SANS_Dogma_OT_Bold_B_11">USER
    ENVIRONMENT AND INTERACTION DETECTION</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
- en: As automated malware sandboxes get better at hiding themselves from evasive
    malware, malware authors must adapt. One tactic they use is to enumerate the user’s
    environment and the user’s interaction with it. As [Chapter 4](chapter4.xhtml)
    noted, the everyday user’s setup has open browser tabs, many windows open and
    apps in use, and frequent mouse and keyboard interaction, making it quite different
    from the sandbox environment. An automated malware analysis sandbox is designed
    to boot up, detonate a malware sample, and then promptly shut down. It may not
    exhibit any normal user behaviors or other indicators that suggest it’s a valid
    end-user system.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Modern malware can look for evidence of a real user by searching for typical
    user behaviors, such as downloaded browser cookies and desktop wallpaper settings
    or mouse and keyboard interactions. In this chapter, I’ll outline some interesting
    techniques that malware uses to accomplish this.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Browser Cookies, Cache, and Browsing
    History</samp>
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some malware may be able to enumerate the host’s internet cookies, cache, and
    browsing history. *Cookies* are small files that web pages save to the disk, usually
    for storing the user’s website configuration and preferences. Depending on the
    browser and version, cookies can be stored in individual files or in a small database,
    such as SQLite. The *cache* is a file or group of files that stores website resources
    such as images so that the page loads more quickly the next time the user visits
    it. Much like cookies, the cache can be stored in multiple files or in a database.
    Finally, the *browsing history* is simply a list of previously visited websites,
    typically stored as one or more database files.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: The typical end user will likely have hundreds or thousands of stored cookie
    and cache files and a large internet browsing history, whereas a typical sandbox
    or malware analysis system may not have any at all. Malware can take advantage
    of this discrepancy by counting the number of cookies, cache entries, or previously
    visited websites and checking it against a threshold value. For example, if the
    victim machine has only five entries in its browsing history, the malware might
    assume it’s running in a clean sandbox environment.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'Every browser has standard locations for cookies, cache files, and browsing
    history that malware might attempt to enumerate. Here are some of the most common:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '**Chrome**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '*C:\Users\<user>\AppData\Local\Google\Chrome\User Data\Default*'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C:\Users\<user>\AppData\Local\Google\Chrome\User Data\Default\Cache*'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C:\Users\<user>\AppData\Local\Google\Chrome\User Data\Default\History*'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Firefox**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '*C:\Users\<user>\AppData\Local\Mozilla\Firefox\Profiles*'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C:\Users\<user>\AppData\Roaming\Mozilla\Firefox\Profiles*'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Internet Explorer**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '*C:\Users\<user>\AppData\Roaming\Microsoft\Windows\Cookies*'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C:\Users\<user>\AppData\Local\Microsoft\Windows\Temporary Internet Files*'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C:\Users\<user>\AppData\Local\Microsoft\Windows\WebCache*'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C:\Users\<user>\AppData\Local\Microsoft\Internet Explorer\Recovery*'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Edge**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '*C:\Users\<user>\AppData\Local\Packages\<package name>\AC\MicrosoftEdge\User\*'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C:\Users\<user>\AppData\Local\Packages\<package name>\AC\MicrosoftEdge\Cache\*'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This list is non-exhaustive, and locations may change, of course, depending
    on the Windows OS and browser versions in use.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: If you spot malware enumerating through these files (possibly by calling Windows
    functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">FindFirstFile</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">FindNextFile</samp>), it may
    be attempting to detect the analysis environment. Malware may also use <samp class="SANS_TheSansMonoCd_W5Regular_11">FindFirstUrlCacheEntry</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">FindNextUrlCacheEntry</samp>,
    which sequentially enumerate browser cache entries. These APIs are specific to
    Microsoft browser caches, however. Once again, the enumeration method will largely
    depend on the browser and version being used.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'Older browsers and versions typically use multiple small files for cookies,
    cache, and history storage, while modern browsers use databases. If the browser
    cookies, cache, and history are stored in database files, the malware may attempt
    to interact with them directly. For example, in either the malware executable
    file or its process memory address space, you may spot static strings that reference
    certain browser directories (such as *C:\Users\<user>\AppData\Local\Google\Chrome\User
    Data\Default\History*), followed by a database query such as this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This command could be used to enumerate all of the web history in the history
    database. Database interaction is beyond the scope of this book, so we won’t go
    into further detail here, but it’s important to be aware of this technique.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Recent Office Files</samp>
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using recent Office files is another good way for malware to determine whether
    it’s running in an analysis lab. A real end user will likely have opened many
    files with Microsoft Office applications, and Windows keeps track of those files.
    When you open a document in Word, for example, the file will be added to your
    *Office Recent Files* list.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Information about your recent Office files is contained in the registry key
    <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CURRENT_USER\SOFTWARE\Microsoft\Office\<</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Office_Version_Number</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">></samp>, under a specific subkey called
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Excel</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Word</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Powerpoint</samp>, and so on. Further
    information may be stored in the filesystem directory *C:\Users\<user>\AppData\Roaming\Microsoft\Office\Recent.*
    If you spot malware enumerating this registry key or folder path (using any of
    the previously mentioned Windows functions for file and registry enumeration),
    it may very well be attempting to identify recent Office documents to determine
    whether the victim host is being used by a “real” end user.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">User Files and Directories</samp>'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: A typical user will probably have many files on the system in various user directories,
    such as *Documents*, *Pictures*, *Desktop*, and so on. Using the file enumeration
    methods described in [Chapter 4](chapter4.xhtml), malware can enumerate these
    directories in order to sense whether the host is a real user or not. If the malware
    discovers a lack of user activity in these directories, it might conclude that
    it’s running in a sandbox or analysis environment and take evasive actions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Desktop Wallpaper</samp>
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One particularly creative method malware uses to detect analysis machines is
    checking the currently configured wallpaper, since authentic users tend to change
    their desktop wallpaper from the Windows default. To do so, the malware can simply
    check the Wallpaper registry value <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CURRENT_USER\Software\Microsoft\Internet
    Explorer\Desktop\General\WallpaperSource</samp>. If the user is still using the
    default Windows wallpaper, the <samp class="SANS_TheSansMonoCd_W5Regular_11">WallpaperSource</samp>
    value will contain that wallpaper’s path, which is somewhere in the *C:\Windows\*
    directory. On the other hand, if the user has custom desktop wallpaper configured,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">WallpaperSource</samp> value
    will likely contain a custom directory and image name, such as *C:\Users\<user>\Pictures\my_wallpaper.jpg*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Desktop Windows</samp>
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some malware variants count the number of active desktop windows or search
    for specific ones. They can use the function <samp class="SANS_TheSansMonoCd_W5Regular_11">GetForegroundWindow</samp>
    to test whether the foreground window (meaning the currently active window) changes.
    Since I’m typing this text in LibreOffice, this program is my active foreground
    window. As a legitimate user, my active window will likely change quite a bit;
    for example, I might minimize LibreOffice to take a break from writing and watch
    YouTube cat videos in Chrome. In an automated malware analysis sandbox environment,
    the active window probably won’t change much. Some malware variants know this
    and can use it against the analysis system for detection. In this example, the
    malware is checking whether the foreground window has changed after five seconds:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: First, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetForegroundWindow</samp>,
    which returns a handle to the current foreground window and stores it in the buffer
    at address <samp class="SANS_TheSansMonoCd_W5Regular_11">[ebx+WindowHandle]</samp>.
    Next, the malware calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp>
    function, which will pause the sample for five seconds. The malware makes a second
    call to <samp class="SANS_TheSansMonoCd_W5Regular_11">GetForegroundWindow</samp>
    and then compares the handle values of the two <samp class="SANS_TheSansMonoCd_W5Regular_11">GetForegroundWindow</samp>
    calls with <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp dword ptr ds:[ebx+WindowHandle],
    eax</samp>. If the handles match (meaning that the foreground window hasn’t changed),
    this routine loops over again. This malware sample could continue to loop indefinitely,
    possibly avoiding analysis in an automated sandbox completely, or it could loop
    several times and then terminate itself. Either scenario presents an interesting
    challenge for a malware analysis sandbox. Fortunately, many modern sandboxes simulate
    user activity to thwart this technique. Some can even run in interactive mode,
    which allows you to directly interact with the malware inside the sandbox, also
    helping to circumvent this type of tactic.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, a malware sample can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumWindows</samp>
    function, which returns the number of open windows on the user’s desktop. Windows
    creates many window objects for various reasons, so in a normal user environment,
    this number will be fairly high. For example, I ran <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumWindows</samp>
    on my personal system and it returned a value of 97 windows! In a sandbox analysis
    environment, this number will likely be substantially lower. This code snippet
    demonstrates the use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumWindows</samp>
    function:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumWindows</samp> takes a parameter
    that essentially serves as a pointer to a buffer that will store the result of
    the function call (<samp class="SANS_TheSansMonoCd_W5Regular_11">push ebx</samp>).
    After <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumWindows</samp> is called,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">pop eax</samp> instruction will
    pop the pointer from the <samp class="SANS_TheSansMonoCd_W5Regular_11">ebx</samp>
    buffer off the stack and into <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>.
    The malware compares the <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumWindows</samp>
    value (now stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>)
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">20</samp>, and if the number
    of open windows is less than or equal to this value, the sample will terminate
    itself. This sample is assuming that a malware analysis sandbox will have 20 or
    fewer windows activated at one time.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides enumerating the number of active windows on the victim system or sensing
    whether the foreground window is changing, malware can also actively search for
    a specific application window. This is useful for two reasons. First, the malware
    sample can search for open windows running applications that are commonly run
    by typical end users: Microsoft Office products, email programs, browsers, and
    so on. If enough of these applications are open, the malware could reasonably
    assume it’s *not* running in a malware analyst’s lab. Second, the malware sample
    can look for certain malware analysis tools, similar to what I described in “Processes”
    in [Chapter 4](chapter4.xhtml). For example, the malware might search for open
    windows that contain the term *Procmon*, *Fiddler*, or *Wireshark*, typically
    by calling the function <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumWindows</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">FindWindow</samp>. As with looking
    for a certain process, it iterates through open windows and compares the title
    of each to a string, and the result can clue it in to the fact that it’s being
    analyzed.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Mouse and Keyboard Interaction</samp>
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Everyday end users are almost always using their mouse to move their cursor
    around the screen, whether they’re browsing the internet, editing a document,
    or playing a video game. Some malware can detect this activity using <samp class="SANS_TheSansMonoCd_W5Regular_11">GetCursorPos</samp>,
    which returns the coordinates of the user’s mouse cursor. The following pseudocode
    shows what this might look like in action:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First, the malware calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetCursorPos</samp>
    function and stores the resulting mouse cursor coordinates in the <samp class="SANS_TheSansMonoCd_W5Regular_11">CursorPos1</samp>
    buffer. Next, it calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp>
    function, which pauses the malware’s execution for 30 seconds, and then it calls
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GetCursorPos</samp> again. Finally,
    it compares the two resulting cursor coordinate values, and if they’re the same
    (meaning the cursor hasn’t moved), the sample will terminate itself. You can probably
    see how this is an effective method for evading automated sandboxes, as the cursor
    is unlikely to move itself (unless, of course, the sandbox is designed to mimic
    a real user).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'Another similar technique involves the malware waiting for certain mouse buttons
    to be pressed or a certain number of mouse clicks to occur before it executes
    its malicious code. FireEye wrote a 2012 research article, “Hot Knives Through
    Butter: Evading File-based Sandboxes,” about this particular technique being used
    by a malware family called Upclicker. To monitor these mouse actions, Upclicker
    established a *hook* on the mouse, allowing the malware to intercept and monitor
    all mouse activity and wait for certain events to occur. Here’s what this might
    look like in malware code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The malware sample first pushes the <samp class="SANS_TheSansMonoCd_W5Regular_11">jump_location</samp>
    parameter to the stack; this is where the malware will jump to when a certain
    mouse event occurs. Another parameter, <samp class="SANS_TheSansMonoCd_W5Regular_11">0E</samp>
    in hexadecimal (or 14 in decimal), tells <samp class="SANS_TheSansMonoCd_W5Regular_11">SetWindowsHookExA</samp>
    to hook mouse actions. The call to <samp class="SANS_TheSansMonoCd_W5Regular_11">SetWindowsHookExA</samp>
    tells the program to jump to the code specified in <samp class="SANS_TheSansMonoCd_W5Regular_11">jump_location</samp>
    once the victim user clicks a mouse button.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: This code is simplified for the sake of brevity. In reality, the malware would
    likely implement extra logic to take action only upon certain mouse events, such
    as a left-button click (as in the case of Upclicker). To read more about Upclicker
    and also get a good introduction to sandbox evasion, check out the FireEye report
    at [*https://<wbr>media<wbr>.blackhat<wbr>.com<wbr>/us<wbr>-13<wbr>/US<wbr>-13<wbr>-Singh<wbr>-Hot<wbr>-Knives<wbr>-Through<wbr>-Butter<wbr>-Evading<wbr>-File<wbr>-based<wbr>-Sandboxes<wbr>-WP<wbr>.pdf<wbr>*](https://media.blackhat.com/us-13/US-13-Singh-Hot-Knives-Through-Butter-Evading-File-based-Sandboxes-WP.pdf).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: This hooking magic doesn’t just work for the mouse. Malware can also hook the
    keyboard by passing <samp class="SANS_TheSansMonoCd_W5Regular_11">0Dh</samp> (13
    in decimal) to the <samp class="SANS_TheSansMonoCd_W5Regular_11">SetWindowsHookEx</samp>
    function instead, then waiting for a certain key to be pressed before fully executing.
    (Hooking will be discussed in more detail in [Chapters 8](chapter8.xhtml) and
    [12](chapter12.xhtml).) Alternatively, malware could also call the function <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetAsyncKeyState</samp> to monitor for
    keypresses.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring mouse and keyboard interactions can be a very effective method of
    detecting and bypassing an automated malware analysis sandbox. Unless the sandbox
    or malware analyst presses the specific keys or mouse buttons, the malware sample
    may look completely benign in the context of the sandbox environment.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*To simulate a real end-user environment, make your analysis VMs and sandboxes
    look as much like a real user as possible. Changing your wallpaper and visiting
    some websites (to populate your cookies and cache directories) can go a long way.
    Even opening additional windows and moving the mouse around the screen may help
    avoid some of these detection techniques, even if you feel a bit silly doing it.*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">System Uptime</samp>
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*System uptime* is the length of time the system has been powered on, and it
    can be a great indicator to malware that it’s in an analysis environment. A typical
    end-user device will likely be powered on for hours, if not days, at a time. Servers
    may be powered on for months or years without a reboot. Since malware analysts
    typically boot up their VMs and sandboxes to analyze a malware sample on demand,
    a short system uptime can be a big hint that the system is an analysis machine.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'There are multiple ways to check for system uptime, via both the Windows API
    and other helper commands. Perhaps the most common method is the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp>
    Windows API function, which returns the system uptime in milliseconds. A *tick*
    is created by the processor clock, which is responsible for keeping time and coordinating
    instructions. When a system is shut down or rebooted, <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp>
    essentially resets to 0\. The following code uses <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp>
    to see if the system has been powered on for 20 minutes:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The sample first moves <samp class="SANS_TheSansMonoCd_W5Regular_11">124F80</samp>
    in hex (1200000 in decimal) into the <samp class="SANS_TheSansMonoCd_W5Regular_11">ebx</samp>
    register, representing 1,200,000 milliseconds, or 20 minutes. Then, it calls <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp> and compares the returned
    tick count value to the value in <samp class="SANS_TheSansMonoCd_W5Regular_11">ebx</samp>.
    If the value from <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp>
    is below the <samp class="SANS_TheSansMonoCd_W5Regular_11">ebx</samp> value, meaning
    the system has been powered on for less than 20 minutes, the malware sample terminates
    itself.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 该样本首先将十六进制的 <samp class="SANS_TheSansMonoCd_W5Regular_11">124F80</samp>（十进制的
    1200000）存入 <samp class="SANS_TheSansMonoCd_W5Regular_11">ebx</samp> 寄存器，代表 1,200,000
    毫秒，即 20 分钟。然后，它调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp>
    并将返回的计时值与 <samp class="SANS_TheSansMonoCd_W5Regular_11">ebx</samp> 中的值进行比较。如果
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp> 返回的值小于 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ebx</samp> 的值，意味着系统开机时间少于 20 分钟，则恶意软件样本会终止自身。
- en: Malware may also use the Windows command line to get the system uptime. Options
    include the <samp class="SANS_TheSansMonoCd_W5Regular_11">sysinfo</samp> command,
    which returns a list of information about the system, including the uptime; <samp
    class="SANS_TheSansMonoCd_W5Regular_11">uptime.exe</samp>, a binary included with
    most versions of Windows; and the <samp class="SANS_TheSansMonoCd_W5Regular_11">net
    statistics workstation</samp> command. Finally, malware can invoke WMIC to return
    the system uptime using the command <samp class="SANS_TheSansMonoCd_W5Regular_11">wmic
    os get lastbootuptime</samp>.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件也可能使用 Windows 命令行获取系统的正常运行时间。可选命令包括 <samp class="SANS_TheSansMonoCd_W5Regular_11">sysinfo</samp>
    命令，它返回关于系统的各种信息，包括正常运行时间；<samp class="SANS_TheSansMonoCd_W5Regular_11">uptime.exe</samp>，这是大多数版本的
    Windows 自带的一个二进制文件；以及 <samp class="SANS_TheSansMonoCd_W5Regular_11">net statistics
    workstation</samp> 命令。最后，恶意软件还可以通过调用 WMIC 来获取系统的正常运行时间，命令是 <samp class="SANS_TheSansMonoCd_W5Regular_11">wmic
    os get lastbootuptime</samp>。
- en: One final important note here is that <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp>
    and the other methods mentioned are often used in both benign and malicious applications,
    and not just for exposing analysis environments and sandboxes. Just because a
    malware sample is inspecting the system uptime doesn’t mean it’s acting evasively,
    but you should treat the behavior as a red flag.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的最后一个重要提示是，<samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp>及其他方法常用于良性和恶意应用程序中，而不仅仅是用于暴露分析环境和沙箱。仅仅因为恶意软件样本正在检查系统的正常运行时间，并不意味着它在采取逃避行为，但你应该将这种行为视为一个警示信号。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: In this chapter, we covered some creative and sneaky ways in which malware can
    enumerate the environment and look for evidence of actual user activity. You can
    thwart many of these user detection techniques simply by designing your analysis
    environment to make it look legitimate to malware. Some of these changes, such
    as changing the default Windows wallpaper and ensuring you have some items in
    your browsing history, are simple to implement. We’ll discuss other ways to thwart
    detection techniques in [Appendix A](appendix-A.xhtml). Note also that some advanced
    sandboxes have built-in protections against many of these techniques.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一些恶意软件枚举环境并寻找实际用户活动证据的创新且狡猾的方法。通过设计一个看起来对恶意软件合法的分析环境，你可以有效阻止这些用户检测技术中的许多。诸如更改默认的
    Windows 桌面背景并确保浏览历史中有一些项目等变化，都是容易实施的。我们将在[附录 A](appendix-A.xhtml)中讨论其他阻止检测技术的方法。还要注意，一些高级沙箱已内置防护措施，能抵御许多这些技术。
- en: In the next chapter, we’ll look at how evasive malware can enumerate system
    hardware and network device information to detect a VM analysis environment.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何通过逃避型恶意软件枚举系统硬件和网络设备信息，以检测虚拟机分析环境。
