<html><head></head><body>
<h2 class="h2" id="ch05"><span epub:type="pagebreak" id="page_61"/><span class="big">5</span><br/>CRYPTOGRAPHY</h2>&#13;
<div class="imagel"><img alt="Image" src="../images/common.jpg"/></div>&#13;
<p class="noindent"><em>Cryptography</em>, the science of protecting the confidentiality and integrity of data, is a key part of the vast set of transactions that take place over your devices daily. You use cryptography when you have conversations on your cell phones, check your email, buy things from online retailers, and file your taxes, among other activities. Without the ability to protect the information you send over such channels, your Internet-based activities would be much riskier.</p>&#13;
<p class="indent">In cryptography, <em>encryption</em> is the process of transforming readable data, called <em>plaintext</em> or <em>cleartext</em>, into an unreadable form, called <em>ciphertext. Decryption</em> is the process of recovering the plaintext message from the ciphertext. You encrypt the plaintext or decrypt the ciphertext using a specific computational procedure called a <em>cryptographic algorithm</em>. You’ll explore several examples of these in this chapter. Cryptographic algorithms generally use a <em>key</em>, or multiple keys, to encrypt or decrypt the message. You can think of a key as a password that you can apply to the algorithm to retrieve the message.</p>&#13;
<p class="indent">In this chapter, you’ll look at some of the earliest examples of cryptography and then dive into modern cryptographic practices.</p>&#13;
<h3 class="h3" id="ch05lev1sec1"><span epub:type="pagebreak" id="page_62"/>The History of Cryptography</h3>&#13;
<p class="noindent">Some of the oldest examples of cryptography date back to ancient Greece and Rome. To hide information, Greeks and Romans used codes, as well as unorthodox methods such as tattooing information on the shaved heads of messengers and allowing hair to grow over it. Enough historical information about cryptography exists to fill an entire volume, and indeed many books have been written on the subject, so I’ll go over just a few highlights.</p>&#13;
<h4 class="h4" id="ch05lev2sec1"><em>The Caesar Cipher</em></h4>&#13;
<p class="noindent">The Caesar cipher, a classic example of ancient cryptography, is said to have been used by Julius Caesar. The Caesar cipher involves shifting each letter of the plaintext message by a certain number of spaces in the alphabet, historically three, as shown in <a href="#ch5fig1">Figure 5-1</a>. After the shift, you would write the letter <em>A</em> as <em>D</em>, the letter <em>B</em> as <em>E</em>, and so on. To decrypt the ciphertext, you would apply the same number of shifts in the opposite direction.</p>&#13;
<div class="image" id="ch5fig1"><img alt="Image" src="../images/05fig01.jpg"/></div>&#13;
<p class="figcap"><em>Figure 5-1: Encrypting the phrase “secret message” with the Caesar cipher</em></p>&#13;
<p class="indent">We call this type of encryption a <em>substitution cipher</em>, because it substitutes each letter in the alphabet with a different one. A more recent variation of the Caesar cipher is the ROT13 cipher, which uses the same mechanism as the Caesar cipher but moves each letter 13 places forward in the alphabet. Moving each letter by 13 places makes the message convenient to decrypt, because all you have to do to retrieve the original is apply another round of encryption with ROT13; two rotations will return each letter to its original starting place in the alphabet. Utilities for performing ROT13 are part of the basic set of tools that ship with many Linux and UNIX operating systems.</p>&#13;
<h4 class="h4" id="ch05lev2sec2"><em>Cryptographic Machines</em></h4>&#13;
<p class="noindent">Before the advent of the modern computer, people used machines to simplify encryption and make more complex encryption schemes feasible. Initially, such devices were basic mechanical machines, but as technology progressed, they began to include electronics and considerably more complex systems.</p>&#13;
<p class="indent">The Jefferson Disk, invented by Thomas Jefferson in 1795, is a purely mechanical cryptographic machine. It is composed of 36 disks, each marked with the letters <em>A</em> through <em>Z</em> in a circle around its rim, as shown in <a href="#ch5fig2">Figure 5-2</a>.<a href="notes.xhtml#ch05fn1" id="kch05fn1"><sup>1</sup></a></p>&#13;
<p class="indent">Each disk represents one character in a message. The letters on each disk are arranged in a different order, and each disk is marked with a unique identifier so you can tell them apart.</p>&#13;
<p class="indent">To encrypt a message, you line up the characters in a row across the set of disks so they spell out the message in plaintext, like in row A of <a href="#ch5fig3">Figure 5-3</a>. Then you choose a different row of characters to use as the ciphertext, as shown in row B.</p>&#13;
<span epub:type="pagebreak" id="page_63"/>&#13;
<div class="image" id="ch5fig2"><img alt="Image" src="../images/05fig02.jpg"/></div>&#13;
<p class="figcap"><em>Figure 5-2: The Jefferson Disk, one of the earliest crypto-graphic machines</em></p>&#13;
<div class="image" id="ch5fig3"><img alt="Image" src="../images/05fig03.jpg"/></div>&#13;
<p class="figcap"><em>Figure 5-3: Encrypting the message “Meeting is a go” using the Jefferson Disk</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_64"/>The key to this cipher is in the order of the disks. If the encrypting and decrypting devices arrange their disks in the same order, all you need to do to decrypt the message is rewrite the ciphertext using the disks and then look at all the rows until you find the plaintext message. This is, of course, merely a more complex version of a substitution cipher, made possible using a mechanical aid, in which the substitution changes with each letter.</p>&#13;
<p class="indent">A more intricate example of a cryptographic machine is the German-made Enigma machine (<a href="#ch5fig4">Figure 5-4</a>).<a href="notes.xhtml#ch05fn2" id="kch05fn2"><sup>2</sup></a> Created by Arthur Scherbius in 1923, the Enigma secured German communications during World War II.</p>&#13;
<div class="image" id="ch5fig4"><img alt="Image" src="../images/05fig04.jpg"/></div>&#13;
<p class="figcap"><em>Figure 5-4: An Enigma machine</em></p>&#13;
<p class="indent">Conceptually, the Enigma resembles the Jefferson Disk. It’s based on a series of wheels, or rotors, each with 26 letters and 26 electrical contacts. It also has a keyboard for entering the plaintext message and a set of 26 characters above the keyboard, which light up to indicate the encrypted equivalent. When you press a key on the Enigma keyboard, one or more of the rotors physically rotates, changing the orientation of the electrical contacts between them. Current flows through the entire series of disks and then back through them again to the original disk, lighting up the scrambled version of each letter on the series of characters above the keyboard.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_65"/>For two Enigma machines to communicate during the war, they needed to have the same configuration. This took a lot of work since both the rotors and the rings marked with the alphabet on each rotor needed to be identical and in the same position, and any cables plugged in needed to be set up in the same fashion. Once the message was encrypted, it would be sent via Morse code to the receiving end. When the receiver got the encrypted Morse code message, they would enter the equivalent characters on the keyboard, and presuming everything was set up properly, the decrypted character would light up.</p>&#13;
<p class="indent">There were several models of Enigma machine and a variety of accessories and add-ons you could attach to them. To add further possible variations, some models had a patch panel, allowing you to swap some or all the letters by plugging cables into different positions. On each rotor, the ring containing the letters of the alphabet could also be rotated independently of the electrical contacts to change the relationship between the character selected and the character output.</p>&#13;
<p class="indent">Between the inherent strengths of the device and the knowledge of the required configuration needed for decryption, the Enigma posed quite a difficult task for those attempting to break the messages generated by it. But a large portion of the device’s strength was in the secrecy surrounding the equipment and the configurations used for specific messages; this is a strategy we call <em>security through obscurity</em> in the security field. Once these secrets became exposed, the encrypted messages were no longer as secure.</p>&#13;
<p class="indent">In 1939, when cryptographers at Bletchley Park, a British code-breaking base during World War II, were given an Enigma to study, they were able to construct a computer called the Bombe that decoded a large portion of the Germans’ messages, even though they didn’t have access to the Enigma settings rotated on a daily basis.</p>&#13;
<div class="sidebar">&#13;
<p class="sidebart"><strong>MORE ON THE ENIGMA MACHINE</strong></p>&#13;
<p class="noindent">Anyone interested in getting hands-on experience with a classic item of cryptographic history can interact with the Enigma in several ways. The DIY inclined can purchase a kit that re-creates the functionality of the Enigma using modern electronics components.<a href="notes.xhtml#ch05fn3" id="kch05fn3"><sup>3</sup></a> Additionally, a variety of software-based Enigma simulators exist.<a href="notes.xhtml#ch05fn4" id="kch05fn4"><sup>4</sup></a> These are particularly useful for representing the relationship between the rotors and the paths running through them, which change with each character entered. A great many books have also been written on this topic, but a particularly good one is <em>The German Enigma Cipher Machine: Beginnings, Success, and Ultimate Failure</em> by Brian J. Winkel, Cipher Deavours, David Kahn, and Louis Kruh. <em>Seizing the Enigma: The Race to Break the German U-Boat Codes, 1933–1945</em> by David Kahn is another excellent source for further detail on some of this work.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch05lev2sec3"><span epub:type="pagebreak" id="page_66"/><em>Kerckhoffs’s Principles</em></h4>&#13;
<p class="noindent">In 1883, the <em>Journal des Sciences Militaires</em> published an article by Auguste Kerckhoffs, a Dutch linguist and cryptographer, titled “La cryptographie militaire.” In the article, Kerckhoffs outlined six principles he thought should serve as a basis for all cryptographic systems.<a href="notes.xhtml#ch05fn5" id="kch05fn5"><sup>5</sup></a></p>&#13;
<ol>&#13;
<li><p class="noindent">The system must be substantially, if not mathematically, undecipherable.</p></li>&#13;
<li><p class="noindent">The system must not require secrecy; even if stolen by the enemy, the system should remain secure.</p></li>&#13;
<li><p class="noindent">The keys must be easy to communicate and remember without written notes, and they must be easy to change or modify to use with different participants.</p></li>&#13;
<li><p class="noindent">The system ought to be compatible with communication via telegraph.</p></li>&#13;
<li><p class="noindent">The system must be portable, and its use must not require more than one person.</p></li>&#13;
<li><p class="noindent">Finally, the system must be easy to use, requiring neither complex thinking nor the knowledge of a long series of rules.</p></li>&#13;
</ol>&#13;
<p class="indent">Although several of these principles, such as requiring the system to support telegraph use or be physically portable, became outmoded once people started using computers for cryptography, the second principle remains a key tenet of modern cryptographic algorithms. Claude Shannon, an American mathematician and cryptographer, later restated the idea as “the enemy knows the system”;<a href="notes.xhtml#ch05fn6" id="kch05fn6"><sup>6</sup></a> in other words, cryptographic algorithms should be robust enough that even if people know every bit of the encryption process except for the key itself, they should still not be able to break the encryption. This idea represents the opposite approach to security through obscurity.</p>&#13;
<h3 class="h3" id="ch05lev1sec2">Modern Cryptographic Tools</h3>&#13;
<p class="noindent">Although efficient electromechanical cryptographic systems like Enigma enabled highly secure means of communication for a period, the increasing complexity of computers quickly rendered these systems obsolete. One reason was that the systems were not completely compliant with Kerckhoffs’s second principle and still largely depended on security through obscurity to protect the data they processed.</p>&#13;
<p class="indent">Modern cryptographic algorithms used by computers are truly open, meaning you can understand the encryption process and still not be able to break the cipher. These algorithms depend on difficult mathematical problems, sometimes referred to as <em>one-way problems</em>. One-way problems are easy to perform in one direction but difficult to perform in the other direction. Factorization of large numbers is an example of a one-way problem; it’s easy to create an algorithm that returns a product of multiple integers, but it’s much more difficult to create one that does the inverse of that operation—finding the factors of a given integer—especially if that number is very large. Such problems form the basis of many modern cryptographic systems.</p>&#13;
<h4 class="h4" id="ch05lev2sec4"><span epub:type="pagebreak" id="page_67"/><em>Keyword Ciphers and One-Time Pads</em></h4>&#13;
<p class="noindent">Two technologies, keyword ciphers and one-time pads, helped bridge the gap between older cryptographic methods and modern ones. Although simpler than the algorithms used today, these techniques increasingly met the standard set by Kerckhoffs’s second principle.</p>&#13;
<h5 class="h5">Keyword Ciphers</h5>&#13;
<p class="noindent"><em>Keyword ciphers</em> are substitution ciphers, like the Caesar cipher discussed earlier in the chapter. But, unlike the Caesar cipher, they use a key to determine what to substitute for each letter of the message. Rather than shifting all letters by the same number of spaces in the alphabet, you’d shift each letter to match the corresponding letter in the keyword. For example, if you use the keyword MYSECRET, you’d have the substitution shown in <a href="#ch5fig5">Figure 5-5</a>.</p>&#13;
<div class="image" id="ch5fig5"><img alt="Image" src="../images/05fig05.jpg"/></div>&#13;
<p class="figcap"><em>Figure 5-5: Encryption using a keyword cipher</em></p>&#13;
<p class="indent">The letter <em>A</em> turns into the letter <em>M</em>, which is the first letter in the key; the letter <em>B</em> turns into the letter <em>Y</em>, which is the second letter in the key. You continue like this, removing any repeating letters in the key—notice the second <em>E</em> in SECRET is missing—and once the keyword ends, you assign the rest of the characters are in alphabetical order, minus any letter used in the key. If you started with the plaintext THE QUICK BROWN FOX, you’d get the ciphertext PAC LQBSF YNJVI RJW.</p>&#13;
<p class="indent">Ciphers such as this one have weaknesses. Like all the other historical ciphers we’ve discussed, they’re vulnerable to <em>frequency analysis</em>, which means you can make guesses about what the message contents might be based on the frequency of characters used, where those characters appear in words, and when they’re repeated. For example, the letter <em>E</em> is the most commonly used letter in the English alphabet, so you could assume that the most frequent letter in the substitution might be an <em>E</em>, as well, and work from there to decrypt the message.</p>&#13;
<p class="indent">To fix this flaw, cryptographers invented the one-time pad.</p>&#13;
<h5 class="h5">One-Time Pads</h5>&#13;
<p class="noindent">The <em>one-time pad</em>, also known as the Vernam cipher, is an unbreakable cipher when used properly. To use it, you create two copies of the same pad of paper containing a completely random set of numbers, known as <em>shifts</em>, and give one copy to each party. These pads are the key. To encrypt the message, you use the shifts to move each letter of the message forward. Like with the keyword <span epub:type="pagebreak" id="page_68"/>cipher, if the first number on the pad were 4, you’d shift the first letter of your message by 4 spots, and if the second number were 6, you’d shift the second letter of the message by 6 spots. <a href="#ch5fig6">Figure 5-6</a> shows an example of this.</p>&#13;
<div class="image" id="ch5fig6"><img alt="Image" src="../images/05fig06.jpg"/></div>&#13;
<p class="figcap"><em>Figure 5-6: Encryption using a one-time pad</em></p>&#13;
<p class="indent">In this example, you’d send the message ATTACKATDAWN as EYGBPMOMJXEP. The receiving party would consult their one-time pad and then perform the relative shifts backward to decrypt the message.</p>&#13;
<p class="indent">The encrypted text could generate an infinite number of possible plaintext messages. In the case of the Caesar cipher, where you shift the entire message by the same number of characters, there are only 26 possible combinations. <em>Brute forcing</em>, or testing every possible key to retrieve the original message, takes little time, and you’ll likely have no trouble recognizing the correct message when you’ve succeeded. But since the one-time pad uses a different shift for each letter, the message could contain any combination of letters or words that fits the message length. From the previous example, you could just as easily decrypt the incorrect messages ATTACKATNOON or NODONTATTACK.</p>&#13;
<p class="indent">The one-time pad is a primitive version of a stream cipher, which we’ll come back to shortly. You can use it with more complex pads and mathematical operations, and modern methods of encryption and key exchange use some of these same concepts.</p>&#13;
<h4 class="h4" id="ch05lev2sec5"><em>Symmetric and Asymmetric Cryptography</em></h4>&#13;
<p class="noindent">Today, we can separate most cryptographic algorithms into two types: symmetric and asymmetric. In this section, I will discuss each type, as well as a few specific examples of each.</p>&#13;
<h5 class="h5">Symmetric Cryptography</h5>&#13;
<p class="noindent">Also known as private key cryptography, <em>symmetric key cryptography</em> uses a single key to both encrypt the plaintext and decrypt the ciphertext. Technically, the ciphers we’ve explored so far in this chapter use symmetric keys; to decode the Caesar cipher, for example, you would apply the same key to the message as the one used to encrypt it. That means you must share the key between the sender and the receiver. This process, known as <em>key exchange</em>, constitutes an entire subtopic of cryptography. I’ll discuss key exchange at greater length later in this chapter.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_69"/>The fact that you must share a single key among all users of the system is one of the chief weaknesses of symmetric key cryptography. If attackers gain access to the key, they could decrypt the message—or, worse yet, decrypt it, alter it, and then encrypt it once more and pass it on to the receiver in place of the original message (a tactic called a <em>man-in-the-middle attack</em>).</p>&#13;
<h5 class="h5">Block vs. Stream Ciphers</h5>&#13;
<p class="noindent">Symmetric key cryptography in the digital age makes use of two types of ciphers: block ciphers and stream ciphers. A <em>block cipher</em> takes a predetermined number of bits (or binary digits, which are either a 1 or a 0), known as a <em>block</em>, and encrypts that block. Blocks typically have 64 bits, but they can be larger or smaller depending on the algorithm used and the various modes the algorithm can operate in. A <em>stream cipher</em> encrypts each bit in the plaintext message one bit at a time. You can make a block cipher act as a stream cipher by setting the block size to one bit.</p>&#13;
<p class="indent">The majority of the encryption algorithms currently in use are block ciphers. Although block ciphers are often slower than stream ciphers, they tend to be more versatile. Since block ciphers operate on larger blocks of the message at a time, they’re usually more resource intensive and more complex to implement. They’re also more susceptible to errors in the encryption process. For example, an error in block cipher encryption would render a large segment of data unusable, whereas in a stream cipher, an error would corrupt only a single bit. You can generally use specific block modes to detect and compensate for such errors. A <em>block mode</em> defines the specific processes and operations that the cipher uses. You’ll learn more about these modes in the next section when I discuss the algorithms that use them.</p>&#13;
<p class="indent">Typically, block ciphers work better with messages whose sizes are fixed or known in advance, such as files, or messages whose sizes are reported in protocol headers. It’s generally better to use stream ciphers when encrypting data of an unknown size or data in a continuous stream, such as information moving over a network, where the kind of data being sent and received is variable.</p>&#13;
<h5 class="h5">Symmetric Key Algorithms</h5>&#13;
<p class="noindent">Some of the most well-known cryptographic algorithms are symmetric key algorithms. The US government has used several of these, such as DES, 3DES, and AES, as standard algorithms for protecting highly sensitive data. I’ll discuss these three examples in this section.</p>&#13;
<p class="indent"><em>DES</em> is a block cipher that uses a 56-bit key (meaning the key used by its cryptographic algorithm is 56 bits long). As you saw when discussing keyword ciphers, the length of the key determines the strength of the algorithm, because the longer the key is, the more possible keys there are. For example, an 8-bit key has a keyspace (range of possible keys) of 2<sup>8</sup>. DES has a keyspace of 2<sup>56</sup>—that’s 72057594037927936 possible keys attackers must test.</p>&#13;
<p class="indent">DES first came into use in 1976 in the United States and has since spread globally. People considered it very secure until 1999, when a distributed computing project attempted to break a DES key by testing every possible key in <span epub:type="pagebreak" id="page_70"/>the entire keyspace. They succeeded in a little more than 22 hours. It turned out the keyspace was too short; to compensate for this, cryptographers began using <em>3DES</em> (pronounced “triple DES”), which is simply DES used to encrypt each block three times, with three different keys.</p>&#13;
<p class="indent">Eventually, the US government replaced DES with <em>AES</em>, a set of symmetric block ciphers. AES uses three different ciphers: one with a 128-bit key, one with a 192-bit key, and one with a 256-bit key, all of which encrypt blocks of 128 bits. Briefly, there are a few key differences between AES and 3DES.</p>&#13;
<ol>&#13;
<li><p class="noindent">3DES is three rounds of DES, while AES uses a newer and completely different algorithm developed in 2000.</p></li>&#13;
<li><p class="noindent">AES uses longer and stronger keys than 3DES, as well as a longer block length, making AES harder to attack.</p></li>&#13;
<li><p class="noindent">3DES is slower than AES.</p></li>&#13;
</ol>&#13;
<p class="indent">Hackers have attempted a variety of attacks against AES, most of them against the encryption using the 128-bit key. Most of these have either failed or had only partial success. At the time of this writing, the US government still considers AES to be secure.</p>&#13;
<p class="indent">Other well-known symmetric block ciphers include Twofish, Serpent, Blowfish, CAST5, RC6, and IDEA. Popular stream ciphers include RC4, ORYX, and SEAL.</p>&#13;
<h5 class="h5">Asymmetric Cryptography</h5>&#13;
<p class="noindent">Martin Hellman and Whitfield Diffie first described asymmetric cryptography in their 1976 paper, “New Directions in Cryptography.”<a href="notes.xhtml#ch05fn7" id="kch05fn7"><sup>7</sup></a> While symmetric key cryptography makes use of only one key, <em>asymmetric key cryptography</em>, also known as public key cryptography, uses two keys: a public key and a private key. You use the public key to encrypt data, and anyone can access the public key. You can see them included in email signatures or posted on servers that exist specifically to host public keys. Private keys, used to decrypt messages, are carefully guarded by the receiver. Cryptographers use complex mathematical operations to create the private and public keys. These operations—which typically involve factorizing very large prime numbers, as I discussed earlier in the chapter—are difficult enough that, currently, no method exists to discover the private key by using the public key.</p>&#13;
<p class="indent">The main advantage of asymmetric key cryptography over symmetric key cryptography is that you no longer need to distribute the key. In symmetric key cryptography, as discussed, the message sender needs to find a way of sharing the key with whomever they want to communicate with. They might do this by exchanging keys in person, sending a key in an email, or repeating it verbally over the phone, but the method must be secure enough to ensure the key isn’t intercepted. But with asymmetric key cryptography, you don’t have to share a secret key. You simply make your public key available, and anyone who needs to send you an encrypted message can use it without compromising the security of the system.</p>&#13;
<h5 class="h5"><span epub:type="pagebreak" id="page_71"/>Asymmetric Key Algorithms</h5>&#13;
<p class="noindent">The <em>RSA</em> algorithm, named after the initials of its creators, Ron Rivest, Adi Shamir, and Leonard Adleman, is an asymmetric algorithm used across the world, including in the Secure Sockets Layer (SSL) protocol. (<em>Protocols</em> are the rules that define communication between devices. SSL secures many common transactions, such as web and email traffic.) Created in 1977, RSA is still one of the most widely used algorithms in the world to this day.</p>&#13;
<p class="indent"><em>Elliptic curve cryptography (ECC)</em> is a class of cryptographic algorithms, although people sometimes refer to it as though it were a single algorithm. Named for the type of mathematical problem on which its cryptographic functions are based, elliptic curve cryptography has several advantages over other types of algorithms.</p>&#13;
<p class="indent">ECC can use short keys while maintaining a higher cryptographic strength than many other types of algorithms. It’s also a fast and efficient type of algorithm that allows us to easily implement it on hardware that has less processing power and memory, such as a cell phone or portable device. A variety of cryptographic algorithms, including the Secure Hash Algorithm 2 (SHA-2) and Elliptic Curve Digital Signature Algorithm (ECDSA), use ECC.</p>&#13;
<p class="indent">Other asymmetric algorithms include ElGamal, Diffie–Hellman, and Digital Signature Standard (DSS). Many protocols and applications are based on asymmetric cryptography, including Pretty Good Privacy (PGP) for securing messages and files, SSL and Transport Layer Security (TLS) for common internet traffic, and some voice over IP (VoIP) protocols for voice conversations.</p>&#13;
<div class="sidebar">&#13;
<p class="sidebart"><strong>PGP</strong></p>&#13;
<p class="noindent">PGP, created by Phil Zimmerman, was one of the first strong encryption tools to reach the eye of the public and the media. Created in the early 1990s, the original release of PGP was based on a symmetric algorithm, and you could use it to secure data such as communications and files. The original version of PGP was given away as free software, including the source code. At the time of its release, PGP was regulated as munitions under the US International Traffic in Arms Regulations (ITAR) law. Zimmerman spent several years under investigation for criminal activities when he was suspected of exporting PGP out of the country, which was illegal at the time and considered to be arms trafficking.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch05lev2sec6"><em>Hash Functions</em></h4>&#13;
<p class="noindent"><em>Hash functions</em> represent a third type of modern cryptography, which we call keyless cryptography. Instead of using a key, hash functions, or message digests, convert the plaintext into a largely unique and fixed-length value, <span epub:type="pagebreak" id="page_72"/>commonly referred to as a <em>hash</em>. You can think of these hash values as fingerprints because they’re unique identifiers of a message. Moreover, hashes of similar messages look completely different. <a href="#ch5fig7">Figure 5-7</a> shows some hashes.</p>&#13;
<div class="image" id="ch5fig7"><img alt="Image" src="../images/05fig07.jpg"/></div>&#13;
<p class="figcap"><em>Figure 5-7: A hash function generates a unique value for every message, no matter how similar the messages are.</em></p>&#13;
<p class="indent">Notice that the message we’re hashing in B differs from message A by only a single word, but it produces a completely different hash. The same is true for message C, which removes only a single space from the original message but still generates a unique hash. You can’t use hashes to discover the contents of the original message, or any of its other characteristics, but you can use it to determine whether the message has changed. This means that if you’re distributing files or sending communications, you can send the hash with the message so that the receiver can verify its integrity. To do this, the receiver simply hashes the message again using the same algorithm and then compares the two hashes. If the hashes match, the message has not changed. If they don’t match, the message has been altered.</p>&#13;
<p class="indent">Although it’s theoretically possible to engineer a matching hash for two different sets of data, called a <em>collision</em>, this is difficult and generally happens only if you’re using a broken hashing algorithm. Some algorithms, such as Message-Digest algorithm 5 (MD5) and Secure Hash Algorithm 1 (SHA-1), have been attacked in this fashion, although it’s uncommon (<a href="#ch5fig8">Figure 5-8</a>).</p>&#13;
<div class="image" id="ch5fig8"><img alt="Image" src="../images/05fig08.jpg"/></div>&#13;
<p class="figcap"><em>Figure 5-8: In a hash collision, two distinct messages produce the same hash.</em></p>&#13;
<p class="indent">When collisions occur, you generally stop using the compromised algorithm. Those who require stringent hash security have mostly stopped using MD5 and replaced it with SHA-2 and SHA-3.</p>&#13;
<p class="indent">Other hash algorithms include MD2, MD4, and RACE.</p>&#13;
<h4 class="h4" id="ch05lev2sec7"><em>Digital Signatures</em></h4>&#13;
<p class="noindent">Another way to use asymmetric algorithms and their associated public and private keys is to create digital signatures. A <em>digital signature</em> allows you to <span epub:type="pagebreak" id="page_73"/>sign a message so that others can detect any changes to the message after you’ve sent it, ensure that the message was legitimately sent by the expected party, and prevent the sender from denying that they sent the message (a principle known as <em>nonrepudiation</em>, covered in <a href="ch04.xhtml">Chapter 4</a>).</p>&#13;
<p class="indent">To digitally sign a message, the sender generates a hash of the message and then uses their private key to encrypt the hash. The sender then sends this digital signature along with the message, usually by appending it to the message itself.</p>&#13;
<p class="indent">When the message arrives at the receiving end, the receiver uses the public key corresponding to the sender’s private key to decrypt the digital signature, thus restoring the original hash of the message. The receiver can then verify the message’s integrity by hashing the message again and comparing the two hashes. This may sound like a considerable amount of work just to verify the integrity of the message, but software applications usually do it for you, so the process is typically invisible to the user.</p>&#13;
<h4 class="h4" id="ch05lev2sec8"><em>Certificates</em></h4>&#13;
<p class="noindent">In addition to hashes and digital signatures, you can use digital certificates to sign your messages. <em>Digital certificates</em>, as shown in <a href="#ch5fig9">Figure 5-9</a>, link a public key to an individual by validating that the key belongs to the proper owner, and they’re often used as a form of electronic identification for that person.</p>&#13;
<div class="image" id="ch5fig9"><img alt="Image" src="../images/05fig09.jpg"/></div>&#13;
<p class="figcap"><em>Figure 5-9: A digital certificate</em></p>&#13;
<p class="indent">You typically create a certificate by taking the public key and identifying information, such as a name and address, and having them signed by a trusted entity that handles digital certificates, called a <em>certificate authority</em>. A certificate authority is the entity that issues certificates. It acts as a trusted third party to both sides of transactions that involve certificates by signing the certificate to begin with and later verifying that it is still valid. One well-known certificate authority is VeriSign. Some large organizations, such as the US Department of Defense, may choose to implement their own certificate authority to keep costs down.</p>&#13;
<p class="indent">A certificate allows you to verify that a public key is truly associated with an individual. In the case of the digital signature discussed in the preceding section, someone might have falsified the keys used to sign the message; <span epub:type="pagebreak" id="page_74"/>maybe those keys did not actually belong to the original sender. If the sender had a digital certificate, you could easily check with the certificate authority to ensure that the public key for the sender is legitimate.</p>&#13;
<p class="indent">A certificate authority is only a small part of the infrastructure that you can put in place to handle certificates on a large scale. This infrastructure is known as a <em>public key infrastructure (PKI)</em>. A PKI usually has two main components: the certificate authorities that issue and verify certificates, and the registration authorities that verify the identity of the individual associated with the certificate, although some organizations may separate some functions out into more than just these.</p>&#13;
<p class="indent">A PKI might also revoke certificates if they reach their expiration date, are compromised, or shouldn’t be used for some other reason. In this case, the certificate will likely be added to a certificate revocation list, which is generally a public list that holds all an organization’s revoked certificates for a time.</p>&#13;
<h3 class="h3" id="ch05lev1sec3">Protecting Data at Rest, in Motion, and in Use</h3>&#13;
<p class="noindent">You can divide the practical uses of cryptography into three major categories: protecting data at rest, protecting data in motion, and protecting data in use. Data at rest includes the large amount of stored data on devices such as backup tapes, flash drives, and hard drives in portable devices such as laptops. Data in motion is the enormous amount of information sent over the internet, including financial transactions, medical information, tax filings, and other similarly sensitive exchanges. Data in use is data actively being accessed.</p>&#13;
<h4 class="h4" id="ch05lev2sec9"><em>Protecting Data at Rest</em></h4>&#13;
<p class="noindent">People often neglect to protect <em>data at rest</em>, which is data on a storage device of some kind that isn’t moving over a network, through a protocol, or across some other communication platform.</p>&#13;
<p class="indent">Somewhat illogically, data at rest can also, technically, be in motion. For example, you might ship a load of backup tapes containing sensitive data, carry a flash drive containing a copy of your tax forms in your pocket, or leave a laptop containing the contents of a customer database in the back seat of your car.</p>&#13;
<p class="indent">Attackers exploit this fact on a regular basis. For example, in 2017, someone found a USB flash drive in the street outside Heathrow Airport in London and discovered it contained information about the routes and security measures used to protect Queen Elizabeth II, as well as other high-ranking officials and dignitaries, when they move through the airport.<a href="notes.xhtml#ch05fn8" id="kch05fn8"><sup>8</sup></a></p>&#13;
<p class="indent">Had necessary steps been taken to protect the flash drive’s data at rest by encrypting it, the security incident would not have occurred (and authorities would not have had to publicly disclose that the incident had occurred, saving them from quite a bit of embarrassment).</p>&#13;
<h5 class="h5"><span epub:type="pagebreak" id="page_75"/>Data Security</h5>&#13;
<p class="noindent">We primarily use encryption to protect data at rest, particularly when we know that the device containing the data could be physically stolen.</p>&#13;
<p class="indent">An enormous number of commercial products provide encryption for portable devices. These often target hard drives and portable storage devices, including products from large companies such as Intel and Symantec, to name a few. These commercial products often encrypt entire hard disks (a process known as <em>full disk encryption</em>) and a variety of removable media, and they report back to centralized management servers or other security and administrative features. There are also several free or open source encryption products on the market, such as VeraCrypt,<a href="notes.xhtml#ch05fn9" id="kch05fn9"><sup>9</sup></a> BitLocker<a href="notes.xhtml#ch05fn10" id="kch05fn10"><sup>10</sup></a> (which ships with some versions of Windows), and dm-crypt<a href="notes.xhtml#ch05fn11" id="kch05fn11"><sup>11</sup></a> (which is specific to Linux).</p>&#13;
<h5 class="h5">Physical Security</h5>&#13;
<p class="noindent">Physical security, which I’ll discuss at length in <a href="ch09.xhtml">Chapter 9</a>, is an important part of protecting data at rest. If you make it more difficult for attackers to physically access or steal the storage media that contains sensitive data, you have solved a large portion of your problem.</p>&#13;
<p class="indent">In many cases, large businesses have databases, file servers, and workstations that contain customer information, sales forecasts, business strategy documents, network diagrams, and other kinds of data they want to keep from becoming public or falling into the hands of their competitors. If the physical security at the building that houses the data is weak, an attacker might be able to simply enter the building, steal a device, and walk right out with the data.</p>&#13;
<p class="indent">You also need to be aware of the areas you cannot physically protect and limit the data that leaves your protected spaces. In an office building, you could apply extra layers of physical security to the data center containing your servers, for example. Once sensitive data leaves such areas, your ability to protect it becomes more limited. In the case of the Heathrow flash drive that I discussed earlier, officials might have kept this sensitive data from being copied to an external drive to prevent it from walking out the door and being lost in the street.</p>&#13;
<h4 class="h4" id="ch05lev2sec10"><em>Protecting Data in Motion</em></h4>&#13;
<p class="noindent">Often, data travels over networks, whether it be a closed wide area network (WAN) or local area network (LAN), a wireless network, or the internet. To protect data exposed on a network, you will usually choose to either encrypt the data itself or encrypt the entire connection.</p>&#13;
<h5 class="h5">Protecting the Data Itself</h5>&#13;
<p class="noindent">You can take a variety of approaches to encrypting the data you are sending over the network, depending on the kind of data you are sending and the protocols over which you are sending it.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_76"/>You will often use SSL and TLS to encrypt a connection between two systems communicating over a network. SSL is TLS’s predecessor, although the terms are often used interchangeably, and they are nearly identical. SSL and TLS operate in conjunction with other protocols, such as Internet Message Access Protocol (IMAP) and Post Office Protocol (POP) for email, Hypertext Transfer Protocol (HTTP) for web traffic, and VoIP for voice conversations and instant messaging.</p>&#13;
<p class="indent">However, SSL and TLS protections generally apply to only a single application or protocol, so although you might be using them to encrypt your communications with the server that holds your email, this doesn’t necessarily mean the connections made through your web browser have the same level of security. Many common applications are capable of supporting SSL and TLS, but you generally need to configure them to do so independently.</p>&#13;
<h5 class="h5">Protecting the Connection</h5>&#13;
<p class="noindent">Another approach to protecting data in motion is encrypting all your network traffic with a virtual private network (VPN) connection. VPN connections use a variety of protocols to create a secure connection between two systems. You might use a VPN when you’re accessing data from a potentially insecure network, such as the wireless connection in a hotel.</p>&#13;
<p class="indent">The two most common protocols currently used to secure VPNs are Internet Protocol Security (IPsec) and SSL. You can configure these two types of VPN connections to have a nearly identical set of features and functionality, from the perspective of the user, but they require a slightly different set of hardware and software to set up.</p>&#13;
<p class="indent">Typically, an IPsec VPN requires a more complex hardware configuration on the back end, as well as a software client you have to install, whereas an SSL VPN often operates from a lightweight plug-in downloaded from a web page and a less complex hardware configuration on the back end. From a security standpoint, the two methods have relatively similar levels of encryption. One weakness of the SSL VPN client, however, is that you could download it to a public computer or other random insecure device and provide an avenue for data leakage or an attack.</p>&#13;
<h4 class="h4" id="ch05lev2sec11"><em>Protecting Data in Use</em></h4>&#13;
<p class="noindent">The last category of data to protect is the data currently being used. Although we can use encryption to protect data while it’s stored or moving across a network, we are somewhat limited in our ability to protect data while legitimate entities have access to it. Authorized users can print files, move them to other machines or storage devices, email them, share them on peer-to-peer file-sharing networks, and generally make a mockery of our meticulous security measures.</p>&#13;
<p class="indent">In June 2013, the public discovered that a government contractor named Edward Snowden had deliberately leaked classified information containing details about the US National Security Agency PRISM program, <span epub:type="pagebreak" id="page_77"/>which was ostensibly designed to collect and review terrorism-related communications.<a href="notes.xhtml#ch05fn12" id="kch05fn12"><sup>12</sup></a> Although this incident occurred more than five years ago at the time of this writing, the US intelligence community is still cleaning up after it and working to prevent another such incident.</p>&#13;
<h3 class="h3" id="ch05lev1sec4">Summary</h3>&#13;
<p class="noindent">Cryptography has existed in one form or another for most of recorded history. Early cryptographic practices varied in complexity, from the simple substitution ciphers of the Roman era to the complex electromechanical machines used before the invention of modern computing systems. Although such primitive cryptographic methods would not protect against modern cryptographic attacks, they form the basis for our modern algorithms.</p>&#13;
<p class="indent">Today, you conduct cryptography by using computers to create complex algorithms that encrypt your data. There are three main kinds of cryptographic algorithms: symmetric key cryptography, asymmetric key cryptography, and hash functions. In symmetric key cryptography, you encrypt and decrypt data with the same key, to which all parties operating on the plaintext or ciphertext have access. In asymmetric cryptography, you use both a public and a private key. The sender encrypts the message with the receiver’s public key, and the receiver decrypts the message with their private key. This resolves the problem of having to find a secure way to share a single private key between the receiver and the sender. Hash functions don’t use a key at all; they create a (theoretically) unique fingerprint of the message so that we can tell if the message has been altered from its original form.</p>&#13;
<p class="indent">Digital signatures are an extension of hash functions that allow you to not only create a hash to ensure that the message has not been altered but also encrypt the hash with the public key of an asymmetric algorithm to ensure that the message was sent by the expected party and to ensure nonrepudiation.</p>&#13;
<p class="indent">Certificates allow you to link a public key to an identity so that you can ensure that an encrypted message really represents a communication from a particular individual. The receiver can check with the issuer of the certificate—the certificate authority—to determine whether the certificate presented is, in fact, legitimate. Behind the certificate, you may find a PKI, which issues, verifies, and revokes certificates.</p>&#13;
<p class="indent">In general, cryptography provides a mechanism to protect data at rest, data in motion, and, to a certain extent, data in use. It provides the core of many of the basic security mechanisms that enable you to communicate and carry out transactions when the data involved is of a sensitive nature.</p>&#13;
<h3 class="h3" id="ch05lev1sec5">Exercises</h3>&#13;
<ol>&#13;
<li><p class="noindent">What type of cipher is a Caesar cipher?</p></li>&#13;
<li><p class="noindent">What is the difference between a block and a stream cipher?</p></li>&#13;
<li><p class="noindent">ECC is classified as which type of cryptographic algorithm?</p></li>&#13;
<li><p class="noindent"><span epub:type="pagebreak" id="page_78"/>What is the key point of Kerckhoffs’s second principle?</p></li>&#13;
<li><p class="noindent">What is a substitution cipher?</p></li>&#13;
<li><p class="noindent">What are the main differences between symmetric and asymmetric key cryptography?</p></li>&#13;
<li><p class="noindent">Explain how 3DES differs from DES.</p></li>&#13;
<li><p class="noindent">How does public key cryptography work?</p></li>&#13;
<li><p class="noindent">Try to decrypt this message using the information in this chapter: V qb abg srne pbzchgref. V srne gur ynpx bs gurz. —Vfnnp Nfvzbi.</p></li>&#13;
<li><p class="noindent">How is physical security important when discussing the cryptographic security of data?</p></li>&#13;
</ol>&#13;
</body></html>