<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch10">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_206" aria-label="206"/>&#13;
<figure class="co-img"><img id="fig-pg206" class="img60" src="../images/pg206.jpg" alt="" width="687" height="1737"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11"> <a href="description-25.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_207" aria-label="207"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch10">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">FILE SCOPE VARIABLE DECLARATIONS AND STORAGE-CLASS SPECIFIERS</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
&#13;
<figure class="opener"><img class="opener" src="../images/opener-img.jpg" alt="" width="407" height="405"/></figure>&#13;
<p class="ChapterIntro">We’ll wrap up <span class="chapterintro_Xref-1"><a href="part1.xhtml">Part I</a></span> by implementing a few important features related to function and variable declarations. We’ll add support for variable declarations at <i>file scope</i>—that is, at the top level of a source file—and introduce the <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> keywords. These keywords are <i>storage-class specifiers</i> that control a declaration’s linkage and the <i>storage duration</i> of the declared object (how long that object exists in memory).</p>&#13;
<p class="TX">We’ll spend most of this chapter on the semantic analysis stage, determining the linkage and storage duration of every declaration. We’ll also need a few new assembly directives to define and initialize different kinds of variables, but the changes to the compiler backend will be relatively simple. Let’s start by reviewing what the C standard has to say about declarations and storage-class specifiers. I recommend reading the following section even if you already know C pretty well. This part of the language looks very <span role="doc-pagebreak" epub:type="pagebreak" id="pg_208" aria-label="208"/>different to a compiler developer than it does to a C programmer, largely because your compiler needs to support behavior that no sensible C programmer would use.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-80"/><samp class="SANS_Futura_Std_Bold_B_11">All About Declarations</samp></h3>&#13;
<p class="TNI">Every declaration in a source file has several properties we need to track, each of which we’ll examine in this section. These include the declaration’s scope, its linkage, and whether it’s a definition as well as a declaration. (Its type is also important, but we won’t have anything new to say about that in this chapter.) We also need to track the storage duration of every variable in the program.</p>&#13;
<p class="TX">The rules for determining these properties are baroque. They depend on whether an identifier refers to a function or variable, whether it’s declared at file scope or at <i>block scope</i> (inside a function body), and which storage-class specifier is applied to it. The <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> specifier has two distinct meanings, which apply in different contexts. The <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> specifier has multiple, seemingly unrelated effects; these also depend on context. (The other storage-class specifiers—<samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">register</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">_Thread_local</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>—serve a hodgepodge of different purposes that I won’t get into here. We won’t be implementing those.) Basically, this part of the C standard is a mess, but we’ll do our best to wade through it.</p>&#13;
<p class="TX">The terminology around declarations in C can be inconsistent, so I’ll spell out how I’m using a few terms before we get started:</p>&#13;
<ul class="BL">&#13;
<li class="ListBullet">A <i>file</i> or <i>source file</i> is a preprocessed source file, referred to in the C standard (and the previous chapter) as a “translation unit.”</li>&#13;
<li class="ListBullet">A <i>static variable</i> is a variable with static storage duration (discussed in <span class="listbullet_Xref">“Storage Duration” on <a href="#pg_212">page 212</a></span>), not just a variable declared with the <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> storage-class specifier. All variables with the <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> specifier are static variables, but not all static variables are declared with that specifier.</li>&#13;
<li class="ListBullet">An <i>automatic variable</i> is a variable with automatic storage duration (also discussed in <span class="listbullet_Xref">“Storage Duration”</span>), as opposed to static storage duration. All the variables we encountered in earlier chapters were automatic variables.</li>&#13;
<li class="ListBullet">An <i>external variable</i> is any variable with internal or external linkage, not just a variable declared with the <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> storage-class specifier. As we’ll see, all external variables are also static variables, but not all static variables are external.</li>&#13;
</ul>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h4 class="H2" id="sec2"><span id="h2-64"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Scope</samp></h4>&#13;
<p class="TNI">Functions and variables follow the same scoping rules. Variables can be declared at either file scope or block scope, just like functions. File scope variables, like functions and block scope variables, must be declared before they can be used and may be shadowed by later block scope identifiers. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_209" aria-label="209"/>Since you already know the rules for determining an identifier’s scope, there’s not much more to say here.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h2-65"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Linkage</samp></h4>&#13;
<p class="TNI">Up to this point, function declarations have always had external linkage: every declaration of a particular function name referred to the same function definition. The local variable declarations we’ve seen so far had no linkage: different declarations of the same variable name always referred to different objects. By default, variable declarations at file scope have external linkage, just like function declarations. Whenever there are multiple file scope declarations of the same identifier, the compiler needs to either reconcile them, so they can all refer to the same thing, or throw an error.</p>&#13;
<p class="TX">Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> specifier, we can also declare functions and variables with <i>internal linkage</i>. Internal linkage works like external linkage, except that declarations with internal linkage never refer to entities in other files. To illustrate the difference, let’s consider a program made up of two source files. <a href="chapter10.xhtml#list10-1">Listing 10-1</a> shows the first file.</p>&#13;
<a id="list10-1"/>&#13;
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">❶</span> int foo(void) {&#13;
    return 1;&#13;
}&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">❷</span> int bar(void) {&#13;
    return 2;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-1: A source file defining two functions with external linkage</samp></p>&#13;
<p class="TX"><a href="chapter10.xhtml#list10-2">Listing 10-2</a> shows the second file.</p>&#13;
<a id="list10-2"/>&#13;
<pre><code><span class="CodeAnnotationHang" aria-label="annotation3">❸</span> int foo(void);&#13;
<span class="CodeAnnotationHang" aria-label="annotation4">❹</span> static int bar(void);&#13;
&#13;
int main(void) {&#13;
    return foo() + bar();&#13;
}&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation5">❺</span> static int bar(void) {&#13;
    return 4;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-2: A source file declaring one function with internal linkage (</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">bar</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">) and two functions with external linkage (</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">foo</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">main</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">)</samp></p>&#13;
<p class="TX">In <a href="chapter10.xhtml#list10-1">Listing 10-1</a>, we define two functions with external linkage: <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span> and <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. <a href="chapter10.xhtml#list10-2">Listing 10-2</a> also includes declarations of identifiers <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> <span class="CodeAnnotation" aria-label="annotation3">❸</span> and <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp> <span class="CodeAnnotation" aria-label="annotation4">❹</span><span class="CodeAnnotation" aria-label="annotation5">❺</span>. First, let’s figure out what <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> means in <a href="chapter10.xhtml#list10-2">Listing 10-2</a>. Because the declaration at <span class="CodeAnnotation" aria-label="annotation3">❸</span> does not include the <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> specifier, it has external linkage. Therefore, declarations <span class="CodeAnnotation" aria-label="annotation1">❶</span> and <span class="CodeAnnotation" aria-label="annotation3">❸</span> refer to the same function, which is defined at <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_210" aria-label="210"/>Next, let’s consider <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp>. Because the declaration at <span class="CodeAnnotation" aria-label="annotation4">❹</span> includes the <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> specifier, it has internal linkage. That means it doesn’t refer to the definition at <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Instead, it declares a brand-new function. The definition of this function appears later, at <span class="CodeAnnotation" aria-label="annotation5">❺</span>. Since declarations <span class="CodeAnnotation" aria-label="annotation4">❹</span> and <span class="CodeAnnotation" aria-label="annotation5">❺</span> both have internal linkage and appear in the same file, they refer to the same function. Therefore, <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> will use the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp> at <span class="CodeAnnotation" aria-label="annotation5">❺</span> to compute <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp> and return <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>.</p>&#13;
<p class="TX">Note that identifiers with internal linkage don’t shadow identifiers with external linkage, or vice versa. The declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp> in <a href="chapter10.xhtml#list10-2">Listing 10-2</a> doesn’t shadow the definition at <span class="CodeAnnotation" aria-label="annotation2">❷</span> in <a href="chapter10.xhtml#list10-1">Listing 10-1</a>; rather, that definition was never visible in <a href="chapter10.xhtml#list10-2">Listing 10-2</a> to begin with, because no declaration in <a href="chapter10.xhtml#list10-2">Listing 10-2</a> refers to it. If an identifier is declared with both internal and external linkage in the same file, the behavior is undefined, and most compilers will throw an error.</p>&#13;
<p class="TX">Section 6.2.2 of the C standard lays out the rules for determining identifier linkage, which I’ll summarize here. A declaration’s linkage depends on two things: what storage-class specifier it includes, if any, and whether it’s declared at block or file scope. Function declarations with no storage-class specifier are always handled as though they include an <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> specifier, which we’ll discuss momentarily. If variable declarations with no storage-class specifier appear at block scope, they have no linkage. If they appear at file scope, they have external linkage.</p>&#13;
<p class="TX">At file scope, the <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> specifier indicates that a function or variable has internal linkage. At block scope, the <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> specifier controls storage duration, not linkage. Variables declared with this specifier at block scope have no linkage, just like variables declared with no specifier. It’s illegal to declare <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> functions at block scope, because functions don’t have storage duration.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> specifier is more complicated. If an identifier is declared with <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> at a point where a prior declaration of that identifier is visible, and the prior declaration has internal or external linkage, the new declaration will have the same linkage as the previous one. If no prior declaration is visible, or the prior declaration had no linkage, an <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> declaration will have external linkage.</p>&#13;
<p class="TX">In <a href="chapter10.xhtml#list10-3">Listing 10-3</a>, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> to declare an identifier that’s already visible.</p>&#13;
<a id="list10-3"/>&#13;
<pre><code>static int a;&#13;
extern int a;</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-3: Declaring an identifier with</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">extern</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">when a prior declaration is visible</samp></p>&#13;
<p class="TX">The first declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> has internal linkage because of the <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> keyword. Because the second declaration is declared with the <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> keyword at a point where the first declaration is visible, it will have internal linkage too.</p>&#13;
<p class="TX">In <a href="chapter10.xhtml#list10-4">Listing 10-4</a>, on the other hand, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> at a point where no prior declaration is visible.</p>&#13;
<a id="list10-4"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_211" aria-label="211"/>int main(void) {&#13;
    extern int a;&#13;
    return a;&#13;
}&#13;
&#13;
int a = 5;</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-4: Using</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">extern</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to declare a variable with external linkage at block scope</samp></p>&#13;
<p class="TX">The declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> inside <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> and the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> later in the file both have external linkage, so they refer to the same object. Therefore, <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> will return <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>.</p>&#13;
<p class="TX">You can use <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> to bring a variable with external linkage back into scope if it’s shadowed by a local variable. <a href="chapter10.xhtml#list10-5">Listing 10-5</a> shows how this works.</p>&#13;
<a id="list10-5"/>&#13;
<pre><code>int a = 4;&#13;
int main(void) {&#13;
    int a = 3;&#13;
    {&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> extern int a;&#13;
        return a;&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-5: Using</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">extern</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to bring a shadowed variable with external linkage back into scope</samp></p>&#13;
<p class="TX">When we declare <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> with the <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> specifier in <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span>, no prior declaration with internal or external linkage is visible. (The initial file scope declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> has external linkage, but it’s hidden by the second declaration at block scope. The block scope declaration is visible, but it has no linkage.) Therefore, this <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> declaration has external linkage. Since the earlier file scope declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> also has external linkage, both declarations refer to the same variable. We then use this variable in the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement on the next line. As a result, <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> returns <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>.</p>&#13;
<p class="TX">Earlier, I mentioned that function declarations without a storage-class specifier are always handled as though they include the <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> specifier. Consider how this rule impacts the linkage of the function definition in <a href="chapter10.xhtml#list10-6">Listing 10-6</a>.</p>&#13;
<a id="list10-6"/>&#13;
<pre><code>static int my_fun(void);&#13;
int my_fun(void) {&#13;
    return 0;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-6: A function declaration with the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">static</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">specifier, followed by a definition of that function with no storage-class specifier</samp></p>&#13;
<p class="TX">As we saw in <a href="chapter10.xhtml#list10-3">Listing 10-3</a>, a declaration with the <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> specifier takes on the same linkage as the previous declaration of that identifier, if one is visible. Since we treat the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">my_fun</samp> as if it had the <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> specifier, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_212" aria-label="212"/>it will take on the same linkage as the declaration on the previous line; that is, internal linkage. This rule implies that including <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> on function declarations is always redundant (with the exception of inline functions, which we won’t implement).</p>&#13;
<p class="TX">Next, we’ll consider a concept that’s new to this chapter: storage duration.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-66"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Storage Duration</samp></h4>&#13;
<p class="TNI">Storage duration is a property of variables; functions don’t have storage duration. Section 6.2.4, paragraphs 1–2, of the C standard provides the following description: “An object has a <i>storage duration</i> that determines its lifetime.… The <i>lifetime</i> of an object is the portion of program execution during which storage is guaranteed to be reserved for it. An object exists, has a constant address, and retains its last-stored value throughout its lifetime.” In other words, during an object’s lifetime, you can work with it in the usual fashion: you can write to it, read from it, and get back the last value you wrote. The object won’t be deallocated or reinitialized during that time.</p>&#13;
<p class="TX">In this chapter, we’ll consider two kinds of storage duration: automatic and static. All the variables we saw in earlier chapters had <i>automatic storage duration</i>. The lifetime of a variable with automatic storage duration starts when you enter the block where it’s declared and ends when you exit that block. This means you can’t, for example, use an automatic variable to track how many times a function has been called. To understand why, take a look at <a href="chapter10.xhtml#list10-7">Listing 10-7</a>, which tries to do exactly that.</p>&#13;
<a id="list10-7"/>&#13;
<pre><code>#include &lt;stdio.h&gt;&#13;
&#13;
int recursive_call(int count_was_initialized) {&#13;
    int count;&#13;
    if(!count_was_initialized) {&#13;
        count = 0;&#13;
        count_was_initialized = 1;&#13;
    }&#13;
    count = count + 1;&#13;
    printf("This function has been called %d times\n", count);&#13;
    if (count &lt; 20) {&#13;
        recursive_call(count_was_initialized);&#13;
    }&#13;
    return 0;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-7: An incorrect attempt to share an automatic variable’s value among multiple function calls</samp></p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">recursive_call</samp> function in <a href="chapter10.xhtml#list10-7">Listing 10-7</a> tries to initialize a local variable, <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp>, the first time it’s called, then increment it on every subsequent invocation. This won’t work, because <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> has automatic storage duration; every invocation of <samp class="SANS_TheSansMonoCd_W5Regular_11">recursive_call</samp> will allocate a new, uninitialized copy of <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp>, which is then deallocated when that invocation returns.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_213" aria-label="213"/>If a variable has <i>static storage duration</i>, on the other hand, its lifetime lasts for the entire duration of the program. Variables with static storage duration are initialized once, before the program starts, and their lifetime ends when the program exits.</p>&#13;
<p class="TX">The rules for determining storage duration are simple: all variables declared at file scope have static storage duration, as do all variables declared at block scope with the <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> keyword. All variables declared at block scope without a storage-class specifier have automatic storage duration. The standard also defines <i>allocated storage duration</i>, which we’ll discuss when we add support for <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> in <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>, and <i>thread storage duration</i>, which we won’t implement in this book.</p>&#13;
<p class="TX">We can use a static counter to fix <a href="chapter10.xhtml#list10-7">Listing 10-7</a>. <a href="chapter10.xhtml#list10-8">Listing 10-8</a> shows the correct implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">recursive_call</samp>.</p>&#13;
<a id="list10-8"/>&#13;
<pre><code>#include &lt;stdio.h&gt;&#13;
&#13;
int recursive_call(void) {&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> static int count = 0;&#13;
    count = count + 1;&#13;
    printf("This function has been called %d times\n", count);&#13;
    if (count &lt; 20) {&#13;
        recursive_call();&#13;
    }&#13;
    return 0;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-8: Correctly sharing a static variable’s value among multiple function calls</samp></p>&#13;
<p class="TX">Now, because <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> is declared with the <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> keyword <span class="CodeAnnotation" aria-label="annotation1">❶</span>, it has static storage duration. We’ll allocate <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> and initialize it to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> just once, before the program starts. Then, we’ll increment that same <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> variable on each invocation of <samp class="SANS_TheSansMonoCd_W5Regular_11">recursive_call</samp>.</p>&#13;
<p class="TX">We don’t initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> again when we reach its declaration inside <samp class="SANS_TheSansMonoCd_W5Regular_11">recursive_call</samp>. The declaration marks the point in the program where the variable is brought into scope, not the point during execution when it’s initialized. It’s important to understand that a static variable’s scope and its lifetime are unrelated. In <span class="Xref-1"><a href="chapter7.xhtml">Chapter 7</a></span>, I described a variable’s scope as the part of the program where it can be used. Now we need to refine that definition and specify that it’s the part of the program’s <i>source code</i> where the variable can be used. A variable’s lifetime, on the other hand, is the part of <i>program execution</i> when the variable has an address and a value. For automatic variables, scope and lifetime are so closely linked that this distinction is almost irrelevant: the variable’s lifetime begins when you start executing the block where it’s in scope and ends when you finish executing that block. But a static variable’s lifetime is independent of its scope. In <a href="chapter10.xhtml#list10-8">Listing 10-8</a>, for example, the lifetime of <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> lasts for the whole duration of the program, but its scope extends only from the point where it’s declared in <samp class="SANS_TheSansMonoCd_W5Regular_11">recursive _call</samp> until the end of the function.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_214" aria-label="214"/>Because static variables are initialized before startup, their initializers must be constant. <a href="chapter10.xhtml#list10-9">Listing 10-9</a> shows two file scope declarations, one of which has an invalid initializer.</p>&#13;
<a id="list10-9"/>&#13;
<pre><code>int first_var = 3;&#13;
int second_var = first_var + 1;</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-9: File scope variable declarations with valid and invalid initializers</samp></p>&#13;
<p class="TX">Both <samp class="SANS_TheSansMonoCd_W5Regular_11">first_var</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">second_var</samp> have static storage duration because they’re declared at file scope. The initializer for <samp class="SANS_TheSansMonoCd_W5Regular_11">first_var</samp> is valid because it’s a constant. However, the initializer for <samp class="SANS_TheSansMonoCd_W5Regular_11">second_var</samp> is invalid because you can’t compute expressions like <samp class="SANS_TheSansMonoCd_W5Regular_11">first_var</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> before the program starts.</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>The C standard permits static variables to be initialized with constant expressions, like 1 + 1, because those can be computed at compile time. To make our lives a little easier, our compiler will support only constant values in initializers, not constant expressions.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h2-67"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Definitions vs. Declarations</samp></h4>&#13;
<p class="TNI">In the previous chapter, we had to distinguish between function definitions and function declarations. In this chapter, we’ll extend that distinction to variables. If a variable is defined, our assembly program will need to allocate storage for it and possibly initialize it. If it’s declared but not defined, we won’t allocate storage for it; we’ll rely on the linker to find the definition in another object file. Like a function, a variable can be declared many times but defined only once.</p>&#13;
<p class="TX">It’s easy to recognize function definitions, because they have bodies. Figuring out what counts as a variable definition is a little trickier. Let’s walk through the rules so you know which variable declarations are also definitions and which ones aren’t. We’ll also discuss how (and when) to initialize variables that are defined without explicit initializers.</p>&#13;
<p class="TX">First, every variable declaration with an initializer is a definition. This is unsurprising, since you can’t initialize a variable if you haven’t allocated storage for it. Second, every variable declaration without linkage is a definition. A variable declaration that didn’t have linkage and wasn’t a definition would be completely useless: a variable with no linkage can’t be declared more than once, so you’d have no way to define the variable elsewhere in the program.</p>&#13;
<p class="TX">How we initialize a variable without linkage depends on its storage duration. Recall that local variables in previous chapters were allocated space on the stack, but not necessarily initialized. Local static variables, as we’ll see in a moment, are allocated space in a different memory segment, and they’re always initialized. If no explicit initializer is provided, they’re initialized to zero.</p>&#13;
<p class="TX">If a variable declaration has the <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> specifier and no initializer, it’s not a definition. Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> variable declarations at block scope can’t have initializers. Therefore, they are never definitions. (This is analogous to <span role="doc-pagebreak" epub:type="pagebreak" id="pg_215" aria-label="215"/>the fact that you can declare functions at block scope, but not define them.) We can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> specifier to declare variables that are defined elsewhere in the same file, like in <a href="chapter10.xhtml#list10-10">Listing 10-10</a>.</p>&#13;
<a id="list10-10"/>&#13;
<pre><code>extern int three;&#13;
&#13;
int main(void) {&#13;
    return three;&#13;
}&#13;
&#13;
int three = 3;</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-10: Declaring an external variable at the start of a file and defining it at the end</samp></p>&#13;
<p class="TX">The declaration at the beginning of the listing brings <samp class="SANS_TheSansMonoCd_W5Regular_11">three</samp> into scope, and the definition at the end of the listing determines its initial value, <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> specifier also lets us declare variables that are defined in other files, like in <a href="chapter10.xhtml#list10-11">Listing 10-11</a>.</p>&#13;
<a id="list10-11"/>&#13;
<pre><code>extern int external_var;&#13;
&#13;
int main(void) {&#13;
    return 1 + external_var;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-11: Declaring a variable without defining it</samp></p>&#13;
<p class="TX">Because <samp class="SANS_TheSansMonoCd_W5Regular_11">external_var</samp> isn’t defined in this file, the compiler won’t allocate or initialize it. The linker will either find its definition in another file or throw an error.</p>&#13;
<p class="TX">A variable declaration with internal or external linkage, no <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> specifier, and no initializer is a <i>tentative definition</i>. <a href="chapter10.xhtml#list10-12">Listing 10-12</a> shows an example.</p>&#13;
<a id="list10-12"/>&#13;
<pre><code>int x;&#13;
&#13;
int main(void) {&#13;
    return x;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-12: A tentative definition</samp></p>&#13;
<p class="TX">The only definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> in this file is the tentative definition on the first line. If a variable is tentatively defined, we’ll initialize it to zero. Therefore, the first line of <a href="chapter10.xhtml#list10-12">Listing 10-12</a> is treated exactly like the following non-tentative definition:</p>&#13;
<pre><code>int x = 0;</code></pre>&#13;
<p class="TX">If a file contains both a tentative definition and an explicitly initialized definition of the same variable, like in <a href="chapter10.xhtml#list10-13">Listing 10-13</a>, the explicit definition takes precedence.</p>&#13;
<a id="list10-13"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_216" aria-label="216"/>int x;&#13;
&#13;
int main(void) {&#13;
    return x;&#13;
}&#13;
&#13;
int x = 3;</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-13: A tentative definition followed by an explicit definition</samp></p>&#13;
<p class="TX">This listing starts with a tentative definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and ends with a non-tentative definition. The non-tentative definition takes precedence, so <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is initialized to <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>. The first line is treated like a declaration, exactly as it would be if it included the <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> specifier.</p>&#13;
<p class="TX">Although it’s illegal to define a variable more than once, having multiple tentative definitions of a variable is perfectly fine. Consider the file scope declarations in <a href="chapter10.xhtml#list10-14">Listing 10-14</a>.</p>&#13;
<a id="list10-14"/>&#13;
<pre><code>int a;&#13;
int a;&#13;
extern int a;&#13;
int a;</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-14: Three tentative definitions and a declaration</samp></p>&#13;
<p class="TX">Here, we have three tentative definitions of <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and one declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> that isn’t a definition due to its <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> specifier. Because there are no non-tentative definitions of <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>, it will be initialized to zero. <a href="chapter10.xhtml#list10-14">Listing 10-14</a> therefore will be compiled as though it contained the following line:</p>&#13;
<pre><code>int a = 0;</code></pre>&#13;
<p class="TX"><a href="chapter10.xhtml#tab10-1">Tables 10-1</a> and <a href="chapter10.xhtml#tab10-2">10-2</a> summarize how an identifier’s linkage, storage duration, and status as a definition are determined. The leftmost columns, Scope and Specifier, refer to a declaration’s syntax; we’ll know a declaration’s scope and storage-class specifier after parsing. The remaining columns are properties that we’ll need to determine during the semantic analysis stage based on the declaration’s syntax.</p>&#13;
<p class="TX"><a href="chapter10.xhtml#tab10-1">Table 10-1</a> covers variable declarations.</p>&#13;
<p class="TT" id="tab10-1"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 10-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">Properties of Variable Declarations</samp></p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_217" aria-label="217"/>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" rowspan="2" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Scope</samp></p></th>&#13;
<th class="Basic-Table TCH" rowspan="2" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Specifier</samp></p></th>&#13;
<th class="Basic-Table TCH" rowspan="2" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Linkage</samp></p></th>&#13;
<th class="Basic-Table TCH" rowspan="2" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Storage duration</samp></p></th>&#13;
<th class="Basic-Table TCH" colspan="2" scope="colgroup"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Definition?</samp></p></th>&#13;
</tr>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">With initializer</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Without initializer</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table graybg TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">File scope</samp></p></td>&#13;
<td class="Basic-Table graybg TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">None</samp></p></td>&#13;
<td class="Basic-Table graybg TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">External</samp></p></td>&#13;
<td class="Basic-Table graybg TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Static</samp></p></td>&#13;
<td class="Basic-Table graybg TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Yes</samp></p></td>&#13;
<td class="Basic-Table graybg TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Tentative</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table graybg  TB"/>&#13;
<td class="Basic-Table graybg  TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp></p></td>&#13;
<td class="Basic-Table graybg  TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Internal</samp></p></td>&#13;
<td class="Basic-Table graybg  TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Static</samp></p></td>&#13;
<td class="Basic-Table graybg  TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Yes</samp></p></td>&#13;
<td class="Basic-Table graybg  TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Tentative</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table graybg  TB"/>&#13;
<td class="Basic-Table graybg  TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp></p></td>&#13;
<td class="Basic-Table graybg  TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Matches prior visible declaration; external by default</samp></p></td>&#13;
<td class="Basic-Table graybg  TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Static</samp></p></td>&#13;
<td class="Basic-Table graybg  TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Yes</samp></p></td>&#13;
<td class="Basic-Table graybg  TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">No</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Block scope</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">None</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">None</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Automatic</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Yes</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Yes (defined but uninitialized)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"/>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">None</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Static</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Yes</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Yes (initialized to zero)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"/>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Matches prior visible declaration; external by default</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Static</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Invalid</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">No</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX"><a href="chapter10.xhtml#tab10-2">Table 10-2</a> covers function declarations.</p>&#13;
<p class="TT" id="tab10-2"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 10-2:</samp></span> <samp class="SANS_Futura_Std_Book_11">Properties of Function Declarations</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" rowspan="2" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Scope</samp></p></th>&#13;
<th class="Basic-Table TCH" rowspan="2" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Specifier</samp></p></th>&#13;
<th class="Basic-Table TCH" rowspan="2" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Linkage</samp></p></th>&#13;
<th class="Basic-Table TCH" colspan="2" scope="colgroup"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Definition?</samp></p></th>&#13;
</tr>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">With body</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Without body</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table graybg TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">File scope</samp></p></td>&#13;
<td class="Basic-Table graybg TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">None or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp></p></td>&#13;
<td class="Basic-Table graybg TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Matches prior visible declaration; external by default</samp></p></td>&#13;
<td class="Basic-Table graybg TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Yes</samp></p></td>&#13;
<td class="Basic-Table graybg TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">No</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table graybg TB"/>&#13;
<td class="Basic-Table graybg TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp></p></td>&#13;
<td class="Basic-Table graybg TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Internal</samp></p></td>&#13;
<td class="Basic-Table graybg TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Yes</samp></p></td>&#13;
<td class="Basic-Table graybg TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">No</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Block scope</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">None or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Matches prior visible declaration; external by default</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Invalid</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">No</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"/>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Invalid</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Invalid</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Invalid</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Note that the parameters in a function definition have automatic storage duration and no linkage, much like block scope variables with no storage-class specifier.</p>&#13;
<p class="TX">At this point, you understand the most important properties of declarations. You know how to determine a declaration’s linkage, its storage duration, and whether it defines an entity as well as declaring it. You also understand how these properties affect what you can do with an identifier. Next, let’s talk about what can go wrong.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h2-68"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Error Cases</samp></h4>&#13;
<p class="TNI">We’ll need to detect a whole slew of error cases in this chapter. Some of these error cases will be familiar from earlier chapters, although the details will change to account for our new language constructs. Other error cases we’ll handle are brand-new.</p>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h5 class="H3" id="sec7"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Conflicting Declarations</samp></h5>&#13;
<p class="TNI">There are a bunch of ways that declarations can conflict. Our compiler already detects some of them. For example, it detects the error when two declarations of an identifier appear in the same local scope and at least one of them has no linkage. This is an error because you can’t resolve later uses of that identifier to a single entity.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_218" aria-label="218"/>As I mentioned earlier, it’s also an error to declare the same identifier with both internal and external linkage. This is an issue even if the two declarations are in completely different parts of the source file. For example, <a href="chapter10.xhtml#list10-15">Listing 10-15</a> includes conflicting declarations.</p>&#13;
<a id="list10-15"/>&#13;
<pre><code>int main(void) {&#13;
    extern int foo;&#13;
    return foo;&#13;
}&#13;
&#13;
static int foo = 3;</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-15: Variable declarations with conflicting linkage</samp></p>&#13;
<p class="TX">At the point where <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> is declared in <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>, no other declaration is visible. (When a variable becomes visible depends on where it’s declared in the source code of the program, not when it’s initialized during program execution.) Based on the rules we discussed earlier, this means that <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> has external linkage. Later in the listing, however, <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> is declared at file scope with internal linkage. You can’t define the same object with both internal and external linkage, so this is illegal.</p>&#13;
<aside class="box" aria-label="box-5"><p class="BoxTitle" id="box-5"><samp class="SANS_Dogma_OT_Bold_B_11">UNDEFINED BEHAVIOR ALERT!</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">Declaring an identifier with both internal and external linkage results in undefined behavior. Compilers aren’t technically required to throw an error when declarations have conflicting linkage, but they almost always do. Interestingly, the following program features an edge case where GCC throws an error but Clang doesn’t:</samp></p>&#13;
<pre><code>static int foo = 0;&#13;
&#13;
int main(void) {&#13;
    int foo = 1;&#13;
    {&#13;
        extern int foo;&#13;
        return foo;&#13;
    }&#13;
}&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">I couldn’t figure out why GCC was rejecting this program, until I found a</samp> <samp class="SANS_Futura_Std_Book_11">nice explanation by Joseph Myers in the GCC bug tracker (</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11"><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=90472#c3">https://<wbr/>gcc<wbr/>.gnu<wbr/>.org<wbr/>/bugzilla<wbr/>/show<wbr/>_bug<wbr/>.cgi<wbr/>?id<wbr/>=90472#c3</a></samp><samp class="SANS_Futura_Std_Book_11">). The defining feature of this edge case is the block scope</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> <samp class="SANS_Futura_Std_Book_11">declaration of a variable that’s already in scope, but shadowed. The first declaration of</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> <samp class="SANS_Futura_Std_Book_11">has internal linkage. The</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> <samp class="SANS_Futura_Std_Book_11">declaration in</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> <samp class="SANS_Futura_Std_Book_11">should have external linkage, because it occurs when the first declaration isn’t visible. That would result in a conflict with the first declaration.</samp> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_219" aria-label="219"/><samp class="SANS_Futura_Std_Book_11">GCC reports this conflict and fails. However, Clang gives the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> <samp class="SANS_Futura_Std_Book_11">declaration internal linkage and carries on without complaint, as though the first declaration were visible. We’ll handle this edge case the way Clang does and not throw an error.</samp></p>&#13;
</aside>&#13;
<p class="TX">Finally, two declarations of the same entity conflict if they have different types. Declaring an external variable and a function with the same name is illegal. Again, this is the case even in programs like <a href="chapter10.xhtml#list10-16">Listing 10-16</a>, where the conflicting declarations are in completely different parts of the program.</p>&#13;
<a id="list10-16"/>&#13;
<pre><code>int foo = 3;&#13;
&#13;
int main(void) {&#13;
    int foo(void);&#13;
    return foo();&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-16: Declarations with conflicting types</samp></p>&#13;
<p class="TX">Because both declarations of <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> have external linkage, they should refer to the same entity, but that’s impossible since one is a function declaration and one is a variable declaration. This program is therefore invalid.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h5 class="H3" id="sec8"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Multiple Definitions</samp></h5>&#13;
<p class="TNI">We’ve already seen that it’s illegal to define a function multiple times in the same program. Having multiple definitions of an external variable is illegal too. If an external variable is defined multiple times in the same file, your compiler should produce an error. If a function or variable is defined in more than one file, your compiler can’t catch the error, but the linker will.</p>&#13;
<aside class="box" aria-label="box-122"><p class="BoxTitle" id="box-122"><samp class="SANS_Dogma_OT_Bold_B_11">UNDEFINED BEHAVIOR ALERT!</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">A tentative definition is tentative only within the file where it’s declared. It still conflicts with definitions of the same variable in other files. Let’s look at a program that includes two source files. Here’s the first file:</samp></p>&#13;
<pre><code>int var = 4;&#13;
</code></pre>&#13;
<p class="BoxBody"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_220" aria-label="220"/><samp class="SANS_Futura_Std_Book_11">And here’s the second:</samp></p>&#13;
<pre><code>int var;&#13;
int main(void) {&#13;
    return var;&#13;
}&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">This program’s behavior is undefined because</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> <samp class="SANS_Futura_Std_Book_11">is defined more than once. The first file explicitly defines and initializes</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp><samp class="SANS_Futura_Std_Book_11">. The second file includes one tentative definition of</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp><samp class="SANS_Futura_Std_Book_11">, which should be treated like a definition because</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> <samp class="SANS_Futura_Std_Book_11">isn’t defined elsewhere in the file.</samp></p>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">We normally get an error at link time if a variable is defined in two different files. But, given the right compiler options, both Clang and GCC will compile this program without errors or warnings. They can avoid errors at link time thanks to</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">common symbols</samp><samp class="SANS_Futura_Std_Book_11">, which are essentially tentative definitions at the binary level. A common symbol tells the linker to allocate space for and initialize a symbol, unless that symbol is defined in another object file.</samp></p>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">Our implementation doesn’t use common symbols, so it can’t compile this program.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h5 class="H3" id="sec9"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">No Definitions</samp></h5>&#13;
<p class="TNI">This kind of error applies to both functions and variables. If you use an identifier that’s declared but never defined, you’ll get an error at link time, when the linker tries to find the definition and fails. Because this is a link-time error, your compiler doesn’t need to detect it.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h5 class="H3" id="sec10"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Invalid Initializers</samp></h5>&#13;
<p class="TNI">As we’ve already seen, the initializer for a static variable must be a constant. An <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> declaration at block scope can’t have any initializer, not even a constant one.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h5 class="H3" id="sec11"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Restrictions on Storage-Class Specifiers</samp></h5>&#13;
<p class="TNI">You can’t apply the <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> specifier to function parameters or variables declared in <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop headers. You also can’t apply <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> to function declarations at block scope. (You can apply <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> to them, but it doesn’t do anything.)</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h3 class="H1" id="sec12"><span id="h1-81"/><samp class="SANS_Futura_Std_Bold_B_11">Linkage and Storage Duration in Assembly</samp></h3>&#13;
<p class="TNI">As we extend each stage of the compiler—especially the semantic analysis stage—it will be helpful to understand how the concepts we covered in the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_221" aria-label="221"/>previous section translate into assembly. I’ll discuss linkage first, then storage duration. Linkage is pretty straightforward: if an identifier has external linkage, we’ll emit a <samp class="SANS_TheSansMonoCd_W5Regular_11">.globl</samp> directive for the corresponding assembly label. If an identifier doesn’t have external linkage, we won’t emit a <samp class="SANS_TheSansMonoCd_W5Regular_11">.globl</samp> directive. The <samp class="SANS_TheSansMonoCd_W5Regular_11">.globl</samp> directive applies the same way to both function and variable names.</p>&#13;
<p class="TX">Now let’s talk storage duration. The variables we dealt with in earlier chapters, which had automatic storage duration, all lived on the stack. Static variables live in a different part of memory, the <i>data section</i>. (Some static variables live in the closely related BSS section, which I’ll discuss in a moment.) Like the stack, the data section is a region in memory that the program can read from and write to.</p>&#13;
<p class="TX">However, while the stack is divided into frames, which are managed by a well-established calling convention, the data section is one big chunk of memory that exists regardless of what function you’re in. This makes the data section the ideal place to store variables with static storage duration: objects in the data section won’t be deallocated or overwritten when we call and return from functions. We don’t have dedicated registers like RSP or RBP that point to particular spots in the data section, and we don’t need them; as you’ll see in a moment, we can refer to variables in this section by name instead.</p>&#13;
<p class="TX">By default, the assembler writes to the text section, which is the region of memory that holds machine instructions. The <samp class="SANS_TheSansMonoCd_W5Regular_11">.data</samp> directive tells the assembler to start writing to the data section instead. <a href="chapter10.xhtml#list10-17">Listing 10-17</a> initializes a variable in the data section.</p>&#13;
<a id="list10-17"/>&#13;
<pre><code>    .data&#13;
    .align 4&#13;
var:&#13;
    .long 3</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-17: Initializing a variable in the data section</samp></p>&#13;
<p class="TX">The first line of <a href="chapter10.xhtml#list10-17">Listing 10-17</a> indicates that we’re writing to the data section. The <samp class="SANS_TheSansMonoCd_W5Regular_11">.align</samp> directive on the next line determines the alignment of the next value we write; a 4-byte alignment means that this value’s address in bytes must be divisible by 4. The meaning of the <samp class="SANS_TheSansMonoCd_W5Regular_11">.align</samp> directive varies by platform. On Linux, <samp class="SANS_TheSansMonoCd_W5Regular_11">.align</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n</samp> produces an <i>n</i>-byte alignment. On macOS, <samp class="SANS_TheSansMonoCd_W5Regular_11">.align</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n</samp> produces a 2<i><sup>n</sup></i>-byte alignment. That means <samp class="SANS_TheSansMonoCd_W5Regular_11">.align 4</samp> results in the next value being 4-byte aligned on Linux and 16-byte aligned on macOS.</p>&#13;
<p class="TX">The third line is a label; you can label locations in the data section just like locations in the text section. Finally, the last line writes the 32-bit integer <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp> to the current section; this is the data section because of the earlier <samp class="SANS_TheSansMonoCd_W5Regular_11">.data</samp> directive. Since <i>long</i> means 32 bits in x64 assembly, the <samp class="SANS_TheSansMonoCd_W5Regular_11">.long</samp> directive always writes a 32-bit integer. (Recall that the <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp> suffix on instructions with 32-bit operands, like <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>, stands for <i>long</i>.)</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_222" aria-label="222"/>Like any other label, the <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> label is internal to this object file by default. We could include the <samp class="SANS_TheSansMonoCd_W5Regular_11">.globl</samp> directive to make it visible in other object files too:</p>&#13;
<pre><code>    .globl var</code></pre>&#13;
<p class="TX">I mentioned earlier that some static variables are stored in the <i>BSS section</i>. (For obscure historical reasons, BSS stands for <i>Block Started by Symbol</i>.) This section works almost exactly like the data section, except that it holds only variables that are initialized to zero. This is a trick to save space on disk; an executable or object file needs to record only the size of the BSS section, not its contents, because its contents are all zeros.</p>&#13;
<p class="TX"><a href="chapter10.xhtml#list10-18">Listing 10-18</a> initializes a variable in the BSS section.</p>&#13;
<a id="list10-18"/>&#13;
<pre><code>    .bss&#13;
    .align 4&#13;
var:&#13;
    .zero 4</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-18: Initializing a variable in the BSS section</samp></p>&#13;
<p class="TX">This code differs from <a href="chapter10.xhtml#list10-17">Listing 10-17</a> in two ways. First, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">.bss</samp> directive to write to the BSS section instead of the data section. Second, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">.zero</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n</samp> directive to write <i>n</i> bytes of zeros. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">.zero 4</samp> initializes a 4-byte integer to zero. We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">.align</samp> directive, declare a label, and include or omit the <samp class="SANS_TheSansMonoCd_W5Regular_11">.globl</samp> directive in exactly the same way whether we’re dealing with the data or BSS section.</p>&#13;
<p class="TX">If a variable is declared, but not defined, in the file you’re compiling, you won’t write anything to the data or BSS section.</p>&#13;
<p class="TX">Finally, let’s see how to refer to labels from the data section in assembly instructions. This line writes the immediate value <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp> to the memory address labeled <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>:</p>&#13;
<pre><code>movl    $4, var(%rip)</code></pre>&#13;
<p class="TX">Operands like <samp class="SANS_TheSansMonoCd_W5Regular_11">var(%rip)</samp> use <i>RIP-relative addressing</i>, which refers to memory addresses relative to the instruction pointer. We obviously can’t refer to symbols in the data section relative to RBP and RSP, the way we refer to stack variables. We also can’t replace them with absolute addresses at link time, because we’re compiling position-independent code, which can be loaded into any spot in program memory. Instead, we use the RIP register, which holds the address of the current instruction in the program’s text section, to calculate the address of a variable like <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> in the program’s data section.</p>&#13;
<p class="TX">The details of RIP-relative addressing are involved, so I won’t go into them here. Instead, I’ll once again recommend Eli Bendersky’s excellent blog posts on position-independent code, which I provided links to in <span class="Xref-1"><a href="chapter1.xhtml">Chapter 1</a>’s “Additional Resources” on <a href="chapter1.xhtml#pg_21">page 21</a></span>.</p>&#13;
<aside class="box" aria-label="box-6"><p class="BoxTitle" id="box-6"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_223" aria-label="223"/><samp class="SANS_Dogma_OT_Bold_B_11">THE GLOBAL OFFSET TABLE</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">There are actually two ways to find a static variable’s address in position-independent code. The first is RIP-relative addressing. The second involves looking up the address in the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">global offset table (GOT)</samp><samp class="SANS_Futura_Std_Book_11">. Programs typically use the GOT to access variables in dynamically linked libraries because these variables’ addresses may be too far from the current instruction pointer for RIP-relative addressing to represent. Our implementation won’t use the GOT, since it’s more complicated than RIP-relative addressing. On macOS, this means you won’t be able to compile code that accesses global variables defined in the standard library or other dynamically linked libraries. On Linux, the impact is somewhat different: you can still compile executables that access global variables defined in dynamically linked libraries, but you can’t compile dynamically linked libraries that use global variables, even if the variables are defined in the same library you’re trying to compile. (This is the limitation on our ability to produce shared libraries that I mentioned in the previous chapter.) To understand</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">why</samp> <samp class="SANS_Futura_Std_Book_11">things work this way on Linux, you’ll need to get deep into the inner workings of the linker and loader. For more details, see MaskRay’s blog post “Copy Relocations, Canonical PLT Entries and Protected Visibility” (</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11"><a href="https://maskray.me/blog/2021-01-09-copy-relocations-canonical-plt-entries-and-protected">https://<wbr/>maskray<wbr/>.me<wbr/>/blog<wbr/>/2021<wbr/>-01<wbr/>-09<wbr/>-copy<wbr/>-relocations<wbr/>-canonical<wbr/>-plt<wbr/>-entries<wbr/>-and<wbr/>-protected</a></samp><samp class="SANS_Futura_Std_Book_11">).</samp></p>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">If you want to extend your compiler to use the GOT, I recommend waiting until we implement pointers in <a href="chapter14.xhtml">Chapter 14</a> so that you have a solid grasp of how to work with memory addresses in assembly.</samp></p>&#13;
</aside>&#13;
<p class="TX">Now that you understand how storage duration, linkage, and variable initialization work in both C and assembly, you’re ready to extend your compiler.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h3 class="H1" id="sec13"><span id="h1-82"/><samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp></h3>&#13;
<p class="TNI">You’ll add two new keywords in this chapter:</p>&#13;
<p class="RunInParaF"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">static</samp></p>&#13;
<p class="RunInParaL"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">extern</samp></p>&#13;
<aside class="box" aria-label="box-7"><p class="BoxTitle" id="box-7"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE LEXER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test out your lexer, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 10 --stage lex</b>&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">Your compiler should successfully lex every test program in this chapter.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_224" aria-label="224"/>&#13;
<h3 class="H1" id="sec14"><span id="h1-83"/><samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp></h3>&#13;
<p class="TNI">In this chapter, we’re going to make two changes to the AST: we’ll add variable declarations as a top-level construct, and we’ll add optional storage-class specifiers to both function and variable declarations. <a href="chapter10.xhtml#list10-19">Listing 10-19</a> shows the updated AST definition.</p>&#13;
<a id="list10-19"/>&#13;
<pre><code>program = Program(<b>declaration*</b>)&#13;
declaration = FunDecl(function_declaration) | VarDecl(variable_declaration)&#13;
variable_declaration = (identifier name, exp? init, <b>storage_class?</b>)&#13;
function_declaration = (identifier name, identifier* params,&#13;
                        block? body, <b>storage_class?</b>)&#13;
<b>storage_class = Static | Extern</b>&#13;
block_item = S(statement) | D(declaration)&#13;
block = Block(block_item*)&#13;
for_init = InitDecl(variable_declaration) | InitExp(exp?)&#13;
statement = Return(exp)&#13;
          | Expression(exp)&#13;
          | If(exp condition, statement then, statement? else)&#13;
          | Compound(block)&#13;
          | Break&#13;
          | Continue&#13;
          | While(exp condition, statement body)&#13;
          | DoWhile(statement body, exp condition)&#13;
          | For(for_init init, exp? condition, exp? post, statement body)&#13;
          | Null&#13;
exp = Constant(int)&#13;
    | Var(identifier)&#13;
    | Unary(unary_operator, exp)&#13;
    | Binary(binary_operator, exp, exp)&#13;
    | Assignment(exp, exp)&#13;
    | Conditional(exp condition, exp, exp)&#13;
    | FunctionCall(identifier, exp* args)&#13;
unary_operator = Complement | Negate | Not&#13;
binary_operator = Add | Subtract | Multiply | Divide | Remainder | And | Or&#13;
                | Equal | NotEqual | LessThan | LessOrEqual&#13;
                | GreaterThan | GreaterOrEqual</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-19: The abstract syntax tree with file scope variables and storage-class specifiers</samp></p>&#13;
<p class="TX">We’ve already defined a <samp class="SANS_TheSansMonoCd_W5Regular_11">declaration</samp> AST node that includes both function and variable declarations. Now that we support file scope variable declarations, we’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">declaration</samp> nodes at the top level.</p>&#13;
<p class="TX"><a href="chapter10.xhtml#list10-20">Listing 10-20</a> shows the corresponding changes to the grammar.</p>&#13;
<a id="list10-20"/>&#13;
<pre><code>&lt;program&gt; ::= {<b>&lt;declaration&gt;</b>}&#13;
&lt;declaration&gt; ::= &lt;variable-declaration&gt; | &lt;function-declaration&gt;&#13;
&lt;variable-declaration&gt; ::= <b>{&lt;specifier&gt;}+ </b>&lt;identifier&gt; ["=" &lt;exp&gt;] ";"&#13;
&lt;function-declaration&gt; ::= <b>{&lt;specifier&gt;}+</b> &lt;identifier&gt; "(" &lt;param-list&gt; ")" (&lt;block&gt; | ";")&#13;
&lt;param-list&gt; ::= "void" | "int" &lt;identifier&gt; {"," "int" &lt;identifier&gt;}&#13;
<b>&lt;specifier&gt; ::= "int" | "static" | "extern"</b>&#13;
&lt;block&gt; ::= "{" {&lt;block-item&gt;} "}"&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_225" aria-label="225"/>&lt;block-item&gt; ::= &lt;statement&gt; | &lt;declaration&gt;&#13;
&lt;for-init&gt; ::= &lt;variable-declaration&gt; | [&lt;exp&gt;] ";"&#13;
&lt;statement&gt; ::= "return" &lt;exp&gt; ";"&#13;
              | &lt;exp&gt; ";"&#13;
              | "if" "(" &lt;exp&gt; ")" &lt;statement&gt; ["else" &lt;statement&gt;]&#13;
              | &lt;block&gt;&#13;
              | "break" ";"&#13;
              | "continue" ";"&#13;
              | "while" "(" &lt;exp&gt; ")" &lt;statement&gt;&#13;
              | "do" &lt;statement&gt; "while" "(" &lt;exp&gt; ")" ";"&#13;
              | "for" "(" &lt;for-init&gt; [&lt;exp&gt;] ";" [&lt;exp&gt;] ")" &lt;statement&gt;&#13;
              | ";"&#13;
&lt;exp&gt; ::= &lt;factor&gt; | &lt;exp&gt; &lt;binop&gt; &lt;exp&gt; | &lt;exp&gt; "?" &lt;exp&gt; ":" &lt;exp&gt;&#13;
&lt;factor&gt; ::= &lt;int&gt; | &lt;identifier&gt; | &lt;unop&gt; &lt;factor&gt; | "(" &lt;exp&gt; ")"&#13;
           | &lt;identifier&gt; "(" [&lt;argument-list&gt;] ")"&#13;
&lt;argument-list&gt; ::= &lt;exp&gt; {"," &lt;exp&gt;}&#13;
&lt;unop&gt; ::= "-" | "~" | "!"&#13;
&lt;binop&gt; ::= "-" | "+" | "*" | "/" | "%" | "&amp;&amp;" | "||"&#13;
          | "==" | "!=" | "&lt;" | "&lt;=" | "&gt;" | "&gt;=" | "="&#13;
&lt;identifier&gt; ::= ? An identifier token ?&#13;
&lt;int&gt; ::= ? A constant token ?</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-20: The grammar with file scope variables and storage-class specifiers</samp></p>&#13;
<p class="TX">We define a <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;program&gt;</samp> as a list of <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;declaration&gt;</samp> symbols, just like we did in <a href="chapter10.xhtml#list10-19">Listing 10-19</a>. We also introduce a new <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;specifier&gt;</samp> symbol, which represents both type and storage-class specifiers, and we require every declaration to start with a list of specifiers. We’ve added a new bit of EBNF notation here: wrapping something in braces followed by a <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> symbol indicates that it must be repeated at least once. Therefore, <samp class="SANS_TheSansMonoCd_W5Regular_11">{&lt;specifier&gt;}+</samp> represents a non-empty list of specifiers. Note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;param-list&gt;</samp> rule hasn’t changed; we still expect each parameter to be declared with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> keyword, not a list of specifiers. If the parser encounters a <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> parameter, it should throw an error.</p>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h4 class="H2" id="sec15"><span id="h2-69"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing Type and Storage-Class Specifiers</samp></h4>&#13;
<p class="TNI">We lump type and storage-class specifiers into a single symbol because they can appear in any order in a declaration. In other words, the declaration</p>&#13;
<pre><code>static int a = 3;</code></pre>&#13;
<p class="BodyContinued">is equivalent to:</p>&#13;
<pre><code>int static a = 3;</code></pre>&#13;
<p class="TX">Things will get even more complicated when we add more type specifiers in <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>. A declaration might include multiple type specifiers (like <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>), which can appear in any order relative to storage-class specifiers and each other.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_226" aria-label="226"/>To construct the AST, the parser needs to consume the list of specifiers at the start of a declaration, then convert them into exactly one type and at most one storage-class specifier. The pseudocode in <a href="chapter10.xhtml#list10-21">Listing 10-21</a> outlines how to process the specifier list.</p>&#13;
<a id="list10-21"/>&#13;
<pre><code>parse_type_and_storage_class(specifier_list):&#13;
    types = []&#13;
    storage_classes = []&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> for specifier in specifier_list:&#13;
        if specifier is "int":&#13;
            types.append(specifier)&#13;
        else:&#13;
            storage_classes.append(specifier)&#13;
&#13;
    if length(types) != 1:&#13;
        fail("Invalid type specifier")&#13;
    if length(storage_classes) &gt; 1:&#13;
        fail("Invalid storage class")&#13;
&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> type = Int&#13;
&#13;
    if length(storage_classes) == 1:&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> storage_class = parse_storage_class(storage_classes[0])&#13;
    else:&#13;
        storage_class = null&#13;
&#13;
    return (type, storage_class)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-21: Determining a declaration’s type and storage class</samp></p>&#13;
<p class="TX">We start by partitioning our list into type specifiers and storage-class specifiers <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Then, we validate each list. The list of type specifiers must have exactly one value. The list of storage-class specifiers could be empty, or it could contain exactly one value. Finally, we return our results. At the moment, <samp class="SANS_TheSansMonoCd_W5Regular_11">Int</samp> is the only possible type <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If the storage-class specifier list isn’t empty, we’ll convert its one element to the corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">storage_class</samp> AST node <span class="CodeAnnotation" aria-label="annotation3">❸</span>. (I’ve omitted the pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_storage_class</samp>, since there’s not much to it.) If the storage-class specifier list is empty, the declaration doesn’t have a storage class.</p>&#13;
<p class="TX"><a href="chapter10.xhtml#list10-21">Listing 10-21</a> is a bit more complicated than we need right now, but it will be easy to extend as we add more type specifiers in later chapters.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h4 class="H2" id="sec16"><span id="h2-70"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Distinguishing Between Function and Variable Declarations</samp></h4>&#13;
<p class="TNI">Our one remaining challenge is that we can’t distinguish between <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;function -declaration&gt;</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;variable-declaration&gt;</samp> symbols without parsing the whole list of type and storage-class specifiers. Once we support more complex declarations in later chapters, these two symbols will have even more parsing logic in common. This means that it isn’t practical to write separate functions to parse these two grammar symbols; instead, you should write a <span role="doc-pagebreak" epub:type="pagebreak" id="pg_227" aria-label="227"/>single function to parse both and return a <samp class="SANS_TheSansMonoCd_W5Regular_11">declaration</samp> AST node. The one spot where you can have one kind of declaration but not the other is the initial clause of a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop. To handle this case, just parse the whole declaration, then fail if it turns out to be a function declaration.</p>&#13;
<p class="TX">Now you have everything you need to extend the parser.</p>&#13;
<aside class="box" aria-label="box-8"><p class="BoxTitle" id="box-8"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE PARSER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test your parser, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 10 --stage parse</b>&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">Your compiler should raise an error for every test program in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter _10/invalid_parse</samp> <samp class="SANS_Futura_Std_Book_11">and successfully parse all the programs in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_10/invalid_declarations</samp><samp class="SANS_Futura_Std_Book_11">,</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_10/invalid_types</samp><samp class="SANS_Futura_Std_Book_11">, and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_10/valid</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">There are several error cases in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_10/invalid_types</samp> <samp class="SANS_Futura_Std_Book_11">that would be just as easy to catch in the parser. These include storage-class specifiers on variable declarations in</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> <samp class="SANS_Futura_Std_Book_11">loop headers,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> <samp class="SANS_Futura_Std_Book_11">specifiers on block scope function declarations, and block scope</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> <samp class="SANS_Futura_Std_Book_11">variables with initializers. You can have the parser catch these errors instead of catching them in the semantic analysis stage if you like. Just be aware that if you do this, the tests for those error cases will fail when you run the command to test the parser.</samp></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h3 class="H1" id="sec17"><span id="h1-84"/><samp class="SANS_Futura_Std_Bold_B_11">Semantic Analysis</samp></h3>&#13;
<p class="TNI">Next, we need to extend the identifier resolution and type checking passes. In the identifier resolution pass, we’ll handle top-level variable declarations and check for duplicate declarations in the same scope. In the type checking pass, we’ll add storage class and linkage information to the symbol table because we’ll need that information when we generate assembly. We’ll also deal with our remaining error cases in the type checker.</p>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h4 class="H2" id="sec18"><span id="h2-71"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Identifier Resolution: Resolving External Variables</samp></h4>&#13;
<p class="TNI">Like functions, external variables aren’t renamed during the identifier resolution pass. Our identifier map will track whether each identifier has linkage (either internal or external) or not. We don’t need to distinguish between internal and external linkage until the type checking pass.</p>&#13;
<p class="TX">We’ll need separate code to process block scope and file scope variable declarations, since different rules for determining linkage apply at these different scopes. <a href="chapter10.xhtml#list10-22">Listing 10-22</a> demonstrates how to resolve variable declarations at file scope.</p>&#13;
<a id="list10-22"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_228" aria-label="228"/>resolve_file_scope_variable_declaration(decl, identifier_map):&#13;
    identifier_map.add(decl.name, MapEntry(new_name=decl.name,&#13;
                                           from_current_scope=True,&#13;
                                           has_linkage=True))&#13;
    return decl</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-22: Resolving file scope variable declarations</samp></p>&#13;
<p class="TX">As you’ll see shortly, this is much simpler than the code to handle block scope variable declarations. We don’t need to generate a unique name, since external variables retain their original names throughout this stage. We don’t need to worry about previous declarations of this variable; any previous declarations must also have internal or external linkage, so they’ll refer to the same object and have the same entry in the identifier map. (File scope declarations can conflict in other ways, but we’ll deal with those conflicts in the type checker.) We can handle declarations uniformly whether they’re <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> or not. Since we don’t need to distinguish internal from external linkage, we’ll keep using the Boolean <samp class="SANS_TheSansMonoCd_W5Regular_11">has_linkage</samp> attribute from the previous chapter. This attribute is always <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> for file scope identifiers. We also don’t need to recursively process the initializer, because it should be a constant and therefore shouldn’t contain any variables we need to rename. If the initializer isn’t a constant, we’ll catch that during type checking.</p>&#13;
<p class="TX">Now let’s consider variables at block scope. If a variable is declared with the <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> keyword, we record that it has linkage in the identifier map and retain its original name. Otherwise, we handle it just like we’ve handled local variables in the past. If an identifier is declared both with and without linkage in the same scope, we can’t maintain a consistent identifier map, so we throw an error. <a href="chapter10.xhtml#list10-23">Listing 10-23</a> shows how to do this in pseudocode.</p>&#13;
<a id="list10-23"/>&#13;
<pre><code>resolve_local_variable_declaration(decl, identifier_map):&#13;
    if decl.name is in identifier_map:&#13;
        prev_entry = identifier_map.get(decl.name)&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> if prev_entry.from_current_scope:&#13;
            if not (prev_entry.has_linkage and decl.storage_class == Extern):&#13;
                fail("Conflicting local declarations")&#13;
&#13;
    if decl.storage_class == Extern:&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> identifier_map.add(decl.name, MapEntry(new_name=decl.name,&#13;
                                               from_current_scope=True,&#13;
                                               has_linkage=True))&#13;
        return decl&#13;
    else:&#13;
        unique_name = make_temporary()&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> identifier_map.add(decl.name, MapEntry(new_name=unique_name,&#13;
                                               from_current_scope=True,&#13;
                                               has_linkage=False))&#13;
        <var>--snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-23: Resolving block scope variable declarations</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_229" aria-label="229"/>First, we check for conflicting declarations <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If this identifier has already been declared in the current scope, we check the previous declaration’s linkage. If it has linkage and the current declaration does too (as indicated by the <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> keyword), they both refer to the same object. In that case, the declarations are consistent, at least for the purposes of identifier resolution. If either or both of the identifiers have no linkage, they refer to two different objects, so we throw an error.</p>&#13;
<p class="TX">Assuming there’s no conflict, we update the identifier map. If this declaration has linkage, it retains its current name <span class="CodeAnnotation" aria-label="annotation2">❷</span>; otherwise, we rename it <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Note that variables without linkage are handled identically here whether they’re <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> or not. Also note that we don’t need to recursively process the initializers of <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> variables, because they shouldn’t have initializers at all. (I’ve snipped out the code to resolve the initializers of variables without linkage, because it’s unchanged from earlier chapters.)</p>&#13;
<p class="TX">You don’t need to change how this pass processes function declarations, with one small exception: you should throw an error if a block scope function declaration includes the <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> specifier. It’s easy to do this during identifier resolution, in the same spot where you validate that block scope function declarations don’t have bodies. However, throwing this error in the type checker, or even the parser, works just as well.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h4 class="H2" id="sec19"><span id="h2-72"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Checking: Tracking Static Functions and Variables</samp></h4>&#13;
<p class="TNI">Next, we’ll update the symbol table and handle the remaining error cases. We’ll add several new pieces of information to the symbol table. First, we’ll record each variable’s storage duration. Second, we’ll record the initial values of variables with static storage duration. Finally, we’ll record whether functions and variables with static storage duration are globally visible. Each of these pieces of information will impact the assembly we generate later.</p>&#13;
<p class="TX">Most of the logic we’re adding to the type checker isn’t type checking per se, since an identifier’s storage class and linkage are separate from its type. But the type checker is a natural place for this logic because we’ll track each identifier’s type, linkage, and storage class together in the symbol table.</p>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
&#13;
<h5 class="H3" id="sec20"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Identifier Attributes in the Symbol Table</samp></h5>&#13;
<p class="TNI">We need to track different information in the symbol table for each kind of identifier: functions, variables with static storage duration, and variables with automatic storage duration. <a href="chapter10.xhtml#list10-24">Listing 10-24</a> gives one way to represent all this information.</p>&#13;
<a id="list10-24"/>&#13;
<pre><code>identifier_attrs = FunAttr(bool defined, bool global)&#13;
                 | StaticAttr(initial_value init, bool global)&#13;
                 | LocalAttr&#13;
&#13;
initial_value = Tentative | Initial(int) | NoInitializer</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-24: The symbol table attributes for different kinds of identifiers</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_230" aria-label="230"/><samp class="SANS_TheSansMonoCd_W5Regular_11">StaticAttr</samp> represents the attributes we need to track for variables with static storage duration. The <samp class="SANS_TheSansMonoCd_W5Regular_11">initial_value</samp> type lets us distinguish between variable definitions with an initializer, tentative definitions with no initializer, and <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> variable declarations. <samp class="SANS_TheSansMonoCd_W5Regular_11">FunAttr</samp> represents functions, and <samp class="SANS_TheSansMonoCd_W5Regular_11">LocalAttr</samp> represents function parameters and variables with automatic storage duration. Each symbol table entry should include both a type (as defined in the previous chapter) and <samp class="SANS_TheSansMonoCd_W5Regular_11">identifier_attrs</samp>.</p>&#13;
<p class="TX">Now that we can represent the information we need in the symbol table, let’s look at the three kinds of declarations we need to type check: function declarations, file scope variable declarations, and block scope variable declarations.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
&#13;
<h5 class="H3" id="sec21"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Function Declarations</samp></h5>&#13;
<p class="TNI">Most of the logic here will stay the same. We’ll check that the current declaration is the same type as any prior declarations and that the function isn’t defined more than once. The only difference is that we’ll also record whether the function is globally visible. The pseudocode in <a href="chapter10.xhtml#list10-25">Listing 10-25</a> captures how we’ll type check function declarations, with changes from <span class="Xref-1"><a href="chapter9.xhtml#list9-21">Listing 9-21</a></span> bolded and some unchanged code omitted. (I’ve also made some changes to the code to accommodate changes to our symbol table representation, even though the logic is essentially the same. These are not bolded.)</p>&#13;
<a id="list10-25"/>&#13;
<pre><code>typecheck_function_declaration(decl, symbols):&#13;
    fun_type = FunType(length(decl.params))&#13;
    has_body = decl.body is not null&#13;
    already_defined = False&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> <b>global = decl.storage_class != Static</b>&#13;
&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> if decl.name is in symbols:&#13;
        old_decl = symbols.get(decl.name)&#13;
        if old_decl.type != fun_type:&#13;
            fail("Incompatible function declarations")&#13;
        already_defined = old_decl.attrs.defined&#13;
        if already_defined and has_body:&#13;
            fail("Function is defined more than once")&#13;
&#13;
<b>        if old_decl.attrs.global and decl.storage_class == Static:</b>&#13;
<b>            fail("Static function declaration follows non-static")</b>&#13;
<b>      </b><span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span><b> global = old_decl.attrs.global</b>&#13;
&#13;
    <b>attrs = FunAttr(defined=(already_defined or has_body), global=global)</b>&#13;
    symbols.add(decl.name, fun_type, <b>attrs=attrs</b>)&#13;
<var>    --snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-25: Type checking function declarations</samp></p>&#13;
<p class="TX">First, we look at the function’s storage class <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If it’s <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>, the function won’t be globally visible, because its linkage is internal. If it’s <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> (or absent entirely, which amounts to the same thing), we tentatively say the function <span role="doc-pagebreak" epub:type="pagebreak" id="pg_231" aria-label="231"/>is globally visible, because its linkage is external. However, this can change depending on what other declarations are in scope.</p>&#13;
<p class="TX">Next, we look at those other declarations, if there are any <span class="CodeAnnotation" aria-label="annotation2">❷</span>. We check for type mismatches and duplicate definitions, just like in the previous chapter. Then, we consider linkage. If the current declaration includes an explicit or implied <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> keyword, we’ll retain the previous declaration’s linkage (and thus its <samp class="SANS_TheSansMonoCd_W5Regular_11">global</samp> attribute). If both the current and past declarations have internal linkage, there’s no conflict. Either way, the linkage from the previous declaration remains unchanged <span class="CodeAnnotation" aria-label="annotation3">❸</span>. But if the function was previously declared with external linkage and is now declared with the <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> keyword, the declarations conflict, so we throw an error.</p>&#13;
<p class="TX">I’ve snipped out the rest of this function because it’s the same as in the previous chapter.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
&#13;
<h5 class="H3" id="sec22"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">File Scope Variable Declarations</samp></h5>&#13;
<p class="TNI">When we encounter a variable declaration at file scope, we need to determine the variable’s initial value and whether it’s globally visible. These properties depend on both the current declaration and any previous declarations of the same variable. <a href="chapter10.xhtml#list10-26">Listing 10-26</a> shows how to type check a file scope variable declaration.</p>&#13;
<a id="list10-26"/>&#13;
<pre><code>typecheck_file_scope_variable_declaration(decl, symbols):&#13;
    if decl.init is constant integer i: <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
        initial_value = Initial(i)&#13;
    else if decl.init is null: <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
        if decl.storage_class == Extern:&#13;
            initial_value = NoInitializer&#13;
        else:&#13;
            initial_value = Tentative&#13;
    else: <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
        fail("Non-constant initializer!")&#13;
&#13;
    global = (decl.storage_class != Static) <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span>&#13;
&#13;
    if decl.name is in symbols: <span class="codeannotated_CodeAnnotation" aria-label="annotation5">❺</span>&#13;
        old_decl = symbols.get(decl.name)&#13;
        if old_decl.type != Int:&#13;
            fail("Function redeclared as variable")&#13;
        if decl.storage_class == Extern:&#13;
            global = old_decl.attrs.global&#13;
        else if old_decl.attrs.global != global:&#13;
            fail("Conflicting variable linkage")&#13;
&#13;
        if old_decl.attrs.init is a constant:&#13;
            if initial_value is a constant:&#13;
                fail("Conflicting file scope variable definitions") <span class="codeannotated_CodeAnnotation" aria-label="annotation6">❻</span>&#13;
            else:&#13;
                initial_value = old_decl.attrs.init&#13;
        else if initial_value is not a constant and old_decl.attrs.init == Tentative:&#13;
            initial_value = Tentative&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_232" aria-label="232"/>    attrs = StaticAttr(init=initial_value, global=global)&#13;
    symbols.add(decl.name, Int, attrs=attrs) <span class="codeannotated_CodeAnnotation" aria-label="annotation7">❼</span></code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-26: Type checking file scope variable declarations</samp></p>&#13;
<p class="TX">First, we determine the variable’s initial value. This depends on the declaration’s initializer and its storage-class specifier. If the initializer is a constant, we’ll use it <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If it’s absent <span class="CodeAnnotation" aria-label="annotation2">❷</span>, we’ll record that this variable is either tentatively defined or not defined at all, depending on whether this is an <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> declaration. If the initializer is any expression other than a constant, we’ll throw an error <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">Next, we determine whether the variable is globally visible <span class="CodeAnnotation" aria-label="annotation4">❹</span>. We tentatively say it’s visible unless the storage-class specifier is <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>.</p>&#13;
<p class="TX">Then, if we recorded prior declarations of this identifier in the symbol table, we factor those in too <span class="CodeAnnotation" aria-label="annotation5">❺</span>. We validate that the prior declaration has type <samp class="SANS_TheSansMonoCd_W5Regular_11">Int</samp>, not a function type, and then we try to reconcile the <samp class="SANS_TheSansMonoCd_W5Regular_11">global</samp> attribute with the previous declaration. If this is an <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> declaration, we just adopt the prior declaration’s <samp class="SANS_TheSansMonoCd_W5Regular_11">global</samp> attribute. Otherwise, we throw an error if the new and old <samp class="SANS_TheSansMonoCd_W5Regular_11">global</samp> attributes disagree.</p>&#13;
<p class="TX">Accounting for the previous declaration’s initializer is more complicated. If either this declaration or the prior one has an explicit initializer, we’ll use that. Otherwise, if either the new declaration or the prior one was a tentative definition, we’ll use a <samp class="SANS_TheSansMonoCd_W5Regular_11">Tentative</samp> initializer. If we haven’t seen any explicit or tentative definitions so far, we’ll stick with <samp class="SANS_TheSansMonoCd_W5Regular_11">NoInitializer</samp>. If the new and old declarations both have explicit initializers, we’ll throw an error <span class="CodeAnnotation" aria-label="annotation6">❻</span>.</p>&#13;
<p class="TX">Finally, we add (or update) this variable’s entry in the symbol table <span class="CodeAnnotation" aria-label="annotation7">❼</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
&#13;
<h5 class="H3" id="sec23"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Block Scope Variable Declarations</samp></h5>&#13;
<p class="TNI">We’ll use the pseudocode in <a href="chapter10.xhtml#list10-27">Listing 10-27</a> to type check variable declarations at block scope.</p>&#13;
<a id="list10-27"/>&#13;
<pre><code>typecheck_local_variable_declaration(decl, symbols):&#13;
    if decl.storage_class == Extern:&#13;
        if decl.init is not null: <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
            fail("Initializer on local extern variable declaration")&#13;
        if decl.name is in symbols:&#13;
            old_decl = symbols.get(decl.name)&#13;
            if old_decl.type != Int: <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
                fail("Function redeclared as variable")&#13;
        else:&#13;
            symbols.add(decl.name, Int, attrs=StaticAttr(init=NoInitializer, global=True)) <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
&#13;
    else if decl.storage_class == Static:&#13;
        if decl.init is constant integer i: <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span>&#13;
            initial_value = Initial(i)&#13;
        else if decl.init is null: <span class="codeannotated_CodeAnnotation" aria-label="annotation5">❺</span>&#13;
            initial_value = Initial(0)&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_233" aria-label="233"/>        else:&#13;
            fail("Non-constant initializer on local static variable")&#13;
        symbols.add(decl.name, Int, attrs=StaticAttr(init=initial_value, global=False)) <span class="codeannotated_CodeAnnotation" aria-label="annotation6">❻</span>&#13;
&#13;
    else:&#13;
        symbols.add(decl.name, Int, attrs=LocalAttr) <span class="codeannotated_CodeAnnotation" aria-label="annotation7">❼</span>&#13;
        if decl.init is not null:&#13;
            typecheck_exp(decl.init, symbols)</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-27: Type checking block scope variable declarations</samp></p>&#13;
<p class="TX">To handle an <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> variable, we first make sure it doesn’t have an initializer <span class="CodeAnnotation" aria-label="annotation1">❶</span> and it wasn’t previously declared as a function <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Then, if this variable wasn’t declared earlier, we record in the symbol table that it’s globally visible and not initialized <span class="CodeAnnotation" aria-label="annotation3">❸</span>. If it was already declared, we do nothing: a local <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> declaration will never change the initial value or linkage we’ve already recorded.</p>&#13;
<p class="TX">A static local variable has no linkage, so we don’t need to consider earlier declarations. We just check the variable’s initializer: if it’s a constant, we use it <span class="CodeAnnotation" aria-label="annotation4">❹</span>; if it’s absent, we initialize the variable to zero <span class="CodeAnnotation" aria-label="annotation5">❺</span>; and if it’s not a constant, we throw an error. Then, we add the variable to the symbol table, recording that it is not globally visible <span class="CodeAnnotation" aria-label="annotation6">❻</span>.</p>&#13;
<p class="TX">We’ll include the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocalAttr</samp> attribute in the symbol table entries for automatic variables <span class="CodeAnnotation" aria-label="annotation7">❼</span>. Aside from this detail, we type check these variables the same way we did in the previous chapter.</p>&#13;
<p class="TX">When you process a declaration in a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop header, validate that it doesn’t include a storage-class specifier before you call the code in <a href="chapter10.xhtml#list10-27">Listing 10-27</a>. (Alternatively, you can handle this error case during the identifier resolution pass, or even during parsing.)</p>&#13;
<p class="TX">That’s it for the type checking pass! It took a lot of work to implement the C standard’s byzantine rules around definitions, declarations, linkage, and storage duration. Luckily, now that the symbol table has all the information we need, the rest of the chapter should be pretty easy.</p>&#13;
<aside class="box" aria-label="box-9"><p class="BoxTitle" id="box-9"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE SEMANTIC ANALYSIS STAGE</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test the semantic analysis stage, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 10 --stage validate</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">The identifier resolution pass should reject the programs in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_10/invalid_declarations</samp> <samp class="SANS_Futura_Std_Book_11">and the type checker should reject the programs in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_10/invalid_types</samp><samp class="SANS_Futura_Std_Book_11">, although some error cases could reasonably be caught in either pass. Both passes should handle the test cases in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_10/valid</samp> <samp class="SANS_Futura_Std_Book_11">without error.</samp></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_234" aria-label="234"/>&#13;
<h3 class="H1" id="sec24"><span id="h1-85"/><samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp></h3>&#13;
<p class="TNI">We need to make two additions to the TACKY IR. First, we’ll add a new <samp class="SANS_TheSansMonoCd_W5Regular_11">global</samp> field to function definitions, which corresponds to the <samp class="SANS_TheSansMonoCd_W5Regular_11">.globl</samp> directive in the final assembly output:</p>&#13;
<pre><code>Function(identifier, <b>bool global</b>, identifier* params, instruction* body)</code></pre>&#13;
<p class="TX">Second, we’ll add a top-level construct to represent static variables:</p>&#13;
<pre><code>StaticVariable(identifier, bool global, int init)</code></pre>&#13;
<p class="TX">We’ll use this construct to represent both external and local static variables. We’ll ultimately translate each <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp> construct into a set of assembly directives to initialize an object in the data or BSS section. <a href="chapter10.xhtml#list10-28">Listing 10-28</a> presents the whole TACKY IR, with changes from the previous chapter bolded.</p>&#13;
<a id="list10-28"/>&#13;
<pre><code>program = Program(<b>top_level*</b>)&#13;
<b>top_level</b> = Function(identifier, <b>bool global</b>, identifier* params, instruction* body)&#13;
          <b>| StaticVariable(identifier, bool global, int init)</b>&#13;
instruction = Return(val)&#13;
            | Unary(unary_operator, val src, val dst)&#13;
            | Binary(binary_operator, val src1, val src2, val dst)&#13;
            | Copy(val src, val dst)&#13;
            | Jump(identifier target)&#13;
            | JumpIfZero(val condition, identifier target)&#13;
            | JumpIfNotZero(val condition, identifier target)&#13;
            | Label(identifier)&#13;
            | FunCall(identifier fun_name, val* args, val dst)&#13;
val = Constant(int) | Var(identifier)&#13;
unary_operator = Complement | Negate | Not&#13;
binary_operator = Add | Subtract | Multiply | Divide | Remainder | Equal | NotEqual&#13;
                | LessThan | LessOrEqual | GreaterThan | GreaterOrEqual</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-28: Adding static variables and the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">global</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">attribute to TACKY</samp></p>&#13;
<p class="TX">We’ve renamed the <samp class="SANS_TheSansMonoCd_W5Regular_11">function_definition</samp> node to <samp class="SANS_TheSansMonoCd_W5Regular_11">top_level</samp>, since it doesn’t just represent functions anymore. Note that when we translate a program into TACKY, we move local static variable definitions to the top level; they become <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp> constructs, not instructions in a function body.</p>&#13;
<p class="TX">When we traverse the AST and convert it to TACKY, we’ll set the new <samp class="SANS_TheSansMonoCd_W5Regular_11">global</samp> attribute on each top-level <samp class="SANS_TheSansMonoCd_W5Regular_11">Function</samp>. We can look up this attribute in the symbol table. We won’t generate any TACKY for file scope variable declarations or for local variable declarations with <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> specifiers. Instead, <i>after</i> we’ve traversed the AST, we’ll perform an additional step where we examine every entry in the symbol table and generate <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp> constructs for some of these entries. Our final TACKY program will include both function definitions converted from the original AST and variable definitions generated from the symbol table.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_235" aria-label="235"/><a href="chapter10.xhtml#list10-29">Listing 10-29</a> demonstrates how to convert symbol table entries into TACKY variable definitions.</p>&#13;
<a id="list10-29"/>&#13;
<pre><code>convert_symbols_to_tacky(symbols):&#13;
    tacky_defs = []&#13;
    for (name, entry) in symbols:&#13;
        match entry.attrs with&#13;
        | StaticAttr(init, global) -&gt;&#13;
            match init with&#13;
            | Initial(i) -&gt; tacky_defs.append(StaticVariable(name, global, i))&#13;
            | Tentative -&gt; tacky_defs.append(StaticVariable(name, global, 0))&#13;
            | NoInitializer -&gt; continue&#13;
        | _ -&gt; continue&#13;
    return tacky_defs</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-29: Converting symbol table entries to TACKY</samp></p>&#13;
<p class="TX">We look at each symbol table entry to determine whether it should be converted into a <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp>. If it doesn’t have a <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticAttr</samp> attribute, we skip over it because it’s not a static variable. If its initial value is <samp class="SANS_TheSansMonoCd_W5Regular_11">NoInitializer</samp>, we skip over it because it’s not defined in this translation unit. Any symbol we don’t skip over is converted into a TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp> and added to the TACKY program. Static variables with tentative definitions get initialized to zero.</p>&#13;
<p class="TX">Right now, it doesn’t matter whether we process the AST or the symbol table first. Starting in <span class="Xref-1"><a href="chapter16.xhtml">Chapter 16</a></span>, it will be important that we process the AST first and the symbol table second. In that chapter, we’ll add new static objects to the symbol table as we convert the AST to TACKY; then, when we traverse the symbol table, we’ll convert those new entries to TACKY constructs.</p>&#13;
<aside class="box" aria-label="box-10"><p class="BoxTitle" id="box-10"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE TACKY GENERATION STAGE</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test TACKY generation, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 10 --stage tacky</b>&#13;
</code></pre></aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
&#13;
<h3 class="H1" id="sec25"><span id="h1-86"/><samp class="SANS_Futura_Std_Bold_B_11">Assembly Generation</samp></h3>&#13;
<p class="TNI">We’ll make a few small changes to the assembly AST in this chapter. These changes are bolded in <a href="chapter10.xhtml#list10-30">Listing 10-30</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_236" aria-label="236"/>&#13;
<a id="list10-30"/>&#13;
<pre><code>program = Program(<b>top_level</b>*)&#13;
<b>top_level</b> = Function(identifier name, <b>bool global,</b> instruction* instructions)&#13;
          <b>| StaticVariable(identifier name, bool global, int init)</b>&#13;
instruction = Mov(operand src, operand dst)&#13;
            | Unary(unary_operator, operand)&#13;
            | Binary(binary_operator, operand, operand)&#13;
            | Cmp(operand, operand)&#13;
            | Idiv(operand)&#13;
            | Cdq&#13;
            | Jmp(identifier)&#13;
            | JmpCC(cond_code, identifier)&#13;
            | SetCC(cond_code, operand)&#13;
            | Label(identifier)&#13;
            | AllocateStack(int)&#13;
            | DeallocateStack(int)&#13;
            | Push(operand)&#13;
            | Call(identifier)&#13;
            | Ret&#13;
&#13;
unary_operator = Neg | Not&#13;
binary_operator = Add | Sub | Mult&#13;
operand = Imm(int) | Reg(reg) | Pseudo(identifier) | Stack(int) |<b> Data(identifier)</b>&#13;
cond_code = E | NE | G | GE | L | LE&#13;
reg = AX | CX | DX | DI | SI | R8 | R9 | R10 | R11</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-30: The assembly AST with static variables</samp></p>&#13;
<p class="TX">Just like in TACKY, we rename <samp class="SANS_TheSansMonoCd_W5Regular_11">function_definition</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">top_level</samp> and add a top-level <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp> that indicates each static variable’s name, its initial value, and whether it’s globally visible. We also add a <samp class="SANS_TheSansMonoCd_W5Regular_11">global</samp> attribute to function definitions. Finally, we add a new assembly operand, <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>, for RIP-relative accesses to the data and BSS sections. We’ll replace pseudoregisters with <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> operands as needed during the pseudoregister replacement pass.</p>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
&#13;
<h4 class="H2" id="sec26"><span id="h2-73"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generating Assembly for Variable Definitions</samp></h4>&#13;
<p class="TNI">Converting our new TACKY constructs to assembly is simple, since we’re just passing a few fields from TACKY to the equivalent assembly constructs. <a href="chapter10.xhtml#tab10-3">Table 10-3</a> summarizes the latest updates to this conversion, with new constructs and changes to existing constructs bolded. <span class="Xref-1"><a href="appendix-B.xhtml">Appendix B</a></span> includes the complete TACKY-to-assembly conversion pass for this chapter, which is also the final version of this pass for <span class="Xref-1"><a href="part1.xhtml">Part I</a></span>.</p>&#13;
<p class="TT" id="tab10-3"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 10-3:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting Top-Level TACKY Constructs to Assembly</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">TACKY top-level construct</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Program(top_level_defs)</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Program(top_level_defs)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">global,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">params,</samp>           <samp class="SANS_TheSansMonoCd_W5Regular_11">instructions)</samp></p></td>&#13;
<td class="Basic-Table TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name,</samp><samp class="SANS_Futura_Std_Book_11"/> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">global,</samp> &#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">         [Mov(Reg(DI), param1),&#13;
          Mov(Reg(SI), param2),           </samp> &#13;
           <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;copy next four parameters from registers&gt;,</samp> &#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">          Mov(Stack(16), param7),&#13;
          Mov(Stack(24), param8),           </samp> &#13;
           <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;copy remaining parameters from stack&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">]</samp><samp class="SANS_Futura_Std_Book_11"/> <samp class="SANS_TheSansMonoCd_W5Regular_11">+&#13;
        instructions)</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">StaticVariable(name, global, init)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">StaticVariable(name, global, init)</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_237" aria-label="237"/>The way we convert all the other TACKY constructs to assembly won’t change. In particular, we’ll convert every TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp> operand to an assembly <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp> operand, regardless of whether it has static or automatic storage duration. This means the name <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp> doesn’t quite fit anymore; the term <i>pseudoregister</i> usually refers to operands that could theoretically live in registers, which static variables cannot. We won’t bother to rename this operand, but you should bear in mind that we’re using the term <i>pseudoregister</i> in a slightly unusual way.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
&#13;
<h4 class="H2" id="sec27"><span id="h2-74"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Replacing Pseudoregisters According to Their Storage Duration</samp></h4>&#13;
<p class="TNI">Next, we’ll adjust how we replace pseudoregisters with concrete locations. In previous chapters, every pseudoregister was assigned a spot on the stack. This time, not every variable belongs on the stack; some of them are stored in the data or BSS section. We’ll check the symbol table to tell which are which. Recall that we build a map from pseudoregisters to concrete addresses throughout the pseudoregister replacement pass. When we encounter a pseudoregister that isn’t in this map, we look it up in the symbol table. If we find that it has static storage duration, we’ll map it to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> operand by the same name. Otherwise, we’ll assign it a new slot on the stack, as usual. (If it’s not in the symbol table, that means it’s a TACKY temporary, so it has automatic storage duration.) For example, if <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> is a static variable, the assembly instruction</p>&#13;
<pre><code>Mov(Imm(0), Pseudo("foo"))</code></pre>&#13;
<p class="BodyContinued">should be rewritten as:</p>&#13;
<pre><code>Mov(Imm(0), Data("foo"))</code></pre>&#13;
<p class="TX">Because static variables don’t live on the stack, they don’t count toward the total stack size we need to track for each function.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec28">&#13;
&#13;
<h4 class="H2" id="sec28"><span id="h2-75"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Fixing Up Instructions</samp></h4>&#13;
<p class="TNI">You’ve already written several rewrite rules that apply if one or both operands are memory addresses. Keep in mind that <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> operands are memory addresses too! For example, if you encounter the instruction</p>&#13;
<pre><code>Mov(Data("x"), Stack(-4))</code></pre>&#13;
<p class="BodyContinued">you should apply the usual rewrite rule for a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction where the source and destination are both in memory. The rewritten assembly will be:</p>&#13;
<pre><code>Mov(Data("x"), Reg(R10))&#13;
Mov(Reg(R10), Stack(-4))</code></pre>&#13;
<p class="TX">Otherwise, this pass won’t change.</p>&#13;
<aside class="box" aria-label="box-11"><p class="BoxTitle" id="box-11"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_238" aria-label="238"/><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE ASSEMBLY GENERATION STAGE</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test that your compiler can generate assembly programs without throwing an error, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 10 --stage codegen</b>&#13;
</code></pre></aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec29">&#13;
&#13;
<h3 class="H1" id="sec29"><span id="h1-87"/><samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp></h3>&#13;
<p class="TNI">To wrap up this chapter, you’ll extend the code emission pass to handle the changes in <a href="chapter10.xhtml#list10-30">Listing 10-30</a>. You should include or omit the <samp class="SANS_TheSansMonoCd_W5Regular_11">.globl</samp> directive for functions based on the <samp class="SANS_TheSansMonoCd_W5Regular_11">global</samp> attribute in the assembly AST. You should also include a <samp class="SANS_TheSansMonoCd_W5Regular_11">.text</samp> directive at the start of each function definition. This directive tells the assembler to write to the text section; you need to include it now that you also write to the data and BSS sections.</p>&#13;
<p class="TX">Emit <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> operands using RIP-relative addressing. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">Data("foo")</samp> will be <samp class="SANS_TheSansMonoCd_W5Regular_11">foo(%rip)</samp> on Linux or <samp class="SANS_TheSansMonoCd_W5Regular_11">_foo(%rip)</samp> on macOS. Emit each <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp> as a list of assembly directives. On Linux, if you have a <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable(name, global, init)</samp>, where <samp class="SANS_TheSansMonoCd_W5Regular_11">global</samp> is true and <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp> is nonzero, you should emit the assembly in <a href="chapter10.xhtml#list10-31">Listing 10-31</a>.</p>&#13;
<a id="list10-31"/>&#13;
<pre><code>    .globl <var>&lt;name&gt;</var>&#13;
    .data&#13;
    .align 4&#13;
<var>&lt;name&gt;</var>:&#13;
    .long <var>&lt;init&gt;</var></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-31: The assembly for a global, nonzero static variable</samp></p>&#13;
<p class="TX">If <samp class="SANS_TheSansMonoCd_W5Regular_11">global</samp> is true and <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp> is zero, you should emit the assembly in <a href="chapter10.xhtml#list10-32">Listing 10-32</a>.</p>&#13;
<a id="list10-32"/>&#13;
<pre><code>    .globl <var>&lt;name&gt;</var>&#13;
    .bss&#13;
    .align 4&#13;
<var>&lt;name&gt;</var>:&#13;
    .zero 4</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-32: The assembly for a global static variable, initialized to zero</samp></p>&#13;
<p class="TX">If <samp class="SANS_TheSansMonoCd_W5Regular_11">global</samp> is false, emit <a href="chapter10.xhtml#list10-31">Listing 10-31</a> or 10-32 without the <samp class="SANS_TheSansMonoCd_W5Regular_11">.globl</samp> directive.</p>&#13;
<p class="TX">On macOS, you’ll emit nearly the same assembly for a <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp>, with a couple of minor differences. First, symbols should start with an underscore, as usual. Second, you should use the <samp class="SANS_TheSansMonoCd_W5Regular_11">.balign</samp> directive instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">.align</samp>. I noted earlier that the <samp class="SANS_TheSansMonoCd_W5Regular_11">.align</samp> directive’s behavior is platform-specific, so <samp class="SANS_TheSansMonoCd_W5Regular_11">.align 4</samp> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_239" aria-label="239"/>will produce 16-byte-aligned values on macOS. The <samp class="SANS_TheSansMonoCd_W5Regular_11">.balign</samp> directive works just like <samp class="SANS_TheSansMonoCd_W5Regular_11">.align</samp>, except that its behavior is consistent across platforms: <samp class="SANS_TheSansMonoCd_W5Regular_11">.balign</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n</samp> always aligns a value to <i>n</i> bytes instead of 2<i><sup>n</sup></i> bytes. (On Linux, <samp class="SANS_TheSansMonoCd_W5Regular_11">.balign</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">.align</samp> are interchangeable, so it’s fine to use either one.)</p>&#13;
<p class="TX"><a href="chapter10.xhtml#tab10-4">Tables 10-4</a> and <a href="chapter10.xhtml#tab10-5">10-5</a> summarize the latest updates to the code emission pass, with new constructs and changes to existing constructs bolded. <span class="Xref-1"><a href="appendix-B.xhtml">Appendix B</a></span> includes the complete code emission pass for this chapter (which is also the complete code emission pass for <span class="Xref-1"><a href="part1.xhtml">Part I</a></span>).</p>&#13;
<p class="TT" id="tab10-4"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 10-4:</samp></span> <samp class="SANS_Futura_Std_Book_11">Formatting Top-Level Assembly Constructs</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp></p></th>&#13;
<td class="Basic-Table TCH"/>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Output</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF" colspan="2"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Program(</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">top_levels</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp></p></td>&#13;
<td class="Basic-Table TBF"><pre class="table"><code><samp class="SANS_Futura_Std_Heavy_B_11">Print out each top-level construct.</samp> &#13;
<samp class="SANS_Futura_Std_Book_11">On Linux, add at end of file:</samp> &#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">    .section .note.GNU-stack,"",@progbits</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB" colspan="2"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">global</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, instructions)</samp></p></td>&#13;
<td class="Basic-Table TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">   </samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;global-directive&gt;</samp> &#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11"> </samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">  .text</samp> &#13;
<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;name&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">:&#13;
    pushq    %rbp&#13;
    movq     %rsp, %rbp    </samp> &#13;
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;instructions&gt;</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB" rowspan="2"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">StaticVariable(name, global, init)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Initialized to zero</samp></p></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">   </samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;global-directive&gt;</samp> &#13;
<samp class="SANS_TheSansMonoCd_W7Bold_B_11">    .bss    </samp> &#13;
<samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">    &lt;alignment-directive&gt;&#13;
&lt;name&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">:&#13;
    .zero 4</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table graybg TB"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Initialized to nonzero value</samp></p></td>&#13;
<td class="Basic-Table graybg TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">   </samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;global-directive&gt;</samp> &#13;
<samp class="SANS_TheSansMonoCd_W7Bold_B_11">    .data    </samp> &#13;
    <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;alignment-directive&gt;&#13;
&lt;name&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">:&#13;
    .long</samp><samp class="SANS_Futura_Std_Book_11"/> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;init&gt;</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table graybg1 TB" colspan="2"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Global directive</samp></p></td>&#13;
<td class="Basic-Table graybg1 TB"><pre class="table"><code><samp class="SANS_Futura_Std_Heavy_B_11">If</samp><samp class="SANS_Futura_Std_Book_11"/> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">global</samp><samp class="SANS_Futura_Std_Book_11"/> <samp class="SANS_Futura_Std_Heavy_B_11">is true:&#13;
.globl</samp><samp class="SANS_Futura_Std_Book_11"/> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;identifier&gt;</samp> &#13;
<samp class="SANS_Futura_Std_Heavy_B_11">Otherwise, omit this directive.</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table graybg TB"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Alignment directive</samp></p></td>&#13;
<td class="Basic-Table graybg TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Linux only</samp></p></td>&#13;
<td class="Basic-Table graybg TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">.align 4</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"/>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">macOS or Linux</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">.balign 4</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab10-5"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 10-5:</samp></span> <samp class="SANS_Futura_Std_Book_11">Formatting Assembly Operands</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Output</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Data(identifier)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;identifier&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">(%rip)</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Once you’ve updated the code emission pass, you’re ready to test your compiler.</p>&#13;
<aside class="box" aria-label="box-12"><p class="BoxTitle" id="box-12"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_240" aria-label="240"/><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE WHOLE COMPILER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test out the whole compiler, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 10</b>&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">Just like in <a href="chapter9.xhtml">Chapter 9</a>, the test cases for this chapter include several programs with both library and client source files. We use multifile tests to check that we’re tracking the linkage of identifiers correctly; for example, one file should be able to define and use a variable with internal linkage even if a different file in the same program defines a variable with the same name with external linkage.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec30">&#13;
&#13;
<h3 class="H1" id="sec30"><span id="h1-88"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI">You’ve just completed <span class="Xref-1"><a href="part1.xhtml">Part I</a></span> of the book! Your compiler can handle identifiers with all kinds of linkage and with both static and automatic storage duration. You’ve also learned how to write assembly programs that define and use values in the data and BSS sections of an object file.</p>&#13;
<p class="TX">You’ve now implemented all the basic mechanics of C, from local and file scope variables to control-flow statements to function calls. You’ve also taken the first steps toward a type system by distinguishing between function types and <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. In <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>, you’ll implement more types, including signed and unsigned integers of various sizes, floating-point numbers, pointers, arrays, and structures. Or, if you want, you can skip straight to <span class="Xref-1"><a href="part3.xhtml">Part III</a></span>, where you’ll implement several classic compiler optimizations. The work you’ve done so far is a solid foundation for whichever part you decide to work on next.</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>