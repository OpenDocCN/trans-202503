- en: '## **9'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '## **9'
- en: HIGH-LEVEL PROGRAMMING**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 高级编程**
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: 'In the last chapter, we looked at the fundamentals of software: machine code
    that runs on processors, and assembly language, a human-readable representation
    of machine code. Although eventually all software must take the form of machine
    code, most software developers work at a higher, more abstract level. In this
    chapter, you learn about high-level programming. We cover an overview of high-level
    programming, discuss common elements found across various programming languages,
    and look at example programs.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了软件的基础：运行在处理器上的机器代码，以及汇编语言，它是机器代码的人类可读表示。虽然最终所有软件都必须以机器代码的形式存在，但大多数软件开发人员在更高、更抽象的层次上工作。本章将介绍高级编程。我们将概述高级编程，讨论各种编程语言中常见的元素，并查看一些示例程序。
- en: '**High-Level Programming Overview**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**高级编程概述**'
- en: Although it’s possible to write software in assembly language (or even machine
    code!), doing so is time-consuming and error-prone, and it results in software
    that is hard to maintain. Furthermore, assembly language is specific to a CPU
    architecture, so if an assembly developer wishes to run their program on another
    type of CPU, the code must be rewritten. To address these shortcomings, *high-level
    programming languages* were developed; these allow programs to be written in a
    language that is independent from a specific CPU and is syntactically closer to
    human language. Many of these languages require a *compiler*, a program that converts
    high-level program statements to machine code for a specific processor. Using
    a high-level language, a software developer can write a program once and then
    compile it for multiple types of processors, sometimes with little or no change
    to the source code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以用汇编语言（甚至机器代码！）编写软件，但这样做既耗时又容易出错，而且结果是难以维护的软件。此外，汇编语言特定于某个 CPU 架构，因此如果汇编开发人员希望在另一种类型的
    CPU 上运行程序，代码必须重写。为了克服这些不足，*高级编程语言*应运而生；它们允许程序以不依赖于特定 CPU 的语言编写，并且语法上更接近人类语言。这些语言中的许多需要一个*编译器*，即将高级程序语句转换为特定处理器的机器代码的程序。使用高级语言，软件开发人员可以编写一次程序，然后将其编译为多种类型的处理器，有时源代码几乎不需要改变或根本不需要改变。
- en: 'The output of a compiler is an object file that contains machine code for a
    specific processor. As we covered in [Project #12](ch08.xhtml#proj12), object
    files aren’t in the correct format for a computer to execute. Another program,
    called a *linker*, is used to convert one or more object files into an executable
    file that the operating system can then run. The linker can also bring in other
    libraries of compiled code when needed. The process of compiling and linking is
    illustrated in [Figure 9-1](ch09.xhtml#ch9fig1).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '编译器的输出是一个目标文件，包含特定处理器的机器代码。正如我们在[项目 #12](ch08.xhtml#proj12)中介绍的那样，目标文件并不是计算机可以执行的正确格式。另一个程序，称为*链接器*，用于将一个或多个目标文件转换为可执行文件，操作系统可以运行该文件。链接器还可以在需要时引入其他已编译的代码库。编译和链接的过程在[图
    9-1](ch09.xhtml#ch9fig1)中进行了说明。'
- en: '![image](../images/fig9-1.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig9-1.jpg)'
- en: '*Figure 9-1: Building executable software from source code*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-1：从源代码构建可执行软件*'
- en: The process of compiling and linking is referred to as *building* software.
    However, in common usage, software developers sometimes speak of *compiling* their
    code when they really mean the entire process of compiling, linking, and any other
    steps required to get their code into its final form. Compilers often invoke the
    linking step automatically, making it less visible to the software developer.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 编译和链接的过程被称为*构建*软件。然而，在日常使用中，软件开发人员有时会说他们在*编译*代码，但实际上是指整个编译、链接以及将代码转换为最终形式所需的其他步骤。编译器通常会自动调用链接步骤，使其对软件开发人员来说不太可见。
- en: '**Introduction to C and Python**'
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**C 和 Python 简介**'
- en: 'The best way to learn about high-level programming is to examine programming
    languages and write some programs in those languages. For this chapter, I’ve chosen
    two high-level languages: C and Python. Both are powerful and useful, and they
    illustrate how programming languages tend to provide similar functionality but
    in different ways. Let’s begin with a brief introduction to each.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 学习高级编程的最佳方式是研究编程语言并用这些语言编写一些程序。在本章中，我选择了两种高级语言：C 和 Python。它们都是功能强大且实用的，并且能够展示编程语言如何以不同的方式提供类似的功能。我们首先简要介绍每种语言。
- en: The *C* programming language dates back to the early 1970s, when it was used
    to write a version of the Unix operating system. Despite being a high-level language,
    C isn’t that far removed from underlying machine code, making it a great choice
    for operating system development or other software that interfaces directly with
    hardware. An updated version of C known as *C++* came about in the 1980s. C and
    C++ are powerful languages that can be used to accomplish nearly anything. However,
    these languages are complex and don’t provide many safeguards against programmer
    mistakes. They remain a popular choice for programs that need to interface with
    hardware and those that require high performance, such as games. C is also useful
    for educational purposes, providing a straightforward mapping between low-level
    and high-level concepts, which is why I chose it for this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*C* 编程语言起源于 1970 年代初期，当时用于编写 Unix 操作系统的一个版本。尽管 C 是一种高级语言，但它与底层机器代码之间的距离并不遥远，这使得它成为操作系统开发或其他与硬件直接交互的软件的理想选择。80
    年代时，C 的更新版本 *C++* 出现了。C 和 C++ 是功能强大的语言，几乎可以完成任何任务。然而，这些语言也很复杂，并且没有为程序员错误提供太多的保护措施。它们仍然是需要与硬件交互或者对性能要求高的软件（如游戏）的流行选择。C
    也因其提供了从低级到高级概念的直观映射，在教育中非常有用，这也是我在本章选择它的原因。'
- en: Compared to C, the *Python* programming language is further removed from underlying
    hardware. Initially released in the 1990s, Python has grown in popularity over
    the years. It’s known for being easy to read and simple for beginners, while still
    providing everything necessary to support complex software projects. Python has
    a “batteries included” philosophy, meaning a standard distribution of Python includes
    a library of helpful capabilities that developers can easily use in their projects.
    The straightforward nature of Python makes it a good choice for teaching concepts
    of programming.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与 C 语言相比，*Python* 编程语言与底层硬件的距离更远。Python 最初于 1990 年代发布，随着时间的推移，它的流行程度逐渐上升。它因易于阅读和对初学者友好而著称，同时仍提供了支持复杂软件项目所需的一切功能。Python
    有着“自带电池”的理念，这意味着标准版 Python 包含了一系列开发者可以轻松使用的库，帮助他们在项目中快速开发。Python 的简洁特性使其成为教授编程概念的良好选择。
- en: Let’s now look at elements found across most high-level programming languages.
    The goal isn’t to teach you to be a programmer in a specific language, but to
    instead familiarize you with the ideas commonly found in programming languages.
    Remember that the capabilities found in high-level programming languages are abstractions
    of CPU instructions. As you know, CPUs provide instructions for memory access,
    math and logic operations, and control of program flow. Let’s look at how high-level
    languages expose these underlying capabilities.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下大多数高级编程语言中的一些元素。目标不是教你使用某一特定语言编程，而是让你熟悉编程语言中常见的思想。记住，高级编程语言中的功能是 CPU
    指令的抽象。正如你所知道的，CPU 提供了内存访问、数学和逻辑运算、程序流控制等指令。我们来看看高级语言是如何暴露这些底层能力的。
- en: '**Comments**'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**注释**'
- en: 'Let’s begin with a feature of programming languages that doesn’t actually instruct
    the CPU to do anything! Nearly all programming languages provide a way to include
    comments in code. A *comment* is text in source code that provides some insight
    into the code. Comments are intended to be read by other developers and are typically
    ignored by the compiler; they have no effect on the compiled software. In the
    C programming language, comments are specified like so:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从编程语言的一个特点开始，这个特点实际上并不会指示 CPU 执行任何操作！几乎所有的编程语言都提供了一种在代码中加入注释的方式。*注释*是源代码中的文本，用于提供对代码的某些解释。注释是供其他开发者阅读的，通常会被编译器忽略；它们对编译后的软件没有任何影响。在
    C 语言中，注释的书写方式如下：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Python uses the hash character for comments, like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Python 使用井号字符（#）来表示注释，像这样：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Python doesn’t provide any particular support for multiline comments; a programmer
    can simply use multiple single-line comments, one after another.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Python 并未提供对多行注释的特殊支持；程序员可以简单地使用多个单行注释，一行接一行。
- en: '**Variables**'
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**变量**'
- en: Memory access is a fundamental capability of processors, and therefore it must
    be a feature of high-level languages as well. The most basic way that programming
    languages expose memory is through variables. A *variable* is a named storage
    location in memory. Variables allow programmers to give a *name* to a memory address
    (or range of memory addresses) and then access data at that address. In most programming
    languages, variables have a *type*, indicating what sort of data they hold. For
    example, a variable may be an integer type or a text string type. Variables also
    have a *value*, which is the data stored in memory. Although it’s often hidden
    from the programmer, variables also have an *address*, the location in memory
    where the variable’s value is stored. Lastly, variables have *scope*, meaning
    they can only be accessed from certain parts of the program, the parts where they
    are “in scope.”
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 内存访问是处理器的基本功能，因此它必须是高级语言的一项特性。编程语言暴露内存的最基本方式就是通过变量。*变量*是内存中一个命名的存储位置。变量允许程序员为内存地址（或一段内存地址范围）指定一个*名称*，然后可以访问该地址上的数据。在大多数编程语言中，变量都有一个*类型*，表示它们保存的数据类型。例如，一个变量可以是整数类型或文本字符串类型。变量还具有*值*，即存储在内存中的数据。尽管这通常对程序员是隐藏的，但变量也有一个*地址*，即存储变量值的内存位置。最后，变量具有*作用域*，意味着它们只能从程序的某些部分访问，通常是它们“有效”的部分。
- en: '***Variables in C***'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***C语言中的变量***'
- en: Let’s look at an example of a variable in the C programming language.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个C语言中变量的例子。
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code *declares* a variable named `points` with a type of `int`, which in
    the C language means the variable holds an integer. The variable is then *assigned*
    a value of `27`. When this code runs, the value of `27` decimal is stored at a
    memory address, but the developer doesn’t need to worry about the specific address
    where the variable is stored. Most C compilers today treat an `int` as a 32-bit
    number, so at *runtime* (the time when a program executes) 4 bytes are allocated
    for this variable (4 bytes × 8 bits per byte = 32 bits), and the memory address
    of the variable refers to the first byte.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码*声明*了一个名为 `points` 的变量，类型为 `int`，在C语言中，这意味着该变量保存一个整数。然后该变量被*赋值*为 `27`。当这段代码运行时，`27`（十进制）的值将被存储在一个内存地址中，但开发者不需要担心该变量被存储的具体地址。如今，大多数C语言编译器将
    `int` 视为32位数值，因此在*运行时*（程序执行时），为该变量分配4字节内存（4字节 × 每字节8位 = 32位），并且该变量的内存地址指向第一个字节。
- en: Let’s now declare a second variable and assign it a value; then we can look
    at how the two variables are allocated in memory.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来声明第二个变量并赋值；然后我们可以查看这两个变量是如何在内存中分配的。
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now we have two variables, `points` and `year`, declared one after another.
    Both are integers, so they each require 4 bytes for storage. The variables can
    be stored in memory as shown in [Table 9-1](ch09.xhtml#ch9tab1).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个变量，`points` 和 `year`，它们一个接一个地声明。两个变量都是整数类型，因此每个变量需要4字节的存储空间。变量可以按照[表
    9-1](ch09.xhtml#ch9tab1)所示存储在内存中。
- en: '**Table 9-1:** Variables Stored in Memory'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-1：** 存储在内存中的变量'
- en: '| **Address** | **Variable name** | **Variable value** |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| **地址** | **变量名称** | **变量值** |'
- en: '| --- | --- | --- |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `0x7efff1cc` | `?` | `?` |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `0x7efff1cc` | `?` | `?` |'
- en: '| `0x7efff1d0` | `year` | `2020` |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `0x7efff1d0` | `year` | `2020` |'
- en: '| `0x7efff1d4` | `points` | `27` |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `0x7efff1d4` | `points` | `27` |'
- en: '| `0x7efff1d8` | `?` | `?` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `0x7efff1d8` | `?` | `?` |'
- en: The memory addresses used in [Table 9-1](ch09.xhtml#ch9tab1) are just examples;
    the actual addresses vary depending on the hardware, operating system, compiler,
    and so forth. Note that the addresses increment by four, since we’re storing 4-byte
    integers. The addresses before and after the known variables have a question mark
    for the variable name and value, since based on the preceding code, we don’t know
    what might be stored there.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在[表 9-1](ch09.xhtml#ch9tab1)中使用的内存地址只是示例；实际地址会根据硬件、操作系统、编译器等不同因素而有所不同。请注意，地址是按四字节递增的，因为我们存储的是4字节的整数。已知变量之前和之后的地址，其变量名称和值用问号表示，因为根据前面的代码，我们无法知道这些位置可能存储的内容。
- en: '**NOTE**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Please see [Project #14](ch09.xhtml#proj14) on [page 184](ch09.xhtml#page_184),
    where you can look at variables in memory*.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参见[项目 #14](ch09.xhtml#proj14)，位于[第184页](ch09.xhtml#page_184)，在那里你可以查看内存中的变量*。'
- en: 'As the name *variable* implies, the value of a variable can change. If our
    earlier C program needed to set the value of `points` to another value, we could
    simply do this later in the program:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如*变量*一词所暗示的，变量的值是可以改变的。如果我们之前的C程序需要将 `points` 的值设置为另一个值，我们可以在程序的后续部分简单地实现这一点：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that unlike our previous code snippet in C, this code does not specify
    `int` or any other type before the variable name. We only need to specify the
    type when the variable is initially declared. In this case, the variable was declared
    earlier, so here we just assign it a value. However, the C language requires that
    the variable’s type remain the same, so once `points` is declared as an `int`,
    only integers can be assigned to that variable. Attempting to assign another type,
    such as a text string, results in a failure when the code is compiled.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与我们之前的 C 代码示例不同，这段代码在变量名前并没有指定 `int` 或其他类型。我们只需要在变量首次声明时指定类型。在这种情况下，变量已经提前声明过，因此这里只是给它赋值。然而，C
    语言要求变量的类型保持不变，所以一旦 `points` 被声明为 `int`，只能给该变量赋值整数类型。如果尝试赋值其他类型，比如文本字符串，则在编译代码时会失败。
- en: '***Variables in Python***'
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Python 中的变量***'
- en: 'Not all languages require a declaration of type. Python, for example, allows
    a variable to be declared and assigned like so:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是所有语言都要求声明类型。例如，Python 允许像这样声明并赋值一个变量：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, in this case, Python recognizes that the type of data is an integer, but
    the programmer doesn’t have to specify this. Unlike in C, the variable’s type
    can change over time, so the following is valid in Python:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在这种情况下，Python 识别到数据的类型是整数，但程序员并不需要指定这一点。与 C 不同，变量的类型可以随着时间变化，因此在 Python 中，以下代码是有效的：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s take a closer look at what is actually happening in this example. A Python
    variable has no type, but the value to which it refers does have a type. This
    is an important distinction: the type is associated with the value, not the variable.
    A Python variable can refer to a value of any type. So when the variable is assigned
    a new value, it isn’t really that the variable’s type is changing, but rather
    that the variable has been bound to a value of a different type. Contrast this
    with C, where the variable itself has a type and can only hold values of that
    type. This difference explains why a variable in Python can be assigned values
    of different types, whereas a variable in C cannot.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解一下这个示例中实际发生了什么。一个 Python 变量没有类型，但它所引用的值有类型。这是一个重要的区别：类型是与值关联的，而不是与变量关联的。一个
    Python 变量可以引用任何类型的值。因此，当给变量赋予新值时，实际上并不是变量的类型发生了变化，而是变量被绑定到了一个不同类型的值上。与此对比，在 C
    中，变量本身具有类型，并且只能保存该类型的值。这一差异解释了为什么 Python 中的变量可以赋值不同类型的值，而 C 中的变量则不能。
- en: '**NOTE**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Please see [Project #15](ch09.xhtml#proj15) on [page 186](ch09.xhtml#page_186),
    where you can change the type of value referenced by a variable in Python*.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参见 [项目 #15](ch09.xhtml#proj15) 和 [第 186 页](ch09.xhtml#page_186)，在那里你可以更改
    Python 中变量引用的值的类型*。'
- en: '**Stack and Heap Memory**'
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**栈内存和堆内存**'
- en: 'When a programmer uses a high-level language to access memory, the details
    of how that memory is managed behind the scenes is somewhat obscured, depending
    on the programming language in use. A programming language like Python makes the
    details of memory allocation nearly invisible to the programmer, whereas a language
    like C exposes some of the underlying memory management mechanisms. Whether the
    details are exposed to the programmer or not, programs commonly make use of two
    types of memory: stack and heap.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序员使用高级语言访问内存时，内存的管理细节会有所隐藏，这取决于所使用的编程语言。例如，像 Python 这样的编程语言使内存分配的细节几乎对程序员不可见，而像
    C 这样的语言则暴露了一些底层的内存管理机制。无论这些细节是否对程序员可见，程序通常都会使用两种类型的内存：栈内存和堆内存。
- en: '***The Stack***'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***栈内存***'
- en: The *stack* is an area of memory that operates on a *last-in first-out (LIFO)*
    model. That is, the last item put on the stack is the first item that comes off
    the stack. You can think of a memory stack as being like a stack of plates. When
    you add to a stack of plates, you add the newest plate to the top. When the time
    comes to take a plate from the stack, you remove the top plate first. This does
    not mean that the items on the stack can only be *accessed* (read or modified)
    in LIFO order. In fact, any item currently on the stack can be read or modified
    at any time. However, when it comes time to remove unneeded items from the stack,
    the items are discarded from the top down, meaning the last item placed on the
    stack is the first to go.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*栈*是一个按照*后进先出（LIFO）*模型工作的内存区域。也就是说，最后放入栈中的项是第一个被移除的项。你可以把内存栈想象成一叠盘子。当你向栈中添加新的盘子时，你把最新的盘子放到最上面。当你需要从栈中取出盘子时，你会首先取出最上面的盘子。这并不意味着栈中的项只能按LIFO顺序被*访问*（读取或修改）。实际上，栈中任何当前的项都可以随时被读取或修改。然而，在需要移除不再需要的项时，项会从栈顶向下被丢弃，意味着最后放入栈中的项会首先被移除。'
- en: The memory address of the value on the top of the stack is stored in a processor
    register known as the *stack pointer*. When a value is added to the top of the
    stack, the stack pointer’s value is adjusted to increase the size of the stack
    and make room for the new value. When a value is removed from the top of the stack,
    the stack pointer is adjusted to decrease the size of the stack.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 栈顶值的内存地址存储在一个称为*栈指针*的处理器寄存器中。当一个值被添加到栈顶时，栈指针的值会被调整，以增加栈的大小并为新值腾出空间。当一个值从栈顶被移除时，栈指针会被调整，以减小栈的大小。
- en: The compiler generates code that uses the stack to track the state of a program’s
    execution and as a place to store local variables. The mechanics of this are transparent
    to a programmer in a high-level language. [Figure 9-2](ch09.xhtml#ch9fig2) provides
    a look at how a C program uses the stack to hold the two local variables that
    we covered earlier in [Table 9-1](ch09.xhtml#ch9tab1).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器生成的代码利用栈来跟踪程序执行的状态，并作为存储局部变量的地方。这些机制对于使用高级语言的程序员来说是透明的。[图9-2](ch09.xhtml#ch9fig2)展示了C程序如何利用栈存储我们在[表9-1](ch09.xhtml#ch9tab1)中提到的两个局部变量。
- en: '![image](../images/fig9-2.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig9-2.jpg)'
- en: '*Figure 9-2: Stack memory is used to hold variable values in a program written
    in C.*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-2：栈内存用于存储用C语言编写的程序中的变量值。*'
- en: In [Figure 9-2](ch09.xhtml#ch9fig2), the `points` variable is declared first
    and assigned a value of `27`, a value that is stored on the stack. Next, the `year`
    variable is declared and assigned a value of `2020`. This second value is placed
    “above” the prior value on the stack. Additional values will continue to be added
    to the top of the stack until they are no longer needed, at which point they will
    be removed from the stack. Keep in mind that each slot in the diagram is just
    a location in memory with an assigned memory address, although the addresses aren’t
    shown in the diagram. You may be surprised to hear that in many architectures,
    the memory addresses assigned to the stack actually *decrease* as the stack grows.
    In this example, that means that the `year` variable has a lower memory address
    than the `points` variable.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图9-2](ch09.xhtml#ch9fig2)中，`points`变量首先被声明，并被赋值为`27`，这个值存储在栈上。接下来，`year`变量被声明并赋值为`2020`。第二个值被放置在栈上第一个值的“上方”。更多的值将继续被添加到栈的顶部，直到不再需要为止，这时它们将从栈中移除。请记住，图中的每个槽只是内存中的一个位置，并分配有内存地址，尽管图中没有显示这些地址。你可能会感到惊讶，许多架构中，栈分配的内存地址实际上是*递减*的。以这个例子来说，意味着`year`变量的内存地址低于`points`变量的地址。
- en: Stack memory is fast and well suited for small memory allocations that have
    limited scope. A separate stack is made available to each thread of execution
    in a program. We’ll cover threads in more detail in [Chapter 10](ch10.xhtml),
    but for now you can think of threads as parallel tasks within a program. The stack
    is a limited resource; there’s a limit to how much memory is allocated to the
    stack. Putting too many values on the stack results in a failure known as a *stack
    overflow*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 栈内存速度快，非常适合于具有有限作用范围的小内存分配。每个执行线程在程序中都会有一个单独的栈。我们将在[第10章](ch10.xhtml)中更详细地讨论线程，但现在你可以把线程看作是程序中的并行任务。栈是一种有限的资源；分配给栈的内存是有上限的。如果将太多的值放入栈中，会导致一种叫做*栈溢出*的错误。
- en: '***The Heap***'
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***堆***'
- en: The stack is meant to hold small values that only need to be temporarily available.
    For memory allocations that are large or need to persist for a longer time, the
    heap is a better fit. The *heap* is a pool of memory that’s available to a program.
    Unlike the stack, heap memory doesn’t work on a LIFO model; there is no standard
    model for how heap memory is allocated. Whereas stack memory is specific to a
    thread, allocations made from the heap can be accessed by any of the program’s
    threads.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈用于存储只需要临时使用的小型值。对于需要更大内存或需要长期存在的内存分配，堆更为合适。*堆*是程序可用的一块内存池。与堆栈不同，堆内存并不采用先进后出（LIFO）模型；堆内存的分配没有标准模型。而堆栈内存特定于某个线程，来自堆的内存分配可以被程序的任何线程访问。
- en: Programs allocate memory from the heap, and that memory usage persists until
    it’s freed by the program or the program terminates. To *free* a memory allocation
    simply means to release it back to the pool of available memory. Some programming
    languages automatically free heap memory when an allocation is no longer referenced;
    one common approach for doing this is known as *garbage collection*. Other programming
    languages, like C, require the programmer to write code to free heap memory. A
    *memory leak* occurs when unused memory isn’t freed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 程序从堆中分配内存，且该内存的使用会持续到程序释放或程序终止。*释放*内存分配意味着将其归还给可用内存池。当某个分配不再被引用时，一些编程语言会自动释放堆内存；这种方法通常被称为*垃圾回收*。其他编程语言，如C，则要求程序员编写代码来释放堆内存。如果未释放未使用的内存，就会发生*内存泄漏*。
- en: In the C programming language, a special kind of variable called a *pointer*
    is used to track memory allocations. A pointer is simply a variable that holds
    a memory address. The pointer value (a memory address) can be stored in a local
    variable on the stack, and that value can refer to a location in the heap, as
    illustrated in [Figure 9-3](ch09.xhtml#ch9fig3).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在C编程语言中，有一种特殊的变量叫做*指针*，用于追踪内存分配。指针实际上是一个存储内存地址的变量。指针值（即内存地址）可以存储在堆栈上的局部变量中，而该值可以指向堆中的某个位置，正如[图9-3](ch09.xhtml#ch9fig3)所示。
- en: '![image](../images/fig9-3.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig9-3.jpg)'
- en: '*Figure 9-3: The pointer variable named `data` is on the stack and points to
    an address in the heap.*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-3：名为`data`的指针变量位于堆栈上，并指向堆中的某个地址。*'
- en: In [Figure 9-3](ch09.xhtml#ch9fig3) we have a code snippet that declares a variable
    called `data`. This variable is of type `void *`, which means it’s a pointer (indicated
    by `*`) that points to a memory address that can hold any type of data (`void`
    means the type isn’t specified). Because `data` is a local variable, it is allocated
    on the stack. The next line of code makes a call to `malloc`, a function in C
    that allocates memory from heap. The program is asking for 512 bytes of memory,
    and the `malloc` function returns the address of the first byte of the newly allocated
    memory. That address is stored in the `data` variable, on the stack. So we end
    up with a local variable at an address on the stack that holds the address of
    an allocation on the heap.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图9-3](ch09.xhtml#ch9fig3)中，我们有一段声明了名为`data`的变量的代码。该变量类型为`void *`，这意味着它是一个指针（由`*`表示），指向一个可以存储任何类型数据的内存地址（`void`表示类型未指定）。因为`data`是一个局部变量，它被分配在堆栈上。接下来的代码调用了`malloc`，这是C语言中一个从堆中分配内存的函数。程序请求分配512字节的内存，`malloc`函数返回新分配内存的第一个字节的地址。这个地址存储在堆栈上的`data`变量中。最终，我们在堆栈上的某个地址处得到了一个局部变量，这个变量存储着堆内存分配的地址。
- en: '**NOTE**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Please see [Project #16](ch09.xhtml#proj16) on [page 187](ch09.xhtml#page_187),
    where you can see for yourself how variables are allocated in a running program*.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参见[项目#16](ch09.xhtml#proj16)（在[第187页](ch09.xhtml#page_187)），你可以亲自查看程序运行时变量是如何分配的。*'
- en: '**Math**'
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数学**'
- en: Since processors provide instructions for performing mathematical operations,
    high-level languages do too. In contrast to programming in assembly language,
    where specific named instructions are required for math (such as the `subs` instruction
    for subtraction on ARM processors), high-level languages generally include symbols
    that represent common mathematical operations, making it simple to perform math
    in code. A large number of programming languages, including C and Python, use
    the same operators for addition, subtraction, multiplication, and division, as
    shown in [Table 9-2](ch09.xhtml#ch9tab2).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于处理器提供了执行数学运算的指令，高级语言也提供了相应的指令。与汇编语言编程不同，汇编语言中需要针对数学运算指定具体的命名指令（例如在ARM处理器上使用`subs`指令进行减法），高级语言通常使用符号来表示常见的数学运算，这使得在代码中进行数学运算变得非常简单。许多编程语言，包括C语言和Python，使用相同的运算符表示加法、减法、乘法和除法，具体如[表9-2](ch09.xhtml#ch9tab2)所示。
- en: '**Table 9-2:** Common Math Operators'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**表9-2：** 常见数学运算符'
- en: '| **Operation** | **Operator** |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **运算符** |'
- en: '| --- | --- |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Addition | `+` |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 加法 | `+` |'
- en: '| Subtraction | `-` |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 减法 | `-` |'
- en: '| Multiplication | `*` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 乘法 | `*` |'
- en: '| Division | `/` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 除法 | `/` |'
- en: 'Another common convention across multiple programming languages is to use the
    equals sign (`=`) to represent an assignment rather than equality. That is, a
    statement like `x = 5` means to *set* the value of x to 5\. Assigning the result
    of a mathematical operation is represented in a natural way, such as in these
    statements:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在多种编程语言中常见的约定是使用等号（`=`）表示赋值，而不是表示相等。也就是说，像`x = 5`这样的语句意味着*将* x 的值设置为 5。将数学运算的结果赋给一个变量的表示方式是自然的，比如在这些语句中：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'So far, we’ve focused on integer math, which is common in computing. However,
    computers and high-level languages also support something called *floating-point
    arithmetic*. Unlike integers that represent whole numbers, floating-point values
    can represent fractions. Some programming languages hide the details of this,
    but internally CPUs use different instructions for floating-point math than for
    integer math. In C, floating-point variables are declared using a floating-point
    type such as `float` or `double`, as shown here:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们关注的是在计算中常见的整数运算。然而，计算机和高级语言也支持一种叫做*浮点运算*的数学运算。与表示整数的整数不同，浮点值可以表示小数。一些编程语言隐藏了这部分细节，但在内部，CPU使用与整数运算不同的指令来执行浮点运算。在C语言中，浮点变量通过浮点类型声明，如`float`或`double`，如下所示：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'On the other hand, Python infers type for its variables, so both integers and
    floating-point values are declared in the same way:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Python会推断变量类型，因此整数和浮点值的声明方式是相同的：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The differences in integers verses floating-point numbers can lead to unexpected
    results sometimes. For example, let’s say you have the following C code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 整数和浮点数之间的差异有时会导致意外的结果。例如，假设你有以下的C语言代码：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: What would you expect the value of `z` to be? It turns out that since all the
    numbers involved are integers, `z` ends up with a value of `2`. Not `2.5`, but
    `2`. As an integer, `z` cannot hold fractional values.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你期望`z`的值是多少？结果发现，由于所有参与运算的数值都是整数，`z`最终的值是`2`。不是`2.5`，而是`2`。作为整数，`z`不能保存小数值。
- en: 'Now what if we changed the code slightly, like so:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们稍微改变一下代码，像这样：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that `z` now has a type of `float`. Now what would you expect the value
    of `z` to be? Interestingly, `z` is now equal to `2.0`; it still isn’t `2.5`!
    This is because the division operation occurred with two integers, so the result
    was an integer too. The division result was `2`, and when it was assigned to floating-point
    variable `z`, it was given the value `2.0`. The C language is very literal; it’s
    compiled into instructions that closely mirror what the programmer said to do.
    This is great for programmers who need fine-grained control of processing, but
    not always so great for programmers who expect more intuitive behavior from their
    programming language.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`z`现在是`float`类型。现在你期望`z`的值是多少？有趣的是，`z`现在等于`2.0`，它依然不是`2.5`！这是因为除法运算发生在两个整数之间，所以结果也是一个整数。除法的结果是`2`，当这个值赋给浮点类型的变量`z`时，它被赋值为`2.0`。C语言是非常字面化的；它被编译成紧密反映程序员指令的机器码。这对于需要精确控制处理过程的程序员来说是很棒的，但对于那些希望编程语言行为更直观的程序员来说，则不总是那么理想。
- en: Python tries to be more helpful, automatically assigning a type that allows
    for fractional results in a situation like this. If we write an equivalent version
    of this code in Python, the result stored in `z` will be `2.5`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Python 尝试更智能地处理，自动分配一个允许小数结果的类型，在这种情况下。如果我们在 Python 中写出等效的代码，存储在 `z` 中的结果将是
    `2.5`。
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Some languages provide mathematical operators that are abbreviated ways of
    stating an operation. For example, C provides increment (add 1) and decrement
    (subtract 1) operators, as shown here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编程语言提供了数学运算符，这些运算符是表示操作的一种简洁方式。例如，C 语言提供了增量（加 1）和减量（减 1）运算符，如下所示：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**NOTE**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Fun fact: the name of the programming language C++ is meant to convey the
    idea that it’s an improvement upon, or an increment of, the C programming language*.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*有趣的事实：编程语言 C++ 的名称意味着它是在 C 语言的基础上进行改进或增量的语言*。'
- en: 'Python also provides some shortcut operators for math. The `+=` and `-=` operators
    allow programmers to add to or subtract from a variable. For example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Python 还提供了一些数学运算的快捷方式。`+=` 和 `-=` 运算符允许程序员对变量进行加法或减法。例如：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `+=` and `-=` operators work in C as well.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`+=` 和 `-=` 运算符在 C 语言中也同样适用。'
- en: '**Logic**'
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**逻辑**'
- en: 'As we covered earlier, processors are very good at performing logical operations,
    since logic is the foundation for digital circuits. As you’d expect, programming
    languages also provide the capability to handle logic. Most high-level languages
    provide two kinds of operators that deal in logic: bitwise operators, which deal
    with the bits of integers, and Boolean operators, which deal with Boolean (true/false)
    values. The terminology here can be confusing, since different programming languages
    use different terms. Python uses “bitwise” and “Boolean,” whereas C uses “bitwise”
    and “logical,” and other languages use still other terms. Let’s stick with “bitwise”
    and “Boolean” here.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，处理器非常擅长执行逻辑运算，因为逻辑是数字电路的基础。正如你所预期的那样，编程语言也提供了处理逻辑的能力。大多数高级语言提供了两种操作逻辑的运算符：位运算符，作用于整数的比特；布尔运算符，作用于布尔（真/假）值。这里的术语可能会让人困惑，因为不同的编程语言使用不同的术语。Python
    使用“位运算”和“布尔”，而 C 语言使用“位运算”和“逻辑”，其他语言则使用其他术语。在这里我们坚持使用“位运算”和“布尔”。
- en: '***Bitwise Operators***'
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***位运算符***'
- en: '*Bitwise operators* act on the individual bits of integer values and result
    in an integer value. A bitwise operator is like a mathematical operator, but instead
    of adding or subtracting, it performs an AND, OR, or other logical operation on
    the bits of integers. These operators work according to the truth tables covered
    in [Chapter 2](ch02.xhtml), performing the operation on all the bits in the integer
    in parallel.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*位运算符* 作用于整数值的单个比特，并返回一个整数值。位运算符就像数学运算符，但它不是进行加法或减法，而是在整数的比特上执行与（AND）、或（OR）或其他逻辑操作。这些运算符依据[第二章](ch02.xhtml)中讨论的真值表工作，平行地对整数的所有比特执行操作。'
- en: Many programming languages, including C and Python, use the set of operators
    shown in [Table 9-3](ch09.xhtml#ch9tab3) for bitwise operations.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编程语言，包括 C 和 Python，使用[表 9-3](ch09.xhtml#ch9tab3)中显示的运算符集合来进行位运算。
- en: '**Table 9-3:** Bitwise Operations as Commonly Expressed in Programming Languages'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-3：** 编程语言中常见的位运算'
- en: '| **Bitwise operation** | **Bitwise operator** |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| **位运算** | **位运算符** |'
- en: '| --- | --- |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| AND | `&` |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 与 | `&` |'
- en: '| OR | `&#124;` |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 或 | `&#124;` |'
- en: '| XOR | `^` |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 异或 | `^` |'
- en: '| NOT (complement) | `~` |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 非（补码） | `~` |'
- en: Let’s look at a bitwise example in Python.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个 Python 中的位运算示例。
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The result of the code above is that `a` is 1 and `b` is 7\. Let’s look at those
    operations in binary ([Figure 9-4](ch09.xhtml#ch9fig4)) to make it clear why this
    is so.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的结果是 `a` 为 1，`b` 为 7。让我们通过二进制（[图 9-4](ch09.xhtml#ch9fig4)）来看这些操作，以便清楚地了解为什么会是这样。
- en: '![image](../images/fig9-4.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig9-4.jpg)'
- en: '*Figure 9-4: Bitwise AND, OR operations on 5 and 3*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-4：5 和 3 的位与、位或运算*'
- en: Take a look at the AND operation in [Figure 9-4](ch09.xhtml#ch9fig4) first;
    recall from [Chapter 2](ch02.xhtml) that AND means that the result is 1 when both
    inputs are 1\. Here we look at the bits one column at a time, and as you can see,
    only the rightmost bit is 1 for both inputs. Therefore, the AND result is 0001
    binary, or 1 decimal. Therefore, `a` is assigned a value of 1 in the preceding
    code.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先查看[图 9-4](ch09.xhtml#ch9fig4)中的与运算；回想一下[第二章](ch02.xhtml)中提到的与运算规则，当两个输入都为
    1 时，结果为 1。我们逐列查看这些位，如你所见，只有最右侧的位在两个输入中都是 1。因此，与运算的结果是 0001 二进制，或 1 十进制。因此，在之前的代码中，`a`
    被赋值为 1。
- en: On the other hand, OR means that the result is 1 if either input (or both inputs)
    is 1\. In this example, the rightmost three bits are all 1 in one input or the
    other, so the result is 0111 binary, or 7 decimal. Therefore, `b` is assigned
    a value of 7 in the preceding code.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，OR 表示如果任一输入（或两个输入中的任何一个）为 1，则结果为 1。在这个例子中，右边三个二进制位中有一个输入或另一个输入的位都为 1，所以结果是二进制
    0111，或十进制 7。因此，`b` 在前面的代码中被赋值为 7。
- en: '**EXERCISE 9-1: BITWISE OPERATORS**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 9-1：位运算符**'
- en: Consider the following Python statements. What will be the values of `a`, `b`,
    and `c` after this code executes?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下 Python 语句。这段代码执行后，`a`、`b` 和 `c` 的值会是什么？
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The answer can be found in [Appendix A](appa.xhtml).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 答案可以在 [附录 A](appa.xhtml) 找到。
- en: '***Boolean Operators***'
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***布尔运算符***'
- en: The other kind of logical operator in high-level programming languages is the
    *Boolean operator*. These operators work on Boolean values and result in a Boolean
    value.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 高级编程语言中的另一类逻辑运算符是 *布尔运算符*。这些运算符作用于布尔值并返回布尔值。
- en: 'Let’s take a moment to talk about Boolean values. A *Boolean value* is either
    true or false. Different programming languages represent true or false in different
    ways. A *Boolean variable* is a named memory address that holds a Boolean value
    of true or false. For example, we could have a variable in Python that tracks
    whether an item is on sale: `item_on_sale = True`.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花一点时间讨论布尔值。*布尔值* 只能是真或假。不同的编程语言以不同的方式表示真或假。*布尔变量* 是一个命名的内存地址，它保存一个布尔值，即真或假。例如，我们可以在
    Python 中定义一个变量来追踪某个物品是否在销售：`item_on_sale = True`。
- en: An expression can evaluate to true or false without the result being stored
    in a variable. For example, the expression `item_cost > 5` evaluates to either
    true or false at runtime depending on the value of the `item_cost` variable.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式可以在不将结果存储到变量中的情况下评估为真或假。例如，表达式 `item_cost > 5` 在运行时根据 `item_cost` 变量的值评估为真或假。
- en: 'Boolean operators allow us to perform a logical operation like AND, OR, or
    NOT on Boolean values. For example, we can check if two conditions are both true
    using Python’s Boolean AND operator: `item_on_sale` and `item_cost > 5`. The expressions
    to the left and right of `and` evaluate to Boolean values, and in turn, the entire
    expression evaluates to a Boolean value. Here C and Python use different operators,
    as shown in [Table 9-4](ch09.xhtml#ch9tab4).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔运算符允许我们对布尔值执行逻辑操作，例如 AND、OR 或 NOT。例如，我们可以使用 Python 的布尔 AND 运算符检查两个条件是否都为真：`item_on_sale`
    和 `item_cost > 5`。`and` 左右两边的表达式会评估为布尔值，整个表达式的结果也将是布尔值。在这里，C 和 Python 使用不同的运算符，如
    [表 9-4](ch09.xhtml#ch9tab4) 所示。
- en: '**Table 9-4:** Boolean Operators in C and Python Programming Languages'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-4：** C 和 Python 编程语言中的布尔运算符'
- en: '| **Boolean operation** | **C operator** | **Python operator** |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| **布尔运算** | **C 运算符** | **Python 运算符** |'
- en: '| --- | --- | --- |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| AND | `&`& | `and` |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 与 | `&`& | `and` |'
- en: '| OR | `&#124;&#124;` | `or` |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 或 | `&#124;&#124;` | `or` |'
- en: '| NOT | `!` | `not` |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 非 | `!` | `not` |'
- en: While we’re on the subject of operators that return Boolean values, a *comparison
    operator* compares two values and evaluates to true or false as the result of
    the comparison. For example, the *greater than operator* allows us to compare
    two numbers and determine if one is larger than the other. [Table 9-5](ch09.xhtml#ch9tab5)
    shows comparison operators used in both C and Python.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论返回布尔值的运算符时，*比较运算符* 会比较两个值，并根据比较结果评估为真或假。例如，*大于运算符* 允许我们比较两个数字并确定其中一个是否大于另一个。[表
    9-5](ch09.xhtml#ch9tab5) 显示了 C 和 Python 中使用的比较运算符。
- en: '**Table 9-5:** Comparison Operators in C and Python Programming Languages'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-5：** C 和 Python 编程语言中的比较运算符'
- en: '| **Comparison operation** | **Comparison operator** |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| **比较操作** | **比较运算符** |'
- en: '| --- | --- |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| EQUALITY | `==` |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 等于 | `==` |'
- en: '| NOT EQUAL | `!=` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 不等于 | `!=` |'
- en: '| GREATER THAN | `>` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 大于 | `>` |'
- en: '| LESS THAN | `<` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 小于 | `<` |'
- en: '| GREATER THAN OR EQUAL | `>=` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 大于或等于 | `>=` |'
- en: '| LESS THAN OR EQUAL | `<=` |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 小于或等于 | `<=` |'
- en: You’ve already seen one of these in use, in our earlier example of `item_cost
    > 5`. Pay attention to the equality operator. Both C and Python use a double equals
    sign to represent an equality comparison, and they use a single equals sign to
    represent an assignment. That means `x == 5` is a comparison that returns true
    or false (is `x` equal to `5`?), whereas `x = 5` is an assignment that sets the
    value of `x` to `5`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到过其中一个例子，我们之前提到的`item_cost > 5`。请注意相等运算符。C语言和Python都使用双等号表示相等比较，使用单等号表示赋值。这意味着`x
    == 5`是一个比较，返回`true`或`false`（`x`是否等于`5`？），而`x = 5`是一个赋值，将`x`的值设为`5`。
- en: '**Program Flow**'
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**程序流程**'
- en: Boolean and comparison operators allow us to evaluate the truth of an expression,
    but that alone isn’t very useful. We need a way to do something in response! *Program
    flow*, or *control flow*, statements allow us to do just that, altering the behavior
    of a program in response to some condition. Let’s look at some common program
    flow constructs found across programming languages.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔运算符和比较运算符让我们能够评估表达式的真假，但仅此并不十分有用。我们需要一种方式来响应这些评估结果！*程序流程*，或称*控制流*语句，使我们能够做出响应，在某些条件下改变程序的行为。让我们来看看不同编程语言中常见的程序流构造。
- en: '***If Statements***'
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***If语句***'
- en: 'An *if statement*, often coupled with an *else statement*, allows the programmer
    to do something if some condition is true. In turn, the `else` statement allows
    the program to do something different if the condition is false. Here’s an example
    in Python:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*if语句*，通常与*else语句*一起使用，允许程序员在某个条件为真时执行某些操作。反过来，`else`语句允许程序在条件为假时执行不同的操作。以下是Python中的一个例子：'
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example, the first `if` statement ❶ checks if the `age` variable refers
    to a value that’s less than 18\. If so, it prints a message indicating that the
    user is young ❷. The `else` statement ❸ tells the program to print a different
    message if `age` is 18 or greater ❹.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，第一个`if`语句 ❶ 检查`age`变量是否小于18。如果是，它会打印一条信息，表示用户很年轻 ❷。`else`语句 ❸ 告诉程序，如果`age`大于或等于18，则打印另一条消息
    ❹。
- en: 'Here is the same “age check” logic, this time written in C:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是相同的“年龄检查”逻辑，这次用C语言编写：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the C example, note the curly braces used after the `if` statement ❶❷. These
    mark off a block of code that should execute in response to the `if`. In C, a
    code block can consist of multiple lines of code, although the braces can be omitted
    when the block consists of a single line. Python doesn’t use braces to delimit
    a block of code; it uses indentation instead. In Python, contiguous lines at the
    same level of indentation (say, four spaces) are considered part of the same block.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言示例中，注意在`if`语句后使用的大括号 ❶❷。这些大括号标记了一段应该在`if`语句响应下执行的代码块。在C语言中，代码块可以由多行代码组成，尽管在代码块只有一行时，可以省略大括号。Python不使用大括号来限制代码块，而是使用缩进。在Python中，连续在同一缩进级别（比如四个空格）的行被视为同一代码块的一部分。
- en: Python also includes an `elif` statement, which means “else if.” An `elif` statement
    is only evaluated if the preceding `if` or `elif` statement was false.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Python还包含了`elif`语句，表示“else if”。只有在前面的`if`或`elif`语句为假时，`elif`语句才会被评估。
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The same thing can be accomplished in C by using an `else` coupled with an
    `if`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中，使用`else`和`if`结合的方式可以完成相同的功能：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that I’ve also omitted the curly braces since all my code blocks are single
    lines.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我也省略了大括号，因为我的所有代码块都是单行的。
- en: '***Looping***'
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***循环***'
- en: Sometimes a program needs to perform a certain action over and over. A *while
    loop* allows code to run repeatedly until some condition is met. In the following
    Python example, a `while` loop is used to print the numbers from 1 to 20.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，程序需要反复执行某个操作。*while循环*允许代码重复运行，直到某个条件满足。在下面的Python示例中，使用`while`循环打印从1到20的数字。
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Initially, the variable `n` is set to `1`. The `while` loop begins, indicating
    that the loop should run while `n` is less than or equal to `20`. Since `n` is
    `1`, it meets that requirement, so the body of the `while` loop runs, printing
    the value of `n` and adding 1 to it. Now `n` is equal to `2`, and the code goes
    back to the top of the `while` loop. This process continues until `n` is equal
    to `21`, at which point it no longer meets the requirements of the `while` loop,
    so the loop ends.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，变量`n`被设置为`1`。`while`循环开始，表示循环应该在`n`小于或等于`20`时运行。由于`n`是`1`，它满足条件，因此`while`循环的主体开始执行，打印`n`的值并将其加1。现在`n`等于`2`，代码返回到`while`循环的顶部。这个过程会一直继续，直到`n`等于`21`，此时它不再满足`while`循环的要求，所以循环结束。
- en: The following is the same thing implemented in C.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是相同功能在C语言中的实现。
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In both examples, the body of the `while` loop increments the value of `n`.
    There’s actually a cleaner way to do this. A *for loop* allows iteration over
    a range of numbers or a collection of values so that the programmer can perform
    some operation on each. Here we have an example in C that prints 1 through 10.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个示例中，`while`循环的主体会递增`n`的值。实际上，有一种更简洁的方式来做这件事。*for循环*允许对一系列数字或值的集合进行迭代，从而使程序员能够对每个项执行某些操作。这里有一个C语言示例，它会打印从1到10的数字。
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `for` loop declares `x` and sets its initial value to `1` ❶, states that
    the loop will continue while `x` is less than or equal to `10` ❷, and finally
    declares that `x` should be incremented after the body of the loop runs ❸. By
    putting all of this information in a `for` statement on a single line, we can
    more easily see the conditions under which the loop will run. The body of the
    `for` loop simply prints the value of `x` ❹.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环声明了`x`并将其初始值设置为`1`❶，指定循环将在`x`小于或等于`10`时继续❷，最后声明在循环体执行后应递增`x`的值❸。通过将所有这些信息写在一行`for`语句中，我们可以更容易地看到循环运行的条件。`for`循环的主体只是打印出`x`的值❹。'
- en: Python takes a different approach with its `for` loops, allowing the program
    to take an action repeatedly on every item in a collection of values. The following
    Python example prints out the names of animals in a list.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Python采用了不同的方式处理`for`循环，允许程序对集合中的每个项执行重复操作。以下是一个Python示例，它会打印出列表中的动物名称。
- en: '[PRE25]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: First, a list of animal names is declared and assigned to a variable named `animal_list`.
    In Python, a list is an ordered collection of values. Next, the `for` loop states
    that the code block runs once for each item in `animal_list`, and each time the
    code runs, the current value in the list is assigned to the `animal` variable.
    So the first time the body of the loop runs, `animal` is equal to `cat`, and the
    program prints `cat`. The next time through `dog` prints, and the final time `mouse`
    prints.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，声明一个动物名称的列表并将其赋值给名为`animal_list`的变量。在Python中，列表是一个有序的值集合。接下来，`for`循环声明代码块会对`animal_list`中的每个项执行一次，每次运行时，列表中的当前值会被赋给`animal`变量。因此，第一次执行循环时，`animal`等于`cat`，程序会打印出`cat`。下一次执行时打印出`dog`，最后一次执行时打印出`mouse`。
- en: '**Functions**'
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数**'
- en: Looping allows a set of instructions to run multiple times in a row. However,
    it’s also common for a program to run a particular set of instructions multiple
    times, but not necessarily in a loop. Instead, such instructions may need to be
    invoked from different parts of the program, at different times, and with varying
    inputs and outputs. When a programmer realizes that the same code is needed in
    multiple places, they may write that code as a function. A *function* is a set
    of program instructions that may be invoked, or called, by other code. Functions
    optionally take inputs (known as *parameters*) and return an output (known as
    a *return value*). Different high-level languages use different terms for a function,
    including *subroutine*, *procedure*, or *method*. In some cases, these various
    names actually convey slightly different meanings, but for our purposes, let’s
    just stick with function.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 循环允许一组指令连续执行多次。然而，程序中也常常需要执行一组特定的指令多次，但不一定在循环中执行。相反，这些指令可能需要从程序的不同部分、不同时间、以及不同的输入和输出中调用。当程序员意识到某些代码在多个地方都需要时，他们可能会将这些代码编写成一个函数。*函数*是一组程序指令，可以被其他代码调用。函数可以选择接受输入（称为*参数*）并返回输出（称为*返回值*）。不同的高级编程语言可能使用不同的术语来描述函数，包括*子例程*、*过程*或*方法*。在某些情况下，这些不同的名称可能传达略有不同的含义，但为了简化，我们就使用函数这一术语。
- en: Converting a character string to lowercase, printing text to the screen, and
    downloading a file from the internet are all examples of what you can do with
    reusable code in the form of a function. Programmers want to avoid typing out
    the same code multiple times. Doing so means maintaining several copies of the
    same code and increasing the overall size of a program. This violates a software
    engineering principle known as *don’t repeat yourself (DRY)* that encourages a
    reduction of duplicative code.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符字符串转换为小写、将文本打印到屏幕以及从互联网下载文件，都是你可以通过可重用的代码（以函数形式）实现的例子。程序员希望避免多次键入相同的代码。这样做会导致维护多个相同代码的副本，并增加程序的整体大小。这违反了一个软件工程原则，即*不要重复自己（DRY）*，该原则鼓励减少重复代码。
- en: Functions are another example of encapsulation. We saw encapsulation earlier
    in the context of hardware, and here we see it again, this time in software. Functions
    encapsulate the internal details of a block of code while providing an interface
    for making use of that code. A developer who wants to use a function only needs
    to understand its inputs and outputs; a full understanding of the function’s internal
    workings isn’t needed.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是封装的另一个例子。我们之前在硬件上下文中看到过封装，在这里我们再次看到它，这次是在软件中。函数封装了代码块的内部细节，同时提供了一个接口来使用该代码。希望使用函数的开发者只需要了解其输入和输出；而不需要完全理解函数内部的工作原理。
- en: '***Defining Functions***'
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***定义函数***'
- en: A function must be defined before it can be used. Once defined, you use a function
    by calling it. A *function definition* includes the name of the function, the
    input parameters, the program statements for the function (called the *body* of
    the function), and in some languages, the return value type. Here we have a sample
    C function that calculates the area of a circle, given its radius.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 函数必须在使用之前定义。一旦定义，你可以通过调用它来使用函数。*函数定义*包括函数名称、输入参数、函数的程序语句（称为*函数体*），以及在某些语言中，返回值类型。这里我们有一个示例
    C 函数，用于计算给定半径的圆的面积。
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `double` type at the beginning ❶ indicates that the function returns a floating-point
    number (`double` is one of the floating-point types in C). The function has a
    name, `areaOfCircle` ❷, meant to convey what the function does—in this case, calculate
    the area of a circle. The function takes one input parameter named `radius` ❸,
    also of type `double`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`double` 类型在开头 ❶ 表明该函数返回一个浮动点数（`double` 是 C 语言中的浮动点类型之一）。该函数有一个名称，`areaOfCircle`
    ❷，旨在传达该函数的作用——在本例中，计算圆的面积。该函数接受一个输入参数，名为 `radius` ❸，其类型也是 `double`。'
- en: Between the opening and closing curly braces we have the body of the function,
    which defines exactly how the function works. We declare a local variable named
    `area`. It’s also of type `double`. The area is calculated as `π` × radius² and
    assigned to the `area` variable. Finally, the function returns the value of the
    `area` variable ❹. Note that the `area` variable’s scope is limited; it cannot
    be accessed outside of this function. When the function returns, the local variable
    `area` is discarded (it was probably stored on the stack), but its value is returned
    to the caller, likely via a processor register.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在大括号之间是函数的主体，定义了函数的具体实现。我们声明了一个名为 `area` 的局部变量，它的类型也是 `double`。面积通过 `π` × radius²
    来计算并赋值给 `area` 变量。最后，函数返回 `area` 变量的值 ❹。请注意，`area` 变量的作用域是有限的；它无法在函数外部访问。当函数返回时，局部变量
    `area` 会被丢弃（它可能被存储在栈上），但其值会通过处理器寄存器返回给调用者。
- en: The following is a similar area function, this time written in Python.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个类似的面积函数，这次是用 Python 编写的。
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Let’s compare the two function examples. Both calculate the `area` as `π` ×
    radius² and then return that value. Both take one input parameter named `radius`.
    The C version explicitly defines the return type as `double` and the type of radius
    as `double`, while the Python version doesn’t require the types to be declared.
    Python indicates that a function definition is about to begin with the `def` keyword.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对比这两个函数示例。它们都通过 `π` × radius² 来计算 `area`，然后返回该值。两者都接受一个名为 `radius` 的输入参数。C
    语言版本显式定义了返回类型为 `double`，以及 `radius` 的类型为 `double`，而 Python 版本则不需要声明类型。Python 用
    `def` 关键字来标识函数定义的开始。
- en: '***Calling Functions***'
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***调用函数***'
- en: 'Defining a function in a program isn’t enough to ensure that function will
    run. A function definition simply makes the code available for other code to invoke
    when needed. Such an invocation is known as a *function call*. The calling code
    passes any needed parameters and hands control over to the function. The function
    then executes its code and returns control (and any output) back to the caller.
    The following demonstrates calling our example function in C:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中定义一个函数并不足以确保该函数能够执行。函数定义只是让其他代码可以在需要时调用该函数。这种调用被称为*函数调用*。调用代码传递所需的参数并将控制权交给函数。然后，函数执行其代码并将控制权（及任何输出）返回给调用者。下面演示了如何在
    C 中调用我们的示例函数：
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'and in Python:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 并且在 Python 中：
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Once the function returns, it’s up to the calling code to store the returned
    value somewhere. Variables `area1` and `area2` are declared in both examples to
    hold the return values from the function calls. In both languages, `area1` is
    12.56 and `area2` is 4,678.4744\. Actually, the calling code can just ignore the
    returned value and not assign it to a variable, but that is not very useful, considering
    this function’s purpose. [Figure 9-5](ch09.xhtml#ch9fig5) illustrates how calling
    a function temporarily cedes control to that function.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦函数返回，调用代码需要将返回值存储到某个地方。在两个示例中，都声明了变量`area1`和`area2`来保存函数调用的返回值。在两种语言中，`area1`的值为
    12.56，`area2`的值为 4,678.4744。实际上，调用代码可以忽略返回值，而不将其赋给变量，但考虑到该函数的用途，这样做并不太有用。[图 9-5](ch09.xhtml#ch9fig5)展示了调用函数如何暂时将控制权交给该函数。
- en: '![image](../images/fig9-5.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig9-5.jpg)'
- en: '*Figure 9-5: Calling a function*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-5：调用一个函数*'
- en: In [Figure 9-5](ch09.xhtml#ch9fig5), the Python code on the left calls the `area_of_circle`
    function, passing it an input `radius` parameter value of `2.0`. The code on the
    left then waits until the function on the right completes its work. Once the function
    returns, the code on the left stores the returned value in variable `area1`, and
    it then resumes execution.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 9-5](ch09.xhtml#ch9fig5)中，左侧的 Python 代码调用了`area_of_circle`函数，并将输入参数`radius`的值设置为`2.0`。左侧的代码随后等待右侧函数完成工作。一旦函数返回，左侧的代码将返回值存储在变量`area1`中，然后继续执行。
- en: '***Using Libraries***'
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用库***'
- en: Although programmers do define functions for their own use, an important part
    of programming is knowing how to best leverage functions that other people have
    already written. Programming languages usually include a large set of functions
    known as the *standard library* for that language. In this context, a *library*
    is a collection of code intended to be used by other software. Both C and Python
    include standard libraries that provide functions for things such as printing
    to the console, working with files, and text processing. Python’s standard library
    is particularly extensive and well-regarded. Although not always the case, most
    implementations of a language include that language’s standard library, so programmers
    can rely on those functions.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管程序员会为自己的使用定义函数，但编程中的一个重要部分是知道如何最好地利用其他人已经编写的函数。编程语言通常包括一套称为*标准库*的函数集合。在这个上下文中，*库*是供其他软件使用的代码集合。C
    和 Python 都包括标准库，提供诸如打印到控制台、处理文件和文本处理等功能。Python 的标准库尤其庞大且广受好评。尽管并非总是如此，大多数编程语言的实现都会包含该语言的标准库，因此程序员可以依赖这些函数。
- en: '**NOTE**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Please see [Project #17](ch09.xhtml#proj17) on [page 189](ch09.xhtml#page_189),
    where you can use what you’ve learned to write a simple guessing game in Python.
    This includes using the Python standard library*.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参见[项目 #17](ch09.xhtml#proj17)在[第 189 页](ch09.xhtml#page_189)，您可以在这里运用所学知识编写一个简单的猜数字游戏。这包括使用
    Python 标准库*。'
- en: Outside of the standard library, additional libraries of functions are also
    available for many programming languages. Developers write libraries for others
    to use and share them in the form of source code or as compiled files. These libraries
    are sometimes shared informally, and certain programming languages have a well-known,
    accepted mechanism for publishing libraries. A shared set of libraries is known
    as a *package*, and a system for sharing such packages is known as a *package
    manager*. Several package managers are available for C, but none of them is universally
    accepted as a standard by C programmers. Python’s included package manager is
    called `pip`. `pip` makes it easy to install community-developed software libraries
    for Python, and it’s commonly used by Python developers.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准库之外，还有许多编程语言的附加函数库可供使用。开发人员编写库供他人使用，并以源代码或编译文件的形式共享这些库。这些库有时以非正式方式共享，某些编程语言具有已知且被接受的库发布机制。共享的库集合称为*包*，而用于共享这些包的系统称为*包管理器*。C
    语言有多个包管理器，但没有一个被 C 程序员普遍接受为标准。Python 自带的包管理器叫做`pip`。`pip`使得安装社区开发的 Python 软件库变得非常简单，Python
    开发者常常使用它。
- en: '**Object-Oriented Programming**'
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**面向对象编程**'
- en: 'Programming languages are designed to support specific *paradigms*, or approaches,
    to programming. Examples include procedural programming, functional programming,
    and object-oriented programming. A language may be designed to support one or
    multiple paradigms, and it is up to the software developer to use the language
    in a way that fits a certain paradigm. Let’s take a look at one popular paradigm:
    *object-oriented programming*, an approach to programming in which code and data
    are grouped together in a construct known as an *object*. Objects are meant to
    represent a logical grouping of data and functionality in a way that models real-world
    concepts.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言旨在支持特定的*范式*，或者说是编程的方法。例如，包括过程式编程、函数式编程和面向对象编程等。一个语言可能被设计来支持一种或多种范式，而软件开发者则需根据某种范式使用该语言。让我们来看一个流行的范式：*面向对象编程*，这是一种将代码和数据组合在一起的编程方法，这种组合被称为*对象*。对象旨在以一种模拟现实世界概念的方式，表示数据和功能的逻辑分组。
- en: Object-oriented programming languages commonly use a class-based approach. A
    *class* is a blueprint for an object. An object created from a class is said to
    be an *instance* of that class. Functions defined in a class are known as *methods*,
    and variables declared in a class are known as *fields*. In Python, fields that
    have different values for each instance of a class are called *instance variables*,
    whereas fields that have the same value across all instances of the class are
    called *class variables*.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程语言通常采用基于类的方法。*类*是对象的蓝图。从类创建的对象被称为该类的*实例*。在类中定义的函数称为*方法*，而在类中声明的变量称为*字段*。在Python中，对于每个类实例有不同值的字段称为*实例变量*，而在所有实例中具有相同值的字段则称为*类变量*。
- en: For example, a class could be written that describes a bank account. The bank
    account class might have a field for the balance, a field for the holder’s name,
    and methods for withdrawing and depositing money. The class describes a generic
    bank account, but no specific instance of a bank account exists until a bank account
    object is created from that class. This is illustrated in [Figure 9-6](ch09.xhtml#ch9fig6).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以编写一个描述银行账户的类。这个银行账户类可能有一个表示余额的字段，一个表示持有人姓名的字段，以及用于取款和存款的方法。该类描述的是一个通用的银行账户，但直到从该类创建一个银行账户对象，才会存在特定的银行账户实例。这在[图9-6](ch09.xhtml#ch9fig6)中得到了说明。
- en: '![image](../images/fig9-6.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig9-6.jpg)'
- en: '*Figure 9-6: Bank account objects are created from a bank account class.*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-6：银行账户对象是从银行账户类创建的。*'
- en: 'As you can see in [Figure 9-6](ch09.xhtml#ch9fig6), the `BankAccount` class
    describes the fields and methods of the bank account, providing us with an understanding
    of what a bank account is like. Two objects, instances of the `BankAccount` class,
    have been created. These objects are specific bank accounts, with names and balances
    assigned. We can use each object’s `withdraw` or `deposit` method to modify its
    `balance` field. In Python, depositing into a bank account object named `myAccount`
    would look like this, resulting in an increase of 25 to its `balance` field:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[图9-6](ch09.xhtml#ch9fig6)中看到的，`BankAccount`类描述了银行账户的字段和方法，帮助我们理解银行账户的样子。已经创建了两个`BankAccount`类的实例。这些对象是具体的银行账户，并且已分配了名称和余额。我们可以使用每个对象的`withdraw`或`deposit`方法来修改其`balance`字段。在Python中，向名为`myAccount`的银行账户对象存款的代码如下所示，这将使其`balance`字段增加25：
- en: '[PRE30]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**NOTE**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Please see [Project #18](ch09.xhtml#proj18) on [page 190](ch09.xhtml#page_190),
    where you can try a Python implementation of the bank account class just described*.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参见[项目#18](ch09.xhtml#proj18)，该项目在[第190页](ch09.xhtml#page_190)中，您可以尝试实现刚才描述的银行账户类的Python实现。*'
- en: '**Compiled or Interpreted**'
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编译或解释**'
- en: 'As mentioned earlier, source code is the text of a program as originally written
    by developers, and it usually isn’t written in a programming language that CPUs
    understand directly. CPUs only understand machine language, so additional steps
    are required: source code must be either compiled to machine code or interpreted
    by other code at runtime.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，源代码是开发者最初编写的程序文本，通常不是用CPU直接理解的编程语言编写的。CPU只理解机器语言，因此需要额外的步骤：源代码必须被编译成机器码，或在运行时通过其他代码解释。
- en: In a *compiled language*, like C, source code is converted into machine instructions
    that can be directly executed by a processor. That process was described earlier
    in this chapter in “High-Level Programming Overview” on [page 160](ch09.xhtml#page_160).
    Source code is compiled during the development process, and the compiled executable
    files (sometimes called *binaries*) are delivered to end users. When end users
    run binaries, they don’t need access to the source code. Compiled code tends to
    be fast, but it only runs on the architecture for which it was compiled. [Figure
    9-7](ch09.xhtml#ch9fig7) shows an example of how a developer would compile and
    run a C program from a command line using the GNU C Compiler (`gcc`).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在*编译型语言*中，例如 C，源代码会被转换为机器指令，可以直接由处理器执行。这个过程在本章的“高级编程概述”一节中已经描述过，见[第 160 页](ch09.xhtml#page_160)。源代码在开发过程中被编译，编译后的可执行文件（有时称为*二进制文件*）会被交付给最终用户。当最终用户运行二进制文件时，他们不需要访问源代码。编译后的代码通常运行得更快，但只在为其编译的架构上运行。[图
    9-7](ch09.xhtml#ch9fig7)展示了开发者如何使用 GNU C 编译器（`gcc`）从命令行编译并运行 C 程序的示例。
- en: '![image](../images/fig9-7.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig9-7.jpg)'
- en: '*Figure 9-7: Compiling a C source file to an executable file that can run on
    its own*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-7：将 C 源文件编译为可以独立运行的可执行文件*'
- en: In an *interpreted language*, like Python, the source code is not compiled ahead
    of time. Instead, it is read by a program called an *interpreter* that reads and
    executes the program’s instructions. It’s the interpreter’s machine code that
    actually runs on the CPU. Developers of code in interpreted languages can distribute
    their source code and end users can run it directly, without the need for a potentially
    complex compilation step. In this scenario, the developers don’t need to worry
    about compiling their code for lots of different platforms—as long as the user
    has the appropriate interpreter on their system, they can run the code. In this
    way, the distributed code is platform-independent.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在*解释型语言*中，例如 Python，源代码不会提前编译。相反，它会被一个叫做*解释器*的程序读取，并执行程序的指令。实际上运行在 CPU 上的是解释器的机器代码。使用解释型语言的开发者可以分发源代码，最终用户可以直接运行，而无需复杂的编译步骤。在这种情况下，开发者不需要担心为多个平台编译代码——只要用户的系统中安装了适当的解释器，就可以运行代码。这样分发的代码是平台无关的。
- en: Interpreted code tends to run more slowly than compiled code due to the overhead
    of interpreting the code as it runs. Distributing interpreted code works best
    when the user already has the required interpreter installed or the user is technically
    proficient enough that installing an interpreter isn’t a barrier. Otherwise, the
    developer needs to either bundle the interpreter with their software or guide
    the user through installing the interpreter. [Figure 9-8](ch09.xhtml#ch9fig8)
    shows an example of running a Python program from a command line, assuming the
    Python version 3 interpreter is already installed. Note how the Python source
    code in *hello.py* is given directly to the interpreter—no intermediate step required.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 解释型代码通常比编译型代码运行得慢，因为在运行时需要进行解释。分发解释型代码时，最好是在用户已经安装了所需的解释器，或者用户技术足够熟练，安装解释器不是问题。否则，开发者需要将解释器与软件打包，或者指导用户安装解释器。[图
    9-8](ch09.xhtml#ch9fig8)展示了从命令行运行 Python 程序的示例，假设已经安装了 Python 3 版本的解释器。请注意，Python
    源代码文件 *hello.py* 直接提供给了解释器——无需中间步骤。
- en: '![image](../images/fig9-8.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig9-8.jpg)'
- en: '*Figure 9-8: The Python interpreter runs Python source code.*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-8：Python 解释器运行 Python 源代码。*'
- en: Some languages use a system that’s a hybrid of these two approaches. Such languages
    compile to an *intermediate language*, or *bytecode*. Bytecode is similar to machine
    code, but rather than targeting a specific hardware architecture, bytecode is
    designed to run on a virtual machine, as illustrated in [Figure 9-9](ch09.xhtml#ch9fig9).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 有些语言使用的是这两种方法的混合体。这些语言会编译成*中间语言*或*字节码*。字节码类似于机器代码，但它不是针对特定硬件架构，而是设计成在虚拟机上运行，如[图
    9-9](ch09.xhtml#ch9fig9)所示。
- en: '![image](../images/fig9-9.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig9-9.jpg)'
- en: '*Figure 9-9: A bytecode compiler turns source code into bytecode that runs
    inside a virtual machine.*'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-9：字节码编译器将源代码转化为在虚拟机中运行的字节码。*'
- en: In this context, a *virtual machine* is a software platform designed to run
    other software. The virtual machine provides a virtual CPU and execution environment,
    abstracting the details of the real underlying hardware and operating system.
    For example, Java source code is compiled to Java bytecode, which then runs within
    the Java virtual machine. Similarly, C# source code is compiled to Common Intermediate
    Language and runs in the .NET Common Language Runtime (CLR) virtual machine. CPython,
    the original implementation of Python, actually converts Python source code to
    bytecode before running it, although this is an implementation detail of the CPython
    interpreter and mostly hidden from Python developers. Programming languages that
    use bytecode retain the platform-independence of interpreted languages while preserving
    some of the performance gains of compiled code.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在此上下文中，*虚拟机*是一种旨在运行其他软件的软件平台。虚拟机提供虚拟的 CPU 和执行环境，抽象出真实底层硬件和操作系统的细节。例如，Java 源代码被编译成
    Java 字节码，然后在 Java 虚拟机中运行。类似地，C# 源代码被编译成通用中间语言（CIL），并在 .NET 公共语言运行时（CLR）虚拟机中运行。CPython，Python
    的原始实现，实际上在运行前将 Python 源代码转换为字节码，尽管这是 CPython 解释器的实现细节，对 Python 开发者来说大多是隐藏的。使用字节码的编程语言在保持解释型语言的跨平台独立性的同时，也保留了一些编译代码的性能提升。
- en: '**Calculating a Factorial in C**'
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**在 C 中计算阶乘**'
- en: 'To wrap up our look at high-level programming, let’s now examine an implementation
    of the factorial algorithm, this time in the C language. We did this before in
    ARM assembly, so seeing the same logic in C should serve as a good comparison
    between assembly language and a high-level language. This C code uses several
    of the concepts we just covered. I chose to use C rather than Python because it’s
    a compiled language, and we can examine the compiled machine code. Here’s a simple
    C function that calculates the factorial of a number:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结我们对高级编程的了解，让我们来看看阶乘算法的实现，这次使用 C 语言。我们之前在 ARM 汇编中做过类似的事情，所以看到 C 中的相同逻辑可以很好地对比汇编语言和高级语言之间的差异。这个
    C 代码使用了我们刚刚介绍的一些概念。我选择使用 C 而不是 Python，因为 C 是编译语言，我们可以检查编译后的机器代码。以下是一个简单的 C 函数，用于计算一个数的阶乘：
- en: '[PRE31]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Other code can call this function, passing the `n` parameter as the value whose
    factorial should be calculated. The function then internally calculates the factorial
    value, storing it in the local variable `result` and returning the calculated
    value to the caller. As we did with the assembly code in [Chapter 8](ch08.xhtml),
    let’s again use an exercise to explore this code in depth.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 其他代码可以调用这个函数，传递`n`参数作为需要计算阶乘的值。然后函数会在内部计算阶乘值，将其存储在局部变量`result`中，并将计算结果返回给调用者。就像我们在[第8章](ch08.xhtml)中使用汇编代码一样，接下来我们通过练习深入探索这段代码。
- en: '**EXERCISE 9-2: RUN A C PROGRAM IN YOUR MIND**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 9-2：在脑海中运行 C 程序**'
- en: Try running the preceding factorial function in your head or use pencil and
    paper. Assume an input value of `n` = 4\. When the function returns, the returned
    result should be the expected value of 24\. I recommend that for each line, you
    keep track of the values of `n` and `result` before and after the statement completes.
    Work through the code until you reach the end of the `while` loop and see if you
    get the expected result. The answer is in [Appendix A](appa.xhtml).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在脑海中运行前面的阶乘函数，或者使用铅笔和纸。假设输入值为`n` = 4。当函数返回时，返回的结果应该是预期的值 24。我建议你在每一行之前和之后，跟踪`n`和`result`的值。按步骤执行代码，直到你到达`while`循环的末尾，看看是否得到预期的结果。答案在[附录
    A](appa.xhtml)中。
- en: Note that the condition of the `while` loop (`--n` > 0) places the decrement
    operator (`--`) before the variable `n`. This means that `n` is decremented *before*
    its value is compared to 0\. This happens each time the `while` loop condition
    is evaluated.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`while` 循环的条件（`--n` > 0）将递减操作符（`--`）放在变量 `n` 之前。这意味着 `n` 会在与 0 比较之前被递减。每次评估
    `while` 循环条件时，都会发生这种情况。
- en: 'I hope that you find the C version of our algorithm more readable than the
    ARM assembly version! The other major advantage of this version of our factorial
    code is that it isn’t tied to a specific processor type. It could be compiled
    for any processor, given an appropriate compiler. If you compile the earlier C
    code for an ARM processor, you see machine code generated that’s similar to the
    ARM assembly we examined earlier. You’ll get a chance to do that in [Project #19](ch09.xhtml#proj19),
    but for now I’ve compiled and disassembled the code for you:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '我希望你能觉得我们算法的 C 版本比 ARM 汇编版本更易读！这个版本的阶乘代码的另一个主要优点是它不依赖于特定的处理器类型。只要有合适的编译器，它就可以为任何处理器编译。如果你将之前的
    C 代码编译到 ARM 处理器上，你会看到生成的机器代码与我们之前分析的 ARM 汇编非常相似。你将在[项目 #19](ch09.xhtml#proj19)中有机会亲自尝试，但现在我已经为你编译并反汇编了代码：'
- en: '[PRE32]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, the code generated from the C source is quite similar to the
    assembly factorial example we covered in [Chapter 8](ch08.xhtml). There are some
    differences, but the specifics aren’t relevant to our discussion. The thing to
    note here is that a program can be written in a high-level language like C, and
    a compiler can do the hard work of translating the high-level statements to machine
    code. You can see how working in a high-level language can simplify things for
    a developer, but in the end, we still end up with bytes of machine code, because
    that’s what a processor needs.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，从 C 源代码生成的代码与我们在[第 8 章](ch08.xhtml)中讨论的汇编阶乘示例非常相似。虽然有一些差异，但这些细节与我们的讨论无关。这里需要注意的是，一个程序可以用像
    C 这样的高级语言编写，编译器可以做繁重的工作，把高级语句翻译成机器代码。你可以看到，使用高级语言进行开发可以简化开发者的工作，但最终我们仍然得到的是机器代码的字节，因为处理器需要的是这些。
- en: '**NOTE**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Please see [Project #19](ch09.xhtml#proj19) on [page 191](ch09.xhtml#page_191),
    where you can try compiling and then disassembling a factorial program in C*.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参阅[项目 #19](ch09.xhtml#proj19)中的内容，位于[第 191 页](ch09.xhtml#page_191)，你可以尝试编译然后反汇编一个
    C 语言的阶乘程序*。'
- en: Something interesting happened here, and I want to make sure you didn’t miss
    it. We started with source code written in the C programming language, compiled
    it into machine code, and then disassembled it into assembly language. The implication
    of this is that if you have a compiled program or software library on your computer,
    you can examine its code as assembly language! You may not have access to the
    original source code, but the assembly version of the program is within your grasp.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了一些有趣的事情，我希望你没有错过。我们从用 C 编写的源代码开始，编译成机器代码，然后反汇编成汇编语言。这意味着，如果你电脑上有一个编译后的程序或软件库，你可以把它当作汇编语言来查看！你可能无法访问原始源代码，但程序的汇编版本就在你手边。
- en: 'We’ve been looking at machine code and assembly language for the ARM processor
    specifically, but as mentioned earlier, one of the advantages of developing in
    a high-level language like C is that the same code can be compiled for a different
    processor. In fact, the same code can even be compiled for another operating system,
    as long as the code in question doesn’t use functionality that’s specific to a
    particular operating system. To illustrate this point, I’ve compiled the same
    factorial C code for a 32-bit x86 processor, this time on Windows rather than
    Linux. Here’s the generated machine code, shown as assembly language:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在研究专门为 ARM 处理器编写的机器代码和汇编语言，但正如前面所提到的，使用像 C 这样的高级语言进行开发的一个优点是，同样的代码可以为不同的处理器编译。事实上，只要代码没有使用特定操作系统的功能，同样的代码甚至可以为另一个操作系统编译。为了说明这一点，我已经将相同的阶乘
    C 代码为 32 位 x86 处理器编译，这次是在 Windows 而不是 Linux 上。以下是生成的机器代码，以汇编语言显示：
- en: '[PRE33]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: I won’t elaborate on the details of this code, but feel free to research the
    x86 instruction set and interpret the code yourself. The main thing I hope you
    take away from this example is that high-level languages, like C, allow developers
    to write code that’s easier to understand than assembly and that can be easily
    compiled for various processors.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会详细说明这段代码的细节，但你可以随意研究 x86 指令集并自行解读代码。我希望你从这个例子中获得的主要收获是，高级语言，如 C，允许开发者编写比汇编更易于理解的代码，而且可以轻松地为各种处理器编译。
- en: '**Summary**'
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: 'In this chapter we covered high-level programming languages. Such languages
    are independent from a specific CPU and syntactically closer to human language.
    You learned about common elements found across programming languages, such as
    comments, variables, functions, and looping capabilities. You saw how these elements
    are expressed in two programming languages: C and Python. Finally, we examined
    an example program in C, and you saw the disassembled machine code generated by
    compiling high-level code.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了高级编程语言。这些语言独立于特定的 CPU，语法上更接近人类语言。你了解了编程语言中常见的元素，如注释、变量、函数和循环功能。你看到这些元素在两种编程语言中的表现：C
    和 Python。最后，我们检查了一个 C 语言的示例程序，并看到了通过编译高级代码生成的反汇编机器码。
- en: In the next chapter, we’ll cover operating systems. We’ll start with an overview
    of the capabilities provided by operating systems, learn about the various families
    of operating systems, and dive deeper into how operating systems work. Along the
    way you’ll have the opportunity to explore Raspberry Pi OS, a version of Linux
    tailored for the Raspberry Pi.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将介绍操作系统。我们将首先概述操作系统提供的功能，了解不同种类的操作系统家庭，并深入探讨操作系统的工作原理。过程中，你将有机会探索 Raspberry
    Pi OS，它是为 Raspberry Pi 定制的 Linux 版本。
- en: '**PROJECT #14: EXAMINE VARIABLES**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目 #14：检查变量**'
- en: 'Prerequisite: A Raspberry Pi, running Raspberry Pi OS. I recommend that you
    flip to [Appendix B](appb.xhtml) and read the entire “Raspberry Pi” section on
    [page 341](appb.xhtml#page_341) if you haven’t already.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 前提条件：一台运行 Raspberry Pi OS 的 Raspberry Pi。如果你还没看过，建议你翻到[附录 B](appb.xhtml)，阅读[第
    341 页](appb.xhtml#page_341)中关于“Raspberry Pi”的全部内容。
- en: In this project, you’ll write high-level code that uses variables and examine
    how this works in memory. Use the text editor of your choice to create a new file
    called *vars.c* in the root of your home folder. Enter the following C code into
    your text editor (you don’t have to preserve indentation and empty lines, but
    be sure to maintain line breaks).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将编写使用变量的高级代码，并检查它在内存中的工作原理。使用你喜欢的文本编辑器，在主文件夹的根目录下创建一个名为 *vars.c* 的新文件。将以下
    C 代码输入到文本编辑器中（你不必保留缩进和空行，但要确保保持换行）。
- en: '[PRE34]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Before continuing, let’s examine the source code. It begins by including a couple
    of header files ❶. These files include details required by the C compiler about
    the `printf` and `raise` functions that are used later in the program. Next you
    see the `main` function defined ❷; this is the entry point of the program where
    execution begins. The program then declares two integer variables, `points` ❸
    and `year` ❹, and assigns values to them. It then prints out both the values of
    the variables and their memory addresses (in hexadecimal) ❺. The `raise(SIGINT)`
    statement causes the program to halt execution ❻. This is not something you normally
    do in code that end users run; it’s a technique we use here to assist with debugging.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们检查一下源代码。它首先包含了几个头文件 ❶。这些文件包含了 C 编译器所需的有关 `printf` 和 `raise` 函数的细节，这些函数将在程序中稍后使用。接下来你会看到定义了
    `main` 函数 ❷；这是程序的入口点，执行从这里开始。程序随后声明了两个整型变量，`points` ❸ 和 `year` ❹，并为它们赋值。然后它打印出变量的值及其内存地址（以十六进制表示）
    ❺。`raise(SIGINT)` 语句会导致程序停止执行 ❻。这不是你在用户运行的代码中通常会做的事情；这是一种我们用来帮助调试的技术。
- en: Once the file is saved, use the GNU C Compiler (`gcc`) to compile your code
    into an executable file. Open a terminal on your Raspberry Pi and enter the following
    command to invoke the compiler. This command takes *vars.c* as an input, compiles
    and links the code, and outputs an executable file named *vars*.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 文件保存后，使用 GNU C 编译器（`gcc`）将你的代码编译成可执行文件。在 Raspberry Pi 上打开终端并输入以下命令以调用编译器。该命令以
    *vars.c* 作为输入，编译并链接代码，并输出名为 *vars* 的可执行文件。
- en: '[PRE35]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now try running the compiled code using the following command. The program should
    print out the values and addresses of the program’s two variables.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用以下命令运行编译后的代码。程序应该会打印出程序中两个变量的值和地址。
- en: '[PRE36]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Once you’ve confirmed that the program works, run it under the GNU Debugger
    (`gdb`) and examine the variables in memory.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在确认程序工作正常后，通过 GNU 调试器（`gdb`）运行它，并检查内存中的变量。
- en: '[PRE37]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: At this point `gdb` has loaded the file but no instructions have run yet. From
    the `(gdb)` prompt, type the following to run the program, which will continue
    until the `raise(SIGINT)` statement is executed.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 此时 `gdb` 已经加载了文件，但还没有执行任何指令。在 `(gdb)` 提示符下，输入以下命令来运行程序，直到执行 `raise(SIGINT)`
    语句为止。
- en: '[PRE38]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Once the program returns to a `(gdb)` prompt, you should see a couple of lines
    where the values and memory addresses of the variables were printed. Following
    those lines, you may also see a potentially worrisome statement about “no such
    file or directory”—you can ignore it. It’s just the debugger trying to find some
    source code that isn’t on your system. The output you do need to pay attention
    to should look something like this:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now you know the memory addresses, and since you’re conveniently in the debugger,
    you’re ready to examine what’s stored at those addresses. In this output, you
    can see that `year` is stored at the lower address, and `points` is stored 4 bytes
    later, so you’ll dump out memory starting at the address of the `year` variable,
    `0x7efff1d0` in my case. Your address may be different. The following command
    dumps out three 32-bit values in memory, in hexadecimal, starting at address `0x7efff1d0`.
    Replace `0x7efff1d0` with the address of `year` on your system if they differ.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You can see here that the value stored at `0x7efff1d0` is `0x000007e4`. That’s
    2020 in decimal, the expected `year` value. And the value stored 4 bytes later
    is `0x0000001b`, or 27 decimal, the expected `points` value. The next value in
    memory happens to be 0 and isn’t one of our variables. Memory is usually examined
    in hexadecimal, but if you want to see these values in decimal, you can use the
    following command instead:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You’re looking at memory in 32-bit (4-byte) chunks, since that’s the size of
    the variables used in this program. But memory is actually byte addressable, meaning
    each byte has its own address. That’s why `points` has an address 4 bytes greater
    than the address of `year`. Let’s look at the same memory range as a series of
    bytes instead:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Look at the value for `year`, emphasized here. Note how the least significant
    byte (`0xe4`) comes first. This is due to little-endian data storage, as discussed
    on [page 156](ch08.xhtml#page_156) in [Project #13](ch08.xhtml#proj13). You can
    exit `gdb` with `q` (it will ask you if you want to quit even though a debugging
    session is active; answer `y`).  **PROJECT #15: CHANGE THE TYPE OF VALUE REFERENCED
    BY A VARIABLE IN PYTHON**'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'Prerequisite: A Raspberry Pi, running Raspberry Pi OS. I recommend that you
    flip to [Appendix B](appb.xhtml) and read the entire “Raspberry Pi” section on
    [page 341](appb.xhtml#page_341) if you haven’t already.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'In this project, you''ll write code that sets a Python variable to a value
    of a certain type and then updates that variable to reference a value of a different
    type. Use the text editor of your choice to create a new file called *vartype.py*
    in the root of your home folder. Enter the following Python code into your text
    editor:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This code sets the variable named `age` to an integer value and then prints
    the type of that value. It then sets `age` to a string value and prints the type
    again.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the file is saved, you can run the file from a terminal window using the
    Python interpreter, like so:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 文件保存后，你可以通过 Python 解释器在终端窗口中运行该文件，方法如下：
- en: '[PRE44]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You should see output like the following:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到如下输出：
- en: '[PRE45]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You can see how the type changes from an integer to a string by simply assigning
    the variable a new value. Don't let the term `class` confuse you; in Python 3,
    built-in types such as `int` and `str` are considered classes (covered in “Object-Oriented
    Programming” on [page 177](ch09.xhtml#page_177)). Setting a variable to a value
    of a different type is easy in Python but not allowed at all in C.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过简单地为变量赋予一个新值，看到类型从整数变为字符串。不要让“`class`”这个术语让你困惑；在 Python 3 中，内置类型如 `int`
    和 `str` 被视为类（在 [第177页](ch09.xhtml#page_177) 的“面向对象编程”中讲解）。在 Python 中，将变量设置为不同类型的值是很容易的，但在
    C 中根本不允许。
- en: '***VERSIONS OF PYTHON***'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '***PYTHON 版本***'
- en: 'Two major versions of Python are in use today, Python 2 and Python 3\. As of
    January 1, 2020, Python 2 is no longer supported, meaning no new bug fixes will
    be made to it. Python developers are encouraged to migrate old projects to Python
    3, and new projects should target Python 3\. Accordingly, the projects in this
    book use Python 3\. On Raspberry Pi OS and some other Linux distributions, running
    python from a command line will invoke the Python 2 interpreter, while running
    python3 will invoke the Python 3 interpreter. That’s why the projects in this
    book have you specifically run python3 rather than python. That said, on other
    platforms, or even on future versions of Raspberry Pi OS, this may not hold true,
    and entering python may actually invoke Python 3\. You can check the invoked version
    of Python like so:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当前有两个主要版本的 Python，Python 2 和 Python 3。自2020年1月1日起，Python 2 不再获得支持，这意味着不会再对其进行任何新的
    bug 修复。Python 开发者被鼓励将旧项目迁移到 Python 3，并且新项目应当面向 Python 3。因此，本书中的项目使用的是 Python 3。在
    Raspberry Pi OS 和一些其他 Linux 发行版中，直接从命令行运行 python 会调用 Python 2 解释器，而运行 python3
    会调用 Python 3 解释器。这就是为什么本书中的项目要求你特别运行 python3 而不是 python。也就是说，在其他平台上，或者在未来版本的 Raspberry
    Pi OS 上，可能会有所不同，输入 python 可能会调用 Python 3。你可以通过以下方式检查调用的 Python 版本：
- en: '[PRE46]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: or
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 或
- en: '[PRE47]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '**PROJECT #16: STACK OR HEAP**'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目 #16：堆栈还是堆**'
- en: 'Prerequisite: [Project #14](ch09.xhtml#proj14).'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '先决条件：[项目 #14](ch09.xhtml#proj14)。'
- en: 'In this project, you''ll look at whether variables are allocated in stack or
    heap memory in a running program. Open a terminal on your Raspberry Pi, and begin
    by debugging the `vars` program you previously compiled in [Project #14](ch09.xhtml#proj14):'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '在本项目中，你将查看在运行中的程序中，变量是分配在堆栈内存还是堆内存中。打开 Raspberry Pi 上的终端，开始调试你之前在 [项目 #14](ch09.xhtml#proj14)
    中编译的 `vars` 程序：'
- en: '[PRE48]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: At this point `gdb` has loaded the file but no instructions have run yet. From
    the `gdb` prompt, type the following to run the program, which continues until
    the `SIGINT` statement is executed.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 此时 `gdb` 已加载文件，但尚未执行任何指令。从 `gdb` 提示符下，输入以下内容运行程序，该程序将继续直到执行 `SIGINT` 语句。
- en: '[PRE49]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Again, look at the memory addresses of the `points` and `year` variables. In
    my case, these variables were found at `0x7efff1d4` and `0x7efff1d0`, but your
    addresses may vary. Now use the following command to see all the mapped memory
    locations for your running program:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看 `points` 和 `year` 变量的内存地址。在我的情况下，这些变量的地址分别是 `0x7efff1d4` 和 `0x7efff1d0`，但你的地址可能不同。现在，使用以下命令查看你运行程序的所有映射内存位置：
- en: '[PRE50]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The output lists the start and end address of the various memory ranges in
    use by this program. Find the one that includes the addresses of your variables.
    Both variable addresses should fall within a single range. For me, this entry
    matched:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 输出列出了该程序使用的各种内存范围的起始和结束地址。找到包含你变量地址的那个范围。两个变量的地址应该都落在同一个范围内。对我来说，这个条目匹配：
- en: '[PRE51]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As you can see, `gdb` indicates that this memory range is allocated for the
    stack, which is exactly where we would expect local variables to be. You can exit
    `gdb` with `q` (it will ask you if you want to quit even though a debugging session
    is active; answer `y`).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`gdb` 指出该内存范围被分配给堆栈，这正是我们期望局部变量所在的地方。你可以通过输入 `q` 退出 `gdb`（即使调试会话处于活动状态，它会询问你是否要退出；回答
    `y`）。
- en: 'Let’s now look at memory allocated on the heap. You need to modify *vars.c*
    and rebuild it so that the program allocates some heap memory. Use the text editor
    of your choice to open the existing *vars.c* file. Add the following line of code
    as the very first line:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看堆上分配的内存。你需要修改 *vars.c* 文件并重新编译，使程序分配一些堆内存。使用你喜欢的文本编辑器打开现有的 *vars.c* 文件。将以下代码行作为第一行添加：
- en: '[PRE52]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then add these two lines immediately before the `SIGINT` line:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let’s cover what these changes mean. We call the memory allocation function
    `malloc` to allocate 512 bytes of memory from the heap. The `malloc` function
    returns the address of the newly allocated memory. That address is stored in a
    new local variable called `data`. The program then prints two memory addresses:
    the address of the new heap allocation and the address of the data variable itself,
    which should be on the stack.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the file is saved, use `gcc` to compile your code:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now run the program again:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Check the newly printed values. For me, the values are as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We expect that the first address, the address that came back from `malloc`,
    to be on the heap. The second value, the address of the `data` local variable,
    should be on the stack. Again, run the following to see this program’s memory
    ranges and see where these two addresses fall.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Find the matching address ranges on your system and confirm that the addresses
    fall in the expected ranges of heap and stack. You can exit `gdb` with `q`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '**PROJECT #17: WRITE A GUESSING GAME**'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you'll write a guessing game in Python, building on what we’ve
    covered in this chapter. Use the text editor of your choice to create a new file
    named *guess.py* in the root of your home folder. Enter the following Python code
    into your text editor. In Python, indentation matters, so make sure you indent
    appropriately.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Let’s examine how this program works. This code starts by importing a function
    called `randint` that generates random integers ❶. This is an example of using
    a function that was written by someone else; `randint` is a part of the Python
    standard library. This call to the `randint` function returns a random integer
    in the range of `1` to `10`, which we’ve stored in a variable named `secret` ❷.
    The code then sets a variable called `guess` to `0` ❸. This variable holds the
    player’s guess, and it’s assigned an initial value of `0`, a value we can be sure
    won’t match the secret value. A third variable named `count` ❹ keeps track of
    the number of times that the player guessed so far.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: The `while` loop runs as long as the player’s `guess` doesn’t match the `secret`
    ❺. The code within the loop calls the built-in function `input` to get the user’s
    guess from the console ❻, and the result is converted to an integer and stored
    in the `guess` variable. Each time a guess is entered, it’s checked against the
    `secret` variable to see whether it’s a match, too low, or too high ❼. Once the
    player’s `guess` matches the `secret`, the loop exits, and the program prints
    the number of times that the player guessed ❽.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the file is saved, you can run it using the Python interpreter like so:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Try out the program several times; the secret number should change each time
    you run it. You may want to try modifying the program so that the range of allowed
    integers is larger, or maybe you want to put in your own custom messages. As a
    challenge, try modifying the program so that when the guess is really close, the
    program prints a different message.  **PROJECT #18: USE A BANK ACCOUNT CLASS IN
    PYTHON**'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '多次运行这个程序；每次运行时，秘密数字应该会改变。你可能想尝试修改程序，使得允许的整数范围更大，或者你可能想放入你自己的自定义消息。作为挑战，尝试修改程序，当猜测非常接近时，程序打印不同的消息。**项目
    #18：在 Python 中使用银行账户类**'
- en: In this project, you’ll write a bank account class in Python and then create
    an object based on that class. Use the text editor of your choice to create a
    new file named *bank.py* in the root of your home folder. Enter the following
    Python code into your text editor. You can skip typing in the comments (lines
    that begin with `#`) if you prefer. Note that `__init__` has two underscore characters
    at its beginning and end.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将用 Python 编写一个银行账户类，并基于该类创建一个对象。使用你选择的文本编辑器，在你主文件夹的根目录下创建一个名为*bank.py*的新文件。将以下
    Python 代码输入到文本编辑器中。如果你愿意，可以跳过输入注释（以`#`开头的行）。请注意，`__init__`前后有两个下划线字符。
- en: '[PRE60]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This code defines a new class called `BankAccount` ❶. Its `__init__` function
    ❷ is automatically invoked when an instance of the class is created. This function
    sets instance variables `balance` ❸ and `name` ❹ to the values passed into the
    initializer function. The variables are unique to each object instance of the
    class that’s created. The class definition also includes two methods: `withdraw`
    ❺ and `deposit` ❻, which simply modify the balance. After the class is defined,
    the code proceeds to create an instance of the class ❼. This bank account object
    can now be used by accessing its variables and methods. Here a deposit is made
    ❽, followed by a retrieval of the new balance, which is printed ❾.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码定义了一个新的类，名为`BankAccount` ❶。它的`__init__`函数 ❷会在创建类的实例时自动调用。这个函数将实例变量`balance`
    ❸和`name` ❹设置为传入初始化函数的值。变量对于创建的每个类的对象实例都是唯一的。类定义还包括两个方法：`withdraw` ❺和`deposit`
    ❻，它们简单地修改余额。类定义之后，代码继续创建类的一个实例 ❼。现在可以通过访问其变量和方法来使用这个银行账户对象。在这里，进行了一次存款操作 ❽，然后获取新余额并打印
    ❾。
- en: 'Once the file is saved, you can run it using the Python interpreter like so:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 文件保存后，你可以像下面这样使用 Python 解释器运行它：
- en: '[PRE61]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You should see the account balance of 15.25 print to the terminal window. In
    truth, this was an overly complicated way of calculating this bank balance! The
    numbers are all hard coded in the program, and we really didn’t need to use an
    object-oriented approach to solve this problem. However, I hope this example helps
    you understand how classes and objects work.  **PROJECT #19: FACTORIAL IN C**'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '你应该看到账户余额15.25打印到终端窗口。事实上，这种计算银行余额的方法过于复杂！所有的数字在程序中都是硬编码的，我们实际上并不需要使用面向对象的方法来解决这个问题。然而，我希望这个例子能帮助你理解类和对象是如何工作的。**项目
    #19：C语言中的阶乘**'
- en: 'Prerequisite: Projects #12 and #13'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '先决条件：项目 #12 和 #13'
- en: 'In this project, you’ll build a factorial program in the C programming language,
    like the one we covered earlier in this chapter. You’ll then examine the machine
    code that was generated when the code was compiled. Use the text editor of your
    choice to create a new file named *fac2.c* in the root of your home folder. Enter
    the following C code:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将使用 C 语言编写一个阶乘程序，和本章之前我们介绍的程序类似。然后，你将查看代码编译后生成的机器代码。使用你选择的文本编辑器，在你主文件夹的根目录下创建一个名为*fac2.c*的新文件。将以下
    C 代码输入：
- en: '[PRE62]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: You can see that the `factorial` function ❶ is exactly the same as the C example
    given earlier in the chapter; this is the core code for calculating the factorial.
    However, to make this a usable program, we also have a `main` function ❷ that
    serves as the entry point—this is where the program begins execution. From `main`,
    the program calls the `factorial` function with a value of 4, storing the result
    in a local variable named `answer` ❸. The program then prints the value of `answer`
    to the terminal ❹.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，`factorial`函数 ❶与本章之前给出的 C 示例完全相同；这是计算阶乘的核心代码。然而，为了使这个程序可用，我们还定义了一个`main`函数
    ❷，作为程序的入口点——程序从这里开始执行。从`main`，程序调用`factorial`函数，传入4的值，将结果存储在名为`answer`的局部变量中 ❸。然后，程序打印`answer`的值到终端
    ❹。
- en: 'Once the file is saved, use `gcc` to compile your code into an executable file.
    The following command takes *fac2.c* as an input and outputs an executable file
    named *fac2*. No separate linking step is required. Also note the `-O` (that is
    a capital letter O) command line option: this means enable compiler optimizations.
    I added this option here because in this case it produces code that’s more similar
    to the assembly code from [Project #12](ch08.xhtml#proj12).'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Now try running the code using the following command. If everything works as
    expected, the program should print the calculated result of 24 on the next line.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now that you have a `fac2` executable file, use the same techniques you used
    in Projects #12 and #13 to inspect the compiled file. I won’t walk you through
    all the details again, but the same approaches you used before will work here
    as well. Here are a few commands to get you started:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: You should see right away that there’s a lot of stuff in the `fac2` file! The
    compiled ELF binary carries some overhead required for a program written in C.
    On my computer, the original `fac` ELF file was 940 bytes, whereas the `fac2`
    ELF file is 8,364 bytes, a 9X increase! Of course, the C version does include
    additional functionality to print out the value, so some size increase is expected.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: When looking at disassembled code, it’s the `factorial` function you want to
    initially examine. Compare it to the factorial code that you wrote in assembly
    language back in [Chapter 8](ch08.xhtml). You may notice `gdb` shows a different
    entry point than `main`. This is because C programs have some initialization code
    that’s called before your `main` entry point is called. If you want to skip this
    code and go right to the `factorial` function, you can set a breakpoint (break
    factorial) then run, and then disassemble.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'The machine instructions generated on your machine may differ somewhat, but
    here’s the `factorial` function machine code and corresponding assembly language
    generated on my computer. This is output from objdump -d fac2:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Before this function is called, the value of `n` has been stored in `r0`. When
    the function begins, right away it decrements `n` and stores the result in `r3`
    ❶. The program then compares `r3` (that is, `n`) to zero ❷. If `n` is less than
    or equal to zero ❸, then the program returns from the function. Otherwise, `result`,
    stored in `r0`, is calculated as `result` × `n` ❹. Next `n` is decremented ❺,
    and if `n` is not zero ❻, the program goes through the loop again, branching back
    to address `10414` ❹. Once `n` reaches zero, the loop ends and the function returns
    ❼.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
