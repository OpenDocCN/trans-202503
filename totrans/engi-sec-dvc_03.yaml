- en: '**2'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**2**'
- en: CRYPTOGRAPHY**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**密码学**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common.jpg)'
- en: The guarantees and powers of cryptographic algorithms often sound like magic.
    A layperson isn’t able to verify any of these properties and neither are most
    engineers. In some cases, even cryptographers can’t prove the security of a scheme,
    but they assume or believe that the underlying mathematical problem is hard to
    solve. Nevertheless, cryptographic algorithms are necessary tools that every developer
    and architect should know how to use.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 密码算法的保障和能力常常听起来像是魔法。普通人无法验证这些特性，大多数工程师也做不到。在某些情况下，即使是密码学家也无法证明一个方案的安全性，但他们假设或相信其背后的数学问题很难解决。尽管如此，密码学算法仍是每个开发者和架构师应当了解并掌握的必要工具。
- en: The word *cryptography* comes from the combination of the Greek words *kryptós*
    and *gráphein*, which translate to *secret writing*. Nowadays, however, cryptography
    is much more than the protection of confidential messages. It’s also used to protect
    the integrity of files, to derive reliable fingerprints of gigabytes of data,
    and to sign documents and code digitally.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*密码学*一词来源于希腊语单词*kryptós*和*gráphein*的组合，意思是*秘密写作*。然而，今天的密码学远不止是保护机密消息，它还用于保护文件的完整性，推导出可靠的指纹信息，用于对数GB的数据进行验证，以及对文件和代码进行数字签名。'
- en: This chapter provides a pragmatic overview of modern cryptographic algorithms
    and their practical properties while keeping mathematical formulas at a minimum.
    We’ll start with some basic principles, then take a peek at typical symmetric
    algorithms and hash functions. A look at the intriguing field of asymmetric crypto
    concludes the chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了现代密码学算法及其实际特性的务实概述，同时尽量减少数学公式的使用。我们将从一些基本原理开始，然后简要了解典型的对称算法和哈希函数。最后，本章以探索对称密码学领域的引人入胜内容作为结尾。
- en: '**Kerckhoffs’s Principle**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**凯克霍夫斯原理**'
- en: 'Auguste Kerckhoffs was a Dutch cryptographer in the 19th century. In the security
    community, he’s known for his proposals to improve practical cryptography in the
    French military. Among the six recommendations he published in 1883, one became
    famously known as *Kerckhoffs’s principle*: “The system must not require secrecy
    and can be stolen by the enemy without causing trouble.”'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 奥古斯特·凯克霍夫斯（Auguste Kerckhoffs）是19世纪的一位荷兰密码学家。在安全领域，他因提出改善法国军队实际密码学的建议而闻名。1883年，他发表的六项建议中，有一项被称为*凯克霍夫斯原理*：“系统不应依赖于保密性，且可以被敌人窃取而不会造成麻烦。”
- en: For cryptographic algorithms, this principle means that procedures like encryption,
    decryption, or signing should not be kept secret and that no one should rely on
    this secrecy to guarantee security. The only secret in the system should be a
    secret cryptographic key.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于密码算法而言，这一原理意味着加密、解密或签名等过程不应保密，任何人都不应依赖这些保密性来保证安全。系统中唯一的秘密应是一个保密的密码密钥。
- en: Today, this point doesn’t seem worth mentioning because all relevant crypto
    algorithms are standardized on a national or international level, and all are
    publicly available for everyone to read and analyze. However, when it comes to
    engineering software and devices, some developers still break with this principle.
    They invent their own “crypto” procedures and argue that security is achieved
    “because nobody knows how it works.” They sometimes do this for performance reasons,
    but more often it’s the result of a lack of solid crypto knowledge. However, the
    phrase “can be stolen by the enemy” could also be interpreted as “can be reverse
    engineered by an attacker,” which would break the security of such a “solution.”
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，这一点似乎不值得特别提及，因为所有相关的密码算法都已在国家或国际层面上标准化，并且所有算法都已公开，供每个人阅读和分析。然而，当涉及到工程软件和设备时，一些开发者仍然违反这一原理。他们发明了自己的“加密”程序，并认为安全性是“因为没人知道它是怎么运作的”而实现的。他们有时这样做是出于性能考虑，但更多的时候则是因为缺乏扎实的密码学知识。然而，“可以被敌人窃取”这一说法，也可以理解为“可以被攻击者逆向工程”，这会破坏这种“解决方案”的安全性。
- en: If you catch yourself considering the implementation of a custom function probably
    including some magic values and XOR operations to achieve security, stop thinking
    about it immediately! It’s called *security by obscurity* and it will only get
    you into trouble.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己在考虑实现一个自定义函数，可能包括一些神秘的值和异或操作来实现安全性，请立刻停止思考！这叫做*安全通过模糊性*，它只会让你陷入麻烦。
- en: '**Levels of Security**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**安全级别**'
- en: 'Cryptographic algorithms have several parameters and properties that describe
    and differentiate them, but one is central: their *security level* that’s indicated
    by a certain bit length—for example, 64-bit, 80-bit, or 256-bit. This practical
    gauge allows you to compare algorithms and their cryptographic strength. But what
    does it actually mean if a specific algorithm has a 128-bit security level?'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 加密算法有多个参数和属性来描述和区分它们，但其中一个是最为核心的：*安全级别*，它通过特定的位长来表示——例如，64位、80位或256位。这个实际的衡量标准使你可以比较算法及其加密强度。但如果一个特定算法有128位安全级别，这到底意味着什么呢？
- en: The level describes the effort an attacker needs to expend in order to break
    the algorithm’s protection goal. Usually, that effort involves testing large sets
    of data for a correct solution, such as a secret decryption key. If an algorithm
    has a 128-bit security level, the *search space* for an attacker is 128 bits large,
    which means that the attacker has to perform a maximum of 2^(128) tries in order
    to identify the needle in the haystack.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 该级别描述了攻击者为了突破算法保护目标所需付出的努力。通常，这种努力涉及测试大量数据集以找到正确的解决方案，比如一个秘密解密密钥。如果一个算法具有128位安全级别，那么攻击者的*搜索空间*就是128位大，这意味着攻击者必须进行最多2^(128)次尝试才能在数据海洋中找到目标。
- en: For well-designed symmetric ciphers, the key length can be translated directly
    into an algorithm’s security level. However, security levels are subject to change
    if cryptographers find algorithmic flaws. In that case, the algorithm’s security
    level might become significantly less than the key length.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于设计良好的对称加密算法，密钥长度可以直接转换为算法的安全级别。然而，如果密码学家发现算法存在缺陷，安全级别可能会发生变化。在这种情况下，算法的安全级别可能远低于密钥长度。
- en: In addition, keep in mind that attackers continuously make performance gains.
    Modern *brute-force* attacks make use of thousands of cloud instances to efficiently
    search for a key. In recent years, attacks on 64-bit secrets have been successful,
    increasing the need for a solid choice of security level.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请记住，攻击者不断提升其性能。现代的*暴力破解*攻击利用数千个云实例来高效地搜索密钥。近年来，对64位密钥的攻击已成功，进一步增加了对安全级别稳固选择的需求。
- en: If you want to engineer secure and long-lasting devices, keep up with the current
    recommendations of crypto security levels (see *[https://www.keylength.com](https://www.keylength.com)*).
    As a rule of thumb at the time of writing, a 128-bit security level is considered
    suitable for practical security engineering, and 256-bit is typically used for
    high-security applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想设计安全且持久的设备，请跟上当前密码学安全级别的推荐（见* [https://www.keylength.com](https://www.keylength.com)
    *）。根据写作时的经验法则，128位安全级别被认为适合实际的安全工程，而256位通常用于高安全性应用。
- en: '**WARNING**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*Although the security level of symmetric ciphers often equals their key length,
    that’s not always the case. In addition, security levels for asymmetric crypto
    are completely different; keys with 2,048 bits might offer only 112-bit security,
    for example, as you’ll see later in this chapter.*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*虽然对称加密的安全级别通常等于其密钥长度，但并非总是如此。此外，非对称加密的安全级别完全不同；例如，具有2048位的密钥可能只提供112位的安全性，正如你将在本章后面看到的。*'
- en: '**Symmetric Ciphers**'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**对称加密算法**'
- en: The origin of symmetric cryptography dates back to the famous Roman named Caesar,
    who is said to have used a simple letter-substitution cipher to make messages
    incomprehensible. Since then, the basic principle of symmetric crypto hasn’t changed.
    It follows the idea that a *plaintext* message can be encrypted to a *ciphertext*
    by using the encryption algorithm `Encrypt``()` and a *cryptographic key*, as
    illustrated in [Figure 2-1](ch02.xhtml#ch02fig01).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对称加密的起源可以追溯到著名的罗马人凯撒，据说他曾使用简单的字母替换加密法使信息变得无法理解。从那时起，对称加密的基本原理就没有改变。它遵循这样的理念：*明文*消息可以通过使用加密算法`Encrypt()`和*加密密钥*将其加密成*密文*，正如[图2-1](ch02.xhtml#ch02fig01)所示。
- en: '![Image](../images/02fig01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig01.jpg)'
- en: '*Figure 2-1: The basic principle of symmetric cryptography*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-1：对称加密的基本原理*'
- en: The decryption operation `Decrypt``()` uses *the same secret key* to reverse
    the encryption and yield the original message, hence the term *symmetriccryptography*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 解密操作`Decrypt`（）使用*相同的秘密密钥*来反转加密过程并恢复原始消息，因此这种加密方式被称为*对称加密*。
- en: '***Data Encryption Standard***'
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数据加密标准***'
- en: Fast-forward 2,000 years. In many cases, symmetric encryption is now handled
    by *block ciphers* that take one block of plaintext and encrypt it to a block
    of ciphertext. One of the first publicly standardized block ciphers was the *Data
    Encryption Standard (DES)*, also known as the *Data Encryption Algorithm (DEA)*.
    It’s based on a so-called *Feistel network* and has only a 56-bit key. Today,
    with dedicated hardware, this key space can be completely searched within hours,
    which makes it absolutely insecure for modern applications.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 快进到2000年。在许多情况下，对称加密现在由*分组密码*处理，这些密码将一块明文加密为一块密文。第一个公开标准化的分组密码是*数据加密标准（DES）*，也称为*数据加密算法（DEA）*。它基于所谓的*Feistel网络*，并且只有56位的密钥。今天，通过专用硬件，这个密钥空间可以在几小时内完全搜索，这使得它对于现代应用来说绝对不安全。
- en: '*Triple DES (3DES)* is an extension of DES that uses three 56-bit keys and
    applies DES three times to a plaintext or ciphertext. Given the total key length
    of 168 bits, the block size of 64 bits, and known cryptographic weaknesses, 3DES
    is considered to achieve only a 112-bit security level and should no longer be
    used in new designs.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*三重DES（3DES）*是DES的扩展，使用三个56位的密钥，并对明文或密文应用三次DES。考虑到总密钥长度为168位，块大小为64位，并且已知的加密弱点，3DES被认为只能提供112位的安全级别，并且不应再用于新的设计中。'
- en: '**WARNING**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*Some modern crypto libraries still provide DES and 3DES. However, if you don’t
    have very good reasons—for example, indispensable backward compatibility—do not
    use any DES-based algorithm.*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*一些现代的加密库仍然提供DES和3DES。然而，如果你没有非常充分的理由——例如，必须的向后兼容性——不要使用任何基于DES的算法。*'
- en: '***Advanced Encryption Standard***'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***高级加密标准***'
- en: 'The first choice for symmetric encryption is currently the *Advanced Encryption
    Standard (AES)*, originally named *Rijndael*. This successor of DES was standardized
    as Federal Information Processing Standard (FIPS) 197 and ISO/IEC 18033-3 after
    a cryptographic competition process that was organized by NIST lasted from 1997
    to 2000\. AES is based on a substitution-permutation network (SPN), has a block
    length of 128 bits, and can be operated with three key lengths: 128-bit, 192-bit,
    and 256-bit.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当前对称加密的首选是*高级加密标准（AES）*，最初名为*Rijndael*。这一DES的继任者经过1997年到2000年由NIST组织的密码学竞赛过程后，作为《联邦信息处理标准》（FIPS）197号和ISO/IEC
    18033-3标准化。AES基于置换-替代网络（SPN），具有128位的块长度，并可以使用三种密钥长度：128位、192位和256位。
- en: As shown in [Figure 2-2](ch02.xhtml#ch02fig02), AES operates on a 4×4 byte matrix,
    known as the *AES state*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图2-2](ch02.xhtml#ch02fig02)所示，AES在一个4×4字节矩阵上操作，这个矩阵被称为*AES状态*。
- en: '![Image](../images/02fig02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig02.jpg)'
- en: '*Figure 2-2: A matrix visualization of the AES state*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-2：AES状态的矩阵可视化*'
- en: 'Depending on the selected key size, this state is processed for a certain number
    of rounds: 10 for 128-bit keys, 12 for 192-bit keys, and 14 for 256-bit keys.
    Here’s the basic encryption process based on the main AES functions:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 根据所选的密钥大小，这个状态会经过一定轮数的处理：对于128位密钥为10轮，192位密钥为12轮，256位密钥为14轮。以下是基于主要AES功能的基本加密过程：
- en: '**Key expansion**    The original key is expanded to multiple 128-bit subkeys,
    one for each round plus an initial one.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**密钥扩展** 原始密钥被扩展为多个128位的子密钥，每轮一个，外加一个初始密钥。'
- en: '**Initial round**    As a preparation step, the function `AddRoundKey``()`
    is applied to the input plaintext to obtain a new state.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**初始轮** 作为准备步骤，函数`AddRoundKey`()被应用于输入明文，以获得新的状态。'
- en: '**Main rounds**    Depending on the key lengths, 9, 11, or 13 main rounds are
    performed with the following operations happening consecutively: `SubBytes``()`,
    `ShiftRows``()`, `MixColumns``()`, and `AddRoundKey``()`.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**主轮** 根据密钥长度，执行9、11或13轮主操作，以下操作依次发生：`SubBytes`()、`ShiftRows`()、`MixColumns`()和`AddRoundKey`()。'
- en: '**Final round**    In the last round, only `SubBytes``()`, `ShiftRows``()`,
    and `AddRoundKey``()` are called. `MixColumns``()` is omitted.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**最后一轮** 在最后一轮中，仅调用`SubBytes`()、`ShiftRows`()和`AddRoundKey`()。`MixColumns`()被省略。'
- en: The four operations that enable this strong encryption are pretty simple. The
    `SubBytes()` function substitutes each byte in the AES state with a corresponding
    byte resulting from a lookup table called an *S-box*, as shown in [Figure 2-3](ch02.xhtml#ch02fig03).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这种强加密的四个操作非常简单。`SubBytes()`函数将AES状态中的每个字节替换为由查找表（称为*S-box*）生成的相应字节，如[图2-3](ch02.xhtml#ch02fig03)所示。
- en: '![Image](../images/02fig03.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig03.jpg)'
- en: '*Figure 2-3: The* SubBytes() *transformation*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-3：* SubBytes() *转换*'
- en: '[Figure 2-4](ch02.xhtml#ch02fig04) shows that the `ShiftRows()` transformation
    shifts the second row of the AES state matrix 1 byte to the left, the third row
    2 bytes to the left, and the fourth row 3 bytes to the left. The first row remains
    unchanged.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-4](ch02.xhtml#ch02fig04)显示了 `ShiftRows()` 变换将 AES 状态矩阵的第二行向左移 1 字节，第三行向左移
    2 字节，第四行向左移 3 字节。第一行保持不变。'
- en: '![Image](../images/02fig04.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig04.jpg)'
- en: '*Figure 2-4: The* ShiftRows() *transformation*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-4：* ShiftRows() *变换*'
- en: The `MixColumns()` operation applies a linear transformation to each column
    of the AES state matrix, as depicted in [Figure 2-5](ch02.xhtml#ch02fig05). This
    yields 4 resulting bytes representing the new state of each column, respectively.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`MixColumns()` 操作对 AES 状态矩阵的每一列应用线性变换，如[图 2-5](ch02.xhtml#ch02fig05)所示。这样得到
    4 个字节，分别表示每一列的新状态。'
- en: '![Image](../images/02fig05.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig05.jpg)'
- en: '*Figure 2-5: The* MixColumns() *transformation*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-5：* MixColumns() *变换*'
- en: Every round, the `AddRoundKey()` operation XORs each byte of the AES state with
    the corresponding byte of a given round key, as illustrated in [Figure 2-6](ch02.xhtml#ch02fig06).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每一轮中，`AddRoundKey()` 操作将 AES 状态的每个字节与给定轮密钥的相应字节进行异或操作，如[图 2-6](ch02.xhtml#ch02fig06)所示。
- en: '![Image](../images/02fig06.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig06.jpg)'
- en: '*Figure 2-6: The* AddRoundKey() *transformation*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-6：* AddRoundKey() *变换*'
- en: For decryption, the order of subkeys is reversed, and the inverse functions
    of `SubBytes()`, `ShiftRows()`, `MixColumns()`, and `AddRoundKey()` are called.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于解密，子密钥的顺序被反转，并且调用 `SubBytes()`、`ShiftRows()`、`MixColumns()` 和 `AddRoundKey()`
    的逆函数。
- en: After more than 20 years and extensive research, nobody has discovered an attack
    on the AES architecture that has practical relevance. It’s available in all major
    crypto software libraries, and systems as small as 8-bit microcontrollers can
    use it with reasonable performance. AES is used for disk encryption in laptops,
    but also for payload encryption in secure internet communication. Whenever it
    comes to symmetric encryption, you should choose AES unless you have serious reasons
    not to do so.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 经过 20 多年的广泛研究，至今没有人发现 AES 架构存在具有实际意义的攻击。它已被所有主要的加密软件库所支持，甚至像 8 位微控制器这样的小型系统也可以在合理的性能下使用它。AES
    被用于笔记本电脑的磁盘加密，也用于安全互联网通信中的有效载荷加密。每当涉及对称加密时，除非有充分的理由，否则你应该选择 AES。
- en: '**Modes of Operation**'
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**工作模式**'
- en: Since AES is a block cipher, it naturally encrypts or decrypts only a single
    block, but many applications have much more input data than just one 128-bit block.
    Therefore, AES has to be used in a certain *mode of operation* that defines the
    procedures to encrypt and decrypt multiple blocks of data. The modes introduced
    here are defined in NIST’s *Special Publication 800-38A*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 AES 是一个分组密码，它自然只加密或解密单个数据块，但许多应用程序的输入数据要比一个 128 位的块多得多。因此，AES 必须在某种*工作模式*下使用，该模式定义了加密和解密多个数据块的过程。这里介绍的模式在
    NIST 的*特殊出版物 800-38A*中有所定义。
- en: '***Electronic Codebook Mode***'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***电子密码本模式（ECB）***'
- en: Some of you might wonder, “Why not just encrypt the data block by block?” That
    trivial approach is exactly what the *Electronic Codebook (ECB) mode* does. It
    takes the first 128 bits of a message as the first plaintext block, encrypts it
    to the first 128 bits of ciphertext, and continues in the same way with as many
    chunks of 128-bit data as available, as shown in [Figure 2-7](ch02.xhtml#ch02fig07).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会想：“为什么不按块加密数据呢？”这种简单的做法正是*电子密码本（ECB）模式*所做的。它将消息的前 128 位作为第一个明文块，将其加密为第一个
    128 位的密文，然后继续对所有可用的 128 位数据块按此方式处理，如[图 2-7](ch02.xhtml#ch02fig07)所示。
- en: '![Image](../images/02fig07.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig07.jpg)'
- en: '*Figure 2-7: Encryption in ECB mode*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-7：ECB 模式下的加密*'
- en: However, the problem with this approach is that equal input data blocks are
    encrypted to equal ciphertext blocks. Therefore, the relation between blocks,
    which can also carry sensitive information, is preserved. [Figure 2-8](ch02.xhtml#ch02fig08)
    illustrates this phenomenon.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法的问题在于相同的输入数据块会加密为相同的密文块。因此，块与块之间的关系（也可能包含敏感信息）得以保持。[图 2-8](ch02.xhtml#ch02fig08)展示了这一现象。
- en: '![Image](../images/02fig08.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig08.jpg)'
- en: '*Figure 2-8: Comparing ECB and Counter (CTR) modes*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-8：比较 ECB 模式与计数器（CTR）模式*'
- en: When images are encrypted in ECB mode, the plaintext pixels with the same values
    are still mapped to ciphertext pixels with identical values. The image information
    is still comprehensible. For other operation modes, such as Counter mode, things
    look different, as explained in “Counter Mode” on [page 34](ch02.xhtml#ch00lev2_22).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当图像使用ECB模式加密时，具有相同值的明文像素仍然会映射到具有相同值的密文像素。图像信息仍然是可以理解的。而对于其他操作模式，如计数器模式，情况则不同，如[第34页](ch02.xhtml#ch00lev2_22)的“计数器模式”一节所述。
- en: '***Cipher Block Chaining Mode***'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***密码分组链接模式***'
- en: The *Cipher Block Chaining (CBC) mode* breaks the relation between plaintext
    and ciphertext by XORing the ciphertext of the first block with the plaintext
    of the second block, and so on. [Figure 2-9](ch02.xhtml#ch02fig09) shows the basic
    principle.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*密码分组链接（CBC）模式*通过将第一个块的密文与第二个块的明文进行异或，依此类推，从而打破了明文与密文之间的关系。[图 2-9](ch02.xhtml#ch02fig09)展示了这一基本原理。'
- en: '![Image](../images/02fig09.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig09.jpg)'
- en: '*Figure 2-9: Encryption in CBC mode*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-9：CBC模式中的加密*'
- en: 'From a security point of view, CBC mode is significantly better than ECB mode,
    but it has a new drawback: the dependency between subsequent encryptions makes
    parallel implementations less efficient, which limits performance.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全角度来看，CBC模式显著优于ECB模式，但它有一个新的缺点：后续加密之间的依赖性使得并行实现的效率降低，从而限制了性能。
- en: '***Counter Mode***'
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***计数器模式***'
- en: An interesting mode that doesn’t permit a relation between ciphertexts but facilitates
    high-performance, multicore implementations is called *Counter (CTR) mode*. As
    illustrated in [Figure 2-10](ch02.xhtml#ch02fig010), the plaintext blocks themselves
    aren’t encrypted, but the concatenation of a *nonce (number used once)* and a
    counter value starting at 0.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一种有趣的模式，既不允许密文之间的关系，但又便于高性能的多核实现，叫做*计数器（CTR）模式*。如[图 2-10](ch02.xhtml#ch02fig010)所示，明文块本身并没有加密，而是将一个*nonce（一次性数字）*与从0开始的计数器值连接起来。
- en: '![Image](../images/02fig10.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig10.jpg)'
- en: '*Figure 2-10: Encryption in CTR mode*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-10：CTR模式中的加密*'
- en: 'The result of this encryption is then XORed with the plaintext to obtain a
    ciphertext. For every further plaintext block, the counter value is incremented
    by one to support changing ciphertexts, as shown in [Figure 2-8](ch02.xhtml#ch02fig08)c.
    This approach even provides another advantage: both encryption and decryption
    utilize the `Encrypt()` function of the used block cipher. There’s no need to
    implement `Decrypt()`.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这种加密的结果会与明文进行异或操作，从而得到密文。对于每一个后续的明文块，计数器值会增加1，以支持密文的变化，如[图 2-8](ch02.xhtml#ch02fig08)c所示。这种方法甚至提供了另一个优势：加密和解密都使用所用分组密码的`Encrypt()`函数，无需实现`Decrypt()`。
- en: 'In contrast to ECB mode, CBC and CTR modes require an additional input parameter:
    an *initialization vector (IV)* or a nonce. The rationale for both is to make
    every encryption unique, so they should never be used twice. Further, decryption
    is possible only if the receiver also has access to the corresponding IV or nonce.
    But since it doesn’t carry confidential data, transmitting it in cleartext is
    okay along with the ciphertext.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 与ECB模式不同，CBC和CTR模式需要额外的输入参数：*初始化向量（IV）*或nonce。两者的目的都是使每次加密都具有唯一性，因此它们不应当重复使用。此外，只有接收方也能访问对应的IV或nonce，解密才是可能的。但由于它不携带机密数据，因此可以与密文一起以明文形式传输。
- en: '**WARNING**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*In practice, just setting an IV or a nonce to 0 or a fixed random number is
    tempting. However, doing so will significantly weaken the strength of this cryptographic
    primitive. Spend the additional effort to implement a suitable generator for unique
    values.*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*实际上，仅将IV或nonce设置为0或一个固定的随机数是很有诱惑的。然而，这么做会显著削弱这个加密原语的强度。花费额外的精力来实现一个适合的生成器，以确保生成唯一的值。*'
- en: Together with the operation modes CBC and CTR, AES enjoys great popularity.
    However, other, more interesting symmetric ciphers might be helpful if you have
    special requirements. For example, the modern stream ciphers Salsa20 and ChaCha20,
    developed by cryptographer Daniel J. Bernstein, have simple designs and provide
    high performance in pure software implementations. If your hardware doesn’t support
    AES but you need to get the highest performance possible, these algorithms might
    be worth looking at.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 与操作模式CBC和CTR一起，AES非常流行。然而，如果你有特殊需求，其他更有趣的对称加密算法可能会有所帮助。例如，由密码学家Daniel J. Bernstein开发的现代流密码Salsa20和ChaCha20，具有简单的设计，并在纯软件实现中提供高性能。如果你的硬件不支持AES，但你需要获得尽可能高的性能，这些算法可能值得一试。
- en: '**Hash Functions**'
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**哈希函数**'
- en: Hash functions are somewhat exotic in the pool of cryptographic algorithms.
    On their own, they don’t aim for one of the classic protection goals. Their objective
    is to map more or less arbitrarily large input data to a fixed-length, binary
    sequence called a *hash value*, or *digest*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数在密码学算法中有些另类。单独使用时，它们并不追求经典的保护目标。它们的目标是将更多或更少任意大的输入数据映射为一个固定长度的二进制序列，称为*哈希值*或*摘要*。
- en: 'However, the design of such functions isn’t trivial. They have to fulfill a
    set of strong requirements:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，设计这样函数并不简单。它们必须满足一系列强要求：
- en: '**Preimage resistance**    The term *preimage* refers to the correct input
    data to a hash function that maps to a given hash value. This requirement says
    that an attacker shouldn’t be able to find such suitable input data for an existing
    hash value. This is why hash functions are also called *one-way functions*. Nobody
    should be able to invert them.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**原像抗性** 术语*原像*指的是映射到给定哈希值的哈希函数的正确输入数据。这个要求表示攻击者不应该能够找到适合现有哈希值的输入数据。这也是为什么哈希函数也被称为*单向函数*的原因。没有人应该能够反转它们。'
- en: '**Second preimage resistance**    Further, a malicious actor who has access
    to a message and its hash value shouldn’t be able to find a *second preimage*—namely,
    another message that maps to the same hash.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**第二原像抗性** 此外，具有消息及其哈希值的恶意行为者不应该能够找到*第二原像*——即另一个映射到相同哈希值的消息。'
- en: '**Collision resistance**    Naturally, hash-value collisions must exist because
    the input space of a hash function is larger than its output space. The strongest
    assumption for hash functions is that finding any two messages that map to the
    same hash value should be *practically impossible*.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**碰撞抗性** 自然，哈希值碰撞是不可避免的，因为哈希函数的输入空间大于其输出空间。哈希函数的最强假设是找到任何两个映射到相同哈希值的消息应该是*实际不可能*的。'
- en: By design, hash functions don’t use a secret key, which means that everyone
    can use them and apply them to all data at hand. Therefore, we have to determine
    the security level of hash functions differently. The security level is described
    as the amount of difficulty in finding collisions, which is again a kind of search-space
    problem, similar to finding the correct key for an encryption algorithm.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从设计上讲，哈希函数不使用秘密密钥，这意味着每个人都可以使用它们并将其应用于手头的所有数据。因此，我们必须以不同的方式来确定哈希函数的安全级别。安全级别描述为找到碰撞的难度，这本质上是一个搜索空间问题，类似于为加密算法找到正确密钥的问题。
- en: Based on the so-called *birthday paradox* and the *rho method*, cryptographers
    have shown that, for well-designed hash functions, we can estimate the security
    level to be half of their output size. For example, for a hash function with 160-bit
    output, the security level estimate is around 80-bit.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 基于所谓的*生日悖论*和*rho方法*，密码学家们已经证明，对于设计良好的哈希函数，我们可以估算其安全级别为输出大小的一半。例如，对于一个输出为160位的哈希函数，安全级别的估算值约为80位。
- en: 'At this point, you might wonder why we need hash functions and their cryptographic
    mapping process for device security. The reason is simple: they’re part of many
    security applications like digital signature generation and verification, key-derivation
    algorithms, secure password storage, and many more.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时候，你可能会想，为什么我们需要哈希函数及其加密映射过程来确保设备安全？原因很简单：它们是许多安全应用的一部分，如数字签名生成和验证、密钥派生算法、安全密码存储等。
- en: The first practical implementations of hash functions emerged in the 1990s.
    MD4, MD5, and SHA-1 are three prominent representatives. However, in the meantime,
    researchers have discovered ways to find collisions for those three (and others),
    so you shouldn’t use those legacy algorithms in modern designs anymore.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数的第一个实际实现出现在1990年代。MD4、MD5和SHA-1是三个突出的代表。然而，与此同时，研究人员已经发现了找到这三种（以及其他哈希函数）碰撞的方法，因此你不应该再在现代设计中使用这些遗留算法。
- en: 'Currently, the most widely used family of hash functions is SHA-2, the successor
    to SHA-1\. It’s described in the *FIPS 180-4* standard and has four members: SHA-224,
    SHA-256, SHA-384, and SHA-512\. The numbers represent the output lengths of these
    functions, so SHA-224 is very similar to SHA-256 except for different initial
    values and the truncation of the final hash value to 224 bits. The same applies
    for SHA-384 in relation to SHA-512.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，最广泛使用的哈希函数家族是SHA-2，它是SHA-1的继任者。它在*FIPS 180-4*标准中进行了描述，并有四个成员：SHA-224、SHA-256、SHA-384和SHA-512。数字表示这些函数的输出长度，因此SHA-224与SHA-256非常相似，除了初始值不同以及最终哈希值被截断为224位。SHA-384与SHA-512之间也有类似的区别。
- en: SHA-256 processes 512 bits (sixteen 32-bit words) in 64 rounds. It exhibits
    a 128-bit security level against collisions and is, therefore, a secure and efficient
    option. SHA-512 is intended for high-security areas like federal and military
    purposes. It works on 1,024 bits (sixteen 64-bit words) for 80 rounds and exhibits
    a lower performance compared to SHA-256.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: SHA-256处理512位（16个32位字）的数据，进行64轮操作。它在抵抗碰撞方面具有128位的安全性，因此是一种安全且高效的选择。SHA-512则用于高安全性领域，如联邦和军事用途。它处理1024位（16个64位字）的数据，进行80轮操作，且相较于SHA-256，性能较低。
- en: Since the SHA-2 family is based on an architecture similar to MD5 and SHA-1,
    cryptographers are skeptical about its long-term security. In 2007, NIST announced
    a cryptographic competition in order to find a candidate to be standardized as
    SHA-3\. One important requirement was that the design of the algorithm should
    be based on primitives other than SHA-2\. Five years later, the *Keccak* algorithm
    was named as the winning hash function. Subsequently, it has been published as
    the new SHA-3 standard in *FIPS 202*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SHA-2系列基于类似于MD5和SHA-1的架构，密码学家对它的长期安全性持怀疑态度。2007年，NIST宣布了一项密码学竞赛，旨在找到一个候选算法，以标准化为SHA-3。一个重要的要求是算法的设计应基于与SHA-2不同的原语。五年后，*Keccak*算法被选为获胜的哈希函数。随后，它被发布为新的SHA-3标准，收录于*FIPS
    202*中。
- en: 'SHA-3 is also available in four versions: SHA3-224, SHA3-256, SHA3-384, and
    SHA3-512\. Again, the lengths of their output values in bits is denoted by the
    numbers after the hyphen in their names. Their performance and security level
    is comparable to those of their SHA-2 counterparts, but they’re based on a completely
    different algorithmic foundation, as intended by NIST.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: SHA-3也有四个版本：SHA3-224、SHA3-256、SHA3-384和SHA3-512。同样，它们的输出值长度（以位为单位）由名称中的连字符后面的数字表示。它们的性能和安全性与SHA-2系列相当，但它们基于完全不同的算法基础，正如NIST所期望的那样。
- en: '**NOTE**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Even if SHA-3 is the newer standard, you don’t need to migrate from SHA-2
    to SHA-3 soon. They are comparable, so you are free to decide which to use depending
    on the libraries you need and application requirements you have.*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*即使SHA-3是更新的标准，你也不需要立即从SHA-2迁移到SHA-3。它们是可比的，因此你可以根据所需的库和应用需求自由决定使用哪一个。*'
- en: '**Message Authentication Codes**'
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**消息认证码**'
- en: A common misconception about encryption is that it protects against manipulation.
    It doesn’t. Even if you use AES and a state-of-the-art mode of operation, and
    an attacker can’t read anything from the resulting ciphertext, that attacker is
    still able to manipulate single bits or whole messages without being detected
    by the block cipher. Encryption protects only confidentiality, not integrity.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 关于加密的一个常见误解是它能防止篡改。事实并非如此。即使你使用AES和最先进的操作模式，并且攻击者无法从结果密文中读取任何内容，攻击者仍然能够篡改单个位或整个消息，而不会被块加密算法检测到。加密只保护机密性，而不保护完整性。
- en: A *message authentication code (MAC)*, also known as a *message integrity code
    (MIC)*, is another primitive from the symmetric cryptography tool belt, and it’s
    meant to protect message integrity and authenticity. It creates an *authentication
    tag* from a message and a secret key. Afterward, everyone in possession of the
    secret key can verify the correctness of a message and its corresponding authentication
    tag.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*消息认证码（MAC）*，也称为*消息完整性码（MIC）*，是对称密码学工具中的另一个原语，它旨在保护消息的完整性和真实性。它通过消息和一个秘密密钥创建*认证标签*。随后，任何拥有秘密密钥的人都可以验证消息及其对应的认证标签的正确性。'
- en: 'A popular method for generating MACs is a *hash-based message authentication
    code (HMAC)*. The HMAC construction, also known as a *keyed hash function*, is
    defined in RFC 2104\. The following formula shows its composition:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的生成MAC的方式是*基于哈希的消息认证码（HMAC）*。HMAC结构，也称为*带密钥的哈希函数*，在RFC 2104中定义。以下公式展示了它的组成：
- en: '*HMAC* = *hash*((*key* ⊕ *opad*) ∥ *hash*((*key* ⊕ *ipad*) ∥ *message*))'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*HMAC* = *哈希*((*密钥* ⊕ *内填充*) ∥ *哈希*((*密钥* ⊕ *外填充*) ∥ *消息*))'
- en: The *inner padding (ipad)* is a byte string, `0x3636...36`, containing the same
    number of bytes as the input block size of the used hash function. It is XORed
    with a key of at least the security level of the underlying hash function. The
    result is concatenated with the message to protect before it is hashed altogether.
    The digest of this operation is then appended to the XOR between the same key
    and the *outer padding (opad)*, a byte string `0x5c5c...5c` of the same length
    as the ipad. Hashing the resultant bytes leads to the final HMAC value.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*内填充（ipad）*是一个字节串，`0x3636...36`，包含与所使用哈希函数的输入块大小相同数量的字节。它与至少具有与底层哈希函数安全级别相同的密钥进行异或。结果与要保护的消息连接在一起，然后进行哈希运算。此操作的摘要随后附加到与*外填充（opad）*（一个字节串`0x5c5c...5c`，其长度与ipad相同）进行异或的结果上。对结果字节进行哈希运算得到最终的HMAC值。'
- en: As an example, if SHA-256 is chosen as an HMAC’s hash function, the cryptographic
    algorithm is then called HMAC-SHA-256\. The length of the inner and outer padding
    is 512 bits, or 64 bytes. The key should be at least 128 bits long, and the HMAC
    length is 256 bits, or 32 bytes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，如果选择SHA-256作为HMAC的哈希函数，那么该加密算法就叫做HMAC-SHA-256。内外填充的长度是512位，即64字节。密钥应至少为128位长，HMAC的长度为256位，即32字节。
- en: '**NOTE**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In practice, you might come across HMAC constructions that are built upon
    MD5 or SHA-1\. Even if collision attacks have been demonstrated for these hash
    functions, they’re still valid to be used for practical HMAC implementations because
    an attacker would have to acquire an enormous number of authentication tags resulting
    from the same single secret key to break a specific instance.*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*实际上，你可能会遇到基于MD5或SHA-1的HMAC结构。即使这些哈希函数已经证明存在碰撞攻击，它们仍然适用于实际的HMAC实现，因为攻击者需要获得大量来自同一个密钥的认证标签才能破解特定实例。*'
- en: A *cipher-based message authentication code (CMAC)* uses a block cipher in CBC
    mode to compute MACs. A variant that’s based on AES, called *AES-CMAC*, is specified
    in RFC 4493\. There, the message to protect is processed with AES in CBC mode
    except for the last message block, which is specifically treated for security
    reasons. The final ciphertext is taken as the authentication tag, and all other
    ciphertexts are discarded.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于密码的消息认证码（CMAC）*使用CBC模式下的分组密码来计算MAC。一个基于AES的变体，称为*AES-CMAC*，在RFC 4493中进行了规定。在那里，保护的消息使用AES在CBC模式下进行处理，除了最后一个消息块，出于安全原因，该块被专门处理。最终的密文作为认证标签，而所有其他密文则被丢弃。'
- en: This solution isn’t as popular as the HMAC construction, but it might be interesting
    from a performance point of view, especially on devices that have built-in AES
    accelerators.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案不像HMAC结构那样流行，但从性能角度来看可能会很有趣，特别是在那些内置AES加速器的设备上。
- en: '**Authenticated Encryption**'
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**认证加密**'
- en: 'For secure communication, confidentiality, integrity, and authenticity are
    common protection goals. In the previous sections, we considered how we can use
    block ciphers and MACs to achieve these goals, but two practical questions still
    remain: “How do we combine them?” and “Can combinations of ciphers and MACs be
    more efficient than using them separately?”'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于安全通信，保密性、完整性和真实性是常见的保护目标。在前面的部分中，我们考虑了如何使用分组密码和MAC来实现这些目标，但仍然有两个实际问题需要解决：“我们如何将它们结合起来？”以及“将密码和MAC组合使用是否比单独使用它们更高效？”
- en: '***Strategies and Requirements***'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略和要求***'
- en: 'When combining encryption and MAC generation, we can use three strategies.
    All three assume the use of secure ciphers and MAC algorithms and that each of
    them uses its own key, but differ in the order of the performed operations:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在结合加密和MAC生成时，我们可以使用三种策略。所有这三种策略都假设使用安全的密码和MAC算法，并且每种算法都使用自己的密钥，但在执行操作的顺序上有所不同：
- en: '**Encrypt-and-MAC**    This approach generates a ciphertext and an authentication
    tag from the same plaintext in parallel, which could yield a performance advantage.
    However, applying a MAC algorithm to plaintext might lead to information leakage
    about the plaintext by the authentication tag because MAC algorithms are not designed
    to protect the confidentiality of their input data. However, for modern MACs like
    HMAC-SHA-256, this problem doesn’t exist. A second issue is that the ciphertext’s
    integrity isn’t protected. An altered ciphertext has to be decrypted first to
    detect the manipulation, which could allow an attacker to exploit implementation
    weaknesses in the decryption routine.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**加密并MAC**    这种方法从相同的明文并行生成密文和认证标签，这可能带来性能优势。然而，将MAC算法应用于明文可能会通过认证标签泄露明文的信息，因为MAC算法并不设计用于保护输入数据的机密性。然而，对于现代的MAC，如HMAC-SHA-256，这个问题不存在。另一个问题是密文的完整性没有得到保护。篡改过的密文必须先被解密才能检测到篡改，这可能允许攻击者利用解密过程中的实现漏洞。'
- en: '**MAC-then-encrypt**    In this variant, an authentication tag is generated
    from the plaintext and appended to it. The result is then encrypted to obtain
    the final ciphertext. In this case, the MAC algorithm can’t leak any information,
    but the ciphertext can still be manipulated without a possibility to detect it
    before decryption.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**先MAC再加密**    在这种变体中，认证标签是从明文生成的，并附加到明文上。结果随后被加密以获得最终的密文。在这种情况下，MAC算法不会泄露任何信息，但密文仍然可以被篡改，在解密之前无法检测到。'
- en: '**Encrypt-then-MAC**    This is a strong strategy for integrity and confidentiality
    protection of messages. First, the plaintext is encrypted before the MAC is generated
    from the resulting ciphertext. With this approach, the authentication tag can’t
    leak any information about the plaintext, and at the same time, we can verify
    the correctness of the ciphertext bits before decrypting the given data.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**先加密再MAC**    这是一种强有力的消息完整性和保密性保护策略。首先，对明文进行加密，然后从加密后的密文中生成MAC。采用这种方法，认证标签不能泄露任何关于明文的信息，同时，我们可以在解密给定数据之前验证密文的正确性。'
- en: Crypto practitioners are always on the lookout for performance gains because
    security measures should have as little performance overhead as possible. Therefore,
    it’s not surprising that the field of *authenticated encryption (AE)* emerged
    from the combination of ciphers and MACs to enhance processing speed.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 加密实践者总是在寻找性能提升的机会，因为安全措施应该尽可能减少性能开销。因此，*认证加密（AE）*领域从结合密码算法和MAC算法以提高处理速度中应运而生，这并不令人惊讶。
- en: In comparison to “normal” ciphers, AE algorithms take plaintext and compute
    both ciphertext and an authentication tag during encryption. At decryption, the
    integrity of the ciphertext and authentication tag are verified before proceeding.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 与“普通”密码算法相比，AE算法在加密过程中不仅计算密文，还计算一个认证标签。在解密时，必须先验证密文和认证标签的完整性，然后才能继续。
- en: An interesting extension of AE is called *authenticated encryption with associated
    data (AEAD)*, which allows you to integrate additional plaintext data into the
    process of generating the authentication tag. Examples are sequence numbers or
    metadata that don’t require confidentiality. The integrity of this associated
    data is achieved while binding it to the yielded ciphertext.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: AE的一个有趣扩展叫做*带关联数据的认证加密（AEAD）*，它允许将额外的明文数据集成到生成认证标签的过程中。例如，序列号或不需要保密性的元数据。通过将这些关联数据与产生的密文绑定，确保了它们的完整性。
- en: '***Galois Counter Mode***'
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***伽罗瓦计数模式***'
- en: Today, the most popular AEAD algorithm is the AES cipher operated in the special
    *Galois Counter mode (GCM)*, which follows the encrypt-then-MAC principle and
    is specified in NIST’s *Special Publication 800-38D*. [Figure 2-11](ch02.xhtml#ch02fig011)
    depicts its basic functionality.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，最流行的AEAD算法是采用特殊*伽罗瓦计数模式（GCM）*操作的AES密码算法，它遵循加密-再MAC原则，并且在NIST的*特殊出版物800-38D*中进行了规范。[图2-11](ch02.xhtml#ch02fig011)展示了它的基本功能。
- en: '![Image](../images/02fig11.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig11.jpg)'
- en: '*Figure 2-11: An authenticated encryption in GCM*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-11：GCM中的认证加密*'
- en: The confidentiality protection is very similar to CTR mode, except GCM doesn’t
    use the result of the first encryption to process plaintext, but rather does it
    in the final step of authentication-tag generation. The MAC generation is based
    on the hash function `GHASH`, which basically consists of a series of multiplications
    in a binary Galois field with a fixed parameter, the *hash subkey*. This subkey
    is derived by encrypting the all-zeros plaintext block with the AES key used for
    encryption.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 机密性保护与CTR模式非常相似，不同之处在于GCM不会使用第一次加密的结果来处理明文，而是在认证标签生成的最后一步进行处理。MAC生成基于哈希函数`GHASH`，它基本上由一系列在固定参数*哈希子密钥*下进行的二进制Galois域乘法组成。该子密钥通过使用加密所用的AES密钥对全零明文块进行加密得出。
- en: The nonce or initialization vector of GCM is meant to be a unique 96-bit binary
    string. GCM is pretty fragile regarding nonce reuse, which means that an attacker
    can forge authentication tags if they have access to two authentication tags that
    were generated using the same key and nonce. Therefore, the implementation of
    a robust nonce generation is essential for GCM.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: GCM的随机数或初始化向量应为唯一的96位二进制字符串。GCM对随机数重用非常敏感，这意味着如果攻击者能访问两个使用相同密钥和随机数生成的认证标签，他们就能伪造认证标签。因此，为GCM实现一个健壮的随机数生成机制至关重要。
- en: Besides AES-GCM, you might encounter many more AE algorithms in the field. Examples
    are the Counter with CBC-MAC (CCM) mode as detailed in NIST’s *Special Publication
    800-38C* and the Offset Codebook (OCB) mode designed by Phil Rogaway. The combination
    of the stream cipher ChaCha20 and the MAC algorithm Poly1305, both designed by
    Bernstein, also serves as a common AEAD solution. It’s especially efficient in
    software-only implementations and has been specified in RFC 8439.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 除了AES-GCM外，你还可能会在该领域遇到许多其他的AE算法。例如，NIST的*特别出版物800-38C*中详细描述了基于CBC-MAC的计数器模式（CCM），以及Phil
    Rogaway设计的偏移码本（OCB）模式。由Bernstein设计的流密码ChaCha20与MAC算法Poly1305的结合也作为一种常见的AEAD解决方案，特别适用于仅软件实现，并且已经在RFC
    8439中指定。
- en: Further, the CAESAR competition (*[https://competitions.cr.yp.to/caesar-submissions.xhtml](https://competitions.cr.yp.to/caesar-submissions.xhtml)*)
    that ran from 2013 to 2019 yielded another set of innovative AEAD designs—for
    example, lightweight implementations on resource-constrained devices or high-performance
    applications.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，从2013年到2019年举办的CAESAR竞赛（* [https://competitions.cr.yp.to/caesar-submissions.xhtml](https://competitions.cr.yp.to/caesar-submissions.xhtml)
    *）产生了一套创新的AEAD设计——例如，面向资源受限设备或高性能应用的轻量级实现。
- en: '**Asymmetric Cryptography**'
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**非对称加密**'
- en: In contrast to using a single secret key, the basic idea of *asymmetric cryptography*
    is having a pair of keys and using each key for only a distinct operation that
    complements the other. For example, everyone uses one key, called a *public key*,
    to encrypt data ([Figure 2-12](ch02.xhtml#ch02fig012)). The second key, called
    a *private key*, belongs to a single entity, and only that entity is able to decrypt
    the previously generated ciphertext by using its private key. Asymmetric cryptosystems
    are also known as *public-key cryptography*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用单一的秘密密钥不同，*非对称加密*的基本思想是拥有一对密钥，并且每个密钥仅用于与另一个密钥互补的特定操作。例如，每个人使用一个密钥，称为*公钥*，来加密数据（[图
    2-12](ch02.xhtml#ch02fig012)）。第二个密钥，称为*私钥*，属于单一实体，只有该实体才能通过使用其私钥解密之前生成的密文。非对称加密系统也被称为*公钥加密*。
- en: '![Image](../images/02fig12.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig12.jpg)'
- en: '*Figure 2-12: Encryption with asymmetric cryptography*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-12：使用非对称加密进行加密*'
- en: However, asymmetric cryptography is useful for more than confidentiality protection.
    The private-key operation can also generate a *digital signature*, which is a
    kind of checksum for given data that only the unique private key of a specific
    entity can compute. Everyone in possession of the corresponding public key would
    be able to verify this signature, which protects not only the protected data’s
    authenticity but also its integrity, because manipulations of the data or signature
    would lead to a verification failure. [Figure 2-13](ch02.xhtml#ch02fig013) illustrates
    the basic idea.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，非对称加密不仅仅用于保护机密性。私钥操作还可以生成*数字签名*，它是一种用于给定数据的校验和，只有特定实体的唯一私钥才能计算。拥有相应公钥的每个人都可以验证这个签名，这不仅保护了受保护数据的真实性，还保护了其完整性，因为数据或签名的篡改会导致验证失败。[图
    2-13](ch02.xhtml#ch02fig013)说明了基本原理。
- en: '![Image](../images/02fig13.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig13.jpg)'
- en: '*Figure 2-13: The generation and verification of a digital signature*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: These fundamentally different opportunities have paved the way for many security
    features we’ve come to take for granted, like secure communication over the internet.
    To understand the basics of the two most popular representatives of asymmetric
    cryptography, there is no way around a little bit of math, as I’ll show in the
    next section.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '**The RSA Cryptosystem**'
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first and still most common asymmetric crypto scheme was published in 1977
    and is named after its inventors: *Rivest-Shamir-Adleman (RSA)*. To achieve the
    typical asymmetry between public and private operations, RSA implements a *trapdoor
    function*. With this approach, you can transform data A to data B easily, but
    deriving data A from data B is practically impossible unless you know the trapdoor.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '***Basic RSA Math***'
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'RSA is based on modular arithmetic, which means integer calculations that wrap
    around if they reach a limit called the *modulus*. The following formula describes
    all the magic behind RSA encryption:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '*y* = *x^e* mod *n*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: The *modular exponentiation* of the *x* plaintext and *e*, the *public exponent*,
    compute the *y* ciphertext. The *n* denotes the modulus.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'Decryption works in a very similar way:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '*x* = *y^d* mod *n*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: The modular exponentiation processes the *y* ciphertext with *d*, the *private
    exponent*, to obtain the *x* plaintext. However, the naive way of exponentiation,
    which means performing *d* – 1 multiplications by *y*, is completely impossible
    for *d* being a number with thousands of bits. You can overcome this obstacle
    with an algorithm called *square-and-multiply*. That algorithm basically operates
    bit by bit on the binary representation of the exponent. In every step, the algorithm
    performs a squaring operation, but if a given bit is 1, it carries out an additional
    multiplication, making RSA a practically usable crypto mechanism.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'The numbers *n* and *e* are usually considered part of the public key, and
    *d* corresponds to the private key in RSA. Their described behavior is possible
    only because *d* and *e* have a special relation that is established during RSA
    key generation. In its first step, two large prime numbers *p* and *q* have to
    be chosen randomly. Their multiplication leads to the modulus *n* = *pq*. Using
    *n*, you can derive the result of Euler’s phi function Φ(*n*):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Φ(*n*) = (*p* – 1)(*q* – 1) = *pq* – *p* – *q* + 1 = (*n* + 1) – (*p* + *q*)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'This value is essential for the RSA cryptosystem and its security because the
    inverse relation between *e* and *d* is achieved in a group modulo Φ(*n*):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '*ed* mod Φ(*n*) = 1'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: In practice, *e* = 65537 = (10000000000000001)[2] is a common choice because
    of its shortness and the low number of 1 bits, both contributing to higher performance
    with the square-and-multiply algorithm. After *e* is chosen, the final step of
    key generation is to compute *d* as the inverse of *e* modulo Φ(*n*).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Knowing these details, it might become clearer why RSA is often mentioned in
    the same sentence with the *integer factorization problem*. This mathematical
    consideration suggests that finding the factors of large numbers is difficult.
    The modulus *n* would be such a large product. RSA is secure because it’s hard
    to find *p* and *q* from a given *n*. However, if someone discovers a solution
    to this problem, an adversary could calculate Φ(*n*) from the factorized values
    *p* and *q* and compute the inverse of *e* modulo Φ(*n*), and RSA would be broken.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Compared to symmetric schemes, the mathematical basis of the RSA cryptosystem
    makes it more difficult to estimate its security level. In *Special Publication
    800-57* from 2020, crypto experts from NIST judged the security levels of RSA
    as listed in [Table 2-1](ch02.xhtml#ch02tab01).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Security Estimation of RSA'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '| **Security level** | **Key size** |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: '| ≤ 80-bit | 1,024-bit |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: '| 112-bit | 2,048-bit |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
- en: '| 128-bit | 3,072-bit |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: '| 192-bit | 7,680-bit |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
- en: '| 256-bit | 15,360-bit |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
- en: Two important properties are obvious. The required key sizes are much longer
    than the achieved security level. The relation between them isn’t linear, but
    the security level rises significantly more slowly in comparison to the invested
    key bits. At the time of writing, 2,048-bit is a common setting, but for long-term
    usage, 4,096-bit RSA keys are recommended.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '***Real-World RSA Usage***'
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The basic structure of RSA, however, is not perfectly suitable for practical
    encryption because attackers in possession of two ciphertexts would be able to
    create a new ciphertext that is the correct encryption of the multiplication of
    the two original plaintexts. The *Optimal Asymmetric Encryption Padding (OAEP)*
    scheme was developed to avoid this weakness. In connection with RSA, it’s called
    *RSA-OAEP* or *RSAES-OAEP* and is specified in NIST’s *Special Publication 800-56B*.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, OAEP uses a random string and two hash functions to process the
    plaintext, often a symmetric key, and generates a padded plaintext version that
    is subsequently used for RSA encryption. For decryption, the ciphertext is decrypted
    as in standard RSA, but then the initial message and random value have to be recovered
    by using the two hash functions mentioned before. Finally, the computation result
    has to be verified for its correct structure before you can use the plaintext.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: A similar problem also exists for digital signatures with the basic RSA equations.
    Based on a valid signature for a specifically prepared message, attackers would
    be able to create a valid signature for a message of their choice. The *Probabilistic
    Signature Scheme (PSS)* defined as RSASSA-PSS (RSA Signature Scheme with Appendix)
    in RFC 3447 prevents such attacks.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: PSS injects additional random padding into the input data of the signature scheme—namely,
    the hash value of the message to be signed. Again, two hash functions and a predefined
    encoding are necessary to generate a padded version of the message’s hash. During
    verification, the intermediate values have to be restored and the padding has
    to be checked for correctness in order to validate a signature.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: PSS 在签名方案的输入数据中注入额外的随机填充，即要签名的消息的哈希值。再次强调，生成消息哈希的填充版本需要两个哈希函数和预定义的编码。在验证过程中，必须恢复中间值并检查填充是否正确，以验证签名的有效性。
- en: '**Diffie-Hellman Key Exchange**'
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Diffie-Hellman密钥交换**'
- en: When only symmetric cryptography was available, people had to exchange keys
    over *secure channels*—in person, with sealed letters, or over an already protected
    communication line. The process was pretty inconvenient and had several practical
    pitfalls.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当只有对称密码学可用时，人们必须通过*安全通道*交换密钥——面对面、密封信件或已保护的通信线路。这一过程非常不便，且存在多个实际缺陷。
- en: Luckily, in 1976, Whitfield Diffie and Martin Hellman published their idea on
    how to establish a *shared secret* between two parties that are able to communicate
    only over an *insecure channel*, which is now commonly known as the *Diffie-Hellman
    (DH) key exchange*. Instead of generating a key at a specific location and then
    applying a *key-transport* mechanism (for example, RSA encryption), DH creates
    the shared key by using a *key-agreement* protocol between two entities.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，1976年，Whitfield Diffie和Martin Hellman发表了他们的想法，介绍了如何在*不安全通道*上建立两个只能通过*不安全通道*进行通信的当事方之间的*共享秘密*，现在通常被称为*Diffie-Hellman
    (DH)密钥交换*。DH不是在特定位置生成密钥，然后应用*密钥传输*机制（例如RSA加密），而是通过两个实体之间的*密钥协商*协议创建共享密钥。
- en: '***The Mathematical Beauty***'
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数学之美***'
- en: The math behind DH is based on a group ![Image](../images/common-01.jpg), where
    all operations are performed modulo a prime *p* and the primitive element is denoted
    as *g*. [Figure 2-14](ch02.xhtml#ch02fig014) illustrates the process of establishing
    a shared secret.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: DH背后的数学基础是基于一个群 ![图片](../images/common-01.jpg)，在此群中所有操作都是模素数*p*进行的，原始元素被标记为*g*。[图2-14](ch02.xhtml#ch02fig014)说明了建立共享秘密的过程。
- en: '![Image](../images/02fig14.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/02fig14.jpg)'
- en: '*Figure 2-14: The steps in a Diffie-Hellman key exchange*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-14: Diffie-Hellman密钥交换的步骤*'
- en: First, both parties, commonly named Alice and Bob, choose secret numbers *a*
    and *b*, respectively ➊. Then, they derive the corresponding public values *A*
    and *B* ➋ and exchange them ➌. Afterward, they raise the public value of the other
    party to the power of their own private value ➍ to obtain the shared secret *k[AB]*.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，双方通常称为Alice和Bob，分别选择秘密数*a*和*b* ➊。然后，他们派生相应的公共值*A*和*B* ➋并交换它们 ➌。随后，他们将对方的公共值提升到他们自己的私密值的幂次
    ➍ 以获得共享秘密*k[AB]*。
- en: 'The security of DH relies on the *discrete logarithm problem (DLP)*: it’s hard
    to obtain *a* from *A* = *g^a* mod *p*. Deriving the private number *a* from the
    publicly transferred value *A* clearly would break the security of this protocol.
    However, since that’s practically impossible, attackers eavesdropping on the DH
    protocol don’t receive any helpful information. The achieved security level in
    relation to DH key sizes is practically the same as for RSA.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: DH 的安全性依赖于*离散对数问题 (DLP)*：从*A* = *g^a* mod *p*中获得*a*是困难的。从公开传输的值*A*中推导出私密数*a*显然会破坏该协议的安全性。然而，由于这几乎是不可能的，窃听DH协议的攻击者不会获得任何有用的信息。与RSA相比，关于DH密钥大小的实现安全级别实际上是相同的。
- en: '***Man-in-the-Middle Attacks***'
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***中间人攻击***'
- en: 'This basic version of DH is also called *anonymous Diffie-Hellman* because
    Alice and Bob can’t verify each other’s identity. This fact can be exploited by
    an adversary through a *man-in-the-middle (MITM)* attack: a malicious actor intercepts
    the communication between the original parties, drops their exchange of public
    values *A* and *B*, and instead performs one DH protocol run with Alice and one
    with Bob. In the end, Alice and Bob think that their key agreement was successful
    and they can communicate securely. However, they now both share a key with the
    attacker, who is able to read and manipulate all information flowing between them.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this problem is the introduction of *authenticated Diffie-Hellman*,
    which is based on the assumption that Alice and Bob each have a long-term public-key
    pair they can use to prove their identities to each other by exchanging digitally
    signed values of *A* and *B*. In this case, an MITM attacker would be unable to
    slip in between without being noticed. In variations of this approach, other protocol
    data is signed and verified, but it’s always essential to authenticate the other
    party before computing and using the shared secret.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: A second property of DH is that you shouldn’t regard the values *a* and *b*
    as long-term keys. Reusing them for multiple key-agreement runs violates the common
    requirement of *perfect forward secrecy (PFS)*. This means that session keys established
    during a key exchange should still be secure, even if long-term keys are compromised
    in the future. You should consider the private numbers *a* and *b* to be *ephemeral
    keys* and use them only once. The corresponding version of DH is often called
    *Diffie-Hellman Ephemeral (DHE)*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: You can find details on Diffie-Hellman variants and other key-agreement schemes
    in NIST’s *Special Publication 800-56A*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '**Elliptic-Curve Cryptography**'
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'RSA and DH provide many meaningful mechanisms for asymmetric cryptography,
    but they come with two strong downsides: long keys and significant performance
    demand. The field of *elliptic-curve cryptography (ECC)*, founded in 1985, promised
    to provide asymmetric cryptography with noticeably reduced drawbacks.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: However, about 20 years passed before it was widely used in practice. The math
    behind ECC is rather complex compared to RSA and DH, and the adoption of ECC was
    impeded by the Certicom company, which held a series of patents that had to be
    licensed in case of ECC usage. Luckily, most of those patents have expired by
    now.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '***The Math Behind the Curves***'
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In a nutshell, *elliptic curves* are considered to be a group of points with
    x- and y-coordinates—for example, denoted as *P*(*x*, *y*). The values of *x*
    and *y* are integers of a group modulo a prime *p*, often denoted as *GF*(*p*),
    a *Galois field*. The equation of an elliptic curve describes all the points that
    are part of it.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'In cryptography, only a few curve equations are of practical relevance. The
    following is used for *Weierstrass curves* like P-256 standardized by NIST and
    has parameters *a* and *b*:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '*x*² = *x*³ + *ax* + *b*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '*Montgomery curves* use parameters *A* and *B*, and they’re especially known
    because of the prominent member Curve25519\. The following equation describes
    them:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '*By*² = *x*³ + *Ax*² + *x*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '*Edwards curves*, with their parameter *d*, are another interesting type of
    curve, and Ed448-Goldilocks is based on it. Here’s the general equation for these
    curves:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '*x*² + *y*² = 1 + *dx*²*y*²'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'You can process points on elliptic curves in three ways:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '**Point addition**    Add two points *P* and *Q* to obtain a new point *R*
    on the same curve: *R* = *P* + *Q*.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '**Point doubling**    Multiply a given point *P* by 2 to obtain a new point
    *R*: *R* = 2*P*.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '**Scalar multiplication**    Take a point *P* and multiply it with an integer
    (scalar) *k* to yield a new curve point *R*: *R* = *kP*.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: The scalar multiplication in ECC is similar to the modular exponentiation for
    RSA. Also, the naive approach to scalar multiplication, which means adding a point
    *k* – 1 times, is infeasible for *k* being a large number with hundreds of bits.
    Therefore, a similar algorithm to square-and-multiply, namely *double-and-add*,
    has to be used to compute it efficiently. Putting it simply, *k* is processed
    bit by bit, and for every bit position, a point doubling is performed. If a bit
    is 1, an extra point addition is executed. Altogether, this enables the practical
    usage of ECC crypto primitives.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Elliptic curves are designed in a way that the *elliptic-curve discrete logarithm
    problem (ECDLP)* is difficult. The name suggests that it’s similar to the DLP
    that’s the foundation of DH, and it is. However, in the ECC world, you can describe
    the problem as finding the scalar *k* given points *P* and *R* = *kP*. [Table
    2-2](ch02.xhtml#ch02tab02), derived from NIST’s *Special Publication 800-57* from
    2022, shows the striking difference of the ECDLP compared to the underlying problems
    of RSA and DH.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-2:** Security Estimation of ECC'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '| **Security level** | **Key size** | **Key size of RSA/DH (for comparison)**
    |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
- en: '| ≤ 80-bit | 160-bit | 1,024-bit |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
- en: '| 112-bit | 224-bit | 2,048-bit |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
- en: '| 128-bit | 256-bit | 3,072-bit |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
- en: '| 192-bit | 384-bit | 7,680-bit |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
- en: '| 256-bit | 512-bit | 15,360-bit |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
- en: ECC achieves the same security level with much lower key sizes. Additionally,
    with increasing key lengths, the corresponding security level rises *linearly*,
    so doubling the curve size from 256-bit to 512-bit also leads to twice the security
    level.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '***The Agony of Choice***'
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In contrast to many other cryptographic algorithms, ECC requires an implementer
    to choose not only a key size but also a specific elliptic curve to be used. Certain
    mathematical requirements have to be fulfilled by “safe” curves, which is why
    it’s reasonable to choose one from the common, standardized options that have
    undergone rigorous analysis.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, a criterion that you can consider in the selection process
    is the origin of the curve parameters. Although the US National Security Agency
    (NSA) created the prime curve P-256, and the NIST standardized it in 2000, it’s
    one of the most popular curves in practice. Its parameter *b* is a 256-bit number,
    and only the NSA knows how and why it was chosen. The same is true for the other
    NIST curves: P-192, P-224, P-384, and P-521\. It might not be a critical issue,
    but maybe a relevant one, for devices operating in critical infrastructures.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Curve25519 is currently the most popular and most trustworthy elliptic curve.
    It was proposed by Bernstein in 2006 and is prominent because of two properties.
    First, it has a strong focus on high performance in software implementations.
    Second, it doesn’t rely on randomly chosen or obscure curve parameters. In the
    future, Edwards curves like Ed448-Goldilocks and Curve41417 also might be of interest
    because they offer a security level above 200-bit.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '***Practical Applications of ECC***'
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the most common applications of ECC is a digital signature based on the
    *Elliptic-Curve Digital Signature Algorithm (ECDSA)* as defined in *FIPS 186-5*.
    The basic setting for this use case is that two parties have agreed on a specific
    curve and its parameters. The signing entity holds the private key *d*, a secret
    integer, and the verifier has access to the corresponding public key *P* = *dG*,
    where *G* is the base point of the selected curve.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: For signature generation, the signer hashes the message, chooses a random ephemeral
    key, and processes both together to obtain a unique signature consisting of two
    values with a total size of twice the curve order—for example, 512 bits, or 64
    bytes, for a 256-bit curve. (The details of the verification process are rather
    complex and beyond the scope of this book.)
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, ECDSA signatures are preferable to RSA signatures for performance
    and security reasons, except for a single case: if the signature verification
    has the highest priority, and signature generation happens only rarely—for example,
    when signing a firmware image once in the development process—and verification
    is time-critical because it happens during the device’s boot process.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Besides digital signatures, ECC is an inherent part of modern key-exchange and
    key-agreement schemes as described in NIST’s *Special Publication 800-56A*. They’re
    also known as *Elliptic-Curve Diffie-Hellman (ECDH)* and *Elliptic-Curve Diffie-Hellman
    Ephemeral (ECDHE)*. There, the modular exponentiation of DH is replaced by a scalar
    multiplication based on an elliptic curve. The rest is pretty similar to DH. Again,
    this leads to a significant performance gain compared to classical DH, which is
    especially interesting when you need to perform a high number of key-agreement
    handshakes regularly, such as a server handling lots of connections.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, you can use ECC for public-key encryption, but it’s rarely
    used in practice. The *Elliptic-Curve Integrated Encryption Scheme (ECIES)* is
    meant for exactly that purpose. In a nutshell, it uses a recipient’s public key
    to generate a shared ECDH secret and derives a symmetric key from it. This key
    is then used to encrypt a message by an AE cipher, producing a ciphertext and
    an authentication tag.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter started off with crypto fundamentals like Kerckhoffs’s principle
    that a cryptographic key should be the only secret in a cryptosystem, followed
    by a discussion that security levels are merely a description of the potential
    search space an attacker has to face.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: I covered the area of symmetric encryption based on the popular AES algorithm
    and common operation modes in detail because it’s omnipresent in security. Hash
    functions like SHA-256, integrity-protecting MAC algorithms, and efficient AE
    schemes like AES-GCM complete the modern tool-box of symmetric cryptography.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'The introduction of asymmetric cryptography based on RSA and DH has enabled
    amazing possibilities to protect communication and devices: public-key encryption,
    digital signatures, and secure key agreements over insecure channels. Further,
    the field of ECC has enhanced the performance of these mechanisms significantly.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '*Post-quantum cryptography* goes beyond the scope of this book, but it might
    be a topic that will challenge existing asymmetric crypto schemes in the future,
    and it will be inevitable if a universal quantum computer is built. NIST’s standardization
    process for post-quantum cryptography (*[https://csrc.nist.gov/projects/post-quantum-cryptography](https://csrc.nist.gov/projects/post-quantum-cryptography)*)
    is still ongoing but worth following.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: If you’re interested in learning more about the inner workings of cryptography,
    Jean-Philippe Aumasson’s *Serious Cryptography* (No Starch Press, 2017; second
    edition forthcoming) and *Understanding Cryptography* by Christof Paar and Jan
    Pelzl (Springer, 2009) are good resources.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
