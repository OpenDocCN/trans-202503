- en: '**2'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CRYPTOGRAPHY**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The guarantees and powers of cryptographic algorithms often sound like magic.
    A layperson isn’t able to verify any of these properties and neither are most
    engineers. In some cases, even cryptographers can’t prove the security of a scheme,
    but they assume or believe that the underlying mathematical problem is hard to
    solve. Nevertheless, cryptographic algorithms are necessary tools that every developer
    and architect should know how to use.
  prefs: []
  type: TYPE_NORMAL
- en: The word *cryptography* comes from the combination of the Greek words *kryptós*
    and *gráphein*, which translate to *secret writing*. Nowadays, however, cryptography
    is much more than the protection of confidential messages. It’s also used to protect
    the integrity of files, to derive reliable fingerprints of gigabytes of data,
    and to sign documents and code digitally.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter provides a pragmatic overview of modern cryptographic algorithms
    and their practical properties while keeping mathematical formulas at a minimum.
    We’ll start with some basic principles, then take a peek at typical symmetric
    algorithms and hash functions. A look at the intriguing field of asymmetric crypto
    concludes the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**Kerckhoffs’s Principle**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Auguste Kerckhoffs was a Dutch cryptographer in the 19th century. In the security
    community, he’s known for his proposals to improve practical cryptography in the
    French military. Among the six recommendations he published in 1883, one became
    famously known as *Kerckhoffs’s principle*: “The system must not require secrecy
    and can be stolen by the enemy without causing trouble.”'
  prefs: []
  type: TYPE_NORMAL
- en: For cryptographic algorithms, this principle means that procedures like encryption,
    decryption, or signing should not be kept secret and that no one should rely on
    this secrecy to guarantee security. The only secret in the system should be a
    secret cryptographic key.
  prefs: []
  type: TYPE_NORMAL
- en: Today, this point doesn’t seem worth mentioning because all relevant crypto
    algorithms are standardized on a national or international level, and all are
    publicly available for everyone to read and analyze. However, when it comes to
    engineering software and devices, some developers still break with this principle.
    They invent their own “crypto” procedures and argue that security is achieved
    “because nobody knows how it works.” They sometimes do this for performance reasons,
    but more often it’s the result of a lack of solid crypto knowledge. However, the
    phrase “can be stolen by the enemy” could also be interpreted as “can be reverse
    engineered by an attacker,” which would break the security of such a “solution.”
  prefs: []
  type: TYPE_NORMAL
- en: If you catch yourself considering the implementation of a custom function probably
    including some magic values and XOR operations to achieve security, stop thinking
    about it immediately! It’s called *security by obscurity* and it will only get
    you into trouble.
  prefs: []
  type: TYPE_NORMAL
- en: '**Levels of Security**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Cryptographic algorithms have several parameters and properties that describe
    and differentiate them, but one is central: their *security level* that’s indicated
    by a certain bit length—for example, 64-bit, 80-bit, or 256-bit. This practical
    gauge allows you to compare algorithms and their cryptographic strength. But what
    does it actually mean if a specific algorithm has a 128-bit security level?'
  prefs: []
  type: TYPE_NORMAL
- en: The level describes the effort an attacker needs to expend in order to break
    the algorithm’s protection goal. Usually, that effort involves testing large sets
    of data for a correct solution, such as a secret decryption key. If an algorithm
    has a 128-bit security level, the *search space* for an attacker is 128 bits large,
    which means that the attacker has to perform a maximum of 2^(128) tries in order
    to identify the needle in the haystack.
  prefs: []
  type: TYPE_NORMAL
- en: For well-designed symmetric ciphers, the key length can be translated directly
    into an algorithm’s security level. However, security levels are subject to change
    if cryptographers find algorithmic flaws. In that case, the algorithm’s security
    level might become significantly less than the key length.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, keep in mind that attackers continuously make performance gains.
    Modern *brute-force* attacks make use of thousands of cloud instances to efficiently
    search for a key. In recent years, attacks on 64-bit secrets have been successful,
    increasing the need for a solid choice of security level.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to engineer secure and long-lasting devices, keep up with the current
    recommendations of crypto security levels (see *[https://www.keylength.com](https://www.keylength.com)*).
    As a rule of thumb at the time of writing, a 128-bit security level is considered
    suitable for practical security engineering, and 256-bit is typically used for
    high-security applications.
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Although the security level of symmetric ciphers often equals their key length,
    that’s not always the case. In addition, security levels for asymmetric crypto
    are completely different; keys with 2,048 bits might offer only 112-bit security,
    for example, as you’ll see later in this chapter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Symmetric Ciphers**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The origin of symmetric cryptography dates back to the famous Roman named Caesar,
    who is said to have used a simple letter-substitution cipher to make messages
    incomprehensible. Since then, the basic principle of symmetric crypto hasn’t changed.
    It follows the idea that a *plaintext* message can be encrypted to a *ciphertext*
    by using the encryption algorithm `Encrypt``()` and a *cryptographic key*, as
    illustrated in [Figure 2-1](ch02.xhtml#ch02fig01).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/02fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-1: The basic principle of symmetric cryptography*'
  prefs: []
  type: TYPE_NORMAL
- en: The decryption operation `Decrypt``()` uses *the same secret key* to reverse
    the encryption and yield the original message, hence the term *symmetriccryptography*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Data Encryption Standard***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Fast-forward 2,000 years. In many cases, symmetric encryption is now handled
    by *block ciphers* that take one block of plaintext and encrypt it to a block
    of ciphertext. One of the first publicly standardized block ciphers was the *Data
    Encryption Standard (DES)*, also known as the *Data Encryption Algorithm (DEA)*.
    It’s based on a so-called *Feistel network* and has only a 56-bit key. Today,
    with dedicated hardware, this key space can be completely searched within hours,
    which makes it absolutely insecure for modern applications.
  prefs: []
  type: TYPE_NORMAL
- en: '*Triple DES (3DES)* is an extension of DES that uses three 56-bit keys and
    applies DES three times to a plaintext or ciphertext. Given the total key length
    of 168 bits, the block size of 64 bits, and known cryptographic weaknesses, 3DES
    is considered to achieve only a 112-bit security level and should no longer be
    used in new designs.'
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Some modern crypto libraries still provide DES and 3DES. However, if you don’t
    have very good reasons—for example, indispensable backward compatibility—do not
    use any DES-based algorithm.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Advanced Encryption Standard***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first choice for symmetric encryption is currently the *Advanced Encryption
    Standard (AES)*, originally named *Rijndael*. This successor of DES was standardized
    as Federal Information Processing Standard (FIPS) 197 and ISO/IEC 18033-3 after
    a cryptographic competition process that was organized by NIST lasted from 1997
    to 2000\. AES is based on a substitution-permutation network (SPN), has a block
    length of 128 bits, and can be operated with three key lengths: 128-bit, 192-bit,
    and 256-bit.'
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Figure 2-2](ch02.xhtml#ch02fig02), AES operates on a 4×4 byte matrix,
    known as the *AES state*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/02fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-2: A matrix visualization of the AES state*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the selected key size, this state is processed for a certain number
    of rounds: 10 for 128-bit keys, 12 for 192-bit keys, and 14 for 256-bit keys.
    Here’s the basic encryption process based on the main AES functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Key expansion**    The original key is expanded to multiple 128-bit subkeys,
    one for each round plus an initial one.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Initial round**    As a preparation step, the function `AddRoundKey``()`
    is applied to the input plaintext to obtain a new state.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Main rounds**    Depending on the key lengths, 9, 11, or 13 main rounds are
    performed with the following operations happening consecutively: `SubBytes``()`,
    `ShiftRows``()`, `MixColumns``()`, and `AddRoundKey``()`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Final round**    In the last round, only `SubBytes``()`, `ShiftRows``()`,
    and `AddRoundKey``()` are called. `MixColumns``()` is omitted.'
  prefs: []
  type: TYPE_NORMAL
- en: The four operations that enable this strong encryption are pretty simple. The
    `SubBytes()` function substitutes each byte in the AES state with a corresponding
    byte resulting from a lookup table called an *S-box*, as shown in [Figure 2-3](ch02.xhtml#ch02fig03).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/02fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-3: The* SubBytes() *transformation*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-4](ch02.xhtml#ch02fig04) shows that the `ShiftRows()` transformation
    shifts the second row of the AES state matrix 1 byte to the left, the third row
    2 bytes to the left, and the fourth row 3 bytes to the left. The first row remains
    unchanged.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/02fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: The* ShiftRows() *transformation*'
  prefs: []
  type: TYPE_NORMAL
- en: The `MixColumns()` operation applies a linear transformation to each column
    of the AES state matrix, as depicted in [Figure 2-5](ch02.xhtml#ch02fig05). This
    yields 4 resulting bytes representing the new state of each column, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/02fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: The* MixColumns() *transformation*'
  prefs: []
  type: TYPE_NORMAL
- en: Every round, the `AddRoundKey()` operation XORs each byte of the AES state with
    the corresponding byte of a given round key, as illustrated in [Figure 2-6](ch02.xhtml#ch02fig06).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/02fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: The* AddRoundKey() *transformation*'
  prefs: []
  type: TYPE_NORMAL
- en: For decryption, the order of subkeys is reversed, and the inverse functions
    of `SubBytes()`, `ShiftRows()`, `MixColumns()`, and `AddRoundKey()` are called.
  prefs: []
  type: TYPE_NORMAL
- en: After more than 20 years and extensive research, nobody has discovered an attack
    on the AES architecture that has practical relevance. It’s available in all major
    crypto software libraries, and systems as small as 8-bit microcontrollers can
    use it with reasonable performance. AES is used for disk encryption in laptops,
    but also for payload encryption in secure internet communication. Whenever it
    comes to symmetric encryption, you should choose AES unless you have serious reasons
    not to do so.
  prefs: []
  type: TYPE_NORMAL
- en: '**Modes of Operation**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since AES is a block cipher, it naturally encrypts or decrypts only a single
    block, but many applications have much more input data than just one 128-bit block.
    Therefore, AES has to be used in a certain *mode of operation* that defines the
    procedures to encrypt and decrypt multiple blocks of data. The modes introduced
    here are defined in NIST’s *Special Publication 800-38A*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Electronic Codebook Mode***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Some of you might wonder, “Why not just encrypt the data block by block?” That
    trivial approach is exactly what the *Electronic Codebook (ECB) mode* does. It
    takes the first 128 bits of a message as the first plaintext block, encrypts it
    to the first 128 bits of ciphertext, and continues in the same way with as many
    chunks of 128-bit data as available, as shown in [Figure 2-7](ch02.xhtml#ch02fig07).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/02fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Encryption in ECB mode*'
  prefs: []
  type: TYPE_NORMAL
- en: However, the problem with this approach is that equal input data blocks are
    encrypted to equal ciphertext blocks. Therefore, the relation between blocks,
    which can also carry sensitive information, is preserved. [Figure 2-8](ch02.xhtml#ch02fig08)
    illustrates this phenomenon.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/02fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: Comparing ECB and Counter (CTR) modes*'
  prefs: []
  type: TYPE_NORMAL
- en: When images are encrypted in ECB mode, the plaintext pixels with the same values
    are still mapped to ciphertext pixels with identical values. The image information
    is still comprehensible. For other operation modes, such as Counter mode, things
    look different, as explained in “Counter Mode” on [page 34](ch02.xhtml#ch00lev2_22).
  prefs: []
  type: TYPE_NORMAL
- en: '***Cipher Block Chaining Mode***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *Cipher Block Chaining (CBC) mode* breaks the relation between plaintext
    and ciphertext by XORing the ciphertext of the first block with the plaintext
    of the second block, and so on. [Figure 2-9](ch02.xhtml#ch02fig09) shows the basic
    principle.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/02fig09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-9: Encryption in CBC mode*'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a security point of view, CBC mode is significantly better than ECB mode,
    but it has a new drawback: the dependency between subsequent encryptions makes
    parallel implementations less efficient, which limits performance.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Counter Mode***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An interesting mode that doesn’t permit a relation between ciphertexts but facilitates
    high-performance, multicore implementations is called *Counter (CTR) mode*. As
    illustrated in [Figure 2-10](ch02.xhtml#ch02fig010), the plaintext blocks themselves
    aren’t encrypted, but the concatenation of a *nonce (number used once)* and a
    counter value starting at 0.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/02fig10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-10: Encryption in CTR mode*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of this encryption is then XORed with the plaintext to obtain a
    ciphertext. For every further plaintext block, the counter value is incremented
    by one to support changing ciphertexts, as shown in [Figure 2-8](ch02.xhtml#ch02fig08)c.
    This approach even provides another advantage: both encryption and decryption
    utilize the `Encrypt()` function of the used block cipher. There’s no need to
    implement `Decrypt()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast to ECB mode, CBC and CTR modes require an additional input parameter:
    an *initialization vector (IV)* or a nonce. The rationale for both is to make
    every encryption unique, so they should never be used twice. Further, decryption
    is possible only if the receiver also has access to the corresponding IV or nonce.
    But since it doesn’t carry confidential data, transmitting it in cleartext is
    okay along with the ciphertext.'
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In practice, just setting an IV or a nonce to 0 or a fixed random number is
    tempting. However, doing so will significantly weaken the strength of this cryptographic
    primitive. Spend the additional effort to implement a suitable generator for unique
    values.*'
  prefs: []
  type: TYPE_NORMAL
- en: Together with the operation modes CBC and CTR, AES enjoys great popularity.
    However, other, more interesting symmetric ciphers might be helpful if you have
    special requirements. For example, the modern stream ciphers Salsa20 and ChaCha20,
    developed by cryptographer Daniel J. Bernstein, have simple designs and provide
    high performance in pure software implementations. If your hardware doesn’t support
    AES but you need to get the highest performance possible, these algorithms might
    be worth looking at.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hash Functions**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Hash functions are somewhat exotic in the pool of cryptographic algorithms.
    On their own, they don’t aim for one of the classic protection goals. Their objective
    is to map more or less arbitrarily large input data to a fixed-length, binary
    sequence called a *hash value*, or *digest*.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the design of such functions isn’t trivial. They have to fulfill a
    set of strong requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Preimage resistance**    The term *preimage* refers to the correct input
    data to a hash function that maps to a given hash value. This requirement says
    that an attacker shouldn’t be able to find such suitable input data for an existing
    hash value. This is why hash functions are also called *one-way functions*. Nobody
    should be able to invert them.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Second preimage resistance**    Further, a malicious actor who has access
    to a message and its hash value shouldn’t be able to find a *second preimage*—namely,
    another message that maps to the same hash.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Collision resistance**    Naturally, hash-value collisions must exist because
    the input space of a hash function is larger than its output space. The strongest
    assumption for hash functions is that finding any two messages that map to the
    same hash value should be *practically impossible*.'
  prefs: []
  type: TYPE_NORMAL
- en: By design, hash functions don’t use a secret key, which means that everyone
    can use them and apply them to all data at hand. Therefore, we have to determine
    the security level of hash functions differently. The security level is described
    as the amount of difficulty in finding collisions, which is again a kind of search-space
    problem, similar to finding the correct key for an encryption algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Based on the so-called *birthday paradox* and the *rho method*, cryptographers
    have shown that, for well-designed hash functions, we can estimate the security
    level to be half of their output size. For example, for a hash function with 160-bit
    output, the security level estimate is around 80-bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you might wonder why we need hash functions and their cryptographic
    mapping process for device security. The reason is simple: they’re part of many
    security applications like digital signature generation and verification, key-derivation
    algorithms, secure password storage, and many more.'
  prefs: []
  type: TYPE_NORMAL
- en: The first practical implementations of hash functions emerged in the 1990s.
    MD4, MD5, and SHA-1 are three prominent representatives. However, in the meantime,
    researchers have discovered ways to find collisions for those three (and others),
    so you shouldn’t use those legacy algorithms in modern designs anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, the most widely used family of hash functions is SHA-2, the successor
    to SHA-1\. It’s described in the *FIPS 180-4* standard and has four members: SHA-224,
    SHA-256, SHA-384, and SHA-512\. The numbers represent the output lengths of these
    functions, so SHA-224 is very similar to SHA-256 except for different initial
    values and the truncation of the final hash value to 224 bits. The same applies
    for SHA-384 in relation to SHA-512.'
  prefs: []
  type: TYPE_NORMAL
- en: SHA-256 processes 512 bits (sixteen 32-bit words) in 64 rounds. It exhibits
    a 128-bit security level against collisions and is, therefore, a secure and efficient
    option. SHA-512 is intended for high-security areas like federal and military
    purposes. It works on 1,024 bits (sixteen 64-bit words) for 80 rounds and exhibits
    a lower performance compared to SHA-256.
  prefs: []
  type: TYPE_NORMAL
- en: Since the SHA-2 family is based on an architecture similar to MD5 and SHA-1,
    cryptographers are skeptical about its long-term security. In 2007, NIST announced
    a cryptographic competition in order to find a candidate to be standardized as
    SHA-3\. One important requirement was that the design of the algorithm should
    be based on primitives other than SHA-2\. Five years later, the *Keccak* algorithm
    was named as the winning hash function. Subsequently, it has been published as
    the new SHA-3 standard in *FIPS 202*.
  prefs: []
  type: TYPE_NORMAL
- en: 'SHA-3 is also available in four versions: SHA3-224, SHA3-256, SHA3-384, and
    SHA3-512\. Again, the lengths of their output values in bits is denoted by the
    numbers after the hyphen in their names. Their performance and security level
    is comparable to those of their SHA-2 counterparts, but they’re based on a completely
    different algorithmic foundation, as intended by NIST.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Even if SHA-3 is the newer standard, you don’t need to migrate from SHA-2
    to SHA-3 soon. They are comparable, so you are free to decide which to use depending
    on the libraries you need and application requirements you have.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Message Authentication Codes**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A common misconception about encryption is that it protects against manipulation.
    It doesn’t. Even if you use AES and a state-of-the-art mode of operation, and
    an attacker can’t read anything from the resulting ciphertext, that attacker is
    still able to manipulate single bits or whole messages without being detected
    by the block cipher. Encryption protects only confidentiality, not integrity.
  prefs: []
  type: TYPE_NORMAL
- en: A *message authentication code (MAC)*, also known as a *message integrity code
    (MIC)*, is another primitive from the symmetric cryptography tool belt, and it’s
    meant to protect message integrity and authenticity. It creates an *authentication
    tag* from a message and a secret key. Afterward, everyone in possession of the
    secret key can verify the correctness of a message and its corresponding authentication
    tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'A popular method for generating MACs is a *hash-based message authentication
    code (HMAC)*. The HMAC construction, also known as a *keyed hash function*, is
    defined in RFC 2104\. The following formula shows its composition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*HMAC* = *hash*((*key* ⊕ *opad*) ∥ *hash*((*key* ⊕ *ipad*) ∥ *message*))'
  prefs: []
  type: TYPE_NORMAL
- en: The *inner padding (ipad)* is a byte string, `0x3636...36`, containing the same
    number of bytes as the input block size of the used hash function. It is XORed
    with a key of at least the security level of the underlying hash function. The
    result is concatenated with the message to protect before it is hashed altogether.
    The digest of this operation is then appended to the XOR between the same key
    and the *outer padding (opad)*, a byte string `0x5c5c...5c` of the same length
    as the ipad. Hashing the resultant bytes leads to the final HMAC value.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, if SHA-256 is chosen as an HMAC’s hash function, the cryptographic
    algorithm is then called HMAC-SHA-256\. The length of the inner and outer padding
    is 512 bits, or 64 bytes. The key should be at least 128 bits long, and the HMAC
    length is 256 bits, or 32 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In practice, you might come across HMAC constructions that are built upon
    MD5 or SHA-1\. Even if collision attacks have been demonstrated for these hash
    functions, they’re still valid to be used for practical HMAC implementations because
    an attacker would have to acquire an enormous number of authentication tags resulting
    from the same single secret key to break a specific instance.*'
  prefs: []
  type: TYPE_NORMAL
- en: A *cipher-based message authentication code (CMAC)* uses a block cipher in CBC
    mode to compute MACs. A variant that’s based on AES, called *AES-CMAC*, is specified
    in RFC 4493\. There, the message to protect is processed with AES in CBC mode
    except for the last message block, which is specifically treated for security
    reasons. The final ciphertext is taken as the authentication tag, and all other
    ciphertexts are discarded.
  prefs: []
  type: TYPE_NORMAL
- en: This solution isn’t as popular as the HMAC construction, but it might be interesting
    from a performance point of view, especially on devices that have built-in AES
    accelerators.
  prefs: []
  type: TYPE_NORMAL
- en: '**Authenticated Encryption**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For secure communication, confidentiality, integrity, and authenticity are
    common protection goals. In the previous sections, we considered how we can use
    block ciphers and MACs to achieve these goals, but two practical questions still
    remain: “How do we combine them?” and “Can combinations of ciphers and MACs be
    more efficient than using them separately?”'
  prefs: []
  type: TYPE_NORMAL
- en: '***Strategies and Requirements***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When combining encryption and MAC generation, we can use three strategies.
    All three assume the use of secure ciphers and MAC algorithms and that each of
    them uses its own key, but differ in the order of the performed operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Encrypt-and-MAC**    This approach generates a ciphertext and an authentication
    tag from the same plaintext in parallel, which could yield a performance advantage.
    However, applying a MAC algorithm to plaintext might lead to information leakage
    about the plaintext by the authentication tag because MAC algorithms are not designed
    to protect the confidentiality of their input data. However, for modern MACs like
    HMAC-SHA-256, this problem doesn’t exist. A second issue is that the ciphertext’s
    integrity isn’t protected. An altered ciphertext has to be decrypted first to
    detect the manipulation, which could allow an attacker to exploit implementation
    weaknesses in the decryption routine.'
  prefs: []
  type: TYPE_NORMAL
- en: '**MAC-then-encrypt**    In this variant, an authentication tag is generated
    from the plaintext and appended to it. The result is then encrypted to obtain
    the final ciphertext. In this case, the MAC algorithm can’t leak any information,
    but the ciphertext can still be manipulated without a possibility to detect it
    before decryption.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Encrypt-then-MAC**    This is a strong strategy for integrity and confidentiality
    protection of messages. First, the plaintext is encrypted before the MAC is generated
    from the resulting ciphertext. With this approach, the authentication tag can’t
    leak any information about the plaintext, and at the same time, we can verify
    the correctness of the ciphertext bits before decrypting the given data.'
  prefs: []
  type: TYPE_NORMAL
- en: Crypto practitioners are always on the lookout for performance gains because
    security measures should have as little performance overhead as possible. Therefore,
    it’s not surprising that the field of *authenticated encryption (AE)* emerged
    from the combination of ciphers and MACs to enhance processing speed.
  prefs: []
  type: TYPE_NORMAL
- en: In comparison to “normal” ciphers, AE algorithms take plaintext and compute
    both ciphertext and an authentication tag during encryption. At decryption, the
    integrity of the ciphertext and authentication tag are verified before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: An interesting extension of AE is called *authenticated encryption with associated
    data (AEAD)*, which allows you to integrate additional plaintext data into the
    process of generating the authentication tag. Examples are sequence numbers or
    metadata that don’t require confidentiality. The integrity of this associated
    data is achieved while binding it to the yielded ciphertext.
  prefs: []
  type: TYPE_NORMAL
- en: '***Galois Counter Mode***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Today, the most popular AEAD algorithm is the AES cipher operated in the special
    *Galois Counter mode (GCM)*, which follows the encrypt-then-MAC principle and
    is specified in NIST’s *Special Publication 800-38D*. [Figure 2-11](ch02.xhtml#ch02fig011)
    depicts its basic functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/02fig11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-11: An authenticated encryption in GCM*'
  prefs: []
  type: TYPE_NORMAL
- en: The confidentiality protection is very similar to CTR mode, except GCM doesn’t
    use the result of the first encryption to process plaintext, but rather does it
    in the final step of authentication-tag generation. The MAC generation is based
    on the hash function `GHASH`, which basically consists of a series of multiplications
    in a binary Galois field with a fixed parameter, the *hash subkey*. This subkey
    is derived by encrypting the all-zeros plaintext block with the AES key used for
    encryption.
  prefs: []
  type: TYPE_NORMAL
- en: The nonce or initialization vector of GCM is meant to be a unique 96-bit binary
    string. GCM is pretty fragile regarding nonce reuse, which means that an attacker
    can forge authentication tags if they have access to two authentication tags that
    were generated using the same key and nonce. Therefore, the implementation of
    a robust nonce generation is essential for GCM.
  prefs: []
  type: TYPE_NORMAL
- en: Besides AES-GCM, you might encounter many more AE algorithms in the field. Examples
    are the Counter with CBC-MAC (CCM) mode as detailed in NIST’s *Special Publication
    800-38C* and the Offset Codebook (OCB) mode designed by Phil Rogaway. The combination
    of the stream cipher ChaCha20 and the MAC algorithm Poly1305, both designed by
    Bernstein, also serves as a common AEAD solution. It’s especially efficient in
    software-only implementations and has been specified in RFC 8439.
  prefs: []
  type: TYPE_NORMAL
- en: Further, the CAESAR competition (*[https://competitions.cr.yp.to/caesar-submissions.xhtml](https://competitions.cr.yp.to/caesar-submissions.xhtml)*)
    that ran from 2013 to 2019 yielded another set of innovative AEAD designs—for
    example, lightweight implementations on resource-constrained devices or high-performance
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: '**Asymmetric Cryptography**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In contrast to using a single secret key, the basic idea of *asymmetric cryptography*
    is having a pair of keys and using each key for only a distinct operation that
    complements the other. For example, everyone uses one key, called a *public key*,
    to encrypt data ([Figure 2-12](ch02.xhtml#ch02fig012)). The second key, called
    a *private key*, belongs to a single entity, and only that entity is able to decrypt
    the previously generated ciphertext by using its private key. Asymmetric cryptosystems
    are also known as *public-key cryptography*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/02fig12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-12: Encryption with asymmetric cryptography*'
  prefs: []
  type: TYPE_NORMAL
- en: However, asymmetric cryptography is useful for more than confidentiality protection.
    The private-key operation can also generate a *digital signature*, which is a
    kind of checksum for given data that only the unique private key of a specific
    entity can compute. Everyone in possession of the corresponding public key would
    be able to verify this signature, which protects not only the protected data’s
    authenticity but also its integrity, because manipulations of the data or signature
    would lead to a verification failure. [Figure 2-13](ch02.xhtml#ch02fig013) illustrates
    the basic idea.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/02fig13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-13: The generation and verification of a digital signature*'
  prefs: []
  type: TYPE_NORMAL
- en: These fundamentally different opportunities have paved the way for many security
    features we’ve come to take for granted, like secure communication over the internet.
    To understand the basics of the two most popular representatives of asymmetric
    cryptography, there is no way around a little bit of math, as I’ll show in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: '**The RSA Cryptosystem**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first and still most common asymmetric crypto scheme was published in 1977
    and is named after its inventors: *Rivest-Shamir-Adleman (RSA)*. To achieve the
    typical asymmetry between public and private operations, RSA implements a *trapdoor
    function*. With this approach, you can transform data A to data B easily, but
    deriving data A from data B is practically impossible unless you know the trapdoor.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Basic RSA Math***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'RSA is based on modular arithmetic, which means integer calculations that wrap
    around if they reach a limit called the *modulus*. The following formula describes
    all the magic behind RSA encryption:'
  prefs: []
  type: TYPE_NORMAL
- en: '*y* = *x^e* mod *n*'
  prefs: []
  type: TYPE_NORMAL
- en: The *modular exponentiation* of the *x* plaintext and *e*, the *public exponent*,
    compute the *y* ciphertext. The *n* denotes the modulus.
  prefs: []
  type: TYPE_NORMAL
- en: 'Decryption works in a very similar way:'
  prefs: []
  type: TYPE_NORMAL
- en: '*x* = *y^d* mod *n*'
  prefs: []
  type: TYPE_NORMAL
- en: The modular exponentiation processes the *y* ciphertext with *d*, the *private
    exponent*, to obtain the *x* plaintext. However, the naive way of exponentiation,
    which means performing *d* – 1 multiplications by *y*, is completely impossible
    for *d* being a number with thousands of bits. You can overcome this obstacle
    with an algorithm called *square-and-multiply*. That algorithm basically operates
    bit by bit on the binary representation of the exponent. In every step, the algorithm
    performs a squaring operation, but if a given bit is 1, it carries out an additional
    multiplication, making RSA a practically usable crypto mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'The numbers *n* and *e* are usually considered part of the public key, and
    *d* corresponds to the private key in RSA. Their described behavior is possible
    only because *d* and *e* have a special relation that is established during RSA
    key generation. In its first step, two large prime numbers *p* and *q* have to
    be chosen randomly. Their multiplication leads to the modulus *n* = *pq*. Using
    *n*, you can derive the result of Euler’s phi function Φ(*n*):'
  prefs: []
  type: TYPE_NORMAL
- en: Φ(*n*) = (*p* – 1)(*q* – 1) = *pq* – *p* – *q* + 1 = (*n* + 1) – (*p* + *q*)
  prefs: []
  type: TYPE_NORMAL
- en: 'This value is essential for the RSA cryptosystem and its security because the
    inverse relation between *e* and *d* is achieved in a group modulo Φ(*n*):'
  prefs: []
  type: TYPE_NORMAL
- en: '*ed* mod Φ(*n*) = 1'
  prefs: []
  type: TYPE_NORMAL
- en: In practice, *e* = 65537 = (10000000000000001)[2] is a common choice because
    of its shortness and the low number of 1 bits, both contributing to higher performance
    with the square-and-multiply algorithm. After *e* is chosen, the final step of
    key generation is to compute *d* as the inverse of *e* modulo Φ(*n*).
  prefs: []
  type: TYPE_NORMAL
- en: Knowing these details, it might become clearer why RSA is often mentioned in
    the same sentence with the *integer factorization problem*. This mathematical
    consideration suggests that finding the factors of large numbers is difficult.
    The modulus *n* would be such a large product. RSA is secure because it’s hard
    to find *p* and *q* from a given *n*. However, if someone discovers a solution
    to this problem, an adversary could calculate Φ(*n*) from the factorized values
    *p* and *q* and compute the inverse of *e* modulo Φ(*n*), and RSA would be broken.
  prefs: []
  type: TYPE_NORMAL
- en: Compared to symmetric schemes, the mathematical basis of the RSA cryptosystem
    makes it more difficult to estimate its security level. In *Special Publication
    800-57* from 2020, crypto experts from NIST judged the security levels of RSA
    as listed in [Table 2-1](ch02.xhtml#ch02tab01).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Security Estimation of RSA'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Security level** | **Key size** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ≤ 80-bit | 1,024-bit |'
  prefs: []
  type: TYPE_TB
- en: '| 112-bit | 2,048-bit |'
  prefs: []
  type: TYPE_TB
- en: '| 128-bit | 3,072-bit |'
  prefs: []
  type: TYPE_TB
- en: '| 192-bit | 7,680-bit |'
  prefs: []
  type: TYPE_TB
- en: '| 256-bit | 15,360-bit |'
  prefs: []
  type: TYPE_TB
- en: Two important properties are obvious. The required key sizes are much longer
    than the achieved security level. The relation between them isn’t linear, but
    the security level rises significantly more slowly in comparison to the invested
    key bits. At the time of writing, 2,048-bit is a common setting, but for long-term
    usage, 4,096-bit RSA keys are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '***Real-World RSA Usage***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The basic structure of RSA, however, is not perfectly suitable for practical
    encryption because attackers in possession of two ciphertexts would be able to
    create a new ciphertext that is the correct encryption of the multiplication of
    the two original plaintexts. The *Optimal Asymmetric Encryption Padding (OAEP)*
    scheme was developed to avoid this weakness. In connection with RSA, it’s called
    *RSA-OAEP* or *RSAES-OAEP* and is specified in NIST’s *Special Publication 800-56B*.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, OAEP uses a random string and two hash functions to process the
    plaintext, often a symmetric key, and generates a padded plaintext version that
    is subsequently used for RSA encryption. For decryption, the ciphertext is decrypted
    as in standard RSA, but then the initial message and random value have to be recovered
    by using the two hash functions mentioned before. Finally, the computation result
    has to be verified for its correct structure before you can use the plaintext.
  prefs: []
  type: TYPE_NORMAL
- en: A similar problem also exists for digital signatures with the basic RSA equations.
    Based on a valid signature for a specifically prepared message, attackers would
    be able to create a valid signature for a message of their choice. The *Probabilistic
    Signature Scheme (PSS)* defined as RSASSA-PSS (RSA Signature Scheme with Appendix)
    in RFC 3447 prevents such attacks.
  prefs: []
  type: TYPE_NORMAL
- en: PSS injects additional random padding into the input data of the signature scheme—namely,
    the hash value of the message to be signed. Again, two hash functions and a predefined
    encoding are necessary to generate a padded version of the message’s hash. During
    verification, the intermediate values have to be restored and the padding has
    to be checked for correctness in order to validate a signature.
  prefs: []
  type: TYPE_NORMAL
- en: '**Diffie-Hellman Key Exchange**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When only symmetric cryptography was available, people had to exchange keys
    over *secure channels*—in person, with sealed letters, or over an already protected
    communication line. The process was pretty inconvenient and had several practical
    pitfalls.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, in 1976, Whitfield Diffie and Martin Hellman published their idea on
    how to establish a *shared secret* between two parties that are able to communicate
    only over an *insecure channel*, which is now commonly known as the *Diffie-Hellman
    (DH) key exchange*. Instead of generating a key at a specific location and then
    applying a *key-transport* mechanism (for example, RSA encryption), DH creates
    the shared key by using a *key-agreement* protocol between two entities.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Mathematical Beauty***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The math behind DH is based on a group ![Image](../images/common-01.jpg), where
    all operations are performed modulo a prime *p* and the primitive element is denoted
    as *g*. [Figure 2-14](ch02.xhtml#ch02fig014) illustrates the process of establishing
    a shared secret.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/02fig14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-14: The steps in a Diffie-Hellman key exchange*'
  prefs: []
  type: TYPE_NORMAL
- en: First, both parties, commonly named Alice and Bob, choose secret numbers *a*
    and *b*, respectively ➊. Then, they derive the corresponding public values *A*
    and *B* ➋ and exchange them ➌. Afterward, they raise the public value of the other
    party to the power of their own private value ➍ to obtain the shared secret *k[AB]*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The security of DH relies on the *discrete logarithm problem (DLP)*: it’s hard
    to obtain *a* from *A* = *g^a* mod *p*. Deriving the private number *a* from the
    publicly transferred value *A* clearly would break the security of this protocol.
    However, since that’s practically impossible, attackers eavesdropping on the DH
    protocol don’t receive any helpful information. The achieved security level in
    relation to DH key sizes is practically the same as for RSA.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Man-in-the-Middle Attacks***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This basic version of DH is also called *anonymous Diffie-Hellman* because
    Alice and Bob can’t verify each other’s identity. This fact can be exploited by
    an adversary through a *man-in-the-middle (MITM)* attack: a malicious actor intercepts
    the communication between the original parties, drops their exchange of public
    values *A* and *B*, and instead performs one DH protocol run with Alice and one
    with Bob. In the end, Alice and Bob think that their key agreement was successful
    and they can communicate securely. However, they now both share a key with the
    attacker, who is able to read and manipulate all information flowing between them.'
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this problem is the introduction of *authenticated Diffie-Hellman*,
    which is based on the assumption that Alice and Bob each have a long-term public-key
    pair they can use to prove their identities to each other by exchanging digitally
    signed values of *A* and *B*. In this case, an MITM attacker would be unable to
    slip in between without being noticed. In variations of this approach, other protocol
    data is signed and verified, but it’s always essential to authenticate the other
    party before computing and using the shared secret.
  prefs: []
  type: TYPE_NORMAL
- en: A second property of DH is that you shouldn’t regard the values *a* and *b*
    as long-term keys. Reusing them for multiple key-agreement runs violates the common
    requirement of *perfect forward secrecy (PFS)*. This means that session keys established
    during a key exchange should still be secure, even if long-term keys are compromised
    in the future. You should consider the private numbers *a* and *b* to be *ephemeral
    keys* and use them only once. The corresponding version of DH is often called
    *Diffie-Hellman Ephemeral (DHE)*.
  prefs: []
  type: TYPE_NORMAL
- en: You can find details on Diffie-Hellman variants and other key-agreement schemes
    in NIST’s *Special Publication 800-56A*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Elliptic-Curve Cryptography**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'RSA and DH provide many meaningful mechanisms for asymmetric cryptography,
    but they come with two strong downsides: long keys and significant performance
    demand. The field of *elliptic-curve cryptography (ECC)*, founded in 1985, promised
    to provide asymmetric cryptography with noticeably reduced drawbacks.'
  prefs: []
  type: TYPE_NORMAL
- en: However, about 20 years passed before it was widely used in practice. The math
    behind ECC is rather complex compared to RSA and DH, and the adoption of ECC was
    impeded by the Certicom company, which held a series of patents that had to be
    licensed in case of ECC usage. Luckily, most of those patents have expired by
    now.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Math Behind the Curves***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In a nutshell, *elliptic curves* are considered to be a group of points with
    x- and y-coordinates—for example, denoted as *P*(*x*, *y*). The values of *x*
    and *y* are integers of a group modulo a prime *p*, often denoted as *GF*(*p*),
    a *Galois field*. The equation of an elliptic curve describes all the points that
    are part of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In cryptography, only a few curve equations are of practical relevance. The
    following is used for *Weierstrass curves* like P-256 standardized by NIST and
    has parameters *a* and *b*:'
  prefs: []
  type: TYPE_NORMAL
- en: '*x*² = *x*³ + *ax* + *b*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Montgomery curves* use parameters *A* and *B*, and they’re especially known
    because of the prominent member Curve25519\. The following equation describes
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '*By*² = *x*³ + *Ax*² + *x*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Edwards curves*, with their parameter *d*, are another interesting type of
    curve, and Ed448-Goldilocks is based on it. Here’s the general equation for these
    curves:'
  prefs: []
  type: TYPE_NORMAL
- en: '*x*² + *y*² = 1 + *dx*²*y*²'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can process points on elliptic curves in three ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Point addition**    Add two points *P* and *Q* to obtain a new point *R*
    on the same curve: *R* = *P* + *Q*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Point doubling**    Multiply a given point *P* by 2 to obtain a new point
    *R*: *R* = 2*P*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scalar multiplication**    Take a point *P* and multiply it with an integer
    (scalar) *k* to yield a new curve point *R*: *R* = *kP*.'
  prefs: []
  type: TYPE_NORMAL
- en: The scalar multiplication in ECC is similar to the modular exponentiation for
    RSA. Also, the naive approach to scalar multiplication, which means adding a point
    *k* – 1 times, is infeasible for *k* being a large number with hundreds of bits.
    Therefore, a similar algorithm to square-and-multiply, namely *double-and-add*,
    has to be used to compute it efficiently. Putting it simply, *k* is processed
    bit by bit, and for every bit position, a point doubling is performed. If a bit
    is 1, an extra point addition is executed. Altogether, this enables the practical
    usage of ECC crypto primitives.
  prefs: []
  type: TYPE_NORMAL
- en: Elliptic curves are designed in a way that the *elliptic-curve discrete logarithm
    problem (ECDLP)* is difficult. The name suggests that it’s similar to the DLP
    that’s the foundation of DH, and it is. However, in the ECC world, you can describe
    the problem as finding the scalar *k* given points *P* and *R* = *kP*. [Table
    2-2](ch02.xhtml#ch02tab02), derived from NIST’s *Special Publication 800-57* from
    2022, shows the striking difference of the ECDLP compared to the underlying problems
    of RSA and DH.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-2:** Security Estimation of ECC'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Security level** | **Key size** | **Key size of RSA/DH (for comparison)**
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ≤ 80-bit | 160-bit | 1,024-bit |'
  prefs: []
  type: TYPE_TB
- en: '| 112-bit | 224-bit | 2,048-bit |'
  prefs: []
  type: TYPE_TB
- en: '| 128-bit | 256-bit | 3,072-bit |'
  prefs: []
  type: TYPE_TB
- en: '| 192-bit | 384-bit | 7,680-bit |'
  prefs: []
  type: TYPE_TB
- en: '| 256-bit | 512-bit | 15,360-bit |'
  prefs: []
  type: TYPE_TB
- en: ECC achieves the same security level with much lower key sizes. Additionally,
    with increasing key lengths, the corresponding security level rises *linearly*,
    so doubling the curve size from 256-bit to 512-bit also leads to twice the security
    level.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Agony of Choice***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In contrast to many other cryptographic algorithms, ECC requires an implementer
    to choose not only a key size but also a specific elliptic curve to be used. Certain
    mathematical requirements have to be fulfilled by “safe” curves, which is why
    it’s reasonable to choose one from the common, standardized options that have
    undergone rigorous analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, a criterion that you can consider in the selection process
    is the origin of the curve parameters. Although the US National Security Agency
    (NSA) created the prime curve P-256, and the NIST standardized it in 2000, it’s
    one of the most popular curves in practice. Its parameter *b* is a 256-bit number,
    and only the NSA knows how and why it was chosen. The same is true for the other
    NIST curves: P-192, P-224, P-384, and P-521\. It might not be a critical issue,
    but maybe a relevant one, for devices operating in critical infrastructures.'
  prefs: []
  type: TYPE_NORMAL
- en: Curve25519 is currently the most popular and most trustworthy elliptic curve.
    It was proposed by Bernstein in 2006 and is prominent because of two properties.
    First, it has a strong focus on high performance in software implementations.
    Second, it doesn’t rely on randomly chosen or obscure curve parameters. In the
    future, Edwards curves like Ed448-Goldilocks and Curve41417 also might be of interest
    because they offer a security level above 200-bit.
  prefs: []
  type: TYPE_NORMAL
- en: '***Practical Applications of ECC***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the most common applications of ECC is a digital signature based on the
    *Elliptic-Curve Digital Signature Algorithm (ECDSA)* as defined in *FIPS 186-5*.
    The basic setting for this use case is that two parties have agreed on a specific
    curve and its parameters. The signing entity holds the private key *d*, a secret
    integer, and the verifier has access to the corresponding public key *P* = *dG*,
    where *G* is the base point of the selected curve.
  prefs: []
  type: TYPE_NORMAL
- en: For signature generation, the signer hashes the message, chooses a random ephemeral
    key, and processes both together to obtain a unique signature consisting of two
    values with a total size of twice the curve order—for example, 512 bits, or 64
    bytes, for a 256-bit curve. (The details of the verification process are rather
    complex and beyond the scope of this book.)
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, ECDSA signatures are preferable to RSA signatures for performance
    and security reasons, except for a single case: if the signature verification
    has the highest priority, and signature generation happens only rarely—for example,
    when signing a firmware image once in the development process—and verification
    is time-critical because it happens during the device’s boot process.'
  prefs: []
  type: TYPE_NORMAL
- en: Besides digital signatures, ECC is an inherent part of modern key-exchange and
    key-agreement schemes as described in NIST’s *Special Publication 800-56A*. They’re
    also known as *Elliptic-Curve Diffie-Hellman (ECDH)* and *Elliptic-Curve Diffie-Hellman
    Ephemeral (ECDHE)*. There, the modular exponentiation of DH is replaced by a scalar
    multiplication based on an elliptic curve. The rest is pretty similar to DH. Again,
    this leads to a significant performance gain compared to classical DH, which is
    especially interesting when you need to perform a high number of key-agreement
    handshakes regularly, such as a server handling lots of connections.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, you can use ECC for public-key encryption, but it’s rarely
    used in practice. The *Elliptic-Curve Integrated Encryption Scheme (ECIES)* is
    meant for exactly that purpose. In a nutshell, it uses a recipient’s public key
    to generate a shared ECDH secret and derives a symmetric key from it. This key
    is then used to encrypt a message by an AE cipher, producing a ciphertext and
    an authentication tag.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter started off with crypto fundamentals like Kerckhoffs’s principle
    that a cryptographic key should be the only secret in a cryptosystem, followed
    by a discussion that security levels are merely a description of the potential
    search space an attacker has to face.
  prefs: []
  type: TYPE_NORMAL
- en: I covered the area of symmetric encryption based on the popular AES algorithm
    and common operation modes in detail because it’s omnipresent in security. Hash
    functions like SHA-256, integrity-protecting MAC algorithms, and efficient AE
    schemes like AES-GCM complete the modern tool-box of symmetric cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: 'The introduction of asymmetric cryptography based on RSA and DH has enabled
    amazing possibilities to protect communication and devices: public-key encryption,
    digital signatures, and secure key agreements over insecure channels. Further,
    the field of ECC has enhanced the performance of these mechanisms significantly.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Post-quantum cryptography* goes beyond the scope of this book, but it might
    be a topic that will challenge existing asymmetric crypto schemes in the future,
    and it will be inevitable if a universal quantum computer is built. NIST’s standardization
    process for post-quantum cryptography (*[https://csrc.nist.gov/projects/post-quantum-cryptography](https://csrc.nist.gov/projects/post-quantum-cryptography)*)
    is still ongoing but worth following.'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re interested in learning more about the inner workings of cryptography,
    Jean-Philippe Aumasson’s *Serious Cryptography* (No Starch Press, 2017; second
    edition forthcoming) and *Understanding Cryptography* by Christof Paar and Jan
    Pelzl (Springer, 2009) are good resources.
  prefs: []
  type: TYPE_NORMAL
