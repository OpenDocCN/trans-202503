<html><head></head><body>
<div id="sbo-rt-content"><section aria-labelledby="ch3" epub:type="chapter" role="doc-chapter">
<span aria-label="41" epub:type="pagebreak" id="pg_41" role="doc-pagebreak"/>
<hgroup>
<h2 class="CHAPTER" id="ch3">
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">3</span></span>
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">STRINGS AND STRING FUNCTIONS</span></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener" height="380" src="../images/opener.jpg" width="380"/>
</figure>
<p class="INTRO">In this chapter, we’ll take a close look at strings, including how to create them, how to combine them, and how to search, transform, and otherwise manipulate them with PHP’s many built-in string functions. Almost every PHP program and web application involves text, so it’s important to understand how to create and work with strings.</p>
<p class="TX">The chapter introduces PHP’s four styles for writing strings: inside single quotation marks or double quotation marks, or in longer, multiline spans as heredocs or nowdocs. These styles come with different features, such as the ability to incorporate variables or represent special symbols. Despite these differences, they all end up with the same result: a value of the <span class="SANS_TheSansMonoCd_W5Regular_11">string</span> data type, which is to say, a sequence of characters.</p>
<section aria-labelledby="sec1" epub:type="division">
<span aria-label="42" epub:type="pagebreak" id="pg_42" role="doc-pagebreak"/>
<h3 class="H1" id="sec1"><span id="toc-link_33"/><span class="SANS_Futura_Std_Bold_B_11">Whitespace</span></h3>
<p class="TNI1">Before we consider strings with characters that you can see, such as letters and numerals, a word about <i>whitespace</i>, the characters you can’t see. These are characters that won’t use any ink when printing (for example, the space character, the tab character, the newline character, and so on). Sometimes it’s useful to distinguish between <i>horizontal</i> whitespace, such as spaces and tabs, and <i>vertical</i> whitespace, such as newline characters and vertical tabs.</p>
<p class="TX">When you write code, the details of the whitespace you use are often unimportant to the execution of the code. As long as you have a minimum of one whitespace character (such as a space or newline) between expressions, it doesn’t matter whether you have additional whitespace characters (such as extra spaces or tabs). For example, the PHP engine will interpret all four of the following statements as exactly the same, ignoring multiple spaces, tabs, and newlines around the variable name and equal sign, and on either side of the string:</p>
<pre><code>$lastName = 'Smith';&#13;
      $lastName = 'Smith';&#13;
   $lastName      =      'Smith'    ;&#13;
$lastName&#13;
=&#13;
    'Smith'&#13;
;</code></pre>
<p class="TX">When you’re declaring or manipulating the contents in string expressions, however, you have to be precise about your use of whitespace. Otherwise, words may end up stuck together with no space between them, or some text may end up on a different line. For example, the strings in these four statements are all different, since the extra whitespace is <i>inside</i> the quotation marks:</p>
<pre><code>$lastName = 'Smith';&#13;
$lastName = '   Smith';&#13;
$lastName = 'Smith   ';&#13;
$lastName = '     Smith   ';</code></pre>
<p class="TX">Whitespace doesn’t come just from the code you write. It can also be introduced when you take a string as input from a user or an external software system such as an application programming interface (API). In this case, you often need to validate that input and trim any unwanted whitespace at its beginning and end. Likewise, you may want to replace any tabs or newline characters inside a string with single spaces (sometimes users press function keys by accident while typing, adding unintended, invisible whitespace characters to their input). You’ll learn to do all these things in this chapter (for example, see <span class="Xref">“Removing All Unnecessary Whitespace”</span> on <span class="Xref"><a href="#pg_60">page 60</a></span>).</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<span aria-label="43" epub:type="pagebreak" id="pg_43" role="doc-pagebreak"/>
<h3 class="H1" id="sec2"><span id="toc-link_34"/><span class="SANS_Futura_Std_Bold_B_11">Single-Quoted Strings</span></h3>
<p class="TNI1">The simplest type of string in PHP is enclosed in single quotation marks, such as <span class="SANS_TheSansMonoCd_W5Regular_11">'matt smith'</span>. Almost everything that appears inside the single quotes is treated literally, meaning it will be reproduced exactly as written, character for character, if the string is printed out.</p>
<p class="TX">PHP has just two special cases for single-quoted strings. First, since single quotes serve to delimit the string, there must be a mechanism for including a single quotation mark inside the string itself. Otherwise, the single quote will be interpreted as the end of the string. The solution is to put a backslash in front of the single quote (<span class="SANS_TheSansMonoCd_W5Regular_11">\'</span>), as in <span class="SANS_TheSansMonoCd_W5Regular_11">'matt smith\'s string'</span>. When this string prints, the single quote will show up, but not the backslash, as you can see here in PHP’s interactive mode:</p>
<pre><code>php &gt; <b>print 'matt smith\'s string';</b>&#13;
matt smith's string</code></pre>
<p class="TX">This technique of having a special sequence of characters in a string that PHP will interpret as a certain character is known as <i>escaping</i>. Since the backslash is needed to escape single quotation marks, there must also be a way to specify a backslash character in a single-quoted string. For that, write two backslashes: <span class="SANS_TheSansMonoCd_W5Regular_11">\\</span>.</p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">\'</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">\\</span> escape sequences are the only characters that the PHP engine will interpret to mean something else in a single-quoted string. Other escape sequences you might know from other programming languages, such as <span class="SANS_TheSansMonoCd_W5Regular_11">\n</span> for newline, aren’t recognized in single-quoted strings.</p>
<p class="TX">That doesn’t mean you can’t include newlines in single-quoted strings, however. For that, simply add line breaks wherever you want them in the string, and PHP will reproduce the line breaks exactly as you’ve written them. In fact, one reason PHP requires a semicolon to declare the end of a statement is to allow a single statement to be written over several lines. <a href="#lis3-1">Listing 3-1</a> illustrates a string broken across multiple lines.</p>
<span id="lis3-1"/>
<pre><code>&lt;?php&#13;
print 'the&#13;
cat&#13;
sat on&#13;
the mat!&#13;
';</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 3-1: A script with a string containing line breaks</span></p>
<p class="TX">This script includes a single <span class="SANS_TheSansMonoCd_W5Regular_11">print</span> statement for a string that contains several line breaks. Here’s the output of running this script at the command line:</p>
<pre><code>the&#13;
cat&#13;
sat on&#13;
the mat!</code></pre>
<p class="BodyContinued">The output includes all the newlines that were written into the string.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<span aria-label="44" epub:type="pagebreak" id="pg_44" role="doc-pagebreak"/>
<h3 class="H1" id="sec3"><span id="toc-link_35"/><span class="SANS_Futura_Std_Bold_B_11">Joining Strings: Concatenation</span></h3>
<p class="TNI1">Often you’ll need to combine several strings, variables, or constants to form a single string expression. You can do this with PHP’s string concatenation operator, represented by a period (<span class="SANS_TheSansMonoCd_W5Regular_11">.</span>). Consider this example using PHP’s interactive mode:</p>
<pre><code>php &gt; <b>$name = 'Matt Smith';</b>&#13;
php &gt; <b>print 'my name is ' . $name;</b>&#13;
my name is Matt Smith</code></pre>
<p class="TX">We declare the <span class="SANS_TheSansMonoCd_W5Regular_11">$name</span> variable whose value is the string <span class="SANS_TheSansMonoCd_W5Regular_11">'Matt Smith'</span>. Then we use the string concatenation operator to combine the value of this variable with another string, and we print the resulting longer string. Note the extra space in the string <span class="SANS_TheSansMonoCd_W5Regular_11">'my name is '</span> before the closing single quote. The concatenation operator doesn’t add any spaces between the strings it’s joining, so this extra space is to prevent something like <span class="SANS_TheSansMonoCd_W5Regular_11">isMatt</span> from being printed.</p>
<p class="TX">When concatenating strings on a single line, it’s good programming practice to make the statement more readable by adding a space on each side of the period, as in the preceding example. You can also spread such statements over several lines, which can help make long string expressions more readable, as shown in the script in <a href="#lis3-2">Listing 3-2</a>. This shows my personal preference of indenting each subsequent line of the statement and beginning each line with the concatenation operator, so it’s clear that each line is appending more to the string expression.</p>
<span id="lis3-2"/>
<pre><code>&lt;?php&#13;
$name = 'Matt Smith';&#13;
print 'my name is '&#13;
    . $name&#13;
    . ', I\'m pleased to meet you!'&#13;
    . PHP_EOL;</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 3-2: A script to concatenate and print out several strings</span></p>
<p class="TX">This script prints out a string formed by concatenating four shorter strings together, including the two from the previous example. Notice that we’ve escaped a single quote to create the apostrophe in the word <span class="SANS_TheSansMonoCd_W5Regular_11">I'm</span> in the third string.</p>
<p class="TX">The fourth string at the end of the expression is the special string constant <span class="SANS_TheSansMonoCd_W5Regular_11">PHP_EOL</span>, short for <i>end of line</i>. This is a string containing the system-appropriate character (or characters) to move the cursor to the beginning of the next line in a command line terminal (the same as hitting <small>ENTER</small>). Such a special constant used to be needed since different operating systems used slightly different ways to specify the end of a line. It’s not such an issue now since applications for most operating systems generally know how to work with each other’s files these days, but the constant is still handy for ensuring that the next terminal prompt after a single-quoted string <span aria-label="45" epub:type="pagebreak" id="pg_45" role="doc-pagebreak"/>starts on a new line. Here’s the output when this script is run at the command line:</p>
<pre><code>% <b>php multi_line.php</b>&#13;
my name is Matt Smith, I'm pleased to meet you!&#13;
%</code></pre>
<p class="TX">I saved the script from <a href="#lis3-2">Listing 3-2</a> in a file named <i>multi_line.php</i>. Running the script concatenates the strings and prints the result on a single line. Notice that the next terminal prompt (in this case, the percent character, <span class="SANS_TheSansMonoCd_W5Regular_11">%</span>) appears on the next line, thanks to the <span class="SANS_TheSansMonoCd_W5Regular_11">PHP_EOL</span> constant.</p>
<aside aria-labelledby="box-3" class="box">
<h4 class="BoxTitle" id="box-3"><span class="SANS_Dogma_OT_Bold_B_11">WHY NOT A PLUS SIGN?</span></h4>
<p class="BoxBodyFirst"><span class="SANS_Futura_Std_Book_11">Most programming languages are strongly typed, so the plus sign (</span><span class="SANS_TheSansMonoCd_W5Regular_11">+</span><span class="SANS_Futura_Std_Book_11">) can be used for both mathematical addition and string concatenation. The compiler knows which operation to implement since it knows whether the variables on either side of the operator are numbers or strings. By contrast, since PHP is loosely typed, the plus sign is used only for mathematical addition. A different character had to be selected for string concatenation, and the period (</span><span class="SANS_TheSansMonoCd_W5Regular_11">.</span><span class="SANS_Futura_Std_Book_11">) was chosen.</span></p>
<p class="BoxBody"><span class="SANS_Futura_Std_Book_11">In most object-oriented languages, the period has a different meaning: it allows access to an object’s methods and properties. PHP didn’t initially support object-oriented programming, however. When this capability was eventually added, the period was already reserved for string concatenation, so PHP had to choose another character sequence for object access. You’ll meet this object access operator (</span><span class="SANS_TheSansMonoCd_W5Regular_11">-&gt;</span><span class="SANS_Futura_Std_Book_11">) in <a href="part5.xhtml">Part V</a>, when we discuss object-oriented programming.</span></p>
<p class="BoxBodyLast"><span class="SANS_Futura_Std_Book_11">The use of dollar signs for variables, periods for string concatenation, and</span> <span class="SANS_TheSansMonoCd_W5Regular_11">-&gt;</span> <span class="SANS_Futura_Std_Book_11">for object access makes PHP’s syntax a little strange for programmers used to other languages. Once you’ve been programming in PHP for a while, though, this will all become second nature.</span></p>
</aside>
<p class="TX">If a variable already contains a string, we can use the concatenating assignment operator (<span class="SANS_TheSansMonoCd_W5Regular_11">.=</span>) to append another string expression to the end of that variable. Here’s an example using PHP’s interactive mode:</p>
<pre><code>php &gt; <b>$name = 'Matt';</b>&#13;
php &gt; <b>$name .= ' Smith';</b>&#13;
php &gt; <b>print</b> <b>$name;</b>&#13;
Matt Smith</code></pre>
<p class="TX">First, we initialize the <span class="SANS_TheSansMonoCd_W5Regular_11">$name</span> variable to the string <span class="SANS_TheSansMonoCd_W5Regular_11">'Matt'</span>. Then we use the concatenating assignment operator to append <span class="SANS_TheSansMonoCd_W5Regular_11">' Smith'</span> to the end of the contents of <span class="SANS_TheSansMonoCd_W5Regular_11">$name</span>. When we print out the variable, we can see that it now contains <span class="SANS_TheSansMonoCd_W5Regular_11">Matt Smith</span>.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<span aria-label="46" epub:type="pagebreak" id="pg_46" role="doc-pagebreak"/>
<h3 class="H1" id="sec4"><span id="toc-link_36"/><span class="SANS_Futura_Std_Bold_B_11">Double-Quoted Strings</span></h3>
<p class="TNI1">The second type of PHP string is enclosed in double quotes, as in <span class="SANS_TheSansMonoCd_W5Regular_11">"Matt Smith"</span>. Double-quoted strings differ from their single-quoted counterparts in that they are <i>parsed</i>, or processed, by the PHP engine, which means they can include PHP variables. When you write a variable (beginning with a dollar sign) in a double-quoted string, the PHP engine will look up the value of the variable and insert it into the string before printing. This is often more convenient than using a period to concatenate single-quoted strings with the contents of variables, as we did in the previous section. Here’s an example using PHP’s interactive mode:</p>
<pre><code>php &gt; <b>$name = 'Matt Smith';</b>&#13;
php &gt; <b>print "My name is $name \nI'm pleased to meet you";</b>&#13;
My name is Matt Smith&#13;
I'm pleased to meet you</code></pre>
<p class="TX">First, we assign the string <span class="SANS_TheSansMonoCd_W5Regular_11">'Matt Smith'</span> to the <span class="SANS_TheSansMonoCd_W5Regular_11">$name</span> variable, as before. Note that we could have used double quotes for this string, but most PHP programmers use them only for strings that will need parsing. Next, we print a double-quoted string that includes the <span class="SANS_TheSansMonoCd_W5Regular_11">$name</span> variable. The output shows that PHP has successfully parsed this string by inserting <span class="SANS_TheSansMonoCd_W5Regular_11">Matt Smith</span> in place of the variable.</p>
<p class="TX">Notice that the double-quoted string includes a single-quote character in the contraction <span class="SANS_TheSansMonoCd_W5Regular_11">I'm</span>. This is perfectly valid in a double-quoted string and doesn’t require escaping. Our double-quoted string also includes the escape sequence <span class="SANS_TheSansMonoCd_W5Regular_11">\n</span> to create a newline in the middle of the output. This is one of several escape sequences available for use in double-quoted strings. <a href="#tab3-1">Table 3-1</a> lists some of the most common.</p>
<p class="TT"><a id="tab3-1"/><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 3-1:</span></span> <span class="SANS_Futura_Std_Book_11">Common Escape Sequences in Double-Quoted Strings</span></p>
<table class="Basic-Table">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Escape sequence</span></p></th>
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Description</span></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBF"><p class="TB_Grey"><span class="SANS_TheSansMonoCd_W5Regular_11">\\</span></p></td>
<td class="TBF"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_11">Backslash</span></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">\"</span></p></td>
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Double-quote</span></p></td>
</tr>
<tr>
<td class="TB"><p class="TB_Grey"><span class="SANS_TheSansMonoCd_W5Regular_11">\$</span></p></td>
<td class="TB"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_11">Dollar sign</span></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">\n</span></p></td>
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Newline</span></p></td>
</tr>
<tr>
<td class="TBL"><p class="TB_Grey"><span class="SANS_TheSansMonoCd_W5Regular_11">\t</span></p></td>
<td class="TBL"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_11">Tab</span></p></td>
</tr>
</tbody>
</table>
<p class="TX">Notice in particular that since a dollar sign will make the PHP engine parse for a variable, you must use <span class="SANS_TheSansMonoCd_W5Regular_11">\$</span> to include an actual dollar sign in a double-quoted string. You also need to use <span class="SANS_TheSansMonoCd_W5Regular_11">\"</span> to include a double quotation mark.</p>
<p class="TX">You can’t include constants in double-quoted strings, since the PHP engine can’t tell the difference between characters that are part of the string and the name of the constant. (Recall from <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span> that constants <span aria-label="47" epub:type="pagebreak" id="pg_47" role="doc-pagebreak"/>don’t start with a dollar sign.) One side effect is that you can’t include the <span class="SANS_TheSansMonoCd_W5Regular_11">PHP_EOL</span> constant in a double-quoted string to create a newline at the end of the string. Instead, use the <span class="SANS_TheSansMonoCd_W5Regular_11">\n</span> newline escape sequence.</p>
<blockquote>
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>
</blockquote>
<p class="NOTE-TXT"><i>On the rare occasions when you need the operating system–independent</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">PHP_EOL</span> <i>constant with a double-quoted string, you can use the string concatenation operator to add the constant to the string, much as you saw in <a href="#lis3-2">Listing 3-2</a>. This situation might arise when a script needs to precisely output the appropriate newline and cursor-to-beginning-of-line character sequence for the system the PHP engine is running on (for example, to ensure that a system file has the correct line endings).</i></p>
<section aria-labelledby="sec5" epub:type="division">
<h4 class="H2" id="sec5"><span id="toc-link_37"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Handling the Character After a Variable Name</span></h4>
<p class="TNI1">When you have a variable name followed by a space in a double-quoted string, such as <span class="SANS_TheSansMonoCd_W5Regular_11">"my name is $name \nI'm pleased to meet you"</span>, the PHP engine can easily identify the variable (<span class="SANS_TheSansMonoCd_W5Regular_11">$name</span>) and recognize that a space should be present after its value. Even punctuation marks such as periods, commas, and colons are fine when they immediately follow a variable, and so are escape sequences, since these aren’t valid characters to have in variable names. Here, for example, using a comma immediately after the <span class="SANS_TheSansMonoCd_W5Regular_11">$name</span> variable is perfectly fine:</p>
<pre><code>php &gt; <b>$name = 'Matt Smith';</b>&#13;
php &gt; <b>print "my name is $name, and I'm pleased to meet you";</b>&#13;
my name is Matt Smith, and I'm pleased to meet you</code></pre>
<p class="TX">If you want other characters to be part of the string immediately after a variable, however, the situation becomes a little more difficult. After its first letter (or underscore character), the characters of a variable name can be letters, numbers and underscores, so if any of these are written immediately after a variable name in a double-quoted string, the PHP engine treats them as part of the variable name. For example, if we have a <span class="SANS_TheSansMonoCd_W5Regular_11">$weight</span> variable and we want its value to be followed immediately by <span class="SANS_TheSansMonoCd_W5Regular_11">kg</span>, as in <span class="SANS_TheSansMonoCd_W5Regular_11">80kg</span>, we can’t write something like this:</p>
<pre><code>print "$weightkg";</code></pre>
<p class="TX">The PHP engine would complain, saying there’s no variable named <span class="SANS_TheSansMonoCd_W5Regular_11">$weightkg</span>. The solution for these more complex double-quoted-string parsing tasks is to enclose the variable name in curly brackets (braces):</p>
<pre><code>php &gt; <b>$weight = 80;</b>&#13;
php &gt; <b>print "my weight is {$weight}kg";</b>&#13;
my weight is 80kg</code></pre>
<p class="TX">Thanks to the curly brackets, PHP has no problem printing the characters <span class="SANS_TheSansMonoCd_W5Regular_11">kg</span> immediately after the value of <span class="SANS_TheSansMonoCd_W5Regular_11">$weight</span>. Note that this is an example of the string context of <i>type juggling</i>, as introduced in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>. When the <span aria-label="48" epub:type="pagebreak" id="pg_48" role="doc-pagebreak"/>string <span class="SANS_TheSansMonoCd_W5Regular_11">"my weight is {$weight}kg"</span> is parsed, the value of <span class="SANS_TheSansMonoCd_W5Regular_11">$weight</span> will be juggled from the integer <span class="SANS_TheSansMonoCd_W5Regular_11">80</span> into the string <span class="SANS_TheSansMonoCd_W5Regular_11">'80'</span> for insertion into the final string.</p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h4 class="H2" id="sec6"><span id="toc-link_38"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Incorporating Unicode Characters</span></h4>
<p class="TNI1">Not all characters are available to type directly from your keyboard or are part of the current language settings of your computer system, but that doesn’t mean you can’t include them in double-quoted strings. <i>Unicode</i> is an international standard for declaring and working with a wide range of characters and symbols, including ordinary English letters, emojis, letters from other alphabets, and more. Each Unicode character is defined by a unique hexadecimal code. For example, the code <span class="SANS_TheSansMonoCd_W5Regular_11">1F60A</span> corresponds to one of several smiling emojis.</p>
<p class="TX">To use a Unicode character in a double-quoted string, start with the escape sequence <span class="SANS_TheSansMonoCd_W5Regular_11">\u</span>, then provide the character’s hexadecimal code in curly brackets. <a href="#lis3-3">Listing 3-3</a> shows code to declare and print several Unicode characters.</p>
<span id="lis3-3"/>
<pre><code>&lt;?php&#13;
$smiley = "\u{1F60A}";&#13;
$elephant = "\u{1F418}";&#13;
$cherokeeTSV = "\u{13E8}";&#13;
&#13;
print "this is a smiley unicode character\n$smiley\n";&#13;
print "followed by some elephants of course\n$elephant $elephant $elephant\n";&#13;
print "Cherokee letter TSV\n$cherokeeTSV\n";</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 3-3: A script to display various Unicode characters</span></p>
<p class="TX">First, we declare the variables <span class="SANS_TheSansMonoCd_W5Regular_11">$smiley</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">$elephant</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">$cherokeeTSV</span> to contain double-quoted strings with the Unicode characters for their respective smiley face and elephant emojis, and the Cherokee TSV symbol. Then we print some double-quoted strings that include those variables. Here’s the result:</p>
<figure class="IMG"><img alt="" class="img100" height="273" src="../images/pg48.jpg" width="1388"/>
</figure>
<p class="TX">Note that we could have included the Unicode character escape sequences directly in the double-quoted strings being printed rather than assigning them to variables first. Having them in variables makes it easier to reuse them throughout the script—for example, to print three elephants instead of just one. (The PHP community has a thing for elephants.) For a complete list of Unicode characters and their corresponding hexadecimal codes, visit <i><a href="https://home.unicode.org">https://home.unicode.org</a></i>.</p>
</section>
</section>
<section aria-labelledby="sec7" epub:type="division">
<span aria-label="49" epub:type="pagebreak" id="pg_49" role="doc-pagebreak"/>
<h3 class="H1" id="sec7"><span id="toc-link_39"/><span class="SANS_Futura_Std_Bold_B_11">Heredocs</span></h3>
<p class="TNI1"><i>Heredocs</i> are an alternative to double-quoted strings. They’re just like double-quoted strings in that they’re parsed and so can contain variables, but they differ in that heredocs typically span multiple lines. Although double-quoted strings can span multiple lines too, many programmers prefer heredocs for multiline strings since their syntax makes them stand out more obviously from the surrounding code.</p>
<p class="TX">To declare a heredoc, start with the heredoc operator (<span class="SANS_TheSansMonoCd_W5Regular_11">&lt;&lt;&lt;</span>), followed by a sequence of characters of your choice that will serve as a delimiter. Then, on a new line, start typing your string. When you get to the end of the string, repeat your chosen delimiter on its own line, followed by a semicolon to end the statement.</p>
<p class="TX">The most commonly used delimiter for heredocs is <span class="SANS_TheSansMonoCd_W5Regular_11">EOT</span> (short for <i>end of text</i>), but which delimiter you choose doesn’t really matter, as long as that character sequence doesn’t appear in the string being declared and as long as the delimiters at the beginning and end of the heredoc match. It makes code more readable to either always use <span class="SANS_TheSansMonoCd_W5Regular_11">EOT</span> or choose something meaningful to the heredoc’s contents, such as <span class="SANS_TheSansMonoCd_W5Regular_11">SQL</span> if it contains a SQL statement or <span class="SANS_TheSansMonoCd_W5Regular_11">HTML</span> if it contains HTML. <a href="#lis3-4">Listing 3-4</a> shows a script with an example heredoc.</p>
<span id="lis3-4"/>
<pre><code>&lt;?php&#13;
$age = 22;&#13;
$weight = 80;&#13;
&#13;
<span aria-label="annotation1" class="codeannotated_CodeAnnotation">❶</span> $message = &lt;&lt;&lt;EOT&#13;
my age is $age&#13;
my weight is {$weight}kg&#13;
&#13;
<span aria-label="annotation2" class="codeannotated_CodeAnnotation">❷</span> EOT;&#13;
&#13;
print $message;</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 3-4: A heredoc string declared and printed with the</span> <span class="TheSansMonoCd_W5Regular_Italic_11">EOT</span> <span class="SANS_Futura_Std_Book_Oblique_11">delimiter</span></p>
<p class="TX">This code creates the variables <span class="SANS_TheSansMonoCd_W5Regular_11">$age</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">$weight</span> containing <span class="SANS_TheSansMonoCd_W5Regular_11">22</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">80</span>, respectively. Then we assign a heredoc expression into the <span class="SANS_TheSansMonoCd_W5Regular_11">$message</span> variable <span aria-label="annotation1" class="CodeAnnotation">❶</span>. The heredoc starts with <span class="SANS_TheSansMonoCd_W5Regular_11">&lt;&lt;&lt;EOT</span>, and its content is everything from the next line until a newline character and the <span class="SANS_TheSansMonoCd_W5Regular_11">EOT;</span> at the end <span aria-label="annotation2" class="CodeAnnotation">❷</span>. Finally, we print the contents of <span class="SANS_TheSansMonoCd_W5Regular_11">$message</span>. Here’s the result:</p>
<span id="lis3-5"/>
<pre><code>% <b>php heredoc.php</b>&#13;
my age is 22&#13;
my weight is 80kg&#13;
%</code></pre>
<p class="TX">I saved the script as <i>heredoc.php</i> and ran it at the command line. Notice that the variables <span class="SANS_TheSansMonoCd_W5Regular_11">$age</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">$weight</span> were successfully parsed within the heredoc, <span aria-label="50" epub:type="pagebreak" id="pg_50" role="doc-pagebreak"/>including when we used curly brackets to allow characters to be output immediately following a variable. Notice also that the next command line prompt starts on its own line. This is because of the blank line in the heredoc before the closing delimiter; heredocs can contain newlines.</p>
<section aria-labelledby="sec8" epub:type="division">
<h4 class="H2" id="sec8"><span id="toc-link_40"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Escape Sequences</span></h4>
<p class="TNI1">You can’t use the <span class="SANS_TheSansMonoCd_W5Regular_11">\"</span> escape sequence to write a double quotation mark in a heredoc. If you write <span class="SANS_TheSansMonoCd_W5Regular_11">\"</span> inside a heredoc, the backslash will become an ordinary character in the string, just like the double quote. You won’t need this escape sequence in heredocs anyway: since you’re no longer using double quotes to delimit the string, using them within the string won’t cause confusion.</p>
<p class="TX">You <i>can</i> include other escape sequences in heredocs, such as <span class="SANS_TheSansMonoCd_W5Regular_11">\t</span> for tabs and <span class="SANS_TheSansMonoCd_W5Regular_11">\n</span> for newlines. These, too, aren’t strictly necessary, however, since you can just use the <small>TAB</small> and <small>ENTER</small> keys when writing the heredoc’s contents. You can also type Unicode characters directly into a heredoc (assuming your editor supports Unicode, that is). <a href="#lis3-5">Listing 3-5</a> shows an example.</p>
<figure class="IMG-1"><img alt="" class="img100" height="613" src="../images/pg50.jpg" width="1388"/></figure>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 3-5: A script with Unicode characters declared in a heredoc string</span></p>
<p class="TX">We declare this heredoc by using <span class="SANS_TheSansMonoCd_W5Regular_11">UNICODE</span> as the delimiter. The code features Unicode characters typed directly into the string, rather than created via escape sequences. The output of running this script is identical to the output from <a href="#lis3-3">Listing 3-3</a>.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h4 class="H2" id="sec9"><span id="toc-link_41"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Indention</span></h4>
<p class="TNI1">An occasionally useful feature of heredocs is that if indention (spaces or tabs) appears before the closing delimiter, the PHP engine will attempt to remove that same amount of indention from all lines of the heredoc. In <a href="#lis3-6">Listing 3-6</a>, for example, we declare and print a heredoc string that has each of its lines, including the line with the ending <span class="SANS_TheSansMonoCd_W5Regular_11">TEXT</span> delimiter, indented four spaces.</p>
<span id="lis3-6"/>
<pre><code><span aria-label="51" epub:type="pagebreak" id="pg_51" role="doc-pagebreak"/>&lt;?php&#13;
$message = &lt;&lt;&lt;TEXT&#13;
    If the closing delimiter is indented&#13;
    then that amount of indention&#13;
    is removed from the lines of the string&#13;
&#13;
    TEXT;&#13;
&#13;
print $message;</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 3-6: A script with an indented heredoc</span></p>
<p class="TX">Since every line of this heredoc has the same indention as the closing delimiter line, all indention will be removed from all lines when the string is printed. Here’s the output:</p>
<pre><code>If the closing delimiter is indented&#13;
then that amount of indention&#13;
is removed from the lines of the string</code></pre>
<p class="TX">If any lines in a heredoc have more indention than the line with the closing delimiter, that extra bit of indention will remain in the output. <a href="#lis3-7">Listing 3-7</a> shows an example.</p>
<span id="lis3-7"/>
<pre><code>&lt;?php&#13;
$message = &lt;&lt;&lt;END&#13;
    I'm the same indention as the ending delimiter (4 spaces)&#13;
      I have 2 extra spaces&#13;
      So have I!&#13;
    I'm back to 4 spaces again&#13;
&#13;
    END;&#13;
&#13;
print $message;</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 3-7: A script that retains extra indention in a heredoc</span></p>
<p class="TX">The first and last lines of the heredoc are indented four spaces, as is the closing delimiter. The middle two lines of the heredoc have two extra spaces of indention. In the output, four spaces will be stripped away from the start of each line, leaving two spaces of indention for the middle two lines, as shown here:</p>
<pre><code>I'm the same indentation as the ending delimiter (4 spaces)&#13;
  I have 2 extra spaces&#13;
  So have I!&#13;
I'm back to 4 spaces again</code></pre>
<p class="TX">This feature of removing indentation from a heredoc is primarily useful when the heredoc is declared as part of a function’s body, where it’s <span aria-label="52" epub:type="pagebreak" id="pg_52" role="doc-pagebreak"/>customary for all code to have some level of indention. This way, you can write cleaner-looking heredocs that adhere to the indention conventions of the code around them. We’ll meet functions in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>.</p>
<blockquote>
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>
</blockquote>
<p class="NOTE-TXT"><i>If any lines in a heredoc have less indention than the closing delimiter, or if they have a different kind of indention (such as a tab character instead of spaces), an error will occur at runtime.</i></p>
</section>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h3 class="H1" id="sec10"><span id="toc-link_42"/><span class="SANS_Futura_Std_Bold_B_11">Nowdocs</span></h3>
<p class="TNI1">The last style of PHP string is the <i>nowdoc</i>, an unparsed string written with the <span class="SANS_TheSansMonoCd_W5Regular_11">&lt;&lt;&lt;</span> operator and delimiters. Essentially, the nowdoc is to unparsed single-quoted strings what the heredoc is to parsed double-quoted strings. The only difference between declaring a nowdoc and a heredoc is that the opening delimiter for the nowdoc must be enclosed in single quotes, as in <span class="SANS_TheSansMonoCd_W5Regular_11">&lt;&lt;&lt;'EOL'</span>. The closing delimiter isn’t written with single quotes.</p>
<p class="TX">One use of nowdocs is for printing out PHP code. Since nowdocs are unparsed, any code, including variable names, will be reproduced literally in the string expression. <a href="#lis3-8">Listing 3-8</a> shows an example.</p>
<span id="lis3-8"/>
<pre><code>&lt;?php&#13;
<span aria-label="annotation1" class="codeannotated_CodeAnnotation">❶</span> $name = "Matt Smith";&#13;
&#13;
<span aria-label="annotation2" class="codeannotated_CodeAnnotation">❷</span> $codeSample = &lt;&lt;&lt;'PHP'&#13;
    $message = "hello \n world \n on 3 lines!";&#13;
    $age = 21;&#13;
  <span aria-label="annotation3" class="Code_CodeAnnotation">❸</span> print $name;&#13;
    print $age;&#13;
&#13;
    PHP;&#13;
&#13;
print $codeSample;</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 3-8: A script declaring a nowdoc that contains unparsed PHP code</span></p>
<p class="TX">First, we declare a <span class="SANS_TheSansMonoCd_W5Regular_11">$name</span> variable <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Then we declare a nowdoc by using the delimiter <span class="SANS_TheSansMonoCd_W5Regular_11">PHP</span> and assign it to the <span class="SANS_TheSansMonoCd_W5Regular_11">$codeSample</span> variable <span aria-label="annotation2" class="CodeAnnotation">❷</span>. (Notice that the starting delimiter is enclosed in single quotes, but the ending delimiter isn’t.) The nowdoc contains statements such as a variable declaration (<span class="SANS_TheSansMonoCd_W5Regular_11">$age</span>), strings with escaped characters, and a reference to our <span class="SANS_TheSansMonoCd_W5Regular_11">$name</span> variable <span aria-label="annotation3" class="CodeAnnotation">❸</span>. All of this goes unparsed when we print the nowdoc, as you can see in the output:</p>
<pre><code>$message = "hello \n world \n on 3 lines!";&#13;
$age = 21;&#13;
print $name;&#13;
print $age;</code></pre>
<p class="TX"><span aria-label="53" epub:type="pagebreak" id="pg_53" role="doc-pagebreak"/>The entire nowdoc has been printed verbatim, including the escape sequences and the characters <span class="SANS_TheSansMonoCd_W5Regular_11">$name</span>. No program statements within the nowdoc were executed; they just became part of the declared nowdoc string. Notice, however, that the indention in the nowdoc has been stripped away, since it matches the indention of the closing delimiter. This works just as with heredocs.</p>
<p class="TX">We’ve finished our overview of the four styles of strings. Deciding which to use is often a matter of personal preference. In general, single quotes are best for short strings that don’t include variables that require parsing. For longer, multiline strings with no parsing, consider using nowdocs. If you need to incorporate parsed variables, use double quotes for shorter strings or heredocs for longer, multiline strings.</p>
</section>
<section aria-labelledby="sec11" epub:type="division">
<h3 class="H1" id="sec11"><span id="toc-link_43"/><span class="SANS_Futura_Std_Bold_B_11">Built-in String Functions</span></h3>
<p class="TNI1">PHP has more than 100 built-in functions for manipulating and analyzing strings, ranging from standard tasks like toggling between uppercase and lowercase letters to more specialized tasks such as implementing hash algorithms. We’ll look at a few of the most commonly used string functions in this section.</p>
<p class="TX">If you’re coming to PHP from another language, you may be used to seeing these kinds of operations as methods that are called directly on the strings themselves. Since PHP wasn’t originally object-oriented, however, the operations instead exist as stand-alone functions.</p>
<blockquote>
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>
</blockquote>
<p class="NOTE-TXT"><i>For a complete list of PHP’s string functions, see</i> <span class="note_LinkURL"><a href="https://www.php.net/manual/ref.strings.php">https://www.php.net/manual/ref.strings.php</a></span><i>.</i></p>
<section aria-labelledby="sec12" epub:type="division">
<h4 class="H2" id="sec12"><span id="toc-link_44"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Converting to Upper- and Lowercase</span></h4>
<p class="TNI1">When working with user input, you’ll often need to standardize strings by ensuring that they all follow the same capitalization rules. This makes it easier to compare strings, or to store text in a database or send it to an API using a consistent format. To that end, PHP has functions for adjusting the capitalization of a string. The <span class="SANS_TheSansMonoCd_W5Regular_11">strtolower()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">strtoupper()</span> functions convert all the letters to lowercase or uppercase, respectively. Here are some examples illustrated using PHP’s interactive mode:</p>
<pre><code>php &gt; <b>$myString = 'the CAT sat on the Mat';</b>&#13;
php &gt; <b>print strtolower($myString);</b>&#13;
the cat sat on the mat&#13;
php &gt; <b>print strtoupper($myString);</b>&#13;
THE CAT SAT ON THE MAT</code></pre>
<p class="TX">We declare a string with a mix of uppercase and lowercase letters. Passing the string to the <span class="SANS_TheSansMonoCd_W5Regular_11">strtolower()</span> function converts everything to lowercase, while passing it to <span class="SANS_TheSansMonoCd_W5Regular_11">strtoupper()</span> converts everything to uppercase.</p>
<p class="TX"><span aria-label="54" epub:type="pagebreak" id="pg_54" role="doc-pagebreak"/>PHP’s <span class="SANS_TheSansMonoCd_W5Regular_11">ucfirst()</span> function capitalizes just the first letter of a string, if it isn’t capitalized already. This is useful when creating messages to be output to the user; capitalizing the first letter helps make the messages look like grammatically correct sentences:</p>
<pre><code>php &gt; <b>$badGrammar = 'some people don\'t type with capital letters.';</b>&#13;
php &gt; <b>print ucfirst($badGrammar);</b>&#13;
Some people don't type with capital letters.</code></pre>
<p class="TX">The related function <span class="SANS_TheSansMonoCd_W5Regular_11">lcfirst()</span> lowercases just the first letter of a string:</p>
<pre><code>php &gt; <b>$worseGrammar = 'SOME PEOPLE TYPE WITH ALL CAPS.';</b>&#13;
php &gt; <b>print lcfirst($worseGrammar);</b>&#13;
sOME PEOPLE TYPE WITH ALL CAPS.</code></pre>
<p class="TX">Often this isn’t much of a grammatical improvement, but it can be useful, for example, if you’re writing a script to output code. In this case, to follow the naming conventions of the programming language (such as for variables), it can be important to ensure that the first character of a string is lowercase.</p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">ucwords()</span> function capitalizes the first letter of every word in a string. PHP can distinguish between the different words if they’re separated by whitespace:</p>
<pre><code>php &gt; <b>$mixedCaps = 'some peoPLE use CAPS spoRADically.';</b>&#13;
php &gt; <b>print ucwords($mixedCaps);</b>&#13;
Some PeoPLE Use CAPS SpoRADically.</code></pre>
<p class="TX">Notice that if any subsequent letters in a word are capitalized, they remain so. Only the first letter of each word is affected. PHP doesn’t have an equivalent function for lowercasing the first letter of each word.</p>
</section>
<section aria-labelledby="sec13" epub:type="division">
<h4 class="H2" id="sec13"><span id="toc-link_45"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Searching and Counting</span></h4>
<p class="TNI1">Several of PHP’s built-in string functions serve analytical purposes, such as reporting the length of a string, searching for a character or substring within a string, or counting the number of occurrences of a character or substring within a string. (A <i>substring</i> is a portion of a larger string.) Before we examine these functions, though, it’s important to distinguish between the <i>number</i> of characters in a string and the <i>position</i> of each character within that string.</p>
<p class="TX">Take the string <span class="SANS_TheSansMonoCd_W5Regular_11">'cat scat'</span> as an example. It consists of eight characters (the space in the middle counts), but character positions in PHP are numbered starting from zero. Thus, the character at position <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> is <span class="SANS_TheSansMonoCd_W5Regular_11">c</span>, at position <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> is <span class="SANS_TheSansMonoCd_W5Regular_11">a</span>, and so on up to the final <span class="SANS_TheSansMonoCd_W5Regular_11">t</span> at position <span class="SANS_TheSansMonoCd_W5Regular_11">7</span>. This counting from zero is called <i>zero-based indexing</i> and is common in computer programming. Using this system, we can say that the substring <span class="SANS_TheSansMonoCd_W5Regular_11">'cat'</span> occurs twice in the string, starting at position <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> for the first occurrence and at position <span class="SANS_TheSansMonoCd_W5Regular_11">5</span> for the second:</p>
<pre><code><span aria-label="55" epub:type="pagebreak" id="pg_55" role="doc-pagebreak"/>cat scat&#13;
01234567&#13;
cat  cat</code></pre>
<p class="TX">With this in mind, let’s try out some analytical string functions on the string <span class="SANS_TheSansMonoCd_W5Regular_11">'cat scat'</span>. First, the <span class="SANS_TheSansMonoCd_W5Regular_11">strlen()</span> function reports the length of a string, as shown here in PHP’s interactive mode:</p>
<pre><code>php &gt; <b>$myString = 'cat scat';</b>&#13;
php &gt; <b>print strlen($myString);</b>&#13;
8</code></pre>
<p class="BodyContinued">As expected, this tells us that <span class="SANS_TheSansMonoCd_W5Regular_11">'cat scat'</span> is eight characters long.</p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">substr_count()</span> function counts the number of times a substring appears within a string. Here, for example, we count the instances of the substring <span class="SANS_TheSansMonoCd_W5Regular_11">'cat'</span>:</p>
<pre><code>php &gt; <b>$myString = 'cat scat';</b>&#13;
php &gt; <b>print substr_count($myString, 'cat');</b>&#13;
2</code></pre>
<p class="TX">We pass two strings to the <span class="SANS_TheSansMonoCd_W5Regular_11">substr_count()</span> function. The first is the string we want to search <i>in</i>, which here we’re providing as the <span class="SANS_TheSansMonoCd_W5Regular_11">$myString</span> variable. The second is the string we want to search <i>for</i>: in this case, <span class="SANS_TheSansMonoCd_W5Regular_11">'cat'</span>. In computer search terminology, these two strings are often referred to as the <i>haystack</i> and the <i>needle</i>, respectively, after the expression “looking for a needle in a haystack.”</p>
<blockquote>
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>
</blockquote>
<p class="NOTE-TXT"><i>The items entered within the parentheses of a function, such as</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">$myString</span> <i>and</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">'cat'</span> <i>in the preceding example, are called</i> <span class="note">arguments</span><i>. They’re pieces of data that the function needs to do its job. We’ll discuss functions in detail in <a href="chapter5.xhtml">Chapter 5</a>.</i></p>
<p class="TX">Most PHP functions that involve searching within a string, including <span class="SANS_TheSansMonoCd_W5Regular_11">substr_count()</span>, are case sensitive, so it’s important to be careful about capitalization. If we try searching <span class="SANS_TheSansMonoCd_W5Regular_11">'cat scat'</span> for the substring <span class="SANS_TheSansMonoCd_W5Regular_11">'Cat'</span> instead of <span class="SANS_TheSansMonoCd_W5Regular_11">'cat'</span>, for example, we’ll end up with a count of <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>:</p>
<pre><code>php &gt; <b>$myString = 'cat scat';</b>&#13;
php &gt; <b>print substr_count($myString, 'Cat');</b>&#13;
0</code></pre>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">strpos()</span> function reports the starting position (counting from zero) of a substring within a string. If the substring occurs multiple times, only the position of the first occurrence is given. Here we search for the first occurrence of the substring <span class="SANS_TheSansMonoCd_W5Regular_11">'cat'</span>:</p>
<pre><code>php &gt; <b>$myString = 'cat scat';</b>&#13;
php &gt; <b>print strpos($myString, 'cat');</b>&#13;
0</code></pre>
<p class="BodyContinued"><span aria-label="56" epub:type="pagebreak" id="pg_56" role="doc-pagebreak"/>As with <span class="SANS_TheSansMonoCd_W5Regular_11">substr_count()</span>, we provide two strings to the <span class="SANS_TheSansMonoCd_W5Regular_11">strpos()</span> function as arguments, first the haystack and then the needle. The function reports the first occurrence of <span class="SANS_TheSansMonoCd_W5Regular_11">'cat'</span> at position <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>.</p>
<p class="TX">Optionally, you can provide an <i>offset</i> to the <span class="SANS_TheSansMonoCd_W5Regular_11">strpos()</span> function as an additional argument, a number that tells it to start searching for the substring from a different position, rather than from the beginning of the string. Here we tell the function to start searching from position <span class="SANS_TheSansMonoCd_W5Regular_11">2</span> onward:</p>
<pre><code>php &gt; <b>$myString = 'cat scat';</b>&#13;
php &gt; <b>print strpos($myString, 'cat', 2);</b>&#13;
5</code></pre>
<p class="TX">This time, since the function isn’t searching from the beginning of the string, it identifies the second occurrence of <span class="SANS_TheSansMonoCd_W5Regular_11">'cat'</span> at position <span class="SANS_TheSansMonoCd_W5Regular_11">5</span>. If the function can’t find any occurrences of the needle within the haystack, it reports <span class="SANS_TheSansMonoCd_W5Regular_11">false</span>.</p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">count_chars()</span> function analyzes which characters are, and are not, included in a string. It’s a powerful string analysis function that you might use when evaluating the complexity of a password or perhaps for data encryption and decryption tasks. It has a few modes, which you specify as a number when the function is called. In the following example, we use mode 3, which generates a new string consisting of all the unique characters used in the string being analyzed:</p>
<pre><code>php &gt; <b>$myString = 'cat scat';</b>&#13;
php &gt; <b>print count_chars($myString, 3);</b>&#13;
acst</code></pre>
<p class="TX">We call the <span class="SANS_TheSansMonoCd_W5Regular_11">count_chars()</span> function on <span class="SANS_TheSansMonoCd_W5Regular_11">$myString</span>, specifying mode 3. The resulting string features one instance of each character from <span class="SANS_TheSansMonoCd_W5Regular_11">'cat scat'</span>, arranged in alphabetical order. It shows us that <span class="SANS_TheSansMonoCd_W5Regular_11">'cat scat'</span> includes only the letters <i>a</i>, <i>c</i>, <i>s</i>, and <i>t</i>.</p>
<blockquote>
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>
</blockquote>
<p class="NOTE-TXT"><i>The</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">count_chars()</span> <i>function has other modes that count the number of occurrences of each character, but the result is reported as an array, so we won’t consider those modes here. We’ll discuss arrays in <a href="chapter7.xhtml">Chapters 7</a> and <a href="chapter8.xhtml">8</a>.</i></p>
</section>
<section aria-labelledby="sec14" epub:type="division">
<h4 class="H2" id="sec14"><span id="toc-link_46"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Extracting and Replacing Substrings</span></h4>
<p class="TNI1">Other PHP functions manipulate strings by extracting a portion of the string or replacing a portion with something else. For example, the <span class="SANS_TheSansMonoCd_W5Regular_11">substr()</span> function extracts part of a string, starting from a given position. Here’s how it works:</p>
<pre><code>php &gt; <b>$warning = 'do not enter';</b>&#13;
php &gt; <b>print substr($warning, 7);</b>&#13;
enter</code></pre>
<p class="TX"><span aria-label="57" epub:type="pagebreak" id="pg_57" role="doc-pagebreak"/>We declare a variable with the string <span class="SANS_TheSansMonoCd_W5Regular_11">'do not enter'</span>, then pass it to the <span class="SANS_TheSansMonoCd_W5Regular_11">substr()</span> function. The number <span class="SANS_TheSansMonoCd_W5Regular_11">7</span> tells the function to extract all the characters from position <span class="SANS_TheSansMonoCd_W5Regular_11">7</span> to the end, giving us <span class="SANS_TheSansMonoCd_W5Regular_11">enter</span> as a result.</p>
<p class="TX">If you use a negative number instead, the function makes the extraction counting from the end of the string. For example, here we use <span class="SANS_TheSansMonoCd_W5Regular_11">-2</span> to get just the last two characters:</p>
<pre><code>php &gt; <b>$warning = 'do not enter';</b>&#13;
php &gt; <b>print substr($warning, -2);</b>&#13;
er</code></pre>
<p class="TX">You can optionally include a second number in the function call to specify a length for the extraction. Here, for example, we extract just three characters from the string, starting from position <span class="SANS_TheSansMonoCd_W5Regular_11">7</span>:</p>
<pre><code>php &gt; <b>$warning = 'do not enter';</b>&#13;
php &gt; <b>print substr($warning, 7, 3);</b>&#13;
ent</code></pre>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">strstr()</span> function provides another technique for extracting part of a string. By default, it searches for the first occurrence of a substring within a string and extracts the contents of the string from that substring on. Here, for example, we search for the substring <span class="SANS_TheSansMonoCd_W5Regular_11">'@'</span> to extract just the domain name and extension from an email address:</p>
<pre><code>php &gt; <b>$email = 'the.cat@aol.com';</b>&#13;
php &gt; <b>print strstr($email, '@');</b>&#13;
@aol.com</code></pre>
<p class="TX">The function searches for the first occurrence of an @ sign and reports everything in the string from that point on, including the @ sign itself. We can also use <span class="SANS_TheSansMonoCd_W5Regular_11">strstr()</span> to extract everything in the string <i>before</i> the first occurrence of the substring. For that, add <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> to the end of the function call, like this:</p>
<pre><code>php &gt; <b>$email = 'the.cat@aol.com';</b>&#13;
php &gt; <b>print strstr($email, '@', true);</b>&#13;
the.cat</code></pre>
<p class="TX">Again, we search the string for the first occurrence of an @ sign, but this time, thanks to the added <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>, the function reports the contents of the string up to but not including the @ sign. This gives us just the username from the email address.</p>
<blockquote>
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>
</blockquote>
<p class="NOTE-TXT"><i>The</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">strstr()</span> <i>function is case sensitive, but PHP provides a case-insensitive version called</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">stristr()</span><i>.</i></p>
<p class="TX"><span aria-label="58" epub:type="pagebreak" id="pg_58" role="doc-pagebreak"/>The <span class="SANS_TheSansMonoCd_W5Regular_11">str_replace()</span> function finds all occurrences of a substring within a string and replaces them with a different substring. The result of the replacement is reported as a new string, meaning the original string itself isn’t modified. Here’s an example:</p>
<pre><code>php &gt; <b>$foodchain = 'dogs eat cats, cats eat mice, mice eat cheese';</b>&#13;
php &gt; <b>print str_replace('eat', 'help', $foodchain);</b>&#13;
dogs help cats, cats help mice, mice help cheese&#13;
php &gt; <b>print $foodchain;</b>&#13;
dogs eat cats, cats eat mice, mice eat cheese</code></pre>
<p class="TX">When we call <span class="SANS_TheSansMonoCd_W5Regular_11">str_replace()</span>, we need to provide three strings. The first is the substring to search for (in this case, <span class="SANS_TheSansMonoCd_W5Regular_11">'eat'</span>). The second is the substring to replace it with (in this case, <span class="SANS_TheSansMonoCd_W5Regular_11">'help'</span>). The third is the string to search in, which we’ve assigned to the <span class="SANS_TheSansMonoCd_W5Regular_11">$foodchain</span> variable. The function generates a new string by replacing all instances of <span class="SANS_TheSansMonoCd_W5Regular_11">'eat'</span> with <span class="SANS_TheSansMonoCd_W5Regular_11">'help'</span>. Then we print the value of <span class="SANS_TheSansMonoCd_W5Regular_11">$foodchain</span> to confirm that it wasn’t affected by the function call.</p>
<p class="TX">To make the replacement somewhat permanent, store the result of calling <span class="SANS_TheSansMonoCd_W5Regular_11">str_replace()</span> in a new variable, like this:</p>
<pre><code>php &gt; <b>$foodchain = 'dogs eat cats, cats eat mice, mice eat cheese';</b>&#13;
<span aria-label="annotation1" class="codeannotated_CodeAnnotation">❶</span> php &gt; <b>$friendchain = str_replace('eat', 'help', $foodchain);</b>&#13;
php &gt; <b>print $foodchain;</b>&#13;
<span aria-label="annotation2" class="codeannotated_CodeAnnotation">❷</span> dogs eat cats, cats eat mice, mice eat cheese&#13;
php &gt; <b>print $friendchain;</b>&#13;
dogs help cats, cats help mice, mice help cheese</code></pre>
<p class="TX">This time when we call <span class="SANS_TheSansMonoCd_W5Regular_11">str_replace()</span>, we assign the result to <span class="SANS_TheSansMonoCd_W5Regular_11">$friendchain</span> <span aria-label="annotation1" class="CodeAnnotation">❶</span>. The original <span class="SANS_TheSansMonoCd_W5Regular_11">$foodchain</span> variable is still unaffected by the replacement operation <span aria-label="annotation2" class="CodeAnnotation">❷</span>, but at least now we have the modified string available in a variable for later use.</p>
<p class="TX">Another replacement function is <span class="SANS_TheSansMonoCd_W5Regular_11">substr_replace()</span>. Rather than specifying a substring that should be replaced, this function lets you specify the position in the string at which the replacement should occur. Here’s an example:</p>
<pre><code>php &gt; <b>$foodchain = 'dogs eat cats, cats eat mice, mice eat cheese';</b>&#13;
php &gt; <b>print substr_replace($foodchain, 'help', 5, 3);</b>&#13;
dogs help cats, cats eat mice, mice eat cheese</code></pre>
<p class="TX">When we call the <span class="SANS_TheSansMonoCd_W5Regular_11">substr_replace()</span> function, we first provide the original string (in <span class="SANS_TheSansMonoCd_W5Regular_11">$foodchain</span>) and the replacement string (<span class="SANS_TheSansMonoCd_W5Regular_11">'help'</span>). Then we provide two numbers as additional arguments. The first, <span class="SANS_TheSansMonoCd_W5Regular_11">5</span>, is the position in the original string where the replacement should begin. The second, <span class="SANS_TheSansMonoCd_W5Regular_11">3</span>, is the number of characters in the original string that should be replaced, starting from the specified position. This has the effect of replacing the first instance of the word <i>eat</i> (which is three characters long and starts at position <span class="SANS_TheSansMonoCd_W5Regular_11">5</span>) with the word <i>help</i>, while leaving the rest of the string as is.</p>
<p class="TX">By setting the replacement length to <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>, we can use <span class="SANS_TheSansMonoCd_W5Regular_11">substr_replace()</span> to insert a substring into a string without otherwise altering it, like so:</p>
<pre><code><span aria-label="59" epub:type="pagebreak" id="pg_59" role="doc-pagebreak"/>php &gt; <b>$foodchain = 'dogs eat cats, cats eat mice, mice eat cheese';</b>&#13;
php &gt; <b>print substr_replace($foodchain, 'don\'t ', 5, 0);</b>&#13;
dogs don't eat cats, cats eat mice, mice eat cheese</code></pre>
<p class="BodyContinued">This inserts the word <i>don’t</i> into the <span class="SANS_TheSansMonoCd_W5Regular_11">$foodchain</span> string starting at position <span class="SANS_TheSansMonoCd_W5Regular_11">5</span>, without replacing any characters.</p>
</section>
<section aria-labelledby="sec15" epub:type="division">
<h4 class="H2" id="sec15"><span id="toc-link_47"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Trimming Whitespace</span></h4>
<p class="TNI1">Often it’s necessary to remove whitespace from the beginning or end of a string, a task known as <i>trimming</i>. PHP provides three trimming functions:</p>
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">trim()</span>   Removes whitespace from the beginning <i>and</i> end of a string</p>
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">ltrim()</span>   Removes whitespace from the beginning of a string (<i>l</i> is for <i>left</i>)</p>
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">rtrim()</span>   Removes whitespace the from end of a string (<i>r</i> is for <i>right</i>)</p>
<p class="TX">All three functions work in the same way: given a string, they remove any space, tab, vertical tab, newline, carriage return, or American Standard Code for Information Interchange (ASCII) null-byte characters, up to the first non-whitespace character and/or after the last non-whitespace character in the string. Here, for example, we use <span class="SANS_TheSansMonoCd_W5Regular_11">trim()</span> to remove the spaces and newline characters at the start and end of a string:</p>
<pre><code>php &gt; <b>$tooSpacey = "    \n\nCAT\nDOG\n\n";</b>&#13;
php &gt; <b>print trim($tooSpacey);</b>&#13;
CAT&#13;
DOG</code></pre>
<p class="TX">The output shows that the newlines and the beginning and end of the string have been trimmed, but notice that a newline still remains between the words <i>CAT</i> and <i>DOG</i>. The trim functions have no effect on any whitespace in the middle of a string.</p>
<p class="TX">You can optionally control which whitespace characters are trimmed by specifying them in a separate double-quoted string when calling the function. Here’s an example:</p>
<pre><code>php &gt; <b>$evenSpacier = "\n\n    CAT\nDOG\n\n";</b>&#13;
php &gt; <b>print ltrim($evenSpacier, </b><span aria-label="annotation1" class="Code_CodeAnnotation">❶</span> <b>"\n");</b>&#13;
    CAT&#13;
DOG&#13;
<span aria-label="annotation2" class="codeannotated_CodeAnnotation">❷</span>&#13;
php &gt;</code></pre>
<p class="TX">This time we use the string <span class="SANS_TheSansMonoCd_W5Regular_11">"\n"</span> <span aria-label="annotation1" class="CodeAnnotation">❶</span> to specify that only newline characters should be trimmed. In the output, notice that the spaces before the word <span class="SANS_TheSansMonoCd_W5Regular_11">CAT</span> have been preserved, since the function ignored all but newline characters. The blank line <span aria-label="annotation2" class="CodeAnnotation">❷</span> before the next prompt also indicates that the newlines at the end of the string were left in place, since the <span class="SANS_TheSansMonoCd_W5Regular_11">ltrim()</span> function affects only the start of the string.</p>
</section>
<section aria-labelledby="sec16" epub:type="division">
<span aria-label="60" epub:type="pagebreak" id="pg_60" role="doc-pagebreak"/>
<h4 class="H2" id="sec16"><span id="toc-link_48"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Removing All Unnecessary Whitespace</span></h4>
<p class="TNI1">To remove whitespace from throughout a string, not just the edges, use <span class="SANS_TheSansMonoCd_W5Regular_11">str_replace()</span> to find all instances of a particular whitespace character and replace them with empty strings. For example, here we use this technique to get rid of all the tab characters in a string:</p>
<pre><code>php &gt; <b>$tooTabby = "\tCat \tDog \t\tMouse";</b>&#13;
php &gt; <b>print $tooTabby;</b>&#13;
    Cat     Dog         Mouse&#13;
php &gt; <b>print str_replace("\t", '', $tooTabby);</b>&#13;
Cat Dog Mouse</code></pre>
<p class="TX">The string assigned to <span class="SANS_TheSansMonoCd_W5Regular_11">$tooTabby</span> contains several tab characters. Replacing each instance of <span class="SANS_TheSansMonoCd_W5Regular_11">"\t"</span> with <span class="SANS_TheSansMonoCd_W5Regular_11">''</span> (an empty string) gets rid of the tabs while preserving the regular spaces between each word.</p>
<p class="TX"><a href="#lis3-9">Listing 3-9</a> pushes this technique even further, repeatedly using <span class="SANS_TheSansMonoCd_W5Regular_11">str_replace()</span> to remove any whitespace from a string except for a single space character between words. This includes getting rid of tabs, newlines, and multiple space characters in a row.</p>
<span id="lis3-9"/>
<pre><code>&lt;?php&#13;
<span aria-label="annotation1" class="codeannotated_CodeAnnotation">❶</span> $string1 = &lt;&lt;&lt;EOT&#13;
the&#13;
    cat     sat&#13;
    \t\t on    the&#13;
mat&#13;
&#13;
&#13;
EOT;&#13;
&#13;
<span aria-label="annotation2" class="codeannotated_CodeAnnotation">❷</span> $noTabs = str_replace("\t", ' ', $string1);&#13;
$noNewlines = str_replace("\n", ' ', $noTabs);&#13;
&#13;
<span aria-label="annotation3" class="codeannotated_CodeAnnotation">❸</span> $output = str_replace('  ', ' ', $noNewlines);&#13;
$output = str_replace('  ', ' ', $output);&#13;
$output = str_replace('  ', ' ', $output);&#13;
&#13;
$output = trim($output);&#13;
&#13;
print "[$output]";</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 3-9: Replacing all whitespace (except single space characters) in a string</span></p>
<p class="TX">We use a heredoc to declare the <span class="SANS_TheSansMonoCd_W5Regular_11">$string1</span> variable, which contains tabs, newline characters, and multiple spaces in a row between words <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Then we use the <span class="SANS_TheSansMonoCd_W5Regular_11">str_replace()</span> function twice, first to replace all tabs with a single space, and a second time to replace all newline characters with a single space <span aria-label="annotation2" class="CodeAnnotation">❷</span>. (We don’t replace them with empty strings in case a tab or newline is the only character between two words.)</p>
<p class="TX"><span aria-label="61" epub:type="pagebreak" id="pg_61" role="doc-pagebreak"/>Next, we repeatedly use <span class="SANS_TheSansMonoCd_W5Regular_11">str_replace()</span> to replace any instances of two space characters with a single space <span aria-label="annotation3" class="CodeAnnotation">❸</span>. It takes three function calls before only single spaces are left. (In <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>, we’ll delve into loops, which provide a more efficient way to repeat the same code several times, or until a particular condition is satisfied.) For good measure, we use <span class="SANS_TheSansMonoCd_W5Regular_11">trim()</span> to remove any lingering whitespace at the start or end of the string before printing out the resulting string, enclosed in square brackets so it’s easier to see where it starts and ends. Here’s the output of running this script:</p>
<pre><code>[the cat sat on the mat]</code></pre>
<p class="TX">The final string has no whitespace before or after it and only single spaces between each word. All the extra whitespace has been removed.</p>
</section>
<section aria-labelledby="sec17" epub:type="division">
<h4 class="H2" id="sec17"><span id="toc-link_49"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Repeating and Padding</span></h4>
<p class="TNI1">Some PHP string functions work by repeating a character or substring to generate a longer string. For example, to create a new string by repeating a string a given number of times, use <span class="SANS_TheSansMonoCd_W5Regular_11">str_repeat()</span>, like this:</p>
<pre><code>php &gt; <b>$lonely = 'Cat';</b>&#13;
php &gt; <b>print str_repeat($lonely, 5);</b>&#13;
CatCatCatCatCat</code></pre>
<p class="BodyContinued">This gives our lonely string some company by repeating <span class="SANS_TheSansMonoCd_W5Regular_11">'Cat'</span> five times.</p>
<p class="TX">Closely related to repeating is <i>padding</i>: a character or substring is repeatedly added to the beginning or end of a string until the string reaches a desired length. Padding is useful, for example, if you’re displaying multiple numbers of different lengths and you want their digits to line up nicely. In that case, you might add spaces or zeros as padding in front of the numbers, as shown here:</p>
<pre><code>     12 // padded with spaces&#13;
   1099&#13;
&#13;
000001 // padded with zeros&#13;
000855</code></pre>
<p class="TX">PHP has a <span class="SANS_TheSansMonoCd_W5Regular_11">str_pad()</span> function for such padding tasks. Here, for example, we pad the string <span class="SANS_TheSansMonoCd_W5Regular_11">'Cat'</span> with hyphens (<span class="SANS_TheSansMonoCd_W5Regular_11">-</span>) until it’s 20 characters long:</p>
<pre><code>php &gt; <b>$tooShort = 'Cat';</b>&#13;
php &gt; <b>print str_pad($tooShort, 20, '-');</b>&#13;
Cat-----------------</code></pre>
<p class="TX">We call <span class="SANS_TheSansMonoCd_W5Regular_11">str_pad()</span>, providing the original string (<span class="SANS_TheSansMonoCd_W5Regular_11">$tooShort</span>), the desired length (<span class="SANS_TheSansMonoCd_W5Regular_11">20</span>), and the string to use as padding (<span class="SANS_TheSansMonoCd_W5Regular_11">'-'</span>). By default, PHP adds the padding to the right of the original string, but you can add the constants <span aria-label="62" epub:type="pagebreak" id="pg_62" role="doc-pagebreak"/><span class="SANS_TheSansMonoCd_W5Regular_11">STR_PAD_LEFT</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">STR_PAD_BOTH</span> to the function call to place the padding on the left or to pad both sides equally instead. Here are some examples:</p>
<pre><code>php &gt; <b>$tooShort = 'Cat';</b>&#13;
php &gt; <b>print str_pad($tooShort, 20, '-', STR_PAD_LEFT);</b>&#13;
-----------------Cat&#13;
php &gt; <b>print str_pad($tooShort, 20, '-', STR_PAD_BOTH);</b>&#13;
--------Cat---------</code></pre>
<p class="TX">In each case, the function adds hyphens until the resulting string is 20 characters long.</p>
</section>
</section>
<section aria-labelledby="sec18" epub:type="division">
<h3 class="H1" id="sec18"><span id="toc-link_50"/><span class="SANS_Futura_Std_Bold_B_11">Summary</span></h3>
<p class="TNI1">Strings are a core data type that you’ll probably use in every web application you create. In this chapter, you learned about the four ways to declare strings: single-quoted strings, double-quoted strings, heredocs, and nowdocs. You saw how double-quoted strings and heredocs are parsed and so can incorporate variables, while single-quoted strings and nowdocs are not. You also tried out PHP’s built-in functions for working with strings, and you learned how to combine strings by using the <span class="SANS_TheSansMonoCd_W5Regular_11">.</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">.=</span> operators.</p>
</section>
<section aria-labelledby="sec19" epub:type="division">
<h3 class="H1" id="sec19"><span id="toc-link_51"/><span class="SANS_Futura_Std_Bold_B_11">Exercises</span></h3>
<p class="ListNumber">1.   Write a script that declares a <span class="SANS_TheSansMonoCd_W5Regular_11">$name</span> variable containing your name as a single-quoted string. Then include a <span class="SANS_TheSansMonoCd_W5Regular_11">print</span> statement that uses the string concatenation operator (<span class="SANS_TheSansMonoCd_W5Regular_11">.</span>) to combine the contents of <span class="SANS_TheSansMonoCd_W5Regular_11">$name</span> with the string <span class="SANS_TheSansMonoCd_W5Regular_11">' is learning PHP'</span>. When you run your script, the output should look something like this:</p>
<pre><code>Matt is learning PHP</code></pre>
<p class="ListNumber">2.   In a script, create a <span class="SANS_TheSansMonoCd_W5Regular_11">$fruit</span> variable containing the string <span class="SANS_TheSansMonoCd_W5Regular_11">'apple'</span>. Then use a double-quoted string and a <span class="SANS_TheSansMonoCd_W5Regular_11">print</span> statement to output the following message:</p>
<pre><code>apple juice is made from apples.</code></pre>
<p class="ListBody">Change your script so that <span class="SANS_TheSansMonoCd_W5Regular_11">$fruit</span> contains <span class="SANS_TheSansMonoCd_W5Regular_11">orange</span>, leading to the following output:</p>
<pre><code>orange juice is made from oranges.</code></pre>
<p class="ListBody">Hint: You’ll need to use curly brackets to create the plural fruit names from the <span class="SANS_TheSansMonoCd_W5Regular_11">$fruit</span> variable.</p>
<p class="ListNumber"><span aria-label="63" epub:type="pagebreak" id="pg_63" role="doc-pagebreak"/>3.   Write a script that declares a heredoc string variable <span class="SANS_TheSansMonoCd_W5Regular_11">$happyMessage</span> containing the following (including the newlines):</p>
<figure class="IMG-LE"><img alt="" class="img100" height="190" src="../images/pg63.jpg" width="1317"/>
</figure>
<p class="ListBody">Print out the contents of the <span class="SANS_TheSansMonoCd_W5Regular_11">$happyMessage</span> variable.</p>
<p class="ListNumber">4.   In a script, create an <span class="SANS_TheSansMonoCd_W5Regular_11">$appleJuice</span> variable containing the string <span class="SANS_TheSansMonoCd_W5Regular_11">'apple juice is made from apples.'</span> Then use the <span class="SANS_TheSansMonoCd_W5Regular_11">str_replace()</span> function to create a new string variable, <span class="SANS_TheSansMonoCd_W5Regular_11">$grapefruitJuice</span>, containing the string <span class="SANS_TheSansMonoCd_W5Regular_11">'grapefruit juice is made from grapefruits.'</span> Try using other PHP functions to further transform the string. For example, capitalize the first letter of the string so it looks like a grammatically correct sentence.</p>
</section>
</section>
</div></body></html>