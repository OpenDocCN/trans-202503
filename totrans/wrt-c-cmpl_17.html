<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch15">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_382" aria-label="382"/>&#13;
<figure class="co-img"><img id="fig-pg382" class="img60" src="../images/pg382.jpg" alt="" width="687" height="1737"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11"> <a href="description-38.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_383" aria-label="383"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch15">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">15</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">ARRAYS AND POINTER ARITHMETIC</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
&#13;
<figure class="opener"><img class="opener" src="../images/opener-img.jpg" alt="" width="407" height="405"/></figure>&#13;
<p class="ChapterIntro">In this chapter, you’ll implement array types. You’ll also add the main language features that programmers use to work with arrays: compound initializers, subscript operators, and pointer arithmetic. Arrays and pointers are distinct but closely related types. Many expressions of array type are implicitly converted to pointers, and many pointer operations, like subscripting, are meant to operate on pointers to array elements. So, to support arrays, you’ll build on the support for pointers that you added in the previous chapter.</p>&#13;
<p class="TX">The type checker plays an especially critical role here. It will handle the implicit conversions from arrays to pointers and annotate the AST with the type information you’ll rely on to perform pointer arithmetic. Once the type checker has done all the hard work, it will be relatively easy to break down <span role="doc-pagebreak" epub:type="pagebreak" id="pg_384" aria-label="384"/>subscript operators and compound initializers into simple pointer operations during TACKY generation. You won’t add any new assembly instructions in this chapter, but you’ll introduce new operands to represent objects in memory and elements within those objects.</p>&#13;
<p class="TX">As usual, we’ll start with an overview of the language constructs we’re going to add. We’ll pay special attention to the relationship between pointers and arrays and how this relationship plays out in pointer arithmetic and subscript expressions. This is a particularly confusing aspect of C, and it’s key to everything we’ll do in this chapter.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-129"/><samp class="SANS_Futura_Std_Bold_B_11">Arrays and Pointer Arithmetic</samp></h3>&#13;
<p class="TNI">Let’s define a few terms up front. In the last chapter, we divided every object type we knew about into two categories: arithmetic types and non-arithmetic types. Now we’ll introduce another distinction. A <i>scalar type</i> represents a single value. The pointer and arithmetic types we’ve already implemented are all scalar types. An <i>aggregate type</i> represents a collection of values. Arrays are aggregate types; so are structures, which we’ll implement in <span class="Xref-1"><a href="chapter18.xhtml">Chapter 18</a></span>. All the values in an array have the same type, which is the array’s <i>element type</i>.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h4 class="H2" id="sec2"><span id="h2-133"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Array Declarations and Initializers</samp></h4>&#13;
<p class="TNI">When we declare an array, we specify its element type and how many elements it contains. For example, we could declare an array of three <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> objects:</p>&#13;
<pre><code>int int_array[3];</code></pre>&#13;
<p class="TX">Or we could declare an array of five pointers to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>:</p>&#13;
<pre><code>double *(ptr_array[5]);</code></pre>&#13;
<p class="TX">(Remember that we interpret a declaration by starting with the basic type—<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, in this case—and then applying type derivations from the outside in.)</p>&#13;
<p class="TX">Both of these examples use scalar element types, but we can use aggregate element types too. The following example declares an array of three elements, where each element is itself an array of two <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> objects:</p>&#13;
<pre><code>long nested_array[3][2];</code></pre>&#13;
<p class="TX">Arrays of arrays like this one are called <i>multidimensional arrays</i>. Note that we still apply type derivations from the outside in to determine this array’s type. We start with the base type <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>, apply the derivation specified by <samp class="SANS_TheSansMonoCd_W5Regular_11">[2]</samp> to get the type “array of two <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> objects,” and then apply the derivation specified by <samp class="SANS_TheSansMonoCd_W5Regular_11">[3]</samp> to get the type “array of three arrays of two <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> objects.”</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_385" aria-label="385"/>You can initialize an array with a <i>compound initializer</i>, which specifies an initial value for each element:</p>&#13;
<pre><code>int int_array[3] = {1, foo(), a * 4};</code></pre>&#13;
<p class="TX">And you can initialize a multidimensional array with nested compound initializers:</p>&#13;
<pre><code>long nested_array[3][2] = {{a, a + 1}, {3l, -4}, {foo(), 6}};</code></pre>&#13;
<p class="TX">Here, the three nested compound initializers initialize the three elements of the outer array. Each of those three elements is, itself, an array of two <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> objects. The nested initializer for each of these elements specifies two arithmetic values (which can be implicitly converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>).</p>&#13;
<p class="TX">You can also leave an array uninitialized. If it has automatic storage duration, its initial value will be undefined. If it has static storage duration, it will be initialized to all zeros. In other words, we treat uninitialized arrays exactly like uninitialized scalar objects.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h2-134"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Memory Layout of Arrays</samp></h4>&#13;
<p class="TNI">At this point, it’s helpful to talk a bit about the memory layout of flat and multidimensional arrays. If you declare an array of <i>n</i> objects, those <i>n</i> objects will be laid out sequentially in memory. Consider the array in <a href="chapter15.xhtml#list15-1">Listing 15-1</a>, which has a scalar element type.</p>&#13;
<a id="list15-1"/>&#13;
<pre><code>int six_ints[6] = {1, 2, 3, 4, 5, 6};</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-1: An array of scalar values</samp></p>&#13;
<p class="TX"><a href="#fig15-1">Figure 15-1</a> shows what <samp class="SANS_TheSansMonoCd_W5Regular_11">six_ints</samp> might look like in memory right after it’s initialized (the memory addresses in this figure are just for illustration; they wouldn’t be valid on a real system).</p>&#13;
<figure class="IMG"><img id="fig15-1" class="img100" src="../images/fig15-1.jpg" alt="" width="1365" height="140"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-1: The layout of</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">six_ints in memory <a href="description-39.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Compare this declaration to <a href="chapter15.xhtml#list15-2">Listing 15-2</a>, which declares a multidimensional array with the same number and type of scalar elements as <samp class="SANS_TheSansMonoCd_W5Regular_11">six_ints</samp>.</p>&#13;
<a id="list15-2"/>&#13;
<pre><code>int three_arrays[3][2] = {{1, 2}, {3, 4}, {5, 6}};</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-2: An array of nested arrays</samp></p>&#13;
<p class="TX">The memory that holds <samp class="SANS_TheSansMonoCd_W5Regular_11">three_arrays</samp> will also look like <a href="#fig15-1">Figure 15-1</a>. In memory, there’s no indication of where one element ends and another begins, so the two arrays are indistinguishable. Although the nested <span role="doc-pagebreak" epub:type="pagebreak" id="pg_386" aria-label="386"/>structure of <samp class="SANS_TheSansMonoCd_W5Regular_11">three_arrays</samp> doesn’t impact its layout in memory, it does impact how you access individual array elements, as we’ll see shortly.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-135"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Array-to-Pointer Decay</samp></h4>&#13;
<p class="TNI">Once we’ve defined and initialized an array, what can we do with it? Not a lot, as it turns out. In fact, there are only two valid operations on objects of array type. First, we can get an array’s size with the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator, which we’ll implement in <span class="Xref-1"><a href="chapter17.xhtml">Chapter 17</a></span>. Second, we can get its address with the <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp> operator:</p>&#13;
<pre><code>int my_array[3] = {1, 2, 3};&#13;
int (*my_pointer)[3] = &amp;my_array;</code></pre>&#13;
<p class="TX">That’s it! There are no other valid operations on arrays. That probably sounds ridiculous, since C programs read and write array elements all the time. What’s going on here? The C standard (section 6.3.2.1, paragraph 3) provides the solution to this puzzle: “Except when it is the operand of the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator, or the unary <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp> operator … an expression that has type ‘array of <i>type</i>’ is converted to an expression with type ‘pointer to <i>type</i>’ that points to the initial element of the array object and is not an lvalue.”</p>&#13;
<p class="TX">This implicit conversion from arrays to pointers is called <i>array-to-pointer decay</i>. (I’ll sometimes say that an array decays to a pointer, and sometimes that it’s implicitly converted to a pointer. They both mean the same thing.) While we can’t do much with arrays, we can perform all sorts of useful operations on pointers. We’ve already implemented some of these operations, and we’ll add a few more in this chapter.</p>&#13;
<p class="TX">The code snippet in <a href="chapter15.xhtml#list15-3">Listing 15-3</a> shows an example of array decay.</p>&#13;
<a id="list15-3"/>&#13;
<pre><code>int my_array[3] = {1, 2, 3};&#13;
int *my_pointer = <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> my_array;&#13;
return <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> *my_pointer;</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-3: Implicitly converting an array to a pointer</samp></p>&#13;
<p class="TX">Let’s say <samp class="SANS_TheSansMonoCd_W5Regular_11">my_array</samp> starts at address <samp class="SANS_TheSansMonoCd_W5Regular_11">0x10</samp>. When <samp class="SANS_TheSansMonoCd_W5Regular_11">my_array</samp> appears on the right side of the assignment expression in this listing, it will be implicitly converted to a pointer whose type is <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp> and whose value is <samp class="SANS_TheSansMonoCd_W5Regular_11">0x10</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. We can then assign this pointer’s value to <samp class="SANS_TheSansMonoCd_W5Regular_11">my_pointer</samp>. When we dereference <samp class="SANS_TheSansMonoCd_W5Regular_11">my_pointer</samp>, the result is the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> object stored in the first 4 bytes of <samp class="SANS_TheSansMonoCd_W5Regular_11">my_array</samp> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Therefore, we’ll return this object’s current value, <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. Note that the address <samp class="SANS_TheSansMonoCd_W5Regular_11">0x10</samp> can be interpreted in a couple of different ways, depending on its type. As an <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>, it points to the array’s initial element, which we can read or write through a pointer dereference operation. The expression <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;my_array</samp> has the same value, <samp class="SANS_TheSansMonoCd_W5Regular_11">0x10</samp>, but it points to the whole array and its type is <samp class="SANS_TheSansMonoCd_W5Regular_11">int (*)[3]</samp>.</p>&#13;
<p class="TX">It’s especially important to keep track of a pointer’s type when working with multidimensional arrays. Consider <a href="chapter15.xhtml#list15-4">Listing 15-4</a>, which tries to assign to two array elements.</p>&#13;
<a id="list15-4"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_387" aria-label="387"/>int nested_array[2][2] = {{1, 2}, {3, 4}};&#13;
**nested_array = 10;&#13;
*nested_array = 0;</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-4: Legal and illegal assignments to array elements</samp></p>&#13;
<p class="TX">The first assignment expression, which assigns to <samp class="SANS_TheSansMonoCd_W5Regular_11">**nested_array</samp>, is valid. First, we implicitly convert the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">nested_array</samp> to a pointer to the array’s initial element. That element has type <samp class="SANS_TheSansMonoCd_W5Regular_11">int[2]</samp>, so the type of the pointer is <samp class="SANS_TheSansMonoCd_W5Regular_11">int(*)[2]</samp>. The first dereference operation on this pointer results in an array object with type <samp class="SANS_TheSansMonoCd_W5Regular_11">int[2]</samp>. We implicitly convert <i>this</i> array to a pointer with type <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>. The second pointer dereference therefore produces an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> object, which we can assign to. The assignment expression overwrites that object’s current value, <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, with a new value, <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">int(*)[2]</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp> pointers in this expression both point to the start of <samp class="SANS_TheSansMonoCd_W5Regular_11">nested_array</samp>; only their types differ.</p>&#13;
<p class="TX">The next assignment expression, which assigns to <samp class="SANS_TheSansMonoCd_W5Regular_11">*nested_array</samp>, is illegal. It starts out as before: we implicitly convert <samp class="SANS_TheSansMonoCd_W5Regular_11">nested_array</samp> to a pointer of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int(*)[2]</samp>, dereference it, and implicitly convert the result to a pointer of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>. We then try to assign directly to this pointer, but the C standard states that the result of this implicit conversion “is not an lvalue,” so we can’t assign to it. It’s not clear what this assignment would do even if it were permitted; it would be like assigning to the result of an <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp> operation.</p>&#13;
<p class="TX">Now we know how to access an array’s initial element in any dimension. We can even read and write to the initial scalar object in an array. However, we usually want to access an array’s other elements too. For that, we’ll need pointer arithmetic.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h2-136"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Pointer Arithmetic to Access Array Elements</samp></h4>&#13;
<p class="TNI">Once we have a pointer to an array’s initial element, we’ll use pointer addition to produce pointers to its other elements. Let’s work through the example in <a href="chapter15.xhtml#list15-5">Listing 15-5</a>.</p>&#13;
<a id="list15-5"/>&#13;
<pre><code>int array[3] = {1, 2, 3};&#13;
int *ptr = array + 1;</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-5: Accessing later array elements with pointer arithmetic</samp></p>&#13;
<p class="TX">We’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">0x10</samp> again as the array’s starting address. In the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp> decays to a pointer to the initial array element, as usual. When we add <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> to this pointer, the result is a pointer to the next <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> element in the array. Since each <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> is 4 bytes, we need to multiply <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> by a scale of 4 to calculate how many bytes to add to <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>’s address. The resulting pointer’s value is <samp class="SANS_TheSansMonoCd_W5Regular_11">0x14</samp>. If we dereferenced this pointer, we would get the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> object at address <samp class="SANS_TheSansMonoCd_W5Regular_11">0x14</samp>, whose current value is <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>. Array elements are zero indexed, so we say the initial element of <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp> is at index 0 and the next element is at index 1.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_388" aria-label="388"/>More generally, when we add an integer <i>n</i> to a pointer, the result is a pointer to another array element at the position <i>n</i> elements further along in the array. Similarly, we can move backward in an array by subtracting an integer (or adding a negative integer). If the result would be outside the bounds of the array in either direction, the behavior is undefined.</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>If x is an</i> <span class="note_Italic">n</span><i>-element array, x + n points one past the end of x. This pointer is a special case. It’s not considered out of bounds, and you can use it in pointer arithmetic. For example, you can compare it to other pointers to elements in the same array. (When you’re looping through array elements, this is a useful way to test whether you’ve reached the end.) But dereferencing it is undefined behavior, because it doesn’t point to an element of the array.</i></p>&#13;
<p class="TX">When we perform pointer arithmetic, the nested structure of the array we point into matters, because it dictates what counts as a single element. Let’s look at <a href="chapter15.xhtml#list15-6">Listing 15-6</a> to see how this plays out for the two arrays we defined in <a href="chapter15.xhtml#list15-1">Listings 15-1</a> and <a href="chapter15.xhtml#list15-2">15-2</a>, which had identical contents in memory.</p>&#13;
<a id="list15-6"/>&#13;
<pre><code>int six_ints[6] = {1, 2, 3, 4, 5, 6};&#13;
int three_arrays[3][2] = {{1, 2}, {3, 4}, {5, 6}};&#13;
<span class="CodeAnnotationHang" aria-label="annotation1">❶</span> int *int_ptr = six_ints + 1;&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">❷</span> int (*array_ptr)[2] = three_arrays + 1;</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-6: Pointer arithmetic with flat and nested arrays</samp></p>&#13;
<p class="TX">The result of the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">six_ints</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> is a pointer to the element at index 1 in <samp class="SANS_TheSansMonoCd_W5Regular_11">six_ints</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. This element is an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> with the value <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>. Similarly, when we compute <samp class="SANS_TheSansMonoCd_W5Regular_11">three_arrays</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, we get a pointer to the array element at index 1 in <samp class="SANS_TheSansMonoCd_W5Regular_11">three_arrays</samp> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. In this case, however, this element is itself an array of two <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> objects, whose current values are <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>. Although <samp class="SANS_TheSansMonoCd_W5Regular_11">six_ints</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">three_arrays</samp> may have identical contents in memory, performing the same operation on both of them produces very different results.</p>&#13;
<p class="TX">So how can we access the scalar objects in <samp class="SANS_TheSansMonoCd_W5Regular_11">three_arrays</samp>? For example, how could we read the last <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> in this array, whose value is <samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp>? First, we’ll get a pointer to the last element in <samp class="SANS_TheSansMonoCd_W5Regular_11">three_arrays</samp>:</p>&#13;
<pre><code>int (*outer_ptr)[2] = three_arrays + 2;</code></pre>&#13;
<p class="TX">This points to the entire two-element array <samp class="SANS_TheSansMonoCd_W5Regular_11">{5, 6}</samp>. We’ll dereference it to get a pointer to a single scalar element in this array instead:</p>&#13;
<pre><code>int *inner_ptr = *outer_ptr;</code></pre>&#13;
<p class="TX">This dereference expression results in an array of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int[2]</samp>, which decays to a pointer with type <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>. Now <samp class="SANS_TheSansMonoCd_W5Regular_11">inner_ptr</samp> points to the first <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> in this nested array, whose value is <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>. We’ll increment it to point to the next <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, whose value is <samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp>:</p>&#13;
<pre><code>inner_ptr = inner_ptr + 1;</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_389" aria-label="389"/>At that point, we can access its value with a normal pointer dereference:</p>&#13;
<pre><code>int result = *inner_ptr;</code></pre>&#13;
<p class="TX">We can consolidate these statements into the single expression in <a href="chapter15.xhtml#list15-7">Listing 15-7</a>.</p>&#13;
<a id="list15-7"/>&#13;
<pre><code>int result = *(*(three_arrays + 2) + 1);</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-7: Accessing the last</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">int</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">three_arrays</samp></p>&#13;
<p class="TX">Through repeated pointer addition, dereferencing, and implicit conversions from arrays to pointers, we can access any element in a multidimensional array. This is, obviously, a huge pain. The subscript operator, <samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>, provides more convenient syntax to accomplish the same thing. The expression <samp class="SANS_TheSansMonoCd_W5Regular_11">a[i]</samp> is equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">*(a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i)</samp>, so we can rewrite <a href="chapter15.xhtml#list15-7">Listing 15-7</a> as <a href="chapter15.xhtml#list15-8">Listing 15-8</a>.</p>&#13;
<a id="list15-8"/>&#13;
<pre><code>int result = three_arrays[2][1];</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-8: A more convenient way to access the last</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">int</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">three_arrays</samp></p>&#13;
<p class="TX">The last point I want to emphasize is that subscripting and pointer arithmetic apply to all pointers, not just pointers that decayed from arrays. If a pointed-to object isn’t in an array, we’ll treat it like the sole element in a one-element array. For example, <a href="chapter15.xhtml#list15-9">Listing 15-9</a> is perfectly valid.</p>&#13;
<a id="list15-9"/>&#13;
<pre><code>int a = 5;&#13;
int *ptr = &amp;a;&#13;
return ptr[0] == 5;</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-9: Subscripting a pointer to a scalar object</samp></p>&#13;
<p class="TX">When we add <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> and dereference the result, we get back the object <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>. Therefore, the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr[0]</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp> evaluates to 1 (that is, true).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h2-137"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Even More Pointer Arithmetic</samp></h4>&#13;
<p class="TNI">We’ll support two other operations on pointers. The first is subtraction; <a href="chapter15.xhtml#list15-10">Listing 15-10</a> gives an example.</p>&#13;
<a id="list15-10"/>&#13;
<pre><code>int arr[3] = {1, 2, 3};&#13;
int *ptr = arr + 2;&#13;
return ptr - arr;</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-10: Subtracting two pointers</samp></p>&#13;
<p class="TX">When we subtract pointers to two elements in the same array, the result is the difference between their indices. In this example, unsurprisingly, we return <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>.</p>&#13;
<p class="TX">We can also compare pointers to array elements, like in <a href="chapter15.xhtml#list15-11">Listing 15-11</a>.</p>&#13;
<a id="list15-11"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_390" aria-label="390"/>int arr[3] = {1, 2, 3};&#13;
int *ptr = arr + 2;&#13;
return ptr &gt; arr;</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-11: Comparing pointers</samp></p>&#13;
<p class="TX">The pointer to the element with the higher array index compares greater than the one with the lower index. In this example, <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> points to the element at index 2 and <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> decays to a pointer to the element at index 0, so the comparison <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr &gt; arr</samp> evaluates to 1. If two pointers don’t point into the same array, the result of subtracting or comparing them is undefined.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h2-138"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Array Types in Function Declarations</samp></h4>&#13;
<p class="TNI">It’s illegal for a function to return an array, like in the following declaration:</p>&#13;
<pre><code>int foo(void)[3];</code></pre>&#13;
<p class="TX">A function can’t take arrays as parameters, either. Weirdly enough, the C standard lets you <i>declare</i> a function with array parameters, but it requires the compiler to adjust your function signature to take pointers instead. For example, the declaration</p>&#13;
<pre><code>int foo(int array_of_three_elements[3]);</code></pre>&#13;
<p class="BodyContinued">will be turned into:</p>&#13;
<pre><code>int foo(int *array_of_three_elements);</code></pre>&#13;
<p class="TX">We’ll adjust parameters with array types to have the corresponding pointer types in the type checker.</p>&#13;
<aside class="box" aria-label="box-40"><p class="BoxTitle" id="box-40"><samp class="SANS_Dogma_OT_Bold_B_11">“IT’S FOR HISTORICAL REASONS”</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">It doesn’t make sense that you can declare function parameters of array type, only to have the compiler treat them like pointers. When I learned about this behavior, it struck me as confusing and useless. Whenever I run into a feature of C that doesn’t make sense, I assume it’s for historical reasons. In this case, that turns out to be true! Dennis Ritchie talks about this in his paper “The</samp> <samp class="SANS_Futura_Std_Book_11">Development of the C Language” (ACM, 1993). In a parameter declaration like</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">int a[]</samp><samp class="SANS_Futura_Std_Book_11">, he notes, the array declarator</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp> <samp class="SANS_Futura_Std_Book_11">is “a living fossil.… The notation survived in part for the sake of compatibility, in part under the rationalization that it would allow programmers to communicate to their readers an intent to pass [a function] a pointer generated from an array, rather than a reference to</samp> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_391" aria-label="391"/><samp class="SANS_Futura_Std_Book_11">a single integer. Unfortunately, it serves as much to confuse the learner as to alert the reader.”</samp></p>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">The paper goes into more detail about how C’s pointer and array semantics have changed over time; you can read it at</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11"><a href="https://www.bell-labs.com/usr/dmr/www/chist.html">https://<wbr/>www<wbr/>.bell<wbr/>-labs<wbr/>.com<wbr/>/usr<wbr/>/dmr<wbr/>/www<wbr/>/chist<wbr/>.html</a></samp><samp class="SANS_Futura_Std_Book_11">.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h4 class="H2" id="sec8"><span id="h2-139"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Things We Aren’t Implementing</samp></h4>&#13;
<p class="TNI">The features we won’t support are significant enough that I’ll mention them explicitly. We won’t implement variable-length arrays, whose length is determined at runtime, like this one:</p>&#13;
<pre><code>int variable_length_array[x];</code></pre>&#13;
<p class="TX">We’ll permit only constants as the dimensions in array declarations. We also won’t permit declarations of incomplete array types:</p>&#13;
<pre><code>int array[];</code></pre>&#13;
<p class="TX">C requires you to specify an array’s dimensions when you define it, but not when you declare it. However, we’ll require array dimensions in declarations as well as definitions.</p>&#13;
<p class="TX">We won’t implement <i>compound literals</i>, which let you construct array objects (and other aggregate objects) outside of initializers:</p>&#13;
<pre><code>int *p = (int []){2, 4};</code></pre>&#13;
<p class="TX">Finally, we won’t fully support C’s semantics for initializing aggregate objects. Compound initializers are a bit of a free-for-all; you can omit braces, wrap scalar values in braces, or initialize some elements but not others. This makes it tricky to figure out which expression is supposed to initialize which element. We’ll take a much stricter approach. First of all, we’ll require braces around the initializers for each nested array. In other words, we’ll accept the declaration</p>&#13;
<pre><code>int arr[2][2] = {{1, 2}, {3, 4}};</code></pre>&#13;
<p class="BodyContinued">but we’ll reject the following equivalent declaration, even though the C standard permits it:</p>&#13;
<pre><code>int arr[2][2] = {1, 2, 3, 4};</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_392" aria-label="392"/>We’ll also reject braces around scalar initializers, like in the following example:</p>&#13;
<pre><code>int i = {3};</code></pre>&#13;
<p class="TX">And we won’t support designators, which let you initialize elements out of order:</p>&#13;
<pre><code>int arr[3] = {0, [2] = 1};</code></pre>&#13;
<p class="TX">However, we <i>will</i> allow compound initializers that don’t initialize every array element, like the following:</p>&#13;
<pre><code>int arr[3] = {1, 2};</code></pre>&#13;
<p class="TX">In this case, we’ll pad out any remaining elements with zeros; that’s the behavior the C standard requires. Now that we’ve clarified exactly what we will and won’t build, we can move on to the lexer.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h3 class="H1" id="sec9"><span id="h1-130"/><samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp></h3>&#13;
<p class="TNI">You’ll add two tokens in this chapter:</p>&#13;
<p class="RunInParaF"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">[</samp> An open square bracket</p>&#13;
<p class="RunInParaL"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">]</samp> A close square bracket</p>&#13;
<p class="TX">After adding these tokens, you can test out your lexer.</p>&#13;
<aside class="box" aria-label="box-41"><p class="BoxTitle" id="box-41"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE LEXER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test the lexer, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 15 --stage lex</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">Lexing should succeed for every test case in this chapter.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h3 class="H1" id="sec10"><span id="h1-131"/><samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp></h3>&#13;
<p class="TNI">Next, we’ll add array types, subscript expressions, and compound initializers to the AST. An array’s type indicates the number of elements in the array and the type of those elements:</p>&#13;
<pre><code>type = <var>--snip--</var> | Array(type element, int size)</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_393" aria-label="393"/>We can nest <samp class="SANS_TheSansMonoCd_W5Regular_11">Array</samp> constructors to specify a multidimensional array. For example, we’ll represent the type of the declaration</p>&#13;
<pre><code>int x[3][4];</code></pre>&#13;
<p class="BodyContinued">as <samp class="SANS_TheSansMonoCd_W5Regular_11">Array(Array(Int, 4), 3)</samp>. Since we won’t support variable-length arrays, every array type must have a constant size.</p>&#13;
<p class="TX">A subscript expression contains two subexpressions, a pointer and an index:</p>&#13;
<pre><code>exp = <var>--snip--</var>&#13;
    | Subscript(exp, exp)</code></pre>&#13;
<p class="TX">Surprisingly, the order in which these two subexpressions appear doesn’t matter; the expressions <samp class="SANS_TheSansMonoCd_W5Regular_11">x[1]</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">1[x]</samp> are equivalent.</p>&#13;
<p class="TX">Finally, we’ll add an <samp class="SANS_TheSansMonoCd_W5Regular_11">initializer</samp> construct to support both scalar and compound variable initializers:</p>&#13;
<pre><code>initializer = SingleInit(exp) | CompoundInit(initializer*)</code></pre>&#13;
<p class="TX">We’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">CompoundInit</samp> to initialize arrays and <samp class="SANS_TheSansMonoCd_W5Regular_11">SingleInit</samp> to initialize scalar objects, including individual array elements. We’ll use a nested <samp class="SANS_TheSansMonoCd_W5Regular_11">CompoundInit</samp> construct for each row in a multidimensional array. <a href="chapter15.xhtml#list15-12">Listing 15-12</a> shows how to represent the initializer <samp class="SANS_TheSansMonoCd_W5Regular_11">{{1, 2}, {3, 4}, {5, 6}}</samp>.</p>&#13;
<a id="list15-12"/>&#13;
<pre><code>CompoundInit([&#13;
    CompoundInit([SingleInit(Constant(ConstInt(1))),&#13;
                  SingleInit(Constant(ConstInt(2)))]),&#13;
    CompoundInit([SingleInit(Constant(ConstInt(3))),&#13;
                  SingleInit(Constant(ConstInt(4)))]),&#13;
    CompoundInit([SingleInit(Constant(ConstInt(5))),&#13;
                  SingleInit(Constant(ConstInt(6)))])&#13;
])</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-12: Representing the initializer for</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">three_arrays</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">, from <a href="chapter15.xhtml#list15-2">Listing 15-2</a>, as an AST node</samp></p>&#13;
<p class="TX">The type checker will annotate initializers with their types, just like it does for <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> nodes. However you support type annotations on <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> nodes, you should do the same thing for <samp class="SANS_TheSansMonoCd_W5Regular_11">initializer</samp>.</p>&#13;
<p class="TX"><a href="chapter15.xhtml#list15-13">Listing 15-13</a> gives the complete AST definition, with this chapter’s additions bolded.</p>&#13;
<a id="list15-13"/>&#13;
<pre><code>program = Program(declaration*)&#13;
declaration = FunDecl(function_declaration) | VarDecl(variable_declaration)&#13;
variable_declaration = (identifier name, <b>initializer? init,</b>&#13;
                        type var_type, storage_class?)&#13;
function_declaration = (identifier name, identifier* params, block? body,&#13;
                        type fun_type, storage_class?)&#13;
<b>initializer = SingleInit(exp) | CompoundInit(initializer*)</b>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_394" aria-label="394"/>type = Int | Long | UInt | ULong | Double&#13;
     | FunType(type* params, type ret)&#13;
     | Pointer(type referenced)&#13;
<b>     | Array(type element, int size)</b>&#13;
storage_class = Static | Extern&#13;
block_item = S(statement) | D(declaration)&#13;
block = Block(block_item*)&#13;
for_init = InitDecl(variable_declaration) | InitExp(exp?)&#13;
statement = Return(exp)&#13;
          | Expression(exp)&#13;
          | If(exp condition, statement then, statement? else)&#13;
          | Compound(block)&#13;
          | Break&#13;
          | Continue&#13;
          | While(exp condition, statement body)&#13;
          | DoWhile(statement body, exp condition)&#13;
          | For(for_init init, exp? condition, exp? post, statement body)&#13;
          | Null&#13;
exp = Constant(const)&#13;
    | Var(identifier)&#13;
    | Cast(type target_type, exp)&#13;
    | Unary(unary_operator, exp)&#13;
    | Binary(binary_operator, exp, exp)&#13;
    | Assignment(exp, exp)&#13;
    | Conditional(exp condition, exp, exp)&#13;
    | FunctionCall(identifier, exp* args)&#13;
    | Dereference(exp)&#13;
    | AddrOf(exp)&#13;
<b>    | Subscript(exp, exp)</b>&#13;
unary_operator = Complement | Negate | Not&#13;
binary_operator = Add | Subtract | Multiply | Divide | Remainder | And | Or&#13;
                | Equal | NotEqual | LessThan | LessOrEqual&#13;
                | GreaterThan | GreaterOrEqual&#13;
const = ConstInt(int) | ConstLong(int) &#13;
      | ConstUInt(int) | ConstULong(int)&#13;
      | ConstDouble(double)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-13: The abstract syntax tree with array types, compound initializers, and subscript expressions</samp></p>&#13;
<p class="TX">Let’s walk through how to parse each of these additions to the AST.</p>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2" id="sec11"><span id="h2-140"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing Array Declarators</samp></h4>&#13;
<p class="TNI">You learned how to parse pointer and function declarators in the previous chapter; now we’ll extend that code to handle array declarators too. <a href="chapter15.xhtml#list15-14">Listing 15-14</a> shows how to extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">declarator</samp> construct that we defined in <span class="Xref-1"><a href="chapter14.xhtml#list14-6">Listing 14-6</a></span>.</p>&#13;
<a id="list15-14"/>&#13;
<pre><code>declarator = Ident(identifier)&#13;
           | PointerDeclarator(declarator)&#13;
<b>           | ArrayDeclarator(declarator, int size)</b>&#13;
           | FunDeclarator(param_info* params, declarator)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-14: Representing array declarators</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_395" aria-label="395"/>Next, we’ll add array declarators to the grammar. Since they have higher precedence than pointer declarators, they belong in the <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;direct-declarator&gt;</samp> grammar rule:</p>&#13;
<pre><code>&lt;direct-declarator&gt; ::= &lt;simple-declarator&gt; [&lt;declarator-suffix&gt;]&#13;
&lt;declarator-suffix&gt; ::= &lt;param-list&gt; | {"[" &lt;const&gt; "]"}+</code></pre>&#13;
<p class="TX">A direct declarator is a simple declarator with an optional suffix: either a parenthesized list of function parameters or a sequence of constant array dimensions of the form <samp class="SANS_TheSansMonoCd_W5Regular_11">[</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">const</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">]</samp>. Each <samp class="SANS_TheSansMonoCd_W5Regular_11">ArrayDeclarator</samp> specifies just one array dimension, so we’ll parse a <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;declarator-suffix&gt;</samp> with multiple dimensions to a sequence of multiple nested <samp class="SANS_TheSansMonoCd_W5Regular_11">ArrayDeclarator</samp> nodes. For example, we’d parse the declarator <samp class="SANS_TheSansMonoCd_W5Regular_11">array[1][2]</samp> to:</p>&#13;
<pre><code>ArrayDeclarator(ArrayDeclarator(Ident("array"), 1), 2)</code></pre>&#13;
<p class="TX">The grammar rule for <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;declarator-suffix&gt;</samp> permits floating-point constants as array dimensions, but the C standard requires array dimensions to be integers. When you parse a <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;declarator-suffix&gt;</samp>, you should reject floating-pointing constants and accept constants of any integer type. The C standard also requires array dimensions to be greater than zero, but Clang and GCC support zero-length arrays as a language extension. It’s up to you whether to accept zero-length arrays or reject them; the test suite doesn’t cover this case.</p>&#13;
<p class="TX">Finally, we’ll update <samp class="SANS_TheSansMonoCd_W5Regular_11">process_declarator</samp>, which converts a <samp class="SANS_TheSansMonoCd_W5Regular_11">declarator</samp> construct into an AST node. <a href="chapter15.xhtml#list15-15">Listing 15-15</a> illustrates how to handle array declarators in <samp class="SANS_TheSansMonoCd_W5Regular_11">process_declarator</samp>.</p>&#13;
<a id="list15-15"/>&#13;
<pre><code>process_declarator(declarator, base_type):&#13;
    match declarator with&#13;
<var>    </var>| <var>--snip--</var>&#13;
    | ArrayDeclarator(inner, size) -&gt;&#13;
        derived_type = Array(base_type, size)&#13;
        return process_declarator(inner, derived_type)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-15: Applying array type derivations</samp></p>&#13;
<p class="TX">This listing follows the same pattern we introduced to derive pointer types in <span class="Xref-1"><a href="chapter14.xhtml">Chapter 14</a></span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2" id="sec12"><span id="h2-141"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing Abstract Array Declarators</samp></h4>&#13;
<p class="TNI">Next, let’s deal with abstract declarators, which specify types without declaring identifiers. We’ll parse abstract array declarators according to the grammar rule in <a href="chapter15.xhtml#list15-16">Listing 15-16</a>.</p>&#13;
<a id="list15-16"/>&#13;
<pre><code>&lt;direct-abstract-declarator&gt; ::= "(" &lt;abstract-declarator&gt; ")" {"[" &lt;const&gt; "]"}&#13;
                               | {"[" &lt;const&gt; "]"}+</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-16: The grammar rule for abstract array declarators</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_396" aria-label="396"/>A direct abstract declarator is either a parenthesized declarator, optionally followed by a sequence of array dimensions, or just a sequence of array dimensions. (Remember that <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp> in EBNF syntax indicates zero or more repetitions, while <samp class="SANS_TheSansMonoCd_W5Regular_11">{}+</samp> indicates one or more repetitions.) We’ll take the same steps here that we took to support normal declarators. <a href="chapter15.xhtml#list15-17">Listing 15-17</a> shows how to extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">abstract_declarator</samp> construct.</p>&#13;
<a id="list15-17"/>&#13;
<pre><code>abstract_declarator = AbstractPointer(abstract_declarator)&#13;
<b>                    | AbstractArray(abstract_declarator, int size)</b>&#13;
                    | AbstractBase</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-17: Representing abstract array declarators</samp></p>&#13;
<p class="TX">After updating <samp class="SANS_TheSansMonoCd_W5Regular_11">abstract_declarator</samp>, we’ll change our parsing code to handle the grammar rule in <a href="chapter15.xhtml#list15-16">Listing 15-16</a>. (This code should accept integer constants as array dimensions and reject floating-point constants, just like the code to parse ordinary declarators.) Finally, we’ll update <samp class="SANS_TheSansMonoCd_W5Regular_11">process_abstract _declarator</samp>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h4 class="H2" id="sec13"><span id="h2-142"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing Compound Initializers</samp></h4>&#13;
<p class="TNI">Now let’s define the grammar rule for initializers:</p>&#13;
<pre><code>&lt;initializer&gt; ::= &lt;exp&gt; | "{" &lt;initializer&gt; {"," &lt;initializer&gt;} [","] "}"</code></pre>&#13;
<p class="TX">This rule is straightforward: an initializer is either an expression or a brace-enclosed list of one or more nested initializers. Note that there can be a trailing comma after the last element in an initializer list: <samp class="SANS_TheSansMonoCd_W5Regular_11">{1, 2, 3}</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">{1, 2, 3,}</samp> are both valid compound initializers.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h4 class="H2" id="sec14"><span id="h2-143"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing Subscript Expressions</samp></h4>&#13;
<p class="TNI">The last new language feature we need to parse is the subscript operator. Subscripting is a <i>postfix</i> operator, which follows the expression it modifies. Postfix operators have higher precedence than prefix operators like <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>. We’ll break up the <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;factor&gt;</samp> grammar rule to reflect this difference in precedence. At the highest precedence level, we’ll have constants, variables, parenthesized expressions, and function calls:</p>&#13;
<pre><code>&lt;primary-exp&gt; ::= &lt;const&gt; | &lt;identifier&gt; | "(" &lt;exp&gt; ")"&#13;
                | &lt;identifier&gt; "(" [&lt;argument-list&gt;] ")"</code></pre>&#13;
<p class="TX">Then, we’ll define a postfix expression as a primary expression, optionally followed by a sequence of subscript operators:</p>&#13;
<pre><code>&lt;postfix-exp&gt; ::= &lt;primary-exp&gt; {"[" &lt;exp&gt; "]"}</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_397" aria-label="397"/>Each subscript operator is an expression enclosed in square brackets. Finally, we’ll define unary expressions, which include both prefix and cast operators:</p>&#13;
<pre><code>&lt;unary-exp&gt; ::= &lt;unop&gt; &lt;unary-exp&gt;&#13;
              | "(" {&lt;type-specifier&gt;}+ [&lt;abstract-declarator&gt;] ")" &lt;unary-exp&gt;&#13;
              | &lt;postfix-exp&gt;</code></pre>&#13;
<p class="TX"><a href="chapter15.xhtml#list15-18">Listing 15-18</a> shows the complete grammar, with this chapter’s changes bolded.</p>&#13;
<a id="list15-18"/>&#13;
<pre><code>&lt;program&gt; ::= {&lt;declaration&gt;}&#13;
&lt;declaration&gt; ::= &lt;variable-declaration&gt; | &lt;function-declaration&gt;&#13;
&lt;variable-declaration&gt; ::= {&lt;specifier&gt;}+ &lt;declarator&gt; ["="<b> &lt;initializer&gt;]</b> ";"&#13;
&lt;function-declaration&gt; ::= {&lt;specifier&gt;}+ &lt;declarator&gt; (&lt;block&gt; | ";")&#13;
&lt;declarator&gt; ::= "*" &lt;declarator&gt; | &lt;direct-declarator&gt;&#13;
&lt;direct-declarator&gt; ::= &lt;simple-declarator&gt;<b> [&lt;declarator-suffix&gt;]</b>&#13;
<b>&lt;declarator-suffix&gt; ::= &lt;param-list&gt; | {"[" &lt;const&gt; "]"}+</b>&#13;
&lt;param-list&gt; ::= "(" "void" ")" | "(" &lt;param&gt; {"," &lt;param&gt;} ")"&#13;
&lt;param&gt; ::= {&lt;type-specifier&gt;}+ &lt;declarator&gt;&#13;
&lt;simple-declarator&gt; ::= &lt;identifier&gt; | "(" &lt;declarator&gt; ")"&#13;
&lt;type-specifier&gt; ::= "int" | "long" | "unsigned" | "signed" | "double"&#13;
&lt;specifier&gt; ::= &lt;type-specifier&gt; | "static" | "extern"&#13;
&lt;block&gt; ::= "{" {&lt;block-item&gt;} "}"&#13;
&lt;block-item&gt; ::= &lt;statement&gt; | &lt;declaration&gt;&#13;
<b>&lt;initializer&gt; ::= &lt;exp&gt; | "{" &lt;initializer&gt; {"," &lt;initializer&gt;} [","] "}"</b>&#13;
&lt;for-init&gt; ::= &lt;variable-declaration&gt; | [&lt;exp&gt;] ";"&#13;
&lt;statement&gt; ::= "return" &lt;exp&gt; ";"&#13;
              | &lt;exp&gt; ";"&#13;
              | "if" "(" &lt;exp&gt; ")" &lt;statement&gt; ["else" &lt;statement&gt;]&#13;
              | &lt;block&gt;&#13;
              | "break" ";"&#13;
              | "continue" ";"&#13;
              | "while" "(" &lt;exp&gt; ")" &lt;statement&gt;&#13;
              | "do" &lt;statement&gt; "while" "(" &lt;exp&gt; ")" ";"&#13;
              | "for" "(" &lt;for-init&gt; [&lt;exp&gt;] ";" [&lt;exp&gt;] ")" &lt;statement&gt;&#13;
              | ";"&#13;
&lt;exp&gt; ::= <b>&lt;unary-exp&gt;</b> | &lt;exp&gt; &lt;binop&gt; &lt;exp&gt; | &lt;exp&gt; "?" &lt;exp&gt; ":" &lt;exp&gt;&#13;
<b>&lt;unary-exp&gt; ::= &lt;unop&gt; &lt;unary-exp&gt;</b>&#13;
<b>              | "(" {&lt;type-specifier&gt;}+ [&lt;abstract-declarator&gt;] ")" &lt;unary-exp&gt;</b>&#13;
<b>              | &lt;postfix-exp&gt;</b>&#13;
<b>&lt;postfix-exp&gt; ::= &lt;primary-exp&gt; {"[" &lt;exp&gt; "]"}</b>&#13;
<b>&lt;primary-exp&gt; ::= &lt;const&gt; | &lt;identifier&gt; | "(" &lt;exp&gt; ")"</b>&#13;
                <b>| &lt;identifier&gt; "(" [&lt;argument-list&gt;] ")"</b>&#13;
&lt;argument-list&gt; ::= &lt;exp&gt; {"," &lt;exp&gt;}&#13;
&lt;abstract-declarator&gt; ::= "*" [&lt;abstract-declarator&gt;]&#13;
                        | &lt;direct-abstract-declarator&gt;&#13;
&lt;direct-abstract-declarator&gt; ::= "(" &lt;abstract-declarator&gt; ")" <b>{"[" &lt;const&gt; "]"}</b>&#13;
                               <b>| {"[" &lt;const&gt; "]"}+</b>&#13;
&lt;unop&gt; ::= "-" | "~" | "!" | "*" | "&amp;"&#13;
&lt;binop&gt; ::= "-" | "+" | "*" | "/" | "%" | "&amp;&amp;" | "||"&#13;
          | "==" | "!=" | "&lt;" | "&lt;=" | "&gt;" | "&gt;=" | "="&#13;
&lt;const&gt; ::= &lt;int&gt; | &lt;long&gt; | &lt;uint&gt; | &lt;ulong&gt; | &lt;double&gt;&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_398" aria-label="398"/>&lt;identifier&gt; ::= ? An identifier token ?&#13;
&lt;int&gt; ::= ? An int token ?&#13;
&lt;long&gt; ::= ? An int or long token ?&#13;
&lt;uint&gt; ::= ? An unsigned int token ?&#13;
&lt;ulong&gt; ::= ? An unsigned int or unsigned long token ?&#13;
&lt;double&gt; ::= ? A floating-point constant token ?</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-18: The grammar with array types, compound initializers, and subscript expressions</samp></p>&#13;
<p class="TX">Once you’ve updated your parser to account for all of the changes in <a href="chapter15.xhtml#list15-18">Listing 15-18</a>, you’re ready to test it out.</p>&#13;
<aside class="box" aria-label="box-42"><p class="BoxTitle" id="box-42"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE PARSER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test your parser, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 15 --stage parse</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">The parser should fail on every test case in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_15/invalid_parse</samp><samp class="SANS_Futura_Std_Book_11">, which includes programs with malformed declarators, initializers, and subscript expressions. It should handle every test case in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_15/invalid_types</samp> <samp class="SANS_Futura_Std_Book_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_15/valid</samp> <samp class="SANS_Futura_Std_Book_11">without error.</samp></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h3 class="H1" id="sec15"><span id="h1-132"/><samp class="SANS_Futura_Std_Bold_B_11">The Type Checker</samp></h3>&#13;
<p class="TNI">The type checker will do most of the heavy lifting in this chapter. It will add type information to subscript and pointer arithmetic expressions; validate the dimensions of compound initializers; and detect type errors, like casting an expression to an array type. It will also handle implicit conversions from array to pointer types. Just as we insert <samp class="SANS_TheSansMonoCd_W5Regular_11">Cast</samp> expressions into the AST to make implicit type conversions explicit, we’ll insert <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> expressions to make conversions from arrays to pointers explicit.</p>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h4 class="H2" id="sec16"><span id="h2-144"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting Arrays to Pointers</samp></h4>&#13;
<p class="TNI">We’ll convert any array type expression to a pointer, unless it’s already the operand of an <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> expression. This might sound familiar from the previous chapter, where we lvalue converted the result of every expression, except when we took its address or assigned to it. In <span class="Xref-1"><a href="chapter14.xhtml">Chapter 14</a></span>, we introduced a new <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky_and_convert</samp> helper function to manage lvalue conversions; now we’ll use a similar design pattern in a different compiler pass. We’ll define a new <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp> function, shown in <a href="chapter15.xhtml#list15-19">Listing 15-19</a>.</p>&#13;
<a id="list15-19"/>&#13;
<pre><code>typecheck_and_convert(e, symbols):&#13;
    typed_e = typecheck_exp(e, symbols)&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_399" aria-label="399"/>    match get_type(typed_e) with&#13;
    | Array(elem_t, size) -&gt;&#13;
        addr_exp = AddrOf(typed_e)&#13;
        return set_type(addr_exp, Pointer(elem_t))&#13;
    | _ -&gt; return typed_e</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-19: Implicitly converting an array to a pointer</samp></p>&#13;
<p class="TX">If an expression has array type, we insert an <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> operation to get its address. We then record its result type, which is a pointer to the array’s element type. This is a different result type than we’d get from an explicit <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp> operator, which always produces a pointer to the type of its operand. Take the following declaration:</p>&#13;
<pre><code>int arr[3];</code></pre>&#13;
<p class="TX">The expression <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;arr</samp> has type <samp class="SANS_TheSansMonoCd_W5Regular_11">int (*)[3]</samp>. The expression <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>, on the other hand, has type <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>. In the type checked AST, we’re using <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> to represent two ways of taking an object’s address, which yield different result types: through an implicit conversion or an explicit <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp> operator.</p>&#13;
<p class="TX">Once we’ve introduced <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>, we’ll use it in place of <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_exp</samp> to check both subexpressions and full expressions. The one exception is type checking the operand of <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>. This operand should not be converted from an array to a pointer, so we’ll continue to process it by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_exp</samp> directly.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h4 class="H2" id="sec17"><span id="h2-145"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Validating Lvalues</samp></h4>&#13;
<p class="TNI">We’ll change a couple of details about how we validate lvalues. First, we should recognize <samp class="SANS_TheSansMonoCd_W5Regular_11">Subscript</samp> expressions as lvalues, in addition to <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Dereference</samp>.</p>&#13;
<p class="TX">Second, we need to reject assignment expressions that try to assign to arrays. Once an array decays to a pointer, it’s no longer an lvalue and can’t be assigned to. To catch these invalid assignment expressions, we’ll process the left operand with <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp> before we check whether it’s an lvalue. <a href="chapter15.xhtml#list15-20">Listing 15-20</a> shows the latest logic to type check assignment expressions.</p>&#13;
<a id="list15-20"/>&#13;
<pre><code>typecheck_exp(e, symbols):&#13;
    match e with&#13;
<var>    </var>| <var>--snip--</var>&#13;
    | Assignment(left, right) -&gt;&#13;
        typed_left = typecheck_and_convert(left, symbols)&#13;
        if typed_left is not an lvalue:&#13;
            fail("Tried to assign to non-lvalue")&#13;
        typed_right = typecheck_and_convert(right, symbols)&#13;
<var>        --snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-20: Type checking assignment expressions</samp></p>&#13;
<p class="TX">If the left operand is an array, <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp> will wrap it in an <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> operation. Then, since <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> isn’t an lvalue, the type checker will throw an error.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_400" aria-label="400"/>&#13;
<h4 class="H2" id="sec18"><span id="h2-146"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Checking Pointer Arithmetic</samp></h4>&#13;
<p class="TNI">Next, we’ll extend addition, subtraction, and the relational operators to work with pointers. Adding any integer type to a pointer is valid. <a href="chapter15.xhtml#list15-21">Listing 15-21</a> demonstrates how to type check addition.</p>&#13;
<a id="list15-21"/>&#13;
<pre><code>    | Binary(Add, e1, e2) -&gt;&#13;
        typed_e1 = typecheck_and_convert(e1, symbols)&#13;
        typed_e2 = typecheck_and_convert(e2, symbols)&#13;
        t1 = get_type(typed_e1)&#13;
        t2 = get_type(typed_e2)&#13;
        if t1 and t2 are arithmetic:&#13;
<var>            --snip--</var>&#13;
        else if t1 is a pointer type and t2 is an integer type:&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> converted_e2 = convert_to(typed_e2, Long)&#13;
            add_exp = Binary(Add, typed_e1, converted_e2)&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> return set_type(add_exp, t1)&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> else if t2 is a pointer type and t1 is an integer type:&#13;
<var>            --snip--</var>&#13;
        else:&#13;
            fail("Invalid operands for addition")</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-21: Type checking pointer addition</samp></p>&#13;
<p class="TX">To type check addition involving a pointer and an integer, we first convert the integer operand to a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. This will simplify later compiler passes, when pointer indices will need to be 8 bytes wide so that we can add them to 8-byte memory addresses. This conversion doesn’t come from the C standard; we’re just adding it for our own convenience. But it also doesn’t violate the standard; converting a valid array index to <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> won’t change its value, so the result of the whole expression is the same either way. (If an integer is too big to represent as a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>, we can safely assume that it’s not a valid array index, since no hardware supports arrays with anywhere close to 2<sup>63</sup> elements.)</p>&#13;
<p class="TX">The result of pointer addition has the same type as the pointer operand <span class="CodeAnnotation" aria-label="annotation2">❷</span>. We use the same logic whether the first or second operand is the pointer, so I’ve omitted the pseudocode for the latter case <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Finally, in any case other than adding a pointer to an integer or adding two arithmetic operands, we throw an error.</p>&#13;
<p class="TX">Subtracting an integer from a pointer works the same way: we convert the integer operand to a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> and annotate the result with the same type as the pointer operand. The only difference is that operand order matters. You can subtract an integer from a pointer, but you can’t subtract a pointer from an integer.</p>&#13;
<p class="TX">When we subtract one pointer from another, both operands must have the same type, and the result has an implementation-defined signed integer type. We’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> as the result type here, which is the norm on 64-bit systems. This type is supposed to be aliased as <samp class="SANS_TheSansMonoCd_W5Regular_11">ptrdiff_t</samp> in the <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;stddef.h&gt;</samp> header, to help users write more portable code. Since we don’t <span role="doc-pagebreak" epub:type="pagebreak" id="pg_401" aria-label="401"/>support <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp> and therefore can’t compile <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;stddef.h&gt;</samp>, we’ll ignore this requirement.</p>&#13;
<p class="TX"><a href="chapter15.xhtml#list15-22">Listing 15-22</a> demonstrates how to type check both cases of pointer subtraction.</p>&#13;
<a id="list15-22"/>&#13;
<pre><code>    | Binary(Subtract, e1, e2) -&gt;&#13;
        typed_e1 = typecheck_and_convert(e1, symbols)&#13;
        typed_e2 = typecheck_and_convert(e2, symbols)&#13;
        t1 = get_type(typed_e1)&#13;
        t2 = get_type(typed_e2)&#13;
        if t1 and t2 are arithmetic:&#13;
<var>            --snip--</var>&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> else if t1 is a pointer type and t2 is an integer type:&#13;
            converted_e2 = convert_to(typed_e2, Long)&#13;
            sub_exp = Binary(Subtract, typed_e1, converted_e2)&#13;
            return set_type(sub_exp, t1)&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> else if t1 is a pointer type and t1 == t2:&#13;
            sub_exp = Binary(Subtract, typed_e1, typed_e2)&#13;
            return set_type(sub_exp, Long)&#13;
        else:&#13;
            fail("Invalid operands for subtraction")</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-22: Type checking pointer subtraction</samp></p>&#13;
<p class="TX">If an expression subtracts an integer from a pointer, we handle it just like pointer addition <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If it subtracts two pointers of the same type, we record <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> as the result type <span class="CodeAnnotation" aria-label="annotation2">❷</span>. In any other case—if an expression subtracts two pointers of different types, subtracts a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> from a pointer, or subtracts a pointer from an arithmetic value—we’ll throw an error.</p>&#13;
<p class="TX">Finally, let’s deal with the <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;=</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;=</samp> operators. Each of these accepts two pointer operands of the same type and returns an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. These are pretty simple to type check, so I won’t provide pseudocode for this case.</p>&#13;
<p class="TX">Note that none of these operators accept null pointer constants; they compare pointers to elements in the same array, but a null pointer, by definition, doesn’t point to an array element. By the same logic, you can’t subtract a pointer from a null pointer constant. If <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is a pointer, the expressions <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">x !=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> are legal, but <samp class="SANS_TheSansMonoCd_W5Regular_11">0 - x</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">0 &lt; x</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">x &gt;=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> are not. (Clang and GCC are more permissive than the standard here; as a language extension, they both let you use null pointer constants with any relational operator. With this extension, any non-null pointer will compare greater than the null pointer constant.)</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h4 class="H2" id="sec19"><span id="h2-147"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Checking Subscript Expressions</samp></h4>&#13;
<p class="TNI">One operand of a subscript expression must be a pointer, and the other must be an integer. The pointer’s referenced type is the result type. Remember that these two operands can appear in either order; we can’t assume that the pointer will be the first operand. <a href="chapter15.xhtml#list15-23">Listing 15-23</a> shows how to type check subscript expressions.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_402" aria-label="402"/>&#13;
<a id="list15-23"/>&#13;
<pre><code>    | Subscript(e1, e2) -&gt;&#13;
        typed_e1 = typecheck_and_convert(e1, symbols)&#13;
        typed_e2 = typecheck_and_convert(e2, symbols)&#13;
        t1 = get_type(typed_e1)&#13;
        t2 = get_type(typed_e2)&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> if t1 is a pointer type and t2 is an integer type:&#13;
            ptr_type = t1&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> typed_e2 = convert_to(typed_e2, Long)&#13;
        else if t1 is an integer type and t2 is a pointer type:&#13;
            ptr_type = t2&#13;
            typed_e1 = convert_to(typed_e1, Long)&#13;
        else:&#13;
            fail("Subscript must have integer and pointer operands")&#13;
        subscript_exp = Subscript(typed_e1, typed_e2)&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> return set_type(subscript_exp, ptr_type.referenced)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-23: Type checking a subscript expression</samp></p>&#13;
<p class="TX">First, we validate that one operand is a pointer and the other is an integer <span class="CodeAnnotation" aria-label="annotation1">❶</span>. We then convert the integer operand to a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Finally, we annotate the whole expression with the pointer’s referenced type <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
&#13;
<h4 class="H2" id="sec20"><span id="h2-148"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Checking Cast Expressions</samp></h4>&#13;
<p class="TNI">This one is easy: you can’t cast an expression to an array type. For example, the expression</p>&#13;
<pre><code>(int[3]) foo;</code></pre>&#13;
<p class="BodyContinued">is invalid and should produce a type error.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
&#13;
<h4 class="H2" id="sec21"><span id="h2-149"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Checking Function Declarations</samp></h4>&#13;
<p class="TNI">When we process a function declaration, we consider both its return type and its parameter types. If a function returns an array type, we throw an error. If any of its parameters has an array type, we adjust it to a pointer type instead. <a href="chapter15.xhtml#list15-24">Listing 15-24</a> describes how to validate and implicitly adjust a function type.</p>&#13;
<a id="list15-24"/>&#13;
<pre><code>typecheck_function_declaration(decl, symbols):&#13;
    if decl.fun_type.ret is an array type:&#13;
        fail("A function cannot return an array!")&#13;
    adjusted_params = []&#13;
    for t in decl.fun_type.params:&#13;
        match t with&#13;
        | Array(elem_t, size) -&gt;&#13;
            adjusted_type = Pointer(elem_t)&#13;
            adjusted_params.append(adjusted_type)&#13;
        | _ -&gt; adjusted_params.append(t)&#13;
    decl.fun_type.params = adjusted_params&#13;
<var>    --snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-24: Adjusting array types in function declarations</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_403" aria-label="403"/>You should add this logic to the very beginning of <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_function _declaration</samp>, in order to adjust a function’s parameter types before you check whether it conflicts with prior definitions of the same identifier. You should also ensure that both the symbol table and the AST node itself use the adjusted parameter types.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
&#13;
<h4 class="H2" id="sec22"><span id="h2-150"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Checking Compound Initializers</samp></h4>&#13;
<p class="TNI">We need to annotate each initializer with its type and emit an error if an initializer is incompatible with the type of the object it’s supposed to initialize. To type check a compound initializer, we first validate that the object it initializes is an array. Then, we recursively type check each nested initializer, validating that it’s compatible with the array’s element type. <a href="chapter15.xhtml#list15-25">Listing 15-25</a> illustrates this approach.</p>&#13;
<a id="list15-25"/>&#13;
<pre><code>typecheck_init(target_type, init, symbols):&#13;
    match target_type, init with&#13;
    | _, SingleInit(e) -&gt; <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
        typechecked_exp = typecheck_and_convert(e, symbols)&#13;
        cast_exp = convert_by_assignment(typechecked_exp, target_type)&#13;
        return set_type(SingleInit(cast_exp), target_type)&#13;
    | Array(elem_t, size), CompoundInit(init_list) -&gt; <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
        if length(init_list) &gt; size:&#13;
            fail("wrong number of values in initializer") <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
        typechecked_list = []&#13;
        for init_elem in init_list:&#13;
            typechecked_elem = typecheck_init(elem_t, init_elem, symbols) <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span>&#13;
            typechecked_list.append(typechecked_elem)&#13;
        while length(typechecked_list) &lt; size:&#13;
            typechecked_list.append(zero_initializer(elem_t)) <span class="codeannotated_CodeAnnotation" aria-label="annotation5">❺</span>&#13;
        return set_type(CompoundInit(typechecked_list), target_type) <span class="codeannotated_CodeAnnotation" aria-label="annotation6">❻</span>&#13;
    | _ -&gt; fail("can't initialize a scalar object with a compound initializer") <span class="codeannotated_CodeAnnotation" aria-label="annotation7">❼</span></code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-25: Type checking initializers</samp></p>&#13;
<p class="TX">In the base case, an initializer is a single expression <span class="CodeAnnotation" aria-label="annotation1">❶</span>. We’ll type check this expression, then call <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp>, which we defined in <span class="Xref-1"><a href="chapter14.xhtml">Chapter 14</a></span>, to convert it to the target type. If it’s not compatible with the target type, <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp> will throw an error (this includes cases where the target type is an array type).</p>&#13;
<p class="TX">In the recursive case, we’ll initialize an array using a compound initializer <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Each item in the list will initialize one element in the array. First, we’ll check that the list doesn’t contain too many elements <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Then, we’ll type check each list item recursively, using the array’s element type as the target type <span class="CodeAnnotation" aria-label="annotation4">❹</span>. If the initializer list contains too few elements, we’ll pad it with zeros <span class="CodeAnnotation" aria-label="annotation5">❺</span>. We’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">zero_initializer</samp> helper function, which I haven’t provided pseudocode for, to produce zero-valued initializers that we can add to the initializer list. Given a scalar type, <samp class="SANS_TheSansMonoCd_W5Regular_11">zero_initializer</samp> should return a <samp class="SANS_TheSansMonoCd_W5Regular_11">SingleInit</samp> of that type with the value 0. Given an array type, it should return a <samp class="SANS_TheSansMonoCd_W5Regular_11">CompoundInit</samp> whose scalar elements (which may be nested several <span role="doc-pagebreak" epub:type="pagebreak" id="pg_404" aria-label="404"/>layers deep) have the value 0. For example, calling <samp class="SANS_TheSansMonoCd_W5Regular_11">zero_initializer</samp> on the type <samp class="SANS_TheSansMonoCd_W5Regular_11">UInt</samp> should return</p>&#13;
<pre><code>SingleInit(Constant(ConstUInt(0)))</code></pre>&#13;
<p class="BodyContinued">and calling it on the type <samp class="SANS_TheSansMonoCd_W5Regular_11">Array(Array(Int, 2), 2)</samp> should return:</p>&#13;
<pre><code>CompoundInit([&#13;
    CompoundInit([SingleInit(Constant(ConstInt(0))),&#13;
                  SingleInit(Constant(ConstInt(0)))]),&#13;
    CompoundInit([SingleInit(Constant(ConstInt(0))),&#13;
                  SingleInit(Constant(ConstInt(0)))])&#13;
])</code></pre>&#13;
<p class="TX">Once we’ve finished building the type checked list of initializers, we’ll package it into a <samp class="SANS_TheSansMonoCd_W5Regular_11">CompoundInit</samp>, which we’ll annotate with the target type <span class="CodeAnnotation" aria-label="annotation6">❻</span>. If the initializer isn’t a single expression and the target type isn’t an array type, we’re trying to initialize a scalar object with a compound initializer, so we’ll throw an error <span class="CodeAnnotation" aria-label="annotation7">❼</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
&#13;
<h4 class="H2" id="sec23"><span id="h2-151"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Initializing Static Arrays</samp></h4>&#13;
<p class="TNI">As with other static variables, we’ll store the initial values of static arrays in the symbol table. We’ll need to update the data structures we use to represent these initial values. We’ll represent the initializer for every object as a list of scalar values:</p>&#13;
<pre><code>initial_value = Tentative | Initial(<b>static_init* init_list</b>) | NoInitializer</code></pre>&#13;
<p class="TX">For scalar objects, <samp class="SANS_TheSansMonoCd_W5Regular_11">init_list</samp> will have only one element. The declaration</p>&#13;
<pre><code>static int a = 3;</code></pre>&#13;
<p class="BodyContinued">will have this initializer:</p>&#13;
<pre><code>Initial([IntInit(3)])</code></pre>&#13;
<p class="TX">For multidimensional arrays, we’ll flatten out any nested structures. Therefore, the declaration</p>&#13;
<pre><code>static int nested[3][2] = {{1, 2}, {3, 4}, {5, 6}};</code></pre>&#13;
<p class="BodyContinued">will have this initializer:</p>&#13;
<pre><code>Initial([IntInit(1),&#13;
         IntInit(2),&#13;
         IntInit(3),&#13;
         IntInit(4),&#13;
         IntInit(5),&#13;
         IntInit(6)])</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_405" aria-label="405"/>Next, we’ll add a <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp> constructor to represent zeroed-out objects of any size:</p>&#13;
<pre><code>static_init = IntInit(int) | LongInit(int) | UIntInit(int) | ULongInit(int)&#13;
            | DoubleInit(double)<b> | ZeroInit(int bytes)</b></code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">bytes</samp> argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp> specifies how many bytes to initialize to zero. If a static array is only partially initialized, we’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp> to pad out any uninitialized elements. For example, the declaration</p>&#13;
<pre><code>static int nested[3][2] = {{100}, {200, 300}};</code></pre>&#13;
<p class="BodyContinued">will have this initializer:</p>&#13;
<pre><code>Initial([IntInit(100),&#13;
         ZeroInit(4),&#13;
         IntInit(200),&#13;
         IntInit(300),&#13;
         ZeroInit(8)])</code></pre>&#13;
<p class="TX">The second element of this initializer list, <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit(4)</samp>, initializes the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> at <samp class="SANS_TheSansMonoCd_W5Regular_11">nested[0][1]</samp>; the last element, <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit(8)</samp>, initializes both elements of the nested array <samp class="SANS_TheSansMonoCd_W5Regular_11">nested[2]</samp>.</p>&#13;
<p class="TX">Once you’ve updated the <samp class="SANS_TheSansMonoCd_W5Regular_11">initial_value</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp> data structures, write a function to convert a compound initializer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp> list. You’ll need to validate that initializers for static arrays have the correct size and structure, just like initializers for non-static arrays; you should reject initializers with too many elements, scalar initializers for arrays, and compound initializers for scalar objects. I won’t provide pseudocode for this transformation, since it’s similar to the way we type check non-static initializers in <a href="chapter15.xhtml#list15-25">Listing 15-25</a>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
&#13;
<h4 class="H2" id="sec24"><span id="h2-152"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Initializing Scalar Variables with ZeroInit</samp></h4>&#13;
<p class="TNI">You can also use <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp> to initialize scalar variables to zero. For instance, given the declaration</p>&#13;
<pre><code>static long x = 0;</code></pre>&#13;
<p class="BodyContinued">you could use this initializer:</p>&#13;
<pre><code>Initial([ZeroInit(8)])</code></pre>&#13;
<p class="TX">Using <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp> here is optional, but it makes code emission simpler because you can easily tell which initializers belong in <samp class="SANS_TheSansMonoCd_W5Regular_11">.data</samp> and which belong in <samp class="SANS_TheSansMonoCd_W5Regular_11">.bss</samp>. Just be careful about using <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp> to initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>s; use it only if you’re sure the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>’s initial value is <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp> and not <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>.</p>&#13;
<aside class="box" aria-label="box-43"><p class="BoxTitle" id="box-43"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_406" aria-label="406"/><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE TYPE CHECKER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test the type checker, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 15 --stage validate</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">Your compiler should successfully type check every test case in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_15/valid</samp><samp class="SANS_Futura_Std_Book_11">, and it should fail on every test case in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_15/invalid_types</samp><samp class="SANS_Futura_Std_Book_11">. The invalid test cases cover all the type errors your compiler should detect, including invalid pointer arithmetic and comparisons, invalid subscript expressions, casts to array type, and attempts to return or assign to expressions of array type. They also cover a wide range of invalid initializers.</samp></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
&#13;
<h3 class="H1" id="sec25"><span id="h1-133"/><samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp></h3>&#13;
<p class="TNI">To accommodate pointer arithmetic and compound initializers, we’ll make a few changes to the TACKY IR. First, since we changed how we represent initializers in the symbol table, we’ll make the corresponding change in TACKY:</p>&#13;
<pre><code>top_level = Function(identifier, bool global, identifier* params, instruction* body)&#13;
          | StaticVariable(identifier, bool global, type t, <b>static_init* init_list</b>)</code></pre>&#13;
<p class="TX">We’ll also introduce a new instruction to support pointer arithmetic:</p>&#13;
<pre><code>AddPtr(val ptr, val index, int scale, val dst)</code></pre>&#13;
<p class="TX">We’ll use this instruction to add or subtract an integer from a pointer, but not to subtract one pointer from another. The <samp class="SANS_TheSansMonoCd_W5Regular_11">scale</samp> operand is the size, in bytes, of each element in the array that <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> points into. For example, if <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> is an <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">scale</samp> operand will be <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, since an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> is 4 bytes. If <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> is an <samp class="SANS_TheSansMonoCd_W5Regular_11">int (*)[3]</samp>, a pointer to an array of three <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> objects, then <samp class="SANS_TheSansMonoCd_W5Regular_11">scale</samp> will be <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp> operand tells us how many elements forward or back to move from the base pointer. At runtime, the program will multiply <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp> by <samp class="SANS_TheSansMonoCd_W5Regular_11">scale</samp> to determine how many bytes to add to the base pointer. It would be possible to implement pointer arithmetic using the existing TACKY instructions for multiplication and addition. However, introducing a specialized <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp> instruction here will help us take advantage of the x64 architecture’s built-in support for pointer arithmetic.</p>&#13;
<p class="TX">We’ll introduce one more instruction to support compound initializers:</p>&#13;
<pre><code>CopyToOffset(val src, identifier dst, int offset)</code></pre>&#13;
<p class="TX">In this instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp> is a scalar value, <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> is the name of some variable of aggregate type, and <samp class="SANS_TheSansMonoCd_W5Regular_11">offset</samp> specifies the number of bytes between the start of <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> and the position we should copy <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp> to. It’s important to note that <span role="doc-pagebreak" epub:type="pagebreak" id="pg_407" aria-label="407"/><samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> designates an array, <i>not</i> a pointer to an array element. In other words, <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp> doesn’t use the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>; it uses <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> to identify an object with a fixed location in memory. Because this instruction operates directly on arrays, rather than pointers, it’s useful for array initialization but not for subscripting. In <span class="Xref-1"><a href="chapter18.xhtml">Chapter 18</a></span>, we’ll use it to initialize and update structures too.</p>&#13;
<p class="TX"><a href="chapter15.xhtml#list15-26">Listing 15-26</a> shows the updated TACKY IR, with this chapter’s changes bolded.</p>&#13;
<a id="list15-26"/>&#13;
<pre><code>program = Program(top_level*)&#13;
top_level = Function(identifier, bool global, identifier* params, instruction* body)&#13;
          | StaticVariable(identifier, bool global, type t, <b>static_init* init_list</b>)&#13;
instruction = Return(val)&#13;
            | SignExtend(val src, val dst)&#13;
            | Truncate(val src, val dst)&#13;
            | ZeroExtend(val src, val dst)&#13;
            | DoubleToInt(val src, val dst)&#13;
            | DoubleToUInt(val src, val dst)&#13;
            | IntToDouble(val src, val dst)&#13;
            | UIntToDouble(val src, val dst)&#13;
            | Unary(unary_operator, val src, val dst)&#13;
            | Binary(binary_operator, val src1, val src2, val dst)&#13;
            | Copy(val src, val dst)&#13;
            | GetAddress(val src, val dst)&#13;
            | Load(val src_ptr, val dst)&#13;
            | Store(val src, val dst_ptr)&#13;
            <b>| AddPtr(val ptr, val index, int scale, val dst)</b>&#13;
            <b>| CopyToOffset(val src, identifier dst, int offset)</b>&#13;
            | Jump(identifier target)&#13;
            | JumpIfZero(val condition, identifier target)&#13;
            | JumpIfNotZero(val condition, identifier target)&#13;
            | Label(identifier)&#13;
            | FunCall(identifier fun_name, val* args, val dst)&#13;
val = Constant(const) | Var(identifier)&#13;
unary_operator = Complement | Negate | Not&#13;
binary_operator = Add | Subtract | Multiply | Divide | Remainder | Equal | NotEqual&#13;
                | LessThan | LessOrEqual | GreaterThan | GreaterOrEqual</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-26: Adding support for arrays to the TACKY IR</samp></p>&#13;
<p class="TX">With these additions, we can implement every new operator and construct in this chapter. Let’s handle each of them in turn.</p>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
&#13;
<h4 class="H2" id="sec26"><span id="h2-153"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Pointer Arithmetic</samp></h4>&#13;
<p class="TNI">We’ll implement the pointer arithmetic expression <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;ptr&gt;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;int&gt;</samp> with an <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp> instruction, as <a href="chapter15.xhtml#list15-27">Listing 15-27</a> demonstrates.</p>&#13;
<a id="list15-27"/>&#13;
<pre><code><var>&lt;instructions for ptr&gt;</var>&#13;
p =<var> &lt;result of ptr&gt;</var>&#13;
<var>&lt;instructions for int&gt;</var>&#13;
i =<var> &lt;result of int&gt;</var>&#13;
result = AddPtr(p, i, <var>&lt;size of referenced type of ptr&gt;</var>)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-27: Adding an integer to a pointer in TACKY</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_408" aria-label="408"/>There are a couple of things to note about this listing. First, the pointer is always the first operand to the <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp> instruction and the integer is always the second, regardless of which was the first operand in the original expression. Second, you need to calculate the size of the pointer’s referenced type at compile time, since the <samp class="SANS_TheSansMonoCd_W5Regular_11">scale</samp> operand is a constant rather than a TACKY value.</p>&#13;
<p class="TX">The TACKY to subtract an integer from a pointer is almost identical; we just negate the index before we include it in <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>. We’ll convert <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;ptr&gt;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;int&gt;</samp> to the TACKY in <a href="chapter15.xhtml#list15-28">Listing 15-28</a>.</p>&#13;
<a id="list15-28"/>&#13;
<pre><code><var>&lt;instructions for ptr&gt;</var>&#13;
p =<var> &lt;result of ptr&gt;</var>&#13;
<var>&lt;instructions for int&gt;</var>&#13;
i =<var> &lt;result of int&gt;</var>&#13;
j = Unary(Negate, i)&#13;
result = AddPtr(p, j,<var> &lt;size of referenced type of ptr&gt;</var>)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-28: Subtracting an integer from a pointer in TACKY</samp></p>&#13;
<p class="TX">Subtracting one pointer from another works a bit differently. First, we calculate the difference in bytes, using an ordinary <samp class="SANS_TheSansMonoCd_W5Regular_11">Subtract</samp> instruction. Then, we divide this result by the number of bytes in one array element, to calculate the difference between the two pointers in terms of array indices. In other words, we’ll convert <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;ptr1&gt;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;ptr2&gt;</samp> to the TACKY in <a href="chapter15.xhtml#list15-29">Listing 15-29</a>.</p>&#13;
<a id="list15-29"/>&#13;
<pre><code><var>&lt;instructions for ptr1&gt;</var>&#13;
p1 =<var> &lt;result of ptr1&gt;</var>&#13;
<var>&lt;instructions for ptr2&gt;</var>&#13;
p2 =<var> &lt;result of ptr2&gt;</var>&#13;
diff = Binary(Subtract, p1, p2)&#13;
result = Binary(Divide, diff,<var> &lt;size of referenced type of ptr1&gt;</var>)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-29: Subtracting two pointers in TACKY</samp></p>&#13;
<p class="TX">We’ll calculate the size of the referenced type at compile time. You can use the type of either operand here, since the type checker already validated that they both have the same type.</p>&#13;
<p class="TX">We’ll compare pointers exactly like arithmetic values, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">LessThan</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">LessOrEqual</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterThan</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterOrEqual</samp> operators.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
&#13;
<h4 class="H2" id="sec27"><span id="h2-154"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Subscripting</samp></h4>&#13;
<p class="TNI">According to the C standard, the subscript expression <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;ptr&gt;</samp>[<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;int&gt;</samp>] is equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">*(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;ptr&gt;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;int&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>. So, to implement a subscript expression, we’ll generate the TACKY for pointer addition from <a href="chapter15.xhtml#list15-27">Listing 15-27</a> but return a <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer(result)</samp> to the caller instead of a <samp class="SANS_TheSansMonoCd_W5Regular_11">PlainOperand(result)</samp>. Generating the right TACKY here is simple, but understanding why it works, especially for multidimensional arrays, is a little trickier. To explore this further, let’s work through the example in <a href="chapter15.xhtml#list15-30">Listing 15-30</a>.</p>&#13;
<a id="list15-30"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_409" aria-label="409"/>int arr[3][4];&#13;
<var>--snip--</var>&#13;
return arr[i][j];</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-30: Returning the result of a subscript operator</samp></p>&#13;
<p class="TX"><a href="chapter15.xhtml#list15-31">Listing 15-31</a> shows the TACKY implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement in this example.</p>&#13;
<a id="list15-31"/>&#13;
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">❶</span> tmp0 = GetAddress(arr)&#13;
tmp1 = AddPtr(tmp0, i, 16)&#13;
tmp2 = AddPtr(tmp1, j, 4)&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">❷</span> tmp3 = Load(tmp2)&#13;
Return(tmp3)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-31: Implementing <a href="chapter15.xhtml#list15-30">Listing 15-30</a> in TACKY</samp></p>&#13;
<p class="TX">First, we issue a <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp> instruction to get a pointer to the first element in <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>. Then, we issue two <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp> instructions to calculate a pointer to the array element at <samp class="SANS_TheSansMonoCd_W5Regular_11">arr[i][j]</samp>. Finally, we use a <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp> instruction to read that array element’s current value into a temporary variable, which we return. <a href="chapter15.xhtml#list15-31">Listing 15-31</a> is efficient, without any superfluous instructions. We saw earlier that array subscripting requires us to repeatedly get the addresses of array elements, perform pointer arithmetic, and dereference the result. But in this listing, we get an array’s address only once, at the beginning <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and we use a <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp> instruction to dereference a pointer only once, at the end <span class="CodeAnnotation" aria-label="annotation2">❷</span>. How does our strategy for TACKY generation produce this result?</p>&#13;
<p class="TX"><a href="chapter15.xhtml#list15-32">Listing 15-32</a> gives the AST for the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement in <a href="chapter15.xhtml#list15-30">Listing 15-30</a>. Let’s figure out how each subexpression in this AST is converted to TACKY.</p>&#13;
<a id="list15-32"/>&#13;
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">❶</span> Return(&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> Subscript(&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> AddrOf(&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> Subscript(&#13;
              <span class="codeannotated_CodeAnnotation" aria-label="annotation5">❺</span> AddrOf(Var("arr")),&#13;
                Var("i")&#13;
            )&#13;
        ),&#13;
        Var("j")&#13;
    )&#13;
)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-32: The AST for <a href="chapter15.xhtml#list15-30">Listing 15-30</a></samp></p>&#13;
<p class="TX">The AST includes the two <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> expressions we inserted during type checking. The inner one <span class="CodeAnnotation" aria-label="annotation5">❺</span> gets the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>, and the outer one <span class="CodeAnnotation" aria-label="annotation3">❸</span> gets the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">arr[i]</samp>. Of course, <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> would have been renamed during identifier resolution, but we’ll ignore that detail in this example (and in the later examples in this chapter).</p>&#13;
<p class="TX">As always, we convert this AST to TACKY in postorder, processing each expression’s operands before we process the expression itself. The first <span role="doc-pagebreak" epub:type="pagebreak" id="pg_410" aria-label="410"/>non-leaf AST node we process is the inner <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> expression, which takes the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> <span class="CodeAnnotation" aria-label="annotation5">❺</span>. We convert it to a <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp> instruction:</p>&#13;
<pre><code>tmp0 = GetAddress(arr)</code></pre>&#13;
<p class="TX">Next, to implement the inner <samp class="SANS_TheSansMonoCd_W5Regular_11">Subscript</samp> expression <span class="CodeAnnotation" aria-label="annotation4">❹</span>, we emit an <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp> instruction:</p>&#13;
<pre><code>tmp1 = AddPtr(tmp0, i, 16)</code></pre>&#13;
<p class="TX">The scale here is <samp class="SANS_TheSansMonoCd_W5Regular_11">16</samp> because <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp> points to a four-<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> array. The second part of a subscript operation is dereferencing the result, so we’ll return <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer(tmp1)</samp> to the caller.</p>&#13;
<p class="TX">In the caller, we process the outer <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> expression <span class="CodeAnnotation" aria-label="annotation3">❸</span>. When we take the address of a dereferenced pointer, the operations cancel out. Therefore, we return <samp class="SANS_TheSansMonoCd_W5Regular_11">PlainOperand(tmp1)</samp> as the result of this expression, without emitting any further instructions.</p>&#13;
<p class="TX">Now we process the outer <samp class="SANS_TheSansMonoCd_W5Regular_11">Subscript</samp> expression <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Once again, we emit an <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp> instruction:</p>&#13;
<pre><code>tmp2 = AddPtr(tmp1, j, 4)</code></pre>&#13;
<p class="TX">We then return <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer(tmp2)</samp> to the caller. Because this <samp class="SANS_TheSansMonoCd_W5Regular_11">Subscript</samp> expression appears in a <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> statement <span class="CodeAnnotation" aria-label="annotation1">❶</span>, not an <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> or assignment expression, we lvalue convert this result. That means we emit a <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp> instruction:</p>&#13;
<pre><code>tmp3 = Load(tmp2)</code></pre>&#13;
<p class="TX">Now <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp3</samp> contains the lvalue-converted result of the whole expression, so we return it:</p>&#13;
<pre><code>Return(tmp3)</code></pre>&#13;
<p class="TX">As this example illustrates, when we index into a multidimensional array the dereference operations and implicit address loads cancel each other out, without producing any extra instructions. Therefore, any subscript and dereference operators work out to pure pointer arithmetic in TACKY, without any <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instructions, until we reach a scalar array element.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec28">&#13;
&#13;
<h4 class="H2" id="sec28"><span id="h2-155"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Compound Initializers</samp></h4>&#13;
<p class="TNI">To process a compound initializer, we evaluate each scalar expression in the initializer and copy it to the appropriate location in memory with a <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp> instruction. For example, we’ll convert the initializer</p>&#13;
<pre><code>long arr[3] = {1l, 2l, 3l};</code></pre>&#13;
<p class="BodyContinued"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_411" aria-label="411"/>to the following sequence of instructions:</p>&#13;
<pre><code>CopyToOffset(1l, "arr", 0)&#13;
CopyToOffset(2l, "arr", 8)&#13;
CopyToOffset(3l, "arr", 16)</code></pre>&#13;
<p class="TX">Since a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> is 8 bytes, the offset increases by eight with each element. Even when we process a nested initializer, we only need to copy the scalar values at the leaves to the correct memory locations. For example, we’ll convert</p>&#13;
<pre><code>long nested[2][3] = {{1l, 2l, 3l}, {4l, 5l, 6l}};</code></pre>&#13;
<p class="BodyContinued">to:</p>&#13;
<pre><code>CopyToOffset(1l, "nested", 0)&#13;
CopyToOffset(2l, "nested", 8)&#13;
CopyToOffset(3l, "nested", 16)&#13;
CopyToOffset(4l, "nested", 24)&#13;
CopyToOffset(5l, "nested", 32)&#13;
CopyToOffset(6l, "nested", 40)</code></pre>&#13;
<p class="TX">This conversion is pretty straightforward, so I’ll omit the pseudocode for it. I will note, however, that you should use the type information the type checker added to each compound initializer to calculate the offset of each element.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec29">&#13;
&#13;
<h4 class="H2" id="sec29"><span id="h2-156"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Tentative Array Definitions</samp></h4>&#13;
<p class="TNI">Recall that when we convert symbol table entries to <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp> constructs, we initialize tentatively defined variables to zero. That goes for tentatively defined arrays too. You should use the new initializer we added in the previous section, <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>, to initialize an <i>n</i>-byte array to zero.</p>&#13;
<p class="TX">You can also use <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp> to initialize tentatively defined scalar variables. For consistency, you should only use <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp> here if you’re using it to initialize explicitly defined scalar variables to zero in the type checker.</p>&#13;
<aside class="box" aria-label="box-44"><p class="BoxTitle" id="box-44"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE TACKY GENERATION STAGE</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test out TACKY generation, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 15 --stage tacky</b>&#13;
</code></pre></aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec30">&#13;
&#13;
<h3 class="H1" id="sec30"><span id="h1-134"/><samp class="SANS_Futura_Std_Bold_B_11">Assembly Generation</samp></h3>&#13;
<p class="TNI">We won’t introduce any new assembly instructions in this chapter. We will, however, introduce a new memory addressing mode, sometimes called <span role="doc-pagebreak" epub:type="pagebreak" id="pg_412" aria-label="412"/><i>indexed addressing</i>. Right now, we can specify a memory operand with a base address in a register and a constant offset, like <samp class="SANS_TheSansMonoCd_W5Regular_11">4(%rax)</samp>. Using indexed addressing, we can store the base address in one register and an index in another. We can also specify a scale, which must be one of the constants <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp>. Here’s an example of indexed addressing in action:</p>&#13;
<pre><code>movl    $5, (%rax, %rbx, 4)</code></pre>&#13;
<p class="TX">To find the destination address of this <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> instruction, the CPU will calculate RAX + RBX × 4. Then, it will store the 4-byte constant <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp> at this address. This addressing mode is convenient for array accesses. If RAX holds the address of an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> objects and RBX holds an index <i>i</i> into that array, the operand <samp class="SANS_TheSansMonoCd_W5Regular_11">(%rax, %rbx, 4)</samp> specifies the element at index <i>i</i>.</p>&#13;
<aside class="box" aria-label="box-45"><p class="BoxTitle" id="box-45"><samp class="SANS_Dogma_OT_Bold_B_11">USING INDEXED ADDRESSING FOR GENERAL-PURPOSE ARITHMETIC</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">Although indexed addressing was designed for pointer arithmetic, it’s an efficient way to add and multiply ordinary integers too. For example, the instruction</samp></p>&#13;
<pre><code>lea    (%rax, %rbx, 2), %rax&#13;
</code></pre>&#13;
<p class="BoxBodyContinued"><samp class="SANS_Futura_Std_Book_11">produces the same result as these instructions:</samp></p>&#13;
<pre><code>imulq   $2, %rbx&#13;
addq    %rbx, %rax&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">Our compiler uses indexed addressing only for pointer operations, but other compilers frequently use it for general-purpose integer arithmetic as well.</samp></p>&#13;
</aside>&#13;
<p class="TX">We’ll add a new operand to support indexed addressing:</p>&#13;
<pre><code>Indexed(reg base, reg index, int scale)</code></pre>&#13;
<p class="TX">We’ll also make a few other changes to the assembly AST to help with bookkeeping in later backend passes. For starters, we’ll add another operand to represent aggregate objects that haven’t been assigned a fixed address yet:</p>&#13;
<pre><code>PseudoMem(identifier, int)</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp> operand serves a similar purpose to the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp> operand; it lets us represent variables in assembly before we’ve allocated registers or memory locations for them. The difference is that <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp> represents aggregate objects, which we’ll always store in memory (even <span role="doc-pagebreak" epub:type="pagebreak" id="pg_413" aria-label="413"/>once we implement register allocation in <span class="Xref-1"><a href="part3.xhtml">Part III</a></span>). <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp>, on the other hand, represents scalar objects that could potentially be stored in registers. The <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp> operand also lets us specify a byte offset into the object in question. Note that the identifier in this operand designates an aggregate object, not a pointer to an aggregate object.</p>&#13;
<p class="TX">Next, we’ll add a new assembly type to represent arrays. In assembly, we’ll treat an array like an undifferentiated chunk of memory. We no longer need to track how many objects will be stored in that chunk of memory or what those objects’ types will be. We do, however, care about its alignment and how much space it takes up, so we can allocate stack space for it. Therefore, we’ll convert array types to a new <samp class="SANS_TheSansMonoCd_W5Regular_11">ByteArray</samp> type:</p>&#13;
<pre><code>assembly_type = Longword | Quadword | Double | <b>ByteArray(int size, int alignment)</b></code></pre>&#13;
<p class="TX">Finally, we’ll adjust how we represent static variables. As in earlier compiler passes, we’ll initialize a static variable with a list of <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp> values, instead of just one:</p>&#13;
<pre><code>StaticVariable(identifier name, bool global, int alignment, <b>static_init* init_list</b>)</code></pre>&#13;
<p class="TX"><a href="chapter15.xhtml#list15-33">Listing 15-33</a> highlights all the changes to the assembly AST in this chapter.</p>&#13;
<a id="list15-33"/>&#13;
<pre><code>program = Program(top_level*)&#13;
assembly_type = Longword | Quadword | Double | <b>ByteArray(int size, int alignment)</b>&#13;
top_level = Function(identifier name, bool global, instruction* instructions)&#13;
          | StaticVariable(identifier name, bool global, int alignment, <b>static_init* init_list</b>)&#13;
          | StaticConstant(identifier name, int alignment, static_init init)&#13;
instruction = Mov(assembly_type, operand src, operand dst)&#13;
            | Movsx(operand src, operand dst)&#13;
            | MovZeroExtend(operand src, operand dst)&#13;
            | Lea(operand src, operand dst)&#13;
            | Cvttsd2si(assembly_type dst_type, operand src, operand dst)&#13;
            | Cvtsi2sd(assembly_type src_type, operand src, operand dst)&#13;
            | Unary(unary_operator, assembly_type, operand)&#13;
            | Binary(binary_operator, assembly_type, operand, operand)&#13;
            | Cmp(assembly_type, operand, operand)&#13;
            | Idiv(assembly_type, operand)&#13;
            | Div(assembly_type, operand)&#13;
            | Cdq(assembly_type)&#13;
            | Jmp(identifier)&#13;
            | JmpCC(cond_code, identifier)&#13;
            | SetCC(cond_code, operand)&#13;
            | Label(identifier)&#13;
            | Push(operand)&#13;
            | Call(identifier)&#13;
            | Ret&#13;
unary_operator = Neg | Not | Shr&#13;
binary_operator = Add | Sub | Mult | DivDouble | And | Or | Xor&#13;
operand = Imm(int) | Reg(reg) | Pseudo(identifier) | Memory(reg, int) | Data(identifier)&#13;
        <b>| PseudoMem(identifier, int) | Indexed(reg base, reg index, int scale)</b>&#13;
cond_code = E | NE | G | GE | L | LE | A | AE | B | BE&#13;
reg = AX | CX | DX | DI | SI | R8 | R9 | R10 | R11 | SP | BP&#13;
    | XMM0 | XMM1 | XMM2 | XMM3 | XMM4 | XMM5 | XMM6 | XMM7 | XMM14 | XMM15</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-33: The assembly AST with support for aggregate objects and indexed addressing</samp></p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_414" aria-label="414"/>&#13;
<p class="TX">Once we’ve updated the assembly AST, we’ll update the conversion from TACKY to assembly.</p>&#13;
<section epub:type="division" aria-labelledby="sec31">&#13;
&#13;
<h4 class="H2" id="sec31"><span id="h2-157"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting TACKY to Assembly</samp></h4>&#13;
<p class="TNI">First, we’ll deal with TACKY variables of array type. To distinguish these from scalar values, we’ll convert them to <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp> operands, instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp> operands. For example, if <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> is an array, we’ll convert</p>&#13;
<pre><code>GetAddress(Var("arr"), Var("dst"))</code></pre>&#13;
<p class="BodyContinued">to:</p>&#13;
<pre><code>Lea(PseudoMem("arr", 0), Pseudo("dst"))</code></pre>&#13;
<p class="TX">Whenever we convert an aggregate TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp> to assembly, we’ll use an offset of zero, in order to designate the whole object.</p>&#13;
<p class="TX">Next, let’s deal with the new <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp> instructions. We’ll use a <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp> operand with the appropriate offset to represent the destination of a <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp> instruction. Therefore, we’ll convert</p>&#13;
<pre><code>CopyToOffset(src, dst, offset)</code></pre>&#13;
<p class="BodyContinued">to:</p>&#13;
<pre><code>Mov(<var>&lt;src type&gt;</var>, src, PseudoMem(dst, offset))</code></pre>&#13;
<p class="TX">We’ll implement <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp> with an <samp class="SANS_TheSansMonoCd_W5Regular_11">Lea</samp> instruction using the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Indexed</samp> operand. The details will vary depending on the scale and index. First, let’s consider the case where the scale is <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp>. We’ll convert</p>&#13;
<pre><code>AddPtr(ptr, index, scale, dst)</code></pre>&#13;
<p class="BodyContinued">to <a href="chapter15.xhtml#list15-34">Listing 15-34</a>.</p>&#13;
<a id="list15-34"/>&#13;
<pre><code>Mov(Quadword, ptr, Reg(AX))&#13;
Mov(Quadword, index, Reg(DX))&#13;
Lea(Indexed(AX, DX, scale), dst)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-34: Implementing</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">AddPtr</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in assembly</samp></p>&#13;
<p class="TX">First, we copy <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp> into registers; I’ve used RAX and RDX here, but anything other than the callee-saved registers or our scratch registers will do. Then, we emit an <samp class="SANS_TheSansMonoCd_W5Regular_11">Lea</samp> instruction to compute <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">index * scale</samp> and store the result in <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_415" aria-label="415"/>The scale of <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp> may not be one of the four values that <samp class="SANS_TheSansMonoCd_W5Regular_11">Indexed</samp> supports, especially if we’re indexing into a multidimensional array instead of an array of scalar objects. In that case, we’ll use a separate instruction to multiply the scale by the index, as <a href="chapter15.xhtml#list15-35">Listing 15-35</a> illustrates.</p>&#13;
<a id="list15-35"/>&#13;
<pre><code>Mov(Quadword, ptr, Reg(AX))&#13;
Mov(Quadword, index, Reg(DX))&#13;
Binary(Mult, Quadword, Imm(scale), Reg(DX))&#13;
Lea(Indexed(AX, DX, 1), dst)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-35: Implementing</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">AddPtr</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in assembly with a nonstandard scale</samp></p>&#13;
<p class="TX">If the <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp> operand is a constant, we can save an instruction by computing <samp class="SANS_TheSansMonoCd_W5Regular_11">index * scale</samp> at compile time. Then, we’ll generate just the two instructions in <a href="chapter15.xhtml#list15-36">Listing 15-36</a>.</p>&#13;
<a id="list15-36"/>&#13;
<pre><code>Mov(Quadword, ptr, Reg(AX))&#13;
Lea(Memory(AX, index * scale), dst)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-36: Implementing</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">AddPtr</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">with a constant index</samp></p>&#13;
<p class="TX">Next, we’ll deal with pointer comparisons. We’ll implement these exactly like unsigned integer comparisons, using the unsigned condition codes: <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">AE</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp>.</p>&#13;
<p class="TX">Finally, let’s talk about the alignment requirements for arrays. There are a couple of cases where we need to calculate an array’s alignment: when we convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp> of array type from TACKY to assembly (a <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp> in assembly includes an <samp class="SANS_TheSansMonoCd_W5Regular_11">alignment</samp> field), and when we convert a frontend symbol table entry of array type to the corresponding entry in the backend symbol table. The assembly type of each array in the backend symbol table will be a <samp class="SANS_TheSansMonoCd_W5Regular_11">ByteArray</samp> with the appropriate size and alignment. The size will be the size of the array’s element type in bytes, multiplied by the number of elements. The rules for calculating alignment are a bit less obvious.</p>&#13;
<p class="TX">If an array is smaller than 16 bytes, it has the same alignment as its scalar elements. For example, an array with type <samp class="SANS_TheSansMonoCd_W5Regular_11">int[2]</samp> and an array with type <samp class="SANS_TheSansMonoCd_W5Regular_11">int[2][1]</samp> both have an alignment of 4. If an array-type variable is 16 bytes or larger, its alignment is always 16, no matter what type its elements are. This requirement makes it possible to use SSE instructions to operate on multiple array elements at once. We don’t use SSE instructions this way, but we need to maintain ABI compatibility with other object files that might.</p>&#13;
<p class="TX">Note that this alignment requirement applies only to variables, not to nested arrays. For example, if we declare the variable</p>&#13;
<pre><code>int nested[3][5];</code></pre>&#13;
<p class="BodyContinued">then <samp class="SANS_TheSansMonoCd_W5Regular_11">nested</samp> needs to start at a 16-byte-aligned address because its total size is 60 bytes. But its first and second elements start at 20 and 40 bytes, respectively, from the start of <samp class="SANS_TheSansMonoCd_W5Regular_11">nested</samp>, so they aren’t 16-byte aligned, even though each of these elements is also larger than 16 bytes.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_416" aria-label="416"/><a href="chapter15.xhtml#tab15-1">Tables 15-1</a> through <a href="chapter15.xhtml#tab15-5">15-5</a> summarize this chapter’s updates to this compiler pass; as usual, new constructs and changes to the conversions for existing constructs are bolded.</p>&#13;
<p class="TT" id="tab15-1"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 15-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting Top-Level TACKY Constructs to Assembly</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">TACKY top-level construct</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable(name, global, t,</samp><samp class="SANS_TheSansMonoCd_W5Regular_11"/> <samp class="SANS_Futura_Std_Heavy_B_11">init_list</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp></code></pre></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable(name, global,</samp><samp class="SANS_TheSansMonoCd_W5Regular_11"/> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;alignment of t&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp> &#13;
<samp class="SANS_Futura_Std_Heavy_B_11">               init_list</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp></code></pre></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab15-2"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 15-2:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting TACKY Instructions to Assembly</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">TACKY instruction</samp></p></th>&#13;
<td class="Basic-Table TCH"/>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly instructions</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table graybg TBF" rowspan="3"><pre class="table"><code><samp class="SANS_Futura_Std_Heavy_B_11">AddPtr(ptr, index,&#13;
             scale, dst)</samp></code></pre></td>&#13;
<td class="Basic-Table graybg TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Constant index</samp></p></td>&#13;
<td class="Basic-Table graybg TBL"><pre class="table"><code><samp class="SANS_Futura_Std_Heavy_B_11">Mov(Quadword, ptr, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R&gt;</samp><samp class="SANS_Futura_Std_Heavy_B_11">))<br/>Lea(Memory(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R&gt;</samp><samp class="SANS_Futura_Std_Heavy_B_11">, index * scale), dst)</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table graybg TBL"><pre class="table"><code><samp class="SANS_Futura_Std_Heavy_B_11">Variable index and scale of</samp><samp class="SANS_TheSansMonoCd_W5Regular_11"/> <samp class="SANS_Futura_Std_Heavy_B_11">1,</samp><samp class="SANS_Futura_Std_Book_11"/> <samp class="SANS_Futura_Std_Heavy_B_11">2,</samp><samp class="SANS_Futura_Std_Book_11"/> <samp class="SANS_Futura_Std_Heavy_B_11">4, or</samp><samp class="SANS_Futura_Std_Book_11"/> <samp class="SANS_Futura_Std_Heavy_B_11">8</samp></code></pre></td>&#13;
<td class="Basic-Table graybg TBL"><pre class="table"><code><samp class="SANS_Futura_Std_Heavy_B_11">Mov(Quadword, ptr, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R1&gt;</samp><samp class="SANS_Futura_Std_Heavy_B_11">))<br/>Mov(Quadword, index, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R2&gt;</samp><samp class="SANS_Futura_Std_Heavy_B_11">))<br/>Lea(Indexed(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R1&gt;</samp><samp class="SANS_Futura_Std_Heavy_B_11">,</samp><samp class="SANS_Futura_Std_Book_11"/> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R2&gt;</samp><samp class="SANS_Futura_Std_Heavy_B_11">, scale), dst)</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table graybg TB"><pre class="table"><code><samp class="SANS_Futura_Std_Heavy_B_11">Variable index and other scale</samp></code></pre></td>&#13;
<td class="Basic-Table graybg TB"><pre class="table"><code><samp class="SANS_Futura_Std_Heavy_B_11">Mov(Quadword, ptr, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R1&gt;</samp><samp class="SANS_Futura_Std_Heavy_B_11">))<br/>Mov(Quadword, index, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R2&gt;</samp><samp class="SANS_Futura_Std_Heavy_B_11">))<br/>Binary(Mult, Quadword, Imm(scale), Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R2&gt;</samp><samp class="SANS_Futura_Std_Heavy_B_11">))<br/>Lea(Indexed(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R1&gt;</samp><samp class="SANS_Futura_Std_Heavy_B_11">,</samp><samp class="SANS_Futura_Std_Book_11"/> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R2&gt;</samp><samp class="SANS_Futura_Std_Heavy_B_11">, 1), dst)</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL" colspan="2"><pre class="table"><code><samp class="SANS_Futura_Std_Heavy_B_11">CopyToOffset(src, dst, offset)</samp></code></pre></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_Futura_Std_Heavy_B_11">Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;src type&gt;</samp><samp class="SANS_Futura_Std_Heavy_B_11">, src, PseudoMem(dst, offset))</samp></code></pre></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab15-3"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 15-3:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting TACKY Comparisons to Assembly</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">TACKY comparison</samp></p></th>&#13;
<td class="Basic-Table TCH"/>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly condition code</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table graybg TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">LessThan</samp></p></td>&#13;
<td class="Basic-Table graybg TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Signed</samp></p></td>&#13;
<td class="Basic-Table graybg TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table graybg TBF"/>&#13;
<td class="Basic-Table graybg TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Unsigned,</samp> <samp class="SANS_Futura_Std_Heavy_B_11">pointer</samp><samp class="SANS_Futura_Std_Book_11">, or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp></p></td>&#13;
<td class="Basic-Table graybg TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">LessOrEqual</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Signed</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">LE</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"/>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Unsigned,</samp> <samp class="SANS_Futura_Std_Heavy_B_11">pointer</samp><samp class="SANS_Futura_Std_Book_11">, or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table graybg TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterThan</samp></p></td>&#13;
<td class="Basic-Table graybg TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Signed</samp></p></td>&#13;
<td class="Basic-Table graybg TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">G</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table graybg TB"/>&#13;
<td class="Basic-Table graybg TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Unsigned,</samp> <samp class="SANS_Futura_Std_Heavy_B_11">pointer</samp><samp class="SANS_Futura_Std_Book_11">, or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp></p></td>&#13;
<td class="Basic-Table graybg TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterOrEqual</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Signed</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">GE</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"/>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Unsigned,</samp> <samp class="SANS_Futura_Std_Heavy_B_11">pointer</samp><samp class="SANS_Futura_Std_Book_11">, or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">AE</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab15-4"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 15-4:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting TACKY Operands to Assembly</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">TACKY operand</samp></p></th>&#13;
<td class="Basic-Table TCH"/>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Var(identifier)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Scalar value</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Pseudo(identifier)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"/>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Aggregate value</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">PseudoMem(identifier, 0)</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_417" aria-label="417"/>&#13;
<p class="TT" id="tab15-5"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 15-5:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting Types to Assembly</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" colspan="2" scope="colgroup"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Source type</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly type</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Alignment</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBL" rowspan="2"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Array(element,       size)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Variables that are 16 bytes or larger</samp></p></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_Futura_Std_Heavy_B_11">ByteArray(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;size of element&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11"/> <samp class="SANS_Futura_Std_Heavy_B_11">* size, 16)</samp></code></pre></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">16</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Everything else</samp></p></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_Futura_Std_Heavy_B_11">ByteArray(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;size of element&gt;</samp><samp class="SANS_Futura_Std_Book_11"/> <samp class="SANS_Futura_Std_Heavy_B_11">* size,</samp> &#13;
<samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">          &lt;alignment of element&gt;</samp><samp class="SANS_Futura_Std_Heavy_B_11">)</samp></code></pre></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Same alignment as element</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Next, we’ll replace <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp> operands with concrete addresses.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec32">&#13;
&#13;
<h4 class="H2" id="sec32"><span id="h2-158"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Replacing PseudoMem Operands</samp></h4>&#13;
<p class="TNI">We can’t call this pass “pseudoregister replacement” anymore, because we’re replacing aggregate values too. Just like we’ll allocate 4 bytes of stack space for a <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp> and 8 bytes for a <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>, we’ll allocate <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">size</samp> bytes for an object with type <samp class="SANS_TheSansMonoCd_W5Regular_11">ByteArray(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">size</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">alignment</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>. As usual, we’ll round down the array’s address to the appropriate alignment.</p>&#13;
<p class="TX">Once an array has been assigned a memory address, we’ll replace any <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp> operands that refer to it. A <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp> operand includes an offset from the start of the array, and the array’s concrete address includes an offset from the address in RBP. We’ll add these two offsets to construct a new concrete memory address. For example, suppose we encounter the following instruction:</p>&#13;
<pre><code>Mov(Longword, Imm(3), PseudoMem("arr", 4))</code></pre>&#13;
<p class="TX">Let’s say that we previously assigned <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> the stack address <samp class="SANS_TheSansMonoCd_W5Regular_11">-12(%rbp)</samp>. We compute –12 + 4 to determine that our new, concrete operand is <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>. We then rewrite the instruction accordingly:</p>&#13;
<pre><code>Mov(Longword, Imm(3), Memory(BP, -8))</code></pre>&#13;
<p class="TX">To access an array with static storage duration, we use the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> operand. If <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> is a static array, we convert</p>&#13;
<pre><code>PseudoMem("arr", 0)</code></pre>&#13;
<p class="BodyContinued">to:</p>&#13;
<pre><code>Data("arr")</code></pre>&#13;
<p class="TX">If we encountered <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem("arr",</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp> for any nonzero <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n</samp>, we’d be in trouble, because the <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> operand doesn’t include an offset. Luckily, this situation won’t come up. At the moment, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp> operands with nonzero offsets only to initialize arrays with automatic storage duration, not to access arrays with static storage duration.</p>&#13;
<p class="TX">RIP-relative addressing <i>does</i> support constant offsets—for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">foo+4(%rip)</samp> represents the address 4 bytes past the symbol <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>—but we <span role="doc-pagebreak" epub:type="pagebreak" id="pg_418" aria-label="418"/>can’t represent these offsets in the assembly AST yet. We’ll add them in <span class="Xref-1"><a href="chapter18.xhtml">Chapter 18</a></span> to support operations on structures.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec33">&#13;
&#13;
<h4 class="H2" id="sec33"><span id="h2-159"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Fixing Up Instructions</samp></h4>&#13;
<p class="TNI">We didn’t introduce any new instructions, so we don’t need any new instruction fix-up rules. This pass must recognize that the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Indexed</samp> operand specifies a memory address and therefore can’t be used where a register or immediate value is required. Otherwise, we don’t need to change anything.</p>&#13;
<aside class="box" aria-label="box-46"><p class="BoxTitle" id="box-46"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE ASSEMBLY GENERATION STAGE</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test that your compiler can generate assembly programs without throwing an error, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 15 --stage codegen</b>&#13;
</code></pre></aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec34">&#13;
&#13;
<h3 class="H1" id="sec34"><span id="h1-135"/><samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp></h3>&#13;
<p class="TNI">We’ll make four small additions to this stage. First, we’ll emit the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Indexed</samp> operand. Second, we’ll emit the static <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp> initializer as a <samp class="SANS_TheSansMonoCd_W5Regular_11">.zero</samp> assembly directive. For example, we’ll emit <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit(32)</samp> as:</p>&#13;
<pre><code>    .zero 32</code></pre>&#13;
<p class="TX">Third, if a variable’s only initializer is <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp>, we’ll write it to the BSS section instead of the data section.</p>&#13;
<p class="TX">And finally, when we define a static variable, we’ll emit each item in the associated initializer list. The file scope declaration</p>&#13;
<pre><code>int arr[4] = {1, 2, 3};</code></pre>&#13;
<p class="BodyContinued">will ultimately be translated to the assembly in <a href="chapter15.xhtml#list15-37">Listing 15-37</a>.</p>&#13;
<a id="list15-37"/>&#13;
<pre><code>    .globl arr&#13;
    .data&#13;
    .align 16&#13;
arr:&#13;
    .long 1&#13;
    .long 2&#13;
    .long 3&#13;
    .zero 4</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-37: Initializing a static array in assembly</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_419" aria-label="419"/>Note that we initialize the last element of this array to zero because it wasn’t initialized explicitly.</p>&#13;
<p class="TX"><a href="chapter15.xhtml#tab15-6">Tables 15-6</a> through <a href="chapter15.xhtml#tab15-8">15-8</a> summarize these additions to the code emission stage, with new constructs and changes to the way we emit existing constructs bolded.</p>&#13;
<p class="TT" id="tab15-6"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 15-6:</samp></span> <samp class="SANS_Futura_Std_Book_11">Formatting Top-Level Assembly Constructs</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp></p></th>&#13;
<td class="Basic-Table TCH"/>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Output</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBL" rowspan="2"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable(name, global,&#13;
               alignment,</samp>&#13;
 <samp class="SANS_Futura_Std_Heavy_B_11">                         init_list</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp></code></pre></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_Futura_Std_Book_11">Integer initialized to zero,</samp> <samp class="SANS_Futura_Std_Heavy_B_11">or</samp><samp class="SANS_Futura_Std_Book_11"/> <samp class="SANS_Futura_Std_Heavy_B_11">any variable</samp><samp class="SANS_Futura_Std_Book_11"/> <samp class="SANS_Futura_Std_Heavy_B_11">initialized only with</samp><samp class="SANS_Futura_Std_Book_11"/> <samp class="SANS_Futura_Std_Heavy_B_11">ZeroInit</samp></code></pre></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">     &lt;global-directive&gt;</samp> &#13;
<samp class="SANS_Futura_Std_Book_11"> </samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">   .bss</samp> &#13;
<samp class="SANS_Futura_Std_Book_11"> </samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">   &lt;alignment-directive&gt;&#13;
&lt;name&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> &#13;
<samp class="SANS_Futura_Std_Book_11"> </samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">   &lt;init_list&gt;</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">All other variables</samp></p></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_Futura_Std_Book_11"> </samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">   &lt;global-directive&gt;</samp> &#13;
<samp class="SANS_Futura_Std_Book_11"> </samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">   .data</samp> &#13;
<samp class="SANS_Futura_Std_Book_11"> </samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">   &lt;alignment-directive&gt;&#13;
&lt;name&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> &#13;
<samp class="SANS_Futura_Std_Book_11"> </samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">   &lt;init_list&gt;</samp></code></pre></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab15-7"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 15-7:</samp></span> <samp class="SANS_Futura_Std_Book_11">Formatting Static Initializers</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Static initializer</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Output</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">ZeroInit(n)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">.zero</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;n&gt;</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab15-8"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 15-8:</samp></span> <samp class="SANS_Futura_Std_Book_11">Formatting Assembly Operands</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Output</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Indexed(reg1, reg2, int)</samp></p></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;reg1&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">,</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"> &lt;reg2&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">,</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"> &lt;int&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">)</samp></code></pre></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">After making these changes, you can test out your compiler.</p>&#13;
<aside class="box" aria-label="box-47"><p class="BoxTitle" id="box-47"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE WHOLE COMPILER</samp></p>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">To test out the whole compiler, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 15</b>&#13;
</code></pre></aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec35">&#13;
&#13;
<h3 class="H1" id="sec35"><span id="h1-136"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI">You’ve just implemented your first aggregate type! In this chapter, you learned how to parse array declarators and compound initializers. In the type checker, you made implicit conversions from arrays to pointers explicit <span role="doc-pagebreak" epub:type="pagebreak" id="pg_420" aria-label="420"/>and analyzed the types of pointer arithmetic expressions. During TACKY generation, you relied on those conversions and that type information to handle operations on pointers cleanly, regardless of whether they point to arrays or scalar values. And on the backend, you added new, more flexible ways to address values in memory.</p>&#13;
<p class="TX">In the next chapter, you’ll implement three more integer types: <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>. You’ll also implement string literals, which can be either array initializers or <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> arrays that decay to pointers, depending on context. Because you’ve already implemented integer types, pointers, and arrays, a lot of the groundwork for the work you’ll do there is already in place.</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>