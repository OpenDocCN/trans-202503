- en: <samp class="SANS_Dogma_OT_Bold_B_11">APPENDIX</samp> <samp class="SANS_Dogma_OT_Bold_B_11">AUXILIARY
    SOURCES</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: Modern EDRs sometimes make use of less popular components not covered in this
    book so far. These auxiliary telemetry sources can provide immense value to the
    EDR, offering access to data that would otherwise be unavailable from other sensors.
  prefs: []
  type: TYPE_NORMAL
- en: Because these data sources are uncommon, we won’t take a deep dive into their
    inner workings. Instead, this appendix covers some examples of them, how they
    work, and what they can offer an EDR agent. This is by no means an exhaustive
    list, but it shines a light on some of the more niche components you may encounter
    during your research.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Alternative Hooking Methods</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This book has shown the value of intercepting function calls, inspecting the
    parameters passed to them, and observing their return values. The most prevalent
    method of hooking function calls at the time of this writing relies on injecting
    a DLL into the target process and modifying the execution flow of another DLL’s
    exported functions, such as those of *ntdll.dll*, forcing execution to pass through
    the EDR’s DLL. However, this method is trivial to bypass due to weaknesses inherent
    in its implementation (see [Chapter 2](chapter2.xhtml)).
  prefs: []
  type: TYPE_NORMAL
- en: Other, more robust methods of intercepting function calls exist, such as using
    the Microsoft-Windows-Threat-Intelligence ETW provider to indirectly intercept
    certain syscalls in the kernel, but these have their own limitations. Having multiple
    techniques for achieving the same effect provides advantages for defenders, as
    one method may work better in some contexts than others. For this reason, some
    vendors have leveraged alternative hooking methods in their products to augment
    their ability to monitor calls to suspicious functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a 2015 Recon talk titled “Esoteric Hooks,” Alex Ionescu expounded on some
    of these techniques. A few mainstream EDR vendors have implemented one of the
    methods he outlines: Nirvana hooks. Where garden-variety function hooking works
    by intercepting the function’s caller, this technique intercepts the point at
    which the syscall returns to user mode from the kernel. This allows the agent
    to identify syscalls that didn’t originate from a known location, such as the
    copy of *ntdll.dll* mapped into a process’s address space. Thus, it can detect
    the use of manual syscalls, a technique that has become relatively common in offensive
    tools in recent years.'
  prefs: []
  type: TYPE_NORMAL
- en: There are a few notable downsides to this hooking method, though. First, it
    relies on an undocumented <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_INFORMATION_CLASS</samp>
    and associated structure being passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationProcess()</samp>
    for each process the product wishes to monitor. Because it isn’t formally supported,
    Microsoft may modify its behavior or disable it entirely at any time. Additionally,
    the developer must identify the source of the call by capturing the return context
    and correlating it to a known good image in order to detect manual syscall invocation.
    Lastly, this hooking method is simple to evade, as adversaries can remove the
    hook from their process by nulling out the callback via a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationProcess()</samp>,
    similarly to how the security process initially placed it.
  prefs: []
  type: TYPE_NORMAL
- en: Even if Nirvana hooks are relatively easy to evade, not every adversary has
    the capability to do so, and the telemetry they provide might still be valuable.
    Vendors can employ multiple techniques to provide the coverage they desire.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">RPC Filters</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recent attacks have rekindled interest in RPC tradecraft. Lee Christensen’s
    PrinterBug and topotam’s PetitPotam exploits, for example, have proven their utility
    in Windows environments. In response, EDR vendors have begun paying attention
    to emerging RPC tradecraft in hopes of detecting and preventing their use.
  prefs: []
  type: TYPE_NORMAL
- en: RPC traffic is notoriously difficult to work with at scale. One way EDRs can
    monitor it is by using *RPC filters*. These are essentially firewall rules based
    on RPC interface identifiers, and they’re simple to create and deploy using built-in
    system utilities. For example, [Listing A-1](#listA-1) demonstrates how to ban
    all inbound DCSync traffic to the current host using *netsh.exe* interactively.
    An EDR could deploy this rule on all domain controllers in an environment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing A-1: Adding and listing RPC filters using <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">netsh</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: These commands add a new RPC filter that specifically blocks any communications
    using the *Directory Replication Service* RPC interface (which has the GUID <samp
    class="SANS_TheSansMonoCd_W5Regular_11">E3514235-4B06-11D1-AB04-00C04FC2DCD2</samp>).
    Once the filter is installed via the <samp class="SANS_TheSansMonoCd_W5Regular_11">add
    filter</samp> command, it is live on the system, prohibiting DCSync.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the RPC filter blocks a connection, the Microsoft-Windows-RPC provider
    will emit an ETW similar to the one shown in [Listing A-2](#listA-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing A-2: An ETW event showing activity blocked by a filter'
  prefs: []
  type: TYPE_NORMAL
- en: While this event is better than nothing, and defenders could theoretically use
    it to build detections, it lacks much of the context needed for a robust detection.
    For example, the principal that issued the request and the direction of traffic
    (as in, inbound or outbound) are not immediately clear, making it difficult to
    filter events to help tune a detection.
  prefs: []
  type: TYPE_NORMAL
- en: A better option may be to consume a similar event from the Microsoft-Windows-Security-Auditing
    Secure ETW provider. Since this provider is protected, standard applications can’t
    consume from it. It is, however, fed into the Windows Event Log, where it populates
    Event ID 5157 whenever the base filtering engine component of the Windows Filtering
    Platform blocks a request. [Listing A-3](#listA-3) contains an example of Event
    ID 5157\. You can see how much more detailed it is than the one emitted by Microsoft-Windows-RPC.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing A-3: An event manifest for the Microsoft-Windows-Security-Auditing
    Secure ETW provider'
  prefs: []
  type: TYPE_NORMAL
- en: While this event contains much more data, it also has some limitations. Notably,
    although the source and destination ports are included, the interface ID is missing,
    making it difficult to determine whether the event is related to the filter that
    blocks DCSync attempts or another filter entirely. Additionally, this event operates
    inconsistently across Windows versions, generating correctly in some and completely
    missing in others. Therefore, some defenders might prefer to use the less-enriched
    but more consistent RPC event as their primary data source.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Hypervisors</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hypervisors virtualize one or more guest operating systems, then act as an intermediary
    between the guest and either the hardware or the base operating system, depending
    on the hypervisor’s architecture. This intermediary position provides EDRs with
    a unique opportunity for detection.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">How Hypervisors Work</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The inner workings of a hypervisor are relatively simple once you understand
    a few core concepts. Windows runs code at several *rings*; the code running in
    a higher ring, such as *ring 3* for user mode, is less privileged than code running
    at a lower one, such as *ring 0* for the kernel. Root mode, where the hypervisor
    resides, operates at ring 0, the lowest architecturally supported privilege level,
    and limits the operations that the guest, or non-root mode system, can perform.
    [Figure A-1](#figA-1) shows this process.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/FigureA-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure A-1: The operation of
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">VMEXIT</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">VMENTER</samp></samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When a virtualized guest system attempts to execute an instruction or perform
    some action that the hypervisor must handle, a <samp class="SANS_TheSansMonoCd_W5Regular_11">VMEXIT</samp>
    instruction occurs. When this happens, control transitions from the guest to the
    hypervisor. The *Virtual Machine Control Structure (VMCS)* preserves the state
    of the processor for both the guest and the hypervisor so that it can be restored
    later. It also keeps track of the reason for the <samp class="SANS_TheSansMonoCd_W5Regular_11">VMEXIT</samp>.
    One VMCS exists for each logical processor of the system, and you can read more
    about them in volume 3C of the Intel Software Developer’s Manual.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '*For the sake of simplicity, this brief exploration covers the operation of
    a hypervisor based on Intel VT-x, as Intel CPUs remain the most popular at the
    time of this writing.*'
  prefs: []
  type: TYPE_NORMAL
- en: When the hypervisor enters root-mode operation, it may emulate, modify, and
    log the activity based on the reason for the <samp class="SANS_TheSansMonoCd_W5Regular_11">VMEXIT</samp>.
    These exits may occur for many common reasons, including instructions such as
    <samp class="SANS_TheSansMonoCd_W5Regular_11">RDMSR</samp>, for reading model-specific
    registers, and <samp class="SANS_TheSansMonoCd_W5Regular_11">CPUID</samp>, which
    returns information about the processor. After the completion of the root-mode
    operation, execution is transferred back to non-root-mode operation via a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">VMRESUME</samp> instruction, allowing
    the guest to continue.
  prefs: []
  type: TYPE_NORMAL
- en: There are two types of hypervisors. Products such as Microsoft’s Hyper-V and
    VMware’s ESX are what we call *Type 1 hypervisors*. This means the hypervisor
    runs on the bare metal system, as shown in Figure A-2.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/FigureA-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure A-2: A Type 1 hypervisor
    architecture</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The other kind of hypervisor, *Type 2*, runs in an operating system installed
    on the bare metal system. Examples of these include VMware’s Workstation and Oracle’s
    VirtualBox. The Type 2 architecture is shown in Figure A-3.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/FigureA-3.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure A-3: A Type 2 hypervisor
    architecture</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Type 2 hypervisors are interesting because they can virtualize a system that
    is already running. Thus, rather than requiring the end user to log in to their
    system, start an application such as VMware Workstation, launch a virtual machine,
    log in to the virtual machine, and then do their work from that virtual machine,
    their host is the virtual machine. This makes the hypervisor layer transparent
    to the user (and resident attackers) while allowing the EDR to collect all the
    telemetry available.
  prefs: []
  type: TYPE_NORMAL
- en: Most EDRs that implement a hypervisor take the Type 2 approach. Even so, they
    must follow a complicated series of steps to virtualize an existing system. Full
    hypervisor implementation is far beyond the scope of this book. If this topic
    interests you, both Daax Rynd and Sina Karvandi have excellent resources for implementing
    your own.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Security Use Cases</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A hypervisor can provide visibility into system operations at a layer deeper
    than nearly any other sensor. Using one, an endpoint security product can detect
    attacks missed by the sensors in other rings, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Virtual Machine Detection**'
  prefs: []
  type: TYPE_NORMAL
- en: Some malware attempts to detect that it is running in a virtual machine by issuing
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">CPUID</samp> instruction. Since
    this instruction causes a <samp class="SANS_TheSansMonoCd_W5Regular_11">VMEXIT</samp>,
    the hypervisor has the ability to choose what to return to the caller, allowing
    it to trick the malware into thinking it isn’t running in a VM.
  prefs: []
  type: TYPE_NORMAL
- en: '**Syscall Interception**'
  prefs: []
  type: TYPE_NORMAL
- en: A hypervisor can potentially leverage the Extended Feature Enable Register (EFER)
    function to exit on each syscall and emulate its operation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Control Register Modification**'
  prefs: []
  type: TYPE_NORMAL
- en: A hypervisor can detect the modification of bits in a control register (such
    as the <samp class="SANS_TheSansMonoCd_W5Regular_11">SMEP</samp> bit in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CR4</samp> register), which is behavior
    that could be part of an exploit. Additionally, the hypervisor can exit when a
    control register is changed, allowing it to inspect the guest execution context
    to identify things such as token-stealing attacks.
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory Change Tracing**'
  prefs: []
  type: TYPE_NORMAL
- en: A hypervisor can use the page-modification log in conjunction with Extended
    Page Tables (EPT) to track changes to certain regions of memory.
  prefs: []
  type: TYPE_NORMAL
- en: '**Branch Tracing**'
  prefs: []
  type: TYPE_NORMAL
- en: A hypervisor can leverage the *last branch record*, a set of registers used
    to trace branches, interrupts, and exceptions, along with EPT to trace the execution
    of the program beyond monitoring its syscalls.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Evading the Hypervisor</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the difficult things about operating against a system onto which a vendor
    has deployed a hypervisor is that, by the time you know you’re in a virtual machine,
    you’ve likely already been detected. Thus, malware developers commonly use virtual-machine-detection
    functions, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">CPUID</samp>
    instructions or sleep acceleration, prior to executing their malware. If the malware
    finds that it is running in a virtual machine, it may opt to terminate or merely
    do something benign.
  prefs: []
  type: TYPE_NORMAL
- en: Another option available to attackers is unloading the hypervisor. In the case
    of Type 2 hypervisors, you might be able to interact with the driver via an I/O
    control code, by changing the boot configuration, or by directly stopping the
    controlling service in order to cause the hypervisor to devirtualize the processors
    and unload, preventing its ability to monitor future actions. To date, there are
    no public reports of a real-world adversary employing these techniques.
  prefs: []
  type: TYPE_NORMAL
