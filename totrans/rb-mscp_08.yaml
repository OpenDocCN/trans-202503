- en: Chapter 8. How Ruby Borrowed a Decades-Old Idea from Lisp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1853819.png.jpg)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Blocks are Ruby’s implementation of closures.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Blocks are one of the most commonly used and powerful features of Ruby because
    they allow you to pass a code snippet to `Enumerable` methods, such as `each`,
    `detect`, or `inject`. Using the `yield` keyword, you can also write your own
    custom iterators or functions that call blocks for other reasons. Ruby code containing
    blocks is often more succinct, elegant, and expressive than equivalent code in
    older languages, such as C.
  prefs: []
  type: TYPE_NORMAL
- en: But don’t jump to the conclusion that blocks are a new idea! In fact, blocks
    are not new to Ruby at all. The computer science concept behind blocks, called
    *closures*, was first invented by Peter J. Landin in 1964, a few years after the
    original version of Lisp was created by John McCarthy in 1958\. Closures were
    later adopted by Lisp, or—more precisely—a dialect of Lisp called *Scheme*, which
    was invented by Gerald Sussman and Guy Steele in 1975\. Sussman and Steele’s use
    of closures in Scheme brought the idea to many programmers for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: But what does the word *closure* actually mean in this context? In other words,
    exactly what are Ruby blocks? Are they just the snippet of Ruby code that appears
    between the `do` and `end` keywords? In this chapter I’ll review how Ruby implements
    blocks internally and demonstrate how they meet the definition of *closure* used
    by Sussman and Steele back in 1975\. I’ll also show how blocks, lambdas, and procs
    are all different ways of looking at closures.
  prefs: []
  type: TYPE_NORMAL
- en: Roadmap
  prefs: []
  type: TYPE_NORMAL
- en: '[Blocks: Closures in Ruby](ch08.html#blocks_closures_in_ruby "Blocks: Closures
    in Ruby")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Stepping Through How Ruby Calls a Block](ch08.html#stepping_through_how_ruby_calls_a_block
    "Stepping Through How Ruby Calls a Block")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Borrowing an Idea from 1975](ch08.html#borrowing_an_idea_from_1975 "Borrowing
    an Idea from 1975")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The rb_block_t and rb_control_frame_t Structures](ch08.html#rbunderscoreblockunderscoret_and_rbu
    "The rb_block_t and rb_control_frame_t Structures")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Experiment 8-1: Which Is Faster: A while Loop or Passing a Block to each?](ch08.html#experiment_8-1_which_is_faster_a_while_l
    "Experiment 8-1: Which Is Faster: A while Loop or Passing a Block to each?")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Lambdas and Procs: Treating a Function as a First-Class Citizen](ch08.html#lambdas_and_procs_treating_a_function_as
    "Lambdas and Procs: Treating a Function as a First-Class Citizen")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Stack vs. Heap Memory](ch08.html#stack_vsdot_heap_memory "Stack vs. Heap Memory")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A Closer Look at How Ruby Saves a String Value](ch08.html#closer_look_at_how_ruby_saves_a_string
    "A Closer Look at How Ruby Saves a String Value")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How Ruby Creates a Lambda](ch08.html#how_ruby_creates_a_lambda "How Ruby Creates
    a Lambda")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How Ruby Calls a Lambda](ch08.html#how_ruby_calls_a_lambda "How Ruby Calls
    a Lambda")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Proc Object](ch08.html#proc_object "The Proc Object")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Experiment 8-2: Changing Local Variables After Calling lambda](ch08.html#experiment_8-2_changing_local_variables
    "Experiment 8-2: Changing Local Variables After Calling lambda")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Calling lambda More Than Once in the Same Scope](ch08.html#calling_lambda_more_than_once_in_the_sam
    "Calling lambda More Than Once in the Same Scope")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](ch08.html#summary-id00033 "Summary")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Blocks: Closures in Ruby'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Internally, Ruby represents each block using a C structure called `rb_block_t`,
    shown in [Figure 8-1](ch08.html#whatapostrophes_inside_the_rbunderscoreb "Figure 8-1. What’s
    inside the rb_block_t C structure?"). By learning what Ruby stores in `rb_block_t`,
    we can find out exactly what a block is.
  prefs: []
  type: TYPE_NORMAL
- en: '![What’s inside the rb_block_t C structure?](httpatomoreillycomsourcenostarchimages1854175.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-1. What’s inside the rb_block_t C structure?
  prefs: []
  type: TYPE_NORMAL
- en: As we did in [Chapter 5](ch05.html "Chapter 5. Objects and Classes") with the
    `RClass` structure, let’s deduce the contents of the `rb_block_t` structure based
    on what we know blocks can do in Ruby. We’ll begin with the most obvious attribute
    of blocks. We know that each block must consist of a piece of Ruby code, or internally
    a set of compiled YARV bytecode instructions. For example, suppose we call a method
    and pass a block as a parameter, as shown in [Example 8-1](ch08.html#superficiallycomma_a_block_is_just_a_sni
    "Example 8-1. Superficially, a block is just a snippet of Ruby code.").
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-1. Superficially, a block is just a snippet of Ruby code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When executing the `10.times` call, Ruby needs to know what code to iterate
    over. Therefore, the `rb_block_t` structure must contain a pointer to that code,
    as shown in [Figure 8-2](ch08.html#rbunderscoreblockunderscoret_structu "Figure 8-2. The
    rb_block_t structure contains a pointer to a snippet of YARV instructions.").
  prefs: []
  type: TYPE_NORMAL
- en: '![The rb_block_t structure contains a pointer to a snippet of YARV instructions.](httpatomoreillycomsourcenostarchimages1854177.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-2. The `rb_block_t` structure contains a pointer to a snippet of YARV
    instructions.
  prefs: []
  type: TYPE_NORMAL
- en: The value `iseq` is a pointer to the YARV instructions for the Ruby code in
    the block.
  prefs: []
  type: TYPE_NORMAL
- en: Another obvious but often overlooked behavior of blocks is that they can access
    variables in the surrounding or parent Ruby scope, as shown in [Example 8-2](ch08.html#code_inside_the_block_accesses_the_v
    "Example 8-2. The code inside the block accesses the variable str from the surrounding
    code.").
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-2. The code inside the block accesses the variable `str` from the
    surrounding code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here the `puts` function call at ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg)
    refers equally to the `str2` variable inside the block and the `str` variable
    defined in the surrounding code at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg).
    Obviously blocks can access values from the code surrounding them. This ability
    is one of the things that makes blocks useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Blocks have in some sense a dual personality. On the one hand, they behave
    like separate methods: You can call them and pass them arguments just as you would
    any method. On the other hand, they’re part of the surrounding function or method.'
  prefs: []
  type: TYPE_NORMAL
- en: Stepping Through How Ruby Calls a Block
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How does this work internally? Does Ruby implement blocks as separate methods
    or as part of the surrounding method? Let’s step through [Example 8-2](ch08.html#code_inside_the_block_accesses_the_v
    "Example 8-2. The code inside the block accesses the variable str from the surrounding
    code.") to see what happens inside Ruby when you call a block.
  prefs: []
  type: TYPE_NORMAL
- en: When Ruby executes the first line of code from [Example 8-2](ch08.html#code_inside_the_block_accesses_the_v
    "Example 8-2. The code inside the block accesses the variable str from the surrounding
    code.") at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg), `str =
    "The quick brown fox"`, YARV stores the local variable `str` on its internal stack.
    YARV tracks the location of `str` using the `EP`, or environment pointer, located
    in the current `rb_control_frame_t` structure, as shown in [Figure 8-3](ch08.html#ruby_saves_the_local_variable_str_on_the
    "Figure 8-3. Ruby saves the local variable str on the stack.").^([[1](#ftn.ch08fn01)])
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby saves the local variable str on the stack.](httpatomoreillycomsourcenostarchimages1854179.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-3. Ruby saves the local variable `str` on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Next, Ruby reaches the `10.times do` call at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    in [Example 8-2](ch08.html#code_inside_the_block_accesses_the_v "Example 8-2. The
    code inside the block accesses the variable str from the surrounding code.").
    Before executing the actual iteration—that is, before calling the `times` method—Ruby
    creates and initializes a new `rb_block_t` structure to represent the block. Ruby
    needs to create the block structure now because the block is really just another
    argument to the `times` method. [Figure 8-4](ch08.html#ruby_creates_a_new_rbunderscoreblockunde
    "Figure 8-4. Ruby creates a new rb_block_t structure before calling the method
    and passing the block to it.") shows this new `rb_block_t` structure.
  prefs: []
  type: TYPE_NORMAL
- en: When creating the new block structure, Ruby copies the current value of the
    `EP` into the new block. In other words, Ruby saves the location of the current
    stack frame in the new block.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby creates a new rb_block_t structure before calling the method and passing
    the block to it.](httpatomoreillycomsourcenostarchimages1854181.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-4. Ruby creates a new `rb_block_t` structure before calling the method
    and passing the block to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, Ruby calls the `times` method on the object `10`, an instance of the
    `Fixnum` class. While doing this, YARV creates a new frame on its internal stack.
    Now we have two stack frames: above, a new stack frame for the `Fixnum.times`
    method, and below, the original stack frame used by the top-level function (see
    [Figure 8-5](ch08.html#ruby_creates_a_new_stack_frame_when_it_e "Figure 8-5. Ruby
    creates a new stack frame when it executes the 10.times call.")).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby creates a new stack frame when it executes the 10.times call.](httpatomoreillycomsourcenostarchimages1854183.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-5. Ruby creates a new stack frame when it executes the `10.times` call.
  prefs: []
  type: TYPE_NORMAL
- en: Ruby implements the `times` method internally using its own C code. Although
    this is a built-in method, Ruby implements it just as you probably would. Ruby
    starts to iterate over the numbers 0, 1, 2, and so on, up to 9, and then it calls
    `yield`, calling the block once for each of these integers. Finally, the code
    that implements `yield` internally calls the block each time it moves through
    the loop, pushing a third frame onto the top of the stack for the code inside
    the block to use. [Figure 8-6](ch08.html#ruby_creates_a_third_stack_frame_when_th
    "Figure 8-6. Ruby creates a third stack frame when the 10.times method yields
    to the block.") shows this third stack frame.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby creates a third stack frame when the 10.times method yields to the block.](httpatomoreillycomsourcenostarchimages1854185.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-6. Ruby creates a third stack frame when the `10.times` method yields
    to the block.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the left side of the figure, we now have three stack frames:'
  prefs: []
  type: TYPE_NORMAL
- en: On the top is the new stack frame for the block, containing the `str2` variable
    defined at ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg) in [Example 8-2](ch08.html#code_inside_the_block_accesses_the_v
    "Example 8-2. The code inside the block accesses the variable str from the surrounding
    code.").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the middle is the stack frame used by the internal C code that implements
    the `Fixnum#times` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And at the bottom is the original function’s stack frame, containing the `str`
    variable defined at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    in [Example 8-2](ch08.html#code_inside_the_block_accesses_the_v "Example 8-2. The
    code inside the block accesses the variable str from the surrounding code.").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While creating the new stack frame, Ruby’s internal `yield` code copies the
    `EP` from the block into the new stack frame. Now the code inside the block can
    access both its local variables, directly via the `rb_control_frame_t` structure,
    and the variables from the parent scope, indirectly via the `EP` pointer using
    dynamic variable access. Specifically, this allows the `puts` statement at ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg)
    in [Example 8-2](ch08.html#code_inside_the_block_accesses_the_v "Example 8-2. The
    code inside the block accesses the variable str from the surrounding code.") to
    access the `str2` variable from the parent scope.
  prefs: []
  type: TYPE_NORMAL
- en: Borrowing an Idea from 1975
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far we’ve seen that Ruby’s `rb_block_t` structure contains two important
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: A pointer to a snippet of YARV code instructions—the `iseq` pointer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pointer to a location on YARV’s internal stack, the location that was at the
    top of the stack when the block was created—the `EP` pointer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 8-7](ch08.html#so_far_weapostropheve_seen_that_ruby_blo "Figure 8-7. So
    far we’ve seen that Ruby blocks contain a pointer to a YARV instruction snippet
    and a location on the YARV stack.") shows these two values in the `rb_block_t`
    structure.'
  prefs: []
  type: TYPE_NORMAL
- en: '![So far we’ve seen that Ruby blocks contain a pointer to a YARV instruction
    snippet and a location on the YARV stack.](httpatomoreillycomsourcenostarchimages1854187.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-7. So far we’ve seen that Ruby blocks contain a pointer to a YARV instruction
    snippet and a location on the YARV stack.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw that Ruby uses the `EP` when a block accesses values from the surrounding
    code. At first, this seems like a very technical, unimportant detail. This is
    obviously a behavior we expect Ruby blocks to exhibit, and the `EP` seems to be
    a minor, uninteresting part of Ruby’s internal implementation of blocks. Or is
    it?
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1854189.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*The IBM 704, above, was the first computer to run Lisp, in the early 1960s.
    (Credit: NASA)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `EP` is actually a profoundly important part of Ruby internals. It’s the
    basis for Ruby’s implementation of *closures*, the computer science concept introduced
    in Lisp long before Ruby was created in the 1990s. Here’s how Sussman and Steele
    defined the term *closure* in 1975:'
  prefs: []
  type: TYPE_NORMAL
- en: In order to solve this problem we introduce the notion of a closure [11, 14]
    which is a data structure containing a lambda expression, and an environment to
    be used when that lambda expression is applied to arguments.^([[2](#ftn.ch08fn02)])
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'They define a closure to be the combination of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A “lambda expression”—that is, a function that takes a set of arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An environment to be used when calling that lambda or function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s take another look at the internal `rb_block_t` structure, repeated for
    convenience in [Figure 8-8](ch08.html#blocks_are_the_combination_of_a_function
    "Figure 8-8. Blocks are the combination of a function and the environment to use
    when calling that function.").
  prefs: []
  type: TYPE_NORMAL
- en: '![Blocks are the combination of a function and the environment to use when
    calling that function.](httpatomoreillycomsourcenostarchimages1854191.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-8. Blocks are the combination of a function and the environment to
    use when calling that function.
  prefs: []
  type: TYPE_NORMAL
- en: 'This structure meets Sussman and Steele’s definition of a closure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`iseq` is a pointer to a lambda expression—a function or code snippet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EP` is a pointer to the environment to be used when calling that lambda or
    function—that is, a pointer to the surrounding stack frame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following this train of thought, we can see that blocks are Ruby’s implementation
    of closures. Ironically, blocks—one of the features that makes Ruby so elegant
    and modern—are based on research and work done at least 20 years before the birth
    of Ruby!
  prefs: []
  type: TYPE_NORMAL
- en: The rb_block_t and rb_control_frame_t Structures
  prefs: []
  type: TYPE_NORMAL
- en: In Ruby 1.9 and later, you’ll find the definition of the `rb_block_t` structure
    in the *vm_core.h* file, as shown in [Example 8-3](ch08.html#definition_of_rbunderscoreblockunder
    "Example 8-3. The definition of rb_block_t from vm_core.h").
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-3. The definition of `rb_block_t` from *vm_core.h*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the `iseq` ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg)
    and `ep` ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg) values described
    above, along with a few other values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`self` ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg): The value
    the `self` pointer had when the block was first referred to is also an important
    part of the closure’s environment. Ruby executes block code inside the same object
    context that the code had outside the block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`klass` ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg): Along with
    `self`, Ruby also keeps track of the class of the current object using this pointer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`proc` ![](httpatomoreillycomsourcenostarchimages1854043.png.jpg): Ruby uses
    this value when it creates a proc object from a block. As we’ll see in the next
    section, procs and blocks are closely related.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Right above the definition of `rb_block_t` in *vm_core.h*, we see the definition
    of the `rb_control_frame_t` structure, as shown in [Example 8-4](ch08.html#definition_of_rbunderscorecontrolund
    "Example 8-4. The definition of rb_control_frame_t from vm_core.h").
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-4. The definition of `rb_control_frame_t` from *vm_core.h*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that this C structure also contains the same values as the `rb_block_t`
    structure: everything from `self` at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    to `proc` at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg). The fact
    that these two structures share the same values is one of the interesting, but
    confusing, optimizations Ruby uses internally to speed things up. Whenever you
    first refer to a block by passing it into a method call, Ruby needs to create
    a new `rb_block_t` structure and copy values such as the `EP` from the current
    `rb_control_frame_t` structure into it. However, because these two structures
    contain the same values in the same order (`rb_block_t` is a subset of `rb_control_frame_t`),
    Ruby can avoid creating a new `rb_block_t` structure and instead set the new block
    pointer to the common portion of the `rb_control_frame_t` structure. In other
    words, instead of allocating new memory to hold the new `rb_block_t` structure,
    Ruby simply passes a pointer to the middle of the `rb_control_frame_t` structure.
    By doing so, Ruby avoids unnecessary calls to `malloc` and speeds up the process
    of creating blocks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Experiment 8-1: Which Is Faster: A while Loop or Passing a Block to each?'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ruby code containing blocks is often more elegant and succinct than the equivalent
    code in older languages, such as C. For example, in C we would write the simple
    `while` loop shown in [Example 8-5](ch08.html#adding_up_1_through_10_in_c_using_a_whil
    "Example 8-5. Adding up 1 through 10 in C using a while loop") to add up the numbers
    1 through 10.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-5. Adding up 1 through 10 in C using a `while` loop
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 8-6](ch08.html#adding_up_1_through_10_in_ruby_using_a_w "Example 8-6. Adding
    up 1 through 10 in Ruby using a while loop") shows the same `while` loop in Ruby.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-6. Adding up 1 through 10 in Ruby using a `while` loop
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: However, most Rubyists would write this code using a range object with a block,
    as shown in [Example 8-7](ch08.html#adding_up_1_through_10_in_ruby_using_a_r "Example 8-7. Adding
    up 1 through 10 in Ruby using a range object and a block").
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-7. Adding up 1 through 10 in Ruby using a range object and a block
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Aesthetics aside, is there any performance penalty for using a block here? Does
    Ruby slow down significantly in order to create the new `rb_block_t` structure,
    copy the `EP` value, and create new stack frames?
  prefs: []
  type: TYPE_NORMAL
- en: Well, I won’t benchmark the C code because clearly it will be faster than either
    option using Ruby. Instead, let’s measure how long it takes Ruby, using a simple
    `while` loop, to add up the integers 1 through 10 to obtain 55, as shown in [Example 8-8](ch08.html#benchmarking_the_while_loop_left_parenth
    "Example 8-8. Benchmarking the while loop (while.rb)").
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-8. Benchmarking the `while` loop *(while.rb)*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, I’m using the benchmark library to measure the time required to run the
    `while` loop one million times. Admittedly, I’m using a block to control the million
    iterations (`ITERATIONS.times do`), but I’ll use the same block in the next test
    as well. Using Ruby 2.0 on my laptop, I can run through this code in just under
    a half second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now let’s measure the time required to run the code shown in [Example 8-9](ch08.html#benchmarking_a_call_to_a_block_left_pare
    "Example 8-9. Benchmarking a call to a block (each.rb)"), which uses `each` with
    a block.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-9. Benchmarking a call to a block *(each.rb)*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This time it takes somewhat longer to run through the loop a million times,
    about 0.75 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Ruby requires about 71 percent more time to call the block 10 times, compared
    to iterating through the simple `while` loop 10 times (see [Figure 8-9](ch08.html#ruby_2dot0_uses_71_percent_more_time_cal
    "Figure 8-9. Ruby 2.0 uses 71 percent more time calling a block vs. a simple while
    loop. The graph shows the time for one million iterations (in seconds).")).
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby 2.0 uses 71 percent more time calling a block vs. a simple while loop.
    The graph shows the time for one million iterations (in seconds).](httpatomoreillycomsourcenostarchimages1854193.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-9. Ruby 2.0 uses 71 percent more time calling a block vs. a simple
    `while` loop. The graph shows the time for one million iterations (in seconds).
  prefs: []
  type: TYPE_NORMAL
- en: Using `each` is slower because internally the `Range#each` method has to call
    or yield to the block each time around the loop. This involves a fairly large
    amount of work. In order to yield to a block, Ruby first has to create a new `rb_block_t`
    structure for that block, setting the `EP` in the new block to the referencing
    environment and passing the block into the call to `each`. Then each time around
    the loop Ruby has to create a new stack frame on YARV’s internal stack, call the
    block’s code, and finally copy the `EP` from the block to the new stack frame.
    Running a simple `while` loop is faster because Ruby needs only to reset the `PC`,
    or program counter, each time around the loop. It never calls a method or creates
    a new stack frame or a new `rb_block_t` structure.
  prefs: []
  type: TYPE_NORMAL
- en: Seventy-one percent more time seems like a large performance penalty, and, depending
    on your work and the context of this `while` loop, it may or may not be important.
    If this loop were part of a time-sensitive, critical operation that your end users
    were waiting for, and if there weren’t other expensive operations inside the loop,
    it might be worth writing the iteration using an old-fashioned C-style `while`
    loop. However, the performance of most Ruby applications, and certainly Ruby on
    Rails websites, is usually limited by database queries, network connections, and
    other factors, not by Ruby execution speed. It’s rare that Ruby’s execution speed
    has an immediate, direct impact on your application’s overall performance. (Of
    course, if you’re using a large framework, such as Ruby on Rails, then your Ruby
    code is a very small piece of a very large system. I imagine that Rails uses blocks
    and iterators many, many times while processing a simple HTTP request, apart from
    the Ruby code you write yourself.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Lambdas and Procs: Treating a Function as a First-Class Citizen'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now to look at a more convoluted way of printing the “quick brown fox” string
    to the console. [Example 8-10](ch08.html#using_lambda_in_ruby "Example 8-10. Using
    lambda in Ruby") shows an example of using `lambda`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-10. Using `lambda` in Ruby
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Let’s step through this code carefully. First, at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    we define a method called `message_function`. Inside `message_function`, we create
    a local variable at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    called `str`. Next, at ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)
    we call `lambda`, and pass it a block. Inside this block, at ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg),
    we print the “quick brown fox” string again. However, `message_function` won’t
    immediately display the string because it doesn’t actually call the block at ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg).
    Instead, `lambda` returns the block we give it as a data value, which in turn
    is returned by `message_function`.
  prefs: []
  type: TYPE_NORMAL
- en: This is an example of “treating a function as a first-class citizen,” to paraphrase
    a commonly used computer science expression. Once the block is returned from `message_function`,
    we save it in the local variable `function_value` at ![](httpatomoreillycomsourcenostarchimages1854043.png.jpg)
    and then call it explicitly, using the `call` method at ![](httpatomoreillycomsourcenostarchimages1854045.png.jpg).
    With the `lambda` keyword—or the equivalent `proc` keyword—Ruby allows you to
    convert a block into a data value in this way.
  prefs: []
  type: TYPE_NORMAL
- en: '![Does Ruby use an rb_lambda_t C structure? And if so, what would it contain?](httpatomoreillycomsourcenostarchimages1854195.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-10. Does Ruby use an *rb_lambda_t* C structure? And if so, what would
    it contain?
  prefs: []
  type: TYPE_NORMAL
- en: I have lots of questions about [Example 8-10](ch08.html#using_lambda_in_ruby
    "Example 8-10. Using lambda in Ruby"). What happens when we call `lambda`? How
    does Ruby convert the block into a data value, and what does it mean to treat
    this block as a first-class citizen? Does `message_function` return an `rb_block_t`
    structure directly, or does it return an `rb_lambda_t` structure? And what information
    would `rb_lambda_t` contain (see [Figure 8-10](ch08.html#does_ruby_use_an_rbunderscorelambdaunder
    "Figure 8-10. Does Ruby use an rb_lambda_t C structure? And if so, what would
    it contain?"))?
  prefs: []
  type: TYPE_NORMAL
- en: Stack vs. Heap Memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can answer these questions, we need to take a closer look at how
    Ruby saves your data. Internally, Ruby saves your data in two places: on the *stack*
    or in the *heap*.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve seen the *stack* before. This is where Ruby saves local variables, return
    values, and arguments for each of the methods in your program. Values on the stack
    are valid only for as long as that method is running. When a method returns, YARV
    deletes its stack frame and all the values inside it.
  prefs: []
  type: TYPE_NORMAL
- en: Ruby uses the *heap* to save information that you might need for a while, even
    after a particular method returns. Each value in the heap remains valid for as
    long as there is a reference to it. Once a value is no longer referred to by any
    variable or object in your program, Ruby’s garbage collection system deletes it,
    freeing its memory for other uses.
  prefs: []
  type: TYPE_NORMAL
- en: This scheme is not unique to Ruby. In fact, it’s used by many other programming
    languages, including Lisp and C. And remember, Ruby itself is a C program. YARV’s
    stack design is based on the way C programs use the stack, and Ruby’s heap uses
    the underlying C heap implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The stack and heap differ in one other important aspect. Ruby saves only references
    to data on the stack—that is, the `VALUE` pointers. For simple integer values,
    symbols, and constants such as `nil`, `true`, or `false`, the reference is the
    actual value. However, for all other data types, the `VALUE` is a pointer to a
    C structure containing the actual data, such as `RObject`. If only the `VALUE`
    references go on the stack, where does Ruby save the structures? In the heap.
    Let’s look at an example to understand this better.
  prefs: []
  type: TYPE_NORMAL
- en: A Closer Look at How Ruby Saves a String Value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s look in detail at how Ruby handles the string value `str` from [Example 8-10](ch08.html#using_lambda_in_ruby
    "Example 8-10. Using lambda in Ruby"). First, imagine YARV has a stack frame for
    the outer scope but has yet to call `message_function`. [Figure 8-11](ch08.html#to_execute_the_code_in_listing_8-11comma
    "Figure 8-11. To execute the code in Example 8-11, Ruby starts with an initial
    stack frame.") shows this initial stack frame.
  prefs: []
  type: TYPE_NORMAL
- en: '![To execute the code in , Ruby starts with an initial stack frame.](httpatomoreillycomsourcenostarchimages1854197.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-11. To execute the code in [Example 8-11](ch08.html#this_code_doesnapostrophet_call_lambdado
    "Example 8-11. This code doesn’t call lambda."), Ruby starts with an initial stack
    frame.
  prefs: []
  type: TYPE_NORMAL
- en: In this figure you can see YARV’s internal stack on the left and the `rb_control_frame_t`
    structure on the right. Now suppose Ruby executes the `message_function` function
    call shown at ![](httpatomoreillycomsourcenostarchimages1854043.png.jpg) in [Example 8-10](ch08.html#using_lambda_in_ruby
    "Example 8-10. Using lambda in Ruby"). [Figure 8-12](ch08.html#ruby_creates_a_second_stack_frame_when_c
    "Figure 8-12. Ruby creates a second stack frame when calling message_function.")
    shows what happens next.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby creates a second stack frame when calling message_function.](httpatomoreillycomsourcenostarchimages1854199.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-12. Ruby creates a second stack frame when calling `message_function`.
  prefs: []
  type: TYPE_NORMAL
- en: Ruby saves the `str` local variable in the new stack frame used by `message_function`.
    Let’s take a closer look at that `str` variable and how Ruby stores the “quick
    brown fox” string into it. Ruby stores each of your objects in a C structure called
    `RObject`, each of your arrays in a structure called `RArray`, each of your strings
    in a structure called `RString`, and so on. [Figure 8-13](ch08.html#ruby_uses_the_rstring_c_structure_to_sav
    "Figure 8-13. Ruby uses the RString C structure to save string values.") shows
    the “quick brown fox” string saved with `RString`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby uses the RString C structure to save string values.](httpatomoreillycomsourcenostarchimages1854201.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-13. Ruby uses the `RString` C structure to save string values.
  prefs: []
  type: TYPE_NORMAL
- en: The actual string structure is shown on the right side of the figure, and a
    reference, or pointer, to the string is shown on the left. When Ruby saves a string
    value (or any object) onto the YARV stack, it actually places only the reference
    to the string on the stack. The actual string structure is saved in the heap instead,
    as shown in [Figure 8-14](ch08.html#str_value_on_the_stack_is_a_referenc "Figure 8-14. The
    str value on the stack is a reference to the RString structure saved in the heap.")
    on the next page.
  prefs: []
  type: TYPE_NORMAL
- en: Once there are no longer any pointers referencing a particular object or value
    in the heap, Ruby frees that object or value during the next run of the garbage
    collection system. To demonstrate, suppose that my example code didn’t call `lambda`
    at all but rather immediately returned `nil` after saving the `str` variable,
    as shown in [Example 8-11](ch08.html#this_code_doesnapostrophet_call_lambdado
    "Example 8-11. This code doesn’t call lambda.").
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-11. This code doesn’t call `lambda`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![The str value on the stack is a reference to the RString structure saved
    in the heap.](httpatomoreillycomsourcenostarchimages1854203.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-14. The `str` value on the stack is a reference to the `RString` structure
    saved in the heap.
  prefs: []
  type: TYPE_NORMAL
- en: Once this call to `message_function` finishes, YARV simply pops the `str` value
    off the stack (as well as any other temporary values saved there) and returns
    to the original stack frame, as shown in [Figure 8-15](ch08.html#now_there_is_no_longer_a_reference_to_th
    "Figure 8-15. Now there is no longer a reference to the RString structure.").
  prefs: []
  type: TYPE_NORMAL
- en: '![Now there is no longer a reference to the RString structure.](httpatomoreillycomsourcenostarchimages1854205.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-15. Now there is no longer a reference to the `RString` structure.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the figure, there is no longer a reference to the `RString`
    structure containing the “quick brown fox” string. Ruby’s garbage collection system
    is designed to identify values in the heap that don’t have any references to them,
    like the “quick brown fox” string here. After it identifies them, the GC system
    will free those orphaned values, returning that memory to the heap.
  prefs: []
  type: TYPE_NORMAL
- en: How Ruby Creates a Lambda
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we understand a bit more about the heap and how Ruby uses it, we’re
    ready to learn more about lambdas. Earlier when I used the phrase “treating a
    function as a first-class citizen,” I meant that Ruby allows you to treat functions
    or code as a data value, saving them into variables, passing them as arguments,
    and so on. Ruby implements this idea using blocks.
  prefs: []
  type: TYPE_NORMAL
- en: The `lambda` (or `proc`) keyword converts a block into a data value. But remember,
    blocks are Ruby’s implementation of closures. This means the new data value must
    somehow contain both the block’s code and referencing environment.
  prefs: []
  type: TYPE_NORMAL
- en: To see what I mean, let’s return to [Example 8-10](ch08.html#using_lambda_in_ruby
    "Example 8-10. Using lambda in Ruby"), repeated here in [Example 8-12](ch08.html#using_lambda_in_ruby_left_parenthesisrep
    "Example 8-12. Using lambda in Ruby (repeated from Example 8-10)") with an eye
    toward its use of `lambda`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-12. Using `lambda` in Ruby (repeated from [Example 8-10](ch08.html#using_lambda_in_ruby
    "Example 8-10. Using lambda in Ruby"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Notice at ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg) that when
    we call the lambda (the block), the `puts` statement inside the block at ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)
    can access the `str` string variable defined at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    inside `message_function`. How can this be? We’ve just seen how the `str` reference
    to the `RString` structure is popped off the stack when `message_function` returns!
    Obviously, after calling `lambda`, the value of `str` lives on so that the block
    can access it later.
  prefs: []
  type: TYPE_NORMAL
- en: When you call `lambda`, Ruby copies the entire contents of the current YARV
    stack frame into the heap, where the `RString` structure is located. For example,
    [Figure 8-16](ch08.html#ruby_creates_a_second_stack_fram-id00030 "Figure 8-16. Ruby
    creates a second stack frame when calling message_function.") shows how the YARV
    stack looks just after the `message_function` starts at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    in [Example 8-12](ch08.html#using_lambda_in_ruby_left_parenthesisrep "Example 8-12. Using
    lambda in Ruby (repeated from Example 8-10)"). (To keep things simple, I’m not
    showing the `RString` structure, but remember that the `RString` structure will
    also be saved in the heap.)
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby creates a second stack frame when calling message_function.](httpatomoreillycomsourcenostarchimages1854207.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-16. Ruby creates a second stack frame when calling `message_function`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, [Example 8-12](ch08.html#using_lambda_in_ruby_left_parenthesisrep "Example 8-12. Using
    lambda in Ruby (repeated from Example 8-10)") calls `lambda` at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg).
    [Figure 8-17](ch08.html#when_you_call_lambdacomma_ruby_copies_th "Figure 8-17. When
    you call lambda, Ruby copies the current stack frame to the heap.") shows what
    happens in Ruby when you call `lambda`.
  prefs: []
  type: TYPE_NORMAL
- en: The horizontal stack icon below the dotted line shows that Ruby creates a new
    copy of the stack frame for `message_function` in the heap. Now there is a second
    reference to the `str RString` structure, which means that Ruby won’t free it
    when `message_function` returns.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, along with the copy of the stack frame, Ruby creates two other new
    objects in the heap:'
  prefs: []
  type: TYPE_NORMAL
- en: An internal environment object, represented by the `rb_env_t` C structure at
    the lower left of the figure. It’s essentially a wrapper for the heap copy of
    the stack. As we’ll see in [Chapter 9](ch09.html "Chapter 9. Metaprogramming"),
    you can access this environment object indirectly in your programs using the `Binding`
    class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Ruby proc object, represented by the `rb_proc_t` structure. This is the actual
    return value from the `lambda` keyword; it’s what the `message_function` function
    returns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the new proc object, the `rb_proc_t` structure, contains an `rb_block_t`
    structure, including the `iseq` and `EP` pointers. Think of a proc as a kind of
    Ruby object that wraps up a block. As with a normal block, these keep track of
    the block’s code and the referencing environment for its closure. Ruby sets the
    `EP` in this block to point to the new heap copy of the stack frame.
  prefs: []
  type: TYPE_NORMAL
- en: Also, notice that the proc object contains an internal value called `is_lambda`.
    This is set to `true` for this example because we used the `lambda` keyword to
    create the proc. If I had instead created the proc using the `proc` keyword, or
    simply by calling `Proc.new`, then `is_lambda` would have been set to `false`.
    Ruby uses this flag to produce the slight behavior differences between procs and
    lambdas, though it’s best to think of procs and lambdas as essentially the same.
  prefs: []
  type: TYPE_NORMAL
- en: '![When you call lambda, Ruby copies the current stack frame to the heap.](httpatomoreillycomsourcenostarchimages1854209.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-17. When you call `lambda`, Ruby copies the current stack frame to
    the heap.
  prefs: []
  type: TYPE_NORMAL
- en: How Ruby Calls a Lambda
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s go back to our lambda example in [Example 8-13](ch08.html#using_lambda_in_ruby_left_parent-id00031
    "Example 8-13. Using lambda in Ruby (repeated again from Example 8-10)").
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-13. Using `lambda` in Ruby (repeated again from [Example 8-10](ch08.html#using_lambda_in_ruby
    "Example 8-10. Using lambda in Ruby"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: What happens when `message_function` returns at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)?
    Because the lambda or proc object is its return value, a reference to the lambda
    is saved in the stack frame for the outer scope in the `function_value` local
    variable. This prevents Ruby from freeing the proc, the internal environment object,
    and the `str` variable, and there are now pointers referring to all of these values
    in the heap (see [Figure 8-18](ch08.html#once_messageunderscorefunction_returnsco
    "Figure 8-18. Once message_function returns, the surrounding code holds a reference
    to the proc object.")).
  prefs: []
  type: TYPE_NORMAL
- en: '![Once message_function returns, the surrounding code holds a reference to
    the proc object.](httpatomoreillycomsourcenostarchimages1854211.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-18. Once `message_function` returns, the surrounding code holds a reference
    to the proc object.
  prefs: []
  type: TYPE_NORMAL
- en: When Ruby executes the `call` method on the proc object at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg),
    it executes its block as well. [Figure 8-19](ch08.html#calling_a_proc_object_creates_a_new_stac
    "Figure 8-19. Calling a proc object creates a new stack frame as usual and sets
    the EP to point to the heap’s referencing environment.") shows what happens in
    Ruby when you use the `call` method on a lambda or proc.
  prefs: []
  type: TYPE_NORMAL
- en: As with any block, when Ruby calls the block inside a proc object it creates
    a new stack frame and sets the `EP` to the block’s referencing environment. However,
    that environment is a copy of a stack frame previously copied into the heap; the
    new stack frame contains an `EP` that points to the heap. This `EP` allows the
    block’s call to `puts` to access the `str` value defined in `message_function`.
    [Figure 8-19](ch08.html#calling_a_proc_object_creates_a_new_stac "Figure 8-19. Calling
    a proc object creates a new stack frame as usual and sets the EP to point to the
    heap’s referencing environment.") shows the argument to the proc, `animal`, saved
    in the new stack frame, like any other method or block argument.
  prefs: []
  type: TYPE_NORMAL
- en: '![Calling a proc object creates a new stack frame as usual and sets the EP
    to point to the heap’s referencing environment.](httpatomoreillycomsourcenostarchimages1854213.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-19. Calling a proc object creates a new stack frame as usual and sets
    the `EP` to point to the heap’s referencing environment.
  prefs: []
  type: TYPE_NORMAL
- en: The Proc Object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve seen that Ruby really has no structure called `rb_lambda_t`. In other
    words, the structure shown in [Figure 8-20](ch08.html#ruby_doesnapostrophet_actually_use_a_str
    "Figure 8-20. Ruby doesn’t actually use a structure called rb_lambda_t.") doesn’t
    actually exist.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby doesn’t actually use a structure called rb_lambda_t.](httpatomoreillycomsourcenostarchimages1854215.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-20. Ruby doesn’t actually use a structure called `rb_lambda_t`.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, in this example, Ruby’s `lambda` keyword created a proc object—really,
    a wrapper for the block we passed to the `lambda` or `proc` keyword. Ruby represents
    procs using an `rb_proc_t` C structure, as you can see in [Figure 8-21](ch08.html#ruby_procs_are_closuressemicolon_they_co
    "Figure 8-21. Ruby procs are closures; they contain pointers to a function and
    a referencing environment.").
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby procs are closures; they contain pointers to a function and a referencing
    environment.](httpatomoreillycomsourcenostarchimages1854217.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-21. Ruby procs are closures; they contain pointers to a function and
    a referencing environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a closure: It contains a function along with the environment that function
    was referred to or created in. The environment is a persistent copy of the stack
    frame saved in the heap.'
  prefs: []
  type: TYPE_NORMAL
- en: A proc is a Ruby object. It contains the same information as other objects,
    including the `RBasic` structure. To save its object-related information, Ruby
    uses a structure called `RTypedData`, along with `rb_proc_t`, to represent instances
    of the proc object. [Figure 8-22](ch08.html#ruby_saves_the_object-related_informatio
    "Figure 8-22. Ruby saves the object-related information about proc objects in
    the RTypedData structure.") shows how these structures work together.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might think of `RTypedData` as a kind of trick that Ruby’s C code uses
    to create a Ruby object wrapper around a C data structure. In this case, Ruby
    uses `RTypedData` to create an instance of the `Proc` Ruby class that represents
    a single copy of the `rb_proc_t` structure. The `RTypedData` structure contains
    the same `RBasic` information as all Ruby objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '****`flags`****. Certain internal technical information Ruby needs to track'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`klass`****. A pointer to the Ruby class that the object is an instance
    of; the `Proc` class in this example'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Ruby saves the object-related information about proc objects in the RTypedData
    structure.](httpatomoreillycomsourcenostarchimages1854219.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-22. Ruby saves the object-related information about proc objects in
    the `RTypedData` structure.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-23](ch08.html#comparing_a_ruby_string_with_a_proc "Figure 8-23. Comparing
    a Ruby string with a proc") takes another look at how Ruby represents a proc object.
    The proc object is on the right next to an `RString` structure.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that Ruby handles the string value and the proc similarly. As with strings,
    procs can be saved into variables or passed as arguments to a function call. Ruby
    uses the `VALUE` pointer to the proc whenever you refer to one or save one into
    a variable.
  prefs: []
  type: TYPE_NORMAL
- en: '![Comparing a Ruby string with a proc](httpatomoreillycomsourcenostarchimages1854221.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-23. Comparing a Ruby string with a proc
  prefs: []
  type: TYPE_NORMAL
- en: 'Experiment 8-2: Changing Local Variables After Calling lambda'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Example 8-10](ch08.html#using_lambda_in_ruby "Example 8-10. Using lambda in
    Ruby") through [Example 8-13](ch08.html#using_lambda_in_ruby_left_parent-id00031
    "Example 8-13. Using lambda in Ruby (repeated again from Example 8-10)") show
    how calling `lambda` copies the current stack frame in the heap. Now for a slightly
    different example. [Example 8-14](ch08.html#which_version_of_str_will_lambda_copy_to
    "Example 8-14. Which version of str will lambda copy to the heap (modify_after_lambda.rb)?")
    is basically the same, except that the line at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    changes `str` after calling `lambda`.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-14. Which version of `str` will `lambda` copy to the heap *(modify_after_lambda.rb)*?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we call `lambda` at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    before changing `str` to `The sly brown fox` at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg),
    Ruby should have copied the stack frame to the heap, including the original value
    of `str`. That means that when we call the lambda at ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg),
    we should see the original “quick brown fox” string. However, running the code,
    we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: What happened? Ruby somehow copied the new value of `str`, `The sly brown fox`,
    to the heap so we could access it when we called the lambda at ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: To find out how Ruby did this, let’s look more closely at what happens when
    you call `lambda`. [Figure 8-24](ch08.html#when_you_call_lambdacomma_ruby_c-id00032
    "Figure 8-24. When you call lambda, Ruby copies the stack frame to the heap.")
    shows how Ruby copies the stack frame to the heap, including the value `str` from
    [Example 8-14](ch08.html#which_version_of_str_will_lambda_copy_to "Example 8-14. Which
    version of str will lambda copy to the heap (modify_after_lambda.rb)?").
  prefs: []
  type: TYPE_NORMAL
- en: '![When you call lambda, Ruby copies the stack frame to the heap.](httpatomoreillycomsourcenostarchimages1854223.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-24. When you call `lambda`, Ruby copies the stack frame to the heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this copy is made, the code at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    in [Example 8-14](ch08.html#which_version_of_str_will_lambda_copy_to "Example 8-14. Which
    version of str will lambda copy to the heap (modify_after_lambda.rb)?") changes
    `str` to the “sly fox” string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Because Ruby copied the stack frame when we called `lambda`, we should be modifying
    the original copy of `str`, not the new lambda copy (see [Figure 8-25](ch08.html#does_ruby_continue_to_use_the_original_s
    "Figure 8-25. Does Ruby continue to use the original stack frame after making
    a heap copy?")).
  prefs: []
  type: TYPE_NORMAL
- en: '![Does Ruby continue to use the original stack frame after making a heap copy?](httpatomoreillycomsourcenostarchimages1854225.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-25. Does Ruby continue to use the original stack frame after making
    a heap copy?
  prefs: []
  type: TYPE_NORMAL
- en: The new heap copy of the string should have remained unmodified, and calling
    the lambda later should have given the original “quick fox” string, not the modified
    “sly fox” one. How does Ruby allow us to modify the new persistent copy of the
    stack once it’s been created by `lambda`?
  prefs: []
  type: TYPE_NORMAL
- en: As it turns out, once Ruby creates the new heap copy of the stack (the new `rb_env_t`
    structure or internal environment object), it resets the `EP` in the `rb_control_frame_t`
    structure to point to the copy. [Figure 8-26](ch08.html#ruby_resets_the_ep_after_creating_a_pers
    "Figure 8-26. Ruby resets the EP after creating a persistent heap copy of a stack
    frame.") shows how Ruby resets the `EP` after creating a persistent heap copy
    of a stack frame.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby resets the EP after creating a persistent heap copy of a stack frame.](httpatomoreillycomsourcenostarchimages1854227.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-26. Ruby resets the `EP` after creating a persistent heap copy of a
    stack frame.
  prefs: []
  type: TYPE_NORMAL
- en: The difference here is that the `EP` now points down to the heap. Now when we
    call `str = "The sly brown fox"` at in [Example 8-14](ch08.html#which_version_of_str_will_lambda_copy_to
    "Example 8-14. Which version of str will lambda copy to the heap (modify_after_lambda.rb)?"),
    Ruby will use the new `EP` and access the value in the heap, not the original
    value on the stack. Notice `The sly brown fox` appears in the heap at the bottom
    of [Figure 8-26](ch08.html#ruby_resets_the_ep_after_creating_a_pers "Figure 8-26. Ruby
    resets the EP after creating a persistent heap copy of a stack frame.").
  prefs: []
  type: TYPE_NORMAL
- en: Calling lambda More Than Once in the Same Scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another interesting behavior of the `lambda` keyword is that Ruby avoids making
    copies of the stack frame more than once, as you can see in [Example 8-15](ch08.html#calling_lambda_twice_in_the_same_scope
    "Example 8-15. Calling lambda twice in the same scope").
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-15. Calling `lambda` twice in the same scope
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This code expects both lambda functions to operate on the local variable `i`
    in the main scope.
  prefs: []
  type: TYPE_NORMAL
- en: But if Ruby made a separate copy of the stack frame for each call to `lambda`,
    each function would operate on a separate copy of `i`. Look at the following example
    in [Example 8-16](ch08.html#calling_the_lambdas_created_in_listing_8 "Example 8-16. Calling
    the lambdas created in Example 8-15").
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-16. Calling the lambdas created in [Example 8-15](ch08.html#calling_lambda_twice_in_the_same_scope
    "Example 8-15. Calling lambda twice in the same scope")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If Ruby used a separate copy of `i` for each lambda function, the previous listing
    would generate the output shown in [Example 8-17](ch08.html#output_we_would_expect_if_each_call
    "Example 8-17. The output we would expect if each call to lambda created its own
    copy of the stack frame").
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-17. The output we would expect if each call to `lambda` created its
    own copy of the stack frame
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: But we actually see the output shown in [Example 8-18](ch08.html#because_the_lambda_functions_share_the_s
    "Example 8-18. Because the lambda functions share the same heap copy of the stack,
    running Example 8-16 generates this output.").
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-18. Because the lambda functions share the same heap copy of the stack,
    running [Example 8-16](ch08.html#calling_the_lambdas_created_in_listing_8 "Example 8-16. Calling
    the lambdas created in Example 8-15") generates this output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Usually this is what you expect: Each block you pass to the lambdas accesses
    the same variable in the parent scope. Ruby achieves this by checking whether
    the `EP` already points to the heap. If so, as with the second call to `lambda`
    in [Example 8-15](ch08.html#calling_lambda_twice_in_the_same_scope "Example 8-15. Calling
    lambda twice in the same scope"), Ruby won’t create a second copy; it will simply
    reuse the same `rb_env_t` structure in the second `rb_proc_t` structure. Ultimately,
    both lambdas use the same heap copy of the stack.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html "Chapter 3. How Ruby Executes Your Code") we saw how
    YARV creates a new stack frame whenever you call a block, just as it does when
    you call a method. At first glance, Ruby blocks appear to be a special kind of
    method that you can call and pass arguments to. However, as we’ve seen in this
    chapter, there’s more to blocks than meets the eye.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking closely at the `rb_block_t` structure, we saw how blocks implement
    the computer science concept of *closure* in Ruby. Blocks are the combination
    of a function and an environment to use when calling that function. We learned
    that blocks have a curious dual personality in Ruby: They are similar to methods,
    but they also become part of the method that you call them from. The simplicity
    with which Ruby’s syntax allows for this dual role is one of the language’s most
    beautiful and elegant features.'
  prefs: []
  type: TYPE_NORMAL
- en: Later we saw how Ruby allows you to treat functions or code as first-class citizens
    using the `lambda` keyword, which converts a block into a data value that you
    can pass, save, and reuse. After reviewing the differences between stack and heap
    memory, we explored the way that Ruby implements lambdas and procs, and we saw
    that Ruby copies the stack frame to the heap when you call `lambda` or `proc`
    and reuses it when you call the lambda’s block. Finally, we saw how the proc object
    represents code as a data object in Ruby.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[1](#ch08fn01)]) If the outer code was located inside a function or method,
    then the `EP` would point to the stack frame as shown. But if the outer code was
    located in the top-level scope of your Ruby program, then Ruby would use dynamic
    access to save the variable in the `TOPLEVEL_BINDING` environment instead. Regardless,
    the `EP` will always indicate the location of the `str` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '^([[2](#ch08fn02)]) Gerald J. Sussman and Guy L. Steele, Jr., “Scheme: An Interpreter
    for Extended Lambda Calculus” (MIT Artificial Intelligence Laboratory, AI Memo
    No. 349, December 1975).'
  prefs: []
  type: TYPE_NORMAL
