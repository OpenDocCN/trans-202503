["```\nboost::asio::io_context io_context{ 8 };\n```", "```\nboost::asio::steady_timer timer{\n  io_context, std::chrono::steady_clock::now() + std::chrono::seconds{ 3 }\n};\n```", "```\n#include <iostream>\n#include <boost/asio.hpp>\n#include <chrono>\n\nboost::asio::steady_timer make_timer(boost::asio::io_context& io_context) { ➊\n  return boost::asio::steady_timer{\n          io_context,\n          std::chrono::steady_clock::now() + std::chrono::seconds{ 3 }\n  };\n}\n\nint main() {\n  boost::asio::io_context io_context; ➋\n\n  auto timer1 = make_timer(io_context); ➌\n  std::cout << \"entering steady_timer::wait\\n\";\n  timer1.wait(); ➍\n  std::cout << \"exited steady_timer::wait\\n\";\n\n  auto timer2 = make_timer(io_context); ➎\n  std::cout << \"entering steady_timer::async_wait\\n\";\n  timer2.async_wait([] (const boost::system::error_code& error) { ➏\n    if (!error) std::cout << \"<<callback function>>\\n\";\n  });\n  std::cout << \"exited steady_timer::async_wait\\n\";\n  std::cout << \"entering io_context::run\\n\";\n  io_context.run(); ➐\n  std::cout << \"exited io_context::run\\n\";\n}\n-----------------------------------------------------------------------\nentering steady_timer::wait\nexited steady_timer::wait\nentering steady_timer::async_wait\nexited steady_timer::async_wait\nentering io_context::run\n<<callback function>>\nexited io_context::run\n```", "```\nboost::asio::ip::tcp::resolver my_resolver{ my_io_context };\n```", "```\n#include <iostream>\n#include <boost/asio.hpp>\n\nint main() {\n  boost::asio::io_context io_context; ➊\n  boost::asio::ip::tcp::resolver resolver{ io_context }; ➋\n  boost::system::error_code ec;\n  for(auto&& result : resolver.resolve(\"www.nostarch.com\", \"http\", ec)) { ➌\n    std::cout << result.service_name() << \" \" ➍\n              << result.host_name() << \" \" ➎\n              << result.endpoint() ➏\n              << std::endl;\n  }\n  if(ec) std::cout << \"Error code: \" << ec << std::endl; ➐\n}\n-----------------------------------------------------------------------\nhttp [www.nostarch.com](http://www.nostarch.com) 104.20.209.3:80\nhttp [www.nostarch.com](http://www.nostarch.com) 104.20.208.3:80\n```", "```\n#include <iostream>\n#include <boost/asio.hpp>\n\nint main() {\n  boost::asio::io_context io_context;\n  boost::asio::ip::tcp::resolver resolver{ io_context };\n  resolver.async_resolve(\"www.nostarch.com\", \"http\", ➊\n    [](boost::system::error_code ec, const auto& results) { ➋\n      if (ec) { ➌\n        std::cerr << \"Error:\" << ec << std::endl;\n        return; ➍\n      }\n      for (auto&& result : results) { ➎\n        std::cout << result.service_name() << \" \"\n                  << result.host_name() << \" \"\n                  << result.endpoint() << \" \"\n                  << std::endl; ➏\n      }\n    }\n  );\n  io_context.run(); ➐\n}\n-----------------------------------------------------------------------\nhttp [www.nostarch.com](http://www.nostarch.com) 104.20.209.3:80\nhttp [www.nostarch.com](http://www.nostarch.com) 104.20.208.3:80\n```", "```\n#include <iostream>\n#include <boost/asio.hpp>\n\nint main() {\n  boost::asio::io_context io_context;\n  boost::asio::ip::tcp::resolver resolver{ io_context }; ➊\n  boost::asio::ip::tcp::socket socket{ io_context }; ➊\n  try  {\n    auto endpoints = resolver.resolve(\"www.nostarch.com\", \"http\"); ➌\n    const auto connected_endpoint = boost::asio::connect(socket, endpoints); ➍\n    std::cout << connected_endpoint; ➎\n  } catch(boost::system::system_error& se) {\n    std::cerr << \"Error: \" << se.what() << std::endl; ➏\n  }\n}\n-----------------------------------------------------------------------\n104.20.209.3:80 ➎\n```", "```\n#include <iostream>\n#include <boost/asio.hpp>\n\nint main() {\n  boost::asio::io_context io_context;\n boost::asio::ip::tcp::resolver resolver{ io_context };\n  boost::asio::ip::tcp::socket socket{ io_context };\n  boost::asio::async_connect(socket, ➊\n    resolver.resolve(\"www.nostarch.com\", \"http\"), ➋\n    [] (boost::system::error_code ec, const auto& endpoint){ ➌\n      std::cout << endpoint; ➍\n  });\n  io_context.run(); ➎\n}\n-----------------------------------------------------------------------\n104.20.209.3:80 ➍\n```", "```\n#include <boost/asio.hpp>\n\nTEST_CASE(\"const_buffer default constructor\") {\n  boost::asio::const_buffer cb; ➊\n  REQUIRE(cb.size() == 0); ➋\n}\n\nTEST_CASE(\"mutable_buffer default constructor\") {\n boost::asio::mutable_buffer mb; ➌\n  REQUIRE(mb.size() == 0); ➍\n}\n```", "```\n#include <boost/asio.hpp>\n#include <string>\n\nTEST_CASE(\"const_buffer constructor\") {\n  boost::asio::const_buffer cb{ \"Blessed are the cheesemakers.\", 7 }; ➊\n\n  REQUIRE(cb.size() == 7); ➋\n  REQUIRE(*static_cast<const char*>(cb.data()) == 'B'); ➌\n}\n\nTEST_CASE(\"mutable_buffer constructor\") {\n  std::string proposition{ \"Charity for an ex-leper?\" };\n  boost::asio::mutable_buffer mb{ proposition.data(), proposition.size() }; ➍\n\n  REQUIRE(mb.data() == proposition.data()); ➎\n  REQUIRE(mb.size() == proposition.size()); ➏\n}\n```", "```\n#include <boost/asio.hpp>\n\nTEST_CASE(\"streambuf constructor\") {\n  boost::asio::streambuf sb; ➊\n  REQUIRE(sb.size() == 0); ➋\n}\n```", "```\nTEST_CASE(\"streambuf input/output\") {\n  boost::asio::streambuf sb; ➊\n  std::ostream os{ &sb }; ➋\n  os << \"Welease Wodger!\"; ➌\n\n  std::istream is{ &sb }; ➍\n  std::string command; ➎\n  is >> command; ➏\n\n  REQUIRE(command == \"Welease\"); ➐\n}\n```", "```\nstd::string proposition{ \"Charity for an ex-leper?\" };\nauto mb = boost::asio::buffer(proposition);\n```", "```\nconst std::string proposition{ \"Charity for an ex-leper?\" };\nauto cb = boost::asio::buffer(proposition);\n```", "```\nstd::string proposition{ \"Charity for an ex-leper?\" };\nauto db = boost::asio::dynamic_buffer(proposition);\n```", "```\n#include <boost/asio.hpp>\n#include <iostream>\n#include <istream>\n#include <ostream>\n#include <string>\n\nstd::string request(std::string host, boost::asio::io_context& io_context) { ➊\n  std::stringstream request_stream;\n  request_stream << \"GET / HTTP/1.1\\r\\n\"\n                    \"Host: \" << host << \"\\r\\n\"\n                    \"Accept: text/html\\r\\n\"\n                    \"Accept-Language: en-us\\r\\n\"\n                    \"Accept-Encoding: identity\\r\\n\"\n                    \"Connection: close\\r\\n\\r\\n\";\n  const auto request = request_stream.str(); ➋\n  boost::asio::ip::tcp::resolver resolver{ io_context };\n  const auto endpoints = resolver.resolve(host, \"http\"); ➌\n  boost::asio::ip::tcp::socket socket{ io_context };\n  const auto connected_endpoint = boost::asio::connect(socket, endpoints); ➍\n  boost::asio::write(socket, boost::asio::buffer(request)); ➎\n  std::string response;\n  boost::system::error_code ec;\n  boost::asio::read(socket, boost::asio::dynamic_buffer(response), ec); ➏\n  if (ec && ec.value() != 2) throw boost::system::system_error{ ec }; ➐\n  return response;\n}\n\nint main() {\n  boost::asio::io_context io_context;\n  try  {\n    const auto response = request(\"www.arcyber.army.mil\", io_context); ➑\n    std::cout << response << \"\\n\"; ➒\n  } catch(boost::system::system_error& se) {\n    std::cerr << \"Error: \" << se.what() << std::endl;\n  }\n}\n-----------------------------------------------------------------------\nHTTP/1.1 200 OK\nPragma: no-cache\nContent-Type: text/html; charset=utf-8\nX-UA-Compatible: IE=edge\npw_value: 3ce3af822980b849665e8c5400e1b45b\nAccess-Control-Allow-Origin: *\nX-Powered-By:\nServer:\nX-ASPNET-VERSION:\nX-FRAME-OPTIONS: SAMEORIGIN\nContent-Length: 76199\nCache-Control: private, no-cache\nExpires: Mon, 22 Oct 2018 14:21:09 GMT\nDate: Mon, 22 Oct 2018 14:21:09 GMT\nConnection: close\n<!DOCTYPE html>\n<html  lang=\"en-US\">\n<head id=\"Head\">\n--snip--\n</body>\n</html>\n```", "```\n#include <boost/asio.hpp>\n#include <iostream>\n#include <string>\n#include <sstream>\n\nusing ResolveResult = boost::asio::ip::tcp::resolver::results_type;\nusing Endpoint = boost::asio::ip::tcp::endpoint;\n\nstruct Request {\n  explicit Request(boost::asio::io_context& io_context, std::string host)\n      : resolver{ io_context },\n        socket{ io_context },\n        host{ std::move(host) } { ➊\n    std::stringstream request_stream;\n    request_stream << \"GET / HTTP/1.1\\r\\n\"\n                      \"Host: \" << this->host << \"\\r\\n\"\n                      \"Accept: text/plain\\r\\n\"\n                      \"Accept-Language: en-us\\r\\n\"\n                      \"Accept-Encoding: identity\\r\\n\"\n                      \"Connection: close\\r\\n\"\n                      \"User-Agent: C++ Crash Course Client\\r\\n\\r\\n\";\n    request = request_stream.str(); ➋\n    resolver.async_resolve(this->host, \"http\",\n       [this] (boost::system::error_code ec, const ResolveResult& results) {\n         resolution_handler(ec, results); ➌\n       });\n  }\n void resolution_handler(boost::system::error_code ec,\n                          const ResolveResult& results) {\n    if (ec) { ➍\n      std::cerr << \"Error resolving \" << host << \": \" << ec << std::endl;\n      return;\n    }\n    boost::asio::async_connect(socket, results,\n            [this] (boost::system::error_code ec, const Endpoint& endpoint){\n              connection_handler(ec, endpoint); ➎\n            });\n  }\n\n  void connection_handler(boost::system::error_code ec,\n                          const Endpoint& endpoint) { ➏\n    if (ec) {\n      std::cerr << \"Error connecting to \" << host << \": \"\n                << ec.message() << std::endl;\n      return;\n    }\n    boost::asio::async_write(socket, boost::asio::buffer(request),\n            [this] (boost::system::error_code ec, size_t transferred){\n              write_handler(ec, transferred);\n            });\n  }\n\n  void write_handler(boost::system::error_code ec, size_t transferred) { ➐\n    if (ec) {\n      std::cerr << \"Error writing to \" << host << \": \" << ec.message()\n                << std::endl;\n    } else if (request.size() != transferred) {\n      request.erase(0, transferred);\n      boost::asio::async_write(socket, boost::asio::buffer(request),\n                               [this] (boost::system::error_code ec,\n                                       size_t transferred){\n                                 write_handler(ec, transferred);\n                               });\n    } else {\n      boost::asio::async_read(socket, boost::asio::dynamic_buffer(response),\n                              [this] (boost::system::error_code ec,\n                                      size_t transferred){\n                                read_handler(ec, transferred);\n                              });\n    }\n  }\n\n  void read_handler(boost::system::error_code ec, size_t transferred) { ➑\n    if (ec && ec.value() != 2)\n      std::cerr << \"Error reading from \" << host << \": \"\n                << ec.message() << std::endl;\n  }\n\n  const std::string& get_response() const noexcept {\n    return response;\n  }\nprivate:\n boost::asio::ip::tcp::resolver resolver;\n  boost::asio::ip::tcp::socket socket;\n  std::string request, response;\n  const std::string host;\n};\n\nint main() {\n  boost::asio::io_context io_context;\n  Request request{ io_context, \"www.arcyber.army.mil\" }; ➒\n  io_context.run(); ➓\n  std::cout << request.get_response();\n}\n-----------------------------------------------------------------------\nHTTP/1.1 200 OK\nPragma: no-cache\nContent-Type: text/html; charset=utf-8\nX-UA-Compatible: IE=edge\npw_value: 3ce3af822980b849665e8c5400e1b45b\nAccess-Control-Allow-Origin: *\nX-Powered-By:\nServer:\nX-ASPNET-VERSION:\nX-FRAME-OPTIONS: SAMEORIGIN\nContent-Length: 76199\nCache-Control: private, no-cache\nExpires: Mon, 22 Oct 2018 14:21:09 GMT\nDate: Mon, 22 Oct 2018 14:21:09 GMT\nConnection: close\n\n<!DOCTYPE html>\n<html  lang=\"en-US\">\n<head id=\"Head\">\n--snip--\n</body>\n</html>\n```", "```\n#include <iostream>\n#include <string>\n#include <boost/asio.hpp>\n#include <boost/algorithm/string/case_conv.hpp>\n\nusing namespace boost::asio;\n\nvoid handle(ip::tcp::socket& socket) { ➊\n  boost::system::error_code ec;\n  std::string message;\n  do {\n    boost::asio::read_until(socket, dynamic_buffer(message), \"\\n\"); ➋\n    boost::algorithm::to_upper(message); ➌\n    boost::asio::write(socket, buffer(message), ec); ➍\n    if (message == \"\\n\") return; ➎\n    message.clear();\n  } while(!ec); ➏\n}\n\nint main()  {\n  try {\n    io_context io_context;\n    ip::tcp::acceptor acceptor{ io_context,\n                                ip::tcp::endpoint(ip::tcp::v4(), 1895) }; ➐\n    while (true) {\n      ip::tcp::socket socket{ io_context };\n      acceptor.accept(socket); ➑\n      handle(socket); ➒\n    }\n  } catch (std::exception& e) {\n    std::cerr << e.what() << std::endl;\n  }\n}\n```", "```\n$ ncat localhost 1895 ➊\nThe 300 ➋\nTHE 300\nThis is Blasphemy! ➋\nTHIS IS BLASPHEMY!\nThis is madness! ➋\nTHIS IS MADNESS!\nMadness...? ➋\nMADNESS...?\nThis is Sparta! ➋\nTHIS IS SPARTA!\n➌\nNcat: Broken pipe. ➍\n```", "```\n#include <iostream>\n#include <string>\n#include <boost/asio.hpp>\n#include <boost/algorithm/string/case_conv.hpp>\n#include <memory>\nusing namespace boost::asio;\n\nstruct Session : std::enable_shared_from_this<Session> {\n  explicit Session(ip::tcp::socket socket) : socket{ std::move(socket) } { } ➊\n  void read() {\n    async_read_until(socket, dynamic_buffer(message), '\\n', ➋\n            [self=shared_from_this()] (boost::system::error_code ec,\n                                       std::size_t length) {\n              if (ec || self->message == \"\\n\") return; ➌\n              boost::algorithm::to_upper(self->message);\n              self->write();\n            });\n  }\n  void write() {\n    async_write(socket, buffer(message), ➍\n                [self=shared_from_this()] (boost::system::error_code ec,\n                                           std::size_t length) {\n                  if (ec) return; ➎\n                  self->message.clear();\n                  self->read();\n                });\n  }\nprivate:\n  ip::tcp::socket socket;\n  std::string message;\n};\n\nvoid serve(ip::tcp::acceptor& acceptor) {\n  acceptor.async_accept([&acceptor](boost::system::error_code ec, ➏\n                                    ip::tcp::socket socket) {\n    serve(acceptor); ➐\n    if (ec) return;\n    auto session = std::make_shared<Session>(std::move(socket)); ➑\n    session->read();\n  });\n}\n\nint main()  {\n  try {\n    io_context io_context;\n    ip::tcp::acceptor acceptor{ io_context,\n                                ip::tcp::endpoint(ip::tcp::v4(), 1895) };\n    serve(acceptor);\n    io_context.run(); ➒\n  } catch (std::exception& e) {\n    std::cerr << e.what() << std::endl;\n  }\n}\n```", "```\n#include <iostream>\n#include <string>\n#include <boost/asio.hpp>\n#include <boost/algorithm/string/case_conv.hpp>\n#include <memory>\n#include <future>\nstruct Session : std::enable_shared_from_this<Session> {\n--snip--\n};\n\nvoid serve(ip::tcp::acceptor& acceptor) {\n--snip--\n}\n\nint main()  {\n  const int n_threads{ 4 };\n  boost::asio::io_context io_context{ n_threads };\n  ip::tcp::acceptor acceptor{ io_context,\n                              ip::tcp::endpoint(ip::tcp::v4(), 1895) }; ➊\n  serve(acceptor); ➋\n\n  std::vector<std::future<void>> futures;\n  std::generate_n(std::back_inserter(futures), n_threads, ➌\n                  [&io_context] {\n                    return std::async(std::launch::async,\n                                      [&io_context] { io_context.run(); }); ➍\n                  });\n\n  for(auto& future : futures) { ➎\n    try {\n      future.get(); ➏\n    } catch (const std::exception& e) {\n      std::cerr << e.what() << std::endl;\n    }\n  }\n}\n```"]