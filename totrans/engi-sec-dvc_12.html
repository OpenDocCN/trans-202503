<html><head></head><body>
<div id="sbo-rt-content"><h2 class="h2" id="ch09"><span epub:type="pagebreak" id="page_159"/><strong><span class="big">9</span><br/>SECURE FIRMWARE UPDATE</strong></h2>
<div class="image1"><img alt="Image" height="252" src="../images/common.jpg" width="252"/></div>
<p class="noindent">Security updates are annoying, for consumers, for administrators, and especially for manufacturers. The latter constantly need to watch out for possible vulnerabilities in their products and react to corresponding notifications, while users and administrators have to apply published patches in a timely manner. Since we can regard a device’s security as a volatile state that might change tomorrow, having a solid update strategy is imperative.</p>
<p class="indent">However, software update handling is not a trivial process. Only authorized entities should be able to supply updates to devices, and they shouldn’t break device functionality or turn it into an expensive brick. In addition, safety experts are often rather reluctant to introduce patches to their certified devices, while corresponding certification bodies increasingly recognize the importance of security updates even in safety-critical areas.</p>
<p class="indent">This chapter walks through the options for secure update approaches and the reasoning behind them. A central consideration is the secure implementation of update verification and its reliable application on the device itself. The chapter concludes with a practical case study for firmware updates based on the popular SWUpdate framework and a Yocto-based toolchain.</p>
<h3 class="h3" id="ch00lev1_72"><span epub:type="pagebreak" id="page_160"/><strong>The Inevitability of Updates</strong></h3>
<p class="noindent">In some software and product development communities, a <em>perpetual beta</em> phase is common: a product never leaves its beta status, and new features are continuously added, even if the software or device is already in the field and in productive use by customers. This concept is sometimes also described as the <em>banana principle</em>, because those fruits are harvested when still green and continue to ripen on their way to customers and even after purchase. In such cases, it’s blatantly obvious that the delivered product isn’t completely finished and requires several software updates to develop its full potential. A secure update approach is essential.</p>
<p class="indent">If we look at industrial systems and critical infrastructures, the situation is very different. Although these systems usually have a long lifetime, their manufacturers and operators may not have seen a need for patch management in the past. However, the increase in connectivity and digitalization in this field, along with the continuous discovery of vulnerabilities in industrial products, forces vendors and users to act and prepare for secure update processes. This situation is especially challenging because manufacturer support for security updates and operational patch management processes for industrial components usually have to run for decades.</p>
<p class="indent">Even if you work in an industry that has a strong security focus and your development processes yield highly secure and robust products, you can’t guarantee that your software, your firmware, and your hardware components are free of bugs. Also, you don’t know whether new attack methodologies—not even invented at the time of product development—will cause security issues for your devices and may demand the replacement of crypto algorithms or the further enhancement of security features. In a nutshell: no product is perfect. Prepare it to be updatable.</p>
<p class="indent">Some prominent cases stress the need for secure update support in embedded and IoT devices. The vulnerability collections <em>Urgent/11</em> from 2019 and <em>Ripple20</em> from 2020 showed that fundamental software components like TCP/IP stacks and OSs may exhibit severe weaknesses. Millions, if not billions, of devices were affected, and many are assumed not to be patchable because they don’t provide the necessary means. In the end, that inability forces customers to replace those devices or leaves them with insecure systems. At this scale, it might even pose a risk to society as a whole because malicious actors know how to invite those IoT products to their botnets. The bottom line is that every digital device sold in the 2020s should have a secure update mechanism.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>I’m not the only one stressing the need for secure update strategies. IEC 62443 for industrial cybersecurity, United Nations (UN) Regulation 156 for the automotive industry, and the cybersecurity part of the US FD&amp;C Act for medical devices also agree, just to name a few.</em></p>
</div>
<h3 class="h3" id="ch00lev1_73"><span epub:type="pagebreak" id="page_161"/><strong>Security Requirements</strong></h3>
<p class="noindent">As with every concept that has the term <em>secure</em> in its title, the obvious question is which (protection) goals are associated with it in this specific context. The following sections describe requirements you must consider for a secure firmware update.</p>
<h4 class="h4" id="ch00lev2_93"><strong><em>Authenticity</em></strong></h4>
<p class="noindent">It is essential that a firmware update can cryptographically prove its authenticity, which ensures that it originates from the original manufacturer of the given device. This prohibits the installation of maliciously crafted updates and should be mandatory for all secure update procedures. This goal is typically achieved by digitally signing an update package.</p>
<h4 class="h4" id="ch00lev2_94"><strong><em>Confidentiality</em></strong></h4>
<p class="noindent">Firmware images are regularly used by people to reverse engineer devices for the enumeration of software libraries, to identify weaknesses, or to analyze proprietary applications for intellectual property and secrets. Confidentiality protection can be achieved by the encryption of the update contents as a whole or in parts.</p>
<p class="indent">However, make sure you understand there is a risk because the corresponding decryption key needs to be stored on the device, so attackers might either be able to extract that key from the device or the plain firmware update after on-device decryption.</p>
<h4 class="h4" id="ch00lev2_95"><strong><em>Secure Distribution Channel</em></strong></h4>
<p class="noindent">The first two requirements, authenticity and confidentiality, impose requirements on the update file itself. However, the distribution channel also might be worth protecting (for example, with TLS).</p>
<p class="indent">A mutually authenticated and encrypted communication between a device and an update server might even be a replacement for the confidentiality protection of the update file.</p>
<h4 class="h4" id="ch00lev2_96"><strong><em>Rollback Option</em></strong></h4>
<p class="noindent">This one is tricky. Rolling back the software version of a device to an older state is sometimes absolutely helpful—for example, if an update introduces severe issues that haven’t existed before. On the other hand, attackers might use this feature to revert a device’s software to a version containing known vulnerabilities that later patches have fixed. In that case, the operation of vulnerable devices and their exploitation becomes possible, although the manufacturer provided security updates.</p>
<p class="indent"><span epub:type="pagebreak" id="page_162"/>If you decide to implement rollback protection, you need corresponding hardware support, such as a monotonic, nonvolatile version counter within your main CPU.</p>
<h4 class="h4" id="ch00lev2_97"><strong><em>Version Distribution Monitoring</em></strong></h4>
<p class="noindent">Monitoring the adoption of security updates in the field can be highly valuable, because doing so gives you an overview of the situation and the corresponding threat landscape for your devices and your customers. You could implement this monitoring with a confirmation notice for each device after a new firmware version has been successfully installed.</p>
<h3 class="h3" id="ch00lev1_74"><strong>Distribution and Deployment of Updates</strong></h3>
<p class="noindent">A central question regarding firmware updates is, “How does the update file find its way into the device?” Answers to that question have a significant impact on usability, processes, and reaction speed for your device’s patch management.</p>
<h4 class="h4" id="ch00lev2_98"><strong><em>Local vs. Remote Updates</em></strong></h4>
<p class="noindent">Since the 1990s, devices that implement an update mechanism offer some kind of interface to upload or to store a firmware file that was previously downloaded from the manufacturer’s website. The update file might even be restricted to be loaded at a local interface, such as via USB media. While local presence for updating can be a security feature, this approach provides pretty poor scalability for IoT scenarios. Millions of devices would require millions of customers with security awareness and millions of manual update installations, which is hardly feasible and results in few updates actually being applied.</p>
<p class="indent">The automotive industry is an interesting example regarding firmware updates. For many years, it was common for a recall to be issued if cars had a significant software bug or vulnerability. The owners had to bring their vehicles to an auto repair shop, where mechanics installed the software update provided by the corresponding car manufacturer that received it from the suppliers of the specific control unit. Nowadays, modern cars can receive software updates through their connection to mobile networks. This approach is called an <em>over-the-air (OTA) update</em>.</p>
<p class="indent">OTA updates are not restricted to cars. They can be applied to all sorts of IoT devices, and even if the term suggests that updates are applied over wireless channels, update transmission over wired networks is clearly not forbidden. The main advantage of this concept is that devices have a connection to an update management backend, usually operated by the device’s manufacturer, that provides information about new updates. This approach provides decent scalability because the update rollout process can be automated and scheduled by manufacturers. However, such a system exposes backend servers and devices listening for updates to remote attackers and network-based attacks.</p>
<div class="note">
<p class="notet"><span epub:type="pagebreak" id="page_163"/><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>In some industrial scenarios, manual local update procedures are still the default. I’ve heard from a person who personally visits hundreds of industrial robots, plugs in a USB stick, and then waits for the update to complete before he continues his journey, which might take weeks for a single update. Crazy!</em></p>
</div>
<h4 class="h4" id="ch00lev2_99"><strong><em>Pull vs. Push Strategy</em></strong></h4>
<p class="noindent">There’s no doubt that a direct connection between devices and an update server in the backend is a reasonable solution for professional update management, but one question remains: Who is in control of the update procedure?</p>
<p class="indent">Usually, devices follow a <em>pull strategy</em> for update management: a client application on the device periodically checks for new updates and downloads newly available images. Afterward, depending on the owner’s configuration, the device might automatically install the update (for example, within a predefined maintenance window) or prompt a user or an administrator to approve installation. After a successful update, the new software state might be reported to a manufacturer’s server. In this case, operators control when and which updates are installed on their devices, which is usually the preferred solution for business scenarios, but they also take responsibility for regular update schedules.</p>
<p class="indent">Alternatively, manufacturers might opt for a <em>push strategy</em> that gives them more power over the update process. They might even force devices into an update mode. This method could be reasonable if the manufacturer is involved and responsible for timely device updates, maybe even by legal obligations. Further, the security of specific customer target groups like private users can benefit significantly if updates are enforced automatically and they don’t have to organize the process themselves. On the other hand, some customers deliberately choose to operate devices with old firmware versions, and if they deny those devices access to the update server, manufacturers are powerless. However, if such cases are part of your challenges, it makes sense to focus on software state monitoring whenever devices connect to your online services and deny access if device firmware is too old, keeping a large portion of devices in the field in a secure state.</p>
<p class="indent">Strategies that mix pull and push aspects are possible in practice. You might even leave the decision to your customers by providing corresponding configuration options for your device. This enables operators to perfectly integrate your device into their specific asset and patch-management processes.</p>
<h3 class="h3" id="ch00lev1_75"><strong>Update Granularity and Format</strong></h3>
<p class="noindent">The terms <em>software update</em> and <em>firmware update</em> are often used interchangeably and for a broad range of update scenarios, from rewriting all memory contents within a device to the change of few configuration parameters within a single file. Therefore, for your specific device, it’s absolutely necessary to define which parts of your device firmware should be replaceable and in which format you would like to distribute that data.</p>
<h4 class="h4" id="ch00lev2_100"><span epub:type="pagebreak" id="page_164"/><strong><em>Firmware Parts</em></strong></h4>
<p class="noindentb">In the PC context, <em>firmware</em> is the software programmed to the onboard nonvolatile memory of the motherboard, installed daughterboards, and further peripheral devices. OSs, software applications, and user data, usually stored on hard disks, are not regarded as firmware. In the embedded system context, however, almost everything can be regarded as firmware:</p>
<p class="hanga"><strong>Bootloader</strong>    Modern embedded devices contain at least one boot-loader, usually more.</p>
<p class="hanga"><strong>Coprocessor firmware</strong>    Recent SoCs include a heterogeneous set of processors within one package. Some of these coprocessors might require their own firmware.</p>
<p class="hanga"><strong>Controller firmware</strong>    On the PCB scale, a single embedded system might have several microcontrollers that execute dedicated firmware.</p>
<p class="hanga"><strong>FPGA bitstream</strong>    As part of an SoC or as a discrete component, FPGAs are integrated into a multitude of embedded devices. Their configuration, called the <em>bitstream</em>, might be read directly from flash memory or loaded by a bootloader or an OS application.</p>
<p class="hanga"><strong>Bare-metal software</strong>    In devices running without an OS, bare-metal software is the main application.</p>
<p class="hanga"><strong>OS kernel</strong>    If your device comes with an OS or an RTOS, the corresponding OS kernel is the central software component.</p>
<p class="hanga"><strong>Device tree</strong>    The hardware components and their parameters for a specific embedded system are often described in a device-tree file that’s loaded by the OS kernel.</p>
<p class="hanga"><strong>Root filesystem</strong>    The basic filesystem on top of which all other filesystems and overlays are mounted contains data that’s crucial for the correct functioning of an OS.</p>
<p class="hanga"><strong>Application software</strong>    Application software might be part of the root filesystem but could also be located in one or multiple manufacturer-specific partitions.</p>
<p class="indenttb">Some of the firmware parts on that list might share a common nonvolatile memory; others might come with their own discrete memory component. Make sure you are aware of all relevant firmware components when developing a secure update concept. However, don’t forget that your device probably carries unique data that must not be affected by a software update:</p>
<p class="hanga"><strong>Unique cryptographic keys</strong>    Data corresponding to your device’s unique identity, probably provisioned during production, is essential for trustworthy device authentication. Additionally, secrets, like SSH keys that are generated at first boot, should survive a software update.</p>
<p class="hanga"><strong>User-dependent system data</strong>    Customers rely on additional user accounts and corresponding credentials as well as custom device configuration files.</p>
<p class="hanga"><span epub:type="pagebreak" id="page_165"/><strong>Runtime data partitions</strong>    Your device might collect and store user-specific runtime data, like sensor-value histories for data analytics applications, but it might also log data that might be relevant for maintenance and repair cases.</p>
<h4 class="h4" id="ch00lev2_101"><strong><em>Update Formats</em></strong></h4>
<p class="noindentb">As mentioned previously, the granularity of software components that need to be covered by updates varies greatly and doesn’t directly suggest a specific format for update distribution. Several requirements should be considered before deciding:</p>
<p class="hanga"><strong>Comprehensive coverage</strong>    The chosen format should have the ability to update as many of a device’s software components as possible.</p>
<p class="hanga"><strong>Efficiency</strong>    Since the size of firmware is constantly increasing, it should be possible to reduce a firmware update to the parts that are actually new.</p>
<p class="hanga"><strong>Atomicity</strong>    The installation of an update should be an <em>indivisible</em> operation allowing only two final states: successfully updated firmware or, upon failure, the original firmware before the update process started.</p>
<p class="indenttb">The following list provides possible update format solutions based on the previously posed requirements:</p>
<p class="hanga"><strong>Files</strong>    A trivial update format would be to supply a device with a set of updated files that can be written to their specific paths in a filesystem. While this would enable updates for all components available in the device’s filesystem, and small, efficient update packages could be created, atomicity is complex. Every file created, written, or deleted requires its own operation that might fail or succeed. In case of an error, the firmware might end up in an unknown state.</p>
<p class="hanga"><strong>Containers</strong>    Containerized applications have become increasingly popular in larger embedded systems. The replacement of whole container images could be effective for their update management, but relying only on container-based updates would neglect important software components like the host OS running the container management.</p>
<p class="hanga"><strong>Images</strong>    Updating entire partition images enables updates for many software components in an embedded system and has advantages regarding atomicity. This approach might lead to larger firmware updates than other formats, but some implementations also support compressed update files or differential updates to overcome this issue.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Firmware parts that aren’t reachable by filesystem access, such as ICs that have to be updated based on a proprietary protocol, require customized treatment. Consider the pros and cons and make a conscious decision regarding the targeted update capabilities for your device.</em></p>
</div>
<h4 class="h4" id="ch00lev2_102"><span epub:type="pagebreak" id="page_166"/><strong><em>Issues with Package Managers</em></strong></h4>
<p class="noindent">You might wonder why Linux-based embedded devices in most cases don’t rely on established package manager applications like <span class="literal">apt-get</span> or <span class="literal">opkg</span> that are used back and forth on desktop and server systems. The reason lies in the testing complexity of systems that are updated on a package basis. Such an approach requires the management of <em>dependencies</em> among all possible packages in a system, and it multiplies the possible software configurations that have to be tested.</p>
<p class="indent">In addition, since embedded devices often operate in critical applications or industries, comprehensive testing is a must. Therefore, many manufacturers refrain from using package managers and choose an atomic, image-based updating approach instead, restricting the interplay of software components to be tested to the specific versions in a certain software release.</p>
<p class="indent">If you want to go down that road, you probably need a partner that offers automated and reliable testing services that handle all the mentioned issues, for example, as provided by Canonical for their Ubuntu Core OS.</p>
<h3 class="h3" id="ch00lev1_76"><strong>Device Partitioning Strategies</strong></h3>
<p class="noindent">A robust update procedure is possible only if the memory partitioning of your device supports it. Depending on available memory and willingness to take risks, various approaches can be used to design a system’s partition layout to support updating processes.</p>
<h4 class="h4" id="ch00lev2_103"><strong><em>Update/Recovery Partition</em></strong></h4>
<p class="noindent">You can enhance robustness against failed firmware updates by introducing an additional <em>recovery partition</em>. This partition contains tools to download and update the main system partition, including the OS kernel and the corresponding root filesystem, as shown in <a href="ch09.xhtml#ch09fig01">Figure 9-1</a>.</p>
<div class="image"><img alt="Image" height="327" id="ch09fig01" src="../images/09fig01.jpg" width="687"/></div>
<p class="figcap"><em>Figure 9-1: The recovery partition to perform system updates</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_167"/>The advantage of this approach is the low memory footprint of the extra partition, which should be feasible for many devices. However, on the downside, the device has to be rebooted to enter the update or recovery mode. If the update process fails, the main partition is corrupted and can’t be booted anymore, so the recovery partition is booted again, and a fresh update process can be initiated.</p>
<h4 class="h4" id="ch00lev2_104"><strong><em>A/B System Approach</em></strong></h4>
<p class="noindent">For devices providing plenty of nonvolatile memory, the <em>A/B system</em> approach can be an interesting candidate. <a href="ch09.xhtml#ch09fig02">Figure 9-2</a> depicts the basic partition layout and update procedure.</p>
<div class="image"><img alt="Image" height="327" id="ch09fig02" src="../images/09fig02.jpg" width="740"/></div>
<p class="figcap"><em>Figure 9-2: Two identical system image copies—A and B</em></p>
<p class="indent">In this layout, two copies, A and B, of the system partition exist, both holding at least the OS kernel and the root filesystem. At boot, the partition marked as “bootable” (partition A in <a href="ch09.xhtml#ch09fig02">Figure 9-2</a>) is used to load the OS and the basic filesystem. This includes an update client that’s able to receive firmware updates, verify them, and write them to the currently unused partition <span class="ent">➊</span> (B in <a href="ch09.xhtml#ch09fig02">Figure 9-2</a>). Afterward, the bootloader is configured to swap the boot partition from A to B (or vice versa) <span class="ent">➋</span> before rebooting to the new firmware version.</p>
<p class="indent">In case of an update failure or partition corruption, the old version is still available in its original state and can be booted again. A significant advantage compared to using a recovery partition is that the standard device operation is not interrupted during the update download and installation. In addition, the newly downloaded firmware can be directly stored on the inactive partition instead of requiring an additional storage location for update caching. On Android devices, this concept is called <em>seamless system updates</em>, and it’s increasingly implemented by phone vendors.</p>
<p class="indent">For devices of even higher criticality, both approaches can be combined, as shown in <a href="ch09.xhtml#ch09fig03">Figure 9-3</a>.</p>
<div class="image"><span epub:type="pagebreak" id="page_168"/><img alt="Image" height="405" id="ch09fig03" src="../images/09fig03.jpg" width="749"/></div>
<p class="figcap"><em>Figure 9-3: The A/B architecture with an additional recovery partition</em></p>
<p class="indent">This design aims for protection against cases in which both system partitions, A and B, are corrupted for whatever reason. For such architectures, it makes sense to store the recovery partition within a different physical memory than the system partitions. Even if the recovery partition can’t successfully reinstall the system partitions, it can still report the system failure and perform diagnostics.</p>
<h4 class="h4" id="ch00lev2_105"><strong><em>A Note on Updating Bootloaders</em></strong></h4>
<p class="noindent">Bootloaders are used on many embedded systems. They handle basic system initialization, select a boot medium, and subsequently load an OS kernel. In many cases, these binaries are regarded as an “immutable” firmware part.</p>
<p class="indent">However, these days, bootloaders like U-Boot and GRUB are complex software components with a variety of features and capabilities. As a consequence, bootloaders also may exhibit bugs or even security vulnerabilities that require updates.</p>
<p class="indent">From a security point of view, you also might need to replace public keys or outdated cryptographic algorithms used for a secure boot process, as described in <a href="ch08.xhtml#ch08">Chapter 8</a>. On the functional side, you might come to a point when you’d like to update hardware initialization settings, kernel boot parameters, or boot configurations. All these reasons render updating boot-loaders and their configuration data a valid consideration.</p>
<p class="indent">In most systems, however, only a single copy per bootloader is available, which means that updating it comes with the risk of breaking the device—for example, in the case of power loss or other failures during the bootloader update. Only a few SoCs and microcontrollers provide support for additional bootloader instances that can be run when the main bootloader fails. Therefore, updating a bootloader is always a critical and risky procedure that can well lead to a situation where physical access to a device is necessary for repair.</p>
<p class="indent">A compromise solution could be a multistage bootloader approach, splitting the functionality in two parts. The first stage is considered immutable and has minimal functionality, but provides support for multiple bootloader copies in the next stage, which carries the fully fledged bootloader. In such <span epub:type="pagebreak" id="page_169"/>a system, security issues in the early stage still remain a problem and would require physical access or a risky update procedure, but the second stage can be stored redundantly, which allows for low-risk updating. However, this approach isn’t standard and would require further development efforts and customizations.</p>
<h3 class="h3" id="ch00lev1_77"><strong>The Interplay Between Development, Backend, and Device</strong></h3>
<p class="noindent">After clarifying all the details influencing your update strategy, it’s time to talk about the necessary operational processes for reliable and secure firmware updates. As described in <a href="ch01.xhtml#ch01">Chapter 1</a>, it’s the manufacturer’s responsibility to monitor device vulnerabilities exploited in the field and take vulnerability reports seriously.</p>
<p class="indent">Let’s assume you have that covered already and your development team is able to provide fixes in a short time frame. An operational question still remains: Should security updates and functional enhancements be merged with firmware updates, or should each be available separately?</p>
<p class="indent">Some customers have to perform comprehensive testing of your device within their given infrastructure and, therefore, avoid upgrading devices with new functionalities that might require retests. However, they’re probably interested in security fixes that contribute to the robustness and security of their systems. In such scenarios, a split between functional and protective updates is recommended.</p>
<p class="indent">In addition, imagine that a new firmware version leads to complications and customers have to downgrade to the previous version. If security updates are included in this update file, your customers would have to live with known vulnerabilities in your devices, at least until the functional issues are fixed. However, taking this separation seriously leads to more possible software configurations and more testing on the manufacturer side.</p>
<p class="indent">No matter the content of a firmware update, it has to be provided and packaged by the development team and corresponding build pipelines. If necessary, the firmware has to be encrypted, usually with a symmetric encryption scheme like AES. To achieve authenticity and integrity protection, the final firmware image has to be digitally signed by appropriate algorithms like RSA or ECDSA.</p>
<p class="indent">Both tasks include two components that have to match. On the manufacturer side, the firmware artifacts yielded by the build system have to be encrypted and signed to generate the actual firmware update files to be distributed. On the device itself, the signature verification and decryption has to be performed.</p>
<p class="indent">Several image-based update systems perform those tasks for you: Mender, SWUpdate, and RAUC. Mender provides the whole infrastructure, including device client software and backend server. SWUpdate and RAUC generate and apply firmware update files, but the update distribution and monitoring is typically performed by the Eclipse hawkBit backend framework. Further candidates include OSTree and swupd, which follow a “Git-like” revision-based approach for firmware updates.</p>
<h3 class="h3" id="ch00lev1_78"><span epub:type="pagebreak" id="page_170"/><strong>Case Study: Secure Firmware Updates with SWUpdate</strong></h3>
<p class="noindent">This case study provides an example of the necessary practical steps to bring a secure firmware update architecture to life. It’s based on the Yocto tool-chain delivered by ST for the STM32MP157F-DK2 board.</p>
<p class="indent">I’ve chosen SWUpdate as the central software component for this implementation. The desired outcome is an update process that verifies the authenticity of updates based on digital signatures and guarantees a reliable update procedure taking an A/B system approach.</p>
<h4 class="h4" id="ch00lev2_106"><strong><em>SD Card Layout Customization</em></strong></h4>
<p class="noindent">The Yocto build system compiles and packages all relevant software for my device’s firmware image and provides it in formats like <em>.ext4</em> and <em>.tar.gz</em>. This is useful for further processing, such as for generating an SD card image and creating an update file, but let’s take it one step at a time.</p>
<p class="indent">The STM32 Cube Programmer tool from ST as well as the handy shell script <em>create_sdcard_from_flashlayout.sh</em> use flash memory layout files in a Tab-Separated Values (TSV) format. Among other things, such a TSV file contains a list of partitions, their offset, and the files required to populate them. Selected columns of the default flash layout for the STM32MP157FDK2 board are shown in <a href="ch09.xhtml#ch09list01">Listing 9-1</a>.</p>
<pre class="pre">Name       Offset     Binary&#13;
fsbl-boot  0x0        arm-trusted-firmware/tf-a-stm32mp157f-dk2-usb.stm32&#13;
fip-boot   0x0        fip/fip-stm32mp157f-dk2-optee.bin&#13;
fsbl1      0x00004400 arm-trusted-firmware/tf-a-stm32mp157f-dk2-sdcard.stm32&#13;
fsbl2      0x00044400 arm-trusted-firmware/tf-a-stm32mp157f-dk2-sdcard.stm32&#13;
metadata1  0x00084400 arm-trusted-firmware/metadata.bin&#13;
metadata2  0x000C4400 arm-trusted-firmware/metadata.bin&#13;
fip-a      0x00104400 fip/fip-stm32mp157f-dk2-optee.bin&#13;
fip-b      0x00504400 none&#13;
u-boot-env 0x00904400 none&#13;
bootfs     0x00984400 st-image-bootfs-openstlinux-eglfs-stm32mp1.ext4&#13;
vendorfs   0x04984400 st-image-vendorfs-openstlinux-eglfs-stm32mp1.ext4&#13;
rootfs     0x05984400 st-image-core-openstlinux-eglfs-stm32mp1.ext4</pre>
<p class="list-title" id="ch09list01"><em>Listing 9-1: The default flash layout for the STM32MP157F-DK2 board</em></p>
<p class="indent">The TSV file contains many lines concerning bootloaders and trusted firmware artifacts that are of minor interest at this point. The last three lines, however, reveal two important facts. First, a dedicated <span class="literal">bootfs</span> partition contains U-Boot configuration files, device-tree blobs, and the Linux kernel as a <span class="literal">uImage</span>. Second, the <span class="literal">rootfs</span> partition is a perfect candidate for duplication for an A/B system approach. <a href="ch09.xhtml#ch09list02">Listing 9-2</a> shows the changes I made to the TSV file.</p>
<pre class="pre"><span epub:type="pagebreak" id="page_171"/>Name       Offset     Binary&#13;
...&#13;
bootfs     0x00984400 st-image-bootfs-openstlinux-eglfs-stm32mp1.ext4&#13;
vendorfs   0x04984400 st-image-vendorfs-openstlinux-eglfs-stm32mp1.ext4&#13;
rootfs-a   0x05984400 st-image-core-openstlinux-eglfs-stm32mp1.ext4&#13;
rootfs-b   0x35984400 st-image-core-openstlinux-eglfs-stm32mp1.ext4&#13;
userfs     0x65984400 st-image-userfs-openstlinux-eglfs-stm32mp1.ext4</pre>
<p class="list-title" id="ch09list02"><em>Listing 9-2: An adjusted partition layout for the A/B update approach</em></p>
<p class="indent">The original <span class="literal">rootfs</span> partition was cloned, resulting in two new partitions: <span class="literal">rootfs-a</span> and <span class="literal">rootfs-b</span>. Also, a <span class="literal">userfs</span> partition, already available in the toolchain provided by ST, was added to store data that should “survive” an update of the root filesystem.</p>
<p class="indent">For SD card image generation with the new parameters, the <em>create_sdcard _from_flashlayout.sh</em> shell script also had to be adapted to correctly handle the newly introduced partitions <span class="literal">rootfs-a</span> and <span class="literal">rootfs-b</span>. The SD card image size was set to 2,048MB, while both root partitions were configured to occupy 768MB, as already indicated by the offset of <span class="literal">0x30000000</span> in the flash layout file.</p>
<p class="indent">An important setting in the image creation script is the allocation of individual partition UUIDs for partitions <span class="literal">rootfs-a</span> and <span class="literal">rootfs-b</span>, as shown in <a href="ch09.xhtml#ch09list03">Listing 9-3</a>.</p>
<pre class="pre">DEFAULT_ROOTFSA_PARTUUID=e91c4e10-16e6-4c0e-bd0e-77becf4a3582&#13;
DEFAULT_ROOTFSB_PARTUUID=997046a6-c6f4-4f41-adb4-9fe614b2a92a</pre>
<p class="list-title" id="ch09list03"><em>Listing 9-3: The individual UUIDs for both copies of the root filesystem</em></p>
<p class="indent">I reused the UUID of the original <span class="literal">rootfs</span> partition for <span class="literal">rootfs-a</span> and randomly created a new one for <span class="literal">rootfs-b</span>. These UUIDs are relevant because they are used in U-Boot’s <em>extlinux.conf</em> configuration file located in the <span class="literal">bootfs</span> partition to determine the partition to be mounted as the root filesystem by the Linux kernel.</p>
<p class="indent">Afterward, the basic partition architecture for this case study is ready to support A/B system updates.</p>
<h4 class="h4" id="ch00lev2_107"><strong><em>SWUpdate Installation and Configuration</em></strong></h4>
<p class="noindent">SWUpdate, a feature-rich firmware update tool for embedded systems, provides the corresponding <span class="literal">meta-swupdate</span> layer for Yocto. This layer can be cloned from its Git repository and added to the STM32MP1 Yocto project.</p>
<h5 class="h5" id="ch00lev3_22"><strong>Addition of Security Features</strong></h5>
<p class="noindent">One of the first tasks is to create a recipe that patches the configuration of SWUpdate to enable signed and encrypted images. <a href="ch09.xhtml#ch09list04">Listing 9-4</a> shows the three lines that have to be explicitly activated.</p>
<pre class="pre"><span epub:type="pagebreak" id="page_172"/>CONFIG_HASH_VERIFY=y&#13;
CONFIG_SIGNED_IMAGES=y&#13;
CONFIG_ENCRYPTED_IMAGES=y</pre>
<p class="list-title" id="ch09list04"><em>Listing 9-4: Activating important security features of SWUpdate</em></p>
<p class="indent">The two options <span class="literal">CONFIG_HASH_VERIFY</span> and <span class="literal">CONFIG_SIGNED_IMAGES</span> add capabilities to SWUpdate that allow it to verify hashes and digital signatures of images included in a software update. The <span class="literal">CONFIG_ENCRYPTED_IMAGES</span> option enables support for AES-encrypted images, which we don’t implement at the moment, but it might be a valuable option for the future.</p>
<h5 class="h5" id="ch00lev3_23"><strong>Key Generation</strong></h5>
<p class="noindent">As explained in <a href="ch02.xhtml#ch02">Chapter 2</a>, digital signatures are an asymmetric crypto primitive that allow for verification of integrity and authenticity of signed data. SWUpdate can generate signatures based on plain RSA keys or certificates. For this case study, I chose to use 4,096-bit RSA keys. Their generation can be split into three steps, as shown in <a href="ch09.xhtml#ch09list05">Listing 9-5</a>.</p>
<pre class="pre">$ <span class="codestrong1">echo "SuperS3cr3t" &gt; passphrase</span>&#13;
$ <span class="codestrong1">openssl genrsa -aes256 -passout file:passphrase -out swu_signing_key.pem 4096</span>&#13;
$ <span class="codestrong1">openssl rsa -in swu_signing_key.pem -pubout -passin file:passphrase</span>&#13;
              <span class="codestrong1">-out swu_verification_key.pem</span></pre>
<p class="list-title" id="ch09list05"><em>Listing 9-5: The RSA key generation for update signing and verification</em></p>
<p class="indent">First, the file <em>passphrase</em> is created that should contain a strong password. Afterward, the RSA key can be generated (for example, with 4,096-bit length). The resulting private key is encrypted based on the given passphrase file and stored as <em>swu_signing_key.pem</em>. Note that this is the RSA private key used for signing a firmware update after the build process. The corresponding public key is extracted and saved as <em>swu_verification_key.pem</em> in the third line of the listing. This is necessary to make that key available in the final device firmware because it’s required for update signature verification.</p>
<h5 class="h5" id="ch00lev3_24"><strong>Software Collection</strong></h5>
<p class="noindent">Next, SWUpdate needs to know which Yocto build artifacts should be included in the firmware update. This information is stored in the <em>sw-description</em> file, which is used for update generation, but it’s also included in the firmware update package itself.</p>
<p class="indent"><a href="ch09.xhtml#ch09list06">Listing 9-6</a> shows the software collection I defined for this use case.</p>
<pre class="pre">software = {&#13;
  version = "0.1.0";&#13;
<span class="ent">➊</span> hardware-compatibility: ["C02"];&#13;
   stable = {&#13;
  <span class="ent">➋</span> rootfs-a: {&#13;
      images: (&#13;
<span epub:type="pagebreak" id="page_173"/>      {&#13;
      <span class="ent">➌</span> filename = "st-image-core-openstlinux-eglfs-stm32mp1.ext4.gz";&#13;
      <span class="ent">➍</span> compressed = "zlib";&#13;
      <span class="ent">➎</span> device = "/dev/mmcblk0p10";&#13;
      <span class="ent">➏</span> sha256 = "$swupdate_get_sha256(st-image-core-...-stm32mp1.ext4.gz)";&#13;
      });&#13;
    }&#13;
  <span class="ent">➐</span> rootfs-b: {&#13;
      images: (&#13;
      {&#13;
        filename = "st-image-core-openstlinux-eglfs-stm32mp1.ext4.gz";&#13;
        compressed = "zlib";&#13;
        device = "/dev/mmcblk0p11";&#13;
        sha256 = "$swupdate_get_sha256(st-image-core-...-stm32mp1.ext4.gz)";&#13;
      });&#13;
    }&#13;
  }&#13;
}</pre>
<p class="list-title" id="ch09list06"><em>Listing 9-6: The software collection defined in the</em> sw-description <em>file</em></p>
<p class="indent">The first point you might stumble upon is the <span class="literal">hardware-compatibility</span> parameter <span class="ent">➊</span>. I set it to <span class="literal">C02</span> because it’s the hardware and assembly revision of my STM32MP157F-DK2 board. At runtime, this parameter has to match the data given in <em>/etc/hwrevision</em> (for example, <span class="literal">stm32mp157f-dk2 C02</span> in my case).</p>
<p class="indent">Second, both partitions <span class="literal">rootfs-a</span> <span class="ent">➋</span> and <span class="literal">rootfs-b</span> <span class="ent">➐</span> are represented in this software collection, although only one will be used for updating at runtime. Both contain the same filename of the artifact to update <span class="ent">➌</span>—in this case, the root filesystem generated by Yocto. The <span class="literal">compressed</span> parameter <span class="ent">➍</span> indicates whether the data is available in compressed form, while <span class="literal">sha256</span> <span class="ent">➏</span> integrates the SHA-256 hash value of the provided artifact into the <em>sw-description</em> file.</p>
<p class="indent">The two images differ in only one property: the partition indicated by the <span class="literal">device</span> parameter <span class="ent">➎</span>. This determines where the SWUpdate client writes the update to. In this case, <em>/dev/mmcblk0p10</em> and <em>/dev/mmcblk0p11</em> are the device names under which the earlier created partitions <span class="literal">rootfs-a</span> and <span class="literal">rootfs-b</span> are available within Linux. If <em>/dev/mmcblk0p10</em> is the active partition, the update has to be written to <em>/dev/mmcblk0p11</em>, and vice versa.</p>
<h5 class="h5" id="ch00lev3_25"><strong>Recipe for Update File Generation</strong></h5>
<p class="noindent">SWUpdate’s firmware update files have the <em>.swu</em> extension. The <span class="literal">meta-swupdate</span> layer comes with a class that supports SWU filegeneration by Yocto based on artifacts previously built and stored in Yocto’s <em>deploy</em> directory. <a href="ch09.xhtml#ch09list07">Listing 9-7</a> shows the corresponding code for a Yocto recipe that automatically generates a valid and digitally signed SWU file.</p>
<pre class="pre"># Local files to be added to the SWU file&#13;
SRC_URI = "file://sw-description"&#13;
<span epub:type="pagebreak" id="page_174"/>&#13;
# Images to build before creating the SWU file&#13;
IMAGE_DEPENDS = "st-image-core"&#13;
&#13;
# Images to include within the SWU file&#13;
SWUPDATE_IMAGES = "st-image-core-openstlinux-eglfs"&#13;
&#13;
# Format of image to include&#13;
SWUPDATE_IMAGES_FSTYPES[st-image-core-openstlinux-eglfs] = ".ext4.gz"&#13;
&#13;
# SWU signing parameters&#13;
SWUPDATE_SIGNING = "RSA"&#13;
SWUPDATE_PRIVATE_KEY = "<span class="codeitalic1">path-to-signing-key</span>/swu_signing_key.pem"&#13;
SWUPDATE_PASSWORD_FILE = "<span class="codeitalic1">path-to-unlocking-passphrase</span>/passphrase"</pre>
<p class="list-title" id="ch09list07"><em>Listing 9-7: The recipe code that generates an SWU update file</em></p>
<p class="indent">The recipe adds the <em>sw-description</em> file created earlier and states the dependency on the <span class="literal">st-image-core</span> image. Within Yocto’s <em>deploy</em> directory, the desired update content (the device’s root filesystem) can be found in files starting with <em>st-image-core-openstlinux-eglfs</em>, while the target machine is added automatically by SWUpdate.</p>
<p class="indent">In contrast to SD card image creation, where the file with the <em>.ext4</em> extension is used (as shown in <a href="ch09.xhtml#ch09list02">Listing 9-2</a>), the firmware update should be as small as possible to optimize transfer times. Therefore, the compressed artifact with <em>.ext4.gz</em> is used for the SWU file. Finally, to enable firmware update signing, I set <span class="literal">SWUPDATE_SIGNING</span> to <span class="literal">"RSA"</span> and provided the paths to the private RSA signing key and its corresponding passphrase file.</p>
<p class="indent">Running this recipe ensures that the <span class="literal">st-image-core</span> image is built and then yields the <em>swupdate-swu-gen-openstlinux-eglfs-stm32mp1.swu</em> file within the <em>deploy</em> directory. This file is actually a copy-in-and-out (CPIO) archive that contains the <em>sw-description</em> file and its signature <em>sw-description.sig</em> file. Additionally, the compressed <em>st-image-core-openstlinux-eglfs-stm32mp1.ext4.gz</em> file is shipped within this archive, which contains the root filesystem.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>If you wonder why there isn’t any signature file for the root filesystem, remember that the</em> sw-description <em>file contains the hash of this image, which would change if anyone had tampered with it. The signature of the description file also protects the authenticity and integrity of the root filesystem.</em></p>
</div>
<h4 class="h4" id="ch00lev2_108"><strong><em>Device-Specific Customization</em></strong></h4>
<p class="noindent">Now let’s turn to the device, the update client, and the necessary customizations to make SWUpdate work properly.</p>
<h5 class="h5" id="ch00lev3_26"><strong>Update Daemon</strong></h5>
<p class="noindentb">To install SWUpdate’s device client and its web server components, <span class="literal">swupdate</span> and <span class="literal">swupdate-www</span> have to be added to ST’s core image. For configuration, <span epub:type="pagebreak" id="page_175"/>the first consideration on the device side is which update methods it should support. In general, SWUpdate provides three typical ways:</p>
<p class="hanga"><strong>Mongoose mode</strong>    This daemon provides a simple web interface to allow for manual updates over a network.</p>
<p class="hanga"><strong>Suricatta mode</strong>    In conjunction with Eclipse’s hawkBit, SWUpdate supports comprehensive OTA update setups that can be managed and controlled by a central server instance.</p>
<p class="hanga"><strong>Local install</strong>    If the SWU file is locally available (for example, on a USB flash drive), the update can be directly installed without requiring a network connection.</p>
<p class="indentt">For this case study, I’ve chosen the mongoose daemon. As the system at hand uses <span class="literal">systemd</span> for Linux service configuration and management, a service file (<em>swupdate.service</em>) can be created as shown in <a href="ch09.xhtml#ch09list08">Listing 9-8</a> and installed in the <em>/etc/systemd/system/</em> directory.</p>
<pre class="pre">[Unit]&#13;
Description=SWUpdate daemon&#13;
&#13;
[Service]&#13;
Type=simple&#13;
ExecStart=/usr/bin/swupdate -w '-r /www -p 8080' -e 'stable,rootfs-b'&#13;
&#13;
[Install]&#13;
WantedBy=multi-user.target</pre>
<p class="list-title" id="ch09list08"><em>Listing 9-8: A basic service file to start</em> <span class="codeitalic1">swupdate</span> <em>in mongoose mode after boot</em></p>
<p class="indent">SWUpdate’s binary is located at <em>/usr/bin/swupdate</em>. It can be started in mongoose daemon mode at system boot with the <span class="literal">-w</span> command line parameter. The <span class="literal">-r /www</span> and <span class="literal">-p 8080</span> arguments following in single quotes tell it to use the default web application located at <em>/www</em> and to bind its web server to port 8080.</p>
<p class="indent">The string provided after the <span class="literal">-e</span> option defines which part of the expected software collection should be installed in the case of an update. In the default scenario, where <span class="literal">rootfs-a</span> is the active partition, the daemon should be started with <span class="literal">-e 'stable,rootfs-b'</span> to make sure that a potential update is written to <span class="literal">rootfs-b</span>, the inactive partition.</p>
<p class="indent">Besides setting configuration options with command line arguments, you could also provide the <em>swupdate.cfg</em> configuration file at a path matching the client’s compile-time configuration—for example, <em>/etc/swupdate/</em>. As shown in <a href="ch09.xhtml#ch09list09">Listing 9-9</a>, logging parameters, paths to keys, and post-update shell scripts are typical settings you might want to place here.</p>
<pre class="pre"><span epub:type="pagebreak" id="page_176"/>globals :&#13;
{&#13;
    verbose = true;&#13;
    loglevel = 5;&#13;
    syslog = true;&#13;
    postupdatecmd = "/etc/swupdate/postupdate.sh";&#13;
    public-key-file = "/etc/swupdate/swu_verification_key.pem";&#13;
};</pre>
<p class="list-title" id="ch09list09"><em>Listing 9-9: An example configuration file for</em> <span class="codeitalic1">swupdate</span></p>
<p class="indent">However, whether you use command line arguments or a configuration file is mainly a matter of taste.</p>
<h5 class="h5" id="ch00lev3_27"><strong>Post-Update Tasks</strong></h5>
<p class="noindent">Every device, its architecture, and its update strategy is different. Therefore, a general tool like SWUpdate can’t automatically derive what to do before and after a firmware update is written to its corresponding memory device or partition. On the command line, the <span class="literal">-p</span> and <span class="literal">-P</span> parameters allow for defining paths to <em>post-update</em> and <em>pre-update</em> commands, respectively.</p>
<p class="indent">In my case, only a post-update routine was necessary to prepare the device for booting the new firmware version. <a href="ch09.xhtml#ch09list010">Listing 9-10</a> shows the contents of the <em>postupdate.sh</em> shell script that’s executed after the update installation, as defined in <em>swupdate.cfg</em>.</p>
<pre class="pre">   #!/bin/sh&#13;
&#13;
<span class="ent">➊</span> if grep -q PARTUUID=e91c4e10-16e6-4c0e-bd0e-77becf4a3582&#13;
           /boot/mmc0_extlinux/stm32mp157f-dk2_extlinux.conf; then&#13;
&#13;
      # Update swupdate service parameters&#13;
      mount PARTUUID=997046a6-c6f4-4f41-adb4-9fe614b2a92a /mnt&#13;
    <span class="ent">➋</span> sed -i 's/rootfs-b/rootfs-a/g' /mnt/etc/systemd/system/swupdate.service&#13;
      umount /mnt&#13;
&#13;
      # Update rootfs boot parameter in extlinux.conf&#13;
    <span class="ent">➌</span> sed -i 's/PARTUUID=e91c4e10-16e6-4c0e-bd0e-77becf4a3582/&#13;
                 PARTUUID=997046a6-c6f4-4f41-adb4-9fe614b2a92a/g'&#13;
          /boot/mmc0_extlinux/stm32mp157f-dk2_extlinux.conf&#13;
&#13;
else&#13;
&#13;
      # Update swupdate service parameters&#13;
      mount PARTUUID=e91c4e10-16e6-4c0e-bd0e-77becf4a3582 /mnt&#13;
      sed -i 's/rootfs-a/rootfs-b/g' /mnt/etc/systemd/system/swupdate.service&#13;
      umount /mnt&#13;
  <span epub:type="pagebreak" id="page_177"/>    # Update rootfs boot parameter in extlinux.conf&#13;
      sed -i 's/PARTUUID=997046a6-c6f4-4f41-adb4-9fe614b2a92a/&#13;
                PARTUUID=e91c4e10-16e6-4c0e-bd0e-77becf4a3582/g'&#13;
          /boot/mmc0_extlinux/stm32mp157f-dk2_extlinux.conf&#13;
   fi&#13;
&#13;
<span class="ent">➍</span> reboot</pre>
<p class="list-title" id="ch09list010"><em>Listing 9-10: A script to prepare a device for booting the updated firmware</em></p>
<p class="indent">The first <span class="literal">if</span> statement <span class="ent">➊</span> checks whether the board’s U-Boot configuration file, <em>stm32mp157f-dk2_extlinux.conf</em>, located at <em>/boot/mmc0_extlinux/</em>, contains the default partition UUID <span class="literal">e91c4e10-16e6-4c0e-bd0e-77becf4a3582</span>. If so, <span class="literal">rootfs-a</span> is the active partition, and the update was just written to <span class="literal">rootfs-b</span>. Therefore, the <em>swupdate.service</em> configuration file on the new partition has to be set to update the soon-to-be-inactive partition, <span class="literal">rootfs-a</span> <span class="ent">➋</span>.</p>
<p class="indent">Afterward, the partition UUID in U-Boot’s configuration file is replaced by the one representing <span class="literal">rootfs-b</span> <span class="ent">➌</span>. This ensures that U-Boot starts the Linux kernel with the new root filesystem. If anything fails before this operation or a power loss occurs, the device will just boot into the existing firmware. But if everything goes well, the partition for the root filesystem is swapped and the device is deliberately rebooted <span class="ent">➍</span>. Of course, the same procedure works the opposite way if the script detects that <span class="literal">rootfs-b</span> is the active partition.</p>
<p class="indent">Obviously, this is just one possible implementation of a post-update script that works for the specific architecture in this case study. Your device might require completely different reconfigurations before or after installing a firmware update.</p>
<h4 class="h4" id="ch00lev2_109"><strong><em>Update Process Evaluation</em></strong></h4>
<p class="noindent">To conclude this case study, I flashed the previously created 2GB image to a 16GB microSD card and booted my STM32MP157F-DK2 board from it. First, I checked which root filesystem partition was currently active. <a href="ch09.xhtml#ch09list011">Listing 9-11</a> shows that both copies A (<span class="literal">mmcblk0p10</span>) and B (<span class="literal">mmcblk0p11</span>) are available and correctly sized. The slash at the right end of the line indicates that <span class="literal">rootfs-a</span> is currently mounted as the root filesystem.</p>
<pre class="pre"># <span class="codestrong1">lsblk</span>&#13;
NAME         MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS&#13;
mmcblk0      179:0    0  14.4G  0 disk &#13;
...&#13;
|-mmcblk0p10 179:10   0   768M  0 part /&#13;
|-mmcblk0p11 179:11   0   768M  0 part&#13;
...</pre>
<p class="list-title" id="ch09list011"><em>Listing 9-11: The</em> <span class="codeitalic1">mmcblk0p10</span> <em>partition mounted as the root filesystem</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_178"/>As a second step, I printed the logs of the installed <span class="literal">swupdate</span> daemon. <a href="ch09.xhtml#ch09list012">Listing 9-12</a> shows selected lines of the output.</p>
<pre class="pre">   # <span class="codestrong1">journalctl -u swupdate.service</span>&#13;
<span class="ent">➊</span> Apr 28 21:34:54 stm32mp1 systemd[1]: Started SWUpdate daemon.&#13;
   ...&#13;
   Apr 28 21:34:54 stm32mp1 swupdate[520]: [INFO ] : SWUPDATE running :&#13;
       <span class="ent">➋</span> [main] : Running on stm32mp157f-dk2 Revision C02 &#13;
   ...&#13;
   Apr 28 21:34:54 stm32mp1 swupdate[520]: [INFO ] : SWUPDATE running :&#13;
       <span class="ent">➌</span> [main] : software set: stable mode: rootfs-b&#13;
   ...&#13;
   Apr 28 21:34:54 stm32mp1 swupdate[520]: [INFO ] : SWUPDATE running :&#13;
          [start_mongoose] : Mongoose web server version 7.8 with pid 533&#13;
       <span class="ent">➍</span> started on [0.0.0.0:8080] with web root [/www]&#13;
   ...</pre>
<p class="list-title" id="ch09list012"><em>Listing 9-12: The</em> <span class="codeitalic1">swupdate</span> <em>service logs</em></p>
<p class="indent">The result indicates that the daemon started <span class="ent">➊</span> and the board as well, as the hardware revision was read correctly <span class="ent">➋</span>. Further, the configuration that a potential update should be written to <span class="literal">rootfs-b</span> <span class="ent">➌</span> is shown as desired. In addition, the start of the included web server with the configured port and given directory is confirmed <span class="ent">➍</span>.</p>
<p class="indent">I used a common browser to connect to the device’s IP address on port 8080, and it immediately showed the default web interface of SWUpdate. There, the SWU file created by Yocto could be uploaded to the device, and a progress bar showed the percentage of update completion. Shortly after reaching 100 percent, the device rebooted as expected, and a second look at <span class="literal">lsblk</span>, as shown in <a href="ch09.xhtml#ch09list013">Listing 9-13</a>, indicated that the swapping from copy A to copy B succeeded. The second update attempt also worked successfully and swapped the root filesystem back to <span class="literal">mmcblk0p10</span>.</p>
<pre class="pre"># <span class="codestrong1">lsblk</span>&#13;
NAME         MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS&#13;
mmcblk0      179:0    0  14.4G  0 disk &#13;
...&#13;
|-mmcblk0p10 179:10   0   768M  0 part &#13;
|-mmcblk0p11 179:11   0   768M  0 part /&#13;
...</pre>
<p class="list-title" id="ch09list013"><em>Listing 9-13: The</em> <span class="codeitalic1">mmcblk0p11</span> <em>partition mounted as the root filesystem after the update</em></p>
<p class="indent">Finally, to test digital signature verification, I also tried to maliciously modify the firmware update file by extracting the original files, changing the target partition of <span class="literal">rootfs-a</span> to <span class="literal">/dev/mmcblk0p9</span>, and combining the modified files into a valid CPIO archive again. However, when uploading over <span epub:type="pagebreak" id="page_179"/>the web interface, it soon responds with the message <span class="literal">Update failed</span>. Looking at the log data on the device shows that the signature verification failed as expected (<a href="ch09.xhtml#ch09list014">Listing 9-14</a>).</p>
<pre class="pre"># <span class="codestrong1">journalctl -u swupdate.service</span>&#13;
...&#13;
Apr 29 04:03:57 stm32mp1 swupdate[520]: [TRACE] : SWUPDATE running :&#13;
       [swupdate_verify_file] : Verify signed image: Read 581 bytes&#13;
Apr 29 04:03:57 stm32mp1 swupdate[520]: [ERROR] : SWUPDATE failed [0] ERROR :&#13;
       EVP_DigestVerifyFinal failed, error 0x2000068 0&#13;
Apr 29 04:03:57 stm32mp1 swupdate[520]: [TRACE] : SWUPDATE running :&#13;
       [swupdate_verify_file] : Error Verifying Data&#13;
...</pre>
<p class="list-title" id="ch09list014"><em>Listing 9-14: The signature verification fails for the modified firmware update.</em></p>
<p class="indent">Testing software update verification routines for their correct <em>rejection behavior</em> is not only valuable during development. It also makes absolute sense to integrate similar test cases into release or production testing, because it wouldn’t be the first time that verification got switched off by accident.</p>
<h3 class="h3" id="ch00lev1_79"><strong>Summary</strong></h3>
<p class="noindent">Providing software and firmware updates for devices doesn’t seem like a very difficult task at first glance. However, if all requirements regarding security, scalability, and reliability are considered, it becomes a complex topic that impacts development pipelines, nonvolatile memory layouts, backend services, and customer processes.</p>
<p class="indent">This chapter stressed the inevitable need to provide secure update mechanisms for all kinds of IoT devices because none of them is perfect, and at some point, manufacturers as well as customers will demand firmware updates that have to be distributed and applied securely and must not break the device. To achieve these requirements, manufacturers have to ensure authenticity and integrity protection, they have to discuss update formats and granularity, and the memory partitioning has to support atomic and fail-safe update procedures. Also, backend servers that schedule, distribute, and monitor update deployments in the field have to be operated.</p>
<p class="indent">If you still think it’s all too much for you to handle, and maybe your devices will never need any updates because that was the case during past decades, pull out the risk analysis for your networked device and reconsider the impact ratings in the event that you wouldn’t be able to fix vulnerabilities. Also, make sure you add “update misuse” to your list of threats if you’re going with an update mechanism that resembles an invitation for adversaries to install their custom software.<span epub:type="pagebreak" id="page_180"/></p>
</div></body></html>