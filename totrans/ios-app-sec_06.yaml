- en: '**4**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**4**'
- en: '**BUILDING YOUR TEST PLATFORM**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**构建你的测试平台**'
- en: In this chapter, I’ll outline the tools you need to review your code and test
    your iOS applications, and I’ll show you how to build a robust and useful test
    platform. That test platform will include a properly set up Xcode instance, an
    interactive network proxy, reverse engineering tools, and tools to bypass iOS
    platform security checks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将概述你需要的工具，以便回顾你的代码并测试 iOS 应用程序，并展示如何构建一个强大而有用的测试平台。该测试平台将包括一个正确设置的 Xcode
    实例、一个互动的网络代理、反向工程工具，以及绕过 iOS 平台安全检查的工具。
- en: I’ll also cover the settings you need to change in Xcode projects to make bugs
    easier to identify and fix. You’ll then learn to leverage Xcode’s static analyzer
    and compiler options to produce well-protected binaries and perform more in-depth
    bug detection.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我还会讲解你需要在 Xcode 项目中更改的设置，以便更容易地识别和修复 bug。你将学习如何利用 Xcode 的静态分析器和编译器选项，生成高度保护的二进制文件，并进行更深入的
    bug 检测。
- en: '**Taking Off the Training Wheels**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**去掉训练轮**'
- en: 'A number of behaviors in a default OS X install prevent you from really digging
    in to the system internals. To get your OS to stop hiding the things you need,
    enter the following commands at a Terminal prompt:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 OS X 安装中有一些行为会阻止你深入系统内部。要让你的操作系统停止隐藏你需要的内容，在终端提示符下输入以下命令：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These settings let you see all the files in the Finder, even ones that are hidden
    from view because they have a dot in front of their name. In addition, these changes
    will display more path information and file extensions, and most importantly,
    they allow you to see your user-specific *Library*, which is where the iOS Simulator
    will store all of its data.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置允许你在 Finder 中查看所有文件，包括那些由于名称前有点（.）而被隐藏的文件。此外，这些更改将显示更多的路径信息和文件扩展名，最重要的是，它们让你能够看到你特定用户的
    *Library*，这是 iOS 模拟器存储所有数据的地方。
- en: The `chflags` command removes a level of obfuscation that Apple has put on directories
    that it considers too complicated for you, such as */tmp* or */usr*. I’m using
    the command here to show the contents of the iOS Simulator directories without
    having to use the command line every time.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`chflags` 命令移除苹果公司对某些目录设置的模糊化保护，这些目录被认为对你来说过于复杂，例如 */tmp* 或 */usr*。我在这里使用该命令，以便在不每次都使用命令行的情况下查看
    iOS 模拟器目录的内容。'
- en: 'One other thing: consider adding *$SIMPATH* to the Finder’s sidebar for easy
    access. It’s convenient to use *$SIMPATH* to examine the iOS Simulator’s filesystem,
    but you can’t get to it in the Finder by default. To make this change, browse
    to the following directory in the Terminal:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件事：考虑将 *$SIMPATH* 添加到 Finder 的侧边栏，以便轻松访问。使用 *$SIMPATH* 来查看 iOS 模拟器的文件系统非常方便，但默认情况下你无法通过
    Finder 访问它。要进行此更改，请在终端中浏览到以下目录：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Then, in the Finder window that opens, drag the iPhone Simulator directory to
    the sidebar. Once you’re riding without training wheels, it’s time to choose your
    testing device.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在打开的 Finder 窗口中，将 iPhone 模拟器目录拖到侧边栏。一旦你不再依赖训练轮，便可以选择你的测试设备。
- en: '**Suggested Testing Devices**'
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**建议的测试设备**'
- en: My favorite test device is the Wi-Fi only iPad because it’s inexpensive and
    easy to jailbreak, which allows for testing iPad, iPhone, and iPod Touch applications.
    Its lack of cellular-based networking isn’t much of a hindrance, given that you’ll
    want to intercept network traffic most of the time anyway.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我最喜欢的测试设备是仅支持 Wi-Fi 的 iPad，因为它价格便宜，且容易越狱，这样就可以测试 iPad、iPhone 和 iPod Touch 应用程序。它缺少基于蜂窝的网络连接，这并不会构成太大障碍，因为大部分时间你都需要截取网络流量。
- en: But this configuration does have some minor limitations. Most significantly,
    the iPad doesn’t have GPS or SMS, and it obviously doesn’t make phone calls. So
    it’s not a bad idea to have an actual iPhone of some kind available.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种配置确实有一些小的限制。最显著的是，iPad 没有 GPS 或短信功能，显然也不能打电话。因此，手头有一台实际的 iPhone 作为备用是个不错的主意。
- en: 'I prefer to have at least two iPads handy for iOS testing: one jailbroken and
    one stock. The stock device allows for testing in a legitimate, realistic end-user
    environment, and it has all platform security mechanisms still intact. It can
    also register properly for push notifications, which has proven problematic for
    jailbroken devices in the past. The jailbroken device allows you to more closely
    inspect the filesystem layout and more detailed workings of iOS; it also facilitates
    black-box testing that wouldn’t be feasible using a stock device alone.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我倾向于为 iOS 测试准备至少两台 iPad：一台越狱设备和一台正常设备。正常设备允许在合法、现实的终端用户环境中进行测试，并且所有平台安全机制仍然保持完好。它还可以正确注册推送通知，而越狱设备过去在这方面经常出现问题。越狱设备则可以让你更深入地检查文件系统布局以及
    iOS 的更详细工作原理；它还便于进行黑盒测试，这些测试在仅使用正常设备时是无法实现的。
- en: '**Testing with a Device vs. Using a Simulator**'
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用设备测试与使用模拟器测试**'
- en: Unlike some other mobile operating systems, iOS development uses a *simulator*
    rather than an emulator. This means there’s no full emulation of the iOS device
    because that would require a virtualized ARM environment. Instead, the simulators
    that Apple distributes with Xcode are compiled for the x64 architecture, and they
    run natively on your development machine, which makes the process significantly
    faster and easier. (Try to boot the Android emulator inside a virtual machine,
    and you’ll appreciate this feature.)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他一些移动操作系统不同，iOS 开发使用的是 *模拟器* 而非仿真器。这意味着 iOS 设备没有完全的仿真，因为这需要一个虚拟化的 ARM 环境。相反，Apple
    与 Xcode 一起分发的模拟器是为 x64 架构编译的，它们直接在你的开发机器上运行，这使得开发过程显著更快、更简单。（试试在虚拟机中启动 Android
    仿真器，你就会更能理解这一特点。）
- en: 'On the flip side, some things simply don’t work the same way in the iOS Simulator
    as they do on the device. The differences are as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，有些事情在 iOS 模拟器中并不像在设备上那样工作。它们的差异如下：
- en: '**Case-sensitivity** Unless you’ve intentionally changed this behavior, OS
    X systems operate with case-insensitive HFS+ filesystems, while iOS uses the case-sensitive
    variant. This should rarely be relevant to security but can cause interoperability
    issues when modifying programs.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**大小写敏感性** 除非你故意更改了这一行为，否则 OS X 系统使用的是不区分大小写的 HFS+ 文件系统，而 iOS 使用的是区分大小写的变种。这通常与安全性无关，但在修改程序时可能会导致互操作性问题。'
- en: '**Libraries** In some cases, iOS Simulator binaries link to OS X frameworks
    that may behave differently than those on iOS. This can result in slightly different
    behavior.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**库** 在某些情况下，iOS 模拟器的二进制文件链接到 OS X 框架，这些框架的行为可能与 iOS 上的不同。这可能导致稍微不同的行为。'
- en: '**Memory and performance** Since applications run natively in the iOS Simulator,
    they’ll be taking full advantage of your development machine’s resources. When
    gauging the impact of things such as PBKDF2 rounds (see [Chapter 13](ch13.html#ch13)),
    you’ll want to compensate for this or test on a real device.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存和性能** 由于应用程序在 iOS 模拟器中原生运行，它们将充分利用你开发机器的资源。在衡量诸如 PBKDF2 轮次（参见[第13章](ch13.html#ch13)）的影响时，你需要考虑到这一点，或者在真实设备上进行测试。'
- en: '**Camera** As of now, the iOS Simulator does not use your development machine’s
    camera. This is rarely a huge issue, but some applications do contain functionality
    such as “Take a picture of my check stub or receipt,” where the handling of this
    photo data can be crucial.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**相机** 截至目前，iOS 模拟器并不使用你开发机器的相机。这通常不会是个大问题，但某些应用程序确实包含例如“拍摄我的支票存根或收据”这样的功能，其中处理这些照片数据可能至关重要。'
- en: '**SMS and cellular** You can’t test interaction with phone calls or SMS integration
    with the iOS Simulator, though you can technically simulate some aspects, such
    as toggling the “in-call” status bar.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**短信和蜂窝网络** 你无法在 iOS 模拟器中测试与电话呼叫或 SMS 集成的交互，尽管你可以在技术上模拟某些方面，例如切换“通话中”状态栏。'
- en: Unlike in older versions of iOS, modern versions of the iOS Simulator do in
    fact simulate the Keychain API, meaning you can manage your own certificate and
    store and manipulate credentials. You can find the files behind this functionality
    in *$SIMPATH/Library/Keychains*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与旧版本的 iOS 不同，现代版本的 iOS 模拟器实际上模拟了 Keychain API，这意味着你可以管理自己的证书并存储和操作凭证。你可以在 *$SIMPATH/Library/Keychains*
    中找到与此功能相关的文件。
- en: '**Network and Proxy Setup**'
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**网络和代理设置**'
- en: Most of the time, the first step in testing any iOS application is to run it
    through a proxy so you can examine and potentially modify traffic going from the
    device to its remote endpoint. Most iOS security testers I know use BurpSuite^([1](footnote.html#fn23))
    for this purpose.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，测试任何 iOS 应用的第一步是通过代理运行它，这样你可以检查并可能修改从设备到远程端点的流量。我认识的大多数 iOS 安全测试人员都使用
    BurpSuite^([1](footnote.html#fn23)) 来执行这项任务。
- en: '***Bypassing TLS Validation***'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***绕过 TLS 验证***'
- en: 'There’s one major catch to running an app under test through a proxy: iOS resolutely
    refuses to continue TLS/SSL connections when it cannot authenticate the server’s
    certificate, as well it should. This is, of course, the correct behavior, but
    your proxy-based testing will screech to a halt rather quickly if iOS can’t authenticate
    your proxy’s certificate.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过代理运行待测试应用时，有一个主要的难点：当 iOS 无法验证服务器的证书时，它会坚决拒绝继续 TLS/SSL 连接，这也是它应该这样做的。当然，这是正确的行为，但如果
    iOS 无法验证你的代理证书，你的基于代理的测试很快就会中断。
- en: For BurpSuite specifically, you can obtain a CA certificate simply by configuring
    your device or iOS Simulator to use Burp as a proxy and then browsing to *[http://burp/cert/](http://burp/cert/)*
    in Mobile Safari. This should work either on a real device or in the iOS Simulator.
    You can also install CA certificates onto a physical device by either emailing
    them to yourself or navigating to them on a web server.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 BurpSuite，具体来说，你可以通过将设备或 iOS 模拟器配置为使用 Burp 作为代理，然后在 Mobile Safari 中浏览 *[http://burp/cert/](http://burp/cert/)*
    来获取 CA 证书。这无论是在真实设备还是在 iOS 模拟器中都应该有效。你也可以通过将证书通过邮件发送给自己或通过 web 服务器访问它们来将 CA 证书安装到物理设备上。
- en: 'For the iOS Simulator, a more general approach that works with almost any web
    proxy is to add the fingerprint of your proxy software’s CA certificate directly
    into the iOS Simulator trust store. The trust store is a SQLite database, making
    it slightly more cumbersome to edit than typical certificate bundles. I recommend
    writing a script to automate this task. If you want to see an example to get you
    started, Gotham Digital Science has already created a Python script that does
    the job. You’ll find the script here: *[https://github.com/GDSSecurity/Add-Trusted-Certificate-to-iOS-Simulator/](https://github.com/GDSSecurity/Add-Trusted-Certificate-to-iOS-Simulator/)*.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 iOS 模拟器，一种适用于几乎所有 web 代理的更通用方法是将代理软件的 CA 证书指纹直接添加到 iOS 模拟器的信任存储中。信任存储是一个
    SQLite 数据库，因此它比典型的证书包稍微难以编辑。我建议编写脚本来自动化此任务。如果你想看看一个示例来开始，Gotham Digital Science
    已经创建了一个 Python 脚本来完成这项工作。你可以在这里找到这个脚本：*[https://github.com/GDSSecurity/Add-Trusted-Certificate-to-iOS-Simulator/](https://github.com/GDSSecurity/Add-Trusted-Certificate-to-iOS-Simulator/)*。
- en: To use this script, you need to obtain the CA certificate you want to install
    into the trust store. First configure Firefox^([2](footnote.html#fn24)) to use
    your local proxy (127.0.0.1, port 8080 for Burp). Then attempt to visit any SSL
    site; you should get a familiar certificate warning. Navigate to **Add Exception**
    → **View** → **Details** and click the **PortSwigger CA** entry, as shown in [Figure
    4-1](ch04.html#ch4fig1).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此脚本，你需要获取你想要安装到信任存储中的 CA 证书。首先，配置 Firefox^([2](footnote.html#fn24)) 使用你的本地代理（127.0.0.1，Burp
    的端口是 8080）。然后尝试访问任何 SSL 网站，你应该会看到一个熟悉的证书警告。导航至 **添加例外** → **查看** → **详细信息** 并点击
    **PortSwigger CA** 条目，如 [图 4-1](ch04.html#ch4fig1) 所示。
- en: 'Click **Export** and follow the prompts. Once you’ve saved the CA certificate,
    open *Terminal.app* and run the Python script to add the certificate to the store
    as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **导出** 并按照提示操作。保存 CA 证书后，打开 *Terminal.app* 并运行 Python 脚本，将证书添加到存储中，如下所示：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Unfortunately, at the time of writing, there isn’t a native way to configure
    the iOS Simulator to go through an HTTP proxy without also routing the rest of
    your system through the proxy. Therefore, you’ll need to configure the proxy in
    your host system’s Preferences, as shown in [Figure 4-2](ch04.html#ch4fig2).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在撰写本文时，没有原生的方法可以配置 iOS 模拟器通过 HTTP 代理运行，而不同时将你系统的其他部分也通过该代理。因此，你需要在主机系统的偏好设置中配置代理，如
    [图 4-2](ch04.html#ch4fig2) 所示。
- en: If you’re using the machine for both testing and other work activities, you
    might consider specifically configuring other applications to go through a separate
    proxy, using something like FoxyProxy^([3](footnote.html#fn25)) for your browser.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这台机器同时用于测试和其他工作活动，你可以考虑专门配置其他应用程序通过单独的代理进行连接，使用像 FoxyProxy^([3](footnote.html#fn25))
    这样的工具为浏览器设置代理。
- en: '![image](graphics/f04-01.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f04-01.jpg)'
- en: '*Figure 4-1: Selecting the PortSwigger CA for export*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-1：选择 PortSwigger CA 进行导出*'
- en: '![image](graphics/f04-02.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f04-02.jpg)'
- en: '*Figure 4-2: Configuring the host system to connect via Burp*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-2：配置主机系统通过Burp连接*'
- en: '***Bypassing SSL with stunnel***'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用stunnel绕过SSL***'
- en: One method of bypassing SSL endpoint verification is to set up a termination
    point locally and then direct your application to use that instead. You can often
    accomplish this without recompiling the application, simply by modifying a plist
    file containing the endpoint URL.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 绕过SSL端点验证的一种方法是本地设置一个终结点，然后让你的应用程序使用该终结点。通常可以通过修改包含端点URL的plist文件，而无需重新编译应用程序，来实现这一点。
- en: 'This setup is particularly useful if you want to observe traffic easily in
    plaintext (for example, with Wireshark), but the Internet-accessible endpoint
    is available only over HTTPS. First, download and install stunnel,^([4](footnote.html#fn26))
    which will act as a broker between the HTTPS endpoint and your local machine.
    If installed via Homebrew, stunnel’s configuration file will be in */usr/local/etc/stunnel/stunnel.conf-sample*.
    Move or copy this file to */usr/local/etc/stunnel/stunnel.conf* and edit it to
    reflect the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想通过明文轻松观察流量（例如，使用Wireshark），但互联网可访问的端点仅通过HTTPS提供，那么这个设置特别有用。首先，下载并安装stunnel，^([4](footnote.html#fn26))，它将作为HTTPS端点和你的本地机器之间的代理。如果通过Homebrew安装，stunnel的配置文件将在*/usr/local/etc/stunnel/stunnel.conf-sample*。将此文件移动或复制到*/usr/local/etc/stunnel/stunnel.conf*，并编辑以反映以下内容：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This simply sets up stunnel in client mode, instructing it to accept connections
    on your loopback interface on port 80, while forwarding them to the remote endpoint
    over SSL. After editing this file, set up Burp so that it uses your loopback listener
    as a proxy, making sure to select the **Support invisible proxying** option, as
    shown in [Figure 4-3](ch04.html#ch4fig3). [Figure 4-4](ch04.html#ch4fig4) shows
    the resulting setup.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是将stunnel设置为客户端模式，指示它在你的回环接口上接受端口80的连接，同时通过SSL将其转发到远程端点。编辑完该文件后，设置Burp以使其使用你的回环监听器作为代理，确保选择**支持隐形代理**选项，如[图4-3](ch04.html#ch4fig3)所示。[图4-4](ch04.html#ch4fig4)展示了结果设置。
- en: '![image](graphics/f04-03.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f04-03.jpg)'
- en: '*Figure 4-3: Setting up invisible proxying through the local stunnel endpoint*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-3：通过本地stunnel端点设置隐形代理*'
- en: '![image](graphics/f04-04.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f04-04.jpg)'
- en: '*Figure 4-4: Final Burp/stunnel setup*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-4：最终的Burp/stunnel设置*'
- en: '***Certificate Management on a Device***'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***设备上的证书管理***'
- en: To install a certificate on a physical iOS device, simply email the certificate
    to an account associated with the device or put it on a public web server and
    navigate to it using Mobile Safari. You can then import it into the device’s trust
    store, as shown in [Figure 4-5](ch04.html#ch4fig5). You can also configure your
    device to go through a network proxy (that is, Burp) hosted on another machine.
    Simply install the CA certificate (as described earlier) of the proxy onto the
    device and configure your proxy to listen on a network-accessible IP address,
    as in [Figure 4-6](ch04.html#ch4fig6).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要在物理iOS设备上安装证书，只需将证书发送到与设备关联的帐户，或将其放在公共Web服务器上，然后使用Mobile Safari导航到该证书。然后，你可以将其导入设备的信任存储中，如[图4-5](ch04.html#ch4fig5)所示。你还可以配置设备通过另一台机器托管的网络代理（即Burp）。只需将代理的CA证书（如前所述）安装到设备上，并配置你的代理在网络可访问的IP地址上监听，如[图4-6](ch04.html#ch4fig6)所示。
- en: '![image](graphics/f04-05.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f04-05.jpg)'
- en: '*Figure 4-5: The certificate import prompt*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-5：证书导入提示*'
- en: '![image](graphics/f04-06.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f04-06.jpg)'
- en: '*Figure 4-6: Configuring Burp to use a nonlocalhost IP address*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-6：配置Burp使用非localhost的IP地址*'
- en: '***Proxy Setup on a Device***'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***设备上的代理设置***'
- en: Once you’ve configured your certificate authorities and set up the proxy, go
    to **Settings** → **Network** → **Wi-Fi** and click the arrow to the right of
    your currently selected wireless network. You can enter the proxy address and
    port from this screen (see [Figure 4-7](ch04.html#ch4fig7)).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 配置好证书颁发机构并设置好代理后，进入**设置** → **网络** → **Wi-Fi**，点击当前选择的无线网络右侧的箭头。在这个界面上，你可以输入代理地址和端口（见[图4-7](ch04.html#ch4fig7)）。
- en: '![image](graphics/f04-07.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f04-07.jpg)'
- en: '*Figure 4-7: Configuring the device to use a test proxy on an internal network*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-7：配置设备在内部网络上使用测试代理*'
- en: 'Note that when configuring a device to use a proxy, only connections initiated
    by `NSURLConnection` or `NSURLSession` will obey the proxy settings; other connections
    such as `NSStream` and `CFStream` (which I’ll discuss further in [Chapter 7](ch07.html#ch07))
    will not. And of course, since this is an HTTP proxy, it works only for HTTP traffic.
    If you have an application using `CFStream`, you can edit the codebase with the
    following code snippet to route stream traffic through the same proxy as the host
    OS:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当配置设备使用代理时，只有通过`NSURLConnection`或`NSURLSession`发起的连接才会遵循代理设置；其他连接，如`NSStream`和`CFStream`（我将在[第7章](ch07.html#ch07)中进一步讨论），则不会受到影响。当然，由于这是一个HTTP代理，它仅适用于HTTP流量。如果你有一个使用`CFStream`的应用程序，你可以通过以下代码片段修改代码库，将流量通过与主机操作系统相同的代理路由：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you’re using `NSStream`, you can accomplish the same by casting the `NSInputStream`
    and `NSOutputStream` to their Core Foundation counterparts, like so:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用`NSStream`，可以通过将`NSInputStream`和`NSOutputStream`转换为其Core Foundation对应物来完成相同的操作，如下所示：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you’re doing black-box testing and have an app that refuses to honor system
    proxy settings for HTTP requests, you can attempt to direct traffic through a
    proxy by adding a line to */etc/hosts* on the device to point name lookups to
    your proxy address, as shown in [Listing 4-1](ch04.html#ch4ex1).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在进行黑盒测试，并且有一个应用程序不遵循系统代理设置进行HTTP请求，你可以尝试通过在设备的*/etc/hosts*文件中添加一行，将名称查找指向你的代理地址，从而将流量通过代理转发，如[清单4-1](ch04.html#ch4ex1)所示。
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 4-1: Adding a hosts file entry*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单4-1：添加hosts文件条目*'
- en: 'You can also configure the device to use a DNS server controlled by you, which
    doesn’t require jailbreaking your test device. One way to do this is to use Tim
    Newsham’s dnsRedir,^([5](footnote.html#fn27)) a Python script that will provide
    a spoofed answer for DNS queries of a particular domain, while passing on queries
    for all other domains to another DNS server (by default, 8.8.8.8, but you can
    change this with the `-d` flag). The script can be used as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以配置设备使用由你控制的DNS服务器，这不需要越狱你的测试设备。做到这一点的一种方式是使用Tim Newsham的dnsRedir，^([5](footnote.html#fn27))
    这是一个Python脚本，它将为特定域的DNS查询提供伪造的答案，同时将其他域的查询传递给另一个DNS服务器（默认是8.8.8.8，但你可以通过`-d`标志更改此设置）。可以按如下方式使用该脚本：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This should answer queries for *[www.evil.com](http://www.evil.com)* with the
    IP address 1.2.3.4, where that IP address should usually be the IP address of
    the test machine you’re proxying data through.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该使用IP地址1.2.3.4来回答* [www.evil.com](http://www.evil.com) *的查询，其中该IP地址通常应为你正在通过其代理数据的测试机器的IP地址。
- en: For non-HTTP traffic, things are a little more involved. You’ll need to use
    a TCP proxy to intercept traffic. The aforementioned Tim Newsham has written a
    program that can make this simpler—the aptly named tcpprox.^([6](footnote.html#fn28))
    If you use the `hosts` file method in [Listing 4-1](ch04.html#ch4ex1) to point
    the device to your proxy machine, you can then have tcpprox dynamically create
    SSL certificates and proxy the connection to the remote endpoint. To do this,
    you’ll need to create a certificate authority certificate and install it on the
    device, as shown in [Listing 4-2](ch04.html#ch4ex2).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非HTTP流量，事情就有些复杂了。你需要使用TCP代理来拦截流量。前面提到的Tim Newsham编写了一个程序，可以简化这一过程——它的名字恰如其分，叫做tcpprox。^([6](footnote.html#fn28))
    如果你使用[清单4-1](ch04.html#ch4ex1)中的`hosts`文件方法将设备指向你的代理机器，那么你可以让tcpprox动态创建SSL证书，并将连接代理到远程端点。为此，你需要创建一个证书颁发机构证书并将其安装在设备上，如[清单4-2](ch04.html#ch4ex2)所示。
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 4-2: Creating a certificate and using tcpprox to intercept traffic*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单4-2：创建证书并使用tcpprox拦截流量*'
- en: 'The *ca.py* script creates the signed certificate, and the *pkcs12.sh* script
    produces the certificate to install on the device, the same as shown in [Figure
    4-5](ch04.html#ch4fig5). After running these and installing the certificate, your
    application should connect to the remote endpoint using the proxy, even for SSL
    connections. Once you’ve performed some testing, you can read the results with
    the *proxcat.py* script included with tcpprox, as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*ca.py*脚本创建签名证书，*pkcs12.sh*脚本生成要安装在设备上的证书，如[图4-5](ch04.html#ch4fig5)所示。运行这些脚本并安装证书后，即使是SSL连接，你的应用程序也应该通过代理连接到远程端点。完成一些测试后，你可以使用tcpprox附带的*proxcat.py*脚本读取结果，方法如下：'
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Once your application is connected through a proxy, you can start setting up
    your Xcode environment.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的应用程序通过代理连接，你就可以开始设置Xcode环境了。
- en: '**Xcode and Build Setup**'
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Xcode和构建设置**'
- en: Xcode contains a twisty maze of project configuration options—hardly anyone
    understands what each one does. This section takes a closer look at these options,
    discusses why you would or wouldn’t want them, and shows you how to get Xcode
    to help you find bugs before they become real problems.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode包含一个错综复杂的项目配置选项迷宫——几乎没有人真正理解每个选项的作用。本节将更深入地探讨这些选项，讨论你为什么要或不应该使用它们，并向你展示如何让Xcode在问题变成真正的麻烦之前帮助你找到错误。
- en: '***Make Life Difficult***'
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***让生活变得艰难***'
- en: 'First things first: treat warnings as errors. Most of the warnings generated
    by clang, Xcode’s compiler frontend, are worth paying attention to. Not only do
    they often help reduce code complexity and ensure correct syntax, they also catch
    a number of errors that might be hard to spot, such as signedness issues or format
    string flaws. For example, consider the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，最重要的是：将警告视为错误。clang生成的大多数警告，作为Xcode的编译器前端，值得关注。它们不仅有助于减少代码复杂性和确保语法正确，还能捕捉一些可能难以发现的错误，例如符号问题或格式字符串缺陷。例如，考虑以下代码：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `count` method of `NSArray` returns an unsigned integer, (`NSUInteger`).
    If you were expecting the number of desired tribbles from user input, a submitted
    value might be –1, presumably indicating that the user would prefer to have an
    anti-tribble. Because `desired` is an integer being compared to an unsigned integer,
    the compiler will treat both as unsigned integers. Therefore, this method would
    unexpectedly allocate an absurd number of tribbles because –1 is an extremely
    large number when converted to an unsigned integer. I’ll discuss this type of
    integer overflow issue further in [Chapter 11](ch11.html#ch11).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSArray`的`count`方法返回一个无符号整数（`NSUInteger`）。如果你期望从用户输入中得到所需的tribbles数量，提交的值可能是-1，这大概意味着用户希望拥有一个反tribble。因为`desired`是一个整数，与一个无符号整数进行比较，编译器会把它们都当作无符号整数来处理。因此，这个方法会意外地分配一个荒谬数量的tribbles，因为-1在转换为无符号整数时会变成一个极大的数字。我将在[第
    11 章](ch11.html#ch11)进一步讨论这类整数溢出问题。'
- en: 'You can have clang flag this type of of bug by enabling most warnings and treating
    them as errors, in which case your build would fail with a message indicating
    `"Comparison of integers of different signs: ''int'' and ''NSUInteger'' (aka ''unsigned
    int'')"`.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过启用大多数警告并将其视为错误来让clang标记这类错误，在这种情况下，构建会失败，并显示一条消息：“不同符号的整数比较：'int'和'NSUInteger'（即'unsigned
    int'）”。
- en: '**NOTE**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In general, you should enable all warnings in your project build configuration
    and promote warnings to errors so that you are forced to deal with bugs as early
    as possible in the development cycle.*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*通常，你应该在项目构建配置中启用所有警告，并将警告提升为错误，这样你就能尽早处理开发周期中的bug。*'
- en: You can enable these options in your project and target build settings. To do
    so, first, under Warning Policies, set Treat Warnings as Errors to **Yes** ([Figure
    4-8](ch04.html#ch4fig8)). Then, under the Warnings sections, turn on all the desired
    options.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在项目和目标构建设置中启用这些选项。首先，在警告策略下，将“将警告视为错误”设置为**是**（[图 4-8](ch04.html#ch4fig8)）。然后，在警告部分，启用所有所需的选项。
- en: Note that not every build warning that clang supports has an exposed toggle
    in the Xcode UI. To develop in “hard mode,” you can add the `-Wextra` or `-Weverything`
    flag, as in [Figure 4-9](ch04.html#ch4fig9). Not all warnings will be useful,
    but it’s best to try to understand exactly what an option intends to highlight
    before disabling it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，并非所有clang支持的构建警告都有一个在Xcode UI中暴露的切换开关。要在“困难模式”下开发，你可以像在[图 4-9](ch04.html#ch4fig9)中那样添加`-Wextra`或`-Weverything`标志。并非所有警告都会有用，但最好在禁用它们之前先理解一个选项的意图。
- en: '`-Weverything`, used in [Figure 4-9](ch04.html#ch4fig9), is probably overkill
    unless you’re curious about clang internals; `-Wextra` is normally sufficient.
    To save you a bit of time, [Table 4-1](ch04.html#ch4tab1) discusses two warnings
    that are almost sure to get in your way (or that are just plain bizarre).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`-Weverything`，如[图 4-9](ch04.html#ch4fig9)所示，可能是过度使用，除非你对clang的内部结构感到好奇；通常`-Wextra`就足够了。为了节省一些时间，[表
    4-1](ch04.html#ch4tab1)讨论了两种几乎肯定会妨碍你开发的警告（或者是那些纯粹奇怪的警告）。'
- en: '![image](graphics/f04-08.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f04-08.jpg)'
- en: '*Figure 4-8: Treating all warnings as errors*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-8：将所有警告视为错误*'
- en: '![image](graphics/f04-09.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f04-09.jpg)'
- en: '*Figure 4-9: This setting enables all warnings, including options for which
    there is no exposed UI.*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-9：此设置启用了所有警告，包括没有暴露UI的选项。*'
- en: '**Table 4-1:** Obnoxious Warnings to Disable in Xcode'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-1：** 在Xcode中禁用的令人讨厌的警告'
- en: '| **Compiler warning** | **Justification for disabling** |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| **编译器警告** | **禁用的理由** |'
- en: '| --- | --- |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Implicit synthesized properties | Since property synthesis is now automatic,
    this isn’t really an error unless your development guidelines require explicit
    synthesis. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 隐式合成属性 | 由于属性合成现在是自动的，除非你的开发规范要求显式合成，否则这不算是一个错误。 |'
- en: '| Unused parameters/functions/variables etc. | These can be supremely irritating
    when writing code, since your code is obviously not completely implemented yet.
    Consider enabling these only for nondebug builds. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 未使用的参数/函数/变量等 | 当编写代码时，这些会非常让人烦恼，因为显然你的代码还没有完全实现。考虑仅在非调试构建中启用这些。 |'
- en: '***Enabling Full ASLR***'
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***启用完整的 ASLR***'
- en: In iOS 4.3, Apple introduced *address space layout randomization (ASLR)*. ASLR
    ensures that the in-memory structure of the program and its data (libraries, the
    main executable, stack and heap, and memory-mapped files) are loaded into less
    predictable locations in the virtual address space. This makes code execution
    exploits more difficult because many rely on referencing the virtual addresses
    of specific library calls, as well as referencing data on the stack or heap.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 4.3 中，Apple 引入了*地址空间布局随机化（ASLR）*。ASLR 确保程序及其数据（库、主可执行文件、堆栈和堆、以及内存映射文件）在虚拟地址空间中加载到不那么可预测的位置。这使得利用代码执行漏洞变得更加困难，因为许多漏洞依赖于引用特定库调用的虚拟地址，以及引用堆栈或堆上的数据。
- en: For this to be fully effective, however, the application must be built as a
    *position-independent executable (PIE)*, which instructs the compiler to build
    machine code that can function regardless of its location in memory. Without this
    option, the location of the base executable and the stack will remain the same,
    even across reboots,^([7](footnote.html#fn29)) making an attacker’s job much easier.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了使这一切完全生效，应用程序必须构建为*位置独立可执行文件（PIE）*，这指示编译器生成可以无论内存中的位置如何都能正常运行的机器代码。如果没有这个选项，即使重启后，基础可执行文件和堆栈的位置也将保持不变，^([7](footnote.html#fn29))
    使攻击者的工作变得更容易。
- en: To ensure that full ASLR with PIE is enabled, check that Deployment Target in
    your Target’s settings is set to at least iOS version 4.3\. In your project’s
    Build Settings, ensure that Generate Position-Dependent Code is set to No and
    that the bizarrely named Don’t Create Position Independent Executable is also
    set to No. So don’t create position-independent executables. Got it?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保启用了完整的 ASLR 和 PIE，请检查目标的设置中的 Deployment Target 至少设置为 iOS 版本 4.3。在项目的构建设置中，确保生成位置相关代码（Generate
    Position-Dependent Code）设置为 No，并且那项奇怪命名的选项“不要创建位置独立可执行文件”（Don’t Create Position
    Independent Executable）也设置为 No。所以，不要创建位置独立可执行文件。明白了吗？
- en: 'For black-box testing or to ensure that your app is built with ASLR correctly,
    you can use otool on the binary, as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行黑盒测试，或者确保你的应用程序正确启用了 ASLR，你可以在二进制文件上使用 otool，方法如下：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: At the end of each `MH_MAGIC` line, if you have your settings correct, you should
    see the `PIE` flag, highlighted in bold. (Note that this must be done on a binary
    compiled for an iOS device and will not work when used on iOS Simulator binaries.)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一行 `MH_MAGIC` 结束时，如果你的设置正确，你应该看到 `PIE` 标志，并且该标志会以粗体显示。（注意，这必须在为 iOS 设备编译的二进制文件上执行，在
    iOS 模拟器的二进制文件上不起作用。）
- en: '***Clang and Static Analysis***'
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Clang 和静态分析***'
- en: In computer security, *static analysis* generally refers to using tools to analyze
    a codebase and identify security flaws. This could involve identifying dangerous
    APIs, or it might include analyzing data flow through the program to identify
    the potentially unsafe handling of program inputs. As part of the build tool chain,
    clang is a good spot to embed static analysis language.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机安全中，*静态分析*通常指使用工具分析代码库并识别安全漏洞。这可能涉及识别危险的 API，或者包括分析程序中的数据流，识别潜在的不安全处理程序输入。作为构建工具链的一部分，clang
    是嵌入静态分析语言的好地方。
- en: Beginning with Xcode 3.2, clang’s static analyzer^([8](footnote.html#fn30))
    has been integrated with Xcode, providing users with a UI to trace logic, coding
    flaws, and general API misuse. While clang’s static analyzer is handy, several
    of its important features are disabled by default in Xcode. Notably, the checks
    for classic dangerous C library functions, such as `strcpy` and `strcat`, are
    oddly absent. Enable these in your Project or Target settings, as in [Figure 4-10](ch04.html#ch4fig10).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从Xcode 3.2开始，clang的静态分析器^([8](footnote.html#fn30))已经与Xcode集成，提供了一个用户界面来跟踪逻辑错误、编码缺陷以及API滥用等问题。虽然clang的静态分析器非常方便，但Xcode中默认禁用了它的几个重要功能。特别地，经典的危险C库函数检查，例如`strcpy`和`strcat`，是没有启用的。你可以在你的项目或目标设置中启用这些检查，正如在[图4-10](ch04.html#ch4fig10)所示。
- en: '![image](graphics/f04-10.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f04-10.jpg)'
- en: '*Figure 4-10: Enabling all clang static analysis checks in Xcode*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-10：在Xcode中启用所有clang静态分析检查*'
- en: '***Address Sanitizer and Dynamic Analysis***'
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***地址清理器与动态分析***'
- en: Recent versions of Xcode include a version of clang/llvm that features the Address
    Sanitizer (ASan). ASan is a dynamic analysis tool similar to Valgrind, but ASan
    runs faster and has improved coverage.^([9](footnote.html#fn31)) ASan tests for
    stack and heap overflows and use-after-free bugs, among other things, to help
    you track down crucial security flaws. It does have a performance impact (program
    execution is estimated to be roughly two times slower), so don’t enable it on
    your release builds, but it should be perfectly usable during testing, quality
    assurance, or fuzzing runs.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的最新版本包含了一个支持地址清理器（ASan）的clang/llvm版本。ASan是一个动态分析工具，类似于Valgrind，但ASan运行得更快，且具有更好的覆盖性。^([9](footnote.html#fn31))
    ASan可以检测栈溢出、堆溢出、以及使用后释放等错误，帮助你追踪关键的安全漏洞。它确实会带来性能影响（程序执行速度大约会变慢两倍），因此不要在发布版本中启用它，但它在测试、质量保证或模糊测试中应该是完全可用的。
- en: To enable ASan, add `-fsanitize=address` to your compiler flags for debug builds
    (see [Figure 4-11](ch04.html#ch4fig11)). On any unsafe crashes, ASan should write
    extra debug information to the console to help you determine the nature and severity
    of the issues. In conjunction with fuzzing,^([10](footnote.html#fn32)) ASan can
    be a great help in pinning down serious issues that may be security-sensitive
    and in giving an idea of their exploitability.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用ASan，请将`-fsanitize=address`添加到调试版本的编译器标志中（见[图4-11](ch04.html#ch4fig11)）。在出现任何不安全崩溃时，ASan应该会向控制台写入额外的调试信息，帮助你确定问题的性质和严重性。结合模糊测试^([10](footnote.html#fn32))，ASan对于定位可能具有安全风险的严重问题并评估其可利用性非常有帮助。
- en: '![image](graphics/f04-11.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f04-11.jpg)'
- en: '*Figure 4-11: Setting the ASan compiler flags*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-11：设置ASan编译器标志*'
- en: '**Monitoring Programs with Instruments**'
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用Instruments监控程序**'
- en: Regardless of whether you’re analyzing someone else’s application or trying
    to improve your own, the DTrace-powered Instruments tool is extremely helpful
    for observing an app’s activity on a fine-grained level. This tool is useful for
    monitoring network socket usage, finding memory allocation issues, and watching
    filesystem interactions. Instruments can be an excellent tool for discovering
    what objects an application stores on local storage in order to find places where
    sensitive information might leak; I use it in that way frequently.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是在分析别人的应用程序，还是想要改进自己的应用，DTrace驱动的Instruments工具都非常有助于在细粒度层面观察应用的活动。这个工具对于监控网络套接字使用、查找内存分配问题以及观察文件系统交互非常有用。Instruments还是一个很好的工具，用于发现应用程序在本地存储中存储的对象，从而找出可能泄露敏感信息的地方；我经常用它来做这件事。
- en: '***Activating Instruments***'
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***激活Instruments***'
- en: To use Instruments on an application from within Xcode, hold down the **Run**
    button and select the **Build for Profiling** option (see [Figure 4-12](ch04.html#ch4fig12)).
    After building, you will be presented with a list of preconfigured templates tailored
    for monitoring certain resources, such as disk reads and writes, memory allocations,
    CPU usage, and so on.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Xcode中使用Instruments分析应用程序，请按住**运行**按钮并选择**用于性能分析构建**选项（见[图4-12](ch04.html#ch4fig12)）。构建完成后，你将看到一系列预配置的模板，专门用于监控某些资源，例如磁盘读写、内存分配、CPU使用等。
- en: '![image](graphics/f04-12.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f04-12.jpg)'
- en: '*Figure 4-12: Selecting the Build for Profiling option*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-12：选择“用于性能分析构建”选项*'
- en: The File Activity template (shown in [Figure 4-13](ch04.html#ch4fig13)) will
    help you monitor your application’s disk I/O operations. After selecting the template,
    the iOS Simulator should automatically launch your application and begin recording
    its activity.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 文件活动模板（如[图 4-13](ch04.html#ch4fig13)所示）将帮助你监控应用程序的磁盘I/O操作。选择模板后，iOS模拟器应该会自动启动应用程序并开始记录其活动。
- en: '![image](graphics/f04-13.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f04-13.jpg)'
- en: '*Figure 4-13: Selecting the File Activity profiling template*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-13：选择文件活动分析模板*'
- en: There are a few preset views in Instruments for monitoring file activity. A
    good place to start is Directory I/O, which will capture all file creation or
    deletion events. Test your application the way you normally would and watch the
    output here. Each event is listed with its Objective-C caller, the C function
    call underlying it, the file’s full path, and its new path if the event is a rename
    operation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Instruments中有几个预设视图用于监控文件活动。一个好的起点是目录I/O，它会捕捉所有文件创建或删除事件。按你平常的方式测试应用程序，并观察这里的输出。每个事件都会列出其Objective-C调用者、底层的C函数调用、文件的完整路径，以及如果该事件是重命名操作，文件的新路径。
- en: You’ll likely notice several types of cache files being written here (see [Figure
    4-14](ch04.html#ch4fig14)), as well as cookies or documents your application has
    been asked to open. If you suspend your application, you should see the application
    screenshot written to disk, which I’ll discuss in [Chapter 10](ch10.html#ch10).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到这里写入了几种类型的缓存文件（见[图 4-14](ch04.html#ch4fig14)），以及应用程序被要求打开的cookies或文档。如果你挂起应用程序，你应该能看到应用程序的截图被写入磁盘，关于这一点，我将在[第10章](ch10.html#ch10)中进行讨论。
- en: For a more detailed view, you can select the Reads/Writes view, as shown in
    [Figure 4-15](ch04.html#ch4fig15). This will show any read or write operations
    on files or sockets, along with statistics on the amount of data read or written.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 若想查看更详细的视图，你可以选择读取/写入视图，如[图 4-15](ch04.html#ch4fig15)所示。该视图将展示所有文件或套接字的读写操作，并显示读取或写入的数据量统计。
- en: '![image](graphics/f04-14.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f04-14.jpg)'
- en: '*Figure 4-14: Directory I/O view showing files created or deleted*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-14：目录I/O视图，显示已创建或删除的文件*'
- en: '![image](graphics/f04-15.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f04-15.jpg)'
- en: '*Figure 4-15: Profiling results showing detailed file reads and writes*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-15：显示详细文件读写的分析结果*'
- en: '***Watching Filesystem Activity with Watchdog***'
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用Watchdog监控文件系统活动***'
- en: Instruments should catch most iOS Simulator activity, but some file writes or
    network calls may actually be performed by other system services, thereby escaping
    the tool’s notice. It’s a good idea to manually inspect the iOS Simulator’s directory
    tree to get a better feel for the structure of iOS and its applications and to
    catch application activity that you might otherwise miss.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Instruments应该能够捕捉大部分iOS模拟器的活动，但有些文件写入或网络调用可能由其他系统服务执行，从而未被工具捕捉到。手动检查iOS模拟器的目录树是个好主意，这可以帮助你更好地了解iOS及其应用程序的结构，并捕捉到你可能会错过的应用程序活动。
- en: 'One easy way to automate this is to use the Python watchdog module.^([11](footnote.html#fn33))
    Watchdog will use either the kqueue or FSEvents API to monitor directory trees
    for file activity and can either log events or take specific actions when these
    events occur. To install watchdog, use the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单的自动化方法是使用Python的watchdog模块。^([11](footnote.html#fn33)) Watchdog将使用kqueue或FSEvents
    API来监控目录树中的文件活动，并可以在这些事件发生时记录事件或采取特定的行动。要安装watchdog，请使用以下命令：
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can write your own scripts to use watchdog’s functionality, but you’ll
    find a nice command line tool already included with watchdog called watchmedo.
    If you open a Terminal window and navigate to the Simulator directory, you should
    be able to use watchmedo to monitor all file changes under the iOS Simulator’s
    directory tree, as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编写自己的脚本来使用watchdog的功能，但你会发现watchdog已经包含了一个不错的命令行工具，叫做watchmedo。如果你打开一个终端窗口并导航到模拟器目录，你应该能够使用watchmedo监控iOS模拟器目录树下的所有文件更改，如下所示：
- en: '[PRE13]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Entries that start with on `on_modified` indicate a file was changed, and entries
    that start with `on_created` indicate a new file. There are several other change
    indicators you might see from watchmedo, and you can read about them in the Watchdog
    documentation.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以`on_modified`开头的条目表示文件已被更改，而以`on_created`开头的条目表示新文件的创建。你可能还会看到watchmedo的其他更改指示符，你可以在Watchdog文档中阅读有关它们的更多信息。
- en: '**Closing Thoughts**'
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结束语**'
- en: You should now have your build and test environment configured for running,
    modifying, and examining iOS apps. In [Chapter 5](ch05.html#ch05), we’ll take
    a closer look at how to debug and inspect applications dynamically, as well as
    how to change their behavior at runtime.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该已经配置好了用于运行、修改和检查 iOS 应用的构建和测试环境。在[第5章](ch05.html#ch05)中，我们将更深入地探讨如何动态调试和检查应用，以及如何在运行时改变它们的行为。
