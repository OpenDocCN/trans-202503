<html><head></head><body>
<div id="sbo-rt-content"><section>&#13;
<header>&#13;
<h1 class="chapter">&#13;
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_175" title="175"/>10</span><br/>&#13;
<span class="ChapterTitle">I<sup>2</sup>C Programming in Real-Time Operating Systems </span></h1>&#13;
</header>&#13;
<figure class="opener">&#13;
<img alt="" height="203" src="image_fi/book_art/chapterart.png" width="203"/>&#13;
</figure>&#13;
<p class="ChapterIntro">I<sup>2</sup>C transmissions are slow, typically 100 kHz. In systems like Arduino, your code must wait for each transmission or reception to complete before doing other work, which drastically reduces your application’s performance. While waiting, the CPU is just executing a busy-waiting loop (also called a <em>spin loop</em>), wasting CPU cycles. In this chapter, you’ll learn to use real-time operating systems (RTOSs) to put those CPU cycles to work.</p>&#13;
<p>This chapter introduces several different RTOSs—µC/OS, FreeRTOS, Teensy Threads, and Mbed—that you can run on typical SBCs, and it provides an example program using I<sup>2</sup>C for each. Some RTOSs, such as Mbed, provide full I<sup>2</sup>C support. Others, like FreeRTOS and Teensy Threads, are simple schedulers for which you must provide your own compatible I<sup>2</sup>C library code. The choice of RTOS is often dictated by the SBC you’re using, since if you’ve chosen a particular SBC to use, you can run only an RTOS <span epub:type="pagebreak" id="Page_176" title="176"/>that has been ported to that board. Conversely, if you want to use a particular RTOS, you must choose an SBC to which it has been ported—unless you’re willing to set up the port yourself, which is generally a lot of work.</p>&#13;
<p>This chapter begins with a description of some basic RTOS concepts and then introduces a few RTOSs, along with one or a few representative SBCs to use with the RTOS the section describes. This is not to suggest that the SBC I pair with a given RTOS is the only (or even the best) SBC to use with that RTOS—these are just the components I had available while writing this book. For most of these RTOSs, you’ll generally have a much wider selection of platforms to choose from when designing your own systems.</p>&#13;
<h2 id="h1-502468c10-0001">	10.1	Real-Time Operating System Basics</h2>&#13;
<p class="BodyFirst">The purpose of an RTOS is to handle asynchronous events, such as the completion of an I<sup>2</sup>C transmission, within a guaranteed amount of time. Another way to do this, of course, is via <em>polling</em>—the CPU simply waits in a spin loop, testing for the event until it occurs and then immediately handling it. While polling has some advantages (in particular, it can provide the fastest response time to an event), there’s also a huge disadvantage: the CPU is tied up in the spin loop and cannot do other work.</p>&#13;
<p>This book will typically use the term <em>task</em> to denote some generic execution unit that is running (pseudo-)concurrently with other execution units. Threads and processes are examples of types of tasks, which I’ll discuss shortly.</p>&#13;
<p>RTOSs allow other tasks to do work while the CPU is waiting for some event to occur. Some hardware support is needed to make this practical; in particular, the external event must be capable of generating an interrupt signal on the CPU. As its name suggests, an <em>interrupt signal</em> will cause the CPU to suspend execution of the currently executing task and transfer control to a special ISR that will handle the event. For some devices, the ISR completely handles the event, and the suspended task resumes control. With most RTOSs and ISRs, however, the ISR simply sets a flag that notes the event has occurred, and the RTOS will schedule the execution of the original code (which was waiting for the completion of an I<sup>2</sup>C transaction or some other task) for some point in the future.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	The RTOS’s guaranteed response time is the length of time between when the event occurs (the interrupt) and when the ISR starts executing. If the ISR sets a flag to execute some additional handler code in the future, there is no guarantee that such execution will take place within a specified time period. If some action must be immediately taken after the event, that action must take place in the ISR.</p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<p>In the context of an I<sup>2</sup>C write, for example, a call to the write function will set up the I<sup>2</sup>C hardware to begin the transmission of the data on the I<sup>2</sup>C bus. Then the task that is writing the data will <em>suspend</em>, allowing other tasks to do some work. When the I<sup>2</sup>C transmission is complete, the I<sup>2</sup>C hardware will generate an interrupt, and the ISR will make a special system call to the RTOS telling it to wake up the suspended task that was writing data to the I<sup>2</sup>C bus.</p>&#13;
<p><span epub:type="pagebreak" id="Page_177" title="177"/>The RTOS moves the I<sup>2</sup>C write task from a suspended queue to a ready-to-run queue. This, however, does not guarantee that the I<sup>2</sup>C write task immediately begins execution (that depends on various RTOS scheduling policies). Control might transfer back to the task that was just suspended when the interrupt came along.</p>&#13;
<p>At some point in the future, the RTOS will decide to allow the I<sup>2</sup>C write task to continue execution. It will then move the task off the ready-to-run queue and start it running, suspending the currently executing task. At that time, the I<sup>2</sup>C write task can continue doing whatever it needs to do, such as writing additional data, reading data, or simply returning to the application that requested the I<sup>2</sup>C write operation.</p>&#13;
<h3 id="h2-502468c10-0001">10.1.1	Processes and Threads</h3>&#13;
<p class="BodyFirst">Operating systems theory defines multiple levels of tasks, including processes and threads. As noted earlier, this book will use the generic term <em>task</em><em/> to describe both processes and threads.</p>&#13;
<p>A <em>thread</em> is a unit of execution that shares an address space with other concurrently executing threads. Because the threads share memory (the address space), one thread can change the memory that another thread reads. This provides an easy way for the threads to communicate with one another, but it also introduces some problems, as you’ll see in the next section.</p>&#13;
<p>A <em>process</em> is a unit of execution that has its own address space and does not share that memory with other processes. Communication between processes is a little more difficult than with threads, since you typically have to use files or other OS-defined data structures for the communication. However, because the processes can’t overwrite each other’s memory spaces, there’s less opportunity for them to interfere with one another.</p>&#13;
<p>An application may consist of one or more processes. Each process will contain one or more threads. The simplest application consists of a single process executing a single thread. One step up in complexity is an application executing a single process that has multiple threads of execution. Above that are applications with multiple processes, each with one or more threads of execution. </p>&#13;
<p>The easiest visualization of multiple processes and threads is to think of each process and thread corresponding to procedures or functions in a programming language. Each independent process or thread corresponds to a unique function that executes the code for that process or thread. While this is a simple model to visualize, it is actually common for different processes and threads to share the same code. For example, two threads of execution could run the same function in memory, perhaps being passed different parameters to allow them to do different operations.</p>&#13;
<h3 id="h2-502468c10-0002">10.1.2	Multithreading and Multitasking</h3>&#13;
<p class="BodyFirst">The principal function of an RTOS is to allow multiple threads to run concurrently. A few microcontrollers include multiple CPUs (<em>multicore CPUs</em>), meaning two or more tasks really can run on different CPUs at exactly the same time. However, most embedded microcontrollers are limited to a single <span epub:type="pagebreak" id="Page_178" title="178"/>CPU (core), allowing only a single task to run at any given time. To simulate multitasking (also known as <em>multithreading</em>), RTOSs rapidly switch between tasks to give the illusion that multiple tasks are executing concurrently.</p>&#13;
<p>Most modern RTOSs use preemption to suspend one task and then allow another to execute. Each RTOS uses a given policy to determine how to preempt a running task. Some RTOSs give each task a fixed amount of time to run and switch between tasks when the timer expires. This time period is known as a <em>time slice </em>or<em> time quantum</em>; the process of switching between tasks is called <em>time multiplexing</em>. Other RTOSs assign priorities to different tasks and allow higher-priority tasks to run unimpeded until they suspend or a higher-priority task is ready to run. Many RTOSs use a combination of these policies. For example, if two tasks with the same priority are ready to run, they use time slicing to switch between themselves, while lower-priority tasks remain suspended until both tasks suspend themselves.</p>&#13;
<p>In a pure priority-based system, lower-priority tasks may never run if some higher-priority task is always running. This could lead to <em>starvation</em>, meaning a given task never executes. Many RTOSs temporarily raise the priority of a low-priority task after some time period to ensure it gets some attention every now and then.</p>&#13;
<p>An RTOS’s scheduling policy determines how it selects the next task to run. For example, if an RTOS assigns equal priority to tasks and gives each task a time slice of equal size, the scheduling policy decides how the CPU chooses the next task to run when one task completes its time slice (or suspends for some other reason). One obvious solution is a <em>round-robin</em> scheduling policy in which the RTOS maintains a queue of ready-to-run tasks and picks the task off the front of the queue when switching between tasks; it places the newly suspended task at the end of the queue. Most of the time, this ensures a fair allocation of CPU resources to each of the ready-to-run tasks. There are some degenerate cases where this scheme is not entirely fair. For example, if a particular task suspends more frequently than others, it must wait through the whole queue again even though it uses little CPU time while actually running. However, as a quick-and-dirty solution, round-robin scheduling works well.</p>&#13;
<p>Sometimes an application can control various aspects of the scheduling priority, but more often than not the application has to live with the scheduling policies provided by the operating system. Tuning RTOS policies is beyond the scope of this book, but to learn more, see “For More Information” at the end of this chapter or the manual for your particular RTOS. Fortunately, I<sup>2</sup>C activities tend to be very slow (at least, when running at 100 kHz), so scheduling tuning generally won’t affect the performance of an I<sup>2</sup>C-based application by that much.</p>&#13;
<h3 id="h2-502468c10-0003">10.1.3	Reentrancy</h3>&#13;
<p class="BodyFirst">Perhaps the biggest problem with programming I<sup>2</sup>C devices in a multithreaded environment is <em>reentrancy</em>, which occurs when two separate threads attempt to run the same code concurrently. An I<sup>2</sup>C device is a single, shared system resource. If a function called by two separate threads attempts to communicate with an I<sup>2</sup>C device, a second thread reentering that same function will <span epub:type="pagebreak" id="Page_179" title="179"/>attempt to talk to that same device concurrently. If one thread started to write a 2- or 3-byte sequence to the device and was interrupted after transmitting the first byte, then from the device’s perspective, the first byte from the second thread would look like the second byte from the first thread. If two threads are going to share the same I<sup>2</sup>C device, proper operation will take very careful synchronization on the part of the two threads.</p>&#13;
<p>Even if two threads don’t access the same device, two different threads cannot talk to two different devices simultaneously on the same bus. Once again, different threads must synchronize their use of the same I<sup>2</sup>C bus. In some respects, this is similar to having two controllers sharing the bus; however, there is no protocol to handle conflicts—the individual threads must handle contention on their own.</p>&#13;
<h3 id="h2-502468c10-0004">10.1.4	Synchronization</h3>&#13;
<p class="BodyFirst">Synchronization is typically handled by mutexes (mutual exclusion primitives), critical sections, semaphores, events, and other such OS synchronization primitives. The basic idea behind all of these operations is to allow access to some section of code by only one thread at a time. In a typical RTOS, a thread will request exclusive access to a critical section of code. If the RTOS grants this request, future requests by other threads will be blocked until the original thread holding the critical section releases it. This mechanism allows only a single thread to enter the critical section at a time, thus eliminating the problems with reentrancy.</p>&#13;
<p>While a thread is waiting for some other thread to release a critical section, the waiting thread is suspended (blocked) and does not consume any CPU cycles waiting for the release of the critical section. In the case of I<sup>2</sup>C transmission, this blockage could last a considerable amount of time; the thread holding the critical section could be transmitting and receiving several bytes on the I<sup>2</sup>C bus (typically requiring 100 μmsec to 1,000 μmsec per byte, plus more if clock stretching occurs). The good news is that the blocked thread does not interfere with the current transmission taking place on the I<sup>2</sup>C bus.</p>&#13;
<h3 id="h2-502468c10-0005">10.1.5	Safety Critical Systems</h3>&#13;
<p class="BodyFirst">Certain RTOSs such as µC/OS or FreeRTOS have been <em>safety qualified</em>, meaning that they have been thoroughly tested using stringent quality-assurance programs. This is a major advantage, since if you’re developing medical equipment, nuclear instrumentation, or automotive applications, industry regulators will probably require that you use either a safety-qualified operating system or provide appropriate documentation and testing that makes the case for the system you’ve chosen before they allow you to deploy your system. For example, I’ve used µC/OS (running on a NetBurner) in the development of instrumentation for nuclear reactors.</p>&#13;
<p>Of course, if you’re not developing mission-critical applications, you might not need a safety-qualified RTOS. Obviously, the choice is very application dependent, but be aware that quality assurance issues may restrict your choice of real-time OSs.</p>&#13;
<h2 id="h1-502468c10-0002"><span epub:type="pagebreak" id="Page_180" title="180"/>	10.2	Real-Time Operating System I<sup>2</sup>C Programming</h2>&#13;
<p class="BodyFirst">This chapter focuses on four RTOSs: µC/OS, FreeRTOS, Teensy Threads (not really an RTOS, just a multithreading package), and Mbed. </p>&#13;
<p>FreeRTOS and Teensy Threads are really just thread scheduling packages that provide basic multitasking and thread synchronization functions. They do not provide any other library code, such as I<sup>2</sup>C communication functions; you’re expected to provide that code yourself. In particular, you are responsible for synchronizing access to shared resources like the I<sup>2</sup>C bus.</p>&#13;
<p>The second two RTOSs, µC/OS and Mbed, are full-featured RTOSs that include library support for many activities, such as I<sup>2</sup>C communication. These fancier RTOSs provide synchronized access to the resources they use.</p>&#13;
<p>The following subsections provide a brief discussion of each of these RTOSs. Where applicable, they also describe how to protect access to shared resources, such as the I<sup>2</sup>C bus.</p>&#13;
<h3 id="h2-502468c10-0006">10.2.1	µC/OS</h3>&#13;
<p class="BodyFirst">In this chapter, I’m going to use the NBRTOS variant of µC/OS provided by NetBurner, Inc., running on their NetBurner MOD54415 SBC. NBRTOS is a variant of µC/OS I that includes several additional libraries to support the MOD54415, including a couple of I<sup>2</sup>C libraries.</p>&#13;
<p>The original µC/OS I RTOS was a purely priority-based RTOS with 64 different priority levels. It had the onerous restriction that each task (the µC/OS name for thread) had to run at a different priority so that you could not have two tasks running at the same priority while using round-robin/time multiplexed scheduling for those tasks at the same priority. Later versions of µC/OS, such as µC/OS III, introduced more priority levels (up to 256) and allowed multiple tasks to run at the same priority by using time multiplexing to switch between tasks of equal priority. However, as NBRTOS uses a version of µC/OS I, this book will stick with priority-based scheduling for µC/OS. Most of the other RTOSs in this book use time slicing (time multiplexing) rather than a priority-based scheme, so µC/OS is unusual in this respect.</p>&#13;
<p>The MOD54415 SBC supports up to four different I<sup>2</sup>C ports. A special library, <code>MultiChannel_I2C</code>, provides support in a multithreaded environment for these four channels. This library provides several different I<sup>2</sup>C functions you can call, though this chapter will use only two of them, <code>MultiChannel_I2CInit()</code> and <code>MultiChannel_I2CSendBuf()</code>, to demonstrate writing to the MCP4725 DAC:</p>&#13;
<pre><code>void MultiChannel_I2CInit&#13;
(&#13;
    int     moduleNum = DEFAULT_I2C_MODULE,&#13;
    uint8_t slave_Addr = 0x08,&#13;
    uint8_t freqdiv = 0x3C &#13;
);&#13;
&#13;
uint8_t MultiChannel_I2CSendBuf&#13;
(&#13;
<span epub:type="pagebreak" id="Page_181" title="181"/>    int      moduleNum,&#13;
    uint8_t  addr,&#13;
    puint8_t buf,&#13;
    int      num,&#13;
    bool     stop = true &#13;
);</code></pre>&#13;
<p>The first function, <code>MultiChannel_I2CInit()</code>, initializes the I<sup>2</sup>C port you’re going to use. This is usually a small integer in the range 0 to 3 (for ports i2c-0 through i2c-3). The second parameter specifies a peripheral address for the port; you specify this only if you’re using the I<sup>2</sup>C port in peripheral mode. If you’re using the port in controller mode, you can ignore this argument (the default of <code>0x08</code> is fine). The last argument specifies the frequency divisor for the I<sup>2</sup>C bus. The default of <code>0x3C</code> is fine for 100-kHz operation; see the NetBurner documentation if you want to operate at a different clock frequency.</p>&#13;
<p>The second function, <code>MultiChannel_I2CSendBuf()</code>, writes data to the I<sup>2</sup>C bus. The first argument is the I<sup>2</sup>C port number (for example, <code>0</code> for i2c-0), the second argument is the I<sup>2</sup>C address of the device, the third argument is an array of bytes containing the data to be written, the fourth argument specifies the number of bytes to write, and the last argument specifies whether a stop condition is written to the I<sup>2</sup>C bus after the transmission (the default is <code>true</code><code/>, which means to send the stop condition).</p>&#13;
<p>The NetBurner library provides a fair number of other functions you can use to manipulate the I<sup>2</sup>C bus. For more detail, see the NetBurner documentation linked in “For More Information.” </p>&#13;
<p>The program in <a href="#listing10-1" id="listinganchor10-1">Listing 10-1</a> is the usual triangle wave DAC output sample program. Other than a few µC/OS peculiarities (outside the scope of this book), this program is equivalent to the demonstration program from other chapters.</p>&#13;
<pre><code>// <a id="listing10-1">Listing 10-1</a> (main.cpp)&#13;
//&#13;
// DAC output example for µC/OS.&#13;
&#13;
#include "predef.h"&#13;
#include &lt;stdio.h&gt;&#13;
#include &lt;startnet.h&gt;&#13;
#include &lt;autoupdate.h&gt;&#13;
#include &lt;multichanneli2c.h&gt;&#13;
&#13;
#define ever ;;&#13;
&#13;
#define I2C_CHANNEL 0      // Going to use I2C0 on NetBurner&#13;
#define mcp4725     0x60   // DAC I2C address&#13;
extern "C" &#13;
{&#13;
    void UserMain( void * pd );&#13;
}&#13;
&#13;
// DACout-&#13;
//&#13;
<span epub:type="pagebreak" id="Page_182" title="182"/>// Draws one cycle of a triangle waveform on&#13;
// the MCP4725 I2C DAC device (for example, &#13;
// Adafruit MCP4725 breakout board).&#13;
//&#13;
// Argument: I2C address for the DAC. For&#13;
// Adafruit MCP4725 breakout boards, this&#13;
// is either 0x62 or 0x63. For SparkFun&#13;
// boards, this is either 0x60 or 0x61.&#13;
&#13;
void DACout( int adrs )&#13;
{&#13;
    uint8_t buf[2];&#13;
    &#13;
    // Send the rising edge of a triangle wave:&#13;
&#13;
    for( uint16_t dacOut = 0; dacOut &lt; 0xfff; ++dacOut )&#13;
    {&#13;
        // Note: MCP4725 requires that you write&#13;
        // the HO byte first and the LO byte second!&#13;
        &#13;
        buf[0] = (dacOut &lt;&lt; 8) &amp; 0xff;&#13;
        buf[1] = dacOut &amp; 0xff;&#13;
        &#13;
        // Transmit the data from the buffer:&#13;
        &#13;
      <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> MultiChannel_I2CSendBuf&#13;
        (&#13;
            I2C_CHANNEL,&#13;
            adrs,      // Device address&#13;
            buf,       // Data to write&#13;
            2,         // 2 bytes to write&#13;
            true       // Send stop condition&#13;
        );&#13;
    }&#13;
&#13;
    // Send the falling edge of the triangle wave.&#13;
&#13;
    for( uint16_t dacOut = 0xffe; dacOut &gt; 0; --dacOut )&#13;
    {&#13;
        // HO then LO byte:&#13;
        &#13;
        buf[0] = (dacOut &lt;&lt; 8) &amp; 0xff;&#13;
        buf[1] = dacOut &amp; 0xff;&#13;
        MultiChannel_I2CSendBuf&#13;
        (&#13;
            I2C_CHANNEL,&#13;
            adrs,       // Device address&#13;
            buf,        // Data to write&#13;
            2,          // 2 bytes to write&#13;
            true        // Send stop condition&#13;
        );&#13;
    }&#13;
}&#13;
&#13;
<span epub:type="pagebreak" id="Page_183" title="183"/>void UserMain( void * pd ) &#13;
{ &#13;
    int cntr = 0;&#13;
&#13;
    // Standard NetBurner initialization stuff:&#13;
    &#13;
    InitializeStack();&#13;
    EnableAutoUpdate(); // Allow Ethernet update of code&#13;
&#13;
    // Initialize I2C0 on the NetBurner MOD54415:&#13;
&#13;
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> MultiChannel_I2CInit( I2C_CHANNEL );&#13;
    for( ever ) &#13;
    {&#13;
        // Print status information to the serial console&#13;
        // every now and then to show that something is&#13;
        // happening:&#13;
                &#13;
        iprintf( "main loop, cntr=%d\n", cntr++ );&#13;
        &#13;
        // Draw one cycle of the triangle waveform&#13;
        // on the DAC:&#13;
                &#13;
        DACout( mcp4725 ); // MCP4725 output&#13;
        &#13;
    } // endfor&#13;
} // UserMain</code></pre>&#13;
<p>The <code>MultiChannel_I2CInit()</code> <span aria-label="annotation2" class="CodeAnnotation">❷</span> and <code>MultiChannel_I2CSendBuf()</code><span aria-label="annotation1" class="CodeAnnotation">❶</span> functions are the µC/OS I<sup>2</sup>C initialization and I<sup>2</sup>C output routines.</p>&#13;
<p><a href="#figure10-1" id="figureanchor10-1">Figure 10-1</a> shows the oscilloscope output from the program in <a href="#listing10-1">Listing 10-1</a>. Note that the frequency is much closer to the Arduino example (see Figure 8-2 in Chapter 8) than the Raspberry Pi example (see Figure 9-3 in Chapter 9). The slower frequency in the Pi example is, undoubtedly, due to all the extra work happening under the multitasking Pi OS (Linux).</p>&#13;
<figure>&#13;
<img alt="" class="keyline" height="304" src="image_fi/502468c10/f10001.png" width="416"/>&#13;
<figcaption><p><a id="figure10-1">Figure 10-1</a>: Oscilloscope output from <a href="#listing10-1">Listing 10-1</a></p></figcaption>&#13;
</figure>&#13;
<p><span epub:type="pagebreak" id="Page_184" title="184"/>Since µC/OS supports multitasking, you might wonder, why not write some code to generate two separate triangle waves concurrently? Of course, two tasks cannot access the same I<sup>2</sup>C device concurrently, but you might reason that you could fix that issue by putting two different DACs on the I<sup>2</sup>C bus. One task could write to the first DAC, and the second task could write to the second DAC. </p>&#13;
<p>Unfortunately, under a pure priority-based system such as µC/OS, this won’t work out well. The higher-priority task always runs, and the lower-priority task never gets a chance to execute (unless you put in code to explicitly suspend the higher-priority task).</p>&#13;
<p><a href="#listing10-2" id="listinganchor10-2">Listing 10-2</a> provides the source code to the version of the code that demonstrates one way to do this.</p>&#13;
<pre><code>// <a id="listing10-2">Listing 10-2</a> (main.cpp)&#13;
//&#13;
// Multi-threaded I2C demonstration #2.&#13;
// This program writes to two separate&#13;
// MCP4725 devices on the same I2C bus&#13;
// using separate threads for each of the&#13;
// DACs, with a semaphore to protect&#13;
// writes to the I2C port.&#13;
 &#13;
#include "predef.h"&#13;
#include &lt;stdio.h&gt;&#13;
#include &lt;startnet.h&gt;&#13;
#include &lt;autoupdate.h&gt;&#13;
#include &lt;pins.h&gt;&#13;
#include &lt;multichanneli2c.h&gt;&#13;
&#13;
#define ever ;;&#13;
&#13;
#define I2C_CHANNEL0 0          // Going to use I2C0 &#13;
&#13;
#define dac1 0x62               // MCP4725 #1 address&#13;
#define dac2 0x63               // MCP4725 #2 address&#13;
&#13;
extern "C" &#13;
{&#13;
    void UserMain(void * pd);&#13;
}&#13;
&#13;
// Stack for DACthread:&#13;
&#13;
#define DACthread_STK_SIZE (4096)&#13;
static  DWORD   DACthread_stack[ DACthread_STK_SIZE ] &#13;
                        __attribute__((aligned(4)));&#13;
&#13;
// Critical section protecting console I/O:&#13;
&#13;
OS_CRIT ioCS;&#13;
&#13;
<span aria-label="annotation1" class="CodeAnnotationCode">❶</span> OS_SEM  threadSem;&#13;
<span epub:type="pagebreak" id="Page_185" title="185"/>OS_SEM  mainSem;&#13;
&#13;
// DACout-&#13;
//&#13;
// Draws one cycle of a triangle waveform on&#13;
// the MCP4725 I2C DAC device (e.g., Adafruit&#13;
// MCP4725 breakout board).&#13;
//&#13;
// Argument: I2C address for the DAC. For&#13;
// Adafruit MCP4725 breakout boards, this&#13;
// is either 0x62 or 0x63. For SparkFun&#13;
// boards, this is either 0x60 or 0x61.&#13;
&#13;
void DACout( int adrs, OS_SEM *enter, OS_SEM *leave )&#13;
{&#13;
    uint8_t buf[2];&#13;
    &#13;
    // Send the rising edge of a triangle wave:&#13;
&#13;
    for( uint16_t dacOut = 0; dacOut &lt; 0xfff; ++dacOut )&#13;
    {&#13;
        // Note: MCP4725 requires that you write&#13;
        // the HO byte first and the LO byte second!&#13;
        &#13;
        buf[0] = (dacOut &lt;&lt; 8) &amp; 0xff;&#13;
        buf[1] = dacOut &amp; 0xff;&#13;
        &#13;
        // Transmit the data from the buffer:&#13;
        &#13;
      <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> OSSemPend( enter, 0 );  // Protect call&#13;
&#13;
          <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> MultiChannel_I2CSendBuf&#13;
            (&#13;
                I2C_CHANNEL0,&#13;
                adrs,           // Device address&#13;
                buf,            // Data to write&#13;
                2,              // 2 bytes to write&#13;
                true            // Send stop condition&#13;
            );&#13;
          &#13;
      <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> OSSemPost( leave );     // Enable other thread&#13;
    }&#13;
&#13;
    // Send the falling edge of the triangle wave.&#13;
&#13;
    for( uint16_t dacOut = 0xffe; dacOut &gt; 0; --dacOut )&#13;
    {&#13;
        // HO then LO byte:&#13;
        &#13;
        buf[0] = (dacOut &lt;&lt; 8) &amp; 0xff;&#13;
        buf[1] = dacOut &amp; 0xff;&#13;
        OSSemPend( enter, 0 );   // Protect call&#13;
&#13;
            MultiChannel_I2CSendBuf&#13;
<span epub:type="pagebreak" id="Page_186" title="186"/>            (&#13;
                I2C_CHANNEL0,&#13;
                adrs,           // Device address&#13;
                buf,            // Data to write&#13;
                2,              // 2 bytes to write&#13;
                true            // Send stop condition&#13;
            );&#13;
            &#13;
        OSSemPost( leave );     // Enable other thread&#13;
    }&#13;
}&#13;
&#13;
void DACthread( void *parm )&#13;
{&#13;
    int cntr = 0;&#13;
    &#13;
    for( ever ) &#13;
    {&#13;
        // Print a message each time the thread&#13;
        // completes one cycle of the triangle&#13;
        // wave. Note that iprintf must be&#13;
        // protected by a critical section.&#13;
        &#13;
        OSCritEnter( &amp;ioCS, 0 );&#13;
             &#13;
            iprintf( "thread loop, cntr=%d\n", cntr++ );&#13;
            &#13;
        OSCritLeave( &amp;ioCS );&#13;
        &#13;
        // Draw one cycle of the triangle waveform&#13;
        // on the DAC at address 0x63:&#13;
&#13;
        DACout( dac2, &amp;threadSem, &amp;mainSem );         &#13;
        &#13;
    } // endfor&#13;
}&#13;
&#13;
void UserMain( void * pd ) &#13;
{ &#13;
    int cntr = 0;&#13;
&#13;
    // Standard NetBurner initialization stuff:&#13;
    &#13;
    InitializeStack();&#13;
    EnableAutoUpdate(); // Allow Ethernet update of code&#13;
&#13;
    // Initialize the critical sections used to protect &#13;
    // console I/O and the I2C output.&#13;
    &#13;
    OSCritInit( &amp;ioCS );&#13;
    OSSemInit( &amp;threadSem, 1 );&#13;
    OSSemInit( &amp;mainSem, 0 );&#13;
&#13;
<span epub:type="pagebreak" id="Page_187" title="187"/>    // Initialize I2C0 pins on the NetBurner MOD54415:&#13;
    &#13;
    MultiChannel_I2CInit( I2C_CHANNEL0 );&#13;
    &#13;
    // Start a thread running that will write to the&#13;
    // DAC at address 0x63. Give the thread a higher&#13;
    // priority than that of the main thread.&#13;
    //&#13;
    // The parameters are the following:&#13;
    //&#13;
    //  1. Address of function to invoke as the&#13;
    //     new thread ("task" in NBRTOS terminology).&#13;
    //&#13;
    //  2. Parameter to pass to the thread.  &#13;
    //&#13;
    //  3. Address of the first byte beyond the&#13;
    //     stack space allocated for the thread.&#13;
    //&#13;
    //  4. Address of the start of the task.&#13;
    //&#13;
    //  5. Thread priority (lower number is&#13;
    //     higher priority).&#13;
    &#13;
  <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> OSTaskCreate&#13;
    (&#13;
        DACthread, &#13;
        NULL,&#13;
        (void*)&amp;DACthread_stack[DACthread_STK_SIZE],&#13;
        (void *)DACthread_stack, &#13;
        MAIN_PRIO + 1&#13;
    );&#13;
    &#13;
    for( ever ) &#13;
    {&#13;
        // Print a message each time the main thread&#13;
        // completes one cycle of the triangle&#13;
        // wave. Note that iprintf must be&#13;
        // protected by a critical section.&#13;
           &#13;
        OSCritEnter( &amp;ioCS, 0 );&#13;
             &#13;
            iprintf( "main loop, cntr=%d\n", cntr++ );&#13;
            &#13;
        OSCritLeave( &amp;ioCS );&#13;
        &#13;
        // Draw one cycle of the triangle waveform&#13;
        // on the DAC at address 0x62:&#13;
                &#13;
        DACout( dac1, &amp;mainSem, &amp;threadSem );&#13;
    } // endfor&#13;
} // UserMain</code></pre>&#13;
<p><span epub:type="pagebreak" id="Page_188" title="188"/>Unfortunately, you cannot use µC/OS critical section variables (<code>OS_CRIT</code>) to protect access to the I<sup>2</sup>C bus. As noted earlier, because µC/OS is strictly a priority-based system, the lower-priority thread will not get a chance to run unless some system call explicitly blocks the main thread. To overcome this problem, the code in <a href="#listing10-2">Listing 10-2</a> uses semaphores.</p>&#13;
<p>Semaphores are similar to critical sections insofar as you can use them to protect a section of code. They differ from critical sections in that they have a counter associated with them. When you enter a critical section (a µC/OS <code>OSSemPend()</code> call), the system first checks to see if this counter is 0. If so, the code blocks; if not, the code decrements the counter and enters the critical section. Note that if you initialize a semaphore with 1, it behaves like a critical section variable.</p>&#13;
<p>µC/OS semaphores use three main functions: <code>OSSemInit()</code>, <code>OSSemPend()</code>, and <code>OSSemPost()</code>. In addition to initializing internal data structures, the <code>OSSemInit()</code> function allows you to initialize the counter with the integer; for managing critical sections, the initial value is usually 0 or 1. As already noted, the <code>OSSemPend()</code> function checks the counter for 0 (and blocks if 0) and decrements the counter if it is nonzero, as well as allowing entry into the critical section. <code>OSSemPost()</code> increments the counter associated with the semaphore. This means you would normally use <code>OSSemPend()</code> to enter a critical section and <code>OSSemPost()</code> to leave a critical section.</p>&#13;
<p>The trick in <a href="#listing10-2">Listing 10-2</a> is to use two semaphores, <code>mainSem</code> and <code>threadSem</code>, to protect access to the DACs by multiple tasks <span aria-label="annotation1" class="CodeAnnotation">❶</span>.  Whenever one of these semaphores contains 1, the associated task can execute; when the semaphore is 0, the task will block. The trick is to make sure that the two threads alternate setting the semaphores to 0 or 1 to allow execution to “ping-pong” between the two tasks.</p>&#13;
<p>If you look at the <code>DACout()</code> function in <a href="#listing10-2">Listing 10-2</a>, you’ll see that a task enters its critical section by executing <code>OSSemPend()</code> on the semaphore associated with that task <span aria-label="annotation2" class="CodeAnnotation">❷</span>. To exit the critical section, the code executes the <code>OSSemPost()</code> function on the semaphore associated with the other thread <span aria-label="annotation4" class="CodeAnnotation">❹</span>. This might seem incorrect, but let’s consider this sequence step-by-step:</p>&#13;
<ol class="decimal">&#13;
<li value="1">Assume the <code>mainSem</code> (enter parameter) counter is 1 and the <code>threadSem</code> (leave parameter) is 0.</li>&#13;
<li value="2">Upon executing <code>OSSemPend( enter, 0 );</code>, the system decrements the counter to 0 and enters the critical section (because the counter wasn’t already 0). Note that because the <code>UserMain()</code> task has a higher priority than the <code>DACthread()</code> task, the <code>UserMain()</code> task continues execution (and the <code>DACthread()</code> task is currently blocked).</li>&#13;
<li value="3">The <code>UserMain()</code> task writes data to the I<sup>2</sup>C bus <span aria-label="annotation3" class="CodeAnnotation">❸</span>.</li>&#13;
<li value="4">The <code>UserMain()</code> task executes <code>OSSemPend()</code> on the <code>threadSem</code> semaphore (<code>leave</code> parameter) <span aria-label="annotation4" class="CodeAnnotation">❹</span>. This increments the counter associated with <code>threadSem</code>; note that the <code>mainSem</code> counter is still 0.</li>&#13;
<li value="5">The <code>UserMain()</code> task continues execution, which in this case means repeating the loop and re-executing the <code>OSSemPend()</code> function at <span aria-label="annotation3" class="CodeAnnotation">❸</span>.  Because the counter is now 0, the task blocks.</li>&#13;
<li value="6"><span epub:type="pagebreak" id="Page_189" title="189"/>Once <code>UserMain()</code> blocks, the <code>DACthread()</code> task begins execution and eventually winds up in <code>DACout()</code> executing the <code>OSSemPend()</code> call. Because the <code>OSSemPost( leave );</code> call in the <code>UserMain()</code> task incremented the <code>threadSem</code> counter, the counter now contains 1 so the <code>DACthread()</code> task can enter its critical section.</li>&#13;
<li value="7">The <code>DACthread()</code> task calls <code>DACout()</code> to write a value to the DAC.</li>&#13;
<li value="8">The <code>DACthread()</code> task exits its critical section by calling <code>OSSemPost()</code> but passing the <code>mainSem</code> semaphore variable. This increments the <code>mainSem</code> counter; note that the <code>threadSem</code> counter is still 0.</li>&#13;
<li value="9">Because the <code>UserMain()</code> thread has the highest priority, it immediately takes over, and this process repeats itself.</li>&#13;
</ol>&#13;
<p>Note that both tasks in <a href="#listing10-2">Listing 10-2</a> call the <code>DACout()</code> function to actually write the data to the DAC (the DAC address and the two semaphores are passed as arguments). The calls to <code>DACout()</code> swap the two semaphore arguments so that <code>UserMain()</code> passes <code>mainSem</code> as the first semaphore argument, whereas <code>DACthread()</code> passes <code>threadSem</code> as the first semaphore argument.</p>&#13;
<p><a href="#figure10-2" id="figureanchor10-2">Figure 10-2</a> shows the oscilloscope output for the program in <a href="#listing10-2">Listing 10-2</a>.</p>&#13;
<figure>&#13;
<img alt="" class="keyline" height="304" src="image_fi/502468c10/f10002.png" width="416"/>&#13;
<figcaption><p><a id="figure10-2">Figure 10-2</a>: Oscilloscope output from <a href="#listing10-2">Listing 10-2</a></p></figcaption>&#13;
</figure>&#13;
<p>As you can see, both tasks are producing proper triangle waves. The frequency of the triangle waves in <a href="#figure10-2">Figure 10-2</a> is about half that of <a href="#figure10-1">Figure 10-1</a> (note the time scale for the oscilloscope in the two figures). The reason for this discrepancy is that the frequency is completely determined by the speed at which the program transmits data to the MCP4725. In <a href="#listing10-2">Listing 10-2</a>, twice as much data is transmitted by sending roughly the same data to both MCP4725 devices, so the frequency is cut roughly in half.</p>&#13;
<h3 id="h2-502468c10-0007">10.2.2	FreeRTOS I<sup>2</sup>C Programming</h3>&#13;
<p class="BodyFirst">FreeRTOS is, in its developer’s words, “the market leading, de facto standard, and cross platform RTOS kernel.” You’ll likely encounter this popular open source kernel if you work with many different RTOSs. </p>&#13;
<p><span epub:type="pagebreak" id="Page_190" title="190"/>To use FreeRTOS, you’ll need a port of the OS to your particular device (or you’ll have to port it yourself). In this chapter I’m going to use the Teensy 4.0 port created by Julian Desvignes running under the PlatformIO IDE (<a class="LinkURL" href="https://platformio.org/lib/show/6737/FreeRTOS-Teensy4">https://platformio.org/lib/show/6737/FreeRTOS-Teensy4</a>). The PlatformIO, FreeRTOS, and Teensy4  port uses the Arduino library and Teensyduino support to run FreeRTOS code in an Arduino environment. This makes it possible to create multithreaded applications while using Arduino-style programming. </p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>	Chapter 30 (online at <a class="LinkURL" href="https://bookofi2c.randallhyde.com">https://bookofi2c.randallhyde.com</a>) discusses using FreeRTOS with the ESP32 SBC module.</p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<p>Because FreeRTOS is just a scheduler that provides basic task switching functionality along with synchronization primitives, you’ll have to provide your own I<sup>2</sup>C library code. Fortunately, such code is easy to find from the Arduino libraries and elsewhere. However, the Arduino libraries are not reentrant, so you have to ensure that only one task is calling a particular library function (or family of functions) using mutexes, critical sections, semaphores, or other synchronization operations. See <a class="LinkURL" href="https://www.freertos.org/a00113.xhtml">https://www.freertos.org/a00113.xhtml</a> for more details on FreeRTOS synchronization primitives.</p>&#13;
<p><a href="#listing10-3" id="listinganchor10-3">Listing 10-3</a> presents the usual triangle wave output demo under FreeRTOS that creates two tasks; one of the tasks will blink the Teensy’s LED, and the other will output the triangle wave data to the MCP4725 DAC device:</p>&#13;
<pre><code>// <a id="listing10-3">Listing 10-3</a> (main.cpp)&#13;
// &#13;
// Simple demonstration of I2C programming&#13;
// under FreeRTOS running on a Teensy 4.0.&#13;
&#13;
#include &lt;FreeRTOS_TEENSY4.h&gt;&#13;
#include &lt;Wire.h&gt;&#13;
&#13;
#define ever ;;&#13;
&#13;
// The LED is attached to pin 13 on the Teensy 4.0.&#13;
&#13;
const uint8_t LED_PIN = 13;&#13;
&#13;
// Thread1-&#13;
//&#13;
// This task blinks the Teensy 4.0's LED&#13;
// every second (1/2 second on, 1/2 second off).&#13;
&#13;
static void Thread1( void* arg )&#13;
{&#13;
    for( ever )&#13;
    {&#13;
&#13;
        // Turn LED on:&#13;
&#13;
<span epub:type="pagebreak" id="Page_191" title="191"/>        digitalWrite( LED_PIN, HIGH );&#13;
&#13;
        // Delay 1/2 second:&#13;
&#13;
        vTaskDelay( (500 * configTICK_RATE_HZ) / 1000 );&#13;
&#13;
        // Turn LED off:&#13;
&#13;
        digitalWrite( LED_PIN, LOW );&#13;
&#13;
        // Delay 1/2 second:&#13;
&#13;
        vTaskDelay( (500 * configTICK_RATE_HZ) / 1000 );&#13;
    }&#13;
}&#13;
&#13;
// Thread2-&#13;
//&#13;
// This task outputs a triangle wave&#13;
// to the MCP4725 device at address 0x62&#13;
// (i.e., an Adafruit MCP4725 breakout board).&#13;
&#13;
static void Thread2( void* arg )&#13;
{&#13;
&#13;
for( ever )&#13;
    {&#13;
        for( uint16_t dacOut = 0; dacOut &lt; 0xfff; ++dacOut )&#13;
        {&#13;
            // Transmit the address byte (and a zero R/W bit):&#13;
&#13;
            Wire.beginTransmission( 0x62 );&#13;
&#13;
            // Transmit the 12-bit DAC value (HO 4 bits first,&#13;
            // LO 8 bits second) along with a 4-bit&#13;
            // "fast write" command (0000 in the HO 4 bits&#13;
            // of the first byte):&#13;
&#13;
            Wire.write( (dacOut &lt;&lt; 8) &amp; 0xf );&#13;
            Wire.write( dacOut &amp; 0xff );&#13;
&#13;
            // Send the stop condition onto the I2C bus:&#13;
&#13;
            Wire.endTransmission( true );&#13;
        }   // for&#13;
&#13;
        // Send the falling edge of the triangle wave:&#13;
&#13;
        for( uint16_t dacOut = 0xffe; dacOut &gt; 0; --dacOut )&#13;
        {&#13;
            // See comments in previous loop.&#13;
&#13;
            Wire.beginTransmission( 0x62 );&#13;
            Wire.write( (dacOut &lt;&lt; 8) &amp; 0xf );&#13;
            Wire.write( dacOut &amp; 0xff );&#13;
<span epub:type="pagebreak" id="Page_192" title="192"/>            Wire.endTransmission( true );&#13;
        }   // for&#13;
    }       // forever&#13;
} // Thread2&#13;
&#13;
// In FreeRTOS for the Teensy 4.0, the&#13;
// Arduino "setup" function is really the&#13;
// equivalent of the main program.&#13;
&#13;
void setup()&#13;
{&#13;
    portBASE_TYPE s1, s2;&#13;
&#13;
    pinMode( LED_PIN, OUTPUT ); // LED is output&#13;
    Wire.begin();               // Initialize I2C library&#13;
&#13;
    // Create task at priority two&#13;
    // Arguments:&#13;
    //&#13;
    //  1.  Address of function to serve as task code.&#13;
    //  2.  A descriptive name for the task (can be NULL).&#13;
    //  3.  Stack depth for the task.&#13;
    //  4.  Parameter to pass to task.&#13;
    //  5.  Task priority.&#13;
    //  6.  Task handle returned here (ignored if NULL).&#13;
&#13;
    s1 =    xTaskCreate&#13;
            (&#13;
                Thread1,&#13;
                NULL,&#13;
                configMINIMAL_STACK_SIZE,&#13;
                NULL,&#13;
                2,&#13;
                NULL&#13;
            );&#13;
&#13;
    // Create task at priority one&#13;
    // (see comments above concerning parms).&#13;
&#13;
    s2 =    xTaskCreate&#13;
            (&#13;
                Thread2,&#13;
                NULL,&#13;
                configMINIMAL_STACK_SIZE,&#13;
                NULL,&#13;
                1,&#13;
                NULL&#13;
            );&#13;
&#13;
    if ( s1 == pdPASS &amp;&amp; s2 == pdPASS )&#13;
<span epub:type="pagebreak" id="Page_193" title="193"/>    {&#13;
&#13;
        // Start scheduler:&#13;
&#13;
        vTaskStartScheduler();&#13;
    }&#13;
&#13;
    // Drop down here if there was&#13;
    // insufficient RAM to create&#13;
    // the tasks or if there was&#13;
    // any other problem in their&#13;
    // creation.&#13;
&#13;
    for( ever );&#13;
}&#13;
&#13;
// WARNING: idle loop has a very small stack&#13;
// (configMINIMAL_STACK_SIZE), so&#13;
// loop must never block.&#13;
&#13;
void loop()&#13;
{&#13;
    // Not used.&#13;
}</code></pre>&#13;
<p>The actual I<sup>2</sup>C code was taken straight out of Listing 8-1 (Arduino code), which is not reentrant code. The key thing to note is that the tasks do not call common library code. <code>Thread1()</code> calls only the Arduino <code>digitalWrite()</code> function, and <code>Thread2()</code> calls only the <code>Wire</code> class functions. Had this example tried to write to I<sup>2</sup>C devices from two separate tasks (even devices on separate I<sup>2</sup>C buses), it would have required mutexes to ensure that only one task at a time could actually execute those function calls. Here’s an example:</p>&#13;
<pre><code>SemaphoreHandle_t xSemaphore = NULL;&#13;
    .&#13;
    .&#13;
    .&#13;
xSemaphore = xSemaphoreCreateMutex();&#13;
    .&#13;
    .&#13;
    .&#13;
if( xSemaphoreTake( xSemaphore, portMAX_DELAY ) == pdTRUE )&#13;
{&#13;
          // Own the critical section.&#13;
       .&#13;
       .  // In critical section, access I2C device here.&#13;
       .&#13;
   xSemaphoreGive( xSemaphore );&#13;
}&#13;
</code></pre>&#13;
<p><span epub:type="pagebreak" id="Page_194" title="194"/><a href="#figure10-3" id="figureanchor10-3">Figure 10-3</a> shows the oscilloscope output from the program in the FreeRTOS demonstration program. </p>&#13;
<figure>&#13;
<img alt="" class="keyline" height="304" src="image_fi/502468c10/f10003.png" width="416"/>&#13;
<figcaption><p><a id="figure10-3">Figure 10-3</a>: Oscilloscope output from <a href="#listing10-3">Listing 10-3</a></p></figcaption>&#13;
</figure>&#13;
<p>Because this program is writing only one stream of data to the MCP4725, the frequency is back up to about 0.5 Hz (again, this is limited by the 100-kHz data transmission speed).</p>&#13;
<h3 id="h2-502468c10-0008">10.2.3	Teensy Threads I<sup>2</sup>C Programming</h3>&#13;
<p class="BodyFirst">There are thread scheduling packages written for many low-end SBCs that you can grab off the Internet and use in simple applications. In this section, I’ll demonstrate how to use one such package: the Teensy Threading Library, created by Fernando Trias. This section also uses the Teensy 4.0 I<sup>2</sup>C library by Richard Gemmell. (See “For More Information” for the links.) It supports the Teensy 3.<em>x</em> and 4.<em>x</em> CPU modules from PJRC and it has the ability to create multiple threads—up to eight, by default, though this can be changed—along with some simple synchronization primitives and various thread utilities. Because the Teensy Threads package uses the term <em>threads</em>, I will use that specific term in this section rather than <em>tasks</em>.</p>&#13;
<p>The Teensy Threading Library is an Arduino library that assumes code is being developed in the Arduino programming model; as such, when you work with Teensy Threads, use the standard Arduino (or Teensy-specific) I<sup>2</sup>C programming libraries to communicate with I<sup>2</sup>C devices. Remember that Arduino code is not reentrant and must be protected when called from various threads. The example in this section will avoid calling the same function in different threads so that synchronization is not required.</p>&#13;
<p>The program in <a href="#listing10-4" id="listinganchor10-4">Listing 10-4</a> demonstrates multithreading using the Teensy Threading Library. It creates three additional threads (plus the main thread that continues execution). One thread blinks the LED every second, two threads transmit triangle waves to MCP 4725 DAC devices (on separate I<sup>2</sup>C buses), and the main thread writes “loop” to the serial output every two seconds.</p>&#13;
<pre><code><span epub:type="pagebreak" id="Page_195" title="195"/>// <a id="listing10-4">Listing 10-4</a> (Listing10-4.ino)&#13;
//&#13;
// Simple demonstration of I2C programming&#13;
// using Teensy Threads running on a Teensy 4.0.&#13;
&#13;
#include &lt;TeensyThreads.h&gt;&#13;
#include &lt;i2c_driver_wire.h&gt;&#13;
&#13;
#define ever ;;&#13;
&#13;
#define dac1 0x62&#13;
#define dac2 0x60&#13;
&#13;
// The LED is attached to pin 13 on the Teensy 4.0.&#13;
&#13;
const uint8_t LED_PIN = 13;&#13;
&#13;
// Thread1-&#13;
//&#13;
// This thread blinks the Teensy 4.0's LED&#13;
// every second (1/2 second on, 1/2 second off).&#13;
&#13;
<span aria-label="annotation1" class="CodeAnnotationCode">❶</span> static void Thread1( int arg )&#13;
{&#13;
    for( ever )&#13;
    {&#13;
&#13;
        // Turn LED on:&#13;
&#13;
        digitalWrite( LED_PIN, HIGH );&#13;
&#13;
        // Delay 1/2 second:&#13;
&#13;
        delay( 500 );&#13;
&#13;
        // Turn LED off:&#13;
&#13;
        digitalWrite( LED_PIN, LOW );&#13;
&#13;
        // Delay 1/2 second:&#13;
&#13;
        delay( 500 );&#13;
    }&#13;
}&#13;
&#13;
// Thread2-&#13;
//&#13;
// This thread outputs a triangle wave&#13;
// to the MCP4725 device at address 0x62 on&#13;
// I2C bus zero (SDA0/SCL0 on Teensy 4.0)&#13;
// (i.e., an Adafruit MCP4725 breakout board).&#13;
&#13;
<span aria-label="annotation2" class="CodeAnnotationCode">❷</span> static void Thread2( int arg )&#13;
<span epub:type="pagebreak" id="Page_196" title="196"/>{&#13;
    for( ever )&#13;
    {&#13;
        for( uint16_t dacOut = 0; dacOut &lt; 0xfff; ++dacOut )&#13;
        {&#13;
            // Transmit the adrs byte (and a 0 R/W bit):&#13;
&#13;
            Wire.beginTransmission( dac1 );&#13;
&#13;
            // Transmit the 12-bit value (HO 4 bits first,&#13;
            // LO 8 bits second) along with a 4-bit&#13;
            // "fast write" command (0000 in the HO 4 bits&#13;
            // of the first byte):&#13;
&#13;
            Wire.write( (dacOut &lt;&lt; 8) &amp; 0xf );&#13;
            Wire.write( dacOut &amp; 0xff );&#13;
&#13;
            // Send the stop condition onto the I2C bus:&#13;
&#13;
            Wire.endTransmission( true );&#13;
        }   // for&#13;
&#13;
        // Send the falling edge of the triangle wave:&#13;
&#13;
        for( uint16_t dacOut = 0xffe; dacOut &gt; 0; --dacOut )&#13;
        {&#13;
            // See comments in previous loop.&#13;
&#13;
            Wire.beginTransmission( dac1 );&#13;
            Wire.write( (dacOut &lt;&lt; 8) &amp; 0xf );&#13;
            Wire.write( dacOut &amp; 0xff );&#13;
            Wire.endTransmission( true );&#13;
        }   // for&#13;
    }       // forever&#13;
} // Thread2&#13;
&#13;
// Thread3-&#13;
//&#13;
// This thread outputs a triangle wave&#13;
// to the MCP4725 device at address dac2 on&#13;
// I2C bus one (SDA1/SCL1 on Teensy 4.0)&#13;
// (i.e., an Adafruit MCP4725 breakout board).&#13;
&#13;
<span aria-label="annotation3" class="CodeAnnotationCode">❸</span> static void Thread3( int arg )&#13;
{&#13;
    for( ever )&#13;
    {&#13;
        for( uint16_t dacOut = 0; dacOut &lt; 0xfff; ++dacOut )&#13;
        {&#13;
            // Transmit the adrs byte (and a 0 R/W bit):&#13;
&#13;
            Wire1.beginTransmission( dac2 );&#13;
&#13;
            // Transmit the 12-bit DAC value (HO 4 bits &#13;
            // first, LO 8 bits second) along with a &#13;
<span epub:type="pagebreak" id="Page_197" title="197"/>            // 4-bit "fast write" command (0000 in the HO &#13;
            // 4 bits of the first byte):&#13;
&#13;
            Wire1.write( (dacOut &lt;&lt; 8) &amp; 0xf );&#13;
            Wire1.write( dacOut &amp; 0xff );&#13;
&#13;
            // Send the stop condition onto the I2C bus:&#13;
&#13;
            Wire1.endTransmission( true );&#13;
        }   // for&#13;
&#13;
        // Send the falling edge of the triangle wave:&#13;
&#13;
        for( uint16_t dacOut = 0xffe; dacOut &gt; 0; --dacOut )&#13;
        {&#13;
            // See comments in previous loop.&#13;
&#13;
            Wire1.beginTransmission( dac2 );&#13;
            Wire1.write( (dacOut &lt;&lt; 8) &amp; 0xf );&#13;
            Wire1.write( dacOut &amp; 0xff );&#13;
            Wire1.endTransmission( true );&#13;
        }   // for&#13;
    }       // forever&#13;
} // Thread3&#13;
&#13;
// In TeensyThreads for the Teensy 4.0, the&#13;
// Arduino "setup" function is really the&#13;
// equivalent of the main program.&#13;
&#13;
void setup()&#13;
{&#13;
&#13;
    Serial.begin( 9600 );&#13;
    pinMode( LED_PIN, OUTPUT ); // LED is output&#13;
    Wire.begin();               // Initialize I2C port 0&#13;
    Wire1.begin();              // Initialize I2C port 1&#13;
&#13;
    // Create thread&#13;
    // Arguments:&#13;
    //&#13;
    //  1.  Address of function to serve as thread code.&#13;
    //  2.  Optional argument passed to thread function.&#13;
    //  3.  Stack size (default is 1024).&#13;
    //  4.  Stack address (default is on heap).&#13;
&#13;
  <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> int id1 = threads.addThread( Thread1,  0 );&#13;
    if ( id1 == -1 )&#13;
    {&#13;
&#13;
        Serial.println( "Thread 1 creation failed" );&#13;
        for( ever );&#13;
    }&#13;
&#13;
    // Create task at priority one&#13;
    // (see comments above concerning parms).&#13;
<span epub:type="pagebreak" id="Page_198" title="198"/>&#13;
  <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> int id2 = threads.addThread( Thread2, 0 );&#13;
    if ( id2 == -1 )&#13;
    {&#13;
&#13;
        Serial.println( "Thread 2 creation failed" );&#13;
        for( ever );&#13;
    }&#13;
&#13;
    // Create task at priority three&#13;
    // (see comments above concerning parms).&#13;
	&#13;
  <span aria-label="annotation6" class="CodeAnnotationCode">❻</span> int id3 = threads.addThread( Thread3, 0 );&#13;
    if ( id3 == -1 )&#13;
    {&#13;
&#13;
        Serial.println( "Thread 3 creation failed" );&#13;
        for( ever );&#13;
    }&#13;
}&#13;
&#13;
// The loop function is, essentially, a fourth thread&#13;
// of execution.&#13;
&#13;
<span aria-label="annotation7" class="CodeAnnotationCode">❼</span> void loop()&#13;
{&#13;
    Serial.println( "loop" );&#13;
    delay( 2000 );&#13;
}</code></pre>&#13;
<p>The <code>Thread1()</code> function executes for the first thread, blinking the LED on the Teensy <span aria-label="annotation1" class="CodeAnnotation">❶</span>. The <code>Thread2()</code> function writes a triangle wave to the DAC at address <code>dac1</code> (0x62) connected to the Teensy’s I<sup>2</sup>C port 0 <span aria-label="annotation2" class="CodeAnnotation">❷</span>. The <code>Thread3() </code>function writes a triangle wave to the DAC at address <code>dac2</code> (0x60) connected to the Teensy’s I<sup>2</sup>C port 1 <span aria-label="annotation3" class="CodeAnnotation">❸</span>. Note that because the two DACs are on different I<sup>2</sup>C ports, the code does not need to synchronize access to the devices.</p>&#13;
<p>The <code>setup()</code> function starts the three threads by calling <code>threads.addThread()</code> <span aria-label="annotation4" class="CodeAnnotation">❹</span>, <span aria-label="annotation5" class="CodeAnnotation">❺</span>, and <span aria-label="annotation6" class="CodeAnnotation">❻</span> and passing in the addresses of the three thread functions. The <code>loop()</code> function effectively becomes a fourth thread <span aria-label="annotation7" class="CodeAnnotation">❼</span>.</p>&#13;
<p>Because the <code>i2c_driver_wire</code> library allocates separate memory objects for <code>wire</code> (SDA0 and SCL0) and <code>wire1</code> (SDA1 and SCL1), calls through these two separate objects do not interfere with one another when called from different threads. Were two different threads to call <code>wire</code> simultaneously, the code would have needed to protect the calls using the Teensy Threads <code>lock()</code> and <code>unlock()</code> functions:</p>&#13;
<pre><code>Threads::Mutex wire_lock;&#13;
    .&#13;
    .&#13;
    .&#13;
   wire_lock.lock();&#13;
&#13;
<span epub:type="pagebreak" id="Page_199" title="199"/>          Wire.beginTransmission( 0x62 );&#13;
          Wire.write( (dacOut &lt;&lt; 8) &amp; 0xf );&#13;
          Wire.write( dacOut &amp; 0xff );&#13;
          Wire.endTransmission( true );&#13;
&#13;
   wire_lock.unlock();</code></pre>&#13;
<p><a href="#figure10-4" id="figureanchor10-4">Figure 10-4</a> shows the oscilloscope output for the program in <a href="#listing10-4">Listing 10-4</a>. The time base has changed for this display (two seconds per major division rather than one). </p>&#13;
<figure>&#13;
<img alt="" class="keyline" height="304" src="image_fi/502468c10/f10004.png" width="416"/>&#13;
<figcaption><p><a id="figure10-4">Figure 10-4</a>: Oscilloscope output from <a href="#listing10-4">Listing 10-4</a></p></figcaption>&#13;
</figure>&#13;
<p>As you can see, the frequency here is much slower than in previous examples (note the time scale on the oscilloscope). This is likely due to the interaction between the synchronous I<sup>2</sup>C library calls and the Teensy Threads package, a typical issue when you bolt on a threading library to a nonthreading package (like Arduino) versus running a true RTOS.</p>&#13;
<h3 id="h2-502468c10-0009">10.2.4	Mbed I<sup><em>2</em></sup>C Programming</h3>&#13;
<p class="BodyFirst">Mbed is an RTOS developed by ARM Limited for use on ARM CPUs. It is marketed as an IoT development system, though it is certainly useful for normal embedded applications. Unlike many RTOSs, which tend to be very generic, Mbed fully supports features found on typical ARM MCUs, including I<sup>2</sup>C and other peripherals. The Mbed RTOS provides a rich set of I<sup>2</sup>C functions you can use in your applications. The library is thread safe, so you don’t have to worry about protecting calls across various threads (of course, your applications must synchronize access to specific devices on the I<sup>2</sup>C bus).</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>	This section uses the term <em>thread</em> rather than the generic term <em>task</em> used elsewhere in the chapter, in keeping with standard Mbed terminology.</p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<p>ARM also provides the Mbed Studio IDE that runs under Linux, macOS, or Windows (see “For More Information” for the link). Mbed Studio allows you to edit, compile, run, and debug your applications on any Mbed-enabled SBC.</p>&#13;
<p><span epub:type="pagebreak" id="Page_200" title="200"/><a href="#listing10-5" id="listinganchor10-5">Listing 10-5</a> provides the standard MCP4725 triangle wave output program running under Mbed. This program has two threads: the main thread and a second thread that it starts. Each thread produces a triangle wave output on separate MCP4725 devices. This particular program runs on an STMicroelectronics Nucleo-F767ZI board (<a class="LinkURL" href="https://www.st.com/en/evaluation-tools/nucleo-f767zi.xhtml">https://www.st.com/en/evaluation-tools/nucleo-f767zi.xhtml</a>) that I found on Amazon for around $35; you can also use the NUCLEO-WB55RG available from SparkFun for around $40 (<a class="LinkURL" href="https://www.sparkfun.com/products/17943">https://www.sparkfun.com/products/17943</a>). Of the several I<sup>2</sup>C ports this board supports, I used ports one and two for the program in <a href="#listing10-5">Listing 10-5</a>.</p>&#13;
<pre><code>// <a href="#listinganchor10-5" id="listing10-5">Listing10-5</a>.cpp&#13;
//&#13;
// Mbed RTOS I2C programming example.&#13;
//&#13;
// This program writes triangle wave&#13;
// data to two MCP4725 DAC devices at&#13;
// addresses 0x62 and 0x63 on I2C ports&#13;
// one and two on a Nucleo-F767ZI board.&#13;
// Or ports one and three on a&#13;
// Nucleo-WB55RG board.&#13;
&#13;
#include "PinNames.h"&#13;
#include "mbed.h"&#13;
#include "mbed_wait_api.h"&#13;
&#13;
#define ever ;;&#13;
#define mcp4725a (0x62 &lt;&lt; 1)&#13;
#define mcp4725b (0x63 &lt;&lt; 1)&#13;
&#13;
// Thread1-&#13;
//&#13;
// Writes a triangle wave to the&#13;
// MCP4726 at address 0x62 on&#13;
// I2C port 1.&#13;
&#13;
<span aria-label="annotation1" class="CodeAnnotationCode">❶</span> void Thread1( void )&#13;
{&#13;
    int  cntr = 0;&#13;
    char data[2];&#13;
    I2C i2c1( I2C_SDA, I2C_SCL );&#13;
    &#13;
    // Set bus frequency to 100 kHz&#13;
    // (this is actually the default,&#13;
    // this call appears here for&#13;
    // testing purposes).&#13;
    &#13;
    i2c1.frequency( 100000 );&#13;
&#13;
    // Create a continuous triangle&#13;
    // wave output:&#13;
    &#13;
    for( ever )&#13;
<span epub:type="pagebreak" id="Page_201" title="201"/>    {&#13;
        // Create the rising edge of the&#13;
        // triangle wave:&#13;
        &#13;
        for( int tri=0; tri &lt; 4095; ++tri )&#13;
        {&#13;
            // Note: MCP4725 requires that you&#13;
            // transmit the HO byte first, followed&#13;
            // by the LO byte of the 16-bit&#13;
            // DAC value (HO 4 bits are zeros).&#13;
            &#13;
            data[0] = (char) (tri &gt;&gt; 8) &amp; 0xff;&#13;
            data[1] = (char) (tri &amp; 0xff);&#13;
            i2c1.write ( mcp4725a, data, 2, false );&#13;
        }&#13;
        &#13;
        // Create the falling edge of the&#13;
        // triangle wave:&#13;
                &#13;
        for( int tri=4094; tri &gt; 0; --tri )&#13;
        {&#13;
            data[0] = (char) (tri &gt;&gt; 8) &amp; 0xff;&#13;
            data[1] = (char) (tri &amp; 0xff);&#13;
            i2c1.write ( mcp4725a, data, 2, false );&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
// Application main program and main thread.&#13;
// This starts Thread1 and then emits the&#13;
// triangle wave on the second MCP4725:&#13;
&#13;
int main() &#13;
{&#13;
    int  cntr = 0;&#13;
    char data[2];&#13;
    Thread thread1;&#13;
&#13;
    // Nucleo-F767ZI: PB_11, PB_10&#13;
    // Nucleo-WB55RG: A1, A0&#13;
&#13;
    I2C i2c2( PB_11, PB_10 );&#13;
&#13;
    i2c2.frequency( 100000 );&#13;
   &#13;
    // Start the thread:&#13;
    &#13;
    thread1.start( Thread1 );&#13;
    &#13;
    // Emit the second triangle wave to&#13;
    // the MCP4725 at address 0x63 on&#13;
    // I2C bus two:&#13;
    &#13;
    for( ever )&#13;
<span epub:type="pagebreak" id="Page_202" title="202"/>    {&#13;
      <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> // See comments in Thread1.&#13;
        &#13;
        for( int tri=0; tri &lt; 4095; ++tri )&#13;
        {&#13;
            data[0] = (char) (tri &gt;&gt; 8) &amp; 0xff;&#13;
            data[1] = (char) (tri &amp; 0xff);&#13;
            i2c2.write ( mcp4725b, data, 2, false );&#13;
        }        &#13;
        for( int tri=4094; tri &gt; 0; --tri )&#13;
        {&#13;
            data[0] = (char) (tri &gt;&gt; 8) &amp; 0xff;&#13;
            data[1] = (char) (tri &amp; 0xff);&#13;
            i2c2.write ( mcp4725b, data, 2, false );&#13;
        }&#13;
    }    &#13;
}</code></pre>&#13;
<p>The code for the first thread writes a triangle wave to the DAC on I<sup>2</sup>C bus 1 <span aria-label="annotation1" class="CodeAnnotation">❶</span>. It sets the I<sup>2</sup>C clock frequency to 100 kHz and then writes out 4,000 increasing DAC values followed by 4K decreasing DAC values. The code for the second thread (the main program <span aria-label="annotation2" class="CodeAnnotation">❷</span>) writes a triangle wave to the DAC on I<sup>2</sup>C bus 2 using the same algorithm as employed by <code>Thread1()</code>.</p>&#13;
<p>Once again, the sample program in <a href="#listing10-5">Listing 10-5</a> avoids synchronization issues by writing to DAC devices on two separate buses. The triangle wave outputs on the oscilloscope appear in <a href="#figure10-5" id="figureanchor10-5">Figure 10-5</a>.</p>&#13;
<figure>&#13;
<img alt="" class="keyline" height="304" src="image_fi/502468c10/f10005.png" width="416"/>&#13;
<figcaption><p><a id="figure10-5">Figure 10-5</a>: Triangle wave output from <a href="#listing10-5">Listing 10-5</a></p></figcaption>&#13;
</figure>&#13;
<p>If you look closely at <a href="#figure10-5">Figure 10-5</a>, you’ll notice that the frequency is about half of what you normally get for this application. Though two separate ports should be able to operate independently, these two ports alternate outputting data to the DACs, as shown by the logic analyzer output in <a href="#figure10-6" id="figureanchor10-6">Figure 10-6</a>. The top two traces are from port one; the bottom two traces are from port two. </p>&#13;
<span epub:type="pagebreak" id="Page_203" title="203"/><figure>&#13;
<img alt="" class="keyline" height="160" src="image_fi/502468c10/f10006.png" width="844"/>&#13;
<figcaption><p><a id="figure10-6">Figure 10-6</a>: Logic analyzer output from the program in <a href="#listing10-5">Listing 10-5</a></p></figcaption>&#13;
</figure>&#13;
<p>I can’t say for sure whether the two ports operating at half speed is because of a limitation of the hardware (or the particular I<sup>2</sup>C device driver for the hardware port) or the fact that Mbed’s thread-safe code doesn’t allow concurrent I<sup>2</sup>C transmissions. Whatever the case, the result is that it’s only about half the bandwidth on each bus that you’d expect, and you probably could have gotten the same performance by putting both devices on the same I<sup>2</sup>C bus. </p>&#13;
<h2 id="h1-502468c10-0003">	10.3	Other Real-Time Operating System I<sup>2</sup>C Programming</h2>&#13;
<p class="BodyFirst">Several RTOSs beyond those discussed in this chapter support I<sup>2</sup>C devices. Due to limited space in this chapter and the lack of development systems on my part, I won’t include example code for these operating systems, but they still deserve mention.</p>&#13;
<ol class="none">&#13;
<li><span class="RunInHead">QNX</span>  One of the older microcomputer RTOSs. Pronounced “cue-nix,” it was originally named Qunix; although it changed its name to avoid trademark infringement, it started out as a “Unix-like” microkernel operating system running on the original IBM PC (an 8088 CPU). It then quickly morphed into an RTOS supporting embedded systems and became very popular in that field. </li>&#13;
<li>QNX was originally developed by Quantum Software Systems (QSS), who changed the company’s name to QNX Software Systems. QNX Software Systems was bought out by BlackBerry, and QNX became the basis for BlackBerry’s tablet and phone offerings after the rise of the Apple iPad. Though the BlackBerry phones and tablets eventually died out, QNX prospered as an OS specifically targeted at automotive and safety-based applications.</li>&#13;
<li>QNX provides I<sup>2</sup>C communications “baked into” the OS. You can read about the I<sup>2</sup>C API at the QNX website at <a class="LinkURL" href="http://www.qnx.com/developers/docs/6.5.0_sp1/index.jsp?topic=%2Fcom.qnx.doc.neutrino_technotes%2Fi2c_framework.xhtml">http://www.qnx.com/developers/docs/6.5.0_sp1/index.jsp?topic=%2Fcom.qnx.doc.neutrino_technotes%2Fi2c_framework.xhtml</a> (or just search for “QNX I<sup>2</sup>C Programming”). </li>&#13;
<li><span class="RunInHead">VxWorks</span>  Another early RTOS that appeared in the late 1980s from Wind River Associates. It was based on an earlier operating system, VRTX, which was created by Mentor Graphics (see <a class="LinkURL" href="https://en.wikipedia.org/wiki/VxWorks">https://en.wikipedia.org/wiki/VxWorks</a> for more history). VxWorks has been very popular in hardcore <span epub:type="pagebreak" id="Page_204" title="204"/>embedded systems requiring safety, including aerospace, medical, and nuclear applications. If QNX is best known for automotive applications, VxWorks is best known for aerospace applications. </li>&#13;
<li>As you can imagine, VxWorks is not a low-cost or open source system hobbyists often use. It does, however, have a no-cost license available for noncommercial or hobbyist use (see <a class="LinkURL" href="https://labs.windriver.com/vxworks-sdk">https://labs.windriver.com/vxworks-sdk</a>) that runs on Raspberry Pi and other SBCs. Like QNX, VxWorks includes built-in support for I<sup>2</sup>C device programming. For more information on the VxWorks I<sup>2</sup>C library, see <a class="LinkURL" href="https://docs.windriver.com/bundle/vxworks_7_application_core_os_sr0630-enus/page/VXBUS/vxbI2cLib.xhtml">https://docs.windriver.com/bundle/vxworks_7_application_core_os_sr0630-enus/page/VXBUS/vxbI2cLib.xhtml</a>.</li>&#13;
<li><span class="RunInHead">eCos</span>  The embedded configurable operating system (eCos) was originally developed by Cygnus (of Windows and Unix shell fame) and was later bought out by Red Hat. Eventually, Red Hat abandoned eCos, releasing it as open source, and some of the original developers created eCos Pro as a commercial product. For a couple of years now, they’ve been promising to deliver a version that runs on Raspberry Pi systems. However, as I’m writing this, that version is yet to appear.  </li>&#13;
<li>For more about eCos’s built-in support for I<sup>2</sup>C programming, see <a class="LinkURL" href="https://ecos.sourceware.org/docs-latest/ref/i2c-porting.xhtml">https://ecos.sourceware.org/docs-latest/ref/i2c-porting.xhtml</a>. You can find additional eCos information at <a class="LinkURL" href="https://doc.ecoscentric.com/user-guide">https://doc.ecoscentric.com/user-guide</a>. </li>&#13;
<li><span class="RunInHead">ChibiOS/RT</span>  A small-footprint, open source, real-time operating system. Although ChibiOS has been ported to a wide range of microcontrollers (see <a class="LinkURL" href="https://en.wikipedia.org/wiki/ChibiOS/RT">https://en.wikipedia.org/wiki/ChibiOS/RT</a>), perhaps its biggest claim to fame is that it has been successfully ported to the Raspberry Pi, providing an honest-to-goodness RTOS for the Pi (see <a class="LinkURL" href="https://www.stevebate.net/chibios-rpi/GettingStarted.xhtml">https://www.stevebate.net/chibios-rpi/GettingStarted.xhtml</a>).</li>&#13;
<li>See <a class="LinkURL" href="http://chibios.sourceforge.net/docs3/hal/group___i2_c.xhtml">http://chibios.sourceforge.net/docs3/hal/group___i2_c.xhtml</a> for more details on ChibiOS’s I<sup>2</sup>C capabilities. </li>&#13;
</ol>&#13;
<h2 id="h1-502468c10-0004">	10.4	Chapter Summary</h2>&#13;
<p class="BodyFirst">This chapter introduced I<sup>2</sup>C programming under multithreaded, real-time operating systems. It began with a gentle introduction to RTOSs and then provided some simple I<sup>2</sup>C examples using four different RTOSs: µC/OS, FreeRTOS, Teensy Threads, and Mbed. Finally, it concluded by briefly discussing four other RTOSs you might find in the real world.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="box">&#13;
<h2><span epub:type="pagebreak" id="Page_205" title="205"/>For More Information</h2>&#13;
<ol class="none">&#13;
<li>Real-time operating systems: <em>Hands-On RTOs with Microcontrollers: Building Real-Time Embedded Systems Using FreeRTOS, STYM32 MCUs, and SEGGER Debug Tools</em> by Brian Amos (Pakt Publishing, 2020)</li>&#13;
<li>NetBurner and µC/OS information: <a class="LinkURL" href="https://www.netburner.com">https://www.netburner.com</a> and <a class="LinkURL" href="https://netburner.com/NBDocs/Developer/html/index.xhtml">https://netburner.com/NBDocs/Developer/html/index.xhtml</a></li>&#13;
<li>NetBurner I<sup>2</sup>C library documentation: <a class="LinkURL" href="https://netburner.com/NBDocs/Developer/html/group__group_i2_c-_m_c_f5441x.xhtml">https://netburner.com/NBDocs/Developer/html/group__group_i2_c-_m_c_f5441x.xhtml</a></li>&#13;
<li>FreeRTOS information: <a class="LinkURL" href="https://www.freertos.org">https://www.freertos.org</a></li>&#13;
<li>PlatformIO information: <a class="LinkURL" href="https://platformio.org">https://platformio.org</a></li>&#13;
<li>The Teensy Threading Library: <a class="LinkURL" href="https://github.com/ftrias/TeensyThreads%20">https://github.com/ftrias/TeensyThreads </a>and <a class="LinkURL" href="https://github.com/Richard-Gemmell/teensy4_i2c">https://github.com/Richard-Gemmell/teensy4_i2c</a></li>&#13;
<li>Teensy 3.<em>x</em> and 4.<em>x</em> modules from PJRC: <a class="LinkURL" href="https://www.pjrc.com/teensy">https://www.pjrc.com/teensy</a></li>&#13;
<li>Examples and Teensy Thread tutorial: <a class="LinkURL" href="https://seansembeddedlinux.wordpress.com/2018/04/02/inter-thread-communications-with-teensythreads">https://seansembeddedlinux.wordpress.com/2018/04/02/inter-thread-communications-with-teensythreads</a></li>&#13;
<li>Mbed downloads and documentation: <a class="LinkURL" href="https://os.mbed.com">https://os.mbed.com</a></li>&#13;
<li>Introduction to Mbed OS: <a class="LinkURL" href="https://os.mbed.com/docs/mbed-os/v6.15/introduction/index.xhtml">https://os.mbed.com/docs/mbed-os/v6.15/introduction/index.xhtml</a> </li>&#13;
<li>List of about 170 off-the-shelf boards that support Mbed: <a class="LinkURL" href="https://os.mbed.com/platforms">https://os.mbed.com/platforms</a></li>&#13;
<li>NUCLEO-WB55RG SBC: <a class="LinkURL" href="https://os.mbed.com/platforms/ST-Nucleo-WB55RG">https://os.mbed.com/platforms/ST-Nucleo-WB55RG</a></li>&#13;
</ol>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
</section>&#13;
</div>&#13;
</body></html>