<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch8">&#13;
<hgroup>&#13;
<h2 class="CHAPTER" id="ch8">&#13;
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_129" aria-label=" Page 129. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">TESTING WITH THE JEST FRAMEWORK</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/Drop-image.jpg" alt=""/>&#13;
</figure>&#13;
<p class="INTRO">Whenever you modify your code, you risk causing unforeseen side effects in another part of your application. As a result, guaranteeing the integrity and stability of a code base can be challenging. To do so, developers follow two main strategies.</p>&#13;
<p class="TX">In the first, an architectural pattern, we split our code into small, self-contained React components. By nature, these components don’t interfere with one another. Hence, changing one shouldn’t lead to any side effects. In the second, we perform automated unit testing, which this chapter covers using the Jest framework.</p>&#13;
<p class="TX">In the following sections, we discuss the essentials of automated unit testing and the benefits of using it. You’ll learn how to write a test suite in Jest and use its reports to improve your code. You’ll also handle dependencies by using code doubles. Lastly, you’ll explore other kinds of tests you might want to run against your application.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h3 class="H1" id="sec1"><span id="h1-50"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_130" aria-label=" Page 130. "/><samp class="SANS_Futura_Std_Bold_B_11">Test-Driven Development and Unit Testing</samp></h3>&#13;
<p class="TNI">Developers sometimes use the technique of <i>test-driven development (TDD)</i>, in which they write their automated tests before implementing the actual code to be tested. They first create a test to evaluate that the smallest possible unit of code would work as expected. Such a test is called a <i>unit test</i>. Next, they write the minimum amount of code necessary to pass the test.</p>&#13;
<p class="TX">This approach has distinct benefits. First, it lets you focus on your app’s requirements by explicitly defining the code’s functionality and edge cases. Therefore, you have a clear picture of its desired behavior, and you can identify unclear or missing specifications sooner rather than later. When you write tests after completing the functionality, they might reflect the behavior you implemented rather than the behavior you require.</p>&#13;
<p class="TX">Second, limiting yourself to writing only necessary code prevents your functions from becoming too complex and splits your application into small, understandable sections. Testable code is maintainable code. In addition, the technique ensures that your tests cover a large portion of the app’s code, a metric called <i>code coverage</i>, and by running the tests frequently during development, you’ll instantly recognize bugs introduced by new lines of code.</p>&#13;
<p class="TX">Depending on the situation, the <i>unit</i> targeted by a unit test can be a module, a function, or a line of code. The tests aim to verify that each unit works in isolation. The single lines inside each test function are the test <i>steps</i>, and the whole test function is called a test <i>case</i>. Test <i>suites</i> aggregate test cases into logical blocks. To be considered reproducible, the test must return the same results every time we run it. As we will explore in this chapter, this means that we must run the tests in a controlled environment with a defined dataset.</p>&#13;
<p class="TX">Facebook developed the Jest testing framework in conjunction with React, but we can use it with any Node.js project. It has a defined syntax for setting up and writing tests. Its <i>test runner</i> executes these tests, automatically replaces any dependencies in our code, and generates a test-coverage report. Additional npm modules provide custom code for testing DOM or React components and, of course, adding TypeScript types.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h3 class="H1" id="sec2"><span id="h1-51"/><samp class="SANS_Futura_Std_Bold_B_11">Using Jest</samp></h3>&#13;
<p class="TNI">To use Jest in a project, we must install its required packages, create a directory for all test files, and add an npm script that will run the tests. Execute the following in your Next.js application’s root directory to install the framework, as well as type definitions from DefinitelyTyped as development dependencies:</p>&#13;
&#13;
<pre class="pre-136"><code>$ <b>npm install --save-dev jest @types/jest</b></code></pre>&#13;
<p class="TX">Then create the directory in which to save your tests. Jest uses the <i>__tests__</i> folder by default, so make one in your root directory. Next, to add <span role="doc-pagebreak" epub:type="pagebreak" id="pg_131" aria-label=" Page 131. "/>the npm script <i>test</i> to your project, open the <i>package.json</i> file and modify the <samp class="SANS_TheSansMonoCd_W5Regular_11">scripts</samp> object to match the one in <a href="chapter8.xhtml#Lis8-1">Listing 8-1</a>.</p>&#13;
<span id="Lis8-1"/>&#13;
<pre class="pre-137"><code>  "scripts": {&#13;
      "dev": "next dev",&#13;
      "build": "next build",&#13;
      "start": "next start",&#13;
      "lint": "next lint"<b>,</b>&#13;
<b>    </b>  <b>"test": "jest"</b>&#13;
  },&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 8-1: The</span> <span class="Futura_Std_Book_11">package.json</span> <span class="Futura_Std_Book_Oblique_BI_11">file with the new text command</span></p>&#13;
<p class="TX">Now we can run tests with the <samp class="SANS_TheSansMonoCd_W5Regular_11">npm test</samp> command. Usually, build servers execute this command by default during the build process. Lastly, to enable TypeScript support in Jest, add the <samp class="SANS_TheSansMonoCd_W5Regular_11">ts-jest</samp> transpiler:</p>&#13;
&#13;
<pre class="pre-138"><code>$ <b>npm install --save-dev ts-jest</b></code></pre>&#13;
<p class="TX">Also create a <i>jest.config</i> file to add TypeScript by running <samp class="SANS_TheSansMonoCd_W5Regular_11">npx ts-jest config:init</samp>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h3 class="H1" id="sec3"><span id="h1-52"/><samp class="SANS_Futura_Std_Bold_B_11">Creating an Example Module to Test</samp></h3>&#13;
<p class="TNI">Let’s write some example code to help us understand unit testing and TDD. Say we want to create a new module in our app, <i>./helpers/sum.ts</i>. It should export a function, <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>, that returns the sum of its parameters. To follow a TDD pattern, we’ll begin by creating test cases for this module.</p>&#13;
<p class="TX">First we need to create the function that will run our tests. Create a file called <i>sum.test.ts</i> in the default test directory and add the code from <a href="chapter8.xhtml#Lis8-2">Listing 8-2</a>.</p>&#13;
<span id="Lis8-2"/>&#13;
<pre class="pre-139"><code>import {sum} from "../helpers/sum";&#13;
&#13;
describe("the sum function", () =&gt; {&#13;
&#13;
});&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 8-2: The empty test suite</span></p>&#13;
<p class="TX">We import the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> function we’ll write later and use Jest’s <samp class="SANS_TheSansMonoCd_W5Regular_11">describe</samp> function to create an empty test suite. As soon as we run the (nonexistent) tests with <samp class="SANS_TheSansMonoCd_W5Regular_11">npm test</samp>, Jest should complain that there is no file called <i>sum.ts</i> in the <i>helpers</i> directory. Create this file and folder now, at the root directory of your project. Within the file, write the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> function shown in <a href="chapter8.xhtml#Lis8-3">Listing 8-3</a>.</p>&#13;
<span id="Lis8-3"/>&#13;
<pre class="pre-140"><code>const sum = () =&gt; {};&#13;
export {sum};&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 8-3: The bare bones of the</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sum</samp> <span class="Futura_Std_Book_Oblique_BI_11">function</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_132" aria-label=" Page 132. "/>Now run the tests again with <samp class="SANS_TheSansMonoCd_W5Regular_11">npm test</samp>. Because the code just exports a placeholder <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> function that returns nothing, the Jest test runner again complains. This time, it informs us that the test suite needs to contain at least one test.</p>&#13;
<p class="TX">Let’s look at the anatomy of a test case and add a few test cases to the <i>sum.test.ts</i> file during the process.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h3 class="H1" id="sec4"><span id="h1-53"/><samp class="SANS_Futura_Std_Bold_B_11">Anatomy of a Test Case</samp></h3>&#13;
<p class="TNI">There are two types of unit tests: state and interaction based. An <i>interaction-based</i> test case verifies that the code under evaluation invokes a specific function, whereas a <i>state-based</i> test case checks the code’s return value or resulting state. Both types follow the same three steps: arrange, act, and assert.</p>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h4 class="H2" id="sec5"><span id="h2-109"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Arrange</samp></h4>&#13;
<p class="TNI">To write independent and reproducible tests, we need to first <i>arrange</i> our environment by defining prerequisites, such as test data. If we need these prerequisites for only one particular test case, we define them at the beginning of the case. Otherwise, we set them globally for all tests in the test suite by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">beforeEach</samp> hook, which gets executed before each test case, or the <samp class="SANS_TheSansMonoCd_W5Regular_11">beforeAll</samp> hook, which gets executed before all tests run.</p>&#13;
<p class="TX">If, for example, we had some reason to use the same global dataset for each test case and knew that our test steps would modify the dataset, we would need to re-create the dataset before each test. The <samp class="SANS_TheSansMonoCd_W5Regular_11">beforeEach</samp> hook would be the perfect place to do this. On the other hand, if the test cases merely consume the data, we’d need to define the datasets only once and so would use the <samp class="SANS_TheSansMonoCd_W5Regular_11">beforeAll</samp> hook.</p>&#13;
<p class="TX">Let’s define two test cases and create the input values for each. Our input parameters will be specific to each test case, so we’ll declare them inside the test cases instead of using a <samp class="SANS_TheSansMonoCd_W5Regular_11">beforeEach</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">beforeAll</samp> hook. Update the <i>sum.test.ts</i> file with the code from <a href="chapter8.xhtml#Lis8-4">Listing 8-4</a>.</p>&#13;
<span id="Lis8-4"/>&#13;
<pre class="pre-141"><code>import {sum} from "../helpers/sum";&#13;
&#13;
describe("the sum function", () =&gt; {&#13;
    <b>test("two plus two is four", () =&gt; {</b>&#13;
<b>        let first =</b><b> 2;</b>&#13;
<b>        let second = 2;</b>&#13;
<b>        let expectation = 4;</b>&#13;
    });&#13;
&#13;
    <b>test("minus eight plus four is minus four", () =&gt; {</b>&#13;
<b>        let first = -8;</b>&#13;
<b>        let second =</b><b> 4;</b>&#13;
<b>        let expectation = -4;</b>&#13;
    });&#13;
});&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 8-4: The test suite containing the arrange steps</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_133" aria-label=" Page 133. "/>The <samp class="SANS_TheSansMonoCd_W5Regular_11">describe</samp> function creates our test suite, which comprises two calls to the <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp> function, each of which is a test case. For both, the first argument is the description we see on the test runner’s report.</p>&#13;
<p class="TX">Each of our tests evaluates the result of the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> function. The first checks the addition feature, verifying that 2 plus 2 returns 4. The second test confirms that the function correctly returns negative values as well. It adds 4 to <span class="symbol">−</span>8 and expects a result of <span class="symbol">−</span>4.</p>&#13;
<p class="TX">You might want to check the return type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> function, too. Usually, we would have done so, but because we’re using TypeScript, there is no need for this additional test case. Instead, we can define the return type in the function signature, and TSC will verify it for us.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h4 class="H2" id="sec6"><span id="h2-110"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Act</samp></h4>&#13;
<p class="TNI">As soon as the test runner executes a case, the test steps <i>act</i> on our behalf by invoking the code under test with the data for the particular test case. Each test case should test exactly one feature or variant of the system. This step is the line of code that invokes the function to execute. <a href="chapter8.xhtml#Lis8-5">Listing 8-5</a> adds it to the test cases in <i>sum.test.ts</i>.</p>&#13;
<span id="Lis8-5"/>&#13;
<pre class="pre-142"><code>import {sum} from "../helpers/sum";&#13;
&#13;
describe("the sum function", () =&gt; {&#13;
&#13;
    test("two plus two is four", () =&gt; {&#13;
        let first = 2;&#13;
        let second = 2;&#13;
        let expectation = 4;&#13;
<b>        let result = sum(first, second);</b>&#13;
    });&#13;
&#13;
    test("minus eight plus four is minus four", () =&gt; {&#13;
        let first = -8;&#13;
        let second = 4;&#13;
        let expectation = -4;&#13;
<b>        let result = sum(first, second);</b>&#13;
    });&#13;
&#13;
});&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 8-5: The test suite containing the act steps</span></p>&#13;
<p class="TX">Our new lines call the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> function and pass it the values we defined as parameters. We store the returned values in the <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp> variable. In your editor, TSC should throw an error along the lines of <samp class="SANS_TheSansMonoCd_W5Regular_11">Expected 0 arguments, but got 2</samp>. This is fine, as the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> function is just an empty placeholder and doesn’t yet expect any parameters.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h4 class="H2" id="sec7"><span id="h2-111"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Assert</samp></h4>&#13;
<p class="TNI">The final step of our test case is the <i>assertion</i> that the code fulfills the expectations we defined. We create this assertion with two parts: the Jest <samp class="SANS_TheSansMonoCd_W5Regular_11">expect</samp> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_134" aria-label=" Page 134. "/>function, used in conjunction with a <i>matcher</i> function from Jest’s <i>assert</i> library that defines the condition for which we are testing. Depending on the unit test’s category, this condition could be a specific return value, a state change, or the invocation of another function. Common matchers check whether a value is a number, a string, and so on. We can also use them to assert that a function returns true or false.</p>&#13;
<p class="TX">Jest’s <i>assert</i> library provides us with a built-in set of basic matchers, and we can add additional ones from the npm repository. One of the most common assert packages is <i>testing-library/dom</i>, used to query the DOM for a particular node and assert its characteristics. For example, we can check for a class name or attribute or work with native DOM events. Another common assert package, <i>testing-library/react</i>, adds utilities for React and gives us access to the <samp class="SANS_TheSansMonoCd_W5Regular_11">render</samp> function and React hooks in our asserts.</p>&#13;
<p class="TX">Because each test case evaluates one condition in one unit of code, we limit each test to one assert. In this way, as soon as the test run succeeds or fails and the test reporter generates the report, we can easily spot which test assumption failed. <a href="chapter8.xhtml#Lis8-6">Listing 8-6</a> adds one assert per test case. Paste it into the <i>sum.test.ts</i> file.</p>&#13;
<span id="Lis8-6"/>&#13;
<pre class="pre-143"><code>import {sum} from "../helpers/sum";&#13;
&#13;
describe("the sum function", () =&gt; {&#13;
&#13;
    test("two plus two is four", () =&gt; {&#13;
        let first = 2;&#13;
        let second = 2;&#13;
        let expectation = 4;&#13;
        let result = sum(first, second);&#13;
<b>        expect(result).toBe(expectation);</b>&#13;
    });&#13;
&#13;
    test("minus eight plus four is minus four", () =&gt; {&#13;
        let first = -8;&#13;
        let second = 4;&#13;
        let expectation = -4;&#13;
        let result = sum(first, second);&#13;
<b>        expect(result).toBe(expectation);</b>&#13;
    });&#13;
&#13;
});&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 8-6: The test suite containing the assert steps</span></p>&#13;
<p class="TX">These lines use the <samp class="SANS_TheSansMonoCd_W5Regular_11">expect</samp> assert function with the <samp class="SANS_TheSansMonoCd_W5Regular_11">toBe</samp> matcher to compare the expected result to be the same as our expectation. Our test cases are now complete. Each follows the <i>arrange, act, assert</i> pattern and verifies one condition. <span class="Xref"><a href="appendix-C.xhtml">Appendix C</a></span> lists additional matchers.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h3 class="H1" id="sec8"><span id="h1-54"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_135" aria-label=" Page 135. "/><samp class="SANS_Futura_Std_Bold_B_11">Using TDD</samp></h3>&#13;
<p class="TNI">Our test cases still haven’t executed, and if you run <samp class="SANS_TheSansMonoCd_W5Regular_11">npm test</samp>, the test runner should fail immediately. TSC checks the code and throws an error for the missing parameter declarations on the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> function:</p>&#13;
&#13;
<pre class="pre-144"><code>FAIL  __tests__/sum.test.ts&#13;
  • Test suite failed to run&#13;
<var>--snip--</var>&#13;
Test Suites: 2 failed, 2 total&#13;
Tests:       0 total&#13;
Snapshots:   0 total&#13;
</code></pre>&#13;
<p class="TX">It’s time to implement this <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> function. Following the principles of TDD, we’ll incrementally add features to the code and run the test suites after each addition, continuing this process until all tests pass. First we’ll add those missing parameters. Replace the code in <i>sum.ts</i> with the contents of <a href="chapter8.xhtml#Lis8-7">Listing 8-7</a>.</p>&#13;
<span id="Lis8-7"/>&#13;
<pre class="pre-145"><code>const sum = (a: number, b: number) =&gt; {};&#13;
&#13;
export {sum};&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 8-7: The</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sum</samp> <span class="Futura_Std_Book_Oblique_BI_11">function with added parameters</span></p>&#13;
<p class="TX">We’ve added the parameters and typed them as numbers. Now we rerun the test cases and, as expected, they fail. The console output tells us that the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> function doesn’t return the expected results. This shouldn’t surprise us, because our <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> function doesn’t return anything at all:</p>&#13;
&#13;
<pre class="pre-146"><code>FAIL  __tests__/sum.test.ts (5.151 s)&#13;
  the sum function&#13;
    × two plus two is four (6 ms)&#13;
    × minus eight plus four is minus four (1 ms)&#13;
&#13;
  • the sum function › two plus two is four&#13;
    Expected: 4&#13;
    Received: undefined&#13;
&#13;
  • the sum function › minus eight plus four is minus four&#13;
    Expected: -4&#13;
    Received: undefined&#13;
&#13;
Test Suites: 1 failed, 1 total&#13;
Tests:       2 failed, 2 total&#13;
Snapshots:   0 total&#13;
Time:        5.328 s, estimated 11 s&#13;
</code></pre>&#13;
<p class="TX">The code in <a href="chapter8.xhtml#Lis8-8">Listing 8-8</a> adds this functionality to the <i>sum.ts</i> file. We type the function’s return type as a number and add the two parameters.</p>&#13;
<span id="Lis8-8"/>&#13;
<pre class="pre-147"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_136" aria-label=" Page 136. "/>const sum = (a: number, b: number): number =&gt; a + b;&#13;
&#13;
export {sum};&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 8-8: The complete</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sum</samp> <span class="Futura_Std_Book_Oblique_BI_11">function</span></p>&#13;
<p class="TX">If we rerun <samp class="SANS_TheSansMonoCd_W5Regular_11">npm test</samp>, Jest should report that all test cases succeed:</p>&#13;
&#13;
<pre class="pre-148"><code>PASS  __tests__/sum.test.ts (8.045 s)&#13;
  the sum function&#13;
    ✓ two plus two is four (2 ms)&#13;
    ✓ minus eight plus four is minus four (2 ms)&#13;
&#13;
Test Suites: 1 passed, 1 total&#13;
Tests:       2 passed, 2 total&#13;
Snapshots:   0 total&#13;
Time:        8.291 s&#13;
</code></pre>&#13;
<p class="TX">As you can see, everything worked.</p>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h4 class="H2" id="sec9"><span id="h2-112"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Refactoring Code</samp></h4>&#13;
<p class="TNI">Unit tests are particularly useful when we need to refactor our code. As an example, let’s rewrite the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> function so that, instead of two parameters, it accepts an array of numbers. The function should return the sum of all array items.</p>&#13;
<p class="TX">We begin by rewriting our existing test cases into a more compact form and then expanding the test suite to verify the new behavior. Replace the code in the <i>sum.test.file</i> with <a href="chapter8.xhtml#Lis8-9">Listing 8-9</a>.</p>&#13;
<span id="Lis8-9"/>&#13;
<pre class="pre-149"><code>import {sum} from "../helpers/sum";&#13;
&#13;
describe("the sum function", () =&gt; {&#13;
&#13;
    test("two plus two is four", () =&gt; {&#13;
<b>        expect(sum([2, 2])).toBe(4);</b>&#13;
    });&#13;
&#13;
    test("<b>minus eight</b> plus <b>four</b> is <b>minus four</b>", () =&gt; {&#13;
        expect(sum([<b>-8</b>, <b>4</b>])).toBe(<b>-4</b>);&#13;
    });&#13;
&#13;
    test("<b>two</b> plus <b>two</b> plus <b>minus four </b>is <b>zero</b>", () =&gt; {&#13;
        expect(sum([<b>2</b>, <b>2</b>, <b>-4</b>])).toBe(0);&#13;
    });&#13;
&#13;
});&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 8-9: The test suite for the refactored</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sum</samp> <span class="Futura_Std_Book_Oblique_BI_11">function</span></p>&#13;
<p class="TX">Notice that we rewrote the test cases in a more compact form. Explicitly splitting the arrange, act, and assert statements across multiple lines may <span role="doc-pagebreak" epub:type="pagebreak" id="pg_137" aria-label=" Page 137. "/>be easier to read, but for simple test cases, such as those in <a href="chapter8.xhtml#Lis8-9">Listing 8-9</a>, we often write them in one line. We’ve changed their functionality to accommodate the new requirements. Instead of accepting two values, our <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> function receives an array with numbers. Again, the TSC instantly notifies us of the mismatching parameters between the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> function in the test suite and the actual implementation.</p>&#13;
<p class="TX">Once we’ve written our tests, we can rewrite our code. <a href="chapter8.xhtml#Lis8-10">Listing 8-10</a> shows the code for the <i>helpers/sum.ts</i> file. Here the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> function now accepts an array of numbers as a parameter and returns a number.</p>&#13;
<span id="Lis8-10"/>&#13;
<pre class="pre-150"><code>const sum = (data: number[]): number =&gt; {&#13;
    return data[0] + data[1];&#13;
};&#13;
&#13;
export {sum};&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 8-10: The rewritten</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sum</samp> <span class="Futura_Std_Book_Oblique_BI_11">function in the</span> <span class="Futura_Std_Book_11">helpers/sum.ts</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">We changed the parameter to an array of numbers. This fixes the TypeScript error caused by the test suite in <a href="chapter8.xhtml#Lis8-9">Listing 8-9</a>. But because we’re following TDD and making only one functional change at a time, we keep the function’s original behavior of adding two values. As expected, one of the test cases fails when we run the automated tests with <samp class="SANS_TheSansMonoCd_W5Regular_11">npm test</samp>:</p>&#13;
&#13;
<pre class="pre-151"><code>FAIL  __tests__/sum.test.ts (7.804 s)&#13;
  the sum function&#13;
    ✓ two plus two is four (7 ms)&#13;
    ✓ minus eight plus four is minus four (1 ms)&#13;
    ✕ two plus two plus minus four is zero (9 ms)&#13;
&#13;
  • the sum function › two plus two plus minus four is zero&#13;
    Expected: 0&#13;
    Received: 4&#13;
&#13;
Test Suites: 1 failed, 1 total&#13;
Tests:       1 failed, 2 passed, 3 total&#13;
Snapshots:   0 total&#13;
Time:        8.057 s, estimated 9 s&#13;
</code></pre>&#13;
<p class="TX">The third test case, which tests the new requirement, is the one that failed. Not only did we expect this result, but we also wanted the test to fail; this way, we know that the tests themselves are working. If they succeeded before we implemented the corresponding functionality, the test cases would be faulty.</p>&#13;
<p class="TX">With the failing test as the baseline, it is now time to refactor the code to accommodate the new requirement. Paste the code in <a href="chapter8.xhtml#Lis8-11">Listing 8-11</a> into the <i>sum.ts</i> file. Here we refactor the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> function to return the sum of all array values.</p>&#13;
<span id="Lis8-11"/>&#13;
<pre class="pre-152"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_138" aria-label=" Page 138. "/>const sum = (data: number[]): number =&gt; {&#13;
    return data.reduce((a, b) =&gt; a + b);&#13;
};&#13;
&#13;
export {sum};&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 8-11: The corrected</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sum</samp> <span class="Futura_Std_Book_Oblique_BI_11">function with</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">array.reduce</samp></p>&#13;
<p class="TX">Although we could loop through the array with a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, we use modern JavaScript’s <samp class="SANS_TheSansMonoCd_W5Regular_11">array.reduce</samp> function. This native array function runs a callback function on each array element. The callback receives the return value of the previous iteration and the current array item as parameters: exactly what we need to calculate the sum.</p>&#13;
<p class="TX">Run all the test cases in our test suite to verify that they are working as expected:</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_139" aria-label=" Page 139. "/>&#13;
<pre class="pre-153"><code>PASS  __tests__/sum.test.ts (7.422 s)&#13;
  the sum function&#13;
    ✓ two plus two is four (2 ms)&#13;
    ✓ minus eight plus four is minus four&#13;
    ✓ two plus two plus minus four is zero&#13;
&#13;
Test Suites: 1 passed, 1 total&#13;
Tests:       3 passed, 3 total&#13;
Snapshots:   0 total&#13;
Time:        7.613 s&#13;
</code></pre>&#13;
<p class="TX">The test runner should show that the code passed every test.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h4 class="H2" id="sec10"><span id="h2-113"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Evaluating Test Coverage</samp></h4>&#13;
<p class="TNI">To measure exactly which lines of code our test suites cover, Jest generates a test-coverage report. The higher the percentage of code our tests assess, the more thorough they are, and the more confident we can be about the application’s quality and maintainability. As a general rule of thumb, you should aim for code coverage of 90 percent or above, with a high coverage for the most critical part of your code. Of course, the test cases should add value by testing the code’s functions; adding tests just to increase the test coverage is not the goal we are aiming for. But as soon as you’ve tested your code base thoroughly, you can refactor existing features and implement new ones without worrying about introducing regression bugs. A high code coverage verifies that changes have no hidden side effects.</p>&#13;
<p class="TX">Modify the <samp class="SANS_TheSansMonoCd_W5Regular_11">npm test</samp> script in the <i>package.json</i> file by adding the <samp class="SANS_TheSansMonoCd_W5Regular_11">--coverage</samp> flag to it, as shown in <a href="chapter8.xhtml#Lis8-12">Listing 8-12</a>.</p>&#13;
<span id="Lis8-12"/>&#13;
<pre class="pre-154"><code>  "scripts": {&#13;
      "dev": "next dev",&#13;
      "build": "next build",&#13;
      "start": "next start",&#13;
      "lint": "next lint"<b>,</b>&#13;
<b>    </b>  <b>"test": "jest --coverage"</b>&#13;
  },&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 8-12: Enabling Jest’s test-coverage feature in the</span> <span class="Futura_Std_Book_11">package.json</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">If we rerun the test suite, Jest should show what percentage of the code our unit tests cover. It generates a code-coverage report and stores it in the <i>coverage</i> folder. Compare your output with the following:</p>&#13;
&#13;
<pre class="pre-155"><code>PASS  __tests__/sum.test.ts (7.324 s)&#13;
  the sum function&#13;
    ✓ two plus two is four (2 ms)&#13;
    ✓ minus eight plus four is minus four&#13;
    ✓ two plus two plus minus four is zero (1 ms)&#13;
----------|---------|----------|---------|---------|-------------------&#13;
File      | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s&#13;
----------|---------|----------|---------|---------|-------------------&#13;
All files |     100 |      100 |     100 |     100 |&#13;
  sum.ts  |     100 |      100 |     100 |     100 |&#13;
----------|---------|----------|---------|---------|-------------------&#13;
Test Suites: 1 passed, 1 total&#13;
Tests:       3 passed, 3 total&#13;
Snapshots:   0 total&#13;
Time:        7.687 s, estimated 8 s&#13;
</code></pre>&#13;
<p class="TX">The report shows the coverage broken down by statements, branches, functions, and lines. We see that our simple <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> function has a code coverage of 100 percent across all categories. Hence, we know that we’ve left no code untested and can trust that the test cases reflect the function’s quality.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h3 class="H1" id="sec11"><span id="h1-55"/><samp class="SANS_Futura_Std_Bold_B_11">Replacing Dependencies with Fakes, Stubs, and Mocks</samp></h3>&#13;
<p class="TNI">We mentioned that our tests should run in isolation, without depending on external code. You might have wondered how to handle imported modules; after all, as soon as you import code, you add a dependency to the unit under evaluation. Those third-party modules might not work as expected, and we don’t want our code to depend on the assumption that they all operate correctly. Consequently, you should provide a set of test cases for each imported module to verify its functionality. They, too, are units to test.</p>&#13;
<p class="TX">Separately, instead of importing modules into our other code units, we need to replace them with <i>test doubles</i> that return a defined set of static data tailored to the test. Test doubles replace an object or a function, effectively removing a dependency. Because they return a defined dataset, their response is known and predictable. You can compare them to stunt doubles in movies.</p>&#13;
<p class="TX">Besides replacing an object or function, test doubles have a second important purpose: they record their calls and let us spy on them. We can thus use them to test whether the test double has been called at all, how often, and which arguments it received. There are three main types of test doubles: fakes, stubs, and mocks. However, you’ll sometimes hear the term <i>mock</i> to refer to all three.</p>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<h4 class="H2" id="sec12"><span id="h2-114"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_140" aria-label=" Page 140. "/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating a Module with Dependencies</samp></h4>&#13;
<p class="TNI">To practice using test doubles in our <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> function, we’ll create a new function that calculates a specified number of values in the Fibonacci sequence. The <i>Fibonacci sequence</i> is a pattern in which each subsequent number is the sum of the previous two, a simple use case for a <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> module.</p>&#13;
<p class="TX">All developers must figure out how fine-grained their test cases need to be. The Fibonacci sequence is a good example, because trying to test every possible number submitted to the function would be useless, as the sequence has no end. Instead, we want to verify that the function properly handles edge cases and that its underlying functionality works. For instance, we’ll check how it handles an input with a length of 0; in that case, the function should return an empty string. Then we’ll test how it calculates a Fibonacci sequence of any length longer than 3. Create the <i>fibonacci.test.ts</i> test suite inside the <i>__tests__</i> folder and then add the code from <a href="chapter8.xhtml#Lis8-13">Listing 8-13</a> to it.</p>&#13;
<span id="Lis8-13"/>&#13;
<pre class="pre-156"><code>import {fibonacci} from "../helpers/fibonacci";&#13;
&#13;
describe("the fibonacci sequence", () =&gt; {&#13;
&#13;
    test("with a length of 0 is ", () =&gt; {&#13;
        expect(fibonacci(0)).toBe(" ");&#13;
    });&#13;
&#13;
    test("with a length of 5 is '0, 1, 1, 2, 3' ", () =&gt; {&#13;
        expect(fibonacci(5)).toBe("0, 1, 1, 2, 3");&#13;
    });&#13;
&#13;
});&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 8-13: The test suite for the</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">fibonacci</samp> <span class="Futura_Std_Book_Oblique_BI_11">function</span></p>&#13;
<p class="TX">We define two test cases: one that checks for a length input of 0 and another that calculates a Fibonacci sequence of five numbers. Both tests follow the <i>arrange, act, assert</i> pattern in the compact variant we used earlier.</p>&#13;
<p class="TX">After we’ve created the test cases, we can move on to writing the Fibonacci function code. Create the <i>fibonacci.ts</i> file in the <i>helpers</i> folder, next to the <i>sum.ts</i> file, and add the code from <a href="chapter8.xhtml#Lis8-14">Listing 8-14</a> to it.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_141" aria-label=" Page 141. "/>&#13;
<span id="Lis8-14"/>&#13;
<pre class="pre-157"><code>import {sum} from "./sum";&#13;
&#13;
const fibonacci = (length: number): string =&gt; {&#13;
    const sequence: number[] = [];&#13;
    for (let i = 0; i &lt; length; i++) {&#13;
        if (i &lt; 2) {&#13;
            sequence.push(sum([0, i]));&#13;
        } else {&#13;
            sequence.push(sum([sequence[i - 1], sequence[i - 2]]));&#13;
        }&#13;
    }&#13;
    return sequence.join(", ");&#13;
};&#13;
&#13;
export {fibonacci};&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 8-14: The</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">fibonacci</samp> <span class="Futura_Std_Book_Oblique_BI_11">function</span></p>&#13;
<p class="TX">We import the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> function from the module we created earlier in this chapter. It is now a dependency that we’ll need to replace with a test double later. Then we implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">fibonacci</samp> function, which accepts the length of the sequence to calculate and returns a string. We store the current sequence in an array so that we have a simple way to access the two previous values needed to calculate the next one. Notice that the first number in the sequence is always <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> and the second is always <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. Finally, we return a string with the requested number of values. If you save this code and rerun the test suites, both <i>sum.test.js</i> and <i>fibonacci.test.ts</i> should pass successfully.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h4 class="H2" id="sec13"><span id="h2-115"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating a Doubles Folder</samp></h4>&#13;
<p class="TNI">Because we import the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> function in the Fibonacci module, our code has an external dependency. This is problematic for testing purposes: if the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> function breaks, the test for the Fibonacci sequence will fail as well, even if the logic of the Fibonacci implementation is correct.</p>&#13;
<p class="TX">To decouple the test from the dependency, we’ll replace the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> function in the <i>fibonacci.ts</i> file with a test double. Jest can replace any module that has an identically named file saved in a <i>__mocks__</i> subdirectory adjacent to the test file during the test run. Create such a folder in the <i>helpers</i> folder next to the test file and place a <i>sum.ts</i> file inside it. Leave the file empty for now.</p>&#13;
<p class="TX">To enable the test double, we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">jest.mock</samp> function, passing it the path to the original module saved in the test file. In <a href="chapter8.xhtml#Lis8-15">Listing 8-15</a>, we add this call to <i>fibonacci.test.ts</i>.</p>&#13;
<span id="Lis8-15"/>&#13;
<pre class="pre-158"><code>import {fibonacci} from "../helpers/fibonacci";&#13;
&#13;
<b>jest.mock("../helpers/sum");</b>&#13;
&#13;
describe("the fibonacci sequence", () =&gt; {&#13;
    test("with a length of 0 is ", () =&gt; {&#13;
        expect(fibonacci(0)).toBe(" ");&#13;
    });&#13;
    test("with a length of 5 is '0, 1, 1, 2, 3' ", () =&gt; {&#13;
        expect(fibonacci(5)).toBe("0, 1, 1, 2, 3");&#13;
    });&#13;
&#13;
});&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 8-15: The test suite for the</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">fibonacci</samp> <span class="Futura_Std_Book_Oblique_BI_11">function with the test double</span></p>&#13;
<p class="TX">This new line replaces the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> module with the test double. Now let’s create all three basic types of test doubles, adding their code to the file in the <i>__mocks__</i> folder.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<h4 class="H2" id="sec14"><span id="h2-116"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_142" aria-label=" Page 142. "/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using a Stub</samp></h4>&#13;
<p class="TNI">Stubs are merely objects that return some predefined data. This makes them very simple to implement but limited in use; often, returning the same data isn’t enough to mimic a dependency’s original actions. <a href="chapter8.xhtml#Lis8-16">Listing 8-16</a> shows a stub implementation for the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> function’s test double. Paste the code into the <i>sum.ts</i> file inside the <i>__mocks__</i> folder.</p>&#13;
<span id="Lis8-16"/>&#13;
<pre class="pre-159"><code>const sum = (data: number[]): number =&gt; 999;&#13;
&#13;
export {sum};&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 8-16: A stub for the</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sum</samp> <span class="Futura_Std_Book_Oblique_BI_11">function</span></p>&#13;
<p class="TX">The stubbed function has the same signature as the original function. It accepts the same arguments, an array of numbers, and returns a string. Unlike the original, however, this test double always returns the same number, 999, regardless of the data it received.</p>&#13;
<p class="TX">To successfully run the test suites with this stub function, we’d need to adjust our expectations about what our code will do. Instead of returning five numbers in the Fibonacci sequence, it would produce the string <samp class="SANS_TheSansMonoCd_W5Regular_11">999, 999, 999, 999, 999</samp>. If we see such a string, we know that the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> function was called five times. Experiment with the stub, modifying the test suite’s expectations to match it. Then restore the matchers to those shown in <a href="chapter8.xhtml#Lis8-15">Listing 8-15</a> so that you can use them for the upcoming tests.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<h4 class="H2" id="sec15"><span id="h2-117"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using a Fake</samp></h4>&#13;
<p class="TNI">Fakes are the most complex kind of test double. They are working implementations of the original functionality, but unlike the real implementation, they provide only the functionality necessary for the unit test. Their implementation is simplified and often doesn’t cater to edge cases.</p>&#13;
<p class="TX">The fake for the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> adds the first and second items of the array manually, instead of using <samp class="SANS_TheSansMonoCd_W5Regular_11">array.reduce</samp>. This simplified implementation strips the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> function of the ability to sum more than two data points, but for the Fibonacci sequence, it is sufficient. The reduced complexity makes it easy to understand and less prone to error. Replace the content of the <i>sum.ts</i> file inside the <i>__mocks__</i> folder with the code in <a href="chapter8.xhtml#Lis8-17">Listing 8-17</a>.</p>&#13;
<span id="Lis8-17"/>&#13;
<pre class="pre-160"><code>const sum = (data: number[]): number =&gt; {&#13;
    return data[0] + data[1];&#13;
}&#13;
export {sum};&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 8-17: A fake for the</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sum</samp> <span class="Futura_Std_Book_Oblique_BI_11">function</span></p>&#13;
<p class="TX">Our fake uses a simple mathematical plus operator (<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>) to add the first and second items of the <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp> parameter. Its main benefit is that it returns a result similar to that of the actual implementation. We can now run the test <span role="doc-pagebreak" epub:type="pagebreak" id="pg_143" aria-label=" Page 143. "/>suites, and they should pass successfully without our having to adjust our expectations, returning the Fibonacci sequence.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<h4 class="H2" id="sec16"><span id="h2-118"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using a Mock</samp></h4>&#13;
<p class="TNI">Mocks lie somewhere between stubs and fakes. Although less sophisticated than fakes, they return more realistic data than stubs. While they don’t simulate a dependency’s true behavior, they can react to the data they receive.</p>&#13;
<p class="TX">For example, our na<span class="accent">i</span>ve mock implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> function will return a result from a hardcoded hash map. Replace the code in the <i>__mocks__/sum.ts</i> file with the code from <a href="chapter8.xhtml#Lis8-18">Listing 8-18</a>, which inspects the request and enables the Fibonacci calculator to use the original test suites.</p>&#13;
<span id="Lis8-18"/>&#13;
<pre class="pre-161"><code>type resultMap = {&#13;
    [key: string]: number;&#13;
}&#13;
&#13;
const results : resultMap= {&#13;
    "0 + 0": 0,&#13;
    "0 + 1": 1,&#13;
    "1 + 0": 1,&#13;
    "1 + 1": 2,&#13;
    "2 + 1": 3&#13;
};&#13;
&#13;
const sum = (data: number[]): number =&gt; {&#13;
    return results[data.join("+")];&#13;
}&#13;
&#13;
export {sum};&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 8-18: A mock for the</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sum</samp> <span class="Futura_Std_Book_Oblique_BI_11">function</span></p>&#13;
<p class="TX">We create a type, called <samp class="SANS_TheSansMonoCd_W5Regular_11">resultMap</samp>, that uses a string as a key and a number as a value. Then we use the newly created type for a hash map that stores our desired responses. Next, we define the mock function with the same interface as the original implementation. Inside the mock, we calculate the key to use in the hash map based on the parameters we receive. This lets us return the correct dataset and produce an actual Fibonacci sequence. The main benefit of using the mock over <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> is that we can control its outcome, as it returns values from a known dataset.</p>&#13;
<p class="TX">Conveniently, Jest provides us with helpers to work with test doubles. The <samp class="SANS_TheSansMonoCd_W5Regular_11">jest.mock</samp> function replaces imported modules with mocks. The <samp class="SANS_TheSansMonoCd_W5Regular_11">jest.fn</samp> API creates a basic mock that can return any kind of predefined data, and <samp class="SANS_TheSansMonoCd_W5Regular_11">jest.spyOn</samp> lets us record calls to any function without modifying it. We will use all of those in <span class="Xref"><a href="#Exe8">Exercise 8</a> on page 146</span>.</p>&#13;
<p class="TX">In typical developer contexts, you won’t bother with the subtle differences between stubs, fakes, and mocks and will use the term <i>mock</i> as a generic term for test doubles. Don’t spend too much time overengineering your mocks; they’re just tools to help you test your code.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<h3 class="H1" id="sec17"><span id="h1-56"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_144" aria-label=" Page 144. "/><samp class="SANS_Futura_Std_Bold_B_11">Additional Types of Tests</samp></h3>&#13;
<p class="TNI">The tests covered in this chapter so far are the most common ones you’ll encounter as a full-stack developer. This section briefly explains additional types of tests and when to use them. These aren’t meant to replace unit tests; rather, they supplement unit tests by covering specific aspects of your implementation that aren’t otherwise testable. For example, because unit tests run in isolation, they can’t evaluate the interaction between modules. Theoretically, if every function and module passes its test, the whole program should work as expected. Practically, you’ll often face issues caused by faulty module documentation. Commonly, the documentation will claim that an API returns a specific type, but the actual implementation will return a different one.</p>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<h4 class="H2" id="sec18"><span id="h2-119"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Functional Tests</samp></h4>&#13;
<p class="TNI">While unit tests examine the implementation of a feature from a developer’s perspective, <i>functional tests</i> cover the user’s perspective by verifying that code works as the user expects it to work. Put otherwise, these tests check that a given input results in an expected output. Most functional tests are a type of <i>black-box</i> test, which ignores the module’s internal code, side effects, and intermediate results and tests only the interfaces. Functional tests do not generate a code-coverage report. Generally, a quality assurance manager will write and use functional tests during a system testing stage. By contrast, developers write and use unit tests during development.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
<h4 class="H2" id="sec19"><span id="h2-120"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Integration Tests</samp></h4>&#13;
<p class="TNI">You learned that the goal of a unit test is to check the smallest possible section of code in isolation. An <i>integration test</i> is the complete opposite. It verifies the behavior of entire subsystems, whether they be layers of code, such as an app’s data storage mechanism, or specific functions consisting of multiple modules. Integration tests check the integration of the subsystem in the context of the current environment. Hence, they never run in isolation and typically don’t use test doubles.</p>&#13;
<p class="TX">Integration tests are helpful for finding three types of problems. The first type is problems related to <i>inter-module communication</i>, which is the communication between modules. Common problems are faulty internal API integrations and undetected side effects, such as a function that doesn’t delete old files before writing new data to the filesystem. The second type is problems related to the <i>environment</i>, which describes the hardware and software setup the code runs on. Different software versions or hardware configurations can introduce significant issues for your code. The most common problem for full-stack developers involves differences in Node.js versions and outdated dependencies in the modules.</p>&#13;
<p class="TX">The third type is problems related to <i>gateway communications</i>, which relates to testing any API communication with a third-party API gateway. Any communication with external APIs should be tested with integration tests. This is the only instance in which integration tests might use test <span role="doc-pagebreak" epub:type="pagebreak" id="pg_145" aria-label=" Page 145. "/>doubles, such as stubbed versions of the external API, in order to simulate a specific API behavior, like a timeout or successful request. As with functional tests, a quality assurance manager generally writes and uses integration tests. Developers do so less often.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
<h4 class="H2" id="sec20"><span id="h2-121"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">End-to-End Tests</samp></h4>&#13;
<p class="TNI">You can think of the <i>end-to-end test</i> as a combination of functional tests and integration tests. As another kind of black-box test, they examine the application’s functionality across the full stack, from the frontend to the backend, in a specific environment. These business-facing tests should provide confidence that the overall application is still working as expected.</p>&#13;
<p class="TX">End-to-end tests run the application in a specific environment. Often, the complexity of the many dependencies increases the risk of flaky tests in which the application works correctly but the environment causes the tests to fail. End-to-end tests are thus the most time-consuming to create and maintain. Due to their complexity, we must craft them carefully. During execution, they are known to be slow, prone to encountering timeouts, and, like nearly all black-box tests, unable to provide detailed error reports. Therefore, they test only the most critical business-facing scenarios. Generally, a quality assurance manager writes them.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
<h4 class="H2" id="sec21"><span id="h2-122"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Snapshot Tests</samp></h4>&#13;
<p class="TNI">The tests described earlier in this chapter check the code against some assertion. By contrast, a <i>snapshot test</i> compares the application’s current visual (or user interface) state to a previous version of it. Hence, these tests are also called visual regression tests. In each test, we create new snapshots and then compare them with ones stored earlier, providing a cheap way to test user interface components and complete pages. Instead of manually creating and maintaining tests that describe every property of an interface, such as a component’s height, width, position, and colors, we can establish a snapshot containing all of these properties.</p>&#13;
<p class="TX">One way to perform this type of test is to create and compare screenshots. Generally, a headless browser renders the component; the test runner waits for the page to render and then captures an image of it. Unfortunately, this process is relatively slow, and headless browsers are flaky. Jest takes a different approach to snapshot testing. Instead of working with headless browsers and image files, it renders the React user interface components to the virtual DOM, serializes them, and saves them as plaintext in <i>snap</i> files stored in the <i>__snapshots__</i> directory. Hence, Jest snapshot tests are much more performant and less flawed. The Food Finder application you’ll build in <span class="Xref"><a href="part2.xhtml">Part II</a></span> will use snapshot tests to verify the integrity of the build and test your React components.</p>&#13;
<p class="HeadProject"><span id="Exe8"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_146" aria-label=" Page 146. "/><samp class="SANS_Futura_Std_Heavy_B_21">Exercise 8: Add Test Cases to the Weather App</samp></p>&#13;
<p class="TNI">As long as you follow the basic principles we’ve discussed, there is no right or wrong way to test your code. Unit, snapshot, and end-to-end tests are all different tools in your tool belt, and you must strike a balance between the time you spend writing the tests and the usefulness of each. There is also no consensus on what to test. While you should strive for 90 percent code coverage or higher, the general rule of thumb is to cover at least the most critical parts of your application with unit tests and then write some integration tests to verify that your application works on each deployment.</p>&#13;
<p class="TX">When it comes to our weather application, we’ll want our test cases to cover four core aspects. First we’ll add unit tests to evaluate the middleware and services. Even though the REST API endpoints and React user interface component are easy to test directly in the browser, we’ll add test cases for both of them: a basic snapshot test for the user interface component and an end-to-end test for the REST API endpoint <i>/v1/weather/[zipcode].ts</i>.</p>&#13;
<p class="TX">We’ve opted to test the REST endpoint rather than the GraphQL API for simplicity’s sake, as each REST endpoint has its own file, while all GraphQL APIs share an entry point, making their testing more complex. However, testing this GraphQL API would make an excellent exercise for exploring end-to-end-tests after you’ve finished the chapter.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
<h4 class="H2" id="sec22"><span id="h2-123"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Testing the Middleware with Spies</samp></h4>&#13;
<p class="TNI">The middleware to connect to the database is a core part of the application, but we can’t access it directly, as it doesn’t expose any API. We can only implicitly test it by examining the database or by running a query through Mongoose, some service, or an API endpoint. Each of these methods would work, but if we want to test the connection to the database as a unit test, we need to do so in a way that isolates that component as much as possible.</p>&#13;
<p class="TX">To do so, we’ll use Jest’s built-in spies to verify that our middleware successfully calls all the functions necessary for establishing the connection to the MongoDB memory server. Navigate to your <i>__tests__</i> folder and create a new folder, <i>middleware</i>, and a file, <i>db-connect.test.ts</i>, inside it. Then copy the code from <a href="chapter8.xhtml#Lis8-19">Listing 8-19</a> into the file.</p>&#13;
<span id="Lis8-19"/>&#13;
<pre class="pre-162"><code>/**&#13;
 * @jest-environment node&#13;
 */&#13;
&#13;
import dbConnect from "../../middleware/db-connect";&#13;
import mongoose from "mongoose";&#13;
import {MongoMemoryServer} from "mongodb-memory-server";&#13;
&#13;
describe("dbConnect ", () =&gt; {&#13;
    &#13;
    let connection: any;&#13;
&#13;
    afterEach(async () =&gt; {&#13;
        jest.clearAllMocks();&#13;
        await connection.stop();&#13;
        await mongoose.disconnect();&#13;
    });&#13;
&#13;
    afterAll(async () =&gt; {&#13;
        jest.restoreAllMocks();&#13;
    });&#13;
&#13;
    test("calls MongoMemoryServer.create()", async () =&gt; {&#13;
        const spy = jest.spyOn(MongoMemoryServer, "create");&#13;
        connection = await dbConnect();&#13;
        expect(spy).toHaveBeenCalled();&#13;
    });&#13;
&#13;
    test("calls mongoose.disconnect()", async () =&gt; {&#13;
        const spy = jest.spyOn(mongoose, "disconnect");&#13;
        connection = await dbConnect();&#13;
        expect(spy).toHaveBeenCalled();&#13;
    });&#13;
&#13;
    test("calls mongoose.connect()", async () =&gt; {&#13;
        const spy = jest.spyOn(mongoose, "connect");&#13;
        connection = await dbConnect();&#13;
        const MONGO_URI = connection.getUri();&#13;
        expect(spy).toHaveBeenCalledWith(MONGO_URI, {dbName: "Weather"});&#13;
    });&#13;
&#13;
});&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 8-19: The</span> <span class="Futura_Std_Book_11">__tests__/middleware/db-connect.test.ts</span> <span class="Futura_Std_Book_Oblique_BI_11">suite for the database connection</span></p>&#13;
<p class="TX">Most of this code resembles the test suites you wrote earlier in this chapter. But instead of testing simplified example code, we’re now testing real code, which requires us to make some adjustments.</p>&#13;
<p class="TX">First we set the testing environment for Jest to <samp class="SANS_TheSansMonoCd_W5Regular_11">node</samp>, which simulates a Node.js runtime. Later, when writing snapshot tests, we’ll use Jest’s default environment, called <samp class="SANS_TheSansMonoCd_W5Regular_11">jsdom</samp>, which simulates a browser by providing a <samp class="SANS_TheSansMonoCd_W5Regular_11">window</samp> object, as well as all the usual DOM properties and functions. By always setting these environments in the file, we avoid issues caused by using the wrong environment. Then, as usual, we import the packages we need.</p>&#13;
<p class="TX">Now we can start writing the test suite for the <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp> function. We define a <samp class="SANS_TheSansMonoCd_W5Regular_11">connection</samp> variable in the test suite’s scope to store the database connection, and then we can access the MongoDB’s server instance, including its methods and properties. For example, we’ll use these to stop the connection and disconnect from the server after each test to guarantee that each test case is independent.</p>&#13;
<p class="TX">To be able to store the connection, we first need to return the <samp class="SANS_TheSansMonoCd_W5Regular_11">mongoServer</samp> constant from the <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp> function in the file <i>db-connect.ts</i>. Open the file and add the line <samp class="SANS_TheSansMonoCd_W5Regular_11">return mongoServer</samp> to the <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp> function right before the function’s closing curly bracket (<samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp>). From time to time, you’ll need to modify <span role="doc-pagebreak" epub:type="pagebreak" id="pg_148" aria-label=" Page 148. "/>the code you wrote earlier to accommodate the requirements of your tests. In other words, you need to adapt the code to make it testable.</p>&#13;
<p class="TX">Now we use the connection we just exposed and set up the <samp class="SANS_TheSansMonoCd_W5Regular_11">afterEach</samp> hook, which runs after each test case, to reset the mocked functions to their initial mocked state, thus clearing all previously gathered data. This is necessary, because otherwise, the spies would report information gained during the previous calls, as they retain their state across all test suites. Also, we re-create the database connection for each test case. Therefore, we need to stop the current connection and explicitly disconnect from the database after each test. Then we set up the <samp class="SANS_TheSansMonoCd_W5Regular_11">afterAll</samp> hook to remove all mocks and restore the original functions through the <samp class="SANS_TheSansMonoCd_W5Regular_11">restoreAllMocks</samp> function.</p>&#13;
<p class="TX">Our test cases should all follow the <i>arrange, act, assert</i> pattern. As we review them, you might find it useful to open the <i>db-connect.ts</i> file in the <i>middleware</i> folder and follow along. The initial test case verifies the call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">create</samp> function on the <samp class="SANS_TheSansMonoCd_W5Regular_11">MongoMemoryServer</samp>, as this is the first function that we call in the <i>db-connect.ts</i> file. To do so, we create a spy with the <samp class="SANS_TheSansMonoCd_W5Regular_11">jest .spyOn</samp> method. As arguments, this method takes the name of an object and the object’s method on which to spy. Then we act on the code under test and call the <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp> function. Finally, we assert that the spy has been called.</p>&#13;
<p class="TX">The second test case works similarly except that it spies on a different method. We use it to check that <samp class="SANS_TheSansMonoCd_W5Regular_11">mongoose.disconnect</samp> was called successfully during the execution of <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp>. The third test case introduces a new matcher. Instead of verifying only the call itself with <samp class="SANS_TheSansMonoCd_W5Regular_11">toHaveBeenCalled</samp>, we now also verify the call’s arguments using <samp class="SANS_TheSansMonoCd_W5Regular_11">toHaveBeenCalledWith</samp>. Here we grab the connection string directly from the connection and store it in the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">MONGO_URI</samp>. We also hardcode the database we want to connect to. Then we call the matcher, passing it the expected arguments and verifying that they meet our expectations.</p>&#13;
<p class="TX">Now run the test suites with <samp class="SANS_TheSansMonoCd_W5Regular_11">npm test</samp>. All tests should pass with 100 percent test coverage.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
<h4 class="H2" id="sec23"><span id="h2-124"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating Mocks to Test the Services</samp></h4>&#13;
<p class="TNI">While the tests we wrote for the middleware were quite simple, the service tests are a bit more complicated. If you open the <i>mongoose/weather/services.ts</i> file, you’ll see that the services depend on <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherModel</samp>, which is Mongoose’s gateway to the MongoDB collection. Each service calls a method on the model that, in turn, requires a database connection. We won’t reevaluate those database connections here; instead, the goal of this test suite will be to verify that the service functions call the correct <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherModel</samp> functions. To do so, we’ll create a mock <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherModel</samp> that exposes the same set of APIs as mocked functions.</p>&#13;
<p class="TX">We first write the mocked model. Following convention, we create the file <i>mongoose/weather/__mocks__/model.ts</i> and add the code in <a href="chapter8.xhtml#Lis8-20">Listing 8-20</a>.</p>&#13;
<span id="Lis8-20"/>&#13;
<pre class="pre-163"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_149" aria-label=" Page 149. "/>import {WeatherInterface} from "../interface";&#13;
&#13;
type param = {&#13;
    [key: string]: string;&#13;
};&#13;
&#13;
const WeatherModel = {&#13;
    create: jest.fn((newData: WeatherInterface) =&gt; Promise.resolve(true)),&#13;
    findOne: jest.fn(({zip: paramZip}: param) =&gt; Promise.resolve(true)),&#13;
    updateOne: jest.fn(({zip: paramZip}: param, newData: WeatherInterface) =&gt;&#13;
        Promise.resolve(true)&#13;
    ),&#13;
    deleteOne: jest.fn(({zip: paramZip}: param) =&gt; Promise.resolve(true))&#13;
};&#13;
export default WeatherModel;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 8-20: The mock for the</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">WeatherModel</samp></p>&#13;
<p class="TX">We implement <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherInterface</samp> and define the new <samp class="SANS_TheSansMonoCd_W5Regular_11">param</samp> type, which is an object with key-value pairs that we use to type the first parameter. We make the mocked <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherModel</samp> the default export and use an object that implements the four methods of the actual <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherModel</samp>, each of which takes the same parameters as the original. They also take the original Mongoose model’s method. Because they are asynchronous functions, we return a promise resolved to <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>.</p>&#13;
<p class="TX">Now we can write the test suite for the services. These check that each service returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> upon success and calls the correct method of the mocked <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherModel</samp>. Create the file <i>/__tests__/mongoose/weather/services.test.ts</i> and add the code from <a href="chapter8.xhtml#Lis8-21">Listing 8-21</a> to it.</p>&#13;
&#13;
<span id="Lis8-21"/>&#13;
<pre class="pre-164"><code>/**&#13;
 * @jest-environment node&#13;
 */&#13;
import {WeatherInterface} from "../../../mongoose/weather/interface";&#13;
import {&#13;
    findByZip,&#13;
    storeDocument,&#13;
    updateByZip,&#13;
    deleteByZip,&#13;
} from "../../../mongoose/weather/services";&#13;
&#13;
import WeatherModel from "../../../mongoose/weather/model";&#13;
jest.mock("../../../mongoose/weather/model");&#13;
&#13;
describe("the weather services", () =&gt; {&#13;
&#13;
    let doc: WeatherInterface = {&#13;
        zip: "test",&#13;
        weather: "weather",&#13;
        tempC: "00",&#13;
        tempF: "01",&#13;
        friends: []&#13;
    };&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_150" aria-label=" Page 150. "/>    afterEach(async () =&gt; {&#13;
        jest.clearAllMocks();&#13;
    });&#13;
&#13;
    afterAll(async () =&gt; {&#13;
        jest.restoreAllMocks();&#13;
    });&#13;
&#13;
    describe("API storeDocument", () =&gt; {&#13;
        test("returns true", async () =&gt; {&#13;
            const result = await storeDocument(doc);&#13;
            expect(result).toBeTruthy();&#13;
        });&#13;
        test("passes the document to Model.create()", async () =&gt; {&#13;
            const spy = jest.spyOn(WeatherModel, "create");&#13;
            await storeDocument(doc);&#13;
            expect(spy).toHaveBeenCalledWith(doc);&#13;
        });&#13;
    });&#13;
&#13;
    describe("API findByZip", () =&gt; {&#13;
        test("returns true", async () =&gt; {&#13;
            const result = await findByZip(doc.zip);&#13;
            expect(result).toBeTruthy();&#13;
        });&#13;
        test("passes the zip code to Model.findOne()", async () =&gt; {&#13;
            const spy = jest.spyOn(WeatherModel, "findOne");&#13;
            await findByZip(doc.zip);&#13;
            expect(spy).toHaveBeenCalledWith({zip: doc.zip});&#13;
        });&#13;
    });&#13;
&#13;
    describe("API updateByZip", () =&gt; {&#13;
        test("returns true", async () =&gt; {&#13;
            const result = await updateByZip(doc.zip, doc);&#13;
            expect(result).toBeTruthy();&#13;
        });&#13;
        test("passes the zip code and the new data to Model.updateOne()", async () =&gt; {&#13;
            const spy = jest.spyOn(WeatherModel, "updateOne");&#13;
            const result = await updateByZip(doc.zip, doc);&#13;
            expect(spy).toHaveBeenCalledWith({zip: doc.zip}, doc);&#13;
        });&#13;
    });&#13;
&#13;
    describe("API deleteByZip", () =&gt; {&#13;
        test("returns true", async () =&gt; {&#13;
            const result = await deleteByZip(doc.zip);&#13;
            expect(result).toBeTruthy();&#13;
        });&#13;
        test("passes the zip code Model.deleteOne()", async () =&gt; {&#13;
            const spy = jest.spyOn(WeatherModel, "deleteOne");&#13;
            const result = await deleteByZip(doc.zip);&#13;
            expect(spy).toHaveBeenCalledWith({zip: doc.zip});&#13;
        });&#13;
    });&#13;
  &#13;
});&#13;
</code></pre>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_151" aria-label=" Page 151. "/>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 8-21: The updated test suite in</span> <span class="Futura_Std_Book_11">__tests__/mongoose/weather/services.test.ts</span></p>&#13;
<p class="TX">As in the previous test suite, we begin by setting up the environment and importing modules. We also import <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherModel</samp> and call <samp class="SANS_TheSansMonoCd_W5Regular_11">jest.mock</samp> with the path to the mocked model we created, effectively replacing the original model in the code under test. Then we create a document containing some test data. We store it in the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">doc</samp> and will pass it to the mocked model’s methods. As done previously, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">afterEach</samp> hook to reset all mocks after each test and the <samp class="SANS_TheSansMonoCd_W5Regular_11">afterAll</samp> hook to remove the mocks and restore the original functions after all test cases have been finished.</p>&#13;
<p class="TX">We create a nested test suite for each of the four services. Each has the same two unit tests: one to verify the return value upon success with the <samp class="SANS_TheSansMonoCd_W5Regular_11">toBeTruthy</samp> matcher and one to spy on a particular <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherModel</samp> mock function. The code follows the same pattern as the previous test suite and uses the same matchers as well.</p>&#13;
<p class="TX">The code-coverage report we receive after running <samp class="SANS_TheSansMonoCd_W5Regular_11">npm test</samp> shows that we tested around 70 percent of the service code. If you take a look at the uncovered lines listed in the last column, you’ll see that they contain the <samp class="SANS_TheSansMonoCd_W5Regular_11">console.log(err);</samp> output. This output is used whenever an asynchronous call to the model’s methods fails:</p>&#13;
&#13;
<pre class="pre-165"><code>PASS  __tests__/mongoose/weather/services.test.ts&#13;
PASS  __tests__/middleware/dbconnect.test.ts (7.193 s)&#13;
&#13;
--------------------|---------|----------|---------|---------|-------------------&#13;
File                | % Stmts | % Branch | % Funcs | % Lines | Uncovered Lines&#13;
--------------------|---------|----------|---------|---------|-------------------&#13;
All files           |   83.63 |      100 |   88.23 |   82.35 |&#13;
 middleware         |     100 |      100 |     100 |     100 |&#13;
  db-connect.test.ts|     100 |      100 |     100 |     100 |&#13;
 mongoose/weather.  |   77.41 |      100 |     100 |   75.86 |&#13;
  services.test.ts  |   70.83 |      100 |     100 |   70.83 |8,20-22,33-35,43-45&#13;
--------------------|---------|----------|---------|---------|-------------------&#13;
</code></pre>&#13;
<p class="TX">For the purposes of this chapter, we’ll leave these lines uncovered. Otherwise, we could modify the mocked model to throw an error—for example, by supplying an invalid document—and then add a third test case per service verifying the error.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
<h4 class="H2" id="sec24"><span id="h2-125"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Performing an End-to-End Test of the REST API</samp></h4>&#13;
<p class="TNI">Sophisticated API tests might use a dedicated API testing library such as <i>SuperTest</i>, which provides matchers for HTTP status codes and simplifies the handling of requests and responses. Alternatively, they might use a GUI <span role="doc-pagebreak" epub:type="pagebreak" id="pg_152" aria-label=" Page 152. "/>tool like Postman. In this example, we’ll merely test that the returned data matches our expectations by using the native <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> method.</p>&#13;
<p class="TX">Unlike the previous tests, this one doesn’t isolate any single component, as our goal is to verify that all components of the system work together as expected. To check whether the API returns a proper response from the database when supplied some input, our end-to-end test will make certain assumptions: that all layers have already been tested independently, that the database contains its initial seed data, and that our application runs at <i>http://localhost:3000/</i>.</p>&#13;
<p class="TX">To verify our first assumption, open the API endpoint file <i>pages/api/v1/weather/[zipcode].ts</i>. You’ll notice that the API code imports two functions, <samp class="SANS_TheSansMonoCd_W5Regular_11">findByZip</samp> from the service module and the middleware’s <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp>, both of which we’ve already tested. The second assumption is also satisfied; the database loads the initial seed on each startup. Create the file <i>zipcode.e2e .test.ts</i> in <i>__tests__/pages/api/v1/weather/</i> and add the code from <a href="chapter8.xhtml#Lis8-22">Listing 8-22</a>.</p>&#13;
<span id="Lis8-22"/>&#13;
<pre class="pre-166"><code>/**&#13;
 * @jest-environment node&#13;
 */&#13;
&#13;
describe("The API /v1/weather/[zipcode]", () =&gt; {&#13;
    test("returns the correct data for the zipcode 96815", async () =&gt; {&#13;
        const zip = "96815";&#13;
        let response = await fetch(`http://localhost:3000/api/v1/weather/${zip}`);&#13;
        let body = await response.json();&#13;
        expect(body.zip).toEqual(zip);&#13;
    });&#13;
});&#13;
&#13;
export {};&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 8-22: The test suite for the REST API</span></p>&#13;
<p class="TX">We set the environment to <samp class="SANS_TheSansMonoCd_W5Regular_11">node</samp> and then define the test suite with one test case. In it, we supply a ZIP code that matches one of the initial seed datasets. Then we use the native <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> method, which has been available since Node.js version 17.5, to call our weather API on our localhost and check whether the returned ZIP code is the same as the one passed as a parameter. We add an empty export statement to define this file as an ES6 module.</p>&#13;
<p class="TX">The test should pass and have 100 percent code coverage. Now that we’re confident that the core of our application is working as expected, we can test the user interface components.</p>&#13;
<p class="TX">When using <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>, there are two common error messages you might encounter. The first, <samp class="SANS_TheSansMonoCd_W5Regular_11">ECONNREFUSED</samp>, tells you that <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> could not connect to your application because it is not running. Use <samp class="SANS_TheSansMonoCd_W7Bold_B_11">npm run dev</samp> to start the application or adjust the port in the <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> call if you’re not using port 3000. The second error mentions that the test exceeded the timeout of 5,000 ms for a test. If you started your application for the purposes of testing and did not use a previously running application, Next.js compiles the API route as soon as the test consumes it. Depending on your environment, this might take longer than the default timeout. Add the line <samp class="SANS_TheSansMonoCd_W7Bold_B_11">jest.setTimeout(20000);</samp> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_153" aria-label=" Page 153. "/>before the <samp class="SANS_TheSansMonoCd_W5Regular_11">describe</samp> method at the top of your file to increase the timeout and make the test wait 20,000 ms instead of 5,000 ms.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
<h4 class="H2" id="sec25"><span id="h2-126"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Evaluating the User Interface with a Snapshot Test</samp></h4>&#13;
<p class="TNI">Snapshot tests verify that a page’s rendered HTML didn’t change between two test runs. To achieve this with Jest, we must first prepare our environment. Add the <samp class="SANS_TheSansMonoCd_W5Regular_11">jsdom</samp> environment, <samp class="SANS_TheSansMonoCd_W5Regular_11">react-testing-library</samp>, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">react-test-renderer</samp> to the project:</p>&#13;
&#13;
<pre class="pre-167"><code>$ <b>npm install --save-dev jest-environment-jsdom</b>&#13;
$ <b>npm install --save-dev @testing-library/react @testing-library/jest-dom</b>&#13;
$ <b>npm install --save-dev @types/react-test-renderer react-test-renderer</b>&#13;
</code></pre>&#13;
<p class="TX">We’ll need these to simulate a browser environment and render React components during our test cases. Now we’ll modify the <i>jest.config.js</i> file in our root directory accordingly. Replace its content with the code in <a href="chapter8.xhtml#Lis8-23">Listing 8-23</a>.</p>&#13;
<span id="Lis8-23"/>&#13;
<pre class="pre-168"><code>const nextJest = require("next/jest");&#13;
const createJestConfig = nextJest({});&#13;
&#13;
module.exports = createJestConfig(nextJest({}));&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 8-23: The updated</span> <span class="Futura_Std_Book_11">jest.config.js</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">This code imports the <i>next/jest</i> package and exports a Jest configuration with the default properties of a Next.js project. It is the simplest form of Next.js-compatible Jest configuration. If you take a look at the official Next.js setup guide at <a href="https://nextjs.org/docs/testing"><i>https://<wbr/>nextjs<wbr/>.org<wbr/>/docs<wbr/>/testing</i></a>, you’ll see that it outlines some basic configuration options, none of which we need.</p>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
<h5 class="H3" id="sec26"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">The First Version</samp></h5>&#13;
<p class="TNI">A snapshot test renders a component or a page, takes a snapshot of it as serialized JSON, and stores it in a <i>__snapshots__</i> folder next to the test suite. On each consecutive run, Jest compares the current snapshot with the stored reference. As long as they are the same, the snapshot test passes. To generate the initial snapshot, create a new folder, <i>__tests__/pages/components</i>, and the file <i>weather.snapshot.test.tsx</i>, and then add the code in <a href="chapter8.xhtml#Lis8-24">Listing 8-24</a> to it.</p>&#13;
<span id="Lis8-24"/>&#13;
<pre class="pre-169"><code>/**&#13;
 * @jest-environment node&#13;
 */&#13;
&#13;
import {act, create} from "react-test-renderer";&#13;
import PageComponentWeather from "../../../pages/components/weather";&#13;
&#13;
describe("PageComponentWeather", () =&gt; {&#13;
    test("renders correctly", async () =&gt; {&#13;
        let component: any;&#13;
        await act(async () =&gt; {&#13;
            component =&#13;
                await create(&lt;PageComponentWeather&gt;&lt;/PageComponentWeather&gt;);&#13;
        });&#13;
        expect(component.toJSON()).toMatchSnapshot();&#13;
    });&#13;
});&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 8-24: The snapshot test for</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PageComponentWeather</samp></p>&#13;
<p class="TX">The first lines of our snapshot test set the environment to <samp class="SANS_TheSansMonoCd_W5Regular_11">jsdom</samp> and import the test renderer’s <samp class="SANS_TheSansMonoCd_W5Regular_11">act</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">create</samp> methods to test the React component, which we import in the next line.</p>&#13;
<p class="TX">Next, we write the simulated user behavior and wrap the component’s creation in the asynchronous <samp class="SANS_TheSansMonoCd_W5Regular_11">act</samp> function. As you might have guessed, this function draws its name from the <i>arrange, act, assert</i> pattern and ensures that all relevant updates to the DOM have been applied before proceeding with the test case. It is required for all statements that cause updates to the React state, and here, it delays the test execution until after the <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp> hook runs.</p>&#13;
<p class="TX">Then we write a test case that awaits the <samp class="SANS_TheSansMonoCd_W5Regular_11">create</samp> function, which renders the JSX component. This lets us generate HTML in a simulated browser environment and store the result in a variable. We await the component’s rendering so that the HTML is available for our follow-up interactions before we continue with the test case. Then we serialize the rendered component to a JSON string and use a new matcher, <samp class="SANS_TheSansMonoCd_W5Regular_11">toMatchSnapshot</samp>, which compares the current JSON string with the stored reference.</p>&#13;
<p class="TX">A trial run shows that all tests succeed. We see two interesting things— that the test created one snapshot and that we achieved a test coverage of 81 percent:</p>&#13;
&#13;
<pre class="pre-170"><code>PASS  __tests__/mongoose/weather/services.test.ts&#13;
PASS  __tests__/pages/api/v1/weather/zipcode.e2e.test.ts&#13;
PASS  __tests__/middleware/dbconnect.test.ts (7.193 s)&#13;
PASS  __tests__/pages/components/weather.snapshot.test.tsx&#13;
&#13;
---------------------|---------|----------|---------|---------|-------------------&#13;
File                 | % Stmts | % Branch | % Funcs | % Lines | Uncovered Lines&#13;
---------------------|---------|----------|---------|---------|-------------------&#13;
All files            |   83.63 |      100 |   88.23 |   82.35 |&#13;
 middleware          |     100 |      100 |     100 |     100 |&#13;
  db-connect.test.ts |     100 |      100 |     100 |     100 |&#13;
 mongoose/weather    |   77.41 |      100 |     100 |   75.86 |&#13;
  services.test.ts   |   70.83 |      100 |     100 |   70.83 |8,20-22,33-35,43-45&#13;
 pages/api/v1/       |         |          |         |         |&#13;
  weather            |         |          |         |         |&#13;
    [zipcode].ts     |     100 |      100 |     100 |     100 |&#13;
 pages/components    |   81.81 |      100 |      60 |      80 |&#13;
  weather.tsx        |   81.81 |      100 |      60 |      80 |8,12&#13;
---------------------|---------|----------|---------|---------|-------------------&#13;
Snapshot Summary&#13;
 › 1 snapshot written from 1 test suite.&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_155" aria-label=" Page 155. "/>You can look at the created snapshot by opening the <i>weather.snapshot.test.tsx.snap</i> file in the <i>__snapshots__</i> folder. It should look fairly similar to the code in <a href="chapter8.xhtml#Lis8-25">Listing 8-25</a>, and you’ll see that it is nothing more than the rendered HTML saved as a multiline template literal. Your HTML might not be identical to that shown here; the important aspect is that it looks the same after each test run when <samp class="SANS_TheSansMonoCd_W5Regular_11">react-test-renderer</samp> rendered the component.</p>&#13;
<span id="Lis8-25"/>&#13;
<pre class="pre-171"><code>// Jest Snapshot v1, https://goo.gl/fbAQLP&#13;
&#13;
exports[`PageComponentWeather renders correctly 1`] = `&#13;
&lt;h1&#13;
    data-testid="h1"&#13;
    onClick={[Function]}&#13;
&gt;&#13;
    The weather is&#13;
    sunny&#13;
    , and the counter shows&#13;
    0&#13;
&lt;/h1&gt;&#13;
`;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 8-25: The</span> <span class="Futura_Std_Book_11">weather.snapshot.test.tsx.snap</span> <span class="Futura_Std_Book_Oblique_BI_11">file with the serialized HTML</span></p>&#13;
<p class="TX">We also see that the counter is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, which indicates that the <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp> did not run before we created the snapshot. If you open the component’s file and check the uncovered lines, you’ll learn that they relate to the click handler that increases the <samp class="SANS_TheSansMonoCd_W5Regular_11">state</samp> variable and, as suspected, the <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp> hook. We want to test these core functionalities as well.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
<h5 class="H3" id="sec27"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Second Version</samp></h5>&#13;
<p class="TNI">We’ll modify the test code to cover the previously untested functionalities. Paste the code from <a href="chapter8.xhtml#Lis8-26">Listing 8-26</a> into the snapshot test file.</p>&#13;
<span id="Lis8-26"/>&#13;
<pre class="pre-172"><code>/**&#13;
 * @jest-environment node&#13;
 */&#13;
&#13;
import {act, create} from "react-test-renderer";&#13;
import PageComponentWeather from "../../../pages/components/weather";&#13;
&#13;
describe("PageComponentWeather", () =&gt; {&#13;
    test("renders correctly", async () =&gt; {&#13;
        let component: any;&#13;
        await act(async () =&gt; {&#13;
            component = await create(&lt;PageComponentWeather&gt;&lt;/PageComponentWeather&gt;);&#13;
        });&#13;
        expect(component.toJSON()).toMatchSnapshot();&#13;
    });&#13;
 &#13;
    test("clicks the h1 element and updates the state", async () =&gt; {&#13;
        let component: any;&#13;
        await act(async () =&gt; {&#13;
            component = await create(&lt;PageComponentWeather&gt;&lt;/PageComponentWeather&gt;);&#13;
            component.root.findByType("h1").props.onClick();&#13;
        });&#13;
        expect(component.toJSON()).toMatchSnapshot();&#13;
    });&#13;
 &#13;
});&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 8-26: The updated snapshot test</span></p>&#13;
<p class="TX">In the updated code, we’ve added another test case that finds the headline on the page and simulates a user clicking it. Remember from previous chapters that this increases the state variable <samp class="SANS_TheSansMonoCd_W5Regular_11">counter</samp>. Again, we await the creation of the component and use the <samp class="SANS_TheSansMonoCd_W5Regular_11">act</samp> function.</p>&#13;
<p class="TX">If you rerun the tests, you should see a failure. The test runner tells us that the snapshots do not match:</p>&#13;
&#13;
<pre class="pre-173"><code>FAIL  __tests__/pages/components/weather.snapshot.test.tsx&#13;
  • PageComponentWeather › renders correctly&#13;
<var>--snip--</var>&#13;
 › 1 snapshot failed.&#13;
<var>--snip--</var>&#13;
Snapshot Summary&#13;
 › 1 snapshot failed from 1 test suite.&#13;
› Inspect your code changes or run `npm test -- -u` to update them.&#13;
</code></pre>&#13;
<p class="TX">Because we modified the test case to wait for the <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp> hook and set the state variable <samp class="SANS_TheSansMonoCd_W5Regular_11">counter</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, the DOM changed as well. Follow the test runner’s advice and rerun the tests with <samp class="SANS_TheSansMonoCd_W5Regular_11">npm test -- -u</samp> to create a new, updated snapshot. The tests should now succeed, reporting a test coverage of 100 percent for our component.</p>&#13;
<p class="TX">Try experimenting with your newfound knowledge. For example, can you write a snapshot test for the page routes in the <i>pages</i> directory or a set of end-to-end tests for the GraphQL API?</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec28">&#13;
<h3 class="H1" id="sec28"><span id="h1-57"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI">You should now be able to create automated tests with Jest and, more broadly, design a testing plan on your own to strike a balance between effort and reward. We discussed the benefits of TDD and unit testing and then used the <i>arrange, act, assert</i> pattern to develop a simple <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> function following test-driven principles. Next, we used three types of test doubles to replace the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> function while calculating the Fibonacci sequence. Finally, we added unit and snapshot tests to our existing Next.js application, created a mock of a Mongoose model, and used spies to verify our assumptions.</p>&#13;
<p class="TX">To learn more about Jest and automated testing, consult the official Jest documentation at <a href="https://jestjs.io/docs/getting-started"><i>https://<wbr/>jestjs<wbr/>.io<wbr/>/docs<wbr/>/getting<wbr/>-started</i></a>. In the next chapter, you’ll explore the differences between authorization and authentication and how you can leverage OAuth in your applications.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>