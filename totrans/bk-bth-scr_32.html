<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><section aria-labelledby="ch29" epub:type="chapter" role="doc-chapter">
<hgroup>
<h2 class="title" id="ch29">
<span class="cn"><span aria-label=" Page 347. " epub:type="pagebreak" id="pg_347" role="doc-pagebreak" class="calibre2"/><span class="sans_dogma_ot_bold_b_">29</span></span>
<span class="ct1"><span class="sans_dogma_ot_bold_b_">ARRAYS AND HASH TABLES</span></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener1" height="407" src="../images/chapter.jpg" width="408"/>
</figure>
<p class="chapterintro">“Arrays? Batch doesn’t have arrays!” After daring to mention the use of this data structure in Batch code, I’ve received an array of incredulous responses. Technically, these skeptics have a point. Arrays are not intrinsic to the language, and the creators of Batch never anticipated their use.</p>
<p class="tx">However, over the years, some innovative coders have found ways to build something that looks like an array, walks like an array, and even quacks like an array (if arrays could quack ... and walk). In this chapter, I’ll explore multiple ways of building fixed- and variable-length arrays in Batch. You’ll learn how to iterate through an array and access any given element in it, as well as how to initialize an array. I’ll also discuss hash tables, detailing their similarities and differences with arrays, and then show how to populate them with data and retrieve that data. Most important, you’ll learn applications for both of these tools that you can use to better organize and house small and large sets of similar data during a bat file’s execution.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="h" id="sec1"><span id="h1-193"/><span aria-label=" Page 348. " epub:type="pagebreak" id="pg_348" role="doc-pagebreak"/><span class="sans_futura_std_bold_b_">Arrays</span></h3>
<p class="tni">Regardless of the coding language, an <i class="calibre6">array</i> is a data structure that holds multiple like variables of the same name, differentiated by an index. You can think of <i class="calibre6">like variables</i> as items or elements in a list; some commonality must tie them together. One array might hold the names of your co-workers. Countries of the world might be in another, and a third array might contain members of a basketball team. These are all examples of arrays of string variables, but an array can contain other data types. Three more arrays might represent statistics in each game of the season for that basketball team: points scored (whole numbers), point differential (integers), or offensive efficiency (floating-point numbers).</p>
<p class="tx">An array has a unique name, and each element in the array is denoted by a combination of the array name and a number or <i class="calibre6">index</i>. In most modern languages, the index counts up from <span class="sans_thesansmonocd_w5regular_">0</span>, which is a <i class="calibre6">zero-offset array</i>. In contrast, arrays that count up from <span class="sans_thesansmonocd_w5regular_">1</span> are <i class="calibre6">one-offset arrays</i>. I’ll be working solely with the more common zero-offset arrays. (If you’re a dyed-in-the-wool COBOL coder, you can build one-offset arrays just as easily in Batch, but at the risk of being labeled a dinosaur by your younger co-workers.)</p>
<p class="tx">One of the arrays just mentioned might be named <span class="sans_thesansmonocd_w5regular_">coworker</span> and another <span class="sans_thesansmonocd_w5regular_">points</span>. The value of <span class="sans_thesansmonocd_w5regular_">points[0]</span> would be the number of points scored in the first game of the season, <span class="sans_thesansmonocd_w5regular_">points[1]</span> would correspond to the second game, and so on. Your co-workers won’t be as ordered, but <span class="sans_thesansmonocd_w5regular_">coworker[0]</span> would be one person and <span class="sans_thesansmonocd_w5regular_">coworker[1]</span> would be another. If you work with 100 people, <span class="sans_thesansmonocd_w5regular_">coworker[99]</span> will be the final element of the 100-element array.</p>
<p class="tx">In many languages, you can define arrays in memory, assigning all of the elements of the array to a certain data type. As detailed often since <span class="xref"><a href="chapter5.xhtml" class="calibre3">Chapter 5</a></span>, Batch simply doesn’t allow you to define variables as certain data types, and that doesn’t change with arrays, but you can set the following variables:</p>
<pre class="pre"><code class="calibre11">set celtics[0]=Bird
set celtics[1]=McHale
set celtics[2]=Parish 
</code></pre>
<p class="tx">Any coder would tell you that this certainly looks like the first three elements of an array named <span class="sans_thesansmonocd_w5regular_">celtics</span>, and that’s exactly how it behaves. It’s important to note that there’s no unifying data structure in memory containing the three elements. Instead, the interpreter considers these to be just three different and ordinary variables whose names all just happen to start with the text <span class="sans_thesansmonocd_w5regular_">celtics[</span>, followed by a number and a trailing].</p>
<p class="tx">Because Batch is so accommodating when it comes to which characters are permissible in variable names, you can easily embed most characters on the keyboard into the variable name itself. Other coders have different conventions on how to name arrays, but I use the square brackets, also called hard brackets, around the index. And behold, an array is born.</p>
<section aria-labelledby="sec2" epub:type="division">
<h4 class="h1" id="sec2"><span id="h2-99"/><span aria-label=" Page 349. " epub:type="pagebreak" id="pg_349" role="doc-pagebreak"/><span class="sans_futura_std_heavy_oblique_bi_">Creating Arrays</span></h4>
<p class="tni">You can create arrays in many different ways. In the previous section, I created the <span class="sans_thesansmonocd_w5regular_">celtics</span> array with three elements. That code snippet defined three elements of the array by assigning three hardcoded values to three hardcoded variables. But you can build arrays of fixed or variable sizes from multiple different sources.</p>
<section aria-labelledby="sec3" epub:type="division">
<h5 class="h2" id="sec3"><span class="sans_futura_std_bold_b_">Fixed-Size Array from User Input</span></h5>
<p class="tni">Sticking with the basketball theme, it doesn’t take much code to build an array of exactly five elements, the starting five players, with data a user enters from the console. A fixed-size array requires a specific number of assignments, which begs for an iterative loop made possible with a <span class="sans_thesansmonocd_w5regular_">for /L</span> command (<span class="xref"><a href="chapter18.xhtml" class="calibre3">Chapter 18</a></span>). Likewise, user input begs for the <span class="sans_thesansmonocd_w5regular_">set /P</span> command (<span class="xref"><a href="chapter15.xhtml" class="calibre3">Chapter 15</a></span>). Here’s the code:</p>
<pre class="pre"><code class="calibre11">&gt; con echo Please Enter the Starting Five:
for /L %%i in (0,1,4) do (
   &gt; con set /P myTeam[%%i]=Enter Array Value %%i = &amp;rem
)
</code></pre>
<p class="tni">The trailing <span class="sans_thesansmonocd_w5regular_">&amp;rem</span> is just there to spotlight the space before it.</p>
<p class="tx">This loop executes the command requesting user input five times, iterating the index, <span class="sans_thesansmonocd_w5regular_">%%i</span>, from <span class="sans_thesansmonocd_w5regular_">0</span> to <span class="sans_thesansmonocd_w5regular_">4</span>. One of the advantages of Batch coding is that variable names can contain other variables, something you can’t easily do in many other languages. Notice that the variable <span class="sans_thesansmonocd_w5regular_">myTeam[%%i]</span> has three components:</p>
<ul class="ul">
<li class="listbullet">The text string ending in the open square bracket: <span class="sans_thesansmonocd_w5regular_">myTeam[</span></li>
<li class="listbullet">The number resolved from <span class="sans_thesansmonocd_w5regular_">%%i</span>: <span class="sans_thesansmonocd_w5regular_">0</span> through <span class="sans_thesansmonocd_w5regular_">4</span></li>
<li class="listbullet">The single character of text for the close square bracket:]</li>
</ul>
<p class="tx">The first time through the loop, the variable name resolves to <span class="sans_thesansmonocd_w5regular_">myTeam[0]</span> as the code assigns it the first value retrieved from the console. Then <span class="sans_thesansmonocd_w5regular_">myTeam[1]</span> accepts the second value entered, and so on until <span class="sans_thesansmonocd_w5regular_">myTeam[4]</span> takes on the value of the fifth and final entry. I’ll be using the same basic technique in the upcoming examples of element assignment.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h5 class="h2" id="sec4"><span class="sans_futura_std_bold_b_">Variable-Size Array from a Parameter List</span></h5>
<p class="tni">I defined the previous array to be a set size, but you often don’t know the ultimate size of an array. The following routine uses an optionless <span class="sans_thesansmonocd_w5regular_">for</span> command (<span class="xref"><a href="chapter17.xhtml" class="calibre3">Chapter 17</a></span>) to process all the parameters passed to it, <span class="sans_thesansmonocd_w5regular_">%*</span>, adding each one to the <span class="sans_thesansmonocd_w5regular_">parmArr</span> (parameter array).</p>
<pre class="pre"><code class="calibre11"><span aria-label=" Page 350. " epub:type="pagebreak" id="pg_350" role="doc-pagebreak"/>:BuildParmArray
 set parmArrSize=0
 for %%i in (%*) do (
    set parmArr[!parmArrSize!]=%%~i
    set /A parmArrSize += 1
 )
 set parmArr
 goto :eof
</code></pre>
<p class="tx">Instead of an iterative loop with a built-in index, this code is executing the code block of the <span class="sans_thesansmonocd_w5regular_">for</span> command once for each parameter. As a result, I first define or initialize the index, defined as <span class="sans_thesansmonocd_w5regular_">parmArrSize</span>, and then increment it with each enumeration of the loop. Since I set it to <span class="sans_thesansmonocd_w5regular_">0</span> initially, the first pass of the loop assigns the first parameter to <span class="sans_thesansmonocd_w5regular_">parmArr[0]</span>. If there are 20 parameters, the <span class="sans_thesansmonocd_w5regular_">for</span> loop assigns 20 elements, up through <span class="sans_thesansmonocd_w5regular_">parmArr[19]</span>.</p>
<p class="tx">This is a subtle point, but notice that I’m incrementing <span class="sans_thesansmonocd_w5regular_">parmArrSize</span> at the end of the loop to the index value of the next parameter, whether or not another one exists. The upshot is that if this code assigns elements <span class="sans_thesansmonocd_w5regular_">0</span> through <span class="sans_thesansmonocd_w5regular_">19</span>, the ultimate value of <span class="sans_thesansmonocd_w5regular_">parmArrSize</span> is <span class="sans_thesansmonocd_w5regular_">20</span>, which is the actual size of the array. Many languages have a method that returns the size of an array; in Batch the next best thing is a variable with that data item.</p>
<p class="tx">This code builds a zero-offset array, but you can build a one-offset array with one minor tweak. Swap the two <span class="sans_thesansmonocd_w5regular_">set</span> commands in the code block to assign <span class="sans_thesansmonocd_w5regular_">parmArr[1]</span> as the first element, and <span class="sans_thesansmonocd_w5regular_">parmArrSize</span> will still contain the correct array size.</p>
<p class="tx">If the call to this routine passes no parameters, <span class="sans_thesansmonocd_w5regular_">parmArrSize</span> remains as <span class="sans_thesansmonocd_w5regular_">0</span>, and this logic adds nothing to the array because the code block of the <span class="sans_thesansmonocd_w5regular_">for</span> command doesn’t execute at all. Thus, this code successfully creates an empty array.</p>
<p class="tx">Also, I don’t want to give short shrift to the <span class="sans_thesansmonocd_w5regular_">set</span> command after the code block. Immediately after building or populating an array, I usually like to document its current contents. This command writes all the variables starting with the <span class="sans_thesansmonocd_w5regular_">parmArr</span> text and their values to stdout or the trace file. Since all of the elements of the array start with this text, they’ll all be displayed.</p>
<p class="tx">I highly recommend doing this for all arrays that aren’t too large. You’ll usually ignore this data, but when a need to troubleshoot arises, it’ll make the task far more pleasant. For diagnostic purposes, it provides a great audit trail of how this code loaded the array, and you can easily repeat it elsewhere in the code after later manipulating the array in any way.</p>
<p class="tx">As a final note on this listing, you may take issue with the variable name I’m using for the index. It’s usually best to define indices succinctly, but <span class="sans_thesansmonocd_w5regular_">parmArrSize</span> is an awfully verbose, even clunky, name for a reason. Since this variable name is the concatenation of the name of the array and the <span class="sans_thesansmonocd_w5regular_">Size</span> text, the <span class="sans_thesansmonocd_w5regular_">set parmArr</span> command displays it and its value along with the array contents. If the array has even a fairly unique name, it’s unlikely that anything else will meet the criterion, resulting in this command cleanly displaying everything you want to know about the current state of this array: its elements and its size.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h5 class="h2" id="sec5"><span aria-label=" Page 351. " epub:type="pagebreak" id="pg_351" role="doc-pagebreak"/><span class="sans_futura_std_bold_b_">Symbiotic Arrays from a File</span></h5>
<p class="tni">I’ll demonstrate a couple intriguing concepts in this next example that you can use together or on their own. One is loading an array from a data file, and the other is building symbiotic arrays. Two arrays are <i class="calibre6">symbiotic</i> when they are the same size and synced up by their indices. For example, two arrays, one of co-workers and one of phone numbers, might each contain 10 entries. That doesn’t make them symbiotic, but if the phone number at index <span class="sans_thesansmonocd_w5regular_">0</span> belongs to the co-worker at index <span class="sans_thesansmonocd_w5regular_">0</span> of the other array and if the same is true of all 10 sets of elements, the arrays are symbiotic.</p>
<p class="tx">In <span class="xref"><a href="chapter15.xhtml" class="calibre3">Chapter 15</a></span>, I presented an interactive bat file that told a joke, a pun, or a riddle. In <span class="xref"><a href="chapter21.xhtml" class="calibre3">Chapter 21</a></span>, when discussing the <span class="sans_thesansmonocd_w5regular_">random</span> pseudo-environment variable, I expanded on this by imagining dozens of jokes, puns, and riddles, all in memory and randomly accessible—ostensibly giving the users hours of entertainment. The last piece to this puzzle is reading a library (also known as a file) containing dozens of jokes and loading them into memory to be accessed randomly. That sounds like an array ... or maybe two arrays.</p>
<p class="tx">Let’s focus solely on the jokes for now and put the puns and riddles aside, knowing that we can do something similar for them later. Mercifully, I’ll include only the first three lines of the <i class="calibre6">BatJokes.txt</i> file (not to be confused with the <i class="calibre6">BadJokes.txt</i> file), but just imagine hundreds of lines of material. Each record contains a joke followed by its answer, delimited by a pipe:</p>
<pre class="pre"><code class="calibre11">Why are bats so active at night?|They charge their bat-teries by day.
How do bats flirt?|They bat their eyes.
What's a good pick-up line for a bat?|Let's hang.
</code></pre>
<p class="tx">The code in <a href="#Lis29-1" class="calibre3">Listing 29-1</a> loads this comedic gold into two arrays, the jokes into the <span class="sans_thesansmonocd_w5regular_">joke</span> array and the answers into the <span class="sans_thesansmonocd_w5regular_">answer</span> array.</p>
<span id="Lis29-1"/>
<pre class="pre"><code class="calibre11">set jokes=0
for /F "tokens=1-2 delims=|" %%b in (C:\Batch\BatJokes.txt) do (
   set joke[!jokes!]=%%~b
   set answer[!jokes!]=%%~c
   set /A jokes += 1
)
set joke
set answer
</code></pre>
<p class="listingcaption"><span class="futura_std_book_oblique_i_">Listing 29-1: Symbiotic arrays built from a data file</span></p>
<p class="tx">These are symbiotic arrays in that the <span class="sans_thesansmonocd_w5regular_">joke</span> located at a specific index corresponds to the <span class="sans_thesansmonocd_w5regular_">answer</span> of the same index. As the <span class="sans_thesansmonocd_w5regular_">for /F</span> command reads each record, it delimits on the pipe to tokenize the text for the <span class="sans_thesansmonocd_w5regular_">joke</span> and its <span class="sans_thesansmonocd_w5regular_">answer</span>. The first two <span class="sans_thesansmonocd_w5regular_">set</span> commands assign each string to an element of the appropriate array using the pluralized <span class="sans_thesansmonocd_w5regular_">jokes</span> index. I’m using this index for both arrays because they’re symbiotic arrays, while incrementing it at the end of the code block.</p>
<p class="tx"><span aria-label=" Page 352. " epub:type="pagebreak" id="pg_352" role="doc-pagebreak"/>The <span class="sans_thesansmonocd_w5regular_">set</span> commands outside of the loop write the following to the console verifying that both arrays were loaded successfully:</p>
<pre class="pre"><code class="calibre11">C:\Batch&gt;set joke 
jokes=3
joke[0]=Why are bats so active at night?
joke[1]=How do bats flirt?
joke[2]=What's a good pick-up line for a bat?

C:\Batch&gt;set answer 
answer[0]=They charge their bat-teries by day.
answer[1]=They bat their eyes.
answer[2]=Let's hang.
</code></pre>
<p class="tni">This also verifies that <span class="sans_thesansmonocd_w5regular_">3</span> is the total number of jokes.</p>
<p class="tx">I’ve built both arrays from a single file, and the contents of <span class="sans_thesansmonocd_w5regular_">answer[1]</span> is the punchline for the contents of <span class="sans_thesansmonocd_w5regular_">joke[1]</span>. If the file had a thousand entries, both symbiotic arrays would have had a thousand elements, and all of their elements would have been synced up. I can set up two more arrays for the riddles, although I must use something other than <span class="sans_thesansmonocd_w5regular_">answer</span> for the name of the riddle punchline array. Puns don’t have punchlines, so I can load each entire record into a <span class="sans_thesansmonocd_w5regular_">pun</span> array.</p>
<p class="tx">We now have almost everything needed to build a truly usable user interface of bat jokes, puns, and riddles. We can build libraries of humor, and we can load those libraries into memory as arrays. We can get a request from the user for a type of humor, and we can randomly determine which of the many jokes, puns, or riddles to select. The last piece is the ability to access the arrays—that is, to extract a joke and its answer to be displayed.</p>
</section>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h4 class="h1" id="sec6"><span id="h2-100"/><span class="sans_futura_std_heavy_oblique_bi_">Accessing Array Elements</span></h4>
<p class="tni">In order for this to be a <i class="calibre6">real</i> array, we must be able to iterate through it, reassign elements, assign elements to other variables, resolve elements, and more. To demonstrate how to access array elements, I’ll first assign 14 elements of the <span class="sans_thesansmonocd_w5regular_">myChar</span> array:</p>
<pre class="pre"><code class="calibre11">set myChar[0]=B
set myChar[1]=a
set myChar[2]=t
set myChar[3]=c
set myChar[4]=h
set myChar[5]= &amp;
set myChar[6]=i
set myChar[7]=s
set myChar[8]=%myChar[5]%
set myChar[9]=C
set myChar[10]=o
set myChar[11]=!myChar[10]!
set myChar[12]=l
set myChar[13]=.
</code></pre>
<p class="tx">I’m assigning each element a single character. Most are straightforward, but a few are a bit more interesting. The sixth <span class="sans_thesansmonocd_w5regular_">set</span> command assigns element <span aria-label=" Page 353. " epub:type="pagebreak" id="pg_353" role="doc-pagebreak"/><span class="sans_thesansmonocd_w5regular_">5</span> to a single space terminated by a command separator, making it obvious that it isn’t being set to null or multiple spaces. Elements <span class="sans_thesansmonocd_w5regular_">8</span> and <span class="sans_thesansmonocd_w5regular_">11</span> are taking on the value of elements defined earlier, so element <span class="sans_thesansmonocd_w5regular_">8</span> is a space, and elements <span class="sans_thesansmonocd_w5regular_">10</span> and <span class="sans_thesansmonocd_w5regular_">11</span> are both the letter <span class="sans_thesansmonocd_w5regular_">o</span>.</p>
<p class="tx">The two resolutions of elements with a hardcoded index illustrate that both delimiters work equally as well. Using percent signs, <span class="sans_thesansmonocd_w5regular_">%myChar[5]%</span> resolves to the 6th element, and with exclamation marks, <span class="sans_thesansmonocd_w5regular_">!myChar[10]!</span> resolves to the 11th element. The syntax is more limited when the index is a variable, as you’ll soon witness.</p>
<p class="tx">Now we can write a <span class="sans_thesansmonocd_w5regular_">for /L</span> command that will iterate through this array, concatenating all the values together into a sentence:</p>
<pre class="pre"><code class="calibre11">set mySentence=&amp;
for /L %%i in (0,1,13) do (
   set mySentence=!mySentence!!myChar[%%i]!
)
&gt; con echo %mySentence%
</code></pre>
<p class="tni">After building the string, the last command writes <span class="sans_thesansmonocd_w5regular_">Batch is Cool.</span> to the console.</p>
<p class="tx">Backing up, the <span class="sans_thesansmonocd_w5regular_">for</span> command iterates <span class="sans_thesansmonocd_w5regular_">%%i</span> from <span class="sans_thesansmonocd_w5regular_">0</span> to <span class="sans_thesansmonocd_w5regular_">13</span>, where <span class="sans_thesansmonocd_w5regular_">!myChar[%%i]!</span> successively resolves to each of the 14 elements. The interpreter first resolves the <span class="sans_thesansmonocd_w5regular_">%%i</span> index and then the array element. For instance, the first time through the loop, the intermediate result is <span class="sans_thesansmonocd_w5regular_">myChar[0]</span>. Since that’s surrounded by exclamation marks, the interpreter resolves it to <span class="sans_thesansmonocd_w5regular_">B</span> and assigns it to <span class="sans_thesansmonocd_w5regular_">mySentence</span>. The second time through the loop, <span class="sans_thesansmonocd_w5regular_">myChar[1]</span> resolves to <span class="sans_thesansmonocd_w5regular_">a</span>, which the interpreter concatenates to the prior result giving us <span class="sans_thesansmonocd_w5regular_">Ba</span>. This repeats another dozen times until we’ve constructed the entire sentence.</p>
<p class="tx">This is yet another example of the power of delayed expansion, and with delayed expansion, you must use exclamation marks as the outside delimiters; percent signs simply won’t work. It’s quite tempting to try <span class="sans_thesansmonocd_w5regular_">%myChar[%%i]%</span>, but if you think as the interpreter does, you won’t see an array. You’ll see two discrete variables to resolve: <span class="sans_thesansmonocd_w5regular_">myChar[</span>and <span class="sans_thesansmonocd_w5regular_">i]</span>. In this example, a <span class="sans_thesansmonocd_w5regular_">for</span> variable is the index, but delayed expansion works the same with a common variable as the index. Consider the following where percent signs encase the <span class="sans_thesansmonocd_w5regular_">idx</span> index and exclamation marks encase the outer array element for the second level of delayed expansion:</p>
<pre class="pre"><code class="calibre11">set idx=9
&gt; con echo The Tenth Element is: !myChar[%idx%]!
</code></pre>
<p class="tni">This writes the capital <span class="sans_thesansmonocd_w5regular_">C</span> to the console.</p>
<p class="tx">Similarly, to extract a joke and its answer from the symbiotic arrays built in <a href="#Lis29-1" class="calibre3">Listing 29-1</a>, you can enter a random non-negative number less than the number of jokes into an index variable such as <span class="sans_thesansmonocd_w5regular_">jokeIdx</span>. Then you can resolve the joke with <span class="sans_thesansmonocd_w5regular_">!joke[%jokeIdx%]!</span>. Because these are symbiotic arrays, you can retrieve its answer with the same index: <span class="sans_thesansmonocd_w5regular_">!answer[%jokeIdx%]!</span>. You now have all of the tools necessary to update the bat file in <span class="xref"><a href="chapter15.xhtml" class="calibre3">Chapter 15</a></span> to randomly display one of any number of jokes, puns, and riddles.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h4 class="h1" id="sec7"><span id="h2-101"/><span aria-label=" Page 354. " epub:type="pagebreak" id="pg_354" role="doc-pagebreak"/><span class="sans_futura_std_heavy_oblique_bi_">Initializing an Array</span></h4>
<p class="tni">Languages with proper arrays usually offer a simple one-line command for creating an array or even re-initializing all of the elements of an existing array. There’s no instantiation of variables, much less of arrays, in Batch, so once again ingenuity is a must.</p>
<p class="tx">Before building the <span class="sans_thesansmonocd_w5regular_">joke</span> array, it makes sense to initialize it just as I have often initialized a variable to <span class="sans_thesansmonocd_w5regular_">0</span> before entering a loop. It’s true that it’s highly unlikely that any active variables start with the <span class="sans_thesansmonocd_w5regular_">joke[</span>text, but there are definitely instances when you’ll want to re-initialize and rebuild an array already in use. The following wipes out all elements of the <span class="sans_thesansmonocd_w5regular_">joke</span> array:</p>
<pre class="pre"><code class="calibre11">for /F "usebackq delims==" %%j in (`set joke[`)  do (set %%j=)</code></pre>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">for /F</span> command accepts as input the <span class="sans_thesansmonocd_w5regular_">set</span> command listing every existing element of the array and its value. By delimiting on the equal sign and passing only the first token—that is, the variable or element name but not its value—we’re setting each element to null in the code block. If there aren’t any variables to reset, the second <span class="sans_thesansmonocd_w5regular_">set</span> command never executes, and the end result is the same.</p>
<p class="tx">In prior examples, I’ve simply assumed that no elements already existed when building arrays. To be certain, it’s best to execute a command such as this to initialize the array before building and using it.</p>
<aside aria-label="box-7" class="box">
<p class="boxtitle" id="box-7"><span class="sans_futura_std_bold_b_">INDEX OUT OF BOUNDS</span></p>
<p class="boxbodyfirst"><span class="sans_futura_std_book_">The best thing about Batch arrays is that they’ll never throw the dreaded</span> <span class="futura_std_book_oblique_i_">index out of bounds</span> <span class="sans_futura_std_book_">abort that’s ubiquitous in other languages. And the worst thing about Batch arrays is that they’ll never throw the dreaded</span> <span class="futura_std_book_oblique_i_">index out of bounds</span> <span class="sans_futura_std_book_">abort.</span></p>
<p class="boxbody"><span class="sans_futura_std_book_">For better or worse, the interpreter sees elements as simple variables, thus resolving any unset elements to null, allowing the process to continue unabated. If the</span> <span class="sans_thesansmonocd_w5regular_">joke</span> <span class="sans_futura_std_book_">array mentioned earlier contains 100 elements, indexed by</span> <span class="sans_thesansmonocd_w5regular_">0</span> <span class="sans_futura_std_book_">to</span> <span class="sans_thesansmonocd_w5regular_">99</span><span class="sans_futura_std_book_">, resolving the value of</span> <span class="sans_thesansmonocd_w5regular_">joke[100]</span> <span class="sans_futura_std_book_">won’t result in an abort; it’ll simply resolve to nothing.</span></p>
<p class="boxbody"><span class="sans_futura_std_book_">This can be an asset. You can enumerate through an array until a null alerts you to the end of the array. In other instances, you might not care to differentiate between an empty element and an undefined element. But the lack of an abort can also cause problems. If you’re expecting an element to contain a valid value but it doesn’t, an abort in some other language will set you on the path of fixing the error. In this instance, the lack of distinction between a purposely set null element and an unset element does matter.</span></p>
<p class="boxbodylast"><span class="sans_futura_std_book_">In the final analysis, use this behavior to your advantage when appropriate, but take care to set and resolve any and all intended elements correctly.</span></p>
</aside>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h4 class="h1" id="sec8"><span id="h2-102"/><span aria-label=" Page 355. " epub:type="pagebreak" id="pg_355" role="doc-pagebreak"/><span class="sans_futura_std_heavy_oblique_bi_">Implementing Multidimensional Arrays</span></h4>
<p class="tni">This technique even extends to building and accessing multidimensional arrays. Single-dimensional arrays are largely possible in Batch because you can embed square brackets into a variable name. For multiple dimensions, we just need one more character: the comma. The following command sets row <span class="sans_thesansmonocd_w5regular_">1</span> and column <span class="sans_thesansmonocd_w5regular_">2</span> of the <span class="sans_thesansmonocd_w5regular_">my2dArray</span> array to a hardcoded value in what unmistakably resembles an element assignment of a two-dimensional array regardless of the language:</p>
<pre class="pre"><code class="calibre11">set my2dArray[1,2]=Row1Col2Data</code></pre>
<p class="tx">As a demonstration, I’ll briefly re-imagine two prior examples as two-dimensional arrays:</p>
<p class="listhead"><b class="calibre10">User Input</b></p>
<p class="listplainfirst">Returning to the array built with user input, the following nested <span class="sans_thesansmonocd_w5regular_">for /L</span> commands build a two-dimensional array of three rows and four columns:</p>
<pre class="list"><code class="calibre11"><span class="sans_thesansmonocd_w5regular_">&gt; con echo Please Enter 2-Dimensional Array Data for 3 rows and 4 columns:</span>
for /L %%r in (0,1,2) do (
   for /L %%c in (0,1,3) do (
      &gt; con set /P my2dArray[%%r,%%c]=Enter Row %%r, Column %%c = &amp;rem
)  )
</code></pre>
<p class="listcontinued1">The outer <span class="sans_thesansmonocd_w5regular_">for</span> variable, <span class="sans_thesansmonocd_w5regular_">%%r</span>, loops through the three rows, while <span class="sans_thesansmonocd_w5regular_">%%c</span> loops through the four columns for each row. This code accepts exactly 12 values before continuing.</p>
<p class="listbody">If <span class="sans_thesansmonocd_w5regular_">rowIdx</span> is set to <span class="sans_thesansmonocd_w5regular_">2</span> and <span class="sans_thesansmonocd_w5regular_">colIdx</span> is set to <span class="sans_thesansmonocd_w5regular_">3</span>, the following resolves to the last data element entered by the user:</p>
<pre class="list"><code class="calibre11"><span class="sans_thesansmonocd_w5regular_">!my2dArray[%rowIdx%,%colIdx%]!</span>
</code></pre>
<p class="listcontinued">The two indices resolve first with the percent signs, resulting in <span class="sans_thesansmonocd_w5regular_">!my2dArray[2,3]!</span>. Then the exclamation marks and delayed expansion finish the job.</p>
<p class="listhead"><b class="calibre10">File Input</b></p>
<p class="listplainfirst">Earlier, we built the two symbiotic arrays, for the joke and answer, from each record of an input file. Instead, we can load the data into a single two-dimensional array where the second-level index of <span class="sans_thesansmonocd_w5regular_">0</span> is the joke and <span class="sans_thesansmonocd_w5regular_">1</span> is the answer:</p>
<pre class="list"><code class="calibre11"><span class="sans_thesansmonocd_w5regular_">set jokes=0</span>
for /F "tokens=1-2 delims=|" %%b in (C:\Batch\BatJokes.txt) do (
   set joke[!jokes!,0]=%%~b
   set joke[!jokes!,1]=%%~c
   set /A jokes += 1
)
set joke
</code></pre>
<p class="listbody"><span aria-label=" Page 356. " epub:type="pagebreak" id="pg_356" role="doc-pagebreak"/>You can think of this array as having exactly two columns; notice the hardcoded index for the second dimension in both assignments: <span class="sans_thesansmonocd_w5regular_">0</span> and <span class="sans_thesansmonocd_w5regular_">1</span>. The <span class="sans_thesansmonocd_w5regular_">set /A</span> command increments the <span class="sans_thesansmonocd_w5regular_">jokes</span> index. The number of rows is dictated by the number of records in the input file. Finally, the single <span class="sans_thesansmonocd_w5regular_">set</span> command at the end of the listing produces the following audit trail given the same three-record input file used earlier:</p>
<pre class="list"><code class="calibre11"><span class="sans_thesansmonocd_w5regular_">jokes=3</span>
joke[0,0]=Why are bats so active at night?
joke[0,1]=They charge their bat-teries by day.
joke[1,0]=How do bats flirt?
joke[1,1]=They bat their eyes.
joke[2,0]=What's a good pick-up line for a bat?
joke[2,1]=Let's hang.
</code></pre>
<p class="tx">Arrays of even greater dimensions are only a comma or two away: <span class="sans_thesansmonocd_w5regular_">my4dArray[1,2,3,4]</span>. I don’t remember ever coding anything quite like this, but single-dimensional arrays and even two-dimensional arrays have many applications in Batch.</p>
<p class="tx">Regardless of the dimension, if you need an extremely large array or if you plan on accessing it many thousands of times, compiled code is a far more efficient solution. But when used wisely, Batch arrays are quite helpful and surprisingly easy to manage.</p>
</section>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h3 class="h" id="sec9"><span id="h1-194"/><span class="sans_futura_std_bold_b_">Hash Tables</span></h3>
<p class="tni">It turns out that Batch does support arrays, or at least we can fashion an array out of the rudimentary tools at our disposal. But surely a hash table isn’t possible? You’ve probably intuited the answer to this question given the title of the chapter and the section that you’re now reading, but before building a hash table, let’s define what it is.</p>
<p class="tx">A <i class="calibre6">hash table</i> (sometimes called a <i class="calibre6">hash map</i>) is a data structure that stores data in pairs: a key and a value. The <i class="calibre6">value</i> can be of any data type, even other data structures. The <i class="calibre6">key</i> is similar to the index of an array, but it doesn’t have to be an integer. In fact, in the Batch universe, arrays and hash tables behave very much alike; in fact, the best way to compare and contrast them is to transform an array into a hash table.</p>
<section aria-labelledby="sec10" epub:type="division">
<h4 class="h1" id="sec10"><span id="h2-103"/><span class="sans_futura_std_heavy_oblique_bi_">Arrays vs. Hash Tables</span></h4>
<p class="tni">Imagine an array where the index is the date formatted as CCYYMMDD and the data is the number of steps a person might take in a day. If this otherwise active individual was sedentary on the first pandemic Christmas doing little more than opening presents and drinking eggnog in solitude, the <span class="sans_thesansmonocd_w5regular_">steps</span> array might contain these three entries:</p>
<pre class="pre"><code class="calibre11"><span aria-label=" Page 357. " epub:type="pagebreak" id="pg_357" role="doc-pagebreak"/>set steps[20201224]=15842
set steps[20201225]=987
set steps[20201226]=13009
</code></pre>
<p class="tx">These indices are quite large, even though we’re using only a small number of elements. It’s a good thing that we didn’t define this array in memory like we would have in many other languages, because its size would have been upward of 20 million elements. One advantage of a Batch array is that it uses memory only for the elements that are defined. Memory has gotten mighty cheap, but there’s still no reason to be profligate.</p>
<p class="tx">The minimal usage of memory is a direct result of the array element (for example, <span class="sans_thesansmonocd_w5regular_">steps[20201225]</span>) being a simple variable with a name consisting of some text, a number, and a couple square brackets. Another advantage of the underlying nature of Batch elements is that the index doesn’t have to be a number at all; in fact, it needn’t even be a true index. To demonstrate, let’s format the date as MM/DD/CCYY for readability:</p>
<pre class="pre"><code class="calibre11">set steps[12/24/2020]=15842
set steps[12/25/2020]=987
set steps[12/26/2020]=13009
</code></pre>
<p class="tx">Because the index is not an integer, this is no longer an array; we’ve transformed it into a hash table. Period, just like that. We can’t iterate through it like we could an array, but we can look up the number of steps given a formatted date. We can no longer retrieve an element for a given index; instead, the lookup involves a key between those brackets.</p>
<p class="tx">Taking this a step further, let’s add text for the day of the week and even an embedded space to the key:</p>
<pre class="pre"><code class="calibre11">set steps[Thu 12/24/2020]=15842
set steps[Fri 12/25/2020]=987
set steps[Sat 12/26/2020]=13009
</code></pre>
<p class="tni">Not incidentally, that key is starting to look a lot like what we can resolve from the <span class="sans_thesansmonocd_w5regular_">date</span> pseudo-environment variable.</p>
<p class="tx">One small problem with this syntax is that it falsely looks like an array. The non-numeric key, in lieu of an index, might make it clear that it isn’t an array, but the key will more than likely be a variable, thus obscuring its data type. For this reason, a different convention is ideal. Personally, I’ve settled on using curly brackets, also called braces:</p>
<pre class="pre"><code class="calibre11">set steps{Thu 12/24/2020}=15842
set steps{Fri 12/25/2020}=987
set steps{Sat 12/26/2020}=13009
</code></pre>
<p class="tx">This is just one convention, and there are others that work just as well. For instance, you can prepend hash table variables with <span class="sans_thesansmonocd_w5regular_">ht</span>. What’s important is that you make the data structure look like something unique and something other than an array. Anyone who reads the code, even quickly, <span aria-label=" Page 358. " epub:type="pagebreak" id="pg_358" role="doc-pagebreak"/>should notice the difference. Even if the reader doesn’t know the convention, the uniqueness of the syntax will raise curiosity, which in turn cracks open the door to understanding.</p>
<p class="tx">Consider this simple, and at the same time not so simple, <span class="sans_thesansmonocd_w5regular_">set</span> command:</p>
<pre class="pre"><code class="calibre11">set steps{%date%}=987</code></pre>
<p class="tx">This command is setting one element of the <span class="sans_thesansmonocd_w5regular_">steps</span> hash table, and the key is the formatted date of whenever the command executes.</p>
<p class="tx">If you choose to use my convention, I’ll summarize it as <span class="sans_thesansmonocd_w5regular_">array[index]</span> and <span class="sans_thesansmonocd_w5regular_">hashTable{key}</span>, but as always, use the convention that makes sense to you and stick with it.</p>
</section>
<section aria-labelledby="sec11" epub:type="division">
<h4 class="h1" id="sec11"><span id="h2-104"/><span class="sans_futura_std_heavy_oblique_bi_">Basic Hash Table Functionality</span></h4>
<p class="tni">Another example of a basic hash table contains multiple pairs of a person and their occupation, where the person’s name is the key, and their job is the value. For instance, the <span class="sans_thesansmonocd_w5regular_">Darwin</span> key retrieves the <span class="sans_thesansmonocd_w5regular_">Naturalist</span> value. <span class="sans_thesansmonocd_w5regular_">Lincoln</span>, <span class="sans_thesansmonocd_w5regular_">Poe</span>, and <span class="sans_thesansmonocd_w5regular_">Braille</span> are the respective keys for the <span class="sans_thesansmonocd_w5regular_">President</span>, <span class="sans_thesansmonocd_w5regular_">Poet</span>, and <span class="sans_thesansmonocd_w5regular_">Inventor</span> values. Here’s the hash table in tabular form:</p>
<table class="basic-table">
<thead class="calibre15">
<tr class="calibre16">
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Key</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Value</span></p></th>
</tr>
</thead>
<tbody class="calibre17">
<tr class="calibre18">
<td class="basic-table1"><p class="tableheader"><span class="sans_futura_std_book_">Lincoln</span></p></td>
<td class="basic-table1"><p class="tableheader"><span class="sans_futura_std_book_">President</span></p></td>
</tr>
<tr class="calibre16">
<td class="basic-table2"><p class="tableheader"><span class="sans_futura_std_book_">Darwin</span></p></td>
<td class="basic-table2"><p class="tableheader"><span class="sans_futura_std_book_">Naturalist</span></p></td>
</tr>
<tr class="calibre18">
<td class="basic-table2"><p class="tableheader"><span class="sans_futura_std_book_">Poe</span></p></td>
<td class="basic-table2"><p class="tableheader"><span class="sans_futura_std_book_">Poet</span></p></td>
</tr>
<tr class="calibre16">
<td class="basic-table3"><p class="tableheader"><span class="sans_futura_std_book_">Braille</span></p></td>
<td class="basic-table3"><p class="tableheader"><span class="sans_futura_std_book_">Inventor</span></p></td>
</tr>
</tbody>
</table>
<p class="tni">Notice the lack of an index and any semblance of order to the elements.</p>
<p class="tx">Every key must be a unique value. If there are two people in this hash table named <span class="sans_thesansmonocd_w5regular_">Darwin</span>, we’ll need to distinguish them in some way, perhaps by adding first and middle names. However, multiple people can hold the job of <span class="sans_thesansmonocd_w5regular_">Poet</span>; that is, the value doesn’t have to be unique.</p>
<p class="tx">The syntax for building and accessing elements of a hash table in Batch is very different from that of many other languages, where after declaring the <span class="sans_thesansmonocd_w5regular_">jobs</span> hash table, you can define a single key-value pair via some variant of the <i class="calibre6">put</i> method. For instance, this is how to do it in Java:</p>
<pre class="pre"><code class="calibre11">jobs.put("Lincoln", "President");</code></pre>
<p class="tx">There’s no dot notation or built-in methods in Batch, but the following <span class="sans_thesansmonocd_w5regular_">set</span> command assigns the same hardcoded pair to the hash table:</p>
<pre class="pre"><code class="calibre11">set jobs{Lincoln}=President</code></pre>
<p class="tx">More typically, the key and value are both variables. The following code creates the same entry:</p>
<pre class="pre"><code class="calibre11"><span aria-label=" Page 359. " epub:type="pagebreak" id="pg_359" role="doc-pagebreak"/>set person=Lincoln
set aJob=President
set jobs{%person%}=%aJob%
</code></pre>
<p class="tx">Extracting the value in many languages requires some variant of the <i class="calibre6">get</i> method. Again, this is from Java:</p>
<pre class="pre"><code class="calibre11">String job = jobs.get("Lincoln");</code></pre>
<p class="tx">The corresponding Batch code retrieves an element much like we did from a Batch array, only with curly brackets and a key instead of square brackets and an index. Both of these commands work equally as well:</p>
<pre class="pre"><code class="calibre11">&gt; con echo The Job is: !jobs{Lincoln}!
&gt; con echo The Job is: %jobs{Lincoln}%
</code></pre>
<p class="tx">But the key is more often a variable, which requires the now familiar delayed expansion:</p>
<pre class="pre"><code class="calibre11">&gt; con echo The Job is: !jobs{%person%}!</code></pre>
<p class="tni">If <span class="sans_thesansmonocd_w5regular_">person</span> is set to <span class="sans_thesansmonocd_w5regular_">Braille</span>, the output is <span class="sans_thesansmonocd_w5regular_">The Job is: Inventor</span>.</p>
<p class="tx">We now have a simple hash table to which we can add more keys (people) and values (occupations) as pairs. We can remove one specific entry if someone is laid off and reconsiders their occupation:</p>
<pre class="pre"><code class="calibre11">set jobs{Jack}=&amp;</code></pre>
<p class="tx">The following assigns a value to a key only if it doesn’t yet exist in the hash table:</p>
<pre class="pre"><code class="calibre11">if not defined jobs{Kai}  set jobs{Kai}=Chef</code></pre>
<p class="tx">This <span class="sans_thesansmonocd_w5regular_">for /F</span> command mimics three different methods available in many other languages that get the size of a hash table and extract lists of keys and values:</p>
<pre class="pre"><code class="calibre11">set hashSize=0
set listKeys=&amp;
set listValues=&amp;
for /F "usebackq tokens=2-3 delims={}=" %%x in (`set jobs{`) do (
   set /A hashSize += 1
   set listKeys=!listKeys! "%%x"
   set listValues=!listValues! "%%y"
)
</code></pre>
<p class="tx"><span aria-label=" Page 360. " epub:type="pagebreak" id="pg_360" role="doc-pagebreak"/>Both lists are space-delimited with each element in double quotes. With a little more work, we can use these results to determine whether the hash table is empty:</p>
<pre class="pre"><code class="calibre11">if not defined listKeys  &gt; con echo The jobs hash table is EMPTY.</code></pre>
<p class="tx">The following code tells us whether a particular key exists in the hash table:</p>
<pre class="pre"><code class="calibre11">echo %listKeys% | findstr "Poe" &amp;&amp; &gt; con echo Quoth the Raven, "Nevermore."</code></pre>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">echo</span> command writes the famous refrain to the console if <span class="sans_thesansmonocd_w5regular_">"Poe"</span> is contained in <span class="sans_thesansmonocd_w5regular_">listKeys</span>. <span class="sans_thesansmonocd_w5regular_">Poe</span> is encased in double quotes because that’s how we added each key to the hash table, and we can similarly search <span class="sans_thesansmonocd_w5regular_">listValues</span> for a specific value.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h4 class="h1" id="sec12"><span id="h2-105"/><span class="sans_futura_std_heavy_oblique_bi_">Complex Hash Tables</span></h4>
<p class="tni">A more complex hash table might also be keyed by a person’s name, but instead of a simple string as the value, it might have something more resembling an object from a more modern language. For example, it might contain a more complete set of information on that person such as occupation, state, hobbies, and more. (I’ll have much more to say on the topic of objects in <span class="xref"><a href="chapter32.xhtml" class="calibre3">Chapter 32</a></span>.)</p>
<p class="tx">Once you understand that hash tables and arrays in Batch are built by simply stringing together text, partial variable names, resolved variables, indices, and brackets, it’s not a huge leap to create a <span class="sans_thesansmonocd_w5regular_">people</span> hash table keyed by a person’s name attached to signifiers for <span class="sans_thesansmonocd_w5regular_">job</span> and <span class="sans_thesansmonocd_w5regular_">state</span>, and even an array of <span class="sans_thesansmonocd_w5regular_">hobbies</span>:</p>
<pre class="pre"><code class="calibre11">set people{Lincoln.job}=President
set people{Lincoln.state}=Illinois
set people{Lincoln.hobbies[0]}=Wrestling
set people{Lincoln.hobbies[1]}=Cats
set people{Lincoln.hobbies[2]}=Storytelling
</code></pre>
<p class="tni">Don’t confuse this with dot notation; <span class="sans_thesansmonocd_w5regular_">people{Lincoln.hobbies[1]}</span> is just a variable name, either a messy one or an elegant one, depending on your perspective.</p>
<p class="tx">After the prior commands execute, the following code extracts the second hobby from the array inside the hash table:</p>
<pre class="pre"><code class="calibre11">set info=hobbies[1]
set person=Lincoln
set hobby=!people{%person%.%info%}!
</code></pre>
<p class="tx">Delayed expansion resolves the two variables encased in percent signs first. Then the exclamation marks resolve the intermediate result to <span class="sans_thesansmonocd_w5regular_">Cats</span>. (The 16th US president shared the White House with Tabby and Dixie.)</p>
<p class="tx"><span aria-label=" Page 361. " epub:type="pagebreak" id="pg_361" role="doc-pagebreak"/>The same considerations that I mentioned earlier for arrays apply to hash tables. This technique isn’t meant for heavy duty processing, but in many instances, a quick and relatively simple solution in the form of a hash table might be hiding in plain sight.</p>
<p class="tx">In <span class="xref"><a href="chapter3.xhtml" class="calibre3">Chapter 3</a></span>, I introduced the idea of using delayed expansion to store and retrieve transmission paths in variables containing city abbreviations, such as <span class="sans_thesansmonocd_w5regular_">pathNYC</span>, <span class="sans_thesansmonocd_w5regular_">pathNash</span>, and <span class="sans_thesansmonocd_w5regular_">pathSTL</span>. This is really a thinly disguised hash table; consider these three elements: <span class="sans_thesansmonocd_w5regular_">path{NYC}</span>, <span class="sans_thesansmonocd_w5regular_">path{Nash}</span>, and <span class="sans_thesansmonocd_w5regular_">path{STL}</span>. Treat the city as a variable and use it to extract the corresponding transmission path with <span class="sans_thesansmonocd_w5regular_">!path{%city%}!</span>.</p>
</section>
</section>
<section aria-labelledby="sec13" epub:type="division">
<h3 class="h" id="sec13"><span id="h1-195"/><span class="sans_futura_std_bold_b_">Summary</span></h3>
<p class="tni">With a little ingenuity, we can make Batch do many things for which it wasn’t first designed, like repurposing an old tire and some rope as a swing. In this chapter, I illustrated how to load arrays from hardcoded data, user data, parameters, and data from a file. You learned the importance of delayed expansion in accessing elements of an array and the possibilities opened with multidimensional arrays. I then extended this technique to build and access hash tables, explaining the similarities and differences between them and arrays, with applications of both.</p>
<p class="tx">I hope these examples have demonstrated the flexibility that’s possible in Batch. In the next chapter, I’ll switch gears and cover a few disparate yet useful topics that are intrinsic to the language.</p>
</section>
</section>
</div></body></html>