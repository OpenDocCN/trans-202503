- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">14</samp> <samp class="SANS_Dogma_OT_Bold_B_11">INTRODUCTION
    TO ROOTKITS</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Rootkits* are malware variants that specialize in hiding their presence on
    a host by first obtaining low-level access to the victim system. The name *rootkit*
    originates from Unix, where the *root* user has the highest level of privileges
    the system allows. Rootkits use several evasion methods, such as intercepting
    and modifying communication between kernel and user space and directly tampering
    with data structures in kernel memory, to hide from endpoint defenses and investigation
    tools.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter provides an introductory overview of kernel-based rootkits and
    some of the techniques they use to evade defenses and manipulate a system. While
    not an exhaustive resource on rootkits or rootkit analysis, this chapter covers
    some of the tactics to be on the lookout for when you’re investigating low-level
    malware.
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Rootkit Fundamentals</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many reasons why a malware author might use rootkit components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Persistence and survivability**'
  prefs: []
  type: TYPE_NORMAL
- en: Since rootkits exist in kernel space and have low-level system access, they
    can persist after reboots and in strong, well-defended environments. Bootkits,
    an advanced form of rootkit we’ll discuss later in the chapter, reside at the
    firmware layer and therefore have even greater persistence.
  prefs: []
  type: TYPE_NORMAL
- en: '**Defense circumvention**'
  prefs: []
  type: TYPE_NORMAL
- en: Some rootkits actively tamper with and blind endpoint defenses such as EDR and
    anti-malware. Such rootkits can also hide and protect their files and processes
    from investigators by redirecting function calls, for example.
  prefs: []
  type: TYPE_NORMAL
- en: '**Low-level access to devices and drivers**'
  prefs: []
  type: TYPE_NORMAL
- en: Some rootkits intercept requests and commands to and from kernel drivers and
    hardware. One example is Moriya (see the May 2021 article “Operation TunnelSnake”
    at [*https://<wbr>securelist<wbr>.com<wbr>/operation<wbr>-tunnelsnake<wbr>-and<wbr>-moriya<wbr>-rootkit<wbr>/101831<wbr>/*](https://securelist.com/operation-tunnelsnake-and-moriya-rootkit/101831/)),
    which intercepts, manipulates, and hides network traffic to and from the infected
    host.
  prefs: []
  type: TYPE_NORMAL
- en: Because rootkits reside in kernel space and work by manipulating kernel elements,
    let’s take a closer look at what these components are before discussing how rootkits
    take advantage of them.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Kernel Modules and
    Drivers</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Kernel modules* are binary files containing code and data that extend the
    kernel’s functionalities. They can be loaded at system boot-up or on demand. *Kernel
    drivers* are a specific type of kernel module that interact with system hardware.
    There are different types of kernel drivers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Device drivers**'
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the most common type of kernel driver, device drivers provide an interface
    between Windows and the underlying hardware devices of the system, such as keyboards,
    mice, and printers. They interact with system hardware either directly or indirectly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filter drivers**'
  prefs: []
  type: TYPE_NORMAL
- en: As their name suggests, filter drivers “filter” IO communication destined for
    other drivers, intercepting and potentially modifying it. These drivers add functionality
    to other drivers or to the system at large, and they also enable capabilities
    such as logging and monitoring. Some malicious actors load filter drivers in the
    kernel to take advantage of these benefits, as you’ll see later.
  prefs: []
  type: TYPE_NORMAL
- en: '**Minifilter drivers**'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to filter drivers, minifilter drivers filter IO operations and were
    introduced in more modern versions of Windows to improve performance and simplify
    development and compatibility. These drivers can also be abused by malicious actors.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Even though all kernel drivers are modules, not all kernel modules are drivers.
    However, for simplicity’s sake, I’ll use the terms* module *and* driver *interchangeably
    in this chapter.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can view loaded kernel modules in Windows using a Process Manager–like tool
    such as Process Hacker, as shown in [Figure 14-1](chapter14.xhtml#fig14-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig14-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-1: Viewing loaded
    kernel modules in Process Hacker</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To view loaded kernel modules in Process Hacker, right-click the system process,
    select **Properties**, and then select the **Modules** tab. In [Figure 14-1](chapter14.xhtml#fig14-1),
    you can see some of the kernel drivers installed on my system, such as Advanced
    Configuration and Power Interface (ACPI) drivers and display drivers such as the
    VGA boot driver.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a basic understanding of kernel drivers, let’s dive into the
    structure of malicious kernel drivers, which are more commonly known as rootkits.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Rootkit Components</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Rootkits commonly have two components: a process running in user space and
    a kernel driver that receives instructions from that process. Rootkits nearly
    always start with a user-space executable that must be deployed and executed on
    the victim host. Once this is accomplished, the malicious process loads a driver
    into kernel space. [Figure 14-2](chapter14.xhtml#fig14-2) shows a simple, high-level
    view of how rootkits are installed.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig14-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-2: The rootkit installation
    process</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: First, the victim is delivered a dropper executable (*malware.exe*) that, once
    executed, decrypts an embedded malicious kernel driver (*rootkit.sys*). The dropper
    configures and executes this driver as a service, completing the rootkit’s installation
    into kernel space. (We’ll discuss this more in a moment.) The user-space process
    code contains the majority of the malware’s primary functionalities, while the
    kernel component works to mask and protect the user-space process on the system,
    establish low-level hooks to hide its artifacts in memory and on disk, and blind
    endpoint defenses and investigators to its presence.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-3](chapter14.xhtml#fig14-3) illustrates some of the newly installed
    rootkit’s functionalities.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig14-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-3: The basic functionalities
    of a rootkit</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This rootkit can conceal its user-space executable (*malware.exe*) as well as
    issue commands to its kernel driver (*rootkit.sys*) ❶. Rootkit user-space components
    often communicate to their kernel-space counterparts by sending requests via a
    WinAPI function such as <samp class="SANS_TheSansMonoCd_W5Regular_11">DeviceIOControl</samp>,
    which allows a user-space process to send a control code (instruction) to a kernel-space
    driver. In addition, this rootkit is able to hook and intercept API calls from
    user space ❷, intercept communication between other kernel components and device
    drivers ❸, and even tamper with kernel memory directly ❹. All of these techniques
    will become clearer as we progress through this chapter. But first, let’s take
    a step back and talk about how rootkits are installed in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Rootkit Installation</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the past, rootkits were more prevalent, but Microsoft has implemented protective
    measures in later versions of Windows that make it more difficult to implement
    the changes necessary to install malicious kernel components on a system. Even
    so, there are ways to bypass these protections, so these kinds of attacks do still
    happen sometimes. Let’s take a look at a recent real-world example: HermeticWiper.'
  prefs: []
  type: TYPE_NORMAL
- en: HermeticWiper targeted victims in Ukraine in 2022\. It’s not a rootkit per se;
    rather, it is destructive malware that requires low-level access to overwrite
    data on the disk, rendering a system unbootable. However, because HermeticWiper
    uses a common method of loading a kernel driver and is well documented, it’s a
    good example of how rootkits can also be installed in a victim environment.
  prefs: []
  type: TYPE_NORMAL
- en: One particular HermeticWiper sample was signed by a certificate stolen from
    a valid company, Hermetica Digital Ltd., potentially allowing HermeticWiper to
    bypass certain endpoint defenses. (This technique was discussed in [Chapter 13](chapter13.xhtml).)
    When HermeticWiper first executes, the sample writes a new *.sys* file with a
    file name consisting of four characters (such as *bpdr.sys*) to disk. This file
    is a legitimate driver from the company EaseUS that is normally used to resize
    and partition disks; however, it can be misused, as we’ll see in a moment. Since
    at the time of the attack, this file is signed by a valid certificate, it’s able
    to bypass Windows protections like driver-signing enforcement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, to obtain the special privileges required for loading drivers, HermeticWiper
    attempts to obtain <samp class="SANS_TheSansMonoCd_W5Regular_11">SeLoadDriverPrivilege</samp>.
    This privilege can be obtained only by a process already running at a high privilege
    level, so most malware will need to use a privilege elevation technique (such
    as a UAC bypass) to get administrator or system-level privileges and then call
    a function such as <samp class="SANS_TheSansMonoCd_W5Regular_11">AdjustTokenPrivileges</samp>
    (as discussed in [Chapter 13](chapter13.xhtml)). Once it has the required privileges,
    HermeticWiper creates a new service by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateServiceW</samp>
    and starts it by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">StartServiceW</samp>.
    Creating and executing a service is one of the most common methods of loading
    a new kernel driver, for both legitimate and malicious purposes. It can also be
    accomplished via the Windows command line, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This command creates a new service (<samp class="SANS_TheSansMonoCd_W5Regular_11">evil</samp>),
    specifying an input parameter of <samp class="SANS_TheSansMonoCd_W5Regular_11">C:\Users\Public\evil.sys</samp>
    (the path of the malicious driver to be loaded) and a type of <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel</samp>,
    denoting this service as a kernel driver installation. The following command can
    then be used to start the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output of executing these commands in Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of HermeticWiper, since the driver (at the time of attack, at least)
    is legitimate and signed by a valid authority, it likely won’t have any issues
    installing in kernel space and can circumvent built-in Windows controls. If the
    driver wasn’t signed by a valid signing authority, we’d receive the following
    error upon starting the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Once the malicious service is successfully installed, the Windows Service Controller
    takes over and loads the driver into kernel address space. The malware’s user-space
    component can now interact with the malicious driver in kernel space by invoking
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DeviceIOControl</samp> and issuing
    commands to it. In doing so, HermeticWiper is using an otherwise legitimate driver
    (the EaseUS driver) to write data to the disk, destroying this data and making
    infected systems inoperable.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Kernel drivers aren’t always loaded using services. There are other techniques
    for loading them, including invoking the NT API function <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">NtLoadDriver</samp>.*'
  prefs: []
  type: TYPE_NORMAL
- en: This abuse of legitimate drivers is a form of the Bring Your Own Vulnerable
    Driver technique, which we’ll discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">BYOVD Attacks</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Bring Your Own Vulnerable Driver* (*BYOVD*, or simply *BYOD*) attacks take
    advantage of legitimate, signed drivers as a sort of proxy to interact with the
    kernel; disable security controls; or load a separate, unsigned, malicious kernel
    driver. A malware author searches for a legitimate driver that is already signed
    by a valid signing authority (and therefore vetted by the Windows operating system)
    that can be dropped to the victim system during the attack. This driver must also
    have some sort of vulnerability that allows the threat actor to perform low-level
    malicious actions on the victim system. To exploit these vulnerabilities, rootkits
    often send commands to the vulnerable driver (by invoking <samp class="SANS_TheSansMonoCd_W5Regular_11">DeviceIOControl</samp>,
    for example) from their user-space process.'
  prefs: []
  type: TYPE_NORMAL
- en: One notable example of this type of attack is the FudModule rootkit, purportedly
    used by North Korean cybercriminals known as the Lazarus Group. As reported by
    researchers at ESET, FudModule takes advantage of a vulnerable, signed Dell driver
    containing a vulnerability (CVE-2021-21551) that allowed Lazarus to write data
    into kernel memory. More specifically, the vulnerability was triggered by a specially
    crafted instruction to the driver via <samp class="SANS_TheSansMonoCd_W5Regular_11">DeviceIOControl</samp>.
    Ultimately, the threat actors successfully disabled multiple defensive mechanisms
    in Windows, effectively blinding endpoint defenses to later stages of the attack.
    For more information, see Peter Kálnai’s article “Amazon-Themed Campaigns of Lazarus
    in the Netherlands and Belgium” at [*https://<wbr>www<wbr>.welivesecurity<wbr>.com<wbr>/2022<wbr>/09<wbr>/30<wbr>/amazon<wbr>-themed<wbr>-campaigns<wbr>-lazarus<wbr>-netherlands<wbr>-belgium<wbr>/*](https://www.welivesecurity.com/2022/09/30/amazon-themed-campaigns-lazarus-netherlands-belgium/).
  prefs: []
  type: TYPE_NORMAL
- en: Another example of malware that uses the BYOVD technique is the BlackByte ransomware
    family. As Sophos reported, BlackByte abuses a vulnerable driver in the legitimate
    product MSI AfterBurner, a tool for tuning graphics cards. The driver vulnerability
    (CVE-2019-16098) allowed the BlackByte operators to interact with the kernel and
    disable EDR products on the host by terminating EDR-related processes. To learn
    more about this malware, check out Andreas Klopsch’s article “Remove All the Callbacks—BlackByte
    Ransomware Disables EDR Via RTCore64.sys Abuse” at [*https://<wbr>news<wbr>.sophos<wbr>.com<wbr>/en<wbr>-us<wbr>/2022<wbr>/10<wbr>/04<wbr>/blackbyte<wbr>-ransomware<wbr>-returns<wbr>/*](https://news.sophos.com/en-us/2022/10/04/blackbyte-ransomware-returns/).
  prefs: []
  type: TYPE_NORMAL
- en: A third example is the malware family ZeroCleare, found by researchers at IBM
    X-Force IRIS to be abusing a vulnerable VirtualBox driver (*vboxdrv.sys*), which
    allowed the attacker to execute shellcode in kernel memory and install a malicious
    kernel driver. You can read more about this attack in the IBM report “New Destructive
    Wiper ZeroCleare Targets Energy Sector in the Middle East” at [*https://<wbr>securityintelligence<wbr>.com<wbr>/posts<wbr>/new<wbr>-destructive<wbr>-wiper<wbr>-zerocleare<wbr>-targets<wbr>-energy<wbr>-sector<wbr>-in<wbr>-the<wbr>-middle<wbr>-east<wbr>/*](https://securityintelligence.com/posts/new-destructive-wiper-zerocleare-targets-energy-sector-in-the-middle-east/).
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, there are other recent examples of malware abusing vulnerable
    drivers to disable and blind endpoint defenses, load additional malicious kernel
    drivers, or otherwise execute malicious code in privileged areas of the operating
    system. Furthermore, since these drivers are legitimate and signed, there’s currently
    not much that can be done to completely prevent this type of attack. There’s a
    dedicated project for tracking these vulnerable drivers; it’s called Living Off
    The Land Drivers (LOLDrivers, for short). It’s worth exploring if you’re interested
    in learning more about BYOVD attacks, so visit the project website at [*https://<wbr>www<wbr>.loldrivers<wbr>.io*](https://www.loldrivers.io).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Not all BYOVD usage is rootkit related. For example, some malware simply leverages
    a vulnerable driver to execute kernel functions or perform low-level actions that
    would otherwise be prohibited.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you’ve gotten an overview of how threat actors can bypass Windows
    protections to install rootkits, let’s start looking into how rootkits behave
    on a victim host and manipulate the system to stay hidden. We’ll start with an
    old technique: DKOM.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Direct Kernel Object Manipulation</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Direct kernel object manipulation* (*DKOM)* involves directly modifying data
    in kernel memory. This is a delicate task because, when done incorrectly, it can
    crash the operating system. Done correctly, however, it can give the malware immense
    power. One example of DKOM is hiding processes.'
  prefs: []
  type: TYPE_NORMAL
- en: Using DKOM, a rootkit can hide its user-space processes and kernel modules from
    endpoint defenses and forensics analysts by modifying its processes’ EPROCESS
    data structures in kernel memory. You might remember from [Chapter 1](chapter1.xhtml)
    that EPROCESS structures form a doubly linked list of processes running on the
    host. Some defense and analysis tools rely on these structures to monitor and
    inspect anomalous running processes.
  prefs: []
  type: TYPE_NORMAL
- en: To perform this type of DKOM technique, a malicious kernel-space module invokes
    a function such as <samp class="SANS_TheSansMonoCd_W5Regular_11">PsLookupProcessByProcessID</samp>
    to get a pointer to its own user-space component’s EPROCESS structure. Then, the
    malware can modify the *forward link (flink)* and *backward link (blink)* members
    of the EPROCESS structure, unlinking the structure from the EPROCESS chain. [Figure
    14-4](chapter14.xhtml#fig14-4) illustrates normal, unmodified EPROCESS structures
    before unlinking.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig14-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-4: Doubly linked
    EPROCESS structures before unlinking</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Notice how the EPROCESS structures are linked by their flink and blink members.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-5](chapter14.xhtml#fig14-5) shows what happens when a rootkit tampers
    with the EPROCESS structures to unlink its malicious process (center).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig14-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-5: EPROCESS structures
    after unlinking</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Notice how both the flink and blink for the malicious process’s EPROCESS structure
    point back to it, effectively disconnecting this process from the normal EPROCESS
    chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an abridged version of the HideProcess project (see [*https://<wbr>github<wbr>.com<wbr>/landhb<wbr>/HideProcess*](https://github.com/landhb/HideProcess)),
    and it demonstrates how the malware accomplishes the tasks outlined previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: First, the code defines the variables <samp class="SANS_TheSansMonoCd_W5Regular_11">Previous</samp>
    (which stores the current process’s blink pointer) ❶ and <samp class="SANS_TheSansMonoCd_W5Regular_11">Next</samp>
    (which stores the current process’s flink pointer) ❷. Later, the code rewrites
    these <samp class="SANS_TheSansMonoCd_W5Regular_11">LIST_ENTRY</samp> values to
    point to itself. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Current->Blink</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(PLIST_ENTRY)&Current->Flink</samp>
    line sets the process’s current blink pointer to its flink pointer value ❸. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Current->Flink</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(PLIST _ENTRY)&Current->Flink</samp>
    line ensures that the process’s flink points to itself ❹. In essence, this breaks
    the EPROCESS chain, hiding the process from process management tools (like Task
    Manager) and some forensics investigation toolsets, perhaps helping it better
    evade endpoint defenses.
  prefs: []
  type: TYPE_NORMAL
- en: DKOM isn’t limited to hiding processes, however. Using DKOM techniques, malware
    can theoretically alter any object in kernel memory. Malware has been known to
    use DKOM techniques to hide malicious network traffic or alter files in order
    to interfere with forensics investigations. DKOM can also be used to inject kernel
    hooks, as you’ll see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: While DKOM is one of the most basic and straightforward methods rootkits can
    use to hide or to alter the system, it’s not a golden ticket. DKOM and other kernel
    manipulation techniques can easily crash the operating system, potentially alerting
    the victim to the malware’s presence. Not only that, but security measures like
    PatchGuard also can create challenges for malware authors, as we’ll discuss later
    in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">“Legacy” Kernel Hooking</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just like malware running in user space can use inline and IAT hooking to monitor,
    intercept, and manipulate function calls, kernel-space malware can use several
    types of hooks to launch its attacks. We’ll discuss some of the most prevalent,
    starting with the decades-old technique of SSDT hooking.
  prefs: []
  type: TYPE_NORMAL
- en: '> <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '*The techniques discussed in this section were at one time some of the most
    common ones used by both rootkits and endpoint defense products alike. Much like
    DKOM, however, they’re no longer popular thanks to the protections that Microsoft
    has implemented in modern versions of Windows. Still, it’s important to gain a
    basic understanding of them since you may occasionally witness malware using these
    or similar tactics, and it’ll also give you a better grasp of more modern rootkit
    techniques.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">SSDT Hooks</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The *System Service Descriptor Table (SSDT)* or *Dispatch Table* contains an
    array of syscall IDs and their corresponding pointers to kernel functions. (These
    differ between 32- and 64-bit operating systems, but we won’t go into those specifics
    here.) As discussed in [Chapters 1](chapter1.xhtml) and [13](chapter13.xhtml),
    when a user-space process invokes Windows API and NT API functions, the function
    eventually makes a syscall into the kernel to fulfill the request. Let’s look
    at an example using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>
    to read a file on disk. Here’s the basic sequence of steps that must occur:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  A program in user space invokes <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>.
    The program initiates a syscall, referencing the syscall ID that corresponds to
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp> function.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  The syscall triggers the processor to switch from user mode to kernel mode
    and passes the request and syscall ID to the syscall handler.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  The syscall handler consults the SSDT to obtain the address of the kernel
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp> function (which
    is exported from *ntoskrnl.exe*) and then proceeds to execute the function.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Since the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>
    function is being invoked to read a file on disk, it must communicate with kernel
    drivers such as the disk driver stack. This is where the IO manager is engaged.
  prefs: []
  type: TYPE_NORMAL
- en: 5.  The IO manager sends instructions in the form of *IO request packets (IRPs)*
    to the appropriate drivers, which will carry out <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>’s
    requested actions (such as reading the specific file on disk). I’ll discuss the
    IO manager and IRPs later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 6.  Once the drivers process the request, the result is sent back to the original
    calling program in user space.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a basic understanding of how the SSDT is used, you can see
    how malware could insert a hook into it to redirect requests to malicious code.
    [Figure 14-6](chapter14.xhtml#fig14-6) shows an example of this approach with
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp> function.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig14-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-6: An SSDT hook for
    NtReadFile</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The rootkit modifies the function pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>
    inside the SSDT, which redirects the request for <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>
    to the rootkit’s malicious kernel module. The rootkit then intercepts and modifies
    the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>. Later,
    it can redirect the call to the original <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>
    function code inside *ntoskrnl.exe*.
  prefs: []
  type: TYPE_NORMAL
- en: There are many reasons why a malware author would use SSDT hooking. For example,
    they might implement an SSDT hook for <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>
    to prevent the malware’s own malicious files and code from being read by endpoint
    defenses and investigators. Another kernel-hooking technique, inline kernel hooks,
    is used for a similar reason.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Inline Kernel Hooks</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Inline hooking is a malware technique employed not just in user space (as discussed
    in [Chapter 12](chapter12.xhtml)) but in kernel functions as well. To install
    the hooks, a rootkit attempts to modify function code inside *ntoskrnl.exe*. Similar
    to the example just discussed with SSDT hooking, a rootkit could hook <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>
    by tampering with the function’s code to insert a jump instruction and redirect
    control flow to the malicious kernel module’s code, as illustrated in [Figure
    14-7](chapter14.xhtml#fig14-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig14-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-7: An inline kernel
    hook for NtReadFile</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of ways a rootkit can write a hook into a target function.
    Similar to inline hooking in user space, the malware first must alter the memory
    protections of the target function’s code and then write a hook into it. The following
    pseudocode demonstrates how this might look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">MmProtectMdlSystemAddress</samp>
    is a kernel function that’s used to set the memory protection type for a *memory
    descriptor list (MDL)*, which is a structure containing a memory address range.
    This function has two parameters: a <samp class="SANS_TheSansMonoCd_W5Regular_11">MemoryDescriptorList</samp>
    (the memory address range that will be altered) and a protection constant (such
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">PAGE_READWRITE</samp>, which
    would change the MDL’s protections to be writable).'
  prefs: []
  type: TYPE_NORMAL
- en: Following this, the malware invokes a kernel function such as <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlCopyMemory</samp>
    to overwrite the target code with a jump instruction, for instance. The primary
    parameters of <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlCopyMemory</samp>
    are the destination address of the target memory region, the source address (which
    contains the jump instruction to be copied), and the size of the data being copied.
    Malware must be careful to set the target memory region back to its original protection
    setting because incorrect and anomalous protections (such as “writable”) may raise
    the suspicions of endpoint defenses or cause system instability.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll turn to IRP hooking, another type of kernel hook rootkits have been
    known to use.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">IRP Hooks</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When user-space programs need to communicate with kernel drivers, they do so
    via the IO manager. This communication is primarily accomplished with IO request
    packets (IRPs), which are objects comprising data structures that contain information
    about the request and actions to be performed. IRPs are passed between the calling
    program and kernel drivers, but they can also be used for communication between
    drivers. For example, a USB keyboard driver will need to communicate with the
    USB host controller driver, and the IO manager helps facilitate this. This relationship
    is illustrated in [Figure 14-8](chapter14.xhtml#fig14-8).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig14-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-8: How an IRP works</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This program invokes the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateFile</samp>
    function to open a handle to a file on disk. Eventually, the program makes a syscall
    into the kernel (*ntoskrnl.exe*). This is where the IO manager gets involved,
    sending an IRP to the filesystem driver that will handle this operation. In the
    final step (not pictured here), the driver sends the status of the operation back
    to the IO manager, which will return the status to the calling program.
  prefs: []
  type: TYPE_NORMAL
- en: Every IRP includes an *IRP code*, which tells the recipient driver what IRP
    handler should be used to handle the respective request. [Table 14-1](chapter14.xhtml#tab14-1)
    lists some of the more interesting IRP function codes for our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 14-1:</samp> <samp class="SANS_Futura_Std_Book_11">IRP
    Codes</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">IRP code</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Request
    description</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE</samp> | <samp
    class="SANS_Futura_Std_Book_11">Sent to a driver when the requesting thread opens
    a handle to a device or file object, such as when making a call to</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_WRITE</samp> | <samp
    class="SANS_Futura_Std_Book_11">Sent to a driver when the requester wishes to
    transfer data, such as when writing data to a file</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_READ</samp> | <samp
    class="SANS_Futura_Std_Book_11">Sent to a driver when the requester wishes to
    read data, such as from a file</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_DEVICE_CONTROL</samp>
    | <samp class="SANS_Futura_Std_Book_11">Sent when a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">DeviceIoControl</samp>
    <samp class="SANS_Futura_Std_Book_11">function is called (meaning a user-space
    process is sending a direct control code, or instruction, to a driver)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_SHUTDOWN</samp> | <samp
    class="SANS_Futura_Std_Book_11">Sent when a system shutdown has been initiated</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_SYSTEM_CONTROL</samp>
    | <samp class="SANS_Futura_Std_Book_11">Sent when a user-space process requests
    system information via Windows Management Instrumentation (WMI)</samp> |'
  prefs: []
  type: TYPE_TB
- en: 'Each driver installed in the kernel includes a table of IRP handlers called
    the *major function table* (or the *IRP function table*). Major function tables
    contain pointers to the handler code that will handle a particular IRP; this code
    might be located in the driver itself or inside another driver or module. The
    following output shows an IRP function table for the FLTMGR driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This output was created with the help of Volatility, a memory forensics and
    analysis tool. Although not covered in this book, memory forensics techniques
    can be great additions to the malware analysis process, especially in the case
    of rootkits. For this specific example, I used the <samp class="SANS_TheSansMonoCd_W5Regular_11">driverirp</samp>
    module in Volatility.
  prefs: []
  type: TYPE_NORMAL
- en: The first column in this output contains the IRP code. The second and third
    columns contain the pointer to the associated IRP handler function and the module
    containing the handler code, respectively. In this case, the driver points to
    handlers it contains.
  prefs: []
  type: TYPE_NORMAL
- en: 'To intercept, modify, and gain control of IO communication, malicious kernel
    drivers might attempt to hook IRPs. One reason for doing so is to hide and protect
    the malware’s artifacts on the endpoint by intercepting IRP function calls that
    reference those artifacts on disk. The Autochk rootkit (<samp class="SANS_TheSansMonoCd_W5Regular_11">SHA256:
    28924b6329f5410a5cca30f3530a3fb8a97c23c9509a192f2092cbdf139a91d8</samp>) does
    exactly this: it hooks <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE</samp>
    inside the FLTMGR driver to intercept IRPs referencing its malicious files on
    disk (as illustrated in [Figure 14-9](chapter14.xhtml#fig14-9)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig14-9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-9: An IRP hook for
    NtReadFile</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'If an application in user space, such as a forensics tool, attempts to access
    this rootkit’s files, the IRP will be handled by the rootkit’s handler code rather
    than by the legitimate handler that would otherwise deal with this request. The
    following Volatility output shows the hooked FLTMGR driver’s IRP function table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Notice anything shady? In the first row of the code, <samp class="SANS_TheSansMonoCd_W5Regular_11">FLTMGR.SYS</samp>
    has been replaced with <samp class="SANS_TheSansMonoCd_W5Regular_11">autochk.sys</samp>.
    All <samp class="SANS_TheSansMonoCd_W5Regular_11">MJ_CREATE</samp> IRPs destined
    for the FLTMGR driver will instead be forwarded to the malicious handler code
    inside the rootkit’s driver, <samp class="SANS_TheSansMonoCd_W5Regular_11">autochk.sys!</samp>
    You can read more about some of the techniques of this rootkit at [*https://<wbr>repnz<wbr>.github<wbr>.io<wbr>/posts<wbr>/autochk<wbr>-rootkit<wbr>-analysis<wbr>/*](https://repnz.github.io/posts/autochk-rootkit-analysis/).
  prefs: []
  type: TYPE_NORMAL
- en: To install an IRP hook, malware authors have a few options. One approach is
    to replace the original handler code pointer value in a victim driver with a pointer
    to malicious handler code. Alternatively, malware could use the inline hooking
    method described previously to overwrite the first few bytes in the legitimate
    handler function with a jump instruction to malicious code.
  prefs: []
  type: TYPE_NORMAL
- en: Both of these techniques, as well as the other hooking techniques mentioned,
    rely on the delicate task of manipulating kernel objects in memory. As noted earlier,
    however, the techniques discussed in this section aren’t often used in malware
    anymore due to the protections now built into Windows. With this in mind, let’s
    shift to some relatively modern techniques that rootkits might use to circumvent
    these Windows protections, starting with IRP filtering and interception.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">IRP Interception by Filtering</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rather than crudely hooking kernel drivers to intercept and manipulate IRPs,
    rootkits can register a filter or minifilter driver to do so. Introduced at the
    beginning of this chapter, filter drivers and minifilter drivers can be “attached”
    to a device and added to its driver stack, intercepting IRPs as they are filtered
    down the stack. Let’s go over this process in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Filter drivers (sometimes called* legacy filter drivers*) and minifilter drivers
    are both types of filters, but they operate quite differently. I won’t go into
    the specifics of these two drivers in this book.*'
  prefs: []
  type: TYPE_NORMAL
- en: Each hardware device attached to the system has an associated hierarchical stack
    of drivers that enables communication between the device and the operating system
    (see [Figure 14-10](chapter14.xhtml#fig14-10)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig14-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-10: How the IO manager
    communicates with driver stacks</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Each driver in the stack performs a specific role and serves as an interface
    between the drivers before and after it in the stack. Additionally, when the IO
    manager sends an IRP to a specific device, the IRP is routed through the device’s
    hierarchical driver stack, passing through each driver in the stack one by one.
    If one of the drivers has a handler for the specific IRP, it takes some sort of
    action on that IRP. The arrows shown in [Figure 14-10](chapter14.xhtml#fig14-10)
    represent communication between drivers in the form of IRPs.
  prefs: []
  type: TYPE_NORMAL
- en: Filter drivers are designed to be inserted into a driver stack to add functionality.
    They can be inserted in various locations (called *altitudes*) in the stack or
    even added all the way to the top of the stack, where they can intercept any and
    all IRPs destined for the driver stack (see [Figure 14-11](chapter14.xhtml#fig14-11)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig14-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-11: A filter driver
    added to the top of the driver stack</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rootkits can register a new filter driver and “insert” it at the top of a driver
    stack, allowing them to see and intercept all inbound IRPs. After intercepting,
    the malware can choose to drop the IRP or modify it. A rootkit might use a filter
    driver this way to protect its own files. For example, it could register a filter
    driver to watch for and intercept IO requests to its own files, either modifying
    the requests or dropping them completely to effectively hide them from investigators
    and analysis tools. EDR and other endpoint defenses sometimes use filter drivers
    for the same reason: to protect their files from malware.'
  prefs: []
  type: TYPE_NORMAL
- en: To implement a filter driver, a rootkit must first load the driver into kernel
    memory (potentially using the techniques from “Rootkit Installation” on [page
    269](chapter14.xhtml#pg_269)). The filter driver must specify which IRP communication
    it cares about by setting up a handler for those IRPs. For instance, if the malware
    is trying to intercept <samp class="SANS_TheSansMonoCd_W5Regular_11">MJ_CREATE</samp>
    IRPs, it must implement this in the filter driver’s IRP function table.
  prefs: []
  type: TYPE_NORMAL
- en: Malware can abuse minifilter drivers by registering one of its own (by calling
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FltRegisterFilter</samp>) or by
    hooking an existing minifilter. Some modern malware has been known to do this.
    When analyzing rootkit driver code, take note of whether the malware is calling
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FltRegisterFilter</samp> to register
    its own minifilter driver. Also notice whether the malware is calling functions
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">FltGetFilterFromName</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FltEnumerateFilters</samp>, or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">FltEnumerateInstances</samp>; it may be
    attempting to enumerate other minifilters on the host, preparing for hooking.
    For more information on how minifilter drivers are implemented in practice, see
    Rahul Dev Tripathi’s article “Storage Device Restriction Using a Minifilter Driver
    Approach” at [*https://<wbr>www<wbr>.codeproject<wbr>.com<wbr>/Articles<wbr>/5341729<wbr>/Storage<wbr>-Device<wbr>-Restriction<wbr>-Using<wbr>-a<wbr>-Minifilter<wbr>-Driv<wbr>*](https://www.codeproject.com/Articles/5341729/Storage-Device-Restriction-Using-a-Minifilter-Driv).
  prefs: []
  type: TYPE_NORMAL
- en: Legacy filter drivers are installed differently. The specifics are outside the
    scope of this book, but you can learn more from the filesystem driver tutorial
    at [*https://<wbr>www<wbr>.codeproject<wbr>.com<wbr>/Articles<wbr>/43586<wbr>/File<wbr>-System<wbr>-Filter<wbr>-Driver<wbr>-Tutorial*](https://www.codeproject.com/Articles/43586/File-System-Filter-Driver-Tutorial)
    and from Rotem Salinas’s great write-up “Fantastic Rootkits and Where to Find
    Them” at [*https://<wbr>www<wbr>.cyberark<wbr>.com<wbr>/resources<wbr>/threat<wbr>-research<wbr>-blog<wbr>/fantastic<wbr>-rootkits<wbr>-and<wbr>-where<wbr>-to<wbr>-find<wbr>-them<wbr>-part<wbr>-1*](https://www.cyberark.com/resources/threat-research-blog/fantastic-rootkits-and-where-to-find-them-part-1).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Abusing Kernel Callbacks</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Abusing kernel callbacks is another more modern approach used by some rootkits.
    To recap the discussion in [Chapter 13](chapter13.xhtml), a callback allows a
    kernel module to be notified of system events so that it can take some sort of
    action when they happen. For example, a driver may need to know when a process
    executed in user space, so it would implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">PsSetCreateProcessNotifyRoutine</samp>
    callback (as in the case of some EDR products). Once this callback is registered
    with the driver, the driver will receive a notification in the form of an IRP
    when a process is created on the system, giving the driver the chance to execute
    its callback code for that event.
  prefs: []
  type: TYPE_NORMAL
- en: The creator of the process is responsible for sending out a notification to
    all registered drivers. So, when a process spawns a child process, for example,
    the calling process sends out the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessNotifyRoutine</samp>
    notification to all registered drivers. When a driver receives the notification,
    the driver’s callback code will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'A rootkit can also use callbacks if it wants to be notified of specific system
    events. Once an event occurs, such as a registry modification or filesystem operation,
    the rootkit’s malicious driver(s) will be notified, and the callback code will
    be executed. The following output shows a listing of registered callback routines
    on an infected system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this output, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp>
    column shows the callback type, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Callback</samp>
    column shows the address of the callback handler, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Module</samp>
    column shows the kernel module that registered the callback. Most of these are
    normal, legitimate callbacks. However, there’s a suspicious module name (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">comp.sys</samp>) that appears to have
    registered an interesting callback (<samp class="SANS_TheSansMonoCd_W5Regular_11">PsSetCreateThreadNotifyRoutine</samp>).
    As mentioned previously, this callback will trigger when a new thread is created
    by a process in user space. Also note that the address of the callback code is
    much different from those of the legitimate callbacks (<samp class="SANS_TheSansMonoCd_W5Regular_11">0xfffff6050d26ccc0</samp>
    versus <samp class="SANS_TheSansMonoCd_W5Regular_11">0xfffff80af3afb210</samp>,
    for example).
  prefs: []
  type: TYPE_NORMAL
- en: 'A similar approach was taken by the DirtyMoe rootkit. DirtyMoe used kernel
    callbacks to silently inject malicious code into newly created threads in user
    space. You can read more about it in Martin Chlumecký’s article “DirtyMoe: Rootkit
    Driver” at [*https://<wbr>decoded<wbr>.avast<wbr>.io<wbr>/martinchlumecky<wbr>/dirtymoe<wbr>-rootkit<wbr>-driver<wbr>/*](https://decoded.avast.io/martinchlumecky/dirtymoe-rootkit-driver/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The infamous Necurs rootkit, which originated in 2014, sets up a registry callback
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">CmRegisterCallback</samp>), a type
    of filter driver callback that will notify it of any access to its registry service
    key. If an investigator or program attempts to access this registry key, the attempt
    fails. This simplified pseudocode example shows how a malicious driver could register
    and abuse a registry callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This malware code first defines the callback function code (<samp class="SANS_TheSansMonoCd_W5Regular_11">RegistryCallback</samp>)
    that will be executed once the callback occurs ❶. Later in the code, the rootkit
    defines the registry callback, passing the callback name (<samp class="SANS_TheSansMonoCd_W5Regular_11">RegistryCallback</samp>)
    and also the context, which is a pointer to a structure containing information
    about the function call ❺. Since this callback will be triggered by programs interacting
    with the Windows registry, this context structure contains important information
    like the particular registry action (open key, write data, and so on) and the
    target of the action (or the specific registry key or value affected).
  prefs: []
  type: TYPE_NORMAL
- en: When a program performs a registry action, such as invoking <samp class="SANS_TheSansMonoCd_W5Regular_11">RegOpenKeyExA</samp>,
    the rootkit’s malicious callback code will be executed. The rootkit checks to
    see if the registry event is equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">CM_EVENT_REGISTRY_KEY_OPEN</samp>
    (indicating that a registry key is being opened) ❷ and then checks to see whether
    the registry key being acted upon is <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\evil</samp>
    (the key used by the malware to establish persistence on the host) ❸. If the key
    name matches, the rootkit attempts to prevent the program or investigator from
    inspecting that registry key ❹. It can do so by temporarily deleting its own registry
    key and re-creating it later, or by injecting malicious code into the calling
    process and hooking into the function call to prevent the call from succeeding,
    among other methods.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">CmRegisterCallback</samp>
    is now obsolete; the modern version of this function is <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">CmRegisterCallbackEx</samp>.
    The principles of the function remain the same, however.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ve seen quite a bit about how rootkits operate at a very low level in the
    operating system to manipulate kernel memory, install hooks, and configure callbacks,
    allowing them to remain hidden and evade defenses. Now we’ll look briefly at a
    variant of malware that delves even deeper: bootkits.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Bootkits</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *bootkit* is a piece of malware designed to hide inside the system firmware,
    compromising the entire boot process. If a bootkit is able to tamper with the
    operating system boot-up, injecting itself into this process chain, it can effectively
    achieve all the benefits of a rootkit while also surviving system rebuilds.
  prefs: []
  type: TYPE_NORMAL
- en: One specific type of bootkit is a UEFI bootkit (sometimes called a UEFI rootkit),
    which operates within the *Unified Extensible Firmware Interface (UEFI)*, a specialized
    storage chip attached to a system’s motherboard. The UEFI contains low-level software
    that executes before the operating system boots up, providing an interface between
    the operating system kernel and the various firmware devices installed in the
    system. Given that the UEFI boots before the operating system, malware that can
    embed itself within the UEFI chip will remain undetected for longer periods of
    time and can even survive operating system reinstallations and rebuilds.
  prefs: []
  type: TYPE_NORMAL
- en: 'One notable example of a UEFI bootkit is CosmicStrand. In July 2022, researchers
    from Kaspersky reported that this UEFI bootkit dug itself into systems, with the
    entry vector possibly being a hardware vulnerability. The bootkit affected various
    systems with certain models of Asus and Gigabyte motherboards and took control
    of the Windows operating system kernel loader, injecting malicious code into kernel
    memory. For more about this threat, see the article “CosmicStrand: The Discovery
    of a Sophisticated UEFI Firmware Rootkit,” from Kaspersky’s Global Research &
    Analysis Team (GreAT) at [*https://<wbr>securelist<wbr>.com<wbr>/cosmicstrand<wbr>-uefi<wbr>-firmware<wbr>-rootkit<wbr>/106973<wbr>/*](https://securelist.com/cosmicstrand-uefi-firmware-rootkit/106973/).'
  prefs: []
  type: TYPE_NORMAL
- en: Another example is the MosaicRegressor framework, which was also discovered
    by Kaspersky. It included a UEFI rootkit component that hijacked the Windows boot
    process to drop an executable to disk that silently executes when Windows boots
    up. If this executable is removed from the disk, it will be rewritten to disk
    upon reboot of the system, providing a high degree of persistence. You can read
    the article from Kaspersky about MosaicRegressor, “Lurking in the Shadows of UEFI,”
    by Mark Lechtik, Igor Kuznetsov, and Yury Parshin, at [*https://<wbr>securelist<wbr>.com<wbr>/mosaicregressor<wbr>/98849<wbr>/*](https://securelist.com/mosaicregressor/98849/).
  prefs: []
  type: TYPE_NORMAL
- en: Compared with traditional user-space malware, bootkits are relatively rare.
    However, they might not be as rare as they’re perceived to be. Because of their
    low-level access to the host, they can survive and persist undetected even in
    well-defended environments. If we can’t detect this type of malware, we don’t
    know it exists, which leads us to the unsettling conclusion that this type of
    malware could be embedded in more systems than we know. However, all is not lost.
    Let’s wrap up this chapter by discussing some of the built-in Windows defenses
    against rootkits and bootkits.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Defenses Against Rootkits</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Microsoft has implemented several defenses against rootkits, two of the most
    important being *PatchGuard* and *Driver Signature Enforcement (DSE)*. Introduced
    in 2005 for x64 versions of Windows XP, PatchGuard, which is also known as *Kernel
    Patch Protection (KPP)*, mitigates many of the rootkit techniques described earlier,
    such as SSDT and IDT hooking and many forms of DKOM. PatchGuard works by periodically
    verifying the integrity of kernel memory structures to test whether they’ve been
    modified. If PatchGuard detects that one of these structures has been modified,
    it forces a crash of the kernel, which has the result shown in [Figure 14-12](chapter14.xhtml#fig14-12).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig14-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-12: A kernel security
    check crash caused by PatchGuard</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: PatchGuard isn’t impervious to circumvention, however. Since it scans kernel
    memory periodically, if these checks are timed properly, malware could very quickly
    tamper with kernel memory and then revert to a “clean” state before PatchGuard
    executes its integrity check. To initiate this check, the operating system calls
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">KeBugCheckEx</samp> kernel API
    function, which certain malware has been known to hook to prevent the kernel integrity
    check from successfully executing. There have also been several issues with malware
    exploiting PatchGuard and other related components. One example of such malware
    is GhostHook, which exploited a vulnerability in the way Windows implements a
    certain low-level Intel API called Intel Processor Trace, potentially allowing
    malware to fly under PatchGuard’s radar. This attack technique is quite complex,
    so we won’t go into the details here, but you can read more about it in Kasif
    Dekel’s post, “GhostHook—Bypassing PatchGuard with Processor Trace Based Hooking,”
    at [*https://<wbr>www<wbr>.cyberark<wbr>.com<wbr>/resources<wbr>/threat<wbr>-research<wbr>-blog<wbr>/ghosthook<wbr>-bypassing<wbr>-patchguard<wbr>-with<wbr>-processor<wbr>-trace<wbr>-based<wbr>-hooking*](https://www.cyberark.com/resources/threat-research-blog/ghosthook-bypassing-patchguard-with-processor-trace-based-hooking).
  prefs: []
  type: TYPE_NORMAL
- en: Two other relatively recent examples of malware that evade PatchGuard are InfinityHook
    ([*https://<wbr>github<wbr>.com<wbr>/everdox<wbr>/InfinityHook*](https://github.com/everdox/InfinityHook)),
    which abuses a kernel API called <samp class="SANS_TheSansMonoCd_W5Regular_11">NtTraceEvent</samp>,
    and ByePg ([*https://<wbr>github<wbr>.com<wbr>/can1357<wbr>/ByePg*](https://github.com/can1357/ByePg)),
    which hijacks a kernel structure called the <samp class="SANS_TheSansMonoCd_W5Regular_11">HalPrivateDispatchTable</samp>.
    Both of these circumvent PatchGuard in different ways. Note, however, that Microsoft
    has been quick to patch some of these known vulnerabilities in PatchGuard, forcing
    malware authors to adapt.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned at the beginning of this section, another security control Microsoft
    has implemented is Driver Signature Enforcement (DSE), sometimes called *digital
    signature enforcement*, which has been released for Windows Vista (x64) and more
    recent versions. DSE ensures that only pre-verified (signed) drivers are allowed
    to be loaded into kernel memory. In theory, legitimate drivers will be permitted,
    while suspicious, unsigned drivers will be prevented from loading. You read earlier
    in the chapter how malware can circumvent this control by using a malicious kernel
    driver signed with a legitimate certificate or by using BYOVD techniques. Microsoft
    recommends dealing with this problem by using *blocklists* of known vulnerable
    drivers. If a driver is reported to be vulnerable or is actively being misused,
    Microsoft adds it to the blocklist, which prevents it from being installed later.
    You can enforce this feature by enabling the “Microsoft Vulnerable Driver Blocklist”
    security option in later versions of Windows. The primary concerns with this control
    are that some legitimate drivers may be prevented from loading and that it protects
    only against known malicious drivers.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, *early launch anti-malware (ELAM)* is a feature of some endpoint defense
    software that protects the Windows boot process. ELAM is responsible for loading
    anti-malware kernel components prior to other third-party components. This ensures
    that the anti-malware is properly loaded and running before rootkits or any other
    persistent malware have the opportunity to load and execute. ELAM can be a good
    defense against rootkits. However, as ELAM drivers aren’t loaded until later stages
    in the boot process, ELAM alone might not prevent loading of bootkits.
  prefs: []
  type: TYPE_NORMAL
- en: For defense against bootkits and UEFI rootkits, you can enable *Secure Boot*.
    Available on most modern hardware, Secure Boot prevents malicious code from hijacking
    the Windows boot process. Upon boot-up, Secure Boot verifies the integrity of
    UEFI firmware drivers and the operating system itself before allowing the system
    to fully boot. This provides a layer of protection in the event malware has embedded
    itself in a UEFI chip. Secure Boot is optional in most versions of Windows, but
    it’s required in Windows 11\. As with all security controls, however, various
    implementations of Secure Boot have vulnerabilities that could be exploited by
    malware. Researchers from Eclypsium ([*https://<wbr>eclypsium<wbr>.com*](https://eclypsium.com))
    reported on some of these vulnerabilities in 2020 and 2022, for example.
  prefs: []
  type: TYPE_NORMAL
- en: As a final note, many Windows rootkit protections, such as PatchGuard and DSE,
    are for x64 (64-bit) versions of Windows only. This leaves x86 (32-bit) versions
    of Windows potentially exposed to a host of dangerous low-level malware. Fortunately,
    precisely because these security features aren’t enabled in x86 mode, EDR and
    anti-malware can use these same techniques for good, to monitor and protect the
    endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This chapter covered the fundamentals of rootkits: how kernel modules work,
    how malware installs malicious modules, and how threat actors bypass protections
    such as signed driver enforcement. We discussed some common rootkit techniques
    such as DKOM, kernel hooking, IRP interception, and kernel callback abuse. You
    were introduced to bootkits and also saw how kernel-space malware can bypass built-in
    Windows protection mechanisms like PatchGuard. This chapter has only scratched
    the surface of rootkits and kernel manipulation techniques, however, so if you’re
    interested in learning more, I encourage you to review [Appendix C](appendix-C.xhtml)
    for more resources. In the next chapter, we’ll discuss how modern malware evades
    endpoint defenses and investigators by leveraging “fileless” and anti- forensics
    techniques.'
  prefs: []
  type: TYPE_NORMAL
