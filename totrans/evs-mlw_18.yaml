- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">14</samp> <samp class="SANS_Dogma_OT_Bold_B_11">INTRODUCTION
    TO ROOTKITS</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">14</samp> <samp class="SANS_Dogma_OT_Bold_B_11">ROOTKIT介绍</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: '*Rootkits* are malware variants that specialize in hiding their presence on
    a host by first obtaining low-level access to the victim system. The name *rootkit*
    originates from Unix, where the *root* user has the highest level of privileges
    the system allows. Rootkits use several evasion methods, such as intercepting
    and modifying communication between kernel and user space and directly tampering
    with data structures in kernel memory, to hide from endpoint defenses and investigation
    tools.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*Rootkit* 是一种恶意软件变种，通过首先获得受害系统的低级访问权限，专门隐藏自己在主机上的存在。*Rootkit* 这个名称源自 Unix 系统，其中
    *root* 用户拥有系统允许的最高权限。Rootkit 使用多种规避方法，例如拦截和修改内核与用户空间之间的通信，直接篡改内核内存中的数据结构，以躲避终端防御和调查工具。'
- en: This chapter provides an introductory overview of kernel-based rootkits and
    some of the techniques they use to evade defenses and manipulate a system. While
    not an exhaustive resource on rootkits or rootkit analysis, this chapter covers
    some of the tactics to be on the lookout for when you’re investigating low-level
    malware.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了基于内核的 rootkit 及其规避防御和操控系统的一些技术的简介。虽然本章不是 rootkit 或 rootkit 分析的详尽资源，但它涵盖了在调查低级恶意软件时需要警惕的一些战术。
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Rootkit Fundamentals</samp>'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">Rootkit 基础</samp>'
- en: 'There are many reasons why a malware author might use rootkit components:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者使用 rootkit 组件的原因有很多：
- en: '**Persistence and survivability**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**持久性和生存能力**'
- en: Since rootkits exist in kernel space and have low-level system access, they
    can persist after reboots and in strong, well-defended environments. Bootkits,
    an advanced form of rootkit we’ll discuss later in the chapter, reside at the
    firmware layer and therefore have even greater persistence.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 rootkit 存在于内核空间并具有低级系统访问权限，它们在重启后以及在强大的、防御良好的环境中依然能保持存在。Bootkit 是一种更先进的 rootkit
    形式，稍后我们将在本章讨论，它驻留在固件层，因此具有更强的持久性。
- en: '**Defense circumvention**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**防御规避**'
- en: Some rootkits actively tamper with and blind endpoint defenses such as EDR and
    anti-malware. Such rootkits can also hide and protect their files and processes
    from investigators by redirecting function calls, for example.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 rootkit 会积极篡改并盲目绕过终端防御措施，例如 EDR 和反恶意软件。这类 rootkit 还可以通过重定向函数调用等方式，隐藏和保护其文件和进程，避免调查人员发现。
- en: '**Low-level access to devices and drivers**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**对设备和驱动程序的低级访问**'
- en: Some rootkits intercept requests and commands to and from kernel drivers and
    hardware. One example is Moriya (see the May 2021 article “Operation TunnelSnake”
    at [*https://<wbr>securelist<wbr>.com<wbr>/operation<wbr>-tunnelsnake<wbr>-and<wbr>-moriya<wbr>-rootkit<wbr>/101831<wbr>/*](https://securelist.com/operation-tunnelsnake-and-moriya-rootkit/101831/)),
    which intercepts, manipulates, and hides network traffic to and from the infected
    host.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 rootkit 拦截与内核驱动程序和硬件之间的请求和命令。例如，Moriya 就是其中之一（请参阅 2021年5月的文章“Operation TunnelSnake”
    [*https://<wbr>securelist<wbr>.com<wbr>/operation<wbr>-tunnelsnake<wbr>-and<wbr>-moriya<wbr>-rootkit<wbr>/101831<wbr>/*](https://securelist.com/operation-tunnelsnake-and-moriya-rootkit/101831/)），它拦截、操控并隐藏与受感染主机之间的网络流量。
- en: Because rootkits reside in kernel space and work by manipulating kernel elements,
    let’s take a closer look at what these components are before discussing how rootkits
    take advantage of them.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 rootkit 存在于内核空间，并通过操控内核元素工作，在讨论 rootkit 如何利用这些元素之前，我们先来更详细地了解这些组件是什么。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Kernel Modules and
    Drivers</samp>
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">内核模块和驱动程序</samp>
- en: '*Kernel modules* are binary files containing code and data that extend the
    kernel’s functionalities. They can be loaded at system boot-up or on demand. *Kernel
    drivers* are a specific type of kernel module that interact with system hardware.
    There are different types of kernel drivers:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*内核模块* 是包含代码和数据的二进制文件，用于扩展内核的功能。它们可以在系统启动时或按需加载。*内核驱动程序* 是一种特定类型的内核模块，与系统硬件进行交互。内核驱动程序有不同的类型：'
- en: '**Device drivers**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**设备驱动程序**'
- en: Perhaps the most common type of kernel driver, device drivers provide an interface
    between Windows and the underlying hardware devices of the system, such as keyboards,
    mice, and printers. They interact with system hardware either directly or indirectly.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 也许是最常见的内核驱动程序类型，设备驱动程序为 Windows 与系统底层硬件设备之间提供接口，例如键盘、鼠标和打印机。它们直接或间接地与系统硬件进行交互。
- en: '**Filter drivers**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**过滤驱动程序**'
- en: As their name suggests, filter drivers “filter” IO communication destined for
    other drivers, intercepting and potentially modifying it. These drivers add functionality
    to other drivers or to the system at large, and they also enable capabilities
    such as logging and monitoring. Some malicious actors load filter drivers in the
    kernel to take advantage of these benefits, as you’ll see later.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如它们的名字所示，过滤驱动程序“过滤”目标为其他驱动程序的 IO 通信，拦截并可能修改它。这些驱动程序为其他驱动程序或整个系统添加功能，同时还启用日志记录和监控等能力。一些恶意行为者将过滤驱动程序加载到内核中，以利用这些功能，正如你稍后将看到的那样。
- en: '**Minifilter drivers**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**迷你过滤驱动程序**'
- en: Similar to filter drivers, minifilter drivers filter IO operations and were
    introduced in more modern versions of Windows to improve performance and simplify
    development and compatibility. These drivers can also be abused by malicious actors.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于过滤驱动程序，迷你过滤驱动程序用于过滤 IO 操作，并且在 Windows 的较新版本中被引入，以提高性能并简化开发和兼容性。这些驱动程序也可能被恶意行为者滥用。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*Even though all kernel drivers are modules, not all kernel modules are drivers.
    However, for simplicity’s sake, I’ll use the terms* module *and* driver *interchangeably
    in this chapter.*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽管所有内核驱动程序都是模块，但并非所有内核模块都是驱动程序。不过，为了简便起见，本章中我将*模块*和*驱动程序*这两个术语交替使用。*'
- en: You can view loaded kernel modules in Windows using a Process Manager–like tool
    such as Process Hacker, as shown in [Figure 14-1](chapter14.xhtml#fig14-1).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用类似 Process Manager 的工具，如 Process Hacker，查看 Windows 中加载的内核模块，如[图 14-1](chapter14.xhtml#fig14-1)所示。
- en: '![](../images/fig14-1.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig14-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-1: Viewing loaded
    kernel modules in Process Hacker</samp>'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 14-1：在 Process Hacker 中查看加载的内核模块</samp>
- en: To view loaded kernel modules in Process Hacker, right-click the system process,
    select **Properties**, and then select the **Modules** tab. In [Figure 14-1](chapter14.xhtml#fig14-1),
    you can see some of the kernel drivers installed on my system, such as Advanced
    Configuration and Power Interface (ACPI) drivers and display drivers such as the
    VGA boot driver.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 Process Hacker 中加载的内核模块，右键单击系统进程，选择**属性**，然后选择**模块**选项卡。在[图 14-1](chapter14.xhtml#fig14-1)中，你可以看到我系统上安装的一些内核驱动程序，如高级配置和电源接口（ACPI）驱动程序，以及显示驱动程序，例如
    VGA 启动驱动程序。
- en: Now that you have a basic understanding of kernel drivers, let’s dive into the
    structure of malicious kernel drivers, which are more commonly known as rootkits.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对内核驱动程序有了基本了解，接下来我们将深入探讨恶意内核驱动程序的结构，它们通常被称为 Rootkit。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Rootkit Components</samp>
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Rootkit 组件</samp>
- en: 'Rootkits commonly have two components: a process running in user space and
    a kernel driver that receives instructions from that process. Rootkits nearly
    always start with a user-space executable that must be deployed and executed on
    the victim host. Once this is accomplished, the malicious process loads a driver
    into kernel space. [Figure 14-2](chapter14.xhtml#fig14-2) shows a simple, high-level
    view of how rootkits are installed.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Rootkit 通常有两个组件：一个运行在用户空间的进程和一个从该进程接收指令的内核驱动程序。Rootkit 几乎总是从一个必须在受害主机上部署并执行的用户空间可执行文件开始。一旦完成部署，恶意进程会将一个驱动程序加载到内核空间中。[图
    14-2](chapter14.xhtml#fig14-2)展示了一个简单的、概览式的 Rootkit 安装方式。
- en: '![](../images/fig14-2.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig14-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-2: The rootkit installation
    process</samp>'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 14-2：Rootkit 安装过程</samp>
- en: First, the victim is delivered a dropper executable (*malware.exe*) that, once
    executed, decrypts an embedded malicious kernel driver (*rootkit.sys*). The dropper
    configures and executes this driver as a service, completing the rootkit’s installation
    into kernel space. (We’ll discuss this more in a moment.) The user-space process
    code contains the majority of the malware’s primary functionalities, while the
    kernel component works to mask and protect the user-space process on the system,
    establish low-level hooks to hide its artifacts in memory and on disk, and blind
    endpoint defenses and investigators to its presence.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，受害者会收到一个投放器可执行文件（*malware.exe*），该文件一旦执行，会解密一个嵌入的恶意内核驱动程序（*rootkit.sys*）。该投放器将该驱动程序配置并作为服务执行，从而完成Rootkit在内核空间中的安装。（我们稍后会详细讨论这一过程。）用户空间进程代码包含了大部分恶意软件的主要功能，而内核组件则负责在系统中掩盖和保护用户空间进程，建立低级钩子以隐藏内存和磁盘中的痕迹，并使端点防御和调查人员无法察觉其存在。
- en: '[Figure 14-3](chapter14.xhtml#fig14-3) illustrates some of the newly installed
    rootkit’s functionalities.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-3](chapter14.xhtml#fig14-3)展示了新安装的Rootkit的一些功能。'
- en: '![](../images/fig14-3.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig14-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-3: The basic functionalities
    of a rootkit</samp>'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图14-3：Rootkit的基本功能</samp>
- en: This rootkit can conceal its user-space executable (*malware.exe*) as well as
    issue commands to its kernel driver (*rootkit.sys*) ❶. Rootkit user-space components
    often communicate to their kernel-space counterparts by sending requests via a
    WinAPI function such as <samp class="SANS_TheSansMonoCd_W5Regular_11">DeviceIOControl</samp>,
    which allows a user-space process to send a control code (instruction) to a kernel-space
    driver. In addition, this rootkit is able to hook and intercept API calls from
    user space ❷, intercept communication between other kernel components and device
    drivers ❸, and even tamper with kernel memory directly ❹. All of these techniques
    will become clearer as we progress through this chapter. But first, let’s take
    a step back and talk about how rootkits are installed in the first place.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 该Rootkit能够隐藏其用户空间的可执行文件（*malware.exe*），并向其内核驱动程序（*rootkit.sys*）发出指令 ❶。Rootkit的用户空间组件通常通过发送请求，利用WinAPI函数如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">DeviceIOControl</samp>与内核空间的对应部分进行通信，该函数允许用户空间进程向内核空间驱动程序发送控制码（指令）。此外，该Rootkit能够挂钩并拦截来自用户空间的API调用
    ❷，拦截其他内核组件与设备驱动程序之间的通信 ❸，甚至直接篡改内核内存 ❹。随着本章的进展，这些技术将变得更加清晰。但首先，让我们回顾一下Rootkit是如何最初被安装的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Rootkit Installation</samp>
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Rootkit安装</samp>
- en: 'In the past, rootkits were more prevalent, but Microsoft has implemented protective
    measures in later versions of Windows that make it more difficult to implement
    the changes necessary to install malicious kernel components on a system. Even
    so, there are ways to bypass these protections, so these kinds of attacks do still
    happen sometimes. Let’s take a look at a recent real-world example: HermeticWiper.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，Rootkit的普遍性较高，但微软在后来的Windows版本中实施了保护措施，使得实施必要的更改以安装恶意内核组件变得更加困难。尽管如此，仍然存在绕过这些保护措施的方法，因此这类攻击有时仍然发生。让我们来看一个最近的实际案例：HermeticWiper。
- en: HermeticWiper targeted victims in Ukraine in 2022\. It’s not a rootkit per se;
    rather, it is destructive malware that requires low-level access to overwrite
    data on the disk, rendering a system unbootable. However, because HermeticWiper
    uses a common method of loading a kernel driver and is well documented, it’s a
    good example of how rootkits can also be installed in a victim environment.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: HermeticWiper在2022年针对乌克兰的受害者发起攻击。它本身并不是一个Rootkit；而是一种破坏性恶意软件，需要低级别的访问权限以覆盖磁盘上的数据，使系统无法启动。然而，由于HermeticWiper使用了常见的加载内核驱动程序的方法，并且有很好的文献记录，它是一个很好的例子，展示了Rootkit如何被安装到受害环境中。
- en: One particular HermeticWiper sample was signed by a certificate stolen from
    a valid company, Hermetica Digital Ltd., potentially allowing HermeticWiper to
    bypass certain endpoint defenses. (This technique was discussed in [Chapter 13](chapter13.xhtml).)
    When HermeticWiper first executes, the sample writes a new *.sys* file with a
    file name consisting of four characters (such as *bpdr.sys*) to disk. This file
    is a legitimate driver from the company EaseUS that is normally used to resize
    and partition disks; however, it can be misused, as we’ll see in a moment. Since
    at the time of the attack, this file is signed by a valid certificate, it’s able
    to bypass Windows protections like driver-signing enforcement.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特定的 HermeticWiper 样本是由从合法公司 Hermetica Digital Ltd. 偷来的证书签名的，这可能使 HermeticWiper
    绕过某些终端防御。（此技术在[第13章](chapter13.xhtml)中讨论过。）当 HermeticWiper 首次执行时，该样本将写入一个新的 *.sys*
    文件，文件名由四个字符组成（例如 *bpdr.sys*）并写入磁盘。此文件是 EaseUS 公司的一款合法驱动程序，通常用于调整和分区磁盘；然而，它也可以被滥用，正如我们稍后将看到的那样。由于在攻击时，该文件由有效证书签名，因此能够绕过
    Windows 的驱动程序签名强制保护。
- en: 'Next, to obtain the special privileges required for loading drivers, HermeticWiper
    attempts to obtain <samp class="SANS_TheSansMonoCd_W5Regular_11">SeLoadDriverPrivilege</samp>.
    This privilege can be obtained only by a process already running at a high privilege
    level, so most malware will need to use a privilege elevation technique (such
    as a UAC bypass) to get administrator or system-level privileges and then call
    a function such as <samp class="SANS_TheSansMonoCd_W5Regular_11">AdjustTokenPrivileges</samp>
    (as discussed in [Chapter 13](chapter13.xhtml)). Once it has the required privileges,
    HermeticWiper creates a new service by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateServiceW</samp>
    and starts it by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">StartServiceW</samp>.
    Creating and executing a service is one of the most common methods of loading
    a new kernel driver, for both legitimate and malicious purposes. It can also be
    accomplished via the Windows command line, like so:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了获得加载驱动程序所需的特殊权限，HermeticWiper 尝试获取 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeLoadDriverPrivilege</samp>。此权限只能由已在高权限级别运行的进程获取，因此大多数恶意软件需要使用特权提升技术（如绕过
    UAC）来获得管理员或系统级权限，然后调用诸如 <samp class="SANS_TheSansMonoCd_W5Regular_11">AdjustTokenPrivileges</samp>
    的函数（如[第13章](chapter13.xhtml)所讨论）。一旦获得所需的权限，HermeticWiper 就通过调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateServiceW</samp>
    创建一个新服务，并通过调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">StartServiceW</samp>
    启动它。创建和执行服务是加载新内核驱动程序的最常见方法之一，既可以用于合法目的，也可以用于恶意目的。它还可以通过 Windows 命令行实现，如下所示：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This command creates a new service (<samp class="SANS_TheSansMonoCd_W5Regular_11">evil</samp>),
    specifying an input parameter of <samp class="SANS_TheSansMonoCd_W5Regular_11">C:\Users\Public\evil.sys</samp>
    (the path of the malicious driver to be loaded) and a type of <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel</samp>,
    denoting this service as a kernel driver installation. The following command can
    then be used to start the service:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令创建了一个新服务（<samp class="SANS_TheSansMonoCd_W5Regular_11">evil</samp>），并指定了一个输入参数
    <samp class="SANS_TheSansMonoCd_W5Regular_11">C:\Users\Public\evil.sys</samp>（要加载的恶意驱动程序的路径）以及类型
    <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel</samp>，表示该服务为内核驱动程序安装。随后，可以使用以下命令启动该服务：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here’s the output of executing these commands in Windows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 Windows 中执行这些命令的输出：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the case of HermeticWiper, since the driver (at the time of attack, at least)
    is legitimate and signed by a valid authority, it likely won’t have any issues
    installing in kernel space and can circumvent built-in Windows controls. If the
    driver wasn’t signed by a valid signing authority, we’d receive the following
    error upon starting the service:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 HermeticWiper，由于驱动程序（至少在攻击时）是合法的，并且已由有效的授权机构签名，它可能不会在内核空间安装时遇到任何问题，且能够绕过内置的
    Windows 控制。如果驱动程序未由有效的签名授权机构签名，我们将在启动服务时收到以下错误：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once the malicious service is successfully installed, the Windows Service Controller
    takes over and loads the driver into kernel address space. The malware’s user-space
    component can now interact with the malicious driver in kernel space by invoking
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DeviceIOControl</samp> and issuing
    commands to it. In doing so, HermeticWiper is using an otherwise legitimate driver
    (the EaseUS driver) to write data to the disk, destroying this data and making
    infected systems inoperable.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦恶意服务成功安装，Windows 服务控制器接管并将驱动程序加载到内核地址空间。恶意软件的用户空间组件现在可以通过调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">DeviceIOControl</samp>
    与内核空间中的恶意驱动程序进行交互，并向其发出命令。通过这种方式，HermeticWiper 使用一个本应合法的驱动程序（EaseUS 驱动程序）向磁盘写入数据，破坏这些数据并使受感染的系统无法操作。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*Kernel drivers aren’t always loaded using services. There are other techniques
    for loading them, including invoking the NT API function <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">NtLoadDriver</samp>.*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*内核驱动并不总是通过服务加载。还有其他加载它们的技术，包括调用 NT API 函数 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">NtLoadDriver</samp>。*'
- en: This abuse of legitimate drivers is a form of the Bring Your Own Vulnerable
    Driver technique, which we’ll discuss next.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对合法驱动程序的这种滥用是一种自带易受攻击驱动程序技术的形式，接下来我们将讨论这一技术。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">BYOVD Attacks</samp>
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">BYOVD 攻击</samp>
- en: '*Bring Your Own Vulnerable Driver* (*BYOVD*, or simply *BYOD*) attacks take
    advantage of legitimate, signed drivers as a sort of proxy to interact with the
    kernel; disable security controls; or load a separate, unsigned, malicious kernel
    driver. A malware author searches for a legitimate driver that is already signed
    by a valid signing authority (and therefore vetted by the Windows operating system)
    that can be dropped to the victim system during the attack. This driver must also
    have some sort of vulnerability that allows the threat actor to perform low-level
    malicious actions on the victim system. To exploit these vulnerabilities, rootkits
    often send commands to the vulnerable driver (by invoking <samp class="SANS_TheSansMonoCd_W5Regular_11">DeviceIOControl</samp>,
    for example) from their user-space process.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*自带易受攻击驱动程序*（*BYOVD*，或简称 *BYOD*）攻击利用合法签名的驱动程序作为代理与内核交互；禁用安全控制；或加载单独的、未签名的恶意内核驱动程序。恶意软件作者寻找一个已经由有效签名机构签名的合法驱动程序（因此已通过
    Windows 操作系统的审查），并在攻击期间将其放置到受害系统中。这个驱动程序还必须具有某种漏洞，允许攻击者在受害系统上执行低级恶意操作。为了利用这些漏洞，rootkit
    通常通过其用户空间进程发送命令给易受攻击的驱动程序（例如通过调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">DeviceIOControl</samp>）。'
- en: One notable example of this type of attack is the FudModule rootkit, purportedly
    used by North Korean cybercriminals known as the Lazarus Group. As reported by
    researchers at ESET, FudModule takes advantage of a vulnerable, signed Dell driver
    containing a vulnerability (CVE-2021-21551) that allowed Lazarus to write data
    into kernel memory. More specifically, the vulnerability was triggered by a specially
    crafted instruction to the driver via <samp class="SANS_TheSansMonoCd_W5Regular_11">DeviceIOControl</samp>.
    Ultimately, the threat actors successfully disabled multiple defensive mechanisms
    in Windows, effectively blinding endpoint defenses to later stages of the attack.
    For more information, see Peter Kálnai’s article “Amazon-Themed Campaigns of Lazarus
    in the Netherlands and Belgium” at [*https://<wbr>www<wbr>.welivesecurity<wbr>.com<wbr>/2022<wbr>/09<wbr>/30<wbr>/amazon<wbr>-themed<wbr>-campaigns<wbr>-lazarus<wbr>-netherlands<wbr>-belgium<wbr>/*](https://www.welivesecurity.com/2022/09/30/amazon-themed-campaigns-lazarus-netherlands-belgium/).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的例子是 FudModule rootkit，据信由朝鲜的网络犯罪集团 Lazarus Group 使用。正如 ESET 研究人员报告的那样，FudModule
    利用了一个含有漏洞（CVE-2021-21551）的已签名的 Dell 驱动程序，这个漏洞允许 Lazarus 向内核内存写入数据。更具体地说，这个漏洞是通过特制的指令通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DeviceIOControl</samp> 触发的。最终，攻击者成功禁用了
    Windows 中的多个防御机制，实际上使终端防御对攻击的后续阶段失去反应能力。更多信息请见 Peter Kálnai 文章“Lazarus 在荷兰和比利时的亚马逊主题攻击”：[*https://<wbr>www<wbr>.welivesecurity<wbr>.com<wbr>/2022<wbr>/09<wbr>/30<wbr>/amazon<wbr>-themed<wbr>-campaigns<wbr>-lazarus<wbr>-netherlands<wbr>-belgium<wbr>/*](https://www.welivesecurity.com/2022/09/30/amazon-themed-campaigns-lazarus-netherlands-belgium/)。
- en: Another example of malware that uses the BYOVD technique is the BlackByte ransomware
    family. As Sophos reported, BlackByte abuses a vulnerable driver in the legitimate
    product MSI AfterBurner, a tool for tuning graphics cards. The driver vulnerability
    (CVE-2019-16098) allowed the BlackByte operators to interact with the kernel and
    disable EDR products on the host by terminating EDR-related processes. To learn
    more about this malware, check out Andreas Klopsch’s article “Remove All the Callbacks—BlackByte
    Ransomware Disables EDR Via RTCore64.sys Abuse” at [*https://<wbr>news<wbr>.sophos<wbr>.com<wbr>/en<wbr>-us<wbr>/2022<wbr>/10<wbr>/04<wbr>/blackbyte<wbr>-ransomware<wbr>-returns<wbr>/*](https://news.sophos.com/en-us/2022/10/04/blackbyte-ransomware-returns/).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使用BYOVD技术的恶意软件例子是BlackByte勒索病毒家族。正如Sophos报道的那样，BlackByte利用了合法产品MSI AfterBurner中的一个脆弱驱动程序，这是一款用于调节显卡的工具。该驱动程序漏洞（CVE-2019-16098）使得BlackByte的操作者能够与内核交互，并通过终止与EDR相关的进程来禁用主机上的EDR产品。想了解更多关于该恶意软件的信息，请查看Andreas
    Klopsch的文章《移除所有回调—BlackByte勒索病毒通过RTCore64.sys滥用禁用EDR》([*https://<wbr>news<wbr>.sophos<wbr>.com<wbr>/en<wbr>-us<wbr>/2022<wbr>/10<wbr>/04<wbr>/blackbyte<wbr>-ransomware<wbr>-returns<wbr>/*](https://news.sophos.com/en-us/2022/10/04/blackbyte-ransomware-returns/))。
- en: A third example is the malware family ZeroCleare, found by researchers at IBM
    X-Force IRIS to be abusing a vulnerable VirtualBox driver (*vboxdrv.sys*), which
    allowed the attacker to execute shellcode in kernel memory and install a malicious
    kernel driver. You can read more about this attack in the IBM report “New Destructive
    Wiper ZeroCleare Targets Energy Sector in the Middle East” at [*https://<wbr>securityintelligence<wbr>.com<wbr>/posts<wbr>/new<wbr>-destructive<wbr>-wiper<wbr>-zerocleare<wbr>-targets<wbr>-energy<wbr>-sector<wbr>-in<wbr>-the<wbr>-middle<wbr>-east<wbr>/*](https://securityintelligence.com/posts/new-destructive-wiper-zerocleare-targets-energy-sector-in-the-middle-east/).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是恶意软件家族ZeroCleare，IBM X-Force IRIS的研究人员发现该家族利用了一个脆弱的VirtualBox驱动程序（*vboxdrv.sys*），使攻击者能够在内核内存中执行shellcode并安装恶意内核驱动程序。你可以在IBM报告《新的破坏性擦除工具ZeroCleare针对中东能源部门》([*https://<wbr>securityintelligence<wbr>.com<wbr>/posts<wbr>/new<wbr>-destructive<wbr>-wiper<wbr>-zerocleare<wbr>-targets<wbr>-energy<wbr>-sector<wbr>-in<wbr>-the<wbr>-middle<wbr>-east<wbr>/*](https://securityintelligence.com/posts/new-destructive-wiper-zerocleare-targets-energy-sector-in-the-middle-east/))中阅读更多关于这一攻击的信息。
- en: Unfortunately, there are other recent examples of malware abusing vulnerable
    drivers to disable and blind endpoint defenses, load additional malicious kernel
    drivers, or otherwise execute malicious code in privileged areas of the operating
    system. Furthermore, since these drivers are legitimate and signed, there’s currently
    not much that can be done to completely prevent this type of attack. There’s a
    dedicated project for tracking these vulnerable drivers; it’s called Living Off
    The Land Drivers (LOLDrivers, for short). It’s worth exploring if you’re interested
    in learning more about BYOVD attacks, so visit the project website at [*https://<wbr>www<wbr>.loldrivers<wbr>.io*](https://www.loldrivers.io).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，还有一些最近的恶意软件例子，利用脆弱驱动程序来禁用并盲化终端防御，加载额外的恶意内核驱动程序，或在操作系统的特权区域中执行恶意代码。此外，由于这些驱动程序是合法且已签名的，目前没有太多办法可以完全防止这种类型的攻击。有一个专门的项目跟踪这些脆弱的驱动程序，叫做Living
    Off The Land Drivers（简称LOLDrivers）。如果你有兴趣了解更多关于BYOVD攻击的知识，值得去探索一下，访问项目网站：[*https://<wbr>www<wbr>.loldrivers<wbr>.io*](https://www.loldrivers.io)。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*Not all BYOVD usage is rootkit related. For example, some malware simply leverages
    a vulnerable driver to execute kernel functions or perform low-level actions that
    would otherwise be prohibited.*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*并非所有BYOVD的使用都与rootkit相关。例如，一些恶意软件仅利用脆弱的驱动程序执行内核功能或进行低级操作，这些操作本来是被禁止的。*'
- en: 'Now that you’ve gotten an overview of how threat actors can bypass Windows
    protections to install rootkits, let’s start looking into how rootkits behave
    on a victim host and manipulate the system to stay hidden. We’ll start with an
    old technique: DKOM.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了威胁行为者如何绕过Windows的保护机制来安装rootkit，我们开始研究rootkit在受害主机上的行为，并通过操控系统保持隐藏。我们从一个老旧的技术开始：DKOM。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Direct Kernel Object Manipulation</samp>
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">直接内核对象操作（DKOM）</samp>
- en: '*Direct kernel object manipulation* (*DKOM)* involves directly modifying data
    in kernel memory. This is a delicate task because, when done incorrectly, it can
    crash the operating system. Done correctly, however, it can give the malware immense
    power. One example of DKOM is hiding processes.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*直接内核对象操作*（*DKOM*）涉及直接修改内核内存中的数据。这是一项精细的任务，因为如果操作不当，可能会导致操作系统崩溃。然而，如果操作得当，它可以赋予恶意软件巨大的能力。DKOM的一个例子是隐藏进程。'
- en: Using DKOM, a rootkit can hide its user-space processes and kernel modules from
    endpoint defenses and forensics analysts by modifying its processes’ EPROCESS
    data structures in kernel memory. You might remember from [Chapter 1](chapter1.xhtml)
    that EPROCESS structures form a doubly linked list of processes running on the
    host. Some defense and analysis tools rely on these structures to monitor and
    inspect anomalous running processes.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用DKOM，rootkit可以通过修改其进程的EPROCESS数据结构，将其用户空间进程和内核模块从终端防御和取证分析中隐藏。你可能还记得在[第1章](chapter1.xhtml)中，EPROCESS结构形成了主机上正在运行的进程的双向链表。一些防御和分析工具依赖这些结构来监视和检查异常的运行进程。
- en: To perform this type of DKOM technique, a malicious kernel-space module invokes
    a function such as <samp class="SANS_TheSansMonoCd_W5Regular_11">PsLookupProcessByProcessID</samp>
    to get a pointer to its own user-space component’s EPROCESS structure. Then, the
    malware can modify the *forward link (flink)* and *backward link (blink)* members
    of the EPROCESS structure, unlinking the structure from the EPROCESS chain. [Figure
    14-4](chapter14.xhtml#fig14-4) illustrates normal, unmodified EPROCESS structures
    before unlinking.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行这种类型的DKOM技术，恶意的内核空间模块会调用诸如 <samp class="SANS_TheSansMonoCd_W5Regular_11">PsLookupProcessByProcessID</samp>
    之类的函数，以获取指向其自身用户空间组件EPROCESS结构的指针。然后，恶意软件可以修改EPROCESS结构的*前向链接（flink）*和*后向链接（blink）*成员，将该结构从EPROCESS链中解除链接。[图14-4](chapter14.xhtml#fig14-4)展示了解除链接前的正常、未修改的EPROCESS结构。
- en: '![](../images/fig14-4.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig14-4.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-4: Doubly linked
    EPROCESS structures before unlinking</samp>'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图14-4：解除链接前的双向链接EPROCESS结构</samp>
- en: Notice how the EPROCESS structures are linked by their flink and blink members.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，EPROCESS结构是通过它们的flink和blink成员链接的。
- en: '[Figure 14-5](chapter14.xhtml#fig14-5) shows what happens when a rootkit tampers
    with the EPROCESS structures to unlink its malicious process (center).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-5](chapter14.xhtml#fig14-5)显示了当rootkit篡改EPROCESS结构以将其恶意进程（中间）解除链接时发生的情况。'
- en: '![](../images/fig14-5.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig14-5.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-5: EPROCESS structures
    after unlinking</samp>'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图14-5：解除链接后的EPROCESS结构</samp>
- en: Notice how both the flink and blink for the malicious process’s EPROCESS structure
    point back to it, effectively disconnecting this process from the normal EPROCESS
    chain.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，恶意进程的EPROCESS结构的flink和blink都指向它自己，从而有效地将该进程与正常的EPROCESS链断开连接。
- en: 'The following code is an abridged version of the HideProcess project (see [*https://<wbr>github<wbr>.com<wbr>/landhb<wbr>/HideProcess*](https://github.com/landhb/HideProcess)),
    and it demonstrates how the malware accomplishes the tasks outlined previously:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是HideProcess项目的简化版本（请参见 [*https://<wbr>github<wbr>.com<wbr>/landhb<wbr>/HideProcess*](https://github.com/landhb/HideProcess)），演示了恶意软件如何完成之前提到的任务：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: First, the code defines the variables <samp class="SANS_TheSansMonoCd_W5Regular_11">Previous</samp>
    (which stores the current process’s blink pointer) ❶ and <samp class="SANS_TheSansMonoCd_W5Regular_11">Next</samp>
    (which stores the current process’s flink pointer) ❷. Later, the code rewrites
    these <samp class="SANS_TheSansMonoCd_W5Regular_11">LIST_ENTRY</samp> values to
    point to itself. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Current->Blink</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(PLIST_ENTRY)&Current->Flink</samp>
    line sets the process’s current blink pointer to its flink pointer value ❸. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Current->Flink</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(PLIST _ENTRY)&Current->Flink</samp>
    line ensures that the process’s flink points to itself ❹. In essence, this breaks
    the EPROCESS chain, hiding the process from process management tools (like Task
    Manager) and some forensics investigation toolsets, perhaps helping it better
    evade endpoint defenses.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码定义了变量<samp class="SANS_TheSansMonoCd_W5Regular_11">Previous</samp>（存储当前进程的blink指针）❶和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Next</samp>（存储当前进程的flink指针）❷。之后，代码将这些<samp
    class="SANS_TheSansMonoCd_W5Regular_11">LIST_ENTRY</samp>值重写为指向自身。<samp class="SANS_TheSansMonoCd_W5Regular_11">Current->Blink</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(PLIST_ENTRY)&Current->Flink</samp>这一行将进程的当前blink指针设置为其flink指针的值❸。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Current->Flink</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(PLIST_ENTRY)&Current->Flink</samp>这一行确保进程的flink指向自身❹。从本质上讲，这打破了EPROCESS链，隐藏了进程，使其从进程管理工具（如任务管理器）和一些取证工具集中消失，可能帮助它更好地逃避端点防御。
- en: DKOM isn’t limited to hiding processes, however. Using DKOM techniques, malware
    can theoretically alter any object in kernel memory. Malware has been known to
    use DKOM techniques to hide malicious network traffic or alter files in order
    to interfere with forensics investigations. DKOM can also be used to inject kernel
    hooks, as you’ll see in the next section.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，DKOM并不限于隐藏进程。使用DKOM技术，恶意软件理论上可以改变内核内存中的任何对象。已知恶意软件使用DKOM技术来隐藏恶意网络流量或修改文件，以干扰取证调查。DKOM还可以用来注入内核钩子，正如你将在下一节中看到的那样。
- en: While DKOM is one of the most basic and straightforward methods rootkits can
    use to hide or to alter the system, it’s not a golden ticket. DKOM and other kernel
    manipulation techniques can easily crash the operating system, potentially alerting
    the victim to the malware’s presence. Not only that, but security measures like
    PatchGuard also can create challenges for malware authors, as we’ll discuss later
    in the chapter.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然DKOM是rootkit用来隐藏或改变系统的最基本和直接的方法之一，但它并不是万能的。DKOM和其他内核操作技术很容易导致操作系统崩溃，从而可能提醒受害者恶意软件的存在。不仅如此，像PatchGuard这样的安全措施也为恶意软件作者带来了挑战，正如我们在本章后面将讨论的那样。
- en: <samp class="SANS_Futura_Std_Bold_B_11">“Legacy” Kernel Hooking</samp>
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">“传统”内核钩子</samp>
- en: Just like malware running in user space can use inline and IAT hooking to monitor,
    intercept, and manipulate function calls, kernel-space malware can use several
    types of hooks to launch its attacks. We’ll discuss some of the most prevalent,
    starting with the decades-old technique of SSDT hooking.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在用户空间运行的恶意软件可以使用内联和IAT钩子来监控、拦截和操作函数调用一样，内核空间中的恶意软件也可以使用几种类型的钩子来发起攻击。我们将讨论一些最常见的钩子技术，从几十年前的SSDT钩子技术开始。
- en: '> <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '> <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>'
- en: '*The techniques discussed in this section were at one time some of the most
    common ones used by both rootkits and endpoint defense products alike. Much like
    DKOM, however, they’re no longer popular thanks to the protections that Microsoft
    has implemented in modern versions of Windows. Still, it’s important to gain a
    basic understanding of them since you may occasionally witness malware using these
    or similar tactics, and it’ll also give you a better grasp of more modern rootkit
    techniques.*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*本节讨论的技术曾经是rootkit和端点防御产品中最常用的一些技术。然而，与DKOM类似，这些技术由于微软在现代Windows版本中实施的保护措施，已经不再流行。不过，了解这些技术仍然很重要，因为你可能偶尔会看到恶意软件使用这些或类似的战术，这也能帮助你更好地理解更现代的rootkit技术。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">SSDT Hooks</samp>
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">SSDT钩子</samp>
- en: 'The *System Service Descriptor Table (SSDT)* or *Dispatch Table* contains an
    array of syscall IDs and their corresponding pointers to kernel functions. (These
    differ between 32- and 64-bit operating systems, but we won’t go into those specifics
    here.) As discussed in [Chapters 1](chapter1.xhtml) and [13](chapter13.xhtml),
    when a user-space process invokes Windows API and NT API functions, the function
    eventually makes a syscall into the kernel to fulfill the request. Let’s look
    at an example using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>
    to read a file on disk. Here’s the basic sequence of steps that must occur:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*系统服务描述符表 (SSDT)* 或 *分发表* 包含一组系统调用 ID 及其对应的内核函数指针。（这些在 32 位和 64 位操作系统之间有所不同，但我们在这里不讨论这些具体细节。）正如在[第
    1 章](chapter1.xhtml)和[第 13 章](chapter13.xhtml)中所讨论的，当用户空间的进程调用 Windows API 和 NT
    API 函数时，最终会通过系统调用进入内核来执行请求。我们来看一个使用<samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>读取磁盘文件的例子。以下是必须发生的基本步骤顺序：'
- en: 1.  A program in user space invokes <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>.
    The program initiates a syscall, referencing the syscall ID that corresponds to
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp> function.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  用户空间中的程序调用<samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>。程序发起一个系统调用，引用与<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>函数对应的系统调用 ID。
- en: 2.  The syscall triggers the processor to switch from user mode to kernel mode
    and passes the request and syscall ID to the syscall handler.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  系统调用触发处理器从用户模式切换到内核模式，并将请求和系统调用 ID 传递给系统调用处理程序。
- en: 3.  The syscall handler consults the SSDT to obtain the address of the kernel
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp> function (which
    is exported from *ntoskrnl.exe*) and then proceeds to execute the function.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  系统调用处理程序查阅 SSDT 获取内核<samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>函数的地址（该函数从
    *ntoskrnl.exe* 导出），然后继续执行该函数。
- en: 4.  Since the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>
    function is being invoked to read a file on disk, it must communicate with kernel
    drivers such as the disk driver stack. This is where the IO manager is engaged.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  由于<samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>函数被调用来读取磁盘上的文件，因此它必须与内核驱动程序（如磁盘驱动程序堆栈）进行通信。这时，IO
    管理器便参与其中。
- en: 5.  The IO manager sends instructions in the form of *IO request packets (IRPs)*
    to the appropriate drivers, which will carry out <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>’s
    requested actions (such as reading the specific file on disk). I’ll discuss the
    IO manager and IRPs later in this chapter.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  IO 管理器以*IO 请求包 (IRP)* 的形式向适当的驱动程序发送指令，这些驱动程序将执行<samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>请求的操作（例如读取磁盘上的特定文件）。我将在本章后面讨论
    IO 管理器和 IRP。
- en: 6.  Once the drivers process the request, the result is sent back to the original
    calling program in user space.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  一旦驱动程序处理完请求，结果将被发送回原始的用户空间调用程序。
- en: Now that you have a basic understanding of how the SSDT is used, you can see
    how malware could insert a hook into it to redirect requests to malicious code.
    [Figure 14-6](chapter14.xhtml#fig14-6) shows an example of this approach with
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp> function.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对 SSDT 的基本使用有了了解，你可以看到恶意软件如何通过在其中插入钩子，将请求重定向到恶意代码。[图 14-6](chapter14.xhtml#fig14-6)展示了这种方法的一个例子，使用了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>函数。
- en: '![](../images/fig14-6.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig14-6.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-6: An SSDT hook for
    NtReadFile</samp>'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 14-6：NtReadFile 的 SSDT 钩子</samp>
- en: The rootkit modifies the function pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>
    inside the SSDT, which redirects the request for <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>
    to the rootkit’s malicious kernel module. The rootkit then intercepts and modifies
    the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>. Later,
    it can redirect the call to the original <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>
    function code inside *ntoskrnl.exe*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: rootkit 修改 SSDT 中指向<samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>的函数指针，进而将对<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>的请求重定向到 rootkit 的恶意内核模块。rootkit
    然后拦截并修改对<samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>的调用。稍后，它可以将调用重定向到
    *ntoskrnl.exe* 中的原始<samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>函数代码。
- en: There are many reasons why a malware author would use SSDT hooking. For example,
    they might implement an SSDT hook for <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>
    to prevent the malware’s own malicious files and code from being read by endpoint
    defenses and investigators. Another kernel-hooking technique, inline kernel hooks,
    is used for a similar reason.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者使用 SSDT 钩子的原因有很多。例如，他们可能会为 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>
    实现一个 SSDT 钩子，以防止恶意软件自身的恶意文件和代码被终端防护和调查人员读取。另一种内核钩子技术——内联内核钩子，也用于类似的原因。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Inline Kernel Hooks</samp>
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">内联内核钩子</samp>
- en: Inline hooking is a malware technique employed not just in user space (as discussed
    in [Chapter 12](chapter12.xhtml)) but in kernel functions as well. To install
    the hooks, a rootkit attempts to modify function code inside *ntoskrnl.exe*. Similar
    to the example just discussed with SSDT hooking, a rootkit could hook <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>
    by tampering with the function’s code to insert a jump instruction and redirect
    control flow to the malicious kernel module’s code, as illustrated in [Figure
    14-7](chapter14.xhtml#fig14-7).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 内联钩子是恶意软件在用户空间（如 [第 12 章](chapter12.xhtml) 讨论的）以及内核函数中都使用的一种技术。为了安装钩子，根工具包试图修改
    *ntoskrnl.exe* 中的函数代码。类似于刚才讨论的 SSDT 钩子示例，根工具包可以通过篡改函数代码插入跳转指令，将控制流重定向到恶意内核模块的代码，如
    [图 14-7](chapter14.xhtml#fig14-7) 所示。
- en: '![](../images/fig14-7.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig14-7.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-7: An inline kernel
    hook for NtReadFile</samp>'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 14-7：NtReadFile 的内联内核钩子</samp>
- en: 'There are a number of ways a rootkit can write a hook into a target function.
    Similar to inline hooking in user space, the malware first must alter the memory
    protections of the target function’s code and then write a hook into it. The following
    pseudocode demonstrates how this might look:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 根工具包可以通过多种方式将钩子写入目标函数。类似于用户空间中的内联钩子，恶意软件首先必须修改目标函数代码的内存保护，然后将钩子写入其中。以下伪代码演示了这一过程：
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">MmProtectMdlSystemAddress</samp>
    is a kernel function that’s used to set the memory protection type for a *memory
    descriptor list (MDL)*, which is a structure containing a memory address range.
    This function has two parameters: a <samp class="SANS_TheSansMonoCd_W5Regular_11">MemoryDescriptorList</samp>
    (the memory address range that will be altered) and a protection constant (such
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">PAGE_READWRITE</samp>, which
    would change the MDL’s protections to be writable).'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">MmProtectMdlSystemAddress</samp>
    是一个内核函数，用于设置 *内存描述符列表 (MDL)* 的内存保护类型，MDL 是一个包含内存地址范围的结构。此函数有两个参数：一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">MemoryDescriptorList</samp>（将要修改的内存地址范围）和一个保护常量（如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">PAGE_READWRITE</samp>，它将改变 MDL 的保护为可写）。
- en: Following this, the malware invokes a kernel function such as <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlCopyMemory</samp>
    to overwrite the target code with a jump instruction, for instance. The primary
    parameters of <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlCopyMemory</samp>
    are the destination address of the target memory region, the source address (which
    contains the jump instruction to be copied), and the size of the data being copied.
    Malware must be careful to set the target memory region back to its original protection
    setting because incorrect and anomalous protections (such as “writable”) may raise
    the suspicions of endpoint defenses or cause system instability.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，恶意软件调用一个内核函数，如 <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlCopyMemory</samp>，将目标代码覆盖为跳转指令。例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">RtlCopyMemory</samp> 的主要参数是目标内存区域的目的地址、源地址（其中包含要复制的跳转指令）和复制数据的大小。恶意软件必须小心将目标内存区域恢复为其原始保护设置，因为不正确和异常的保护（例如“可写”）可能会引起终端防护的怀疑，或者导致系统不稳定。
- en: Next, we’ll turn to IRP hooking, another type of kernel hook rootkits have been
    known to use.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论 IRP 钩子，这也是根工具包已知使用的一种内核钩子类型。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">IRP Hooks</samp>
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">IRP 钩子</samp>
- en: When user-space programs need to communicate with kernel drivers, they do so
    via the IO manager. This communication is primarily accomplished with IO request
    packets (IRPs), which are objects comprising data structures that contain information
    about the request and actions to be performed. IRPs are passed between the calling
    program and kernel drivers, but they can also be used for communication between
    drivers. For example, a USB keyboard driver will need to communicate with the
    USB host controller driver, and the IO manager helps facilitate this. This relationship
    is illustrated in [Figure 14-8](chapter14.xhtml#fig14-8).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户空间程序需要与内核驱动程序通信时，它们通过 IO 管理器来实现。这种通信主要通过 IO 请求包（IRP）完成，IRP 是包含请求信息和待执行操作的数据结构对象。IRP
    在调用程序和内核驱动程序之间传递，但它们也可以用于驱动程序之间的通信。例如，USB 键盘驱动程序需要与 USB 主机控制器驱动程序通信，IO 管理器有助于促进这种通信。这个关系在
    [图 14-8](chapter14.xhtml#fig14-8) 中得到了说明。
- en: '![](../images/fig14-8.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig14-8.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-8: How an IRP works</samp>'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 14-8：IRP 的工作原理</samp>
- en: This program invokes the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateFile</samp>
    function to open a handle to a file on disk. Eventually, the program makes a syscall
    into the kernel (*ntoskrnl.exe*). This is where the IO manager gets involved,
    sending an IRP to the filesystem driver that will handle this operation. In the
    final step (not pictured here), the driver sends the status of the operation back
    to the IO manager, which will return the status to the calling program.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 本程序调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateFile</samp> 函数来打开磁盘上的文件句柄。最终，程序会进行系统调用，进入内核（*ntoskrnl.exe*）。此时，IO
    管理器开始介入，向文件系统驱动程序发送 IRP 来处理此操作。在最后一步（这里未显示），驱动程序将操作的状态发送回 IO 管理器，后者将状态返回给调用程序。
- en: Every IRP includes an *IRP code*, which tells the recipient driver what IRP
    handler should be used to handle the respective request. [Table 14-1](chapter14.xhtml#tab14-1)
    lists some of the more interesting IRP function codes for our purposes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 IRP 包含一个 *IRP 代码*，该代码告诉接收驱动程序应使用哪个 IRP 处理程序来处理相应的请求。[表 14-1](chapter14.xhtml#tab14-1)
    列出了我们目的相关的一些更有趣的 IRP 功能代码。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 14-1:</samp> <samp class="SANS_Futura_Std_Book_11">IRP
    Codes</samp>
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 14-1：</samp> <samp class="SANS_Futura_Std_Book_11">IRP
    代码</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">IRP code</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Request
    description</samp> |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">IRP 代码</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">请求描述</samp>
    |'
- en: '| --- | --- |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE</samp> | <samp
    class="SANS_Futura_Std_Book_11">Sent to a driver when the requesting thread opens
    a handle to a device or file object, such as when making a call to</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp> |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE</samp> | <samp
    class="SANS_Futura_Std_Book_11">当请求线程打开设备或文件对象的句柄时发送给驱动程序，例如调用</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_WRITE</samp> | <samp
    class="SANS_Futura_Std_Book_11">Sent to a driver when the requester wishes to
    transfer data, such as when writing data to a file</samp> |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_WRITE</samp> | <samp
    class="SANS_Futura_Std_Book_11">当请求者希望传输数据时发送给驱动程序，例如将数据写入文件</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_READ</samp> | <samp
    class="SANS_Futura_Std_Book_11">Sent to a driver when the requester wishes to
    read data, such as from a file</samp> |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_READ</samp> | <samp
    class="SANS_Futura_Std_Book_11">当请求者希望读取数据时发送给驱动程序，例如从文件中读取数据</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_DEVICE_CONTROL</samp>
    | <samp class="SANS_Futura_Std_Book_11">Sent when a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">DeviceIoControl</samp>
    <samp class="SANS_Futura_Std_Book_11">function is called (meaning a user-space
    process is sending a direct control code, or instruction, to a driver)</samp>
    |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_DEVICE_CONTROL</samp>
    | <samp class="SANS_Futura_Std_Book_11">当调用</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">DeviceIoControl</samp>
    <samp class="SANS_Futura_Std_Book_11">函数时发送（意味着一个用户空间进程正在向驱动程序发送直接控制代码或指令）</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_SHUTDOWN</samp> | <samp
    class="SANS_Futura_Std_Book_11">Sent when a system shutdown has been initiated</samp>
    |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_SHUTDOWN</samp> | <samp
    class="SANS_Futura_Std_Book_11">当系统关闭已被启动时发送</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_SYSTEM_CONTROL</samp>
    | <samp class="SANS_Futura_Std_Book_11">Sent when a user-space process requests
    system information via Windows Management Instrumentation (WMI)</samp> |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_SYSTEM_CONTROL</samp>
    | <samp class="SANS_Futura_Std_Book_11">当用户空间进程通过 Windows 管理工具（WMI）请求系统信息时发送</samp>
    |'
- en: 'Each driver installed in the kernel includes a table of IRP handlers called
    the *major function table* (or the *IRP function table*). Major function tables
    contain pointers to the handler code that will handle a particular IRP; this code
    might be located in the driver itself or inside another driver or module. The
    following output shows an IRP function table for the FLTMGR driver:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 每个安装在内核中的驱动都会包括一个 IRP 处理程序表，称为 *主要函数表*（或 *IRP 函数表*）。主要函数表包含指向处理特定 IRP 的处理程序代码的指针；这些代码可能位于驱动程序本身中，或者位于另一个驱动或模块中。以下输出显示了
    FLTMGR 驱动的 IRP 函数表：
- en: '[PRE6]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This output was created with the help of Volatility, a memory forensics and
    analysis tool. Although not covered in this book, memory forensics techniques
    can be great additions to the malware analysis process, especially in the case
    of rootkits. For this specific example, I used the <samp class="SANS_TheSansMonoCd_W5Regular_11">driverirp</samp>
    module in Volatility.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 该输出是借助 Volatility 创建的，Volatility 是一款内存取证和分析工具。尽管本书未涵盖此内容，但内存取证技术可以极大地增强恶意软件分析过程，特别是在处理根套件时。对于这个具体的例子，我使用了
    Volatility 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">driverirp</samp> 模块。
- en: The first column in this output contains the IRP code. The second and third
    columns contain the pointer to the associated IRP handler function and the module
    containing the handler code, respectively. In this case, the driver points to
    handlers it contains.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 该输出的第一列包含 IRP 代码。第二列和第三列分别包含指向相关 IRP 处理程序函数的指针，以及包含处理程序代码的模块。在这个例子中，驱动指向它所包含的处理程序。
- en: 'To intercept, modify, and gain control of IO communication, malicious kernel
    drivers might attempt to hook IRPs. One reason for doing so is to hide and protect
    the malware’s artifacts on the endpoint by intercepting IRP function calls that
    reference those artifacts on disk. The Autochk rootkit (<samp class="SANS_TheSansMonoCd_W5Regular_11">SHA256:
    28924b6329f5410a5cca30f3530a3fb8a97c23c9509a192f2092cbdf139a91d8</samp>) does
    exactly this: it hooks <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE</samp>
    inside the FLTMGR driver to intercept IRPs referencing its malicious files on
    disk (as illustrated in [Figure 14-9](chapter14.xhtml#fig14-9)).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '为了拦截、修改并控制 IO 通信，恶意内核驱动可能尝试挂钩 IRP。这样做的一个原因是通过拦截引用磁盘上恶意文件的 IRP 函数调用来隐藏和保护恶意软件的痕迹。Autochk
    根套件（<samp class="SANS_TheSansMonoCd_W5Regular_11">SHA256: 28924b6329f5410a5cca30f3530a3fb8a97c23c9509a192f2092cbdf139a91d8</samp>）正是这样做的：它在
    FLTMGR 驱动中挂钩 <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE</samp>，以拦截引用磁盘上恶意文件的
    IRP（如 [图 14-9](chapter14.xhtml#fig14-9) 所示）。'
- en: '![](../images/fig14-9.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig14-9.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-9: An IRP hook for
    NtReadFile</samp>'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 14-9：NtReadFile 的 IRP 挂钩</samp>
- en: 'If an application in user space, such as a forensics tool, attempts to access
    this rootkit’s files, the IRP will be handled by the rootkit’s handler code rather
    than by the legitimate handler that would otherwise deal with this request. The
    following Volatility output shows the hooked FLTMGR driver’s IRP function table:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户空间中的应用程序，例如取证工具，尝试访问这个根套件的文件，IRP 将由根套件的处理程序代码来处理，而不是由本应处理此请求的合法处理程序处理。以下是
    Volatility 输出，显示了挂钩的 FLTMGR 驱动的 IRP 函数表：
- en: '[PRE7]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice anything shady? In the first row of the code, <samp class="SANS_TheSansMonoCd_W5Regular_11">FLTMGR.SYS</samp>
    has been replaced with <samp class="SANS_TheSansMonoCd_W5Regular_11">autochk.sys</samp>.
    All <samp class="SANS_TheSansMonoCd_W5Regular_11">MJ_CREATE</samp> IRPs destined
    for the FLTMGR driver will instead be forwarded to the malicious handler code
    inside the rootkit’s driver, <samp class="SANS_TheSansMonoCd_W5Regular_11">autochk.sys!</samp>
    You can read more about some of the techniques of this rootkit at [*https://<wbr>repnz<wbr>.github<wbr>.io<wbr>/posts<wbr>/autochk<wbr>-rootkit<wbr>-analysis<wbr>/*](https://repnz.github.io/posts/autochk-rootkit-analysis/).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到什么可疑的事情了吗？在代码的第一行，<samp class="SANS_TheSansMonoCd_W5Regular_11">FLTMGR.SYS</samp>已被替换为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">autochk.sys</samp>。所有原本应发送给FLTMGR驱动的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">MJ_CREATE</samp> IRP，现在将被转发到rootkit驱动中的恶意处理代码，即<samp
    class="SANS_TheSansMonoCd_W5Regular_11">autochk.sys!</samp>你可以在[*https://<wbr>repnz<wbr>.github<wbr>.io<wbr>/posts<wbr>/autochk<wbr>-rootkit<wbr>-analysis<wbr>/*](https://repnz.github.io/posts/autochk-rootkit-analysis/)阅读有关此rootkit的一些技术细节。
- en: To install an IRP hook, malware authors have a few options. One approach is
    to replace the original handler code pointer value in a victim driver with a pointer
    to malicious handler code. Alternatively, malware could use the inline hooking
    method described previously to overwrite the first few bytes in the legitimate
    handler function with a jump instruction to malicious code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装一个IRP钩子，恶意软件作者有几种选择。一种方法是将受害者驱动中原始处理程序代码指针的值替换为指向恶意处理程序代码的指针。或者，恶意软件可以使用之前描述的内联挂钩方法，通过跳转指令覆盖合法处理函数中的前几个字节，跳转到恶意代码。
- en: Both of these techniques, as well as the other hooking techniques mentioned,
    rely on the delicate task of manipulating kernel objects in memory. As noted earlier,
    however, the techniques discussed in this section aren’t often used in malware
    anymore due to the protections now built into Windows. With this in mind, let’s
    shift to some relatively modern techniques that rootkits might use to circumvent
    these Windows protections, starting with IRP filtering and interception.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种技术以及其他提到的挂钩技术，都依赖于在内存中操控内核对象的精细任务。然而，如前所述，由于Windows现在内置了保护措施，本节讨论的技术在恶意软件中已不常使用。考虑到这一点，让我们转向一些相对现代的技术，rootkit可能会使用这些技术绕过Windows的保护，首先从IRP过滤和拦截开始。
- en: <samp class="SANS_Futura_Std_Bold_B_11">IRP Interception by Filtering</samp>
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">IRP 拦截与过滤</samp>
- en: Rather than crudely hooking kernel drivers to intercept and manipulate IRPs,
    rootkits can register a filter or minifilter driver to do so. Introduced at the
    beginning of this chapter, filter drivers and minifilter drivers can be “attached”
    to a device and added to its driver stack, intercepting IRPs as they are filtered
    down the stack. Let’s go over this process in more detail.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 与粗暴地挂钩内核驱动以拦截和操控IRP不同，rootkit可以注册一个过滤或迷你过滤驱动来实现此功能。如本章开始时所述，过滤驱动和迷你过滤驱动可以“附加”到设备，并被添加到其驱动栈中，拦截通过栈传递的IRP。让我们更详细地了解这一过程。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*Filter drivers (sometimes called* legacy filter drivers*) and minifilter drivers
    are both types of filters, but they operate quite differently. I won’t go into
    the specifics of these two drivers in this book.*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*过滤驱动（有时也称为*遗留过滤驱动*）和迷你过滤驱动是两种过滤类型，但它们的工作方式大不相同。在本书中，我不会详细讲解这两种驱动的具体细节。*'
- en: Each hardware device attached to the system has an associated hierarchical stack
    of drivers that enables communication between the device and the operating system
    (see [Figure 14-10](chapter14.xhtml#fig14-10)).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 每个附加到系统的硬件设备都有一个与之关联的分层驱动栈，用于实现设备与操作系统之间的通信（参见[图 14-10](chapter14.xhtml#fig14-10)）。
- en: '![](../images/fig14-10.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig14-10.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-10: How the IO manager
    communicates with driver stacks</samp>'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 14-10：IO管理器如何与驱动栈通信</samp>
- en: Each driver in the stack performs a specific role and serves as an interface
    between the drivers before and after it in the stack. Additionally, when the IO
    manager sends an IRP to a specific device, the IRP is routed through the device’s
    hierarchical driver stack, passing through each driver in the stack one by one.
    If one of the drivers has a handler for the specific IRP, it takes some sort of
    action on that IRP. The arrows shown in [Figure 14-10](chapter14.xhtml#fig14-10)
    represent communication between drivers in the form of IRPs.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈中的每个驱动程序执行特定角色，并作为堆栈中前后驱动程序之间的接口。此外，当IO管理器将IRP发送到特定设备时，IRP会通过设备的层次化驱动程序堆栈，逐一经过堆栈中的每个驱动程序。如果其中一个驱动程序有一个处理特定IRP的处理程序，它将对该IRP执行某种操作。[图14-10](chapter14.xhtml#fig14-10)中显示的箭头表示驱动程序之间通过IRP进行的通信。
- en: Filter drivers are designed to be inserted into a driver stack to add functionality.
    They can be inserted in various locations (called *altitudes*) in the stack or
    even added all the way to the top of the stack, where they can intercept any and
    all IRPs destined for the driver stack (see [Figure 14-11](chapter14.xhtml#fig14-11)).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '筛选驱动程序旨在插入驱动程序堆栈中以添加功能。它们可以插入堆栈中的不同位置（称为*高度*），甚至可以添加到堆栈的顶部，在那里它们可以拦截所有目的地为驱动程序堆栈的IRP（见[图14-11](chapter14.xhtml#fig14-11)）。  '
- en: '![](../images/fig14-11.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig14-11.jpg)  '
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-11: A filter driver
    added to the top of the driver stack</samp>'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图14-11：添加到驱动程序堆栈顶部的筛选驱动程序</samp>  '
- en: 'Rootkits can register a new filter driver and “insert” it at the top of a driver
    stack, allowing them to see and intercept all inbound IRPs. After intercepting,
    the malware can choose to drop the IRP or modify it. A rootkit might use a filter
    driver this way to protect its own files. For example, it could register a filter
    driver to watch for and intercept IO requests to its own files, either modifying
    the requests or dropping them completely to effectively hide them from investigators
    and analysis tools. EDR and other endpoint defenses sometimes use filter drivers
    for the same reason: to protect their files from malware.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 'Rootkit 可以注册一个新的筛选驱动程序并将其“插入”到驱动程序堆栈的顶部，从而让它们看到并拦截所有传入的IRP。拦截后，恶意软件可以选择丢弃该IRP或修改它。rootkit
    可能会通过这种方式使用筛选驱动程序来保护自己的文件。例如，它可以注册一个筛选驱动程序来监视并拦截对其文件的IO请求，修改请求或完全丢弃它们，从而有效地将其隐藏于调查人员和分析工具之外。EDR
    和其他端点防御有时也会出于相同的原因使用筛选驱动程序：保护其文件免受恶意软件侵害。  '
- en: To implement a filter driver, a rootkit must first load the driver into kernel
    memory (potentially using the techniques from “Rootkit Installation” on [page
    269](chapter14.xhtml#pg_269)). The filter driver must specify which IRP communication
    it cares about by setting up a handler for those IRPs. For instance, if the malware
    is trying to intercept <samp class="SANS_TheSansMonoCd_W5Regular_11">MJ_CREATE</samp>
    IRPs, it must implement this in the filter driver’s IRP function table.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '要实现筛选驱动程序，rootkit 必须首先将驱动程序加载到内核内存中（可能使用“Rootkit 安装”中提到的技术，见[第269页](chapter14.xhtml#pg_269)）。筛选驱动程序必须通过为这些IRP设置处理程序来指定它关心的IRP通信。例如，如果恶意软件试图拦截<samp
    class="SANS_TheSansMonoCd_W5Regular_11">MJ_CREATE</samp> IRP，它必须在筛选驱动程序的IRP功能表中实现这一点。  '
- en: Malware can abuse minifilter drivers by registering one of its own (by calling
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FltRegisterFilter</samp>) or by
    hooking an existing minifilter. Some modern malware has been known to do this.
    When analyzing rootkit driver code, take note of whether the malware is calling
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FltRegisterFilter</samp> to register
    its own minifilter driver. Also notice whether the malware is calling functions
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">FltGetFilterFromName</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FltEnumerateFilters</samp>, or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">FltEnumerateInstances</samp>; it may be
    attempting to enumerate other minifilters on the host, preparing for hooking.
    For more information on how minifilter drivers are implemented in practice, see
    Rahul Dev Tripathi’s article “Storage Device Restriction Using a Minifilter Driver
    Approach” at [*https://<wbr>www<wbr>.codeproject<wbr>.com<wbr>/Articles<wbr>/5341729<wbr>/Storage<wbr>-Device<wbr>-Restriction<wbr>-Using<wbr>-a<wbr>-Minifilter<wbr>-Driv<wbr>*](https://www.codeproject.com/Articles/5341729/Storage-Device-Restriction-Using-a-Minifilter-Driv).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可以通过注册自己的小型过滤器（调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">FltRegisterFilter</samp>）或挂钩现有的小型过滤器来滥用小型过滤器驱动程序。一些现代恶意软件已知会这样做。在分析
    rootkit 驱动程序代码时，注意恶意软件是否调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">FltRegisterFilter</samp>
    来注册自己的小型过滤器驱动程序。还要注意恶意软件是否调用了诸如 <samp class="SANS_TheSansMonoCd_W5Regular_11">FltGetFilterFromName</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">FltEnumerateFilters</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">FltEnumerateInstances</samp>
    等函数；它可能正在尝试枚举主机上的其他小型过滤器，为挂钩做准备。有关小型过滤器驱动程序如何在实践中实现的更多信息，请参见 Rahul Dev Tripathi
    的文章《通过小型过滤器驱动程序方法限制存储设备》：[*https://<wbr>www<wbr>.codeproject<wbr>.com<wbr>/Articles<wbr>/5341729<wbr>/Storage<wbr>-Device<wbr>-Restriction<wbr>-Using<wbr>-a<wbr>-Minifilter<wbr>-Driv<wbr>*](https://www.codeproject.com/Articles/5341729/Storage-Device-Restriction-Using-a-Minifilter-Driv)。
- en: Legacy filter drivers are installed differently. The specifics are outside the
    scope of this book, but you can learn more from the filesystem driver tutorial
    at [*https://<wbr>www<wbr>.codeproject<wbr>.com<wbr>/Articles<wbr>/43586<wbr>/File<wbr>-System<wbr>-Filter<wbr>-Driver<wbr>-Tutorial*](https://www.codeproject.com/Articles/43586/File-System-Filter-Driver-Tutorial)
    and from Rotem Salinas’s great write-up “Fantastic Rootkits and Where to Find
    Them” at [*https://<wbr>www<wbr>.cyberark<wbr>.com<wbr>/resources<wbr>/threat<wbr>-research<wbr>-blog<wbr>/fantastic<wbr>-rootkits<wbr>-and<wbr>-where<wbr>-to<wbr>-find<wbr>-them<wbr>-part<wbr>-1*](https://www.cyberark.com/resources/threat-research-blog/fantastic-rootkits-and-where-to-find-them-part-1).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的过滤器驱动程序安装方式不同。具体细节超出了本书的范围，但你可以通过文件系统驱动程序教程了解更多：[*https://<wbr>www<wbr>.codeproject<wbr>.com<wbr>/Articles<wbr>/43586<wbr>/File<wbr>-System<wbr>-Filter<wbr>-Driver<wbr>-Tutorial*](https://www.codeproject.com/Articles/43586/File-System-Filter-Driver-Tutorial)，以及
    Rotem Salinas 的精彩文章《奇妙的 Rootkits 及其发现方法》：[*https://<wbr>www<wbr>.cyberark<wbr>.com<wbr>/resources<wbr>/threat<wbr>-research<wbr>-blog<wbr>/fantastic<wbr>-rootkits<wbr>-and<wbr>-where<wbr>-to<wbr>-find<wbr>-them<wbr>-part<wbr>-1*](https://www.cyberark.com/resources/threat-research-blog/fantastic-rootkits-and-where-to-find-them-part-1)。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Abusing Kernel Callbacks</samp>
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">滥用内核回调</samp>
- en: Abusing kernel callbacks is another more modern approach used by some rootkits.
    To recap the discussion in [Chapter 13](chapter13.xhtml), a callback allows a
    kernel module to be notified of system events so that it can take some sort of
    action when they happen. For example, a driver may need to know when a process
    executed in user space, so it would implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">PsSetCreateProcessNotifyRoutine</samp>
    callback (as in the case of some EDR products). Once this callback is registered
    with the driver, the driver will receive a notification in the form of an IRP
    when a process is created on the system, giving the driver the chance to execute
    its callback code for that event.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 滥用内核回调是一些 rootkit 使用的另一种现代方法。回顾 [第 13 章](chapter13.xhtml) 中的讨论，回调允许内核模块在发生系统事件时接收到通知，以便它可以采取某种行动。例如，驱动程序可能需要知道何时在用户空间执行了某个进程，因此它会实现
    <samp class="SANS_TheSansMonoCd_W5Regular_11">PsSetCreateProcessNotifyRoutine</samp>
    回调（例如某些 EDR 产品的情况）。一旦此回调在驱动程序中注册，驱动程序将在系统上创建进程时收到 IRP 形式的通知，驱动程序有机会为该事件执行其回调代码。
- en: The creator of the process is responsible for sending out a notification to
    all registered drivers. So, when a process spawns a child process, for example,
    the calling process sends out the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessNotifyRoutine</samp>
    notification to all registered drivers. When a driver receives the notification,
    the driver’s callback code will be executed.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 进程的创建者负责向所有注册的驱动程序发送通知。因此，当一个进程生成一个子进程时，调用进程会向所有注册的驱动程序发送 <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessNotifyRoutine</samp>
    通知。当驱动程序收到通知时，驱动程序的回调代码将被执行。
- en: 'A rootkit can also use callbacks if it wants to be notified of specific system
    events. Once an event occurs, such as a registry modification or filesystem operation,
    the rootkit’s malicious driver(s) will be notified, and the callback code will
    be executed. The following output shows a listing of registered callback routines
    on an infected system:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 根套件（rootkit）如果希望接收特定系统事件的通知，也可以使用回调。一旦发生事件，比如注册表修改或文件系统操作，根套件的恶意驱动程序将会收到通知，回调代码将被执行。以下输出显示了在被感染系统上注册的回调例程：
- en: '[PRE8]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this output, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp>
    column shows the callback type, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Callback</samp>
    column shows the address of the callback handler, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Module</samp>
    column shows the kernel module that registered the callback. Most of these are
    normal, legitimate callbacks. However, there’s a suspicious module name (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">comp.sys</samp>) that appears to have
    registered an interesting callback (<samp class="SANS_TheSansMonoCd_W5Regular_11">PsSetCreateThreadNotifyRoutine</samp>).
    As mentioned previously, this callback will trigger when a new thread is created
    by a process in user space. Also note that the address of the callback code is
    much different from those of the legitimate callbacks (<samp class="SANS_TheSansMonoCd_W5Regular_11">0xfffff6050d26ccc0</samp>
    versus <samp class="SANS_TheSansMonoCd_W5Regular_11">0xfffff80af3afb210</samp>,
    for example).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在此输出中，<samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp> 列显示回调类型，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Callback</samp> 列显示回调处理程序的地址，<samp class="SANS_TheSansMonoCd_W5Regular_11">Module</samp>
    列显示注册回调的内核模块。大多数这些都是正常、合法的回调。然而，有一个可疑的模块名称（<samp class="SANS_TheSansMonoCd_W5Regular_11">comp.sys</samp>），它似乎注册了一个有趣的回调（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">PsSetCreateThreadNotifyRoutine</samp>）。如前所述，当用户空间中的进程创建新线程时，这个回调将被触发。还需要注意的是，回调代码的地址与合法回调的地址有很大不同（例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0xfffff6050d26ccc0</samp> 与 <samp class="SANS_TheSansMonoCd_W5Regular_11">0xfffff80af3afb210</samp>）。
- en: 'A similar approach was taken by the DirtyMoe rootkit. DirtyMoe used kernel
    callbacks to silently inject malicious code into newly created threads in user
    space. You can read more about it in Martin Chlumecký’s article “DirtyMoe: Rootkit
    Driver” at [*https://<wbr>decoded<wbr>.avast<wbr>.io<wbr>/martinchlumecky<wbr>/dirtymoe<wbr>-rootkit<wbr>-driver<wbr>/*](https://decoded.avast.io/martinchlumecky/dirtymoe-rootkit-driver/).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: DirtyMoe 根套件采用了类似的方法。DirtyMoe 使用内核回调将恶意代码悄悄注入到用户空间中新创建的线程中。你可以在 Martin Chlumecký
    的文章《DirtyMoe：Rootkit 驱动程序》中阅读更多内容，文章链接为 [*https://<wbr>decoded<wbr>.avast<wbr>.io<wbr>/martinchlumecky<wbr>/dirtymoe<wbr>-rootkit<wbr>-driver<wbr>/*](https://decoded.avast.io/martinchlumecky/dirtymoe-rootkit-driver/)。
- en: 'The infamous Necurs rootkit, which originated in 2014, sets up a registry callback
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">CmRegisterCallback</samp>), a type
    of filter driver callback that will notify it of any access to its registry service
    key. If an investigator or program attempts to access this registry key, the attempt
    fails. This simplified pseudocode example shows how a malicious driver could register
    and abuse a registry callback:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 恶名昭著的 Necurs 根套件起源于 2014 年，它设置了一个注册表回调（<samp class="SANS_TheSansMonoCd_W5Regular_11">CmRegisterCallback</samp>），这是一种过滤驱动程序回调，能够通知它访问其注册表服务键的任何行为。如果调查员或程序尝试访问此注册表键，访问将失败。以下是一个简化的伪代码示例，展示了恶意驱动程序如何注册并滥用注册表回调：
- en: '[PRE9]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This malware code first defines the callback function code (<samp class="SANS_TheSansMonoCd_W5Regular_11">RegistryCallback</samp>)
    that will be executed once the callback occurs ❶. Later in the code, the rootkit
    defines the registry callback, passing the callback name (<samp class="SANS_TheSansMonoCd_W5Regular_11">RegistryCallback</samp>)
    and also the context, which is a pointer to a structure containing information
    about the function call ❺. Since this callback will be triggered by programs interacting
    with the Windows registry, this context structure contains important information
    like the particular registry action (open key, write data, and so on) and the
    target of the action (or the specific registry key or value affected).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这段恶意代码首先定义了回调函数代码（<samp class="SANS_TheSansMonoCd_W5Regular_11">RegistryCallback</samp>），一旦回调发生，就会执行此函数❶。稍后，在代码中，rootkit
    定义了注册表回调，传递回调名称（<samp class="SANS_TheSansMonoCd_W5Regular_11">RegistryCallback</samp>）以及上下文，它是一个指向包含有关函数调用信息的结构体的指针❺。由于此回调将由与
    Windows 注册表交互的程序触发，因此此上下文结构包含重要信息，如特定的注册表操作（打开键、写数据等）和操作目标（或受影响的特定注册表键或值）。
- en: When a program performs a registry action, such as invoking <samp class="SANS_TheSansMonoCd_W5Regular_11">RegOpenKeyExA</samp>,
    the rootkit’s malicious callback code will be executed. The rootkit checks to
    see if the registry event is equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">CM_EVENT_REGISTRY_KEY_OPEN</samp>
    (indicating that a registry key is being opened) ❷ and then checks to see whether
    the registry key being acted upon is <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\evil</samp>
    (the key used by the malware to establish persistence on the host) ❸. If the key
    name matches, the rootkit attempts to prevent the program or investigator from
    inspecting that registry key ❹. It can do so by temporarily deleting its own registry
    key and re-creating it later, or by injecting malicious code into the calling
    process and hooking into the function call to prevent the call from succeeding,
    among other methods.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个程序执行注册表操作时，例如调用<samp class="SANS_TheSansMonoCd_W5Regular_11">RegOpenKeyExA</samp>，rootkit
    的恶意回调代码将被执行。rootkit 会检查注册表事件是否等于<samp class="SANS_TheSansMonoCd_W5Regular_11">CM_EVENT_REGISTRY_KEY_OPEN</samp>（表示正在打开注册表键）❷，然后检查正在操作的注册表键是否是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\evil</samp>（恶意软件用于在主机上建立持久性的注册表键）❸。如果键名匹配，rootkit
    会尝试阻止程序或调查者检查该注册表键❹。它可以通过暂时删除自己的注册表键并稍后重新创建它，或通过将恶意代码注入调用进程并挂钩该函数调用来防止调用成功，等等方法来做到这一点。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">CmRegisterCallback</samp>
    is now obsolete; the modern version of this function is <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">CmRegisterCallbackEx</samp>.
    The principles of the function remain the same, however.*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">CmRegisterCallback</samp>
    现在已过时；该函数的现代版本是 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">CmRegisterCallbackEx</samp>。然而，函数的原理保持不变。*'
- en: 'You’ve seen quite a bit about how rootkits operate at a very low level in the
    operating system to manipulate kernel memory, install hooks, and configure callbacks,
    allowing them to remain hidden and evade defenses. Now we’ll look briefly at a
    variant of malware that delves even deeper: bootkits.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了一些关于 rootkit 如何在操作系统中以非常低级的方式操作，操控内核内存、安装钩子并配置回调，从而保持隐藏并逃避防御的内容。现在我们简要地看一下更深层次的恶意软件变种：引导程序。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Bootkits</samp>
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">引导程序</samp>
- en: A *bootkit* is a piece of malware designed to hide inside the system firmware,
    compromising the entire boot process. If a bootkit is able to tamper with the
    operating system boot-up, injecting itself into this process chain, it can effectively
    achieve all the benefits of a rootkit while also surviving system rebuilds.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*引导程序*是一种恶意软件，旨在隐藏在系统固件中，破坏整个启动过程。如果引导程序能够篡改操作系统的启动过程，将自身注入此过程链中，它可以有效地实现 rootkit
    的所有功能，同时还能在系统重建后生存下来。'
- en: One specific type of bootkit is a UEFI bootkit (sometimes called a UEFI rootkit),
    which operates within the *Unified Extensible Firmware Interface (UEFI)*, a specialized
    storage chip attached to a system’s motherboard. The UEFI contains low-level software
    that executes before the operating system boots up, providing an interface between
    the operating system kernel and the various firmware devices installed in the
    system. Given that the UEFI boots before the operating system, malware that can
    embed itself within the UEFI chip will remain undetected for longer periods of
    time and can even survive operating system reinstallations and rebuilds.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一种特定类型的启动劫持程序是UEFI启动劫持程序（有时称为UEFI rootkit），它在*统一可扩展固件接口（UEFI）*内运行，UEFI是附加到系统主板的一个专用存储芯片。UEFI包含在操作系统启动之前执行的低级软件，为操作系统内核与系统中安装的各种固件设备提供接口。由于UEFI在操作系统启动之前就已运行，因此能够嵌入到UEFI芯片中的恶意软件将在更长时间内保持不被检测到，甚至可以在操作系统重装和重建后仍然存活。
- en: 'One notable example of a UEFI bootkit is CosmicStrand. In July 2022, researchers
    from Kaspersky reported that this UEFI bootkit dug itself into systems, with the
    entry vector possibly being a hardware vulnerability. The bootkit affected various
    systems with certain models of Asus and Gigabyte motherboards and took control
    of the Windows operating system kernel loader, injecting malicious code into kernel
    memory. For more about this threat, see the article “CosmicStrand: The Discovery
    of a Sophisticated UEFI Firmware Rootkit,” from Kaspersky’s Global Research &
    Analysis Team (GreAT) at [*https://<wbr>securelist<wbr>.com<wbr>/cosmicstrand<wbr>-uefi<wbr>-firmware<wbr>-rootkit<wbr>/106973<wbr>/*](https://securelist.com/cosmicstrand-uefi-firmware-rootkit/106973/).'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一个显著的UEFI启动劫持程序例子是CosmicStrand。2022年7月，卡巴斯基的研究人员报告称，这个UEFI启动劫持程序深入系统，入侵途径可能是硬件漏洞。该启动劫持程序影响了某些型号的华硕和技嘉主板的系统，并控制了Windows操作系统内核加载程序，将恶意代码注入到内核内存中。有关这一威胁的更多信息，请参见卡巴斯基全球研究与分析团队（GreAT）的文章《CosmicStrand：一款复杂的UEFI固件Rootkit的发现》，文章链接是
    [*https://<wbr>securelist<wbr>.com<wbr>/cosmicstrand<wbr>-uefi<wbr>-firmware<wbr>-rootkit<wbr>/106973<wbr>/*](https://securelist.com/cosmicstrand-uefi-firmware-rootkit/106973/)。
- en: Another example is the MosaicRegressor framework, which was also discovered
    by Kaspersky. It included a UEFI rootkit component that hijacked the Windows boot
    process to drop an executable to disk that silently executes when Windows boots
    up. If this executable is removed from the disk, it will be rewritten to disk
    upon reboot of the system, providing a high degree of persistence. You can read
    the article from Kaspersky about MosaicRegressor, “Lurking in the Shadows of UEFI,”
    by Mark Lechtik, Igor Kuznetsov, and Yury Parshin, at [*https://<wbr>securelist<wbr>.com<wbr>/mosaicregressor<wbr>/98849<wbr>/*](https://securelist.com/mosaicregressor/98849/).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是MosaicRegressor框架，该框架也被卡巴斯基发现。它包含一个UEFI rootkit组件，通过劫持Windows启动过程，在磁盘上放置一个可执行文件，该文件在Windows启动时悄悄执行。如果从磁盘中移除此可执行文件，它将在系统重启时重新写入磁盘，从而提供高度的持久性。你可以阅读卡巴斯基关于MosaicRegressor的文章《潜伏在UEFI阴影中的MosaicRegressor》，由Mark
    Lechtik、Igor Kuznetsov和Yury Parshin撰写，文章地址是 [*https://<wbr>securelist<wbr>.com<wbr>/mosaicregressor<wbr>/98849<wbr>/*](https://securelist.com/mosaicregressor/98849/)。
- en: Compared with traditional user-space malware, bootkits are relatively rare.
    However, they might not be as rare as they’re perceived to be. Because of their
    low-level access to the host, they can survive and persist undetected even in
    well-defended environments. If we can’t detect this type of malware, we don’t
    know it exists, which leads us to the unsettling conclusion that this type of
    malware could be embedded in more systems than we know. However, all is not lost.
    Let’s wrap up this chapter by discussing some of the built-in Windows defenses
    against rootkits and bootkits.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的用户空间恶意软件相比，启动劫持程序（bootkits）相对较少见。然而，它们可能并不像人们所认为的那样罕见。由于它们能够以低级别访问主机，即使在防御良好的环境中，它们也能在不被察觉的情况下存活并持久存在。如果我们无法检测到这种类型的恶意软件，我们就无法知道它的存在，这让我们得出一个令人不安的结论：这种恶意软件可能嵌入了比我们知道的更多的系统中。然而，并非一切都已失去。让我们通过讨论一些Windows内置的防御措施来结束这一章，来应对rootkits和bootkits。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Defenses Against Rootkits</samp>
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">Rootkit防御</samp>
- en: Microsoft has implemented several defenses against rootkits, two of the most
    important being *PatchGuard* and *Driver Signature Enforcement (DSE)*. Introduced
    in 2005 for x64 versions of Windows XP, PatchGuard, which is also known as *Kernel
    Patch Protection (KPP)*, mitigates many of the rootkit techniques described earlier,
    such as SSDT and IDT hooking and many forms of DKOM. PatchGuard works by periodically
    verifying the integrity of kernel memory structures to test whether they’ve been
    modified. If PatchGuard detects that one of these structures has been modified,
    it forces a crash of the kernel, which has the result shown in [Figure 14-12](chapter14.xhtml#fig14-12).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 微软已经实施了多种防御措施来对抗根套件，其中最重要的两项是*PatchGuard*和*驱动签名强制(DSE)*。PatchGuard于2005年为Windows
    XP的x64版本推出，也被称为*内核补丁保护(KPP)*，它缓解了前面描述的许多根套件技术，例如SSDT和IDT钩子以及多种形式的DKOM。PatchGuard通过定期验证内核内存结构的完整性来测试它们是否被修改。如果PatchGuard检测到其中一个结构被修改，它会强制内核崩溃，结果如[图14-12](chapter14.xhtml#fig14-12)所示。
- en: '![](../images/fig14-12.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig14-12.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-12: A kernel security
    check crash caused by PatchGuard</samp>'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图14-12: 由PatchGuard引起的内核安全检查崩溃</samp>'
- en: PatchGuard isn’t impervious to circumvention, however. Since it scans kernel
    memory periodically, if these checks are timed properly, malware could very quickly
    tamper with kernel memory and then revert to a “clean” state before PatchGuard
    executes its integrity check. To initiate this check, the operating system calls
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">KeBugCheckEx</samp> kernel API
    function, which certain malware has been known to hook to prevent the kernel integrity
    check from successfully executing. There have also been several issues with malware
    exploiting PatchGuard and other related components. One example of such malware
    is GhostHook, which exploited a vulnerability in the way Windows implements a
    certain low-level Intel API called Intel Processor Trace, potentially allowing
    malware to fly under PatchGuard’s radar. This attack technique is quite complex,
    so we won’t go into the details here, but you can read more about it in Kasif
    Dekel’s post, “GhostHook—Bypassing PatchGuard with Processor Trace Based Hooking,”
    at [*https://<wbr>www<wbr>.cyberark<wbr>.com<wbr>/resources<wbr>/threat<wbr>-research<wbr>-blog<wbr>/ghosthook<wbr>-bypassing<wbr>-patchguard<wbr>-with<wbr>-processor<wbr>-trace<wbr>-based<wbr>-hooking*](https://www.cyberark.com/resources/threat-research-blog/ghosthook-bypassing-patchguard-with-processor-trace-based-hooking).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，PatchGuard并非不可绕过。由于它定期扫描内核内存，如果这些检查的时机恰当，恶意软件可以非常快速地篡改内核内存，然后在PatchGuard执行完整性检查之前恢复到“干净”状态。为了启动此检查，操作系统调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">KeBugCheckEx</samp>内核API函数，已知某些恶意软件会劫持此函数，防止内核完整性检查成功执行。还存在一些恶意软件利用PatchGuard和其他相关组件的漏洞。例如，GhostHook恶意软件利用了Windows实现某种低级Intel
    API——Intel Processor Trace的漏洞，可能允许恶意软件绕过PatchGuard的监测。这种攻击技术相当复杂，因此我们在此不深入探讨，但你可以在Kasif
    Dekel的文章《GhostHook——利用处理器跟踪钩子绕过PatchGuard》中阅读更多内容，网址为[*https://<wbr>www<wbr>.cyberark<wbr>.com<wbr>/resources<wbr>/threat<wbr>-research<wbr>-blog<wbr>/ghosthook<wbr>-bypassing<wbr>-patchguard<wbr>-with<wbr>-processor<wbr>-trace<wbr>-based<wbr>-hooking*](https://www.cyberark.com/resources/threat-research-blog/ghosthook-bypassing-patchguard-with-processor-trace-based-hooking)。
- en: Two other relatively recent examples of malware that evade PatchGuard are InfinityHook
    ([*https://<wbr>github<wbr>.com<wbr>/everdox<wbr>/InfinityHook*](https://github.com/everdox/InfinityHook)),
    which abuses a kernel API called <samp class="SANS_TheSansMonoCd_W5Regular_11">NtTraceEvent</samp>,
    and ByePg ([*https://<wbr>github<wbr>.com<wbr>/can1357<wbr>/ByePg*](https://github.com/can1357/ByePg)),
    which hijacks a kernel structure called the <samp class="SANS_TheSansMonoCd_W5Regular_11">HalPrivateDispatchTable</samp>.
    Both of these circumvent PatchGuard in different ways. Note, however, that Microsoft
    has been quick to patch some of these known vulnerabilities in PatchGuard, forcing
    malware authors to adapt.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个相对较新的逃避PatchGuard的恶意软件实例是InfinityHook（[*https://<wbr>github<wbr>.com<wbr>/everdox<wbr>/InfinityHook*](https://github.com/everdox/InfinityHook)），它滥用一个名为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtTraceEvent</samp>的内核API，以及ByePg（[*https://<wbr>github<wbr>.com<wbr>/can1357<wbr>/ByePg*](https://github.com/can1357/ByePg)），它劫持一个名为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">HalPrivateDispatchTable</samp>的内核结构。它们以不同的方式绕过PatchGuard。然而，值得注意的是，微软已经迅速修补了PatchGuard中一些已知的漏洞，迫使恶意软件作者做出适应。
- en: As mentioned at the beginning of this section, another security control Microsoft
    has implemented is Driver Signature Enforcement (DSE), sometimes called *digital
    signature enforcement*, which has been released for Windows Vista (x64) and more
    recent versions. DSE ensures that only pre-verified (signed) drivers are allowed
    to be loaded into kernel memory. In theory, legitimate drivers will be permitted,
    while suspicious, unsigned drivers will be prevented from loading. You read earlier
    in the chapter how malware can circumvent this control by using a malicious kernel
    driver signed with a legitimate certificate or by using BYOVD techniques. Microsoft
    recommends dealing with this problem by using *blocklists* of known vulnerable
    drivers. If a driver is reported to be vulnerable or is actively being misused,
    Microsoft adds it to the blocklist, which prevents it from being installed later.
    You can enforce this feature by enabling the “Microsoft Vulnerable Driver Blocklist”
    security option in later versions of Windows. The primary concerns with this control
    are that some legitimate drivers may be prevented from loading and that it protects
    only against known malicious drivers.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本节开头所提到的，微软实施的另一个安全控制是驱动程序签名强制（DSE），有时称为*数字签名强制*，该功能已在 Windows Vista（x64）及更高版本中发布。DSE
    确保只有经过预验证（已签名）的驱动程序才能被加载到内核内存中。理论上，合法的驱动程序将被允许加载，而可疑的未签名驱动程序则会被阻止加载。你在本章前面阅读到过，恶意软件可以通过使用带有合法证书签名的恶意内核驱动程序或使用
    BYOVD 技术来绕过这一控制。微软建议通过使用*黑名单*已知的易受攻击驱动程序来解决这个问题。如果某个驱动程序被报告为易受攻击或正在被恶意利用，微软会将其加入黑名单，从而防止其后续安装。你可以通过在
    Windows 的较新版本中启用“Microsoft 易受攻击驱动程序黑名单”安全选项来强制执行此功能。这个控制的主要问题是，某些合法驱动程序可能会被阻止加载，而且它仅能防御已知的恶意驱动程序。
- en: Finally, *early launch anti-malware (ELAM)* is a feature of some endpoint defense
    software that protects the Windows boot process. ELAM is responsible for loading
    anti-malware kernel components prior to other third-party components. This ensures
    that the anti-malware is properly loaded and running before rootkits or any other
    persistent malware have the opportunity to load and execute. ELAM can be a good
    defense against rootkits. However, as ELAM drivers aren’t loaded until later stages
    in the boot process, ELAM alone might not prevent loading of bootkits.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*早期启动反恶意软件（ELAM）*是一些终端防御软件的功能，旨在保护 Windows 启动过程。ELAM 负责在其他第三方组件之前加载反恶意软件内核组件。这确保了反恶意软件在根套件或其他持久性恶意软件有机会加载和执行之前，能够正确加载并运行。ELAM
    可以有效防御根套件。然而，由于 ELAM 驱动程序直到启动过程的后期阶段才会加载，单靠 ELAM 可能无法防止启动病毒的加载。
- en: For defense against bootkits and UEFI rootkits, you can enable *Secure Boot*.
    Available on most modern hardware, Secure Boot prevents malicious code from hijacking
    the Windows boot process. Upon boot-up, Secure Boot verifies the integrity of
    UEFI firmware drivers and the operating system itself before allowing the system
    to fully boot. This provides a layer of protection in the event malware has embedded
    itself in a UEFI chip. Secure Boot is optional in most versions of Windows, but
    it’s required in Windows 11\. As with all security controls, however, various
    implementations of Secure Boot have vulnerabilities that could be exploited by
    malware. Researchers from Eclypsium ([*https://<wbr>eclypsium<wbr>.com*](https://eclypsium.com))
    reported on some of these vulnerabilities in 2020 and 2022, for example.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防御启动病毒和 UEFI 根套件，你可以启用*安全启动*。安全启动可在大多数现代硬件上使用，防止恶意代码劫持 Windows 启动过程。在启动时，安全启动会验证
    UEFI 固件驱动程序和操作系统本身的完整性，然后才允许系统完全启动。如果恶意软件已经嵌入 UEFI 芯片中，这为系统提供了一层保护。大多数版本的 Windows
    中，安全启动是可选的，但在 Windows 11 中是必须启用的。然而，像所有安全控制一样，安全启动的不同实现方式可能存在漏洞，恶意软件可能会利用这些漏洞。Eclypsium
    的研究人员（[*https://<wbr>eclypsium<wbr>.com*](https://eclypsium.com)）在 2020 年和 2022
    年报道了其中的一些漏洞。
- en: As a final note, many Windows rootkit protections, such as PatchGuard and DSE,
    are for x64 (64-bit) versions of Windows only. This leaves x86 (32-bit) versions
    of Windows potentially exposed to a host of dangerous low-level malware. Fortunately,
    precisely because these security features aren’t enabled in x86 mode, EDR and
    anti-malware can use these same techniques for good, to monitor and protect the
    endpoint.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后需要注意的是，许多 Windows 根套件保护措施，如 PatchGuard 和 DSE，仅适用于 x64（64 位）版本的 Windows。这使得
    x86（32 位）版本的 Windows 可能暴露于一系列危险的低级恶意软件之中。幸运的是，正因为这些安全特性在 x86 模式下未启用，EDR 和反恶意软件可以利用这些相同的技术进行保护，监控并保护终端。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: 'This chapter covered the fundamentals of rootkits: how kernel modules work,
    how malware installs malicious modules, and how threat actors bypass protections
    such as signed driver enforcement. We discussed some common rootkit techniques
    such as DKOM, kernel hooking, IRP interception, and kernel callback abuse. You
    were introduced to bootkits and also saw how kernel-space malware can bypass built-in
    Windows protection mechanisms like PatchGuard. This chapter has only scratched
    the surface of rootkits and kernel manipulation techniques, however, so if you’re
    interested in learning more, I encourage you to review [Appendix C](appendix-C.xhtml)
    for more resources. In the next chapter, we’ll discuss how modern malware evades
    endpoint defenses and investigators by leveraging “fileless” and anti- forensics
    techniques.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了rootkit的基础知识：内核模块的工作原理、恶意软件如何安装恶意模块，以及威胁行为者如何绕过如签名驱动程序强制执行等保护措施。我们讨论了一些常见的rootkit技术，如DKOM、内核钩子、IRP拦截和内核回调滥用。你还了解了bootkit，并看到内核空间恶意软件如何绕过Windows内建的保护机制，如PatchGuard。本章仅仅触及了rootkit和内核操作技术的皮毛，如果你有兴趣深入了解，建议你查看[附录C](appendix-C.xhtml)以获取更多资源。在下一章中，我们将讨论现代恶意软件如何通过利用“无文件”技术和反取证技术，避开端点防御和调查人员的监测。
