- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">14</samp> <samp class="SANS_Dogma_OT_Bold_B_11">INTRODUCTION
    TO ROOTKITS</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">14</samp> <samp class="SANS_Dogma_OT_Bold_B_11">ROOTKIT介绍</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: '*Rootkits* are malware variants that specialize in hiding their presence on
    a host by first obtaining low-level access to the victim system. The name *rootkit*
    originates from Unix, where the *root* user has the highest level of privileges
    the system allows. Rootkits use several evasion methods, such as intercepting
    and modifying communication between kernel and user space and directly tampering
    with data structures in kernel memory, to hide from endpoint defenses and investigation
    tools.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*Rootkit* 是一种恶意软件变种，通过首先获得受害系统的低级访问权限，专门隐藏自己在主机上的存在。*Rootkit* 这个名称源自 Unix 系统，其中
    *root* 用户拥有系统允许的最高权限。Rootkit 使用多种规避方法，例如拦截和修改内核与用户空间之间的通信，直接篡改内核内存中的数据结构，以躲避终端防御和调查工具。'
- en: This chapter provides an introductory overview of kernel-based rootkits and
    some of the techniques they use to evade defenses and manipulate a system. While
    not an exhaustive resource on rootkits or rootkit analysis, this chapter covers
    some of the tactics to be on the lookout for when you’re investigating low-level
    malware.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了基于内核的 rootkit 及其规避防御和操控系统的一些技术的简介。虽然本章不是 rootkit 或 rootkit 分析的详尽资源，但它涵盖了在调查低级恶意软件时需要警惕的一些战术。
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Rootkit Fundamentals</samp>'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">Rootkit 基础</samp>'
- en: 'There are many reasons why a malware author might use rootkit components:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者使用 rootkit 组件的原因有很多：
- en: '**Persistence and survivability**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**持久性和生存能力**'
- en: Since rootkits exist in kernel space and have low-level system access, they
    can persist after reboots and in strong, well-defended environments. Bootkits,
    an advanced form of rootkit we’ll discuss later in the chapter, reside at the
    firmware layer and therefore have even greater persistence.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 rootkit 存在于内核空间并具有低级系统访问权限，它们在重启后以及在强大的、防御良好的环境中依然能保持存在。Bootkit 是一种更先进的 rootkit
    形式，稍后我们将在本章讨论，它驻留在固件层，因此具有更强的持久性。
- en: '**Defense circumvention**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**防御规避**'
- en: Some rootkits actively tamper with and blind endpoint defenses such as EDR and
    anti-malware. Such rootkits can also hide and protect their files and processes
    from investigators by redirecting function calls, for example.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 rootkit 会积极篡改并盲目绕过终端防御措施，例如 EDR 和反恶意软件。这类 rootkit 还可以通过重定向函数调用等方式，隐藏和保护其文件和进程，避免调查人员发现。
- en: '**Low-level access to devices and drivers**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**对设备和驱动程序的低级访问**'
- en: Some rootkits intercept requests and commands to and from kernel drivers and
    hardware. One example is Moriya (see the May 2021 article “Operation TunnelSnake”
    at [*https://<wbr>securelist<wbr>.com<wbr>/operation<wbr>-tunnelsnake<wbr>-and<wbr>-moriya<wbr>-rootkit<wbr>/101831<wbr>/*](https://securelist.com/operation-tunnelsnake-and-moriya-rootkit/101831/)),
    which intercepts, manipulates, and hides network traffic to and from the infected
    host.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 rootkit 拦截与内核驱动程序和硬件之间的请求和命令。例如，Moriya 就是其中之一（请参阅 2021年5月的文章“Operation TunnelSnake”
    [*https://<wbr>securelist<wbr>.com<wbr>/operation<wbr>-tunnelsnake<wbr>-and<wbr>-moriya<wbr>-rootkit<wbr>/101831<wbr>/*](https://securelist.com/operation-tunnelsnake-and-moriya-rootkit/101831/)），它拦截、操控并隐藏与受感染主机之间的网络流量。
- en: Because rootkits reside in kernel space and work by manipulating kernel elements,
    let’s take a closer look at what these components are before discussing how rootkits
    take advantage of them.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 rootkit 存在于内核空间，并通过操控内核元素工作，在讨论 rootkit 如何利用这些元素之前，我们先来更详细地了解这些组件是什么。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Kernel Modules and
    Drivers</samp>
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">内核模块和驱动程序</samp>
- en: '*Kernel modules* are binary files containing code and data that extend the
    kernel’s functionalities. They can be loaded at system boot-up or on demand. *Kernel
    drivers* are a specific type of kernel module that interact with system hardware.
    There are different types of kernel drivers:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*内核模块* 是包含代码和数据的二进制文件，用于扩展内核的功能。它们可以在系统启动时或按需加载。*内核驱动程序* 是一种特定类型的内核模块，与系统硬件进行交互。内核驱动程序有不同的类型：'
- en: '**Device drivers**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**设备驱动程序**'
- en: Perhaps the most common type of kernel driver, device drivers provide an interface
    between Windows and the underlying hardware devices of the system, such as keyboards,
    mice, and printers. They interact with system hardware either directly or indirectly.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 也许是最常见的内核驱动程序类型，设备驱动程序为 Windows 与系统底层硬件设备之间提供接口，例如键盘、鼠标和打印机。它们直接或间接地与系统硬件进行交互。
- en: '**Filter drivers**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**过滤驱动程序**'
- en: As their name suggests, filter drivers “filter” IO communication destined for
    other drivers, intercepting and potentially modifying it. These drivers add functionality
    to other drivers or to the system at large, and they also enable capabilities
    such as logging and monitoring. Some malicious actors load filter drivers in the
    kernel to take advantage of these benefits, as you’ll see later.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如它们的名字所示，过滤驱动程序“过滤”目标为其他驱动程序的 IO 通信，拦截并可能修改它。这些驱动程序为其他驱动程序或整个系统添加功能，同时还启用日志记录和监控等能力。一些恶意行为者将过滤驱动程序加载到内核中，以利用这些功能，正如你稍后将看到的那样。
- en: '**Minifilter drivers**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**迷你过滤驱动程序**'
- en: Similar to filter drivers, minifilter drivers filter IO operations and were
    introduced in more modern versions of Windows to improve performance and simplify
    development and compatibility. These drivers can also be abused by malicious actors.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于过滤驱动程序，迷你过滤驱动程序用于过滤 IO 操作，并且在 Windows 的较新版本中被引入，以提高性能并简化开发和兼容性。这些驱动程序也可能被恶意行为者滥用。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*Even though all kernel drivers are modules, not all kernel modules are drivers.
    However, for simplicity’s sake, I’ll use the terms* module *and* driver *interchangeably
    in this chapter.*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽管所有内核驱动程序都是模块，但并非所有内核模块都是驱动程序。不过，为了简便起见，本章中我将*模块*和*驱动程序*这两个术语交替使用。*'
- en: You can view loaded kernel modules in Windows using a Process Manager–like tool
    such as Process Hacker, as shown in [Figure 14-1](chapter14.xhtml#fig14-1).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用类似 Process Manager 的工具，如 Process Hacker，查看 Windows 中加载的内核模块，如[图 14-1](chapter14.xhtml#fig14-1)所示。
- en: '![](../images/fig14-1.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig14-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-1: Viewing loaded
    kernel modules in Process Hacker</samp>'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 14-1：在 Process Hacker 中查看加载的内核模块</samp>
- en: To view loaded kernel modules in Process Hacker, right-click the system process,
    select **Properties**, and then select the **Modules** tab. In [Figure 14-1](chapter14.xhtml#fig14-1),
    you can see some of the kernel drivers installed on my system, such as Advanced
    Configuration and Power Interface (ACPI) drivers and display drivers such as the
    VGA boot driver.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 Process Hacker 中加载的内核模块，右键单击系统进程，选择**属性**，然后选择**模块**选项卡。在[图 14-1](chapter14.xhtml#fig14-1)中，你可以看到我系统上安装的一些内核驱动程序，如高级配置和电源接口（ACPI）驱动程序，以及显示驱动程序，例如
    VGA 启动驱动程序。
- en: Now that you have a basic understanding of kernel drivers, let’s dive into the
    structure of malicious kernel drivers, which are more commonly known as rootkits.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对内核驱动程序有了基本了解，接下来我们将深入探讨恶意内核驱动程序的结构，它们通常被称为 Rootkit。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Rootkit Components</samp>
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Rootkit 组件</samp>
- en: 'Rootkits commonly have two components: a process running in user space and
    a kernel driver that receives instructions from that process. Rootkits nearly
    always start with a user-space executable that must be deployed and executed on
    the victim host. Once this is accomplished, the malicious process loads a driver
    into kernel space. [Figure 14-2](chapter14.xhtml#fig14-2) shows a simple, high-level
    view of how rootkits are installed.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Rootkit 通常有两个组件：一个运行在用户空间的进程和一个从该进程接收指令的内核驱动程序。Rootkit 几乎总是从一个必须在受害主机上部署并执行的用户空间可执行文件开始。一旦完成部署，恶意进程会将一个驱动程序加载到内核空间中。[图
    14-2](chapter14.xhtml#fig14-2)展示了一个简单的、概览式的 Rootkit 安装方式。
- en: '![](../images/fig14-2.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig14-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-2: The rootkit installation
    process</samp>'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 14-2：Rootkit 安装过程</samp>
- en: First, the victim is delivered a dropper executable (*malware.exe*) that, once
    executed, decrypts an embedded malicious kernel driver (*rootkit.sys*). The dropper
    configures and executes this driver as a service, completing the rootkit’s installation
    into kernel space. (We’ll discuss this more in a moment.) The user-space process
    code contains the majority of the malware’s primary functionalities, while the
    kernel component works to mask and protect the user-space process on the system,
    establish low-level hooks to hide its artifacts in memory and on disk, and blind
    endpoint defenses and investigators to its presence.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，受害者会收到一个投放器可执行文件（*malware.exe*），该文件一旦执行，会解密一个嵌入的恶意内核驱动程序（*rootkit.sys*）。该投放器将该驱动程序配置并作为服务执行，从而完成Rootkit在内核空间中的安装。（我们稍后会详细讨论这一过程。）用户空间进程代码包含了大部分恶意软件的主要功能，而内核组件则负责在系统中掩盖和保护用户空间进程，建立低级钩子以隐藏内存和磁盘中的痕迹，并使端点防御和调查人员无法察觉其存在。
- en: '[Figure 14-3](chapter14.xhtml#fig14-3) illustrates some of the newly installed
    rootkit’s functionalities.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-3](chapter14.xhtml#fig14-3)展示了新安装的Rootkit的一些功能。'
- en: '![](../images/fig14-3.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig14-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-3: The basic functionalities
    of a rootkit</samp>'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图14-3：Rootkit的基本功能</samp>
- en: This rootkit can conceal its user-space executable (*malware.exe*) as well as
    issue commands to its kernel driver (*rootkit.sys*) ❶. Rootkit user-space components
    often communicate to their kernel-space counterparts by sending requests via a
    WinAPI function such as <samp class="SANS_TheSansMonoCd_W5Regular_11">DeviceIOControl</samp>,
    which allows a user-space process to send a control code (instruction) to a kernel-space
    driver. In addition, this rootkit is able to hook and intercept API calls from
    user space ❷, intercept communication between other kernel components and device
    drivers ❸, and even tamper with kernel memory directly ❹. All of these techniques
    will become clearer as we progress through this chapter. But first, let’s take
    a step back and talk about how rootkits are installed in the first place.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 该Rootkit能够隐藏其用户空间的可执行文件（*malware.exe*），并向其内核驱动程序（*rootkit.sys*）发出指令 ❶。Rootkit的用户空间组件通常通过发送请求，利用WinAPI函数如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">DeviceIOControl</samp>与内核空间的对应部分进行通信，该函数允许用户空间进程向内核空间驱动程序发送控制码（指令）。此外，该Rootkit能够挂钩并拦截来自用户空间的API调用
    ❷，拦截其他内核组件与设备驱动程序之间的通信 ❸，甚至直接篡改内核内存 ❹。随着本章的进展，这些技术将变得更加清晰。但首先，让我们回顾一下Rootkit是如何最初被安装的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Rootkit Installation</samp>
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Rootkit安装</samp>
- en: 'In the past, rootkits were more prevalent, but Microsoft has implemented protective
    measures in later versions of Windows that make it more difficult to implement
    the changes necessary to install malicious kernel components on a system. Even
    so, there are ways to bypass these protections, so these kinds of attacks do still
    happen sometimes. Let’s take a look at a recent real-world example: HermeticWiper.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，Rootkit的普遍性较高，但微软在后来的Windows版本中实施了保护措施，使得实施必要的更改以安装恶意内核组件变得更加困难。尽管如此，仍然存在绕过这些保护措施的方法，因此这类攻击有时仍然发生。让我们来看一个最近的实际案例：HermeticWiper。
- en: HermeticWiper targeted victims in Ukraine in 2022\. It’s not a rootkit per se;
    rather, it is destructive malware that requires low-level access to overwrite
    data on the disk, rendering a system unbootable. However, because HermeticWiper
    uses a common method of loading a kernel driver and is well documented, it’s a
    good example of how rootkits can also be installed in a victim environment.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: HermeticWiper在2022年针对乌克兰的受害者发起攻击。它本身并不是一个Rootkit；而是一种破坏性恶意软件，需要低级别的访问权限以覆盖磁盘上的数据，使系统无法启动。然而，由于HermeticWiper使用了常见的加载内核驱动程序的方法，并且有很好的文献记录，它是一个很好的例子，展示了Rootkit如何被安装到受害环境中。
- en: One particular HermeticWiper sample was signed by a certificate stolen from
    a valid company, Hermetica Digital Ltd., potentially allowing HermeticWiper to
    bypass certain endpoint defenses. (This technique was discussed in [Chapter 13](chapter13.xhtml).)
    When HermeticWiper first executes, the sample writes a new *.sys* file with a
    file name consisting of four characters (such as *bpdr.sys*) to disk. This file
    is a legitimate driver from the company EaseUS that is normally used to resize
    and partition disks; however, it can be misused, as we’ll see in a moment. Since
    at the time of the attack, this file is signed by a valid certificate, it’s able
    to bypass Windows protections like driver-signing enforcement.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特定的 HermeticWiper 样本是由从合法公司 Hermetica Digital Ltd. 偷来的证书签名的，这可能使 HermeticWiper
    绕过某些终端防御。（此技术在[第13章](chapter13.xhtml)中讨论过。）当 HermeticWiper 首次执行时，该样本将写入一个新的 *.sys*
    文件，文件名由四个字符组成（例如 *bpdr.sys*）并写入磁盘。此文件是 EaseUS 公司的一款合法驱动程序，通常用于调整和分区磁盘；然而，它也可以被滥用，正如我们稍后将看到的那样。由于在攻击时，该文件由有效证书签名，因此能够绕过
    Windows 的驱动程序签名强制保护。
- en: 'Next, to obtain the special privileges required for loading drivers, HermeticWiper
    attempts to obtain <samp class="SANS_TheSansMonoCd_W5Regular_11">SeLoadDriverPrivilege</samp>.
    This privilege can be obtained only by a process already running at a high privilege
    level, so most malware will need to use a privilege elevation technique (such
    as a UAC bypass) to get administrator or system-level privileges and then call
    a function such as <samp class="SANS_TheSansMonoCd_W5Regular_11">AdjustTokenPrivileges</samp>
    (as discussed in [Chapter 13](chapter13.xhtml)). Once it has the required privileges,
    HermeticWiper creates a new service by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateServiceW</samp>
    and starts it by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">StartServiceW</samp>.
    Creating and executing a service is one of the most common methods of loading
    a new kernel driver, for both legitimate and malicious purposes. It can also be
    accomplished via the Windows command line, like so:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了获得加载驱动程序所需的特殊权限，HermeticWiper 尝试获取 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeLoadDriverPrivilege</samp>。此权限只能由已在高权限级别运行的进程获取，因此大多数恶意软件需要使用特权提升技术（如绕过
    UAC）来获得管理员或系统级权限，然后调用诸如 <samp class="SANS_TheSansMonoCd_W5Regular_11">AdjustTokenPrivileges</samp>
    的函数（如[第13章](chapter13.xhtml)所讨论）。一旦获得所需的权限，HermeticWiper 就通过调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateServiceW</samp>
    创建一个新服务，并通过调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">StartServiceW</samp>
    启动它。创建和执行服务是加载新内核驱动程序的最常见方法之一，既可以用于合法目的，也可以用于恶意目的。它还可以通过 Windows 命令行实现，如下所示：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This command creates a new service (<samp class="SANS_TheSansMonoCd_W5Regular_11">evil</samp>),
    specifying an input parameter of <samp class="SANS_TheSansMonoCd_W5Regular_11">C:\Users\Public\evil.sys</samp>
    (the path of the malicious driver to be loaded) and a type of <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel</samp>,
    denoting this service as a kernel driver installation. The following command can
    then be used to start the service:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令创建了一个新服务（<samp class="SANS_TheSansMonoCd_W5Regular_11">evil</samp>），并指定了一个输入参数
    <samp class="SANS_TheSansMonoCd_W5Regular_11">C:\Users\Public\evil.sys</samp>（要加载的恶意驱动程序的路径）以及类型
    <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel</samp>，表示该服务为内核驱动程序安装。随后，可以使用以下命令启动该服务：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here’s the output of executing these commands in Windows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 Windows 中执行这些命令的输出：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the case of HermeticWiper, since the driver (at the time of attack, at least)
    is legitimate and signed by a valid authority, it likely won’t have any issues
    installing in kernel space and can circumvent built-in Windows controls. If the
    driver wasn’t signed by a valid signing authority, we’d receive the following
    error upon starting the service:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 HermeticWiper，由于驱动程序（至少在攻击时）是合法的，并且已由有效的授权机构签名，它可能不会在内核空间安装时遇到任何问题，且能够绕过内置的
    Windows 控制。如果驱动程序未由有效的签名授权机构签名，我们将在启动服务时收到以下错误：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once the malicious service is successfully installed, the Windows Service Controller
    takes over and loads the driver into kernel address space. The malware’s user-space
    component can now interact with the malicious driver in kernel space by invoking
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DeviceIOControl</samp> and issuing
    commands to it. In doing so, HermeticWiper is using an otherwise legitimate driver
    (the EaseUS driver) to write data to the disk, destroying this data and making
    infected systems inoperable.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦恶意服务成功安装，Windows 服务控制器接管并将驱动程序加载到内核地址空间。恶意软件的用户空间组件现在可以通过调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">DeviceIOControl</samp>
    与内核空间中的恶意驱动程序进行交互，并向其发出命令。通过这种方式，HermeticWiper 使用一个本应合法的驱动程序（EaseUS 驱动程序）向磁盘写入数据，破坏这些数据并使受感染的系统无法操作。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*Kernel drivers aren’t always loaded using services. There are other techniques
    for loading them, including invoking the NT API function <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">NtLoadDriver</samp>.*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*内核驱动并不总是通过服务加载。还有其他加载它们的技术，包括调用 NT API 函数 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">NtLoadDriver</samp>。*'
- en: This abuse of legitimate drivers is a form of the Bring Your Own Vulnerable
    Driver technique, which we’ll discuss next.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对合法驱动程序的这种滥用是一种自带易受攻击驱动程序技术的形式，接下来我们将讨论这一技术。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">BYOVD Attacks</samp>
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">BYOVD 攻击</samp>
- en: '*Bring Your Own Vulnerable Driver* (*BYOVD*, or simply *BYOD*) attacks take
    advantage of legitimate, signed drivers as a sort of proxy to interact with the
    kernel; disable security controls; or load a separate, unsigned, malicious kernel
    driver. A malware author searches for a legitimate driver that is already signed
    by a valid signing authority (and therefore vetted by the Windows operating system)
    that can be dropped to the victim system during the attack. This driver must also
    have some sort of vulnerability that allows the threat actor to perform low-level
    malicious actions on the victim system. To exploit these vulnerabilities, rootkits
    often send commands to the vulnerable driver (by invoking <samp class="SANS_TheSansMonoCd_W5Regular_11">DeviceIOControl</samp>,
    for example) from their user-space process.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*自带易受攻击驱动程序*（*BYOVD*，或简称 *BYOD*）攻击利用合法签名的驱动程序作为代理与内核交互；禁用安全控制；或加载单独的、未签名的恶意内核驱动程序。恶意软件作者寻找一个已经由有效签名机构签名的合法驱动程序（因此已通过
    Windows 操作系统的审查），并在攻击期间将其放置到受害系统中。这个驱动程序还必须具有某种漏洞，允许攻击者在受害系统上执行低级恶意操作。为了利用这些漏洞，rootkit
    通常通过其用户空间进程发送命令给易受攻击的驱动程序（例如通过调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">DeviceIOControl</samp>）。'
- en: One notable example of this type of attack is the FudModule rootkit, purportedly
    used by North Korean cybercriminals known as the Lazarus Group. As reported by
    researchers at ESET, FudModule takes advantage of a vulnerable, signed Dell driver
    containing a vulnerability (CVE-2021-21551) that allowed Lazarus to write data
    into kernel memory. More specifically, the vulnerability was triggered by a specially
    crafted instruction to the driver via <samp class="SANS_TheSansMonoCd_W5Regular_11">DeviceIOControl</samp>.
    Ultimately, the threat actors successfully disabled multiple defensive mechanisms
    in Windows, effectively blinding endpoint defenses to later stages of the attack.
    For more information, see Peter Kálnai’s article “Amazon-Themed Campaigns of Lazarus
    in the Netherlands and Belgium” at [*https://<wbr>www<wbr>.welivesecurity<wbr>.com<wbr>/2022<wbr>/09<wbr>/30<wbr>/amazon<wbr>-themed<wbr>-campaigns<wbr>-lazarus<wbr>-netherlands<wbr>-belgium<wbr>/*](https://www.welivesecurity.com/2022/09/30/amazon-themed-campaigns-lazarus-netherlands-belgium/).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的例子是 FudModule rootkit，据信由朝鲜的网络犯罪集团 Lazarus Group 使用。正如 ESET 研究人员报告的那样，FudModule
    利用了一个含有漏洞（CVE-2021-21551）的已签名的 Dell 驱动程序，这个漏洞允许 Lazarus 向内核内存写入数据。更具体地说，这个漏洞是通过特制的指令通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DeviceIOControl</samp> 触发的。最终，攻击者成功禁用了
    Windows 中的多个防御机制，实际上使终端防御对攻击的后续阶段失去反应能力。更多信息请见 Peter Kálnai 文章“Lazarus 在荷兰和比利时的亚马逊主题攻击”：[*https://<wbr>www<wbr>.welivesecurity<wbr>.com<wbr>/2022<wbr>/09<wbr>/30<wbr>/amazon<wbr>-themed<wbr>-campaigns<wbr>-lazarus<wbr>-netherlands<wbr>-belgium<wbr>/*](https://www.welivesecurity.com/2022/09/30/amazon-themed-campaigns-lazarus-netherlands-belgium/)。
- en: Another example of malware that uses the BYOVD technique is the BlackByte ransomware
    family. As Sophos reported, BlackByte abuses a vulnerable driver in the legitimate
    product MSI AfterBurner, a tool for tuning graphics cards. The driver vulnerability
    (CVE-2019-16098) allowed the BlackByte operators to interact with the kernel and
    disable EDR products on the host by terminating EDR-related processes. To learn
    more about this malware, check out Andreas Klopsch’s article “Remove All the Callbacks—BlackByte
    Ransomware Disables EDR Via RTCore64.sys Abuse” at [*https://<wbr>news<wbr>.sophos<wbr>.com<wbr>/en<wbr>-us<wbr>/2022<wbr>/10<wbr>/04<wbr>/blackbyte<wbr>-ransomware<wbr>-returns<wbr>/*](https://news.sophos.com/en-us/2022/10/04/blackbyte-ransomware-returns/).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使用BYOVD技术的恶意软件例子是BlackByte勒索病毒家族。正如Sophos报道的那样，BlackByte利用了合法产品MSI AfterBurner中的一个脆弱驱动程序，这是一款用于调节显卡的工具。该驱动程序漏洞（CVE-2019-16098）使得BlackByte的操作者能够与内核交互，并通过终止与EDR相关的进程来禁用主机上的EDR产品。想了解更多关于该恶意软件的信息，请查看Andreas
    Klopsch的文章《移除所有回调—BlackByte勒索病毒通过RTCore64.sys滥用禁用EDR》([*https://<wbr>news<wbr>.sophos<wbr>.com<wbr>/en<wbr>-us<wbr>/2022<wbr>/10<wbr>/04<wbr>/blackbyte<wbr>-ransomware<wbr>-returns<wbr>/*](https://news.sophos.com/en-us/2022/10/04/blackbyte-ransomware-returns/))。
- en: A third example is the malware family ZeroCleare, found by researchers at IBM
    X-Force IRIS to be abusing a vulnerable VirtualBox driver (*vboxdrv.sys*), which
    allowed the attacker to execute shellcode in kernel memory and install a malicious
    kernel driver. You can read more about this attack in the IBM report “New Destructive
    Wiper ZeroCleare Targets Energy Sector in the Middle East” at [*https://<wbr>securityintelligence<wbr>.com<wbr>/posts<wbr>/new<wbr>-destructive<wbr>-wiper<wbr>-zerocleare<wbr>-targets<wbr>-energy<wbr>-sector<wbr>-in<wbr>-the<wbr>-middle<wbr>-east<wbr>/*](https://securityintelligence.com/posts/new-destructive-wiper-zerocleare-targets-energy-sector-in-the-middle-east/).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是恶意软件家族ZeroCleare，IBM X-Force IRIS的研究人员发现该家族利用了一个脆弱的VirtualBox驱动程序（*vboxdrv.sys*），使攻击者能够在内核内存中执行shellcode并安装恶意内核驱动程序。你可以在IBM报告《新的破坏性擦除工具ZeroCleare针对中东能源部门》([*https://<wbr>securityintelligence<wbr>.com<wbr>/posts<wbr>/new<wbr>-destructive<wbr>-wiper<wbr>-zerocleare<wbr>-targets<wbr>-energy<wbr>-sector<wbr>-in<wbr>-the<wbr>-middle<wbr>-east<wbr>/*](https://securityintelligence.com/posts/new-destructive-wiper-zerocleare-targets-energy-sector-in-the-middle-east/))中阅读更多关于这一攻击的信息。
- en: Unfortunately, there are other recent examples of malware abusing vulnerable
    drivers to disable and blind endpoint defenses, load additional malicious kernel
    drivers, or otherwise execute malicious code in privileged areas of the operating
    system. Furthermore, since these drivers are legitimate and signed, there’s currently
    not much that can be done to completely prevent this type of attack. There’s a
    dedicated project for tracking these vulnerable drivers; it’s called Living Off
    The Land Drivers (LOLDrivers, for short). It’s worth exploring if you’re interested
    in learning more about BYOVD attacks, so visit the project website at [*https://<wbr>www<wbr>.loldrivers<wbr>.io*](https://www.loldrivers.io).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，还有一些最近的恶意软件例子，利用脆弱驱动程序来禁用并盲化终端防御，加载额外的恶意内核驱动程序，或在操作系统的特权区域中执行恶意代码。此外，由于这些驱动程序是合法且已签名的，目前没有太多办法可以完全防止这种类型的攻击。有一个专门的项目跟踪这些脆弱的驱动程序，叫做Living
    Off The Land Drivers（简称LOLDrivers）。如果你有兴趣了解更多关于BYOVD攻击的知识，值得去探索一下，访问项目网站：[*https://<wbr>www<wbr>.loldrivers<wbr>.io*](https://www.loldrivers.io)。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*Not all BYOVD usage is rootkit related. For example, some malware simply leverages
    a vulnerable driver to execute kernel functions or perform low-level actions that
    would otherwise be prohibited.*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*并非所有BYOVD的使用都与rootkit相关。例如，一些恶意软件仅利用脆弱的驱动程序执行内核功能或进行低级操作，这些操作本来是被禁止的。*'
- en: 'Now that you’ve gotten an overview of how threat actors can bypass Windows
    protections to install rootkits, let’s start looking into how rootkits behave
    on a victim host and manipulate the system to stay hidden. We’ll start with an
    old technique: DKOM.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了威胁行为者如何绕过Windows的保护机制来安装rootkit，我们开始研究rootkit在受害主机上的行为，并通过操控系统保持隐藏。我们从一个老旧的技术开始：DKOM。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Direct Kernel Object Manipulation</samp>
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">直接内核对象操作（DKOM）</samp>
- en: '*Direct kernel object manipulation* (*DKOM)* involves directly modifying data
    in kernel memory. This is a delicate task because, when done incorrectly, it can
    crash the operating system. Done correctly, however, it can give the malware immense
    power. One example of DKOM is hiding processes.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*直接内核对象操作*（*DKOM*）涉及直接修改内核内存中的数据。这是一项精细的任务，因为如果操作不当，可能会导致操作系统崩溃。然而，如果操作得当，它可以赋予恶意软件巨大的能力。DKOM的一个例子是隐藏进程。'
- en: Using DKOM, a rootkit can hide its user-space processes and kernel modules from
    endpoint defenses and forensics analysts by modifying its processes’ EPROCESS
    data structures in kernel memory. You might remember from [Chapter 1](chapter1.xhtml)
    that EPROCESS structures form a doubly linked list of processes running on the
    host. Some defense and analysis tools rely on these structures to monitor and
    inspect anomalous running processes.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用DKOM，rootkit可以通过修改其进程的EPROCESS数据结构，将其用户空间进程和内核模块从终端防御和取证分析中隐藏。你可能还记得在[第1章](chapter1.xhtml)中，EPROCESS结构形成了主机上正在运行的进程的双向链表。一些防御和分析工具依赖这些结构来监视和检查异常的运行进程。
- en: To perform this type of DKOM technique, a malicious kernel-space module invokes
    a function such as <samp class="SANS_TheSansMonoCd_W5Regular_11">PsLookupProcessByProcessID</samp>
    to get a pointer to its own user-space component’s EPROCESS structure. Then, the
    malware can modify the *forward link (flink)* and *backward link (blink)* members
    of the EPROCESS structure, unlinking the structure from the EPROCESS chain. [Figure
    14-4](chapter14.xhtml#fig14-4) illustrates normal, unmodified EPROCESS structures
    before unlinking.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行这种类型的DKOM技术，恶意的内核空间模块会调用诸如 <samp class="SANS_TheSansMonoCd_W5Regular_11">PsLookupProcessByProcessID</samp>
    之类的函数，以获取指向其自身用户空间组件EPROCESS结构的指针。然后，恶意软件可以修改EPROCESS结构的*前向链接（flink）*和*后向链接（blink）*成员，将该结构从EPROCESS链中解除链接。[图14-4](chapter14.xhtml#fig14-4)展示了解除链接前的正常、未修改的EPROCESS结构。
- en: '![](../images/fig14-4.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig14-4.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-4: Doubly linked
    EPROCESS structures before unlinking</samp>'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图14-4：解除链接前的双向链接EPROCESS结构</samp>
- en: Notice how the EPROCESS structures are linked by their flink and blink members.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，EPROCESS结构是通过它们的flink和blink成员链接的。
- en: '[Figure 14-5](chapter14.xhtml#fig14-5) shows what happens when a rootkit tampers
    with the EPROCESS structures to unlink its malicious process (center).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-5](chapter14.xhtml#fig14-5)显示了当rootkit篡改EPROCESS结构以将其恶意进程（中间）解除链接时发生的情况。'
- en: '![](../images/fig14-5.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig14-5.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-5: EPROCESS structures
    after unlinking</samp>'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图14-5：解除链接后的EPROCESS结构</samp>
- en: Notice how both the flink and blink for the malicious process’s EPROCESS structure
    point back to it, effectively disconnecting this process from the normal EPROCESS
    chain.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，恶意进程的EPROCESS结构的flink和blink都指向它自己，从而有效地将该进程与正常的EPROCESS链断开连接。
- en: 'The following code is an abridged version of the HideProcess project (see [*https://<wbr>github<wbr>.com<wbr>/landhb<wbr>/HideProcess*](https://github.com/landhb/HideProcess)),
    and it demonstrates how the malware accomplishes the tasks outlined previously:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是HideProcess项目的简化版本（请参见 [*https://<wbr>github<wbr>.com<wbr>/landhb<wbr>/HideProcess*](https://github.com/landhb/HideProcess)），演示了恶意软件如何完成之前提到的任务：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: First, the code defines the variables <samp class="SANS_TheSansMonoCd_W5Regular_11">Previous</samp>
    (which stores the current process’s blink pointer) ❶ and <samp class="SANS_TheSansMonoCd_W5Regular_11">Next</samp>
    (which stores the current process’s flink pointer) ❷. Later, the code rewrites
    these <samp class="SANS_TheSansMonoCd_W5Regular_11">LIST_ENTRY</samp> values to
    point to itself. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Current->Blink</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(PLIST_ENTRY)&Current->Flink</samp>
    line sets the process’s current blink pointer to its flink pointer value ❸. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Current->Flink</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(PLIST _ENTRY)&Current->Flink</samp>
    line ensures that the process’s flink points to itself ❹. In essence, this breaks
    the EPROCESS chain, hiding the process from process management tools (like Task
    Manager) and some forensics investigation toolsets, perhaps helping it better
    evade endpoint defenses.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: DKOM isn’t limited to hiding processes, however. Using DKOM techniques, malware
    can theoretically alter any object in kernel memory. Malware has been known to
    use DKOM techniques to hide malicious network traffic or alter files in order
    to interfere with forensics investigations. DKOM can also be used to inject kernel
    hooks, as you’ll see in the next section.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: While DKOM is one of the most basic and straightforward methods rootkits can
    use to hide or to alter the system, it’s not a golden ticket. DKOM and other kernel
    manipulation techniques can easily crash the operating system, potentially alerting
    the victim to the malware’s presence. Not only that, but security measures like
    PatchGuard also can create challenges for malware authors, as we’ll discuss later
    in the chapter.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">“Legacy” Kernel Hooking</samp>
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just like malware running in user space can use inline and IAT hooking to monitor,
    intercept, and manipulate function calls, kernel-space malware can use several
    types of hooks to launch its attacks. We’ll discuss some of the most prevalent,
    starting with the decades-old technique of SSDT hooking.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '> <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '*The techniques discussed in this section were at one time some of the most
    common ones used by both rootkits and endpoint defense products alike. Much like
    DKOM, however, they’re no longer popular thanks to the protections that Microsoft
    has implemented in modern versions of Windows. Still, it’s important to gain a
    basic understanding of them since you may occasionally witness malware using these
    or similar tactics, and it’ll also give you a better grasp of more modern rootkit
    techniques.*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">SSDT Hooks</samp>
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The *System Service Descriptor Table (SSDT)* or *Dispatch Table* contains an
    array of syscall IDs and their corresponding pointers to kernel functions. (These
    differ between 32- and 64-bit operating systems, but we won’t go into those specifics
    here.) As discussed in [Chapters 1](chapter1.xhtml) and [13](chapter13.xhtml),
    when a user-space process invokes Windows API and NT API functions, the function
    eventually makes a syscall into the kernel to fulfill the request. Let’s look
    at an example using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>
    to read a file on disk. Here’s the basic sequence of steps that must occur:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 1.  A program in user space invokes <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>.
    The program initiates a syscall, referencing the syscall ID that corresponds to
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp> function.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 2.  The syscall triggers the processor to switch from user mode to kernel mode
    and passes the request and syscall ID to the syscall handler.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 3.  The syscall handler consults the SSDT to obtain the address of the kernel
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp> function (which
    is exported from *ntoskrnl.exe*) and then proceeds to execute the function.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Since the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>
    function is being invoked to read a file on disk, it must communicate with kernel
    drivers such as the disk driver stack. This is where the IO manager is engaged.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 5.  The IO manager sends instructions in the form of *IO request packets (IRPs)*
    to the appropriate drivers, which will carry out <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>’s
    requested actions (such as reading the specific file on disk). I’ll discuss the
    IO manager and IRPs later in this chapter.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 6.  Once the drivers process the request, the result is sent back to the original
    calling program in user space.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a basic understanding of how the SSDT is used, you can see
    how malware could insert a hook into it to redirect requests to malicious code.
    [Figure 14-6](chapter14.xhtml#fig14-6) shows an example of this approach with
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp> function.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig14-6.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-6: An SSDT hook for
    NtReadFile</samp>'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: The rootkit modifies the function pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>
    inside the SSDT, which redirects the request for <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>
    to the rootkit’s malicious kernel module. The rootkit then intercepts and modifies
    the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>. Later,
    it can redirect the call to the original <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>
    function code inside *ntoskrnl.exe*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: There are many reasons why a malware author would use SSDT hooking. For example,
    they might implement an SSDT hook for <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>
    to prevent the malware’s own malicious files and code from being read by endpoint
    defenses and investigators. Another kernel-hooking technique, inline kernel hooks,
    is used for a similar reason.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者使用 SSDT 钩子的原因有很多。例如，他们可能会为 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>
    实现一个 SSDT 钩子，以防止恶意软件自身的恶意文件和代码被终端防护和调查人员读取。另一种内核钩子技术——内联内核钩子，也用于类似的原因。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Inline Kernel Hooks</samp>
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">内联内核钩子</samp>
- en: Inline hooking is a malware technique employed not just in user space (as discussed
    in [Chapter 12](chapter12.xhtml)) but in kernel functions as well. To install
    the hooks, a rootkit attempts to modify function code inside *ntoskrnl.exe*. Similar
    to the example just discussed with SSDT hooking, a rootkit could hook <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>
    by tampering with the function’s code to insert a jump instruction and redirect
    control flow to the malicious kernel module’s code, as illustrated in [Figure
    14-7](chapter14.xhtml#fig14-7).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 内联钩子是恶意软件在用户空间（如 [第 12 章](chapter12.xhtml) 讨论的）以及内核函数中都使用的一种技术。为了安装钩子，根工具包试图修改
    *ntoskrnl.exe* 中的函数代码。类似于刚才讨论的 SSDT 钩子示例，根工具包可以通过篡改函数代码插入跳转指令，将控制流重定向到恶意内核模块的代码，如
    [图 14-7](chapter14.xhtml#fig14-7) 所示。
- en: '![](../images/fig14-7.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig14-7.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-7: An inline kernel
    hook for NtReadFile</samp>'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 14-7：NtReadFile 的内联内核钩子</samp>
- en: 'There are a number of ways a rootkit can write a hook into a target function.
    Similar to inline hooking in user space, the malware first must alter the memory
    protections of the target function’s code and then write a hook into it. The following
    pseudocode demonstrates how this might look:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 根工具包可以通过多种方式将钩子写入目标函数。类似于用户空间中的内联钩子，恶意软件首先必须修改目标函数代码的内存保护，然后将钩子写入其中。以下伪代码演示了这一过程：
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">MmProtectMdlSystemAddress</samp>
    is a kernel function that’s used to set the memory protection type for a *memory
    descriptor list (MDL)*, which is a structure containing a memory address range.
    This function has two parameters: a <samp class="SANS_TheSansMonoCd_W5Regular_11">MemoryDescriptorList</samp>
    (the memory address range that will be altered) and a protection constant (such
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">PAGE_READWRITE</samp>, which
    would change the MDL’s protections to be writable).'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">MmProtectMdlSystemAddress</samp>
    是一个内核函数，用于设置 *内存描述符列表 (MDL)* 的内存保护类型，MDL 是一个包含内存地址范围的结构。此函数有两个参数：一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">MemoryDescriptorList</samp>（将要修改的内存地址范围）和一个保护常量（如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">PAGE_READWRITE</samp>，它将改变 MDL 的保护为可写）。
- en: Following this, the malware invokes a kernel function such as <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlCopyMemory</samp>
    to overwrite the target code with a jump instruction, for instance. The primary
    parameters of <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlCopyMemory</samp>
    are the destination address of the target memory region, the source address (which
    contains the jump instruction to be copied), and the size of the data being copied.
    Malware must be careful to set the target memory region back to its original protection
    setting because incorrect and anomalous protections (such as “writable”) may raise
    the suspicions of endpoint defenses or cause system instability.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，恶意软件调用一个内核函数，如 <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlCopyMemory</samp>，将目标代码覆盖为跳转指令。例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">RtlCopyMemory</samp> 的主要参数是目标内存区域的目的地址、源地址（其中包含要复制的跳转指令）和复制数据的大小。恶意软件必须小心将目标内存区域恢复为其原始保护设置，因为不正确和异常的保护（例如“可写”）可能会引起终端防护的怀疑，或者导致系统不稳定。
- en: Next, we’ll turn to IRP hooking, another type of kernel hook rootkits have been
    known to use.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论 IRP 钩子，这也是根工具包已知使用的一种内核钩子类型。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">IRP Hooks</samp>
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">IRP 钩子</samp>
- en: When user-space programs need to communicate with kernel drivers, they do so
    via the IO manager. This communication is primarily accomplished with IO request
    packets (IRPs), which are objects comprising data structures that contain information
    about the request and actions to be performed. IRPs are passed between the calling
    program and kernel drivers, but they can also be used for communication between
    drivers. For example, a USB keyboard driver will need to communicate with the
    USB host controller driver, and the IO manager helps facilitate this. This relationship
    is illustrated in [Figure 14-8](chapter14.xhtml#fig14-8).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig14-8.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-8: How an IRP works</samp>'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: This program invokes the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateFile</samp>
    function to open a handle to a file on disk. Eventually, the program makes a syscall
    into the kernel (*ntoskrnl.exe*). This is where the IO manager gets involved,
    sending an IRP to the filesystem driver that will handle this operation. In the
    final step (not pictured here), the driver sends the status of the operation back
    to the IO manager, which will return the status to the calling program.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Every IRP includes an *IRP code*, which tells the recipient driver what IRP
    handler should be used to handle the respective request. [Table 14-1](chapter14.xhtml#tab14-1)
    lists some of the more interesting IRP function codes for our purposes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 14-1:</samp> <samp class="SANS_Futura_Std_Book_11">IRP
    Codes</samp>
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">IRP code</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Request
    description</samp> |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE</samp> | <samp
    class="SANS_Futura_Std_Book_11">Sent to a driver when the requesting thread opens
    a handle to a device or file object, such as when making a call to</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp> |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_WRITE</samp> | <samp
    class="SANS_Futura_Std_Book_11">Sent to a driver when the requester wishes to
    transfer data, such as when writing data to a file</samp> |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_READ</samp> | <samp
    class="SANS_Futura_Std_Book_11">Sent to a driver when the requester wishes to
    read data, such as from a file</samp> |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_DEVICE_CONTROL</samp>
    | <samp class="SANS_Futura_Std_Book_11">Sent when a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">DeviceIoControl</samp>
    <samp class="SANS_Futura_Std_Book_11">function is called (meaning a user-space
    process is sending a direct control code, or instruction, to a driver)</samp>
    |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_SHUTDOWN</samp> | <samp
    class="SANS_Futura_Std_Book_11">Sent when a system shutdown has been initiated</samp>
    |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_SYSTEM_CONTROL</samp>
    | <samp class="SANS_Futura_Std_Book_11">Sent when a user-space process requests
    system information via Windows Management Instrumentation (WMI)</samp> |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
- en: 'Each driver installed in the kernel includes a table of IRP handlers called
    the *major function table* (or the *IRP function table*). Major function tables
    contain pointers to the handler code that will handle a particular IRP; this code
    might be located in the driver itself or inside another driver or module. The
    following output shows an IRP function table for the FLTMGR driver:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This output was created with the help of Volatility, a memory forensics and
    analysis tool. Although not covered in this book, memory forensics techniques
    can be great additions to the malware analysis process, especially in the case
    of rootkits. For this specific example, I used the <samp class="SANS_TheSansMonoCd_W5Regular_11">driverirp</samp>
    module in Volatility.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: The first column in this output contains the IRP code. The second and third
    columns contain the pointer to the associated IRP handler function and the module
    containing the handler code, respectively. In this case, the driver points to
    handlers it contains.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'To intercept, modify, and gain control of IO communication, malicious kernel
    drivers might attempt to hook IRPs. One reason for doing so is to hide and protect
    the malware’s artifacts on the endpoint by intercepting IRP function calls that
    reference those artifacts on disk. The Autochk rootkit (<samp class="SANS_TheSansMonoCd_W5Regular_11">SHA256:
    28924b6329f5410a5cca30f3530a3fb8a97c23c9509a192f2092cbdf139a91d8</samp>) does
    exactly this: it hooks <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE</samp>
    inside the FLTMGR driver to intercept IRPs referencing its malicious files on
    disk (as illustrated in [Figure 14-9](chapter14.xhtml#fig14-9)).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig14-9.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-9: An IRP hook for
    NtReadFile</samp>'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'If an application in user space, such as a forensics tool, attempts to access
    this rootkit’s files, the IRP will be handled by the rootkit’s handler code rather
    than by the legitimate handler that would otherwise deal with this request. The
    following Volatility output shows the hooked FLTMGR driver’s IRP function table:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice anything shady? In the first row of the code, <samp class="SANS_TheSansMonoCd_W5Regular_11">FLTMGR.SYS</samp>
    has been replaced with <samp class="SANS_TheSansMonoCd_W5Regular_11">autochk.sys</samp>.
    All <samp class="SANS_TheSansMonoCd_W5Regular_11">MJ_CREATE</samp> IRPs destined
    for the FLTMGR driver will instead be forwarded to the malicious handler code
    inside the rootkit’s driver, <samp class="SANS_TheSansMonoCd_W5Regular_11">autochk.sys!</samp>
    You can read more about some of the techniques of this rootkit at [*https://<wbr>repnz<wbr>.github<wbr>.io<wbr>/posts<wbr>/autochk<wbr>-rootkit<wbr>-analysis<wbr>/*](https://repnz.github.io/posts/autochk-rootkit-analysis/).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: To install an IRP hook, malware authors have a few options. One approach is
    to replace the original handler code pointer value in a victim driver with a pointer
    to malicious handler code. Alternatively, malware could use the inline hooking
    method described previously to overwrite the first few bytes in the legitimate
    handler function with a jump instruction to malicious code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Both of these techniques, as well as the other hooking techniques mentioned,
    rely on the delicate task of manipulating kernel objects in memory. As noted earlier,
    however, the techniques discussed in this section aren’t often used in malware
    anymore due to the protections now built into Windows. With this in mind, let’s
    shift to some relatively modern techniques that rootkits might use to circumvent
    these Windows protections, starting with IRP filtering and interception.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">IRP Interception by Filtering</samp>
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rather than crudely hooking kernel drivers to intercept and manipulate IRPs,
    rootkits can register a filter or minifilter driver to do so. Introduced at the
    beginning of this chapter, filter drivers and minifilter drivers can be “attached”
    to a device and added to its driver stack, intercepting IRPs as they are filtered
    down the stack. Let’s go over this process in more detail.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Filter drivers (sometimes called* legacy filter drivers*) and minifilter drivers
    are both types of filters, but they operate quite differently. I won’t go into
    the specifics of these two drivers in this book.*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Each hardware device attached to the system has an associated hierarchical stack
    of drivers that enables communication between the device and the operating system
    (see [Figure 14-10](chapter14.xhtml#fig14-10)).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig14-10.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-10: How the IO manager
    communicates with driver stacks</samp>'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Each driver in the stack performs a specific role and serves as an interface
    between the drivers before and after it in the stack. Additionally, when the IO
    manager sends an IRP to a specific device, the IRP is routed through the device’s
    hierarchical driver stack, passing through each driver in the stack one by one.
    If one of the drivers has a handler for the specific IRP, it takes some sort of
    action on that IRP. The arrows shown in [Figure 14-10](chapter14.xhtml#fig14-10)
    represent communication between drivers in the form of IRPs.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Filter drivers are designed to be inserted into a driver stack to add functionality.
    They can be inserted in various locations (called *altitudes*) in the stack or
    even added all the way to the top of the stack, where they can intercept any and
    all IRPs destined for the driver stack (see [Figure 14-11](chapter14.xhtml#fig14-11)).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig14-11.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-11: A filter driver
    added to the top of the driver stack</samp>'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Rootkits can register a new filter driver and “insert” it at the top of a driver
    stack, allowing them to see and intercept all inbound IRPs. After intercepting,
    the malware can choose to drop the IRP or modify it. A rootkit might use a filter
    driver this way to protect its own files. For example, it could register a filter
    driver to watch for and intercept IO requests to its own files, either modifying
    the requests or dropping them completely to effectively hide them from investigators
    and analysis tools. EDR and other endpoint defenses sometimes use filter drivers
    for the same reason: to protect their files from malware.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: To implement a filter driver, a rootkit must first load the driver into kernel
    memory (potentially using the techniques from “Rootkit Installation” on [page
    269](chapter14.xhtml#pg_269)). The filter driver must specify which IRP communication
    it cares about by setting up a handler for those IRPs. For instance, if the malware
    is trying to intercept <samp class="SANS_TheSansMonoCd_W5Regular_11">MJ_CREATE</samp>
    IRPs, it must implement this in the filter driver’s IRP function table.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Malware can abuse minifilter drivers by registering one of its own (by calling
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FltRegisterFilter</samp>) or by
    hooking an existing minifilter. Some modern malware has been known to do this.
    When analyzing rootkit driver code, take note of whether the malware is calling
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FltRegisterFilter</samp> to register
    its own minifilter driver. Also notice whether the malware is calling functions
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">FltGetFilterFromName</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FltEnumerateFilters</samp>, or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">FltEnumerateInstances</samp>; it may be
    attempting to enumerate other minifilters on the host, preparing for hooking.
    For more information on how minifilter drivers are implemented in practice, see
    Rahul Dev Tripathi’s article “Storage Device Restriction Using a Minifilter Driver
    Approach” at [*https://<wbr>www<wbr>.codeproject<wbr>.com<wbr>/Articles<wbr>/5341729<wbr>/Storage<wbr>-Device<wbr>-Restriction<wbr>-Using<wbr>-a<wbr>-Minifilter<wbr>-Driv<wbr>*](https://www.codeproject.com/Articles/5341729/Storage-Device-Restriction-Using-a-Minifilter-Driv).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Legacy filter drivers are installed differently. The specifics are outside the
    scope of this book, but you can learn more from the filesystem driver tutorial
    at [*https://<wbr>www<wbr>.codeproject<wbr>.com<wbr>/Articles<wbr>/43586<wbr>/File<wbr>-System<wbr>-Filter<wbr>-Driver<wbr>-Tutorial*](https://www.codeproject.com/Articles/43586/File-System-Filter-Driver-Tutorial)
    and from Rotem Salinas’s great write-up “Fantastic Rootkits and Where to Find
    Them” at [*https://<wbr>www<wbr>.cyberark<wbr>.com<wbr>/resources<wbr>/threat<wbr>-research<wbr>-blog<wbr>/fantastic<wbr>-rootkits<wbr>-and<wbr>-where<wbr>-to<wbr>-find<wbr>-them<wbr>-part<wbr>-1*](https://www.cyberark.com/resources/threat-research-blog/fantastic-rootkits-and-where-to-find-them-part-1).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Abusing Kernel Callbacks</samp>
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Abusing kernel callbacks is another more modern approach used by some rootkits.
    To recap the discussion in [Chapter 13](chapter13.xhtml), a callback allows a
    kernel module to be notified of system events so that it can take some sort of
    action when they happen. For example, a driver may need to know when a process
    executed in user space, so it would implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">PsSetCreateProcessNotifyRoutine</samp>
    callback (as in the case of some EDR products). Once this callback is registered
    with the driver, the driver will receive a notification in the form of an IRP
    when a process is created on the system, giving the driver the chance to execute
    its callback code for that event.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: The creator of the process is responsible for sending out a notification to
    all registered drivers. So, when a process spawns a child process, for example,
    the calling process sends out the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessNotifyRoutine</samp>
    notification to all registered drivers. When a driver receives the notification,
    the driver’s callback code will be executed.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'A rootkit can also use callbacks if it wants to be notified of specific system
    events. Once an event occurs, such as a registry modification or filesystem operation,
    the rootkit’s malicious driver(s) will be notified, and the callback code will
    be executed. The following output shows a listing of registered callback routines
    on an infected system:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this output, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp>
    column shows the callback type, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Callback</samp>
    column shows the address of the callback handler, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Module</samp>
    column shows the kernel module that registered the callback. Most of these are
    normal, legitimate callbacks. However, there’s a suspicious module name (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">comp.sys</samp>) that appears to have
    registered an interesting callback (<samp class="SANS_TheSansMonoCd_W5Regular_11">PsSetCreateThreadNotifyRoutine</samp>).
    As mentioned previously, this callback will trigger when a new thread is created
    by a process in user space. Also note that the address of the callback code is
    much different from those of the legitimate callbacks (<samp class="SANS_TheSansMonoCd_W5Regular_11">0xfffff6050d26ccc0</samp>
    versus <samp class="SANS_TheSansMonoCd_W5Regular_11">0xfffff80af3afb210</samp>,
    for example).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'A similar approach was taken by the DirtyMoe rootkit. DirtyMoe used kernel
    callbacks to silently inject malicious code into newly created threads in user
    space. You can read more about it in Martin Chlumecký’s article “DirtyMoe: Rootkit
    Driver” at [*https://<wbr>decoded<wbr>.avast<wbr>.io<wbr>/martinchlumecky<wbr>/dirtymoe<wbr>-rootkit<wbr>-driver<wbr>/*](https://decoded.avast.io/martinchlumecky/dirtymoe-rootkit-driver/).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'The infamous Necurs rootkit, which originated in 2014, sets up a registry callback
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">CmRegisterCallback</samp>), a type
    of filter driver callback that will notify it of any access to its registry service
    key. If an investigator or program attempts to access this registry key, the attempt
    fails. This simplified pseudocode example shows how a malicious driver could register
    and abuse a registry callback:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This malware code first defines the callback function code (<samp class="SANS_TheSansMonoCd_W5Regular_11">RegistryCallback</samp>)
    that will be executed once the callback occurs ❶. Later in the code, the rootkit
    defines the registry callback, passing the callback name (<samp class="SANS_TheSansMonoCd_W5Regular_11">RegistryCallback</samp>)
    and also the context, which is a pointer to a structure containing information
    about the function call ❺. Since this callback will be triggered by programs interacting
    with the Windows registry, this context structure contains important information
    like the particular registry action (open key, write data, and so on) and the
    target of the action (or the specific registry key or value affected).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: When a program performs a registry action, such as invoking <samp class="SANS_TheSansMonoCd_W5Regular_11">RegOpenKeyExA</samp>,
    the rootkit’s malicious callback code will be executed. The rootkit checks to
    see if the registry event is equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">CM_EVENT_REGISTRY_KEY_OPEN</samp>
    (indicating that a registry key is being opened) ❷ and then checks to see whether
    the registry key being acted upon is <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\evil</samp>
    (the key used by the malware to establish persistence on the host) ❸. If the key
    name matches, the rootkit attempts to prevent the program or investigator from
    inspecting that registry key ❹. It can do so by temporarily deleting its own registry
    key and re-creating it later, or by injecting malicious code into the calling
    process and hooking into the function call to prevent the call from succeeding,
    among other methods.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">CmRegisterCallback</samp>
    is now obsolete; the modern version of this function is <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">CmRegisterCallbackEx</samp>.
    The principles of the function remain the same, however.*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ve seen quite a bit about how rootkits operate at a very low level in the
    operating system to manipulate kernel memory, install hooks, and configure callbacks,
    allowing them to remain hidden and evade defenses. Now we’ll look briefly at a
    variant of malware that delves even deeper: bootkits.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Bootkits</samp>
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *bootkit* is a piece of malware designed to hide inside the system firmware,
    compromising the entire boot process. If a bootkit is able to tamper with the
    operating system boot-up, injecting itself into this process chain, it can effectively
    achieve all the benefits of a rootkit while also surviving system rebuilds.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: One specific type of bootkit is a UEFI bootkit (sometimes called a UEFI rootkit),
    which operates within the *Unified Extensible Firmware Interface (UEFI)*, a specialized
    storage chip attached to a system’s motherboard. The UEFI contains low-level software
    that executes before the operating system boots up, providing an interface between
    the operating system kernel and the various firmware devices installed in the
    system. Given that the UEFI boots before the operating system, malware that can
    embed itself within the UEFI chip will remain undetected for longer periods of
    time and can even survive operating system reinstallations and rebuilds.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'One notable example of a UEFI bootkit is CosmicStrand. In July 2022, researchers
    from Kaspersky reported that this UEFI bootkit dug itself into systems, with the
    entry vector possibly being a hardware vulnerability. The bootkit affected various
    systems with certain models of Asus and Gigabyte motherboards and took control
    of the Windows operating system kernel loader, injecting malicious code into kernel
    memory. For more about this threat, see the article “CosmicStrand: The Discovery
    of a Sophisticated UEFI Firmware Rootkit,” from Kaspersky’s Global Research &
    Analysis Team (GreAT) at [*https://<wbr>securelist<wbr>.com<wbr>/cosmicstrand<wbr>-uefi<wbr>-firmware<wbr>-rootkit<wbr>/106973<wbr>/*](https://securelist.com/cosmicstrand-uefi-firmware-rootkit/106973/).'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Another example is the MosaicRegressor framework, which was also discovered
    by Kaspersky. It included a UEFI rootkit component that hijacked the Windows boot
    process to drop an executable to disk that silently executes when Windows boots
    up. If this executable is removed from the disk, it will be rewritten to disk
    upon reboot of the system, providing a high degree of persistence. You can read
    the article from Kaspersky about MosaicRegressor, “Lurking in the Shadows of UEFI,”
    by Mark Lechtik, Igor Kuznetsov, and Yury Parshin, at [*https://<wbr>securelist<wbr>.com<wbr>/mosaicregressor<wbr>/98849<wbr>/*](https://securelist.com/mosaicregressor/98849/).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Compared with traditional user-space malware, bootkits are relatively rare.
    However, they might not be as rare as they’re perceived to be. Because of their
    low-level access to the host, they can survive and persist undetected even in
    well-defended environments. If we can’t detect this type of malware, we don’t
    know it exists, which leads us to the unsettling conclusion that this type of
    malware could be embedded in more systems than we know. However, all is not lost.
    Let’s wrap up this chapter by discussing some of the built-in Windows defenses
    against rootkits and bootkits.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Defenses Against Rootkits</samp>
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Microsoft has implemented several defenses against rootkits, two of the most
    important being *PatchGuard* and *Driver Signature Enforcement (DSE)*. Introduced
    in 2005 for x64 versions of Windows XP, PatchGuard, which is also known as *Kernel
    Patch Protection (KPP)*, mitigates many of the rootkit techniques described earlier,
    such as SSDT and IDT hooking and many forms of DKOM. PatchGuard works by periodically
    verifying the integrity of kernel memory structures to test whether they’ve been
    modified. If PatchGuard detects that one of these structures has been modified,
    it forces a crash of the kernel, which has the result shown in [Figure 14-12](chapter14.xhtml#fig14-12).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig14-12.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-12: A kernel security
    check crash caused by PatchGuard</samp>'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: PatchGuard isn’t impervious to circumvention, however. Since it scans kernel
    memory periodically, if these checks are timed properly, malware could very quickly
    tamper with kernel memory and then revert to a “clean” state before PatchGuard
    executes its integrity check. To initiate this check, the operating system calls
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">KeBugCheckEx</samp> kernel API
    function, which certain malware has been known to hook to prevent the kernel integrity
    check from successfully executing. There have also been several issues with malware
    exploiting PatchGuard and other related components. One example of such malware
    is GhostHook, which exploited a vulnerability in the way Windows implements a
    certain low-level Intel API called Intel Processor Trace, potentially allowing
    malware to fly under PatchGuard’s radar. This attack technique is quite complex,
    so we won’t go into the details here, but you can read more about it in Kasif
    Dekel’s post, “GhostHook—Bypassing PatchGuard with Processor Trace Based Hooking,”
    at [*https://<wbr>www<wbr>.cyberark<wbr>.com<wbr>/resources<wbr>/threat<wbr>-research<wbr>-blog<wbr>/ghosthook<wbr>-bypassing<wbr>-patchguard<wbr>-with<wbr>-processor<wbr>-trace<wbr>-based<wbr>-hooking*](https://www.cyberark.com/resources/threat-research-blog/ghosthook-bypassing-patchguard-with-processor-trace-based-hooking).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Two other relatively recent examples of malware that evade PatchGuard are InfinityHook
    ([*https://<wbr>github<wbr>.com<wbr>/everdox<wbr>/InfinityHook*](https://github.com/everdox/InfinityHook)),
    which abuses a kernel API called <samp class="SANS_TheSansMonoCd_W5Regular_11">NtTraceEvent</samp>,
    and ByePg ([*https://<wbr>github<wbr>.com<wbr>/can1357<wbr>/ByePg*](https://github.com/can1357/ByePg)),
    which hijacks a kernel structure called the <samp class="SANS_TheSansMonoCd_W5Regular_11">HalPrivateDispatchTable</samp>.
    Both of these circumvent PatchGuard in different ways. Note, however, that Microsoft
    has been quick to patch some of these known vulnerabilities in PatchGuard, forcing
    malware authors to adapt.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned at the beginning of this section, another security control Microsoft
    has implemented is Driver Signature Enforcement (DSE), sometimes called *digital
    signature enforcement*, which has been released for Windows Vista (x64) and more
    recent versions. DSE ensures that only pre-verified (signed) drivers are allowed
    to be loaded into kernel memory. In theory, legitimate drivers will be permitted,
    while suspicious, unsigned drivers will be prevented from loading. You read earlier
    in the chapter how malware can circumvent this control by using a malicious kernel
    driver signed with a legitimate certificate or by using BYOVD techniques. Microsoft
    recommends dealing with this problem by using *blocklists* of known vulnerable
    drivers. If a driver is reported to be vulnerable or is actively being misused,
    Microsoft adds it to the blocklist, which prevents it from being installed later.
    You can enforce this feature by enabling the “Microsoft Vulnerable Driver Blocklist”
    security option in later versions of Windows. The primary concerns with this control
    are that some legitimate drivers may be prevented from loading and that it protects
    only against known malicious drivers.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Finally, *early launch anti-malware (ELAM)* is a feature of some endpoint defense
    software that protects the Windows boot process. ELAM is responsible for loading
    anti-malware kernel components prior to other third-party components. This ensures
    that the anti-malware is properly loaded and running before rootkits or any other
    persistent malware have the opportunity to load and execute. ELAM can be a good
    defense against rootkits. However, as ELAM drivers aren’t loaded until later stages
    in the boot process, ELAM alone might not prevent loading of bootkits.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: For defense against bootkits and UEFI rootkits, you can enable *Secure Boot*.
    Available on most modern hardware, Secure Boot prevents malicious code from hijacking
    the Windows boot process. Upon boot-up, Secure Boot verifies the integrity of
    UEFI firmware drivers and the operating system itself before allowing the system
    to fully boot. This provides a layer of protection in the event malware has embedded
    itself in a UEFI chip. Secure Boot is optional in most versions of Windows, but
    it’s required in Windows 11\. As with all security controls, however, various
    implementations of Secure Boot have vulnerabilities that could be exploited by
    malware. Researchers from Eclypsium ([*https://<wbr>eclypsium<wbr>.com*](https://eclypsium.com))
    reported on some of these vulnerabilities in 2020 and 2022, for example.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: As a final note, many Windows rootkit protections, such as PatchGuard and DSE,
    are for x64 (64-bit) versions of Windows only. This leaves x86 (32-bit) versions
    of Windows potentially exposed to a host of dangerous low-level malware. Fortunately,
    precisely because these security features aren’t enabled in x86 mode, EDR and
    anti-malware can use these same techniques for good, to monitor and protect the
    endpoint.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This chapter covered the fundamentals of rootkits: how kernel modules work,
    how malware installs malicious modules, and how threat actors bypass protections
    such as signed driver enforcement. We discussed some common rootkit techniques
    such as DKOM, kernel hooking, IRP interception, and kernel callback abuse. You
    were introduced to bootkits and also saw how kernel-space malware can bypass built-in
    Windows protection mechanisms like PatchGuard. This chapter has only scratched
    the surface of rootkits and kernel manipulation techniques, however, so if you’re
    interested in learning more, I encourage you to review [Appendix C](appendix-C.xhtml)
    for more resources. In the next chapter, we’ll discuss how modern malware evades
    endpoint defenses and investigators by leveraging “fileless” and anti- forensics
    techniques.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
