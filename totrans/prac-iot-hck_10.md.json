["```\n#elif defined(STM32)       // STM32 bluepill, \n byte       pins[] = {  10 ,  11 ,  12 ,  13 ,  14 ,  15 ,  16 ,  17, 18 , 19 , 21 , 22  };\n```", "```\n# **apt-get install arduino**\n```", "```\n$ **wget https://github.com/rogerclarkmelbourne/Arduino_STM32/archive/master.zip**\n$ **unzip master.zip**\n$ **cp -r Arduino_STM32-master /home/***ithilgore***/Arduino/hardware/**\n$ **cd /home/***ithilgore***/Arduino/hardware/Arduino_STM 32-master/tools/linux**\n$ **./install.sh**\n```", "```\n$ **sudo apt-get install libusb-1.0-0:i386**\n```", "```\n$ **sudo apt-get install libtool autoconf texinfo libusb-dev libftdi-dev libusb-1.0**\n$ **git clone git://git.code.sf.net/p/openocd/code openocd**\n$ **cd openocd**\n$ **./bootstrap**\n$ **./configure --enable-maintainer-mode --disable-werror --enable-buspirate --enable-ftdi** \n$ **make**\n$ **sudo make install**\n```", "```\n$ **sudo apt install gdb gdb-multiarch**\n```", "```\nconst byte bufsiz = 32; 1\nchar buf[bufsiz];\nboolean new_data = false;\nboolean start = true;\n\nvoid setup() { 2\n  delay(3000);\n  Serial1.begin(9600);\n}\n\nvoid loop() { 3\n  if (start == true) {\n    Serial1.print(\"Login: \");\n    start = false;\n  }\n  recv_data();\n  if (new_data == true)\n    validate();\n}\n\nvoid recv_data() { 4\n  static byte i = 0;\n static char last_char;\n  char end1 = '\\n';\n  char end2 = '\\r';\n  char rc;\n\n  while (Serial1.available() > 0 && new_data == false) { 5\n    rc = Serial1.read();       \n    // skip next character if previous one was \\r or \\n and this one is \\r or \\n\n    if ((rc == end1 || rc == end2) && (last_char == end2 || last_char == end1)) 6\n      return;\n    last_char = rc;\n\n    if (rc != end1 && rc != end2) { 7\n      buf[i++] = rc;\n      if (i >= bufsiz)\n        i = bufsiz - 1;\n    } else { 8\n      buf[i] = '\\0'; // terminate the string\n      i = 0;\n      new_data = true;       \n    }\n  } \n}\n\nvoid validate() { 9\n  Serial1.println(buf);\n  new_data = false;\n  if (strcmp(buf, \"sock-raw.org\") == 0) a\n    Serial1.println(\"ACCESS GRANTED\");\n  else {\n    Serial1.println(\"Access Denied.\");\n    Serial1.print(\"Login: \");\n  }\n}\n```", "`````````` The `setup()` function 2 is a built-in Arduino function that gets executed once when the program initializes. Inside this function, we initialize the serial interface (`Serial1.begin`) with``a baud rate of 9600 bits per second. Note that `Serial1` is different from `Serial`, `Serial2`, and `Serial3`, each of which corresponds to different UART pins on the black pill. The object `Serial1` corresponds to pins A9 and A10\\.``   ````````` The `loop()` function 3 is another built-in Arduino function that gets called automatically after `setup()`, looping consecutively and executing the main program. It continuously calls `recv_data()`, which is responsible for receiving and validating serial data. When the program has finished receiving all bytes (which happens when `new_data` becomes `true`), `loop()` calls `validate()`, which checks whether the received bytes constitute the correct passphrase.    The `recv_data()` function 4 begins by defining two *static* variables (which means their value will be retained between every call of this function): `i` for iterating through the `buf` array and `last_char` for storing the last character we read from the serial port. The `while` loop 5 checks whether there are any bytes available for reading from the serial port (through `Serial1.available`), reads the next available byte with `Serial1.read`,``and checks whether the previously stored character (which is held in `last_char`) is a carriage return `‘\\r’` or new line `‘\\n’` 6. It does that so it can deal with devices that send a carriage return, new line, or both to terminate their lines when they send serial data. If the next byte doesn’t indicate the end of the line 7, we store the newly read byte `rc` in `buf` and increment the `i` counter by one. If `i` reaches the end of the buffer length, the program no longer stores any new bytes in the buffer. If the read byte signifies the end of the line 8, meaning the user on the serial interface most likely pressed ENTER, we null terminate the string in the array, reset the `i` counter, and set `new_data` to `true`.``   ```````` In that case, we call the `validate()` function 9, which prints the received line and compares it with the correct password a. If the password is correct, it prints `ACCESS GRANTED`. Otherwise, it prints `Access Denied` and prompts the user to try logging in again.    ### Flashing and Running the Arduino Program    Now upload the Arduino program to the black pill. This process varies slightly depending on whether or not you purchased the black pill with the Arduino bootloader preflashed, but we’ll walk through both methods. You could also upload the program using a third method: a serial adapter, which allows you to flash your own bootloader (such as [https://github.com/rogerclarkmelbourne/STM32duino-bootloader/](https://github.com/rogerclarkmelbourne/STM32duino-bootloader/)), but we won’t cover this process here; you’ll find multiple resources online for doing this.    Either way, we’ll use the ST-Link programmer and write the program to the main flash memory. Alternatively, you could write it to the embedded SRAM if you encounter any problems with writing it to flash. The main problem with that approach is that you’ll have to reupload the Arduino program every time you power cycle the device, because the SRAM content is volatile, which means it gets lost every time you power off the device.    #### Selecting the Boot Mode    To make sure you upload the program to the black pill’s flash memory, you’ll have to select the correct boot mode. STM32F10*xxx* devices have three different boot modes, which you can choose from using the *BOOT1* and *BOOT0* pins, as shown in [Table 7-1](#table7-1). Reference the pinout diagram in [Figure 7-11](#figure7-11) to locate these two pins on the black pill.      Table 7-1: Boot Modes for the Black Pill and Other STM32F10*xxx* Microcontrollers       | **Boot mode selection pins** | **Boot mode** | **Aliasing** | | --- | --- | --- | | BOOT1 | BOOT0 |  |  | | x | 0 | Main flash memory | Selects the main flash memory as the boot space | | 0 | 1 | System memory | Selects the system memory as the boot space | | 1 | 1 | Embedded SRAM | Selects the embedded SRAM as the boot space |    Use the jumper pin that comes with the black pill to select the boot mode. A *jumper pin* is a set of small pins in a plastic box that creates an electrical connection between two pin headers ([Figure 7-12](#figure7-12)). You can use the jumper pin to connect the boot mode selection pins to VDD (logical 1) or GND (logical 0).  ![f07012](Images/f07012.png)    Figure 7-12: A jumper pin, also known as a jumper shunt or shunt      Connect the jumper pin for both BOOT0 and BOOT1 of the black pill to the GND. If you wanted to write to SRAM, you would connect both to VDD.    #### Uploading the Program    To upload the program, first, make sure the jumpers for BOOT0 and BOOT1 are connected to the GND. Create a new file in the Arduino IDE, copy and paste the code from [Listing 7-1](#listing7-1) into it, and then save the file. We used the name *serial-simple*. Click **Tools**▶**Board** and select **Generic STM32F103C series** in the **STM32F1 Boards** section. Next, click **Tools**▶**Variant** and select **STM32F103C8 (20k RAM, 64k Flash)**, which should be the default option. Check that **Tools**▶**Upload method** is set to **STLink** and, ideally, that **Optimize** is set to **Debug (-g)**.This ensures that debug symbols appear in the final binary. Leave the rest of the options as-is.    If the black pill has the Arduino bootloader flashed, you can directly connect it to your computer via the USB cable without the ST-Link programmer. Then set the **Upload** method to **STM32duino bootloader** instead of **STLink**. But for learning purposes, we’ll use the ST-Link programmer, so you don’t need the bootloader preflashed.    To upload the program to the black pill, connect the ST-Link programmer to it. Use four jumper wires to link the SWCLK, SWDIO, GND, and 3.3 V pins of the ST-Link to the CLK, DIO, GND, 3.3 V pins of the black pill, respectively. These pins are located on the bottom part of the black pill’s pin header. Reference [Figure 7-14](#figure7-14) and [Figure 7-15](#figure7-15) to see what this looks like.    #### Using a Logic Analyzer to Identify the UART Pins    Next, identify the UART pins on the device. We showed you how to do this with a multimeter earlier in this chapter, but now we’ll use a logic analyzer to identify a UART TX pin. A TX pin transmits output, so it’s easy to recognize. You can use an inexpensive HiLetgo USB logic analyzer with eight channels for this exercise, because it’s compatible with the Saleae Logic software we’ll use. Download that software for your operating system from [https://saleae.com/downloads/](https://saleae.com/downloads/). (We used the Linux version in this example.) Then unzip the bundle to a local folder, browse to it in a terminal, and enter the following:    ``` $ **sudo ./Logic** ```    This command will open Saleae Logic’s graphic interface. Leave it open for now.    Make sure any system you’re testing is powered off when you connect the logic analyzer’s probes to it to avoid short-circuiting. In this case, because the black pill is powered by the ST-Link programmer, temporarily disconnect the programmer from your computer’s USB port. Remember that if you power off the black pill after uploading the Arduino code to the SRAM instead of the flash, you’ll have to reupload the code to the black pill.    Use a jumper wire to connect one of your logic analyzer’s GND pins to one of the black pill’s GND pins so they share a common ground. Next, use two more jumper wires to connect the logic analyzer’s CH0and CH1 channels (all channel pins should be labeled) to the black pill’s A9 and A10 pins. Connect the logic analyzer to a USB port on your computer.    In the Saleae interface, you should see at least a couple of channels in the left pane, each of which corresponds to one of the logic analyzer’s channel pins. You can always add more channels, if your logic analyzer supports them, so you can sample more pins at the same time. Add them by clicking the two arrows next to the green Start button to open the settings. You can then select how many channels you want to display by toggling the number next to each channel.    In the settings, change the **Speed (Sample Rate)** to 50 kS/s and the **Duration** to 20 seconds. As a rule, you should sample digital signals at least four times faster than their bandwidth. With serial communications, which are generally very slow, a 50 kS/s sampling rate is more than enough, although sampling faster than this does no harm. As for the duration, 20 seconds is enough time for the device to power on and start transmitting data.    Click the **Start** button to begin capturing the signals and immediately power on the black pill by connecting the ST-Link programmer to a USB port. The session will last for 20 seconds, but you can stop it at any time before then. If you don’t see any data on the channels, try power cycling the black pill while the session is on. At some point, you should see a signal coming from the channel corresponding to the A9 (TX) pin. Zoom in or out using your mouse wheel to inspect it more clearly.    To decode the data, click the **+** beside **Analyzers** in the Graphical User Interface (GUI)’s right pane, select **Async Serial**, choose the channel on which you’re reading the signal, and set the **Bit Rate** to 9600\\. (The bit rate in this case is the same as the baud rate.) Note that when you don’t know the bit rate, you can select **Use Autobaud** and let the software work its magic to detect the right one. You should now see the `Login:` prompt from the Arduino program as a series of UART packets in the signal you just captured ([Figure 7-13](#figure7-13)).  ![f07013](Images/f07013.png)    Figure 7-13: Decoding the UART data coming from the black pill’s TX pin using the Saleae Logic software. In the bottom right, you can see the `Login:` prompt that the Arduino program runs when the device boots.      Notice in [Figure 7-13](#figure7-13) how the device sends the letter “L,” which indicates the beginning of the login message. The communication starts with an idle line (at a logical 1 value). The black pill then sends a start bit with a logical 0 value, followed by the data bits, from least to most significant. In ASCII, the letter L is 0x4C, or 00110010 in binary, as you can see in the transmission. Finally, the black pill sends a stop bit (with a logical 1 value), before beginning the letter “o.”    We placed two timing markers (A1 and A2 in [Figure 7-13](#figure7-13)) on either side of one random bit. *Timing markers* are annotations that you can use to measure the time elapsed between any two locations in your data. We measured a duration of 100 μs, which proves that the transmission has a baud rate of 9600 bits/sec. (One bit takes 1/9600 seconds to transmit, or 0.000104 seconds, which is roughly 100 μs.)    #### Connecting the USB to a Serial Adapter    To test the USB-to-serial adapter, let’s connect it to our computer. Some USB-to-serial adapters, including the one we used, come with a jumper pin preinstalled on the RX and TX pins ([Figure 7-12](#figure7-12)). The jumper pin will short-circuit the RX and TX pin headers, creating a loop between them. This is useful for testing that the adapter works: connect it to your computer’s USB port and then open a terminal emulator program, such as `screen` or `minicom`, to that port. Try using the terminal emulator to send serial data to the connected devices. If you see the keystrokes echoed in the terminal, you know the adapter works. The reason is that your keyboard sends characters through the USB port to the adapter’s TX pin; because of the jumper, the characters get sent to the RX pin and then returned to the computer through the USB port.    Plug the adapter into your computer with the jumper pin in place, and then enter the following command to see which device file descriptor it was assigned to:    ``` $ **sudo dmesg**  … usb 1-2.1: FTDI USB Serial Device converter now attached to ttyUSB0 ```    Typically, it will be assigned to */dev/ttyUSB0* if you don’t have any other peripheral devices attached. Then start `screen` and pass it the file descriptor as an argument:    ``` $ **screen /dev/ttyUSB0** ```    To exit the screen session, press CTRL-A followed by **\\**.    You can also provide the baud rate as a second argument. To find the current baud rate of the adapter, enter the following:    ``` $ **stty -F /dev/ttyUSB0** speed 9600 baud; line =0; … ```    This output shows that the adapter has a baud speed of 9600\\.    Verify that the adapter is working and then remove the jumper pin, because we’ll need to connect the RX and TX pins to the black pill. [Figure 7-14](#figure7-14) shows the connections you have to make.    Connect the adapter’s RX pin to a TX pin on the black pill (pin A9, in this case). Then connect the adapter’s TX pin to the black pill’s RX pin (A10). Using A9 and A10 is important, because these pins correspond to the `Serial1` interface we used in the Arduino code.    The USB-to-serial adapter must have the same GND as the black pill, because the devices use GND as a point of reference for voltage levels. The Clear to Send (CTS) pin should be set to GND as well, because it’s considered active when low (meaning at a logic level of 0). If it weren’t connected to GND, it would float high, indicating that the adapter isn’t clear to send bytes to the black pill.  ![f07014](Images/f07014.png)    Figure 7-14: Pin connections between the black pill, ST-Link, USB-to-serial adapter, and laptop      #### Connecting to a Computer    Once you’ve connected the black pill, ST-Link, and USB-to-serial adapter, connect the ST-Link to a USB port on your computer. Then connect the adapter to a USB port. [Figure 7-15](#figure7-15) shows an example setup.    Now that the setup is ready, return to the Arduino IDE. Enable verbose output by clicking **File**▶**Preferences** and selecting the **Show verbose output during: compilation** checkbox. Then click **Sketch**▶**Upload** to compile the program and upload it to the black pill.  ![f07015](Images/f07015.png)    Figure 7-15: The black pill, ST-Link programmer, and USB-to-serial adapter are connected using jumper wires. Note that the black pill isn’t connected to any USB port; the ST-Link programmer powers it.      Because we enabled verbose output in the Arduino IDE, compiling and uploading the program should give you a lot of information about the process, including a temporary directory that stores the intermediate files necessary for compilation ([Figure 7-16](#figure7-16)).  ![f07016](Images/f07016.png)    Figure 7-16: Verbose output from Arduino IDE when compiling and uploading the program. Highlighted is the temporary directory you’ll need.      On Linux, this directory typically looks like */tmp/arduino_build_336697*, where the last number is a random identifier (yours will obviously be different) that changes with new builds. When you compile your program, take note of this directory, because you’ll need it later.    At this point, open the serial monitor console by clicking **Tools**▶**Serial Monitor**. The *Serial Monitor* is a pop-up window that can send and receive UART data to and from the black pill. It has similar functionality to `screen`, used earlier, but it’s built into the Arduino IDE for convenience. Click **Tools**▶**Port** to make sure you’ve selected the USB port to which your USB-to-serial adapter is connected. Check that the Serial Monitor’s baud rate is 9600, like we specified in the code. You should then see the `Login:` prompt from our Arduino program. Enter some sample text to test the program. [Figure 7-17](#figure7-17) shows a sample session.    If you enter anything other than `sock-raw.org`, you should get the `Access Denied` message. Otherwise, you should get the `ACCESS GRANTED` message.  ![f07017](Images/f07017.png)    Figure 7-17: The Serial Monitor pop-up window in the Arduino IDE      ### Debugging the Target    Now it’s time for the main exercise: debugging and hacking the black pill. If you followed all of the previous steps, you should have a fully working debugging environment and the black pill should contain the Arduino program we wrote.    We’ll use OpenOCD to communicate with the black pill using SWD through the ST-Link programmer. We’ll leverage that connection to open a remote debugging session with GDB. Then, using GDB, we’ll walk through the program’s instructions and bypass its authentication check.    #### Running an OpenOCD Server    We’ll start OpenOCD as a server. We need OpenOCD to communicate with the black pill through SWD. To run it against the black pill’s STM32F103 core using the ST-Link, we have to specify the two relevant configuration files using the `-f` switch:    ``` $ **sudo openocd -f /usr/local/share/openocd/scripts/interface/stlink.cfg -f /usr/local/share/openocd/scripts/targets/stm32f1x.cfg**  [sudo] password for ithilgore:  Open On-Chip Debugger 0.10.0+dev-00936-g0a13ca1a (2019-10-06-12:35) Licensed under GNU GPL v2 For bug reports, read \thttp://openocd.org/doc/doxygen/bugs.html Info : auto-selecting first available session transport \"hla_swd\". To override use 'transport select <transport>'. Info : The selected transport took over low-level target control. The results might differ compared to plain JTAG/SWD Info : Listening on port 6666 for tcl connections Info : Listening on port 4444 for telnet connections Info : clock speed 1000 kHz Info : STLINK V2J31S7 (API v2) VID:PID 0483:3748 Info : Target voltage: 3.218073 Info : stm32f1x.cpu: hardware has 6 breakpoints, 4 watchpoints Info : Listening on port 3333 for gdb connections ```    These configuration files help OpenOCD understand how to interact with the devices using JTAG and SWD. If you installed OpenOCD from source, as described earlier, these configuration files should be in */usr/local/share/openocd*. When you run the command, OpenOCD will start accepting local Telnet connections on TCP port 4444 and GDB connections on TCP port 3333.    At this point, we’ll connect to the OpenOCD session with Telnet and begin issuing some commands to the black pill over SWD. In another terminal, enter the following:    ``` $ **telnet localhost 4444** Trying 127.0.0.1... Connected to localhost. Escape character is '^]'. Open On-Chip Debugger > 1**reset init**  target halted due to debug-request, current mode: Thread  xPSR: 0x01000000 pc: 0x08000538 msp: 0x20005000 > 2**halt**  > 3**flash banks**  #0 : stm32f1x.flash (stm32f1x) at 0x08000000, size 0x00000000, buswidth 0, chipwidth 0 > 4**mdw 0x08000000 0x20**  0x08000000: 20005000 08000539 080009b1 080009b5 080009b9 080009bd 080009c1 08000e15  0x08000020: 08000e15 08000e15 08000e15 08000e15 08000e15 08000e15 08000e15 08000e35  0x08000040: 08000e15 08000e15 08000e15 08000e15 08000e15 08000e15 08000a11 08000a35  0x08000060: 08000a59 08000a7d 08000aa1 080008f1 08000909 08000921 0800093d 08000959  > 5**dump_image firmware-serial.bin 0x08000000 17812**  dumped 17812 bytes in 0.283650s (61.971 KiB/s) ```    The `reset init` command 1 halts the target and performs a hard reset, executing the *reset-init* script that is associated with the target device. This script is an event handler that performs tasks like setting up clocks and JTAG clock rates. You can find examples of these handlers if you inspect the *openocd/scripts/targets/*``` directory’s *.cfg* files. The `halt` command 2 sends a halt request for the target to halt and enter debug mode. The `flash banks` command 3 prints a one-line summary of each flash memory area that was specified in the OpenOCD *.cfg* file (in this case, *stm32f1x.cfg*). It printed the black pill’s main flash memory, which starts at the address `0x08000000`.`` This step is important, because it can help you identify which segment of memory to dump firmware from.`Note that sometimes the size value isn’t reported correctly. Consulting the datasheets remains the best resource for this step.` `` ```   ``````` `````` ````` We then send the 32-bit memory access command `mdw` 4, starting at that address, to read and display the first 32 bytes of flash memory. Finally, we dump the target’s memory from that address for `17812` bytes and save it into a file named *firmware-serial.bin* in our computer’s local directory 5. We got the number 17812 by inspecting the size of the Arduino program file loaded in the flash memory. To do this, issue the following command from the temporary Arduino build directory:    ``` /tmp/arduino_build_336697 $ **stat -c '%s' serial-simple.ino.bin**  17812 ```    You can then use tools like colordiff and xxd to see whether there are any differences between the *firmware-serial.bin* file that we dumped from the flash memory and the *serial-simple.ino.bin* file that we uploaded through the Arduino IDE. If you dumped the exact number of bytes as the size of the Arduino program, there should be no differences in the output of `colordiff`:    ``` $ **sudo apt install colordiff xxd** $ **colordiff -y <(xxd serial-simple.ino.bin) <(xxd firmware-serial.bin) | less** ```    We recommend you experiment with more OpenOCD commands; they’re all documented on its website. One useful command to try is the following:    ``` `` > `flash write_image erase custom_firmware.bin 0x08000000` `` ```    You can use it to flash new firmware.    #### Debugging with GDB    Let’s debug and alter the execution flow of the Arduino program using GDB. With the OpenOCD server already running, we can start a remote GDB session. To help us, we’ll use the *Executable and Linkable Format (ELF)* file created during the Arduino program compilation. The ELF file format is the standard file format for executable files, object code, shared libraries, and core dumps in Unix-like systems. In this case, it acts as an intermediate file during compilation.    Browse to the temporary directory returned during compilation. Make sure you change the random number part of the directory name to the one that you got from your own Arduino compilation. Then, assuming your Arduino program was named *serial-simple,* start a remote GDB session using `gdb-multiarch` with the arguments shown here:    ``` $ **cd /tmp/arduino_build_336697/** $ **gdb-multiarch** **-q** **--eval-command=\"target remote localhost:3333\" serial-simple.ino.elf** Reading symbols from serial-simple.ino.elf...done. Remote debugging using localhost:3333 0x08000232 in loop () at /home/ithilgore/Arduino/serial-simple/serial-simple.ino:15 15       if (start == true) {  (gdb) ```    This command will open the GDB session and use the local ELF binary file (called *serial-simple.ino.elf*) created by Arduino during compilation for debug symbols. *Debug symbols* are primitive data types that allow debuggers to gain access to information, such as variables and function names, from the binary’s source code.    In that terminal, you can now issue GDB commands. Start by entering the `info functions` command to verify that the symbols have indeed been loaded:    ``` (gdb) **info functions** All defined functions:  File /home/ithilgore/Arduino/hardware/Arduino_STM32-master/STM32F1/cores/maple/HardwareSerial.cpp: HardwareSerial *HardwareSerial::HardwareSerial(usart_dev*, unsigned char, unsigned char); int HardwareSerial::available(); … File /home/ithilgore/Arduino/serial-simple/serial-simple.ino: void loop(); void recv_data(); void setup(); void validate(); … ```    Now let’s place a breakpoint on the `validate()` function, because the name implies that it does some sort of checking, which might be related to authentication.    ``` (gdb) **b****reak** **validate** Breakpoint 1 at 0x800015c: file /home/ithilgore/Arduino/serial-simple/serial-simple.ino, line 55. ```    Because the debugging information recorded in the ELF binary informs GDB about what source files were used to build it, we can use the `list` command to print parts of the program’s source. You’ll rarely have this convenience in real reverse engineering scenarios, where you’ll have to rely on the `disassemble` command, which shows the assembly code instead. Here is the output of both commands:    ```  (gdb) **l****ist** **validate****,** 55     void validate() { 56       Serial1.println(buf); 57       new_data = false; 58 59       if (strcmp(buf, \"sock-raw.org\") == 0) 60         Serial1.println(\"ACCESS GRANTED\"); 61       else { 62         Serial1.println(\"Access Denied.\"); 63         Serial1.print(\"Login: \"); 64       }  (gdb) **disas****semble** **validate** Dump of assembler code for function validate():    0x0800015c <+0>: push   {r3, lr}    0x0800015e <+2>: ldr    r1, [pc, #56] ; (0x8000198 <validate()+60>)    0x08000160 <+4>: ldr    r0, [pc, #56] ; (0x800019c <validate()+64>)    0x08000162 <+6>: bl     0x80006e4 <Print::println(char const*)>    0x08000166 <+10>: ldr    r3, [pc, #56] ; (0x80001a0 <validate()+68>)    0x08000168 <+12>: movs   r2, #0    0x0800016a <+14>: ldr    r0, [pc, #44] ; (0x8000198 <validate()+60>)    0x0800016c <+16>: ldr    r1, [pc, #52] ; (0x80001a4 <validate()+72>)    0x0800016e <+18>: strb   r2, [r3, #0]    0x08000170 <+20>: bl     0x8002de8 <strcmp>    0x08000174 <+24>: cbnz   r0, 0x8000182 <validate()+38>    0x08000176 <+26>: ldr    r0, [pc, #36] ; (0x800019c <validate()+64>) … ```    If you have only the assembly code, import the file (in this case *serial-simple.ino.elf*)into a decompiler like those that Ghidra or IDA Pro provide. This will help you tremendously, because it will translate the assembly code into C, which is much easier to read ([Figure 7-18](#figure7-18)).  ![f07018](Images/f07018.png)    Figure 7-18: Using the decompiler in Ghidra to quickly read C code instead of assembly code      If you have only the *hex* file (for example, the *firmware-serial.bin*) as a result of dumping the firmware from the flash memory, you’ll first have to disassemble it using the ARM toolchain like this:    ``` $ **arm-none-eabi-objdump -D -b binary -marm -Mforce-thumb firmware-serial.bin > output.s** ```    The *output.s*`file will contain the assembly code.`   ````Next, let’s look at how we can bypass our target’s simple authentication process. Allow normal execution of the program to continue by issuing the `continue` command (or `c` for short):    ``` (gdb) **c****ontinue** Continuing. ```    The program is now waiting for serial input. Open the serial monitor from the Arduino IDE like we did on page 180, enter a sample password, like `test123`, and press ENTER. On the GDB terminal, you should see that the breakpoint for the `validate` function gets triggered. From then on, we’ll make GDB automatically display the next instruction to be executed each time the program stops by issuing the command `display/i $pc`. Then we’ll gradually step one machine instruction at a time using the `stepi` command until we reach the `strcmp` call. When we reach the `Print::println` call, we’ll use the `next` command to step over it, because it doesn’t concern us in this context ([Listing 7-2](#listing7-2)).    ``` Breakpoint 1, validate () at /home/ithilgore/Arduino/serial-simple/serial-simple.ino:55 55     void validate() { (gdb) **display/i $pc**  1: x/i $pc => 0x800015c <validate()>:  push   {r3, lr} (gdb) **stepi** halted: PC: 0x0800015e 56         Serial1.println(buf); 3: x/i $pc => 0x800015e <validate()+2>:\tldr    r1, [pc, #56]\t; (0x8000198 <validate()+60>) (gdb) **stepi** halted: PC: 0x08000160 0x08000160    56         Serial1.println(buf); 1: x/i $pc => 0x8000160 <validate()+4>:\tldr    r0, [pc, #56]\t; (0x800019c <validate()+64>) (gdb) **stepi** halted: PC: 0x08000162 0x08000162    56         Serial1.println(buf); 1: x/i $pc => 0x8000162 <validate()+6>:\tbl     0x80006e4 <Print::println(char const*)> (gdb) **next** halted: PC: 0x080006e4 57         new_data = false; 1: x/i $pc => 0x8000166 <validate()+10>:      ldr    r3, [pc, #56]\t; (0x80001a0 <validate()+68>) (gdb) **stepi** halted: PC: 0x08000168 0x08000168    57         new_data = false; 1: x/i $pc => 0x8000168 <validate()+12>:      movs   r2, #0 (gdb) **stepi** halted: PC: 0x0800016a 59\t     if (strcmp(buf, \"sock-raw.org\") == 0) 1: x/i $pc => 0x800016a <validate()+14>:ldr    r0, [pc, #44]\t; (0x8000198 <validate()+60>) (gdb) **stepi** halted: PC: 0x0800016c 0x0800016c    59         if (strcmp(buf, \"sock-raw.org\") == 0) 1: x/i $pc => 0x800016c <validate()+16>:      ldr    r1, [pc, #52]\t; (0x80001a4 <validate()+72>) (gdb) **stepi** halted: PC: 0x0800016e 57          new_data = false; 1: x/i $pc => 0x800016e <validate()+18>:\tstrb\tr2, [r3, #0] (gdb) **stepi** halted: PC: 0x08000170 59          if (strcmp(buf, \"sock-raw.org\") == 0) 1: x/i $pc => 0x8000170 <validate()+20>:      bl     0x8002de8 <strcmp> (gdb) **x/s $r0**1 0x200008ae <buf>:    \"test123\" (gdb) **x/s $r1**2 0x8003a48:    \"sock-raw.org\" ```    Listing 7-2: Stepping through our program’s validate function in GDB    The last two GDB commands (`x/s $r0` 1 and `x/s $r1` 2) display the contents of the registers `r0` and `r1` as strings. These registers should hold the two arguments passed to the `strcmp()` Arduino function, because according to the ARM Procedure Call Standard (APCS), the first four arguments of any function are passed in the first four ARM registers `r0`, `r1`, `r2`, `r3`. That means the `r0` and `r1` registers hold the addresses of the string `test123` (which we supplied as a password) and the string of the valid password, `sock-raw.org`, against which it’s compared. You can display all the registers at any time in GDB by issuing the `info registers` command (or `i r` for short).    We can now bypass authentication in multiple ways. The easiest way is to set the value of `r0` to `sock-raw.org` right before execution reaches the `strcmp()` call. You can easily do that by issuing the following GDB command:    ``` set $r0=”sock-raw.org”  ```    Alternatively, if we didn’t know the correct passphrase’s string value, we could bypass the authentication by fooling the program into thinking that `strcmp()` had succeeded. To do that, we’ll change the return value of `strcmp()` right after it returns. Notice that `strcmp()` returns 0 if it succeeds.    We can change the return value using the `cbnz` command, which stands for *compare and branch on non-zero*. It checks the register in the left operand, and if it’s not zero, *branches*, or jumps, to the destination referenced in the right operand. In this case, the register is `r0` and it holds the return value of `strcmp()`:    ```  0x08000170 <+20>:\tbl     0x8002de8 <strcmp>    0x08000174 <+24>:\tcbnz   r0, 0x8000182 <validate()+38> ```    Now we’ll step inside the `strcmp()` function by issuing another `stepi` when we reach it. Then we can step out of it by issuing a `finish` command. Immediately before the `cbnz` command executes, we’ll change the `r0` value to `0`, which indicates that `strcmp()` was successful:    ``` (gdb) **stepi** halted: PC: 0x08002de8 0x08002de8 in strcmp () 3: x/i $pc => 0x8002de8 <strcmp>:      orr.w  r12, r0, r1  (gdb) **finish** Run till exit from #0  0x08002de8 in strcmp () 0x08000174 in validate () at /home/ithilgore/Arduino/serial-simple/serial-simple.ino:59 59\t    if (strcmp(buf, \"sock-raw.org\") == 0) 3: x/i $pc => 0x8000174 <validate()+24>:      cbnz   r0, 0x8000182 <validate()+38> (gdb) **set $r0=0** (gdb) **x/x $r0** 0x0:   0x00 (gdb) **c** Continuing. ```    When we do this, our program won’t branch to the memory address 0x8000182\\. Instead, it will continue by executing the instructions immediately after `cbnz`. If you now let the rest of the program run by issuing a `continue` command, you’ll see an `ACCESS GRANTED` message in the Arduino serial monitor, indicating that you successfully hacked the program!    There are even more ways to hack the program, but we’ll leave such experimentation as an exercise for you.    ## Conclusion    In this chapter, you learned how UART, JTAG, and SWD work and how you can exploit these protocols to gain complete access to a device. Most of the chapter walked through a practical exercise that used an STM32F103C8T6 (black pill) microcontroller as a target device. You learned how to code and flash a simple Arduino program that performs a very basic authentication routine through UART. Then you interfaced with the device using a USB-to-serial adapter. We leveraged an ST-Link programmer to access SWD on the target through OpenOCD and, finally, we used GDB to dynamically bypass the authentication function.    Exploiting UART—and especially JTAG and SWD—almost always means that you can gain complete access to the device, because these interfaces were designed to give manufacturers full debugging privileges for testing purposes. Learn how to leverage them to their fullest potential and your IoT hacking journey will become much more productive!```` ````` `````` ``````` ```````` ````````` ``````````"]