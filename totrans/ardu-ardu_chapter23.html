<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>Arduino for Arduinians</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:67118b6d-3178-4c1c-99a1-6e412fe74179" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section aria-labelledby="ch23" epub:type="chapter" role="doc-chapter">
<header>
<h1 class="CHAPTER" id="ch23">
<span class="CN"><span aria-label=" Page 397. " epub:type="pagebreak" id="pg_397" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">23</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">BUILDING A MINI WEB SERVER</samp></span>
</h1>
</header>
<figure class="opener"><img alt="" class="opener" src="../images/opener-img.png"/>
</figure>
<p class="INTRO">The term <i>web server</i> may bring to mind a room full of computer servers connected by dozens of cables. However, any device with an IP address can act as a web server, including your ESP32 board. Thanks to its onboard Wi-Fi connection and software libraries, the board can respond to HTTP requests from web browser clients to display your required data.</p>
<p class="TX">In this chapter, you’ll create your own mini web server to monitor, in real time, any information gathered or generated by the ESP32 board, allowing anyone with access to the server to review the data captured without any additional software or tools. You’ll set up a simple web page using HTML to test and demonstrate the framework in this chapter and then build a web server to display ESP32 analog and digital input status and then another to display date, time, and temperature information.</p>
<p class="HeadProject"><span id="h1-166"/><span aria-label=" Page 398. " epub:type="pagebreak" id="pg_398" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #66: Creating a Basic Text Web Server</samp></p>
<p class="TNI">In this project, you’ll create a basic text web server. You can use it as a framework to display text or other information built with HTML.</p>
<p class="TX">If you haven’t already, turn to <span class="Xref"><a href="chapter19.xhtml">Chapter 19</a></span> and complete the instructions in <span class="Xref">“Configuring the Arduino IDE for the ESP32”</span> through <span class="Xref">“Testing the ESP32”</span> to get your ESP32 working. Be sure to follow the instructions to set up port forwarding, if necessary. You should also have completed <span class="Xref">“BMP180 Sensors” in <a href="chapter10.xhtml">Chapter 10</a></span>.</p>
<p class="TX">For hardware, you’ll need only the ESP32 board and matching USB cable. Once you’ve connected your ESP32 to your computer, upload the Project #66 sketch, adding your Wi-Fi network and name in the appropriate fields as originally explained in <span class="Xref">Project #55 in <a href="chapter19.xhtml">Chapter 19</a></span>.</p>
<p class="TX">Open the Serial Monitor in the Arduino IDE. You should see the network name (SSID) that the ESP32 has connected to, along with its IP address on your local network. <a href="chapter23.xhtml#fig23-1">Figure 23-1</a>, shows a connection to IP address 192.168.20.10.</p>
<figure class="IMG"><img alt="A SCREENSHOT OF SERIAL MONITOR SHOWING THE CONNECTION DETAILS" class="img1" id="fig23-1" src="../images/fig23-1.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 23-1: The Serial Monitor output for Project #66</samp></p></figcaption>
</figure>
<p class="TX">Now open a web browser and enter the IP address for your project in the URL field, as shown in <a href="chapter23.xhtml#fig23-2">Figure 23-2</a>.</p>
<figure class="IMG"><img alt="A SCREENSHOT OF THE BASIC WEB SERVER IN ACTION" class="img4" id="fig23-2" src="../images/fig23-2.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 23-2: A basic web server in action</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 399. " epub:type="pagebreak" id="pg_399" role="doc-pagebreak"/>Let’s see how this works:</p>
<span id="pro-66"/>

<pre><code>// Project #66 - Basic web page server

#include &lt;WiFi.h&gt;
WiFiServer server(80); // Set web server port to 80

char* ssid = "<var>name</var>";
char* password = "<var>password</var>";

String request; // Stores HTTP request from client (web browser)
unsigned long currentTime = millis();
unsigned long previousTime = 0;
const long timeoutTime = 2000; // Allowed client connection time

void setup()
{
    Serial.begin(115200);
    // Connect to Wi-Fi network:
    Serial.print("Connecting to ");
    Serial.println(ssid);
    WiFi.begin(ssid, password);
    while (WiFi.status() != WL_CONNECTED)
    // Show indicator while waiting for connection:
    {
        delay(500);
        Serial.print(".");
    }
    Serial.println(); // Display local IP address on Serial Monitor
    Serial.print("Connected, IP address: ");
    Serial.println(WiFi.localIP());
    // Start web server:
    server.begin();
}

void loop()
{
    String millisValue;
    String textLine = " ";
    // Listen for incoming clients from web browser
    WiFiClient client = server.available(); <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>
    if (client) // If a request received
    {
        currentTime = millis();
        previousTime = currentTime;
        Serial.println("New client connected");
        String currentLine = " ";
        while (client.connected() &amp;&amp; (currentTime - previousTime &lt;= timeoutTime))
        {// Stay connected for timeoutTime
            currentTime = millis();
            if (client.available())
            {
                char c = client.read();
                Serial.write(c);
<span aria-label=" Page 400. " epub:type="pagebreak" id="pg_400" role="doc-pagebreak"/>                request += c;
                if (c == '\n') // Client request has finished
                {
                    if (currentLine.length() == 0)
                    {
                        // Send HTTP response back to client: <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>
                        client.println("HTTP/1.1 200 OK");
                        client.println("Content-type:text/html");
                        client.println("Connection: close");
                        client.println();

                        // Build web page for display on browser:
                        client.println("&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;");

                        // Now HTML for your page:
                        client.println("&lt;h1&gt;millis() server&lt;/h1&gt;"); <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>
                        millisValue = String(millis());
                        textLine += "&lt;p&gt;ESP32 board uptime is : ";
                        textLine += millisValue;
                        textLine += " milliseconds&lt;/p&gt;";

                        client.println(textLine);
                        client.println("&lt;/body&gt;&lt;/html&gt;"); <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>
                        // End the response to client request:
                        client.println();
                        break;
                    } else
                    {// If you received a newline, clear currentLine:
                        currentLine = " ";
                    }
                } else if (c != '\r')
                {
                    currentLine += c;
                }
            }
        }
        request = " ";
        // Close connection to client:
        client.stop(); <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>
        Serial.println("Disconnected.");
    }
}</code></pre>

<p class="TX">The sketch first includes the Wi-Fi library and initializes an instance of a web server with port number 80. The client computer will use this port number to contact the web server. That is, if you’re using a static IP address, you’ll enter the IP address followed by <samp class="SANS_TheSansMonoCd_W5Regular_11">:80</samp> in the web browser’s URL field to reach the web server.</p>
<p class="TX">The sketch then declares the required variables, including <samp class="SANS_TheSansMonoCd_W5Regular_11">timeoutTime</samp>, the length of time in milliseconds that a client can stay connected to your web server. If you plan to allow many clients to use the web server, you may want to reduce this number, as the server can deal with only one client request at a time.</p>
<p class="TX"><span aria-label=" Page 401. " epub:type="pagebreak" id="pg_401" role="doc-pagebreak"/>In <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>, the code starts the Serial Monitor and then connects to the Wi-Fi network as usual. Once connected, the IP address is displayed in the Serial Monitor and the web server starts. In <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp>, the ESP32 waits for an incoming request from an HTTP client (a web browser on a remote device) <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. When it receives such a request, the sketch records the current value returned by <samp class="SANS_TheSansMonoCd_W5Regular_11">millis()</samp> to determine how long the client stays connected. As long as the amount of time the client is connected is less than the limit set earlier, your web server receives the client request and sends it to the Serial Monitor for debugging and observational purposes.</p>
<p class="TX">When the client request ends, the server sends the following HTTP response in HTML <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>:</p>

<pre><code>HTTP/1.1 200 OK
Content-type:text/html
Connection: close
</code></pre>

<p class="TX">To send your web page HTML code back to the client web browser, the sketch uses <samp class="SANS_TheSansMonoCd_W5Regular_11">client.print()</samp> to send text to the web client and then uses <samp class="SANS_TheSansMonoCd_W5Regular_11">.println()</samp>to send text followed by a newline character to the client, starting with the page initialization. You’ll need to begin with this page initialization line of HTML every time you form a web page.</p>
<p class="TX">Next, the sketch sends the contents of the web page in the form of the following HTML code:</p>

<pre><code>&lt;h1&gt;millis() server&lt;/h1&gt;
&lt;p&gt;ESP32 board uptime is : <var>millis</var> &lt;/p&gt;
</code></pre>

<p class="TX">The sketch replaces <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">millis</samp> in the HTML with the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">millis()</samp> by building up a line of text after the header <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;h1&gt;</samp> line <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> into a string and then sending the string with the <samp class="SANS_TheSansMonoCd_W5Regular_11">client.println(textLine)</samp> function.</p>
<p class="TX">The sketch sends the line to end your web page <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. As with the page initialization code, you’ll always use this same line to end a web page in similar projects. Finally, the sketch closes the connection to the client <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> and the ESP32 awaits a new request.</p>
<p class="TX">In the next project, you’ll build on the skills you just learned to display data relating to the ESP32’s I/O ports on a web page.</p>
<p class="HeadProject"><span id="h1-167"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #67: Creating an ESP32 I/O Port Monitor</samp></p>
<p class="TNI">This project displays the status of four digital input pins and four analog input pins on your ESP32 board. This gives you the framework for a web server that displays data from devices with analog outputs read by the ESP32’s analog inputs, such as light sensors or potentiometers, and data from devices with simple digital outputs, such as motion sensors or door-activated switches. In this case, you’ll stimulate these types of sensors with buttons and trimpots.</p>
<p class="TX"><span aria-label=" Page 402. " epub:type="pagebreak" id="pg_402" role="doc-pagebreak"/>You will need:</p>
<ul class="ul">
<li class="BL">An ESP32 dev board and matching USB cable</li>
<li class="BL">A solderless breadboard</li>
<li class="BL">Assorted jumper wires</li>
<li class="BL">Four tactile buttons</li>
<li class="BL">Four 10 kΩ, 0.25 W, 1 percent resistors</li>
<li class="BL">Four 10 kΩ breadboard-compatible trimpots</li>
</ul>
<p class="TX">Assemble the circuit as shown in <a href="chapter23.xhtml#fig23-3">Figure 23-3</a>.</p>
<figure class="IMG"><img alt="THE SCHEMATIC FOR PROJECT #67" class="img1" id="fig23-3" src="../images/fig23-3.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 23-3: The schematic for Project #67</samp></p></figcaption>
</figure>
<p class="TX">Upload the sketch, adding your Wi-Fi network and name in the fields at the top of the sketch, then open the Serial Monitor in the Arduino IDE. The Serial Monitor should show the network name (SSID) of the Wi-Fi network to which the ESP32 has connected, along with the ESP32’s IP address on your local network.</p>
<p class="TX">Open this IP address in a web browser using a device on your local network. You should be presented with the status website served up by the ESP32. Adjust the trimpots to random positions, hold down one or more buttons in the circuit, and then refresh the web browser. The next display should show the values measured by the ADC pins and the status of the four digital inputs, as shown in <a href="chapter23.xhtml#fig23-4">Figure 23-4</a>.<span aria-label=" Page 403. " epub:type="pagebreak" id="pg_403" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="A SCREENSHOT OF THE EXAMPLE OUTPUT FOR PROJECT #67" class="img5" id="fig23-4" src="../images/fig23-4.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 23-4: Example output from Project #67</samp></p></figcaption>
</figure>
<p class="TX">Unlike the Arduino Uno and compatible boards, whose ADC has a range of 0 through 1,023 thanks to its 10-bit resolution, the ADC on the ESP32 boards has a range of 0 through 4,095, as it uses 12-bit resolution (2<sup>12</sup> = 4,096). You can also see the calculated voltage for the ADC inputs in the last item of data for each analog pin’s status on the web page.</p>
<p class="TX">Let’s see how this works:</p>
<span id="pro-67"/>

<pre><code>// Project #67 - ESP32 I/O monitor

#include &lt;WiFi.h&gt;
WiFiServer server(80); // Set web server port to 80

char* ssid = "<var>SSID</var>";
char* password = "<var>password</var>";

String request; // Stores HTTP request from client (web browser)

unsigned long currentTime = millis();
unsigned long previousTime = 0;
const long timeoutTime = 2000; // Allowed client connection time

void setup()
{
    Serial.begin(115200);
    pinMode(18, INPUT);
    pinMode(19, INPUT);
    pinMode(23, INPUT);
    pinMode(5, INPUT);

    // Connect to Wi-Fi network:
    Serial.print("Connecting to ");
    Serial.println(ssid);
    WiFi.begin(ssid, password);
<span aria-label=" Page 404. " epub:type="pagebreak" id="pg_404" role="doc-pagebreak"/>    while (WiFi.status() != WL_CONNECTED)
    // Show indicator while waiting for connection:
    {
        delay(500);
        Serial.print(".");
    }
    Serial.println(); // Display local IP address on Serial Monitor
    Serial.print("Connected, IP address: ");
    Serial.println(WiFi.localIP());
    // Start web server
    server.begin();
}

void loop()
{
    String textLine = " "; <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>
    int IO18, IO19, IO23, IO5;
    float IO2, IO4, IO35, IO34;
    float IO2A, IO4A, IO35A, IO34A;
    String IO2S, IO4S, IO35S, IO34S;
    // Listen for incoming clients from web browser:
    WiFiClient client = server.available();
    if (client) // If a request received
    {
        currentTime = millis();
        previousTime = currentTime;
        Serial.println("New client connected");
        String currentLine = " ";
        while (client.connected() &amp;&amp; (currentTime - previousTime &lt;= timeoutTime))
        {// Stay connected for timeoutTime:
            currentTime = millis();
            if (client.available())
            {
                char c = client.read();
                Serial.write(c);
                request += c;
                if (c == '\n') // Client request has finished
                {
                    if (currentLine.length() == 0)
                    {

                        // Send HTTP response back to client:
                        client.println("HTTP/1.1 200 OK");
                        client.println("Content-type:text/html");
                        client.println("Connection: close");
                        client.println();

                        // Build web page for display on browser:
                        client.println("&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;");

                        // Now HTML for your page:
                        client.println("&lt;h1&gt;ESP32 I/O Monitor&lt;/h1&gt;"); <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>
                        client.print ("&lt;p&gt; Status as of last update.");
                        client.println("Refresh browser for latest values.&lt;/p&gt;");
                        client.println("&lt;hr&gt;");

<span aria-label=" Page 405. " epub:type="pagebreak" id="pg_405" role="doc-pagebreak"/>                        IO18 = digitalRead(18); <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>
                        IO19 = digitalRead(19);
                        IO23 = digitalRead(23);
                        IO5 = digitalRead(5);

                        IO2 = analogRead(2);
                        IO4 = analogRead(4);
                        IO35 = analogRead(35);
                        IO34 = analogRead(34);

                        IO2A = ((IO2 / 4096) * 3.3); <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>
                        IO4A = ((IO4 / 4096) * 3.3);
                        IO35A = ((IO35 / 4096) * 3.3);
                        IO34A = ((IO34 / 4096) * 3.3);

                        client.println("&lt;p&gt;&lt;b&gt;Digital Input Status:&lt;/b&gt;&lt;/p&gt;"); <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>
                        textLine += "&lt;p&gt;Digital pin IO18 is ";
                        if (IO18 == 1)
                        {
                            textLine += "HIGH";
                        } else
                        {
                          textLine += "LOW&lt;/p&gt;";
                        }
                        client.println(textLine);
                        textLine = " ";
                        textLine += "&lt;p&gt;Digital pin IO19 is ";
                        if (IO19 == 1)
                        {
                            textLine += "HIGH";
                        } else
                        {
                            textLine += "LOW&lt;/p&gt;";
                        }
                        client.println(textLine);
                        textLine = " ";
                        textLine += "&lt;p&gt;Digital pin IO23 is ";
                        if (IO23 == 1)
                        {
                            textLine += "HIGH";
                        } else
                        {
                            textLine += "LOW&lt;/p&gt;";
                        }
                        client.println(textLine);
                        textLine = " ";
                        textLine += "&lt;p&gt;Digital pin IO5 is ";
                        if (IO5 == 1)
                        {
                          textLine += "HIGH";
                        } else
                        {
                            textLine += "LOW&lt;/p&gt;";
                        }
<span aria-label=" Page 406. " epub:type="pagebreak" id="pg_406" role="doc-pagebreak"/>                        client.println(textLine);
                        textLine = " ";
                        client.println(" ");
                        client.println("&lt;p&gt;&lt;b&gt;Analog Input Status:&lt;/b&gt;&lt;/p&gt;"); <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>
                        textLine += "Analog pin IO2 raw value: ";
                        textLine += String(IO2);
                        textLine += "; Voltage (V): ";
                        client.println(textLine);
                        client.println(IO2A);
                        client.println("&lt;/p&gt;");
                        textLine = " ";

                        textLine += "Analog pin IO4 raw value: ";
                        textLine += String(IO4);
                        textLine += "; Voltage (V): ";
                        client.println(textLine);
                        client.println(IO4A);
                        client.println("&lt;/p&gt;");
                        textLine = " ";

                        textLine += "Analog pin IO35 raw value: ";
                        textLine += String(IO35);
                        textLine += "; Voltage (V): ";
                        client.println(textLine);
                        client.println(IO35A);
                        client.println("&lt;/p&gt;");
                        textLine = " ";

                        textLine += "Analog pin IO34 raw value: ";
                        textLine += String(IO34);
                        textLine += "; Voltage (V): ";
                        client.println(textLine);
                        client.println(IO34A);
                        client.println("&lt;/p&gt;");
                        textLine = " ";
                        client.println("&lt;hr&gt;");

                        client.println("&lt;/body&gt;&lt;/html&gt;"); <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>
                        // End the response to client request:
                        client.println();
                        break;
                    } else
                    {// If you received a newline, clear currentLine:
                        currentLine = " ";
                    }
                } else if (c != '\r')
                {
                    currentLine += c;
                }
            }
        }
<span aria-label=" Page 407. " epub:type="pagebreak" id="pg_407" role="doc-pagebreak"/>        request = " ";
        // Close connection to client:
        client.stop();
        Serial.println("Disconnected.");
    }
}</code></pre>

<p class="TX">Like the previous project, this sketch serves an HTML web page after receiving a client request. The only differences are the blocks of code required to deal with the I/O values and displaying the results in HTML.</p>
<p class="TX">The sketch declares variables <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> used to store the status of each of the eight inputs—integer variables for the digital inputs, and floating-point variables for the analog inputs. It then uses string variables to store the values from the ADC that it will later combine with HTML for the web page display. The main web page construction starts <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> with a large header and some text for the user, followed by a horizontal line. The sketch stores the values of the digital inputs (1 for HIGH, 0 for LOW) <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> and then the analog values of the four ADCs, converting the latter into voltages <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>.</p>
<p class="TX">To display the input data on the web page <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>, the sketch tests the status of each digital pin, adding the results as text to the string <samp class="SANS_TheSansMonoCd_W5Regular_11">textLine</samp>. It displays that text using <samp class="SANS_TheSansMonoCd_W5Regular_11">client.print()</samp> and repeats the process for the other three digital input pins. Next, it displays the values of each analog input and the matching voltage <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>. It concatenates the required HTML text for each line into the string <samp class="SANS_TheSansMonoCd_W5Regular_11">textLin</samp>, followed by an HTML <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;/p&gt;</samp> command to end the paragraph. After the sketch sends the line to end the web page <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>, the ESP32 closes the connection and awaits a new client request.</p>
<p class="TX">Throughout the code, the sketch uses the function <samp class="SANS_TheSansMonoCd_W5Regular_11">String()</samp> to convert an integer or floating-point value to text to add that value to a larger string variable. This is the key to displaying data generated by the sketch within an HTML web page.</p>
<p class="TX">For more practice in displaying sensor data on a web page, you’ll display more types of data on the server web page in the next project.</p>
<p class="HeadProject"><span id="h1-168"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #68: Building a Time and Weather Server</samp></p>
<p class="TNI">This project builds on your existing knowledge to create a web server that displays, on request, the current time, date, temperature, and air pressure at sea level. This is a good example of displaying data from multiple sources on one web page.</p>
<p class="TX">You will need:</p>
<ul class="ul">
<li class="BL">An ESP32 dev board and matching USB cable</li>
<li class="BL">A solderless breadboard</li>
<li class="BL">Assorted jumper wires</li>
<li class="BL">A BMP180 temperature and air pressure sensor board</li>
</ul>
<p class="TX">Assemble the circuit as shown in <a href="chapter23.xhtml#fig23-5">Figure 23-5</a>.<span aria-label=" Page 408. " epub:type="pagebreak" id="pg_408" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="THE SCHEMATIC FOR PROJECT #68" class="img4" id="fig23-5" src="../images/fig23-5.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 23-5: The schematic for Project #68</samp></p></figcaption>
</figure>
<p class="TX">Upload the Project #68 sketch, adding your Wi-Fi network and name in the fields at the top of the code as usual, then open the Serial Monitor in the Arduino IDE. The Serial Monitor should display the network name (SSID) that the ESP32 has connected to, along with its IP address on your local network.</p>
<p class="TX">As discussed in <span class="Xref">“Network Time Protocol”</span> in <span class="Xref"><a href="chapter21.xhtml">Chapter 21</a></span>, you may want to change the network time server IP address and the time zone offset to suit your location.</p>
<p class="TX">Open the IP address in a web browser using a device on your local network. You should see the status website served up by the ESP32, as shown in <a href="chapter23.xhtml#fig23-6">Figure 23-6</a>. Refresh the browser to view the latest information at any given time.</p>
<figure class="IMG"><img alt="A SCREENSHOT OF THE EXAMPLE OUTPUT FROM PROJECT #68" class="img5" id="fig23-6" src="../images/fig23-6.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 23-6: Example output from Project #68</samp></p></figcaption>
</figure>
<p class="TX">Let’s see how this works:</p>
<span id="pro-68"/>

<pre><code>// Project #68 - ESP32 time and weather server

#include &lt;Adafruit_BMP085.h&gt;
Adafruit_BMP085 bmp;
#include &lt;NTPClient.h&gt;
#include &lt;WiFi.h&gt;
#include &lt;WiFiUdp.h&gt;
WiFiUDP ntpUDP;
WiFiServer server(80); // Set web server port to 80

char* ssid = "<var>SSID</var>";
char* password = "<var>password</var>";

// ntpUDP, time server pool, offset in seconds, update interval (mS)
NTPClient timeClient(ntpUDP, "<var>0.au.pool.ntp.org</var>", 36000, 60000);

<span aria-label=" Page 409. " epub:type="pagebreak" id="pg_409" role="doc-pagebreak"/>String request; // Stores HTTP request from client (web browser)

unsigned long currentTime = millis();
unsigned long previousTime = 0;
const long timeoutTime = 2000; // Allowed client connection time

void setup()
{
    Serial.begin(115200);
    bmp.begin();
    // Connect to Wi-Fi network
    WiFi.mode(WIFI_STA);
    WiFi.begin(ssid, password);
    while (WiFi.status() != WL_CONNECTED)
    {
        delay(500);
        Serial.print(".");
    }
    Serial.println(); // Display local IP address on Serial Monitor
    Serial.print("Connected, IP address: ");
    Serial.println(WiFi.localIP());
    // Start web server
    server.begin();
}

void loop()
{
    String dateString;
    String date, month, year;

    // Listen for incoming clients from web browser:
    WiFiClient client = server.available();
    if (client) // If a request received
    {
        currentTime = millis();
        previousTime = currentTime;
        Serial.println("New client connected");
        String currentLine = " ";
        while (client.connected() &amp;&amp; (currentTime - previousTime &lt;= timeoutTime))
        {// Stay connected for timeoutTime
            currentTime = millis();
            if (client.available())
            {
                char c = client.read(); // Display data from client on Serial Monitor
                Serial.write(c);
                request += c;
                if (c == '\n') // Client request has finished
                {
                    if (currentLine.length() == 0)
                    {
                        // Send HTTP response back to client
                        client.println("HTTP/1.1 200 OK");
                        client.println("Content-type:text/html");
                        client.println("Connection: close");
                        client.println();
<span aria-label=" Page 410. " epub:type="pagebreak" id="pg_410" role="doc-pagebreak"/>                        // Build web page for display on browser:
                        client.println("&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;");
                        client.println("&lt;h1&gt;ESP32 Time and Weather Server&lt;/h1&gt;");
                        client.println("&lt;p&gt;Refresh browser for latest information.&lt;/p&gt;");
                        client.println("&lt;hr&gt;");
                        client.print("&lt;p&gt;Time: ");
                        timeClient.update();
                        client.print(timeClient.getFormattedTime()); <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>
                        client.print("&lt;/p&gt;");
                        client.print("&lt;p&gt;Today is ");
                        switch (timeClient.getDay()) <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>
                        {
                            case 0: client.print("Sunday "); break;
                            case 1: client.print("Monday "); break;
                            case 2: client.print("Tuesday "); break;
                            case 3: client.print("Wednesday "); break;
                            case 4: client.print("Thursday "); break;
                            case 5: client.print("Friday "); break;
                            case 6: client.print("Saturday "); break;
                            case 7: client.print("Sunday "); break;
                        }
                        // Retrieve and format date display:
                        dateString = timeClient.getFormattedDate(); <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>
                        date = dateString.substring(8, 10);
                        client.print(date);
                        client.print("/");
                        month = dateString.substring(5, 7);
                        client.print(month);
                        client.print("/");
                        year = dateString.substring(0, 4);
                        client.print(year);
                        client.print("&lt;/p&gt;");
                        client.println("&lt;hr&gt;"); <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>
                        client.print("&lt;p&gt;Current temperature (C): ");
                        client.print(bmp.readTemperature()); <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>
                        client.print("&lt;/p&gt;");
                        client.print("&lt;p&gt;Current air pressure at ");
                        client.print("sea level (calculated) (Pa): ");
                        client.print(bmp.readSealevelPressure()); <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>
                        client.print("&lt;/p&gt;");
                        client.println("&lt;hr&gt;");
                        client.println("&lt;/body&gt;&lt;/html&gt;"); <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>
                        // End the response to client request
                        client.println();
                        break;
                        } else
                            {// If you received a newline, clear currentLine:
                                currentLine = " ";
                        }
                } else if (c != '\r')
                {
<span aria-label=" Page 411. " epub:type="pagebreak" id="pg_411" role="doc-pagebreak"/>                    currentLine += c;
                }
            }
        }
        request = " ";
        // Close connection to client:
        client.stop();
        Serial.println("Disconnected.");
    }
}</code></pre>

<p class="TX">The requirements to serve a web page are the same as with the previous project; only the code required for the recorded data and display is different. The sketch includes the required libraries and starts instances of the Wi-Fi server and the Network Time Protocol client.</p>
<p class="TX">As in previous projects, the sketch connects to the local-area network Wi-Fi and displays the connection details on the Serial Monitor. When a client request is received, the ESP32 board sends the web server HTML to the client with the first piece of data (the current time) requested from the network time server <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> and then sends the time to the web page with the <samp class="SANS_TheSansMonoCd_W5Regular_11">client.print()</samp> function. Next, the sketch retrieves the day of the week <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, determines the name of the day with a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch…case</samp> function, and sends all this information to the client.</p>
<p class="TX">The sketch stores the full date in the string <samp class="SANS_TheSansMonoCd_W5Regular_11">dateString</samp> <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. The date values (day of month, month, and year) are extracted into individual string variables so the sketch can use <samp class="SANS_TheSansMonoCd_W5Regular_11">client.print()</samp> to send them as part of the HTML.</p>
<p class="TX">The code adds a horizontal line for a neater display <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> and then retrieves and displays the temperature <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> and air pressure at sea level <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>. Finally, it completes the web page <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>, and the response to the client request is finished.</p>
<section aria-labelledby="sec1" epub:type="division">
<h2 class="H1" id="sec1"><span id="h1-169"/><samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp></h2>
<p class="TNI">In this chapter, you learned to create web pages that can display any data you can gather or calculate with devices used alongside an ESP32. From simple weather reports to data from sensors in a laboratory, you can put any of this data on the web for you or others to use.</p>
<p class="TX">The next chapter covers a final IoT skill set, demonstrating how to use an ESP32-controlled digital camera for surveillance or fun.</p>
</section>
</section>
</body>
</html>