<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch11">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_175" aria-label="175"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch11">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">11</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">BRIDGES AND ARTICULATION POINTS</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" role="presentation" alt="" width="386" height="386"/>&#13;
</figure>&#13;
<p class="ChapterIntro">In this chapter we consider another aspect of connectivity: nodes and edges that are essential to maintaining the integrity of a connected component in an undirected graph. These are known as <i>articulation points</i> and <i>bridges</i>, respectively. Understanding which nodes or edges are essential to maintaining connectivity is important in a range of real-world problems. Any time we must ensure that there is no single point of failure in a network, we need to find its bridges and articulation points.</p>&#13;
<p class="TX">After formally defining bridges and articulation points, this chapter provides a few demonstrative real-world use cases where these concepts apply, such as developing a robust transportation network for a set of islands and building the best secret labyrinth for an evil wizard. We then present two algorithms to efficiently search for these elements in <span role="doc-pagebreak" epub:type="pagebreak" id="pg_176" aria-label="176"/>undirected graphs, building on the depth-first search algorithm introduced in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h-138"/><samp class="SANS_Futura_Std_Bold_B_11">Defining Bridges and Articulation Points</samp></h3>&#13;
<p class="TNI1">For every pair of nodes in an undirected graph to be mutually reachable, they must be part of the same connected component. In <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>, we learned that a connected component in an undirected graph is a subset of nodes <i>V</i><span class="symbol">′ ⊆</span> <i>V</i> such that <i>u</i> is reachable from <i>v</i> for all pairs <i>u</i> <span class="symbol">∈</span> <i>V</i><span class="symbol">′</span> and <i>v</i> <span class="symbol">∈</span> <i>V</i><span class="symbol">′</span>. As a concrete example, consider a series of islands joined by ferries. Nodes represent islands and edges represent the ferry routes between them. To provide full travel options, the transportation planners need the resulting graph to consist of a single connected component. That is, a person must be able to travel between any two islands on the ferry network, whether by a direct connection or by a series of trips.</p>&#13;
<p class="TX"><a href="#fig11-1">Figure 11-1</a> shows an example graph with two separate connected components {0, 1, 2, 4, 5} and {3, 6, 7}.</p>&#13;
<figure class="IMG"><img id="fig11-1" class="img30" src="../images/f11001.jpg" alt="There are no edges between a node in the set containing nodes 0, 1, 2, 4, and 5 and a node in the set containing nodes 3, 6, and 7." width="461" height="419"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-1: A graph with two separate connected components</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">A <i>bridge</i> is an edge whose removal splits a single connected component into two disjoint components. <a href="#fig11-2">Figure 11-2(a)</a> shows an example graph with two bridges (1, 2) and (4, 5). Removing either edge would split the single connected component into two. Removing both would split the graph into three separate connected components, as shown in <a href="#fig11-2">Figure 11-2(b)</a>.</p>&#13;
<figure class="IMG"><img id="fig11-2" class="img100" src="../images/f11002.jpg" alt="(A) shows a graph with eight nodes. The edges (1, 2) and (4, 5) are bolded. (B) shows the same graph with those edges removed." width="1381" height="322"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-2: A graph with two bridges (a) and the three separate components that arise from removing the bridges (b)</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_177" aria-label="177"/>Similarly, an <i>articulation point</i> (or <i>cut vertex</i>) is a node whose removal splits a connected component into two or more disjoint components. For example, the graph in <a href="#fig11-3">Figure 11-3</a> has three articulation points: the shaded nodes 1, 2, and 4.</p>&#13;
<figure class="IMG"><img id="fig11-3" class="img40" src="../images/f11003.jpg" alt="a graph with eight nodes. Nodes 1, 2, and 4 are shaded." width="648" height="252"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-3: A graph with three articulation points</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><a href="#fig11-4">Figure 11-4</a> shows the impact of individually removing each of the articulation points in <a href="#fig11-3">Figure 11-3</a>.</p>&#13;
<figure class="IMG"><img id="fig11-4" class="img30" src="../images/f11004.jpg" alt="(A) shows the graph with node 1 removed. (B) shows the graph with node 2 removed. (C) shows the graph with node 4 removed." width="479" height="814"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-4: The results of removing different articulation points</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In <a href="#fig11-4">Figure 11-4(a)</a>, removing node 1 creates the components {0, 4, 5} and {2, 3, 6, 7}. <a href="#fig11-4">Figure 11-4(b)</a> shows that removing node 2 creates the components {0, 1, 4, 5} and {3, 6, 7}, while removing node 4 would create components {0, 1, 2, 3, 6, 7} and {5}, as shown in <a href="#fig11-4">Figure 11-4(c)</a>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h-139"/><samp class="SANS_Futura_Std_Bold_B_11">Use Cases</samp></h3>&#13;
<p class="TNI1">Identifying the bridges and articulation points in a graph is essential for understanding single points of failure in a network. This section provides some real-world applications for finding bridges and articulation points. We first show how to apply these concepts to create a resilient ferry network, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_178" aria-label="178"/>then examine how to extend the same techniques to prevent the spread of disease or construct optimal magical labyrinths.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h-140"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Designing Resilient Networks</samp></h4>&#13;
<p class="TNI1">A <i>resilient network</i> needs to be able to gracefully handle the loss of an individual edge or node without losing connectivity. To expand the island example from the previous section, let’s consider two hypothetical ferry networks among eight of the Hawaiian islands, as shown in <a href="#fig11-5">Figures 11-5</a> and <a href="#fig11-6">11-6</a>.</p>&#13;
<figure class="IMG"><img id="fig11-5" class="img100" src="../images/f11005.jpg" alt="A map of eight Hawaiian islands and seven edges forming a single connected component." width="1669" height="1087"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-5: A map of hypothetical ferry routes among the Hawaiian islands</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><a href="#fig11-5">Figure 11-5</a> shows a minimal ferry network needed to connect the eight islands. If all ferries are running without problems, it is possible to travel between any two islands. It might take multiple hops for someone to reach their destination, but there will be a path.</p>&#13;
<p class="TX">However, the network is fragile. If the ferry between O‘ahu (node 2) and Moloka‘i (node 3) breaks down, it splits the network in two. People can no longer travel from Maui (node 5) and Ni‘ihau (node 0). Each ferry route in the graph is a bridge. The loss of any single route would disconnect at least one island. Similarly, many of the nodes in <a href="#fig11-5">Figure 11-5</a> are articulation points. If the ferry terminal in O‘ahu (node 2) is closed due to weather, it will disconnect Kaua‘i (node 1) from Maui (node 5).</p>&#13;
<p class="TX">By understanding their network’s bridges and articulation points, planners could design a more robust network with no bridges, as shown in <a href="#fig11-6">Figure 11-6</a>. A single broken ferry (removal of an edge) won’t cut off travel <span role="doc-pagebreak" epub:type="pagebreak" id="pg_179" aria-label="179"/>between any two islands. If the ferry between O‘ahu (node 2) and Moloka‘i (node 3) breaks down, for example, a traveler could still make their way from Maui (node 5) to Ni‘ihau (node 0) via other routes. The network also lacks articulation points. If the ferry terminal in Maui closes, for instance, it cuts off only that island.</p>&#13;
<figure class="IMG"><img id="fig11-6" class="img100" src="../images/f11006.jpg" alt="A map of eight Hawaiian islands with 14 edges connecting the islands." width="1673" height="1089"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-6: A second map of hypothetical ferry routes among the Hawaiian islands</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">We can extend these concepts beyond transportation systems to computer networks, power grids, communication networks, or wastewater systems. While it’s often preferable to construct graphs without bridges or articulation points, it’s not always feasible. However, understanding a network’s weaknesses may still be helpful for planning purposes.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h-141"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Preventing the Spread of Diseases</samp></h4>&#13;
<p class="TNI1">Consider how a common cold migrates through a social network. For simplicity’s sake, let’s assume you need to be in proximity to a sick person to catch the cold. You cannot catch the cold from someone you never see. If the edges represent real-world interactions between people, the virus can pass only between neighboring nodes.</p>&#13;
<p class="TX">We can use the concept of bridges and articulation points to model or stop the spread of disease. That coffee meeting with a former workmate acts as a bridge that allows the cold to jump between two otherwise disjoint sets of people: your previous and your current coworkers. A person who self-isolates and cuts off the spread of the virus between groups is an <span role="doc-pagebreak" epub:type="pagebreak" id="pg_180" aria-label="180"/>articulation point. By not going to any events for a few weeks, you can help prevent a cold from passing between your different social circles. Your running friends, the members of your data structures reading group, and your coworkers will each be limited to their own colds without sharing any through you.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h-142"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Designing Magical Labyrinths</samp></h4>&#13;
<p class="TNI1">In contrast to the previous two cases, where we want to minimize the bridges and articulation points, imagine an evil wizard deciding where to place the most effective traps in their labyrinth. A tunnel that serves as the only connection between two sections of the labyrinth is a bridge. If one section contains the labyrinth entrance and the other contains the goal, the wizard knows that thorough adventurers must pass through the tunnel, making it a great place for the best trap. Similarly, a room that must be traversed to move between two parts of the labyrinth is an articulation point—an ideal place to deploy high-level monsters.</p>&#13;
<p class="TX">In more common settings, we can use these same techniques to place tollbooths on critical highways (bridges) or information booths at the intersection of airport terminals (articulation points). In these cases, we use the fact that people traveling from one part of the graph to another must pass through this single node or edge. Understanding the connectivity of the graph thus lets us optimize potentially scarce or expensive resources.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h3 class="H1" id="sec6"><span id="h-143"/><samp class="SANS_Futura_Std_Bold_B_11">A Bridge-Finding Algorithm</samp></h3>&#13;
<p class="TNI1">The computer scientist Robert Tarjan proposed a range of useful algorithms for understanding graphs using the properties of their depth-first search trees. This section introduces a <i>bridge-finding algorithm</i> on undirected graphs that uses this approach. The algorithm starts a depth-first search from an arbitrary node and tracks both the edges used and the order in which the nodes are first visited (the <i>order index</i> or <i>preorder index</i>, denoted <i>order</i>(<i>u</i>)). We can use this information to look for bridges by asking whether an edge in the depth-first search tree provides the only path to reach the nodes in its subtree. Edges that do not appear in the depth-first search tree <i>T</i> can be immediately ruled out as bridges because we were already able to reach the nodes without using them. This means we need to consider only the edges in <i>T</i>.</p>&#13;
<p class="TX"><a href="#fig11-7">Figure 11-7</a> shows an example of a graph and two representations of its corresponding depth-first search tree rooted at node 0. <a href="#fig11-7">Figure 11-7(a)</a> shows the initial graph. <a href="#fig11-7">Figure 11-7(b)</a> shows the corresponding depth-first search tree when starting from node 0; the number outside each node indicates the order index. <a href="#fig11-7">Figure 11-7(c)</a> shows the same tree with the <i>untraversed edges</i> as dashed lines. These untraversed edges are called <i>back edges</i> and lead back to a node that has already been visited during the depth-first search.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_181" aria-label="181"/>&#13;
<figure class="IMG"><img id="fig11-7" class="img100" src="../images/f11007.jpg" alt="(A) shows an undirected graph with seven nodes and nine edges. (B) shows a tree built from this graph with root node 0. Node 0 is labeled with order = 0 and has two children: node 1 with order = 1, and node 3 with order = 5. (C) shows the same tree as subfigure B with three additional dashed edges." width="1678" height="581"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-7: An undirected graph (a), a depth-first search tree (b), and the depth-first search tree with untraversed edges (c)</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">We can identify bridges by looking for edges leading into a subtree of <i>T</i>, where that subtree’s nodes only have neighbors in the same subtree. In other words, if the edge (<i>v</i>, <i>u</i>) is a bridge, there is no way to get into or out of the subtree of node <i>u</i> except through the edge into (<i>v</i>, <i>u</i>). Edge (1, 6) in <a href="#fig11-7">Figure 11-7(a)</a> presents one such example, providing the only path into or out of the subtree rooted at node 6. In contrast, the edge (0, 3) is not a bridge, because node 5 has an edge back to node 0.</p>&#13;
<p class="TX">The key to this algorithm is that we can look at the minimum and maximum order index in the neighborhoods of <i>u</i> and its descendants. By the properties of depth-first search, all the nodes in <i>u</i>’s subtree must have an order index in the range [<i>order</i>(<i>u</i>), <i>order</i>(<i>u</i>) + <i>K</i> − 1], where <i>K</i> is the number of nodes in the subtree (including <i>u</i>). This is because the search travels to those nodes after visiting <i>u</i> and before visiting nodes in other subtrees. If the nodes in <i>u</i>’s subtree have any neighbor with an order index outside that range, the edge to that neighbor would provide an alternate path into <i>u</i>’s subtree.</p>&#13;
<p class="TX">We can use a common simplification by observing that any unvisited nodes reachable from the subtree would be explored by the depth-first search and thus would appear in the subtree. Therefore, we need to check only for back edges to neighbors with a lower order index. We can test whether edge (<i>v</i>, <i>u</i>), where <i>v</i> is the parent of <i>u</i>, is a bridge by checking if any node in <i>u</i>’s subtree has a neighbor <i>w</i> such that <i>order</i>(<i>w</i>) &lt; <i>order</i>(<i>u</i>), excluding the connection (<i>v</i>, <i>u</i>) itself. If there is such a neighbor, we have found a back edge that bypasses (<i>v</i>, <i>u</i>) and know that (<i>v</i>, <i>u</i>) is not a bridge. Conversely, if <i>order</i>(<i>w</i>) ≥ <i>order</i>(<i>u</i>) for all the subtree’s neighbors <i>w</i> when excluding the connection (<i>v</i>, <i>u</i>), then (<i>v</i>, <i>u</i>) is a bridge.</p>&#13;
<p class="TX">Node 2 in <a href="#fig11-7">Figure 11-7</a> provides an example of this case. The search reached node 2 via the edge (1, 2) and assigned it an order index of 2, as shown in <a href="#fig11-7">Figure 11-7(b)</a>. For edge (1, 2) to be a bridge, there must be no alternate path out of that subtree. However, node 2 itself has an edge to node 0 (with order = 0), providing such an alternate route.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_182" aria-label="182"/>The opposite case is shown in <a href="#fig11-8">Figure 11-8</a> with edge (0, 1). The graph in <a href="#fig11-8">Figure 11-8(a)</a> has a slight modification from the one in <a href="#fig11-7">Figure 11-7(a)</a>, the exclusion of edge (0, 2), which results in edge (0, 1) now being a bridge. <a href="#fig11-8">Figure 11-8(b)</a> shows the corresponding depth-first search subtree rooted at node 0, with the untraversed edges in gray. The dotted ovals in both figures indicate the subtree of node 1. As shown in <a href="#fig11-8">Figure 11-8(b)</a>, the only connection from the subtree of node 1 to a node with order less than 1 is the edge (0, 1) itself.</p>&#13;
<figure class="IMG"><img id="fig11-8" class="img100" src="../images/f11008.jpg" alt="(A) shows an undirected graph with seven nodes and eight edges. (B) shows a tree built from this graph with root node 0 and additional gray edges." width="1378" height="659"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-8: An undirected graph (a) and a depth-first search tree (b)</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The bridge-finding algorithm checks each subtree in the depth-first search tree by recording the lowest-order indices that neighbor any node in the subtree. The only adjacent edge we exclude is the link between the subtree root <i>u</i> and its parent, as this is the edge we are testing.</p>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h-144"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp></h4>&#13;
<p class="TNI1">We can implement the bridge-finding algorithm using a single pass of depth-first search. To simplify the code, we’ll use the helper data structure <samp class="SANS_TheSansMonoCd_W5Regular_11">DFSTreeStats</samp> to track information about the order in which the depth-first search reaches various nodes, including:</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">parent</samp> <b>(</b><samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp><b>) </b>Maps each node’s index to that of its parent in the depth-first search tree</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">next_order_index</samp> <b>(</b><samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp><b>) </b>Stores the next order index to assign</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">order</samp> <b>(</b><samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp><b>) </b>Maps each node’s index to its order index</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">lowest</samp> <b>(</b><samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp><b>) </b>Maps each node to the <i>lowest</i> order index of any nodes in its depth-first search subtree or their immediate neighbors (excluding the node’s parent)</p>&#13;
<p class="TX">The data structure <samp class="SANS_TheSansMonoCd_W5Regular_11">DFSTreeStats</samp> provides a wrapper for this information and saves us from having to pass many parameters to the search function. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_183" aria-label="183"/>We can also use the object to perform basic assignments and updates. We define <samp class="SANS_TheSansMonoCd_W5Regular_11">DFSTreeStats</samp> in the following code:</p>&#13;
<pre><code>class DFSTreeStats:&#13;
    def __init__(self, num_nodes: int): &#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> self.parent: list = [-1] * num_nodes&#13;
        self.next_order_index: int = 0&#13;
        self.order: list = [-1] * num_nodes&#13;
        self.lowest: list = [-1] * num_nodes&#13;
&#13;
    def set_order_index(self, node_index: int):&#13;
        self.order[node_index] = self.next_order_index&#13;
        self.next_order_index += 1&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> self.lowest[node_index] = self.order[node_index]&#13;
</code></pre>&#13;
<p class="TX">The constructor sets all the information to its initial values <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. The code initializes all entries of the lists <samp class="SANS_TheSansMonoCd_W5Regular_11">parent</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">lowest</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp> in order to indicate that these values are unset for each node. It sets <samp class="SANS_TheSansMonoCd_W5Regular_11">next_order_index</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> in preparation for the first node.</p>&#13;
<p class="TX">The helper method <samp class="SANS_TheSansMonoCd_W5Regular_11">set_order_index()</samp> records the current node’s order index and increments the next one to assign. It also initializes the lowest order index seen for this node, which is initially the order index of the node itself <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">We use a depth-first search adapted from those in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span> to fill in the entries of <samp class="SANS_TheSansMonoCd_W5Regular_11">DFSTreeStats</samp> and find the bridges:</p>&#13;
<pre><code>def bridge_finding_dfs(g: Graph, index: int, stats: DFSTreeStats, results: list):&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> stats.set_order_index(index)&#13;
&#13;
    for edge in g.nodes[index].get_sorted_edge_list():&#13;
        neighbor: int = edge.to_node&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> if stats.order[neighbor] == -1:&#13;
            stats.parent[neighbor] = index&#13;
            bridge_finding_dfs(g, neighbor, stats, results)&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> stats.lowest[index] = min(stats.lowest[index],&#13;
                                      stats.lowest[neighbor])&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation4">❹</span> if stats.lowest[neighbor] &gt;= stats.order[neighbor]:&#13;
                results.append(edge)&#13;
        elif neighbor != stats.parent[index]:&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation5">❺</span> stats.lowest[index] = min(stats.lowest[index],&#13;
                                      stats.order[neighbor])&#13;
&#13;
def find_bridges(g: Graph) -&gt; list:&#13;
    results: list = []&#13;
    stats: DFSTreeStats = DFSTreeStats(g.num_nodes)&#13;
    for index in range(g.num_nodes):&#13;
        if stats.order[index] == -1:&#13;
            bridge_finding_dfs(g, index, stats, results)&#13;
    return results&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_184" aria-label="184"/>The recursive helper function <samp class="SANS_TheSansMonoCd_W5Regular_11">bridge_finding_dfs()</samp> starts by setting the current node’s order index and initial value for the lowest order index reachable in the subtree using the <samp class="SANS_TheSansMonoCd_W5Regular_11">set_order_index()</samp> helper method <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>.</p>&#13;
<p class="TX">The code then uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop to check each of the node’s neighbors. For consistency of ordering with other examples, we use the function <samp class="SANS_TheSansMonoCd_W5Regular_11">get_sorted_edge_list()</samp> to traverse the neighbors in order of their index, though traversing them in sorted order is not necessary for the correctness of the algorithm. If a neighbor has not been visited (its <samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp> value is unset) <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>, the code sets its parent and recursively explores it. After returning from the recursive call, the code checks whether it has found a smaller order index neighboring the subtree by comparing the child’s <samp class="SANS_TheSansMonoCd_W5Regular_11">lowest</samp> entry with its own <samp class="SANS_TheSansMonoCd_W5Regular_11">lowest</samp> entry <span class="CodeAnnotationCode" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">At this point, the search has finished exploring the depth-first search subtree rooted at <samp class="SANS_TheSansMonoCd_W5Regular_11">neighbor</samp>. It can check whether <samp class="SANS_TheSansMonoCd_W5Regular_11">edge</samp> is a bridge by comparing the lowest-order index of any node in the subtree or its immediate neighbor with the order index of the subtree’s root <span class="CodeAnnotationCode" aria-label="annotation4">❹</span>. The code appends new bridges to <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>.</p>&#13;
<p class="TX">If the neighbor has been seen (its <samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp> value is set), then the code first checks whether the neighbor is the parent node itself. If it is, then the edge under consideration was just traversed and the search ignores it. Otherwise, the code checks whether this neighbor represents a node outside the subtree by checking that neighbor’s order index <span class="CodeAnnotationCode" aria-label="annotation5">❺</span>.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">find_bridges()</samp> function provides a wrapper that sets up the statistics and <samp class="SANS_TheSansMonoCd_W5Regular_11">results</samp> data structures, then starts the search(es). The code finds all bridges in each connected component by performing a single depth-first search from that component, using the approach adapted from <span class="Xref"><a href="chapter4.xhtml#list4-2">Listing 4-2</a></span>. Since each node is visited only once and each edge is examined at most twice (once in each direction), the cost of the full algorithm scales as |<i>V</i> | + |<i>E</i>|.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h4 class="H2" id="sec8"><span id="h-145"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp></h4>&#13;
<p class="TNI1"><a href="#fig11-9">Figure 11-9</a> shows an example run of the bridge-finding algorithm on a graph with eight nodes. Each subfigure shows the state of the search after <i>completing</i> the visit to the circled node. The <samp class="SANS_TheSansMonoCd_W5Regular_11">DFSTreeStats</samp>’s lists <samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">low</samp> are shown. The arrows indicate edges traversed so far and the dashed edges indicate ones that were seen by search but not traversed, while the bolded gray arrows are the bridges.</p>&#13;
<p class="TX"><a href="#fig11-9">Figure 11-9(a)</a> shows the state of the algorithm after the search completes node 6. At this point, it has initially visited and set a preorder index for nodes 0, 1, 2, 3, 7, and 6. Nodes 4 and 5 are unvisited and thus do not have a preorder index. Similarly, the lower bounds correspond to the algorithm’s state after visiting only some of the visited node’s children. Node 6 has the final state of <samp class="SANS_TheSansMonoCd_W5Regular_11">lowest</samp> since the search has finished processing it. In contrast, the <samp class="SANS_TheSansMonoCd_W5Regular_11">lowest</samp> value of node 3 is not finalized because the algorithm has not finished searching its subtree.</p>&#13;
<p class="TX">In <a href="#fig11-9">Figure 11-9(b)</a>, the search backtracks to node 7 and completes that node. During this process, the algorithm checks whether the edge (7, 6) could be a bridge. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">lowest[6]</samp> is less than <samp class="SANS_TheSansMonoCd_W5Regular_11">order[6]</samp>, we know there is an alternate path out of the subtree (through node 2) and the edge is not a bridge.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_185" aria-label="185"/>&#13;
<figure class="IMG"><img id="fig11-9" class="img70" src="../images/f11009.jpg" alt="Each subfigure shows a graph with eight nodes and the values in two arrays. In (A) node 6 is circled, the order array contains [0, 1, 2, 3, –1, –1, 5, 4], and the low array contains [0,1, 2, 3, –1, –1, 2, 4]." width="1340" height="2314"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-9: The stages of the bridge-finding algorithm</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_186" aria-label="186"/>By <a href="#fig11-9">Figure 11-9(e)</a>, the search has found the first bridge. While it has not finished processing node 1, it has fully searched the subtree rooted at node 2. After returning from node 2, the algorithm finds that <samp class="SANS_TheSansMonoCd_W5Regular_11">lowest[2]</samp> is equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">order[2]</samp>, indicating that the edge (1, 2) is the only path into or out of the subtree rooted at node 2. It adds (1, 2) to the list of bridges before moving on to the other children of node 1. In <a href="#fig11-9">Figure 11-9(f)</a>, after finishing the subtree rooted at node 5, the search finds that the edge (4, 5) must be another bridge, as the removal of that edge disconnects node 5.</p>&#13;
<p class="TX">To visualize this, imagine our evil wizard inspecting their newly created magical labyrinth. They start by walking the labyrinth, building a depth-first tree, and recording the preorder index of each room with a chalk marking on the wall. Each time they enter a new room, they recursively explore any unvisited neighboring rooms and poke their head into previously visited neighboring rooms to check the marks on the wall. When visiting the Room of Loose Ceiling Tiles they might see a new neighbor, the Room with the Ugly Carpet, and also find a connection back to the previously visited Room That Is Always Uncomfortably Warm. Throughout the process, they track the lowest number they have seen since entering each room.</p>&#13;
<p class="TX">After backtracking through each hallway, the wizard checks their notes to determine whether any of the rooms they just visited have a neighboring room with a preorder index less than the room at the far end of the hallway (the room that they just left when backtracking). After backtracking through their personal favorite, the Hallway of Excessive Chandeliers, the wizard effectively asks, “Is there another passage through which the adventurers could reach one of the rooms up ahead? Or do they have to go through the Hallway of Excessive Chandeliers?” If there is no alternate path, they can mark the Hallway of Excessive Chandeliers as a bridge, be happy in the knowledge that the adventurers will always get to see this opulently decorated passage, and also plan to deploy a good trap.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h3 class="H1" id="sec9"><span id="h-146"/><samp class="SANS_Futura_Std_Bold_B_11">An Algorithm for Finding Articulation Points</samp></h3>&#13;
<p class="TNI1">We can adapt the bridge-finding algorithm to identify articulation points by considering the roots of each subtree instead of the edges directly connected to them, using very similar logic. We identify articulation points by looking for a node <i>u</i> whose descendants in the depth-first search tree do not have a neighbor above <i>u</i> in that tree. An edge from a node outside the subtree of <i>u</i> to one of the descendants of <i>u</i> would provide the critical alternate path around <i>u</i>.</p>&#13;
<p class="TX">To understand how to use the node’s subtrees to identify articulation points, consider the two cases shown in <a href="#fig11-10">Figure 11-10</a>. We map the depth-first search subtrees onto the original undirected graph with arrows and label each node with its order index. The current node under consideration is shaded and a dashed boundary marks the node’s descendants.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_187" aria-label="187"/>&#13;
<figure class="IMG"><img id="fig11-10" class="img100" src="../images/f11010.jpg" alt="In (A), nodes {2, 3, 6, 7} are circled. In (B), nodes {6, 7} are circled." width="1543" height="476"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-10: Two nodes and their subtrees in a graph’s depth-first search tree</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In <a href="#fig11-10">Figure 11-10(a)</a>, the algorithm is considering node 1 and descendants {2, 3, 6, 7}. Removing node 1 would cut its descendants off from the rest of the graph. In contrast, node 3 is not an articulation point, as shown in <a href="#fig11-10">Figure 11-10(b)</a>. That node’s descendants include node 6, which has a link back to node 2 (outside the subtree of node 3). The edge (2, 6), although not included in the depth-first search tree, provides an alternate path to nodes 6 and 7 in the event node 3 is removed.</p>&#13;
<p class="TX">This logic works for every node except the root node. Since the root node has no ancestors, we cannot use the same approach of checking the subtrees for back edges. Instead, we must look for cases where the root node has more than one subtree. As shown in the example graph in <a href="#fig11-11">Figure 11-11</a>, the root node will have multiple subtrees only if the graph has components that would be disconnected by the removal of the root node. If there were an edge joining the subtrees, the depth-first search would traverse that edge before returning to the root.</p>&#13;
<figure class="IMG"><img id="fig11-11" class="img30" src="../images/f11011.jpg" alt="A graph with seven nodes. Six of the edges are arrows, including (0, 1), (1, 2), and (1, 6). Three edges are dashed lines including (0, 2), (0, 5) and (1, 4)." width="490" height="437"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-11: A depth-first subtree where the root node is an articulation point</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">We can combine the specialized root test with the lower bound tracking from the bridge-detection algorithm to identify the articulation points in a graph, as shown in the following code.</p>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_188" aria-label="188"/>&#13;
<h4 class="H2"><span id="sec10"/><span id="h-147"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp></h4>&#13;
<p class="TNI1">As with the bridge-finding algorithm, we implement the <i>articulation-point-finding algorithm</i> with a single pass of depth-first search that completes both the search and the identification. We reuse the <samp class="SANS_TheSansMonoCd_W5Regular_11">DFSTreeStats</samp> data structure track and update information about each node’s parent, order index, and lowest reachable order index.</p>&#13;
<p class="TX">To simplify the code, we break the search into two functions. The first function handles the non-root nodes and performs the recursive exploration:</p>&#13;
<pre><code>def articulation_point_dfs(g: Graph, index: int, stats: DFSTreeStats,&#13;
                           results: set): &#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> stats.set_order_index(index)&#13;
    for edge in g.nodes[index].get_edge_list():&#13;
        neighbor: int = edge.to_node&#13;
        if stats.order[neighbor] == -1:&#13;
            stats.parent[neighbor] = index&#13;
            articulation_point_dfs(g, neighbor, stats, results)&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> stats.lowest[index] = min(stats.lowest[index],&#13;
                                      stats.lowest[neighbor])&#13;
&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> if stats.lowest[neighbor] &gt;= stats.order[index]:&#13;
                results.add(index)&#13;
&#13;
        elif neighbor != stats.parent[index]:&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation4">❹</span> stats.lowest[index] = min(stats.lowest[index],&#13;
                                      stats.order[neighbor])&#13;
</code></pre>&#13;
<p class="TX">The recursive function <samp class="SANS_TheSansMonoCd_W5Regular_11">articulation_point_dfs()</samp> performs the majority of the work for this algorithm. It starts by setting the current node’s order index and tentative lower bound <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>, then performs the depth-first search by iterating over each neighbor, checking whether it has been visited, and, if not, recursively exploring it.</p>&#13;
<p class="TX">The code tracks the lower bounds for the neighbors of any node in the subtree. For subtrees in the depth-first search tree (previously unexplored nodes), the code updates the lower bound based on the lowest neighbor of that entire subtree <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>. The logic for identifying articulation points takes place after this recursive exploration of each child. The code determines whether the subtree it just visited would be cut off by the removal of the <i>current</i> node by checking whether any node in that subtree contains a neighbor above the current node in the depth-first search tree <span class="CodeAnnotationCode" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">For neighbors that are not part of the depth-first search subtree (previously explored nodes) and are not the current node’s parent, the code compares the node’s lower bound to the neighbor’s order index <span class="CodeAnnotationCode" aria-label="annotation4">❹</span>.</p>&#13;
<p class="TX">For the root node, we add some additional logic to track the number of subtrees:</p>&#13;
<pre><code>def articulation_point_root(g: Graph, root: int,&#13;
                            stats: DFSTreeStats, results: set): &#13;
    stats.set_order_index(root)&#13;
    num_subtrees: int = 0<span role="doc-pagebreak" epub:type="pagebreak" id="pg_189" aria-label="189"/>&#13;
&#13;
    for edge in g.nodes[root].get_edge_list():&#13;
        neighbor: int = edge.to_node&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> if stats.order[neighbor] == -1:&#13;
            stats.parent[neighbor] = root&#13;
            articulation_point_dfs(g, neighbor, stats, results)&#13;
            num_subtrees += 1&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> if num_subtrees &gt;= 2:&#13;
        results.add(root)&#13;
</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">articulation_point_root()</samp> function starts by setting the order index of the root and initializing the <samp class="SANS_TheSansMonoCd_W5Regular_11">num_subtrees</samp> counter. It then starts the depth-first search by iterating over each neighbor, checking if it has been visited <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>, and, if not, recursively exploring it using the <samp class="SANS_TheSansMonoCd_W5Regular_11">articulation_point_dfs()</samp> function. Instead of using the lower bound logic in deciding whether the root is an articulation point, the code simply checks whether the root has two or more subtrees <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>. If so, it appends the root to the results.</p>&#13;
<p class="TX">The function for finding all articulation points consists of using the <samp class="SANS_TheSansMonoCd_W5Regular_11">articulation_point_root()</samp> function to run this search on each connected component in the graph:</p>&#13;
<pre><code>def find_articulation_points(g: Graph) -&gt; set:&#13;
    stats: DFSTreeStats = DFSTreeStats(g.num_nodes)&#13;
    results: set = set()&#13;
    for index in range(g.num_nodes):&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> if stats.order[index] == -1:&#13;
            articulation_point_root(g, index, stats, results)&#13;
    return results&#13;
</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">find_articulation_points()</samp> function starts by creating and initializing the data structures needed for the algorithm. Since the data structures are indexed by node and the different connected components are disjoint, the code can use a single <samp class="SANS_TheSansMonoCd_W5Regular_11">stats</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">results</samp> object for all connected components. The code then iterates over each node, checks whether it has been visited by a search <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>, and, if not, starts a new depth-first search from that node. It finishes by returning the list of all articulation points.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2"><span id="sec11"/><span id="h-148"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp></h4>&#13;
<p class="TNI1"><a href="#fig11-12">Figure 11-12</a> shows an illustration of the algorithm for finding articulation points. Each subfigure shows the state of the algorithm after <i>completing</i> the visit to the circled node. The edges tested are represented by an arrow if they are part of the depth-first search tree or a dashed line if they are not. Unexplored edges are solid gray lines, and the discovered articulation points are shaded.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_190" aria-label="190"/>&#13;
<figure class="IMG"><img id="fig11-12" class="img70" src="../images/f11012.jpg" alt="Each subfigure shows a graph with eight nodes and the values in two arrays. In (A), node 6 is circled, the order array contains [0, 1, 2, 3, –1, –1, 5, 4], and the low array contains [0,1, 2, 3, –1, –1, 2, 4]." width="1355" height="2336"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-12: The stages of the articulation-point-finding algorithm</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_191" aria-label="191"/>The majority of the algorithm behavior represented in <a href="#fig11-12">Figure 11-12</a> is the same as that in <a href="#fig11-9">Figure 11-9</a>. The order in which the nodes are explored and the values of <samp class="SANS_TheSansMonoCd_W5Regular_11">DFSTreeStats</samp> at each step are identical. The difference in behavior arises where articulation points are detected in <a href="#fig11-12">Figure 11-12(d)</a>. The lowest-order index for any neighbor of the subtree rooted at node 3 is 2, the order index of the current node. We know that node 2 has at least one subtree without connections back to any of its ancestors, meaning that removing node 2 would disconnect that subtree.</p>&#13;
<p class="TX"><a href="#fig11-12">Figure 11-12(e)</a> is interesting because, although it shows the state after finishing node 5, the algorithm has already marked (the unfinished) node 1 as an articulation point due to performing the articulation point test after checking each subtree. Regardless of what happens while exploring the other descendants of node 1, we know that removing that node would disconnect the subtree rooted at node 2.</p>&#13;
<p class="TX"><a href="#fig11-12">Figure 11-12(h)</a> shows the final step of the algorithm. At this point, the search has returned from the call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">articulation_point_dfs()</samp> function and is testing the root. Instead of using the low boundary, it checks how many subtrees the root has, revealing that node 0 has a single depth-first search subtree. All nodes in the graph are reached through node 1 before the search returns to node 0. Therefore, node 0 is not an articulation point.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h3 class="H1" id="sec12"><span id="h-149"/><samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp></h3>&#13;
<p class="TNI1">Bridges and articulation points are critical for understanding the structure of graphs, including their points of failure and bottlenecks. As we saw in the example use cases, these features apply to a variety of real-world problems, from incorporating redundant routes into airline networks to designing the ultimate magical labyrinth.</p>&#13;
<p class="TX">The algorithms introduced in this chapter provide practical methods for identifying these structural elements and using depth-first search trees and order indexes to determine which nodes are reachable via alternate paths. This again highlights the power and versatility of a simple depth-first search and shows how augmenting information like order indexes can provide deep insights into the overall structure of the graph.</p>&#13;
<p class="TX">The next chapter further extends our discussion of connectivity, this time considering directed graphs and the related concept of strongly connected components. We introduce an algorithm that builds off the ideas presented in this chapter of collecting statistics with depth-first search to understand the graph’s structure.</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>