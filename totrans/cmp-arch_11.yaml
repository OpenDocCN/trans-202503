- en: '**9**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**INPUT/OUTPUT**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Image](../images/f0201-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You’ve seen how to build a basic CPU and RAM, which together can run programs.
    CPU and RAM are great for performing calculations, but to bring a computer to
    life with graphics, sound, joysticks, and other interactions with the real world,
    we also need input and output, known together as *I/O*. In this chapter, you’ll
    see how to add I/O capabilities using buses, I/O modules, devices, and peripherals.
  prefs: []
  type: TYPE_NORMAL
- en: Basic I/O Concepts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To discuss I/O in detail, let’s first define a few terms. *I/O modules* are
    digital electronics that—like RAM—are assigned and connected to addresses in the
    computer’s *address space*, the range of possible addresses that the CPU can access.
    I/O modules are also connected to *devices*, which are electronic systems, including
    digital and analog electronics, that aren’t connected directly to the computer’s
    address space but that can communicate with it via the attached I/O modules. Devices
    may be physically inside the computer, such as an analog circuit that controls
    the scanning beam of a CRT monitor, or outside it, such as the electronic circuits
    inside a printer.
  prefs: []
  type: TYPE_NORMAL
- en: '*Peripherals* are the most obvious elements of I/O for most computer users:
    they’re the physical objects that connect to the computer from the outside, such
    as mice, joysticks, monitors, and printers. Peripherals are encased in their own
    plastic and connect to the computer’s box via a wire that the end user can easily
    plug and unplug. Some peripherals, such as printers, physically contain their
    devices. Others, such as monitors, rely on a device inside the computer box (CRT
    controllers, in the case of a monitor).'
  prefs: []
  type: TYPE_NORMAL
- en: In the 8-bit era, computer design meant building a complete computer by buying
    and connecting together CPU, memory, devices, and logic chips, and perhaps custom-designing
    I/O modules. For example, the Commodore 64 mainboard shown in [Figure 9-1](ch09.xhtml#ch09fig1)
    shows that a large part of the machine is devoted to I/O.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0202-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-1: A C64 mainboard, showing CPU, memory (RAM and ROM), I/O modules,
    and devices*'
  prefs: []
  type: TYPE_NORMAL
- en: The I/O section in the top-left of the figure includes two *Complex Interface
    Adapter (CIA)* chips, each of which contain multiple I/O modules. The devices
    section in the bottom-right includes graphics and sound chips.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, something like the entire mainboard of the Commodore 64 is shrunk
    down to a single system-on-chip (SoC) in your phone, but the structure was easier
    to understand and learn from when the parts were in physically separate integrated
    circuit (IC) packages. Keep this image in mind as we move through this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: To the CPU, I/O modules appear exactly like part of RAM. They have addresses
    that can be read and written to, using the same load and store instructions as
    reading and writing to RAM. Now that we have both RAM and I/O modules connecting
    to the same CPU address and data lines, we need a way for them to share these
    resources. This can be done using the bus architecture seen in the next section.
    After discussing buses, we’ll look inside the I/O modules and see how to communicate
    with them in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Buses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A *bus architecture* is a specific type of network architecture in which every
    device involved in communication has equal access to a shared wire or set of wires,
    called the *bus*. Like the public transportation vehicle of the same name, a computer
    bus is so-called because it is a public place (it abbreviates the Latin *omnibus*,
    meaning “for all”). To illustrate the public quality of a bus architecture, consider
    the example of a prison water pipe tapping system: all the prisoners in a prison
    have plumbing connected to the same pipes, so tapping on one pipe to transmit
    a plan for a prison breakout in Morse code inevitably broadcasts the message to
    anyone and everyone who is listening to the pipes. There’s no privacy in a bus
    architecture (unless encryption is used), which may have interesting security
    implications if untrusted devices are allowed to access it.'
  prefs: []
  type: TYPE_NORMAL
- en: A bus is the simplest form of network, lacking the complexity of the internet’s
    packets, error handling, and routing. For example, it’s possible that two prisoners
    will try to tap the pipe at the same time, creating a collision that destroys
    both of their messages.
  prefs: []
  type: TYPE_NORMAL
- en: In general, a bus is composed of several *nodes* (things that want to talk to
    each other) and communication lines (wires) between them. Modern buses usually
    have many lines used in parallel, though there are also buses with only one. We
    may divide these lines into control, address, and data lines.
  prefs: []
  type: TYPE_NORMAL
- en: A protocol is needed to ensure that signals don’t collide with the signals being
    sent by other nodes, so for a node to send a message to another it must first
    announce whom the message is for—the address, on the address lines—and announce
    what type of message it is—the control, on the control lines. It then broadcasts
    the data on the data lines. Either you can have one of the nodes in charge of
    the bus, enforcing the protocol by only allowing nodes to write when it gives
    them permission, or you can trust the nodes to implement the protocol themselves
    and play nicely with each other.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE VICTORIAN INTERNET**'
  prefs: []
  type: TYPE_NORMAL
- en: The telegraph system of Babbage’s and Boole’s time has been called the “Victorian
    Internet.” It was a bus architecture connecting sites in Britain, America, and
    the British Empire. Human operators at a local station would tap out Morse code
    text messages (telegrams) for customers, and listen for messages addressed to
    their station from elsewhere. All of the messages were transmitted onto the same
    wire, which could be written to and read from by all operators. These operators
    spent thousands of hours listening and writing to the wire, becoming fluent in
    Morse code and developing their own Morse “speaking” styles that could be used
    to recognize who was talking. They would also chat with one another when not sending
    messages for customers, engaging in typical modern chat-room behaviors such as
    using abbreviated slang (textspeak), falling in love, and even getting married
    to operators on other continents without having met them in person.
  prefs: []
  type: TYPE_NORMAL
- en: An advantage of a bus architecture is that it’s easy to add new devices to the
    bus, as the same set of shared wires connect all the components. The shared wires
    also make buses cheap to implement. On the other hand, the bus can be a bottleneck,
    limiting the performance of the system. This is particularly annoying if you’re
    optimizing your CPU or memory to go very fast, only to then have the data hit
    a bus and slow down. Bus performance can also be limited by physical factors such
    as wire length and the number of connections.
  prefs: []
  type: TYPE_NORMAL
- en: '*Bus Lines*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The lines on the bus are the same as the wires we’ve previously connected point-to-point
    between CPU (or its cache) and RAM. There are three different kinds:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Address lines** These are used to designate the source or destination of
    data on the data bus. The width of the address bus determines the maximum possible
    memory capacity (that is, the amount of memory a system can address). For example,
    a system with a 32-bit address bus can address 2^(32) (4,294,967,296) memory locations.
    If each memory location held an 8-bit word (byte), the addressable memory space
    is 4 GiB. For a 64-bit address space of 64-bit words, exactly 1 zebibit (2⁶× 2^(64)
    = 2^(70)) of memory can be used, which is enough to allow all of the data in a
    search engine–sized data center to have its own RAM address.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data lines** These provide the path for the actual transfer of data among
    nodes. A key performance factor is the width of the data bus (that is, the number
    of data lines). A typical data bus consists of 32, 64, 128, or even more separate
    lines. To send messages that are longer than the data line width, you need to
    split them up and send them over several cycles. For example, if a data bus is
    32 bits wide and each instruction is 64 bits long, then the CPU must access the
    memory module twice during each instruction cycle.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Control lines** These are used to control access to and use of the data and
    address lines. For example, the write-enable wire used previously in [Figure 7-10](ch07.xhtml#ch07fig10)
    when we discussed the Baby’s store operation is a simple control line. More generally,
    as the data and address lines are shared by many components, there must be a means
    of controlling their use such that multiple components don’t attempt to write
    to those lines at the same time. Further control lines can be used to request
    and negotiate for this access.'
  prefs: []
  type: TYPE_NORMAL
- en: '*The CPU-Bus Interface*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most CPUs are designed to connect to an external bus, printed onto the mainboard,
    via pins on the CPU chip connecting to sockets on the main-board. Where the bus
    wires physically connect to the CPU, the connection is known as the *front side
    bus (FSB)*. The vast majority of a CPU’s pins are taken up by the FSB, as can
    be seen in the Commodore 64’s 8-bit 6502 CPU chip pinout and the 1990s 32-bit
    Intel Socket2 pinout in [Figure 9-2](ch09.xhtml#ch09fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0205-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-2: Pinout diagrams for an 8-bit 6502 (left) and 32-bit Socket2 chip
    (center), plus a pin photo of a 64-bit LGA1155 socket CPU (right)*'
  prefs: []
  type: TYPE_NORMAL
- en: The 6502 here uses 16-bit addresses and 8-bit words, so it has 16 address (A)
    pins and 8 data (D) pins. The R/W pin is for the read/write control line. In all,
    more than half of the chip’s 40 pins are devoted to the bus. The Socket2 was used
    with 32-bit address spaces and 32-bit data words, so it has 32 each of A and D
    pins (colored white and black in the diagram, respectively). Meanwhile, 64-bit
    CPU chips and sockets need twice as many of each, requiring them to be smaller
    and more fragile.
  prefs: []
  type: TYPE_NORMAL
- en: The CPU needs to communicate with the bus, but the bus is usually slower than
    the CPU. Hence, CPU designers prefer to use registers to stage data going in and
    out of the CPU (as in the Analytical Engine’s ingress/ egress axes, connecting
    the CPU to its mechanical rack bus). The bus is a scarce resource, so we don’t
    want to use it for any longer than needed; if data is staged, it can be put on
    and off the bus at whatever time the bus becomes available. Typically, these staging
    mechanisms include a *memory address register (MAR)*, which stores the address
    from which we want to read or write, and a *memory buffer register (MBR)*, which
    stores a copy of the data being written to or read from that address, as shown
    in [Figure 9-3](ch09.xhtml#ch09fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0205-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-3: A bus architecture, including a CPU, a RAM module, and two I/O
    modules*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute a load instruction, the operand containing the address to be loaded
    is temporarily connected from its instruction register (IR) bits to the MAR, creating
    a copy in the MAR. When this copy is completed, the MAR is temporarily connected
    to memory as a read request, and the data from memory is temporarily connected
    to the MBR, which takes a copy of this data. Then the control unit (CU) can temporarily
    connect the MBR to the accumulator or other user register. In register transfer
    language (RTL) style, this can be written as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The same MAR and MBR registers can be used to execute a store instruction as
    well. The CU temporarily connects the MAR to the operand bits in the IR containing
    the address to be written to; the MAR takes a copy of the address. Then, the CU
    temporarily connects the MBR to the register containing the value to be written;
    the MBR takes a copy of the value. The MAR and MBR now contain all the required
    information describing the store. Finally, the CU temporarily connects the MAR
    to the RAM’s address lines and the MBR to the RAM’s data lines, and sets its command
    line to store, which performs the store in RAM. In RTL this can be written as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Having the MAR and MBR also simplifies the design of CPUs that have multiple
    user registers rather than just an accumulator. They make it easy to separate
    out the logic and timing for selecting which register is to be connected to the
    bus from the logic and timing of transferring the data to and from the bus.
  prefs: []
  type: TYPE_NORMAL
- en: I/O Modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Devices usually attach to a computer via an I/O module. This is a chip that
    sits on the bus and at some addresses; it looks just like RAM to the CPU. If you
    learn only one thing from this chapter, it should be this: I/O modules appear
    to the CPU and assembly programmer as an area of readable, writable memory, just
    like main RAM. Unlike RAM, an I/O module also has wires coming out of the other
    side that go to the device. The module presents a standardized interface to the
    CPU, and translates requests from the CPU to specific signals on the wires to
    the particular device. Hence, we can buy any device, such as a sound chip, on
    eBay and install it in a particular type of computer, as long as we make an I/O
    module that provides a suitable address space for the computer and sends whatever
    signals the sound chip is expecting.'
  prefs: []
  type: TYPE_NORMAL
- en: Storing to these addresses might transmit commands to the device; it might write
    assembly-like instructions specific to the module for further translation into
    device commands (used in modern graphics cards, for example), or it might send
    data to the device (such as what audio to play). Loading from these addresses
    might read data from the device, such as a keyboard key press or a microphone
    sound wave, or read status information from the device, such as whether there’s
    a printer jam. It’s up to the designer of an I/O module how they want to interpret
    these load and store commands.
  prefs: []
  type: TYPE_NORMAL
- en: Some I/O addresses may be implemented by actual RAM inside the module (distinct
    from regular RAM chips, because this specialized RAM has extra connections to
    the rest of the I/O circuitry); other times, it may just be immediate digital
    logic with no RAM. Both methods present the same interface to the CPU, which doesn’t
    know if there’s real memory there or something else.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to device communication, the I/O module will also usually handle
    control and timing, data buffering, and device errors. Let’s turn there now.
  prefs: []
  type: TYPE_NORMAL
- en: '*Control and Timing*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An I/O module must be able to coordinate the flow of data between the internal
    resources and external devices. The latter may be slow, so the module manages
    them independently of the CPU. This allows the CPU to go and do other things while
    it’s waiting. This is a form of non–CPU level parallelism.
  prefs: []
  type: TYPE_NORMAL
- en: The I/O module achieves this independent management by using data buffering
    to transfer data into and out of main memory or CPU. *Buffering* means using a
    dedicated area of memory, called a *buffer*, as a staging area. Slow devices can
    take their time writing to or reading from a buffer, independently of the CPU.
    The fast CPU can also read or write to the same buffer, independently of the device.
  prefs: []
  type: TYPE_NORMAL
- en: '*Ring buffers* are used in audio and similar real-time signal-processing I/Os.
    Conceptually, a ring buffer is a region of data in which the data items are organized
    in a circle, each with a previous and next neighbor, as in [Figure 9-4](ch09.xhtml#ch09fig4).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0208-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-4: A ring buffer. Both pointers move clockwise. The string 0123456789
    has been written, with the initial 01 now overwritten by 89\. Of this, 01234 has
    been read.*'
  prefs: []
  type: TYPE_NORMAL
- en: Two pointers—which can be visualized as clock hands—keep track of the read point
    and the write point. As new data arrives in real time, it’s written to the write
    point, which is then incremented to point to the next slot. Eventually the write
    pointer makes it all the way around the ring, at which point it starts overwriting
    old data. The user program can request to read the next available items at any
    time. When this happens, the data at the read pointer is copied out and the read
    pointer is incremented until the number of items requested is met or the read
    pointer hits the write pointer, meaning there’s no further new data available.
  prefs: []
  type: TYPE_NORMAL
- en: '*Double buffers* are often used for graphics rendering. Here, two buffers are
    maintained, each representing the layout of the screen, as in [Figure 9-5](ch09.xhtml#ch09fig5).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0208-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-5: Double buffering*'
  prefs: []
  type: TYPE_NORMAL
- en: At any instant, one buffer stores a completely rendered image and is connected
    (shown by the thick black outlines in the figure) to the graphics display hardware,
    which works to physically display it. Meanwhile, the other buffer is used to gradually
    build up the next image to be displayed—for example, by drawing the background
    and then adding sprites and overlays to it. Only when the new buffer is finished
    is the output line swapped over to connect it to the display; then the original
    buffer is cleared and used to start drawing the third image in the sequence. This
    approach means that only completed images are ever shown on the screen, which
    avoids flickering images that show the parts of the images being built up in real
    time. (Triple buffering is also used in some cases, allowing *two* future frames
    to be drawn in parallel while the current frame is being displayed. This can achieve
    a higher frame rate, as long as it’s known far enough in advance what will be
    wanted.)
  prefs: []
  type: TYPE_NORMAL
- en: '*Error Detection*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another major function of I/O modules is device error handling. What should
    an I/O module do if the CPU asks it to do something, but then it detects an error
    from its device? The error could be a mechanical or electrical malfunction in
    the device (for example, a paper jam in a printer or a bad disk track), or it
    could be the result of unintentional changes to bit patterns as they’re transmitted
    between the device and the I/O module, often due to noisy external cables.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, a device shouldn’t report an error directly to the CPU, which may
    be busy doing other things. Instead, it reports the error to the I/O module, which
    can then pass it on to the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: I/O Module Techniques
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Transferring data from an external device to the CPU requires several steps.
    First, the CPU writes to the bus, asking the I/O module to check the status of
    the device. Next, the I/O module returns the device status in reply, also writing
    to the bus. If the device is ready, the CPU requests transfer of data with another
    bus write. The I/O module then obtains a unit of data from the device. This data
    is finally transferred via the bus from the I/O module to the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: This process will be slow if it requires waiting for things in the real world.
    If a gigahertz CPU asks to read 100 audio samples, and audio samples arrive only
    at 44 kHz, it will need to spend most of its time doing nothing and waiting around
    for each of these samples to arrive and be sent on the bus by the I/O module.
    We would prefer the CPU to keep busy doing other things while waiting for the
    requested I/O to take place. This can be accomplished via three common techniques.
    We’ll discuss each in turn.
  prefs: []
  type: TYPE_NORMAL
- en: '*Polling*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Suppose your boss needs you to get a report finished. One management strategy
    they could use is *polling*, in which they repeatedly come back and ask you, “Have
    you finished that job yet?” every hour, day, or month.
  prefs: []
  type: TYPE_NORMAL
- en: A CPU can similarly use polling to check whether and when an I/O request has
    completed. The CPU requests an action by the I/O module over the bus. The I/O
    module starts to perform the requested action, setting appropriate bits in an
    internal I/O module status register as it goes. The CPU then periodically checks
    (or polls) the status of the I/O module by reading this status register until
    it finds that the action is complete.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the CPU could ask a webcam’s I/O module to grab a new frame of
    video data. It could then poll until the status is reported complete, then load
    the data from the module, knowing that it’s ready.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of polling are that it’s simple to implement and the CPU has direct
    control over I/O operation, requiring very little hardware support. The disadvantage—as
    in the human boss case—is that the CPU must periodically poll the module to check
    its status. This ties up the CPU, creating long periods where it does no useful
    work. The CPU is slowed to the speed of the peripheral, which is inefficient.
    Just like for humans, it gets quite exhausting needing to remember to ask, every
    day, if you’ve done your job yet—and to do the actual asking, too. It interferes
    with the mental workflow of other tasks for the manager and the worker.
  prefs: []
  type: TYPE_NORMAL
- en: '*Interrupts*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most managers would prefer to ask you to tell them when you’ve done your job,
    so they can forget about it until you take the initiative to tell them it’s complete.
    This approach is an example of an *interrupt architecture*. It frees the manager
    up to focus on other useful work.
  prefs: []
  type: TYPE_NORMAL
- en: In a computational interrupt architecture, the CPU is extended—for example,
    by adding an extra register and an instruction to set its contents—to enable the
    programmer to tell it the address of a special subroutine called a handler. The
    CPU is also extended by adding an extra dedicated physical pin called an *interrupt
    request (IRQ)* input, along with adding digital logic to the CU to make use of
    the pin. A high voltage on the IRQ tells the CU to alter the program flow by immediately
    calling the handler subroutine.
  prefs: []
  type: TYPE_NORMAL
- en: To use an interrupt architecture, the IRQ pin must be connected to a dedicated
    output from the I/O module. The programmer creates a handler subroutine intended
    to be executed once the I/O work is done, and tells the CPU its address. The programmer
    then writes a main program that instructs the I/O module to do actions. When an
    action command is sent to the I/O module, the CPU forgets all about it and continues
    executing the main program. The I/O module makes its device do its thing, which
    can take some time. When the device is done, the I/O module interrupts the CPU
    by setting the IRQ line to *high*. This calls the handler subroutine, which makes
    use of the new data from the device or tells it what to do next. Like any subroutine,
    calling the handler includes storing and returning to the value of the program
    counter for the instruction being interrupted, so the main program resumes after
    the interruption has been handled.
  prefs: []
  type: TYPE_NORMAL
- en: An advantage of interrupts is that they’re fast and efficient, with no need
    for the CPU to wait or to have to manage polling requests. A disadvantage of interrupts
    is that they can be tricky to write, especially when multiple I/O modules are
    in play, all sending interrupt signals at the same time. A *re-entrant architecture*
    allows interrupt-handling subroutines to be themselves interrupted by higher-priority
    IRQs, while a *non-re-entrant architecture* might ignore or delay these meta-interrupts.
    The code for a re-entrant architecture needs to think very carefully about how
    to handle meta-interrupts correctly, as a form of concurrent programming.
  prefs: []
  type: TYPE_NORMAL
- en: CPUs have a finite number of physical IRQ pins—sometimes fewer pins than there
    are devices that want to use them. Pins are a valuable, limited “real-estate”
    resource for modern CPUs, as adding more pins would force an increase in the physical
    package size of the chip.
  prefs: []
  type: TYPE_NORMAL
- en: '**IRQ HELL**'
  prefs: []
  type: TYPE_NORMAL
- en: Interrupts were a major bane in the lives of computer music creators in the
    1990s, as they needed to use a lot of external devices, such as multiple sound
    cards, MIDI cards, and input controller devices, all at the same time. You would
    get several physical IRQ lines on your Intel CPU chip, each intended to represent
    one physical device connected to the computer. If you had more devices than available
    IRQ pins, you needed a hack to get around this limitation. Hacks included trying
    to convince hardware and drivers made by different manufacturers to share a single
    IRQ line, or disabling IRQs used by system hardware to free them up for use by
    audio devices. Sometimes the latter had system-destroying side effects.
  prefs: []
  type: TYPE_NORMAL
- en: '*Direct Memory Access*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Both polling and interrupts are very slow for tasks that involve transferring
    large amounts of data from a device (such as a hard drive) into RAM. For example,
    if we request a 1Mb transfer, the I/O module will go off and do this, leaving
    the CPU free and happy, but when the interrupt is made this will create a big,
    slow job for the CPU to load every bit of that data into registers and then send
    it out to RAM. *Direct memory access (DMA)* is a technique to avoid this problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'DMA requires a dedicated hardware DMA controller (an I/O module itself) to
    be placed on the system bus. So far, all our uses of the system bus have involved
    the CPU talking to another node on the bus, which may be RAM or an I/O module,
    but buses also allow non-CPU nodes to communicate directly with one another, independently
    of the CPU. Any node can put a message to any other node on the bus, and this
    is done in DMA: the CPU grants authority for the I/O module to communicate directly
    with RAM over the bus, reading from or writing to memory without any CPU involvement.'
  prefs: []
  type: TYPE_NORMAL
- en: This frees the CPU to do other things; as with an IRQ, the CPU can “set and
    forget.” DMA usually sends an interrupt when a task is complete, so the CPU is
    involved only at the beginning and end of the transfer. This is especially useful
    for large data movements because the data doesn’t have to go through the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: I/O Without Modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I/O modules are the preferred architecture for I/O in most cases, but other
    module-less I/O architectures also exist and have their places in the world. We’ll
    consider some of them now.
  prefs: []
  type: TYPE_NORMAL
- en: '*CPU I/O Pins*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Some older CPUs, as well as some modern embedded CPUs, forgo I/O modules and
    bus-based I/O and have the CPU communicate directly with a few specific devices
    via dedicated pins. This approach isn’t scalable, as pins are a limited and valuable
    CPU resource (they determine the package’s physical size). But it can reduce the
    complexity of the architecture in cases where we know firmly in advance that only
    a couple of specific devices will ever be attached. If the whole I/O system is
    designed this way, it can remove the need for IRQ pins and control logic. It also
    frees up the bus for other activities.
  prefs: []
  type: TYPE_NORMAL
- en: '*Memory Mapping*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Rather than having an addressable I/O module, some architectures use areas of
    regular RAM as the interface between CPU and device. In these architectures, the
    RAM is readable and writable by both the CPU and the device (so it needs some
    extra non-bus wires connecting the pins to devices and to the bus). With this
    setup, the CPU writes directly to actual RAM as usual, then the device (or a module-like
    chip interfacing between the device and the RAM, but not on the bus itself) reads
    out of the RAM and translates into device commands like an I/O module. To the
    programmer it might be invisible whether the video RAM addresses they’re writing
    to are in fact regular RAM used in this way, or whether they’re part of a hardware
    I/O module.
  prefs: []
  type: TYPE_NORMAL
- en: '*Bus Hierarchies*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In modern architectures we often have more than one bus, forming a hierarchy
    of buses, as shown in [Figure 9-6](ch09.xhtml#ch09fig6).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0212-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-6: A bus hierarchy*'
  prefs: []
  type: TYPE_NORMAL
- en: The upper level here shows the same bus as in [Figure 9-3](ch09.xhtml#ch09fig3).
    However, the I/O module IO2 is an interface to a lower-level bus, which hosts
    three further lower-level components. This structure can improve usability and
    speed. Traditionally, each I/O module was connected to a single device and had
    to be mounted at particular addresses in address space when the computer was turned
    on. It was hard to add or remove (“plug and play”) devices while the computer
    was on. By introducing a single I/O module, such as a USB hub at a fixed address,
    we can allow for multiple plug-and-play devices to all connect to this same I/O
    module via a lower-level protocol, USB. This arrangement also solves the IRQ hell
    problem, as the I/O module can use a single, valuable IRQ line to alert the CPU
    to interrupts from any of these devices. The lower-level bus can be built from
    slower and cheaper technology than the system bus, as it only needs to run at
    the speed the data is actually available (which may be limited, for example, by
    waiting for real-world audio or spinning hard disks).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a computer to interact with the outside world, such as through graphics
    and sound, it needs input and output. This can be achieved through I/O modules,
    which are digital logic components that to the CPU look and act like RAM. Stores
    sent to their addresses are interpreted as commands to control devices in the
    outside world, while reads from them are used to send data that has been obtained
    from sensors in the outside world.
  prefs: []
  type: TYPE_NORMAL
- en: CPU, memory, and I/O all share the same address space and communicate using
    a shared, public bus of wires, which include address, data, and control lines.
    CPUs interface to the bus via the staging registers MAR and MBR.
  prefs: []
  type: TYPE_NORMAL
- en: CPU may also interface directly to a limited number of I/O modules via interrupt
    lines, which the I/O module uses to request the CPU to jump to a handler subroutine.
    I/O modules have also become increasingly independent of the CPU and can use methods
    such as DMA to communicate with one another and with RAM over the bus without
    involving the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: An important use of the bus and of I/O is for managing real-world memory, including
    multiple physical RAM and ROM modules, and hard disk and optical disc devices.
    We’ll study these in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Challenging**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Take your LogiSim Baby from [Figure 7-13](ch07.xhtml#ch07fig13) and extend it
    so that storing to one of its addresses acts to turn a simulated LED on and off.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extend it again so that loading from another address acts to read the state
    of a simulated switch. You can do this by reducing the size of the RAM by two
    addresses, then adding a new digital logic I/O module to the bus that listens
    for those addresses and acts accordingly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extend it yet again so that the I/O module decodes multiple commands sent as
    data inside the store instruction and uses them to command the LED to do different
    things, such as flash at different speeds. Here the LED and switch represent general
    devices that could be controlled in this way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'See *The Victorian Internet* by Tom Standage (London: Weidenfeld & Nicolson,
    1998) for a comparison of the 19th-century telegraph and the modern internet.'
  prefs: []
  type: TYPE_NORMAL
