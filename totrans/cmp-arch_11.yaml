- en: '**9**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**9**'
- en: '**INPUT/OUTPUT**'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**输入/输出**'
- en: '![Image](../images/f0201-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0201-01.jpg)'
- en: You’ve seen how to build a basic CPU and RAM, which together can run programs.
    CPU and RAM are great for performing calculations, but to bring a computer to
    life with graphics, sound, joysticks, and other interactions with the real world,
    we also need input and output, known together as *I/O*. In this chapter, you’ll
    see how to add I/O capabilities using buses, I/O modules, devices, and peripherals.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了如何构建一个基本的 CPU 和 RAM，它们可以一起运行程序。CPU 和 RAM 非常适合执行计算，但要让计算机具备图形、声音、操纵杆和与现实世界其他交互的能力，我们还需要输入和输出，统称为*I/O*。在本章中，你将学习如何使用总线、I/O
    模块、设备和外设添加 I/O 功能。
- en: Basic I/O Concepts
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本的 I/O 概念
- en: To discuss I/O in detail, let’s first define a few terms. *I/O modules* are
    digital electronics that—like RAM—are assigned and connected to addresses in the
    computer’s *address space*, the range of possible addresses that the CPU can access.
    I/O modules are also connected to *devices*, which are electronic systems, including
    digital and analog electronics, that aren’t connected directly to the computer’s
    address space but that can communicate with it via the attached I/O modules. Devices
    may be physically inside the computer, such as an analog circuit that controls
    the scanning beam of a CRT monitor, or outside it, such as the electronic circuits
    inside a printer.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了详细讨论 I/O，首先让我们定义一些术语。*I/O 模块*是数字电子设备，像 RAM 一样，它们被分配并连接到计算机的*地址空间*中的地址，地址空间是
    CPU 可以访问的地址范围。I/O 模块也与*设备*相连接，设备是包括数字和模拟电子学在内的电子系统，这些设备并不直接连接到计算机的地址空间，但可以通过附加的
    I/O 模块与其通信。设备可以物理地位于计算机内部，例如控制 CRT 显示器扫描束的模拟电路；也可以在外部，例如打印机内部的电子电路。
- en: '*Peripherals* are the most obvious elements of I/O for most computer users:
    they’re the physical objects that connect to the computer from the outside, such
    as mice, joysticks, monitors, and printers. Peripherals are encased in their own
    plastic and connect to the computer’s box via a wire that the end user can easily
    plug and unplug. Some peripherals, such as printers, physically contain their
    devices. Others, such as monitors, rely on a device inside the computer box (CRT
    controllers, in the case of a monitor).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*外设*是大多数计算机用户最直观的 I/O 元件：它们是与计算机连接的物理对象，例如鼠标、操纵杆、显示器和打印机。外设被封装在自己的塑料外壳中，通过一根用户可以轻松插拔的电缆连接到计算机的机箱。有些外设，比如打印机，内部包含其设备。其他外设，比如显示器，则依赖于计算机机箱内的设备（例如显示器的
    CRT 控制器）。'
- en: In the 8-bit era, computer design meant building a complete computer by buying
    and connecting together CPU, memory, devices, and logic chips, and perhaps custom-designing
    I/O modules. For example, the Commodore 64 mainboard shown in [Figure 9-1](ch09.xhtml#ch09fig1)
    shows that a large part of the machine is devoted to I/O.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在 8 位时代，计算机设计意味着通过购买并连接 CPU、内存、设备和逻辑芯片来构建一台完整的计算机，并可能需要定制设计输入/输出（I/O）模块。例如，图
    [9-1](ch09.xhtml#ch09fig1) 中显示的 Commodore 64 主板展示了机器中很大一部分是用于 I/O 的。
- en: '![Image](../images/f0202-01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0202-01.jpg)'
- en: '*Figure 9-1: A C64 mainboard, showing CPU, memory (RAM and ROM), I/O modules,
    and devices*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-1：C64 主板，显示 CPU、内存（RAM 和 ROM）、I/O 模块和设备*'
- en: The I/O section in the top-left of the figure includes two *Complex Interface
    Adapter (CIA)* chips, each of which contain multiple I/O modules. The devices
    section in the bottom-right includes graphics and sound chips.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图中左上方的 I/O 部分包含两个*复杂接口适配器（CIA）*芯片，每个芯片包含多个 I/O 模块。右下角的设备部分包括图形和声音芯片。
- en: Nowadays, something like the entire mainboard of the Commodore 64 is shrunk
    down to a single system-on-chip (SoC) in your phone, but the structure was easier
    to understand and learn from when the parts were in physically separate integrated
    circuit (IC) packages. Keep this image in mind as we move through this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，类似于 Commodore 64 主板的整体结构已经缩小为手机中的单一系统芯片（SoC），但是当各个部件是以物理分开的集成电路（IC）封装形式存在时，结构更容易理解和学习。请在我们继续阅读本章时牢记这一形象。
- en: To the CPU, I/O modules appear exactly like part of RAM. They have addresses
    that can be read and written to, using the same load and store instructions as
    reading and writing to RAM. Now that we have both RAM and I/O modules connecting
    to the same CPU address and data lines, we need a way for them to share these
    resources. This can be done using the bus architecture seen in the next section.
    After discussing buses, we’ll look inside the I/O modules and see how to communicate
    with them in more detail.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CPU来说，I/O模块看起来就像是RAM的一部分。它们有可以读取和写入的地址，使用与读取和写入RAM相同的加载和存储指令。现在，RAM和I/O模块都连接到相同的CPU地址和数据线，我们需要一种方式让它们共享这些资源。这可以通过下节中将介绍的总线架构来实现。讨论完总线之后，我们将深入了解I/O模块，并详细介绍如何与它们通信。
- en: Buses
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总线
- en: 'A *bus architecture* is a specific type of network architecture in which every
    device involved in communication has equal access to a shared wire or set of wires,
    called the *bus*. Like the public transportation vehicle of the same name, a computer
    bus is so-called because it is a public place (it abbreviates the Latin *omnibus*,
    meaning “for all”). To illustrate the public quality of a bus architecture, consider
    the example of a prison water pipe tapping system: all the prisoners in a prison
    have plumbing connected to the same pipes, so tapping on one pipe to transmit
    a plan for a prison breakout in Morse code inevitably broadcasts the message to
    anyone and everyone who is listening to the pipes. There’s no privacy in a bus
    architecture (unless encryption is used), which may have interesting security
    implications if untrusted devices are allowed to access it.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*总线架构*是一种特定类型的网络架构，其中每个参与通信的设备都可以平等地访问一个共享的电线或一组电线，这些电线称为*总线*。就像同名的公共交通工具一样，计算机总线之所以得名是因为它是一个公共场所（它缩写自拉丁语*omnibus*，意思是“为所有人”）。为了说明总线架构的公共性质，可以考虑一个监狱水管窃听系统的例子：监狱中的所有囚犯都有连接到同一管道的水管，因此，任何人敲击一根管道，利用摩尔斯电码传输越狱计划，必然会广播该消息给所有监听管道的人。在总线架构中没有隐私（除非使用加密），如果允许不信任的设备访问总线，可能会带来有趣的安全隐患。'
- en: A bus is the simplest form of network, lacking the complexity of the internet’s
    packets, error handling, and routing. For example, it’s possible that two prisoners
    will try to tap the pipe at the same time, creating a collision that destroys
    both of their messages.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 总线是最简单的网络形式，缺乏互联网的分包、错误处理和路由等复杂性。例如，可能有两个囚犯会试图同时窃听同一根管道，造成碰撞，导致他们的消息都被破坏。
- en: In general, a bus is composed of several *nodes* (things that want to talk to
    each other) and communication lines (wires) between them. Modern buses usually
    have many lines used in parallel, though there are also buses with only one. We
    may divide these lines into control, address, and data lines.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，总线由几个*节点*（即希望互相通信的设备）和它们之间的通信线路（电线）组成。现代总线通常有许多并行使用的线路，但也有只有一根线路的总线。我们可以将这些线路分为控制线、地址线和数据线。
- en: A protocol is needed to ensure that signals don’t collide with the signals being
    sent by other nodes, so for a node to send a message to another it must first
    announce whom the message is for—the address, on the address lines—and announce
    what type of message it is—the control, on the control lines. It then broadcasts
    the data on the data lines. Either you can have one of the nodes in charge of
    the bus, enforcing the protocol by only allowing nodes to write when it gives
    them permission, or you can trust the nodes to implement the protocol themselves
    and play nicely with each other.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一种协议来确保信号不会与其他节点发送的信号发生冲突，因此，节点在向另一个节点发送消息之前，必须首先宣布消息的接收者——即地址，通过地址线传递——并宣布消息的类型——即控制信息，通过控制线传递。然后，它在数据线上广播数据。你可以让其中一个节点负责总线，通过仅在允许时才允许节点写入来强制执行该协议，或者你可以信任节点自行实现协议，并彼此配合良好。
- en: '**THE VICTORIAN INTERNET**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**维多利亚时代的互联网**'
- en: The telegraph system of Babbage’s and Boole’s time has been called the “Victorian
    Internet.” It was a bus architecture connecting sites in Britain, America, and
    the British Empire. Human operators at a local station would tap out Morse code
    text messages (telegrams) for customers, and listen for messages addressed to
    their station from elsewhere. All of the messages were transmitted onto the same
    wire, which could be written to and read from by all operators. These operators
    spent thousands of hours listening and writing to the wire, becoming fluent in
    Morse code and developing their own Morse “speaking” styles that could be used
    to recognize who was talking. They would also chat with one another when not sending
    messages for customers, engaging in typical modern chat-room behaviors such as
    using abbreviated slang (textspeak), falling in love, and even getting married
    to operators on other continents without having met them in person.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 巴贝奇和布尔时代的电报系统被称为“维多利亚时代的互联网”。它是一种总线架构，连接着英国、美国和大英帝国的各个站点。当地车站的人工操作员会为顾客敲击莫尔斯电码文本消息（电报），并监听从其他地方发送到其站点的消息。所有消息都通过同一条电缆传输，所有操作员都可以读取和写入这些信息。这些操作员花费了成千上万的小时在电缆上收听和写作，精通莫尔斯电码，并发展出自己独特的莫尔斯“说话”风格，可以用来识别是谁在讲话。他们还会在不为顾客发送消息时相互聊天，进行典型的现代聊天室行为，比如使用简化俚语（短信语言）、谈恋爱，甚至在没有见过面的情况下与其他大陆的操作员结婚。
- en: An advantage of a bus architecture is that it’s easy to add new devices to the
    bus, as the same set of shared wires connect all the components. The shared wires
    also make buses cheap to implement. On the other hand, the bus can be a bottleneck,
    limiting the performance of the system. This is particularly annoying if you’re
    optimizing your CPU or memory to go very fast, only to then have the data hit
    a bus and slow down. Bus performance can also be limited by physical factors such
    as wire length and the number of connections.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 总线架构的一个优点是，添加新设备到总线非常容易，因为相同的一组共享线路连接所有组件。共享线路还使得总线的实现成本较低。另一方面，总线可能成为瓶颈，限制系统的性能。如果你优化了CPU或内存的速度，非常快速，但数据最终还是通过总线传输，导致速度变慢，那就特别令人烦恼。总线性能还可能受到物理因素的限制，如线路长度和连接数量。
- en: '*Bus Lines*'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*总线线路*'
- en: 'The lines on the bus are the same as the wires we’ve previously connected point-to-point
    between CPU (or its cache) and RAM. There are three different kinds:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 总线上的线路与我们之前在CPU（或其缓存）与RAM之间点对点连接的线路相同。它们有三种不同的类型：
- en: '**Address lines** These are used to designate the source or destination of
    data on the data bus. The width of the address bus determines the maximum possible
    memory capacity (that is, the amount of memory a system can address). For example,
    a system with a 32-bit address bus can address 2^(32) (4,294,967,296) memory locations.
    If each memory location held an 8-bit word (byte), the addressable memory space
    is 4 GiB. For a 64-bit address space of 64-bit words, exactly 1 zebibit (2⁶× 2^(64)
    = 2^(70)) of memory can be used, which is enough to allow all of the data in a
    search engine–sized data center to have its own RAM address.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**地址线** 这些用于指定数据总线上数据的来源或目的地。地址总线的宽度决定了系统的最大内存容量（即系统可以寻址的内存量）。例如，一个32位地址总线的系统可以寻址2^(32)（4,294,967,296）个内存位置。如果每个内存位置存储一个8位字（字节），则可寻址的内存空间为4
    GiB。对于64位地址空间的64位字，正好可以使用1泽比特（2⁶× 2^(64) = 2^(70)）的内存，这足以使搜索引擎大小的数据中心中的所有数据都有自己的RAM地址。'
- en: '**Data lines** These provide the path for the actual transfer of data among
    nodes. A key performance factor is the width of the data bus (that is, the number
    of data lines). A typical data bus consists of 32, 64, 128, or even more separate
    lines. To send messages that are longer than the data line width, you need to
    split them up and send them over several cycles. For example, if a data bus is
    32 bits wide and each instruction is 64 bits long, then the CPU must access the
    memory module twice during each instruction cycle.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据线** 这些线路提供了在节点之间实际传输数据的路径。一个关键的性能因素是数据总线的宽度（即数据线的数量）。一个典型的数据总线由32、64、128或更多条独立的线路组成。为了发送超过数据线宽度的消息，你需要将它们分拆并通过多个周期传输。例如，如果数据总线宽度是32位，每条指令是64位长，那么CPU在每个指令周期内必须访问内存模块两次。'
- en: '**Control lines** These are used to control access to and use of the data and
    address lines. For example, the write-enable wire used previously in [Figure 7-10](ch07.xhtml#ch07fig10)
    when we discussed the Baby’s store operation is a simple control line. More generally,
    as the data and address lines are shared by many components, there must be a means
    of controlling their use such that multiple components don’t attempt to write
    to those lines at the same time. Further control lines can be used to request
    and negotiate for this access.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制线** 这些用于控制数据和地址线的访问和使用。例如，在我们讨论 Baby 存储操作时，之前在[图 7-10](ch07.xhtml#ch07fig10)中使用的写使能线就是一个简单的控制线。更一般地说，由于数据线和地址线被许多组件共享，因此必须有一种方式来控制它们的使用，以避免多个组件同时尝试写入这些线路。进一步的控制线可以用于请求和协商访问权限。'
- en: '*The CPU-Bus Interface*'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*CPU-总线接口*'
- en: Most CPUs are designed to connect to an external bus, printed onto the mainboard,
    via pins on the CPU chip connecting to sockets on the main-board. Where the bus
    wires physically connect to the CPU, the connection is known as the *front side
    bus (FSB)*. The vast majority of a CPU’s pins are taken up by the FSB, as can
    be seen in the Commodore 64’s 8-bit 6502 CPU chip pinout and the 1990s 32-bit
    Intel Socket2 pinout in [Figure 9-2](ch09.xhtml#ch09fig2).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 CPU 设计为通过 CPU 芯片上的引脚连接到主板上的插座，以便与主板上的外部总线连接。在总线电缆与 CPU 物理连接的地方，这种连接被称为 *前端总线（FSB）*。正如在[图
    9-2](ch09.xhtml#ch09fig2)中的 Commodore 64 的 8 位 6502 CPU 引脚图和 1990 年代的 32 位英特尔
    Socket2 引脚图所示，绝大多数 CPU 的引脚都被 FSB 占据。
- en: '![Image](../images/f0205-01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0205-01.jpg)'
- en: '*Figure 9-2: Pinout diagrams for an 8-bit 6502 (left) and 32-bit Socket2 chip
    (center), plus a pin photo of a 64-bit LGA1155 socket CPU (right)*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-2：8 位 6502（左）和 32 位 Socket2 芯片（中）的引脚图，以及 64 位 LGA1155 插座 CPU 的引脚照片（右）*'
- en: The 6502 here uses 16-bit addresses and 8-bit words, so it has 16 address (A)
    pins and 8 data (D) pins. The R/W pin is for the read/write control line. In all,
    more than half of the chip’s 40 pins are devoted to the bus. The Socket2 was used
    with 32-bit address spaces and 32-bit data words, so it has 32 each of A and D
    pins (colored white and black in the diagram, respectively). Meanwhile, 64-bit
    CPU chips and sockets need twice as many of each, requiring them to be smaller
    and more fragile.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 6502 使用 16 位地址和 8 位数据，因此它有 16 个地址（A）引脚和 8 个数据（D）引脚。R/W 引脚用于读/写控制线。总的来说，芯片的
    40 个引脚中有超过一半用于总线。Socket2 用于 32 位地址空间和 32 位数据字，因此它有 32 个 A 引脚和 32 个 D 引脚（分别在图中以白色和黑色表示）。同时，64
    位 CPU 芯片和插座需要每种引脚数量的两倍，因此它们必须更小且更脆弱。
- en: The CPU needs to communicate with the bus, but the bus is usually slower than
    the CPU. Hence, CPU designers prefer to use registers to stage data going in and
    out of the CPU (as in the Analytical Engine’s ingress/ egress axes, connecting
    the CPU to its mechanical rack bus). The bus is a scarce resource, so we don’t
    want to use it for any longer than needed; if data is staged, it can be put on
    and off the bus at whatever time the bus becomes available. Typically, these staging
    mechanisms include a *memory address register (MAR)*, which stores the address
    from which we want to read or write, and a *memory buffer register (MBR)*, which
    stores a copy of the data being written to or read from that address, as shown
    in [Figure 9-3](ch09.xhtml#ch09fig3).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 需要与总线通信，但总线通常比 CPU 慢。因此，CPU 设计师倾向于使用寄存器来缓存进出 CPU 的数据（如分析机中的输入/输出轴，连接 CPU
    和其机械架构总线）。总线是一种稀缺资源，因此我们不希望将其使用时间过长；如果数据被缓存，它可以在总线可用时随时放入或取出。通常，这些缓存机制包括 *内存地址寄存器（MAR）*，它存储我们要读取或写入的地址，以及
    *内存缓冲寄存器（MBR）*，它存储正在写入或读取该地址的数据副本，如[图 9-3](ch09.xhtml#ch09fig3)所示。
- en: '![Image](../images/f0205-02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0205-02.jpg)'
- en: '*Figure 9-3: A bus architecture, including a CPU, a RAM module, and two I/O
    modules*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-3：一种总线架构，包括一个 CPU、一个 RAM 模块和两个 I/O 模块*'
- en: 'To execute a load instruction, the operand containing the address to be loaded
    is temporarily connected from its instruction register (IR) bits to the MAR, creating
    a copy in the MAR. When this copy is completed, the MAR is temporarily connected
    to memory as a read request, and the data from memory is temporarily connected
    to the MBR, which takes a copy of this data. Then the control unit (CU) can temporarily
    connect the MBR to the accumulator or other user register. In register transfer
    language (RTL) style, this can be written as:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行加载指令，包含要加载地址的操作数会暂时从其指令寄存器（IR）位连接到MAR，创建MAR中的副本。当副本完成时，MAR会暂时连接到内存，发出读取请求，并且内存中的数据会暂时连接到MBR，MBR获取该数据的副本。然后，控制单元（CU）可以暂时将MBR连接到累加器或其他用户寄存器。用寄存器传输语言（RTL）风格表示，这可以写成：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The same MAR and MBR registers can be used to execute a store instruction as
    well. The CU temporarily connects the MAR to the operand bits in the IR containing
    the address to be written to; the MAR takes a copy of the address. Then, the CU
    temporarily connects the MBR to the register containing the value to be written;
    the MBR takes a copy of the value. The MAR and MBR now contain all the required
    information describing the store. Finally, the CU temporarily connects the MAR
    to the RAM’s address lines and the MBR to the RAM’s data lines, and sets its command
    line to store, which performs the store in RAM. In RTL this can be written as:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的MAR和MBR寄存器也可以用来执行存储指令。CU会暂时将MAR连接到IR中包含要写入地址的操作数字段；MAR获取该地址的副本。然后，CU会暂时将MBR连接到包含要写入值的寄存器；MBR获取该值的副本。现在，MAR和MBR包含描述存储操作所需的所有信息。最后，CU会暂时将MAR连接到RAM的地址线，将MBR连接到RAM的数据线，并将其命令线设置为存储，这样就会在RAM中执行存储操作。在RTL中，这可以写成：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Having the MAR and MBR also simplifies the design of CPUs that have multiple
    user registers rather than just an accumulator. They make it easy to separate
    out the logic and timing for selecting which register is to be connected to the
    bus from the logic and timing of transferring the data to and from the bus.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有MAR和MBR也简化了设计具有多个用户寄存器而非仅一个累加器的CPU。它们使得从选择连接到总线的寄存器的逻辑和时序，分离出数据从总线传输到寄存器的逻辑和时序变得容易。
- en: I/O Modules
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I/O模块
- en: 'Devices usually attach to a computer via an I/O module. This is a chip that
    sits on the bus and at some addresses; it looks just like RAM to the CPU. If you
    learn only one thing from this chapter, it should be this: I/O modules appear
    to the CPU and assembly programmer as an area of readable, writable memory, just
    like main RAM. Unlike RAM, an I/O module also has wires coming out of the other
    side that go to the device. The module presents a standardized interface to the
    CPU, and translates requests from the CPU to specific signals on the wires to
    the particular device. Hence, we can buy any device, such as a sound chip, on
    eBay and install it in a particular type of computer, as long as we make an I/O
    module that provides a suitable address space for the computer and sends whatever
    signals the sound chip is expecting.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 设备通常通过I/O模块连接到计算机。这是一个芯片，坐落在总线上，位于某些地址；它对CPU来说看起来就像RAM。如果你从本章中学到的唯一一件事，那应该是这一点：I/O模块对CPU和汇编程序员来说，表现得像一个可读写的内存区域，就像主RAM一样。与RAM不同，I/O模块的另一侧还连接着通往设备的线路。该模块为CPU提供了一个标准化的接口，并将CPU的请求转换为通过这些线路传送到特定设备的信号。因此，我们可以在eBay上购买任何设备，例如声音芯片，并将其安装在特定类型的计算机中，只要我们制造一个I/O模块，提供适当的地址空间，并发送声音芯片所期望的信号。
- en: Storing to these addresses might transmit commands to the device; it might write
    assembly-like instructions specific to the module for further translation into
    device commands (used in modern graphics cards, for example), or it might send
    data to the device (such as what audio to play). Loading from these addresses
    might read data from the device, such as a keyboard key press or a microphone
    sound wave, or read status information from the device, such as whether there’s
    a printer jam. It’s up to the designer of an I/O module how they want to interpret
    these load and store commands.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 存储到这些地址可能会向设备发送命令；它可能会写入类似汇编的指令，这些指令是针对模块的，用于进一步转化为设备命令（例如，在现代显卡中使用），或者它可能会向设备发送数据（例如，播放什么音频）。从这些地址加载可能会从设备读取数据，例如键盘按键或麦克风声波，或者读取设备的状态信息，例如是否有打印机卡纸。I/O模块的设计者可以根据需要解释这些加载和存储命令。
- en: Some I/O addresses may be implemented by actual RAM inside the module (distinct
    from regular RAM chips, because this specialized RAM has extra connections to
    the rest of the I/O circuitry); other times, it may just be immediate digital
    logic with no RAM. Both methods present the same interface to the CPU, which doesn’t
    know if there’s real memory there or something else.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 I/O 地址可能由模块内部的实际 RAM 实现（不同于常规 RAM 芯片，因为这种专用 RAM 具有额外的连接与其他 I/O 电路相连）；有时，它也可能只是没有
    RAM 的直接数字逻辑。两种方法都向 CPU 提供相同的接口，CPU 并不知道那里是否有真实内存或其他东西。
- en: In addition to device communication, the I/O module will also usually handle
    control and timing, data buffering, and device errors. Let’s turn there now.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 除了设备通信，I/O 模块通常还会处理控制和时序、数据缓冲以及设备错误。我们现在来谈谈这些内容。
- en: '*Control and Timing*'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*控制和时序*'
- en: An I/O module must be able to coordinate the flow of data between the internal
    resources and external devices. The latter may be slow, so the module manages
    them independently of the CPU. This allows the CPU to go and do other things while
    it’s waiting. This is a form of non–CPU level parallelism.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: I/O 模块必须能够协调内部资源和外部设备之间的数据流。外部设备可能较慢，因此模块独立于 CPU 管理它们。这使得 CPU 在等待时可以去做其他事情。这是一种非
    CPU 级并行性。
- en: The I/O module achieves this independent management by using data buffering
    to transfer data into and out of main memory or CPU. *Buffering* means using a
    dedicated area of memory, called a *buffer*, as a staging area. Slow devices can
    take their time writing to or reading from a buffer, independently of the CPU.
    The fast CPU can also read or write to the same buffer, independently of the device.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: I/O 模块通过使用数据缓冲来实现独立管理，将数据转入或转出主内存或 CPU。*缓冲*意味着使用专用的内存区域，称为 *缓冲区*，作为暂存区。慢速设备可以在独立于
    CPU 的情况下，花时间向缓冲区写入或从缓冲区读取数据。快速的 CPU 也可以独立于设备读取或写入同一个缓冲区。
- en: '*Ring buffers* are used in audio and similar real-time signal-processing I/Os.
    Conceptually, a ring buffer is a region of data in which the data items are organized
    in a circle, each with a previous and next neighbor, as in [Figure 9-4](ch09.xhtml#ch09fig4).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*环形缓冲区*用于音频和类似的实时信号处理 I/O。概念上，环形缓冲区是一个数据区域，其中数据项以圆形排列，每个数据项都有前一个和下一个邻居，如[图
    9-4](ch09.xhtml#ch09fig4)所示。'
- en: '![Image](../images/f0208-01.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0208-01.jpg)'
- en: '*Figure 9-4: A ring buffer. Both pointers move clockwise. The string 0123456789
    has been written, with the initial 01 now overwritten by 89\. Of this, 01234 has
    been read.*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-4：一个环形缓冲区。两个指针顺时针移动。字符串 0123456789 已经写入，最初的 01 现在被 89 覆盖。其中，01234 已经被读取。*'
- en: Two pointers—which can be visualized as clock hands—keep track of the read point
    and the write point. As new data arrives in real time, it’s written to the write
    point, which is then incremented to point to the next slot. Eventually the write
    pointer makes it all the way around the ring, at which point it starts overwriting
    old data. The user program can request to read the next available items at any
    time. When this happens, the data at the read pointer is copied out and the read
    pointer is incremented until the number of items requested is met or the read
    pointer hits the write pointer, meaning there’s no further new data available.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 两个指针——可以形象地看作时钟指针——跟踪读取点和写入点。当新数据实时到达时，它会被写入到写入点，之后写入点递增指向下一个槽。最终，写入指针会绕环一圈，开始覆盖旧数据。用户程序可以随时请求读取下一个可用项。当发生这种情况时，读取指针的数据会被复制出去，读取指针递增，直到满足请求的项数，或者读取指针与写入指针重合，意味着没有更多的新数据可用。
- en: '*Double buffers* are often used for graphics rendering. Here, two buffers are
    maintained, each representing the layout of the screen, as in [Figure 9-5](ch09.xhtml#ch09fig5).'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*双缓冲区*通常用于图形渲染。在这里，维护了两个缓冲区，每个缓冲区代表屏幕的布局，如[图 9-5](ch09.xhtml#ch09fig5)所示。'
- en: '![Image](../images/f0208-02.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0208-02.jpg)'
- en: '*Figure 9-5: Double buffering*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-5：双缓冲*'
- en: At any instant, one buffer stores a completely rendered image and is connected
    (shown by the thick black outlines in the figure) to the graphics display hardware,
    which works to physically display it. Meanwhile, the other buffer is used to gradually
    build up the next image to be displayed—for example, by drawing the background
    and then adding sprites and overlays to it. Only when the new buffer is finished
    is the output line swapped over to connect it to the display; then the original
    buffer is cleared and used to start drawing the third image in the sequence. This
    approach means that only completed images are ever shown on the screen, which
    avoids flickering images that show the parts of the images being built up in real
    time. (Triple buffering is also used in some cases, allowing *two* future frames
    to be drawn in parallel while the current frame is being displayed. This can achieve
    a higher frame rate, as long as it’s known far enough in advance what will be
    wanted.)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时刻，一个缓冲区存储着完全渲染的图像，并通过图中显示的粗黑线连接到图形显示硬件，后者负责物理显示该图像。与此同时，另一个缓冲区则用于逐步构建下一张将要显示的图像——例如，先绘制背景，然后在其上添加精灵和覆盖物。只有当新的缓冲区完成时，输出线路才会交换，连接到新图像的显示器上；然后，原来的缓冲区被清空，并用于开始绘制序列中的第三张图像。这种方法确保只有完成的图像才会显示在屏幕上，从而避免了实时构建图像时的闪烁现象。（在某些情况下，也会使用三重缓冲技术，允许
    *两个* 未来的帧并行绘制，同时当前帧正在显示。只要提前知道需要显示什么内容，这可以实现更高的帧率。）
- en: '*Error Detection*'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*错误检测*'
- en: Another major function of I/O modules is device error handling. What should
    an I/O module do if the CPU asks it to do something, but then it detects an error
    from its device? The error could be a mechanical or electrical malfunction in
    the device (for example, a paper jam in a printer or a bad disk track), or it
    could be the result of unintentional changes to bit patterns as they’re transmitted
    between the device and the I/O module, often due to noisy external cables.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: I/O 模块的另一个主要功能是设备错误处理。如果 CPU 请求 I/O 模块执行某个操作，但 I/O 模块在执行时发现了设备的错误，应该怎么办？这个错误可能是设备的机械故障或电气故障（例如打印机卡纸或硬盘损坏的磁道），也可能是由于设备与
    I/O 模块之间的比特传输发生了无意的变化，这通常是由于外部电缆的噪音干扰。
- en: Typically, a device shouldn’t report an error directly to the CPU, which may
    be busy doing other things. Instead, it reports the error to the I/O module, which
    can then pass it on to the CPU.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，设备不应直接向 CPU 报告错误，因为 CPU 可能正在忙于其他任务。相反，设备会将错误报告给 I/O 模块，然后 I/O 模块将错误传递给
    CPU。
- en: I/O Module Techniques
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I/O 模块技术
- en: Transferring data from an external device to the CPU requires several steps.
    First, the CPU writes to the bus, asking the I/O module to check the status of
    the device. Next, the I/O module returns the device status in reply, also writing
    to the bus. If the device is ready, the CPU requests transfer of data with another
    bus write. The I/O module then obtains a unit of data from the device. This data
    is finally transferred via the bus from the I/O module to the CPU.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据从外部设备传输到 CPU 需要几个步骤。首先，CPU 向总线写入，要求 I/O 模块检查设备的状态。接下来，I/O 模块回复设备状态，并同样向总线写入。如果设备准备好了，CPU
    会再次通过总线写入请求数据传输。然后，I/O 模块从设备中获取一单元数据。最后，这些数据通过总线从 I/O 模块传输到 CPU。
- en: This process will be slow if it requires waiting for things in the real world.
    If a gigahertz CPU asks to read 100 audio samples, and audio samples arrive only
    at 44 kHz, it will need to spend most of its time doing nothing and waiting around
    for each of these samples to arrive and be sent on the bus by the I/O module.
    We would prefer the CPU to keep busy doing other things while waiting for the
    requested I/O to take place. This can be accomplished via three common techniques.
    We’ll discuss each in turn.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该过程需要等待现实世界中的某些事情，它将变得很慢。例如，如果一颗千兆赫兹的 CPU 要求读取 100 个音频样本，但音频样本的到达速率只有 44 kHz，那么它将不得不花费大部分时间什么都不做，等待每一个样本到达并通过
    I/O 模块发送到总线上。我们希望 CPU 在等待请求的 I/O 操作时，能做其他事情。这个目标可以通过三种常见的技术来实现。我们将逐一讨论每种技术。
- en: '*Polling*'
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*轮询*'
- en: Suppose your boss needs you to get a report finished. One management strategy
    they could use is *polling*, in which they repeatedly come back and ask you, “Have
    you finished that job yet?” every hour, day, or month.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的老板需要你完成一份报告。他们可以使用的一种管理策略是 *轮询*，也就是他们每隔一段时间（每小时、每天或每月）就回来看你一次，问你：“你完成那个任务了吗？”
- en: A CPU can similarly use polling to check whether and when an I/O request has
    completed. The CPU requests an action by the I/O module over the bus. The I/O
    module starts to perform the requested action, setting appropriate bits in an
    internal I/O module status register as it goes. The CPU then periodically checks
    (or polls) the status of the I/O module by reading this status register until
    it finds that the action is complete.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: CPU也可以类似地使用轮询来检查I/O请求是否已完成。CPU通过总线向I/O模块请求执行某个操作。I/O模块开始执行请求的操作，并在过程中设置内部I/O模块状态寄存器中的适当位。然后，CPU定期检查（或轮询）I/O模块的状态，读取该状态寄存器，直到发现操作已完成。
- en: For example, the CPU could ask a webcam’s I/O module to grab a new frame of
    video data. It could then poll until the status is reported complete, then load
    the data from the module, knowing that it’s ready.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，CPU可以要求一个网络摄像头的I/O模块抓取一帧新的视频数据。然后，它可以进行轮询，直到状态报告完成，再从模块加载数据，知道数据已经准备好。
- en: Advantages of polling are that it’s simple to implement and the CPU has direct
    control over I/O operation, requiring very little hardware support. The disadvantage—as
    in the human boss case—is that the CPU must periodically poll the module to check
    its status. This ties up the CPU, creating long periods where it does no useful
    work. The CPU is slowed to the speed of the peripheral, which is inefficient.
    Just like for humans, it gets quite exhausting needing to remember to ask, every
    day, if you’ve done your job yet—and to do the actual asking, too. It interferes
    with the mental workflow of other tasks for the manager and the worker.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 轮询的优点在于它易于实现，且CPU可以直接控制I/O操作，几乎不需要硬件支持。缺点——就像人类老板的例子一样——是CPU必须定期轮询模块以检查其状态。这占用了CPU的时间，造成了长时间的无效工作。CPU的速度被外设的速度限制，效率低下。就像人类一样，每天都需要记得询问你是否完成工作，并且还要实际进行询问，这非常疲惫。它干扰了管理者和工人的其他任务的思维流程。
- en: '*Interrupts*'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*中断*'
- en: Most managers would prefer to ask you to tell them when you’ve done your job,
    so they can forget about it until you take the initiative to tell them it’s complete.
    This approach is an example of an *interrupt architecture*. It frees the manager
    up to focus on other useful work.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数经理更倾向于让你告诉他们何时完成工作，这样他们可以忘记它，直到你主动告诉他们已经完成。这种方法是一个*中断架构*的例子，它使经理能够专注于其他有用的工作。
- en: In a computational interrupt architecture, the CPU is extended—for example,
    by adding an extra register and an instruction to set its contents—to enable the
    programmer to tell it the address of a special subroutine called a handler. The
    CPU is also extended by adding an extra dedicated physical pin called an *interrupt
    request (IRQ)* input, along with adding digital logic to the CU to make use of
    the pin. A high voltage on the IRQ tells the CU to alter the program flow by immediately
    calling the handler subroutine.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算中断架构中，CPU通过扩展来实现——例如，添加一个额外的寄存器和一个指令来设置其内容——以使程序员能够告知它一个特殊子程序（称为处理程序）的地址。CPU还通过增加一个额外的专用物理引脚，称为*中断请求（IRQ）*输入，并在控制单元（CU）中增加数字逻辑以利用该引脚。IRQ上的高电压通知CU通过立即调用处理程序子程序来改变程序流程。
- en: To use an interrupt architecture, the IRQ pin must be connected to a dedicated
    output from the I/O module. The programmer creates a handler subroutine intended
    to be executed once the I/O work is done, and tells the CPU its address. The programmer
    then writes a main program that instructs the I/O module to do actions. When an
    action command is sent to the I/O module, the CPU forgets all about it and continues
    executing the main program. The I/O module makes its device do its thing, which
    can take some time. When the device is done, the I/O module interrupts the CPU
    by setting the IRQ line to *high*. This calls the handler subroutine, which makes
    use of the new data from the device or tells it what to do next. Like any subroutine,
    calling the handler includes storing and returning to the value of the program
    counter for the instruction being interrupted, so the main program resumes after
    the interruption has been handled.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用中断架构，IRQ引脚必须连接到I/O模块的专用输出。程序员创建一个处理程序子程序，用于在I/O工作完成后执行，并将其地址告诉CPU。然后，程序员编写主程序，指示I/O模块执行某些操作。当命令被发送到I/O模块时，CPU会忘记所有相关内容并继续执行主程序。I/O模块让设备执行任务，这可能需要一些时间。当设备完成时，I/O模块通过将IRQ线设置为*高*来中断CPU。这会调用处理程序子程序，处理程序子程序会利用来自设备的新数据，或告诉设备接下来做什么。像所有子程序一样，调用处理程序包括保存并返回中断指令的程序计数器的值，以便主程序在中断处理后能够恢复执行。
- en: An advantage of interrupts is that they’re fast and efficient, with no need
    for the CPU to wait or to have to manage polling requests. A disadvantage of interrupts
    is that they can be tricky to write, especially when multiple I/O modules are
    in play, all sending interrupt signals at the same time. A *re-entrant architecture*
    allows interrupt-handling subroutines to be themselves interrupted by higher-priority
    IRQs, while a *non-re-entrant architecture* might ignore or delay these meta-interrupts.
    The code for a re-entrant architecture needs to think very carefully about how
    to handle meta-interrupts correctly, as a form of concurrent programming.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 中断的优点在于它们快速且高效，无需CPU等待或管理轮询请求。中断的缺点在于它们可能很难编写，尤其是当多个I/O模块同时工作、并且都在发送中断信号时。*可重入架构*允许中断处理子程序被更高优先级的IRQ中断，而*不可重入架构*可能会忽略或延迟这些元中断。可重入架构的代码需要非常仔细地考虑如何正确处理元中断，这是一种并发编程的形式。
- en: CPUs have a finite number of physical IRQ pins—sometimes fewer pins than there
    are devices that want to use them. Pins are a valuable, limited “real-estate”
    resource for modern CPUs, as adding more pins would force an increase in the physical
    package size of the chip.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: CPU的物理IRQ引脚数量是有限的——有时引脚的数量比需要使用它们的设备还要少。引脚是现代CPU的一项宝贵且有限的“资源”，因为增加更多引脚会迫使芯片的物理封装尺寸增大。
- en: '**IRQ HELL**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**IRQ地狱**'
- en: Interrupts were a major bane in the lives of computer music creators in the
    1990s, as they needed to use a lot of external devices, such as multiple sound
    cards, MIDI cards, and input controller devices, all at the same time. You would
    get several physical IRQ lines on your Intel CPU chip, each intended to represent
    one physical device connected to the computer. If you had more devices than available
    IRQ pins, you needed a hack to get around this limitation. Hacks included trying
    to convince hardware and drivers made by different manufacturers to share a single
    IRQ line, or disabling IRQs used by system hardware to free them up for use by
    audio devices. Sometimes the latter had system-destroying side effects.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 中断在1990年代对计算机音乐创作者来说是一个主要的痛点，因为他们需要同时使用大量外部设备，例如多个声卡、MIDI卡和输入控制器设备。你的Intel CPU芯片上会有几个物理IRQ线，每条IRQ线代表一个连接到计算机的物理设备。如果设备数量超过了可用的IRQ引脚，就需要通过黑客手段绕过这一限制。黑客方法包括试图说服不同厂商生产的硬件和驱动程序共享同一条IRQ线，或禁用系统硬件使用的IRQ，将它们释放给音频设备使用。有时，后者可能会产生摧毁系统的副作用。
- en: '*Direct Memory Access*'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*直接内存访问*'
- en: Both polling and interrupts are very slow for tasks that involve transferring
    large amounts of data from a device (such as a hard drive) into RAM. For example,
    if we request a 1Mb transfer, the I/O module will go off and do this, leaving
    the CPU free and happy, but when the interrupt is made this will create a big,
    slow job for the CPU to load every bit of that data into registers and then send
    it out to RAM. *Direct memory access (DMA)* is a technique to avoid this problem.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于涉及将大量数据从设备（例如硬盘）传输到RAM的任务，轮询和中断都非常慢。例如，如果我们请求1Mb的传输，I/O模块将去执行这个任务，使CPU保持空闲和愉快，但当中断发生时，这将为CPU创建一个大而慢的任务，需要将每一位数据加载到寄存器中，然后发送到RAM。*直接内存访问（DMA）*是一种避免此问题的技术。
- en: 'DMA requires a dedicated hardware DMA controller (an I/O module itself) to
    be placed on the system bus. So far, all our uses of the system bus have involved
    the CPU talking to another node on the bus, which may be RAM or an I/O module,
    but buses also allow non-CPU nodes to communicate directly with one another, independently
    of the CPU. Any node can put a message to any other node on the bus, and this
    is done in DMA: the CPU grants authority for the I/O module to communicate directly
    with RAM over the bus, reading from or writing to memory without any CPU involvement.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: DMA需要一个专用的硬件DMA控制器（一个I/O模块本身）被放置在系统总线上。到目前为止，我们使用系统总线的所有方式都涉及CPU与总线上另一个节点的通信，该节点可能是RAM或I/O模块，但总线也允许非CPU节点之间直接通信，而不需要CPU的介入。任何节点都可以将消息发送到总线上的任何其他节点，这在DMA中是这样做的：CPU授权I/O模块通过总线直接与RAM通信，读取或写入内存而无需任何CPU干预。
- en: This frees the CPU to do other things; as with an IRQ, the CPU can “set and
    forget.” DMA usually sends an interrupt when a task is complete, so the CPU is
    involved only at the beginning and end of the transfer. This is especially useful
    for large data movements because the data doesn’t have to go through the CPU.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得CPU可以做其他事情；就像IRQ一样，CPU可以“设置并忘记”。DMA通常在任务完成时发送中断，因此CPU只在传输的开始和结束时参与。这对于大数据量的移动尤其有用，因为数据不必经过CPU。
- en: I/O Without Modules
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无模块的I/O
- en: I/O modules are the preferred architecture for I/O in most cases, but other
    module-less I/O architectures also exist and have their places in the world. We’ll
    consider some of them now.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: I/O模块是大多数情况下首选的I/O架构，但也存在其他没有模块的I/O架构，并且它们在某些场合中也有其存在的价值。我们现在将考虑其中的一些。
- en: '*CPU I/O Pins*'
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*CPU I/O引脚*'
- en: Some older CPUs, as well as some modern embedded CPUs, forgo I/O modules and
    bus-based I/O and have the CPU communicate directly with a few specific devices
    via dedicated pins. This approach isn’t scalable, as pins are a limited and valuable
    CPU resource (they determine the package’s physical size). But it can reduce the
    complexity of the architecture in cases where we know firmly in advance that only
    a couple of specific devices will ever be attached. If the whole I/O system is
    designed this way, it can remove the need for IRQ pins and control logic. It also
    frees up the bus for other activities.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一些较旧的CPU，以及一些现代嵌入式CPU，放弃了I/O模块和基于总线的I/O，直接通过专用引脚与少数特定设备进行通信。这种方法不可扩展，因为引脚是有限且宝贵的CPU资源（它们决定了封装的物理大小）。但是，在我们明确知道将来只会连接少数特定设备的情况下，这种方法可以减少架构的复杂性。如果整个I/O系统以这种方式设计，它可以去除IRQ引脚和控制逻辑的需求。它还腾出了总线用于其他活动。
- en: '*Memory Mapping*'
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*内存映射*'
- en: Rather than having an addressable I/O module, some architectures use areas of
    regular RAM as the interface between CPU and device. In these architectures, the
    RAM is readable and writable by both the CPU and the device (so it needs some
    extra non-bus wires connecting the pins to devices and to the bus). With this
    setup, the CPU writes directly to actual RAM as usual, then the device (or a module-like
    chip interfacing between the device and the RAM, but not on the bus itself) reads
    out of the RAM and translates into device commands like an I/O module. To the
    programmer it might be invisible whether the video RAM addresses they’re writing
    to are in fact regular RAM used in this way, or whether they’re part of a hardware
    I/O module.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 与其拥有一个可寻址的I/O模块，一些架构使用常规RAM的区域作为CPU与设备之间的接口。在这些架构中，RAM可以被CPU和设备同时读取和写入（因此它需要一些额外的非总线连接线将引脚连接到设备和总线）。通过这种设置，CPU像往常一样直接写入实际的RAM，然后设备（或者一个在设备和RAM之间进行接口的模块化芯片，但不在总线本身上）从RAM中读取并将其转换为类似I/O模块的设备命令。对于程序员来说，是否写入的实际上是以这种方式使用的常规RAM，还是I/O模块的一部分，这可能是不可见的。
- en: '*Bus Hierarchies*'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*总线层次结构*'
- en: In modern architectures we often have more than one bus, forming a hierarchy
    of buses, as shown in [Figure 9-6](ch09.xhtml#ch09fig6).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代架构中，我们通常有多个总线，形成总线层次结构，如[图9-6](ch09.xhtml#ch09fig6)所示。
- en: '![Image](../images/f0212-01.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0212-01.jpg)'
- en: '*Figure 9-6: A bus hierarchy*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-6：总线层次结构*'
- en: The upper level here shows the same bus as in [Figure 9-3](ch09.xhtml#ch09fig3).
    However, the I/O module IO2 is an interface to a lower-level bus, which hosts
    three further lower-level components. This structure can improve usability and
    speed. Traditionally, each I/O module was connected to a single device and had
    to be mounted at particular addresses in address space when the computer was turned
    on. It was hard to add or remove (“plug and play”) devices while the computer
    was on. By introducing a single I/O module, such as a USB hub at a fixed address,
    we can allow for multiple plug-and-play devices to all connect to this same I/O
    module via a lower-level protocol, USB. This arrangement also solves the IRQ hell
    problem, as the I/O module can use a single, valuable IRQ line to alert the CPU
    to interrupts from any of these devices. The lower-level bus can be built from
    slower and cheaper technology than the system bus, as it only needs to run at
    the speed the data is actually available (which may be limited, for example, by
    waiting for real-world audio or spinning hard disks).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 上层显示的是与[图9-3](ch09.xhtml#ch09fig3)中相同的总线。然而，I/O模块IO2是连接到一个较低级别总线的接口，后者承载着三个更低级别的组件。这种结构可以提高可用性和速度。传统上，每个I/O模块只连接一个设备，并且在计算机开机时必须安装在地址空间中的特定地址。开机后很难添加或移除（“即插即用”）设备。通过引入一个单一的I/O模块，如固定地址的USB集线器，我们可以允许多个即插即用设备通过较低级别的协议（如USB）连接到同一个I/O模块。这个安排还解决了IRQ困境问题，因为I/O模块可以使用一个重要的IRQ线路来提醒CPU这些设备的中断。较低级别的总线可以使用比系统总线更慢且更便宜的技术，因为它只需要在数据实际可用的速度下运行（例如，可能会受到等待真实世界音频或旋转硬盘的限制）。
- en: Summary
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: For a computer to interact with the outside world, such as through graphics
    and sound, it needs input and output. This can be achieved through I/O modules,
    which are digital logic components that to the CPU look and act like RAM. Stores
    sent to their addresses are interpreted as commands to control devices in the
    outside world, while reads from them are used to send data that has been obtained
    from sensors in the outside world.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使计算机与外部世界互动，如通过图形和声音，它需要输入和输出。这可以通过I/O模块来实现，I/O模块是数字逻辑组件，在CPU看来就像RAM。发送到它们地址的存储被解释为控制外部设备的命令，而从它们读取的数据则用于发送从外部世界传感器获取的数据。
- en: CPU, memory, and I/O all share the same address space and communicate using
    a shared, public bus of wires, which include address, data, and control lines.
    CPUs interface to the bus via the staging registers MAR and MBR.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: CPU、内存和I/O共享相同的地址空间，并通过一个公共的总线进行通信，该总线包括地址、数据和控制线路。CPU通过暂存寄存器MAR和MBR与总线进行接口。
- en: CPU may also interface directly to a limited number of I/O modules via interrupt
    lines, which the I/O module uses to request the CPU to jump to a handler subroutine.
    I/O modules have also become increasingly independent of the CPU and can use methods
    such as DMA to communicate with one another and with RAM over the bus without
    involving the CPU.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: CPU还可以通过中断线路直接与有限数量的I/O模块进行接口，I/O模块使用这些中断线路请求CPU跳转到一个处理子程序。I/O模块也变得越来越独立于CPU，并且可以使用诸如DMA等方法，通过总线与彼此和RAM进行通信，而无需涉及CPU。
- en: An important use of the bus and of I/O is for managing real-world memory, including
    multiple physical RAM and ROM modules, and hard disk and optical disc devices.
    We’ll study these in the next chapter.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 总线和I/O的一个重要用途是管理现实世界中的内存，包括多个物理RAM和ROM模块，以及硬盘和光盘设备。我们将在下一章学习这些内容。
- en: Exercises
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 习题
- en: '**Challenging**'
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**挑战**'
- en: Take your LogiSim Baby from [Figure 7-13](ch07.xhtml#ch07fig13) and extend it
    so that storing to one of its addresses acts to turn a simulated LED on and off.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[图7-13](ch07.xhtml#ch07fig13)中的LogiSim Baby开始进行扩展，使得存储到其地址之一时，能够控制模拟LED的开关。
- en: Extend it again so that loading from another address acts to read the state
    of a simulated switch. You can do this by reducing the size of the RAM by two
    addresses, then adding a new digital logic I/O module to the bus that listens
    for those addresses and acts accordingly.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次扩展，使得从另一个地址加载时能够读取模拟开关的状态。你可以通过将RAM的大小减少两个地址，然后向总线添加一个新的数字逻辑I/O模块，该模块监听这些地址并作出相应的反应。
- en: Extend it yet again so that the I/O module decodes multiple commands sent as
    data inside the store instruction and uses them to command the LED to do different
    things, such as flash at different speeds. Here the LED and switch represent general
    devices that could be controlled in this way.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次扩展，使得 I/O 模块能够解码存储指令中作为数据发送的多个命令，并利用这些命令让 LED 执行不同的操作，例如以不同的速度闪烁。在这里，LED 和开关代表可以通过这种方式控制的通用设备。
- en: Further Reading
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'See *The Victorian Internet* by Tom Standage (London: Weidenfeld & Nicolson,
    1998) for a comparison of the 19th-century telegraph and the modern internet.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 Tom Standage 的《*维多利亚时代的互联网*》（伦敦：Weidenfeld & Nicolson，1998），其中对比了 19 世纪的电报与现代互联网。
