<html><head></head><body>
<div id="sbo-rt-content" class="calibre1">
 <div class="chapter" id="ch03">
  <div id="header0301" class="chapter">
   <h1 class="cn">
    <span class="page" id="p57">
    </span>
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rch03">
     3
    </a>
   </h1>
   <h1 class="ctfm">
    Getting and Displaying Input
   </h1>
  </div>
  <div class="figure" id="ct03">
   <p class="fig">
    <img alt="" src="images/nsp-boxall502581-ct.jpg" class="calibre9"/>
   </p>
  </div>
  <p class="pf">
   <span>
   </span>
   AVR microcontrollers can process input from the outside world and react with output, which offers huge potential for interactive projects—for example, those that react to the surrounding temperature. In this chapter, you’ll program ATtiny85s and ATmega328P-PUs to detect input signals from external devices and put them to work.
  </p>
  <p class="calibre8">
   In particular, you will:
  </p>
  <ul class="calibre10">
   <li class="blf">
    • Learn about digital inputs and buttons.
   </li>
   <li class="bl">
    • Make decisions with
    <code class="calibre23">
     if...else
    </code>
    and
    <code class="calibre23">
     switch...case
    </code>
    statements.
   </li>
   <li class="bl">
    • Use seven-segment LED displays to make a digital counter.
   </li>
   <li class="bl">
    • Make a single-cell battery tester.
   </li>
   <li class="bl">
    • Learn about the TMP36 temperature sensor.
   </li>
   <li class="bll">
    • Make a digital thermometer.
   </li>
  </ul>
  <p class="calibre8">
   <span id="p58">
   </span>
   Along the way, you’ll learn how to counter switch bounce with resistors, as well as gaining more experience with programming in C by creating your own functions and using floating-point variable and analog inputs.
  </p>
  <div class="chapter">
   <h2 class="ah" id="ah0501">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah0501">
     Digital Inputs
    </a>
   </h2>
   <p class="paft">
    In
    <a class="url" href="nsp-boxall502581-0012.xhtml#ch02">
     Chapter 2
    </a>
    , you learned to use digital I/O pins as outputs. You can use the same pins to accept input from users and other components. Just like digital outputs, digital inputs have two states: instead of
    <i class="calibre5">
     on
    </i>
    or
    <i class="calibre5">
     off
    </i>
    , they’re
    <i class="calibre5">
     high
    </i>
    and
    <i class="calibre5">
     low
    </i>
    . Using digital I/O pins for input is similar to controlling the outputs, too. In this section, you’ll set up the DDR
    <i class="calibre5">
     x
    </i>
    , then monitor the value of another register called the
    <i class="calibre5">
     PINx
    </i>
    that stores the status of the digital input pins. Let’s get started!
   </p>
   <div class="chapter">
    <h3 class="bh" id="bh0501">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0501">
      Introducing the Pushbutton
     </a>
    </h3>
    <p class="paft">
     One of the simplest forms of digital input is the
     <i class="calibre5">
      pushbutton
     </i>
     , shown in
     <a class="url" href="nsp-boxall502581-0013.xhtml#f03001">
      Figure 3-1
     </a>
     . Pushbuttons are easy to insert into a solderless breadboard. When pressed, they allow an electrical current to pass, which your microcontroller can detect through a digital input.
    </p>
    <div class="figure" id="f03001">
     <p class="fig">
      <img alt="Four tactile buttons sitting on a solderless breadboard" height="825" src="images/nsp-boxall502581-f03001.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 3-1:
       </span>
       Simple pushbuttons on a breadboard
      </p>
     </div>
    </div>
    <p class="calibre8">
     You’ll use pushbuttons in the
     <a class="url" href="nsp-boxall502581-0013.xhtml#pro8">
      next project
     </a>
     , so note how the pushbutton at the bottom of
     <a class="url" href="nsp-boxall502581-0013.xhtml#f03001">
      Figure 3-1
     </a>
     is inserted into the breadboard. The legs bridge rows 23 and 25 so that when you press the button, an electrical connection is made between those two rows.
     <a class="url" href="nsp-boxall502581-0013.xhtml#f03002">
      Figure 3-2
     </a>
     shows the schematic symbol for this type of pushbutton.
    </p>
    <div class="figure" id="f03002">
     <p class="fig">
      <img alt="Schematic symbol for a four-legged tactile button" src="images/nsp-boxall502581-f03002.jpg" class="calibre27"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 3-2:
       </span>
       Pushbutton schematic symbol
      </p>
     </div>
    </div>
    <p class="calibre8">
     <span id="p59">
     </span>
     The lines labeled 1 and 2 represent the pushbutton’s legs on one side, with 3 and 4 representing the legs on the other side. When you compare the schematic symbol against the real pushbutton in
     <a class="url" href="nsp-boxall502581-0013.xhtml#f03001">
      Figure 3-1
     </a>
     , the legs labeled 1 and 2 are in row 23, and the legs labeled 3 and 4 are in row 25. The broken line represents an open switch inside the pushbutton. Pins 1 and 2 are electrically connected, as are 3 and 4, so you don’t need to run a wire to both pins on each side of the button. When you press the button, the switch closes, allowing current to flow.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh0502">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0502">
      Reading the Status of Digital Input Pins
     </a>
    </h3>
    <p class="paft">
     Once you set an I/O pin to an input by assigning a value to
     <code class="calibre23">
      DDRB
     </code>
     , the status of each input pin is stored in the PIN
     <i class="calibre5">
      x
     </i>
     register. Just like the other registers, the PIN
     <i class="calibre5">
      x
     </i>
     register is 8 bits wide, and each bit corresponds to a physical I/O pin.
    </p>
    <p class="calibre8">
     Think of the PIN
     <i class="calibre5">
      x
     </i>
     register as a binary number, where each bit represents the state of the matching physical pin. If a bit is 1, there is current at the pin and the pin is
     <i class="calibre5">
      high
     </i>
     ; if the bit is 0, there’s no current and the pin is
     <i class="calibre5">
      low
     </i>
     . For example, on an ATtiny85 with all I/O pins set to inputs, if pins 5 (PB0) and 6 (PB1) were high, then the PINB register would have a value of
     <code class="calibre23">
      0b00000011
     </code>
     .
    </p>
    <p class="calibre8">
     The numerical value of the PIN
     <i class="calibre5">
      x
     </i>
     register is assigned to an integer variable, which is then compared against another number. For example, to check whether input pins PB0 and PB1 are high, you would compare the value of PINB to
     <code class="calibre23">
      0b00000011
     </code>
     .
    </p>
    <p class="calibre8">
     But enough theory—let’s build some simple circuits that demonstrate inputs and outputs with microcontrollers!
    </p>
    <p class="hd" id="pro8">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro8">
      <span class="ccust1">
       Project 8: Blinking an LED on Command
      </span>
     </a>
    </p>
    <p class="paft">
     In this project, you’ll experiment with ATtiny85 digital inputs by blinking an LED, as you did in
     <a class="url" href="nsp-boxall502581-0012.xhtml#ch02">
      Chapter 2
     </a>
     . This time, however, that LED will blink only when you press a pushbutton.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh0503">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0503">
      The Hardware
     </a>
    </h3>
    <p class="paft">
     You will need the following hardware:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • USBasp programmer
     </li>
     <li class="bl">
      • Solderless breadboard
     </li>
     <li class="bl">
      • ATtiny85–20PU microcontroller
     </li>
     <li class="bl">
      • One LED
     </li>
     <li class="bl">
      • One 560
      <span lang="el" xml:lang="el">
       Ω
      </span>
      resistor
     </li>
     <li class="bl">
      • One pushbutton
     </li>
     <li class="bl">
      • One 10
      <span lang="en" xml:lang="en">
       kΩ
      </span>
      resistor
     </li>
     <li class="bll">
      • Jumper wires
     </li>
    </ul>
    <p class="calibre8">
     Assemble the circuit shown in
     <a class="url" href="nsp-boxall502581-0013.xhtml#f03003">
      Figure 3-3
     </a>
     on your breadboard. When you’re done experimenting with this project, keep the circuit together; you’ll use it for
     <a class="url" href="nsp-boxall502581-0013.xhtml#pro9">
      Projects 9
     </a>
     ,
     <a class="url" href="nsp-boxall502581-0013.xhtml#pro10">
      10
     </a>
     , and
     <a class="url" href="nsp-boxall502581-0013.xhtml#pro11">
      11
     </a>
     as well.
    </p>
    <div class="figure" id="f03003">
     <p class="fig">
      <span id="p60">
      </span>
      <img alt="Schematic diagram for Project 8" height="620" src="images/nsp-boxall502581-f03003.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 3-3:
       </span>
       The main circuit for
       <a class="url" href="nsp-boxall502581-0013.xhtml#pro8">
        Project 8
       </a>
      </p>
     </div>
    </div>
    <p class="calibre8">
     With your circuit assembled, connect the USBasp programmer to the ATtiny85. Repeat the connections as shown in
     <a class="url" href="nsp-boxall502581-0012.xhtml#tab0201">
      Table 2-1
     </a>
     in
     <a class="url" href="nsp-boxall502581-0012.xhtml#ch02">
      Chapter 2
     </a>
     .
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh0504">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0504">
      The Code
     </a>
    </h3>
    <p class="paft">
     Open a terminal window, navigate to the
     <i class="calibre5">
      Project 8
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 3
     </i>
     folder, and enter the command
     <code class="b">
      make flash
     </code>
     . The toolchain will compile the program file and then upload the data to the microcontroller. At this point, the circuit won’t do anything until you press the button. When you do so, the LED should stay on for about one second.
    </p>
    <p class="calibre8">
     Let’s see how this works. Open the
     <i class="calibre5">
      main.c
     </i>
     file for
     <a class="url" href="nsp-boxall502581-0013.xhtml#pro8">
      Project 8
     </a>
     :
    </p>
    <div class="codeline">
     <p class="clf">
      // Project 8 - Blinking an LED on Command
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="clf">
      int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>1</ccust1>-->
      ❶ DDRB =  0b00001111;
     </p>
     <p class="cl">
      <!--<ccust1>2</ccust1>-->
      ❷ PORTB = 0b00000000;
     </p>
     <p class="cl">
      for (;;)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>3</ccust1>-->
      ❸ if (PINB == 0b00010000) // If PB4 is HIGH . . .
     </p>
     <p class="cl">
      <!--<ccust1>4</ccust1>-->
      ❹ {
     </p>
     <p class="cl">
      PORTB = 0b00000001;  // then turn on PB0 output
     </p>
     <p class="cl">
      _delay_ms(1000);     // Wait a moment
     </p>
     <p class="cl">
      PORTB = 0b00000000;  // Turn off PB0 output
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      return 0;
     </p>
     <p class="cll">
      }
     </p>
    </div>
    <p class="calibre8">
     <span id="p61">
     </span>
     This code tells the microcontroller to continually check whether pin 3 (PB4) is high. If it is, we turn on an LED connected to pin 5 (PB0) for about one second.
    </p>
    <p class="calibre8">
     First we set the DDRB register so that pins PB0 to PB3 are outputs and pins PB4 to PB7 are inputs
     <!--<ccust1>1</ccust1>-->
     ❶. Although the ATtiny85 only has eight pins in total, and up to six for inputs and outputs, we still include all eight bits in the
     <code class="calibre23">
      DDRB
     </code>
     statement. Next, we turn off the internal pullup resistors
     <!--<ccust1>2</ccust1>-->
     ❷. (I’ll return to pullup resistors later in this chapter.)
    </p>
    <p class="calibre8">
     After that, the program compares the value of the PINB register to the value
     <code class="calibre23">
      0b00010000
     </code>
     <!--<ccust1>3</ccust1>-->
     ❸. If an electrical current is present at PB4 (pin 3), the fourth bit will be 1 and thus the PINB register will match
     <code class="calibre23">
      0b00010000
     </code>
     . If the comparison results in two equal numbers, the code between the curly brackets will run
     <!--<ccust1>4</ccust1>-->
     ❹, turning the LED on for a second and then off again.
    </p>
    <p class="calibre8">
     In the next section we’ll take a closer look at
     <code class="calibre23">
      if
     </code>
     statements like the one in this project, which are used to make comparisons and decisions.
    </p>
   </div>
  </div>
  <div class="chapter">
   <h2 class="ah" id="ah0502">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah0502">
     Making Decisions in Code
    </a>
   </h2>
   <p class="paft">
    Sometimes you’ll want certain code to run only if a condition is true or false, such as whether or not a button is pressed. You can use
    <code class="calibre23">
     if
    </code>
    statements,
    <code class="calibre23">
     if...else
    </code>
    statements, and
    <code class="calibre23">
     switch...case
    </code>
    statements to test those conditions and decide what code to execute next.
   </p>
   <div class="chapter">
    <h3 class="bh" id="bh0505">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0505">
      if Statements
     </a>
    </h3>
    <p class="paft">
     The first line of an
     <code class="calibre23">
      if
     </code>
     statement like the one in
     <a class="url" href="nsp-boxall502581-0013.xhtml#pro8">
      Project 8
     </a>
     tests for a condition. If the condition is true (in
     <a class="url" href="nsp-boxall502581-0013.xhtml#pro8">
      Project 8
     </a>
     , if the value of
     <code class="calibre23">
      PINB
     </code>
     matches the number
     <code class="calibre23">
      0b00010000
     </code>
     ), then the code in the curly brackets executes. If the condition is false, then the code in the curly brackets is ignored.
    </p>
    <p class="calibre8">
     To test conditions, you’ll use one or more of the following
     <i class="calibre5">
      comparison operators
     </i>
     inside the
     <code class="calibre23">
      if
     </code>
     statement:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • Equal to:
      <code class="calibre23">
       ==
      </code>
     </li>
     <li class="bl">
      • Not equal to:
      <code class="calibre23">
       !=
      </code>
     </li>
     <li class="bl">
      • Greater than:
      <code class="calibre23">
       &gt;
      </code>
     </li>
     <li class="bl">
      • Less than:
      <code class="calibre23">
       &lt;
      </code>
     </li>
     <li class="bl">
      • Greater than or equal to:
      <code class="calibre23">
       &gt;=
      </code>
     </li>
     <li class="bll">
      • Less than or equal to:
      <code class="calibre23">
       &lt;=
      </code>
     </li>
    </ul>
    <p class="calibre8">
     Over time, you’ll use the comparison operators more often and they’ll become second nature.
    </p>
    <p class="pcust">
     <span class="ccust">
      Warning
     </span>
     One common mistake is to use a single equal sign (
     <code class="calibre23">
      =
     </code>
     ), which means “make equal to,” in a test statement instead of a double equal sign (
     <code class="calibre23">
      ==
     </code>
     ), which says, “test if it is equal to.” You may not get an error message from the toolchain, but your code probably won’t work properly!
    </p>
    <p class="calibre8">
     <span id="p62">
     </span>
     You can also make various types of comparisons where there are two or more options to choose from, which can save code space. These are explained in the following sections.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh0506">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0506">
      if . . . else Statements
     </a>
    </h3>
    <p class="paft">
     You can add another action to an
     <code class="calibre23">
      if
     </code>
     statement using
     <code class="calibre23">
      else
     </code>
     . For example, you can rewrite the code in
     <a class="url" href="nsp-boxall502581-0013.xhtml#pro8">
      Project 8
     </a>
     as follows:
    </p>
    <div class="codeline">
     <p class="clf">
      if (PINB == 0b00010000) // If PB4 is high . . .
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      PORTB = 0b00000001;  // turn on PB0 output
     </p>
     <p class="cl">
      } else
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      PORTB = 0b00000000;  // turn off PB0 output
     </p>
     <p class="cll">
      }
     </p>
    </div>
    <p class="calibre8">
     With this modification, the LED turns on if you press the button and off if you don’t press the button.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh0507">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0507">
      Making Two or More Comparisons
     </a>
    </h3>
    <p class="paft">
     You can also use two or more comparisons in the same
     <code class="calibre23">
      if
     </code>
     using
     <i class="calibre5">
      comparison operators
     </i>
     . For example, to compare the value of the integer variable
     <code class="calibre23">
      counter
     </code>
     against a range between 23 and 42, use two comparisons joined with the AND operator,
     <code class="calibre23">
      &amp;&amp;
     </code>
     :
    </p>
    <div class="codeline">
     <p class="clf">
      if (counter&gt;=23 &amp;&amp; counter &lt;42) // If counter is between 23 and 42 . . .
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      PORTB = 0b00000001;          // turn on PB0 output
     </p>
     <p class="cl">
      } else
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      PORTB = 0b00000000;          // turn off PB0 output
     </p>
     <p class="cll">
      }
     </p>
    </div>
    <p class="calibre8">
     Note that the AND operator used for comparisons (
     <code class="calibre23">
      &amp;&amp;
     </code>
     ) is different from the bitwise arithmetic AND operator (
     <code class="calibre23">
      &amp;
     </code>
     ) introduced in
     <a class="url" href="nsp-boxall502581-0012.xhtml#ch02">
      Chapter 2
     </a>
     .
    </p>
    <p class="calibre8">
     You can also use an OR comparison. For example, if you need to test for cases in which the value of the
     <code class="calibre23">
      counter
     </code>
     variable is less than 100 or greater than 115, use two comparisons joined with the operator
     <code class="calibre23">
      ||
     </code>
     :
    </p>
    <div class="codeline">
     <p class="clf">
      if (counter&lt;100 || counter &gt;115) // If counter is under 100 or over 115 . . .
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      PORTB = 0b00000001;           // turn on PB0 output
     </p>
     <p class="cl">
      } else
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      PORTB = 0b00000000;           // turn off PB0 output
     </p>
     <p class="cll">
      }
     </p>
    </div>
    <p class="calibre8">
     You’ll expand your knowledge of these useful operators in later projects.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh0508">
     <span class="page" id="p63">
     </span>
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0508">
      switch . . . case Statements
     </a>
    </h3>
    <p class="paft">
     To compare two or more variables, it’s easier to use a
     <code class="calibre23">
      switch...case
     </code>
     statement instead of several
     <code class="calibre23">
      if...else
     </code>
     statements. The
     <code class="calibre23">
      switch...case
     </code>
     statement runs code when one of the defined comparisons is true.
    </p>
    <p class="calibre8">
     For example, say you want to run different code for each possible value of the integer variable
     <code class="calibre23">
      counter
     </code>
     , 1, 2, or 3. You could use one
     <code class="calibre23">
      switch...case
     </code>
     statement instead of multiple
     <code class="calibre23">
      if...else
     </code>
     statements:
    </p>
    <div class="codeline">
     <p class="clf">
      switch(counter)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      case 1:   // Do something if the value of counter is 1
     </p>
     <p class="cl">
      break; // Finish and exit the switch statement
     </p>
     <p class="cl">
      case 2:   // Do something if the value of counter is 2
     </p>
     <p class="cl">
      break; // Finish and exit the switch statement
     </p>
     <p class="cl">
      case 3:   // Do something if the value of counter is 3
     </p>
     <p class="cl">
      break; // Finish and exit the switch statement
     </p>
     <p class="cl">
      default:  // Do something if counter isn't 1, 2, or 3
     </p>
     <p class="cl">
      // (the "default" section is optional)
     </p>
     <p class="cll">
      }
     </p>
    </div>
    <p class="calibre8">
     The optional
     <code class="calibre23">
      default
     </code>
     section at the end of this code lets you run code when there aren’t any true comparisons in the
     <code class="calibre23">
      switch...case
     </code>
     statement.
    </p>
   </div>
  </div>
  <div class="chapter">
   <h2 class="ah" id="ah0503">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah0503">
     Creating Your Own Functions
    </a>
   </h2>
   <p class="paft">
    Sooner or later, you’ll want to repeat sections of code more than once or define your own set of instructions. You can achieve both goals by creating your own functions that either take care of a task, accept variables and act upon them, or return a value as their result, like a mathematical function. We’ll discuss these three types of functions in the next three projects.
   </p>
   <p class="calibre8">
    The first type of function simply repeats some code:
   </p>
   <div class="codeline">
    <p class="clf">
     void
     <code class="i1">
      name()
     </code>
    </p>
    <p class="cl">
     {
    </p>
    <p class="cl">
     // Insert your code to run here.
    </p>
    <p class="cll">
     }
    </p>
   </div>
   <p class="calibre8">
    In this example,
    <code class="i1">
     name()
    </code>
    is a placeholder. You can name your function almost anything you’d like, but the name must always be preceded with
    <code class="calibre23">
     void
    </code>
    . Additionally, you can’t use
    <i class="calibre5">
     reserved keywords
    </i>
    in your own creations, since the language already uses them. For example, you can’t call a function
    <code class="calibre23">
     void void()
    </code>
    because
    <code class="calibre23">
     void
    </code>
    is a reserved keyword in C, C++, and other languages. You can find a complete list of reserved keywords in C at
    <a class="url-i" href="https://en.cppreference.com/w/c/keyword">
     https://en.cppreference.com/w/c/keyword
    </a>
    .
   </p>
   <p class="calibre8">
    The function’s code goes inside the curly brackets. Always put your custom functions before the
    <code class="calibre23">
     int main(void)
    </code>
    section of your code.
   </p>
   <p class="hd" id="pro9">
    <span class="page" id="p64">
    </span>
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro9">
     <span class="ccust1">
      Project 9: A Simple Custom Function
     </span>
    </a>
   </p>
   <p class="paft">
    This project demonstrates the creation of a simple custom function that performs a task. Using the hardware from
    <a class="url" href="nsp-boxall502581-0013.xhtml#pro8">
     Project 8
    </a>
    , open a terminal window, navigate to the
    <i class="calibre5">
     Project 9
    </i>
    subfolder of this book’s
    <i class="calibre5">
     Chapter 3
    </i>
    folder, and enter the command
    <code class="b">
     make flash
    </code>
    to upload the code for
    <a class="url" href="nsp-boxall502581-0013.xhtml#pro9">
     Project 9
    </a>
    as usual. You should see the LED blink twice every five seconds.
   </p>
   <p class="calibre8">
    Let’s take a look at the code:
   </p>
   <div class="codeline">
    <p class="clf">
     // Project 9 - A Simple Custom Function
    </p>
    <p class="clf">
     #include &lt;avr/io.h&gt;
    </p>
    <p class="cl">
     #include &lt;util/delay.h&gt;
    </p>
    <p class="cl2f">
     <!--<ccust1>1</ccust1>-->
     ❶ void blinkTwice()
    </p>
    <p class="cl">
     {
    </p>
    <p class="cl">
     PORTB = 0b11111111;
    </p>
    <p class="cl">
     _delay_ms(100);
    </p>
    <p class="cl">
     PORTB = 0b00000000;
    </p>
    <p class="cl">
     _delay_ms(100);
    </p>
    <p class="cl">
     PORTB = 0b11111111;
    </p>
    <p class="cl">
     _delay_ms(100);
    </p>
    <p class="cl">
     PORTB = 0b00000000;
    </p>
    <p class="cl">
     _delay_ms(100);
    </p>
    <p class="cl">
     }
    </p>
    <p class="clf">
     int main(void)
    </p>
    <p class="cl">
     {
    </p>
    <p class="cl">
     // Set PB3 (and all other pins on PORTB) as output
    </p>
    <p class="cl">
     DDRB = 0b11111111;
    </p>
    <p class="cl">
     for(;;)
    </p>
    <p class="cl">
     {
    </p>
    <p class="cl">
     <!--<ccust1>2</ccust1>-->
     ❷ blinkTwice();
    </p>
    <p class="cl">
     _delay_ms(5000);
    </p>
    <p class="cl">
     }
    </p>
    <p class="cl">
     return 0;
    </p>
    <p class="cll">
     }
    </p>
   </div>
   <p class="calibre8">
    The custom function
    <code class="calibre23">
     blinkTwice()
    </code>
    <!--<ccust1>1</ccust1>-->
    ❶ makes the LED blink twice, as it sets the entire PORTB register on and off twice with a short delay. Once you’ve created a function like this, you can call it anywhere in the code
    <!--<ccust1>2</ccust1>-->
    ❷.
   </p>
   <p class="calibre8">
    What if you want to be able to easily change how many times the LED blinks? That’s where the second type of custom function—functions to which you can pass values—comes in handy:
   </p>
   <div class="codeline">
    <p class="clf">
     <code class="i1">
      void name
     </code>
     (
     <code class="i1">
      type variable
     </code>
     ,
     <code class="i1">
      type variable2
     </code>
     , . . .)
    </p>
    <p class="cl">
     {
    </p>
    <p class="cl">
     // Insert your code to run here.
    </p>
    <p class="cll">
     }
    </p>
   </div>
   <p class="calibre8">
    <span id="p65">
    </span>
    Again, you’ll give your function a name, but this time the parentheses will contain two parameters that will be used in the code inside the parentheses after the function name:
    <code class="i1">
     type
    </code>
    and
    <code class="i1">
     variable
    </code>
    , which specify the type and name of the variable being passed to the function, respectively.
   </p>
   <p class="hd" id="pro10">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro10">
     <span class="ccust1">
      Project 10: Custom Functions with Internal Variables
     </span>
    </a>
   </p>
   <p class="paft">
    This project demonstrates the creation of custom functions that accept variables as parameters, then act upon those variables. Using the same hardware from
    <a class="url" href="nsp-boxall502581-0013.xhtml#pro8">
     Project 8
    </a>
    , navigate to the
    <i class="calibre5">
     Project 10
    </i>
    subfolder of this book’s
    <i class="calibre5">
     Chapter 3
    </i>
    folder in your terminal window and enter the command
    <code class="b">
     make flash
    </code>
    to upload the code for
    <a class="url" href="nsp-boxall502581-0013.xhtml#pro10">
     Project 10
    </a>
    . You should see the LED blink on and off 11 times.
   </p>
   <p class="calibre8">
    Let’s take a look at the code in this project’s
    <i class="calibre5">
     main.c
    </i>
    file:
   </p>
   <div class="codeline">
    <p class="clf">
     // Project 10 - Custom Functions with Internal Variables
    </p>
    <p class="clf">
     #include &lt;avr/io.h&gt;
    </p>
    <p class="cl">
     #include &lt;util/delay.h&gt;
    </p>
    <p class="clf">
     void delay_ms(int ms)
    </p>
    <p class="cl">
     {
    </p>
    <p class="cl">
     uint8_t i;
    </p>
    <p class="cl">
     for (i = 0; i &lt; ms; i++)
    </p>
    <p class="cl">
     {
    </p>
    <p class="cl">
     _delay_ms(1);
    </p>
    <p class="cl">
     }
    </p>
    <p class="cl">
     }
    </p>
    <p class="cl2f">
     <!--<ccust1>1</ccust1>-->
     ❶ void blinkLED(uint8_t blinks)
    </p>
    <p class="cl">
     {
    </p>
    <p class="cl">
     uint8_t i;
    </p>
    <p class="cl">
     for (i = 0; i &lt; blinks; i++)
    </p>
    <p class="cl">
     {
    </p>
    <p class="cl">
     PORTB = 0b11111111;
    </p>
    <p class="cl">
     delay_ms(100);
    </p>
    <p class="cl">
     PORTB = 0b00000000;
    </p>
    <p class="cl">
     delay_ms(100);
    </p>
    <p class="cl">
     }
    </p>
    <p class="cl">
     }
    </p>
    <p class="clf">
     int main(void)
    </p>
    <p class="cl">
     {
    </p>
    <p class="cl">
     DDRB = 0b11111111; // Set PB3 as output
    </p>
    <p class="cl">
     for(;;)
    </p>
    <p class="cl">
     {
    </p>
    <p class="cl">
     <!--<ccust1>2</ccust1>-->
     ❷ blinkLED(10);
    </p>
    <p class="cl">
     _delay_ms(3000);
    </p>
    <p class="cl">
     }
    </p>
    <p class="cl">
     return 0;
    </p>
    <p class="cll">
     }
    </p>
   </div>
   <p class="calibre8">
    <span id="p66">
    </span>
    The function
    <code class="calibre23">
     blinkLED(uint8_t blinks)
    </code>
    <!--<ccust1>1</ccust1>-->
    ❶ accepts an unsigned integer and uses it in a
    <code class="calibre23">
     for
    </code>
    loop to blink the LED that number of times. Now you can call the
    <code class="calibre23">
     blinkLED()
    </code>
    function with different values anywhere in your code. For example, in this project’s code we call
    <code class="calibre23">
     blinkLED(10)
    </code>
    <!--<ccust1>2</ccust1>-->
    ❷ to make the LED blink 11 times.
   </p>
   <p class="calibre8">
    To pass more than one variable into a custom function, just add a comma between each variable within the parentheses after the function name. For example, here I’ve added a second parameter,
    <code class="calibre23">
     blinkDelay
    </code>
    , to the
    <code class="calibre23">
     blinkLED()
    </code>
    function, which allows you to set the value of the delay between the LED turning on and off. This parameter is then passed into the
    <code class="calibre23">
     delay_ms()
    </code>
    function:
   </p>
   <div class="codeline">
    <p class="clf">
     void blinkLED(uint8_t blinks, uint8_t blinkDelay)
    </p>
    <p class="cl">
     {
    </p>
    <p class="cl">
     uint8_t i;
    </p>
    <p class="cl">
     for (i = 0; i &lt; blinks; i++)
    </p>
    <p class="cl">
     {
    </p>
    <p class="cl">
     PORTB = 0b11111111;
    </p>
    <p class="cl">
     delay_ms(blinkDelay);
    </p>
    <p class="cl">
     PORTB = 0b00000000;
    </p>
    <p class="cl">
     delay_ms(blinkDelay);
    </p>
    <p class="cll">
     }
    </p>
   </div>
   <p class="calibre8">
    The code for
    <a class="url" href="nsp-boxall502581-0013.xhtml#pro10">
     Project 10
    </a>
    actually defines two custom functions: the first one is
    <code class="calibre23">
     delay_ms(int ms)
    </code>
    . Sometimes you might want a delay function in your code, and you’ll want to specify the length of that delay using a variable. That isn’t possible with the standard
    <code class="calibre23">
     _delay_ms()
    </code>
    function, so just create your own!
   </p>
   <p class="hd" id="pro11">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro11">
     <span class="ccust1">
      Project 11: Custom Functions That Return Values
     </span>
    </a>
   </p>
   <p class="paft">
    In this project I’ll demonstrate the third type of custom function you can create: one that accepts one or more variables, uses them in a mathematical operation, and then returns the result.
   </p>
   <p class="calibre8">
    Functions that return the result of an operation can be incredibly useful. Think of them as mathematical formula black boxes: values go in on one end, operations are performed on them, and the result pops out the other end. You can create such a function as follows:
   </p>
   <div class="codeline">
    <p class="clf">
     <code class="i1">
      type variable
     </code>
     (
     <code class="i1">
      type variable
     </code>
     ,
     <code class="i1">
      type variable 2
     </code>
     , . . .)
    </p>
    <p class="cl">
     {
    </p>
    <p class="cl">
     // Declare a variable to hold the results of the calculations.
    </p>
    <p class="cl">
     // Insert your code to run here.
    </p>
    <p class="cl">
     // Return the declared variable.
    </p>
    <p class="cll">
     }
    </p>
   </div>
   <p class="calibre8">
    Note that the variable you declare must be of the same type as the function.
   </p>
   <p class="calibre8">
    <span id="p67">
    </span>
    Let’s put this into action. Using the same hardware from
    <a class="url" href="nsp-boxall502581-0013.xhtml#pro8">
     Project 8
    </a>
    , navigate to the
    <i class="calibre5">
     Project 11
    </i>
    subfolder of this book’s
    <i class="calibre5">
     Chapter 3
    </i>
    folder in your terminal window and enter the command
    <code class="b">
     make flash
    </code>
    to upload the code for
    <a class="url" href="nsp-boxall502581-0013.xhtml#pro11">
     Project 11
    </a>
    . You should see the LED blink 12 times every 2 seconds.
   </p>
   <p class="calibre8">
    To see how this works, open the
    <i class="calibre5">
     main.c
    </i>
    file for this project:
   </p>
   <div class="codeline">
    <p class="clf">
     // Project 11 - Custom Functions That Return Values
    </p>
    <p class="clf">
     #include &lt;avr/io.h&gt;
    </p>
    <p class="cl">
     #include &lt;util/delay.h&gt;
    </p>
    <p class="clf">
     void blinkLED(uint8_t blinks)
    </p>
    <p class="cl">
     {
    </p>
    <p class="cl">
     uint8_t i;
    </p>
    <p class="cl">
     for (i = 0; i &lt; blinks; i++)
    </p>
    <p class="cl">
     {
    </p>
    <p class="cl">
     PORTB = 0b11111111;
    </p>
    <p class="cl">
     _delay_ms(100);
    </p>
    <p class="cl">
     PORTB = 0b00000000;
    </p>
    <p class="cl">
     _delay_ms(100);
    </p>
    <p class="cl">
     }
    </p>
    <p class="cl">
     }
    </p>
    <p class="cl2f">
     <!--<ccust1>1</ccust1>-->
     ❶ uint8_t timesThree(uint8_t subject)
    </p>
    <p class="cl">
     {
    </p>
    <p class="cl">
     uint8_t product;
    </p>
    <p class="cl">
     <!--<ccust1>2</ccust1>-->
     ❷ product = subject * 3;
    </p>
    <p class="cl">
     <!--<ccust1>3</ccust1>-->
     ❸ return product;
    </p>
    <p class="cl">
     }
    </p>
    <p class="clf">
     int main(void)
    </p>
    <p class="cl">
     {
    </p>
    <p class="cl">
     DDRB = 0b11111111; // Set PB3 as output
    </p>
    <p class="cl">
     uint8_t j;
    </p>
    <p class="cl">
     uint8_t k;
    </p>
    <p class="cl">
     for(;;)
    </p>
    <p class="cl">
     {
    </p>
    <p class="cl">
     j = 4;
    </p>
    <p class="cl">
     k = timesThree(j);
    </p>
    <p class="cl">
     blinkLED(k);
    </p>
    <p class="cl">
     _delay_ms(2000);
    </p>
    <p class="cl">
     }
    </p>
    <p class="cl">
     return 0;
    </p>
    <p class="cll">
     }
    </p>
   </div>
   <p class="calibre8">
    We’re still blinking the LED (this is the last time, I promise!), but now we call
    <code class="calibre23">
     blinkLED
    </code>
    with
    <code class="calibre23">
     k
    </code>
    , which is set to the result of the
    <code class="calibre23">
     timesThree()
    </code>
    function. The
    <code class="calibre23">
     timesThree()
    </code>
    function multiplies an integer by three. First we declare what type of variable the function will return—in this case, an integer (
    <code class="calibre23">
     uint8_t
    </code>
    )
    <!--<ccust1>1</ccust1>-->
    ❶. This is followed by the function name,
    <code class="calibre23">
     timesThree()
    </code>
    , and the variable that will contain the number we pass into the function.
    <span id="p68">
    </span>
    Inside the function, we declare another variable to hold the result of the multiplication operation
    <!--<ccust1>2</ccust1>-->
    ❷. Next, we call
    <code class="calibre23">
     return
    </code>
    to pass the result back to the code
    <!--<ccust1>3</ccust1>-->
    ❸.
   </p>
   <p class="calibre8">
    To actually use
    <code class="calibre23">
     timesThree()
    </code>
    in other parts of your program, just call it with an argument and set a variable equal to it:
   </p>
   <div class="codeline">
    <p class="cls">
     k = timesThree(j);
    </p>
   </div>
   <p class="calibre8">
    As you gain more experience with microcontrollers, you’ll find that creating your own functions can save you quite a bit of time. For now, though, let’s turn to discussing possible problems that can arise when using buttons, and how to solve them in order to create more reliable projects.
   </p>
  </div>
  <div class="chapter">
   <h2 class="ah" id="ah0504">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah0504">
     Switch Bounce
    </a>
   </h2>
   <p class="paft">
    Pushbuttons, which you first encountered in
    <a class="url" href="nsp-boxall502581-0013.xhtml#pro8">
     Project 8
    </a>
    , are prone to
    <i class="calibre5">
     switch bounce
    </i>
    (also known as
    <i class="calibre5">
     switch bouncing
    </i>
    ), a button’s tendency to turn on and off several times after being pressed only once by the user. Switch bounce occurs because the metal contacts inside a pushbutton are so small that they can vibrate after the button has been released, causing the switch to quickly and repeatedly open and close until the vibration ends.
   </p>
   <p class="calibre8">
    Switch bounce can be observed using a
    <i class="calibre5">
     digital storage oscilloscope (DSO)
    </i>
    , a device that plots the change in a voltage over a period of time.
    <a class="url" href="nsp-boxall502581-0013.xhtml#f03004">
     Figure 3-4
    </a>
    shows a DSO displaying the voltage measured across a pushbutton during a switch bounce.
   </p>
   <div class="figure" id="f03004">
    <p class="fig">
     <img alt="A screenshot showing electrical signals during switch bounce on an oscilloscope" height="781" src="images/nsp-boxall502581-f03004.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 3-4:
      </span>
      Measuring switch bounce
     </p>
    </div>
   </div>
   <p class="calibre8">
    The top half of the display in
    <a class="url" href="nsp-boxall502581-0013.xhtml#f03004">
     Figure 3-4
    </a>
    shows the result of the button being pressed several times. When the voltage line in the lower half of the image is at the higher horizontal position (5 V), the button is on.
   </p>
   <p class="calibre8">
    Underneath the word Stop at the top right, two vertical lines highlight a slice of time. The pushbutton voltage during this time is magnified in the bottom half of the screen. At A, the user releases the button and the line drops down to 0 V. However, due to physical vibration, it immediately jumps
    <span id="p69">
    </span>
    back up to 5 V again until B, when it vibrates off and then on again until C, where it settles at the low (off) state. In effect, instead of relaying one button press to our microcontroller, we have unwittingly sent three.
   </p>
   <p class="calibre8">
    You can’t prevent switch bounce, but you can prevent your program from reacting to it: just use the
    <code class="calibre23">
     _delay_ms()
    </code>
    function to force the program to wait before executing any more code after detecting a button press. About 50 ms should be long enough, but test this with your own hardware to find the precise length of time that meets your needs.
   </p>
  </div>
  <div class="chapter">
   <h2 class="ah" id="ah0505">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah0505">
     Protecting Your AVR from Fluctuating Voltages
    </a>
   </h2>
   <p class="paft">
    In a perfect world, a digital input pin would see either a 5 V electrical signal (high) or no electrical signal (low). In reality, switch bounce and other imperfections can cause the voltage at an input pin to vary wildly between 5 V and 0 V.
   </p>
   <p class="calibre8">
    Adding delays in your program helps prevent software malfunctions due to switch bounce, but these fluctuations can happen even when you’re not using the pin, which can confuse or even damage your AVR. Fortunately, you can protect the AVR with pullup or pulldown resistors.
   </p>
   <div class="chapter">
    <h3 class="bh" id="bh0509">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0509">
      Pullup Resistors
     </a>
    </h3>
    <p class="paft">
     A
     <i class="calibre5">
      pullup resistor
     </i>
     , illustrated in
     <a class="url" href="nsp-boxall502581-0013.xhtml#f03005">
      Figure 3-5
     </a>
     , keeps the voltage at a digital input pin as close as possible to a high state.
    </p>
    <div class="figure" id="f03005">
     <p class="fig">
      <img alt="Pullup resistor example schematic" height="728" src="images/nsp-boxall502581-f03005.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 3-5:
       </span>
       Example use of a pullup resistor
      </p>
     </div>
    </div>
    <p class="calibre8">
     The voltage at input pin 3 on the microcontroller will always be connected to a high signal, until the button is pressed, at which point pin 3 will be directly connected to GND and become low. The resistor prevents you from shorting 5 V to GND (which can damage your hardware) when you press the button.
    </p>
    <p class="calibre8">
     <span id="p70">
     </span>
     AVR microcontrollers have internal pullup resistors. This is a neat way to reduce the size of a circuit, but the catch is that you’ll have to invert the logic in your programs. For example, if you have a button connected between a digital input pin and GND and the internal pullups are enabled, the input goes low (instead of high) when the button is pressed. This is a small price to pay for convenience. To turn on the internal pullup resistors for pins that are set as inputs, write 1s to the corresponding bits in PORT
     <i class="calibre5">
      x
     </i>
     ; to turn internal pullups off, write 0s to those bits.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh0510">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0510">
      Pulldown Resistors
     </a>
    </h3>
    <p class="paft">
     A
     <i class="calibre5">
      pulldown
     </i>
     resistor, illustrated in
     <a class="url" href="nsp-boxall502581-0013.xhtml#f03006">
      Figure 3-6
     </a>
     , keeps the voltage at a digital input pin as close as possible to a low state.
    </p>
    <div class="figure" id="f03006">
     <p class="fig">
      <img alt="Pulldown resistor example schematic" height="721" src="images/nsp-boxall502581-f03006.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 3-6:
       </span>
       Example use of a pulldown resistor
      </p>
     </div>
    </div>
    <p class="calibre8">
     The voltage at pin 3 on the microcontroller connects to a low signal until the button is pressed. Then pin 3 directly connects to 5 V (high). Again, we use the resistor to avoid a dead short between the 5 V and GND when the button is pressed.
    </p>
   </div>
  </div>
  <div class="chapter">
   <h2 class="ah" id="ah0506">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah0506">
     Introducing Seven-Segment LED Displays
    </a>
   </h2>
   <p class="paft">
    One way to make your microcontroller react to input is by displaying a number. To do that, you can add a new component to your toolbox: the
    <i class="calibre5">
     seven-segment LED display
    </i>
    , shown in
    <a class="url" href="nsp-boxall502581-0013.xhtml#f03007">
     Figure 3-7
    </a>
    .
   </p>
   <div class="figure" id="f03007">
    <p class="fig">
     <span>
     </span>
     <img alt="Two examples of seven-segment LED displays" height="840" src="images/nsp-boxall502581-f03007.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 3-7:
      </span>
      Seven-segment LED display modules
     </p>
    </div>
   </div>
   <p class="calibre8">
    These small plastic bricks contain eight LEDs, arranged into a familiar
    <span id="p71">
    </span>
    digital-number display with a decimal point. You’ll find them in various household appliances, and they’re great for displaying numbers, letters, or even symbols.
   </p>
   <p class="calibre8">
    Seven-segment displays are available in a myriad of sizes and colors, and electrically they are the same as eight separate LEDs, with one catch: to reduce the number of pins used by the display, all of the anodes or cathodes of the LEDs are connected together. These are called
    <i class="calibre5">
     common-anode
    </i>
    and
    <i class="calibre5">
     common-cathode
    </i>
    configurations, respectively. All seven-segment displays in this book use common-cathode modules. The schematic symbol for this example display is shown in
    <a class="url" href="nsp-boxall502581-0013.xhtml#f03008">
     Figure 3-8
    </a>
    .
   </p>
   <div class="figure" id="f03008">
    <p class="fig">
     <img alt="Schematic symbol for a seven-segment LED display" height="1200" src="images/nsp-boxall502581-f03008.jpg" width="723" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 3-8:
      </span>
      Schematic symbol for a seven-segment common-cathode LED display module
     </p>
    </div>
   </div>
   <p class="calibre8">
    Next to each LED’s cathode is its matching segment. The display’s LEDs are labeled A to G and DP (for the decimal point) with an anode pin for each LED segment, and the cathodes are connected to one or two common cathode pins.
   </p>
   <p class="calibre8">
    Seven-segment display pin layouts vary by manufacturer, so when you purchase them, make sure the supplier gives you the data sheet showing which pins are the anodes for each segment, and which pin is the cathode. If in doubt, note that most common models have pin 1 at the bottom-left corner of the display with the rest numbered counterclockwise. Remember that they’re still individual LEDs, and you’ll still need a current-limiting resistor for each one.
   </p>
   <p class="hd" id="pro12">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro12">
     <span class="ccust1">
      Project 12: Building a Single-Digit Numerical Counter
     </span>
    </a>
   </p>
   <p class="paft">
    Let’s consolidate what you’ve learned so far by making an interactive device that I hope will spur your imagination: a single-digit numerical counter. Your counter will have two buttons (one to increase the count, and another to reset the counter to zero) and a seven-segment display.
   </p>
   <div class="chapter">
    <h3 class="bh" id="bh0511">
     <span class="page" id="p72">
     </span>
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0511">
      The Hardware
     </a>
    </h3>
    <p class="paft">
     You will need the following hardware:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • USBasp programmer
     </li>
     <li class="bl">
      • Solderless breadboard
     </li>
     <li class="bl">
      • ATmega328P-PU microcontroller
     </li>
     <li class="bl">
      • One common-cathode seven-segment LED display
     </li>
     <li class="bl">
      • Seven 560
      <span lang="el" xml:lang="el">
       Ω
      </span>
      resistors (R1–R7)
     </li>
     <li class="bl">
      • Two pushbuttons
     </li>
     <li class="bl">
      • Two 10
      <span lang="en" xml:lang="en">
       kΩ
      </span>
      resistors (R8, R9)
     </li>
     <li class="bll">
      • Jumper wires
     </li>
    </ul>
    <p class="calibre8">
     Assemble your circuit as shown in
     <a class="url" href="nsp-boxall502581-0013.xhtml#f03009">
      Figure 3-9
     </a>
     .
    </p>
    <div class="figure" id="f03009">
     <p class="fig">
      <img alt="Schematic diagram for Project 12" height="1070" src="images/nsp-boxall502581-f03009.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 3-9:
       </span>
       The main circuit for
       <a class="url" href="nsp-boxall502581-0013.xhtml#pro12">
        Project 12
       </a>
      </p>
     </div>
    </div>
    <p class="calibre8">
     By now you should remember on your own to connect the USBasp and wire it to the circuit before getting started, so after this project I’ll stop reminding you.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh0512">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0512">
      The Code
     </a>
    </h3>
    <p class="paft">
     Open a terminal window, navigate to the
     <i class="calibre5">
      Project 12
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 3
     </i>
     folder, and enter the command
     <code class="b">
      make flash
     </code>
     . Once you’ve uploaded the code to your microcontroller, press the button connected to PD0 to increase the counter, and press the other button to reset the count to zero.
    </p>
    <p class="calibre8">
     <span id="p73">
     </span>
     To see how this works, open the
     <i class="calibre5">
      main.c
     </i>
     file for
     <a class="url" href="nsp-boxall502581-0013.xhtml#pro12">
      Project 12
     </a>
     :
    </p>
    <div class="codeline">
     <p class="clf">
      // Project 12 - Building a Single-Digit Numerical Counter
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="cl">
      #define TIME 150
     </p>
     <p class="cl2f">
      <!--<ccust1>1</ccust1>-->
      ❶ void displayNumber(uint8_t value)
     </p>
     <p class="cl">
      // Displays numbers 0–9 on a seven-segment LED display
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      switch(value)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      case 0 : PORTB = 0b00111111; break; // 0
     </p>
     <p class="cl">
      case 1 : PORTB = 0b00000110; break; // 1
     </p>
     <p class="cl">
      case 2 : PORTB = 0b01011011; break; // 2
     </p>
     <p class="cl">
      case 3 : PORTB = 0b01001111; break; // 3
     </p>
     <p class="cl">
      case 4 : PORTB = 0b01100110; break; // 4
     </p>
     <p class="cl">
      case 5 : PORTB = 0b01101101; break; // 5
     </p>
     <p class="cl">
      case 6 : PORTB = 0b01111101; break; // 6
     </p>
     <p class="cl">
      case 7 : PORTB = 0b00000111; break; // 7
     </p>
     <p class="cl">
      case 8 : PORTB = 0b01111111; break; // 8
     </p>
     <p class="cl">
      case 9 : PORTB = 0b01101111; break; // 9
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>2</ccust1>-->
      ❷ uint8_t i = 0;             // Counter value
     </p>
     <p class="cl">
      <!--<ccust1>3</ccust1>-->
      ❸ DDRB = 0b11111111;         // Set PORTB to outputs
     </p>
     <p class="cl">
      DDRD = 0b00000000;         // Set PORTD to inputs
     </p>
     <p class="cl">
      <!--<ccust1>4</ccust1>-->
      ❹ PORTD = 0b11111100;        // Turn off internal pullups for PD0 and PD1
     </p>
     <p class="cl">
      for(;;)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>5</ccust1>-->
      ❺ displayNumber(i);       // Display count
     </p>
     <p class="cl">
      _delay_ms(TIME);
     </p>
     <p class="cl">
      <!--<ccust1>6</ccust1>-->
      ❻ if (PIND == 0b11111110) // If reset button pressed . . .
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      i = 0;               // set counter to zero
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      <!--<ccust1>7</ccust1>-->
      ❼ if (PIND == 0b11111101) // If count button pressed . . .
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      i++;                 // increase counter
     </p>
     <p class="cl">
      if (i &gt; 9)           // If counter is greater than 9 . . .
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      i = 0;            // set counter to zero
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      return 0;
     </p>
     <p class="cll">
      }
     </p>
    </div>
    <p class="calibre8">
     This code defines a new function,
     <code class="calibre23">
      displayNumber()
     </code>
     , that receives an integer and sets the PORTB outputs to turn individual segments of the LED
     <span id="p74">
     </span>
     display on or off, thus displaying a digit from 0 to 9
     <!--<ccust1>1</ccust1>-->
     ❶. By using a
     <code class="calibre23">
      switch...case
     </code>
     statement, the code can neatly decide which
     <code class="calibre23">
      PORTB
     </code>
     command to run based on what digit you want to display.
    </p>
    <p class="calibre8">
     The variable
     <code class="calibre23">
      i
     </code>
     keeps track of what number you want to display
     <!--<ccust1>2</ccust1>-->
     ❷. This variable is initialized with a value of zero so that the counter starts at zero when the power is turned on.
    </p>
    <p class="calibre8">
     Next, we set up the I/O pins, using PORTB as outputs for the LEDs and PORTD as inputs that detect when the buttons are pressed
     <!--<ccust1>3</ccust1>-->
     ❸. The internal pullup resistors are turned off for pins PD0 and PD1
     <!--<ccust1>4</ccust1>-->
     ❹ because the buttons are connected to those pins, and the pullups are turned on for the rest of PORTD. This ensures that the unused pins in PORTD will always be high.
    </p>
    <p class="calibre8">
     Every time the code loops, it first displays the value of the count
     <!--<ccust1>5</ccust1>-->
     ❺, then checks if the reset or count buttons have been pressed. Note that when the code compares
     <code class="calibre23">
      PIND
     </code>
     against the binary values representing button presses on PD0
     <!--<ccust1>6</ccust1>-->
     ❻ or PD1
     <!--<ccust1>7</ccust1>-->
     ❼, the unused bits (or inputs) in the comparison are 1s, not 0s. This is because the internal pullup resistors have been activated for the unused inputs, keeping them at 1.
    </p>
    <p class="calibre8">
     When you press the count button, the count variable
     <code class="calibre23">
      i
     </code>
     should increase by one. If the count is greater than 9, it should reset back to 0 because you’re working with a single-digit display.
    </p>
    <p class="calibre8">
     Once you’ve completed this project, you’ll have a nifty display—but remember, you learn by doing. Experiment with this program! For example, try changing it to a countdown timer or creating changing patterns with the LEDs instead of numbers.
    </p>
    <p class="calibre8">
     If possible, keep this project assembled, as you’ll reuse most of it for
     <a class="url" href="nsp-boxall502581-0013.xhtml#pro14">
      Project 14
     </a>
     .
    </p>
   </div>
  </div>
  <div class="chapter">
   <h2 class="ah" id="ah0507">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah0507">
     Analog Inputs
    </a>
   </h2>
   <p class="paft">
    Up to this point, your projects have used digital electrical signals with just two levels: high and low. For your microcontrollers, high is close to 5 V and low is close to 0 V (or GND). We used the PORT
    <i class="calibre5">
     x
    </i>
    register to blink LEDs and the PIN
    <i class="calibre5">
     x
    </i>
    register to measure whether a digital input was high or low.
    <a class="url" href="nsp-boxall502581-0013.xhtml#f03010">
     Figure 3-10
    </a>
    illustrates a digital signal measured with a DSO.
   </p>
   <div class="figure" id="f03010">
    <p class="fig">
     <img alt="A screenshot of a digital signal in the form of a square wave displayed on an oscilloscope" height="781" src="images/nsp-boxall502581-f03010.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 3-10:
      </span>
      A digital signal, with highs appearing as horizontal lines at the top and lows appearing at the bottom
     </p>
    </div>
   </div>
   <p class="calibre8">
    <span id="p75">
    </span>
    Unlike digital signals,
    <i class="calibre5">
     analog signals
    </i>
    can vary with an indefinite number of steps between high and low. For example,
    <a class="url" href="nsp-boxall502581-0013.xhtml#f03011">
     Figure 3-11
    </a>
    shows an analog voltage signal that looks like a sine wave.
   </p>
   <div class="figure" id="f03011">
    <p class="fig">
     <img alt="A screenshot of an analog signal in the form of a sine wave displayed on an oscilloscope" height="781" src="images/nsp-boxall502581-f03011.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 3-11:
      </span>
      A sinusoidal analog signal
     </p>
    </div>
   </div>
   <p class="calibre8">
    Notice that as time progresses, the voltage moves fluidly between high and low levels. Analog signals can represent all sorts of information from various devices, such as temperature or distance sensors. To use analog signals in your projects, you measure the voltage values of the signal using certain I/O pins in your microcontrollers, which are connected to
    <i class="calibre5">
     analog-to-digital converters (ADCs)
    </i>
    . An ADC can convert a voltage to a number, which you can then use in your code. Refer to the pinout and port register diagrams in
    <a class="url" href="nsp-boxall502581-0012.xhtml#ch02">
     Chapter 2
    </a>
    ; the analog inputs are marked as ADC
    <i class="calibre5">
     x
    </i>
    for
    <i class="calibre5">
     analog-to-digital converter x
    </i>
    .
   </p>
   <p class="calibre8">
    On the ATtiny85 you have PB0, PB1, PB2, and PB5 (physical pins 5–7 and 1). On the ATmega328P-PU you have a whole new register (PORTC), which has six ADCs from PC0 to PC5.
   </p>
  </div>
  <div class="chapter">
   <h2 class="ah" id="ah0508">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah0508">
     Using ATtiny85 ADCs
    </a>
   </h2>
   <p class="paft">
    To set up the ADC pins on the ATtiny85, you’ll need to set two new registers. (Yes, more registers! You’ll get used to them the more you use them.) The first, ADMUX, selects which pin you’ll connect to the ADC. You’ll leave the first six bits as
    <code class="calibre23">
     001000
    </code>
    and use the last two bits to select the physical pin for the ADC. They’re
    <code class="calibre23">
     00
    </code>
    for ADC0 (pin 1),
    <code class="calibre23">
     01
    </code>
    for ADC1 (pin 7),
    <code class="calibre23">
     10
    </code>
    for ADC2 (pin 3), and
    <code class="calibre23">
     11
    </code>
    for ADC3 (pin 2). For example, to use physical pin 3 as the analog input, set ADMUX as follows:
   </p>
   <div class="codeline">
    <p class="cls">
     ADMUX = 0b00100010;
    </p>
   </div>
   <p class="calibre8">
    The second register to set, called ADCSRA, is responsible for several settings, including the speed of the ADC. All ATtiny85 projects in this book set the speed to 1 MHz. As the ADC section of the microcontroller operates at a different speed, you’ll use ADCSRA to set a prescale value that determines the ADC speed. You’ll typically use a prescaler of 8, which brings the ADC speed down to 125 kHz (which we calculate by dividing the speed of 1 MHz by 8). The matching ADCSRA line is:
   </p>
   <div class="codeline">
    <p class="cls">
     <span id="p76">
     </span>
     ADCSRA = 0b10000011;
    </p>
   </div>
   <p class="calibre8">
    It’s a good idea to put the two register settings in their own custom function, which you could name
    <code class="calibre23">
     startADC()
    </code>
    , for example. This keeps your code neat and makes it easy to call the function wherever you need it.
   </p>
   <p class="calibre8">
    When using ADCs, it can be helpful to use a different way of addressing bits in a register—using bitwise operations. For now I’ll keep it simple and just show you how this works; we’ll revisit this topic (and the use of prescalers) in more detail in
    <a class="url" href="nsp-boxall502581-0016.xhtml#ch06">
     Chapter 6
    </a>
    .
   </p>
   <p class="calibre8">
    To measure a value from your preset ADC pin, first start the ADC with the line:
   </p>
   <div class="codeline">
    <p class="cls">
     ADCSRA |= (1 &lt;&lt; ADSC);
    </p>
   </div>
   <p class="calibre8">
    This sets the ADSC bit in the ADCSRA register to 1, which tells your ATtiny85 to read the analog input and convert it to a value. When the ATtiny85 has finished, the ADSC bit returns to 0. You’ll need to tell your code to wait a moment until this happens, like so:
   </p>
   <div class="codeline">
    <p class="cls">
     while (ADCSRA &amp; (1 &lt;&lt; ADSC));
    </p>
   </div>
   <p class="calibre8">
    This compares the ADSC bit in the ADCSRA register to 1 and does nothing if they’re both 1. When the ADC process is complete, the ADSC bit returns to 0, the
    <code class="calibre23">
     while()
    </code>
    function finishes, and the microcontroller progresses.
   </p>
   <p class="calibre8">
    Finally, the value from the ADC is stored in the variable
    <code class="calibre23">
     ADCH
    </code>
    . The value of
    <code class="calibre23">
     ADCH
    </code>
    should be between 0 and 255. You can then work with
    <code class="calibre23">
     ADCH
    </code>
    as required.
   </p>
   <p class="hd" id="pro13">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro13">
     <span class="ccust1">
      Project 13: Making a Single-Cell Battery Tester
     </span>
    </a>
   </p>
   <p class="paft">
    In this project, you’ll put your ATtiny85’s ADC to work by making a simple battery tester. You can use this to check the voltage of AA, AAA, C, or D cell batteries.
   </p>
   <p class="pcust">
    <span class="ccust">
     Warning
    </span>
    Do not connect any battery (or other power source) with a voltage greater than 5 V to your tester, and don’t connect the battery the wrong way around (check the schematic in
    <a class="url" href="nsp-boxall502581-0013.xhtml#f03012">
     Figure 3-12
    </a>
    ). Doing either will damage your ATtiny85.
   </p>
   <p class="calibre8">
    This tester uses two LEDs to indicate whether the battery is good (with a voltage greater than or equal to 1.4 V) or bad (with a voltage less than 1.4 V).
   </p>
   <div class="chapter">
    <h3 class="bh" id="bh0513">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0513">
      The Hardware
     </a>
    </h3>
    <p class="paft">
     You’ll need the following hardware:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • USBasp programmer
     </li>
     <li class="bl">
      • Solderless breadboard
     </li>
     <li class="bl">
      <span id="p77">
      </span>
      • ATtiny85–20PU microcontroller
     </li>
     <li class="bl">
      • Two LEDs
     </li>
     <li class="bl">
      • One 560
      <span lang="el" xml:lang="el">
       Ω
      </span>
      resistor
     </li>
     <li class="bll">
      • Jumper wires
     </li>
    </ul>
    <p class="calibre8">
     Assemble your circuit as shown in
     <a class="url" href="nsp-boxall502581-0013.xhtml#f03012">
      Figure 3-12
     </a>
     . Note that the two wires labeled positive (+) and negative (−) are jumper wires used to contact the battery you want to test. Connect the + and − wires to the matching points on the battery.
    </p>
    <div class="figure" id="f03012">
     <p class="fig">
      <img alt="Schematic diagram for Project 13" height="737" src="images/nsp-boxall502581-f03012.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 3-12:
       </span>
       Schematic for
       <a class="url" href="nsp-boxall502581-0013.xhtml#pro13">
        Project 13
       </a>
      </p>
     </div>
    </div>
    <p class="calibre8">
     You may find that it helps to use some insulation tape to keep the wires connected to the battery under test. You might also use red and green LEDs to indicate whether the battery under test is “bad” or “good.”
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh0514">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0514">
      The Code
     </a>
    </h3>
    <p class="paft">
     Open a terminal window, navigate to the
     <i class="calibre5">
      Project 13
     </i>
     subfolder of the
     <i class="calibre5">
      Chapter 3
     </i>
     folder for this book, and enter the command
     <code class="b">
      make flash
     </code>
     . Once you’ve uploaded the code, find a AA, AAA, C, or D cell battery, and connect the positive and negative leads to the circuit as shown in the schematic. If the voltage is greater than or equal to 1.4 V, LED2 should turn on; if it’s less than 1.4 V, LED1 should turn on.
    </p>
    <p class="calibre8">
     To see how this is implemented, open the
     <i class="calibre5">
      main.c
     </i>
     file for
     <a class="url" href="nsp-boxall502581-0013.xhtml#pro13">
      Project 13
     </a>
     :
    </p>
    <div class="codeline">
     <p class="clf">
      // Project 13 - Making a Single-Cell Battery Tester
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="cl2f">
      <!--<ccust1>1</ccust1>-->
      ❶ void startADC()
     </p>
     <p class="cl">
      <span id="p78">
      </span>
      // Set up the ADC
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      ADMUX = 0b00100010;               // Set ADC pin to 3
     </p>
     <p class="cl">
      ADCSRA = 0b10000011;              // Set prescaler speed for 1 MHz
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      DDRB = 0b00000011;                // Set pins 5 and 6 as outputs
     </p>
     <p class="cl">
      <!--<ccust1>2</ccust1>-->
      ❷  startADC();
     </p>
     <p class="cl">
      for(;;)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>3</ccust1>-->
      ❸ ADCSRA |= (1 &lt;&lt; ADSC);         // Start ADC measurement
     </p>
     <p class="cl">
      while (ADCSRA &amp; (1 &lt;&lt; ADSC) ); // Wait until conversion completes
     </p>
     <p class="cl">
      _delay_ms(5);
     </p>
     <p class="clf">
      <!--<ccust1>4</ccust1>-->
      ❹ if (ADCH &gt;= 71)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // If ADC input voltage is more than or equal to ~1.4 V . . .
     </p>
     <p class="cl">
      PORTB = 0b00000010;         // Turn on "battery OK" LED2
     </p>
     <p class="clf">
      <!--<ccust1>5</ccust1>-->
      ❺ } else if (ADCH &lt; 71)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Else, if ADC input voltage is less than ~1.4 V . . .
     </p>
     <p class="cl">
      PORTB = 0b00000001;         // Turn on "battery not OK" LED1
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="cll">
      return 0;
     </p>
    </div>
    <p class="calibre8">
     }The function
     <code class="calibre23">
      startADC()
     </code>
     sets physical pin 3 to use its ADC function and sets the prescaler for 1 MHz operation
     <!--<ccust1>1</ccust1>-->
     ❶. We need to call this function before using the ADC
     <!--<ccust1>2</ccust1>-->
     ❷. We then activate the ADC for a reading and wait for it to complete
     <!--<ccust1>3</ccust1>-->
     ❸.
    </p>
    <p class="calibre8">
     The value from the ADC—a number between 0 and 255—is stored in the variable
     <code class="calibre23">
      ADCH
     </code>
     . This value maps to the voltage range of the ADC, which is 0 to 5 V. You can find the ADC value with some basic math:
    </p>
    <div class="equation">
     <p class="eq">
      (Map Voltage × 256) / Supply Voltage = ADC Value
     </p>
    </div>
    <p class="calibre8">
     For our example, we calculate the matching ADC value for 1.4 V as follows:
    </p>
    <div class="equation">
     <p class="eq">
      (1.4 V × 256 / 5 V) = 71.68
     </p>
    </div>
    <p class="calibre8">
     Based on this calculation, 1.4 V maps to an ADC value of 71.4, which we round to 71 in our code because we’re using whole numbers in this project. This is the value used in the
     <code class="calibre23">
      if
     </code>
     statements at and to determine whether the battery is good to use
     <!--<ccust1>4</ccust1>-->
     ❹ or not
     <!--<ccust1>5</ccust1>-->
     ❺.
    </p>
    <p class="calibre8">
     At this point, you should understand how to read analog signals in the form of varying voltages from external devices. This is incredibly useful, as there are many types of sensors whose values are returned as a varying voltage and thus are easy to read with the ADC pin of your microcontroller.
    </p>
    <p class="calibre8">
     <span id="p79">
     </span>
     Next, let’s look at the ADCs on the ATmega328P-PU, along with some more information about variable types.
    </p>
   </div>
  </div>
  <div class="chapter">
   <h2 class="ah" id="ah0509">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah0509">
     Using the ATmega328P-PU ADCs
    </a>
   </h2>
   <p class="paft">
    Setting up the ADC pins on the ATmega328P-PU is similar to setting them up on the ATtiny85. You’ll start by setting up some registers. The first is ADMUX, which has two functions: indicating which ADC pin you want to use and selecting the source of the reference voltage the ADC compares against the analog signal being measured.
   </p>
   <p class="calibre8">
    First you’ll set the REFS0 bit in the ADMUX register to 1, which tells the microcontroller to use the voltage connected to AV
    <sub class="calibre28">
     CC
    </sub>
    (pin 20) for comparisons with analog signals. Again, you can use a bitwise operation for this:
   </p>
   <div class="codeline">
    <p class="cls">
     ADMUX |= (1 &lt;&lt; REFS0);
    </p>
   </div>
   <p class="calibre8">
    This is a simpler and less error-prone method of setting individual bits in a register, as it lets you avoid having to deal with all eight bits at once—you only set the bit you want to change. Also remember that you only need to set bits to 1, as by default they’re all 0.
   </p>
   <p class="calibre8">
    Next, you’ll set the MUX2 and MUX0 bits to 1, which tells the ADC to read signals coming in on pin 28:
   </p>
   <div class="codeline">
    <p class="cls">
     ADMUX |= (1 &lt;&lt; MUX2) | (1 &lt;&lt; MUX0);
    </p>
   </div>
   <p class="calibre8">
    The second register you’ll set, ADCSRA, activates the ADC and sets the speed of the ADC in the microcontroller. All your ATmega328P-PU projects from here until
    <a class="url" href="nsp-boxall502581-0023.xhtml#ch13">
     Chapter 13
    </a>
    will use the speed 1 MHz, and the matching ADCSRA line is:
   </p>
   <div class="codeline">
    <p class="cls">
     ADCSRA |= (1 &lt;&lt; ADPS1) | (1 &lt;&lt; ADPS0);
    </p>
   </div>
   <p class="calibre8">
    Finally, you need to activate the ADC by setting the ADEN bit to 1:
   </p>
   <div class="codeline">
    <p class="cls">
     ADCSRA |= (1 &lt;&lt; ADEN);
    </p>
   </div>
   <p class="calibre8">
    As in
    <a class="url" href="nsp-boxall502581-0013.xhtml#pro12">
     Project 12
    </a>
    , it’s a good idea to put the register settings in their own custom function, which I’ve named
    <code class="calibre23">
     startADC()
    </code>
    .
   </p>
   <p class="calibre8">
    When you want to measure a value from the preset ADC pin, you first need to start the ADC as follows:
   </p>
   <div class="codeline">
    <p class="cls">
     ADCSRA |= (1 &lt;&lt; ADSC);
    </p>
   </div>
   <p class="calibre8">
    This sets the ADSC bit in the ADCSRA register to 1, which tells your ATmega328P-PU to read the analog input and convert it to a value. This is not instantaneous; your code needs to wait until the ATmega328P-PU has
    <span id="p80">
    </span>
    finished the ADC reading, at which point the ADSC bit returns to 0. The following is a convenient space-saving function that can be used to monitor changes of bits in registers:
   </p>
   <div class="codeline">
    <p class="cls">
     loop_until_bit_is_clear(ADCSRA, ADSC);
    </p>
   </div>
   <p class="calibre8">
    In this case, it forces the code to wait until the ADSC bit returns to 0; when this happens, the ADC process is complete, and the code can then continue.
   </p>
   <p class="calibre8">
    The value from the ADC is a 10-bit number, which the toolchain makes available in a virtual register variable called, you guessed it,
    <code class="calibre23">
     ADC
    </code>
    . However, for purposes where accuracy isn’t entirely necessary, you can just use an 8-bit value, dropping the last 2 bits off the ADC register like so:
   </p>
   <div class="codeline">
    <p class="cls">
     ADCvalue = ADC;
    </p>
   </div>
   <p class="pcon">
    where
    <code class="calibre23">
     ADCvalue
    </code>
    is an integer variable used to hold the value from the ADC.
   </p>
   <p class="calibre8">
    Finally, when using the same power to run the microcontroller and its internal ADC, it’s wise to use a small smoothing capacitor over the positive and negative power supply lines, as shown in the
    <a class="url" href="nsp-boxall502581-0013.xhtml#pro14">
     following project
    </a>
    .
   </p>
  </div>
  <div class="chapter">
   <h2 class="ah" id="ah0510">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah0510">
     Introducing the Variable Resistor
    </a>
   </h2>
   <p class="paft">
    Variable resistors, also known as
    <i class="calibre5">
     potentiometers
    </i>
    , can generally be adjusted from 0
    <span lang="el" xml:lang="el">
     Ω
    </span>
    up to their rated value.
    <a class="url" href="nsp-boxall502581-0013.xhtml#f03013">
     Figure 3-13
    </a>
    shows their schematic symbol.
   </p>
   <div class="figure" id="f03013">
    <p class="fig">
     <img alt="Potentiometer schematic symbol" height="1200" src="images/nsp-boxall502581-f03013.jpg" width="806" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 3-13:
      </span>
      Variable resistor (potentiometer) symbol
     </p>
    </div>
   </div>
   <p class="calibre8">
    Variable resistors have three electrical connections, one in the center and one on each side. As the shaft of the variable resistor is turned, it increases the resistance between one side and the center and decreases the resistance between the opposite side and the center.
   </p>
   <p class="calibre8">
    Variable resistors can be either
    <i class="calibre5">
     linear
    </i>
    or
    <i class="calibre5">
     logarithmic
    </i>
    . The resistance of linear models changes at a constant rate when turning, while the resistance of logarithmic models changes slowly at first and then increases rapidly. Logarithmic potentiometers are used more often in audio amplifier circuits because they model the human hearing response. You can generally
    <span id="p81">
    </span>
    identify whether a potentiometer is logarithmic or linear via the marking on the rear. Most will have either an A or a B next to the resistance value: A for logarithmic, B for linear. Most projects use linear variable resistors such as the one shown in
    <a class="url" href="nsp-boxall502581-0013.xhtml#f03014">
     Figure 3-14
    </a>
    .
   </p>
   <div class="figure" id="f03014">
    <p class="fig">
     <img alt="An example of a variable resistor" height="1200" src="images/nsp-boxall502581-f03014.jpg" width="909" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 3-14:
      </span>
      A typical linear variable resistor
     </p>
    </div>
   </div>
   <p class="calibre8">
    Miniature variable resistors are known as
    <i class="calibre5">
     trimpots
    </i>
    or
    <i class="calibre5">
     trimmers
    </i>
    (see
    <a class="url" href="nsp-boxall502581-0013.xhtml#f03015">
     Figure 3-15
    </a>
    ). Because of their size, trimpots are more useful for making adjustments in circuits, but they’re also very useful for breadboard work because they can be slotted in.
   </p>
   <div class="figure" id="f03015">
    <p class="fig">
     <img alt="Three different styles of trimpot" height="540" src="images/nsp-boxall502581-f03015.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 3-15:
      </span>
      Various trimpots
     </p>
    </div>
   </div>
   <p class="calibre8">
    When shopping for trimpots, take note of the type. If possible, you’ll want one that is easy to adjust with the screwdriver you have on hand. The enclosed types pictured in
    <a class="url" href="nsp-boxall502581-0013.xhtml#f03015">
     Figure 3-15
    </a>
    are also preferable, as they last longer than the cheaper, open-contact types.
   </p>
   <p class="hd" id="pro14">
    <span class="page" id="p82">
    </span>
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro14">
     <span class="ccust1">
      Project 14: Experimenting with an ATmega328P-PU ADC
     </span>
    </a>
   </p>
   <p class="paft">
    In this project, you’ll experiment with an ADC on the larger ATmega328P-PU microcontroller, along with practicing with more involved decision-making code. This project measures the signal from a trimpot, which varies between 0 V and 5 V. The value falls into one of four ranges and is indicated by one of the four LEDs.
   </p>
   <div class="chapter">
    <h3 class="bh" id="bh0515">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0515">
      The Hardware
     </a>
    </h3>
    <p class="paft">
     You’ll need the following hardware:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • USBasp programmer
     </li>
     <li class="bl">
      • Solderless breadboard
     </li>
     <li class="bl">
      • ATtiny328P-PU microcontroller
     </li>
     <li class="bl">
      • Four LEDs
     </li>
     <li class="bl">
      • Four 560
      <span lang="el" xml:lang="el">
       Ω
      </span>
      resistors
     </li>
     <li class="bl">
      • 0.1
      <span lang="el" xml:lang="el">
       μF
      </span>
      ceramic capacitor
     </li>
     <li class="bl">
      • 10
      <span lang="en" xml:lang="en">
       kΩ
      </span>
      breadboard-compatible linear trimpot
     </li>
     <li class="bll">
      • Jumper wires
     </li>
    </ul>
    <p class="calibre8">
     Assemble your circuit as shown in
     <a class="url" href="nsp-boxall502581-0013.xhtml#f03016">
      Figure 3-16
     </a>
     .
    </p>
    <div class="figure" id="f03016">
     <p class="fig">
      <img alt="Schematic diagram for Project 14" height="1070" src="images/nsp-boxall502581-f03016.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 3-16:
       </span>
       Schematic for
       <a class="url" href="nsp-boxall502581-0013.xhtml#pro14">
        Project 14
       </a>
      </p>
     </div>
    </div>
    <p class="calibre8">
     <span id="p83">
     </span>
     If you can’t get a breadboard-compatible trimpot, you can use a full-size potentiometer, although you’ll need to solder jumper wires to the potentiometer’s three pins in order to make contact with the solderless breadboard.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh0516">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0516">
      The Code
     </a>
    </h3>
    <p class="paft">
     Open a terminal window, navigate to the
     <i class="calibre5">
      Project 14
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 3
     </i>
     folder, and enter the command
     <code class="b">
      make flash
     </code>
     to upload the code for
     <a class="url" href="nsp-boxall502581-0013.xhtml#pro14">
      Project 14
     </a>
     as usual. Once you’ve uploaded the code, start slowly moving the trimpot toward one limit, then turn it through the other direction to the other limit. The LEDs should indicate which quartile of the trimpot range you are currently turning through.
    </p>
    <p class="calibre8">
     Let’s examine how this works. Open the
     <i class="calibre5">
      main.c
     </i>
     file for
     <a class="url" href="nsp-boxall502581-0013.xhtml#pro14">
      Project 14
     </a>
     and take a look at the code:
    </p>
    <div class="codeline">
     <p class="clf">
      // Project 14 - Experimenting with an ATmega328P-PU ADC
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;math.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="cl2f">
      <!--<ccust1>1</ccust1>-->
      ❶ void startADC()
     </p>
     <p class="cl">
      // Set up the ADC
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      ADMUX |= (1 &lt;&lt; REFS0);                 // Use AVcc pin with ADC
     </p>
     <p class="cl">
      ADMUX |= (1 &lt;&lt; MUX2) | (1 &lt;&lt; MUX0);    // Use ADC5 (pin 28)
     </p>
     <p class="cl">
      ADCSRA |= (1 &lt;&lt; ADPS1) | (1 &lt;&lt; ADPS0); // Prescaler for 1MHz (/8)
     </p>
     <p class="cl">
      ADCSRA |= (1 &lt;&lt; ADEN);                 // Enable ADC
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      uint16_t ADCvalue;
     </p>
     <p class="cl">
      <!--<ccust1>2</ccust1>-->
      ❷ DDRB = 0b11111111;                      // Set PORTB to outputs
     </p>
     <p class="cl">
      DDRC = 0b00000000;                      // Set PORTC to inputs
     </p>
     <p class="cl">
      <!--<ccust1>3</ccust1>-->
      ❸ startADC();
     </p>
     <p class="cl">
      for(;;)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>4</ccust1>-->
      ❹ // Take reading from potentiometer via ADC
     </p>
     <p class="cl">
      ADCSRA |= (1 &lt;&lt; ADSC);                // Start ADC measurement
     </p>
     <p class="cl">
      loop_until_bit_is_clear(ADCSRA, ADSC);
     </p>
     <p class="cl">
      // Wait for conversion to finish
     </p>
     <p class="cl">
      <!--<ccust1>5</ccust1>-->
      ❺ _delay_ms(10);
     </p>
     <p class="clf">
      <!--<ccust1>6</ccust1>-->
      ❻ // Assign ADC value to "ADCvalue"
     </p>
     <p class="cl">
      ADCvalue = ADC;
     </p>
     <p class="cl">
      <!--<ccust1>7</ccust1>-->
      ❼ if (ADCvalue&gt;=0 &amp;&amp; ADCvalue &lt;256)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      PORTB = 0b00000001;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      else if (ADCvalue&gt;=256 &amp;&amp; ADCvalue&lt;512)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <span id="p84">
      </span>
      PORTB = 0b00000010;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      else if (ADCvalue&gt;=512 &amp;&amp; ADCvalue&lt;768)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      PORTB = 0b00000100;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      else if (ADCvalue&gt;=768 &amp;&amp; ADCvalue&lt;1023)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      PORTB = 0b00001000;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      // Turn off the LEDs in preparation for the next reading
     </p>
     <p class="cl">
      _delay_ms(100);
     </p>
     <p class="cl">
      PORTB = 0b00000000;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      return 0;
     </p>
     <p class="cll">
      }
     </p>
    </div>
    <p class="calibre8">
     First we specify the pins used for outputs (LEDs—PORTB) and inputs for ADC
     <!--<ccust1>2</ccust1>-->
     ❷, then we call the function
     <code class="calibre23">
      startADC()
     </code>
     <!--<ccust1>1</ccust1>-->
     ❶ to set up the ADC
     <!--<ccust1>3</ccust1>-->
     ❸. We measure the value fed from the trimpot to the ADC via pin PC5
     <!--<ccust1>4</ccust1>-->
     ❹ and store it into the integer variable
     <code class="calibre23">
      ADCvalue
     </code>
     <!--<ccust1>6</ccust1>-->
     ❻ after a short delay
     <!--<ccust1>5</ccust1>-->
     ❺ to give the ADC time to complete its conversion of data.
    </p>
    <p class="calibre8">
     Next, the code evaluates the value of the ADC using a series of
     <code class="calibre23">
      if...else
     </code>
     functions
     <!--<ccust1>7</ccust1>-->
     ❼. Each of these checks if the ADC value falls within a certain range using the
     <code class="calibre23">
      AND
     </code>
     (
     <code class="calibre23">
      &amp;&amp;
     </code>
     ) conditional operator, then activates an LED to provide a visual indication if the result of the test is true.
    </p>
    <p class="calibre8">
     Finally, the LED is turned off at the end of the main loop after a short delay to allow time for indication, and the process starts again.
    </p>
   </div>
  </div>
  <div class="chapter">
   <h2 class="ah" id="ah0511">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah0511">
     Doing Arithmetic with an AVR
    </a>
   </h2>
   <p class="paft">
    Like a pocket calculator, the AVR can perform basic calculations for you. This is really handy when you’re dealing with analog-to-digital conversions. Here are some of the mathematical operations available for your AVR:
   </p>
   <div class="codeline">
    <p class="clf">
     432 + 956; // Addition
    </p>
    <p class="cl">
     100 / 20;  // Division
    </p>
    <p class="cl">
     5 * 200;   // Multiplication
    </p>
    <p class="cl">
     25 - 25;   // Subtraction
    </p>
    <p class="cll">
     10 % 4;    // Modulo
    </p>
   </div>
   <p class="calibre8">
    The C language handles some kinds of calculations a little differently than a pocket calculator, though. For example, when dividing two integers, the AVR simply discards the remainder rather than rounding the quotient up or down: 16 divided by 2 equals 8, 10 divided by 3 equals 3, and 18 divided by 8 equals 2. I’ll explain a few other oddities as they come up.
   </p>
   <p class="calibre8">
    <span id="p85">
    </span>
    When working with numbers that have or will result in a decimal point (for example, dividing 1 by 3), you will need to use a new type of variable called a
    <i class="calibre5">
     float
    </i>
    . The values that can be stored in a float can fall between −3.39 × 10
    <sup class="calibre6">
     38
    </sup>
    and 3.39 × 10
    <sup class="calibre6">
     38
    </sup>
    . To use floating-point math in your code, you’ll need to include a new library:
   </p>
   <div class="codeline">
    <p class="cls">
     #include &lt;math.h&gt;
    </p>
   </div>
   <p class="calibre8">
    You’ll get used to this math by using it in
    <a class="url" href="nsp-boxall502581-0013.xhtml#pro15">
     Project 15
    </a>
    , along with your first analog sensor, which I’ll introduce next.
   </p>
  </div>
  <div class="chapter">
   <h2 class="ah" id="ah0512">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah0512">
     Using External Power
    </a>
   </h2>
   <p class="paft">
    Up to this point you’ve been powering your projects directly from the AVR programmer, which is a neat solution for small projects and experiments. However, this method leaves less than 5 V of output voltage available to your circuit, as the internal circuitry of the programmer reduces the voltage.
   </p>
   <p class="calibre8">
    If you use a multimeter to measure the voltage across pins 7 and 8 of your ATmega328P-PU in
    <a class="url" href="nsp-boxall502581-0013.xhtml#pro14">
     Project 14
    </a>
    or others created earlier, you’ll find it’s less than 5 V. When working with parts that expect 5 V (such as the TMP36 used in the
    <a class="url" href="nsp-boxall502581-0013.xhtml#pro15">
     next project
    </a>
    ), you’ll need an external power supply for accuracy and reliability.
   </p>
   <p class="calibre8">
    One easy way to add external 5 V power is to use a breadboard power supply module, such as the one from PMD Way (part number 20250303) shown in
    <a class="url" href="nsp-boxall502581-0013.xhtml#f03017">
     Figure 3-17
    </a>
    .
   </p>
   <div class="figure" id="f03017">
    <p class="fig">
     <img alt="Power supply module fitted to the end of a solderless breadboard" height="1004" src="images/nsp-boxall502581-f03017.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 3-17:
      </span>
      A breadboard power supply module
     </p>
    </div>
   </div>
   <p class="calibre8">
    <span id="p86">
    </span>
    The PMD Way module is inserted into the end of your breadboard and is powered by a common AC to DC wall wart power supply. The unit supplies 5 V or 3.3 V to both sides of the breadboard and has a neat power switch for control. It is a small and very convenient outlay.
   </p>
  </div>
  <div class="chapter">
   <h2 class="ah" id="ah0513">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah0513">
     The TMP36 Temperature Sensor
    </a>
   </h2>
   <p class="paft">
    With the TMP36 temperature sensor (shown in
    <a class="url" href="nsp-boxall502581-0013.xhtml#f03018">
     Figure 3-18
    </a>
    ) and a little math, you can turn your AVR into a thermometer. This inexpensive and easy-to-use analog sensor outputs a voltage that changes with the temperature around it.
   </p>
   <div class="figure" id="f03018">
    <p class="fig">
     <img alt="A TMP36 temperature sensor" src="images/nsp-boxall502581-f03018.jpg" class="calibre29"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 3-18:
      </span>
      The TMP36 temperature sensor
     </p>
    </div>
   </div>
   <p class="calibre8">
    The TMP36 has three legs. When you’re looking at the flat side of the sensor with the writing on it, the legs are (from left to right) voltage in, voltage out, and GND. You’ll connect pin 1 to the 5 V power in your projects, pin 2 to an analog input on the microcontroller, and pin 3 to GND.
    <a class="url" href="nsp-boxall502581-0013.xhtml#f03019">
     Figure 3-19
    </a>
    shows the schematic symbol for the TMP36.
   </p>
   <div class="figure" id="f03019">
    <p class="fig">
     <img alt="Schematic symbol for the TMP36 temperature sensor" height="1200" src="images/nsp-boxall502581-f03019.jpg" width="998" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 3-19:
      </span>
      Schematic symbol for the TMP36
     </p>
    </div>
   </div>
   <p class="calibre8">
    The voltage output from the TMP36 is a representation of the temperature around the sensor; for example, at 25 degrees Celsius, the output is 750 mV (or 0.75 V), and for every change of one degree, the voltage
    <span id="p87">
    </span>
    output changes by 10 mV. The TMP36 can measure temperatures from −40 to 125 degrees Celsius, but for the
    <a class="url" href="nsp-boxall502581-0013.xhtml#pro15">
     next project
    </a>
    you’ll just measure room temperatures.
   </p>
   <p class="calibre8">
    To determine the temperature from the voltage, multiply the value in ADC by 5, then divide by 1,024, which gives you the actual voltage returned by the sensor. Next, subtract 0.5 (0.5 V is the offset used by the TMP36 to allow for temperatures below 0) then multiply by 100, which gives you the temperature in degrees Celsius.
   </p>
   <p class="pcust">
    <span class="ccust">
     Note
    </span>
    If you want to work in Fahrenheit, multiply the Celsius value by 1.8 and add 32 to the result.
   </p>
   <p class="calibre8">
    As this is an analog device, the output voltage is determined by the input voltage. If you don’t have 5 V or very close to 5 V on the input, your output and thus the temperature reading will not be correct.
   </p>
   <p class="hd" id="pro15">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro15">
     <span class="ccust1">
      Project 15: Creating a Digital Thermometer
     </span>
    </a>
   </p>
   <p class="paft">
    In this project, you’ll use what you learned from
    <a class="url" href="nsp-boxall502581-0013.xhtml#pro12">
     Project 12
    </a>
    to create a numeric display with the ADC on the ATmega328P-PU that acts as a digital thermometer. To keep things simple, this project will display temperatures starting from 0 degrees Celsius and going up; negative readings are not included.
   </p>
   <div class="chapter">
    <h3 class="bh" id="bh0517">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0517">
      The Hardware
     </a>
    </h3>
    <p class="paft">
     To build your thermometer, you’ll read the TMP36 analog temperature sensor with the microcontroller, which will then display the temperature one digit at a time using the seven-segment LED display from
     <a class="url" href="nsp-boxall502581-0013.xhtml#pro12">
      Project 12
     </a>
     .
    </p>
    <p class="calibre8">
     You’ll need the following hardware:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • USBasp programmer
     </li>
     <li class="bl">
      • Solderless breadboard
     </li>
     <li class="bl">
      • 5 V breadboard power supply
     </li>
     <li class="bl">
      • ATmega328P-PU microcontroller
     </li>
     <li class="bl">
      • One TMP36 temperature sensor
     </li>
     <li class="bl">
      • One common-cathode seven-segment LED display
     </li>
     <li class="bl">
      • Seven 560
      <span lang="el" xml:lang="el">
       Ω
      </span>
      resistors (R1–R7)
     </li>
     <li class="bl">
      • 0.1
      <span lang="el" xml:lang="el">
       μF
      </span>
      ceramic capacitor
     </li>
     <li class="bll">
      • Jumper wires
     </li>
    </ul>
    <p class="calibre8">
     <span id="p88">
     </span>
     Assemble your circuit as shown in
     <a class="url" href="nsp-boxall502581-0013.xhtml#f03020">
      Figure 3-20
     </a>
     .
    </p>
    <div class="figure" id="f03020">
     <p class="fig">
      <img alt="Schematic diagram for Project 15" height="1070" src="images/nsp-boxall502581-f03020.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 3-20:
       </span>
       Schematic for
       <a class="url" href="nsp-boxall502581-0013.xhtml#pro15">
        Project 15
       </a>
      </p>
     </div>
    </div>
    <p class="calibre8">
     You’ll use the 0.1
     <span lang="el" xml:lang="el">
      μF
     </span>
     capacitor to help maintain a smooth power supply to the TMP36 temperature sensor; it should be mounted as close as possible to the TMP36’s 5 V and GND pins.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh0518">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0518">
      The Code
     </a>
    </h3>
    <p class="paft">
     Open a terminal window, navigate to the
     <i class="calibre5">
      Project 15
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 3
     </i>
     folder, and enter the command
     <code class="b">
      make flash
     </code>
     to upload the code for
     <a class="url" href="nsp-boxall502581-0013.xhtml#pro15">
      Project 15
     </a>
     as usual. Once you’ve uploaded the code, the LED module should display the approximate temperature one digit at a time. For example, if the temperature were 8 degrees Celsius, the display would show a 0, followed by a short delay, and then an 8.
    </p>
    <p class="calibre8">
     To see how this works, open the
     <i class="calibre5">
      main.c
     </i>
     file for
     <a class="url" href="nsp-boxall502581-0013.xhtml#pro15">
      Project 15
     </a>
     and take a look at the code:
    </p>
    <div class="codeline">
     <p class="clf">
      // Project 15 - Creating a Digital Thermometer
     </p>
     <p class="cl2f">
      <!--<ccust1>1</ccust1>-->
      ❶ #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;math.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="cl2f">
      <span id="p89">
      </span>
      <!--<ccust1>2</ccust1>-->
      ❷ void startADC()
     </p>
     <p class="cl">
      // Set up the ADC
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      ADMUX |= (1 &lt;&lt; REFS0);                 // Use AVcc pin with  ADC
     </p>
     <p class="cl">
      ADMUX |= (1 &lt;&lt; MUX2) | (1 &lt;&lt; MUX0);    // Use ADC5 (pin 28)
     </p>
     <p class="cl">
      ADCSRA |= (1 &lt;&lt; ADPS1) | (1 &lt;&lt; ADPS0); // Prescaler for 1MHz (/8)
     </p>
     <p class="cl">
      ADCSRA |= (1 &lt;&lt; ADEN);                 // enable ADC}
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>3</ccust1>-->
      ❸ void displayNumber(uint8_t value)
     </p>
     <p class="cl">
      // Displays a number from 0–9 on the seven-segment LED display
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      switch(value)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      case 0 : PORTB = 0b00111111; break; // 0
     </p>
     <p class="cl">
      case 1 : PORTB = 0b00110000; break; // 1
     </p>
     <p class="cl">
      case 2 : PORTB = 0b01011011; break; // 2
     </p>
     <p class="cl">
      case 3 : PORTB = 0b01111001; break; // 3
     </p>
     <p class="cl">
      case 4 : PORTB = 0b01110100; break; // 4
     </p>
     <p class="cl">
      case 5 : PORTB = 0b01101101; break; // 5
     </p>
     <p class="cl">
      case 6 : PORTB = 0b01101111; break; // 6
     </p>
     <p class="cl">
      case 7 : PORTB = 0b00111000; break; // 7
     </p>
     <p class="cl">
      case 8 : PORTB = 0b01111111; break; // 8
     </p>
     <p class="cl">
      case 9 : PORTB = 0b01111101; break; // 9
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>4</ccust1>-->
      ❹ uint8_t tens = 0;  // Holds tens digit for temperature
     </p>
     <p class="cl">
      uint8_t ones = 0;  // Holds ones digit for temperature
     </p>
     <p class="cl">
      float temperature;
     </p>
     <p class="cl">
      float voltage;
     </p>
     <p class="cl">
      uint16_t ADCvalue;
     </p>
     <p class="cl">
      uint8_t finalTemp;
     </p>
     <p class="clf">
      DDRB = 0b11111111; // Set PORTB to outputs
     </p>
     <p class="cl">
      DDRC = 0b00000000; // Set PORTC to inputs
     </p>
     <p class="cl">
      startADC();
     </p>
     <p class="cl">
      for(;;)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>5</ccust1>-->
      ❺ // Take reading from TMP36 via ADC
     </p>
     <p class="cl">
      ADCSRA |= (1 &lt;&lt; ADSC);         // Start ADC measurement
     </p>
     <p class="cl">
      while (ADCSRA &amp; (1 &lt;&lt; ADSC) ); // Wait for conversion to finish
     </p>
     <p class="cl">
      _delay_ms(10);
     </p>
     <p class="clf">
      // Get value from ADC register, store in ADCvalue
     </p>
     <p class="cl">
      ADCvalue = ADC;
     </p>
     <p class="clf">
      <!--<ccust1>6</ccust1>-->
      ❻ // Convert reading to temperature value (Celsius)
     </p>
     <p class="cl">
      voltage = (ADCvalue * 5);
     </p>
     <p class="cl">
      voltage = voltage / 1024;
     </p>
     <p class="cl">
      temperature = ((voltage - 0.5) * 100);
     </p>
     <p class="clf">
      <!--<ccust1>7</ccust1>-->
      ❼ // Display temperature on LED module
     </p>
     <p class="cl">
      <span id="p90">
      </span>
      finalTemp = (uint8_t) round(temperature);
     </p>
     <p class="clf">
      tens = finalTemp / 10;
     </p>
     <p class="cl">
      ones = finalTemp % 10;
     </p>
     <p class="clf">
      <!--<ccust1>8</ccust1>-->
      ❽ displayNumber(tens);  // Display tens digit
     </p>
     <p class="cl">
      _delay_ms(250);
     </p>
     <p class="cl">
      displayNumber(ones);  // Display ones digit
     </p>
     <p class="cl">
      _delay_ms(250);
     </p>
     <p class="clf">
      <!--<ccust1>9</ccust1>-->
      ❾ // Turn off the LED display in preparation for the next reading
     </p>
     <p class="cl">
      PORTB = 0b00000000;
     </p>
     <p class="cl">
      _delay_ms(1000);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      return 0;
     </p>
     <p class="cll">
      }
     </p>
    </div>
    <p class="calibre8">
     In this code, we first include the necessary libraries (among them,
     <i class="calibre5">
      math.h
     </i>
     , for the floating-point math)
     <!--<ccust1>1</ccust1>-->
     ❶. We add the function
     <code class="calibre23">
      startADC()
     </code>
     to start the ADC
     <!--<ccust1>2</ccust1>-->
     ❷ (this function is called at the start of the main part of the code), and we reuse the
     <code class="calibre23">
      displayNumber()
     </code>
     function from
     <a class="url" href="nsp-boxall502581-0013.xhtml#pro12">
      Project 12
     </a>
     <!--<ccust1>3</ccust1>-->
     ❸.
    </p>
    <p class="calibre8">
     In the main section of the code, we declare the required variables, define the input and output pins, and initialize the ADC
     <!--<ccust1>4</ccust1>-->
     ❹. The main loop of the code is broken into five steps:
    </p>
    <ol class="calibre10">
     <li class="blf">
      1. The voltage from the TMP36 is measured by the ADC and stored in the variable
      <code class="calibre23">
       ADCvalue
      </code>
      <!--<ccust1>5</ccust1>-->
      ❺.
     </li>
     <li class="bl">
      2. Using the formula described in “Introducing the TMP36 Temperature Sensor,” the code converts the value of the ADC to a voltage. This voltage is then converted to the temperature in degrees Celsius
      <!--<ccust1>6</ccust1>-->
      ❻.
     </li>
     <li class="bl">
      3. The digits used to represent the temperature are extracted from
      <code class="calibre23">
       finalTemp
      </code>
      and then rounded up or down to the nearest whole number with
      <code class="calibre23">
       round()
      </code>
      . The code determines the left digit (for tens) by dividing the temperature by 10. If the temperature is less than 10 degrees, this will be 0. It determines the right digit (for ones) by taking the remainder from dividing the temperature by 10 with modulo
      <!--<ccust1>7</ccust1>-->
      ❼.
     </li>
     <li class="bl">
      4. The
      <code class="calibre23">
       displayNumber()
      </code>
      function is used to display the tens and ones digits of the temperature, respectively, with a quarter-second delay between the digits
      <!--<ccust1>8</ccust1>-->
      ❽.
     </li>
     <li class="bll">
      5. Finally, the display is turned off for a second
      <!--<ccust1>9</ccust1>-->
      ❾, giving a visual break between the displayed value and the new value to come.
     </li>
    </ol>
    <p class="calibre8">
     This seemingly complex project just combines your existing knowledge in new ways, which I hope is starting to fire up your imagination. In
     <a class="url" href="nsp-boxall502581-0014.xhtml#ch04">
      Chapter 4
     </a>
     , we’ll turn to a new topic: enabling bidirectional communication between your microcontroller and a PC for the purposes of data capture and control.
    </p>
   </div>
  </div>
 </div>
</div></body></html>