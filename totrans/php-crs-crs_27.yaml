- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 22 STRUCTURING AN OBJECT-ORIENTED WEB APPLICATION
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding chapter, we used object- oriented PHP code to create a simple
    two-page website controlled from an Application class. In this chapter, we’ll
    revisit that website and explore how to further leverage OOP techniques to improve
    its structure. You’ll learn how to use multiple classes to compartmentalize the
    application logic, and you’ll see how inheritance can help share code among those
    classes to cut down on redundancy.
  prefs: []
  type: TYPE_NORMAL
- en: Dividing the application logic across multiple classes will help make the site
    more manageable. This may seem trivial for a two-page website, but imagine if
    the site grew to include tens, hundreds, or thousands of pages. The Application
    class would quickly become unwieldy. It would be imperative to organize the code
    into different types of actions and assign those actions to different classes.
  prefs: []
  type: TYPE_NORMAL
- en: For our application in [Chapter 21](chapter21.xhtml), two main types of actions
    need to be performed. The first is deciding what to do when a request comes into
    the web server. We can assign this task to a front-controller class that will
    examine each incoming request, including its URL pattern and any data variables
    received, and decide which type of page is appropriate to be returned to the web
    client.
  prefs: []
  type: TYPE_NORMAL
- en: The other main action is displaying the requested page. We can assign this task
    to a range of page-generating controller classes. One such class might be designed
    for displaying basic pages (such as home and Contact Us), another for displaying
    pages with security features like logging in and updating passwords, another for
    product listings, and so on. Each of these page-controller classes can operate
    knowing that the front controller has already made the decision to return the
    appropriate page.
  prefs: []
  type: TYPE_NORMAL
- en: Separating Display and Front-Controller Logic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s start the process of improving our application architecture by separating
    the front-controller decision logic (in the Application class) from the basic
    page-generation actions for the home page and Contact Us page. We’ll move the
    latter into a new class called DefaultController. The name reflects that the home
    page is the default page displayed when the URL pattern / is requested, but the
    class could also reasonably be named BasicPageController, HomePageController,
    or something similar.
  prefs: []
  type: TYPE_NORMAL
- en: Copy *src/Application.php*, name the copy *src/DefaultController.php*, and delete
    the run() method from this new DefaultController class. Also make the homepage()
    and contactUs() methods public so that they can still be called from the Application
    class. After these changes, the file should match [Listing 22-1](#lis22-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 22-1: Declaring the DefaultController class'
  prefs: []
  type: TYPE_NORMAL
- en: This new DefaultController class has a constant for the path to the template
    files, a twig property for rendering the templates, a constructor method, and
    homepage() and contactUs() methods for displaying the two pages of the web application.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve encapsulated the logic for displaying the web pages in a separate
    class, we can simplify the Application class to focus only on deciding which page
    to display. All we need to keep in Application is the run() method, which will
    determine which page to display and invoke the corresponding DefaultController
    method. Update *src/Application.php* as shown in [Listing 22-2](#lis22-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 22-2: The simplified Application class'
  prefs: []
  type: TYPE_NORMAL
- en: Our updated Application class’s only content, the run() method, begins by creating
    a new DefaultController object. Then, in the switch statement, we invoke either
    that object’s contactUs() method ❶ or homepage() method ❷ to display the appropriate
    page based on the action received in the HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this new arrangement, Application is functioning as a true front controller:
    it receives requests from the client and decides how to respond. Meanwhile, the
    code that generates and prints a response has been delegated to the DefaultController
    class. For our simple two-page site, this may seem like software architecture
    overkill, but for more sophisticated websites, this separation of front-controller
    logic from page-generation logic means that when we add methods for many pages,
    we won’t end up with a single, overcrowded Application class trying to do too
    many things.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, say we have some pages that can be accessed only by a logged-in
    user. We could encapsulate the methods for displaying these pages in a SecureActions
    controller class. Then we would check whether the user is logged in within the
    front-controller Application class and invoke methods of SecureActions only if
    the user is logged in. Otherwise, we could offer the user an error page or login
    page as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Another example of the value of separating front-controller actions from page
    controllers is testing the incoming URL patterns for data parameters. Let’s say
    some of the pages of our website display news items by using a NewsItem page controller
    class. The methods of this class need the ID of the news item to be retrieved
    from a database or file store, based on a URL pattern such as */?action=news&id=<id>*.
    In this case, our front controller can check for an integer ID along with the
    news action, then pass that ID to an appropriate NewsItem object method. If no
    such integer ID is found in the URL, we can offer the user an error page instead.
  prefs: []
  type: TYPE_NORMAL
- en: In both of these examples, the methods in the page-controller classes can be
    written knowing that any required checks and decisions (determining whether the
    user is logged in or retrieving a news item ID) have already taken place and been
    satisfied. We’re separating the decision of *what to do* (the front controller)
    from the actions that define *how we do it* (the page-controller class methods).
  prefs: []
  type: TYPE_NORMAL
- en: Using Multiple Controller Classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our DefaultController class works well for displaying simple pages with static
    content such as the home page, but pages with other features would benefit from
    being organized within their own specialized controller classes. For example,
    an e-commerce site would likely have several kinds of pages related to products:
    a list of all available products, search results showing products that match a
    particular user query, pages showing the details of a single product, and so on.
    Each of these pages would likely need a way of interacting with objects of a Product
    class, perhaps passed to the page templates in a $products array or a single $product
    object.'
  prefs: []
  type: TYPE_NORMAL
- en: Our DefaultController class isn’t currently equipped to handle these kinds of
    product-related operations. We could extend and modify the class, but a more logical
    approach would be to create a separate ProductController class to handle the specialized
    operations required to display pages related to products. Similarly, pages that
    include login forms might have their own LoginController class, pages for displaying
    and editing a shopping cart would have their own CartController class, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate the benefit of multiple controller classes, and to demonstrate
    how easy it is to add more pages and sections to an object-oriented web application,
    we’ll add a Product List page to our website, as shown in [Figure 22-1](#fig22-1),
    and we’ll create a ProductController class for displaying this page.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure22-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 22-1: The Product List page we’ll create'
  prefs: []
  type: TYPE_NORMAL
- en: Our new page will display the name and price of a collection of products, where
    each product is an instance (object) of a Product class. Using Twig template inheritance,
    we’ll give the page the same navigation bar and header content as the other pages
    of the website. We’ll coordinate the page’s display from our new ProductController
    class, which will be designed specifically to gather Product objects in an array
    that can be passed to the Twig template.
  prefs: []
  type: TYPE_NORMAL
- en: To build the new page, we’ll first create the Product class to represent each
    product’s name and price. Create a new file, *src/Product.php*, containing the
    code in [Listing 22-3](#lis22-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 22-3: The Product class'
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare two public properties for each Product object: name and price. Then
    we declare a constructor method ❶ that will take in initial values for each of
    these properties when creating a new Product object.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a Product class, we can create the ProductController class
    for displaying the page. Create a new *src/ProductController.php* file as shown
    in [Listing 22-4](#lis22-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 22-4: The src/ProductController.php file declaring the ProductController
    class'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ProductController class’s constructor method is similar to that of the
    DefaultController class: it performs the setup necessary for working with the
    Twig templates. What distinguishes this controller from the other is its productList()
    method for displaying the new Product List page.'
  prefs: []
  type: TYPE_NORMAL
- en: Within that method, we create three Product objects and package them into a
    $products array ❶. Then we set the $template variable to 'productList.xhtml.twig',
    the new Twig template file we’ll create to list all the products. We next construct
    the $args array. It maps the 'products' key (which will become a Twig variable
    name) to $products, our array of Product objects ❷. Then we pass the $template
    and $args variables to Twig to generate the HTML needed for the page ❸.
  prefs: []
  type: TYPE_NORMAL
- en: We next need to update the front-controller logic in our Application class to
    call the ProductController class’s productList() method when the value of action
    in the URL is products. Update *src/Application.php* to match [Listing 22-5](#lis22-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 22-5: Updating the Application class to handle the products case'
  prefs: []
  type: TYPE_NORMAL
- en: In the run() method, we create $productController, a variable referencing a
    new ProductController object ❶. Then we add a new case to the switch statement
    ❷. When the action in the URL has the value products, we’ll send a message to
    our ProductController object to invoke its productList() method.
  prefs: []
  type: TYPE_NORMAL
- en: We can now write the Twig template to loop through and display the provided
    array of products. Create the new Twig template file *templates/productList.xhtml.twig*
    as shown in [Listing 22-6](#lis22-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 22-6: The productList.xhtml.twig template'
  prefs: []
  type: TYPE_NORMAL
- en: Like our other page templates, this one inherits from *base.xhtml.twig*, giving
    it access to all the content shared across pages. We’re therefore able to focus
    on just filling in the blocks from that base template that need to be customized.
    First, we override the pageTitle Twig block with the text Product List. Then we
    override the productsLink Twig block with the text active to highlight this page’s
    link in the navigation bar (we’ll add a new navigation bar link to the base template
    next).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we override the main Twig block with the page-specific body content. The
    centerpiece of this content is a loop through all the Product objects in the products
    Twig array variable to generate the items of an HTML definition list ❶. The name
    of each product is declared as the definition term (<dt>), and the definition
    data element (<dd>) is the price of the product, formatted to two decimal places
    by using the Twig number_format filter. If the products array is empty, a Twig
    else statement will display an appropriate message.
  prefs: []
  type: TYPE_NORMAL
- en: Our final action to get our Product List page working is to add a new item to
    its navigation bar in the base template. Update *templates/base.xhtml.twig* to
    match [Listing 22-7](#lis22-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 22-7: Adding the product list link to the base.xhtml.twig template'
  prefs: []
  type: TYPE_NORMAL
- en: We add a third item to the navigation bar for the Product List page. As with
    the other links, we include a class attribute containing a Twig block named productsLink
    so the link can be styled active as needed.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now added a Product List page to our website. In the new ProductController
    class, our productList() method creates an array of objects and uses the Twig
    template *templates/productList.xhtml.twig* to create the HTML for the page. Adding
    a new navigation link to our base Twig template was easy. Clicking that link creates
    a GET request with action=products. In our Application class front controller,
    an instance of the ProductController is created so that when this value of action
    is found in the request URL, the productList() method can be invoked. In all,
    the majority of the new code for this product list feature is well organized in
    its own controller class and corresponding Twig template.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing Controller Features Through Inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As a last step, let’s use the OOP principle of inheritance to streamline our
    controller classes. Right now, DefaultController and ProductController share several
    lines of identical code: both declare a PATH_TO_TEMPLATES constant, have a private
    twig property, and have identical constructor methods to create a Twig\Environment
    object. If we were to create more controller classes (for login security, shopping
    carts, and so on), they would also need this identical code.'
  prefs: []
  type: TYPE_NORMAL
- en: To avoid all this repetition, we’ll take the common properties and behaviors
    all controller classes should have and make them part of a general Controller
    superclass. The individual controller classes, such as DefaultController and ProductController,
    will inherit from this superclass and extend it with their own unique properties
    and methods. [Figure 22-2](#fig22-2) shows a diagram of the class structure we’ll
    create.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure22-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 22-2: The Controller superclass and its DefaultController and ProductController
    subclasses'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll declare our new Controller class as abstract, meaning we can never actually
    create a Controller object. This is fitting since the Controller class exists
    only to store the general code that all controllers should have and to be subclassed
    by the specific controller classes we’ll want to instantiate. Remember, declaring
    a class abstract is a way to tell other programmers (and yourself in the future)
    that you don’t want the class to be instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 22-2](#fig22-2), notice the plus signs (+) denoting public methods
    and constants, as well as the hash mark (#) next to the twig property in the Controller
    superclass, which indicates this property has protected visibility, not public
    or private. We wouldn’t want this twig property to be public, since it could be
    incorrectly changed or used by any code in the web application with access to
    a Controller object or one of its subclasses. However, if we were to make the
    twig property private, the code in the methods of our subclasses wouldn’t have
    access to it either. This would be a problem, since using Twig to render templates
    is a core behavior of all our controller classes.
  prefs: []
  type: TYPE_NORMAL
- en: Giving the twig property protected visibility ensures that subclasses of Controller
    can access it, while preventing direct access by any code outside the Controller
    class hierarchy. This is a useful real-world example of the inheritance concepts
    we examined in [Chapter 19](chapter19.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Listing 22-8 shows the code for the Controller superclass. Create *src/Controller.php*
    containing the code from this listing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 22-8: The Controller superclass'
  prefs: []
  type: TYPE_NORMAL
- en: We declare the class to be abstract so it can’t be instantiated ❶, and we designate
    the twig property as protected so it will be available to the subclasses ❷. Otherwise,
    this code is identical to the code at the start of our DefaultController and ProductController
    classes. Now that this code lives in the Controller class, the redundant parts
    can be removed. [Listing 22-9](#lis22-9) shows the much-simplified DefaultController
    class code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 22-9: The simplified DefaultController class, a subclass of Controller'
  prefs: []
  type: TYPE_NORMAL
- en: We declare that DefaultController extends the Controller class, allowing it
    to inherit the constructor and twig property. Thanks to this inheritance, DefaultController
    now has only two methods of its own, for displaying the home page and Contact
    Us templates. We can similarly streamline the ProductController class code, as
    shown in [Listing 22-10](#lis22-10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 22-10: The simplified ProductController class, a subclass of Controller'
  prefs: []
  type: TYPE_NORMAL
- en: Again, we use extends Controller when declaring the class so that ProductController
    will inherit from Controller. The only method specific to the subclass is productList()
    for displaying the Product List page.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now successfully used inheritance to abstract the common twig property
    and its initialization into a Controller superclass. This has simplified the two
    page-controller classes, while still providing exactly the same functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we improved the architecture of our object-oriented web application.
    We separated the overall front-controller logic governing the site, located in
    the Application class, from the page-controller logic for displaying the individual
    web pages. The latter is divided between an abstract Controller superclass, which
    contains the Twig setup code required for displaying any web page, and multiple
    subclasses containing just the code for logic specific to displaying particular
    kinds of pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example site in this chapter has only three pages: a home page, a Contact
    Us page, and a Product List page. However, the architecture demonstrated in this
    chapter can easily be scaled up for complex websites with hundreds or thousands
    of pages and complex features like session interactions, shopping carts, login
    security, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.   Make a copy of the project from this chapter and add a fourth page for
    a privacy policy. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: a.   Create a *privacy.xhtml.twig* template.
  prefs: []
  type: TYPE_NORMAL
- en: b.   Add a new privacyPolicy() method to the DefaultController class that displays
    the new template.
  prefs: []
  type: TYPE_NORMAL
- en: c.   Add a Privacy Policy navigation bar link in the *base.xhtml.twig* template
    with the URL ?action=privacy.
  prefs: []
  type: TYPE_NORMAL
- en: d.   Add a new case to the switch statement in the run() method of the Application
    class that invokes the privacyPolicy() method of the DefaultController object
    if the value of action in the URL is privacy.
  prefs: []
  type: TYPE_NORMAL
- en: '2.   Make a copy of your project from Exercise 1, and add a fifth page for
    listing company staff. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: a.   Create a Staff class to represent staff details, including firstName, lastName,
    and email properties.
  prefs: []
  type: TYPE_NORMAL
- en: b.   Create a new subclass of Controller named StaffController. Give it a list()
    method that creates two or three staff objects and passes them as an array to
    the Twig render() method, along with the template name *staff.xhtml.twig*.
  prefs: []
  type: TYPE_NORMAL
- en: c.   Add a new Staff List navigation bar link in the *base.xhtml.twig* template
    with the URL ?action=staffList.
  prefs: []
  type: TYPE_NORMAL
- en: d.   Create a *staff.xhtml.twig* template, based on the *productList.xhtml.twig*
    template, that uses Twig code to loop through and print out each Staff object
    in the received array.
  prefs: []
  type: TYPE_NORMAL
- en: e.   In the run() method of the Application class, create a new $staffController
    object that’s an instance of the StaffController class. Then add a new switch
    statement case that calls $staffController->list() if the value of action in the
    URL is staffList.
  prefs: []
  type: TYPE_NORMAL
