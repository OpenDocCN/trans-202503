<html><head></head><body>
		<h2 class="h2" id="ch13"><span epub:type="pagebreak" id="page_451"/><strong><span class="big">13</span></strong><br/><strong>CONTROL STRUCTURES AND PROGRAMMATIC DECISIONS</strong></h2>&#13;
		<div class="image1">&#13;
			<img alt="image" src="../images/common01.jpg"/>&#13;
		</div>&#13;
		<p class="noindent">Control structures are the bread and butter of high-level language (HLL) programming. The ability to make decisions based on the evaluation of stated conditions is fundamental to practically every kind of automation that computers provide. The translation of HLL control structures into machine code has, perhaps, the largest impact on program performance and size. As you’ll see in this chapter, knowing which control structures to use in a given situation is the key to writing great code. In particular, this chapter describes the machine implementation of control structures related to decision making and unconditional flow, including:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent"><code>if</code> statements</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent"><code>switch</code> or <code>case</code> statements</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent"><code>goto</code> and related statements</p>&#13;
				</li>&#13;
		</ul>&#13;
		<p class="indent">The following two chapters will expand this discussion to loop control structures and procedure/function calls and returns.</p>&#13;
		<h3 class="h3" id="ch00lev1sec109"><span epub:type="pagebreak" id="page_452"/><strong>13.1 How Control Structures Affect a Program’s Efficiency</strong></h3>&#13;
		<p class="noindent">A fair percentage of the machine instructions in a program control the execution path through that program. Because control transfer instructions often flush the instruction pipeline (see <em>WGC1</em>), they tend to be slower than instructions that perform simple calculations. To produce efficient programs, you should reduce the number of control transfer instructions or, if that’s not possible, choose the fastest ones.</p>&#13;
		<p class="indent">The exact set of instructions that CPUs use to control program flow varies across processors. Nevertheless, many CPUs (including the five families covered in this book) control program flow using the “compare-and-jump” paradigm. That is, after a compare or another instruction that modifies the CPU flags, a conditional jump instruction transfers control to another location based on the CPU flag settings. Some CPUs can do all this with a single instruction, while others require two, three, or more. Some CPUs allow you to compare two values for a large range of different conditions, whereas others allow only a few tests. Regardless of the mechanism, HLL statements that map to a given sequence on one CPU will map to a comparable sequence on a second CPU. Therefore, if you understand the basic conversion for one CPU, you’ll have a good idea how the compiler works across all CPUs.</p>&#13;
		<h3 class="h3" id="ch00lev1sec110"><strong>13.2 Introduction to Low-Level Control Structures</strong></h3>&#13;
		<p class="noindent">Most CPUs use a two-step process to make a programmatic decision. First, the program compares two values and saves the result of the comparison in a machine register or flag. Then the program tests that result and, based on what it learns, transfers control to one of two locations. With little more than this <em>compare and conditional branch</em> sequence, it is possible to synthesize most of the major HLL control structures.</p>&#13;
		<p class="indent">Even within the compare and conditional branch paradigm, CPUs commonly implement conditional code sequences using two different approaches. One technique, especially common on stack-based architectures (such as the UCSD p-machine, Java Virtual Machine, and Microsoft CLR), is to have different forms of the compare instruction that test for specific conditions. For example, you might have <em>compare if equal</em>, <em>compare if not equal</em>, <em>compare if less than</em>, <em>compare if greater than</em>, and so on. The result of each is a Boolean value. Then a pair of conditional branch instructions, <em>branch if true</em> and <em>branch if false</em>, can test the result of the comparison and transfer control to the appropriate location. Some of these VMs might actually merge the compare and branch instructions into “compare and branch” instructions (one for each condition to test). Despite using fewer instructions, the end result is exactly the same.</p>&#13;
		<p class="indent">The second, and historically more popular, approach is for the CPU’s instruction set to contain a single comparison instruction that sets (or clears) several bits in the CPU’s <em>program status</em> or <em>flags</em> register. Then the program uses one of several more specific conditional branch instructions to transfer control to some other location. These conditional branch instructions might have names such as <em>jump if equal</em>, <em>jump if not equal</em>, <em>jump if <span epub:type="pagebreak" id="page_453"/>less than</em>, or <em>jump if greater than</em>. Because this “compare and jump” technique is the one the 80x86, ARM, and PowerPC use, that’s also the approach this chapter’s examples use; however, it’s easy to convert them to the multiple comparisons/jump true/jump false paradigm.</p>&#13;
		<p class="indent">The 32-bit variants of the ARM processor introduce a third technique: conditional execution. Most instructions (not just the branches) on the 32-bit ARM provide this option. For example, the <code>addeq</code> instruction adds two values if and only if the result of the previous comparison (or other operation) has set the zero flag. See “Conditional Suffixes for Instructions” in Appendix C online for more details.</p>&#13;
		<p class="indent">Conditional branches are typically two-way branches. That is, they transfer control to one location in the program if the condition they’re testing is <code>true</code> and to a different location if the condition is <code>false</code>. To reduce the size of the instruction, the conditional branches on most CPUs encode the address of only one of the two possible branch locations, and they use an implied address for the opposite condition. Specifically, most conditional branches transfer control to some target location if the condition is <code>true</code> and fall through to the next instruction if the condition is <code>false</code>. For example, consider the following 80x86 <code>je</code> (jump if equal) instruction sequence:</p>&#13;
		<pre class="programs">&#13;
			// Compare the value in EAX to the value in EBX<br/><br/>        cmp( eax, ebx );<br/><br/>// Branch to label EAXequalsEBX if EAX==EBX<br/><br/>        je EAXequalsEBX;<br/><br/>        mov( 4, ebx );      // Drop down here if EAX != EBX<br/>            .<br/>            .<br/>            .<br/>EAXequalsEBX:</pre>&#13;
		<p class="indent">This instruction sequence begins by comparing the value in the EAX register against the value in EBX (the <code>cmp</code> instruction); this sets the <em>condition-code bits</em> in the 80x86 EFLAGS register. In particular, this instruction sets the 80x86 zero flag to <code>1</code> if the value in EAX is equal to the value in EBX. The <code>je</code> instruction tests the zero flag to see if it is set, and if so, transfers control to the machine instruction immediately following the <code>EAXequalsEBX</code> label. If the value in EAX is not equal to EBX, then the <code>cmp</code> instruction clears the zero flag and the <code>je</code> instruction falls through to the <code>mov</code> instruction rather than transferring control to the destination label.</p>&#13;
		<p class="indent">Certain machine instructions that access data can be smaller (and faster) if the memory location the machine instruction accesses is near the base address of the activation record containing that variable. This rule also applies to conditional jump instructions. The 80x86 provides two forms of the conditional jump instructions. One form is only 2 bytes long (1 byte for an opcode and 1 byte for a signed displacement in the range –128 through +127). The other form is 6 bytes long (2 bytes for the opcode <span epub:type="pagebreak" id="page_454"/>and 4 bytes for a signed displacement in the range –2 billion through +2 billion). The displacement value specifies how far (in bytes) the program must jump to reach the target location. To transfer control to a nearby location, the program can use the short form of the branch. Because 80x86 instructions are between 1 and 15 bytes long (typically around 3 or 4 bytes long), the short forms of the conditional jump instructions can usually skip over about 32 to 40 machine instructions. Once the target location is out of the ±127-byte range, the 6-byte version of these conditional jump instructions extends the range to ±2 billion bytes around the current instruction. If you’re interested in writing the most efficient code, then, you’ll want to use the 2-byte form as often as possible.</p>&#13;
		<p class="indent">Branching is an expensive operation in a modern (pipelined) CPU because a branch may require the CPU to flush the pipeline and reload it (see <em>WGC1</em> for more details). Conditional branches incur this cost only if the branch is taken; if the conditional branch instruction falls through to the next instruction, the CPU will continue to use the instructions found in the pipeline without flushing them. Therefore, on many systems the <em>branch that falls through to the next instruction is faster than the branch that is taken</em>. Note, however, that some CPUs (like the 80x86, PowerPC, and ARM) support a <em>branch prediction</em> feature that tells the CPU to begin fetching instructions for the pipeline from the branch’s target location rather than from the instructions that immediately follow the conditional jump. Unfortunately, branch prediction algorithms vary from processor to processor (even within the 80x86 CPU family), so it’s difficult to predict, in general, how branch prediction will affect your HLL code. It’s probably safest to assume, unless you’re writing code for a specific processor, that falling through to the next instruction is more efficient than taking the jump.</p>&#13;
		<p class="indent">Although the compare and conditional branch paradigm is the most common control structure found in machine code programs, there are other ways to transfer control to another location in memory based on some computed result. Without question, the indirect jump (especially via a table of addresses) is the most common alternative form. Consider the following 32-bit 80x86 <code>jmp</code> instruction:</p>&#13;
		<pre class="programs">&#13;
			readonly<br/>    jmpTable: dword[4] := [&amp;label1, &amp;label2, &amp;label3, &amp;label4];<br/>            .<br/>            .<br/>            .<br/>        jmp( jmpTable[ ebx*4 ] );</pre>&#13;
		<p class="indent">This <code>jmp</code> instruction fetches the double-word value at the index specified by the value in EBX in the <code>jmpTable</code> array. That is, the instruction transfers control to one of four different locations based upon the value (<code>0..3</code>) in EBX. For example, if EBX contains <code>0</code>, then the <code>jmp</code> instruction fetches the double word at index <code>0</code> in <code>jmpTable</code> (the address of the instruction prefixed by <code>label1</code>). Likewise, if EBX contains <code>2</code>, then this <code>jmp</code> instruction fetches the third double word from this table (the address of <code>label3</code> in the <span epub:type="pagebreak" id="page_455"/>program). This is roughly equivalent to, but usually shorter than, the following sequence of instructions:</p>&#13;
		<pre class="programs">&#13;
			cmp( ebx, 0 );<br/>je label1;<br/>cmp( ebx, 1 );<br/>je label2;<br/>cmp( ebx, 2 );<br/>je label3;<br/>cmp( ebx, 3 );<br/>je label4;<br/><br/>// Results are undefined if EBX &lt;&gt; 0, 1, 2, or 3</pre>&#13;
		<p class="indent">A few other conditional control transfer mechanisms are available on various CPUs, but these two mechanisms (compare and conditional branch and indirect jump) are the ones most HLL compilers use to implement standard control structures in the HLL.</p>&#13;
		<h3 class="h3" id="ch00lev1sec111"><strong>13.3 The goto Statement</strong></h3>&#13;
		<p class="noindent">The <code>goto</code> statement is, perhaps, the most fundamental low-level control structure. Since the wave of “structured programming” in the late 1960s and 1970s, its use in HLL code has diminished. Indeed, some modern high-level programming languages (for example, Java and Swift) don’t even provide an unstructured <code>goto</code> statement. Even in those languages where one is available, programming style guidelines usually restrict its use to special circumstances. Combined with the fact that student programmers have been religiously taught to avoid them in their programs since the mid 1970s, it’s now rare to find many <code>goto</code> statements in a modern program. From a readability point of view, this is a good thing (check out some 1960sera FORTRAN programs to get an idea of how hard to read code can be when it’s peppered with <code>goto</code> statements). Nevertheless, some programmers believe that they can achieve higher efficiency by using <code>goto</code> statements in their code. While this is sometimes true, the gains are rarely worth the loss of readability that ultimately occurs.</p>&#13;
		<p class="indent">One of the big efficiency arguments for <code>goto</code> is that it helps avoid duplicate code. Consider the following simple C/C++ example:</p>&#13;
		<pre class="programs">&#13;
			if( a == b || c &lt; d )<br/>{<br/>    &lt;&lt; execute some number of statements &gt;&gt;<br/><br/>    if( x == y )<br/>    {<br/>        &lt;&lt; execute some statements if x == y &gt;&gt;<br/>    }<br/>    else<br/>    {<br/>        &lt;&lt; execute some statements if x != y &gt;&gt;<br/><span epub:type="pagebreak" id="page_456"/>    }<br/>}<br/>else<br/>{<br/>    &lt;&lt; execute the same sequence of statements<br/>       that the code executes if x!= y in the<br/>       previous else section &gt;&gt;<br/>}</pre>&#13;
		<p class="indent">Programmers looking for ways to make their programs more efficient will immediately notice all the duplicated code and might be tempted to rewrite the example as follows:</p>&#13;
		<pre class="programs">&#13;
			if( a == b || c &lt; d )<br/>{<br/>    &lt;&lt; execute some number of statements &gt;&gt;<br/><br/>    if( x != y ) goto DuplicatedCode;<br/><br/>    &lt;&lt; execute some statements if x == y &gt;&gt;<br/>}<br/>else<br/>{<br/>DuplicatedCode:<br/>    &lt;&lt; execute the same sequence of statements<br/>       if x != y or the original<br/>       Boolean expression is false &gt;&gt;<br/>}</pre>&#13;
		<p class="indent">There are, of course, several software engineering problems with this code, including the fact that it is a bit harder to read, modify, and maintain than the original example. (You <em>could</em> argue that it’s actually a little easier to maintain, because you no longer have duplicated code and you only have to fix defects in the common code at one spot.) However, there’s no denying that there’s less code in this example. Or is there?</p>&#13;
		<p class="indent">The optimizers in many modern compilers actually look for code sequences like the first example and generate code that’s identical to what you’d expect for the second example. Therefore, a <em>good</em> compiler avoids generating duplicate machine code even when the source file contains duplication, as in the first example.</p>&#13;
		<p class="indent">Consider the following C/C++ example:</p>&#13;
		<pre class="programs">&#13;
			#include &lt;stdio.h&gt;<br/><br/>static int a;<br/>static int b;<br/><br/>extern int x;<br/>extern int y;<br/>extern int f( int );<br/>extern int g( int );<br/><span epub:type="pagebreak" id="page_457"/>int main( void )<br/>{<br/>    if( a==f(x))<br/>    {<br/>        if( b==g(y))<br/>        {<br/>            a=0;<br/>        }<br/>        else<br/>        {<br/>            printf( "%d %d\n", a, b );<br/>            a=1;<br/>            b=0;<br/>        }<br/>    }<br/>    else<br/>    {<br/>        printf( "%d %d\n", a, b );<br/>        a=1;<br/>        b=0;<br/>    }<br/><br/>    return( 0 );<br/>}</pre>&#13;
		<p class="indent">Here’s the compilation of the <code>if</code> sequence to PowerPC code by GCC:</p>&#13;
		<pre class="programs">&#13;
			        ; f(x):<br/><br/>        lwz r3,0(r9)<br/>        bl L_f$stub<br/><br/>        ; Compute a==f(x), jump to L2 if false<br/><br/>        lwz r4,0(r30)<br/>        cmpw cr0,r4,r3<br/>        bne+ cr0,L2<br/><br/>        ; g(y):<br/><br/>        addis r9,r31,ha16(L_y$non_lazy_ptr-L1$pb)<br/>        addis r29,r31,ha16(_b-L1$pb)<br/>        lwz r9,lo16(L_y$non_lazy_ptr-L1$pb)(r9)<br/>        la r29,lo16(_b-L1$pb)(r29)<br/>        lwz r3,0(r9)<br/>        bl L_g$stub<br/><br/>        ; Compute b==g(y), jump to L3 if false:<br/><br/>        lwz r5,0(r29)<br/>        cmpw cr0,r5,r3<br/>        bne- cr0,L3<br/><br/>        ; a=0<br/><span epub:type="pagebreak" id="page_458"/>        li r0,0<br/>        stw r0,0(r30)<br/>        b L5<br/><br/>        ; Set up a and b parameters if<br/>        ; a==f(x) but b!=g(y):<br/><br/>L3:<br/>        lwz r4,0(r30)<br/>        addis r3,r31,ha16(LC0-L1$pb)<br/>        b L6<br/><br/>        ; Set up parameters if a!=f(x):<br/>L2:<br/>        addis r29,r31,ha16(_b-L1$pb)<br/>        addis r3,r31,ha16(LC0-L1$pb)<br/>        la r29,lo16(_b-L1$pb)(r29)<br/>        lwz r5,0(r29)<br/><br/>        ; Common code shared by both<br/>        ; ELSE sections:<br/>L6:<br/>        la r3,lo16(LC0-L1$pb)(r3) ; Call printf<br/>        bl L_printf$stub<br/>        li r9,1                 ; a=1<br/>        li r0,0                 ; b=0<br/>        stw r9,0(r30)           ; Store a<br/>        stw r0,0(r29)           ; Store b<br/>L5:</pre>&#13;
		<p class="indent">Of course, not every compiler has an optimizer that will recognize the duplicated code. So, if you want to write a program that compiles to efficient machine code regardless of the compiler, you might be tempted to use the version of the code that employs the <code>goto</code> statement. Indeed, you could make a strong software engineering argument that having duplicate code in a source file makes the program harder to read and harder to maintain. (If you fix a defect in one copy of the code, chances are that you’ll forget to correct the defect in the other copies of the code.) While this is definitely true, if you make changes to the code at the target label, it’s not immediately obvious that the change is appropriate for each and every section of code that jumps to the target label. And it’s not immediately obvious how many different <code>goto</code> statements transfer control to the same target label when you’re reading through the source code.</p>&#13;
		<p class="indent">The traditional software engineering approach is to put the common code into a procedure or function and simply call that function. However, the overhead of a function call and return can be rather large (especially if there isn’t much duplicated code), so from a performance point of view, that approach may not be satisfactory. For short sequences of common code, creating a macro or an inline function is probably the best solution. To complicate the issue, you might need a change that affects only one instance of the duplicated code (that is, it would no longer be a duplicate). <span epub:type="pagebreak" id="page_459"/>The bottom line is that using a <code>goto</code> statement to gain efficiency in this manner should be your last resort.</p>&#13;
		<p class="indent">Another common use for <code>goto</code> statements is for exceptional conditions. When you find yourself nested deeply in several statements and you encounter a situation where you need to exit all those statements, the common consensus is that a <code>goto</code> is acceptable if restructuring the code wouldn’t make it more readable. However, jumps out of nested blocks may thwart the optimizer’s ability to generate decent code for the entire procedure or function. The use of the <code>goto</code> statement may save a few bytes or processor cycles in the code it immediately affects, but it could have detrimental effects on the rest of the function, resulting in less efficient code overall. So, take care when inserting <code>goto</code> statements into your code—they can make your source code harder to read, and might wind up making it less efficient as well.</p>&#13;
		<p class="indent">For what it’s worth, there’s a programming trick you can use to solve the original problem. Consider the following modification to the code:</p>&#13;
		<pre class="programs">&#13;
			switch( a == b || c &lt; d )<br/>{<br/>    case 1:<br/>        &lt;&lt; execute some number of statements &gt;&gt;<br/><br/>        if( x == y )<br/>        {<br/>            &lt;&lt; execute some statements if x == y &gt;&gt;<br/>            break;<br/>        }<br/>        // Fall through if x != y<br/><br/>    case 0:<br/><br/>        &lt;&lt; execute some statements if x!= y or<br/>            if !( a == b || c &lt; d )  &gt;&gt;<br/>}</pre>&#13;
		<p class="noindent">Of course, this is tricky code, and tricky code isn’t usually great code. However, it does have the benefit of avoiding duplication of source code in your program.</p>&#13;
		<h4 class="h4" id="ch00lev2sec167"><strong>13.3.1 Restricted Forms of the goto Statement</strong></h4>&#13;
		<p class="noindent">In an effort to support structured <code>goto</code>-less programming, many programming languages have added restricted forms of the <code>goto</code> statement that allow a programmer to immediately exit a control structure such as a loop or a procedure/function. Typical statements include <code>break</code> and <code>exit</code>, which jump out of an enclosing loop; <code>continue</code>, <code>cycle</code>, and <code>next</code>, which restart an enclosing loop; and <code>return</code> and <code>exit</code>, which immediately return from an enclosing procedure or function. These statements are more structured than a standard <code>goto</code> because the programmer doesn’t choose the destination; instead, control transfers to a fixed location based upon whatever control statement (or function or procedure) encloses the statement.</p>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_460"/>Almost every one of these statements compiles into a single <code>jmp</code> instruction. Those that jump out of a loop (such as <code>break</code>) compile into a single <code>jmp</code> instruction that transfers control to the first statement beyond the bottom of the loop. Those that restart a loop (for example, <code>continue</code>, <code>next</code>, or <code>cycle</code>) compile into a single <code>jmp</code> instruction that transfers control to the loop termination test (in the case of while or <code>repeat..until</code>/<code>do..while</code>) or to the top of the loop (in the case of most other loops).</p>&#13;
		<p class="indent">However, just because these statements typically compile to a single <code>jmp</code> instruction doesn’t mean they’re efficient to use. Even ignoring the fact that a <code>jmp</code> can be somewhat expensive (because it forces the CPU to flush the instruction pipeline), statements that branch out of a loop can have a serious impact on the compiler’s optimizer, dramatically reducing the opportunity to generate high-quality code. Therefore, you should attempt to use these statements as sparingly as possible.</p>&#13;
		<h3 class="h3" id="ch00lev1sec112"><strong>13.4 The if Statement</strong></h3>&#13;
		<p class="noindent">Perhaps the most basic high-level control structure is the <code>if</code> statement. Indeed, with nothing more than an <code>if</code> and a <code>goto</code> statement, you can (semantically) implement all other control structures.<sup><a id="ch13fn_1"/><a href="footnotes.xhtml#ch13fn1">1</a></sup> We’ll revisit this point when discussing other control structures, but for now we’ll look at how a typical compiler converts an <code>if</code> statement into machine code.</p>&#13;
		<p class="indent">To implement a simple <code>if</code> statement that compares two values and executes the body if the condition is <code>true</code>, you can use a single compare and conditional branch instruction. Consider the following Pascal <code>if</code> statement:</p>&#13;
		<pre class="programs">&#13;
			if( EAX = EBX ) then begin<br/><br/>    writeln( 'EAX is equal to EBX' );<br/>    i := i + 1;<br/><br/>end;</pre>&#13;
		<p class="indent">Here’s the conversion to 80x86/HLA code:</p>&#13;
		<pre class="programs">&#13;
			    cmp( EAX, EBX );<br/>    jne skipIfBody;<br/>    stdout.put( "EAX is equal to EBX", nl );<br/>    inc( i );<br/>skipIfBody:</pre>&#13;
		<p class="indent">In the Pascal source code, the body of the <code>if</code> statement executes if the value of EAX is equal to EBX. In the resulting assembly code, the program compares EAX with EBX and then, if EAX does not equal EBX, branches over the statements that correspond to the <code>if</code> statement’s body. This is the <span epub:type="pagebreak" id="page_461"/>“boilerplate” conversion of an HLL <code>if</code> statement into machine code: test some condition and, if it’s <code>false</code>, branch over the <code>if</code> statement’s body.</p>&#13;
		<p class="indent">The implementation of an <code>if..then..else</code> statement is only slightly more complicated than the basic <code>if</code> statement. An <code>if..then..else</code> statement typically employs syntax and semantics such as the following:</p>&#13;
		<pre class="programs">&#13;
			if( <span class="codeitalic1">some_boolean_expression</span> ) then<br/><br/>    &lt;&lt; Statements to execute if the expression is true &gt;&gt;<br/><br/>else<br/><br/>    &lt;&lt; Statements to execute if the expression is false &gt;&gt;<br/><br/>endif</pre>&#13;
		<p class="indent">Implementing this code sequence in machine code requires only a single machine instruction beyond what a simple <code>if</code> statement requires. Consider this example C/C++ code:</p>&#13;
		<pre class="programs">&#13;
			if( EAX == EBX )<br/>{<br/>    printf( "EAX is equal to EBX\n" );<br/>    ++i;<br/>}<br/>else<br/>{<br/>    printf( "EAX is not equal to EBX\n" );<br/>}</pre>&#13;
		<p class="indent">Here is the conversion to 80x86 assembly language code:</p>&#13;
		<pre class="programs">&#13;
			    cmp( EAX, EBX );        // See if EAX == EBX<br/>    jne doElse;             // Branch around "then" code<br/>    stdout.put( "EAX is equal to EBX", nl );<br/>    inc( i );<br/>    jmp skipElseBody;        // Skip over "else" section.<br/><br/>// if they are not equal.<br/><br/>doElse:<br/>    stdout.put( "EAX is not equal to EBX", nl );<br/><br/>skipElseBody:</pre>&#13;
		<p class="indent">There are two things to note about this code. First, if the condition evaluates to <code>false</code>, the code transfers to the first statement of the <code>else</code> block rather than the first statement following the (entire) <code>if</code> statement. The second thing to note is the <code>jmp</code> instruction at the end of the <code>true</code> clause skips the <code>else</code> block.</p>&#13;
		<p class="indent">Some languages, including HLA, support an <code>elseif</code> clause in their <code>if</code> statement to evaluate a second condition if the first one fails. This is a <span epub:type="pagebreak" id="page_462"/>straightforward extension of the code generation of the <code>if</code> statement I’ve shown. Consider the following HLA <code>if..elseif..else..endif</code> statements:</p>&#13;
		<pre class="programs">&#13;
			if( EAX = EBX ) then<br/><br/>    stdout.put( "EAX is equal to EBX" nl );<br/>    inc( i );<br/><br/>elseif( EAX = ECX ) then<br/><br/>    stdout.put( "EAX is equal to ECX" nl );<br/><br/>else<br/><br/>    stdout.put( "EAX is not equal to EBX or ECX" nl);<br/><br/>endif;</pre>&#13;
		<p class="noindent">And here’s the conversion to pure 80x86/HLA assembly language code:</p>&#13;
		<pre class="programs">&#13;
			// Test to see if EAX = EBX<br/><br/>    cmp( eax, ebx );<br/>    jne tryElseif;    // Skip "then" section if equal<br/><br/>    // Start of the "then" section<br/><br/>    stdout.put( "EAX is equal to EBX", nl );<br/>    inc( i );<br/>    jmp skipElseBody  // End of "then" section, skip<br/>                      // over the elseif clause.<br/>tryElseif:<br/>    cmp( eax, ecx );  // ELSEIF test for EAX = ECX<br/>    jne doElse;       // Skip "then" clause if not equal<br/><br/>    // elseif "then" clause<br/><br/>    stdout.put( "EAX is equal to ECX", nl );<br/>    jmp skipElseBody; // Skip over the "else" section<br/><br/>doElse: // else clause begins here<br/>    stdout.put( "EAX is not equal to EBX or ECX", nl );<br/><br/>skipElseBody:</pre>&#13;
		<p class="indent">The translation of the <code>elseif</code> clause is very straightforward; the machine code for it is identical to an <code>if</code> statement. What’s noteworthy here is how the compiler emits a <code>jmp</code> instruction at the end of the <code>if..then</code> clause to skip around the Boolean test emitted for the <code>elseif</code> clause.</p>&#13;
		<h4 class="h4" id="ch00lev2sec168"><span epub:type="pagebreak" id="page_463"/><strong>13.4.1 Improving the Efficiency of Certain if/else Statements</strong></h4>&#13;
		<p class="noindent">From an efficiency point of view, it’s important to note that there’s no path through the <code>if..else</code> statement that doesn’t involve a transfer of control (unlike the simple <code>if</code> statement, which simply falls through if the conditional expression is <code>true</code>). As this chapter has pointed out, branches are bad because they often flush the CPU’s instruction pipeline, which takes several CPU cycles to refill. If both outcomes of the Boolean expression (<code>true</code> and <code>false</code>) are equally likely, there’s little you can do to improve the code’s performance by rearranging the <code>if..else</code> statement. For most <code>if</code> statements, however, one outcome is often more likely—perhaps much more likely—than the other. Assembly coders who understand the likelihood of one comparison over another will often encode their <code>if..else</code> statements as follows:</p>&#13;
		<pre class="programs">&#13;
			// if( eax == ebx ) then<br/>//    //&lt;likely case&gt;<br/>//    stdout.put( "EAX is equal to EBX", nl );<br/>// else<br/>//    // unlikely case<br/>//    stdout.put( "EAX is not equal to EBX" nl );<br/>// endif;<br/><br/>    cmp( EAX, EBX );<br/>    jne goDoElse;<br/>    stdout.put( "EAX is equal to EBX", nl );<br/>backFromElse:<br/>        .<br/>        .<br/>        .<br/>// Somewhere else in the code (not in the direct path of the above):<br/><br/>goDoElse:<br/>    stdout.put( "EAX is not equal to EBX", nl );<br/>    jmp backFromElse</pre>&#13;
		<p class="indent">Note that in the most common case (where the expression evaluates to <code>true</code>), the code falls through to the <code>then</code> section, which then falls straight through to the code that follows the entire <code>if</code> statement. Therefore, if the Boolean expression (<code>eax == ebx</code>) is <code>true</code> most of the time, this code executes straight through without any branches. In the rare case, when EAX does not equal EBX, the program actually has to execute two branches: one to transfer control to the section of code that handles the <code>else</code> clause, and one to return control to the first statement following the <code>if</code>. As long as this occurs less than half of the time, the software sees an overall performance boost. You can achieve this same result in an HLL such as C using <code>goto</code> statements. For example:</p>&#13;
		<pre class="programs">&#13;
			if( eax != ebx ) goto doElseStuff;<br/><br/>    // &lt;&lt; body of the if statement goes here&gt;&gt;<br/>    // (statements between then and else)<br/><span epub:type="pagebreak" id="page_464"/>endOfIF:<br/>// &lt;&lt; statements following the if..endif statement &gt;&gt;<br/>    .<br/>    .<br/>    .<br/>// Somewhere outside the direct execution path of the above<br/><br/>doElseStuff:<br/>    &lt;&lt; Code to do if the expression is false &gt;&gt;<br/>    goto endOfIF;</pre>&#13;
		<p class="indent">Of course, the drawback to this scheme is that it produces <em>spaghetti code</em> that becomes unreadable once you add more than a few of these kludges. Assembly language programmers get away with this because most assembly language code is, by definition, spaghetti code.<sup><a id="ch13fn_2"/><a href="footnotes.xhtml#ch13fn2">2</a></sup> For HLL code, however, this programming style is generally unacceptable, and you should use it only when necessary. (See “The <code>goto</code> Statement” on <a href="ch13.xhtml#page_455">page 455</a>.)</p>&#13;
		<p class="indent">The following generic <code>if</code> statement is common in programs written in HLLs such as C:</p>&#13;
		<pre class="programs">&#13;
			if( eax == ebx )<br/>{<br/>    // Set i to some value along this execution path.<br/><br/>    i = j+5;<br/>}<br/>else<br/>{<br/>    // Set i to a different value along this path<br/><br/>    i = 0;<br/>}</pre>&#13;
		<p class="indent">Here’s the conversion of this C code into 80x86/HLA assembly code:</p>&#13;
		<pre class="programs">&#13;
			        cmp( eax, ebx );<br/>        jne doElse;<br/>        mov( j, edx );<br/>        add( 5, edx );<br/>        mov( edx, i );<br/>        jmp ifDone;<br/><br/>doElse:<br/>        mov( 0, i );<br/>ifDone:</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_465"/>As you’ve seen in previous examples, the <code>if..then..else</code> statement conversion to assembly language requires two control transfer instructions:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent">The <code>jne</code> instruction that tests the comparison between EAX and EBX</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">The unconditional <code>jmp</code> instruction that skips over the <code>else</code> section of the <code>if</code> statement</p>&#13;
				</li>&#13;
		</ul>&#13;
		<p class="indent">Regardless of which path the program takes (through the <code>then</code> or the <code>else</code> section), the CPU executes a slow branch instruction that winds up flushing the instruction pipeline. Consider the following code, which does not have this problem:</p>&#13;
		<pre class="programs">&#13;
			i = 0;<br/>if( eax == ebx )<br/>{<br/>    i = j + 5;<br/>}</pre>&#13;
		<p class="indent">Here is its conversion to pure 80x86/HLA assembly code:</p>&#13;
		<pre class="programs">&#13;
			        mov( 0, i );<br/>        cmp( eax, ebx );<br/>        jne skipIf;<br/>        mov( j, edx );<br/>        add( 5, edx );<br/>        mov( edx, i );<br/>skipIf:</pre>&#13;
		<p class="indent">As you can see, if the expression evaluates to <code>true</code>, the CPU executes no control transfer statements at all. Yes, the CPU executes an extra <code>mov</code> instruction whose result is immediately overwritten (so the execution of the first <code>mov</code> instruction is wasted); however, the execution of this extra <code>mov</code> instruction happens much more rapidly than the execution of the <code>jmp</code> instruction. This trick is a prime example of why it’s a good idea to know some assembly language code (and know how compilers generate machine code from high-level code). It’s not at all obvious that the second sequence is better than the first. Beginning programmers, in fact, would probably believe it to be inferior because the program “wastes” an assignment to <code>i</code> when the expression evaluates to <code>true</code> (and no such assignment is made in the first version). This is one reason why this chapter exists—to make sure you understand the costs associated with using high-level control structures.</p>&#13;
		<h4 class="h4" id="ch00lev2sec169"><strong>13.4.2 Forcing Complete Boolean Evaluation in an if Statement</strong></h4>&#13;
		<p class="noindent">Because complete Boolean evaluation and short-circuit Boolean evaluation can produce different results (see “Short-Circuit Evaluation” on <a href="ch12.xhtml#page_441">page 441</a>), there are times when you’ll need to force your code to use one form or the other when computing the result of a Boolean expression.</p>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_466"/>The general way to force complete Boolean evaluation is to evaluate each subcomponent of the expression and store the subresult into temporary variables. Then you can combine the temporary results after their computation to produce the complete result. For example, consider the following Pascal code fragment:</p>&#13;
		<pre class="programs">&#13;
			if( (i &lt; g(y)) and (k &gt; f(x)) ) then begin<br/><br/>    i := 0;<br/><br/>end;</pre>&#13;
		<p class="indent">Because Pascal doesn’t guarantee complete Boolean evaluation, function <code>f()</code> might not be called in this expression—if <code>i</code> is less than <code>g(y)</code>—and thus any side effects produced by the call to <code>f()</code> might not occur. (See “Side Effects in Arithmetic Expressions” on <a href="ch12.xhtml#page_430">page 430</a>.) If the logic of the application depends on any side effects produced by the calls to <code>f()</code> and <code>g()</code>, then you must ensure that the application calls both functions. Note that simply swapping the two subexpressions around the AND operator is insufficient to solve this problem; with that change, the application might not call <code>g()</code>.</p>&#13;
		<p class="indent">One way to solve this problem is to compute the Boolean results of the two subexpressions using separate assignment statements and then compute the logical AND of the two results within the <code>if</code> expression:</p>&#13;
		<pre class="programs">&#13;
			lexpr := i &lt; g(y);<br/>rexpr := k &gt; f(x);<br/>if( lexpr AND rexpr ) then begin<br/><br/>    i := 0;<br/><br/>end;</pre>&#13;
		<p class="indent">Don’t be too concerned about the efficiency loss that could result from using these temporary variables. Any compiler that provides optimization facilities will put these values into registers and not bother using actual memory locations. Consider the following variant of the previous Pascal program written in C and compiled with the Visual C++ compiler:</p>&#13;
		<pre class="programs">&#13;
			#include &lt;stdio.h&gt;<br/><br/>static int i;<br/>static int k;<br/><br/>extern int x;<br/>extern int y;<br/>extern int f( int );<br/>extern int g( int );<br/><br/>int main( void )<br/>{<br/>    int lExpr;<br/><span epub:type="pagebreak" id="page_467"/>    int rExpr;<br/><br/>    lExpr = i &lt; g(y);<br/>    rExpr = k &gt; f(x);<br/>    if( lExpr &amp;&amp; rExpr )<br/>    {<br/>        printf( "Hello" );<br/>    }<br/><br/>    return( 0 );<br/>}</pre>&#13;
		<p class="indent">Here’s the conversion to 32-bit MASM code by the Visual C++ compiler (a few instructions have been rearranged to make their intent clearer):</p>&#13;
		<pre class="programs">&#13;
			main    PROC<br/><br/>$LN7:<br/>        mov     QWORD PTR [rsp+8], rbx<br/>        push    rdi<br/>        sub     rsp, 32                                 ; 00000020H<br/><br/>; eax = g(y)<br/>        mov     ecx, DWORD PTR y<br/>        call    g<br/>; ebx (lExpr) = i &lt; g(y)<br/>        xor     edi, edi<br/>        cmp     DWORD PTR i, eax<br/>        mov     ebx, edi ; ebx = 0<br/>        setl    bl ;if i &lt; g(y), set EBX to 1.<br/><br/>; eax = f(x)<br/>        mov     ecx, DWORD PTR x<br/>        call    f<br/><br/>; EDI = k &gt; f(x)<br/><br/>        cmp     DWORD PTR k, eax<br/>        setg    dil ; Sets EDI to 1 if k &gt; f(x)<br/><br/>; See if lExpr is false:<br/><br/>        test    ebx, ebx<br/>        je      SHORT $LN4@main<br/><br/>; See if rExpr is false:<br/><br/>        test    edi, edi<br/>        je      SHORT $LN4@main<br/><br/>; "then" section of the if statement:<br/><br/>        lea     rcx, OFFSET FLAT:$SG7893<br/>        call    printf<br/><span epub:type="pagebreak" id="page_468"/><br/>$LN4@main:<br/><br/>; return(0);<br/>        xor     eax, eax<br/><br/>        mov     rbx, QWORD PTR [rsp+48]<br/>        add     rsp, 32                                 ; 00000020H<br/>        pop     rdi<br/>        ret     0<br/>main    ENDP</pre>&#13;
		<p class="indent">If you scan the assembly code, you’ll see that this code fragment always executes the calls to both <code>f()</code> and <code>g()</code>. Contrast this with the following C code and assembly output:</p>&#13;
		<pre class="programs">&#13;
			#include &lt;stdio.h&gt;<br/><br/>static int i;<br/>static int k;<br/><br/>extern int x;<br/>extern int y;<br/>extern int f( int );<br/>extern int g( int );<br/><br/>int main( void )<br/>{<br/>    if( i &lt; g(y) &amp;&amp; k &gt; f(x) )<br/>    {<br/>        printf( "Hello" );<br/>    }<br/><br/>    return( 0 );<br/>}</pre>&#13;
		<p class="indent">Here’s the MASM assembly output:</p>&#13;
		<pre class="programs">&#13;
			main    PROC<br/><br/>$LN7:<br/>        sub     rsp, 40                                 ; 00000028H<br/><br/>; if (!(i &lt; g(y))) then bail on the rest of the code:<br/><br/>        mov     ecx, DWORD PTR y<br/>        call    g<br/>        cmp     DWORD PTR i, eax<br/>        jge     SHORT $LN4@main<br/><br/>; if (!(k &gt; f(x))) then skip printf:<br/><br/>        mov     ecx, DWORD PTR x<br/>        call    f<br/>        cmp     DWORD PTR k, eax<br/><span epub:type="pagebreak" id="page_469"/>        jle     SHORT $LN4@main<br/><br/>; Here's the body of the if statement.<br/><br/>        lea     rcx, OFFSET FLAT:$SG7891<br/>        call    printf<br/>$LN4@main:<br/><br/>; return 0<br/>        xor     eax, eax<br/><br/>        add     rsp, 40                                 ; 00000028H<br/>        ret     0<br/>main    ENDP</pre>&#13;
		<p class="indent">In C, you can use another trick to force complete Boolean evaluation in any Boolean expression. The C bitwise operators do not support short-circuit Boolean evaluation. If your subexpressions in a Boolean expression always produce <code>0</code> or <code>1</code>, the bitwise Boolean conjunction and disjunction operators (that is, <code>&amp;</code> and <code>|</code>) produce identical results to the logical Boolean operators (<code>&amp;&amp;</code> and <code>||</code>). Consider the following C code and the MASM code that the Visual C++ compiler produces:</p>&#13;
		<pre class="programs">&#13;
			#include &lt;stdio.h&gt;<br/><br/>static int i;<br/>static int k;<br/><br/>extern int x;<br/>extern int y;<br/>extern int f( int );<br/>extern int g( int );<br/><br/>int main( void )<br/>{<br/>    if( i &lt; g(y) &amp; k &gt; f(x) )<br/>    {<br/>        printf( "Hello" );<br/>    }<br/>    return( 0 );<br/>}</pre>&#13;
		<p class="indent">Here’s the MASM code emitted by Visual C++:</p>&#13;
		<pre class="programs">&#13;
			main    PROC<br/><br/>$LN6:<br/>        mov     QWORD PTR [rsp+8], rbx<br/>        push    rdi<br/>        sub     rsp, 32                                 ; 00000020H<br/><br/>        mov     ecx, DWORD PTR x<br/>        call    f<br/><span epub:type="pagebreak" id="page_470"/>        mov     ecx, DWORD PTR y<br/>        xor     edi, edi<br/>        cmp     DWORD PTR k, eax<br/>        mov     ebx, edi<br/>        setg    bl<br/>        call    g<br/>        cmp     DWORD PTR i, eax<br/>        setl    dil<br/>        test    edi, ebx<br/>        je      SHORT $LN4@main<br/><br/>        lea     rcx, OFFSET FLAT:$SG7891<br/>        call    printf<br/>$LN4@main:<br/><br/>        xor     eax, eax<br/><br/>        mov     rbx, QWORD PTR [rsp+48]<br/>        add     rsp, 32                                 ; 00000020H<br/>        pop     rdi<br/>        ret     0<br/>main    ENDP</pre>&#13;
		<p class="indent">Note how the use of the bitwise operators produces comparable code to the earlier sequence that used temporary variables. This creates less clutter in your original C source file.</p>&#13;
		<p class="indent">Do keep in mind, however, that C’s bitwise operators produce the same results as the logical operators <em>only</em> if the operands are <code>0</code> and <code>1</code>. Fortunately, you can use a little C trick here: just write <code>!!(<span class="codeitalic1">expr</code>)</span>, and if the expression’s value is zero or nonzero, C will convert the result to <code>0</code> or <code>1</code>. To see this in action, consider the following C/C++ code fragment:</p>&#13;
		<pre class="programs">&#13;
			#include &lt;stdlib.h&gt;<br/>#include &lt;math.h&gt;<br/>#include &lt;stdio.h&gt;<br/><br/>int main( int argc, char **argv )<br/>{<br/>    int boolResult;<br/><br/>    boolResult = !!argc;<br/>    printf( "!!(argc) = %d\n", boolResult );<br/>    return 0;<br/>}</pre>&#13;
		<p class="indent">Here’s the 80x86 assembly code that Microsoft’s Visual C++ compiler produces for this short program:</p>&#13;
		<pre class="programs">&#13;
			main    PROC<br/>$LN4:<br/>        sub     rsp, 40      ; 00000028H<br/><br/>        xor     edx, edx     ; EDX = 0<br/><span epub:type="pagebreak" id="page_471"/>        test    ecx, ecx     ; System passes ARGC in ECX register<br/>        setne   dl           ; If ECX==0, sets EDX=1, else EDX=0<br/><br/>        lea     rcx, OFFSET FLAT:$SG7886 ; Zero flag unchanged!<br/>        call    printf       ; printf parm1 in RCX, parm2 in EDX<br/><br/>; Return 0;<br/>        xor     eax, eax<br/><br/>        add     rsp, 40                   ; 00000028H<br/>        ret     0<br/>main    ENDP</pre>&#13;
		<p class="noindent">As you can see in the 80x86 assembly output, only three machine instructions (involving no expensive branches) are needed to convert zero/nonzero to <code>0</code>/<code>1</code>.</p>&#13;
		<h4 class="h4" id="ch00lev2sec170"><strong>13.4.3 Forcing Short-Circuit Evaluation in an if Statement</strong></h4>&#13;
		<p class="noindent">Although it’s useful to be able to force complete Boolean evaluation on occasion, needing to force short-circuit evaluation is probably more common. Consider the following Pascal statement:</p>&#13;
		<pre class="programs">&#13;
			if( (ptrVar &lt;&gt; NIL) AND (ptrVar^ &lt; 0) ) then begin<br/><br/>    ptrVar^ := 0;<br/><br/>end;</pre>&#13;
		<p class="indent">The Pascal language definition leaves it up to the compiler writer to decide whether to use complete Boolean evaluation or short-circuit evaluation. In fact, the writer is free to use both schemes as desired. Thus, it’s quite possible that the same compiler could use complete Boolean evaluation for the previous statement in one section of the code and short-circuit evaluation in another.</p>&#13;
		<p class="indent">You can see that this Boolean expression will fail if <code>ptrVar</code> contains the NIL pointer value and if the compiler uses complete Boolean evaluation. The only way to get this statement to work properly is by using short-circuit Boolean evaluation.</p>&#13;
		<p class="indent">Simulating short-circuit Boolean evaluation with the AND operator is actually quite simple. All you have to do is create a pair of nested <code>if</code> statements and place each subexpression in each one. For example, you could guarantee short-circuit Boolean evaluation in the current Pascal example by rewriting it as follows:</p>&#13;
		<pre class="programs">&#13;
			if( ptrVar &lt;&gt; NIL ) then begin<br/><br/>    if( ptrVar^ &lt; 0 ) then begin<br/><br/>        ptrVar^ := 0;<br/><span epub:type="pagebreak" id="page_472"/><br/>    end;<br/><br/>end;</pre>&#13;
		<p class="indent">This statement is semantically identical to the previous one. It should be clear that the second subexpression will not execute if the first expression evaluates to <code>false</code>. Even though this approach clutters up the source file a bit, it does guarantee short-circuit evaluation regardless of whether the compiler supports that scheme.</p>&#13;
		<p class="indent">Handling the logical-OR operation is a little more difficult. Guaranteeing that the right operand of a logical-OR does not execute if the left operand evaluates to <code>true</code> requires an extra test. Consider the following C code (remember that C supports short-circuit evaluation by default):</p>&#13;
		<pre class="programs">&#13;
			#include &lt;stdio.h&gt;<br/><br/>static int i;<br/>static int k;<br/><br/>extern int x;<br/>extern int y;<br/>extern int f( int );<br/>extern int g( int );<br/><br/>int main( void )<br/>{<br/>    if( i &lt; g(y) || k &gt; f(x) )<br/>    {<br/>        printf( "Hello" );<br/>    }<br/><br/>    return( 0 );<br/>}</pre>&#13;
		<p class="indent">Here’s the machine code that the Microsoft Visual C++ compiler produces:</p>&#13;
		<pre class="programs">&#13;
			main    PROC<br/><br/>$LN8:<br/>        sub     rsp, 40             ; 00000028H<br/><br/>        mov     ecx, DWORD PTR y<br/>        call    g<br/>        cmp     DWORD PTR i, eax<br/>        jl      SHORT $LN3@main<br/>        mov     ecx, DWORD PTR x<br/>        call    f<br/>        cmp     DWORD PTR k, eax<br/>        jle     SHORT $LN6@main<br/>$LN3@main:<br/><br/>        lea     rcx, OFFSET FLAT:$SG6880<br/><span epub:type="pagebreak" id="page_473"/>        call    printf<br/>$LN6@main:<br/><br/>        xor     eax, eax<br/><br/>        add     rsp, 40              ; 00000028H<br/>        ret     0<br/>main    ENDP<br/>_TEXT   ENDS</pre>&#13;
		<p class="indent">Here’s a version of the C program that implements short-circuit evaluation without relying on the C compiler to do so (not that this is necessary for C, as its language definition guarantees short-circuit evaluation, but you could use this approach in any language):</p>&#13;
		<pre class="programs">&#13;
			#include &lt;stdio.h&gt;<br/><br/>static int i;<br/>static int k;<br/><br/>extern int x;<br/>extern int y;<br/>extern int f( int );<br/>extern int g( int );<br/><br/>int main( void )<br/>{<br/>    int temp;<br/><br/>        // Compute left subexpression and<br/>        // save.<br/><br/>    temp = i &lt; g(y);<br/><br/>        // If the left subexpression<br/>        // evaluates to false, then try<br/>        // the right subexpression.<br/><br/>    if( !temp )<br/>    {<br/>        temp = k &gt; f(x);<br/>    }<br/><br/>        // If either subexpression evaluates<br/>        // to true, then print "Hello"<br/><br/>    if( temp )<br/>    {<br/>        printf( "Hello" );<br/>    }<br/><br/>    return( 0 );<br/>}</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_474"/>Here’s the corresponding MASM code emitted by the Microsoft Visual C++ compiler:</p>&#13;
		<pre class="programs">&#13;
			main    PROC<br/><br/>$LN9:<br/>        sub     rsp, 40         ; 00000028H<br/><br/>        mov     ecx, DWORD PTR y<br/>        call    g<br/>        xor     ecx, ecx<br/>        cmp     DWORD PTR i, eax<br/>        setl    cl<br/>        test    ecx, ecx<br/><br/>        jne     SHORT $LN7@main<br/><br/>        mov     ecx, DWORD PTR x<br/>        call    f<br/>        xor     ecx, ecx<br/>        cmp     DWORD PTR k, eax<br/>        setg    cl<br/>        test    ecx, ecx<br/><br/>        je      SHORT $LN5@main<br/>$LN7@main:<br/><br/>        lea     rcx, OFFSET FLAT:$SG6881<br/>        call    printf<br/>$LN5@main:<br/><br/>        xor     eax, eax<br/><br/>        add     rsp, 40            ; 00000028H<br/>        ret     0<br/>main    ENDP</pre>&#13;
		<p class="indent">As you can see, the code the compiler emits for the second version of the routine, which manually forces short-circuit evaluation, isn’t quite as good as that emitted by the C compiler for the first example. However, if you need the semantics for short-circuit evaluation so the program will execute correctly, you’ll have to live with possibly less efficient code than you’d get if the compiler supported this scheme directly.</p>&#13;
		<p class="indent">If speed, minimal size, and short-circuit evaluation are all necessary, and you’re willing to sacrifice a little readability and maintainability in your code to achieve them, then you can destructure the code and create something comparable to what the C compiler produces using short-circuit evaluation. Consider the following C code and the resulting output:</p>&#13;
		<pre class="programs">&#13;
			#include &lt;stdio.h&gt;<br/><br/>static int i;<br/><span epub:type="pagebreak" id="page_475"/>static int k;<br/><br/>extern int x;<br/>extern int y;<br/>extern int f( int );<br/>extern int g( int );<br/><br/>int main( void )<br/>{<br/>    if( i &lt; g(y)) goto IntoIF;<br/>    if( k &gt; f(x) )<br/>    {<br/>      IntoIF:<br/><br/>        printf( "Hello" );<br/>    }<br/><br/>    return( 0 );<br/>}</pre>&#13;
		<p class="indent">Here’s the MASM output from Visual C++:</p>&#13;
		<pre class="programs">&#13;
			main    PROC<br/><br/>$LN8:<br/>        sub     rsp, 40         ; 00000028H<br/><br/>        mov     ecx, DWORD PTR y<br/>        call    g<br/>        cmp     DWORD PTR i, eax<br/>        jl      SHORT $IntoIF$9<br/><br/>        mov     ecx, DWORD PTR x<br/>        call    f<br/>        cmp     DWORD PTR k, eax<br/>        jle     SHORT $LN6@main<br/>$IntoIF$9:<br/><br/>        lea     rcx, OFFSET FLAT:$SG6881<br/>        call    printf<br/>$LN6@main:<br/><br/>        xor     eax, eax<br/><br/>        add     rsp, 40         ; 00000028H<br/>        ret     0<br/>main    ENDP</pre>&#13;
		<p class="indent">If you compare this code to the MASM output for the original C example (which relies on short-circuit evaluation), you’ll see that this code is just as efficient. This is a classic example of why there was considerable resistance to structured programming in the 1970s among some <span epub:type="pagebreak" id="page_476"/>programmers—sometimes it leads to less efficient code. Of course, readability and maintainability are usually more important than a few bytes or machine cycles. But never forget that if performance is paramount for a small section of code, destructuring that code can improve efficiency in some special cases.</p>&#13;
		<h3 class="h3" id="ch00lev1sec113"><strong>13.5 The switch/case Statement</strong></h3>&#13;
		<p class="noindent">The <code>switch</code> (or <code>case</code>) high-level control statement is another conditional statement found in HLLs. As you’ve seen, an <code>if</code> statement tests a Boolean expression and executes one of two different paths in the code based on the result of the expression. A <code>switch/case</code> statement, on the other hand, can branch to one of several different points in the code based on the result of an ordinal (integer) expression. The following examples demonstrate the <code>switch</code> and <code>case</code> statements in C/C++, Pascal, and HLA. First, the C/C++ <code>switch</code> statement:</p>&#13;
		<pre class="programs">&#13;
			switch( <span class="codeitalic1">expression</span> )<br/>{<br/>  case 0:<br/>    &lt;&lt; statements to execute if the<br/>       expression evaluates to 0 &gt;&gt;<br/>    break;<br/><br/>  case 1:<br/>    &lt;&lt; statements to execute if the<br/>       expression evaluates to 1 &gt;&gt;<br/>    break;<br/><br/>  case 2:<br/>    &lt;&lt; statements to execute if the<br/>       expression evaluates to 2&gt;&gt;<br/>    break;<br/><br/>  &lt;&lt;etc&gt;&gt;<br/><br/>  default:<br/>    &lt;&lt; statements to execute if the expression is<br/>       not equal to any of these cases &gt;&gt;<br/>}</pre>&#13;
		<p class="indent">Java and Swift provide a similar syntax to C/C++ for the <code>switch</code> statement, although Swift’s version has many additional features. We’ll explore some of those additional features in the section “The Swift <code>switch</code> Statement” on <a href="ch13.xhtml#page_500">page 500</a>.</p>&#13;
		<p class="indent">Here’s an example of a Pascal <code>case</code> statement:</p>&#13;
		<pre class="programs">&#13;
			case ( expression ) of<br/>  0: begin<br/>    &lt;&lt; statements to execute if the<br/><span epub:type="pagebreak" id="page_477"/>       expression evaluates to 0 &gt;&gt;<br/>    end;<br/><br/>  1: begin<br/>    &lt;&lt; statements to execute if the<br/>       expression evaluates to 1 &gt;&gt;<br/>    end;<br/><br/>  2: begin<br/>    &lt;&lt; statements to execute if the<br/>       expression evaluates to 2&gt;&gt;<br/>    end;<br/><br/>  &lt;&lt;etc&gt;&gt;<br/><br/>  else<br/>    &lt;&lt; statements to execute if<br/>       REG32 is not equal to any of these cases &gt;&gt;<br/><br/>end; (* case *)</pre>&#13;
		<p class="indent">And finally, here’s the HLA <code>switch</code> statement:</p>&#13;
		<pre class="programs">&#13;
			switch( REG32 )<br/><br/>  case( 0 )<br/>    &lt;&lt; statements to execute if<br/>       REG32 contains 0 &gt;&gt;<br/><br/>  case( 1 )<br/>    &lt;&lt; statements to execute<br/>       REG32 contains 1 &gt;&gt;<br/><br/>  case( 2 )<br/>    &lt;&lt; statements to execute if<br/>       REG32 contains 2&gt;&gt;<br/><br/>  &lt;&lt;etc&gt;&gt;<br/><br/>  default<br/>    &lt;&lt; statements to execute if<br/>       REG32 is not equal to any of these cases &gt;&gt;<br/><br/>endswitch;</pre>&#13;
		<p class="indent">As you can tell by these examples, these statements all share a similar syntax.</p>&#13;
		<h4 class="h4" id="ch00lev2sec171"><strong>13.5.1 Semantics of a switch/case Statement</strong></h4>&#13;
		<p class="noindent">Most beginning programming classes and textbooks teach the semantics of the <code>switch</code>/<code>case</code> statement by comparing it with a chain of <code>if..else..if</code> statements; this introduces the <code>switch</code>/<code>case</code> statement using a concept the student <span epub:type="pagebreak" id="page_478"/>already understands. Unfortunately, this approach can be misleading. To see why, consider the following code, which an introductory Pascal programming book might claim is equivalent to our Pascal <code>case</code> statement:</p>&#13;
		<pre class="programs">&#13;
			if( expression = 0 ) then begin<br/><br/>  &lt;&lt; statements to execute if expression is 0 &gt;&gt;<br/><br/>end<br/>else if( expression = 1 ) then begin<br/><br/>  &lt;&lt; statements to execute if expression is 1 &gt;&gt;<br/><br/>end<br/>else if( expression = 2 ) then begin<br/><br/>  &lt;&lt; statements to execute if expression is 2 &gt;&gt;<br/><br/>end<br/>else<br/>  &lt;&lt; statements to execute if expression is not 1 or 2 &gt;&gt;<br/><br/>end;</pre>&#13;
		<p class="indent">Although this particular sequence will achieve the same result as the <code>case</code> statement, there are several fundamental differences between the <code>if..then..elseif</code> sequence and the Pascal <code>case</code> implementation. First, the case labels in a <code>case</code> statement must all be constants, but in an <code>if..then..elseif</code> chain you can actually compare variables and other nonconstant values against the control variable. Another limitation of the <code>switch</code>/<code>case</code> statement is that you can compare only the value of a single expression against a set of constants; you cannot compare one expression against a constant for one case and a separate expression against a second constant, as you can with an <code>if..then..elseif</code> chain. The reason for these limitations will become clear in a moment, but the takeaway here is that an <code>if..then..elseif</code> chain is semantically different from—and more powerful than—a <code>switch</code>/<code>case</code> statement.</p>&#13;
		<h4 class="h4" id="ch00lev2sec172"><strong>13.5.2 Jump Tables vs. Chained Comparisons</strong></h4>&#13;
		<p class="noindent">Although it is arguably more readable and convenient than an <code>if..then..elseif</code> chain, the <code>switch</code>/<code>case</code> statement was originally added to HLLs for efficiency, not readability or convenience. Consider an <code>if..then..elseif</code> chain with 10 separate expressions to test. If all the cases are mutually exclusive and equally likely, then on average the program will execute five comparisons before encountering an expression that evaluates to <code>true</code>. In assembly language, it’s possible to transfer control to one of several different locations in a fixed amount of time, independent of the number of cases, by using a table lookup and an indirect jump. Effectively, such code uses the value of the <code>switch</code>/<code>case</code> expression as an index into a table of addresses and then jumps (indirectly) to the statement specified by the table entry. When you have more than three or four cases, this scheme <span epub:type="pagebreak" id="page_479"/>is typically faster and consumes less memory than the corresponding <code>if..then..elseif</code> chain. Consider the following simple implementation of a <code>switch</code>/<code>case</code> statement in assembly language:</p>&#13;
		<pre class="programs">&#13;
			// Conversion of<br/>//    switch(i)<br/>//    { case 0:...case 1:...case 2:...case 3:...}<br/>// into assembly<br/><br/>static<br/>  jmpTable: dword[4] :=<br/>    [ &amp;label0, &amp;label1, &amp;label2, &amp;label3 ];<br/>      .<br/>      .<br/>      .<br/>    // jmps to address specified by jmpTable[i]<br/><br/>    mov( i, eax );<br/>    jmp( jmpTable[ eax*4 ] );<br/><br/>label0:<br/>    &lt;&lt; code to execute if i = 0 &gt;&gt;<br/>    jmp switchDone;<br/><br/>label1:<br/>    &lt;&lt; code to execute if i = 1 &gt;&gt;<br/>    jmp switchDone;<br/><br/>label2:<br/>    &lt;&lt; code to execute if i = 2 &gt;&gt;<br/>    jmp switchDone;<br/><br/>label3:<br/>    &lt;&lt; code to execute if i = 3 &gt;&gt;<br/><br/>switchDone:<br/>  &lt;&lt; Code that follows the switch statement &gt;&gt;</pre>&#13;
		<p class="indent">To see how this code operates, we’ll step through it one instruction at a time. The <code>jmpTable</code> declaration defines an array of four double-word pointers, one pointer for each case in our <code>switch</code> statement emulation. Entry 0 in the array holds the address of the statement to jump to when the <code>switch</code> expression evaluates to <code>0</code>, entry 1 contains the address of the statement to execute when the <code>switch</code> expression evaluates to <code>1</code>, and so on. Note that the array must have one element whose index matches each of the possible cases in the <code>switch</code> statement (<code>0</code> through <code>3</code> in this particular example).</p>&#13;
		<p class="indent">The first machine instruction in this example loads the value of the <code>switch</code> expression (variable <code>i</code>’s value) into the EAX register. Because this code uses the <code>switch</code> expression’s value as an index into the <code>jmpTable</code> array, this value must be an ordinal (integer) value in an 80x86 32-bit register. The next instruction (<code>jmp</code>) does the real work of the <code>switch</code> statement emulation: it jumps to the address specified by the entry in the <code>jmpTable</code> array, <span epub:type="pagebreak" id="page_480"/>indexed by EAX. If EAX contains <code>0</code> upon execution of this <code>jmp</code> statement, the program fetches the double word from <code>jmpTable[0]</code> and transfers control to that address; this is the address of the first instruction following the <code>label0</code> label in the program code. If EAX contains <code>1</code>, then the <code>jmp</code> instruction fetches the double word at address <code>jmpTable + 4</code> in memory (note that the <code>*4</code> scaled-index addressing mode is used in this code; see “Indexed Addressing Mode” on <a href="ch03.xhtml#page_34">page 34</a> for more details). Likewise, if EAX contains <code>2</code> or <code>3</code>, then the <code>jmp</code> instruction transfers control to the double-word address held at <code>jmpTable + 8</code> or <code>jmpTable + 12</code> (respectively). Because the <code>jmpTable</code> array is initialized with the addresses of <code>label0</code>, <code>label1</code>, <code>label2</code>, and <code>label3</code>, at respective offsets 0, 4, 8, and 12, this particular indirect <code>jmp</code> instruction will transfer control to the statement at the label corresponding to <code>i</code>’s value (<code>label0</code>, <code>label1</code>, <code>label2</code>, or <code>label3</code>, respectively).</p>&#13;
		<p class="indent">The first point of interest about this <code>switch</code> statement emulation is that it requires only two machine instructions (and a jump table) to transfer control to any of the four possible cases. Contrast this with an <code>if..then..elseif</code> implementation, which requires at least two machine instructions for each case. Indeed, as you add more cases to the <code>if..then..elseif</code> implementation, the number of compare and conditional branch instructions increases, yet the number of machine instructions for the jump table implementation remains fixed at two (even though the size of the jump table increases by one entry for each case). Accordingly, the <code>if..then..elseif</code> implementation gets progressively slower as you add more cases, while the jump table implementation takes a constant amount of time to execute (regardless of the number of cases). Assuming your HLL compiler uses a jump table implementation for <code>switch</code> statements, a <code>switch</code> statement will typically be much faster than an <code>if..then..elseif</code> sequence if there are a large number of cases.</p>&#13;
		<p class="indent">The jump table implementation of <code>switch</code> statements does have a couple of drawbacks, though. First, because the jump table is an array in memory, and accessing (noncached) memory can be slow, accessing the jump table array could possibly impair system performance.</p>&#13;
		<p class="indent">Another downside is that you must have one entry in the table for every possible case between the largest and the smallest case values, including those values for which you haven’t actually supplied an explicit case. In the example up to this point, this hasn’t been an issue because the case values started with <code>0</code> and were contiguous through <code>3</code>. However, consider the following Pascal <code>case</code> statement:</p>&#13;
		<pre class="programs">&#13;
			case( i ) of<br/><br/>  0: begin<br/>      &lt;&lt; statements to execute if i = 0 &gt;&gt;<br/>     end;<br/><br/>  1: begin<br/>      &lt;&lt; statements to execute if i = 1 &gt;&gt;<br/>     end;<br/><span epub:type="pagebreak" id="page_481"/>  5: begin<br/>      &lt;&lt; statements to execute if i = 5 &gt;&gt;<br/>     end;<br/><br/>  8: begin<br/>      &lt;&lt; statements to execute if i = 8 &gt;&gt;<br/>     end;<br/><br/>end; (* case *)</pre>&#13;
		<p class="indent">We can’t implement this <code>case</code> statement with a jump table containing four entries. If the value of <code>i</code> were <code>0</code> or <code>1</code>, then it would fetch the correct address. However, for case 5, the index into the jump table would be <code>20</code> (5 × 4), not the third (2 x 4 = 8) entry in the jump table. If the jump table contained only four entries (16 bytes), indexing into the jump table using the value <code>20</code> would grab an address beyond the end of the table and likely crash the application. This is exactly why in the original definition of Pascal, the results were undefined if the program supplied a case value that wasn’t present in the set of labels for a particular <code>case</code> statement.</p>&#13;
		<p class="indent">To solve this problem in assembly language, you must make sure there are entries for each of the possible case labels as well as all values in between them. In the current example, the jump table would need nine entries to handle all the possible case values, <code>0</code> through <code>8</code>:</p>&#13;
		<pre class="programs">&#13;
			// Conversion of<br/>//    switch(i)<br/>//    { case 0:...case 1:...case 5:...case 8:}<br/>// into assembly<br/><br/>static<br/>  jmpTable: dword[9] :=<br/>          [<br/>            &amp;label0, &amp;label1, &amp;switchDone,<br/>            &amp;switchDone, &amp;switchDone,<br/>            &amp;label5, &amp;switchDone, &amp;switchDone,<br/>            &amp;label8<br/>          ];<br/>      .<br/>      .<br/>      .<br/>    // jumps to address specified by jmpTable[i]<br/><br/>    mov( i, eax );<br/>    jmp( jmpTable[ eax*4 ] );<br/><br/>label0:<br/>    &lt;&lt; code to execute if i = 0 &gt;&gt;<br/>    jmp switchDone;<br/><br/>label1:<br/>    &lt;&lt; code to execute if i = 1 &gt;&gt;<br/>    jmp switchDone;<br/><span epub:type="pagebreak" id="page_482"/>label5:<br/>    &lt;&lt; code to execute if i = 5 &gt;&gt;<br/>    jmp switchDone;<br/><br/>label8:<br/>    &lt;&lt; code to execute if i = 8 &gt;&gt;<br/><br/>switchDone:<br/>  &lt;&lt; Code that follows the switch statement &gt;&gt;</pre>&#13;
		<p class="indent">Notice that if <code>i</code> is equal to <code>2</code>, <code>3</code>, <code>4</code>, <code>6</code>, or <code>7</code>, then this code transfers control to the first statement beyond the <code>switch</code> statement (the standard semantics for C’s <code>switch</code> statement and the <code>case</code> statement in most modern variants of Pascal). Of course, C will also transfer control to this point in the code if the <code>switch</code>/<code>case</code> expression value is greater than the largest case value. Most compilers implement this feature with a comparison and conditional branch immediately before the indirect jump. For example:</p>&#13;
		<pre class="programs">&#13;
			// Conversion of<br/>//    switch(i)<br/>//    { case 0:...case 1:...case 5:...case 8:}<br/>// into assembly, that automatically<br/>// handles values greater than 8.<br/><br/>static<br/>  jmpTable: dword[9] :=<br/>          [<br/>            &amp;label0, &amp;label1, &amp;switchDone,<br/>            &amp;switchDone, &amp;switchDone,<br/>            &amp;label5, &amp;switchDone, &amp;switchDone,<br/>            &amp;label8<br/>          ];<br/>      .<br/>      .<br/>      .<br/>    // Check to see if the value is outside the range<br/>    // of values allowed by this switch/case stmt.<br/><br/>    mov( i, eax );<br/>    cmp( eax, 8 );<br/>    ja switchDone;<br/><br/>    // jmps to address specified by jmpTable[i]<br/><br/>    jmp( jmpTable[ eax*4 ] );<br/><br/>      .<br/>      .<br/>      .<br/><br/>switchDone:<br/>  &lt;&lt; Code that follows the switch statement &gt;&gt;</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_483"/>You may have noticed another assumption that this code is making—that the case values start at <code>0</code>. Modifying the code to handle an arbitrary range of case values is simple. Consider the following example:</p>&#13;
		<pre class="programs">&#13;
			// Conversion of<br/>//    switch(i)<br/>//    { case 10:...case 11:...case 12:...case 15:...case 16:}<br/>// into assembly, that automatically handles values<br/>// greater than 16 and values less than 10.<br/><br/>static<br/>  jmpTable: dword[7] :=<br/>          [<br/>            &amp;label10, &amp;label11, &amp;label12,<br/>            &amp;switchDone, &amp;switchDone,<br/>            &amp;label15, &amp;label16<br/>          ];<br/>      .<br/>      .<br/>      .<br/>    // Check to see if the value is outside the<br/>    // range 10..16.<br/><br/>    mov( i, eax );<br/>    cmp( eax, 10 );<br/>    jb switchDone;<br/>    cmp( eax, 16 );<br/>    ja switchDone;<br/><br/>    // The "- 10*4" part of the following expression<br/>    // adjusts for the fact that EAX starts at 10<br/>    // rather than 0, but we still need a zero-based<br/>    // index into our array.<br/><br/>    jmp( jmpTable[ eax*4 - 10*4] );<br/><br/>      .<br/>      .<br/>      .<br/><br/>switchDone:<br/>  &lt;&lt; Code that follows the switch statement &gt;&gt;</pre>&#13;
		<p class="indent">There are two differences between this example and the previous one. First, this example compares the value in EAX against the range <code>10..16</code> and, if the value falls outside this range, branches to the <code>switchDone</code> label (in other words, there is no case label for the value in EAX). Second, the <code>jmpTable</code> index has been modified to be <code>[eax*4 – 10*4]</code>. Arrays at the machine level always begin at index <code>0</code>; the “<code>- 10*4</code>” component of this expression adjusts for the fact that EAX actually contains a value starting at <code>10</code> rather than <code>0</code>. Effectively, this expression makes <code>jmpTable</code> start 40 bytes earlier in memory than its declaration states. Because EAX is always 10 or greater (40 bytes or greater because of the <code>eax*4</code> component), this code begins accessing the <span epub:type="pagebreak" id="page_484"/>table at its declared beginning location. Note that HLA subtracts this offset from the address of <code>jmpTable</code>; the CPU doesn’t actually perform this subtraction at runtime. Hence, there is no additional efficiency loss to create this zero-based index.</p>&#13;
		<p class="indent">Notice that a fully generalized <code>switch</code>/<code>case</code> statement actually requires six instructions to implement: the original two instructions plus four instructions to test the range.<sup><a id="ch13fn_3"/><a href="footnotes.xhtml#ch13fn3">3</a></sup> This, plus the fact that an indirect jump is slightly more expensive to execute than a conditional branch, is why the break-even point for a <code>switch</code>/<code>case</code> statement (versus an <code>if..then..elseif</code> chain) is around three to four cases.</p>&#13;
		<p class="indent">As mentioned earlier, one serious drawback to the jump table implementation of the <code>switch</code>/<code>case</code> statement is the fact that you must have one table entry for every possible value between the smallest case and the largest case. Consider the following C/C++ <code>switch</code> statement:</p>&#13;
		<pre class="programs">&#13;
			switch( i )<br/>{<br/>  case 0:<br/>      &lt;&lt; statements to execute if i == 0 &gt;&gt;<br/>      break;<br/><br/>  case 1:<br/>      &lt;&lt; statements to execute if i == 1 &gt;&gt;<br/>      break;<br/><br/>  case 10:<br/>      &lt;&lt; statements to execute if i == 10 &gt;&gt;<br/>      break;<br/><br/>  case 100:<br/>      &lt;&lt; statements to execute if i == 100 &gt;&gt;<br/>      break;<br/><br/>  case 1000:<br/>      &lt;&lt; statements to execute if i == 1000 &gt;&gt;<br/>      break;<br/><br/>  case 10000:<br/>      &lt;&lt; statements to execute if i == 10000 &gt;&gt;<br/>      break;<br/>}</pre>&#13;
		<p class="indent">If the C/C++ compiler implements this <code>switch</code> statement using a jump table, that table will require 10,001 entries (that is, 40,004 bytes of memory on a 32-bit processor). That’s quite a chunk of memory for such a simple statement! Although the wide separation of the cases has a major effect on memory usage, it has only a minor effect on the execution speed of the <code>switch</code> statement. The program executes the same four instructions it would <span epub:type="pagebreak" id="page_485"/>execute if the values were all contiguous (only four instructions are necessary because the case values start at <code>0</code>, so there’s no need to check the <code>switch</code> expression against a lower bound). Indeed, the only reason there’s a performance difference at all is because of the effects of the table size on the cache (it’s less likely you will find a particular table entry in the cache when the table is large). Speed issues aside, the memory usage by the jump table is difficult to justify for most applications. Therefore, if your particular compiler emits a jump table for all <code>switch</code>/<code>case</code> statements (which you can determine by looking at the code it produces), you should be careful about creating <code>switch</code>/<code>case</code> statements whose cases are widely separated.</p>&#13;
		<h4 class="h4" id="ch00lev2sec173"><strong>13.5.3 Other Implementations of switch/case</strong></h4>&#13;
		<p class="noindent">Because of the issue with jump table sizes, some HLL compilers do not implement <code>switch</code>/<code>case</code> statements using jump tables. Some compilers will simply convert a <code>switch</code>/<code>case</code> statement into the corresponding <code>if..then..elseif</code> chain (Swift falls into this category). Obviously, such compilers tend to produce low-quality code (from a speed point of view) whenever a jump table would be appropriate. Many modern compilers are relatively smart about their code generation. They’ll determine the number of cases in a <code>switch</code>/<code>case</code> statement as well as the spread of the case values. Then the compiler will choose a jump table or <code>if..then..elseif</code> implementation based on some threshold criteria (code size versus speed). Some compilers might even use a combination of the techniques. For example, consider the following Pascal <code>case</code> statement:</p>&#13;
		<pre class="programs">&#13;
			case( i ) of<br/>  0: begin<br/>      &lt;&lt; statements to execute if i = 0 &gt;&gt;<br/>     end;<br/><br/>  1: begin<br/>      &lt;&lt; statements to execute if i = 1 &gt;&gt;<br/>     end;<br/><br/>  2: begin<br/>      &lt;&lt; statements to execute if i = 2 &gt;&gt;<br/>     end;<br/><br/>  3: begin<br/>      &lt;&lt; statements to execute if i = 3 &gt;&gt;<br/>     end;<br/><br/>  4: begin<br/>      &lt;&lt; statements to execute if i = 4 &gt;&gt;<br/>     end;<br/><br/>  1000: begin<br/>      &lt;&lt; statements to execute if i = 1000 &gt;&gt;<br/>        end;<br/>end; (* case *)</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_486"/>A good compiler will recognize that the majority of the cases work well in a jump table, with the exception of only one (or a few) cases. It will translate this code to a sequence of instructions that combine the <code>if..then</code> and jump table implementation. For example:</p>&#13;
		<pre class="programs">&#13;
			    mov( i, eax );<br/>    cmp( eax, 4 );<br/>    ja try1000;<br/>    jmp( jmpTable[ eax*4 ] );<br/>      .<br/>      .<br/>      .<br/>try1000:<br/>    cmp( eax, 1000 );<br/>    jne switchDone;<br/>    &lt;&lt; code to do if i = 1000 &gt;&gt;<br/>switchDone:</pre>&#13;
		<p class="indent">Although the <code>switch</code>/<code>case</code> statement was originally created to allow the use of an efficient jump table transfer mechanism in an HLL, there are few language definitions that require a specific implementation for a control structure. Therefore, unless you stick with a specific compiler and you know how that compiler generates code under all circumstances, there’s absolutely no guarantee that your <code>switch</code>/<code>case</code> statements will compile to a jump table, an <code>if..then..elseif</code> chain, some combination of the two, or something else entirely. For example, consider the following short C program and the resulting assembly output:</p>&#13;
		<pre class="programs">&#13;
			extern void f( void );<br/>extern void g( void );<br/>extern void h( void );<br/>int main( int argc, char **argv )<br/>{<br/>    int boolResult;<br/><br/>    switch( argc )<br/>    {<br/>        case 1:<br/>            f();<br/>            break;<br/><br/>        case 2:<br/>            g();<br/>            break;<br/><br/>        case 10:<br/>            h();<br/>            break;<br/><br/>        case 11:<br/>            f();<br/>            break;<br/><span epub:type="pagebreak" id="page_487"/>    }<br/>    return 0;<br/>}</pre>&#13;
		<p class="indent">Here’s the 80x86 output from the (older) Borland C++ v5.0 compiler:</p>&#13;
		<pre class="programs">&#13;
			_main   proc    near<br/>?live1@0:<br/>   ;<br/>   ;    int main( int argc, char **argv )<br/>   ;<br/>@1:<br/>    push      ebp<br/>    mov       ebp,esp<br/>   ;<br/>   ;    {<br/>   ;        int boolResult;<br/>   ;<br/>   ;        switch( argc )<br/>   ;<br/><br/>; Is argc == 1?<br/><br/>    mov       eax,dword ptr [ebp+8]<br/>    dec       eax<br/>    je        short @7<br/><br/>; Is argc == 2?<br/><br/>    dec       eax<br/>    je        short @6<br/><br/>; Is argc == 10?<br/><br/>    sub       eax,8<br/>    je        short @5<br/><br/>; Is argc == 11?<br/><br/>    dec       eax<br/>    je        short @4<br/><br/>; If none of the above<br/><br/>    jmp       short @2<br/>   ;<br/>   ;        {<br/>   ;            case 1:<br/>   ;                f();<br/>   ;<br/>@7:<br/>    call      _f<br/>   ;<br/>   ;                break;<br/>   ;<br/><span epub:type="pagebreak" id="page_488"/>    jmp       short @8<br/>   ;<br/>   ;<br/>   ;            case 2:<br/>   ;                g();<br/>   ;<br/>@6:<br/>    call      _g<br/>   ;<br/>   ;                break;<br/>   ;<br/>    jmp       short @8<br/>   ;<br/>   ;<br/>   ;            case 10:<br/>   ;                h();<br/>   ;<br/>@5:<br/>    call      _h<br/>   ;<br/>   ;                break;<br/>   ;<br/>    jmp       short @8<br/>   ;<br/>   ;<br/>   ;            case 11:<br/>   ;                f();<br/>   ;<br/>@4:<br/>    call      _f<br/>   ;<br/>   ;                break;<br/>   ;<br/>   ;        }<br/>   ;        return 0;<br/>   ;<br/>@2:<br/>@8:<br/>    xor       eax,eax<br/>   ;<br/>   ;    }<br/>   ;<br/>@10:<br/>@9:<br/>    pop       ebp<br/>    ret<br/>_main   endp</pre>&#13;
		<p class="indent">As you can see at the beginning of the main program, this code compares the value in <code>argc</code> against the four values (<code>1</code>, <code>2</code>, <code>10</code>, and <code>11</code>) sequentially. For a <code>switch</code> statement as small as this one, this isn’t a bad implementation.</p>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_489"/>When there are a fair number of cases and a jump table would be too large, many modern optimizing compilers generate a binary search tree to test the cases. For example, consider the following C program and the corresponding output:</p>&#13;
		<pre class="programs">&#13;
			#include &lt;stdio.h&gt;<br/><br/>extern void f( void );<br/>int main( int argc, char **argv )<br/>{<br/>    int boolResult;<br/><br/>    switch( argc )<br/>    {<br/>        case 1:<br/>            f();<br/>            break;<br/><br/>        case 10:<br/>            f();<br/>            break;<br/><br/>        case 100:<br/>            f();<br/>            break;<br/><br/>        case 1000:<br/>            f();<br/>            break;<br/><br/>        case 10000:<br/>            f();<br/>            break;<br/><br/>        case 100000:<br/>            f();<br/>            break;<br/><br/>        case 1000000:<br/>            f();<br/>            break;<br/><br/>        case 10000000:<br/>            f();<br/>            break;<br/><br/>        case 100000000:<br/>            f();<br/>            break;<br/><br/>        case 1000000000:<br/>            f();<br/>            break;<br/><span epub:type="pagebreak" id="page_490"/>    }<br/>    return 0;<br/>}</pre>&#13;
		<p class="indent">Here’s the 64-bit MASM output from the Visual C++ compiler. Note how Microsoft’s compiler generates a partial binary search through each of the 10 cases:</p>&#13;
		<pre class="programs">&#13;
			main    PROC<br/><br/>$LN18:<br/>        sub     rsp, 40                                 ; 00000028H<br/><br/>; &gt;+ 100,000?<br/>        cmp     ecx, 100000                             ; 000186a0H<br/>        jg      SHORT $LN15@main<br/>        je      SHORT $LN10@main<br/><br/>; handle cases where argc is less than 100,000<br/>;<br/>; Check for argc = 1<br/><br/>        sub     ecx, 1<br/>        je      SHORT $LN10@main<br/><br/>; check for argc = 10<br/><br/>        sub     ecx, 9<br/>        je      SHORT $LN10@main<br/><br/>;check for argc = 100<br/><br/>        sub     ecx, 90                                 ; 0000005aH<br/>        je      SHORT $LN10@main<br/><br/>; check for argc = 1000<br/><br/>        sub     ecx, 900                                ; 00000384H<br/>        je      SHORT $LN10@main<br/><br/>; check for argc = 1000<br/>        cmp     ecx, 9000                               ; 00002328H<br/><br/>        jmp     SHORT $LN16@main<br/>$LN15@main:<br/><br/>; Check for argc = 100,000<br/><br/>      cmp     ecx, 1000000                              ; 000f4240H<br/>        je      SHORT $LN10@main<br/><br/>; check for argc = 1,000,000<br/>        cmp     ecx, 10000000                           ; 00989680H<br/>        je      SHORT $LN10@main<br/><br/><span epub:type="pagebreak" id="page_491"/>; check for argc = 10,000,000<br/>        cmp     ecx, 100000000                          ; 05f5e100H<br/>        je      SHORT $LN10@main<br/><br/>; check for argc = 100,000,000<br/><br/>        cmp     ecx, 1000000000                         ; 3b9aca00H<br/>$LN16@main:<br/>        jne     SHORT $LN2@main<br/>$LN10@main:<br/><br/>        call    f<br/>$LN2@main:<br/><br/>        xor     eax, eax<br/><br/>        add     rsp, 40                                 ; 00000028H<br/>        ret     0<br/>main    ENDP</pre>&#13;
		<p class="indent">Interestingly enough, when compiling to 32-bit code, Visual C++ produces a true binary search. Here’s the MASM32 output from the 32-bit version of Visual C++:</p>&#13;
		<pre class="programs">&#13;
			_main   PROC<br/><br/>        mov     eax, DWORD PTR _argc$[esp-4] ; argc is passed on stack in 32-bit code<br/><br/>; Start with &gt;100,000, = 100,000, or &lt; 100,000<br/><br/>        cmp     eax, 100000                  ; 000186a0H<br/>        jg      SHORT $LN15@main             ; Go if &gt;100,000<br/>        je      SHORT $LN4@main              ; Match if equal<br/><br/>; Handle cases where argc &lt; 100,000<br/>;<br/>; Divide it into &gt;100 and &lt; 100<br/><br/>        cmp     eax, 100                     ; 00000064H<br/>        jg      SHORT $LN16@main             ; Branch if &gt; 100<br/>        je      SHORT $LN4@main              ; = 100<br/><br/>; Down here if &lt; 100<br/><br/>        sub     eax, 1<br/>        je      SHORT $LN4@main              ; branch if it was 1<br/><br/>        sub     eax, 9                       ; Test for 10<br/>        jmp     SHORT $LN18@main<br/><br/>; Come down here if &gt;100 and &lt;100,000<br/><span epub:type="pagebreak" id="page_492"/>$LN16@main:<br/><br/>        cmp     eax, 1000                    ; 000003e8H<br/>        je      SHORT $LN4@main              ; Branch if 1000<br/>        cmp     eax, 10000                   ; 00002710H<br/>        jmp     SHORT $LN18@main             ; Handle =10,000 or not in range<br/><br/>; Handle &gt; 100,000 here.<br/><br/>$LN15@main:<br/>        cmp     eax, 100000000               ; 05f5e100H<br/>        jg      SHORT $LN17@main             ; &gt; 100,000,000<br/>        je      SHORT $LN4@main              ; = 100,000<br/><br/>; Handle &lt; 100,000,000 and &gt; 100,000 here:<br/><br/>        cmp     eax, 1000000                 ; 000f4240H<br/>        je      SHORT $LN4@main              ; =1,000,000<br/>        cmp     eax, 10000000                ; 00989680H<br/><br/>        jmp     SHORT $LN18@main             ; Handle 10,000,000 or not in range<br/><br/>; Handle &gt; 100,000,000 here<br/>$LN17@main:<br/>; check for 1,000,000,000<br/>        cmp     eax, 1000000000              ; 3b9aca00H<br/>$LN18@main:<br/>        jne     SHORT $LN2@main<br/>$LN4@main:<br/><br/>        call    _f<br/>$LN2@main:<br/><br/>        xor     eax, eax<br/><br/>        ret     0<br/>_main   ENDP</pre>&#13;
		<p class="indent">Some compilers, especially those for some microcontroller devices, generate a table of <em>2-tuples</em> (paired records/structures), with one element of the tuple being the value of the case and the second element being the address to jump to if the value matches. Then the compiler emits a loop that scans through this little table searching for the current <code>switch</code>/<code>case</code> expression value. If this is a linear search, this implementation is even slower than the <code>if..then..elseif</code> chain. If the compiler emits a binary search, the code may be faster than an <code>if..then.elseif</code> chain but probably not as fast as a jump table implementation.</p>&#13;
		<p class="indent">Here’s a Java example of a <code>switch</code> statement, along with the Java bytecode the compiler produces:</p>&#13;
		<pre class="programs">&#13;
			public class Welcome<br/>{<br/>    public static void f(){}<br/><span epub:type="pagebreak" id="page_493"/>    public static void main( String[] args )<br/>    {<br/>        int i = 10;<br/>        switch (i)<br/>        {<br/>            case 1:<br/>                f();<br/>                break;<br/><br/>            case 10:<br/>                f();<br/>                break;<br/><br/>            case 100:<br/>                f();<br/>                break;<br/><br/>            case 1000:<br/>                f();<br/>                break;<br/><br/>            case 10000:<br/>                f();<br/>                break;<br/><br/>            case 100000:<br/>                f();<br/>                break;<br/><br/>            case 1000000:<br/>                f();<br/>                break;<br/><br/>            case 10000000:<br/>                f();<br/>                break;<br/><br/>            case 100000000:<br/>                f();<br/>                break;<br/><br/>            case 1000000000:<br/>                f();<br/>                break;<br/><br/>        }<br/>    }<br/>}<br/><br/>// JBC output:<br/><br/>Compiled from "Welcome.java"<br/>public class Welcome extends java.lang.Object{<br/>public Welcome();<br/><span epub:type="pagebreak" id="page_494"/>  Code:<br/>   0:   aload_0<br/>   1:   invokespecial   #1; //Method java/lang/Object."&lt;init&gt;":()V<br/>   4:   return<br/><br/>public static void f();<br/>  Code:<br/>   0:   return<br/><br/>public static void main(java.lang.String[]);<br/>  Code:<br/>   0:   bipush  10<br/>   2:   istore_1<br/>   3:   iload_1<br/>   4:   lookupswitch{ //10<br/>        1: 96;<br/>        10: 102;<br/>        100: 108;<br/>        1000: 114;<br/>        10000: 120;<br/>        100000: 126;<br/>        1000000: 132;<br/>        10000000: 138;<br/>        100000000: 144;<br/>        1000000000: 150;<br/>        default: 153 }<br/>   96:  invokestatic    #2; //Method f:()V<br/>   99:  goto    153<br/>   102: invokestatic    #2; //Method f:()V<br/>   105: goto    153<br/>   108: invokestatic    #2; //Method f:()V<br/>   111: goto    153<br/>   114: invokestatic    #2; //Method f:()V<br/>   117: goto    153<br/>   120: invokestatic    #2; //Method f:()V<br/>   123: goto    153<br/>   126: invokestatic    #2; //Method f:()V<br/>   129: goto    153<br/>   132: invokestatic    #2; //Method f:()V<br/>   135: goto    153<br/>   138: invokestatic    #2; //Method f:()V<br/>   141: goto    153<br/>   144: invokestatic    #2; //Method f:()V<br/>   147: goto    153<br/>   150: invokestatic    #2; //Method f:()V<br/>   153: return<br/>}</pre>&#13;
		<p class="indent">The <code>lookupswitch</code> bytecode instruction contains a table of 2-tuples. As described earlier, the first value of the tuple is the case value, and the second is the target address where the code transfers on a match. Presumably, the bytecode interpreter does a binary search on these values rather than a linear search (one would hope!). Notice that the Java compiler generates a <span epub:type="pagebreak" id="page_495"/>separate call to method <code>f()</code> for each of the cases; it doesn’t optimize them to a single call as GCC and Visual C++ do.</p>&#13;
		<div class="note">&#13;
			<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
			<p class="notep"><em>Java also has a <span class="codeitalic">tableswitch</span> VM instruction that executes a table-driven <span class="codeitalic">switch</span> operation. The Java compiler chooses between the <span class="codeitalic">tableswitch</span> and <span class="codeitalic">lookupswitch</span> instructions based on the density of the case values.</em></p>&#13;
		</div>&#13;
		<p class="indent">Sometimes, compilers resort to some code tricks to generate marginally better code under certain circumstances. Consider again the short <code>switch</code> statement that led the Borland compiler to produce a linear search:</p>&#13;
		<pre class="programs">&#13;
			switch( argc )<br/>    {<br/>        case 1:<br/>            f();<br/>            break;<br/><br/>        case 2:<br/>            g();<br/>            break;<br/><br/>        case 10:<br/>            h();<br/>            break;<br/><br/>        case 11:<br/>            f();<br/>            break;<br/><br/>    }</pre>&#13;
		<p class="indent">Here’s the code that the Microsoft Visual C++ 32-bit compiler generates for this <code>switch</code> statement:</p>&#13;
		<pre class="programs">&#13;
			; File t.c<br/>; Line 13<br/>;<br/>; Use ARGC as an index into the $L1240 table,<br/>; which returns an offset into the $L1241 table:<br/><br/>    mov eax, DWORD PTR _argc$[esp-4]<br/>    dec eax         ; --argc, 1=0, 2=1, 10=9, 11=10<br/>    cmp eax, 10     ; Out of range of cases?<br/>    ja  SHORT $L1229<br/>    xor ecx, ecx<br/>    mov cl, BYTE PTR $L1240[eax]<br/>    jmp DWORD PTR $L1241[ecx*4]<br/><br/>    npad    3<br/>$L1241:<br/>    DD  $L1232  ; cases that call f<br/>    DD  $L1233  ; cases that call g<br/><span epub:type="pagebreak" id="page_496"/>    DD  $L1234  ; cases that call h<br/>    DD  $L1229  ; Default case<br/><br/>$L1240:<br/>    DB  0   ; case 1 calls f<br/>    DB  1   ; case 2 calls g<br/>    DB  3   ; default<br/>    DB  3   ; default<br/>    DB  3   ; default<br/>    DB  3   ; default<br/>    DB  3   ; default<br/>    DB  3   ; default<br/>    DB  3   ; default<br/>    DB  2   ; case 10 calls h<br/>    DB  0   ; case 11 calls f<br/><br/>; Here is the code for the various cases:<br/><br/>$L1233:<br/>; Line 19<br/>    call    _g<br/>; Line 31<br/>    xor eax, eax<br/>; Line 32<br/>    ret 0<br/><br/>$L1234:<br/>; Line 23<br/>    call    _h<br/>; Line 31<br/>    xor eax, eax<br/>; Line 32<br/>    ret 0<br/><br/>$L1232:<br/>; Line 27<br/>    call    _f<br/>$L1229:<br/>; Line 31<br/>    xor eax, eax<br/>; Line 32<br/>    ret 0</pre>&#13;
		<p class="indent">The trick in this 80x86 code is that Visual C++ first does a table lookup to make an <code>argc</code> value in the range <code>1..11</code> to a value in the range <code>0..3</code> (which corresponds to the three different code bodies appearing in the cases, plus a default case). This code is shorter than a jump table, with the corresponding double-word entries mapping to the default case, although it’s a little slower than a jump table because it needs to access two different tables in memory. (As for how the speed of this code compares with a binary search or linear search, that research is left to you; the answer will probably vary <span epub:type="pagebreak" id="page_497"/>by processor.) Note, however, that when producing 64-bit code, Visual C++ reverts to the linear search:</p>&#13;
		<pre class="programs">&#13;
			main    PROC<br/><br/>$LN12:<br/>        sub     rsp, 40                                 ; 00000028H<br/><br/>; ARGC is passed in ECX<br/><br/>        sub     ecx, 1<br/>        je      SHORT $LN4@main  ; case 1<br/>        sub     ecx, 1<br/>        je      SHORT $LN5@main  ; case 2<br/>        sub     ecx, 8<br/>        je      SHORT $LN6@main  ; case 10<br/>        cmp     ecx, 1<br/>        jne     SHORT $LN10@main ; case 11<br/>$LN4@main:<br/><br/>        call    f<br/>$LN10@main:<br/><br/>        xor     eax, eax<br/><br/>        add     rsp, 40                                 ; 00000028H<br/>        ret     0<br/>$LN6@main:<br/><br/>        call    h<br/><br/>        xor     eax, eax<br/><br/>        add     rsp, 40                                 ; 00000028H<br/>        ret     0<br/>$LN5@main:<br/><br/>        call    g<br/><br/>        xor     eax, eax<br/><br/>        add     rsp, 40                                 ; 00000028H<br/>        ret     0<br/>main    ENDP</pre>&#13;
		<p class="indent">Few compilers give you the option of explicitly specifying how the compiler will translate a specific <code>switch</code>/<code>case</code> statement. For example, if you really want the <code>switch</code> statement with cases 0, 1, 10, 100, 1,000, and 10,000 given earlier to generate a jump table, you’ll have to write the code in assembly language or use a specific compiler whose code generation traits you understand. Any HLL code you’ve written that depends on the <span epub:type="pagebreak" id="page_498"/>compiler generating a jump table won’t be portable to other compilers, however, because few languages specify the actual machine code implementation of high-level control structures.</p>&#13;
		<p class="indent">Of course, you don’t have to totally rely on the compiler to generate decent code for a <code>switch</code>/<code>case</code> statement. Assuming your compiler uses the jump table implementation for all <code>switch</code>/<code>case</code> statements, you can help it produce better code when modifications to your HLL source code would generate a huge jump table. For example, consider the <code>switch</code> statement given earlier with the cases 0, 1, 2, 3, 4, and 1,000. If your compiler generates a jump table with 1,001 entries (consuming a little more than 4KB of memory), you can improve its output by writing the following Pascal code:</p>&#13;
		<pre class="programs">&#13;
			if( i = 1000 ) then begin<br/><br/>  &lt;&lt; statements to execute if i = 1000 &gt;&gt;<br/><br/>end<br/>else begin<br/><br/>  case( i ) of<br/>    0: begin<br/>        &lt;&lt; statements to execute if i = 0 &gt;&gt;<br/>       end;<br/><br/>    1: begin<br/>        &lt;&lt; statements to execute if i = 1 &gt;&gt;<br/>       end;<br/><br/>    2: begin<br/>        &lt;&lt; statements to execute if i = 2 &gt;&gt;<br/>       end;<br/><br/>    3: begin<br/>        &lt;&lt; statements to execute if i = 3 &gt;&gt;<br/>       end;<br/><br/>    4: begin<br/>        &lt;&lt; statements to execute if i = 4 &gt;&gt;<br/>       end;<br/>  end; (* case *)<br/>end; (* if *)</pre>&#13;
		<p class="indent">By handling case value <code>1000</code> outside the <code>switch</code> statement, the compiler can produce a short jump table for the main cases, which are contiguous.</p>&#13;
		<p class="indent">Another possibility (which is arguably easier to read) is the following C/C++ code:</p>&#13;
		<pre class="programs">&#13;
			switch( i )<br/>{<br/>  case 0:<br/>      &lt;&lt; statements to execute if i == 0 &gt;&gt;<br/><span epub:type="pagebreak" id="page_499"/>      break;<br/><br/>  case 1:<br/>      &lt;&lt; statements to execute if i == 1 &gt;&gt;<br/>      break;<br/><br/>  case 2:<br/>      &lt;&lt; statements to execute if i == 2 &gt;&gt;<br/>      break;<br/><br/>  case 3:<br/>      &lt;&lt; statements to execute if i == 3 &gt;&gt;<br/>      break;<br/><br/>  case 4:<br/>      &lt;&lt; statements to execute if i == 4 &gt;&gt;<br/>     break;<br/><br/>  default:<br/>    if( i == 1000 )<br/>    {<br/>      &lt;&lt; statements to execute if i == 1000 &gt;&gt;<br/>    }<br/>    else<br/>    {<br/>      &lt;&lt; Statements to execute if none of the cases match &gt;&gt;<br/>    }<br/>}</pre>&#13;
		<p class="indent">What makes this example slightly easier to read is that the code for the case when <code>i</code> is equal to <code>1000</code> has been moved into the <code>switch</code> statement (thanks to the default clause), so it doesn’t appear to be separate from all the tests taking place in the <code>switch</code>.</p>&#13;
		<p class="indent">Some compilers simply won’t generate a jump table for a <code>switch</code>/<code>case</code> statement. If you’re using such a compiler and you want to generate a jump table, there’s little you can do—short of dropping into assembly language or using nonstandard C extensions.</p>&#13;
		<p class="indent">Although jump table implementations of <code>switch</code>/<code>case</code> statements are generally efficient when you have a fair number of cases and they’re all equally likely, remember that an <code>if..then..elseif</code> chain can be faster if one or two cases are far more likely than the others. For example, if a variable has the value <code>15</code> more than half the time, the value <code>20</code> about a quarter of the time, and one of several different values the remaining 25 percent of the time, it’s probably more efficient to implement the multiway test using an <code>if..then..elseif</code> chain (or a combination of <code>if..then..elseif</code> and a <code>switch</code>/<code>case</code> statement). By testing the most common case(s) first, you can often reduce the average time the multiway statement needs to execute. For example:</p>&#13;
		<pre class="programs">&#13;
			if( i == 15 )<br/>{<br/><span epub:type="pagebreak" id="page_500"/>  // If i = 15 better than 50% of the time,<br/>  // then we only execute a single test<br/>  // better than 50% of the time:<br/>}<br/>else if( i == 20 )<br/>{<br/>  // if i == 20 better than 25% of the time,<br/>  // then we only execute one or<br/>  // two comparisons 75% of the time.<br/>}<br/>else if etc....</pre>&#13;
		<p class="indent">If <code>i</code> is equal to <code>15</code> more often than not, then most of the time this code sequence will execute the body of the first <code>if</code> statement after executing only two instructions. Even in the best <code>switch</code> statement implementation, you’re going to need more instructions than this.</p>&#13;
		<h4 class="h4" id="ch00lev2sec174"><strong>13.5.4 The Swift switch Statement</strong></h4>&#13;
		<p class="noindent">Swift’s <code>switch</code> statement is semantically different from most other languages. There are four major differences between Swift’s <code>switch</code> and the typical C/C++ <code>switch</code> or Pascal <code>case</code> statement:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent">Swift’s <code>switch</code> provides a special <code>where</code> clause that lets you apply a conditional to a <code>switch</code>.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Swift’s <code>switch</code> allows you to use the same value in more than one <code>case</code> statement (differentiated by the <code>where</code> clause).</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Swift’s <code>switch</code> allows the use of nonintegral/ordinal data types, such as tuples, strings, and sets, as the selection value (with appropriately typed case values).</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Swift’s <code>switch</code> statement supports pattern matching for case values.</p>&#13;
				</li>&#13;
		</ul>&#13;
		<p class="indent">Check out the Swift language reference manual for more details. The purpose of this section is not to provide the syntax and semantics of the Swift <code>switch</code>, but rather to discuss how Swift’s design affects its implementation.</p>&#13;
		<p class="indent">Because it allows arbitrary types as the <code>switch</code> selector value, there’s no way that Swift could use a jump table to implement the <code>switch</code> statement. A jump table implementation requires an ordinal value (something you can represent as an integer) that the compiler can use as an index into the jump table. A string selector, for example, couldn’t be used as an index into an array. Furthermore, Swift allows you to specify the same case value twice,<sup><a id="ch13fn_4"/><a href="footnotes.xhtml#ch13fn4">4</a></sup> creating a consistency problem with the same jump table entry mapping to two separate sections of code (which is impossible for a jump table).</p>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_501"/>Given the design of the Swift <code>switch</code> statement, then, the only solution is a linear search (effectively, the <code>switch</code> statement is equivalent to a chain of <code>if..else if..else if..etc</code>. statements). The bottom line is that there is no performance benefit to using the <code>switch</code> statement over a set of <code>if</code> statements.</p>&#13;
		<h4 class="h4" id="ch00lev2sec175"><strong>13.5.5 Compiler Output for switch Statements</strong></h4>&#13;
		<p class="noindent">Before you run off to help your compiler produce better code for <code>switch</code> statements, you might want to examine the actual code it produces. This chapter has described several of the techniques that various compilers use for implementing <code>switch</code>/<code>case</code> statements at the machine code level, but there are several additional implementations that this book could not cover. Although you can’t assume that a compiler will always generate the same code for a <code>switch</code>/<code>case</code> statement, observing its output can help you see the different implementations that compiler authors use.</p>&#13;
		<h3 class="h3" id="ch00lev1sec114"><strong>13.6 For More Information</strong></h3>&#13;
		<p class="bib">Aho, Alfred V., Monica S. Lam, Ravi Sethi, and Jeffrey D. Ullman. <em>Compilers: Principles, Techniques, and Tools</em>. 2nd ed. Essex, UK: Pearson Education Limited, 1986.</p>&#13;
		<p class="bib">Barrett, William, and John Couch. <em>Compiler Construction: Theory and Practice</em>. Chicago: SRA, 1986.</p>&#13;
		<p class="bib">Dershem, Herbert, and Michael Jipping. <em>Programming Languages, Structures and Models</em>. Belmont, CA: Wadsworth, 1990.</p>&#13;
		<p class="bib">Duntemann, Jeff. <em>Assembly Language Step-by-Step</em>. 3rd ed. Indianapolis: Wiley, 2009.</p>&#13;
		<p class="bib">Fraser, Christopher, and David Hansen. <em>A Retargetable C Compiler: Design and Implementation</em>. Boston: Addison-Wesley Professional, 1995.</p>&#13;
		<p class="bib">Ghezzi, Carlo, and Jehdi Jazayeri. <em>Programming Language Concepts</em>. 3rd ed. New York: Wiley, 2008.</p>&#13;
		<p class="bib">Hoxey, Steve, Faraydon Karim, Bill Hay, and Hank Warren, eds. <em>The PowerPC Compiler Writer’s Guide</em>. Palo Alto, CA: Warthman Associates for IBM, 1996.</p>&#13;
		<p class="bib">Hyde, Randall. <em>The Art of Assembly Language</em>. 2nd ed. San Francisco: No Starch Press, 2010.</p>&#13;
		<p class="bib">Intel. “Intel 64 and IA-32 Architectures Software Developer Manuals.” Updated November 11, 2019. <em><a href="https://software.intel.com/en-us/articles/intel-sdm">https://software.intel.com/en-us/articles/intel-sdm</a></em>.</p>&#13;
		<p class="bib">Ledgard, Henry, and Michael Marcotty. <em>The Programming Language Landscape</em>. Chicago: SRA, 1986.</p>&#13;
		<p class="bib">Louden, Kenneth C. <em>Compiler Construction: Principles and Practice</em>. Boston: Cengage, 1997.</p>&#13;
		<p class="bib"><span epub:type="pagebreak" id="page_502"/>Louden, Kenneth C., and Kenneth A. Lambert. <em>Programming Languages: Principles and Practice</em>. 3rd ed. Boston: Course Technology, 2012.</p>&#13;
		<p class="bib">Parsons, Thomas W. <em>Introduction to Compiler Construction</em>. New York: W. H. Freeman, 1992.</p>&#13;
		<p class="bib">Pratt, Terrence W., and Marvin V. Zelkowitz. <em>Programming Languages, Design and Implementation</em>. 4th ed. Upper Saddle River, NJ: Prentice Hall, 2001.</p>&#13;
		<p class="bib">Sebesta, Robert. <em>Concepts of Programming Languages</em>. 11th ed. Boston: Pearson, 2016.</p>&#13;
	</body></html>