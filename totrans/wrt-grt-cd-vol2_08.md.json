["```\ndata_type  array_name [ number_of_elements ];\n```", "```\n\n\t\t\tchar CharArray[ 128 ];\nint intArray[ 8 ];\nunsigned char ByteArray[ 10 ];\nint *PtrArray[ 4 ];\n```", "```\ndata_type array_name[ number_of_elements ] = {element_list};\n```", "```\nint intArray[8] = {0,1,2,3,4,5,6,7};\n```", "```\n\n\t\t\t#include <stdio.h>\nstatic int intArray[8] = {1,2,3,4,5,6,7,8};\nstatic int array2[8];\n\nint main( int argc, char **argv )\n{\n    int i;\n    for( i=0; i<8; ++i )\n    {\n        array2[i] = intArray[i];\n    }\n    for( i=7; i>= 0; --i )\n    {\n        printf( \"%d\\n\", array2[i] );\n    }\n    return 0;\n}\n```", "```\n\n\t\t\t_DATA    SEGMENT\nintArray DD      01H\n         DD      02H\n         DD      03H\n         DD      04H\n         DD      05H\n         DD      06H\n         DD      07H\n         DD      08H\n$SG6842  DB      '%d', 0aH, 00H\n_DATA    ENDS\n_BSS     SEGMENT\n_array2  DD      08H DUP (?)\n_BSS     ENDS\n```", "```\narray_name : data_type [ number_of_elements ];\n```", "```\n\n\t\t\tstatic\n\n // Character array with elements 0..127.\n\n CharArray: char[128];\n\n // \"integer\" array with elements 0..7.\n\n IntArray: integer[ 8 ];\n\n// Byte array with elements 0..9.\n\n ByteArray: byte[10];\n\n // Double word array with elements 0..3.\n\n PtrArray: dword[4];\n```", "```\n\n\t\t\tRealArray: real32[8] :=\n    [ 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0 ];\n\nIntegerAry: integer[8] :=\n    [ 8, 9, 10, 11, 12, 13, 14, 15 ];\n```", "```\narray_name : array[ lower_bound..upper_bound ] of data_type;\n```", "```\n\n\t\t\ttype\n    ptrToChar = ^char;\nvar\n    CharArray: array[ 0..127 ] of char;   // 128 elements\n    IntArray: array[ 0..7 ] of integer;   // 8 elements\n    ByteArray: array[ 0..9 ] of char;     // 10 elements\n    PtrArray: array[ 0..3 ] of ptrToChar; // 4 elements\n```", "```\n\n\t\t\tvar\n   ProfitsByYear : array[ 1998..2028 ] of real; // 31 elements\n```", "```\n\n\t\t\tvar data_type array_name = Array<element_type>()\nvar data_type array_name = [element_type]()\n```", "```\n\n\t\t\tvar data_type array_name = Array<element_type>( repeating: initial_value, count: elements )\n```", "```\n\n\t\t\tvar intArray = Array<Int>( repeating: 0, count: 100 )\nvar intArray2 = [Int]( repeating: 0, count: 100 )\n```", "```\n\n\t\t\tvar intArray = [1, 2, 3]\nvar strArray = [\"str1\", \"str2\", \"str3\"]\n```", "```\nalphaCnt : array[ 'A'..'Z' ] of integer;\n```", "```\n\n\t\t\tfor ch := 'A' to 'Z' do\n    alphaCnt[ ch ] := 0;\n```", "```\n\n\t\t\t#include <stdio.h>\n\nstatic char array[8] = {0,1,2,3,4,5,6,7};\n\nint main( void )\n{\n\n    printf( \"%d\\n\", array[0] );\n}\n```", "```\n\n\t\t\t        .align 2\n_array:\n        .byte   0   ; Note that the assembler stores the byte\n        .byte   1   ; values on successive lines into\n        .byte   2   ; contiguous memory locations.\n        .byte   3\n        .byte   4\n        .byte   5\n        .byte   6\n        .byte   7\n```", "```\n\n\t\t\t#include <stdio.h>\n\nstatic int array[8] = {0,0,0,0,0,0,0,1};\n\nint main( void )\n{\n    printf( \"%d\\n\", array[0] );\n}\n```", "```\n\n\t\t\t        .align 2\n_array:\n        .long   0\n        .long   0\n        .long   0\n        .long   0\n        .long   0\n        .long   0\n        .long   0\n        .long   1\n```", "```\n\n\t\t\t#include <stdio.h>\n\ntypedef struct\n{\n    long a;\n    char b;\n} FiveBytes;\n\nstatic FiveBytes shortArray[2] = {{2,3}, {4,5}};\nint main( void )\n{\n    printf( \"%ld\\n\", shortArray[0].a );\n}\n```", "```\n\n\t\t\t.data\n        .align 2   ; Ensure that _shortArray begins on an\n                   ; address boundary that is a multiple\n                   ; of 4.\n_shortArray:\n        .long   2  ; shortArray[0].a\n        .byte   3  ; shortArray[0].b\n        .space  3  ; Padding, to align next element to 4 bytes\n        .long   4  ; shortArray[1].a\n        .byte   5  ; shortArray[1].b\n        .space  3  ; Padding, at end of array.\n```", "```\n\n\t\t\tvar data_type array_name = ContiguousArray<element_type>()\n```", "```\nElement_Address = Base_Address + index * Element_Size\n```", "```\nvar  SixteenInts : array[0..15] of integer;\n```", "```\nElement_Address = AddressOf( SixteenInts ) + index * 4\n```", "```\n\n\t\t\tmov( index, ebx );\nmov( SixteenInts[ ebx*4 ], eax );\n```", "```\n\n\t\t\tprogram x(input,output);\nvar\n    i :integer;\n    sixteenInts :array[0..15] of integer;\n\n    function changei(i:integer):integer;\n    begin\n        changei := 15 - i;\n    end;\n\n    // changei         proc    near\n    //                 mov     edx, 0Fh\n    //                 sub     edx, eax\n    //                 mov     eax, edx\n    //                 retn\n    // changei         endp\n\nbegin\n    for i:= 0 to 15 do\n        sixteenInts[ changei(i) ] := i;\n\n    //                 xor     ebx, ebx\n    //\n    // loc_403AA7:\n    //                 mov     eax, ebx\n    //                 call    changei\n    //\n    // Note the use of the scaled-index addressing mode\n    // to multiply the array index by 4 prior to accessing\n    // elements of the array:\n    //\n    //                 mov     ds:sixteenInts[eax*4], ebx\n    //                 inc     ebx\n    //                 cmp     ebx, 10h\n    //                 jnz     short loc_403AA7\n\nend.\n```", "```\n\n\t\t\tprogram x(input,output);\ntype\n    NineBytes=\n        record\n            FourBytes       :integer;\n            FourMoreBytes   :integer;\n            OneByte         :char;\n        end;\n\nvar\n    i               :integer;\n    NineByteArray   :array[0..15] of NineBytes;\n\n    function changei(i:integer):integer;\n    begin\n        changei := 15 - i;\n    end;\n\n    // changei         proc    near\n    //                 mov     edx, 0Fh\n    //                 sub     edx, eax\n    //                 mov     eax, edx\n    //                 retn\n    // changei         endp\n\nbegin\n\n    for i:= 0 to 15 do\n        NineByteArray[ changei(i) ].FourBytes := i;\n\n//                  xor     ebx, ebx\n//\n//  loc_403AA7:\n//                  mov     eax, ebx\n//                  call    changei\n//\n//            // Compute EAX = EAX * 3\n//\n//                  lea     eax, [eax+eax*2]\n//\n//            // Actual index used is index*12 ((EAX*3) * 4)\n//\n//                  mov     ds:NineByteArray[eax*4], ebx\n//                  inc     ebx\n//                  cmp     ebx, 10h\n//                  jnz     short loc_403AA7\n\nend.\n```", "```\n\n\t\t\tprogram x(input,output);\n\n// Note the use of the \"packed\" keyword.\n// This tells Delphi to pack each record\n// into 9 consecutive bytes, without\n// any padding at the end of the record.\n\ntype\n    NineBytes=\n        packed record\n            FourBytes       :integer;\n            FourMoreBytes   :integer;\n            OneByte         :char;\n        end;\n\nvar\n    i               :integer;\n    NineByteArray   :array[0..15] of NineBytes;\n\n    function changei(i:integer):integer;\n    begin\n        changei := 15 - i;\n    end;\n\n    // changei         proc near\n    //                 mov     edx, 0Fh\n    //                 sub     edx, eax\n    //                 mov     eax, edx\n    //                 retn\n    // changei         endp\n\nbegin\n\n    for i:= 0 to 15 do\n        NineByteArray[ changei(i) ].FourBytes := i;\n//                 xor     ebx, ebx\n//\n// loc_403AA7:\n//                 mov     eax, ebx\n//                 call    changei\n//\n//      // Compute index (eax) = index * 9\n//      // (computed as index = index + index*8):\n//\n//                 lea     eax, [eax+eax*8]\n//\n//                 mov     ds:NineBytes[eax], ebx\n//                 inc     ebx\n//                 cmp     ebx, 10h\n//                 jnz     short loc_403AA7\n\nend.\n```", "```\n\n\t\t\ttypedef struct\n{\n    double EightBytes;\n    double EightMoreBytes;\n    float  SixteenBytes[4];\n} PowerOfTwoBytes;\n\nint i;\nPowerOfTwoBytes ThirtyTwoBytes[16];\n\nint changei(int i)\n{\n    return 15 - i;\n}\n\nint main( int argc, char **argv )\n{\n    for( i=0; i<16; ++i )\n    {\n        ThirtyTwoBytes[ changei(i) ].EightBytes = 0.0;\n    }\n\n    // @5:\n    //  push      ebx\n    //  call      _changei\n    //  pop       ecx           // Remove parameter\n    //\n    // Multiply index (in EAX) by 32.\n    // Note that (eax << 5) = eax * 32\n    //\n    //  shl       eax,5\n    //\n    // 8 bytes of zeros are the coding for\n    // (double) 0.0:\n    //\n    //  xor       edx,edx\n    //  mov       dword ptr [eax+_ThirtyTwoBytes],edx\n    //  mov       dword ptr [eax+_ThirtyTwoBytes+4],edx\n    //\n    // Finish up the for loop here:\n    //\n    //  inc       dword ptr [esi]   ;ESI points at i.\n    // @6:\n    //  mov       ebx,dword ptr [esi]\n    //  cmp       ebx,16\n    //  jl        short @5\n\n    return 0;\n}\n```", "```\ndata_type array_name [dim1][dim2]...[dimn];\n```", "```\nint threeDInts[ 4 ][ 2 ][ 8 ];\n```", "```\n\n\t\t\tvar\n    threeDInts:\n        array[0..3] of array[0..1] of array[0..7] of integer;\n\n    threeDInts2: array[0..3, 0..1, 0..7] of integer;\n```", "```\n\n\t\t\timport Foundation\n\nvar a1 = [[Int]]()\nvar a2 = ContiguousArray<Array<Int>>()\na1.append( [1,2,3] )\na1.append( [4,5,6] )\na2.append( [1,2,3] )\na2.append( [4,5,6] )\n\nprint( a1 )\nprint( a2 )\nprint( a1[0] )\nprint( a1[0][1] )\n```", "```\n\n\t\t\t[[1, 2, 3], [4, 5, 6]]\n[[1, 2, 3], [4, 5, 6]]\n[1, 2, 3]\n2\n```", "```\n\n\t\t\timport Foundation\n\nvar a2 = ContiguousArray<Array<Int>>()\na2.append( [1,2,3] )\na2.append( [4,5] )\n\nprint( a2 )\nprint( a2[0] )\nprint( a2[0][1] )\n```", "```\n\n\t\t\t[[1, 2, 3], [4, 5]]\n[1, 2, 3]\n2\n```", "```\nA:array[0..3,0..3] of char;\n```", "```\narray[ colindex ][ rowindex ]\n```", "```\nElement_Address =\n    Base_Address +\n        (colindex * row_size + rowindex) * Element_Size\n```", "```\nsomeType array[depth_size][col_size][row_size];\n```", "```\nAddress =\n    Base +\n        ((depth_index * col_size + col_index) *\n            row_size + row_index) * Element_Size\n```", "```\ntype A[bounds0] [bounds1] [bounds2] [bounds3];\n```", "```\nAddress =\n    Base +\n        (((i * bounds1 + j) * bounds2 + k) * bounds3 + m) *\n            Element_Size\n```", "```\ndataType array[bn-1][bn-2]...[b0];\n```", "```\narray[an-1][an-2]...[a1][a0]\n```", "```\nAddress := an-1\nfor i := n-2 downto 0 do\n    Address := Address * bi + ai\nAddress := Base_Address + Address * Element_Size\n```", "```\nElement_Address =\n    Base_Address +\n        (rowindex * col_size + colindex) *\n            Element_Size\n```", "```\nElement_Address =\n    Base_Address +\n        ((rowindex * col_size + colindex) *\n            depth_size + depthindex) *\n                Element_Size\n```", "```\nint ThreeDInts[ 8 ][ 2 ][ 4 ];\n```", "```\nThreeDInts[i][j][k] = n;\n```", "```\nElement_Address =\n    Base_Address +\n        ((i * col_size + j) * // col_size = 2\n            row_size + k) *   // row_size = 4\n                Element_Size\n```", "```\n\n\t\t\tintmul( 2, i, ebx );    // EBX = 2*i\nadd( j, ebx );          // EBX = 2*i + j\nintmul( 4, ebx );       // EBX = (2*i + j)*4\nadd( k, ebx );          // EBX = (2*i + j)*4 + k\nmov( n, eax );\nmov( eax, ThreeDInts[ebx*4] );  // ThreeDInts[i][j][k] = n; assumes 4-byte ints\n```", "```\n\n\t\t\tint i, j;\nint TwoByTwo[4][4];\n\nint main( int argc, char **argv )\n{\n    for( j=0; j<4; ++j )\n    {\n        for( i=0; i<4; ++i )\n        {\n            TwoByTwo[i][j] = i+j;\n        }\n    }\n    return 0;\n}\n```", "```\n\n\t\t\t    mov       ecx,offset _i\n    mov       ebx,offset _j\n   ;\n   ;    {\n   ;        for( j=0; j<4; ++j )\n   ;\n?live1@16: ; ECX = &i, EBX = &j\n    xor       eax,eax\n    mov       dword ptr [ebx],eax ;i = 0\n    jmp       short @3\n   ;\n   ;        {\n   ;            for( i=0; i<4; ++i )\n   ;\n@2:\n    xor       edx,edx\n    mov       dword ptr [ecx],edx ; j = 0\n\n; Compute the index to the start of the\n; current column of the array as\n; base( TwoByTwo ) + eax*4\\. Leave this\n; \"column base address\" in EDX:\n\n    mov       eax,dword ptr [ebx]\n    lea       edx,dword ptr [_TwoByTwo+4*eax]\n    jmp       short @5\n   ;\n   ;            {\n   ;                TwoByTwo[i][j] = i+j;\n   ;\n?live1@48: ; EAX = @temp0, EDX = @temp1, ECX = &i, EBX = &j\n@4:\n\n;\n    mov       esi,eax                  ; Compute i+j\n    add       esi,dword ptr [ebx]      ; EBX points at j's value\n\n    shl       eax,4                    ; Multiply row index by 16\n\n; Store the sum (held in ESI) into the specified array element.\n; Note that EDX contains the base address plus the column\n; offset into the array. EAX contains the row offset into the\n; array. Their sum produces the address of the desired array\n; element.\n\n    mov       dword ptr [edx+eax],esi  ; Store sum into element\n\n    inc       dword ptr [ecx]          ; increment i by 1\n@5:\n    mov       eax,dword ptr [ecx]      ; Fetch i's value\n    cmp       eax,4                    ; Is i less than 4?\n    jl        short @4                 ; If so, repeat inner loop\n    inc       dword ptr [ebx]          ; Increment j by 1\n@3:\n    cmp       dword ptr [ebx],4        ; Is j less than 4?\n    jl        short @2                 ; If so, repeat outer loop.\n   ;\n\n       .\n       .\n       .\n; Storage for the 4x4 (x4 bytes) two-dimensional array:\n; Total = 4*4*4 = 64 bytes:\n\n    align   4\n_TwoByTwo   label   dword\n    db  64  dup(?)\n```", "```\n\n\t\t\t; EDX = base address + columnIndex * 4\n\n    mov       eax,dword ptr [ebx]\n    lea       edx,dword ptr [_TwoByTwo+4*eax]\n      .\n      .\n      .\n; EAX = rowIndex, ESI = i+j\n\n    shl       eax,4                    ; Multiply row index by 16\n    mov       dword ptr [edx+eax],esi  ; Store sum into element\n```", "```\n\n\t\t\t#include <stdlib.h>\nint i, j, k;\nint ThreeByThree[3][3][3];\n\nint main( int argc, char **argv )\n{\n    for( j=0; j<3; ++j )\n    {\n        for( i=0; i<3; ++i )\n        {\n            for( k=0; k<3; ++k )\n            {\n                // Initialize the 27 array elements\n                // with a set of random values:\n\n                ThreeByThree[i][j][k] = rand();\n            }\n        }\n    }\n    return 0;\n}\n```", "```\n\n\t\t\t; Line 9\n        mov     DWORD PTR j, 0     // for( j = 0;...;... )\n        jmp     SHORT $LN4@main\n\n$LN2@main:\n        mov     eax, DWORD PTR j   // for( ...;...;++j )\n        inc     eax\n        mov     DWORD PTR j, eax\n\n$LN4@main:\n        cmp     DWORD PTR j, 4     // for( ...;j<4;... )\n        jge     $LN3@main\n\n; Line 11\n        mov     DWORD PTR i, 0     // for( i=0;...;... )\n        jmp     SHORT $LN7@main\n\n$LN5@main:\n        mov     eax, DWORD PTR i   // for( ...;...;++i )\n        inc     eax\n        mov     DWORD PTR i, eax\n\n$LN7@main:\n        cmp     DWORD PTR i, 4     // for( ...;i<4;... )\n        jge     SHORT $LN6@main\n\n; Line 13\n        mov     DWORD PTR k, 0     // for( k=0;...;... )\n        jmp     SHORT $LN10@main\n\n$LN8@main:\n        mov     eax, DWORD PTR k   // for( ...;...;++k )\n        inc     eax\n        mov     DWORD PTR k, eax\n\n$LN10@main:\n        cmp     DWORD PTR k, 3     // for( ...; k<3;... )\n        jge     SHORT $LN9@main\n\n; Line 18\n        call    rand\n        movsxd  rcx, DWORD PTR i   // Index =( (( ( i*3 + j ) * 3 + k ) * 4 )\n        imul    rcx, rcx, 36       // 00000024H\n        lea     rdx, OFFSET FLAT:ThreeByThree\n        add     rdx, rcx\n        mov     rcx, rdx\n        movsxd  rdx, DWORD PTR j\n        imul    rdx, rdx, 12\n        add     rcx, rdx\n        movsxd  rdx, DWORD PTR k\n//  ThreeByThree[i][j][k] = rand();\n\n        mov     DWORD PTR [rcx+rdx*4], eax\n\n; Line 19\n        jmp     SHORT $LN8@main // End of for( k = 0; k<3; ++k )\n$LN9@main:\n; Line 20\n        jmp     SHORT $LN5@main // End of for( i = 0; i<4; ++i )\n$LN6@main:\n; Line 21\n        jmp     $LN2@main       // End of for( j = 0; j<4; ++j )\n$LN3@main:\n```", "```\n\n\t\t\tint array[ NumRows ][ NumCols ];\n```", "```\nelement = array[ rowIndex ][ colIndex ]\n```", "```\n\n\t\t\tfor( row=0; row<NumRows; ++row )\n{\n    for( col=0; col<NumCols; ++col )\n    {\n        array[ row ][ col ] = 0;\n    }\n}\n```", "```\n\n\t\t\tfor( row=0; row<NumRows; ++row )\n{\n    for( col=0; col<NumCols; ++col )\n    {\n        array[ col ][ row ] = 0;\n    }\n}\n```", "```\n\n\t\t\tint columnMajor[ NumCols * NumRows ]; // Allocate storage\n    .\n    .\n    .\nfor( row=0; row<NumRows; ++row)\n{\n    for( col=0; col<NumCols; ++col )\n    {\n        columnMajor[ col*NumRows + row ] = 0;\n    }\n}\n```", "```\n\n\t\t\timport Foundation\n\n// Create a 3-D array[4][4][4]:\n\nvar a1 = ContiguousArray<Int>( repeating:0, count:4*4*4 )\n\nfor var i in 0...3\n{\n    for var j in 0...3\n    {\n        for var k in 0...3\n        {\n            a1[ (i*4+j)*4 + k ] = (i*4+j)*4 + k\n        }\n    }\n}\nprint( a1 )\n```", "```\n\n\t\t\t[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,\n22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,\n41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n60, 61, 62, 63]\n```", "```\n\n\t\t\t#include <stdlib.h>\nint i, j, k;\nint ThreeByThreeByThree[3][3][3];\n\nint main( int argc, char **argv )\n{\n    // The important difference to note here is how\n    // the loops are arranged with the indices i, j, and k\n    // used so that i changes the slowest and k changes\n    // most rapidly (corresponding to row-major ordering).\n\n    for( i=0; i<3; ++i )\n    {\n        for( j=0; j<3; ++j )\n        {\n            for( k=0; k<3; ++k )\n            {\n                ThreeByThreeByThree[i][j][k] = 0;\n            }\n        }\n    }\n    return 0;\n}\n```", "```\n\n\t\t\t    push    edi\n;\n; The following code zeros out the 27 (3*3*3) elements\n; of the ThreeByThreeByThree array.\n\n    mov ecx, 27                 ; 0000001bH\n    xor eax, eax\n    mov edi, OFFSET FLAT:_ThreeByThreeByThree\n    rep stosd\n```", "```\n\n\t\t\tprogram slow;\n#include ( \"stdlib.hhf\" )\nbegin slow;\n\n    // A dynamically allocated array accessed as follows:\n    // array [12][1000][1000]\n\n    malloc( 12_000_000 ); // Allocate 12,000,000 bytes\n    mov( eax, esi );\n\n    // Initialize each byte of the array to 0:\n\n    for( mov( 0, ecx ); ecx < 1000; inc( ecx ) ) do\n\n        for( mov( 0, edx ); edx < 1000; inc( edx ) ) do\n\n            for( mov( 0, ebx ); ebx < 12; inc( ebx ) ) do\n\n                // Compute the index into the array\n                // as EBX*1_000_000 + EDX*1_000 + ECX\n\n                intmul( 1_000_000, ebx, eax );\n                intmul( 1_000, edx, edi );\n                add( edi, eax );\n                add( ecx, eax );\n                mov( 0, (type byte [esi+eax]) );\n\n            endfor;\n\n        endfor;\n\n    endfor;\n\nend slow;\n```", "```\ndim dynamicArray[ i * 2 ]\n```", "```\n\n\t\t\tvoid usesPDArray( int aSize )\n{\n    int array[ aSize ];\n        .\n        .\n        .\n} /* end of function usesPDArray */\n```", "```\n\n\t\t\tvoid usesPDArray( int aSize )\n{\n    int *array;\n\n    array = (int *) malloc( aSize * sizeof( int ) );\n        .\n        .\n        .\n    free( array );\n\n} /* end of function usesPDArray */\n```", "```\n\n\t\t\ttype\n    dopeVector2D :\n        record\n            ptrToArray :pointer to int32;\n            bounds :uns32[2];\n        endrecord;\n```", "```\n\n\t\t\tvar\n    pdArray :dopeVector2D;\n        .\n        .\n        .\nstdout.put( \"Enter array dimension #1:\" );\nstdin.get( pdArray.bounds[0] );\nstdout.put( \"Enter array dimension #2:\" );\nstdin.get( pdArray.bounds[4] );  //Remember, '4' is a\n                                 // byte offset into bounds.\n// To allocate storage for the array, we must\n// allocate bounds[0]*bounds[4]*4 bytes:\n\nmov( pdArray.bounds[0], eax );\n\n// bounds[0]*bounds[4] -> EAX\n\nintmul( pdArray.bounds[4], eax );\n\n// EAX := EAX * 4 (4=size of int32).\n\nshl( 2, eax );\n\n// Allocate the bytes for the array.\n\nmalloc( eax );\n\n// Save away base address.\n\nmov( eax, pdArray.ptrToArray );\n```", "```\n\n\t\t\ttypedef struct\n{\n    int *ptrtoArray;\n    int bounds[2];\n} dopeVector2D;\n\ndopeVector2D pdArray;\n        .\n        .\n        .\n    // Allocate storage for the pseudo-dynamic array:\n\n    cout << \"Enter array dimension #1:\";\n    cin >> pdArray.bounds[0];\n    cout << \"Enter array dimension #2:\" ;\n    cin >> pdArray.bounds[1];\n    pdArray.ptrtoArray =\n        new int[ pdArray.bounds[0] * pdArray.bounds[1] ];\n        .\n        .\n        .\n    // Set all the elements of this dynamic array to\n    // successive integer values:\n\n    k = 0;\n    for( i=0; i < pdArray.bounds[0]; ++i )\n    {\n        for( j=0; j < pdArray.bounds[1]; ++j )\n        {\n            // Use row-major ordering to access\n            // element [i][j]:\n\n            *(pdArray.ptrtoArray + i*pdArray.bounds[1] + j) = k;\n            ++k;\n        }\n    }\n```", "```\n\n\t\t\t#include <stdlib.h>\n\nint main( int argc, char **argv )\n{\n\n    // Allocate storage for a 3x3x3 dynamic array:\n\n    int *iptr = (int*) malloc( 3*3*3 *4 );\n    int depthIndex;\n    int rowIndex;\n    int colIndex;\n\n    // A pseudo-static 3x3x3 array for comparison:\n\n    int ssArray[3][3][3];\n\n    // The following nested for loops initialize all\n    // the elements of the dynamic 3x3x3 array with\n    // zeros:\n\n    for( depthIndex=0; depthIndex<3; ++depthIndex )\n    {\n        for( rowIndex=0; rowIndex<3; ++rowIndex )\n        {\n            for( colIndex=0; colIndex<3; ++colIndex )\n            {\n                iptr\n                [\n                    // Row-major order computation:\n\n                      ((depthIndex*3) + rowIndex)*3\n                    + colIndex\n\n                ] = 0;\n            }\n        }\n    }\n\n    // The following three nested loops are comparable\n    // to the above, but they initialize the elements\n    // of a pseudo-static array. Because the compiler\n    // knows the array bounds at compile time, it can\n    // generate better code for this sequence.\n\n    for( depthIndex=0; depthIndex<3; ++depthIndex )\n    {\n        for( rowIndex=0; rowIndex<3; ++rowIndex )\n        {\n            for( colIndex=0; colIndex<3; ++colIndex )\n            {\n                ssArray[depthIndex][rowIndex][colIndex] = 0;\n            }\n        }\n    }\n\n    return 0;\n}\n```", "```\n\n\t\t\t    .section __TEXT,__text,regular,pure_instructions\n\n_main:\n\n// Allocate storage for local variables\n// (192 bytes, includes the ssArray,\n// loop control variables, other stuff,\n// and padding to 64 bytes):\n\n    mflr r0\n    stw r0,8(r1)\n    stwu r1,-192(r1)\n\n// Allocate 108 bytes of storage for\n// the 3x3x3 array of 4-byte ints.\n// This call to  malloc leaves the\n// pointer to the array in R3.\n    li r3,108\n    bl L_malloc$stub\n\n    li r8,0     // R8= depthIndex\n    li r0,0\n\n    // R10 counts off the number of\n    // elements in rows we've processed:\n\n    li r10,0\n\n// Top of the outermost for loop\n\nL16:\n    // Compute the number of bytes\n    // from the beginning of the\n    // array to the start of the\n    // row we are about to process.\n    // Each row contains 12 bytes and\n    // R10 contains the number of rows\n    // processed so far. The product\n    // of 12 by R10 gives us the number\n    // of bytes to the start of the\n    // current row. This value is put\n    // into R9:\n\n    mulli r9,r10,12\n\n    li r11,0    // R11 = rowIndex\n\n// Top of the middle for loop\n\nL15:\n    li r6,3     // R6/CTR = colIndex\n\n    // R3 is the base address of the array.\n    // R9 is the index to the start of the\n    // current row, computed by the MULLI\n    // instruction, above. R2 will now\n    // contain the base address of the\n    // current row in the array.\n\n    add r2,r9,r3\n\n    // CTR = 3\n\n    mtctr r6\n\n    // Repeat the following loop\n    // once for each element in\n    // the current row of the array:\n\nL45:\n    stw r0,0(r2)    // Zero out current element\n    addi r2,r2,4    // Move on to next element\n    bdnz L45        // Repeat loop CTR times\n\n    addi r11,r11,1  // Bump up RowIndex by 1\n    addi r9,r9,12   // Index of next row in array\n    cmpwi cr7,r11,2 // Repeat for RowIndex=0..2\n    ble+ cr7,L15\n\n    addi r8,r8,1    // Bump up depthIndex by 1\n    addi r10,r10,3  // Bump up element cnt by 3\n    cmpwi cr7,r8,2  // Repeat for depthIndex=0..2\n    ble+ cr7,L16\n\n/////////////////////////////////////////////////////\n//\n// Here's the code that initializes the pseudo-static\n// array:\n\n    li r8,0         // DepthIndex = 0\n    addi r10,r1,64  // Compute base address of ssArray\n    li r0,0\n    li r7,0         // R7 is index to current row\nL31:\n    li r11,0        // RowIndex = 0\n    slwi r9,r7,2    // Convert row/int index to\n                    // row/byte index (int_index*4)\nL30:\n    li r6,3         // # iterations for colIndex\n    add r2,r9,r10   // Base+row_index = row address\n    mtctr r6        // CTR = 3\n\n// Repeat innermost loop three times:\n\nL44:\n    stw r0,0(r2)    // Zero out current element\n    addi r2,r2,4    // Bump up to next element\n    bdnz L44        // Repeat CTR times\n\n    addi r11,r11,1  // Bump up RowIndex by 1\n    addi r9,r9,12   // R9=Adrs of start of next row\n    cmpwi cr7,r11,2 // Repeat until RowIndex >=3\n    ble+ cr7,L30\n\n    addi r8,r8,1    // Bump up depthIndex by 1\n    addi r7,r7,9    // Index of next depth in array\n    cmpwi cr7,r8,2\n    ble+ cr7,L31\n\n    lwz r0,200(r1)\n    li r3,0\n    addi r1,r1,192\n    mtlr r0\n    blr\n```"]