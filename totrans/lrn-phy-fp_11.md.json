["```\n{-# OPTIONS -Wall #-}\n\nmodule SimpleVec where\n\ninfixl 6 ^+^\ninfixl 6 ^-^\ninfixr 7 *^\ninfixl 7 ^*\ninfixr 7 ^/\ninfixr 7 <.>\ninfixl 7 ><\n```", "```\ntype VecDerivative = (R -> Vec) -> R -> Vec\n```", "```\nvecDerivative :: R -> VecDerivative\nvecDerivative dt v t = (v (t + dt/2) ^-^ v (t - dt/2)) ^/ dt\n```", "```\n*SimpleVec> vec 1 2 3 ^+^ vec 4 5 6\nvec 5.0 7.0 9.0\n```", "```\n*SimpleVec> 5 *^ vec 1 2 3\nvec 5.0 10.0 15.0\n```", "```\n*SimpleVec> vec 1 2 3 ^* 5\nvec 5.0 10.0 15.0\n```", "```\n*SimpleVec> vec 1 2 3 ^/ 5\nvec 0.2 0.4 0.6\n```", "```\n*SimpleVec> vec 1 2 3 ^-^ vec 4 5 6\nvec (-3.0) (-3.0) (-3.0)\n```", "```\n*SimpleVec> vec 1 2 3 <.> vec 4 5 6\n32.0\n```", "```\n*SimpleVec> vec 1 2 3 >< vec 4 5 6\nvec (-3.0) 6.0 (-3.0)\n```", "```\n*SimpleVec> xComp $ vec 1 2 3 >< vec 4 5 6\n-3.0\n```", "```\n*SimpleVec> negateV $ vec 1 2 3 >< vec 4 5 6\nvec 3.0 (-6.0) 3.0\n```", "```\nv1 :: R -> Vec\nv1 t = 2 *^ t**2 *^ iHat ^+^ 3 *^ t**3 *^ jHat ^+^ t**4 *^ kHat\n```", "```\nxCompFunc :: (R -> Vec) -> R -> R\nxCompFunc v t = xComp (v t)\n```", "```\nxCompFunc . vecDerivative dt\n```", "```\nderivative dt . xCompFunc\n```", "```\n*SimpleVec>  (xCompFunc . vecDerivative 0.01) v1 3\n11.999999999999744\n*SimpleVec>  (derivative 0.01 . xCompFunc) v1 3\n11.999999999999744\n```", "```\ntype Derivative = (R -> R) -> R -> R\n\nderivative :: R -> Derivative\nderivative dt x t = (x (t + dt/2) - x (t - dt/2)) / dt\n```", "```\ntype Time         = R\ntype PosVec       = Vec\ntype Velocity     = Vec\ntype Acceleration = Vec\n```", "```\nvelFromPos :: R                   -- dt\n           -> (Time -> PosVec  )  -- position function\n           -> (Time -> Velocity)  -- velocity function\nvelFromPos = vecDerivative\n```", "```\naccFromVel :: R                       -- dt\n           -> (Time -> Velocity)      -- velocity function\n           -> (Time -> Acceleration)  -- acceleration function\naccFromVel = vecDerivative\n```", "```\npositionCV :: PosVec -> Velocity -> Time -> PosVec\npositionCV r0 v0 t = v0 ^* t ^+^ r0\n```", "```\nvelocityCA :: Velocity -> Acceleration -> Time -> Velocity\nvelocityCA v0 a0 t = a0 ^* t ^+^ v0\n```", "```\npositionCA :: PosVec -> Velocity -> Acceleration\n           -> Time -> PosVec\npositionCA r0 v0 a0 t = 0.5 *^ t**2 *^ a0 ^+^ v0 ^* t ^+^ r0\n```", "```\naParallel :: Vec -> Vec -> Vec\naParallel v a = let vHat = v ^/ magnitude v\n                in (vHat <.> a) *^ vHat\n\naPerp :: Vec -> Vec -> Vec\naPerp v a = a ^-^ aParallel v a\n```", "```\nspeedRateChange :: Vec -> Vec -> R\nspeedRateChange v a = (v <.> a) / magnitude v\n```", "```\nradiusOfCurvature :: Vec -> Vec -> R\nradiusOfCurvature v a = (v <.> v) / magnitude (aPerp v a)\n```", "```\nprojectilePos :: PosVec -> Velocity -> Time -> PosVec\nprojectilePos r0 v0 = positionCA r0 v0 (9.81 *^ negateV kHat)\n```", "```\ntype R = Double\n```", "```\ndata Mass = Mass R\n            deriving (Eq,Show)\n```", "```\n*SimpleVec> Mass 9\nMass 9.0\n```", "```\n*SimpleVec>  :t Mass 9\nMass 9 :: Mass\n```", "```\n*SimpleVec> :t Mass\nMass :: R -> Mass\n```", "```\ndata Grade = Grade String Int\n             deriving (Eq,Show)\n```", "```\ngrades :: [Grade]\ngrades = [Grade \"Albert Einstein\" 89\n         ,Grade \"Isaac Newton\"    95\n         ,Grade \"Alan Turing\"    91\n         ]\n```", "```\n*SimpleVec> :t Grade\nGrade :: String -> Int -> Grade\n```", "```\ndata GradeRecord = GradeRecord { name  :: String\n                               , grade :: Int\n                               } deriving (Eq,Show)\n```", "```\n*SimpleVec> :t name\nname :: GradeRecord -> String\n*SimpleVec> :t grade\ngrade :: GradeRecord -> Int\n```", "```\ngradeRecords1 :: [GradeRecord]\ngradeRecords1 = [GradeRecord \"Albert Einstein\" 89\n                ,GradeRecord \"Isaac Newton\"    95\n                ,GradeRecord \"Alan Turing\"    91\n                ]\n```", "```\ngradeRecords2 :: [GradeRecord]\ngradeRecords2 = [GradeRecord {name = \"Albert Einstein\", grade = 89}\n                ,GradeRecord {name = \"Isaac Newton\"   , grade = 95}\n                ,GradeRecord {name = \"Alan Turing\"    , grade = 91}\n                ]\n```", "```\ndata MyBool = MyFalse | MyTrue\n              deriving (Eq,Show)\n```", "```\n*SimpleVec> :t MyFalse\nMyFalse :: MyBool\n```", "```\ndata MyMaybe a = MyNothing\n               | MyJust a\n               deriving (Eq,Show)\n```", "```\n*SimpleVec> :t MyNothing\nMyNothing :: MyMaybe a\n*SimpleVec> :t MyJust\nMyJust :: a -> MyMaybe a\n```", "```\n*SimpleVec> :t Nothing\nNothing :: Maybe a\n*SimpleVec> :t Just\nJust :: a -> Maybe a\n```", "```\ntype Vec = [R]  -- not our definition\n```", "```\ntype Vec = (R,R,R)  -- not our definition\n```", "```\ndata Vec = Vec { xComp :: R  -- x component\n               , yComp :: R  -- y component\n               , zComp :: R  -- z component\n               } deriving (Eq)\n```", "```\ninstance Show Vec where\n    show (Vec x y z) = \"vec \" ++ showDouble x ++ \" \"\n                              ++ showDouble y ++ \" \"\n                              ++ showDouble z\n```", "```\nshowDouble :: R -> String\nshowDouble x\n    | x < 0      = \"(\" ++ show x ++ \")\"\n    | otherwise  = show x\n```", "```\n-- Form a vector by giving its x, y, and z components.\nvec :: R  -- x component\n    -> R  -- y component\n    -> R  -- z component\n    -> Vec\nvec = Vec\n```", "```\niHat :: Vec\niHat = vec 1 0 0\n\njHat :: Vec\njHat = vec 0 1 0\n\nkHat :: Vec\nkHat = vec 0 0 1\n```", "```\nzeroV :: Vec\nzeroV = vec 0 0 0\n```", "```\nnegateV :: Vec -> Vec\nnegateV (Vec ax ay az) = Vec (-ax) (-ay) (-az)\n```", "```\n(^+^) :: Vec -> Vec -> Vec\nVec ax ay az ^+^ Vec bx by bz = Vec (ax+bx) (ay+by) (az+bz)\n\n(^-^) :: Vec -> Vec -> Vec\nVec ax ay az ^-^ Vec bx by bz = Vec (ax-bx) (ay-by) (az-bz)\n```", "```\nsumV :: [Vec] -> Vec\nsumV = foldr (^+^) zeroV\n```", "```\n(*^)  :: R   -> Vec -> Vec\nc *^ Vec ax ay az = Vec (c*ax) (c*ay) (c*az)\n\n(^*)  :: Vec -> R   -> Vec\nVec ax ay az ^* c = Vec (c*ax) (c*ay) (c*az)\n\n(<.>) :: Vec -> Vec -> R\nVec ax ay az <.> Vec bx by bz = ax*bx + ay*by + az*bz\n\n(><)  :: Vec -> Vec -> Vec\nVec ax ay az >< Vec bx by bz\n    = Vec (ay*bz - az*by) (az*bx - ax*bz) (ax*by - ay*bx)\n```", "```\n(^/) :: Vec -> R -> Vec\nVec ax ay az ^/ c = Vec (ax/c) (ay/c) (az/c)\n```", "```\nmagnitude :: Vec -> R\nmagnitude v = sqrt(v <.> v)\n```", "```\nvecIntegral :: R          -- step size dt\n            -> (R -> Vec) -- vector-valued function\n            -> R          -- lower limit\n            -> R          -- upper limit\n            -> Vec        -- result\nvecIntegral = undefined\n```", "```\nintegral :: R -> (R -> R) -> R -> R -> R -- from Chapter 6\n```", "```\nmaxHeight :: PosVec -> Velocity -> R\nmaxHeight = undefined\n```", "```\nspeedCA :: Velocity -> Acceleration -> Time -> R\nspeedCA = undefined\n```", "```\nmagAngleFromVec2D :: Vec2D -> (R,R)\nmagAngleFromVec2D = undefined\n\nvec2DFromMagAngle :: (R,R) -> Vec2D\nvec2DFromMagAngle = undefined\n```", "```\nxyProj :: Vec -> Vec\nxyProj = undefined\n```", "```\nmagAngles :: Vec -> (R,R,R)\nmagAngles = undefined\n```", "```\n(3.7416573867739413,2.5010703409103687,-2.0344439357957027)\n```", "```\ngEarth :: Vec\ngEarth = undefined\n```", "```\nvBall :: R -> Vec\nvBall t = undefined t\n```", "```\nspeedRateChangeBall :: R -> R\nspeedRateChangeBall t = undefined t\n```", "```\nrNCM :: (R, R -> R) -> R -> Vec\nrNCM (radius, theta) t = undefined radius theta t\n```", "```\naPerpFromPosition :: R -> (R -> Vec) -> R -> Vec\naPerpFromPosition epsilon r t\n    = let v = vecDerivative epsilon r\n          a = vecDerivative epsilon v\n      in aPerp (v t) (a t)\n```"]