- en: '**8**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**8**'
- en: '**ATTACKING ECUS AND OTHER EMBEDDED SYSTEMS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**攻击ECU和其他嵌入式系统**'
- en: '![image](graphics/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/common-01.jpg)'
- en: The ECU is a common target of reverse engineering, sometimes referred to as
    chip tuning. As mentioned in [Chapter 7](ch07.html#ch07), the most popular ECU
    hack is modifying the fuel map to alter the balance of fuel efficiency and performance
    in order to give you a higher-performance vehicle. There’s a large community involved
    with these types of modifications, and we’ll go into more detail on firmware modifications
    like this in [Chapter 13](ch13.html#ch13).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: ECU是反向工程的常见目标，有时也称为芯片调优。如[第7章](ch07.html#ch07)所述，最流行的ECU破解方法是修改燃油地图，以改变燃油效率与性能之间的平衡，从而提升车辆性能。参与这些类型修改的社区非常庞大，我们将在[第13章](ch13.html#ch13)中更详细地讨论这类固件修改。
- en: This chapter will focus on generic embedded-system methods of attack as well
    as side-channel attacks. These methodologies can be applied to any embedded system,
    not just to the ECU, and they may even be used to modify a vehicle with the help
    of aftermarket tools. Here, we’ll focus on debugging interfaces for hardware as
    well as performing side-channel analysis attacks and glitching attacks.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将专注于通用的嵌入式系统攻击方法以及旁路攻击。这些方法不仅可以应用于ECU，也适用于任何嵌入式系统，甚至可以借助后市场工具修改车辆。在这里，我们将重点讨论硬件的调试接口以及执行旁路分析攻击和故障攻击。
- en: '**NOTE**'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*To get the most out of this chapter, you should have a good understanding
    of basic electronics, but I’ve done my best to explain things within reason.*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了充分理解本章内容，你应该对基础电子学有一定了解，但我已经尽力在合理范围内进行解释。*'
- en: '**Analyzing Circuit Boards**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**分析电路板**'
- en: The first step in attacking the ECU or any embedded system in a vehicle is to
    analyze the target circuit board. I touched upon circuit board analysis in [Chapter
    7](ch07.html#ch07), but in this chapter, I’ll go into more detail about how electronics
    and chips work. I’ll introduce you to techniques that can be applied to any embedded
    system in the vehicle.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击ECU或任何车辆中的嵌入式系统的第一步是分析目标电路板。我在[第7章](ch07.html#ch07)中简要介绍了电路板分析，但在本章中，我将更详细地介绍电子设备和芯片的工作原理。我将向你介绍一些可以应用于车辆中任何嵌入式系统的技术。
- en: '***Identifying Model Numbers***'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***识别型号***'
- en: When reversing a circuit board, first look at the model numbers of the microcontroller
    chips on the board. These model numbers can help you track down valuable information
    that can be key to your analysis. Most of the chips you’ll find on vehicle circuit
    boards are generic—companies rarely make custom ones—so an Internet search of
    a chip’s model number can provide you with the complete data sheet for that chip.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在反向工程电路板时，首先查看电路板上微控制器芯片的型号。这些型号可以帮助你追踪到有价值的信息，这些信息可能是你分析的关键。你在车辆电路板上找到的大多数芯片都是通用型的——公司很少制造定制芯片——因此，搜索芯片型号通常可以为你提供该芯片的完整数据表。
- en: As mentioned in [Chapter 7](ch07.html#ch07), you’ll sometimes run into custom
    ASIC processors with custom opcodes, especially in older systems, which will be
    harder to reprogram. When you encounter older chips like these, remove them from
    the board and plug them in to an EPROM programmer in order to read their firmware.
    You should be able to reprogram modern systems directly via debugging software,
    like JTAG.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第7章](ch07.html#ch07)所述，你有时会遇到定制的ASIC处理器和定制的操作码，尤其是在旧系统中，这些处理器会更加难以重新编程。当你遇到像这样的旧芯片时，应该将它们从电路板上取下，并插入EPROM编程器中以读取其固件。你应该能够通过调试软件，如JTAG，直接重新编程现代系统。
- en: Once you locate a data sheet, try to identify the microcontrollers and memory
    locations on each chip to determine how things are wired together and where to
    find diagnostic pins—a potential way in.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到数据表，尝试识别每个芯片上的微控制器和内存位置，以确定各个组件如何连接在一起，以及如何找到诊断引脚——这可能是一个潜在的突破口。
- en: '***Dissecting and Identifying a Chip***'
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***拆解与识别芯片***'
- en: If you can’t find a model number, sometimes all you’ll have to go on is the
    chip’s logo (after a while, you’ll find that you start to recognize chip logos)
    and a few of its product codes. The logo shown in [Figure 8-1](ch08.html#ch8fig1)
    is for STMicroelectronics. At the top of the chip is the model number—in this
    case, STM32F407—which may be hard to read because it’s engraved. Often, a light-up
    magnifier or a cheap USB microscope can prove very handy in reading these markings.
    Go to *[http://www.st.com/](http://www.st.com/)* to find the data sheet for the
    STM32F series chips, specifically the 407 variety. Much like VIN numbers, model
    numbers are often broken down into sections representing model number and different
    variations. There’s no standard for how to break down these numbers, however,
    and every manufacturer will represent their data differently.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你找不到型号，有时你只能依靠芯片的标志（过一段时间后，你会发现自己开始认识芯片的标志）和几个产品代码来判断。图[8-1](ch08.html#ch8fig1)中显示的标志是STMicroelectronics的标志。在芯片的顶部是型号——在这个例子中是STM32F407——可能因为是刻印的，所以很难看清。通常，带有背光的放大镜或便宜的USB显微镜对读取这些标记非常有帮助。请访问*[http://www.st.com/](http://www.st.com/)*
    查找STM32F系列芯片的数据手册，特别是407型号的。如果你仔细观察，会发现型号像汽车的VIN号一样，通常会分解成几个部分，分别表示型号和不同的变种。然而，没有标准化的方法来拆解这些数字，每个制造商都会有自己表示数据的方式。
- en: '![image](graphics/f08-01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f08-01.jpg)'
- en: '*Figure 8-1: STM32 chipset identification*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-1：STM32芯片识别*'
- en: Below the chip’s model number is the code—in this case, VGT6—which tells you
    the specific features, such as USB support, available on the chip. If you look
    up the model number in conjunction with the ST code, you’ll learn that the STM32F407Vx
    series is an ARM Cortext M4 chip with support for Ethernet, USB, two CANs, and
    LIN as well as JTAG and Serial Wire Debug.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在芯片的型号下方是代码——在这个例子中是VGT6——它告诉你芯片的特定功能，例如USB支持。如果你查找型号和ST代码，你会发现STM32F407Vx系列是支持以太网、USB、两个CAN和LIN以及JTAG和串行线调试的ARM
    Cortex M4芯片。
- en: To determine the function of the various pins, scan the data sheet to find the
    package pinout diagrams, and look for the package that matches yours for pin count.
    For example, as you can see in [Figure 8-1](ch08.html#ch8fig1), each side of the
    chip has 25 pins for a total of 100, which matches the LQFP100 pinout in the data
    sheet shown in [Figure 8-2](ch08.html#ch8fig2).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定各个引脚的功能，可以扫描数据手册，找到封装引脚分布图，并根据引脚数寻找与你的芯片匹配的封装。例如，如图[8-1](ch08.html#ch8fig1)所示，芯片的每一侧都有25个引脚，总共有100个引脚，这与数据手册中显示的LQFP100引脚分布图（见[图8-2](ch08.html#ch8fig2)）相符。
- en: Each chip will usually have a dot or dimple at pin 1 (see [Figure 8-1](ch08.html#ch8fig1)),
    and once you identify pin 1, you can follow the pinout to determine each pin’s
    function. Sometimes you’ll find two dimples, but one should be slightly more pronounced.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每个芯片通常会在第1引脚处有一个点或凹痕（见[图8-1](ch08.html#ch8fig1)），一旦你识别出第1引脚，就可以沿着引脚分布图确定每个引脚的功能。有时你会发现有两个凹痕，但其中一个应该会更明显一些。
- en: Sometimes pin 1 on a chip is indicated by a cut-off corner. If you find nothing
    on a chip that allows you to identify pin 1, look for things you *can* identify.
    For example, if another chip on the board is a common CAN transceiver, you could
    use a multitool to trace the lines to figure out which pins it connects to. You
    could then reference the data sheet to see which side of the chip contains these
    CAN pins. To do this, put your multimeter in continuity mode. Once in continuity
    mode, it will beep if you touch both pins to the same trace, indicating that they’re
    connected. Once you’re able to identify just one pin, you can use that information
    together with the pinout to deduce the pin layout.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有时芯片的第1引脚通过一个切角来表示。如果你在芯片上找不到任何能帮助你识别第1引脚的标记，可以寻找你*可以*识别的其他特征。例如，如果电路板上的另一颗芯片是常见的CAN收发器，你可以使用多功能工具追踪线路，找出它连接的引脚。然后，你可以参考数据手册，查看芯片的哪一侧包含这些CAN引脚。为了做到这一点，将万用表设置为连通性模式。一旦进入连通性模式，当你同时接触两个引脚到同一条线路时，万用表会发出蜂鸣声，表示它们已连接。识别出一个引脚后，你可以结合引脚分布图推断出引脚布局。
- en: '![image](graphics/f08-02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f08-02.jpg)'
- en: '*Figure 8-2: STM32F4 data sheet pinout*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-2：STM32F4数据手册引脚分布图*'
- en: '**Debugging Hardware with JTAG and Serial Wire Debug**'
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用JTAG和串行线调试进行硬件调试**'
- en: You can use a variety of debugging protocols to debug chips just as you do software.
    To determine which protocol your target chip supports, you’ll need to use the
    chip’s data sheet. You should be able to use a chip’s debugging port to intercept
    its processing and download and upload modifications to the chip’s firmware.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用各种调试协议来调试芯片，就像调试软件一样。要确定目标芯片支持哪种协议，你需要查阅芯片的数据手册。你应该能够使用芯片的调试端口来拦截其处理过程，并下载和上传对芯片固件的修改。
- en: '***JTAG***'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***JTAG***'
- en: JTAG is a protocol that allows for chip-level debugging and downloading and
    uploading firmware to a chip. You can locate the JTAG connections on a chip using
    its data sheet.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: JTAG 是一种协议，它允许进行芯片级调试以及固件的下载和上传。你可以通过查阅芯片的数据手册来定位 JTAG 连接。
- en: '**JTAGulator**'
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**JTAGulator**'
- en: You’ll often find pads on a chip’s circuit board that are broken out from the
    chip itself and that may give you access to the JTAG pins. To test the exposed
    pads for JTAG connections, use a tool like JTAGulator, shown in [Figure 8-3](ch08.html#ch8fig3).
    Plug all of the chip’s exposed pins in to the JTAGulator, and set the voltage
    to match the chip. JTAGulator should then find any JTAG pins and even walk the
    JTAG chain—a method of linking chips over JTAG—to see whether any other chips
    are attached.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你常常会在芯片的电路板上找到从芯片本身引出的焊盘，这些焊盘可能会给你提供 JTAG 引脚的访问权限。要测试暴露出来的焊盘是否为 JTAG 连接，可以使用像
    JTAGulator 这样的工具，如[图 8-3](ch08.html#ch8fig3)所示。将芯片暴露的所有引脚插入 JTAGulator，并设置电压以匹配芯片。然后，JTAGulator
    应该能够找到所有 JTAG 引脚，甚至可以遍历 JTAG 链——一种通过 JTAG 将芯片连接在一起的方法——以查看是否有其他芯片连接。
- en: '![image](graphics/f08-03.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f08-03.jpg)'
- en: '*Figure 8-3: JTAGulator with a Bus Pirate cable*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-3：带有总线海盗电缆的 JTAGulator*'
- en: JTAGulator supports either screw terminals or the use of a Bus Pirate cable
    (as in [Figure 8-3](ch08.html#ch8fig3)) for probing. Both the JTAGulator and the
    Bus Pirate cable use a serial interface to configure and interact with a chip.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: JTAGulator 支持使用螺丝接线端子或总线海盗电缆（如[图 8-3](ch08.html#ch8fig3)所示）进行探测。JTAGulator 和总线海盗电缆都使用串行接口来配置并与芯片进行交互。
- en: '**Debugging with JTAG**'
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**通过 JTAG 调试**'
- en: You can debug a chip with JTAG using just two wires, but it’s more common to
    use four or five pin connections. Of course, finding the JTAG connection is only
    the first step; usually, you’ll need to overcome additional protections that prevent
    you from just downloading the chip’s firmware in order to do anything interesting.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过仅使用两根线调试芯片，但更常见的是使用四或五个引脚连接。当然，找到 JTAG 连接只是第一步；通常，你还需要克服其他保护机制，这些保护机制会阻止你仅仅下载芯片的固件来进行一些有趣的操作。
- en: Developers will disable JTAG firmware via either software or hardware. When
    disabling JTAG in software, the programmer sets the JTD bit, which is usually
    enabled twice via software during runtime. If the bit it isn’t called twice within
    a short time, it’s not set. It’s possible to defeat a software protection like
    this by using a clock or power-glitching attack to skip at least one of these
    instructions. (We’ll discuss glitching attacks later in “[Fault Injection](ch08.html#ch08lev1sec5)”
    on [page 148](ch08.html#page_148).)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员会通过软件或硬件禁用 JTAG 固件。当通过软件禁用 JTAG 时，程序员会设置 JTD 位，通常在运行时通过软件启用两次。如果该位在短时间内没有被调用两次，则不会被设置。通过使用时钟或电源故障攻击来跳过这些指令中的至少一条，可以绕过这种软件保护。（我们将在
    “[故障注入](ch08.html#ch08lev1sec5)” 中讨论故障攻击，[第 148 页](ch08.html#page_148)中会有更多内容。）
- en: The other way to disable JTAG on a chip is to attempt to permanently disable
    programming by setting the JTAG fuse—OCDEN and JTAGEN—and thereby disabling both
    registers. This is harder to bypass with glitch attacks, though voltage glitching
    or the more invasive optical glitches may succeed. (Optical glitches entail decapping
    the chip and using a microscope and a laser, so they’re very costly. We won’t
    be covering them in this book.)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种禁用芯片 JTAG 的方法是通过设置 JTAG 融断器——OCDEN 和 JTAGEN——来尝试永久禁用编程，从而禁用这两个寄存器。这种方法较难通过故障攻击绕过，尽管电压故障或更具侵入性的光学故障可能成功。（光学故障包括拆除芯片外壳，使用显微镜和激光器进行操作，因此它们成本非常高。本书将不涉及此类故障。）
- en: '***Serial Wire Debug***'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***串行线调试***'
- en: Although JTAG is the most commonly used hardware debugging protocol, some microcontrollers—such
    as the STM32F4 series, which is commonly used in automotive applications because
    it has onboard CAN support—primarily use *Serial Wire Debug (SWD)*. While the
    ST32F4 series of ICs can support JTAG, they’re often wired to support only SWD
    because SWD requires only two pins instead of the five used for JTAG. SWD also
    allows overlapping of the JTAG pins, so these chips may support both JTAG and
    SWD by using the pins labeled *TCK* and *TMS*. (These pins are labeled *SWCLK*
    and *SWIO* in the data sheet.) When debugging ST chips, you can use a tool like
    ST-Link to connect, debug, and reflash the processor. ST-Link is cheap (about
    $20) compared to some of its JTAG counterparts. You can also use a STM32 Discovery
    board.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 JTAG 是最常用的硬件调试协议，但一些微控制器——例如 STM32F4 系列，因为它具有车载 CAN 支持，通常用于汽车应用——主要使用*串行线调试（SWD）*。虽然
    ST32F4 系列的 IC 支持 JTAG，但它们通常仅接线以支持 SWD，因为 SWD 只需要两个引脚，而 JTAG 需要五个引脚。SWD 还允许 JTAG
    引脚的重叠，因此这些芯片可能通过使用标记为*TCK* 和 *TMS* 的引脚来支持 JTAG 和 SWD。（在数据表中，这些引脚被标记为 *SWCLK* 和
    *SWIO*。）在调试 ST 芯片时，您可以使用像 ST-Link 这样的工具连接、调试并重新刷写处理器。与一些 JTAG 对应工具相比，ST-Link 非常便宜（约
    20 美元）。您也可以使用 STM32 开发板。
- en: '**The STM32F4DISCOVERY Kit**'
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**STM32F4DISCOVERY 套件**'
- en: The STM32F4DISCOVERY kit (sold by STM) is another tool you can use to debug
    and program these chips. These are actually developer boards with their own programmer.
    They cost about $15 and should be in your car hacking tool set. The benefit of
    using the Discovery kit is that it’s both a cheap programmer and a development
    board that you can use to to test modifications to the chip’s firmware.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: STM32F4DISCOVERY 套件（由 STM 销售）是另一个可以用来调试和编程这些芯片的工具。这些实际上是带有自带编程器的开发板。它们的价格大约为
    15 美元，应该包含在您的汽车破解工具集中。使用 Discovery 套件的好处是，它既是一个便宜的编程器，又是一个开发板，您可以用它来测试芯片固件的修改。
- en: In order to use the Discovery kit as a generic programmer, remove the jumpers
    from the pins labeled *ST-Link*, and then connect the six pins on the opposite
    side labeled *SWD* (see [Figure 8-4](ch08.html#ch8fig4)). Pin 1 starts next to
    the white dot on the SWD connector.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将 Discovery 套件用作通用编程器，请从标有 *ST-Link* 的引脚上移除跳线，然后连接对面标有 *SWD* 的六个引脚（参见[图 8-4](ch08.html#ch8fig4)）。引脚
    1 紧挨着 SWD 连接器上的白点。
- en: '[Table 8-1](ch08.html#ch8tab1) shows the pinout.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 8-1](ch08.html#ch8tab1) 显示了引脚分配图。'
- en: '**Table 8-1:** Pinout for the STM32F4DISCOVERY kit'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-1：** STM32F4DISCOVERY 套件引脚分配图'
- en: '| **STM32 chip** | **STM32F4DISCOVERY kit** |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| **STM32 芯片** | **STM32F4DISCOVERY 套件** |'
- en: '| --- | --- |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| VDD_TARGET | Pin 1 |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| VDD_TARGET | 引脚 1 |'
- en: '| SWLCK | Pin 2 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| SWLCK | 引脚 2 |'
- en: '| GND | Pin 3 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| GND | 引脚 3 |'
- en: '| SWDIO | Pin 4 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| SWDIO | 引脚 4 |'
- en: '| nRESET | Pin 5 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| nRESET | 引脚 5 |'
- en: '| SWO | Pin 6 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| SWO | 引脚 6 |'
- en: '![image](graphics/f08-04.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f08-04.jpg)'
- en: '*Figure 8-4: Programming a STM32 chip via the STM32F4DISCOVERY kit*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-4：通过 STM32F4DISCOVERY 套件编程 STM32 芯片*'
- en: You’ll most likely need to provide power to the target device, but instead of
    using pin 1 on the SWD connector, use the 3V pin from the Discovery portion of
    the board, as shown in [Figure 8-4](ch08.html#ch8fig4). (Notice in the pinout
    that the Discovery kit doesn’t use all six pins for SWD; pins nRESET and SWO are
    optional.)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您很可能需要为目标设备提供电源，但不是使用 SWD 连接器上的引脚 1，而是使用开发板中 Discovery 部分的 3V 引脚，如[图 8-4](ch08.html#ch8fig4)所示。（请注意，连接图中
    Discovery 套件没有使用 SWD 的所有六个引脚；引脚 nRESET 和 SWO 是可选的。）
- en: Once you’re connected, you’ll most likely want to read and write to the firmware.
    If you’re running Linux, you can get the ST-Link from GitHub at *[https://github.com/texane/stlink/](https://github.com/texane/stlink/)*.
    Once you have those utilities installed, you’ll not only be able to read and write
    to the chip’s flash memory, but you can also start a gdbserver to work as a real-time
    debugger.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦连接成功，您很可能想要读取和写入固件。如果您使用的是 Linux，您可以从 GitHub 获取 ST-Link，地址为*[https://github.com/texane/stlink/](https://github.com/texane/stlink/)*。安装这些工具后，您不仅可以读取和写入芯片的闪存，还可以启动
    gdbserver 来作为实时调试器使用。
- en: '***The Advanced User Debugger***'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***高级用户调试器***'
- en: Renesas is a popular automotive chipset used in ECUs (see [Figure 8-5](ch08.html#ch8fig5)).
    It has its own implementation over JTAG called the *Advanced User Debugger (AUD)*.
    AUD provides the same functionality as JTAG but with its own proprietary interface.
    As with SWD, AUD requires an interface specific to it in order to communicate
    with Renesas chipsets.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Renesas 是一种流行的汽车芯片集，广泛应用于 ECU（见[图 8-5](ch08.html#ch8fig5)）。它有自己的 JTAG 实现，称为
    *高级用户调试器（AUD）*。AUD 提供与 JTAG 相同的功能，但具有其专有的接口。与 SWD 一样，AUD 需要特定的接口才能与 Renesas 芯片集进行通信。
- en: '![image](graphics/f08-05.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-5: 2005 Acura TL ECU with Renesas SH MCU and AUD port*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '***Nexus***'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Nexus from Freescale/Power Architecture (now NXP) is another proprietary JTAG
    interface. Like AUD and SWD, this in-circuit debugger requires its own device
    in order to interface with it. When dealing with Freescale chips, such as the
    MCP5xxx series, keep in mind that the debugger may be Nexus.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: The Nexus interface uses a dedicated set of pins that should be defined in the
    chipset’s data sheet. Look for the EVTI/O pins in the auxiliary port section of
    the data sheet.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '**Side-Channel Analysis with the ChipWhisperer**'
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Side-channel analysis* is another hardware attack used to bypass ECU and other
    microcontroller protections and to crack built-in cryptography. This type of attack
    takes advantage of various characteristics of embedded electronic systems instead
    of directly targeting specific hardware or software. Side-channel attacks take
    many forms, and some can cost anywhere from $30,000 to $100,000 to perform because
    they require specialized equipment like electron microscopes. Expensive side-channel
    attacks like these are often invasive, meaning they’ll permanently alter the target.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: We’ll focus on simpler and cheaper side-channel attacks with the help of the
    ChipWhisperer, a noninvasive tool from NewAE Technologies (*[http://newae.com/chipwhisperer/](http://newae.com/chipwhisperer/)*).
    The ChipWhisperer is an open source side-channel analysis tool and framework that
    costs just over $1,000—considerably less than its non–open source counterparts,
    which typically start around $30,000.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '*It’s possible to accomplish the attacks I’ll discuss at less of a cost by
    building a specialized device, but the ChipWhisperer is the cheapest tool that
    covers all the main bases. Also, ChipWhisperer tutorials target open source designs,
    which makes them ideal for this book, since we can’t use examples from specific
    manufacturers due to copyright. I’ll integrate the NewAE tutorials throughout
    this chapter when demonstrating each attack.*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: The ChipWhisperer has an optional package that includes a target development
    board called the MultiTarget Victim Board (see [Figure 8-6](ch08.html#ch8fig6)).
    This board is mainly used for demonstration and training, and we’ll use it as
    the target of our demos as well.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f08-06.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-6: MultiTarget Victim Board*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'The MultiTarget Victim Board is basically three separate systems: an ATmega328,
    a XMEGA, and a smart card reader. (The ChipWhisperer can perform man-in-the-middle
    attacks on smart cards, but because cars don’t really use smart cards, we won’t
    cover that feature here.)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: By changing jumpers on the board, you can pass power to enable or disable different
    systems, but be careful to enable only one section at a time, or you may short
    the board. Pay attention to the jumper settings before testing.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '***Installing the Software***'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First install the ChipWhisperer software. The following instructions are for
    Linux, but you can find detailed setup instructions for Windows at *[http://www.newae.com/sidechannel/cwdocs/](http://www.newae.com/sidechannel/cwdocs/)*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先安装ChipWhisperer软件。以下说明适用于Linux系统，但你可以在*[http://www.newae.com/sidechannel/cwdocs/](http://www.newae.com/sidechannel/cwdocs/)*找到Windows的详细设置说明。
- en: 'The ChipWhisperer software requires Python 2.7 and some additional Python libraries
    to run. First, enter the following code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ChipWhisperer软件需要Python 2.7和一些额外的Python库才能运行。首先，输入以下代码：
- en: '[PRE0]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To get the ChipWhisperer software, you can either download a stable version
    as a ZIP file from the NewAE site or grab a copy from the GitHub repository, as
    shown here:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取ChipWhisperer软件，你可以从NewAE网站下载一个稳定版本的ZIP文件，或者从GitHub仓库获取一份，链接如下：
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The second `git` command downloads OpenADC. The OpenADC board of the ChipWhisperer
    is the oscilloscope part, which measures voltage signals and is basically the
    heart of the ChipWhisperer system. Use the following commands to set up the software
    (you should be root in the ChipWhisperer directory):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`git`命令会下载OpenADC。ChipWhisperer的OpenADC板是示波器部分，负责测量电压信号，基本上是ChipWhisperer系统的核心。使用以下命令来设置软件（你应该在ChipWhisperer目录下具有root权限）：
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The hardware is already natively supported by Linux, but you should add a group
    for the normal user that you’ll test so that the user can have access to the device
    without needing root privileges. To allow non-root users to use the equipment,
    create a *udev* file, such as */etc/udev/rules.d/99 -ztex.rules*, and add the
    following to that file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件已经原生支持Linux系统，但你应该为要测试的普通用户添加一个组，以便该用户可以访问设备，而不需要root权限。为了允许非root用户使用设备，创建一个*udev*文件，如*/etc/udev/rules.d/99
    -ztex.rules*，并将以下内容添加到该文件：
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Also, create a file for the AVR programmer called */etc/udev/rules.d/ 99-avrisp.rules*:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，为AVR编程器创建一个名为*/etc/udev/rules.d/99-avrisp.rules*的文件：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now add yourself (you’ll need to log out and back in for these new permissions
    to take effect):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加你的用户（你需要注销并重新登录，以便新权限生效）：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Connect the ChipWhisperer to your machine by plugging a mini-USB cable in to
    the side of the ChipWhisperer box. The green System Status light on the top should
    light up, and your ChipWhisperer should now be set up or at least in its unconfigured
    core.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 将ChipWhisperer通过插入mini-USB线连接到你的电脑。ChipWhisperer顶部的绿色系统状态指示灯应该会亮起，表示ChipWhisperer已设置好，或者至少处于未配置的核心状态。
- en: '***Prepping the Victim Board***'
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***准备受害者板***'
- en: 'To prep the Victim Board—or *device under test (DUT)*, as it’s referred to
    in the ChipWhisperer documentation—download the AVR Crypto library (the library
    isn’t included with the ChipWhisperer framework by default due to export laws)
    by entering the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备受害者板——或称为ChipWhisperer文档中的*设备待测（DUT）*——下载AVR加密库（由于出口法规，这个库默认不包含在ChipWhisperer框架中），通过输入以下命令进行下载：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We’ll use the AVRDUDESS GUI to program our Victim Board. You can get AVRDUDESS
    from its GitHub repository at *[https://github.com/zkemble/avrdudess/](https://github.com/zkemble/avrdudess/)*
    or grab binaries from sites such as *[http://blog.zakkemble.co.uk/avrdudess-a-gui-for-avrdude/](http://blog.zakkemble.co.uk/avrdudess-a-gui-for-avrdude/)*.
    You’ll need to install mono for this to work:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用AVRDUDESS GUI来编程我们的受害者板。你可以从其GitHub仓库获取AVRDUDESS，链接为*[https://github.com/zkemble/avrdudess/](https://github.com/zkemble/avrdudess/)*，或者从像*[http://blog.zakkemble.co.uk/avrdudess-a-gui-for-avrdude/](http://blog.zakkemble.co.uk/avrdudess-a-gui-for-avrdude/)*这样的站点下载二进制文件。你需要安装mono才能让它正常工作：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Next, make sure the Victim Board is set up to use the ATmega328 portion by changing
    the jumper settings to match the layout in [Figure 8-7](ch08.html#ch8fig7).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，确保受害者板配置为使用ATmega328部分，通过更改跳线设置，使其与[图8-7](ch08.html#ch8fig7)中的布局匹配。
- en: '![image](graphics/f08-07.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f08-07.jpg)'
- en: '*Figure 8-7: Jumper settings for the MultiTarget Victim Board*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-7：多目标受害者板的跳线设置*'
- en: Your ChipWhisperer should have come with a 20-pin ribbon cable. Plug this cable
    in to the back of the ChipWhisperer and the USB A/B cable in to the side, as shown
    in [Figure 8-8](ch08.html#ch8fig8). Dmesg should report seeing an AVRISP mkII
    plugged in, which is the programmer that we’ll use to program the target board.
    This will allow us to perform testing without disconnecting the device.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你的ChipWhisperer应该附带有一根20针的排线。按照图示，将这根线缆插入ChipWhisperer的后部，并将USB A/B线缆插入侧面，如[图8-8](ch08.html#ch8fig8)所示。Dmesg应该会报告识别到插入的AVRISP
    mkII，这是我们用来编程目标板的编程器。这样我们就可以在不拔掉设备的情况下进行测试。
- en: '![image](graphics/f08-08.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f08-08.jpg)'
- en: '*Figure 8-8: Wiring up the MultiTarget Victim Board*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-8：连接 MultiTarget 受害者板*'
- en: Finally, attach the SMA cable from the VOUT on the target board to the LNA connector
    in CH-A on the front of the ChipWhisperer. [Table 8-2](ch08.html#ch8tab2) shows
    the pinout. We’ll use this setup for our demos unless otherwise specified.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将 SMA 电缆从目标板上的 VOUT 连接到 ChipWhisperer 前面 CH-A 上的 LNA 接口。[表 8-2](ch08.html#ch8tab2)
    显示了引脚分配。除非另有说明，我们将使用此设置进行演示。
- en: '**Table 8-2:** Pinout for the MultiTarget Victim Board'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-2：** MultiTarget 受害者板的引脚分配'
- en: '| **Victim Board** | **ChipWhisperer** | **Component** |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| **受害者板** | **ChipWhisperer** | **组件** |'
- en: '| --- | --- | --- |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 20-pin connector | Back of the ChipWhisperer | 20-pin ribbon cable |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 20 针连接器 | ChipWhisperer 背面 | 20 针排线电缆 |'
- en: '| VOUT | LNA on CH-A | SMA cable |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| VOUT | LNA 在 CH-A 上 | SMA 电缆 |'
- en: '| Computer | Side of the ChipWhisperer | Mini USB cable |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 计算机 | ChipWhisperer 侧面 | Mini USB 电缆 |'
- en: '**Brute-Forcing Secure Boot Loaders in Power-Analysis Attacks**'
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**在功率分析攻击中暴力破解安全启动加载程序**'
- en: Now you have your Victim Board set up, we’ll look at using a power-analysis
    attack to brute-force a password. Power-analysis attacks involve looking at the
    power consumption of different chipsets to identify unique power signatures. By
    monitoring the power consumption for each instruction, it’s possible to determine
    the type of instruction being executed. For instance, a no-operation (NOP) instruction
    will use less power than a multiply (MUL) instruction. These differences can reveal
    how a system is configured or even whether a password is correct because a correct
    password character may use more power than an incorrect one.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经设置好了受害者板，我们将使用功率分析攻击来暴力破解密码。功率分析攻击通过观察不同芯片组的功率消耗来识别独特的功率特征。通过监控每条指令的功率消耗，可以确定正在执行的指令类型。例如，一个无操作（NOP）指令的功率消耗会比乘法（MUL）指令少。这些差异可以揭示系统的配置，甚至能判断密码是否正确，因为正确的密码字符可能会比错误的密码字符消耗更多的功率。
- en: In the following example, we’ll explore TinySafeBoot (*[http://jtxp.org/tech/tinysafeboot_en.htm](http://jtxp.org/tech/tinysafeboot_en.htm)*),
    a small, open source bootloader designed for AVR systems. The bootloader requires
    a password in order to make modifications. We’ll use the ChipWhisperer to exploit
    a vulnerability in its password-checking method and derive the password from the
    chip. This vulnerability has been fixed in newer versions of TinySafeBoot, but
    for practice, the old version is included in the *victims* folder of the ChipWhisperer
    framework. This tutorial is based on NewAE’s “Timing Analysis with Power for Attacking
    TSB” (*[http://www.newae.com/sidechannel/cwdocs/tutorialtimingpasswd.html](http://www.newae.com/sidechannel/cwdocs/tutorialtimingpasswd.html)*).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将探索 TinySafeBoot (*[http://jtxp.org/tech/tinysafeboot_en.htm](http://jtxp.org/tech/tinysafeboot_en.htm)*)，一个为
    AVR 系统设计的小型开源引导加载程序。该引导加载程序需要密码才能进行修改。我们将使用 ChipWhisperer 利用其密码检查方法中的漏洞，从芯片中推导出密码。这个漏洞在新版本的
    TinySafeBoot 中已被修复，但为了练习，旧版本已包含在 ChipWhisperer 框架的 *victims* 文件夹中。本教程基于 NewAE
    的“使用功率进行时序分析以攻击 TSB”(*[http://www.newae.com/sidechannel/cwdocs/tutorialtimingpasswd.html](http://www.newae.com/sidechannel/cwdocs/tutorialtimingpasswd.html)*)。
- en: '***Prepping Your Test with AVRDUDESS***'
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 AVRDUDESS 准备测试***'
- en: To begin, open AVRDUDESS and select **AVR ISP mkII** from the Programmer drop-down
    menu. Make sure you have ATmega328P selected in the MCU field, and then click
    **Detect** to verify that you’re connected to the ATmega328p (see [Figure 8-9](ch08.html#ch8fig9)).
    Select the flash file *hardware/victims/firmware/ tinysafeboot-20140331* in the
    Flash field.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开 AVRDUDESS 并从程序员下拉菜单中选择 **AVR ISP mkII**。确保在 MCU 字段中选择了 ATmega328P，然后点击
    **检测** 来验证你是否已连接到 ATmega328p（参见 [图 8-9](ch08.html#ch8fig9)）。在 Flash 字段中选择 *hardware/victims/firmware/tinysafeboot-20140331*
    作为闪存文件。
- en: '![image](graphics/f08-09.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f08-09.jpg)'
- en: '*Figure 8-9: Programming TinySafeBoot in AVRDUDESS*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-9：在 AVRDUDESS 中编程 TinySafeBoot*'
- en: Click **Program!** and AVRDUDESS should write the TinySafeBoot program to the
    ATmega.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **编程！**，AVRDUDESS 应该将 TinySafeBoot 程序写入 ATmega。
- en: '***Setting Up the ChipWhisperer for Serial Communications***'
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***设置 ChipWhisperer 用于串行通信***'
- en: 'Now we’re ready for testing! We’ll use the ChipWhisperer to set and monitor
    the power usage when the bootloader checks for the password. Then, we’ll use this
    information to build a tool to crack the password much faster than a traditional
    brute-force method would. To begin, set up the ChipWhisperer to communicate with
    the bootloader over the bootloader’s serial interface, like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备进行测试了！我们将使用 ChipWhisperer 设置并监控当引导程序检查密码时的功率使用情况。然后，我们将利用这些信息构建一个工具，比传统的暴力破解方法更快地破解密码。首先，设置
    ChipWhisperer 通过引导程序的串口接口与引导程序通信，像这样：
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The ChipWhisperer has lots of options, so we’ll go step by step through each
    setting you’ll need to change.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ChipWhisperer 有很多选项，所以我们将逐步介绍你需要更改的每个设置。
- en: In ChipWhispererCapture, go to the General Settings tab and set the Scope Module
    to **ChipWhisperer/OpenADC** and the Target Module to **Simple Serial**, as shown
    in [Figure 8-10](ch08.html#ch8fig10).
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 ChipWhispererCapture 中，转到常规设置选项卡，将 Scope 模块设置为 **ChipWhisperer/OpenADC**，将
    Target 模块设置为 **Simple Serial**，如 [图 8-10](ch08.html#ch8fig10) 所示。
- en: '![image](graphics/f08-10.jpg)'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](graphics/f08-10.jpg)'
- en: '*Figure 8-10: Setting the Scope and Target types*'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图 8-10：设置 Scope 和 Target 类型*'
- en: '![image](graphics/f08-11.jpg)'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](graphics/f08-11.jpg)'
- en: '*Figure 8-11: Setting Connection and Baud*'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图 8-11：设置连接和波特率*'
- en: Switch to the Target Settings tab (at the bottom of the window), and change
    the Connection setting to **ChipWhisperer**. Then under Serial Port Settings,
    set both TX Baud and RX Baud to **9600**, as shown in [Figure 8-11](ch08.html#ch8fig11).
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到目标设置选项卡（窗口底部），将连接设置更改为 **ChipWhisperer**。然后在串口设置下，将 TX Baud 和 RX Baud 都设置为
    **9600**，如 [图 8-11](ch08.html#ch8fig11) 所示。
- en: At the top of the screen, click the red circle next to Scope with *DIS* in it.
    The circle should become green and display *CON*.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕顶部，点击带有 *DIS* 的红色圆圈。圆圈应该变为绿色并显示 *CON*。
- en: The ChipWhisperer comes with a simple serial terminal interface. Choose **Tools
    ▸ Open Terminal** to open it. You should see a terminal like the one shown in
    [Figure 8-12](ch08.html#ch8fig12).
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ChipWhisperer 配备了一个简单的串口终端界面。选择 **工具 ▸ 打开终端** 来打开它。你应该会看到一个像 [图 8-12](ch08.html#ch8fig12)
    中所示的终端。
- en: '![image](graphics/f08-12.jpg)'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](graphics/f08-12.jpg)'
- en: '*Figure 8-12: ChipWhisperer serial terminal*'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图 8-12：ChipWhisperer 串口终端*'
- en: 'Set TX on Enter at the bottom of the terminal to **None**, and check the box
    that says **RX: Show non-ASCII as hex** (see [Figure 8-12](ch08.html#ch8fig12)).
    Now click **Connect** to enable your text areas.'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在终端底部，将 TX 设置为 **None**，并勾选 **RX: 显示非 ASCII 为十六进制**（参见 [图 8-12](ch08.html#ch8fig12)）。然后点击
    **连接** 以启用你的文本区域。'
- en: Enter **@@@** (TinySafeBoot’s start-up password) in the text field to the left
    of the Send button, and click **Send**. The bootloader should start with TSB and
    mainly contain information about the firmware version and AVR settings. TSB is
    just an identifier used by TinySafeBoot, most likely its initials. The output
    should match that in [Figure 8-12](ch08.html#ch8fig12).
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在发送按钮左侧的文本框中输入 **@@@**（TinySafeBoot 的启动密码），然后点击 **发送**。引导程序应该以 TSB 开头，并主要包含固件版本和
    AVR 设置的信息。TSB 只是 TinySafeBoot 使用的一个标识符，最有可能是其首字母缩写。输出应该与 [图 8-12](ch08.html#ch8fig12)
    中的内容匹配。
- en: '***Setting a Custom Password***'
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***设置自定义密码***'
- en: Now we need to set a custom password so that we can monitor the power levels
    when a password is entered.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要设置一个自定义密码，以便在输入密码时监控功率水平。
- en: First, close the serial terminal. Then enter the following lines in the Python
    console window, which is at the bottom center of the ChipWhisperer main window.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，关闭串口终端。然后在 ChipWhisperer 主窗口底部中央的 Python 控制台窗口中输入以下几行代码。
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We use the serial command `self.target.driver.ser.write("@@@")` to send the
    current password for the bootloader. Next, we enter the serial command `self.target.driver.ser.read(255)`
    to read up to the next 255 bytes from the bootloader to see its response to our
    sending the password (see [Figure 8-13](ch08.html#ch8fig13)).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用串口命令 `self.target.driver.ser.write("@@@")` 来发送当前的引导程序密码。接下来，我们输入串口命令 `self.target.driver.ser.read(255)`
    来从引导程序读取最多 255 个字节，以查看它对我们发送密码的响应（参见 [图 8-13](ch08.html#ch8fig13)）。
- en: '![image](graphics/f08-13.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f08-13.jpg)'
- en: '*Figure 8-13: Sending* `@@@` *via ChipWhisperer’s Python console*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-13：通过 ChipWhisperer 的 Python 控制台发送* `@@@`'
- en: 'For convenience, first assign the read and write commands to their own variables
    so you don’t have to enter such a long command (the following examples assume
    you’ve completed this step):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，首先将读写命令分配给各自的变量，这样就不需要每次都输入这么长的命令（以下示例假设你已经完成了这一步）：
- en: '[PRE10]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The password is stored in the last page of the device’s flash memory. We’ll
    grab that page, remove the confirmation `!` character from the response, and write
    a new password—`og`—to the firmware.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 密码存储在设备闪存的最后一页。我们将抓取该页面，去除响应中的确认`!`字符，并将新密码`og`写入固件中。
- en: '**NOTE**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You’ll find a more detailed explanation of this procedure in the NewAE tutorials*
    ([http://www.newae.com/sidechannel/cwdocs/tutorialtimingpasswd.html](http://www.newae.com/sidechannel/cwdocs/tutorialtimingpasswd.html))
    *or Python manuals*.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*您可以在NewAE教程* ([http://www.newae.com/sidechannel/cwdocs/tutorialtimingpasswd.html](http://www.newae.com/sidechannel/cwdocs/tutorialtimingpasswd.html))
    *或Python手册中找到对此过程的更详细解释*。'
- en: Return to the Python console, and enter [Listing 8-1](ch08.html#ch8list1).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 返回Python控制台，输入[清单8-1](ch08.html#ch8list1)。
- en: '[PRE11]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 8-1: Modifying the last page of memory to set the password to* `og`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单8-1：修改最后一页内存以将密码设置为* `og`'
- en: 'If the login times out, resend `@@@` like so:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果登录超时，像这样重新发送`@@@`：
- en: '[PRE12]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Once you’ve written the new characters to memory, verify that `og` is the new
    password with `write("og")`, followed by a `read(255)` in the Python console.
    Notice in [Figure 8-14](ch08.html#ch8fig14) that we first try sending `@@@` but
    that we don’t get a TinySafeBoot response until we send the `og` password.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您将新字符写入内存，使用`write("og")`验证`og`是新密码，然后在Python控制台中执行`read(255)`。请注意，在[图8-14](ch08.html#ch8fig14)中，我们首先尝试发送`@@@`，但是直到我们发送`og`密码时才收到TinySafeBoot响应。
- en: '![image](graphics/f08-14.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f08-14.jpg)'
- en: '*Figure 8-14: Setting the password to* `og`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-14：将密码设置为* `og`'
- en: '***Resetting the AVR***'
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***重置AVR***'
- en: 'Having changed the password, we can start reading power signals. First, we
    need to be able to get out of the infinite loop that the system goes into when
    we enter an incorrect password. Write a small script to reset the AVR when this
    happens. While still in the Python console, enter the following commands to create
    a resetAVR helper function:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 更改密码后，我们可以开始读取功率信号。首先，我们需要能够脱离系统在输入错误密码时进入的无限循环。编写一个小脚本，当发生这种情况时重置AVR。在Python控制台中输入以下命令以创建一个resetAVR辅助函数：
- en: '[PRE13]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***Setting Up the ChipWhisperer ADC***'
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***设置ChipWhisperer ADC***'
- en: Now, set up the ChipWhisperer ADC so that it knows how to record the power trace.
    Return to the ChipWhisperer main window, click the Scope tab, and set the values
    as shown in [Table 8-3](ch08.html#ch8tab3) and [Figure 8-15](ch08.html#ch8fig15).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，设置ChipWhisperer ADC，使其知道如何记录功率轨迹。返回ChipWhisperer主窗口，点击示波器标签，并按照[表8-3](ch08.html#ch8tab3)和[图8-15](ch08.html#ch8fig15)中的示例设置值。
- en: '**Table 8-3:** Scope Tab Settings to Set Up the OpenADC for the Victim Board'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**表8-3：** 配置OpenADC以设置受害者板的示波器标签'
- en: '| **Area** | **Category** | **Setting** | **Value** |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| **区域** | **类别** | **设置** | **值** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| OpenADC | Gain Setting | Setting | 40 |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| OpenADC | 增益设置 | 设置 | 40 |'
- en: '| OpenADC | Trigger Setup | Mode | Falling edge |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| OpenADC | 触发器设置 | 模式 | 下降沿 |'
- en: '| OpenADC | Trigger Setup | Timeout | 7 |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| OpenADC | 触发器设置 | 超时 | 7 |'
- en: '|  OpenADC  | ADC Clock | Source | EXTCLK x1 via DCM |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '|  OpenADC  | ADC时钟 | 来源 | EXTCLK x1通过DCM |'
- en: '| CW Extra | Trigger Pins | Front Panel A | Uncheck |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| CW附加功能 | 触发器引脚 | 前面板A | 取消勾选 |'
- en: '| CW Extra | Trigger Pins | Target IO1 (Serial TXD) | Check |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| CW附加功能 | 触发器引脚 | 目标IO1（串行TXD） | 勾选 |'
- en: '| CW Extra | Trigger Pins | Clock Source | Target IO-IN |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| CW附加功能 | 触发器引脚 | 时钟源 | 目标IO-IN |'
- en: '| OpenADC | ADC Clock | Reset ADC DCM | Push button |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| OpenADC | ADC时钟 | 重置ADC DCM | 按钮 |'
- en: '![image](graphics/f08-15.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f08-15.jpg)'
- en: '*Figure 8-15: ADC values to trigger on Serial TX*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-15：触发串行TX上的ADC值*'
- en: '***Monitoring Power Usage on Password Entry***'
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***监控密码输入时的功率使用***'
- en: 'Now we’ll monitor the power usage when entering a password to see whether we
    can spot a difference in power between a valid and an invalid password. We’ll
    look at what happens when we enter the now invalid password of `@@@`. Recall from
    earlier that when the bootloader detects that you’ve entered a wrong password,
    it’ll go into an infinite loop, so we can monitor what the power usage looks like
    at that point. Of course, you’ll need to exit that infinite loop, so once you’ve
    tried the incorrect password and are sent into a loop, reset the device and try
    to enter another password. To do this, navigate to the password prompt in the
    Python console as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将监控输入密码时的功率使用，看看能否发现有效密码和无效密码之间的功率差异。我们将观察当输入现在无效的密码`@@@`时发生了什么。回想一下，之前当引导加载程序检测到你输入错误的密码时，它会进入无限循环，所以我们可以监控此时的功率使用情况。当然，你需要退出该无限循环，所以一旦你尝试了错误的密码并进入循环，重置设备并尝试输入另一个密码。为此，请在
    Python 控制台中按以下方式导航到密码提示符：
- en: '[PRE14]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, issue the next command with the correct password, but do *not* click Enter
    yet:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用正确的密码执行下一条命令，但*不要*点击回车键：
- en: '[PRE15]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Click **1** in the green play icon in the toolbar to record one power trace.
    Immediately after you do so, click **Enter** in the Python console. A Capture
    Waveform window should open and show you the power trace recording of the valid
    password (see [Figure 8-16](ch08.html#ch8fig16)).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 点击工具栏中绿色播放图标上的**1**来记录一次功率轨迹。操作后，立即在 Python 控制台中点击**回车**。应该会弹出一个捕获波形窗口，显示有效密码的功率轨迹记录（参见[图
    8-16](ch08.html#ch8fig16)）。
- en: '![image](graphics/f08-16.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f08-16.jpg)'
- en: '*Figure 8-16: Power trace of a valid password*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-16：有效密码的功率轨迹*'
- en: The details of [Figure 8-16](ch08.html#ch8fig16) aren’t that important; the
    point is to give you a feel for what a “good” signal looks like. The thick lines
    you see are normal processing, and there’s a dip around the 8,000 sample range
    when the processing instructions changed. (This could be something in the password
    check, but let’s not get hung up on details at this stage.)
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-16](ch08.html#ch8fig16)的细节并不是那么重要；关键是让你了解“良好”信号的样子。你看到的粗线条表示正常处理，当处理指令发生变化时，大约在8,000样本范围内会有一个功率下降。（这可能与密码检查有关，但在这个阶段我们不必纠结于细节。）'
- en: 'Now, enter an invalid password—`ff`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输入一个无效密码—`ff`：
- en: '[PRE16]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[Figure 8-17](ch08.html#ch8fig17) shows the power trace for this password.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-17](ch08.html#ch8fig17)展示了该密码的功率轨迹。'
- en: '![image](graphics/f08-17.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f08-17.jpg)'
- en: '*Figure 8-17: Power trace for a password with no valid characters*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-17：无效字符密码的功率轨迹*'
- en: You can see that the program hangs in its infinite loop when the power reading
    shifts from normal to a near consistent 0 power usage.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到当功率读数从正常转变为几乎一致的0功率使用时，程序卡在了它的无限循环中。
- en: 'Now, let’s try a password with a valid first character to see whether we notice
    a difference:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试输入一个第一个字符有效的密码，看看是否能发现差异：
- en: '[PRE17]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In [Figure 8-18](ch08.html#ch8fig18), one additional chunk is active before
    the device enters the infinite loop. We see normal power usage, followed by the
    dip at 8,000 that we saw in the first valid reading, and then some more normal
    usage before the device enters the infinite loop of 0 usage.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 8-18](ch08.html#ch8fig18)中，设备进入无限循环之前，会有一个额外的片段处于活动状态。我们看到正常的功率使用，然后在8,000处出现了我们在第一次有效读数中看到的功率下降，接着是更多的正常功率使用，然后设备进入0功率的无限循环。
- en: '![image](graphics/f08-18.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f08-18.jpg)'
- en: '*Figure 8-18: Power trace of a password with a valid first character*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-18：具有有效第一个字符的密码的功率轨迹*'
- en: '**NOTE**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You can determine the size of samples used for one valid character by measuring
    the length between the dip at 8,000 and the infinite loop that starts around 16,000\.
    In this case, we can roughly approximate that the sample size to check one character
    is about 8,000 traces (16,000 – 8,000).*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以通过测量8,000处的功率下降和大约16,000处开始的无限循环之间的长度，来确定检查一个有效字符所使用的样本大小。在这种情况下，我们大致可以估算出检查一个字符的样本大小约为8,000次轨迹（16,000
    – 8,000）。*'
- en: '***Scripting the ChipWhisperer with Python***'
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 Python 脚本化 ChipWhisperer***'
- en: Because the ChipWhisperer is written in Python, it’s highly scriptable, so you
    can script these power traces to create a brute-forcer that can get the password
    for the bootloader very quickly. By setting a script to check whether the data
    points of the power trace exceed a set threshold, your brute-forcer can immediately
    tell whether the target character is correct. By looking at the data values on
    the y-axis in [Figure 8-18](ch08.html#ch8fig18), we can see that when we have
    activity, data reaches 0.1, but when we’re in the infinite loop, it hovers around
    the 0 mark. If the target character is correct, the threshold for our script can
    be set to 0.1, and if no data in the sample range of a byte reaches 0.1, then
    we can conclude that we’re in the infinite loop and the password character was
    incorrect.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 因为ChipWhisperer是用Python编写的，所以它具有高度的脚本化功能，因此你可以编写这些功率跟踪脚本，创建一个暴力破解工具，可以非常快速地获取启动加载程序的密码。通过设置脚本来检查功率跟踪的数据显示点是否超过设定的阈值，暴力破解者可以立即判断目标字符是否正确。通过查看[图8-18](ch08.html#ch8fig18)中y轴上的数据值，我们可以看到当有活动时，数据达到0.1，而当进入无限循环时，数据徘徊在0附近。如果目标字符正确，我们可以将脚本的阈值设置为0.1，如果字节样本范围内没有任何数据达到0.1，则可以得出结论：我们处于无限循环中，密码字符不正确。
- en: For example, if the password is made up of 255 different characters with a maximum
    length of 3, the password will be one of 255³, or 16,581,375, possibilities. However,
    because we can instantly detect when we have a correct character, in a worst-case
    scenario, the brute-forcer will have to try only 255 × 3, or 765, possibilities.
    If the character doesn’t match the set password, the bootloader jumps into the
    infinite loop. On the other hand, if the password check routine waited until the
    entire password was checked regardless of its correctness, this type of timing
    analysis couldn’t be done. The fact that the small code on embedded systems is
    often designed to be as efficient as possible can open it up to devastating timing
    attacks.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果密码由255个不同字符组成，且最大长度为3，则密码将是255³，即16,581,375种可能。然而，由于我们可以立即检测到正确的字符，在最坏情况下，暴力破解者只需尝试255
    × 3，即765种可能。如果字符与设置的密码不匹配，启动程序将跳入无限循环。另一方面，如果密码检查程序等待直到整个密码被检查完毕，无论其正确与否，这种定时分析将无法进行。嵌入式系统上的小型代码通常设计得尽可能高效，这可能使其容易受到致命的定时攻击。
- en: '**NOTE**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For details on how to write your own brute-forcer for the ChipWhisperer, see
    the NewAE tutorials. A sample brute-forcer is included at* [http://www.nostarch.com/carhacking/](http://www.nostarch.com/carhacking/).'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*有关如何为ChipWhisperer编写自己的暴力破解工具的详细信息，请参阅NewAE教程。一个示例暴力破解工具已包含在* [http://www.nostarch.com/carhacking/](http://www.nostarch.com/carhacking/)。'
- en: Secure bootloaders and any embedded system that checks for a valid code can
    be susceptible to this type of attack. Some automotive systems require a challenge
    response or a valid access code to access lower-level functions. Guessing or brute-forcing
    these passwords can be very time consuming and would make traditional brute-forcing
    methods unrealistic. By using power analysis to monitor how these passwords or
    codes are being checked, you can derive the password, making something that would’ve
    been too time consuming to crack completely doable.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 安全启动加载程序和任何检查有效代码的嵌入式系统都可能受到这种攻击的影响。一些汽车系统要求提供挑战响应或有效的访问代码才能访问较低级别的功能。猜测或暴力破解这些密码可能非常耗时，这使得传统的暴力破解方法变得不切实际。通过使用功率分析来监控这些密码或代码是如何被检查的，你可以推导出密码，从而使那些本来需要大量时间才能破解的密码变得可以轻松破解。
- en: '**Fault Injection**'
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**故障注入**'
- en: '*Fault injection*, also known as *glitching*, involves attacking a chip by
    disrupting its normal operations and potentially causing it to skip running certain
    instructions, such as ones used to enable security. When reading a chip’s data
    sheet, you’ll see that attached to the range for clock speeds and power levels
    is a warning that failing to stick to these ranges will have unpredictable results—and
    that’s exactly what you’ll take advantage of when glitching. In this section,
    you’ll learn how to introduce faults by injecting faults into clock speeds and
    power levels.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*故障注入*，也称为*故障攻击*，是通过干扰芯片的正常操作来攻击芯片，可能导致其跳过执行某些指令，例如用于启用安全功能的指令。当阅读芯片的数据手册时，你会看到时钟速度和电源水平的范围旁边有警告，表示如果不遵循这些范围，将会产生不可预测的结果——这正是你在进行故障攻击时所利用的。在这一部分，你将学习如何通过注入时钟速度和电源级别的故障来引入错误。'
- en: '***Clock Glitching***'
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***时钟故障***'
- en: Any ECU or chip will rely on an internal clock to time its instructions. Each
    time the microcontroller receives a pulse from the clock, it loads an instruction,
    and while that instruction is being decoded and executed, the next instruction
    is being loaded. This means that a steady rhythm of pulses is needed for the instructions
    to have time to load and execute correctly. But what happens if there’s a hiccup
    during one of these clock pulses? Consider the clock glitch in [Figure 8-19](ch08.html#ch8fig19).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 任何ECU或芯片都依赖于内部时钟来定时其指令。每当微控制器从时钟接收到一个脉冲时，它就加载一个指令，而在该指令被解码和执行的同时，下一条指令也在加载。这意味着需要一个稳定的脉冲节奏，以确保指令有足够的时间加载并正确执行。但是，如果在这些时钟脉冲中的某个脉冲出现了问题，会发生什么呢？请参见[图8-19](ch08.html#ch8fig19)中的时钟故障。
- en: '![image](graphics/f08-19.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f08-19.jpg)'
- en: '*Figure 8-19: Normal clock cycle (top) and glitched clock cycle (bottom)*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-19：正常时钟周期（上）和故障时钟周期（下）*'
- en: Because the Program Counter has time to increment but not enough time to decode
    and execute the instruction before the next instruction is loaded, the microcontroller
    will usually skip that instruction. In the bottom cycle of [Figure 8-19](ch08.html#ch8fig19),
    instruction 3 is skipped because it does not have enough time to execute before
    another instruction is issued. This can be useful for bypassing security methods,
    breaking out of loops, or re-enabling JTAG.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 因为程序计数器有足够的时间递增，但在加载下一条指令之前没有足够的时间解码和执行当前指令，微控制器通常会跳过该指令。在[图8-19](ch08.html#ch8fig19)的底部周期中，指令3被跳过，因为在另一条指令发出之前，它没有足够的时间执行。这可以用于绕过安全方法、突破循环或重新启用JTAG。
- en: To perform a clock glitch, you need to use a system faster than your target’s
    system. A field-programmable gate array (FPGA) board is ideal, but you can accomplish
    this trick with other microcontrollers, too. To perform the glitch, you need to
    sync with the target’s clock, and when the instruction you want to skip is issued,
    drive the clock to ground for a partial cycle.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行时钟故障攻击，您需要使用一个比目标系统更快的系统。场可编程门阵列（FPGA）板是理想的选择，但您也可以使用其他微控制器来完成这个技巧。为了执行故障，您需要与目标的时钟同步，当您想跳过的指令被发出时，将时钟拉低到地面，执行部分周期。
- en: We’ll demonstrate a clock-glitching attack using the ChipWhisperer and some
    demo software made for this kind of attack. The Victim Board setup is almost the
    same as for the power attack, except that you’ll need to change the jumpers for
    the Clock pin (in the middle of the board), which should be set only for FPGAOUT
    by jumping the pins (see [Figure 8-20](ch08.html#ch8fig20)).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用ChipWhisperer和一些为这种攻击制作的演示软件演示时钟故障攻击。受害板的设置几乎与电源攻击时相同，唯一需要更改的是时钟引脚（位于板的中央）的跳线，应该仅通过跳接引脚设置为FPGAOUT（请参见[图8-20](ch08.html#ch8fig20)）。
- en: '![image](graphics/f08-20.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f08-20.jpg)'
- en: '*Figure 8-20: MultiTarget Victim Board set for glitching*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-20：为故障攻击设置的多目标受害板*'
- en: We’ll set up the ChipWhisperer to control the clock of the ATmega328\. Both
    the general settings and the target settings are the same as in the power attack
    discussed in “[Setting Up the ChipWhisperer for Serial Communications](ch08.html#ch08lev2sec10)”
    on [page 140](ch08.html#page_140); the only exception is that we’ll set the baud
    rate to 38400 for both TX and RX. Enable both the Scope and Target by switching
    from DIS to CON in the toolbar, as discussed earlier. [Figure 8-21](ch08.html#ch8fig21)
    and [Table 8-4](ch08.html#ch8tab4) show the complete settings.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置ChipWhisperer来控制ATmega328的时钟。通用设置和目标设置与我们在“[为串行通信设置ChipWhisperer](ch08.html#ch08lev2sec10)”一节中讨论的电源攻击中的设置相同；唯一的例外是，我们将TX和RX的波特率都设置为38400。通过将工具栏中的设置从DIS切换到CON，启用示波器和目标设置，正如之前所讨论的那样。[图8-21](ch08.html#ch8fig21)和[表8-4](ch08.html#ch8tab4)显示了完整的设置。
- en: '![image](graphics/f08-21.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f08-21.jpg)'
- en: '*Figure 8-21: Scope settings for glitching*'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-21：用于故障攻击的示波器设置*'
- en: '**Table 8-4:** ChipWhisperer Main Window Settings for a Clock-Glitch Attack'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**表8-4：** ChipWhisperer主窗口设置，用于时钟故障攻击'
- en: '| **Area** | **Category** | **Setting** | **Value** |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| **区域** | **类别** | **设置** | **值** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| OpenADC | ADC Clock | Frequency Counter Src | CLKGEN Output |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| OpenADC | ADC时钟 | 频率计数器源 | CLKGEN输出 |'
- en: '| OpenADC | CLKGEN Settings | Desired Frequency | 7.37 MHz |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| OpenADC | CLKGEN设置 | 期望频率 | 7.37 MHz |'
- en: '| OpenADC | CLKGEN Settings | Reset CLKGEN DCM | Push button |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| OpenADC | CLKGEN设置 | 重置CLKGEN DCM | 按钮 |'
- en: '| Glitch module | Clock Source |  | CLKGEN |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| 故障模块 | 时钟源 |  | CLKGEN |'
- en: '| CW Extra | Trigger Pins | Target HS IO-Out | Glitch Module |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| CW 外部设备 | 触发引脚 | 目标 HS IO 输出 | 故障模块 |'
- en: 'These settings give the ChipWhisperer full control of the target board’s clock
    and allow you to upload the glitch demo firmware. You’ll find the firmware for
    the target in the ChipWhisperer framework in this directory: *hardware/victims/firmware/avr-glitch-examples*.
    Open *glitchexample.c* in your favorite editor and then go to the `main()` method
    at the bottom of the code. Change `glitch1()` to `glitch3()` in order to follow
    along with this demo, and then recompile the *glitchexample* firmware for the
    ATmega328p:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置使 ChipWhisperer 完全控制目标板的时钟，并允许您上传故障演示固件。您将在 ChipWhisperer 框架的此目录中找到目标固件：*hardware/victims/firmware/avr-glitch-examples*。在您喜欢的编辑器中打开
    *glitchexample.c*，然后转到代码底部的 `main()` 方法。将 `glitch1()` 改为 `glitch3()`，以便跟随本演示，并重新编译
    ATmega328p 的 *glitchexample* 固件：
- en: '[PRE18]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, upload the *glitchexample.hex* file via AVRDUDESS, as we did in “[Prepping
    Your Test with AVRDUDESS](ch08.html#ch08lev2sec9)” on [page 139](ch08.html#page_139).
    Once the firmware is loaded, switch to the main ChipWhisperer window and open
    a serial terminal. Click **Connect**, and then switch to AVRDUDESS and click **Detect**.
    This should reset the chip so that you see `hello` appear in the capture terminal.
    Enter a password, and click **Send**. Assuming you enter the wrong password, the
    capture terminal should display `FOff` and hang, as shown in [Figure 8-22](ch08.html#ch8fig22).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，像我们在 “[使用 AVRDUDESS 准备测试](ch08.html#ch08lev2sec9)” 中的[第139页](ch08.html#page_139)那样，通过
    AVRDUDESS 上传 *glitchexample.hex* 文件。固件加载完成后，切换到主 ChipWhisperer 窗口并打开串行终端。点击 **连接**，然后切换回
    AVRDUDESS 并点击 **检测**。这应该会重置芯片，您将看到 `hello` 出现在捕获终端中。输入密码，并点击 **发送**。假设您输入了错误的密码，捕获终端应该显示
    `FOff` 并挂起，如[图 8-22](ch08.html#ch8fig22)所示。
- en: '![image](graphics/f08-22.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f08-22.jpg)'
- en: '*Figure 8-22: A bad password example*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-22：错误密码示例*'
- en: Now return to your editor and look at the *glitchexample* source code. As shown
    in [Listing 8-2](ch08.html#ch8list2), this is a simple password check.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在返回到编辑器，查看 *glitchexample* 源代码。如[列表 8-2](ch08.html#ch8list2)所示，这是一个简单的密码检查。
- en: '[PRE19]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 8-2: Password check method for* `glitch3()`'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-2：`glitch3()` 的密码检查方法*'
- en: If an invalid password is entered, `passok` is set to 0, and the message `Foff`
    is printed to the screen; otherwise, `Welcome` is printed to the screen. Our goal
    is to introduce a clock glitch that bypasses the password verification either
    by skipping over the instruction that sets `passok` to 0 (so that it’s never set
    to 0) or by jumping straight to the welcome message. We’ll do the latter by manipulating
    the width and offset percentages in the glitch settings.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入了无效密码，`passok` 将设置为 0，并且屏幕上会显示 `Foff` 消息；否则，屏幕上将显示 `Welcome` 消息。我们的目标是引入一个时钟故障，通过跳过设置
    `passok` 为 0 的指令（以避免它被设置为 0），或通过直接跳转到欢迎消息来绕过密码验证。我们将通过在故障设置中操控宽度和偏移百分比来实现后者。
- en: '[Figure 8-23](ch08.html#ch8fig23) shows some possible places to locate the
    glitch. Different chips and different instructions react differently depending
    on where your glitch is placed, so experiment to determine which location works
    best for your situation. [Figure 8-23](ch08.html#ch8fig23) also shows what a normal
    clock cycle looks like under a scope. If we use a positive offset in the ChipWhisperer
    settings, it’ll cause a brief drop in the middle of the clock cycle. If we use
    a negative offset, it’ll cause a brief spike before the clock cycle.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-23](ch08.html#ch8fig23)展示了定位故障的一些可能位置。不同的芯片和指令在故障放置位置上的反应不同，因此请尝试不同位置以确定哪个位置最适合您的情况。[图
    8-23](ch08.html#ch8fig23)还展示了在示波器下正常的时钟周期。如果我们在 ChipWhisperer 设置中使用正偏移，它将导致时钟周期中间出现短暂的下跌。如果使用负偏移，它将在时钟周期之前引起一个短暂的尖峰。'
- en: 'We’ll set the following glitch options in the ChipWhisperer to cause a brief
    spike before the clock cycle by using a –10 percent offset:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 ChipWhisperer 中设置以下故障选项，通过使用 -10% 的偏移量，在时钟周期之前引起一个短暂的尖峰：
- en: '[PRE20]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![image](graphics/f08-23.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f08-23.jpg)'
- en: '*Figure 8-23: Example glitch placements*'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-23：示例故障放置位置*'
- en: Now return to the ChipWhisperer main window to set up the CW Extras, as shown
    in [Figure 8-24](ch08.html#ch8fig24). This will configure the ChipWhisperer to
    cause the clock glitch only when it gets a signal from the trigger line.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在返回 ChipWhisperer 主窗口，设置 CW 外部设备，如[图 8-24](ch08.html#ch8fig24)所示。这将配置 ChipWhisperer，仅在接收到触发线信号时才引起时钟故障。
- en: '![image](graphics/f08-24.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f08-24.jpg)'
- en: '*Figure 8-24: Glitch setup in the CW Extra Settings*'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-24：在 CW 外部设备设置中配置故障*'
- en: '**NOTE**'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Glitching is an inexact science. Different chips will respond to settings
    differently, and you’ll need to play around with settings a lot to get the timing
    right. Even if you fail to exploit the clock glitch consistently, often you’ll
    need to get it right only once to exploit a device.*'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*故障是一个不精确的科学。不同的芯片对设置的反应不同，你需要大量调整设置以获得正确的时机。即使你无法始终如一地利用时钟故障，通常只需要一次成功的操作就能利用设备。*'
- en: '***Setting a Trigger Line***'
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***设置触发线***'
- en: Now that we have the ChipWhisperer set up to listen for a signal on the trigger
    line, we need to modify the code to use the trigger line. The trigger line is
    pin 16 on the ChipWhisperer connector. When the trigger line receives a signal
    (voltage peaks), it triggers the ChipWhisperer software to spring into action.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好 ChipWhisperer 来监听触发线上的信号，我们需要修改代码来使用触发线。触发线是 ChipWhisperer 连接器上的第
    16 引脚。当触发线接收到信号（电压峰值）时，它会触发 ChipWhisperer 软件启动执行。
- en: The trigger line is a generic input method used by ChipWhisperer. The goal is
    to get the trigger line to receive a signal just before the point we want to attack.
    If we were looking at a piece of hardware and noticed a light come on just before
    the area we wanted to attack, we could solder the LED to the trigger line in order
    to make the ChipWhisperer wait until just the right moment.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 触发线是 ChipWhisperer 使用的通用输入方法。目标是让触发线在我们想要攻击的点之前接收到信号。如果我们在观察一块硬件时注意到某个灯光在我们想要攻击的区域之前亮起，我们可以将
    LED 焊接到触发线上，以便让 ChipWhisperer 等到合适的时刻再进行操作。
- en: For this demo, we’ll modify the firmware to make the trigger line go off in
    the area we want to glitch. First we’ll add some code to the default glitch 3
    example shown in [Listing 8-2](ch08.html#ch8list2). Use your favorite editor to
    add the defines in [Listing 8-3](ch08.html#ch8list3), toward the top of the *glitchexample.c*.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个演示，我们将修改固件，使触发线在我们想要故障的区域触发。首先，我们将在 [列表 8-2](ch08.html#ch8list2) 中显示的默认故障
    3 示例中添加一些代码。使用你喜欢的编辑器，将 [列表 8-3](ch08.html#ch8list3) 中的定义添加到 *glitchexample.c*
    文件的顶部。
- en: '[PRE21]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 8-3: Setting up trigger defines in* `glitchexample.c`'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-3：在* `glitchexample.c` *中设置触发定义*'
- en: Place a `trigger_setup()` inside the `main()` method just before it prints *hello*,
    and then wrap your target with the trigger, as shown in [Listing 8-4](ch08.html#ch8list4).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main()` 方法中，在打印 *hello* 之前放置一个 `trigger_setup()`，然后将你的目标用触发器包裹，如 [列表 8-4](ch08.html#ch8list4)
    所示。
- en: '[PRE22]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 8-4: Adding* `trigger_high` *and* `trigger_low` *around* `passok`
    *to trigger a glitch*'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-4：添加* `trigger_high` *和* `trigger_low` *围绕* `passok` *以触发故障*'
- en: Now, recompile `make MCU=atmega328p`, and reupload the firmware to the Victim
    Board. (Make sure to set the Glitch Trigger option to Manual in the ChipWhisperer
    settings before you upload the firmware or you may accidentally glitch the firmware
    upload.) Once the firmware is uploaded, switch the Glitch Trigger option back
    to Ext Trigger:Continous. Now, enter any password. If you get a `Welcome` message,
    you’ve successfully glitched the device, as shown in [Figure 8-25](ch08.html#ch8fig25).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重新编译 `make MCU=atmega328p`，并将固件重新上传到受害者板（在上传固件之前，确保在 ChipWhisperer 设置中将故障触发选项设置为手动，否则你可能会不小心触发固件上传的故障）。上传固件后，将故障触发选项切换回外部触发：连续模式。现在，输入任意密码。如果你看到
    `Welcome` 信息，那么说明你已经成功触发了设备故障，如 [图 8-25](ch08.html#ch8fig25) 所示。
- en: '![image](graphics/f08-25.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f08-25.jpg)'
- en: '*Figure 8-25: Successfully glitching password check*'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-25：成功触发密码检查故障*'
- en: Unfortunately, in the real world, you probably won’t be able to use a trigger
    line in the same way because you won’t have access to the target source or a trigger
    event won’t be close enough to where you want to glitch. In such cases, you’ll
    need to play with other settings and the Ext trigger offset. Open the Glitch Monitor
    under Tools to experiment with different settings.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在现实世界中，你可能无法像这样使用触发线，因为你无法访问目标源，或者触发事件离你想要故障的位置不够近。在这种情况下，你需要调整其他设置和外部触发偏移量。打开工具中的故障监视器，以便尝试不同的设置。
- en: '***Power Glitching***'
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***电源故障***'
- en: 'Power glitching is triggered like clock glitching: you feed the target board
    the proper power at a steady rate, and when you want to trigger unexpected results
    at particular instructions, you either drop or raise the voltage to interrupt
    that instruction. Dropping the voltage is often safer than raising it, so try
    that first. Each microcontroller reacts differently to power glitching, so play
    around at different points and power levels to build a glitch profile and see
    what types of behavior can be controlled. (When instructions are skipped via power
    glitching, it’s often because the opcode instruction has become corrupted and
    done something other than the intended instruction or because one of the registers
    has become corrupted.)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 功率故障注入的触发方式类似于时钟故障注入：你为目标板提供稳定的电力，并在需要在特定指令上触发意外结果时，通过降低或提高电压来中断该指令。降低电压通常比提高电压更安全，因此可以先尝试降低电压。每个微控制器对功率故障的反应不同，因此可以在不同的时刻和功率水平下进行尝试，建立故障概况并查看可以控制哪些类型的行为。（当指令通过功率故障跳过时，通常是因为操作码指令已经损坏，执行了不同于预期的指令，或者某个寄存器已经损坏。）
- en: '**NOTE**'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Some microcontrollers aren’t vulnerable at all to power glitching, so test
    with your target chipset before trying it on a vehicle.*'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '*一些微控制器根本不容易受到功率故障攻击的影响，因此在尝试应用于车辆之前，先在目标芯片组上进行测试。*'
- en: Power glitching can also affect memory reads and writes. Depending on which
    instruction is running during the power fault, you can cause the controller to
    read the wrong data or forget to write a value.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 功率故障注入还可以影响内存读写。根据功率故障发生时运行的指令，你可以导致控制器读取错误的数据或忘记写入值。
- en: '***Invasive Fault Injection***'
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***侵入式故障注入***'
- en: Because invasive fault injection attacks are more time-consuming and expensive
    than glitch attacks, we’ll examine them only briefly here. However, if you need
    to do the job and you have the resources, invasive fault injection is often the
    best way. The catch is that it doesn’t preserve the target and can even destroy
    it.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 由于侵入式故障注入攻击比故障攻击更耗时且成本更高，因此我们将在此简要讨论它。然而，如果你需要执行此任务并且拥有资源，侵入式故障注入通常是最好的方法。关键是，它不能保留目标，甚至可能摧毁它。
- en: Invasive fault injection involves physically unpacking the chip, typically with
    acid (nitric acid and acetone) and using an electron microscope to image the chip.
    You can work on just the top or bottom layer of the chip or map out each layer
    and decipher the logic gates and internals. You can also use microprobes and a
    microprobe station to inject the exact signal you want into your target. By the
    same token, you could use targeted lasers or even directed heat to cause optical
    faults to slow down processes in that region. For instance, if a move instruction
    is supposed to take two clock cycles, you can slow the registry retrieval to make
    it late for the next instruction.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 侵入式故障注入涉及物理拆解芯片，通常使用酸性物质（如硝酸和丙酮），并使用电子显微镜对芯片进行成像。你可以只处理芯片的顶部或底部层，或绘制每一层的地图并解读逻辑门和内部结构。你还可以使用微探针和微探针站将精确的信号注入目标。类似地，你也可以使用定向激光或定向热量来引起光学故障，从而减缓该区域的处理过程。例如，如果一个移动指令应该需要两个时钟周期，你可以通过延迟寄存器检索，使其晚于下一个指令。
- en: '**Summary**'
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you’ve learned several advanced techniques for attacking embedded
    systems; these techniques will become only more valuable as automotive security
    improves. You learned how to identify chips and monitor power usage to create
    a profile of good operations. We tested whether password checks could be attacked
    by monitoring the power output of bad characters in passwords, ultimately to create
    a brute-forcing application using power analysis to cut the password brute-force
    time down to seconds. We also saw how clock and power glitching can make instructions
    skip at key points in the firmware’s execution, such as during validation security
    checks or when setting JTAG security.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经学习了几种针对嵌入式系统的高级攻击技巧；随着汽车安全的不断提升，这些技巧将变得更加有价值。你学习了如何识别芯片并监控功耗，以创建正常操作的概况。我们测试了是否可以通过监控密码中错误字符的功率输出来攻击密码检查，最终创建了一个暴力破解应用，利用功率分析将密码暴力破解时间缩短到秒级。我们还观察到时钟和功率故障注入如何使固件执行中的关键点指令跳过，例如在验证安全检查时或设置JTAG安全时。
