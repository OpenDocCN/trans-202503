["```\n<f1>:\n  test edi,edi\n  jne _ret\n  xor eax,eax\n  call f2\n_ret:\n  ret\n```", "```\n<f1>:\n  jmp f1_copy\n  ; junk bytes\n```", "```\n<__x86.get_pc_thunk.bx>:\n  mov ebx,DWORD PTR [esp]\n  ret\n```", "```\n➊ #include \"pin.H\"\n\n➋ KNOB<bool> ProfileCalls(KNOB_MODE_WRITEONCE, \"pintool\", \"c\", \"0\", \"Profile function calls\");\n   KNOB<bool> ProfileSyscalls(KNOB_MODE_WRITEONCE, \"pintool\", \"s\", \"0\", \"Profile syscalls\");\n\n➌ std::map<ADDRINT, std::map<ADDRINT, unsigned long> > cflows;\n   std::map<ADDRINT, std::map<ADDRINT, unsigned long> > calls;\n   std::map<ADDRINT, unsigned long> syscalls;\n   std::map<ADDRINT, std::string> funcnames;\n\n   unsigned long insn_count    = 0;\n   unsigned long cflow_count   = 0;\n   unsigned long call_count    = 0;\n   unsigned long syscall_count = 0;\n\n   int\n   main(int argc, char *argv[])\n   {\n➍   PIN_InitSymbols();\n➎   if(PIN_Init(argc,argv)) {\n       print_usage();\n       return 1;\n     }\n\n➏   IMG_AddInstrumentFunction(parse_funcsyms, NULL);\n     TRACE_AddInstrumentFunction(instrument_trace, NULL);\n     INS_AddInstrumentFunction(instrument_insn, NULL);\n➐   if(ProfileSyscalls.Value()) {\n       PIN_AddSyscallEntryFunction(log_syscall, NULL);\n     }\n\n ➑   PIN_AddFiniFunction(print_results, NULL);\n\n     /* Never returns */\n➒   PIN_StartProgram();\n\n     return 0;\n   }\n```", "```\n   static void\n   parse_funcsyms(IMG img, void *v)\n   {\n➊    if(!IMG_Valid(img)) return;\n\n➋    for(SEC sec = IMG_SecHead(img); SEC_Valid(sec); sec = SEC_Next(sec)) {\n➌      for(RTN rtn = SEC_RtnHead(sec); RTN_Valid(rtn); rtn = RTN_Next(rtn)) {\n➍        funcnames[RTN_Address(rtn)] = RTN_Name(rtn);\n        }\n      }\n   }\n```", "```\n   static void\n   instrument_trace(TRACE trace, void *v)\n   {\n➊    IMG img = IMG_FindByAddress(TRACE_Address(trace));\n     if(!IMG_Valid(img) || !IMG_IsMainExecutable(img)) return;\n\n➋    for(BBL bb = TRACE_BblHead(trace); BBL_Valid(bb); bb = BBL_Next(bb)) {\n➌      instrument_bb(bb);\n     }\n   }\n\n   static void\n   instrument_bb(BBL bb)\n   {\n➍    BBL_InsertCall(\n       bb, ➎IPOINT_ANYWHERE, ➏(AFUNPTR)count_bb_insns,\n       ➐IARG_UINT32, BBL_NumIns(bb),\n       ➑IARG_END\n     );\n   }\n```", "```\n   static void\n   instrument_insn(INS ins, void *v)\n   {\n➊   if(!INS_IsBranchOrCall(ins)) return;\n\n     IMG img = IMG_FindByAddress(INS_Address(ins));\n     if(!IMG_Valid(img) || !IMG_IsMainExecutable(img)) return;\n\n➋   INS_InsertPredicatedCall(\n       ins, ➌IPOINT_TAKEN_BRANCH, (AFUNPTR)count_cflow,\n       ➍IARG_INST_PTR, ➎IARG_BRANCH_TARGET_ADDR,\n       IARG_END\n     );\n\n➏   if(INS_HasFallThrough(ins)) {\n       INS_InsertPredicatedCall(\n         ins, ➐IPOINT_AFTER, (AFUNPTR)count_cflow,\n         IARG_INST_PTR, ➑IARG_FALLTHROUGH_ADDR,\n         IARG_END\n       );\n     }\n\n➒   if(INS_IsCall(ins)) {\n       if(ProfileCalls.Value()) {\n         INS_InsertCall(\n           ins, ➓IPOINT_BEFORE, (AFUNPTR)count_call,\n           IARG_INST_PTR, IARG_BRANCH_TARGET_ADDR,\n           IARG_END\n         );\n       }\n     }\n   }\n```", "```\n   static void\n➊ count_bb_insns(UINT32 n)\n   {\n     insn_count += n;\n   }\n\n   static void\n➋ count_cflow(➌ADDRINT ip, ADDRINT target)\n   {\n     cflows[target][ip]++;\n     cflow_count++;\n   }\n\n   static void\n➍ count_call(ADDRINT ip, ADDRINT target)\n   {\n     calls[target][ip]++;\n     call_count++;\n   }\n\n   static void\n➎ log_syscall(THREADID tid, CONTEXT *ctxt, SYSCALL_STANDARD std, VOID *v)\n   {\n     syscalls[➏PIN_GetSyscallNumber(ctxt, std)]++;\n     syscall_count++;\n   }\n```", "```\n➊ $ cd ~/pin/pin-3.6-97554-g31f0a167d-gcc-linux/\n➋ $ ./pin -t ~/code/chapter9/profiler/obj-intel64/profiler.so -c -s -- /bin/true\n➌ executed 95 instructions\n\n➍ ******* CONTROL TRANSFERS *******\n   0x00401000 <- 0x00403f7c:   1 (4.35%)\n   0x00401015 <- 0x0040100e:   1 (4.35%)\n   0x00401020 <- 0x0040118b:   1 (4.35%)\n   0x00401180 <- 0x004013f4:   1 (4.35%)\n   0x00401186 <- 0x00401180:   1 (4.35%)\n   0x00401335 <- 0x00401333:   1 (4.35%)\n   0x00401400 <- 0x0040148d:   1 (4.35%)\n   0x00401430 <- 0x00401413:   1 (4.35%)\n   0x00401440 <- 0x004014ab:   1 (4.35%)\n   0x00401478 <- 0x00401461:   1 (4.35%)\n   0x00401489 <- 0x00401487:   1 (4.35%)\n   0x00401492 <- 0x00401431:   1 (4.35%)\n   0x004014a0 <- 0x00403f99:   1 (4.35%)\n   0x004014ab <- 0x004014a9:   1 (4.35%)\n   0x00403f81 <- 0x00401019:   1 (4.35%)\n   0x00403f86 <- 0x00403f84:   1 (4.35%)\n   0x00403f9d <- 0x00401479:   1 (4.35%)\n   0x00403fa6 <- 0x00403fa4:   1 (4.35%)\n   0x7fa9f58437bf <- 0x00403fb4:   1 (4.35%)\n   0x7fa9f5843830 <- 0x00401337:   1 (4.35%)\n   0x7faa09235de7 <- 0x0040149a:   1 (4.35%)\n   0x7faa09235e05 <- 0x00404004:   1 (4.35%)\n   0x7faa0923c870 <- 0x00401026:   1 (4.35%)\n\n➎ ******* FUNCTION CALLS *******\n   [_init                         ] 0x00401000 <- 0x00403f7c:   1 (25.00%)\n   [__libc_start_main@plt         ] 0x00401180 <- 0x004013f4:   1 (25.00%)\n   [                              ] 0x00401400 <- 0x0040148d:   1 (25.00%)\n   [                              ] 0x004014a0 <- 0x00403f99:   1 (25.00%)\n\n➏ ******* SYSCALLS *******\n     0:   1 (4.00%)\n     2:   2 (8.00%)\n     3:   2 (8.00%)\n     5:   2 (8.00%)\n     9:   7 (28.00%)\n    10:   4 (16.00%)\n    11:   1 (4.00%)\n    12:   1 (4.00%)\n    21:   3 (12.00%)\n   158:   1 (4.00%)\n   231:   1 (4.00%)\n```", "```\n➊ $ echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope\n➋ $ nc -l -u 127.0.0.1 9999 &\n   [1] ➌3100\n➍ $ cd ~/pin/pin-3.6-97554-g31f0a167d-gcc-linux/\n➎ $ ./pin -pid 3100 -t /home/binary/code/chapter9/profiler/obj-intel64/profiler.so -c -s\n➏ $ echo \"Testing the profiler\" | nc -u 127.0.0.1 9999\n   Testing the profiler\n   ˆC\n➐ $ fg\n   nc -l -u 127.0.0.1 9999\n   ˆC\n   executed 164 instructions\n\n➑ ******* CONTROL TRANSFERS *******\n   0x00401380 <- 0x0040140b:   1 (2.04%)\n   0x00401380 <- 0x0040144b:   1 (2.04%)\n   0x00401380 <- 0x004014db:   1 (2.04%)\n   ...\n   0x7f4741177ad0 <- 0x004015e0:   1 (2.04%)\n 0x7f474121b0b0 <- 0x004014d0:   1 (2.04%)\n   0x7f4741913870 <- 0x00401386:   5 (10.20%)\n\n➒ ******* FUNCTION CALLS *******\n   [__read_chk@plt                ] 0x00401400 <- 0x00402dc7:   1 (11.11%)\n   [write@plt                     ] 0x00401440 <- 0x00403c06:   1 (11.11%)\n   [__poll_chk@plt                ] 0x004014d0 <- 0x00402eba:   2 (22.22%)\n   [fileno@plt                    ] 0x004015e0 <- 0x00402d62:   1 (11.11%)\n   [fileno@plt                    ] 0x004015e0 <- 0x00402d71:   1 (11.11%)\n   [connect@plt                   ] 0x004016a0 <- 0x00401e80:   1 (11.11%)\n   [                              ] 0x00402d30 <- 0x00401e90:   1 (11.11%)\n   [                              ] 0x00403bb0 <- 0x00402dfc:   1 (11.11%)\n\n➓ ******* SYSCALLS *******\n     0:   1 (16.67%)\n     1:   1 (16.67%)\n     7:   2 (33.33%)\n    42:   1 (16.67%)\n    45:   1 (16.67%)\n```", "```\n   #include \"pin.H\"\n\n➊ typedef struct mem_access {\n     mem_access()                                  : w(false), x(false), val(0) {}\n     mem_access(bool ww, bool xx, unsigned char v) : w(ww)   , x(xx)   , val(v) {}\n     bool w;\n     bool x;\n     unsigned char val;\n   } mem_access_t;\n\n➋ typedef struct mem_cluster {\n     mem_cluster() : base(0), size(0), w(false), x(false) {}\n     mem_cluster(ADDRINT b, unsigned long s, bool ww, bool xx)\n                   : base(b), size(s), w(ww), x(xx)       {}\n     ADDRINT       base;\n     unsigned long size;\n     bool          w;\n     bool          x;\n   } mem_cluster_t;\n\n➌ FILE *logfile;\n   std::map<ADDRINT, mem_access_t> shadow_mem;\n   std::vector<mem_cluster_t> clusters;\n   ADDRINT saved_addr;\n\n➍ KNOB<string> KnobLogFile(KNOB_MODE_WRITEONCE, \"pintool\", \"l\", \"unpacker.log\", \"log file\");\n\n   static void\n➎ fini(INT32 code, void *v)\n   {\n     print_clusters();\n     fprintf(logfile, \"------- unpacking complete -------\\n\");\n     fclose(logfile);\n   }\n\n   int\n   main(int argc, char *argv[])\n   {\n➏   if(PIN_Init(argc, argv) != 0) {\n       fprintf(stderr, \"PIN_Init failed\\n\");\n       return 1;\n     }\n\n➐   logfile = fopen(KnobLogFile.Value().c_str(), \"a\");\n     if(!logfile) {\n       fprintf(stderr, \"failed to open '%s'\\n\", KnobLogFile.Value().c_str());\n       return 1;\n     }\n     fprintf(logfile, \"------- unpacking binary -------\\n\");\n\n➑   INS_AddInstrumentFunction(instrument_mem_cflow, NULL);\n➒   PIN_AddFiniFunction(fini, NULL);\n\n➓   PIN_StartProgram();\n\n     return 1;\n   }\n```", "```\n   static void\n   instrument_mem_cflow(INS ins, void *v)\n   {\n➊   if(INS_IsMemoryWrite(ins) && INS_hasKnownMemorySize(ins)) {\n➋     INS_InsertPredicatedCall(\n         ins, IPOINT_BEFORE, (AFUNPTR)queue_memwrite,\n➌       IARG_MEMORYWRITE_EA,\n         IARG_END\n       );\n➍     if(INS_HasFallThrough(ins)) {\n➎       INS_InsertPredicatedCall(\n           ins, IPOINT_AFTER, (AFUNPTR)log_memwrite,\n➏         IARG_MEMORYWRITE_SIZE,\n           IARG_END\n         );\n       }\n➐     if(INS_IsBranchOrCall(ins)) {\n➑       INS_InsertPredicatedCall(\n           ins, IPOINT_TAKEN_BRANCH, (AFUNPTR)log_memwrite,\n           IARG_MEMORYWRITE_SIZE,\n           IARG_END\n         );\n       }\n     }\n\n➒   if(INS_IsIndirectBranchOrCall(ins) && INS_OperandCount(ins) > 0) {\n➓     INS_InsertCall(\n         ins, IPOINT_BEFORE, (AFUNPTR)check_indirect_ctransfer,\n         IARG_INST_PTR, IARG_BRANCH_TARGET_ADDR,\n         IARG_END\n      );\n    }\n  }\n```", "```\n   static void\n➊ queue_memwrite(ADDRINT addr)\n   {\n     saved_addr = addr;\n   }\n\n   static void\n➋ log_memwrite(UINT32 size)\n   {\n➌   ADDRINT addr = saved_addr;\n➍   for(ADDRINT i = addr; i < addr+size; i++) {\n➎     shadow_mem[i].w = true;\n➏     PIN_SafeCopy(&shadow_mem[i].val, (const void*)i, 1);\n     }\n   }\n```", "```\n   static void\n   check_indirect_ctransfer(ADDRINT ip, ADDRINT target)\n   {\n➊   mem_cluster_t c;\n\n➋   shadow_mem[target].x = true;\n➌   if(shadow_mem[target].w && ➍!in_cluster(target)) {\n       /* control transfer to a once-writable memory region, suspected transfer\n        * to original entry point of an unpacked binary */\n➎     set_cluster(target, &c);\n➏     clusters.push_back(c);\n       /* dump the new cluster containing the unpacked region to file */\n➐     mem_to_file(&c, target);\n       /* we don't stop here because there might be multiple unpacking stages */\n     }\n   }\n```", "```\n➊ $ cp /bin/ls packed\n➋ $ upx packed\n                           Ultimate Packer for eXecutables\n                              Copyright (C) 1996 - 2013\n   UPX 3.91         Markus Oberhumer, Laszlo Molnar & John Reiser   Sep 30th 2013\n\n           File size         Ratio      Format      Name\n      --------------------   ------   -----------   -----------\n➌     126584 ->     57188   45.18%  linux/ElfAMD   packed\n\n   Packed 1 file.\n```", "```\n   $ cd ~/pin/pin-3.6-97554-g31f0a167d-gcc-linux/\n➊ $ ./pin -t ~/code/chapter9/unpacker/obj-intel64/unpacker.so -- ~/code/chapter9/packed\n➋ doc  extlicense  extras  ia32  intel64  LICENSE  pin  pin.log  README  redist.txt  source\n   unpacked.0x400000-0x41da64_entry-0x40000c  unpacked.0x800000-0x80d6d0_entry-0x80d465\n   unpacked.0x800000-0x80dd42_entry-0x80d6d0  unpacker.log\n➌ $ head unpacker.log\n   ------- unpacking binary -------\n   extracting unpacked region 0x0000000000800000 (   53.7kB) wx entry 0x000000000080d465\n   extracting unpacked region 0x0000000000800000 (   55.3kB) wx entry 0x000000000080d6d0\n➍ extracting unpacked region 0x0000000000400000 (  118.6kB) wx entry 0x000000000040000c\n   ******* Memory access clusters *******\n   0x0000000000400000 (  118.6kB) wx: =======================================================...==\n   0x0000000000800000 (   55.3kB) wx: =====================================\n   0x000000000061de00 (    4.5kB) w-: ===\n   0x00007ffc89084f60 (    3.8kB) w-: ==\n   0x00007efc65ac12a0 (    3.3kB) w-: ==\n➎ $ file unpacked.0x400000-0x41da64_entry-0x40000c\n   unpacked.0x400000-0x41da64_entry-0x40000c: ERROR: ELF 64-bit LSB executable, x86-64,\n   version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2\n   error reading (Invalid argument)\n```", "```\n➊  $ strings unpacked.0x400000-0x41da64_entry-0x40000c\n    ...\n➋  Usage: %s [OPTION]... [FILE]...\n    List information about the FILEs (the current directory by default).\n    Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.\n    Mandatory arguments to long options are mandatory for short options too.\n      -a, --all                 do not ignore entries starting with .\n      -A, --almost-all          do not list implied . and ..\n          --author              with -l, print the author of each file\n      -b, --escape              print C-style escapes for nongraphic characters\n          --block-size=SIZE     scale sizes by SIZE before printing them; e.g.,\n                                  '--block-size=M' prints sizes in units of\n                                  1,048,576 bytes; see SIZE format below\n      -B, --ignore-backups      do not list implied entries ending with ~\n      -c                        with -lt: sort by, and show, ctime (time of last\n                                  modification of file status information);\n                                  with -l: show ctime and sort by name;\n                                  otherwise: sort by ctime, newest first\n      -C                        list entries by columns\n          --color[=WHEN]        colorize the output; WHEN can be 'always' (default\n                                  if omitted), 'auto', or 'never'; more info below\n      -d, --directory           list directories themselves, not their contents\n     ...\n```", "```\n➊  $ objdump -M intel -d /bin/ls\n\n   402a00: push   r15\n   402a02: push   r14\n   402a04: push   r13\n   402a06: push   r12\n   402a08: push   rbp\n   402a09: push   rbx\n   402a0a: mov    ebx,edi\n   402a0c: mov    rbp,rsi\n   402a0f: sub    rsp,0x388\n   402a16: mov    rdi,QWORD PTR [rsi]\n   402a19: mov    rax,QWORD PTR fs:0x28\n   402a22: mov    QWORD PTR [rsp+0x378],rax\n   402a2a: xor    eax,eax\n   402a2c: call   40db00 <__sprintf_...>\n   402a31: mov    esi,0x419ac1\n   402a36: mov    edi,0x6\n   402a3b: call   402840 <setlocale@plt>\n```", "```\n➋  $ objdump -M intel -b binary -mi386 -Mx86-64 \\\n     -D unpacked.0x400000-0x41da64_entry-0x40000c\n   2a00: push  r15\n   2a02: push  r14\n   2a04: push  r13\n   2a06: push  r12\n   2a08: push  rbp\n   2a09: push  rbx\n   2a0a: mov   ebx,edi\n   2a0c: mov   rbp,rsi\n   2a0f: sub   rsp,0x388\n   2a16: mov   rdi,QWORD PTR [rsi]\n   2a19: mov   rax,QWORD PTR fs:0x28\n   2a22: mov   QWORD PTR [rsp+0x378],rax\n   2a2a: xor   eax,eax\n➌  2a2c: call  0xdb00\n   2a31: mov   esi,0x419ac1\n   2a36: mov   edi,0x6\n➍  2a3b: call  0x2840\n```"]