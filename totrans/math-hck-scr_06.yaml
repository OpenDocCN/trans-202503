- en: '**6**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Making Codes, and Cracking Them Too**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Say you have a secret that you want to share with a friend. You could write
    it down and pass them a note, but somebody else might see it. Or you could whisper
    it to them, but somebody might overhear. Think how much better it would be if
    anyone else who intercepted your message couldn’t make sense of it. A secret code!
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll use Scratch to practice *cryptography*, the art of secret
    codes. We’ll write programs with a few different cryptographic techniques, consider
    their strengths and weaknesses, and use them to encode messages. Writing a message
    in code is only half the job, though. There has to be a way to undo the code,
    or else *nobody* will be able to read it, not even the people you want. We’ll
    look at the other side of the story too, and see how to decode secret messages.
  prefs: []
  type: TYPE_NORMAL
- en: Caesar’s Shifty Cipher
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Secret codes are important in military applications because commanders need
    a way to let soldiers in the field know their battle plans, preferably without
    revealing them to the enemy if they fall into the wrong hands. The Roman general
    Julius Caesar is credited with devising one of the earliest known methods of encoding
    messages, for just this purpose. As the story goes, when communicating with his
    soldiers Caesar used a simple replacement system in which all the letters in the
    messages (written in Latin, I suppose) were shifted three places to the right.
    So if there was an A in the message, it was replaced by a D, each B was replaced
    by an E, and so on. This approach of creating a coded message by shifting the
    letters in the alphabet is now known as the *Caesar cipher*. The shift doesn’t
    have to be by three; a shift by any number of places will turn a readable message
    into total gibberish.
  prefs: []
  type: TYPE_NORMAL
- en: '*Cipher* is an old-fashioned word for a procedure or a puzzle. It used to be
    that doing arithmetic was called *ciphering* because the way numbers get manipulated
    in big multiplication problems or long division looks like an intricate puzzle.
    The process of converting a message into a disguised form (*encrypting*) and recovering
    the original message from its encrypted form (*decrypting*) is also like solving
    a puzzle, so today *cipher* more commonly refers to a code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The puzzle for the Caesar cipher can be solved with a two-row table. One row
    shows the alphabet from A to Z, and the other shows the alphabet shifted over
    by the appropriate number of places:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg122_Image_144.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It can help to wrap the rows of the table around in a circle to indicate that
    when we get to the end of the alphabet, we wrap around to the beginning again.
    Imagine two circles, with an inner alphabet and an outer alphabet, as shown in
    [Figure 6-1](ch06.xhtml#ch6fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg122_Image_145.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-1: Shifting around a circle*'
  prefs: []
  type: TYPE_NORMAL
- en: If the circles can rotate independently, then they can be used to illustrate
    the Caesar cipher with different shifts. You can make a tool like this and use
    it to encrypt and decrypt messages by hand, one letter a time. But why do all
    that work when Scratch can do it for you?
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 22: Encryption by a Caesar Shift'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this project, we’ll use Scratch to automate the process of encrypting a message
    with the Caesar cipher. First, we’ll put the alphabet into a list, using the custom
    block shown in [Figure 6-2](ch06.xhtml#ch6fig2). That way, we can work with the
    letters by using the numbers that index them in the list.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg123_Image_146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-2: Putting the alphabet in a list*'
  prefs: []
  type: TYPE_NORMAL
- en: The custom `Alphabet` block builds a list called `alphabet`, adding letters
    one at a time. If you want, you can extend the alphabet to include other symbols,
    like maybe spaces, numbers, and punctuation, but for now we’ll keep it to the
    26 letters from A to Z.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll create a custom block called `Initialize` to set up the program
    (see [Figure 6-3](ch06.xhtml#ch6fig3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg124_Image_147.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-3: The setup code for the Caesar cipher*'
  prefs: []
  type: TYPE_NORMAL
- en: In this block, after we call `Alphabet`, we define `size` based on the number
    of characters in the alphabet chosen. Next, we prompt the user for a shift size
    and a message to encrypt. We then build a scrambled alphabet based on the chosen
    shift size using the custom `Scramble` block, shown in [Figure 6-4](ch06.xhtml#ch6fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg124_Image_148.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-4: Building a scrambled alphabet*'
  prefs: []
  type: TYPE_NORMAL
- en: The `Scramble` block builds a list called `scrambled` by applying the shift
    to the original `alphabet` list, one letter at a time. In theory, the letter at
    index `i` in the `scrambled` list should be the same as the letter at index `shift
    + i` in the `alphabet` list. It’s not quite that simple, though, since at some
    point we need to wrap back around to the start of the alphabet. The custom `Wrap`
    block, also shown in [Figure 6-4](ch06.xhtml#ch6fig4), uses `mod` to recalculate
    the index when necessary. Because modular arithmetic expects to start from a minimum
    value of 0 but Scratch wants lists to be indexed starting with 1, we need to subtract
    1 before taking the `mod`, then add 1 again before using the resulting index.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The scrambling code is broken out into a separate block to make it easy for
    us to modify the encryption technique in later programs. All we’ll have to do
    is change how the scrambled encrypting alphabet is constructed.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-5](ch06.xhtml#ch6fig5) shows the main program stack.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg125_Image_149.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-5: The main code for the Caesar cipher*'
  prefs: []
  type: TYPE_NORMAL
- en: After calling `Initialize`, we loop through the provided message one character
    at a time. The `if...else` block checks if the current message character is included
    in `alphabet`. If it is, the program looks up the equivalent shifted character
    and joins it to the encoded message in the `encrypted` variable. If the character
    isn’t in the alphabet—for example, if it’s a space or punctuation mark—then the
    program just passes that character through to the encoded message unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Figure 6-6](ch06.xhtml#ch6fig6) shows the results of two sample runs of the
    program.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg126_Image_150.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-6: Encrypting and decrypting a message*'
  prefs: []
  type: TYPE_NORMAL
- en: On the left, we’ve specified a shift of 3 to encode the message “hello!” Scratch
    keeps track of its characters in uppercase, so when each letter is advanced by
    3 we get the encrypted message “KHOOR!” The way we wrote the program, the punctuation
    doesn’t change.
  prefs: []
  type: TYPE_NORMAL
- en: A convenient feature of this program (and of the Caesar cipher itself) is that
    it can be used to decrypt as well as encrypt. The output on the right shows how
    we can take the encoded message “KHOOR!” and shift it by 23 to recover our original
    message of “HELLO!” (now in all caps). Since the alphabet size was 26, an additional
    shift of 23 after the initial shift of 3 gets us back to 26, which is no shift
    at all. It would also have worked to enter the second shift as –3 instead of 23
    because modulo 26 we get to the same place by going 3 steps backward or 23 steps
    forward.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Code
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Because non-alphabet characters aren’t encrypted, our code preserves the spaces
    between words, even as the words themselves are scrambled. This can sometimes
    be a giveaway, providing clues about the contents of the original message: a one-letter
    word, for example, is likely *a* or *I*, and *the* and *and* are some of the most
    common three-letter words. Including a space character in the alphabet will help
    disguise such clues in the encrypted message by making the original word breaks
    less obvious. (In addition, some encryption techniques are more effective if the
    alphabet size is a prime number; this is another reason why adding a space and
    a couple of other punctuation characters to the alphabet may be a good idea!)'
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, we’ve written the code in such a way that it works no matter the
    length of the alphabet, so adding extra characters is easy. The modular arithmetic
    needed to wrap back around to the start of the alphabet relies on the `size` variable,
    which is set based on the length of the `Alphabet` list at the start of the program.
    This way, the modulus will be adjusted automatically if the alphabet changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s another possible improvement: after a few encryptions and decryptions,
    you may find that you’d like to have a history of the work that Scratch has done.
    It’s easy to add a *log* to hold a record of all of the program’s input and output
    in one place. All you need to do is define a list called `log`, then add a few
    blocks (shown in [Figure 6-7](ch06.xhtml#ch6fig7)) to the program to write data
    to the list. Since the contents of a list can be saved to a file, keeping this
    log makes it easy to copy the encoded messages into another program, such as a
    text editor or email client, or back into the input field in the Scratch program
    for further processing.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg127_Image_151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-7: Adding a logfile*'
  prefs: []
  type: TYPE_NORMAL
- en: To create a logfile, add the first two block stacks shown in [Figure 6-7](ch06.xhtml#ch6fig7),
    logging the values of `shift` and `message`, to the end of the `Initialize` block
    ([Figure 6-3](ch06.xhtml#ch6fig3)). Then, add the third stack, logging the encrypted
    message, to the end of the main program stack ([Figure 6-5](ch06.xhtml#ch6fig5)).
    The last stack in [Figure 6-7](ch06.xhtml#ch6fig7) erases the log when you press
    the down arrow key. You can use this feature to cover your tracks, or to reset
    the log if it starts to get too long.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-8](ch06.xhtml#ch6fig8) shows what the log looks like when we decrypt
    “KHOOR!” by shifting by –3 instead of 23.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg127_Image_152.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-8: Another decryption of “HELLO!”*'
  prefs: []
  type: TYPE_NORMAL
- en: Because the `log` list resets only when you press the down arrow key, it will
    continue to store values over multiple runs of the program, even as the values
    of `shift`, `message`, and `encrypted` are overwritten.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 23: Cracking the Caesar Cipher'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Caesar’s cipher was effective in its time, perhaps because most people couldn’t
    read that well anyway. But in truth, it isn’t a very secure method of encryption.
    If you have a message and you know it’s been encrypted by shifting, all you have
    to do is pass the message through every possible shift factor, and one of them
    will give you the decrypted text. The number of possible shifts is only the size
    of the alphabet—in this case, 26\. As we’ll see in this project, Scratch can work
    through all the possibilities almost instantaneously.
  prefs: []
  type: TYPE_NORMAL
- en: To create a program for automatically decrypting messages encrypted with a Caesar
    shift, keep the supporting blocks from the previous project, but modify the main
    `when clicked` program stack as shown in [Figure 6-9](ch06.xhtml#ch6fig9). This
    updated code will produce a list applying all possible shifts to the encrypted
    message. When you scroll through the list, the appropriate shift and decoding
    should jump right out at you.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg128_Image_153.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-9: Making all possible shifts*'
  prefs: []
  type: TYPE_NORMAL
- en: We start with an initial `shift` of `1` ❶ and use a loop to gradually shift
    through the entire alphabet. Then, we use an inner loop to cycle through the letters
    of the message and decode them using the current shift factor. At the end of the
    inner loop, we have a possible decrypted message, which we add to the `Shifts`
    list. As in the previous project, we use an `if ... else` block to pass characters
    through unchanged if they aren’t in the alphabet ➋.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg129_Image_154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-10: Initializing the cracking program*'
  prefs: []
  type: TYPE_NORMAL
- en: We also need to modify the `Initialize` block from the previous project, as
    shown in [Figure 6-10](ch06.xhtml#ch6fig10).
  prefs: []
  type: TYPE_NORMAL
- en: This updated `Initialize` block manages the `Shifts` list by deleting its previous
    contents ❶. We still prompt for a message, but we no longer have to bother with
    prompting for a shift, since the code generates all possible shifts anyway.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Suppose you intercept the message “UVA CLYF DLSS OPKKLU, DHZ PA?” Plug it into
    the decrypting program (you can copy-paste it or enter it by hand) to discover
    the message in [Figure 6-11](ch06.xhtml#ch6fig11).
  prefs: []
  type: TYPE_NORMAL
- en: The decrypted message is in line 19 of the `Shifts` list, which tells us that
    a shift of 19 was needed to recover the message. So the original message must
    have been encrypted with a shift of 26 – 19 = 7\. With a shift of 7, N becomes
    U, O becomes V, T becomes A (after wrapping), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg129_Image_155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-11: Uncovering a shifted message*'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenges'
  prefs: []
  type: TYPE_NORMAL
- en: '**6.1** Use the graphics in Scratch to design a magic decoder ring using a
    Caesar cipher. The program should animate a ring like the one in [Figure 6-1](ch06.xhtml#ch6fig1)
    so that shifted letters line up with the corresponding unshifted letters.'
  prefs: []
  type: TYPE_NORMAL
- en: '**6.2** In the movie *2001: A Space Odyssey*, the sentient computer HAL controlling
    a spaceship carrying two astronauts on a mission to Jupiter attempts to murder
    the crew. Apply a Caesar shift of 1 to “HAL” to see if there might be a secret
    message there about who built him.'
  prefs: []
  type: TYPE_NORMAL
- en: '**6.3** A Caesar shift can translate between different languages, if you’re
    lucky! Apply a shift of 16 to “yes” to translate it into French.'
  prefs: []
  type: TYPE_NORMAL
- en: '**6.4** Find the Caesar shift to decrypt the message “DROBO GSVV LO K RYD DSWO
    SX DRO YVN DYGX DYXSQRD!”'
  prefs: []
  type: TYPE_NORMAL
- en: More Substitution Ciphers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Caesar cipher is an example of a *substitution cipher*, where each letter
    of the alphabet is substituted for some other letter of the alphabet. In effect,
    a substitution cipher scrambles the alphabet, making once-readable words look
    unfamiliar. With the Caesar cipher, we do the scrambling by shifting all the letters
    by a set number of positions, but any other scrambling technique would work just
    as well for encrypting a text. In fact, a nice thing about our original Caesar
    cipher program is that its main stack (the code in [Figure 6-5](ch06.xhtml#ch6fig5))
    can work with any scrambled alphabet, not just one generated through shifting.
    We can modify the `Scramble` block ([Figure 6-4](ch06.xhtml#ch6fig4)) to build
    the `scrambled` list in some other way, and the program will encode messages accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: If we don’t limit ourselves to shifts, how many possibilities for scrambling
    are there? Well, we have 26 choices for what the letter A becomes, then 25 choices
    for what B becomes, 24 choices for C, and so on. In all, that gives us 26! (26
    factorial) permutations, or over 400 septillion (4 ⋅ 10^(26)) ways to scramble
    the alphabet. The Caesar cipher considers only 25 of these permutations (assuming
    you don’t want to use a shift of 0).
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of the Caesar cipher is that it takes only one number, the shift
    factor, to determine the scrambled alphabet. In other words, if you want to give
    a friend the key for decoding your shifted messages, all you have to do is whisper
    that one number to them. Encryption is essentially an addition by the shift factor,
    and decryption involves undoing the addition. You can undo a shift of *s* by subtracting
    *s* or by adding 26 – *s*. By contrast, to let your friend in on some other scrambling
    scheme (perhaps chosen randomly from the 26! possible permutations), you’d need
    to provide 25 separate pieces of information before they’d know how to decode
    your messages. You’d have to say what each letter from A to Y becomes, after which
    Z has to go in the only slot left. That’s a lot of extra information to keep track
    of!
  prefs: []
  type: TYPE_NORMAL
- en: Encryption by Modular Multiplication
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Here’s a different idea. The Caesar cipher scrambles the alphabet by shifting,
    which can be thought of as addition modulo 26\. What if we scramble the alphabet
    by *multiplication* modulo 26 rather than addition? That is, we can take each
    letter’s position in the alphabet and multiply it by some number modulo 26 to
    get the position of the letter it should be replaced with. To get us started,
    [Figure 6-12](ch06.xhtml#ch6fig12) shows an operation table for mod 26 multiplication.
    (You can generate this table yourself using the code from [Project 21](ch05.xhtml#ch05lev13)
    in [Chapter 5](ch05.xhtml#ch05).)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg131_Image_156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-12: Multiplication mod 26*'
  prefs: []
  type: TYPE_NORMAL
- en: This table gives all possible products of two numbers modulo 26\. For example,
    to multiply 9 by 5, look at row 9 and column 5\. The entry where they intersect
    is 19, so 9 ⋅ 5 is 19 mod 26\. That makes sense, since we know that 9 ⋅ 5 is “really”
    45, and 45 leaves a remainder of 19 when it’s divided by 26.
  prefs: []
  type: TYPE_NORMAL
- en: For a row (or column) of this table to lead to a successful scrambling of the
    alphabet, it needs to include every number from 0 to 25—that is, it must be a
    permutation (or reordering) of the table’s index. Not every row works. For example,
    row 4 begins (0, 4, 8, . . .) and starts repeating itself at column 13\. Meanwhile,
    the values in row 13 simply alternate back and forth between 0 and 13, which would
    turn all the letters in a message into either As or Ns. Not very useful!
  prefs: []
  type: TYPE_NORMAL
- en: 'The usable rows (and columns) are the ones indexed by numbers that are relatively
    prime to 26, meaning they share no common factors with 26 other than 1\. There
    are 12 of them: rows 1, 3, 5, 7, 9, 11, 15, 17, 19, 21, 23, and 25\. These rows
    all contain permutations of the numbers between 0 and 25\. For example, multiplying
    the letters of the alphabet by 3 mod 26 would give the following cipher:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg132_Image_157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You could build the scrambled row by counting ahead by three letters each time
    (A B **C**, D E **F**, G H **I**, . . .), wrapping around at Z to begin again,
    until the entire alphabet has been assigned.
  prefs: []
  type: TYPE_NORMAL
- en: To implement a multiplication-based cipher using our code from [Project 22](ch06.xhtml#ch06lev2),
    all we have to do is make one small change to our `Scramble` block from earlier,
    as illustrated in [Figure 6-13](ch06.xhtml#ch6fig13).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg132_Image_158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-13: Multiply, don’t add!*'
  prefs: []
  type: TYPE_NORMAL
- en: By changing `+` to `*`, we tell the program to encrypt messages using modular
    multiplication rather than modular addition.
  prefs: []
  type: TYPE_NORMAL
- en: Decryption by Modular Multiplication
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now let’s consider decrypting. We decrypted a Caesar shift by undoing the addition.
    To undo a shift of 3 letters to the right, for example, we shifted 3 letters to
    the left (or 26 – 3 = 23 more to the right, since the arithmetic is mod 26). To
    undo a multiplication by 3, we need to divide by 3, but there’s no room for fractions
    or decimal places in modular arithmetic. If the original modular multiplication
    by 3 gave a result of 14, we can’t turn around and divide by 3 to say we want
    letter 4.66 of the alphabet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, there’s still a way to undo the multiplication. We have to find
    the modular inverse of the multiplier and use that as the decryption key. The
    *modular inverse* is the multiplicative inverse, where the multiplication is interpreted
    using modular arithmetic. Given a modulus *m*—in this case, 26—multiplying a number
    by its modular inverse yields 1 mod *m*. For example, notice in the multiplication
    table in [Figure 6-12](ch06.xhtml#ch6fig12) that there’s a 1 in row 3, located
    at column 9\. This tells us that 9 is the modular inverse of 3 mod 26\. To prove
    it, check the math: 3 ⋅ 9 = 27, and 27 mod 26 = 1.'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re used to arithmetic giving a multiplicative inverse as a fraction,
    it may seem strange to see a multiplicative inverse that’s an integer, let alone
    an integer that’s greater than the original number. Shouldn’t the multiplicative
    inverse be something small? After all, in ordinary arithmetic the multiplicative
    inverse of 3 is 1/3, since 3 ⋅ 1/3 is 1\. All that matters for an inverse, though,
    is that the product is 1\. With ordinary arithmetic, you get 1 by multiplying
    *n* by 1/*n*. With modular arithmetic, you get 1 by multiplying *n* by some other
    integer.
  prefs: []
  type: TYPE_NORMAL
- en: Since 9 is the multiplicative inverse of 3 mod 26, we can use a multiplier of
    9 to decrypt a message that was encrypted with a multiplier of 3\. The log shown
    in [Figure 6-14](ch06.xhtml#ch6fig14) confirms this.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg133_Image_159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-14: Uncovering a multiplied message*'
  prefs: []
  type: TYPE_NORMAL
- en: First, we use a multiplier of 3 to encrypt the message “Hello!” Then, we use
    9, the modular inverse of 3 mod 26, to “encrypt” the result, which restores the
    original message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 24: The Modular Inverse Is the Key'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ve established that to recover a message encrypted through modular multiplication,
    we need the modular inverse. In this project, we’ll look at how to find a modular
    inverse to aid in the decryption process.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to find a modular inverse is to just look for it: study the operation
    table for multiplication mod `alphabet size` and see what multiple of *m* gives
    the answer 1\. That multiple is the modular inverse. That’s the approach we took
    in the last section, examining the mod 26 multiplication table in [Figure 6-12](ch06.xhtml#ch6fig12)
    to determine that the modular inverse of 3 is 9\. Now let’s automate that process
    with Scratch so we can easily find the modular inverse for any number and any
    modulus. [Figure 6-15](ch06.xhtml#ch6fig15) shows how.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg134_Image_160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-15: Finding a modular inverse*'
  prefs: []
  type: TYPE_NORMAL
- en: The program first prompts for a modulus and a number to invert. These two values
    must be relatively prime in order for the number to have a modular inverse. We
    test for this using the custom `gcd` block we built for [Project 9](ch02.xhtml#ch02lev14)
    back in [Chapter 2](ch02.xhtml#ch02) (see [Figure 2-17](ch02.xhtml#ch2fig17) [page
    38](ch02.xhtml#page_38)). If the GCD is `1`, the values are relatively prime,
    so we use a loop to test every possible inverse, starting from `1`, until we find
    the one where `x * inverse mod modulus = 1` ❶. This is the programmatic equivalent
    of scanning a row of the operation table until we find the column with a 1 in
    it.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Figure 6-16](ch06.xhtml#ch6fig16) shows some output demonstrating how the
    code works.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg135_Image_161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-16: Modular inverse calculations*'
  prefs: []
  type: TYPE_NORMAL
- en: The program confirms that 9 is the inverse of 3 mod 26\. It also correctly concludes
    that 4 mod 26 has no modular inverse, since 4 and 26 aren’t relatively prime.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Code
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The trial-and-error approach in our modular inverse program isn’t bad for a
    small alphabet (and, by extension, a small modulus), but it would be better to
    have a more focused algorithm to quickly calculate the modular inverse of any
    number for any modulus. As with the `gcd` block, we can reuse part of a program
    we wrote earlier for this: the calculation of the greatest common divisor via
    Euclid’s algorithm from [Project 9](ch02.xhtml#ch02lev14) in [Chapter 2](ch02.xhtml#ch02).'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that Euclid’s algorithm worked to calculate the GCD *d* of two given
    numbers *b* and *a* with a sequence of divisions, ending with the GCD as the last
    nonzero remainder. To use this algorithm to find a modular inverse, set *b* to
    the modulus and *a* to the number whose inverse you want to find. Work through
    the algorithm as usual, keeping track of the arithmetic of the divisions. Then,
    step through it backward, looking for an equation that puts 1 on one side and
    both *a* and *b* on the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we wanted to find the modular inverse of 3 mod 26, we could
    first pass those numbers through Euclid’s algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg135_Image_162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last nonzero remainder, 1, is the GCD. Next, we need to unwind the steps
    to find a combination of 26 and 3 that equals 1\. Rewriting the middle equation
    in the algorithm, we get 1 = 3 – 2\. Rewriting the top equation in the algorithm,
    we get 2 = 26 – 8 ⋅ 3\. Then, substituting 26 – 8 ⋅ 3 for the 2 in the middle
    equation, we get 1 = 3 – (26 – 8 ⋅ 3). Overall, the right side of this equation
    has one 3 and then eight more 3s in the parentheses, so 1 + 8 = 9 of them in all,
    along with –1 ⋅ 26\. We can combine the pieces to see 1 = 9 ⋅ 3 – 26\. This tells
    us that 1 = 9 ⋅ 3 mod 26, so 9 is the modular inverse of 3\. There’s a programming
    challenge coming up to make this approach work in general.
  prefs: []
  type: TYPE_NORMAL
- en: More Encryption Options with Linear Transformations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You might think we haven’t gained much by switching from modular addition to
    modular multiplication. After all, for an alphabet of size 26 there were 26 possible
    shifted alphabets, and there are only 12 possible multiplied alphabets. However,
    we can get a much bigger set of scrambled alphabets by combining both approaches:
    multiply *and* shift. That is, we can apply any of the 26 possible shifts to each
    of the 12 scrambled alphabets obtained through multiplication, giving us 26 ⋅
    12 = 312 potential alphabets. That’s many more possibilities to hide a message.'
  prefs: []
  type: TYPE_NORMAL
- en: The general rule for this combined approach is that we scramble the alphabet
    by replacing the letter whose index is *i* with the letter whose index is *m*
    ⋅ *i* + *s*. In other words, we multiply the index by *m*, then add a constant
    *s*. If we picked values for *m* and *s* and graphed the results of this formula
    for every value of *i*, we’d find that the graph shows a straight line with a
    slope of *m*. For example, say we set *m* to 2 and *s* to 3\. If we graph the
    function 2*i* + 3, the line passes through the points (0, 3), (1, 5), (2, 7),
    (3, 9), (4, 11), (5, 13), and (6, 15), as shown in [Figure 6-17](ch06.xhtml#ch6fig17).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg136_Image_163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-17: A graph of 2*i *+ 3*'
  prefs: []
  type: TYPE_NORMAL
- en: Because they produce straight lines, “multiply plus a constant” formulas like
    *m* ⋅ *i* + *s* are known as *linear functions*. By extension, a “multiply and
    shift” encryption process is called a *linear transformation*. As long as the
    multiplier *m* is chosen to be relatively prime to the alphabet size, the encryption
    will work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 25: Encryption by a Linear Transformation'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s adapt our Caesar cipher code from [Project 22](ch06.xhtml#ch06lev2) to
    handle linear transformations. First, we’ll update the `Initialize` block as shown
    in [Figure 6-18](ch06.xhtml#ch6fig18).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg137_Image_164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-18: Linear transformation encryption*'
  prefs: []
  type: TYPE_NORMAL
- en: We now prompt for both a shift and a multiplier, instead of just a shift like
    before. Notice also the extra code to maintain the `log` list. Next, we’ll modify
    the `Scramble` block to match [Figure 6-19](ch06.xhtml#ch6fig19).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg138_Image_165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-19: Wrapping with a linear transformation*'
  prefs: []
  type: TYPE_NORMAL
- en: This updated `Scramble` block still uses the original `Wrap` block from [Figure
    6-4](ch06.xhtml#ch6fig4). The input to `Wrap` implements the *m* ⋅ *i* + *s* linear
    function to scramble the alphabet.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Figure 6-20](ch06.xhtml#ch6fig20) shows an example of the linear transformation
    program in action. It encrypts the message “TOP SECRET!” using a multiplier of
    3 and a shift of 5.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg138_Image_166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-20: Encrypting with a linear transformation*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To decrypt the resulting message, we need to undo both the shift and the multiplication.
    Undoing the shift is easy: for an original shift of *s*, we instead perform a
    shift of –*s*. And as we’ve discussed, to undo a multiplication by *m*, we can
    multiply by the modular inverse of *m*. We’ll perform these operations separately,
    by running the encrypted message through the linear transformation program twice:
    once for the shift and once for the multiplication.'
  prefs: []
  type: TYPE_NORMAL
- en: First, we undo the shift of 5 with a shift of –5, as shown in [Figure 6-21](ch06.xhtml#ch6fig21).
    We use a multiplier of 1, meaning we’re effectively doing no multiplication at
    all.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg138_Image_167.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-21: Undoing the shift*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to take the result and feed it back into the linear transformation
    program to undo the multiplication. We know that the modular inverse of 3 mod
    26 is 9, so that’s the multiplier we use in [Figure 6-22](ch06.xhtml#ch6fig22).
    This time, we use a shift of 0 to focus just on reversing the multiplication.
    The result is the original message.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg139_Image_168.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-22: Undoing the multiplication*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In all, only two numbers determine an encryption by linear transformation:
    the shift and the multiplier. Likewise, only two numbers are needed to decrypt
    the message. It’s a pretty compact secret key!'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenges'
  prefs: []
  type: TYPE_NORMAL
- en: '**6.5** You’ve seen how to decrypt a linear transformation cipher in two separate
    steps, first undoing the shift and then undoing the multiplication. Is it possible
    to combine these into a single step? For example, could you decrypt the message
    MXA JTNGTM!” from [Figure 6-20](ch06.xhtml#ch6fig20) by running the linear transformation
    program once, with a shift of –5 and a multiplier of 9? As it turns out, this
    won’t work, but there’s a different shift factor that will. Think about what it
    could be, and why.'
  prefs: []
  type: TYPE_NORMAL
- en: '**6.6** Use what you’ve learned from Challenge 6.5 to write a Scratch program
    that takes in a multiplier and shift for a linear transformation encryption and
    calculates the modular inverse and appropriate shift to perform the decryption
    in one step.'
  prefs: []
  type: TYPE_NORMAL
- en: '**6.7** What goes wrong in a linear transformation encryption if the multiplier
    isn’t relatively prime to the alphabet size?'
  prefs: []
  type: TYPE_NORMAL
- en: '**6.8** Modify the [Project 23](ch06.xhtml#ch06lev5) code for cracking a Caesar
    shift ([Figure 6-9](ch06.xhtml#ch6fig9)) so the program lists all possible decryptions
    for all 312 possible linear transformation ciphers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**6.9** Any permutation or scrambling of the alphabet can be the key for a
    substitution cipher. Write a Scratch program that will generate a random scrambling
    of the alphabet. The `pick random` operator block might come in handy for this.'
  prefs: []
  type: TYPE_NORMAL
- en: '**6.10** Write a program to calculate modular inverses using Euclid’s algorithm,
    as discussed in “Hacking the Code” on [page 115](ch06.xhtml#ch06lev12). You’ll
    probably want to keep track of quotients and remainders as lists and work your
    way backward up the lists to unwind the steps.'
  prefs: []
  type: TYPE_NORMAL
- en: Unbreakable One-Time Pad Ciphers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *one-time pad cipher* is a technique that uses one text (the key) to encrypt
    or decrypt another text (the message). The encryption takes the first character
    of the message and shifts it by the position of the first character in the key.
    It then shifts the second character by the position of the second character in
    the key, and so on. Every character in the message uses its own encryption scheme,
    with the alphabet essentially being rescrambled for each letter.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate, let’s say we want to encrypt the message “Hello” using the word
    “Scratch” as a key. (The key should always be at least as long as, if not longer
    than, the message.) The first letter of the key, S, is the 19th letter of the
    alphabet, so we should shift the first letter in the message, H, by 19 positions,
    yielding the letter A (after wrapping around at Z). The second letter of the key,
    C, is the third letter of the alphabet, so we should shift the second letter of
    the message, E, by 3 positions, yielding the letter H. If we keep going like this,
    we’ll end up with “AHDMI” as the coded message. Using the key to do the shifts
    in reverse decrypts the message.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, one-time pads are used to share longer coded messages, using correspondingly
    longer keys. The key might be a literal notepad, with a long handwritten sequence
    of random letters determining the shifts to be used. Or it could be any other
    text that the sender and recipient of the message agree to share, such as the
    lyrics of a song, a passage in a book, or an article posted on the internet. The
    important thing is to keep the key a secret.
  prefs: []
  type: TYPE_NORMAL
- en: One-time pads are much stronger codes than the simpler ciphers we discussed
    earlier in the chapter. In fact, if you use a truly random sequence of characters
    for the key and you never use the same key twice (hence *one-time* pad), your
    coded messages will be impossible to crack. The same cannot be said about any
    secret code based on a fixed permutation of the alphabet, whether it’s a Caesar
    cipher, a linear transformation, or any other scrambling algorithm. This is because,
    as mentioned earlier, the English language has patterns and regularities in it
    that provide clues about the message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if we remove the spaces between words to conceal obvious giveaways like
    one-letter words (almost certain *I* or *a*) and recurring three-letter words
    (quite possibly *the* or *and*), there are other patterns that can shine through
    in a scrambled alphabet. For example, only certain letters commonly appear twice
    in a row in English: there are plenty of words with double Es, Ss, and Ts, far
    fewer with double As or double Zs, and virtually none with double Qs or double
    Js. Two-letter sequences like TH and CK are also common.'
  prefs: []
  type: TYPE_NORMAL
- en: More broadly, letters like E and A occur much more often in a given English
    text than letters like Q and Z, so counting the *frequency*, meaning the number
    of occurrences, of each letter in an encrypted message—especially a long message—can
    give a good clue about the encryption scheme. To prove it, we’ll write a program
    to calculate letter frequencies and test it on a text encrypted with a Caesar
    shift. Then we’ll write a program to implement a one-time pad cipher and test
    its result as well. We should see that the one-time pad cipher eliminates any
    regular patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 26: Frequency Analysis for Cracking Codes'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The goal for this project is to create a program that counts how many times
    each letter is used in an encrypted message, potentially providing clues about
    the encryption scheme based on how many times different letters are used in a
    typical unencrypted English text. We’ll need to take advantage of Scratch’s text
    processing capabilities for this. In particular, we’ll use the green `length of`
    and `letter of` blocks together in a loop to examine a text one character at a
    time. [Figure 6-23](ch06.xhtml#ch6fig23) shows the program.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg141_Image_169.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-23: Counting how many times each letter is used*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use two separate lists: `alphabet`, which is built up at the start of the
    program with the same `Alphabet` block first defined in [Figure 6-2](ch06.xhtml#ch6fig2),
    and `frequency`, where we store the number of occurrences of each letter of the
    alphabet. To begin, we fill `frequency` with 26 0s. Then we take in a text to
    process from the user and loop through it one character at a time. The `item #
    of letter i of text in alphabet` does a reverse lookup of the *i*th character
    of the text in `alphabet`. For example, if the character is C, this will give
    us `3`, C’s position in the `alphabet` list. We add `1` to the entry at the same
    position in the `frequency` list to count that character ❶.'
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Code
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The code in [Figure 6-24](ch06.xhtml#ch6fig24) is a nice little addition to
    the program that adds labels to the `frequency` list. Place it at the end, after
    the `repeat` loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg142_Image_170.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-24: Adding a label to each entry in the* frequency *list*'
  prefs: []
  type: TYPE_NORMAL
- en: After all the counting is done, this extra code labels each entry in the `frequency`
    list with the letter of the alphabet it represents. This way, you won’t have to
    remind yourself that letter A is 1, letter B is 2, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s put the frequency analysis program to work. We’ll start with a reasonably
    sized unencrypted text, the first chapter of *Alice’s Adventures in Wonderland*,
    to get a feel for the normal frequencies of letters in ordinary English. You don’t
    have to type the whole text out yourself; just look it up online and copy-paste
    it when Scratch Cat asks for your input. [Figure 6-25](ch06.xhtml#ch6fig25) shows
    the results.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg143_Image_171.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-25: Analyzing character frequencies in an unencrypted text (down
    the rabbit hole . . .)*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the text contains lots of Es and As, but only one J. If you
    scroll to the bottom of the list, you’ll find there’s one Q and no Xs or Zs. This
    is a pretty typical distribution of letters for an English-language text.
  prefs: []
  type: TYPE_NORMAL
- en: Now try using our original Caesar cipher program from [Project 22](ch06.xhtml#ch06lev2)
    to encrypt the same *Alice’s Adventures in Wonderland* chapter, shifting the alphabet
    by three places. Plug the encrypted text into the frequency analysis program.
    [Figure 6-26](ch06.xhtml#ch6fig26) shows the result.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg143_Image_172.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-26: Analyzing character frequencies in a shifted text*'
  prefs: []
  type: TYPE_NORMAL
- en: 'I can’t read the encrypted message, but I do notice that the word *DQG* appears
    lots of times, which is a clue. More importantly, there’s still a strong pattern
    in the frequencies of letters that suggests how the most common letters have been
    encoded. Of course, the pattern matches the original message perfectly, shifted
    three places: you can see the original frequency for A showing up at D, the original
    frequency for E showing up at H, and so on. The zeros at A and C are from X and
    Z wrapped around. Looking at this output, even if I didn’t know what the original
    text was, I could make a good guess as to which letter is E.'
  prefs: []
  type: TYPE_NORMAL
- en: In theory, a one-time pad cipher should eliminate these patterns, causing every
    letter in the encrypted text to appear with roughly the same frequency. We’ll
    find out in the next project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 27: Encryption with a One-Time Pad'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can program a one-time pad encryption in Scratch by making just a few changes
    to the encryption programs we’ve written so far. [Figure 6-27](ch06.xhtml#ch6fig27)
    shows the `Initialize` block.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg144_Image_173.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-27: Setup code for the one-time pad*'
  prefs: []
  type: TYPE_NORMAL
- en: This block asks for the encoding key and the message. It also asks if the user
    wants to encrypt or decrypt ❶, so we can use the same program for both operations.
    Depending on the answer, the variable `action` is assigned a value of `1` or `-1`.
    This value is incorporated into the arithmetic of the shift, such that encryption
    involves adding the shift and decryption involves subtracting it.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `Initialize` block sets up a log so we can scroll through a
    history of the program’s use. It also calls a custom `Trim key` block, which is
    defined in [Figure 6-28](ch06.xhtml#ch6fig28).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg145_Image_174.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-28: Trimming the key*'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Trim key` block, we take the text that will be used to encrypt the message
    and remove any characters (like spaces or punctuation) that aren’t in the alphabet.
    The variable `trimmed_key` starts out empty. Then, the `repeat` loop steps through
    the key character by character; it ignores characters that aren’t in the `alphabet`
    list and puts the rest of the characters into `trimmed_key`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-29](ch06.xhtml#ch6fig29) shows the main program code.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg146_Image_175.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-29: The main code for one-time pad encryption (and decryption)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this stack, we move character by character through the message (using index
    `i`) and the trimmed key (using index `j`), determining the shift for the current
    character in the message based on the current character in the key. We use an
    `if` statement ❶ to wrap back around to the start of the trimmed key if there
    are more characters in the message than in the key. As I mentioned earlier in
    the chapter, though, it’s best to use a key that’s at least as long as the message.
    A shorter key is a vulnerability: if the key starts to repeat, frequency analysis
    can reveal information about the key length and encoding phrase. A one-character
    key, for example, is equivalent to a Caesar shift!'
  prefs: []
  type: TYPE_NORMAL
- en: The real work is done in the `set` block ➋. It builds the encrypted message
    one character at a time by shifting the original character by an amount determined
    by the corresponding character in the key. We use the original `Wrap` block from
    [Figure 6-4](ch06.xhtml#ch6fig4) to get the index for the appropriate letter.
    Notice also that we multiply by `action` (either `1` or `-1`) when setting the
    value of `shift`. As mentioned previously, this allows the program to work for
    encryption and decryption by shifting either forward or backward.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To see how secure one-time pad encryption is compared to simple alphabet scramblings
    like the Caesar cipher, let’s use our program to encrypt the same *Alice’s Adventures
    in Wonderland* chapter as before. For that, we need to choose a key. I’ll use
    the nonsense poem “Jabberwocky,” shown in [Figure 6-30](ch06.xhtml#ch6fig30),
    to keep in the Lewis Carroll spirit.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg147_Image_176.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-30: The one-time pad key*'
  prefs: []
  type: TYPE_NORMAL
- en: Encode the *Alice* chapter using the one-time pad program in encryption mode,
    find the encrypted text in the log, and copy-paste it into the frequency analysis
    program from the previous project. The result should look something like [Figure
    6-31](ch06.xhtml#ch6fig31).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg147_Image_177.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-31: Analyzing character frequencies in text encrypted with a one-time
    pad*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the distribution of letters is now much flatter: no one letter
    stands out as being used much more (or less) frequently than the others, so frequency
    analysis doesn’t provide any clues for cracking the code. What’s more, the one-time
    pad has also eliminated regular patterns from the encrypted text itself. Whereas
    the Caesar-shifted version ([Figure 6-26](ch06.xhtml#ch6fig26)) showed *DQG* at
    every instance of the word *and*, now each occurrence of *and* is encoded differently:
    first *ZKI*, then *JFH*, and so on. Without the key, decrypting the text seems
    like an impossible task; there are no clues to help you. And just imagine if spaces
    and punctuation were included in the alphabet and scrambled along with the letters—the
    encoded message would look like letter soup!'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenges'
  prefs: []
  type: TYPE_NORMAL
- en: '**6.11** A *cryptogram* is a word puzzle based on a scrambled alphabet, not
    necessarily a Caesar shift or a linear transformation. Write a Scratch program
    to help solve cryptograms by keeping track of letters as they’re guessed and showing
    progress with a partial decryption. Here’s an example of a cryptogram for you
    to solve. As a clue to help you get started, this cryptogram uses M to stand for
    S. You can look at patterns and letter frequencies to guess the other letters.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg148_Image_178.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**6.12** Write a Scratch program to remove spaces and punctuation from a text
    string so all that’s left is a string of letters and numbers. This could be useful
    to remove word-break clues from an encrypted message.'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Scratch isn’t just for processing numbers; it’s just as good at processing text.
    Any transformation rule that’s reversible can be the basis of an encryption algorithm
    for sharing secrets, but some rules (like using a one-time pad) are better than
    others (like basic shifts) for keeping secrets safe. You can always use techniques
    like frequency analysis to look for clues about how to decode a message.
  prefs: []
  type: TYPE_NORMAL
