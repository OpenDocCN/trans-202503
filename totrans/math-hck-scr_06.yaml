- en: '**6**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**6**'
- en: '**Making Codes, and Cracking Them Too**'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**制作密码，并破解它们**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: Say you have a secret that you want to share with a friend. You could write
    it down and pass them a note, but somebody else might see it. Or you could whisper
    it to them, but somebody might overhear. Think how much better it would be if
    anyone else who intercepted your message couldn’t make sense of it. A secret code!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个秘密，想要与朋友分享。你可以把它写下来并传递给他们，但别人可能会看到。或者你可以悄悄地告诉他们，但也许有人会偷听。想象一下，如果任何拦截你信息的人都无法理解它，那该多好。一个秘密的密码！
- en: In this chapter, we’ll use Scratch to practice *cryptography*, the art of secret
    codes. We’ll write programs with a few different cryptographic techniques, consider
    their strengths and weaknesses, and use them to encode messages. Writing a message
    in code is only half the job, though. There has to be a way to undo the code,
    or else *nobody* will be able to read it, not even the people you want. We’ll
    look at the other side of the story too, and see how to decode secret messages.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Scratch来练习*密码学*，即秘密编码的艺术。我们将编写程序，使用几种不同的密码技术，考虑它们的优缺点，并用它们来编码信息。然而，写下加密信息只是工作的一半。必须有一种方法可以撤销这个编码，否则*没有人*能读取它，甚至包括你希望阅读的人。我们也将探讨故事的另一面，看看如何解码秘密信息。
- en: Caesar’s Shifty Cipher
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 凯撒的移位密码
- en: Secret codes are important in military applications because commanders need
    a way to let soldiers in the field know their battle plans, preferably without
    revealing them to the enemy if they fall into the wrong hands. The Roman general
    Julius Caesar is credited with devising one of the earliest known methods of encoding
    messages, for just this purpose. As the story goes, when communicating with his
    soldiers Caesar used a simple replacement system in which all the letters in the
    messages (written in Latin, I suppose) were shifted three places to the right.
    So if there was an A in the message, it was replaced by a D, each B was replaced
    by an E, and so on. This approach of creating a coded message by shifting the
    letters in the alphabet is now known as the *Caesar cipher*. The shift doesn’t
    have to be by three; a shift by any number of places will turn a readable message
    into total gibberish.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密编码在军事应用中非常重要，因为指挥官需要一种方法来让前线的士兵了解他们的作战计划，最好是在计划落入敌人手中时不会被揭示。罗马将军尤利乌斯·凯撒被认为发明了最早的已知信息加密方法，正是出于这个目的。故事是这样的：凯撒在与士兵通信时使用了一种简单的替换系统，在这个系统中，消息中的所有字母（我想是用拉丁语写的）都被移位了三位。因此，如果消息中有一个A，它会被替换为D，每个B会被替换为E，以此类推。这种通过字母表移位创建加密消息的方法如今被称为*凯撒密码*。移位不一定是三位；任何位移都能将可读的消息变成完全没有意义的内容。
- en: '*Cipher* is an old-fashioned word for a procedure or a puzzle. It used to be
    that doing arithmetic was called *ciphering* because the way numbers get manipulated
    in big multiplication problems or long division looks like an intricate puzzle.
    The process of converting a message into a disguised form (*encrypting*) and recovering
    the original message from its encrypted form (*decrypting*) is also like solving
    a puzzle, so today *cipher* more commonly refers to a code.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*密码*是一个古老的词，用来表示一种程序或谜题。以前，算术运算被称为*密码运算*，因为大乘法或长除法中的数字操作看起来像一个复杂的谜题。将信息转换成一种伪装形式（*加密*）并从加密形式恢复原始信息（*解密*）的过程也像是在解谜，因此今天*密码*更多地指代一种编码。'
- en: 'The puzzle for the Caesar cipher can be solved with a two-row table. One row
    shows the alphabet from A to Z, and the other shows the alphabet shifted over
    by the appropriate number of places:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 凯撒密码的谜题可以通过一个双行表格来解决。一行显示从A到Z的字母表，另一行显示字母表经过适当位移后的结果：
- en: '![Image](../images/pg122_Image_144.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg122_Image_144.jpg)'
- en: It can help to wrap the rows of the table around in a circle to indicate that
    when we get to the end of the alphabet, we wrap around to the beginning again.
    Imagine two circles, with an inner alphabet and an outer alphabet, as shown in
    [Figure 6-1](ch06.xhtml#ch6fig1).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 将表格的行围绕成一个圆圈有助于表示，当我们到达字母表的末尾时，应该重新回到字母表的开头。想象两个圆圈，一个是内圈字母表，一个是外圈字母表，如[图6-1](ch06.xhtml#ch6fig1)所示。
- en: '![Image](../images/pg122_Image_145.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg122_Image_145.jpg)'
- en: '*Figure 6-1: Shifting around a circle*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-1：围绕圆圈进行移位*'
- en: If the circles can rotate independently, then they can be used to illustrate
    the Caesar cipher with different shifts. You can make a tool like this and use
    it to encrypt and decrypt messages by hand, one letter a time. But why do all
    that work when Scratch can do it for you?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些圆圈能够独立旋转，那么它们可以用来展示带有不同移位的凯撒密码。你可以制作这样的工具，手动加密和解密消息，每次一个字母。但为什么要做这么多工作呢，Scratch可以为你完成这些任务。
- en: 'Project 22: Encryption by a Caesar Shift'
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目 22：通过凯撒移位加密
- en: In this project, we’ll use Scratch to automate the process of encrypting a message
    with the Caesar cipher. First, we’ll put the alphabet into a list, using the custom
    block shown in [Figure 6-2](ch06.xhtml#ch6fig2). That way, we can work with the
    letters by using the numbers that index them in the list.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将使用 Scratch 来自动化凯撒密码加密消息的过程。首先，我们将字母表放入一个列表中，使用[图 6-2](ch06.xhtml#ch6fig2)中显示的自定义块。这样，我们就可以通过使用索引这些字母的数字来操作字母。
- en: '![Image](../images/pg123_Image_146.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg123_Image_146.jpg)'
- en: '*Figure 6-2: Putting the alphabet in a list*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-2：将字母表放入列表中*'
- en: The custom `Alphabet` block builds a list called `alphabet`, adding letters
    one at a time. If you want, you can extend the alphabet to include other symbols,
    like maybe spaces, numbers, and punctuation, but for now we’ll keep it to the
    26 letters from A to Z.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义的 `Alphabet` 块通过一次添加一个字母，构建名为 `alphabet` 的列表。如果需要，你可以将字母表扩展到包括其他符号，比如空格、数字和标点符号，但现在我们先保持字母表只有
    A 到 Z 的 26 个字母。
- en: Next, we’ll create a custom block called `Initialize` to set up the program
    (see [Figure 6-3](ch06.xhtml#ch6fig3)).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个名为 `Initialize` 的自定义块来设置程序（见[图 6-3](ch06.xhtml#ch6fig3)）。
- en: '![Image](../images/pg124_Image_147.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg124_Image_147.jpg)'
- en: '*Figure 6-3: The setup code for the Caesar cipher*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：凯撒密码的设置代码*'
- en: In this block, after we call `Alphabet`, we define `size` based on the number
    of characters in the alphabet chosen. Next, we prompt the user for a shift size
    and a message to encrypt. We then build a scrambled alphabet based on the chosen
    shift size using the custom `Scramble` block, shown in [Figure 6-4](ch06.xhtml#ch6fig4).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个块中，在调用 `Alphabet` 后，我们根据所选字母表中的字符数定义 `size`。接着，我们提示用户输入移位大小和要加密的消息。然后，使用自定义的
    `Scramble` 块（如[图 6-4](ch06.xhtml#ch6fig4)所示）根据所选的移位大小构建一个打乱的字母表。
- en: '![Image](../images/pg124_Image_148.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg124_Image_148.jpg)'
- en: '*Figure 6-4: Building a scrambled alphabet*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：构建一个打乱的字母表*'
- en: The `Scramble` block builds a list called `scrambled` by applying the shift
    to the original `alphabet` list, one letter at a time. In theory, the letter at
    index `i` in the `scrambled` list should be the same as the letter at index `shift
    + i` in the `alphabet` list. It’s not quite that simple, though, since at some
    point we need to wrap back around to the start of the alphabet. The custom `Wrap`
    block, also shown in [Figure 6-4](ch06.xhtml#ch6fig4), uses `mod` to recalculate
    the index when necessary. Because modular arithmetic expects to start from a minimum
    value of 0 but Scratch wants lists to be indexed starting with 1, we need to subtract
    1 before taking the `mod`, then add 1 again before using the resulting index.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scramble` 块通过对原始 `alphabet` 列表中的每个字母应用移位，构建一个名为 `scrambled` 的列表。从理论上讲，`scrambled`
    列表中索引为 `i` 的字母应该与 `alphabet` 列表中索引为 `shift + i` 的字母相同。但事情并没有那么简单，因为有时我们需要回绕到字母表的起始位置。自定义的
    `Wrap` 块（也如[图 6-4](ch06.xhtml#ch6fig4)所示）使用 `mod` 来在必要时重新计算索引。由于模运算期望从最小值 0 开始，而
    Scratch 列表的索引从 1 开始，因此我们需要在取 `mod` 之前减去 1，然后再将结果索引加回 1。'
- en: '**NOTE**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The scrambling code is broken out into a separate block to make it easy for
    us to modify the encryption technique in later programs. All we’ll have to do
    is change how the scrambled encrypting alphabet is constructed.*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*加密代码被拆分为一个独立的块，这样我们可以方便地在后续程序中修改加密方法。我们需要做的只是改变如何构建打乱的加密字母表。*'
- en: '[Figure 6-5](ch06.xhtml#ch6fig5) shows the main program stack.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](ch06.xhtml#ch6fig5) 显示了主要的程序栈。'
- en: '![Image](../images/pg125_Image_149.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg125_Image_149.jpg)'
- en: '*Figure 6-5: The main code for the Caesar cipher*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：凯撒密码的主要代码*'
- en: After calling `Initialize`, we loop through the provided message one character
    at a time. The `if...else` block checks if the current message character is included
    in `alphabet`. If it is, the program looks up the equivalent shifted character
    and joins it to the encoded message in the `encrypted` variable. If the character
    isn’t in the alphabet—for example, if it’s a space or punctuation mark—then the
    program just passes that character through to the encoded message unchanged.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`Initialize`后，我们逐个字符地遍历提供的消息。`if...else`语句块检查当前消息字符是否包含在`alphabet`中。如果包含，程序会查找对应的移位字符，并将其添加到`encrypted`变量中的加密消息。如果字符不在字母表中——例如，如果是空格或标点符号——程序则将该字符原封不动地传递到加密消息中。
- en: The Results
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 结果
- en: '[Figure 6-6](ch06.xhtml#ch6fig6) shows the results of two sample runs of the
    program.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-6](ch06.xhtml#ch6fig6)展示了该程序运行的两个示例结果。'
- en: '![Image](../images/pg126_Image_150.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg126_Image_150.jpg)'
- en: '*Figure 6-6: Encrypting and decrypting a message*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：加密和解密一条消息*'
- en: On the left, we’ve specified a shift of 3 to encode the message “hello!” Scratch
    keeps track of its characters in uppercase, so when each letter is advanced by
    3 we get the encrypted message “KHOOR!” The way we wrote the program, the punctuation
    doesn’t change.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，我们指定了移位数为3，以加密消息“hello!” Scratch将字符视为大写字母，因此当每个字母移位3个位置时，我们得到加密后的消息“KHOOR!”。按照我们编写的程序，标点符号不会发生变化。
- en: A convenient feature of this program (and of the Caesar cipher itself) is that
    it can be used to decrypt as well as encrypt. The output on the right shows how
    we can take the encoded message “KHOOR!” and shift it by 23 to recover our original
    message of “HELLO!” (now in all caps). Since the alphabet size was 26, an additional
    shift of 23 after the initial shift of 3 gets us back to 26, which is no shift
    at all. It would also have worked to enter the second shift as –3 instead of 23
    because modulo 26 we get to the same place by going 3 steps backward or 23 steps
    forward.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序（以及凯撒密码本身）的一大便利功能是，它不仅可以用来加密，还可以用来解密。右侧的输出展示了我们如何将加密后的消息“KHOOR!”再移位23位，从而恢复原始消息“HELLO!”（现在全部为大写字母）。由于字母表大小为26，初始移位3后，再移位23就回到了26，即没有移位。输入第二次移位为-3而不是23也是有效的，因为在模26的情况下，往回移动3步或向前移动23步，结果是一样的。
- en: Hacking the Code
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 破解代码
- en: 'Because non-alphabet characters aren’t encrypted, our code preserves the spaces
    between words, even as the words themselves are scrambled. This can sometimes
    be a giveaway, providing clues about the contents of the original message: a one-letter
    word, for example, is likely *a* or *I*, and *the* and *and* are some of the most
    common three-letter words. Including a space character in the alphabet will help
    disguise such clues in the encrypted message by making the original word breaks
    less obvious. (In addition, some encryption techniques are more effective if the
    alphabet size is a prime number; this is another reason why adding a space and
    a couple of other punctuation characters to the alphabet may be a good idea!)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于非字母字符不会被加密，我们的代码保留了单词间的空格，即使单词本身被打乱。这有时会成为破译的线索，提供原始消息内容的提示：例如，一个单字可能是*a*或*I*，而*the*和*and*是最常见的三字词之一。如果将空格字符也包括在字母表中，它将有助于隐藏这些线索，使加密消息中的原始单词分隔不那么显眼。（此外，如果字母表的大小是素数，某些加密技术会更有效；这也是将空格和其他几个标点符号加入字母表的另一个原因！）
- en: Fortunately, we’ve written the code in such a way that it works no matter the
    length of the alphabet, so adding extra characters is easy. The modular arithmetic
    needed to wrap back around to the start of the alphabet relies on the `size` variable,
    which is set based on the length of the `Alphabet` list at the start of the program.
    This way, the modulus will be adjusted automatically if the alphabet changes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们编写的代码使得它无论字母表的长度如何都能正常工作，因此添加额外字符非常简单。将字母表重新计算回起始位置所需的模运算依赖于`size`变量，这个变量根据程序开始时`Alphabet`列表的长度进行设置。这样，如果字母表发生变化，模运算会自动调整。
- en: 'Here’s another possible improvement: after a few encryptions and decryptions,
    you may find that you’d like to have a history of the work that Scratch has done.
    It’s easy to add a *log* to hold a record of all of the program’s input and output
    in one place. All you need to do is define a list called `log`, then add a few
    blocks (shown in [Figure 6-7](ch06.xhtml#ch6fig7)) to the program to write data
    to the list. Since the contents of a list can be saved to a file, keeping this
    log makes it easy to copy the encoded messages into another program, such as a
    text editor or email client, or back into the input field in the Scratch program
    for further processing.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个可能的改进：经过几次加密和解密后，你可能会发现你想要有一个记录Scratch所做工作的历史。很容易添加一个*日志*，将程序的所有输入和输出集中记录在一个地方。你只需定义一个名为`log`的列表，然后添加一些代码块（如[图6-7](ch06.xhtml#ch6fig7)所示）将数据写入该列表。由于列表的内容可以保存到文件中，保持这个日志使得将加密的消息复制到另一个程序（如文本编辑器或电子邮件客户端），或重新输入到Scratch程序中的输入框进行进一步处理变得非常简单。
- en: '![Image](../images/pg127_Image_151.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg127_Image_151.jpg)'
- en: '*Figure 6-7: Adding a logfile*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-7：添加日志文件*'
- en: To create a logfile, add the first two block stacks shown in [Figure 6-7](ch06.xhtml#ch6fig7),
    logging the values of `shift` and `message`, to the end of the `Initialize` block
    ([Figure 6-3](ch06.xhtml#ch6fig3)). Then, add the third stack, logging the encrypted
    message, to the end of the main program stack ([Figure 6-5](ch06.xhtml#ch6fig5)).
    The last stack in [Figure 6-7](ch06.xhtml#ch6fig7) erases the log when you press
    the down arrow key. You can use this feature to cover your tracks, or to reset
    the log if it starts to get too long.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建日志文件，添加[图6-7](ch06.xhtml#ch6fig7)中所示的前两个代码块栈，将`shift`和`message`的值记录到`Initialize`块（[图6-3](ch06.xhtml#ch6fig3)）的末尾。然后，将第三个代码块栈，记录加密消息，添加到主程序栈（[图6-5](ch06.xhtml#ch6fig5)）的末尾。[图6-7](ch06.xhtml#ch6fig7)中的最后一个栈在按下向下箭头键时会清除日志。你可以利用这个功能来掩盖你的痕迹，或者在日志变得太长时重置它。
- en: '[Figure 6-8](ch06.xhtml#ch6fig8) shows what the log looks like when we decrypt
    “KHOOR!” by shifting by –3 instead of 23.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-8](ch06.xhtml#ch6fig8)展示了当我们通过-3而不是23的移位解密“KHOOR!”时，日志的样子。'
- en: '![Image](../images/pg127_Image_152.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg127_Image_152.jpg)'
- en: '*Figure 6-8: Another decryption of “HELLO!”*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-8：对“HELLO!”的另一种解密方式*'
- en: Because the `log` list resets only when you press the down arrow key, it will
    continue to store values over multiple runs of the program, even as the values
    of `shift`, `message`, and `encrypted` are overwritten.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`log`列表只有在按下向下箭头键时才会重置，它会在程序的多次运行中继续存储值，即使`shift`、`message`和`encrypted`的值被覆盖。
- en: 'Project 23: Cracking the Caesar Cipher'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目23：破解凯撒密码
- en: Caesar’s cipher was effective in its time, perhaps because most people couldn’t
    read that well anyway. But in truth, it isn’t a very secure method of encryption.
    If you have a message and you know it’s been encrypted by shifting, all you have
    to do is pass the message through every possible shift factor, and one of them
    will give you the decrypted text. The number of possible shifts is only the size
    of the alphabet—in this case, 26\. As we’ll see in this project, Scratch can work
    through all the possibilities almost instantaneously.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 凯撒密码在当时是有效的，也许因为大多数人都不太懂阅读。但实际上，这并不是一种非常安全的加密方法。如果你有一条消息，并且知道它是通过移位加密的，你只需要通过所有可能的移位因子来传递消息，其中一个将给你解密后的文本。可能的移位数目仅为字母表的大小——在这种情况下，是26。正如我们在这个项目中将看到的，Scratch几乎可以瞬间完成所有可能性的计算。
- en: To create a program for automatically decrypting messages encrypted with a Caesar
    shift, keep the supporting blocks from the previous project, but modify the main
    `when clicked` program stack as shown in [Figure 6-9](ch06.xhtml#ch6fig9). This
    updated code will produce a list applying all possible shifts to the encrypted
    message. When you scroll through the list, the appropriate shift and decoding
    should jump right out at you.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个自动解密使用凯撒移位加密的消息的程序，保留前一个项目中的支持代码块，但修改主程序的`when clicked`程序栈，如[图6-9](ch06.xhtml#ch6fig9)所示。这个更新的代码将生成一个列表，应用所有可能的移位到加密消息。当你滚动查看列表时，合适的移位和解码结果应该会立即显现。
- en: '![Image](../images/pg128_Image_153.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg128_Image_153.jpg)'
- en: '*Figure 6-9: Making all possible shifts*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-9：进行所有可能的移位*'
- en: We start with an initial `shift` of `1` ❶ and use a loop to gradually shift
    through the entire alphabet. Then, we use an inner loop to cycle through the letters
    of the message and decode them using the current shift factor. At the end of the
    inner loop, we have a possible decrypted message, which we add to the `Shifts`
    list. As in the previous project, we use an `if ... else` block to pass characters
    through unchanged if they aren’t in the alphabet ➋.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从初始的`shift`值为`1` ❶开始，使用一个循环逐步位移整个字母表。然后，使用内部循环遍历消息中的字母，并使用当前的位移因子对其进行解码。在内部循环结束时，我们得到了一个可能的解密消息，并将其添加到`Shifts`列表中。与之前的项目一样，我们使用`if
    ... else`模块，如果字母不在字母表中，就让其原封不动地通过 ➋。
- en: '![Image](../images/pg129_Image_154.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg129_Image_154.jpg)'
- en: '*Figure 6-10: Initializing the cracking program*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-10：初始化破解程序*'
- en: We also need to modify the `Initialize` block from the previous project, as
    shown in [Figure 6-10](ch06.xhtml#ch6fig10).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改前一个项目中的`Initialize`模块，如[图 6-10](ch06.xhtml#ch6fig10)所示。
- en: This updated `Initialize` block manages the `Shifts` list by deleting its previous
    contents ❶. We still prompt for a message, but we no longer have to bother with
    prompting for a shift, since the code generates all possible shifts anyway.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更新后的`Initialize`模块通过删除之前的内容来管理`Shifts`列表 ❶。我们仍然提示输入消息，但不再需要提示输入位移，因为代码会自动生成所有可能的位移。
- en: The Results
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 结果
- en: Suppose you intercept the message “UVA CLYF DLSS OPKKLU, DHZ PA?” Plug it into
    the decrypting program (you can copy-paste it or enter it by hand) to discover
    the message in [Figure 6-11](ch06.xhtml#ch6fig11).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你截获了消息“UVA CLYF DLSS OPKKLU, DHZ PA？”将其输入解密程序（你可以复制粘贴或手动输入）以发现[图 6-11](ch06.xhtml#ch6fig11)中的消息。
- en: The decrypted message is in line 19 of the `Shifts` list, which tells us that
    a shift of 19 was needed to recover the message. So the original message must
    have been encrypted with a shift of 26 – 19 = 7\. With a shift of 7, N becomes
    U, O becomes V, T becomes A (after wrapping), and so on.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 解密后的消息位于`Shifts`列表的第19行，这告诉我们需要使用19的位移来恢复消息。所以原始消息必须是使用26 – 19 = 7的位移进行加密的。使用7的位移，N变成U，O变成V，T变成A（绕回），依此类推。
- en: '![Image](../images/pg129_Image_155.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg129_Image_155.jpg)'
- en: '*Figure 6-11: Uncovering a shifted message*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-11：揭示一个位移后的信息*'
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenges'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pg26_Image_12.jpg) 编程挑战'
- en: '**6.1** Use the graphics in Scratch to design a magic decoder ring using a
    Caesar cipher. The program should animate a ring like the one in [Figure 6-1](ch06.xhtml#ch6fig1)
    so that shifted letters line up with the corresponding unshifted letters.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.1** 使用Scratch中的图形设计一个凯撒密码魔法解码戒指。该程序应像[图 6-1](ch06.xhtml#ch6fig1)中的戒指一样进行动画演示，使得位移后的字母与未位移的字母对齐。'
- en: '**6.2** In the movie *2001: A Space Odyssey*, the sentient computer HAL controlling
    a spaceship carrying two astronauts on a mission to Jupiter attempts to murder
    the crew. Apply a Caesar shift of 1 to “HAL” to see if there might be a secret
    message there about who built him.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.2** 在电影*2001太空漫游*中，感知计算机HAL控制着一艘载有两名宇航员前往木星执行任务的宇宙飞船，并试图谋杀船员。对“HAL”应用1的凯撒位移，看看是否能发现隐藏的关于谁制造了它的秘密信息。'
- en: '**6.3** A Caesar shift can translate between different languages, if you’re
    lucky! Apply a shift of 16 to “yes” to translate it into French.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.3** 如果幸运的话，凯撒位移可以在不同语言之间进行转换！对“yes”应用16的位移，将其翻译成法语。'
- en: '**6.4** Find the Caesar shift to decrypt the message “DROBO GSVV LO K RYD DSWO
    SX DRO YVN DYGX DYXSQRD!”'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.4** 找到凯撒位移解密消息“DROBO GSVV LO K RYD DSWO SX DRO YVN DYGX DYXSQRD！”'
- en: More Substitution Ciphers
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多的替换密码
- en: The Caesar cipher is an example of a *substitution cipher*, where each letter
    of the alphabet is substituted for some other letter of the alphabet. In effect,
    a substitution cipher scrambles the alphabet, making once-readable words look
    unfamiliar. With the Caesar cipher, we do the scrambling by shifting all the letters
    by a set number of positions, but any other scrambling technique would work just
    as well for encrypting a text. In fact, a nice thing about our original Caesar
    cipher program is that its main stack (the code in [Figure 6-5](ch06.xhtml#ch6fig5))
    can work with any scrambled alphabet, not just one generated through shifting.
    We can modify the `Scramble` block ([Figure 6-4](ch06.xhtml#ch6fig4)) to build
    the `scrambled` list in some other way, and the program will encode messages accordingly.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 凯撒密码是一种*替换密码*的示例，在这种密码中，字母表中的每个字母都被替换为另一个字母。实际上，替换密码通过混淆字母表，使得曾经可读的单词看起来陌生。使用凯撒密码时，我们通过将所有字母按设定的位数进行位移来进行混淆，但任何其他混淆技巧同样适用于加密文本。实际上，我们最初的凯撒密码程序的一个优点是，它的主要栈（[图6-5](ch06.xhtml#ch6fig5)中的代码）可以与任何混淆字母表一起使用，而不仅仅是通过位移生成的字母表。我们可以修改`Scramble`块（[图6-4](ch06.xhtml#ch6fig4)）以某种方式构建`scrambled`列表，程序将相应地对消息进行编码。
- en: If we don’t limit ourselves to shifts, how many possibilities for scrambling
    are there? Well, we have 26 choices for what the letter A becomes, then 25 choices
    for what B becomes, 24 choices for C, and so on. In all, that gives us 26! (26
    factorial) permutations, or over 400 septillion (4 ⋅ 10^(26)) ways to scramble
    the alphabet. The Caesar cipher considers only 25 of these permutations (assuming
    you don’t want to use a shift of 0).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不局限于位移，那么有多少种混淆的可能性呢？嗯，我们有26种选择来决定字母A变成什么，然后是25种选择来决定B变成什么，C有24种选择，依此类推。总的来说，这给我们提供了26!（26的阶乘）种排列方式，或者超过400千亿亿（4
    ⋅ 10^(26)）种混淆字母表的方式。凯撒密码仅考虑其中的25种排列方式（假设你不想使用0的位移）。
- en: The advantage of the Caesar cipher is that it takes only one number, the shift
    factor, to determine the scrambled alphabet. In other words, if you want to give
    a friend the key for decoding your shifted messages, all you have to do is whisper
    that one number to them. Encryption is essentially an addition by the shift factor,
    and decryption involves undoing the addition. You can undo a shift of *s* by subtracting
    *s* or by adding 26 – *s*. By contrast, to let your friend in on some other scrambling
    scheme (perhaps chosen randomly from the 26! possible permutations), you’d need
    to provide 25 separate pieces of information before they’d know how to decode
    your messages. You’d have to say what each letter from A to Y becomes, after which
    Z has to go in the only slot left. That’s a lot of extra information to keep track
    of!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 凯撒密码的优势在于，只需要一个数字——位移因子——就能确定混淆字母表。换句话说，如果你想给朋友提供解码你位移信息的密钥，你所需要做的就是将这个数字悄悄告诉他们。加密本质上是通过位移因子进行加法，而解密则是撤销加法。你可以通过减去*s*或加上26
    – *s*来撤销*s*的位移。相比之下，如果你想让你的朋友了解其他混淆方案（可能是从26!个可能的排列中随机选择），你需要提供25个独立的信息，才能让他们知道如何解码你的信息。你得说清楚从A到Y每个字母变成什么，之后Z必须放在剩下的唯一位置。这需要大量额外的信息来跟踪！
- en: Encryption by Modular Multiplication
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过模乘法加密
- en: Here’s a different idea. The Caesar cipher scrambles the alphabet by shifting,
    which can be thought of as addition modulo 26\. What if we scramble the alphabet
    by *multiplication* modulo 26 rather than addition? That is, we can take each
    letter’s position in the alphabet and multiply it by some number modulo 26 to
    get the position of the letter it should be replaced with. To get us started,
    [Figure 6-12](ch06.xhtml#ch6fig12) shows an operation table for mod 26 multiplication.
    (You can generate this table yourself using the code from [Project 21](ch05.xhtml#ch05lev13)
    in [Chapter 5](ch05.xhtml#ch05).)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个想法。凯撒密码通过位移来混淆字母表，这可以被认为是模26加法。假设我们通过*乘法*模26而不是加法来混淆字母表会怎样？也就是说，我们可以将每个字母在字母表中的位置与某个数字进行模26相乘，得到应该替换的字母的位置。为了让我们入门，[图6-12](ch06.xhtml#ch6fig12)展示了一个模26乘法的操作表。（你可以使用[第5章](ch05.xhtml#ch05)中[项目21](ch05.xhtml#ch05lev13)的代码自己生成此表。）
- en: '![Image](../images/pg131_Image_156.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg131_Image_156.jpg)'
- en: '*Figure 6-12: Multiplication mod 26*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-12：模26乘法*'
- en: This table gives all possible products of two numbers modulo 26\. For example,
    to multiply 9 by 5, look at row 9 and column 5\. The entry where they intersect
    is 19, so 9 ⋅ 5 is 19 mod 26\. That makes sense, since we know that 9 ⋅ 5 is “really”
    45, and 45 leaves a remainder of 19 when it’s divided by 26.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表格列出了两个数字模26的所有可能乘积。例如，要将9乘以5，可以查看第9行和第5列。它们交汇处的值是19，所以9 ⋅ 5是19 mod 26。这个结果是合理的，因为我们知道9
    ⋅ 5实际上是45，而45除以26的余数是19。
- en: For a row (or column) of this table to lead to a successful scrambling of the
    alphabet, it needs to include every number from 0 to 25—that is, it must be a
    permutation (or reordering) of the table’s index. Not every row works. For example,
    row 4 begins (0, 4, 8, . . .) and starts repeating itself at column 13\. Meanwhile,
    the values in row 13 simply alternate back and forth between 0 and 13, which would
    turn all the letters in a message into either As or Ns. Not very useful!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这张表的一行（或一列）能够成功地扰乱字母表，它需要包括从0到25的每个数字——也就是说，它必须是表格索引的一个排列（或重新排序）。并不是每一行都有效。例如，第4行的数字是（0,
    4, 8, . . .），并且在第13列开始重复。而第13行的值则在0和13之间交替，这样会将信息中的所有字母都转换成A或N。这并不太有用！
- en: 'The usable rows (and columns) are the ones indexed by numbers that are relatively
    prime to 26, meaning they share no common factors with 26 other than 1\. There
    are 12 of them: rows 1, 3, 5, 7, 9, 11, 15, 17, 19, 21, 23, and 25\. These rows
    all contain permutations of the numbers between 0 and 25\. For example, multiplying
    the letters of the alphabet by 3 mod 26 would give the following cipher:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的行（和列）是那些与26互质的行和列，也就是说，它们除了1以外与26没有其他公因数。共有12行：第1、3、5、7、9、11、15、17、19、21、23和25行。这些行包含0到25之间数字的排列。例如，字母表中的字母乘以3
    mod 26会得到以下密码：
- en: '![Image](../images/pg132_Image_157.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg132_Image_157.jpg)'
- en: You could build the scrambled row by counting ahead by three letters each time
    (A B **C**, D E **F**, G H **I**, . . .), wrapping around at Z to begin again,
    until the entire alphabet has been assigned.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过每次向前数三个字母来构建扰乱的行（A B **C**, D E **F**, G H **I**, . . .），在Z处循环重新开始，直到整个字母表都被分配完。
- en: To implement a multiplication-based cipher using our code from [Project 22](ch06.xhtml#ch06lev2),
    all we have to do is make one small change to our `Scramble` block from earlier,
    as illustrated in [Figure 6-13](ch06.xhtml#ch6fig13).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们在[项目22](ch06.xhtml#ch06lev2)中的代码实现基于乘法的密码，只需对我们之前的`Scramble`模块进行一个小小的修改，如[图6-13](ch06.xhtml#ch6fig13)所示。
- en: '![Image](../images/pg132_Image_158.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg132_Image_158.jpg)'
- en: '*Figure 6-13: Multiply, don’t add!*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-13：乘法，别加法！*'
- en: By changing `+` to `*`, we tell the program to encrypt messages using modular
    multiplication rather than modular addition.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`+`改为`*`，我们告诉程序使用模乘法而不是模加法来加密消息。
- en: Decryption by Modular Multiplication
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过模乘法解密
- en: Now let’s consider decrypting. We decrypted a Caesar shift by undoing the addition.
    To undo a shift of 3 letters to the right, for example, we shifted 3 letters to
    the left (or 26 – 3 = 23 more to the right, since the arithmetic is mod 26). To
    undo a multiplication by 3, we need to divide by 3, but there’s no room for fractions
    or decimal places in modular arithmetic. If the original modular multiplication
    by 3 gave a result of 14, we can’t turn around and divide by 3 to say we want
    letter 4.66 of the alphabet.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑解密。我们通过撤销加法来解密凯撒移位。例如，要撤销向右移动3个字母的移位，我们向左移动3个字母（或者说26 – 3 = 23，向右移动23个字母，因为算术是模26的）。要撤销乘法3的操作，我们需要除以3，但在模运算中无法处理分数或小数。如果原始的模乘法结果是14，我们不能反过来除以3，去说我们想要字母表中的字母4.66。
- en: 'Fortunately, there’s still a way to undo the multiplication. We have to find
    the modular inverse of the multiplier and use that as the decryption key. The
    *modular inverse* is the multiplicative inverse, where the multiplication is interpreted
    using modular arithmetic. Given a modulus *m*—in this case, 26—multiplying a number
    by its modular inverse yields 1 mod *m*. For example, notice in the multiplication
    table in [Figure 6-12](ch06.xhtml#ch6fig12) that there’s a 1 in row 3, located
    at column 9\. This tells us that 9 is the modular inverse of 3 mod 26\. To prove
    it, check the math: 3 ⋅ 9 = 27, and 27 mod 26 = 1.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，仍然有方法可以撤销乘法操作。我们需要找到乘数的模反元素，并将其作为解密密钥。*模反元素*是乘法逆元，其中乘法使用模运算来解释。给定模数*m*——在本例中为26——将一个数字与其模反元素相乘会得到1
    mod *m*。例如，在[图6-12](ch06.xhtml#ch6fig12)中的乘法表中，注意到在第3行第9列有一个1。这告诉我们9是3在模26下的模反元素。为了验证，检查数学：3
    ⋅ 9 = 27，而27 mod 26 = 1。
- en: If you’re used to arithmetic giving a multiplicative inverse as a fraction,
    it may seem strange to see a multiplicative inverse that’s an integer, let alone
    an integer that’s greater than the original number. Shouldn’t the multiplicative
    inverse be something small? After all, in ordinary arithmetic the multiplicative
    inverse of 3 is 1/3, since 3 ⋅ 1/3 is 1\. All that matters for an inverse, though,
    is that the product is 1\. With ordinary arithmetic, you get 1 by multiplying
    *n* by 1/*n*. With modular arithmetic, you get 1 by multiplying *n* by some other
    integer.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯于算术给出一个乘法逆元作为分数，那么看到一个乘法逆元是整数，甚至是一个大于原始数字的整数，可能会觉得很奇怪。乘法逆元不应该是小的东西吗？毕竟，在普通算术中，3的乘法逆元是1/3，因为3
    ⋅ 1/3 = 1。然而，对于逆元来说，唯一重要的是乘积为1。在普通算术中，你通过将*n*乘以1/*n*得到1。而在模算术中，你通过将*n*乘以另一个整数得到1。
- en: Since 9 is the multiplicative inverse of 3 mod 26, we can use a multiplier of
    9 to decrypt a message that was encrypted with a multiplier of 3\. The log shown
    in [Figure 6-14](ch06.xhtml#ch6fig14) confirms this.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于9是3在模26下的乘法逆元，我们可以使用9作为乘数来解密一个使用3作为乘数加密的消息。[图6-14](ch06.xhtml#ch6fig14)中的日志证实了这一点。
- en: '![Image](../images/pg133_Image_159.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg133_Image_159.jpg)'
- en: '*Figure 6-14: Uncovering a multiplied message*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-14：揭示被乘加密的消息*'
- en: First, we use a multiplier of 3 to encrypt the message “Hello!” Then, we use
    9, the modular inverse of 3 mod 26, to “encrypt” the result, which restores the
    original message.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用3作为乘数对消息“Hello!”进行加密。然后，我们使用9，它是3在模26下的模反元素，来“加密”结果，从而恢复原始消息。
- en: 'Project 24: The Modular Inverse Is the Key'
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目24：模反元素是关键
- en: We’ve established that to recover a message encrypted through modular multiplication,
    we need the modular inverse. In this project, we’ll look at how to find a modular
    inverse to aid in the decryption process.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定，要恢复通过模乘法加密的消息，我们需要模反元素。在这个项目中，我们将研究如何找到模反元素来帮助解密过程。
- en: 'One way to find a modular inverse is to just look for it: study the operation
    table for multiplication mod `alphabet size` and see what multiple of *m* gives
    the answer 1\. That multiple is the modular inverse. That’s the approach we took
    in the last section, examining the mod 26 multiplication table in [Figure 6-12](ch06.xhtml#ch6fig12)
    to determine that the modular inverse of 3 is 9\. Now let’s automate that process
    with Scratch so we can easily find the modular inverse for any number and any
    modulus. [Figure 6-15](ch06.xhtml#ch6fig15) shows how.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找模反元素的一种方法是直接寻找它：研究乘法模`字母表大小`的运算表，查看哪个*m*的倍数能得到答案1。这个倍数就是模反元素。这就是我们在上一节采取的方法，检查[图6-12](ch06.xhtml#ch6fig12)中的模26乘法表，确定3的模反元素是9。现在，让我们使用Scratch自动化这个过程，这样我们就能轻松找到任何数字和任何模数的模反元素。[图6-15](ch06.xhtml#ch6fig15)展示了如何操作。
- en: '![Image](../images/pg134_Image_160.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg134_Image_160.jpg)'
- en: '*Figure 6-15: Finding a modular inverse*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-15：寻找模反元素*'
- en: The program first prompts for a modulus and a number to invert. These two values
    must be relatively prime in order for the number to have a modular inverse. We
    test for this using the custom `gcd` block we built for [Project 9](ch02.xhtml#ch02lev14)
    back in [Chapter 2](ch02.xhtml#ch02) (see [Figure 2-17](ch02.xhtml#ch2fig17) [page
    38](ch02.xhtml#page_38)). If the GCD is `1`, the values are relatively prime,
    so we use a loop to test every possible inverse, starting from `1`, until we find
    the one where `x * inverse mod modulus = 1` ❶. This is the programmatic equivalent
    of scanning a row of the operation table until we find the column with a 1 in
    it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 程序首先提示输入模数和待求逆的数字。这两个值必须是互质的，才能使数字具有模块逆。我们通过使用在[第2章](ch02.xhtml#ch02)中的[项目9](ch02.xhtml#ch02lev14)中构建的自定义`gcd`模块来进行测试（见[图2-17](ch02.xhtml#ch2fig17)
    [第38页](ch02.xhtml#page_38)）。如果最大公约数是`1`，则这两个值是互质的，因此我们使用一个循环来测试每一个可能的逆，从`1`开始，直到找到使`x
    * inverse mod modulus = 1` ❶成立的那个逆。这相当于在操作表的一行中扫描，直到找到包含1的那一列。
- en: The Results
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 结果
- en: '[Figure 6-16](ch06.xhtml#ch6fig16) shows some output demonstrating how the
    code works.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-16](ch06.xhtml#ch6fig16)展示了一些输出，演示了代码的工作原理。'
- en: '![Image](../images/pg135_Image_161.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg135_Image_161.jpg)'
- en: '*Figure 6-16: Modular inverse calculations*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-16：模块逆计算*'
- en: The program confirms that 9 is the inverse of 3 mod 26\. It also correctly concludes
    that 4 mod 26 has no modular inverse, since 4 and 26 aren’t relatively prime.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 程序确认9是3模26的逆运算结果。它还正确地得出结论，4模26没有模块逆，因为4和26不是互质的。
- en: Hacking the Code
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 破解代码
- en: 'The trial-and-error approach in our modular inverse program isn’t bad for a
    small alphabet (and, by extension, a small modulus), but it would be better to
    have a more focused algorithm to quickly calculate the modular inverse of any
    number for any modulus. As with the `gcd` block, we can reuse part of a program
    we wrote earlier for this: the calculation of the greatest common divisor via
    Euclid’s algorithm from [Project 9](ch02.xhtml#ch02lev14) in [Chapter 2](ch02.xhtml#ch02).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在模块逆运算程序中使用的试错法，对于小字母表（也就是说小模数）来说效果不错，但如果能有一个更专注的算法来快速计算任何数在任意模数下的模块逆，就更好了。与`gcd`模块一样，我们可以重用之前编写的部分程序来实现这一目标：通过欧几里得算法计算最大公约数，该算法来源于[第2章](ch02.xhtml#ch02)中的[项目9](ch02.xhtml#ch02lev14)。
- en: Remember that Euclid’s algorithm worked to calculate the GCD *d* of two given
    numbers *b* and *a* with a sequence of divisions, ending with the GCD as the last
    nonzero remainder. To use this algorithm to find a modular inverse, set *b* to
    the modulus and *a* to the number whose inverse you want to find. Work through
    the algorithm as usual, keeping track of the arithmetic of the divisions. Then,
    step through it backward, looking for an equation that puts 1 on one side and
    both *a* and *b* on the other.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，欧几里得算法通过一系列除法来计算两个给定数字*b*和*a*的最大公约数*d*，直到最后得到最大公约数作为最后一个非零余数。要使用这个算法来查找模块逆，请将*b*设置为模数，将*a*设置为你想要找到其逆的数字。按常规方法执行算法，跟踪除法运算。然后，向后推算，寻找一个方程，使得1在一边，*a*和*b*在另一边。
- en: 'For example, if we wanted to find the modular inverse of 3 mod 26, we could
    first pass those numbers through Euclid’s algorithm:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想找到3模26的模块逆，我们可以首先将这两个数字传入欧几里得算法：
- en: '![Image](../images/pg135_Image_162.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg135_Image_162.jpg)'
- en: The last nonzero remainder, 1, is the GCD. Next, we need to unwind the steps
    to find a combination of 26 and 3 that equals 1\. Rewriting the middle equation
    in the algorithm, we get 1 = 3 – 2\. Rewriting the top equation in the algorithm,
    we get 2 = 26 – 8 ⋅ 3\. Then, substituting 26 – 8 ⋅ 3 for the 2 in the middle
    equation, we get 1 = 3 – (26 – 8 ⋅ 3). Overall, the right side of this equation
    has one 3 and then eight more 3s in the parentheses, so 1 + 8 = 9 of them in all,
    along with –1 ⋅ 26\. We can combine the pieces to see 1 = 9 ⋅ 3 – 26\. This tells
    us that 1 = 9 ⋅ 3 mod 26, so 9 is the modular inverse of 3\. There’s a programming
    challenge coming up to make this approach work in general.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的非零余数1就是最大公约数。接下来，我们需要回溯这些步骤，找到26和3的组合，使其等于1。将算法中的中间方程改写为1 = 3 – 2，再将算法中的顶部方程改写为2
    = 26 – 8 ⋅ 3。然后，将26 – 8 ⋅ 3代入中间方程中的2，得到1 = 3 – (26 – 8 ⋅ 3)。总体来看，这个方程右边有一个3和括号中8个3，所以1
    + 8 = 9个3，再加上–1 ⋅ 26。我们可以将这些部分合并，得到1 = 9 ⋅ 3 – 26。这告诉我们1 = 9 ⋅ 3 mod 26，因此9是3的模块逆。接下来会有一个编程挑战，旨在让这种方法能够普遍适用。
- en: More Encryption Options with Linear Transformations
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用线性变换的更多加密选项
- en: 'You might think we haven’t gained much by switching from modular addition to
    modular multiplication. After all, for an alphabet of size 26 there were 26 possible
    shifted alphabets, and there are only 12 possible multiplied alphabets. However,
    we can get a much bigger set of scrambled alphabets by combining both approaches:
    multiply *and* shift. That is, we can apply any of the 26 possible shifts to each
    of the 12 scrambled alphabets obtained through multiplication, giving us 26 ⋅
    12 = 312 potential alphabets. That’s many more possibilities to hide a message.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为，从模加法转为模乘法我们并没有获得太多。毕竟，对于一个26个字母的字母表，有26种可能的移位字母表，而只有12种可能的乘法字母表。然而，通过结合这两种方法：乘法*和*移位，我们可以得到更多的扰乱字母表。也就是说，我们可以将每个通过乘法获得的12个扰乱字母表应用26种可能的移位，从而得到26
    ⋅ 12 = 312种潜在的字母表。这样可以隐藏更多的信息。
- en: The general rule for this combined approach is that we scramble the alphabet
    by replacing the letter whose index is *i* with the letter whose index is *m*
    ⋅ *i* + *s*. In other words, we multiply the index by *m*, then add a constant
    *s*. If we picked values for *m* and *s* and graphed the results of this formula
    for every value of *i*, we’d find that the graph shows a straight line with a
    slope of *m*. For example, say we set *m* to 2 and *s* to 3\. If we graph the
    function 2*i* + 3, the line passes through the points (0, 3), (1, 5), (2, 7),
    (3, 9), (4, 11), (5, 13), and (6, 15), as shown in [Figure 6-17](ch06.xhtml#ch6fig17).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组合方法的一般规则是，我们通过用字母索引为*i*的字母替换字母索引为*m* ⋅ *i* + *s*的字母来扰乱字母表。换句话说，我们先将索引乘以*m*，然后加上常数*s*。如果我们为*m*和*s*选择了值，并为每个*i*值绘制这个公式的结果，我们会发现图形显示的是一条具有*m*斜率的直线。例如，假设我们将*m*设置为2，*s*设置为3。如果我们绘制函数2*i*
    + 3的图形，线条将通过(0, 3)、(1, 5)、(2, 7)、(3, 9)、(4, 11)、(5, 13)和(6, 15)这些点，如[图6-17](ch06.xhtml#ch6fig17)所示。
- en: '![Image](../images/pg136_Image_163.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg136_Image_163.jpg)'
- en: '*Figure 6-17: A graph of 2*i *+ 3*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-17：2*i* + 3的图形*'
- en: Because they produce straight lines, “multiply plus a constant” formulas like
    *m* ⋅ *i* + *s* are known as *linear functions*. By extension, a “multiply and
    shift” encryption process is called a *linear transformation*. As long as the
    multiplier *m* is chosen to be relatively prime to the alphabet size, the encryption
    will work.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它们产生直线，“乘法加常数”公式像*m* ⋅ *i* + *s*被称为*线性函数*。因此，“乘法和移位”加密过程被称为*线性变换*。只要乘数*m*被选为与字母表大小互质，这种加密方法就能奏效。
- en: 'Project 25: Encryption by a Linear Transformation'
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目25：通过线性变换进行加密
- en: Let’s adapt our Caesar cipher code from [Project 22](ch06.xhtml#ch06lev2) to
    handle linear transformations. First, we’ll update the `Initialize` block as shown
    in [Figure 6-18](ch06.xhtml#ch6fig18).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将[项目22](ch06.xhtml#ch06lev2)中的凯撒密码代码改编为处理线性变换。首先，我们将更新`Initialize`模块，如[图6-18](ch06.xhtml#ch6fig18)所示。
- en: '![Image](../images/pg137_Image_164.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg137_Image_164.jpg)'
- en: '*Figure 6-18: Linear transformation encryption*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-18：线性变换加密*'
- en: We now prompt for both a shift and a multiplier, instead of just a shift like
    before. Notice also the extra code to maintain the `log` list. Next, we’ll modify
    the `Scramble` block to match [Figure 6-19](ch06.xhtml#ch6fig19).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们同时提示输入移位值和乘数，而不再仅仅是之前的移位值。还要注意新增的代码，用来维护`log`列表。接下来，我们将修改`Scramble`模块，以匹配[图6-19](ch06.xhtml#ch6fig19)。
- en: '![Image](../images/pg138_Image_165.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg138_Image_165.jpg)'
- en: '*Figure 6-19: Wrapping with a linear transformation*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-19：使用线性变换进行封装*'
- en: This updated `Scramble` block still uses the original `Wrap` block from [Figure
    6-4](ch06.xhtml#ch6fig4). The input to `Wrap` implements the *m* ⋅ *i* + *s* linear
    function to scramble the alphabet.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更新后的`Scramble`模块仍然使用[图6-4](ch06.xhtml#ch6fig4)中的原始`Wrap`模块。`Wrap`的输入实现了*m*
    ⋅ *i* + *s*的线性函数来扰乱字母表。
- en: The Results
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 结果
- en: '[Figure 6-20](ch06.xhtml#ch6fig20) shows an example of the linear transformation
    program in action. It encrypts the message “TOP SECRET!” using a multiplier of
    3 and a shift of 5.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-20](ch06.xhtml#ch6fig20)展示了线性变换程序在实际应用中的例子。它使用乘数3和移位5加密了消息“TOP SECRET！”'
- en: '![Image](../images/pg138_Image_166.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg138_Image_166.jpg)'
- en: '*Figure 6-20: Encrypting with a linear transformation*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-20：使用线性变换加密*'
- en: 'To decrypt the resulting message, we need to undo both the shift and the multiplication.
    Undoing the shift is easy: for an original shift of *s*, we instead perform a
    shift of –*s*. And as we’ve discussed, to undo a multiplication by *m*, we can
    multiply by the modular inverse of *m*. We’ll perform these operations separately,
    by running the encrypted message through the linear transformation program twice:
    once for the shift and once for the multiplication.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解密得到的消息，我们需要撤销移位和乘法。撤销移位很简单：对于原始移位*s*，我们执行移位–*s*。正如我们所讨论的，要撤销乘法*m*，我们可以乘以*m*的模块逆。我们将通过运行加密消息两次，分别执行撤销移位和撤销乘法。
- en: First, we undo the shift of 5 with a shift of –5, as shown in [Figure 6-21](ch06.xhtml#ch6fig21).
    We use a multiplier of 1, meaning we’re effectively doing no multiplication at
    all.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过移位–5撤销移位5，正如[图6-21](ch06.xhtml#ch6fig21)所示。我们使用乘数1，这意味着我们实际上并未进行任何乘法。
- en: '![Image](../images/pg138_Image_167.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg138_Image_167.jpg)'
- en: '*Figure 6-21: Undoing the shift*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-21：撤销移位*'
- en: Next, we need to take the result and feed it back into the linear transformation
    program to undo the multiplication. We know that the modular inverse of 3 mod
    26 is 9, so that’s the multiplier we use in [Figure 6-22](ch06.xhtml#ch6fig22).
    This time, we use a shift of 0 to focus just on reversing the multiplication.
    The result is the original message.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将结果反馈到线性变换程序中，撤销乘法。我们知道，3 mod 26的模块逆是9，所以在[图6-22](ch06.xhtml#ch6fig22)中我们使用的乘数就是9。这一次，我们使用移位0，仅关注撤销乘法。结果就是原始消息。
- en: '![Image](../images/pg139_Image_168.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg139_Image_168.jpg)'
- en: '*Figure 6-22: Undoing the multiplication*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-22：撤销乘法*'
- en: 'In all, only two numbers determine an encryption by linear transformation:
    the shift and the multiplier. Likewise, only two numbers are needed to decrypt
    the message. It’s a pretty compact secret key!'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，只有两个数字决定了线性变换加密：移位和乘数。同样，解密消息也只需要这两个数字。它是一个非常紧凑的密钥！
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenges'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pg26_Image_12.jpg) 编程挑战'
- en: '**6.5** You’ve seen how to decrypt a linear transformation cipher in two separate
    steps, first undoing the shift and then undoing the multiplication. Is it possible
    to combine these into a single step? For example, could you decrypt the message
    MXA JTNGTM!” from [Figure 6-20](ch06.xhtml#ch6fig20) by running the linear transformation
    program once, with a shift of –5 and a multiplier of 9? As it turns out, this
    won’t work, but there’s a different shift factor that will. Think about what it
    could be, and why.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.5** 你已经看到如何通过两个步骤解密线性变换密码，首先撤销移位，然后撤销乘法。是否可以将这两个步骤合并成一个步骤呢？例如，能否通过运行一次线性变换程序来解密消息“MXA
    JTNGTM！”？假设移位为–5，乘数为9。从[图6-20](ch06.xhtml#ch6fig20)来看，实际情况是这样做行不通，但有一个不同的移位因子可以奏效。想一想它可能是什么，以及为什么。'
- en: '**6.6** Use what you’ve learned from Challenge 6.5 to write a Scratch program
    that takes in a multiplier and shift for a linear transformation encryption and
    calculates the modular inverse and appropriate shift to perform the decryption
    in one step.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.6** 利用你从挑战6.5中学到的知识，编写一个Scratch程序，输入线性变换加密的乘数和移位，并计算出模块逆和适当的移位，以便一步完成解密。'
- en: '**6.7** What goes wrong in a linear transformation encryption if the multiplier
    isn’t relatively prime to the alphabet size?'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.7** 如果乘数与字母表大小不是互质的，线性变换加密会出什么问题？'
- en: '**6.8** Modify the [Project 23](ch06.xhtml#ch06lev5) code for cracking a Caesar
    shift ([Figure 6-9](ch06.xhtml#ch6fig9)) so the program lists all possible decryptions
    for all 312 possible linear transformation ciphers.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.8** 修改[项目23](ch06.xhtml#ch06lev5)的代码，用于破解凯撒移位密码（[图6-9](ch06.xhtml#ch6fig9)），使得程序列出所有312种可能的线性变换密码的所有解密结果。'
- en: '**6.9** Any permutation or scrambling of the alphabet can be the key for a
    substitution cipher. Write a Scratch program that will generate a random scrambling
    of the alphabet. The `pick random` operator block might come in handy for this.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.9** 任何字母表的排列或打乱都可以作为替换密码的密钥。编写一个Scratch程序，生成字母表的随机打乱。`pick random`操作块可能会在这方面派上用场。'
- en: '**6.10** Write a program to calculate modular inverses using Euclid’s algorithm,
    as discussed in “Hacking the Code” on [page 115](ch06.xhtml#ch06lev12). You’ll
    probably want to keep track of quotients and remainders as lists and work your
    way backward up the lists to unwind the steps.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.10** 编写一个程序，使用欧几里得算法计算模逆，如《破解代码》一书中[第115页](ch06.xhtml#ch06lev12)所讨论的。你可能需要将商和余数记录为列表，并通过反向追溯列表中的步骤来解开过程。'
- en: Unbreakable One-Time Pad Ciphers
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不可破解的一次性密钥密码
- en: A *one-time pad cipher* is a technique that uses one text (the key) to encrypt
    or decrypt another text (the message). The encryption takes the first character
    of the message and shifts it by the position of the first character in the key.
    It then shifts the second character by the position of the second character in
    the key, and so on. Every character in the message uses its own encryption scheme,
    with the alphabet essentially being rescrambled for each letter.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*一次性密钥密码* 是一种技术，使用一种文本（密钥）来加密或解密另一种文本（信息）。加密过程将信息的第一个字符按密钥第一个字符的位置进行位移。然后将第二个字符按密钥第二个字符的位置进行位移，依此类推。信息中的每个字符都有自己的加密方案，字母表基本上为每个字母进行重新排列。'
- en: To illustrate, let’s say we want to encrypt the message “Hello” using the word
    “Scratch” as a key. (The key should always be at least as long as, if not longer
    than, the message.) The first letter of the key, S, is the 19th letter of the
    alphabet, so we should shift the first letter in the message, H, by 19 positions,
    yielding the letter A (after wrapping around at Z). The second letter of the key,
    C, is the third letter of the alphabet, so we should shift the second letter of
    the message, E, by 3 positions, yielding the letter H. If we keep going like this,
    we’ll end up with “AHDMI” as the coded message. Using the key to do the shifts
    in reverse decrypts the message.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设我们想要使用“Scratch”这个词作为密钥来加密消息“Hello”。（密钥的长度应该至少与消息长度相同，最好更长。）密钥的第一个字母S是字母表中的第19个字母，因此我们需要将消息中的第一个字母H按19个位置进行位移，得到字母A（在Z处换行）。密钥的第二个字母C是字母表中的第3个字母，因此我们需要将消息中的第二个字母E按3个位置进行位移，得到字母H。如果我们继续这样做，最终加密得到的消息是“AHDMI”。使用密钥逆向进行位移即可解密消息。
- en: Typically, one-time pads are used to share longer coded messages, using correspondingly
    longer keys. The key might be a literal notepad, with a long handwritten sequence
    of random letters determining the shifts to be used. Or it could be any other
    text that the sender and recipient of the message agree to share, such as the
    lyrics of a song, a passage in a book, or an article posted on the internet. The
    important thing is to keep the key a secret.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一次性密钥用于共享较长的编码信息，使用相应更长的密钥。密钥可能是一个字面意义上的记事本，里面有一长串随机字母手写序列，用来确定需要使用的位移。或者它也可以是发送方和接收方商定共享的任何其他文本，比如歌曲的歌词、书中的一段话，或是互联网上发布的文章。关键是要保持密钥的保密性。
- en: One-time pads are much stronger codes than the simpler ciphers we discussed
    earlier in the chapter. In fact, if you use a truly random sequence of characters
    for the key and you never use the same key twice (hence *one-time* pad), your
    coded messages will be impossible to crack. The same cannot be said about any
    secret code based on a fixed permutation of the alphabet, whether it’s a Caesar
    cipher, a linear transformation, or any other scrambling algorithm. This is because,
    as mentioned earlier, the English language has patterns and regularities in it
    that provide clues about the message.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一次性密钥比我们在本章早些时候讨论的简单密码更强大。事实上，如果你使用一个真正随机的字符序列作为密钥，并且永远不重复使用相同的密钥（因此是*一次性*密钥），你的编码消息将是无法破解的。对于任何基于字母表固定排列的秘密代码，这一点无法成立，无论是凯撒密码、线性变换，还是其他任何混排算法。这是因为，正如前面所提到的，英语语言中存在一些模式和规律，提供了破解消息的线索。
- en: 'Even if we remove the spaces between words to conceal obvious giveaways like
    one-letter words (almost certain *I* or *a*) and recurring three-letter words
    (quite possibly *the* or *and*), there are other patterns that can shine through
    in a scrambled alphabet. For example, only certain letters commonly appear twice
    in a row in English: there are plenty of words with double Es, Ss, and Ts, far
    fewer with double As or double Zs, and virtually none with double Qs or double
    Js. Two-letter sequences like TH and CK are also common.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们移除单词之间的空格，以掩盖像单字词（几乎确定是*I*或*a*）和常见的三字词（很可能是*the*或*and*）等明显的线索，仍然会有其他模式在混淆的字母表中显现出来。例如，只有某些字母在英语中常常连续出现两次：有很多双重E、S和T的单词，但双重A或双重Z的单词就少得多，几乎没有双重Q或双重J的单词。像TH和CK这样的双字母组合也很常见。
- en: More broadly, letters like E and A occur much more often in a given English
    text than letters like Q and Z, so counting the *frequency*, meaning the number
    of occurrences, of each letter in an encrypted message—especially a long message—can
    give a good clue about the encryption scheme. To prove it, we’ll write a program
    to calculate letter frequencies and test it on a text encrypted with a Caesar
    shift. Then we’ll write a program to implement a one-time pad cipher and test
    its result as well. We should see that the one-time pad cipher eliminates any
    regular patterns.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 更广泛地说，像E和A这样的字母在给定的英文文本中出现的频率远高于Q和Z，因此统计加密消息中每个字母的*频率*——即每个字母出现的次数——尤其是在长消息中，能够提供有关加密方案的有力线索。为了验证这一点，我们将编写一个程序来计算字母的频率，并用一个使用凯撒移位加密的文本进行测试。然后，我们将编写一个程序来实现一次性密码本加密，并测试其结果。我们应该会看到一次性密码本加密消除了任何规律性的模式。
- en: 'Project 26: Frequency Analysis for Cracking Codes'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目26：破解密码的频率分析
- en: The goal for this project is to create a program that counts how many times
    each letter is used in an encrypted message, potentially providing clues about
    the encryption scheme based on how many times different letters are used in a
    typical unencrypted English text. We’ll need to take advantage of Scratch’s text
    processing capabilities for this. In particular, we’ll use the green `length of`
    and `letter of` blocks together in a loop to examine a text one character at a
    time. [Figure 6-23](ch06.xhtml#ch6fig23) shows the program.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的目标是创建一个程序，用于统计加密消息中每个字母的出现次数，这可能会根据不同字母在典型的未加密英文文本中的使用频率，提供关于加密方案的线索。我们将需要利用Scratch的文本处理能力来实现这一目标。特别是，我们将结合使用绿色的`length
    of`和`letter of`积木，在循环中逐个字符地检查文本。[图6-23](ch06.xhtml#ch6fig23)展示了该程序。
- en: '![Image](../images/pg141_Image_169.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg141_Image_169.jpg)'
- en: '*Figure 6-23: Counting how many times each letter is used*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-23：统计每个字母的使用次数*'
- en: 'We use two separate lists: `alphabet`, which is built up at the start of the
    program with the same `Alphabet` block first defined in [Figure 6-2](ch06.xhtml#ch6fig2),
    and `frequency`, where we store the number of occurrences of each letter of the
    alphabet. To begin, we fill `frequency` with 26 0s. Then we take in a text to
    process from the user and loop through it one character at a time. The `item #
    of letter i of text in alphabet` does a reverse lookup of the *i*th character
    of the text in `alphabet`. For example, if the character is C, this will give
    us `3`, C’s position in the `alphabet` list. We add `1` to the entry at the same
    position in the `frequency` list to count that character ❶.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '我们使用两个独立的列表：`alphabet`，它在程序开始时由[图6-2](ch06.xhtml#ch6fig2)中首次定义的`Alphabet`积木构建；以及`frequency`，我们将每个字母在字母表中出现的次数存储在此列表中。首先，我们将`frequency`填充为26个0。然后，我们从用户处获取要处理的文本，并逐个字符地循环遍历它。`item
    # of letter i of text in alphabet`会反向查找文本中第*i*个字符在`alphabet`中的位置。例如，如果字符是C，它会返回`3`，即C在`alphabet`列表中的位置。我们将在`frequency`列表中相应位置上加1，以统计该字符的出现次数❶。'
- en: Hacking the Code
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 破解代码
- en: The code in [Figure 6-24](ch06.xhtml#ch6fig24) is a nice little addition to
    the program that adds labels to the `frequency` list. Place it at the end, after
    the `repeat` loop.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-24](ch06.xhtml#ch6fig24)中的代码是对程序的一个小改进，添加了标签到`frequency`列表中。将其放在`repeat`循环之后。'
- en: '![Image](../images/pg142_Image_170.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg142_Image_170.jpg)'
- en: '*Figure 6-24: Adding a label to each entry in the* frequency *list*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-24：为频率列表中的每一项添加标签*'
- en: After all the counting is done, this extra code labels each entry in the `frequency`
    list with the letter of the alphabet it represents. This way, you won’t have to
    remind yourself that letter A is 1, letter B is 2, and so on.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有计数后，这段额外的代码会为`frequency`列表中的每一项标注它所代表的字母。这样，你就不需要时刻提醒自己字母A是1，字母B是2，依此类推。
- en: The Results
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 结果
- en: Let’s put the frequency analysis program to work. We’ll start with a reasonably
    sized unencrypted text, the first chapter of *Alice’s Adventures in Wonderland*,
    to get a feel for the normal frequencies of letters in ordinary English. You don’t
    have to type the whole text out yourself; just look it up online and copy-paste
    it when Scratch Cat asks for your input. [Figure 6-25](ch06.xhtml#ch6fig25) shows
    the results.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动频率分析程序。我们将从一段合理大小的未加密文本开始，选取*《爱丽丝梦游仙境》*的第一章，来感受普通英文文本中字母的正常频率。你不需要自己输入完整的文本，只需在线查找并在Scratch
    Cat要求输入时复制粘贴即可。[图 6-25](ch06.xhtml#ch6fig25)显示了结果。
- en: '![Image](../images/pg143_Image_171.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg143_Image_171.jpg)'
- en: '*Figure 6-25: Analyzing character frequencies in an unencrypted text (down
    the rabbit hole . . .)*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-25：分析未加密文本中的字符频率（掉进兔子洞……）*'
- en: As you can see, the text contains lots of Es and As, but only one J. If you
    scroll to the bottom of the list, you’ll find there’s one Q and no Xs or Zs. This
    is a pretty typical distribution of letters for an English-language text.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，文本中包含了大量的E和A字母，但只有一个J。如果你向下滚动到列表的底部，你会发现有一个Q，但没有Xs或Zs。这是英文文本中字母分布的典型特征。
- en: Now try using our original Caesar cipher program from [Project 22](ch06.xhtml#ch06lev2)
    to encrypt the same *Alice’s Adventures in Wonderland* chapter, shifting the alphabet
    by three places. Plug the encrypted text into the frequency analysis program.
    [Figure 6-26](ch06.xhtml#ch6fig26) shows the result.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用我们原始的凯撒密码程序，来自[项目 22](ch06.xhtml#ch06lev2)，对同一章节的*《爱丽丝梦游仙境》*进行加密，字母表偏移三个位置。将加密后的文本输入到频率分析程序中。[图
    6-26](ch06.xhtml#ch6fig26)显示了结果。
- en: '![Image](../images/pg143_Image_172.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg143_Image_172.jpg)'
- en: '*Figure 6-26: Analyzing character frequencies in a shifted text*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-26：分析偏移后文本中的字符频率*'
- en: 'I can’t read the encrypted message, but I do notice that the word *DQG* appears
    lots of times, which is a clue. More importantly, there’s still a strong pattern
    in the frequencies of letters that suggests how the most common letters have been
    encoded. Of course, the pattern matches the original message perfectly, shifted
    three places: you can see the original frequency for A showing up at D, the original
    frequency for E showing up at H, and so on. The zeros at A and C are from X and
    Z wrapped around. Looking at this output, even if I didn’t know what the original
    text was, I could make a good guess as to which letter is E.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我无法读取加密后的消息，但我注意到单词*DQG*出现了很多次，这是一个线索。更重要的是，字母的频率仍然有很强的模式，这表明最常见的字母是如何被编码的。当然，这个模式与原始消息完全匹配，只是偏移了三个位置：你可以看到字母A的原始频率出现在D的位置，字母E的原始频率出现在H的位置，依此类推。A和C处的零来自于X和Z的回绕。从这个输出中，即使我不知道原文是什么，我也能大致猜出哪个字母是E。
- en: In theory, a one-time pad cipher should eliminate these patterns, causing every
    letter in the encrypted text to appear with roughly the same frequency. We’ll
    find out in the next project.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，一次性密钥密码应该消除这些模式，使得加密文本中每个字母的出现频率大致相同。我们将在下一个项目中验证这一点。
- en: 'Project 27: Encryption with a One-Time Pad'
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目 27：一次性密钥加密
- en: We can program a one-time pad encryption in Scratch by making just a few changes
    to the encryption programs we’ve written so far. [Figure 6-27](ch06.xhtml#ch6fig27)
    shows the `Initialize` block.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过对我们至今写的加密程序做一些小修改，在Scratch中编写一次性密钥加密。[图 6-27](ch06.xhtml#ch6fig27)显示了`Initialize`模块。
- en: '![Image](../images/pg144_Image_173.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg144_Image_173.jpg)'
- en: '*Figure 6-27: Setup code for the one-time pad*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-27：一次性密钥的设置代码*'
- en: This block asks for the encoding key and the message. It also asks if the user
    wants to encrypt or decrypt ❶, so we can use the same program for both operations.
    Depending on the answer, the variable `action` is assigned a value of `1` or `-1`.
    This value is incorporated into the arithmetic of the shift, such that encryption
    involves adding the shift and decryption involves subtracting it.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块要求输入编码密钥和消息。它还询问用户是否要进行加密或解密 ❶，这样我们就可以使用相同的程序进行这两种操作。根据回答，变量`action`会被赋值为`1`或`-1`。这个值被用在移位的运算中，导致加密时添加移位，而解密时则是减去移位。
- en: Notice that the `Initialize` block sets up a log so we can scroll through a
    history of the program’s use. It also calls a custom `Trim key` block, which is
    defined in [Figure 6-28](ch06.xhtml#ch6fig28).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Initialize`块设置了一个日志，以便我们可以滚动查看程序使用的历史记录。它还调用了一个自定义的`Trim key`块，该块在[图6-28](ch06.xhtml#ch6fig28)中定义。
- en: '![Image](../images/pg145_Image_174.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg145_Image_174.jpg)'
- en: '*Figure 6-28: Trimming the key*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-28：修剪密钥*'
- en: In the `Trim key` block, we take the text that will be used to encrypt the message
    and remove any characters (like spaces or punctuation) that aren’t in the alphabet.
    The variable `trimmed_key` starts out empty. Then, the `repeat` loop steps through
    the key character by character; it ignores characters that aren’t in the `alphabet`
    list and puts the rest of the characters into `trimmed_key`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Trim key`块中，我们将用于加密消息的文本，并去除任何不在字母表中的字符（如空格或标点符号）。变量`trimmed_key`最初为空。然后，`repeat`循环逐个字符地遍历密钥；它忽略不在`alphabet`列表中的字符，并将其余字符放入`trimmed_key`中。
- en: '[Figure 6-29](ch06.xhtml#ch6fig29) shows the main program code.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-29](ch06.xhtml#ch6fig29)显示了主程序代码。'
- en: '![Image](../images/pg146_Image_175.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg146_Image_175.jpg)'
- en: '*Figure 6-29: The main code for one-time pad encryption (and decryption)*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-29：一次性密码本加密（和解密）的主要代码*'
- en: 'In this stack, we move character by character through the message (using index
    `i`) and the trimmed key (using index `j`), determining the shift for the current
    character in the message based on the current character in the key. We use an
    `if` statement ❶ to wrap back around to the start of the trimmed key if there
    are more characters in the message than in the key. As I mentioned earlier in
    the chapter, though, it’s best to use a key that’s at least as long as the message.
    A shorter key is a vulnerability: if the key starts to repeat, frequency analysis
    can reveal information about the key length and encoding phrase. A one-character
    key, for example, is equivalent to a Caesar shift!'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个堆栈中，我们通过消息中的每个字符（使用索引`i`）和修剪后的密钥（使用索引`j`）逐个字符地移动，根据密钥中的当前字符确定消息中当前字符的位移。我们使用`if`语句❶，当消息中的字符比密钥中的字符多时，会将指针回绕到修剪后的密钥的开头。如我在本章早些时候提到的，最好使用一个至少和消息一样长的密钥。较短的密钥是一个漏洞：如果密钥开始重复，频率分析就能揭示关于密钥长度和编码短语的信息。例如，一个单字符的密钥，相当于凯撒移位！
- en: The real work is done in the `set` block ➋. It builds the encrypted message
    one character at a time by shifting the original character by an amount determined
    by the corresponding character in the key. We use the original `Wrap` block from
    [Figure 6-4](ch06.xhtml#ch6fig4) to get the index for the appropriate letter.
    Notice also that we multiply by `action` (either `1` or `-1`) when setting the
    value of `shift`. As mentioned previously, this allows the program to work for
    encryption and decryption by shifting either forward or backward.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的工作是在`set`块中完成的➋。它通过将原始字符按密钥中相应字符确定的偏移量逐个字符地加密消息。我们使用[图6-4](ch06.xhtml#ch6fig4)中的原始`Wrap`块来获取适当字母的索引。还要注意，在设置`shift`值时，我们乘以`action`（即`1`或`-1`）。如前所述，这允许程序通过向前或向后移动来进行加密和解密。
- en: The Results
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 结果
- en: To see how secure one-time pad encryption is compared to simple alphabet scramblings
    like the Caesar cipher, let’s use our program to encrypt the same *Alice’s Adventures
    in Wonderland* chapter as before. For that, we need to choose a key. I’ll use
    the nonsense poem “Jabberwocky,” shown in [Figure 6-30](ch06.xhtml#ch6fig30),
    to keep in the Lewis Carroll spirit.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到一次性密码本加密相对于简单字母表乱序（如凯撒密码）的安全性，我们将使用我们的程序加密与之前相同的*《爱丽丝梦游仙境》*章节。为此，我们需要选择一个密钥。我将使用“贾布沃基”这首无意义的诗歌，如[图6-30](ch06.xhtml#ch6fig30)所示，以保持刘易斯·卡罗尔的风格。
- en: '![Image](../images/pg147_Image_176.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg147_Image_176.jpg)'
- en: '*Figure 6-30: The one-time pad key*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-30：一次性密码本密钥*'
- en: Encode the *Alice* chapter using the one-time pad program in encryption mode,
    find the encrypted text in the log, and copy-paste it into the frequency analysis
    program from the previous project. The result should look something like [Figure
    6-31](ch06.xhtml#ch6fig31).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一次性密码本程序在加密模式下编码*《爱丽丝》*章节，在日志中找到加密后的文本，并将其复制粘贴到上一个项目中的频率分析程序中。结果应该类似于[图6-31](ch06.xhtml#ch6fig31)。
- en: '![Image](../images/pg147_Image_177.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg147_Image_177.jpg)'
- en: '*Figure 6-31: Analyzing character frequencies in text encrypted with a one-time
    pad*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-31：分析用一次性密码本加密的文本中的字符频率*'
- en: 'As you can see, the distribution of letters is now much flatter: no one letter
    stands out as being used much more (or less) frequently than the others, so frequency
    analysis doesn’t provide any clues for cracking the code. What’s more, the one-time
    pad has also eliminated regular patterns from the encrypted text itself. Whereas
    the Caesar-shifted version ([Figure 6-26](ch06.xhtml#ch6fig26)) showed *DQG* at
    every instance of the word *and*, now each occurrence of *and* is encoded differently:
    first *ZKI*, then *JFH*, and so on. Without the key, decrypting the text seems
    like an impossible task; there are no clues to help you. And just imagine if spaces
    and punctuation were included in the alphabet and scrambled along with the letters—the
    encoded message would look like letter soup!'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，字母分布现在更平坦了：没有任何字母在使用频率上显著高（或低）于其他字母，因此频率分析无法提供破解密码的线索。而且，一次性密码本还消除了加密文本中的常规模式。与凯撒加密版本（[图
    6-26](ch06.xhtml#ch6fig26)）中每次出现的 *DQG*（表示 *and*）不同，现在每个 *and* 的编码方式都不一样：首先是 *ZKI*，然后是
    *JFH*，依此类推。没有密钥，解密这段文本似乎是不可能的任务；没有任何线索可以帮助你。而且，想象一下，如果空格和标点符号也被包括在字母表中并与字母一起打乱——加密后的消息看起来就像字母汤一样！
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenges'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pg26_Image_12.jpg) 编程挑战'
- en: '**6.11** A *cryptogram* is a word puzzle based on a scrambled alphabet, not
    necessarily a Caesar shift or a linear transformation. Write a Scratch program
    to help solve cryptograms by keeping track of letters as they’re guessed and showing
    progress with a partial decryption. Here’s an example of a cryptogram for you
    to solve. As a clue to help you get started, this cryptogram uses M to stand for
    S. You can look at patterns and letter frequencies to guess the other letters.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.11** *密码谜题*是基于字母表乱序的文字谜题，不一定是凯撒加密或线性变换。编写一个 Scratch 程序，通过跟踪已猜字母并显示部分解密进度，帮助解决密码谜题。这里有一个密码谜题供你解答。作为提示，帮助你入手，这个密码谜题使用
    M 代表 S。你可以通过观察模式和字母频率来猜测其他字母。'
- en: '![Image](../images/pg148_Image_178.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg148_Image_178.jpg)'
- en: '**6.12** Write a Scratch program to remove spaces and punctuation from a text
    string so all that’s left is a string of letters and numbers. This could be useful
    to remove word-break clues from an encrypted message.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.12** 编写一个 Scratch 程序，去除文本字符串中的空格和标点符号，只留下字母和数字的字符串。这对去除加密信息中的词语分隔线索可能很有用。'
- en: Conclusion
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: Scratch isn’t just for processing numbers; it’s just as good at processing text.
    Any transformation rule that’s reversible can be the basis of an encryption algorithm
    for sharing secrets, but some rules (like using a one-time pad) are better than
    others (like basic shifts) for keeping secrets safe. You can always use techniques
    like frequency analysis to look for clues about how to decode a message.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Scratch 不仅仅用于处理数字；它同样擅长处理文本。任何可逆的变换规则都可以成为加密算法的基础，用来共享秘密，但某些规则（比如使用一次性密码本）比其他规则（如简单的位移）更适合保护秘密的安全。你始终可以使用频率分析等技术来寻找解密消息的线索。
