- en: '**12**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**12**'
- en: '**ATTACKING WIRELESS SYSTEMS WITH SDR**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**攻击无线系统与SDR**'
- en: '![image](graphics/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/common-01.jpg)'
- en: In this chapter, we’ll delve into embedded wireless systems, beginning with
    embedded systems that transmit simple wireless signals to the ECU. Embedded wireless
    systems can be easy targets. They often rely on short-range signals as their only
    security, and because they’re small devices with specific functionalities, there
    are typically no checks from the ECU to validate the data outside of the signal
    and the CRC algorithm. Such systems are usually good stepping stones for learning
    before looking at more advanced systems, such as those with keyless entry, which
    we’ll look at hacking in the latter part of the chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨嵌入式无线系统，首先从向ECU传输简单无线信号的嵌入式系统开始。嵌入式无线系统往往是容易被攻击的目标。它们通常仅依赖短程信号作为唯一的安全防护措施，且由于这些设备体积小巧，功能单一，通常ECU没有检查信号外的任何数据，仅通过信号和CRC算法进行验证。这类系统通常是学习的好起点，尤其是在学习更先进的系统之前，例如无钥匙进入系统，我们将在本章后半部分研究如何破解这类系统。
- en: We’ll look at the technology that unlocks and starts your vehicle as we explore
    both the wireless side of keyless entry systems and the encryption they use. In
    particular, we’ll focus on the TPMS and wireless key systems. We’ll consider possible
    hacks, including ways that the TPMS could be used to track a vehicle, trigger
    events, overload the ECU, or spoof the ECU to cause unusual behavior.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨解锁和启动车辆的技术，同时了解无钥匙进入系统的无线部分以及它们使用的加密技术。特别地，我们将重点关注TPMS和无线钥匙系统。我们会考虑可能的黑客攻击，包括TPMS如何被用来追踪车辆、触发事件、超载ECU或欺骗ECU以导致异常行为。
- en: '**Wireless Systems and SDR**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**无线系统与SDR**'
- en: First, a quick primer on sending and receiving wireless signals. To perform
    the type of research discussed in this chapter, you’ll need an SDR, a programmable
    radio that sells anywhere from $20, for example, RTL-SDR (*[http://www.rtl-sdr.com/](http://www.rtl-sdr.com/)*),
    to over $2,000, for example, a Universal Software Radio Peripheral (USRP) device
    from Ettus Research (*[http://www.ettus.com/](http://www.ettus.com/)*). The HackRF
    One is a good and very serviceable option from Great Scott Gadgets that will cost
    you about $300, but you’ll most likely want two so you can send and receive at
    the same time.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，简要介绍一下发送和接收无线信号的基础知识。为了进行本章讨论的研究，你需要一个SDR，这是一个可编程无线电设备，价格从约20美元的RTL-SDR（*[http://www.rtl-sdr.com/](http://www.rtl-sdr.com/)*）到超过2,000美元的USRP设备（来自Ettus
    Research，* [http://www.ettus.com/](http://www.ettus.com/)*）。HackRF One是Great Scott
    Gadgets推出的一个非常实用的选项，价格大约为300美元，但你很可能需要两个，以便能够同时进行发送和接收。
- en: One significant difference between SDR devices that has a direct effect on cost
    is the *sample rate*, or the number of samples of audio carried per second. Unsurprisingly,
    the larger your sample rate, the more bandwidth you can simultaneously watch—but
    also the more expensive the SDR and the faster the processor needs to be. For
    instance, the RTL-SDR maxes out at around 3Mbps, the HackRF at 20Mbps, and the
    USRP at 100Mbps. As a point of reference, 20Mbps will let you sample the entire
    FM spectrum simultaneously. SDR devices work well with the free GNU Radio Companion
    (GRC) from GNURadio (*[https://gnuradio.org/](https://gnuradio.org/)*), which
    you can use to view, filter, and demodulate encoded signals. You can use GNU Radio
    to filter out desired signals, identify the type of modulation being used (see
    the next section), and apply the right demodulator to identify the bitstream.
    GNU Radio can help you go from wireless signals directly to data you can recognize
    and manipulate.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: SDR设备之间一个直接影响成本的重要区别是*采样率*，即每秒传输的音频样本数量。不出所料，采样率越大，你能够同时观察到的带宽就越大——但SDR设备也就越贵，且处理器需要更快。例如，RTL-SDR的最大传输速率约为3Mbps，HackRF为20Mbps，USRP为100Mbps。作为参考，20Mbps可以让你同时采样整个FM频谱。SDR设备与GNU
    Radio Companion (GRC)配合得很好，GNU Radio是来自GNURadio的免费工具（*[https://gnuradio.org/](https://gnuradio.org/)*），你可以用它来查看、过滤和解调编码信号。你可以使用GNU
    Radio来过滤出所需的信号，识别所使用的调制类型（见下节），并应用正确的解调器来识别比特流。GNU Radio可以帮助你从无线信号直接获取你能识别和处理的数据。
- en: '**NOTE**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*See the Great Scott Gadgets tutorials at* [http://greatscottgadgets.com/sdr/](http://greatscottgadgets.com/sdr/)
    *for more on how to use SDR devices with GNU Radio.*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*欲了解如何将SDR设备与GNU Radio结合使用，请参阅Great Scott Gadgets的教程，访问* [http://greatscottgadgets.com/sdr/](http://greatscottgadgets.com/sdr/)
    *。*'
- en: '***Signal Modulation***'
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***信号调制***'
- en: 'To apply the right demodulator, you first need to be able to identify the type
    of modulation a signal is using. Signal modulation is the way you represent binary
    data using a wireless signal, and it comes into play when you need to be able
    to tell the difference between a digital 1 and a digital 0\. There are two common
    types of digital signal modulation: amplitude-shift keying (ASK) and frequency-shift
    keying (FSK).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用正确的解调器，首先需要能够识别信号使用的调制类型。信号调制是将二进制数据通过无线信号表示的方式，它在你需要区分数字1和数字0时发挥作用。常见的两种数字信号调制方式是幅度键控（ASK）和频移键控（FSK）。
- en: '**Amplitude-Shift Keying**'
  id: totrans-12
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**幅度键控（ASK）**'
- en: When ASK modulation is used, the bits are designated by the amplitude of the
    signal. [Figure 12-1](ch12.html#ch12fig1) shows a plot of the signal being transmitted
    in *carrier waves*. A carrier wave is the amplitude of the carrier, and when there’s
    no wave, that’s the signal’s resting state. When the carrier line is high for
    a specific duration, which registers as a wave, that’s a binary 1\. When the carrier
    line is at a resting state for a shorter duration, that’s a binary 0.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用ASK调制时，位是通过信号的幅度来指定的。[图12-1](ch12.html#ch12fig1)显示了通过*载波波形*传输的信号图。载波波形是载波的幅度，当没有波形时，这是信号的静止状态。当载波线在特定时间内处于高位，表示为一个波形，这就是二进制1。当载波线处于静止状态且持续时间较短时，这就是二进制0。
- en: '![image](graphics/f12-01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f12-01.jpg)'
- en: '*Figure 12-1: ASK modulation*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-1：ASK调制*'
- en: 'ASK modulation is also known as on-off keying (OOK), and it typically uses
    a start-and-stop bit. Start-and-stop bits are common ways to separate where a
    message starts and where it stops. Accounting for start-and-stop bits, [Figure
    12-1](ch12.html#ch12fig1) could represent nine bits: 0-1-1-0-1-1-0-1-0.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ASK调制也称为开关键控（OOK），通常使用开始和停止位。开始和停止位是常用的方式，用于区分消息的开始和结束位置。考虑到开始和停止位，[图12-1](ch12.html#ch12fig1)可以表示九个比特：0-1-1-0-1-1-0-1-0。
- en: '**Frequency-Shift Keying**'
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**频移键控（FSK）**'
- en: Unlike ASK, FSK always has a carrier signal but that signal is instead measured
    by how quickly it changes—its frequency (see [Figure 12-2](ch12.html#ch12fig2)).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与ASK不同，FSK总是有一个载波信号，但这个信号是通过它变化的速度—即频率来测量的（见图[12-2](ch12.html#ch12fig2)）。
- en: '![image](graphics/f12-02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f12-02.jpg)'
- en: '*Figure 12-2: FSK modulation*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-2：FSK调制*'
- en: In FSK, a high-frequency signal is a 0, and a low-frequency signal is a 1\.
    When the carrier waves are close, that’s a 1, and when they’re spaced farther
    apart, that’s a 0\. The bits in [Figure 12-2](ch12.html#ch12fig2) are probably
    1-0-0-1-0-0-1-0-1.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在FSK中，高频信号表示0，低频信号表示1。当载波波形接近时，表示1；当它们相距较远时，表示0。图[12-2](ch12.html#ch12fig2)中的位可能是1-0-0-1-0-0-1-0-1。
- en: '**Hacking with TPMS**'
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**利用TPMS进行黑客攻击**'
- en: The TPMS is a simple device that sits inside the tire and sends data on tire-pressure
    readings and wheel rotation and temperature, and warnings about certain conditions
    like low sensor batteries to the ECU (see [Figure 12-3](ch12.html#ch12fig3)).
    The data is then displayed to the driver via gauges, digital displays, or warning
    lights. In the fall of 2000, the United States enacted the Transportation Recall
    Enhancement, Accountability, and Documentation (TREAD) Act, requiring that all
    new vehicles have a TPMS system installed in order to improve road safety by alerting
    drivers to underinflated tires. Thanks to TREAD, the TPMS has widespread adoption,
    making it a prevalent attack target.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: TPMS是一个简单的设备，安装在轮胎内部，向ECU发送轮胎压力、轮胎转速、温度数据，并提供低传感器电池等特定情况的警告（见图[12-3](ch12.html#ch12fig3)）。然后，这些数据通过仪表盘、数字显示屏或警告灯显示给驾驶员。2000年秋季，美国通过了《交通召回增强、问责和文档化（TREAD）法案》，要求所有新车安装TPMS系统，以通过提醒驾驶员轮胎气压不足来提高道路安全性。得益于TREAD，TPMS得到了广泛应用，成为一个常见的攻击目标。
- en: '![image](graphics/f12-03.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f12-03.jpg)'
- en: '*Figure 12-3: Two TPMS sensors*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-3：两个TPMS传感器*'
- en: 'The TPMS device sits inside the wheel and transmits wirelessly into the wheel
    well, allowing its signals to be partially shielded by the body of the vehicle
    in order to prevent too much leakage. Most TPMS systems use a radio to communicate
    with the ECU. The signal frequency varies between devices but typically runs at
    315 MHz or 433 MHz UHF and uses either ASK or FSK modulation. Some TPMS systems
    use Bluetooth, which has its pros and cons from the perspective of an attacker:
    Bluetooth has a greater default range, but the Bluetooth protocol can also enable
    secure communication, making it harder to intercept or connect to. In this chapter,
    I’ll focus on TPMS systems that use radio signals.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: TPMS设备安装在车轮内部，并通过无线信号传输到轮毂，从而使其信号部分受到车身的屏蔽，以防止过多信号泄漏。大多数TPMS系统使用无线电与ECU进行通信。信号频率因设备而异，但通常在315
    MHz或433 MHz UHF范围内运行，并使用ASK或FSK调制。某些TPMS系统使用蓝牙技术，从攻击者的角度来看，蓝牙有其优缺点：蓝牙的默认传输范围较大，但蓝牙协议也能实现安全通信，使其更难以被拦截或连接。在本章中，我将重点讨论使用无线电信号的TPMS系统。
- en: '***Eavesdropping with a Radio Receiver***'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用无线电接收器进行窃听***'
- en: 'Most public research on TPMS security is summarized in “Security and Privacy
    Vulnerabilities of In-Car Wireless Networks: A Tire Pressure Monitoring System
    Case Study” from researchers at the University of South Carolina and Rutgers University.^([1](footnote.html#fn02))
    The paper shows how the researchers were able to eavesdrop on a TPMS system from
    40 m away using a relatively low-cost USRP receiver ($700 to $2,000) to sniff
    its wireless signals. (As mentioned earlier, you could use a different SDR.) Once
    the signals have been captured, GNU Radio can be used to filter and demodulate
    them.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数关于TPMS安全性的公共研究都总结在《汽车无线网络的安全与隐私漏洞：一种胎压监测系统案例研究》一文中，该研究由南卡罗来纳大学和罗格斯大学的研究人员进行。^([1](footnote.html#fn02))
    论文展示了研究人员如何使用相对低成本的USRP接收器（$700到$2,000）在40米远的地方窃听TPMS系统的无线信号。（如前所述，您也可以使用不同的SDR设备。）一旦信号被捕获，就可以使用GNU
    Radio进行过滤和解调。
- en: TPMS systems have very weak signals and, therefore, don’t leak data too far
    from the vehicle. In order to overcome the low leakage factor of a TPMS system,
    you could add a low-noise amplifier (LNA) to your radio receiver to increase the
    sniffing range, which should allow you to capture a TPMS signal from the side
    of the road or from a vehicle traveling alongside the target. You could also implement
    directional antennas to boost your range.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: TPMS系统的信号非常弱，因此不会泄漏到距离车辆太远的地方。为了克服TPMS系统的低泄漏特性，您可以向无线电接收器添加一个低噪声放大器（LNA），以增加监听范围，这应该能够让您从路边或与目标车辆并行行驶的车辆中捕获到TPMS信号。您还可以使用定向天线来增强信号范围。
- en: TPMS sensors transmit only every 60 to 90 seconds, and sensors usually aren’t
    required to send information until the vehicle is traveling at 25 mph or higher.
    However, many sensors transmit even when a car is idle, and some transmit even
    when the car is off. When auditing a stationary vehicle that’s powered off, be
    sure to send a wake-up signal to trigger a response from the TPMS.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: TPMS传感器每60到90秒才会传输一次信息，通常传感器在车辆以时速25英里（40公里）或更高行驶时才需要发送信息。然而，许多传感器即使车辆处于空闲状态时也会传输，某些传感器甚至在车辆熄火时也会传输。在对一辆停放的、已关闭电源的车辆进行审计时，请确保发送一个唤醒信号，以触发TPMS的响应。
- en: The best way to know how your target TPMS sensor works is to listen for packets
    with the vehicle completely off. You most likely won’t see any communication without
    a wake-up signal, but some devices may transmit at slow intervals anyhow. Next,
    turn the vehicle on and leave it in an idle state. The ECU should prompt the tire
    to respond at the very least during startup, but most likely it’ll poll every
    so often.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 了解目标TPMS传感器工作原理的最佳方法是，在车辆完全熄火的情况下监听数据包。没有唤醒信号时，您很可能不会看到任何通信，但某些设备即使在低频率下也可能进行传输。接下来，启动车辆并让其处于空闲状态。ECU应该至少在启动时提示轮胎响应，但更有可能的是，它会定期轮询。
- en: Once you see the TPMS signal, you’ll need to decode it in order for its contents
    to make sense. Thankfully, researcher Jared Boone has made that easy with a suite
    of tools designed to capture and decode TPMS packets. You’ll find the source code
    for his `gr-tpms` tool at *[https://github.com/jboone/gr-tpms/](https://github.com/jboone/gr-tpms/)*
    and the source code for his `tpms` tool at *[https://github.com/jboone/tpms/](https://github.com/jboone/tpms/)*.
    After using these tools to capture and decode TPMS packets, you can analyze the
    captured data to determine which bits represent the system’s unique ID as well
    as any other fields.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '***TPMS Packets***'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: TPMS packets will typically contain the same information, with some differences
    between models. [Figure 12-4](ch12.html#ch12fig4) shows an example of a TPMS packet.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f12-04.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-4: An example TPMS packet*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: The SensorID is a 28- or 32-bit number that’s unique to each sensor and registered
    with the ECU. If your only goal is to fingerprint a target for tracking or triggering
    an event, the SensorID is probably the only part of the packet you’ll care about.
    The Pressure and Temperature fields contain readings from the TPMS device. The
    Flags field can contain extra meta-data, such as a warning about a low battery
    in a sensor.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: When determining packet encoding, check whether Manchester encoding was used.
    Manchester encoding is commonly used in near-field devices, like TPMS systems.
    If you know what chipset is being used, the data sheet should tell you whether
    it supports Manchester encoding. If it does, you’ll first need to decode the packet
    before parsing its contents. Jared Boone’s tools can assist with this task.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '***Activating a Signal***'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As mentioned, sensors generally transmit around once a minute, but rather than
    waiting 60 seconds for the sensor to send a packet, an attacker can send a 125
    kHz activation signal to the TPMS device with an SDR to elicit a response. Your
    interception of this response will need to be timed carefully, though, because
    there’s a delay between when you send an activation signal and when the response
    is transmitted. For example, if you’re receiving from the side of the road and
    the vehicle is traveling too fast past your sensor, you could easily miss the
    response.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: The activation signal is designed primarily for TPMS test equipment, so it may
    be tricky to use it on a moving vehicle. If the target vehicle sends packets when
    it’s stationary or off, your task will be much easier.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: TPMS sensors don’t use input validation. The ECU will check to make sure that
    it recognizes only the SignalID, so the only attribute you, as an attacker, need
    to know or match is the ID.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '***Tracking a Vehicle***'
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It’s possible to use TPMS to track vehicles by placing receivers in the areas
    you wish to track. For instance, to track vehicles entering a parking garage,
    you’d simply need to place some receivers by the entrance and exit areas. However,
    to track vehicles around a city or along a route, you’d need to strategically
    place sensors along the area to be tracked. Because the sensors would have limited
    range, you’d have to place them around intersections or freeway on- or off-ramps.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在你希望跟踪的区域放置接收器来使用 TPMS 跟踪车辆。例如，要跟踪进入停车场的车辆，你只需要在入口和出口区域放置一些接收器。然而，要在城市或沿途路线跟踪车辆，你需要战略性地在需要跟踪的区域放置传感器。由于传感器的范围有限，你必须将其放置在交叉口或高速公路的上下匝道附近。
- en: As mentioned, TPMS sensors broadcast their unique ID every 60 to 90 seconds,
    so you’ll miss a lot of signals if you’re recording IDs on a high-speed road.
    To improve your chances of capturing signals, send the activation signal to wake
    up the device as it passes. The sensor’s limited distance can also affect your
    ability to gather IDs, but you could add an LNA to your tracking system to increase
    the range.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，TPMS 传感器每 60 到 90 秒广播一次其唯一 ID，因此如果你在高速路上记录 ID，可能会错过很多信号。为了提高捕获信号的机会，可以在车辆经过时发送激活信号以唤醒设备。传感器的有限距离也可能影响你收集
    ID 的能力，但你可以为跟踪系统添加 LNA 来增加范围。
- en: '***Event Triggering***'
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***事件触发***'
- en: Besides simply tracking a vehicle, TPMS can be used to trigger an event, from
    something simple like opening a garage door when the car approaches to something
    more sinister. For instance, a malicious actor could plant a roadside explosive
    and set it to detonate when it receives a known ID from the TPMS sensor. Because
    you have four tires, the attacker would have reasonable assurance that they have
    the right vehicle if they receive a signal for each tire. Essentially, using all
    four tires would allow you to create a basic but accurate sensor fingerprint for
    a target vehicle.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单地跟踪车辆外，TPMS 还可以用于触发事件，从简单的例如当车辆接近时打开车库门，到更险恶的用途。例如，恶意行为者可能会在路边埋设爆炸物，并设置为接收到来自
    TPMS 传感器的已知 ID 时引爆。由于每辆车有四个轮胎，攻击者可以合理地确保他们锁定了目标车辆，如果他们收到来自每个轮胎的信号。基本上，使用四个轮胎可以为目标车辆创建一个基本但准确的传感器指纹。
- en: '***Sending Forged Packets***'
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***发送伪造的数据包***'
- en: Once you have access to the TPMS signal, you can send your own forged packets
    by setting up GNU Radio as a transmitter instead of as a receiver. By forging
    packets, you can not only spoof dangerous PSI and temperature readings but also
    cause other engine lights to trigger. And because sensors still respond to activation
    packets while the vehicle is off, it’s possible to drain a vehicle’s battery by
    flooding the sensor with activation requests.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你获得了 TPMS 信号的访问权限，你可以通过将 GNU Radio 设置为发射器而不是接收器来发送你自己的伪造数据包。通过伪造数据包，你不仅可以伪造危险的
    PSI 和温度读数，还可以触发其他引擎故障灯。而且，由于传感器在车辆关闭时仍会响应激活数据包，因此通过向传感器发送激活请求，你有可能耗尽车辆的电池。
- en: In the paper “Security and Privacy Vulnerabilities of In-Car Wireless Networks”
    referenced previously, the researchers flooded the sensors with spoofed packets,
    eventually managing to completely shut down the ECU while the vehicle was in use.
    Shutting down the ECU either halts the vehicle or forces it into “limp mode.”
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前引用的论文《车载无线网络的安全性和隐私漏洞》中，研究人员通过伪造数据包洪泛传感器，最终成功在车辆使用过程中完全关闭了 ECU。关闭 ECU 会使车辆停驶或强制其进入“紧急模式”。
- en: '**WARNING**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*Shutting down the ECU while a vehicle is traveling at high speed could be
    extremely dangerous. Even though playing with TPMS may seem innocuous, be sure
    to take standard safety precautions when assessing any vehicle.*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*在车辆高速行驶时关闭 ECU 可能是极其危险的。尽管玩弄 TPMS 看似无害，但在评估任何车辆时，请务必采取标准的安全预防措施。*'
- en: '**Attacking Key Fobs and Immobilizers**'
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**攻击钥匙扣和防盗系统**'
- en: Anyone who has driven a modern vehicle is likely familiar with the key fob and
    the remote unlock. In 1982, radio-frequency identification (RFID) was first introduced
    into remote keyless vehicle entry systems via the Renault Fuego, and it’s been
    in wide use since 1995\. Earlier systems used infrared, so when working with one
    of these earlier vehicles, you’ll need to assess the key fob by recording the
    infrared light source (which is not covered in this chapter). Today’s systems
    use a key fob to send an RFID signal to a vehicle to remotely unlock the doors
    or even start the vehicle. The key fob uses a transponder operating at 125 kHz
    to communicate with an immobilizer in the vehicle, which prevents the vehicle
    from starting unless it receives the correct code or other token. The reason to
    use a low-frequency RFID signal is to allow the key system to work even if the
    key fob runs out of battery power.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: We’ll examine using SDR devices to analyze wireless communications set by the
    wireless key fobs used to unlock and start vehicles. While older key fobs use
    a simple fixed code to start the vehicle, most modern systems rely on a rolling
    code or a challenge–response system that prevents simply recording and playing
    back a fixed code by challenging the key fob to perform a task, like completing
    a calculation and returning the correct answer. These calculations require both
    a bit more power and the use of a battery, which also makes it possible for the
    key fob to communicate on a higher frequency from a greater distance.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Remote keyless entry systems typically run at 315 MHz in North America and 433.92
    MHz in Europe and Asia. You can use GNU Radio to watch the signal sent by a key
    fob or use a tool like the Gqrx SDR (*[http://gqrx.dk/](http://gqrx.dk/)*) for
    a nice real-time view of the entire bandwidth brought in from your SDR device.
    Using Gqrx with a high sample rate (bandwidth) allows you to identify the frequency
    of an RFID signal as it’s sent from a key fob to a vehicle. For example, [Figure
    12-5](ch12.html#ch12fig5) shows Gqrx set to listen at 315 MHz (the center, vertical
    line) and at offset –1,192.350 kHz, as it monitors a key fob unlock request for
    a Honda. Gqrx has identified two peaks in the signal that are likely to be the
    unlock requests.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f12-05.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-5: Gqrx capture of a key fob unlock request*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '***Key Fob Hacks***'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are plenty of ways to hack key fob systems, and I’ll give examples of
    a few methods an attacker might use in the following sections.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '**Jamming the Key Fob Signal**'
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: One way to attack a key fob signal is to jam it by passing garbage data within
    the RFID receiver’s *passband*, the area the receiver is listening to for a valid
    signal. The width of the passband window includes some extra space where you can
    add noise to prevent the receiver from changing the rolling code while still allowing
    the attacker to view the correct key sequence (see [Figure 12-6](ch12.html#ch12fig6)).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: While holding onto that valid unlock request in memory, the attacker waits for
    another request to be sent and records that request, too. The attacker can then
    replay the first valid packet to the vehicle, causing it to lock or unlock the
    car, depending on the signal sent by the key fob. When the car owner leaves the
    vehicle, the attacker has the last valid key stored and can replay it to open
    the vehicle doors or start the vehicle. This attack was demonstrated by Samy Kamkar
    at DEF CON 23 on both vehicles and garage door openers.^([2](footnote.html#fn03))
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在保持有效解锁请求的内存中，攻击者等待另一个请求被发送并记录该请求。然后，攻击者可以将第一个有效数据包重放到车辆上，导致车辆锁定或解锁，具体取决于钥匙扣发送的信号。当车主离开车辆时，攻击者拥有最后一个有效密钥，并可以重放该密钥来打开车门或启动车辆。此攻击在DEF
    CON 23上由Samy Kamkar演示，适用于车辆和车库门开关器。^([2](footnote.html#fn03))
- en: '![image](graphics/f12-06.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f12-06.jpg)'
- en: '*Figure 12-6: Jamming the passband filter to preserve the key exchange*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-6：通过干扰通带滤波器来保持密钥交换*'
- en: '**Pulling the Response Codes from Memory**'
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**从内存中提取响应码**'
- en: Sometimes it’s possible to find the response code still in the immobilizer’s
    memory, even a few minutes after the key fob has stopped sending signals. This
    provides a window of opportunity to start the car not by capturing signals live
    from a key fob but rather by pulling the signal from the immobilizer’s memory.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有时即使钥匙扣停止发送信号几分钟后，也能在防盗系统的内存中找到响应码。这为启动汽车提供了一个机会窗口，攻击者可以通过从防盗系统内存中提取信号，而不是实时捕获钥匙扣信号来启动汽车。
- en: If an area of memory can be identified to contain this information, then the
    attacker needs to either quickly get access to the vehicle or have a device on
    the vehicle that can respond to record this information.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果能够识别出存储此信息的内存区域，那么攻击者需要快速获取对车辆的访问权限，或者在车辆上安装一个可以响应并记录此信息的设备。
- en: '**Brute-Forcing a Key Code**'
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**暴力破解密钥代码**'
- en: Some response codes can be accessed by brute force, though the feasibility of
    a brute-force attack depends on the key code length and algorithm. (We’ll discuss
    the cryptography behind these key systems in “[Immobilizer Cryptography](ch12.html#ch12lev2sec10)”
    on [page 220](ch12.html#page_220).) In order for a brute-force attack to succeed,
    the attacker needs to build custom software to brute-force the key using an SDR,
    a custom hardware component, or—better yet—a combination of the two. For instance,
    if the key fob detected brute-forcing attacks, you may want to have some custom
    hardware reset the key fob on lockout by bouncing the power.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一些响应码可以通过暴力破解方式访问，尽管暴力破解攻击的可行性取决于密钥码的长度和算法。（我们将在“[防盗系统密码学](ch12.html#ch12lev2sec10)”中讨论这些密钥系统背后的加密学，见[第220页](ch12.html#page_220)。）为了使暴力破解攻击成功，攻击者需要使用SDR、定制硬件组件，或者—更好的是—两者的组合，来编写自定义软件以暴力破解密钥。例如，如果钥匙扣能够检测到暴力破解攻击，您可能希望使用一些定制硬件通过切断电源来重置钥匙扣，防止锁定。
- en: '**Forward-Prediction Attacks**'
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**前向预测攻击**'
- en: If an attacker is able to observe challenge–response exchanges that occur when
    the key fob sends a signal to the vehicle and the vehicle’s transponder responds,
    the attacker can perform a *forward-prediction attack*. In such an attack, the
    attacker observes multiple challenges and from those, predicts what the next challenge
    request will be. If the transponder’s pseudorandom number generator (PRNG) is
    weak, this attack may well succeed. To greatly simplify this example, if the PRNG
    was based on when the key fob first received power, an attacker could seed their
    own random number generator with a matching start time. Once the attacker was
    synced to the target, the attacker could predict all future codes.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果攻击者能够观察到当钥匙扣向车辆发送信号并且车辆的转发器作出响应时发生的挑战-响应交换，攻击者可以执行*前向预测攻击*。在这种攻击中，攻击者观察多个挑战并从中预测下一个挑战请求是什么。如果转发器的伪随机数生成器（PRNG）较弱，这种攻击很可能会成功。为了简化这个例子，如果PRNG基于钥匙扣首次接收到电源的时间，攻击者可以用匹配的开始时间来初始化他们自己的随机数生成器。一旦攻击者与目标同步，攻击者就能预测所有未来的代码。
- en: '**Dictionary Attacks**'
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**字典攻击**'
- en: Similarly, if an attacker can record numerous valid challenge–response exchanges
    between the key fob and the transponder, they can store them in a dictionary and
    then use the collected key pairs to repeatedly request challenges from the transponder
    until one challenge matches a response in the dictionary. This tricky attack is
    possible only when the keyless entry system doesn’t use sender verification to
    make sure that responses are valid. The attacker would also need to be able to
    continuously request authentication from the transponder.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果攻击者能够记录多个有效的挑战–响应交换，涉及钥匙扣和应答器之间的交互，他们可以将其存储在字典中，然后利用收集到的密钥对反复向应答器请求挑战，直到其中一个挑战与字典中的响应匹配。这个巧妙的攻击只有在无钥匙进入系统没有使用发送方验证来确保响应有效时才能实现。攻击者还需要能够持续请求应答器进行认证。
- en: In order to perform a dictionary attack, the attacker would need to build a
    system to trigger the key fob request and record the exchange with an SDR. An
    Arduino wired to the button press of the researcher’s valid key fob would suffice.
    Assuming the authentication takes place over CAN, it’s also possible to grab the
    key fob ID over ultra-high frequency and attempt to gather the key stream by replaying
    and recording the communication over the CAN bus, as discussed in “[Reversing
    CAN Bus Communications with can-utils and Wireshark](ch05.html#ch05lev1sec2)”
    on [page 68](ch05.html#page_68). Using custom tools, this would be possible to
    repeat over any bus network. For more information on this type of attack, see
    the paper “Broken Keys to the Kingdom”.^([3](footnote.html#fn04))
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行字典攻击，攻击者需要建立一个系统来触发钥匙扣请求并使用软件定义无线电（SDR）记录交换内容。一个连接到研究者有效钥匙扣按钮的Arduino就足够了。假设认证通过CAN进行，也可以通过超高频信号获取钥匙扣ID，并通过重放和记录CAN总线上的通信来尝试收集密钥流，正如在[“使用can-utils和Wireshark逆向CAN总线通信”](ch05.html#ch05lev1sec2)中讨论的那样，在[第68页](ch05.html#page_68)也有相关介绍。通过自定义工具，这种方法可以在任何总线网络上重复进行。有关这种攻击的更多信息，请参见论文《破碎的王国之钥》。^([3](footnote.html#fn04))
- en: '**Dumping the Transponder Memory**'
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**转储应答器内存**'
- en: It’s often possible to dump the memory of the transponder to get the secret
    key. In [Chapter 8](ch08.html#ch08), we examined how to use debugger pins, such
    as JTAG, as well as side-channel analysis attacks to dump memory from the transponder.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通常可以通过转储应答器的内存来获取秘密密钥。在[第8章](ch08.html#ch08)中，我们探讨了如何使用调试引脚（如JTAG）以及侧信道分析攻击来从应答器中转储内存。
- en: '**Reversing the CAN Bus**'
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**逆向CAN总线**'
- en: To gain access to a vehicle, an attacker can simulate the lock button press
    using the CAN bus reversing methods discussed in [Chapter 5](ch05.html#ch05).
    If the attacker has access to the CAN bus, they can replay lock and unlock packets
    to control and occasionally even start the vehicle. Sometimes CAN bus wires are
    even accessible from outside the vehicle; for instance, some vehicles have CAN
    bus running to the tail lights. An attacker could pop out a tail light and tap
    into the CAN bus network in order to unlock the vehicle.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得车辆的访问权限，攻击者可以使用在[第5章](ch05.html#ch05)中讨论的CAN总线逆向方法模拟锁定按钮的按压。如果攻击者能够访问CAN总线，他们可以重放锁定和解锁数据包来控制并偶尔启动车辆。有时，CAN总线的电缆甚至可以从车辆外部访问；例如，某些车辆的CAN总线会连接到尾灯。攻击者可以拆下尾灯并接入CAN总线网络，以解锁车辆。
- en: '**Key Programmers and Transponder Duplication Machines**'
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**关键程序员和应答器复制机**'
- en: Transponder duplication machines are often used to steal vehicles. These machines,
    the same as those used by a mechanic or dealership to replace lost keys, can be
    purchased online for anywhere from $200 to $1,000\. Attackers acquire the transponder
    signal from their target vehicle and use it to create a clone of the key, by either
    having a valid key nearby or using one of the attacks discussed earlier. For example,
    the attacker—possibly a valet or a parking garage attendant—might jam the door
    lock signal and then sneak into the vehicle and attach a custom dongle to the
    OBD-II connector. The dongle would acquire the key fob communication and possibly
    even include a GPS broadcast to allow the attacker to locate the vehicle later.
    The attacker would later return to the vehicle and use the dongle to unlock and
    start the car.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 转发器复制机通常用于盗窃车辆。这些机器与机械师或经销商用来替换丢失钥匙的机器相同，可以在线购买，价格从 $200 到 $1,000 不等。攻击者获取目标车辆的转发器信号，并使用它来创建钥匙的克隆，可以通过将有效的钥匙放在附近或使用前面讨论的攻击方式之一。例如，攻击者——可能是代客泊车员或停车场工作人员——可能会干扰车门锁信号，然后悄悄进入车辆，并将一个定制的加密狗连接到
    OBD-II 接口。加密狗会获取钥匙扣通信，甚至可能包括 GPS 广播，允许攻击者稍后定位车辆。攻击者稍后返回车辆，并使用加密狗解锁并启动汽车。
- en: '***Attacking a PKES System***'
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***攻击 PKES 系统***'
- en: '*Passive keyless entry and start (PKES) systems* are very similar to traditional
    transponder immobilizer systems, except that the key fob can remain in the owner’s
    pocket and no button needs to be pressed. When a PKES system is implemented, antennas
    in the vehicle read RFID signals from the key fob when it’s in range. PKES key
    fobs use a low-frequency (LF) RFID chip and an ultra-high-frequency (UHF) signal
    to unlock or start the vehicle. The vehicle ignores UHF signals from the key fob
    if the LF RFID signal isn’t seen, meaning that the key isn’t nearby. The RFID
    on the key fob receives a crypto challenge from the vehicle, and the microcontroller
    on the key fob solves this challenge and responds over the UHF signal. Some vehicles
    use RFID sensors inside the vehicle to triangulate the location of the key fob
    to ensure the key fob is inside the vehicle. If the battery dies in a PKES key
    fob, there’s typically a hidden physical key in the fob that will unlock the door,
    though the immobilizer will still use the RFID to verify that the key is present
    before starting the vehicle.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*无钥匙进入与启动（PKES）系统* 与传统的转发器防盗系统非常相似，不同之处在于钥匙扣可以保持在车主的口袋中，无需按下任何按钮。当实现 PKES 系统时，车辆内的天线会在钥匙扣处于有效范围时读取其
    RFID 信号。PKES 钥匙扣使用低频（LF）RFID 芯片和超高频（UHF）信号来解锁或启动车辆。如果没有看到 LF RFID 信号，意味着钥匙不在附近，车辆会忽略来自钥匙扣的
    UHF 信号。钥匙扣上的 RFID 接收来自车辆的加密挑战，钥匙扣上的微控制器解答该挑战并通过 UHF 信号作出响应。有些车辆会在车内使用 RFID 传感器来三角定位钥匙扣的位置，以确保钥匙扣在车辆内。如果
    PKES 钥匙扣的电池耗尽，通常钥匙扣内会有一个隐藏的物理钥匙，用于解锁车门，尽管防盗系统仍会使用 RFID 验证钥匙是否存在，然后才能启动汽车。'
- en: 'There are typically two types of possible attacks on a PKES system: a relay
    attack and an amplified relay attack. In a *relay attack*, an attacker places
    a device next to the car and another next to the owner or holder of the key fob
    (the target). The device relays the signals between the target’s key fob and the
    vehicle, enabling the attacker to start the car.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: PKES 系统通常面临两种类型的攻击：中继攻击和放大中继攻击。在*中继攻击*中，攻击者将一个设备放置在汽车旁边，另一个设备放置在车主或钥匙扣持有者（目标）旁边。设备在目标的钥匙扣与车辆之间转发信号，从而使攻击者能够启动汽车。
- en: This relay tunnel can be set up to communicate over any channel that’s fast
    and has a larger range than the normal key fob. For instance, a device placed
    near the target could set up a cellular tunnel to a laptop near the vehicle. Packets
    would go from the target’s key fob into the device to be transmitted over cellular
    and replayed by the laptop. For more information, see “Relay Attacks on Passive
    Keyless Entry and Start Systems in Modern Cars.”^([4](footnote.html#fn05))
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个中继通道可以通过任何速度较快、范围比普通钥匙扣更大的通道进行通信。例如，放置在目标附近的设备可以通过一个蜂窝通道与靠近车辆的笔记本电脑建立连接。数据包会从目标的钥匙扣传输到设备，通过蜂窝网络转发并由笔记本电脑重播。如需更多信息，请参阅“现代汽车中无钥匙进入与启动系统的中继攻击”。^([4](footnote.html#fn05))
- en: An *amplified relay attack* uses the same basic principles as a relay attack
    but with only a single amplifier. The attacker stands by the target vehicle and
    amplifies the signal, and if the target is nearby with the key fob, the vehicle
    will unlock. This is an unsophisticated attack that simply increases the range
    of the vehicle’s sensors. It’s been seen in the wild, primarily in residential
    neighborhoods, prompting a series of news articles advising residents to put their
    keys in their refrigerator or wrap them in aluminum foil when they’re at home
    to prevent them from sending a readable signal. Obviously, treating your keys
    like lunch is silly, but until auto manufacturers provide an alternative solution,
    I’m afraid you’re stuck with homemade Faraday cages.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '***Immobilizer Cryptography***'
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Like most systems in a vehicle, immobilizer systems are usually created using
    a combination of cheap components. As a result, manufacturers have become creative
    with things like cryptography, which has introduced numerous weaknesses into these
    systems. For example, some immobilizer vendors make the common mistake of creating
    their own crypto and hiding it behind a trade secret clause designed to protect
    it instead of validating it with public scrutiny. Known as *security through obscurity*,
    this method is almost always doomed to fail, and it’s why we don’t see a standard
    cryptography implementation to handle the key exchange between the key fob and
    the immobilizer.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: The immobilizer–key exchange uses a challenge–response system and PRNGs. The
    PRNG is equally important as the crypto algorithm, as a poor PRNG can lead to
    predictable results regardless of how good your crypto algorithm is.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'The typical key exchange implementation follows this general sequence:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: The immobilizer sends a challenge to the key using a PRNG.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The key encrypts the challenge using a PRNG and returns it to the immobilizer.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The immobilizer sends a second random number challenge.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The key encrypts both challenges and returns them to the immobilizer.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These algorithms are typically from the pseudorandom function (PRF) family,
    which generate what only *look* like random output given random input. There’s
    a strong reliance on generated randomness in order for these systems to work properly.
    Some of these systems have already been cracked and the cracking methods widely
    disseminated, but some still remain unbroken. Unfortunately, because manufacturers
    don’t have systems in place to update their key fobs’ firmware, you’ll see all
    of these algorithms in use if you look long and hard enough.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: The following are some of the known proprietary algorithms still in use and
    their current crack status—that is, whether they’ve been broken or not. Whenever
    possible, I identify which vehicles you may see the algorithm used in.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '*This section is designed to assist in your research. Each area should give
    you basic information on the key system you’re looking at and details that should
    help you to jump-start your crypto research. This section isn’t meant to explain
    cryptography, and I won’t delve into the intricacies of the mathematics behind
    each algorithm.*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '**EM Micro Megamos**'
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Introduced** 1997'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '**Manufacturer** Volkswagen/Thales'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '**Key Length** 96 bits'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '**Algorithm** Proprietary'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '**Vehicles** Porsche, Audi, Bentley, Lamborghini'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '**Crack Status** Broken but the attack methods have been censored by lawsuit'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: The Megamos cryptographic system has a particularly interesting history. Megamos
    “optimized” its key handshake by requiring only one round of challenge and response
    and eliminating the second round, as outlined earlier. While an attacker attempting
    to crack a challenge–response key would normally need access to the target key,
    they could crack Megamos without a key present because the Megamos challenge response
    is never actually acted on by the vehicle’s transponder. This flaw basically skips
    the key challenge portion and provides only an encrypted key.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: The Megamos memory is a 160-bit EEPROM, organized into 10 words, as shown in
    [Table 12-1](ch12.html#ch12tab1). Crypt Key is the secret key storage, ID is the
    32-bit identifier, LB 0 and LB 1 are the lock bits, and UM is the 30 bits of user
    memory.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 12-1:** Layout of the Megamos Memory Space'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bit 15** | **Bit 0** | **Bit 15** | **Bit 0** |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
- en: '| Crypt Key 95 | Crypt Key 80 | Crypt Key 15 | Crypt Key 0 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
- en: '| Crypt Key 79 | Crypt Key 64 | ID 31 | ID 16 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
- en: '| Crypt Key 63 | Crypt Key 48 | ID 15 | ID 0 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
- en: '| Crypt Key 47 | Crypt Key 32 | LB1, LB0, UM 29 | UM 16 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
- en: '| Crypt Key 31 | Crypt Key 16 | UM 15 | UM 0 |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
- en: 'This algorithm was cracked publicly in 2013 when Flavio D. Garcia, a security
    researcher at the University of Birmingham, published a paper called “Dismantling
    Megamos Crypto: Wirelessly Lockpicking a Vehicle Immobilizer”.^([5](footnote.html#fn06))
    Garcia and two fellow researchers from Radboud University Nijmegen, Barış Ege
    and Roel Verdult, notified the chipmakers, Volkswagen and Thales, nine months
    prior to the scheduled publication of their paper. Volkswagen and Thales reacted
    by suing the researchers for having identified the vulnerabilities, and the researchers
    lost the court case because the algorithm was leaked online. The leaked algorithm
    was used in pirated software—the Tango Programmer from VAG-info.com—for adding
    new keys. The researchers acquired this software and reversed the internals of
    the software to identify the algorithm.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: In their paper, the researchers analyzed the algorithm and reported on the vulnerabilities
    they found, though the actual exploit was apparently not trivial and there were
    much easier ways to steal a car with a Megamos system. Nevertheless, the research
    was placed under a gag order, and the findings weren’t made public. Unfortunately,
    the problem with Megamos still exists, and it’s still insecure—the gag order simply
    prevents vehicle owners from determining their risk because the research isn’t
    publicly available. This is a prime example of how the auto industry should *not*
    respond to security research.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find a transcript of the court decision here: *[http://www.bailii.org/ew/cases/EWHC/Ch/2013/1832.html](http://www.bailii.org/ew/cases/EWHC/Ch/2013/1832.html)*.
    In order not to leak any details, I’ll simply quote the court case:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'In detail the way this works is as follows: both the car computer and the transponder
    know a secret number. The number is unique to that car. It is called the “secret
    key”. Both the car computer and the transponder also know a secret algorithm.
    That is a complex mathematical formula. Given two numbers it will produce a third
    number. The algorithm is the same for all cars which use the Megamos Crypto chip.
    Carrying out that calculation is what the Megamos Crypto chip does.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: When the process starts the car generates a random number. It is sent to the
    transponder. Now both computers perform the complex mathematical operation using
    two numbers they both should know, the random number and the secret key. They
    each produce a third number. The number is split into two parts called F and G.
    Both computers now know F and G. The car sends its F to the transponder. The transponder
    can check that the car has correctly calculated F. That proves to the transponder
    that the car knows both the secret key and the Megamos Crypto algorithm. The transponder
    can now be satisfied that the car is genuinely the car it is supposed to be. If
    the transponder is happy, the transponder sends G to the car. The car checks that
    G is correct. If it is correct then the car is happy that the transponder also
    knows the secret key and the Megamos Crypto algorithm. Thus the car can be satisfied
    that the transponder is genuine. So both devices have confirmed the identity of
    the other without actually revealing the secret key or the secret algorithm. The
    car can safely start. The verification of identity in this process depends on
    the shared secret knowledge. For the process to be secure, both pieces of information
    need to remain secret—the key and the algorithm.^([6](footnote.html#fn07))
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: In reality, any robust crypto algorithm can be known. In fact, as any cryptographer
    will tell you, if knowing the math behind an algorithm jeopardizes the security
    of that algorithm, the algorithm is flawed.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: The court case determined that the attacks were hard to mitigate and would require
    a complete redesign. The researchers offered other lightweight algorithms that
    could be used in the redesigned key systems, but because the research was silenced,
    no key systems were updated. The Megamos algorithm is still found in key programmers
    like Volkswagen’s Tango Programmer, among others.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '**EM4237**'
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Introduced** 2006'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '**Manufacturer** EM Microelectronic'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '**Key Length** 128 bits'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '**Algorithm** Proprietary'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '**Vehicles** Unknown'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '**Crack Status** No known published cracks'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: EM4237 is described by the manufacturer as a generic, long-range, passive, contactless
    tag system that uses transponders. This is similar to a beefed-up proximity card
    used for building access but with a range of 1 to 1.5 m. Normally, EM4237 requires
    a high-security, 128-bit password, but it can run in a low-security mode that
    requires only a 32-bit password if, for example, the key fob is low on battery,
    as it takes less energy to compute a 32-bit key than a 128-bit key. The system’s
    low-security mode key is located in the same memory section of the transponder
    as the high-security mode key, and the system can be toggled between high and
    low security without having to reenter the password/key. The EM4237 transponder
    claims to be compliant with vicinity card standards (ISO/IEC 15693), which offers
    full encryption of the RF channel (13.56 MHz). When auditing EM4237, ensure that
    implementation on your target matches the specification.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '**Hitag 1**'
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Introduced** Unknown'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '**Manufacturer** Philips/NXP'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '**Key Length** 32 bits'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '**Algorithm** Proprietary'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '**Vehicles** Unknown'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '**Crack Status** Broken'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Hitag 1 relies on a 32-bit secret key and is susceptible to a brute-force attack
    that can take only a few minutes. You won’t find Hitag 1 used in many of today’s
    vehicles, but Hitag 1 transponders are still used in other RFID products, such
    as smart keychains and proximity cards.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '**Hitag 2**'
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Introduced** 1997'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '**Manufacturer** Philips/NXP'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '**Key Length** 48 bits'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '**Algorithm** Proprietary'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '**Vehicles** Audi, Bentley, BMW, Chrysler, Land Rover, Mercedes, Porsche, Saab,
    Volkswagen, and many more'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '**Crack Status** Broken'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Hitag 2 is one of the most widely implemented (and broken) algorithms in vehicles
    produced around the world. The algorithm was cracked because its stream cipher,
    shown in [Figure 12-7](ch12.html#ch12fig7), is never fed back into the original
    state, making the key discoverable.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f12-07.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-7: Hitag 2 cipher*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Hitag 2 keys can be cracked in under a minute by using a type of smart brute-forcing
    that intelligently picks the next guess rather than trying every possibility.
    The Hitag 2 system can be brute-forced so quickly because it doesn’t even use
    its full bit length, and when the transponders are introduced into a system, they
    don’t produce true random numbers during initialization. Both Hitag 1 and Hitag
    2 are also vulnerable to dictionary attacks.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll find numerous papers online that discuss a multitude of weaknesses in
    Hitag 2, such as “Gone in 360 Seconds: Hijacking with Hitag2”.^([7](footnote.html#fn08))'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '**Hitag AES**'
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Introduced** 2007'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '**Manufacturer** Philips/NXP'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '**Key Length** 128 bits'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '**Algorithm** AES'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '**Vehicles** Audi, Bentley, BMW, Porsche'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '**Crack Status** No known published cracks'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: This newer cipher relies on the proven AES algorithm, which means that any weaknesses
    in the crypto will result from a manufacturer’s implementation. As I write this,
    there are no known cracks for Hitag AES.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '**DST-40**'
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Introduced** 2000'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '**Manufacturer** Texas Instruments'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '**Key Length** 40 bits'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '**Algorithm** Proprietary (unbalanced Feistel cipher)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '**Vehicles** Ford, Lincoln, Mercury, Nissan, Toyota'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '**Crack Status** Broken'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm used by the digital signal transponder DST-40 was also used in
    the Exxon-Mobil Speedpass payment system. The DST-40, a 200-round unbalanced Feistel
    cipher, was reverse engineered by researchers at Johns Hopkins University who
    created a series of FPGAs to brute-force the key, allowing them to clone the transponders.
    (FPGAs make it possible to create hardware that’s custom designed to crack algorithms,
    which makes brute-forcing much more feasible.) Because an FPGA is specialized
    and can run with parallel inputs, it can often process things much faster than
    a general-purpose computer.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: The attack on DST-40 takes advantage of the transponder’s weak 40-bit key and
    requires no more than one hour to complete. To perform the attack, the attacker
    must get two challenge–response pairs from a valid transponder—a relatively easy
    task, since DST-40 responds to as many as eight queries per second. (See “Security
    Analysis of Cryptographically-Enabled RFID Device” for more details on this crack.^([8](footnote.html#fn09)))
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '**DST-80**'
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Introduced** 2008'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '**Manufacturer** Texas Instruments'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '**Key Length** 80 bits'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '**Algorithm** Proprietary (unbalanced Feistel cipher)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '**Crack Status** No known published cracks'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: When DST-40 was cracked, Texas Instruments responded by doubling the key length
    to produce DST-80\. DST-80 isn’t as widely deployed as DST-40\. Some sources claim
    that DST-80 is still susceptible to attack, though, as of this writing, no attacks
    have been published.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '**Keeloq**'
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Introduced** Mid-1980s'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '**Manufacturer** Nanoteq'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '**Key Length** 64 bits'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '**Algorithm** Proprietary (NLFSR)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '**Vehicles** Chrysler, Daewoo, Fiat, General Motor, Honda, Jaguar, Toyota,
    Volkswagen, Volvo'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '**Crack Status** Broken'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Keeloq, shown in [Figure 12-8](ch12.html#ch12fig8), is a very old algorithm,
    and there have been many published attacks on its encryption. Keeloq can use both
    a rolling code and a challenge response, and it uses a block cipher based on nonlinear
    feedback shift register (NLFSR). The manufacturer implementing Keeloq receives
    a key, which is stored in all receivers. Receivers learn transponder keys by receiving
    their IDs over a bus line programmed by the auto manufacturer.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: The most effective cryptographic attack in Keeloq uses both a slide and a meet-in-the-middle
    attack. The attack targets Keeloq’s challenge–response mode and requires the collection
    of 216 known plaintext messages from a transponder—the recording of which can
    take just over one hour. The attack typically results only in the ability to clone
    the transponder, but if the manufacturer’s key derivation is weak, it may be possible
    for the attacker to deduce the key used on their transponders. However, attacking
    the crypto has become unnecessary because newer dedicated FPGA clusters make it
    possible to simply brute-force the key.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f12-08.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-8: Keeloq algorithm*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Keeloq is also susceptible to a power-analysis attack. A power-analysis attack
    can be used to extract the manufacturer’s key used on the transponders with only
    two transponder messages. If successful, such an attack typically results only
    in the ability to clone a transponder in a few minutes by monitoring the power
    traces on the transponder. Power analysis can also be used to get the manufacturer
    key, though such an attack could take several hours to perform. Once the attacker
    has the master key, they can clone any transponder. Finally, because Keeloq takes
    varying clock cycles when using its lookup table, it’s also susceptible to timing
    attacks. (For more on power-analysis and timing attacks, see [Chapter 8](ch08.html#ch08).)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '**Open Source Immobilizer Protocol Stack**'
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Introduced** 2011'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '**Manufacturer** Atmel'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '**Key Length** 128 bits'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '**Algorithm** AES'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '**Crack Status** No known published cracks'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'In 2011, Atmel released the Open Source Immobilizer Protocol Stack under an
    open source license, making it freely available to the public and encouraging
    public scrutiny of the protocol design. As I write this, there are no known attacks
    on this protocol. You can download the protocol from the Atmel site: *[http://www.atmel.com/](http://www.atmel.com/)*.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '***Physical Attacks on the Immobilizer System***'
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far, we’ve looked at wireless attacks and direct cryptography attacks against
    the transponders. Next, we’ll look at physical modification and attacks to the
    vehicle itself. Physical attacks typically take longer to perform and aren’t meant
    to be stealthy.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '**Attacking Immobilizer Chips**'
  id: totrans-196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: One way to attack an immobilization system is to physically attack the immobilizer
    chip. In fact, it’s possible to completely remove the immobilizer chip (typically
    from a vehicle’s ECU) and still operate a vehicle, though perhaps not quite normally.
    At the very least, this removal would create a DTC and turn on the MIL, as discussed
    in “[Diagnostic Trouble Codes](ch04.html#ch04lev1sec1)” on [page 52](ch04.html#page_52).
    In order to physically remove immobilizer-based security, you can purchase or
    build an immobilizer bypass chip and then solder it where the original immobilizer
    chip was to keep the rest of the ECU happy. These chips, sometimes referred to
    as *immo emulators*, typically cost $20 to $30\. You’d still need to have a key
    cut for the vehicle, but having bypassed any challenge–response security entirely,
    the key would simply unlock and start the vehicle.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '**Brute-Forcing Keypad Entry**'
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now, for a change of pace: Here’s one method for brute-forcing a keypad lock
    on a vehicle; this particular method was discovered by Peter Boothe (available
    at *[http://www.nostarch.com/carhacking/](http://www.nostarch.com/carhacking/)*).
    If the vehicle has a keypad under the door handle with buttons labeled 1/2, 3/4,
    5/6, 7/8, 9/0, you can manually enter the following sequence in about 20 minutes
    to unlock the car door. You don’t have to enter the entire sequence—you can stop
    entering the code whenever the doors unlock. For convenience, each button is labeled
    1, 3, 5, 7, and 9, respectively.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This method works because the key codes roll into one another. The vehicle doesn’t
    know where one code ends and the other one starts, which means that you don’t
    have to try each possibility in order to stumble on the right combination.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '***Flashback: Hotwiring***'
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: No car hacking book would be complete without some discussion of hotwiring—a
    truly brute-force attack. Unfortunately, this attack has been obsolete since about
    the mid-1990s, but you still see it in countless movies, so I’m including it here.
    My goal isn’t to help you go out and hotwire a car but to give you a sense of
    how hotwiring was done.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'In the past, ignition systems used a vehicle’s key to complete an electrical
    circuit: turn the key and you’ve connected the starter wire to the ignition and
    battery wires. No tricky immobilizer system got in the way of the vehicle starting;
    the security was purely electrical.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: To hotwire a susceptible car, you’d remove the steering wheel to expose the
    ignition cylinder and typically three bundles of wires. Using the car’s manual
    or simply by tracing the wires, you’d locate the ignition-battery bundle and the
    starter wire. Next, you’d strip the battery and ignition wires and twist them
    together (see [Figure 12-9](ch12.html#ch12fig9)). Then, you’d “spark” the bundle
    with the starter wire to start the car. Once the car started, you’d remove the
    starter wire.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f12-09.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-9: Simple illustration of which wires to cross*'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: If a car had a steering wheel lock, you’d bypass it by breaking off the metal
    keyhole spring and breaking the lock, or sometimes just by forcing the wheel to
    turn until you broke the lock.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about low-level wireless communications. We went
    over methods for identifying wireless signals and common attacks against wireless
    communications. We demonstrated a few hacks using the TPMS to show that even seemingly
    benign devices are vulnerable to attack. We also reviewed key fob security and
    demonstrated a few simple hacks there. Vehicle theft is rapidly adapting to modern
    electronic vehicles, and keyless system attacks are one of the main hacks used
    in thefts. Understanding the different systems, their strengths and weaknesses,
    and how to attack them can help you understand how vulnerable your vehicle is
    to theft. Finally, we discussed some old-school nonelectronic hacks, like manually
    brute-forcing door keypads and hotwiring.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 13](ch13.html#ch13), we’ll look at a common, and arguably less
    malicious, type of hacking: performance tuning.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
