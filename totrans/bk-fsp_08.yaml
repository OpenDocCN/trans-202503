- en: Chapter 8. Measuring Up
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8章：测量标准
- en: It is all too easy to mix up units of measurement in a long, intricate computer
    program. When such a mix-up occurs, the consequences can be extremely costly,
    even tragic. One of the most famous examples is the crash of NASA’s *Mars Climate
    Orbiter* in 1999\. Investigation into the accident revealed that the crash was
    caused by a unit mismatch; pound-force seconds were used instead of newton seconds.
    This error led to an incorrect trajectory calculation and ultimately to the vehicle’s
    demise.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个长而复杂的计算机程序中，混淆测量单位是非常容易发生的。当这种混淆发生时，后果可能是极其昂贵的，甚至是悲剧性的。最著名的例子之一是1999年NASA的*火星气候轨道探测器*坠毁事件。事故调查揭示，坠毁的原因是单位不匹配；使用了磅力秒而不是牛顿秒。这一错误导致了不正确的轨迹计算，最终导致了探测器的毁灭。
- en: One can argue that proper testing should have detected the calculation error
    and thus prevented the crash, but a bigger question is whether the error would
    have even occurred if the programming language had enforced the proper units through
    its type system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 可以争辩说，适当的测试应该能检测到计算错误，从而避免坠毁，但更大的问题是，如果编程语言通过其类型系统强制使用正确的单位，这个错误是否根本不会发生。
- en: Over the years, people have tried enforcing units of measure in software systems,
    usually through external libraries, to varying degrees of success. F# is one of
    the first languages to include units of measure as a native part of its static
    type checking system. In addition to providing an extra level of safety beyond
    the basic type system, F#’s units of measure can enhance code readability by removing
    ambiguity about what is actually expected in the code without resorting to longer
    identifiers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，人们一直在尝试在软件系统中强制使用测量单位，通常通过外部库来实现，并且成功程度不一。F#是最早将测量单位作为其静态类型检查系统的原生部分之一的编程语言之一。除了提供比基本类型系统更高的安全性外，F#的测量单位还可以通过消除关于代码中实际期望内容的模糊性来增强代码的可读性，而无需依赖更长的标识符。
- en: Defining Measures
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义度量
- en: 'To enable static measure checking, you first need to define a measure. *Measures*
    are type-like constructs that are decorated with the `Measure` attribute to represent
    real-world measurements. They can include an optional *measure formula* that describes
    the measure in terms of other measures. For example, the following definition
    creates a named unit of measure for a foot:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用静态测量检查，你首先需要定义一个度量。*度量*是类似类型的构造，带有`Measure`属性来表示实际世界中的测量。它们可以包含一个可选的*测量公式*，通过其他度量来描述该度量。例如，以下定义创建了一个名为英尺的度量单位：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: International System of Units
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 国际单位制
- en: F# 3.0 includes predefined measure types for the International System of Units
    (SI) units, including meters, kilograms, and amperes, among many others. You can
    find each SI unit in the `Microsoft.FSharp.Data.UnitSystems` namespace. Prior
    to F# 3.0, the SI units are included in the F# PowerPack and can be found in the
    `Microsoft.FSharp.Math` namespace.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: F# 3.0包含了国际单位制（SI）单位的预定义度量类型，包括米、千克和安培等。你可以在`Microsoft.FSharp.Data.UnitSystems`命名空间中找到每个SI单位。在F#
    3.0之前，SI单位包含在F# PowerPack中，并可以在`Microsoft.FSharp.Math`命名空间中找到。
- en: Measure Formulas
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测量公式
- en: 'Measure formulas allow you to define derivative measures based on one or more
    previously defined measures. At their most basic, formulas serve as an easy way
    to create synonyms for types. For instance, if you’ve defined a measure named
    `foot` and want to abbreviate it as `ft`, you could write this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 测量公式允许你基于一个或多个先前定义的度量来定义派生度量。最基本的情况是，公式作为一种简单的方式为类型创建同义词。例如，如果你已经定义了一个名为`foot`的度量，并希望将其缩写为`ft`，你可以这样写：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Measure formulas aren’t always quite so simple, though; they can also be used
    to describe more complex relationships between types, such as a measurement of
    distance over time. For example, miles per hour could be defined as `m / h` (assuming
    that `m` and `h` were previously defined to represent miles and hours, respectively).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，测量公式并不总是那么简单；它们也可以用来描述类型之间更复杂的关系，例如距离与时间的关系。例如，英里每小时可以定义为`m / h`（假设`m`和`h`之前已分别定义为英里和小时）。
- en: 'Here are some of the most notable guidelines to follow when composing measure
    formulas:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写测量公式时，以下是一些最重要的指南：
- en: 'You can multiply measures by separating two measures with a space or an asterisk
    (`*`) to create a *product measure*. For instance, torque is sometimes measured
    in pound-feet and could be represented in F# as:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can divide measures by separating two measures with a forward slash (/)
    to create a *quotient measure*. For instance, a distance over time, such as miles
    per hour, could be expressed like this:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Positive and negative integral values can be used to express an exponential
    relationship between two measures. For instance, square feet can be expressed
    like this:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Applying Measures
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you’ve defined some measures you can apply them to values. Out of the box,
    F# defines measure-aware variations of the `sbyte`, `int16`, `int32`, `int64`,
    `float`, `float32`, and `decimal` primitive types. Values without measure annotations
    are said to be *measureless* or *dimensionless*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply a measure to a constant value, you simply need to annotate the value
    as if the measure were a generic type parameter. For instance, you could define
    a length in feet and an area in square feet as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, `length` is bound to `float<ft>` while `area` is bound to `float<sqft>`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Where Have the Stars Gone?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Although units of measure play an important role within F#’s type system, they
    are erased during compilation and therefore have no impact on the compiled code.
    This is not to say that the measure types are not present in the compiled assembly;
    it means only that they’re not attached to any individual values. The net result
    of erasure is that units of measure can be enforced only within F# code, and any
    measure-aware functions or types used by assemblies written in other languages
    will be treated as measureless.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'Measure annotations are great for constant values, but how can we apply measures
    to external data (such as something read from a database)? The easiest way to
    convert a measureless value to a measured one is to multiply it by a measured
    value, like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we define a measure representing dots per inch (`dpi`) and create a resolution
    by multiplying `300.0` by `1.0<dpi>`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'For a more verbose alternative, you can use one of the seven typed `WithMeasure`
    functions from the `LanguagePrimitives` module. Each `WithMeasure` function corresponds
    to one of the measured primitives. Here’s how to create a new measured value using
    the `FloatWithMeasure` function:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `WithMeasure` functions are a bit more explicit in their intent and are
    definitely more verbose. Typically, their use is reserved for when type inference
    fails.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Stripping Measures
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The vast majority of functions do not accept unitized values, so you may need
    to strip measures from values. Luckily, like applying measures, stripping measures
    is easy.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'The typical way to strip measures is to simply divide the value by a measured
    `1`, like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Alternatively, you can use the corresponding type conversion operator to achieve
    the same effect. For instance, we can strip the units from `300.0<dpi>` by calling
    the `float` function as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Enforcing Measures
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because units of measure are part of F#’s type system, you can enforce that
    values passed to a function use the correct units through type annotations on
    the parameters. Here we define a `getArea` function that requires the supplied
    width and height to be measured in feet:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you were to call `getArea` with measureless arguments as shown here, you’d
    receive the following error:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Similarly, calling `getArea` with arguments annotated with the wrong measure
    (or no measure at all) will result in a compiler error. To correctly call the
    `getArea` function, you must provide values in the proper units, like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Notice that the function’s return value is `float<ft ^ 2>` despite our having
    defined `sqft` as `ft ^ 2`. The compiler doesn’t automatically convert the measures
    unless explicitly instructed to do so through a return type annotation, as shown
    here:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Ranges
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Measured units are permissible in range expressions, but there’s a catch: You
    must provide a step value. To create a measured range, you could write something
    like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Without an explicit step value, the compiler will try to create the range with
    the underlying type’s default, measureless value and will raise an error.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Converting Between Measures
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While measure formulas allow you to create derivative units, they really aren’t
    flexible enough to allow arbitrary conversions between measures. To work around
    this limitation, you can define measure types with static members for both conversion
    factors and functions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Static Conversion Factors
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Defining a conversion factor on a measure type takes the same syntax as a static
    property. For instance, since there are 12 inches per foot, you could write something
    like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `perFoot` conversion can be accessed through the `inch` type like any static
    property. To convert from feet to inches, you would multiply a value measured
    in feet by `inch.perFoot`, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Notice how the compiler inferred through the multiplication operation that
    the result should be measured in inches. Similarly, we can convert from inches
    to feet by dividing a value measured in inches by `inch.perFoot`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Static Conversion Functions
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you need more than a conversion factor, you can define static conversion
    functions (and their reciprocal conversions) directly on the measure types. Consistently
    defining the conversion functions on both measure types can help avoid confusion
    about where they’re defined.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'To maximize code reuse, you can define the measure types as mutually recursive
    types by joining them together with the `and` keyword. Here, we define Fahrenheit
    and Celsius measures as mutually recursive types:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The Fahrenheit measure includes functions for converting to and from Celsius.
    Likewise, the Celsius measure includes functions for converting to and from Fahrenheit,
    but through the mutually recursive definition it can reuse the functions defined
    on the Fahrenheit type.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 华氏度度量包含用于转换为摄氏度和从摄氏度转换回来的函数。同样，摄氏度度量也包含用于转换为华氏度和从华氏度转换回来的函数，但通过相互递归定义，它可以重用华氏度类型上定义的函数。
- en: 'Depending on the complexity of your measure definitions or the conversion functions,
    you may find it cleaner to define the types independently and add the static methods
    later with intrinsic type extensions. This snippet shows one possible approach:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的度量定义或转换函数的复杂性，你可能会发现将类型独立定义，然后通过内建类型扩展添加静态方法会更清晰。以下代码片段展示了一种可能的方法：
- en: '[PRE19]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, the measure types are defined on their own (without mutual recursion)
    and immediately followed by the conversion functions. Since neither of the conversion
    functions has been attached to the measure types, we follow their definition by
    extending the measure types with static properties that expose the conversion
    functions.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，度量类型是独立定义的（没有相互递归），并紧跟着转换函数。由于转换函数没有附加到度量类型上，我们通过扩展度量类型并添加静态属性来公开这些转换函数。
- en: Generic Measures
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用度量
- en: You’ve already seen numerous examples of how to write measure-aware functions
    for specific measure types, but it’s also possible to write functions against
    arbitrary measures using *generic measures*. Writing such a function is the same
    as for specific measure types, except that instead of using a concrete unit value
    you use an underscore character (`_`). Alternatively, or when your function accepts
    multiple parameters that must use the same generic measure type, you can use a
    generic identifier (such as `'U`) instead of an underscore.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了许多如何为特定度量类型编写度量感知函数的例子，但也可以使用*通用度量*编写针对任意度量的函数。编写这样的函数与为特定度量类型编写函数相同，只不过你不使用具体的单位值，而是使用下划线字符（`_`）。或者，当你的函数接受多个必须使用相同通用度量类型的参数时，你可以使用通用标识符（例如`'U`）代替下划线。
- en: 'You might use generic measures when you need to perform the same operation
    against a variety of measures. For instance, you could write a function that computes
    the square of any measured `float` like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要针对多种度量执行相同操作时，可能会使用通用度量。例如，你可以编写一个计算任意测量值`float`平方的函数，代码如下：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Because `square` is defined to use a generic measure, its argument can accept
    any measured type. In fact, its argument can even be measureless. Here we use
    the square function to compute square inches, square feet, and a measureless square:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`square`被定义为使用通用度量，所以它的参数可以接受任何度量类型。事实上，它的参数甚至可以是没有度量的。在这里，我们使用平方函数来计算平方英寸、平方英尺和无度量的平方：
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Custom Measure-Aware Types
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义度量感知类型
- en: 'You can create your own measure-aware type by defining a generic type with
    a type parameter decorated with the `Measure` attribute. Consider the following
    record type:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过定义一个带有`Measure`属性的类型参数来创建你自己的度量感知类型。考虑以下记录类型：
- en: '[PRE22]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `Point` type behaves just like any other record type, except that its members
    are defined as generic measures. Rather than working only with measureless floats,
    `Point` includes a single measure, `''u`①, that is used by `X` ② and `Y` ③. `Point`
    also defines a `FindDistance` function ④ that performs a measure-safe calculation
    to find the distance between two points. Here we create a `Point` instance and
    invoke the `FindDistance` function against another `Point`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`Point`类型的行为与其他记录类型相同，只是它的成员被定义为通用度量。`Point`不只是处理没有度量的浮动值，而是包含一个度量`''u`①，`X`②和`Y`③使用此度量。`Point`还定义了一个`FindDistance`函数④，该函数执行度量安全计算，以查找两个点之间的距离。这里我们创建了一个`Point`实例，并对另一个`Point`调用`FindDistance`函数：'
- en: '[PRE23]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you try calling `FindDistance` with a `Point` that uses a different measure,
    the compiler will raise a type mismatch error like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试用使用不同度量单位的`Point`调用`FindDistance`，编译器会抛出类似这样的类型不匹配错误：
- en: '[PRE24]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Custom measure-aware types aren’t restricted to record types, either. For instance,
    you could define an equivalent measure-aware class like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义度量感知类型也不限于记录类型。例如，你可以像这样定义一个等效的度量感知类：
- en: '[PRE25]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Summary
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Most programming languages rely on programmer discipline to ensure that measures
    are used correctly and consistently. One of the unique ways that F# helps developers
    produce more correct code is by including a rich syntax for units of measure directly
    within its type system.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言依赖程序员的自律来确保度量单位的正确和一致使用。F# 帮助开发者生成更准确代码的独特方式之一，就是通过在其类型系统中直接包含丰富的度量单位语法。
- en: F# not only includes predefined measure types for the International System of
    Units, but it also lets you define your own. You can enforce that the proper units
    are used in your calculations by annotating individual constant values with the
    appropriate measure or including them in type annotations in function definitions.
    Finally, you can define your own measure-aware types using a generic-like syntax.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: F# 不仅包括国际单位制（SI）的预定义度量类型，而且还允许你定义自己的度量单位。你可以通过在常量值上添加适当的度量单位注解，或在函数定义中将其包含在类型注解中，从而强制使用正确的度量单位进行计算。最后，你还可以使用类似泛型的语法定义自己的度量单位感知类型。
