<html><head></head><body>
<h2 class="h2" id="ch17"><span epub:type="pagebreak" id="page_241"/><span class="big">17</span><br/>DEPLOYING ACTIVE DIRECTORY</h2>&#13;
<div class="image1"><img class="inline" src="../images/common.jpg" alt="Images"/></div>&#13;
<p class="noindent"><span class="bign">In this chapter, you’ll take what you’ve learned over the last few chapters of <a href="part2.xhtml#part2">Part II</a> and begin deploying services on top of your virtual machines. Because so many other services depend on Active Directory, you must first deploy an Active Directory forest and domain. The AD forest and domain will support your authentication and authorization needs for the remaining chapters.</span></p>&#13;
<p class="indent">Assuming that you already read through and provisioned the LABDC VM in the preceding chapter, you’ll be using that to fully automate provisioning an Active Directory forest, and populating it with some test users and groups.</p>&#13;
<h3 class="h3" id="ch17lev1"><span epub:type="pagebreak" id="page_242"/>Prerequisites</h3>&#13;
<p class="noindent">You’ll use what you made in <a href="ch16.xhtml#ch16">Chapter 16</a>, so I’m assuming that you have a LABDC VM set up, built using the unattended XML, and booted up running Windows Server 2016. If so, you’re good to go! If not, you can still mine this chapter for examples of how to automate Active Directory, but fair warning: you won’t be able to completely follow along.</p>&#13;
<p class="indent">As always, run the associated prerequisite Pester test to ensure that you meet all the prerequisites for this chapter.</p>&#13;
<h3 class="h3" id="ch17lev2">Creating an Active Directory Forest</h3>&#13;
<p class="noindent">The good news is that, all things considered, creating an AD forest with PowerShell is pretty easy. When it comes down to it, you’re essentially running just two commands: <code>Install-WindowsFeature</code> and <code>Install-ADDSForest</code>. With these two commands, you can build a single forest, build a domain, and provision a Windows server as a domain controller.</p>&#13;
<p class="indent">Because you’ll use this forest in a lab environment, you’ll also be creating some organizational units, users, and groups. Being in a lab environment means you don’t have any production objects to work with. Without going through the hassle of attempting to sync production AD objects with your lab, you can, instead, create many objects that mimic production and give you some objects to work with.</p>&#13;
<h3 class="h3" id="ch17lev3">Building the Forest</h3>&#13;
<p class="noindent">The first thing you need to do when creating a new AD forest is to promote a <em>domain controller</em>, the lowest common denominator in Active Directory. To have a functioning AD environment, you must have at least one domain controller.</p>&#13;
<p class="indent">Since this is a lab environment, you’ll use a single domain controller. In a real-world situation, you’d want at least two domain controllers for redundancy. However, because you have no data in your lab environment and the ability to quickly re-create it from scratch, you’ll use only one here. Before doing anything, you need to install the <code>AD-Domain-Services</code> Windows feature on your LABDC server. The command to install a Windows feature is <code>Install-WindowsFeature</code>:</p>&#13;
<pre>PS&gt; <span class="codestrong1">$cred = Import-CliXml -Path C:\PowerLab\VMCredential.xml</span> &#13;
PS&gt;<span class="codestrong1"> Invoke-Command -VMName 'LABDC' -Credential $cred -ScriptBlock</span> &#13;
<span class="codestrong1">{ Install-windowsfeature -Name AD-Domain-Services }</span>&#13;
PSComputerName : LABDC RunspaceId : 33d41d5e-50f3-475e-a624-4cc407858715&#13;
Success : True RestartNeeded : No FeatureResult : {Active Directory Domain&#13;
Services, Remote Server Administration Tools, Active Directory module for&#13;
Windows PowerShell, AD DS and AD LDS Tools...} ExitCode : Success ```</pre>&#13;
<p class="indent">After providing a credential to connect to the server, you use <code>Invoke-Command</code> to remotely run the <code>Install-WindowsFeature</code> commands on the remote server.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_243"/>Once the feature is installed, you can create the forest by using the <code>Install-ADDSForest</code> command. This command is part of the <code>ActiveDirectory</code> PowerShell module, which was installed on LABDC as part of the feature installation.</p>&#13;
<p class="indent">The <code>Install-ADDSForest</code> command is the only command you need to create a forest. It takes a few parameters, which you’ll fill in using code but are usually filled in using a GUI. This forest will be called <code>powerlab.local</code>. Since the domain controller is Windows Server 2016, you’ll set the domain mode and forest mode both to <code>WinThreshold</code>. For a full breakdown of all the available <code>DomainMode</code> and <code>ForestMode</code> values, refer to the <em>Install-ADDSForest</em> Microsoft documentation page (<em><a href="http://bit.ly/2rrgUi6">http://bit.ly/2rrgUi6</a></em>).</p>&#13;
<h4 class="h4" id="ch17lev3sec3">Saving Secure Strings to Disk</h4>&#13;
<p class="noindent">In <a href="ch16.xhtml#ch16">Chapter 16</a>, when you needed credentials, you saved <code>PSCredential</code> objects and reused them in your commands. This time around, you don’t need a <code>PSCredential</code> object. Instead, you need only a single encrypted string.</p>&#13;
<p class="indent">In this section, you’ll see that you need to pass a safe mode administrator password to a command. As with any piece of sensitive information, you want to use encryption. As you did in the preceding chapter, you’ll use <code>Export-CliXml</code> and <code>Import-CliXml</code> to save and retrieve PowerShell objects from the filesystem. Here, though, instead of calling <code>Get-Credential</code>, you’ll create a secure string by using <code>ConvertTo-SecureString</code> and then save that object to a file.</p>&#13;
<p class="indent">To save an encrypted password to a file, you pass the plaintext password to <code>ConvertTo-SecureString</code> and then export that secure string object to <code>Export-CliXml</code>, creating a file you can reference later:</p>&#13;
<pre>PS&gt;<span class="codestrong1"> 'P@$$w0rd12' | ConvertTo-SecureString -Force -AsPlainText</span> &#13;
<span class="codestrong1">| Export-Clixml -Path C:\PowerLab\SafeModeAdministratorPassword.xml</span></pre>&#13;
<p class="indent">As you can see, after you have the safe mode administrator password saved to disk, you can read it with <code>Import-CliXml</code> and pass in all the other parameters that <code>Install-ADDSForest</code> needs to run. You do this with the following code:</p>&#13;
<pre>PS&gt; <span class="codestrong1">$safeModePw = Import-CliXml -Path C:\PowerLab\&#13;
SafeModeAdministratorPassword.xml</span>&#13;
PS&gt; <span class="codestrong1">$cred = Import-CliXml -Path C:\PowerLab\VMCredential.xml</span>&#13;
PS&gt; <span class="codestrong1">$forestParams = @{</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">DomainName                    = 'powerlab.local'</span> <span class="ent">❶</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">DomainMode                    = 'WinThreshold'</span> <span class="ent">❷</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">ForestMode                    = 'WinThreshold'</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">Confirm                       = $false</span> <span class="ent">❸</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">SafeModeAdministratorPassword = $safeModePw</span> <span class="ent">❹</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">WarningAction                 = 'Ignore</span> <span class="ent">❺</span>&#13;
&gt;&gt;&gt;<span class="codestrong1">}</span>&#13;
PS&gt; <span class="codestrong1">Invoke-Command -VMName 'LABDC' -Credential $cred -ScriptBlock { $null =&#13;
Install-ADDSForest @using:forestParams }</span></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_244"/>Here, you’re creating a forest and domain called <em>powerlab.local</em> <span class="ent">❶</span> running at a Windows Server 2016 functional level (<code>WinThreshold</code>) <span class="ent">❷</span>, bypassing all confirmations <span class="ent">❸</span>, passing your safe mode administrator password <span class="ent">❹</span>, and ignoring the irrelevant warning messages that typically come up <span class="ent">❺</span>.</p>&#13;
<h4 class="h4" id="ch17lev3sec4">Automating Forest Creation</h4>&#13;
<p class="noindent">Now that you’ve done it manually, let’s build a function in your PowerLab module that will handle AD forest creation for you. Once you have a function, you’ll be able to use it across numerous environments.</p>&#13;
<p class="indent">In the PowerLab module included with this chapter’s resources, you’ll see a function called <code>New-PowerLabActiveDirectoryForest</code>, as shown in <a href="ch17.xhtml#ch17list1">Listing 17-1</a>.</p>&#13;
<pre>function New-PowerLabActiveDirectoryForest {&#13;
    param(&#13;
&#13;
        [Parameter(Mandatory)]&#13;
        [pscredential]$Credential,&#13;
&#13;
        [Parameter(Mandatory)]&#13;
        [string]$SafeModePassword,&#13;
&#13;
        [Parameter()]&#13;
        [string]$VMName = 'LABDC',&#13;
&#13;
        [Parameter()]&#13;
        [string]$DomainName = 'powerlab.local',&#13;
&#13;
        [Parameter()]&#13;
        [string]$DomainMode = 'WinThreshold',&#13;
&#13;
        [Parameter()]&#13;
        [string]$ForestMode = 'WinThreshold'&#13;
    )&#13;
&#13;
    Invoke-Command -VMName $VMName -Credential $Credential -ScriptBlock {&#13;
&#13;
        Install-windowsfeature -Name AD-Domain-Services&#13;
        &#13;
        $forestParams = @{&#13;
            DomainName                    = $using:DomainName&#13;
            DomainMode                    = $using:DomainMode&#13;
            ForestMode                    = $using:ForestMode&#13;
            Confirm                       = $false&#13;
            SafeModeAdministratorPassword = (ConvertTo-SecureString&#13;
                                            -AsPlainText -String $using:&#13;
                                            SafeModePassword -Force)&#13;
            WarningAction                 = 'Ignore'&#13;
        }&#13;
        $null = Install-ADDSForest @forestParams&#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch17list1"><em>Listing 17-1: The <span class="codeitalic">New-PowerLabActiveDirectoryForest</span> function</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_245"/>As in the preceding chapter, you simply define several parameters you’ll use to pass to the <code>ActiveDirectory</code> module’s <code>Install-ADDSForest</code> command. Notice that you define two <code>Mandatory</code> parameters for the credentials and password. As its name suggests, these are parameters the user needs to pass in (because the other parameters have default values, the user does not necessarily need to pass them in). You’ll use this function by reading in your saved administrator password and credential, and then passing the two into the function:</p>&#13;
<pre>PS&gt; <span class="codestrong1">$safeModePw = Import-CliXml -Path C:\PowerLab\SafeModeAdministratorPassword.xml</span>&#13;
PS&gt; <span class="codestrong1">$cred = Import-CliXml -Path C:\PowerLab\VMCredential.xml</span>&#13;
PS&gt; <span class="codestrong1">New-PowerLabActiveDirectoryForest -Credential $cred -SafeModePassword $safeModePw</span></pre>&#13;
<p class="indent">After running this code, you’ll have a fully working Active Domain forest! Well, you should, anyway—let’s figure out a way to confirm that the forest is up and running. A good test is to query all the default user accounts in the domain. To do so, however, you need to create another <code>PSCredential</code> object stored on disk; because LABDC is a domain controller now, you need a domain user account (not a local user account). You’ll create and save a credential with the username of <code>powerlab.local\administrator</code> and a password of <code>P@$$w0rd12</code> to the <em>C:\PowerLab\DomainCredential.xml</em> file. Remember that you need to do this only once. Then, you can use the new domain credential to connect to LABDC:</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-Credential | Export-CliXml -Path C:\PowerLab\DomainCredential.xml</span></pre>&#13;
<p class="indent">Once the domain credential is created, you’ll create another function in your PowerLab module called <code>Test-PowerLabActiveDirectoryForest</code>. Right now, this function just gathers all the users in a domain, but because you have this functionality wrapped in a function, you can customize this test to your liking:</p>&#13;
<pre>function Test-PowerLabActiveDirectoryForest {&#13;
    param(&#13;
        [Parameter(Mandatory)]&#13;
        [pscredential]$Credential,&#13;
&#13;
        [Parameter()]&#13;
        [string]$VMName = 'LABDC'&#13;
    )&#13;
&#13;
    Invoke-Command -Credential $Credential -ScriptBlock {Get-AdUser -Filter * }&#13;
}</pre>&#13;
<p class="indent">Try executing the <code>Test-PowerLabActiveDirectoryForest</code> function by using the domain credential and a <code>VMName</code> of <code>LABDC</code>. If you’re shown a few user accounts, congrats! You’re done! You’ve now successfully set up a domain controller and stored credentials for connecting to VMs in a workgroup (and any future domain-joined VMs).</p>&#13;
<h4 class="h4" id="ch17lev3sec5"><span epub:type="pagebreak" id="page_246"/>Populating the Domain</h4>&#13;
<p class="noindent">In the preceding section, you set up a domain controller in your PowerLab. Now let’s create some test objects. Since this is a test lab, you want to create various objects (OUs, users, groups, and so on) so that you cover all your bases. You could run the required command to create each individual object, but because you have so many objects to create, that wouldn’t be practical. It’ll be a much better use of your time to define everything in one file, read in each object, and create them all in one go.</p>&#13;
<h5 class="h5">Handling Your Object Spreadsheet</h5>&#13;
<p class="noindent">Here, you’ll use an Excel spreadsheet as your input file to define everything you need as input. This Excel spreadsheet is available via the chapter’s downloadable resources. When you open it, you’ll see it has two worksheets: Users (<a href="ch17.xhtml#ch17fig1">Figure 17-1</a>) and Groups (<a href="ch17.xhtml#ch17fig2">Figure 17-2</a>).</p>&#13;
<div class="image"><img src="../images/17fig01.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch17fig1"><em>Figure 17-1: The Users spreadsheet</em></p>&#13;
&#13;
<div class="image"><img src="../images/17fig02.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch17fig2"><em>Figure 17-2: The Groups spreadsheet</em></p>&#13;
<p class="indent">Each row of these worksheets corresponds to a user or group that needs to be created, containing information you’ll read into PowerShell. As you saw in <a href="ch10.xhtml#ch10">Chapter 10</a>, native PowerShell cannot handle Excel spreadsheets without significant work. With the help of a popular community module, however, you can make this much easier. Using the <code>ImportExcel</code> module, you can read Excel spreadsheets just as easily as you can natively read CSV files. To get <code>ImportExcel</code>, you can download it from the PowerShell Gallery by using <span class="codestrong">Install-Module -Name ImportExcel</span>. After a few security prompts, you should have the module downloaded and ready to use.</p>&#13;
<p class="indent">Now let’s use the <code>Import-Excel</code> command to parse in the rows from the worksheet:</p>&#13;
<pre>PS&gt; <span class="codestrong1">Import-Excel -Path 'C:\Program Files\WindowsPowerShell\Modules\PowerLab\&#13;
ActiveDirectoryObjects.xlsx' -WorksheetName Users | Format-Table -AutoSize</span>&#13;
&#13;
<span epub:type="pagebreak" id="page_247"/>OUName         UserName   FirstName LastName  MemberOf&#13;
------         --------   --------- --------  --------&#13;
PowerLab Users jjones     Joe       Jones     Accounting&#13;
PowerLab Users abertram   Adam      Bertram   Accounting&#13;
PowerLab Users jhicks     Jeff      Hicks     Accounting&#13;
PowerLab Users dtrump     Donald    Trump     Human Resources&#13;
PowerLab Users alincoln   Abraham   Lincoln   Human Resources&#13;
PowerLab Users bobama     Barack    Obama     Human Resources&#13;
PowerLab Users tjefferson Thomas    Jefferson IT&#13;
PowerLab Users bclinton   Bill      Clinton   IT&#13;
PowerLab Users gbush      George    Bush      IT&#13;
PowerLab Users rreagan    Ronald    Reagan    IT&#13;
&#13;
PS&gt; <span class="codestrong1">Import-Excel -Path 'C:\Program Files\WindowsPowerShell\Modules\PowerLab\&#13;
ActiveDirectoryObjects.xlsx' -WorksheetName Groups | Format-Table -AutoSize</span>&#13;
&#13;
OUName          GroupName       Type&#13;
------          ---------       ----&#13;
PowerLab Groups Accounting      DomainLocal&#13;
PowerLab Groups Human Resources DomainLocal&#13;
PowerLab Groups IT              DomainLocal</pre>&#13;
<p class="indent">Using the <code>Path</code> and <code>WorksheetName</code> parameters, you can easily pull out the data you need. Notice that here, you’re using the <code>Format-Table</code> command. This is a useful command that forces PowerShell to display the output in a table format. The <code>AutoSize</code> parameter tells PowerShell to try to squeeze each row into one line in the console.</p>&#13;
<h5 class="h5">Creating a Plan</h5>&#13;
<p class="noindent">You now have a way to read the data from the Excel spreadsheet. The next step is figuring out what to do with it. You’ll build a function in your PowerLab module that reads each row and performs the action it requires. All code covered here is available via the <code>New-PowerLabActiveDirectoryTestObject</code> function in the associated PowerLab module.</p>&#13;
<p class="indent">This function is a little more complicated than our previous scripts, so let’s break it down in an informal way—this way, you have something to refer back to. This step may not sound important, but as you make bigger functions, you’ll find that planning them out at the start will save you a lot of work in the long run. In this function, you need to do the following:</p>&#13;
<ol>&#13;
<li><p class="noindent">Read both worksheets in an Excel spreadsheet and retrieve all user and group rows.</p></li>&#13;
<li><p class="noindent">Read each row in both worksheets and first confirm whether the OU that the user or group is supposed to be a part of exists.</p></li>&#13;
<li><p class="noindent">If the OU does not exist, create the OU.</p></li>&#13;
<li><p class="noindent">If the user/group does not exist, create the user or group.</p></li>&#13;
<li><p class="noindent">For users only: add the user as a member of the specified group.</p></li>&#13;
</ol>&#13;
<p class="indent">Now that you have this informal outline, let’s get down to coding.</p>&#13;
<h5 class="h5"><span epub:type="pagebreak" id="page_248"/>Creating the AD Objects</h5>&#13;
<p class="noindent">For the first pass through, you want to keep it simple: let’s focus on handling a single object. No need to complicate things now by worrying about all of them. You installed the <code>AD-Domain-Services</code> Windows feature on LABDC earlier, so now you have the <code>ActiveDirectory</code> module installed. This module provides a large set of useful commands (as you saw in <a href="ch11.xhtml#ch11">Chapter 11</a>). Recall that many of the commands follow the same naming convention of <code>Get/Set/New-AD</code>.</p>&#13;
<p class="indent">Let’s open a blank <em>.ps1</em> script and get to work. Start by writing out all the commands you need (<a href="ch17.xhtml#ch17list2">Listing 17-2</a>) based on the previous outline:</p>&#13;
<pre>Get-ADOrganizationalUnit -Filter "Name -eq '<span class="codeitalic1">OUName</span>'" <span class="ent">❶</span>&#13;
New-ADOrganizationalUnit -Name <span class="codeitalic1">OUName</span> <span class="ent">❷</span>&#13;
&#13;
Get-ADGroup -Filter "Name -eq '<span class="codeitalic1">GroupName</span>'" <span class="ent">❸</span>&#13;
New-ADGroup -Name <span class="codeitalic1">$group.GroupName</span> -GroupScope <span class="codeitalic1">GroupScope</span> -Path "OU=<span class="codeitalic1">$group.OUName</span>,DC=powerlab,DC=local" <span class="ent">❹</span>&#13;
&#13;
Get-ADUser -Filter "Name -eq '<span class="codeitalic1">UserName</span>'" <span class="ent">❺</span>&#13;
New-ADUser -Name $user.UserName -Path "OU=$($user.OUName),DC=powerlab,DC=local" <span class="ent">❻</span>&#13;
&#13;
<span class="codeitalic1">UserName</span> -in (Get-ADGroupMember -Identity <span class="codeitalic1">GroupName</span>).Name <span class="ent">❼</span>&#13;
Add-ADGroupMember -Identity <span class="codeitalic1">GroupName</span> -Members <span class="codeitalic1">UserName</span> <span class="ent">❽</span></pre>&#13;
&#13;
<p class="caption" id="ch17list2"><em>Listing 17-2: Figuring out code to check for and create new users and groups</em></p>&#13;
<p class="indent">Recall from our plan that you first need to check whether an OU exists <span class="ent">❶</span>, and then create one if it doesn’t <span class="ent">❷</span>. You do the same thing with each group: check whether it exists <span class="ent">❸</span> and create one if it doesn’t <span class="ent">❹</span>. And do the same thing for each user: check <span class="ent">❺</span> and create <span class="ent">❻</span>. Lastly, for your users, check whether they are a member of the group specified in the spreadsheet <span class="ent">❼</span>, and add them to it if they are not <span class="ent">❽</span>.</p>&#13;
<p class="indent">All you’re missing here is the conditional structure, which you add in <a href="ch17.xhtml#ch17list3">Listing 17-3</a>.</p>&#13;
<pre>if (-not (Get-ADOrganizationalUnit -Filter "Name -eq '<span class="codeitalic1">OUName</span>'")) {&#13;
    New-ADOrganizationalUnit -Name <span class="codeitalic1">OUName</span>&#13;
}&#13;
&#13;
if (-not (Get-ADGroup -Filter "Name -eq '<span class="codeitalic1">GroupName</span>'")) {&#13;
    New-ADGroup -Name <span class="codeitalic1">GroupName</span> -GroupScope <span class="codeitalic1">GroupScope</span> -Path "OU<span class="codeitalic1">=OUName</span>,DC=powerlab,DC=local"&#13;
}&#13;
&#13;
if (-not (Get-ADUser -Filter "Name -eq '<span class="codeitalic1">UserName</span>'")) {&#13;
    New-ADUser -Name $user.UserName -Path "OU<span class="codeitalic1">=OUName</span>,DC=powerlab,DC=local"&#13;
}&#13;
&#13;
if (<span class="codeitalic1">UserName</span> -notin (Get-AdGroupMember -Identity <span class="codeitalic1">GroupName</span>).Name) {&#13;
    Add-ADGroupMember -Identity <span class="codeitalic1">GroupName</span> -Members <span class="codeitalic1">UserName</span>&#13;
}</pre>&#13;
<p class="caption" id="ch17list3"><em>Listing 17-3: Creating users and groups only if they don’t already exist</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_249"/>Now that you have the code to do what you want for an individual user or group, you need to figure out how to do it for all of them. First, though, you need to read in the worksheets. You’ve already seen which commands to use; now you need to store all those rows in variables. This isn’t technically required, but it keeps your code more explicit and self-documenting. You’ll use <code>foreach</code> loops to read all users and groups, as shown in <a href="ch17.xhtml#ch17list4">Listing 17-4</a>.</p>&#13;
<pre>$users = Import-Excel -Path 'C:\Program Files\WindowsPowerShell\Modules\&#13;
PowerLab\ActiveDirectoryObjects.xlsx' -WorksheetName Users&#13;
$groups = Import-Excel -Path 'C:\Program Files\WindowsPowerShell\Modules\&#13;
PowerLab\ActiveDirectoryObjects.xlsx' -WorksheetName Groups&#13;
&#13;
foreach ($group in $groups) {&#13;
&#13;
}&#13;
&#13;
foreach ($user in $users) {&#13;
&#13;
}</pre>&#13;
<p class="caption" id="ch17list4"><em>Listing 17-4: Building the code structure to iterate over each Excel worksheet row</em></p>&#13;
<p class="indent">Now that you have a structure to loop through every row, let’s use our individual code to handle the rows, as shown in <a href="ch17.xhtml#ch17list5">Listing 17-5</a>.</p>&#13;
<pre>$users = Import-Excel -Path 'C:\Program Files\WindowsPowerShell\Modules\PowerLab\&#13;
ActiveDirectoryObjects.xlsx' -WorksheetName Users&#13;
$groups = Import-Excel -Path 'C:\Program Files\WindowsPowerShell\Modules\PowerLab\&#13;
ActiveDirectoryObjects.xlsx' -WorksheetName Groups&#13;
&#13;
foreach ($group in $groups) {&#13;
    if (-not (Get-ADOrganizationalUnit -Filter "Name -eq '$($group.OUName)'")) {&#13;
        New-ADOrganizationalUnit -Name $group.OUName&#13;
    }&#13;
    if (-not (Get-ADGroup -Filter "Name -eq '$($group.GroupName)'")) {&#13;
        New-ADGroup -Name $group.GroupName -GroupScope $group.Type&#13;
        -Path "OU=$($group.OUName),DC=powerlab,DC=local"&#13;
    }&#13;
}&#13;
&#13;
foreach ($user in $users) {&#13;
    if (-not (Get-ADOrganizationalUnit -Filter "Name -eq '$($user.OUName)'")) {&#13;
        New-ADOrganizationalUnit -Name $user.OUName&#13;
    }&#13;
    if (-not (Get-ADUser -Filter "Name -eq '$($user.UserName)'")) {&#13;
        New-ADUser -Name $user.UserName -Path "OU=$($user.OUName),DC=powerlab,DC=local"&#13;
    }&#13;
    if ($user.UserName -notin (Get-ADGroupMember -Identity $user.MemberOf).Name) {&#13;
        Add-ADGroupMember -Identity $user.MemberOf -Members $user.UserName&#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch17list5"><em>Listing 17-5: Performing tasks on all users and groups</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_250"/>You’re almost done! The script is all ready to go, but now you need to run it on the LABDC server. Since you’re not running this code directly on the LABDC VM itself yet, you have to wrap all this up into a scriptblock and have <code>Invoke-Command</code> run it remotely on LABDC for you. Since you want to create and populate the forest in one go, you’ll take all your “scratch” code and move it into your <code>New-PowerLabActiveDirectoryTestObject</code> function. You can download a copy of this fully created function in the chapter’s resources.</p>&#13;
<h3 class="h3" id="ch17lev4">Building and Running Pester Tests</h3>&#13;
<p class="noindent">You have all the code you need to create a new AD forest and populate it. Now you’ll build some Pester tests to confirm that everything is working as planned. You have quite a bit to test, so the Pester tests are going to be more complicated than before. Just as you did before creating the <em>New-PowerLabActiveDirectoryTestObject.ps1</em> script, first create a Pester test script, and then start thinking of test cases. If you need a refresher about Pester, check out <a href="ch09.xhtml#ch9">Chapter 9</a>. I’ve also included all Pester tests for this chapter in the book’s resources.</p>&#13;
<p class="indent">What do you need to test? In this chapter, you did the following:</p>&#13;
<ul>&#13;
<li><p class="noindent">Created a new AD forest</p></li>&#13;
<li><p class="noindent">Created a new AD domain</p></li>&#13;
<li><p class="noindent">Created AD users</p></li>&#13;
<li><p class="noindent">Created AD groups</p></li>&#13;
<li><p class="noindent">Created AD organizational units</p></li>&#13;
</ul>&#13;
<p class="indent">After determining that they exist, you need to make sure that your objects have the correct attributes (the attributes you passed in as parameters to the commands that created them). These are the attributes you’re looking for:</p>&#13;
<p class="tabcap" id="ch17tab1"><strong>Table 17-1:</strong> AD Attributes</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Object</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Attributes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">AD forest</p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><code>DomainName</code>, <code>DomainMode</code>, <code>ForestMode</code>, safe mode administrator password</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">AD user</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">OU path, name, group member</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">AD group</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">OU path, name</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h1aa"><p class="taba">AD organizational unit</p></td>&#13;
<td style="vertical-align: top;" class="table-h1aa"><p class="taba">Name</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">With that, you have a good back-of-the-napkin plan for what you’re looking for with your Pester tests. If you take a look at the <em>Creating an Active Directory Forest.Tests.ps1</em> script, you’ll see that I’ve chosen to break down each of these entities into contexts and test all the associated attributes inside as individual tests.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_251"/>To give you an idea of how these tests are created, <a href="ch17.xhtml#ch17list6">Listing 17-6</a> has a snippet of the test code.</p>&#13;
<pre>context 'Domain' {&#13;
 <span class="ent">❶</span> $domain = Invoke-Command -Session $session -ScriptBlock { Get-AdDomain }&#13;
    $forest = Invoke-Command -Session $session -ScriptBlock { Get-AdForest }&#13;
&#13;
 <span class="ent">❷</span> it "the domain mode should be Windows2016Domain" {&#13;
        $domain.DomainMode | should be 'Windows2016Domain'&#13;
    }&#13;
&#13;
    it "the forest mode should be WinThreshold" {&#13;
        $forest.ForestMode | should be 'Windows2016Forest'&#13;
    }&#13;
&#13;
    it "the domain name should be powerlab.local" {&#13;
        $domain.Name | should be 'powerlab'&#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch17list6"><em>Listing 17-6: Some of the Pester test code</em></p>&#13;
<p class="indent">For this context, you want to make sure that the AD domain and forest are created properly. So you first create the domain and forest <span class="ent">❶</span>; then you verify that the domain and forest have the attributes you expect <span class="ent">❷</span>.</p>&#13;
<p class="indent">Running the whole test should give you something like this:</p>&#13;
<pre>Describing Active Directory Forest&#13;
   Context Domain&#13;
    [+] the domain mode should be Windows2016Domain 933ms&#13;
    [+] the forest mode should be WinThreshold 25ms&#13;
    [+] the domain name should be powerlab.local 41ms&#13;
   Context Organizational Units&#13;
    [+] the OU [PowerLab Users] should exist 85ms&#13;
    [+] the OU [PowerLab Groups] should exist 37ms&#13;
   Context Users&#13;
    [+] the user [jjones] should exist 74ms&#13;
    [+] the user [jjones] should be in the [PowerLab Users] OU 35ms&#13;
    [+] the user [jjones] should be in the [Accounting] group 121ms&#13;
    [+] the user [abertram] should exist 39ms&#13;
    [+] the user [abertram] should be in the [PowerLab Users] OU 30ms&#13;
    [+] the user [abertram] should be in the [Accounting] group 80ms&#13;
    [+] the user [jhicks] should exist 39ms&#13;
    [+] the user [jhicks] should be in the [PowerLab Users] OU 32ms&#13;
    [+] the user [jhicks] should be in the [Accounting] group 81ms&#13;
    [+] the user [dtrump] should exist 45ms&#13;
    [+] the user [dtrump] should be in the [PowerLab Users] OU 40ms&#13;
    [+] the user [dtrump] should be in the [Human Resources] group 84ms&#13;
    [+] the user [alincoln] should exist 41ms&#13;
    [+] the user [alincoln] should be in the [PowerLab Users] OU 40ms&#13;
    [+] the user [alincoln] should be in the [Human Resources] group 125ms&#13;
    [+] the user [bobama] should exist 44ms&#13;
    [+] the user [bobama] should be in the [PowerLab Users] OU 27ms&#13;
    [+] the user [bobama] should be in the [Human Resources] group 92ms&#13;
<span epub:type="pagebreak" id="page_252"/>    [+] the user [tjefferson] should exist 58ms&#13;
    [+] the user [tjefferson] should be in the [PowerLab Users] OU 33ms&#13;
    [+] the user [tjefferson] should be in the [IT] group 73ms&#13;
    [+] the user [bclinton] should exist 47ms&#13;
    [+] the user [bclinton] should be in the [PowerLab Users] OU 29ms&#13;
    [+] the user [bclinton] should be in the [IT] group 84ms&#13;
    [+] the user [gbush] should exist 50ms&#13;
    [+] the user [gbush] should be in the [PowerLab Users] OU 33ms&#13;
    [+] the user [gbush] should be in the [IT] group 78ms&#13;
    [+] the user [rreagan] should exist 56ms&#13;
    [+] the user [rreagan] should be in the [PowerLab Users] OU 30ms&#13;
    [+] the user [rreagan] should be in the [IT] group 78ms&#13;
   Context Groups&#13;
    [+] the group [Accounting] should exist 71ms&#13;
    [+] the group [Accounting] should be in the [PowerLab Groups] OU 42ms&#13;
    [+] the group [Human Resources] should exist 48ms&#13;
    [+] the group [Human Resources] should be in the [PowerLab Groups] OU 29ms&#13;
    [+] the group [IT] should exist 51ms&#13;
    [+] the group [IT] should be in the [PowerLab Groups] OU 31ms</pre>&#13;
<h3 class="h3" id="ch17lev5">Summary</h3>&#13;
<p class="noindent">In this chapter, you took the next step in the creation of your PowerLab and added an Active Directory forest before populating it with several objects. You did this both manually and automatically, and in the process, reviewed some of what you had learned about Active Directory in previous chapters. Lastly, you dived a little deeper into Pester testing, taking a closer look at how to build custom tests that suit your needs. In the next chapter, you’ll continue with the PowerLab project and learn how to automate installing and configuring a SQL server.</p>&#13;
</body></html>